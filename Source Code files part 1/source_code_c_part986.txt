on(new CodePropertyReferenceExpression(new CodeSnippetExpression(InternalName),
																			strPath),"ClassName"));
		coce1.Parameters.Add(new CodeTypeOfExpression("String"));
		cace.Initializers.Add(coce1);
		coce.Parameters.Add(cace);

		cis.TrueStatements.Add(new CodeAssignStatement(new CodeSnippetExpression(CreationBundleObject),
															coce));
		cmm.Statements.Add(cis);
		cmm.Statements.Add(new CodeMethodReturnStatement(new CodeSnippetExpression(CreationBundleObject)));
	
		CodeConvertorClass.Members.Add(cmm);

		//For GetProperties Function

		string MemberAttribiutesArrayClass = "MemberAttribute[]";
		string MemberAttributesObject = "attributes";
		string PropertyDescriptorCollectionClass = "PropertyDescriptorCollection";

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override;
		cmm.Name = "GetProperties";
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression("Object",ActualObject));
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(MemberAttribiutesArrayClass,MemberAttributesObject));
        cmm.ReturnType = new CodeTypeReference(PropertyDescriptorCollectionClass);

		cmie = new CodeMethodInvokeExpression(
					new CodeSnippetExpression("TypeDescriptor"),
					"GetProperties"
					);
		cmie.Parameters.Add(new CodeTypeOfExpression(PrivateNamesUsed["GeneratedClassName"].ToString()));
		cmie.Parameters.Add(new CodeSnippetExpression(MemberAttributesObject));
		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));

		CodeConvertorClass.Members.Add(cmm);

		//For GetPropertiesSupported Function
		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Override;
		cmm.Name = "GetPropertiesSupported";
		cmm.Parameters.Add(new CodeParameterDeclarationExpression(TypeDescriptorContextClass,contextObject));
        cmm.ReturnType = new CodeTypeReference("Boolean");

		cmm.Statements.Add(new CodeMethodReturnStatement(new CodePrimitiveExpression(true)));
		CodeConvertorClass.Members.Add(cmm);
		
		cn.Types.Add(CodeConvertorClass);
	}

	public void GenerateCollectionClass()
	{
		string strManagementObjectCollectionType = "ManagementObjectCollection";
		string strObjectCollection = "ObjectCollection";
		string strobjCollection = "objCollection";

		//public class ServiceCollection : ICollection, IEnumerable
		ccc = new CodeTypeDeclaration(PrivateNamesUsed["CollectionClass"].ToString());
		ccc.BaseTypes.Add("ICollection");
		ccc.BaseTypes.Add("IEnumerable");

		//private ManagementObjectCollection objCollection;
		cf = new CodeMemberField();
		cf.Name = strObjectCollection;
		cf.Attributes = MemberAttributes.Private | MemberAttributes.Final ;
		cf.Type = new CodeTypeReference(strManagementObjectCollectionType);
		ccc.Members.Add(cf);

		//internal ServiceCollection(ManagementObjectCollection obj)
		//{
		//	objCollection = obj;
		//}

		cctor = new CodeConstructor();
//		cctor.Attributes = MemberAttributes.Assembly;
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Name = strobjCollection;
		cpde.Type = new CodeTypeReference(strManagementObjectCollectionType);
		cctor.Parameters.Add(cpde);

		cctor.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(strObjectCollection),
													new CodeSnippetExpression(strobjCollection)));
		ccc.Members.Add(cctor);
		
		
		//public Int32 Count {
		//	get { 
		//			return objCollection.Count; 
		//		}
		//}

		cmp = new CodeMemberProperty();
		cmp.Type = new CodeTypeReference("Int32");
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Name = "Count";
		cmp.ImplementationTypes.Add("ICollection");
		//cmp.ImplementsType = "ICollection";
		cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodePropertyReferenceExpression(
															new CodeSnippetExpression(strObjectCollection),
															"Count")));
		ccc.Members.Add(cmp);
		

 		//public bool IsSynchronized {
		//	get {
		//		return objCollection.IsSynchronized;
		//	}
		//}

		cmp = new CodeMemberProperty();
		cmp.Type = new CodeTypeReference("Boolean");
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Name = "IsSynchronized";
		cmp.ImplementationTypes.Add("ICollection");
		//cmp.ImplementsType = "ICollection";
		cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodePropertyReferenceExpression(
															new CodeSnippetExpression(strObjectCollection),
															"IsSynchronized")));
		ccc.Members.Add(cmp);

		//public Object SyncRoot { 
		//	get { 
		//		return this; 
		//	} 
		//}

		cmp = new CodeMemberProperty();
		cmp.Type = new CodeTypeReference("Object");
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Name = "SyncRoot";
		cmp.ImplementationTypes.Add("ICollection");
		//cmp.ImplementsType = "ICollection";
		cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodeThisReferenceExpression()));
		ccc.Members.Add(cmp);

		//public void CopyTo (Array array, Int32 index) 
		//{
		//	objCollection.CopyTo(array,index);
		//	for(int iCtr=0;iCtr < array.Length ;iCtr++)
		//	{
		//		array.SetValue(new Service((ManagementObject)array.GetValue(iCtr)),iCtr);
		//	}
		//}

		string strArray = "array";
		string strIndex = "index";
		string strnCtr = "nCtr";

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmm.Name = "CopyTo";
		cmm.ImplementationTypes.Add("ICollection");
		//cmm.ImplementsType = "ICollection";

		cpde = new CodeParameterDeclarationExpression();
		cpde.Name = strArray;
		cpde.Type = new CodeTypeReference("Array");
		cmm.Parameters.Add(cpde);

		cpde = new CodeParameterDeclarationExpression();
		cpde.Name = strIndex;
		cpde.Type = new CodeTypeReference("Int32");
		cmm.Parameters.Add(cpde);

		cmie = new CodeMethodInvokeExpression(
			new CodeSnippetExpression(strObjectCollection),
			"CopyTo"
			);

		cmie.Parameters.Add(new CodeSnippetExpression(strArray));
		cmie.Parameters.Add(new CodeSnippetExpression(strIndex));
		cmm.Statements.Add(new CodeExpressionStatement(cmie));

		cfls = new CodeIterationStatement();
		cfls.InitStatement = new CodeVariableDeclarationStatement("Int32",strnCtr,new CodePrimitiveExpression(0));
		cboe = new CodeBinaryOperatorExpression();
		cboe.Left = new CodeSnippetExpression(strnCtr);
		cboe.Operator = CodeBinaryOperatorType.LessThan;
		cboe.Right = new CodePropertyReferenceExpression(new CodeSnippetExpression(strArray),"Length");
		cfls.TestExpression = cboe;
		cfls.IncrementStatement = new CodeAssignStatement(new CodeSnippetExpression(strnCtr),
														  new CodeBinaryOperatorExpression(
																new CodeSnippetExpression(strnCtr),
																CodeBinaryOperatorType.Add,
																new CodePrimitiveExpression(1)));

		cmie = new CodeMethodInvokeExpression(
									new CodeSnippetExpression(strArray),
									"SetValue");
		
		CodeMethodInvokeExpression cmie1 = new CodeMethodInvokeExpression(
									new CodeSnippetExpression(strArray),
									"GetValue",
									new CodeSnippetExpression(strnCtr));
		//cmie1.MethodName = "GetValue";
		//cmie1.TargetObject = new CodeSnippetExpression(strArray);
		//cmie1.Parameters.Add(new CodeSnippetExpression(strnCtr));

		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PrivateNamesUsed["GeneratedClassName"].ToString());
		coce.Parameters.Add(new CodeCastExpression(PublicNamesUsed["LateBoundClass"].ToString(),cmie1));

		cmie.Parameters.Add(coce);
		cmie.Parameters.Add(new CodeSnippetExpression(strnCtr));
		cfls.Statements.Add(new CodeExpressionStatement(cmie));

		cmm.Statements.Add(cfls);
		ccc.Members.Add(cmm);

		//ServiceEnumerator GetEnumerator()
		//{
		//	return new ServiceEnumerator (objCollection.GetEnumerator());
		//}

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmm.Name = "GetEnumerator";
//		cmm.ReturnType = PrivateNamesUsed["EnumeratorClass"].ToString();
		cmm.ReturnType = new CodeTypeReference("IEnumerator");
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PrivateNamesUsed["EnumeratorClass"].ToString());
		coce.Parameters.Add(new CodeMethodInvokeExpression(new CodeSnippetExpression(strObjectCollection),"GetEnumerator"));
		cmm.Statements.Add(new CodeMethodReturnStatement(coce));
		ccc.Members.Add(cmm);

		/*
		//ZINA: commenting this out for now, since 
		//"cmm.ImplementationTypes.Add("IEnumerable");"
		//does not work, and therefore the function is ambiguous and
		//does not compile.
		
		//IEnumerator IEnumerable.GetEnumerator()
		//{
		//	return GetEnumerator ();
		//}

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.VTableMask;
		cmm.Name = "GetEnumerator";
		cmm.ReturnType = new CodeTypeReference("IEnumerator");
		cmm.ImplementationTypes.Add("IEnumerable");
		//cmm.ImplementsType = "IEnumerable";
		cmie = new CodeMethodInvokeExpression(
					null,	//no TargetObject?
					"GetEnumerator"
					);

		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
		ccc.Members.Add(cmm);
		*/
		
		//Now generate the Enumerator Class
		GenerateEnumeratorClass();
		
		cc.Members.Add(ccc);
	}

	public void GenerateEnumeratorClass()
	{
		string strObjectEnumerator = "ObjectEnumerator";
		string strManagementObjectEnumeratorType = "ManagementObjectEnumerator";
		string strManagementObjectCollectionType = "ManagementObjectCollection";
		string strobjEnum = "objEnum";

		//public class ServiceEnumerator : IEnumerator
		ecc = new CodeTypeDeclaration(PrivateNamesUsed["EnumeratorClass"].ToString());
		ecc.BaseTypes.Add("IEnumerator");

		//private ManagementObjectCollection.ManagementObjectEnumerator ObjectEnumerator;
		cf = new CodeMemberField();
		cf.Name = strObjectEnumerator;
		cf.Attributes = MemberAttributes.Private | MemberAttributes.Final ;
		cf.Type = new CodeTypeReference(strManagementObjectCollectionType+"."+strManagementObjectEnumeratorType);
		ecc.Members.Add(cf);

		//constructor
		//internal ServiceEnumerator(ManagementObjectCollection.ManagementObjectEnumerator objEnum)
		//{
		//	ObjectEnumerator = objEnum;
		//}
		cctor = new CodeConstructor();
//		cctor.Attributes = MemberAttributes.Assembly;
		cctor.Attributes = MemberAttributes.Public;
		cpde = new CodeParameterDeclarationExpression();
		cpde.Name = strobjEnum;
		cpde.Type = new CodeTypeReference(strManagementObjectCollectionType+"."+strManagementObjectEnumeratorType);
		cctor.Parameters.Add(cpde);

		cctor.Statements.Add(new CodeAssignStatement(new CodeSnippetExpression(strObjectEnumerator),
													new CodeSnippetExpression(strobjEnum)));
		ecc.Members.Add(cctor);

		//public Service Current {
		//get {
		//		return new Service((ManagementObject)ObjectEnumerator.Current);
		//	}
		//}

		cmp = new CodeMemberProperty();
//		cmp.Type = PrivateNamesUsed["GeneratedClassName"].ToString();
		cmp.Type = new CodeTypeReference("Object");
		cmp.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmp.Name = "Current";
		cmp.ImplementationTypes.Add("IEnumerator");
		//cmp.ImplementsType = "IEnumerator";
		coce = new CodeObjectCreateExpression();
		coce.CreateType = new CodeTypeReference(PrivateNamesUsed["GeneratedClassName"].ToString());
		coce.Parameters.Add(new CodeCastExpression(PublicNamesUsed["LateBoundClass"].ToString(),
													new CodePropertyReferenceExpression(
														new CodeSnippetExpression(strObjectEnumerator),
														"Current")));
		cmp.GetStatements.Add(new CodeMethodReturnStatement(coce));
		ecc.Members.Add(cmp);

/*		//object IEnumerator.Current {
		//get {
		//		return Current;
		//	}
		//}

		cmp = new CodeMemberProperty();
		cmp.Attributes = MemberAttributes.VTableMask;
		cmp.Type = "object";
		cmp.Name = "IEnumerator.Current";
		cmp.GetStatements.Add(new CodeMethodReturnStatement(new CodeSnippetExpression("Current")));
		ecc.Members.Add(cmp);
*/
		//public bool MoveNext ()
		//{
		//	return ObjectEnumerator.MoveNext();
		//}

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmm.Name = "MoveNext";
		cmm.ImplementationTypes.Add("IEnumerator");
		//cmm.ImplementsType = "IEnumerator";
		cmm.ReturnType = new CodeTypeReference("Boolean");
		cmie = new CodeMethodInvokeExpression(
					new CodeSnippetExpression(strObjectEnumerator),
					"MoveNext"
					);

		cmm.Statements.Add(new CodeMethodReturnStatement(cmie));
		ecc.Members.Add(cmm);

		//public void Reset ()
		//{
		//	ObjectEnumerator.Reset();
		//}

		cmm = new CodeMemberMethod();
		cmm.Attributes = MemberAttributes.Public | MemberAttributes.Final;
		cmm.Name = "Reset";
		cmm.ImplementationTypes.Add("IEnumerator");
		//cmm.ImplementsType = "IEnumerator";
		cmie = new CodeMethodInvokeExpression(
			new CodeSnippetExpression(strObjectEnumerator),
			"Reset"
			);
		cmm.Statements.Add(new CodeExpressionStatement (cmie));
		ecc.Members.Add(cmm);

		ccc.Members.Add(ecc);
	}

/// <summary>
/// This function will find a given string in the passed 
/// in a case insensitive manner and will return true if the string is found.
/// </summary>
	int IsContainedIn(String strToFind, ref SortedList sortedList)
	{
		int nIndex = -1;
		for (int i=0; i < sortedList.Count; i++)
		{
			if(String.Compare(sortedList.GetByIndex(i).ToString(),strToFind,true) == 0)
			{
				//The string is found. This is the index
				nIndex = i;
				break;
			}
		}
		return nIndex;
	}
/// <summary>
/// This function will convert the given CIMTYPE to an acceptable .NET type.
/// Since CLS doen't support lotz of the basic types, we are using .NET helper 
/// classes here. We safely assume that there won't be any problem using them
/// since .NET has to be there for the System.Management.Dll to work.
/// </summary>
/// <param name="cType"> </param>
/// <param name="Name"> </param>
	public static string ConvertCIMType(CimType cType,bool isArray,Languages Language)
	{
		string retVal;
		switch(cType)
		{
			case CimType.SInt8:
			{
				retVal = "SByte";
				break;
			}
			case CimType.UInt8: //TODO : is this fine???
			{
				retVal = "Byte";
				break;
			}
			case CimType.SInt16:
			{
				retVal = "Int16";
				break;
			}
			case CimType.UInt16:
			{
				if(ManagementClassGenerator.UnsignedNotSupported(Language) == true)
				{
					retVal = "Int16";
				}
				else
				{
					retVal = "UInt16";
				}
				break;
			}
			case CimType.SInt32:
			{
				retVal = "Int32";
				break;
			}
			case CimType.UInt32:
			{
				if(ManagementClassGenerator.UnsignedNotSupported(Language) == true)
				{
					retVal = "Int32";
				}
				else
				{
					retVal = "UInt32";
				}
				break;
			}
			case CimType.SInt64:
			{
				retVal = "Int64";
				break;
			}
			case CimType.UInt64:
			{
				if(ManagementClassGenerator.UnsignedNotSupported(Language) == true)
				{
					retVal = "Int64";
				}
				else
				{
					retVal = "UInt64";
				}
				break;
			}
			case CimType.Real32:
			{
				retVal = "Single";
				break;
			}
			case CimType.Real64:
			{
				retVal = "Double";
				break;
			}
			case CimType.Boolean:
			{
				retVal = "Boolean";
				break;
			}
			case CimType.String:
			{
				retVal = "String";
				break;
			}
			case CimType.DateTime:
			{
				retVal = "DateTime";
				break;
			}
			case CimType.Reference:
			{
				retVal = "";		//????
				break;
			}
			case CimType.Char16:
			{
				retVal = "Char";
				break;
			}
			case CimType.Object:
			default:
				retVal = "ManagementObject";
				break;
		}

		if(isArray == true)
		{
			retVal += " []";
		}
		return retVal;
	}
/// <summary>
/// This function is used to determine whether the given CIMTYPE can be represented as an integer.
/// This helper function is mainly used to determine whether this type will be support by enums.
/// </summary>
/// <param name="cType"> </param>
	public bool isTypeInt(CimType cType)
	{
		bool retVal;
		switch(cType)
		{
			case CimType.UInt8: //TODO : is this fine???
			case CimType.UInt16:
			case CimType.UInt32:
			case CimType.SInt8:
			case CimType.SInt16:
			case CimType.SInt32:
			{
				retVal = true;
				break;
			}
			case CimType.SInt64:
			case CimType.UInt64:
			case CimType.Real32:
			case CimType.Real64:
			case CimType.Boolean:
			case CimType.String:
			case CimType.DateTime:
			case CimType.Reference:
			case CimType.Char16:
			case CimType.Object:
			default:
				retVal = false;
				break;
		}

		return retVal;

	}

	public static bool UnsignedNotSupported(Languages Language)
	{
		bool isNotSupported = true;
		switch(Language)
		{
			case Languages.CSharp:
				isNotSupported = false;
				break;
			default:
				break;
		}	
		return isNotSupported;
	}

	public string GeneratedFileName
	{
		get
		{
			return genFileName;
		}
	}

	public string GeneratedTypeName
	{
		get
		{
			return PrivateNamesUsed["GeneratedNamespace"].ToString() + "." +
					PrivateNamesUsed["GeneratedClassName"].ToString();
		}
	}
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\upgrade.cpp ===
// Copyright (c) 2000 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include <stdio.h>
#include <string.h>
#include <time.h>
#include "upgrade.h"
#include "wbemutil.h"
#include "reg.h"
#include "export.h"
#include "import.h"
#include <WDMSHELL.h>
#include <wmimof.h>	
#include <wmicom.h>
#include <setupapi.h>
#include <persistcfg.h>

//Handy pointer to the MMF arena which almost every file
//to do with the on-disk representation management uses.
CMMFArena2* g_pDbArena = 0;

bool DoCoreUpgrade(int nInstallType )
{
	LogMessage(MSG_INFO, "Beginning Core Upgrade");

	bool bRet = true;
	bool bCoreFailure = false;
	bool bExternalFailure = false;
	bool bOrgRepositoryPreserved = false;
	CMultiString mszSystemMofs;
	CMultiString mszExternalMofList;
	CString szFailedSystemMofs;
	CString szFailedExternalMofs;
	CString szMissingMofs;

	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_ERROR, "Unable to access registry for DoCoreUpgrade.");
		return false;
	}

	IMofCompiler* pCompiler = NULL;

    SCODE sc = CoCreateInstance(CLSID_MofCompiler, 0, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (LPVOID *) &pCompiler);
    
    if(SUCCEEDED(sc))
	{
		GetStandardMofs(mszSystemMofs, nInstallType);
		UpgradeAutoRecoveryRegistry(mszSystemMofs, mszExternalMofList, szMissingMofs);
		WipeOutAutoRecoveryRegistryEntries();

		if (DoesFSRepositoryExist())
		{
			// check whether repository needs upgrading, and perform upgrade if necessary
			bOrgRepositoryPreserved = UpgradeRepository();
		}

		// if we find an MMF, convert it, regardless of whether another repository already exists
		if (DoesMMFRepositoryExist())
		{
			bOrgRepositoryPreserved = DoConvertRepository();
		}

		bRet = LoadMofList(pCompiler, mszSystemMofs, szFailedSystemMofs);
		if (bRet == false)
			bCoreFailure = true;

		// if the repository did not exist when we began, 
		// or we had to create a new one due to an upgrade failure,
		// we need to reload external mofs
		if (!bOrgRepositoryPreserved)
		{
			bRet = LoadMofList(pCompiler, mszExternalMofList, szFailedExternalMofs);
			if (bRet == false)
				bExternalFailure = true;
		}
		pCompiler->Release();

		//Part of the tidy-up code is to write back the registry entries, so here we go...
		WriteBackAutoRecoveryMofs(mszSystemMofs, mszExternalMofList);

		FILETIME ftCurTime;
		LARGE_INTEGER liCurTime;
		char szBuff[50];
		GetSystemTimeAsFileTime(&ftCurTime);
		liCurTime.LowPart = ftCurTime.dwLowDateTime;
		liCurTime.HighPart = ftCurTime.dwHighDateTime;
		_ui64toa(liCurTime.QuadPart, szBuff, 10);
		r.SetStr("Autorecover MOFs timestamp", szBuff);
	}
	else
	{
		bRet = false;
	}

	if (szFailedSystemMofs.Length())
	{
		LogMessage(MSG_ERROR, "The following WMI CORE MOF file(s) failed to load:");
		LogMessage(MSG_ERROR, szFailedSystemMofs);
	}
	else if (bCoreFailure)
	{
		LogMessage(MSG_NTSETUPERROR, "None of the WMI CORE MOFs could be loaded.");
	}
	else if (szFailedExternalMofs.Length())
	{
		LogMessage(MSG_ERROR, "The following External MOF file(s) failed to load:");
		LogMessage(MSG_ERROR, szFailedExternalMofs);
	}
	else if (bExternalFailure)
	{
		LogMessage(MSG_NTSETUPERROR, "None of the External MOFs could be loaded.");
	}
	else if (bRet == false)
	{
		LogMessage(MSG_NTSETUPERROR, "No MOFs could be loaded because the MOF Compiler failed to intialize.");
	}
	if (szMissingMofs.Length())
	{
		LogMessage(MSG_WARNING, "The following MOFs could not be found and were removed from the auto-recovery registry setting:");
		LogMessage(MSG_WARNING, szMissingMofs);
	}

	LogMessage(MSG_INFO, "Core Upgrade completed.");
	return bRet;
}

bool UpgradeAutoRecoveryRegistry(CMultiString &mszSystemMofs, CMultiString &mszExternalMofList, CString &szMissingMofs)
{
	char* pszNewList = NULL;
	char* pszEmptyList = NULL;
	char* pszRecoveredList = NULL;
		
	try
	{
		//First we need to recover the existing entries...

		Registry r(WBEM_REG_WINMGMT);
		if (r.GetStatus() != no_error)
		{
			LogMessage(MSG_ERROR, "Unable to access registry for UpgradeAutoRecoveryRegistry.");
			return false;
		}

		DWORD dwSize = 0;
		pszNewList = r.GetMultiStr(WBEM_REG_AUTORECOVER, dwSize);
		pszEmptyList = r.GetMultiStr(WBEM_REG_AUTORECOVER_EMPTY, dwSize);
		pszRecoveredList = r.GetMultiStr(WBEM_REG_AUTORECOVER_RECOVERED, dwSize);
		CMultiString mszOtherMofs;

		//Lets work through the list in the new mof list if it exists...
		GetNewMofLists(pszNewList, mszSystemMofs, mszOtherMofs, szMissingMofs);

		//Lets work through the empty list first...
		GetNewMofLists(pszEmptyList, mszSystemMofs, mszOtherMofs, szMissingMofs);

		//Lets work through the recovered list next...
		GetNewMofLists(pszRecoveredList, mszSystemMofs, mszOtherMofs, szMissingMofs);

		//Now we copy across the other MOFs to the external list...
		CopyMultiString(mszOtherMofs, mszExternalMofList);
	}
	catch (...)
	{
		// assume something has corrupted the registry key, so toss out the work we've done so far (empty the lists)
		mszExternalMofList.Empty();
		szMissingMofs = "";
	}

	//Tidy up the memory...
	delete [] pszNewList;
	delete [] pszEmptyList;
	delete [] pszRecoveredList;

	//Now we are done with the registry.
	return true;
}

bool GetNewMofLists(const char *pszMofList, CMultiString &mszSystemMofs, CMultiString &mszOtherMofs, CString &szMissingMofs)
{
	// produce a standard mof list with only filenames and no paths to be used as our search list
	CMultiString mszStandardMofList;
	const char* pszFrom = mszSystemMofs;
	CString path;
	CString filename;
	while (pszFrom && *pszFrom)
	{
		ExtractPathAndFilename(pszFrom, path, filename);
		mszStandardMofList.AddUnique(filename);
		pszFrom += strlen(pszFrom) + 1;
	}

	// check each file to see if it is a standard mof
	const char *psz = pszMofList;
	while (psz && *psz)
	{
		if (FileExists(psz))
		{
			if (IsStandardMof(mszStandardMofList, psz))
			{
				// This means we will be loading it with this install,
				// so we don't need to do anything here...
			}
			else
			{
				mszOtherMofs.AddUnique(psz);
			}
		}
		else
		{
			if (szMissingMofs.Length())
			{
				szMissingMofs += "\n";
			}
			szMissingMofs += psz;
		}

		//Move on to the next string...
		psz += strlen(psz) + 1;
	}

	return true;
}

bool GetMofList(const char* rgpszMofFilename[], CMultiString &mszMofs)
{
	char* pszFullName = NULL;

	for (int i = 0; rgpszMofFilename[i] != NULL; i++)
	{
		pszFullName = GetFullFilename(rgpszMofFilename[i]);
		if (pszFullName)
		{
			if (FileExists(pszFullName))
				mszMofs.AddUnique(pszFullName);
			delete [] pszFullName;
			pszFullName = NULL;
		}
		else
		{
			char szTemp[MAX_MSG_TEXT_LENGTH];
			sprintf(szTemp, "Failed GetFullFilename for %s in GetMofList.", rgpszMofFilename[i]);
			LogMessage(MSG_ERROR, szTemp);
			
			// do not return false here, keep processing other mofs
		}
	}

	return true;
}

bool FileExists(const char *pszFilename)
{
	char *szExpandedFilename = NULL;
	DWORD nRes = ExpandEnvironmentStrings(pszFilename,NULL,0); 
	if (nRes == 0)
	{
		szExpandedFilename = new char[strlen(pszFilename) + 1];
		if (szExpandedFilename == NULL)
		{
			return false;
		}
		strcpy(szExpandedFilename, pszFilename);
	}
	else
	{
		szExpandedFilename = new char[nRes];
		if (szExpandedFilename == NULL)
		{
			return false;
		}
		nRes = ExpandEnvironmentStrings(pszFilename,szExpandedFilename,nRes); 
		if (nRes == 0)
		{
			delete [] szExpandedFilename;
			return false;
		}
	}
	
	bool bExists = false;
	DWORD dwAttribs = GetFileAttributes(szExpandedFilename);
	if (dwAttribs != 0xFFFFFFFF)
	{
		bExists = true;
	}

	delete [] szExpandedFilename;
	return bExists;
}

bool IsStandardMof(CMultiString &mszStandardMofList, const char* pszMofFile)
{
	//For this one we need to loop though our standard MOF list to see if it appears
	//in the list.	Ignore the path if present and compare only the filename.
	CString path;
	CString filename;
	ExtractPathAndFilename(pszMofFile, path, filename);

	bool bFound = false;
	const char* pszCompare = mszStandardMofList;
	while (pszCompare && *pszCompare)
	{
		if (_stricmp(pszCompare, filename) == 0)
		{
			bFound = true;
			break;
		}
		pszCompare += strlen(pszCompare) + 1;
	}

	return bFound;
}

bool ExtractPathAndFilename(const char *pszFullPath, CString &path, CString &filename)
{
	char *pszTmpName = new char[strlen(pszFullPath) + 1];
	if (pszTmpName == NULL)
		return false;

	strcpy(pszTmpName, pszFullPath);

	char *pszFilename = pszTmpName;
	char *psz = strtok(pszTmpName, "\\");
	while (psz != NULL)
	{
		pszFilename = psz;
		psz = strtok(NULL, "\\");

		if (psz != NULL)
		{
			path += pszFilename;
			path += "\\";
		}
	}

	filename = pszFilename;

	delete [] pszTmpName;
	
	return true;
}

bool CopyMultiString(CMultiString &mszFrom, CMultiString &mszTo)
{
	const char *pszFrom = mszFrom;
	while (pszFrom && *pszFrom)
	{
		//Due to the fact that we should not have duplicates in the list, we will now do
		//a check to inforce this...
		mszTo.AddUnique(pszFrom);

		pszFrom += strlen(pszFrom) + 1;
	}

	return true;
}

bool GetStandardMofs(CMultiString &mszSystemMofs, int nCurInstallType)
{
	// find the location of the inf
	char* pszWinDir = new char[_MAX_PATH+1];
	if (!pszWinDir)
	{
		LogMessage(MSG_ERROR, "Failed to allocate memory for pszWinDir for GetStandardMofs.");
		return FALSE;
	}
	if (!GetWindowsDirectory(pszWinDir, _MAX_PATH+1))
	{
		LogMessage(MSG_ERROR, "Failed to retrieve Windows directory for GetStandardMofs.");
		delete [] pszWinDir;
		return FALSE;
	}
	char* pszFileName = new char[strlen(pszWinDir)+strlen("\\inf\\wbemoc.inf")+1];
	if (!pszFileName)
	{
		LogMessage(MSG_ERROR, "Failed to allocate memory for pszFileName for GetStandardMofs.");
		delete [] pszWinDir;
		return FALSE;
	}
	strcpy(pszFileName, pszWinDir);
	strcat(pszFileName, "\\inf\\wbemoc.inf");
	delete [] pszWinDir;

	// verify that inf exists
	if (!FileExists(pszFileName))
	{
		char szTemp[MAX_MSG_TEXT_LENGTH+1];
		sprintf(szTemp, "Failed to locate inf file %s in GetStandardMofs.", pszFileName);
		LogMessage(MSG_ERROR, szTemp);
		delete [] pszFileName;
		return FALSE;
	}

	// GetPrivateProfileSection doesn't tell how large of a buffer is needed,
	// only how many chars it succeeded in copying, so I have to test to see
	// if I need to enlarge the buffer and try again
	const DWORD INITIAL_BUFFER_SIZE = 700;
	const DWORD BUFFER_SIZE_INCREMENT = 100;

	DWORD dwSize = INITIAL_BUFFER_SIZE;
	char* pszBuffer = new char[dwSize];
	if (!pszBuffer)
	{
		LogMessage(MSG_ERROR, "Failed to allocate memory for pszBuffer for GetStandardMofs.");
		delete [] pszFileName;
		return FALSE;
	}

	char* pszAppName = "WBEM.SYSTEMMOFS";
	DWORD dwCopied = GetPrivateProfileSection(pszAppName, pszBuffer, dwSize, pszFileName);
	 // if buffer isn't large enough, it copies dwSize - 2, so test for this
	while (dwCopied == (dwSize - 2))
	{
		delete [] pszBuffer;
		dwSize += BUFFER_SIZE_INCREMENT;
		pszBuffer = new char[dwSize];
		if (!pszBuffer)
		{
			LogMessage(MSG_ERROR, "Failed to allocate memory for pszBuffer for GetStandardMofs.");
			delete [] pszFileName;
			return FALSE;
		}
		dwCopied = GetPrivateProfileSection(pszAppName, pszBuffer, dwSize, pszFileName);
	}
	delete [] pszFileName;

	// now extract all the mofs from the buffer, get the full path, and store in the mof list
	char* pszFullName = NULL;
	char* psz = pszBuffer;
	char* pComment = NULL;
	while (psz[0] != '\0')
	{
		// if a comment is present after the filename, this will cut it off
		if (pComment = strchr(psz, ';'))
		{
			psz = strtok(psz, " \t;"); // there may be leading space or tabs as well as the semicolon
		}

		pszFullName = GetFullFilename(psz, (InstallType)nCurInstallType);
		if (pszFullName)
		{
			if (nCurInstallType != MUI || strstr(_strupr(pszFullName), ".MFL") != NULL)
			{
				if (FileExists(pszFullName))
					mszSystemMofs.AddUnique(pszFullName);
				else
				{
					char szTemp[MAX_MSG_TEXT_LENGTH+1];
					sprintf(szTemp, "GetStandardMofs failed to locate file %s.", pszFullName);
					LogMessage(MSG_ERROR, szTemp);
				}
			}
			delete [] pszFullName;
			pszFullName = NULL;
		}
		else
		{
			char szTemp[MAX_MSG_TEXT_LENGTH+1];
			sprintf(szTemp, "Failed GetFullFilename for %s with install type = %i in GetStandardMofs.", psz, nCurInstallType);
			LogMessage(MSG_ERROR, szTemp);
			// do not return false here, keep processing other mofs
		}
		psz += (strlen(psz) + 1);

		if (pComment)
		{
			// skip over the comment at the end of the line
			psz += (strlen(psz) + 1);
			pComment = NULL;
		}
	}

	delete [] pszBuffer;

	return true;
}

char* GetFullFilename(const char *pszFilename, InstallType eInstallType)
{
	char *pszDirectory = NULL;
	Registry r(WBEM_REG_WBEM);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_ERROR, "Unable to access registry for GetFullFilename.");
		return NULL;
	}

	if (r.GetStr("Installation Directory", &pszDirectory))
	{
		LogMessage(MSG_ERROR, "Unable to retrieve Installation Directory from registry for GetFullFilename.");
		return NULL;
	}
	CString pszPathFilename(pszDirectory);
	if (eInstallType == MUI)
	{
		if (pszPathFilename.Length() && (pszPathFilename[pszPathFilename.Length()-1] != '\\'))
		{
			pszPathFilename += "\\MUI\\";
			pszPathFilename += g_szLangId;
		}
	}

	if (pszPathFilename.Length() && (pszPathFilename[pszPathFilename.Length()-1] != '\\'))
	{
		pszPathFilename += "\\";
	}
	pszPathFilename += pszFilename;

	delete [] pszDirectory;

	return pszPathFilename.Unbind();
}

bool WipeOutAutoRecoveryRegistryEntries()
{
	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_ERROR, "Unable to access registry for WipeOutAutoRecoveryRegistryEntries.");
		return false;
	}
	else
	{
		r.SetMultiStr(WBEM_REG_AUTORECOVER, "\0", 2);
		r.DeleteEntry(WBEM_REG_AUTORECOVER_EMPTY);
		r.DeleteEntry(WBEM_REG_AUTORECOVER_RECOVERED);
		return true;
	}
}

bool DoesMMFRepositoryExist()
{
	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_ERROR, "Unable to access registry for DoesMMFRepositoryExist.");
		return false;
	}

	char *pszDbDir = NULL;
	if (r.GetStr("Repository Directory", &pszDbDir))
	{
		LogMessage(MSG_ERROR, "Unable to retrieve Repository Directory from registry for DoesMMFRepositoryExist.");
		return false;
	}

	if (!pszDbDir)
	{
		LogMessage(MSG_ERROR, "Unable to retrieve Repository Directory from registry for DoesMMFRepositoryExist.");
		return false;
	}

	CString szDbFilename(pszDbDir);
	if (szDbFilename.Length() != 0)
		szDbFilename += "\\";
	szDbFilename += "cim.rep";

	delete [] pszDbDir;
	
	return FileExists(szDbFilename);
}

bool DoesFSRepositoryExist()
{
	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_ERROR, "Unable to access registry for DoesMMFRepositoryExist.");
		return false;
	}

	char *pszDbDir = NULL;
	if (r.GetStr("Repository Directory", &pszDbDir))
	{
		LogMessage(MSG_ERROR, "Unable to retrieve Repository Directory from registry for DoesMMFRepositoryExist.");
		return false;
	}

	if (!pszDbDir || (strlen(pszDbDir) == 0))
	{
		LogMessage(MSG_ERROR, "Unable to retrieve Repository Directory from registry for DoesMMFRepositoryExist.");
		return false;
	}

	CString szDbFilename1(pszDbDir);
	szDbFilename1 += "\\FS\\MainStage.dat";
	CString szDbFilename2(pszDbDir);
	szDbFilename2 += "\\FS\\LowStage.dat";

	delete [] pszDbDir;
	
	return FileExists(szDbFilename1)||FileExists(szDbFilename2);
}


// This function is used to detect an earlier post-MMF repository version and upgrade it
// Returns TRUE if repository upgrade succeeded; FALSE in all other cases
bool UpgradeRepository()
{
	LogMessage(MSG_INFO, "Beginning repository upgrade");

	bool bRet = false;
	IWbemLocator *pLocator = NULL;
	HRESULT hr = CoCreateInstance(CLSID_WbemLocator,NULL, CLSCTX_ALL, IID_IWbemLocator,(void**)&pLocator);
	if(FAILED(hr))
	{
		LogMessage(MSG_ERROR, "WMI Repository upgrade failed CoCreateInstance.");
		return bRet;
	}
	
	IWbemServices *pNamespace = NULL;
	BSTR tmpStr = SysAllocString(L"root");

	hr = pLocator->ConnectServer(tmpStr, NULL, NULL, NULL, NULL, NULL, NULL, &pNamespace);
	if (SUCCEEDED(hr))
	{
		pNamespace->Release();
		LogMessage(MSG_INFO, "WMI Repository upgrade succeeded.");
		bRet = true;
	}
	else
	{
		if (hr == WBEM_E_DATABASE_VER_MISMATCH)
		{
			LogMessage(MSG_ERROR, "WMI Repository upgrade failed with WBEM_E_DATABASE_VER_MISMATCH.");

			// shut down so we can delete the repository
			ShutdownWinMgmt();

			// delete the repository so it can be rebuilt
			// try multiple times in case winmgmt hasn't shut down yet
			int nTry = 20;
			while (nTry--)
			{
				hr = MoveRepository();
				if (SUCCEEDED(hr))
				{
					break;
				}
				Sleep(500);
			}
			if (FAILED(hr))
			{
				LogMessage(MSG_ERROR, "WMI Repository upgrade failed to move repository to backup location.");
			}
		}
		else
		{
			LogMessage(MSG_ERROR, "WMI Repository upgrade failed ConnectServer.");
		}
	}

	SysFreeString(tmpStr);

	pLocator->Release();

	LogMessage(MSG_INFO, "Repository upgrade completed.");
	return bRet;
}

// This function is used to convert an old MMF repository to the current default repository
bool DoConvertRepository()
{
	// get MMF filename
	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_ERROR, "Unable to access registry for DoConvertRepository.");
		return false;
	}

	char* pszDbDir = NULL;
	if (r.GetStr("Repository Directory", &pszDbDir))
	{
		LogMessage(MSG_ERROR, "Unable to get repository directory from registry for DoConvertRepository");
		return false;
	}
	if (!pszDbDir)
	{
		LogMessage(MSG_ERROR, "Unable to get repository directory from registry for DoConvertRepository");
		return false;
	}

	CString szDbFilename(pszDbDir);
	delete [] pszDbDir;
	if (szDbFilename.Length() != 0)
		szDbFilename += "\\";
	szDbFilename += "cim.rep";

	// check that MMF really exists
	if (!FileExists(szDbFilename))
	{
		LogMessage(MSG_ERROR, "MMF Repository does not exist.");
		return false;
	}

	{	//Scope so that we delete the g_pDbArena before we try to delete the file
		// create arena and load MMF
		g_pDbArena = new CMMFArena2();
		if (g_pDbArena == 0)
		{
			LogMessage(MSG_ERROR, "Unable to create CMMFArena2");
			return false;
		}
		CDeleteMe<CMMFArena2> delMe1(g_pDbArena);
		if (!g_pDbArena->LoadMMF(szDbFilename) || (g_pDbArena->GetStatus() != no_error))
		{
			LogMessage(MSG_ERROR, "Error opening existing MMF");
			return false;
		}

		// get export filename
		TCHAR *pszFilename = GetFullFilename(WINMGMT_DBCONVERT_NAME);
		if (pszFilename == 0)
		{
			LogMessage(MSG_ERROR, "Unable to get DB name");
			return false;
		}
		CVectorDeleteMe<TCHAR> delMe2(pszFilename);

		// determine version of exporter to use
		CRepExporter*	pExporter	= NULL;
		DWORD			dwVersion	= g_pDbArena->GetVersion();
		MsgType			msgType		= MSG_INFO;
		char			szTemp[MAX_MSG_TEXT_LENGTH+1];
		sprintf(szTemp, "Upgrading repository format.  Repository format version detected %lu.", dwVersion);
		switch (dwVersion)
		{
			case INTERNAL_DATABASE_VERSION:
			{
				pExporter = new CRepExporterV9;
				break;
			}
			case 3: //450 build
			{
				pExporter = new CRepExporterV1;
				break;
			}
			case 5: //500 series
			case 6: //600 series Nova M1
			{
				pExporter = new CRepExporterV5;
				break;
			}
			case 7: //900 series Nova M3 first attempt!
			case 8: //900 series... has null key trees until instance created
			{
				pExporter = new CRepExporterV7;
				break;
			}
			case 10: //9x version of version 9!
			{
				pExporter = new CRepExporterV9;
				break;
			}
			default:
			{
				sprintf(szTemp, "Unsupported repository version detected.  Version found = %lu, version expected = %lu.", dwVersion, DWORD(INTERNAL_DATABASE_VERSION));
				msgType = MSG_ERROR;
			}
		}
		LogMessage(msgType, szTemp);

		// do we have an exporter?
		if (!pExporter)
		{
			LogMessage(MSG_ERROR, "Unable to create exporter object.");
			return false;
		}
		CDeleteMe<CRepExporter> delMe3(pExporter);

		// export the old repository
		if (pExporter->Export(g_pDbArena, pszFilename) != no_error)
		{
			LogMessage(MSG_ERROR, "Failed to export old WMI Repository.");
			return false;
		}
	

		// create new repository and import into it using IWbemServices
		CRepImporter import;
		if (import.ImportRepository(pszFilename) != no_error)
		{
			LogMessage(MSG_ERROR, "Failed to import data from old WMI Repository.");
			return false;
		}
		DeleteFile(pszFilename);
	}

	// conversion was successful, so now delete the old stuff
	DeleteMMFRepository();

	return true;
}

void DeleteMMFRepository()
{
	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_ERROR, "Unable to access registry for DeleteMMFRepository.");
		return;
	}

	char* pszDbDir = NULL;
	if (r.GetStr("Repository Directory", &pszDbDir))
	{
		LogMessage(MSG_ERROR, "Unable to get repository directory from registry for DeleteMMFRepository");
		return;
	}
	if (!pszDbDir)
	{
		LogMessage(MSG_ERROR, "Unable to get repository directory from registry for DeleteMMFRepository");
		return;
	}

	CString szDbFilename(pszDbDir);
	if (szDbFilename.Length() != 0)
		szDbFilename += "\\";
	szDbFilename += "cim.rep";

	CString szDbBackup(pszDbDir);
	if (szDbBackup.Length() != 0)
		szDbBackup += "\\";
	szDbBackup += "cim.rec";

	CString szDbNewFilename(pszDbDir);
	if (szDbNewFilename.Length() != 0)
		szDbNewFilename += "\\";
	szDbNewFilename += "cim.bak";

	delete [] pszDbDir;

	DeleteFile(szDbFilename);
	DeleteFile(szDbBackup);
	DeleteFile(szDbNewFilename);
}

void ShutdownWinMgmt()
{
    PROCESS_INFORMATION pi;
    STARTUPINFO si;
	memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);

	//Try killing WinMgmt
	char *pszFullPath = GetFullFilename("Winmgmt.exe");
	if (!pszFullPath)
	{
		LogMessage(MSG_NTSETUPERROR, "Could not shut down Winmgmt -- failed to get full path to Winmgmt.exe.");
		return;
	}

	if (CreateProcess(pszFullPath, "Winmgmt /kill", 0, 0, FALSE, 0, 0, 0, &si, &pi))
	{
		WaitForSingleObject(pi.hProcess, INFINITE);
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);

		Sleep(10000);
	}
	else
	{
		LogMessage(MSG_NTSETUPERROR, "Could not shut down Winmgmt -- failed to create process for Winmgmt.exe.");
	}
	delete [] pszFullPath;
}

/******************************************************************************
 *
 *	GetRepositoryDirectory
 *
 *	Description:
 *		Retrieves the location of the repository directory from the registry.
 *
 *	Parameters:
 *		wszRepositoryDirectory:	Array to store location in.
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1])
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ, &hKey);
    if(lRes)
        return WBEM_E_FAILED;

    wchar_t wszTmp[MAX_PATH + 1];
    DWORD dwLen = sizeof(wszTmp);
    lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL, 
                (LPBYTE)wszTmp, &dwLen);
	RegCloseKey(hKey);
    if(lRes)
        return WBEM_E_FAILED;

	if (ExpandEnvironmentStringsW(wszTmp,wszRepositoryDirectory, MAX_PATH + 1) == 0)
		return WBEM_E_FAILED;

	return WBEM_S_NO_ERROR;
}

HRESULT GetLoggingDirectory(wchar_t wszLoggingDirectory[MAX_PATH+1])
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ, &hKey);
    if(lRes)
        return WBEM_E_FAILED;

    wchar_t wszTmp[MAX_PATH + 1];
    DWORD dwLen = sizeof(wszTmp);
    lRes = RegQueryValueExW(hKey, L"Logging Directory", NULL, NULL, 
                (LPBYTE)wszTmp, &dwLen);
	RegCloseKey(hKey);
    if(lRes)
        return WBEM_E_FAILED;

	if (ExpandEnvironmentStringsW(wszTmp,wszLoggingDirectory, MAX_PATH + 1) == 0)
		return WBEM_E_FAILED;

	return WBEM_S_NO_ERROR;
}

/******************************************************************************
 *
 *	MoveRepository
 *
 *	Description:
 *		Move all files and directories under the repository directory
 *		to a backup location. The repository directory location is retrieved
 *		from the registry.
 *
 *	Parameters:
 *		<none>
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT MoveRepository()
{
	HRESULT hres = WBEM_S_NO_ERROR;
	wchar_t wszRepositoryDirectory[MAX_PATH+1];
	wchar_t wszRepositoryMove[MAX_PATH+1];

	//Get the root directory of the repository
	hres = GetRepositoryDirectory(wszRepositoryDirectory);

	if (SUCCEEDED(hres))
	{
        for (int i=1; i<999; i++)
        {
    		wsprintfW(wszRepositoryMove, L"%s.%03i", wszRepositoryDirectory, i);

            if (GetFileAttributesW(wszRepositoryMove) == 0xFFFFFFFF)
                break;
		}

		if (!MoveFileW(wszRepositoryDirectory, wszRepositoryMove))
			hres = WBEM_E_FAILED;
        else
        {
        	char szTemp[MAX_MSG_TEXT_LENGTH+1];
//		    sprintf(szTemp, "Original WMI repository has been backed up to %S", wszRepositoryMove);
//		    LogMessage(MSG_INFO, szTemp);

		    sprintf(szTemp, "wbemupgd.dll: The WMI repository has failed to upgrade. "
							"The repository has been backed up to %S and a new one created.",
							wszRepositoryMove);

		    LogMessage(MSG_NTSETUPERROR, szTemp);
        }

	}
	
	return hres;
}

/******************************************************************************
 *
 *	DeleteRepository
 *
 *	Description:
 *		Delete all files and directories under the repository directory.
 *		The repository directory location is retrieved from the registry.
 *
 *	Parameters:
 *		<none>
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT DeleteRepository()
{
	HRESULT hres = WBEM_S_NO_ERROR;
	wchar_t wszRepositoryDirectory[MAX_PATH+1];

	//Get the root directory of the repository
	hres = GetRepositoryDirectory(wszRepositoryDirectory);

	if (SUCCEEDED(hres))
	{
		hres = DeleteContentsOfDirectory(wszRepositoryDirectory);
	}
	
	return hres;
}

/******************************************************************************
 *
 *	DeleteContentsOfDirectory
 *
 *	Description:
 *		Given a directory, iterates through all files and directories and
 *		calls into the function to delete it.
 *
 *	Parameters:
 *		wszRepositoryDirectory:	Directory to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT DeleteContentsOfDirectory(const wchar_t *wszRepositoryDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;

	wchar_t *wszFullFileName = new wchar_t[MAX_PATH+1];
	if (wszFullFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;

	WIN32_FIND_DATAW findFileData;
	HANDLE hff = INVALID_HANDLE_VALUE;

	//create file search pattern...
	wchar_t *wszSearchPattern = new wchar_t[MAX_PATH+1];
	if (wszSearchPattern == NULL)
		hres = WBEM_E_OUT_OF_MEMORY;
	else
	{
		wcscpy(wszSearchPattern, wszRepositoryDirectory);
		wcscat(wszSearchPattern, L"\\*");
	}

	//Start the file iteration in this directory...
	if (SUCCEEDED(hres))
	{
		hff = FindFirstFileW(wszSearchPattern, &findFileData);
		if (hff == INVALID_HANDLE_VALUE)
		{
			hres = WBEM_E_FAILED;
		}
	}
	
	if (SUCCEEDED(hres))
	{
		do
		{
			//If we have a filename of '.' or '..' we ignore it...
			if ((wcscmp(findFileData.cFileName, L".") == 0) ||
				(wcscmp(findFileData.cFileName, L"..") == 0))
			{
				//Do nothing with these...
			}
			else if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				//This is a directory, so we need to deal with that...
				hres = PackageDeleteDirectory(wszRepositoryDirectory, findFileData.cFileName);
				if (FAILED(hres))
					break;
			}
			else
			{
				//This is a file, so we need to deal with that...
				wcscpy(wszFullFileName, wszRepositoryDirectory);
				wcscat(wszFullFileName, L"\\");
				wcscat(wszFullFileName, findFileData.cFileName);
				if (!DeleteFileW(wszFullFileName))
				{
					hres = WBEM_E_FAILED;
					break;
				}
			}
			
		} while (FindNextFileW(hff, &findFileData));
	}
	
	if (wszFullFileName)
		delete [] wszFullFileName;

	if (wszSearchPattern)
		delete [] wszSearchPattern;

	if (hff != INVALID_HANDLE_VALUE)
		FindClose(hff);

	return hres;
}

/******************************************************************************
 *
 *	PackageDeleteDirectory
 *
 *	Description:
 *		This is the code which processes a directory.  It iterates through
 *		all files and directories in that directory.
 *
 *	Parameters:
 *		wszParentDirectory:	Full path of parent directory
 *		eszSubDirectory:	Name of sub-directory to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT PackageDeleteDirectory(const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;

	//Get full path of new directory...
	wchar_t *wszFullDirectoryName = NULL;
	wszFullDirectoryName = new wchar_t[MAX_PATH+1];
	if (wszFullDirectoryName == NULL)
		hres = WBEM_E_OUT_OF_MEMORY;
	else
	{
		wcscpy(wszFullDirectoryName, wszParentDirectory);
		wcscat(wszFullDirectoryName, L"\\");
		wcscat(wszFullDirectoryName, wszSubDirectory);
	}

	//Package the contents of that directory...
	if (SUCCEEDED(hres))
	{
		hres = DeleteContentsOfDirectory(wszFullDirectoryName);
	}

	// now that the directory is empty, remove it
	if (SUCCEEDED(hres))
	{
		if (!RemoveDirectoryW(wszFullDirectoryName))
			hres = WBEM_E_FAILED;
	}

	if (wszFullDirectoryName)
		delete [] wszFullDirectoryName;

	return hres;
}

bool LoadMofList(IMofCompiler * pCompiler, const char *mszMofs, CString &szMOFFailureList)
{
	LogMessage(MSG_INFO, "Beginning MOF load");

	bool bRet = true;
	WCHAR wFileName[MAX_PATH+1];
	const char *pszMofs = mszMofs;
	char szTemp[MAX_MSG_TEXT_LENGTH+1];
	WBEM_COMPILE_STATUS_INFO statusInfo;

	// get logging directory or default if failed
	wchar_t wszMofcompLog[MAX_PATH+1];
	HRESULT hres = GetLoggingDirectory(wszMofcompLog);
	if (SUCCEEDED(hres))
	{
		wcscat(wszMofcompLog, L"mofcomp.log");
	}
	else
	{
		wcscpy(wszMofcompLog, L"<systemroot>\\system32\\wbem\\logs\\mofcomp.log");
	}

	// process each MOF
	while (*pszMofs != '\0')
	{
		char *szExpandedFilename = NULL;
		DWORD nRes = ExpandEnvironmentStrings(pszMofs,NULL,0); 
		if (nRes == 0)
		{
			szExpandedFilename = new char[strlen(pszMofs) + 1];
			if (szExpandedFilename == NULL)
			{
				LogMessage(MSG_INFO, "Failed allocating memory for szExpandedFilename - 1.");

				bRet = false;
				break;
			}
			strcpy(szExpandedFilename, pszMofs);
		}
		else
		{
			szExpandedFilename = new char[nRes];
			if (szExpandedFilename == NULL)
			{
				LogMessage(MSG_INFO, "Failed allocating memory for szExpandedFilename - 2.");

				bRet = false;
				break;
			}
			nRes = ExpandEnvironmentStrings(pszMofs,szExpandedFilename,nRes); 
			if (nRes == 0)
			{
				LogMessage(MSG_INFO, "Failed expanding environment strings.");

				delete [] szExpandedFilename;
				bRet = false;
				break;
			}
		}
		
		sprintf(szTemp, "Processing %s", szExpandedFilename);
		LogMessage(MSG_INFO, szTemp);

		//Call MOF Compiler with (pszMofs);
     	mbstowcs(wFileName, szExpandedFilename, MAX_PATH+1);
       	SCODE sRet = pCompiler->CompileFile(wFileName, NULL, NULL, NULL, NULL, WBEM_FLAG_CONNECT_REPOSITORY_ONLY | WBEM_FLAG_DONT_ADD_TO_LIST, WBEM_FLAG_UPDATE_FORCE_MODE, 0, &statusInfo);
		if (sRet != S_OK)
		{
			//This MOF failed to load.
			if (szMOFFailureList.Length())
				szMOFFailureList += "\n";
			szMOFFailureList += szExpandedFilename;

//			sprintf(szTemp, "A MOF compilation error occurred while processing item %li defined on lines %li - %li in file %s",
//					statusInfo.ObjectNum, statusInfo.FirstLine, statusInfo.LastLine, szExpandedFilename);

			sprintf(szTemp, "An error occurred while compiling the following MOF file: %s  "
							"Please refer to %S for more detailed information.",
							szExpandedFilename, wszMofcompLog);

			LogMessage(MSG_NTSETUPERROR, szTemp);

			bRet = false;
		}
		delete [] szExpandedFilename;

		//Move on to the next string
		pszMofs += strlen(pszMofs) + 1;
	}	// end while

	LogMessage(MSG_INFO, "MOF load completed.");

	return bRet;
}

bool WriteBackAutoRecoveryMofs(CMultiString &mszSystemMofs, CMultiString &mszExternalMofList)
{
	CMultiString mszNewList;
	CopyMultiString(mszSystemMofs, mszNewList);
	CopyMultiString(mszExternalMofList, mszNewList);
	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_ERROR, "Unable to access registry for WriteBackAutoRecoverMofs.");
		return false;
	}

	r.SetMultiStr(WBEM_REG_AUTORECOVER, mszNewList, mszNewList.Length() + 1);
	return true;
}

void LogMessage(MsgType msgType, const char *pszMessage)
{
	//Load messages from the resource
	char pszSetupMessage[10];
	switch (msgType)
	{
		case MSG_NTSETUPERROR:
			LogSetupError(pszMessage);
			// now fall through to next case
		case MSG_ERROR:
			strcpy(pszSetupMessage, "ERROR: ");
			break;
		case MSG_WARNING:
			strcpy(pszSetupMessage, "WARNING: ");
			break;
		case MSG_INFO:
		default:
			strcpy(pszSetupMessage, "");
			break;
	}

	char* pszNewMessage = new char[strlen(pszMessage) + 1];
	if (!pszNewMessage)
	{
		// we failed to allocate memory for the message, so no logging :(
		return;
	}
	strcpy(pszNewMessage, pszMessage);

	// get log file path and name
	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() != no_error)
	{
		// no messages will be logged because we don't know where to write the log :(
		delete [] pszNewMessage;
		return;		
	}	

	char* pszFullDirectory = NULL;
	if (r.GetStr("Logging Directory", &pszFullDirectory))
	{
		// no messages will be logged because we don't know where to write the log :(
		delete [] pszNewMessage;
		return;		
	}
	if (!pszFullDirectory)
	{
		// no messages will be logged because we don't know where to write the log :(
		delete [] pszNewMessage;
		return;		
	}

	char* pszFilename = "setup.log";
	char* pszFullPath = new char [strlen(pszFullDirectory) + strlen("\\") + strlen(pszFilename) + 1];
	if (!pszFullPath)
	{
		// we failed to allocate memory for the path, so no logging :(
		delete [] pszNewMessage;
		return;
	}

	strcpy(pszFullPath, pszFullDirectory);
	strcat(pszFullPath, "\\");
	strcat(pszFullPath, pszFilename);
	delete [] pszFullDirectory;

    // Get time
    char timebuf[64];
    time_t now = time(0);
    struct tm *local = localtime(&now);
    if(local)
    {
        strcpy(timebuf, asctime(local));
        timebuf[strlen(timebuf) - 1] = 0;
    }
    else
        strcpy(timebuf,"unknown time");

	char* pszTime = new char [strlen(timebuf) + strlen("(): ") + 1];
	if (!pszTime)
	{
		// we failed to allocate memory for the time, so no logging :(

		delete [] pszNewMessage;
		delete [] pszFullPath;
		return;
	}

	strcpy(pszTime, "(");
	strcat(pszTime, timebuf);
	strcat(pszTime, "): ");

	// write messages to log file
	HANDLE hFile = CreateFile(pszFullPath, GENERIC_WRITE, 0, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		const char* pszCR = "\r\n";
		char* psz;
		DWORD dwWritten;
		SetFilePointer(hFile, 0, 0, FILE_END);
		psz = strtok(pszNewMessage, "\n");
		while (psz)
		{
			WriteFile(hFile, pszTime, strlen(pszTime), &dwWritten, 0);
			WriteFile(hFile, pszSetupMessage, strlen(pszSetupMessage), &dwWritten, 0);
			WriteFile(hFile, psz, strlen(psz), &dwWritten, 0);
			WriteFile(hFile, pszCR, strlen(pszCR), &dwWritten, 0);
			psz = strtok(NULL, "\n");
		}
		CloseHandle(hFile);
	}

	delete [] pszNewMessage;
	delete [] pszFullPath;
	delete [] pszTime;
}

void LogSetupError(const char *pszMessage)
{
	char* pszTemp = new char[strlen(pszMessage) + 1];
	if (!pszTemp)
	{
		// we failed to allocate memory for the message, so no logging :(
		return;
	}
	strcpy(pszTemp, pszMessage);

	char* psz;
	char* pszMessageLine;
	const char* pszCR = "\r\n";

	psz = strtok(pszTemp, "\n");
	while (psz)
	{
		pszMessageLine = new char[strlen(psz) + strlen(pszCR) + 1];
		if (!pszMessageLine)
		{
			delete [] pszTemp;
			return;
		}
		strcpy(pszMessageLine, psz);
		strcat(pszMessageLine, pszCR);
		SetupLogError(pszMessageLine, LogSevError);
		delete [] pszMessageLine;

		psz = strtok(NULL, "\n");
	}

	delete [] pszTemp;
}


void RunLodctr()
{
	char *pszDirectory = NULL;
	Registry r(WBEM_REG_WBEM);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_ERROR, "Unable to access registry for RunLodctr.");
		return;
	}

	if (r.GetStr("Installation Directory", &pszDirectory))
	{
		LogMessage(MSG_ERROR, "Unable to get Installation Directory from registry for RunLodctr.");
		return;
	}
	if (!pszDirectory)
	{
		LogMessage(MSG_ERROR, "Unable to get Installation Directory from registry for RunLodctr.");
		return;
	}

    PROCESS_INFORMATION pi;
    STARTUPINFO si;
	memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);
	if(CreateProcess(NULL, "lodctr wmiperf.ini", NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, pszDirectory, &si, &pi))
	{
		WaitForSingleObject(pi.hProcess, INFINITE);
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
		LogMessage(MSG_INFO, "Succeeded run Lodctr for wmiperf");
	}
	else
	{
		LogMessage(MSG_ERROR, "Failed to run Lodctr for wmiperf");
	}
	delete [] pszDirectory;
	return;
}

void ClearWMISetupRegValue()
{
	Registry r(WBEM_REG_WINMGMT);
	if (r.GetStatus() == no_error)
		r.SetStr("WMISetup", "0");
	else
		LogMessage(MSG_NTSETUPERROR, "Unable to clear WMI setup reg value.");
}

void SetWBEMBuildRegValue()
{
	Registry r(WBEM_REG_WBEM);
	if (r.GetStatus() != no_error)
	{
		LogMessage(MSG_NTSETUPERROR, "Unable to set WBEM build reg value.");
		return;
	}
	
	char* pszBuildNo = new char[10];

	OSVERSIONINFO os;
	os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if(GetVersionEx(&os))
	{
		sprintf(pszBuildNo, "%lu.0000", os.dwBuildNumber);
	}
	r.SetStr("Build", pszBuildNo);

	delete [] pszBuildNo;
}

void RecordFileVersion()
{
	DWORD dwHandle;
	DWORD dwLen = GetFileVersionInfoSizeW(L"wbemupgd.dll", &dwHandle);

	if (dwLen)
	{
		BYTE* lpData = new BYTE[dwLen];

		if (lpData)
		{
			if (GetFileVersionInfoW(L"wbemupgd.dll", dwHandle, dwLen, lpData))
			{
				struct LANGANDCODEPAGE {
					WORD wLanguage;
					WORD wCodePage;
				} *lpTranslate;
				UINT cbTranslate;

				if (VerQueryValueW(lpData, L"\\VarFileInfo\\Translation", (LPVOID*)&lpTranslate, &cbTranslate))
				{
					wchar_t* pswzSubBlock = new wchar_t[dwLen];
					wchar_t* pwszFileVersion = NULL;
					UINT cbBytes;

					for(UINT i=0; i < (cbTranslate/sizeof(struct LANGANDCODEPAGE)); i++)
					{
						wsprintfW(pswzSubBlock, L"\\StringFileInfo\\%04x%04x\\FileVersion", lpTranslate[i].wLanguage, lpTranslate[i].wCodePage);

						// Retrieve file description for language and code page "i". 
						if (VerQueryValueW(lpData, pswzSubBlock, (LPVOID*)&pwszFileVersion, &cbBytes))
						{
							if (cbBytes)
							{
								wchar_t wszTemp[MAX_MSG_TEXT_LENGTH+1];
								wsprintfW(wszTemp, L"Current build of wbemupgd.dll is %s", pwszFileVersion);

								// once LogMessage is updated to handle wchars, this conversion can be removed
								char* szTemp = new char[MAX_MSG_TEXT_LENGTH+1];
								if (szTemp)
								{
									wcstombs(szTemp, wszTemp, MAX_MSG_TEXT_LENGTH+1);
									LogMessage(MSG_INFO, szTemp);
									delete [] szTemp;
								}
							}
						}
					}
					delete [] pswzSubBlock;
				}
			}
			delete [] lpData;
		}
	}
}

void CallEscapeRouteBeforeMofCompilation()
{
	HMODULE hDll = NULL;
	ESCDOOR_BEFORE_MOF_COMPILATION pfnEscRouteBeforeMofCompilation;
	char *pszFullPath = GetFullFilename("WmiEscpe.dll");
	if (!pszFullPath)
		return;

	hDll = LoadLibrary(pszFullPath);
	delete[] pszFullPath;
	if(hDll == NULL)
	{
		return;
	}
	pfnEscRouteBeforeMofCompilation =
		(ESCDOOR_BEFORE_MOF_COMPILATION)GetProcAddress((HMODULE)hDll, "EscRouteBeforeMofCompilation");

	if (pfnEscRouteBeforeMofCompilation == NULL)
	{
		if(hDll != NULL)
			FreeLibrary(hDll);
		return;
	}
	
	pfnEscRouteBeforeMofCompilation();
	if(hDll != NULL)
		FreeLibrary(hDll);
}

void CallEscapeRouteAfterMofCompilation()
{
	HMODULE hDll = NULL;
	ESCDOOR_AFTER_MOF_COMPILATION pfnEscRouteAfterMofCompilation;
	char *pszFullPath = GetFullFilename("WmiEscpe.dll");
	if (!pszFullPath)
		return;

	hDll = LoadLibrary(pszFullPath);
	delete[] pszFullPath;
	if(hDll == NULL)
	{
		return;
	}
	pfnEscRouteAfterMofCompilation =
		(ESCDOOR_AFTER_MOF_COMPILATION)GetProcAddress((HMODULE)hDll, "EscRouteAfterMofCompilation");

	if (pfnEscRouteAfterMofCompilation == NULL)
	{
		if(hDll != NULL)
			FreeLibrary(hDll);
		return;
	}
	
	pfnEscRouteAfterMofCompilation();
	if(hDll != NULL)
		FreeLibrary(hDll);
}

bool DoMofLoad(wchar_t* pComponentName, CMultiString& mszSystemMofs)
{
    bool bRet = true;
    bool bMofLoadFailure = false;
    CString szFailedSystemMofs;

    IMofCompiler * pCompiler = NULL;
    SCODE sc = CoCreateInstance(CLSID_MofCompiler, 0, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (LPVOID *) &pCompiler);
    
    if(SUCCEEDED(sc))
    {
        bRet = LoadMofList(pCompiler, mszSystemMofs, szFailedSystemMofs);
        if (bRet == false)
            bMofLoadFailure = true;
        
        pCompiler->Release();
    }
    else
    {
        bRet = false;
    }
    
    if (szFailedSystemMofs.Length())
    {
        char szTemp[MAX_MSG_TEXT_LENGTH];
        sprintf(szTemp, "The following %S file(s) failed to load:", pComponentName);
        LogMessage(MSG_ERROR, szTemp);
        LogMessage(MSG_ERROR, szFailedSystemMofs);
    }
    else if (bMofLoadFailure)
    {
        char szTemp[MAX_MSG_TEXT_LENGTH];
        sprintf(szTemp, "None of the %S files could be loaded.", pComponentName);
        LogMessage(MSG_ERROR, szTemp);
    }
    else if (bRet == false)
    {
        LogMessage(MSG_ERROR, "No MOFs could be loaded because the MOF Compiler failed to initialize.");
    }
    return bRet;
}

// this call back is needed by the wdmlib functions called by DoWDMProviderInit()
void WINAPI EventCallbackRoutine(PWNODE_HEADER WnodeHeader, ULONG_PTR Context)
{
	return;
}

bool DoWDMNamespaceInit()
{
	LogMessage(MSG_INFO, "Beginning WMI(WDM) Namespace Init");

	bool bRet = FALSE;

	IWbemLocator *pLocator = NULL;
	HRESULT hr = CoCreateInstance(CLSID_WbemLocator,NULL, CLSCTX_ALL, IID_IWbemLocator,(void**)&pLocator);
	if(SUCCEEDED(hr))
	{
		BSTR tmpStr = SysAllocString(L"root\\wmi");
		IWbemServices* pNamespace = NULL;
		hr = pLocator->ConnectServer(tmpStr, NULL, NULL, NULL, NULL, NULL, NULL, &pNamespace);
		if (SUCCEEDED(hr))
		{
			CHandleMap	HandleMap;
			CWMIBinMof Mof;
	
			if( SUCCEEDED( Mof.Initialize(&HandleMap, TRUE, WMIGUID_EXECUTE|WMIGUID_QUERY, pNamespace, NULL, NULL)))
			{
				Mof.ProcessListOfWMIBinaryMofsFromWMI();
			}

			pNamespace->Release();
			bRet = TRUE;
		}
		SysFreeString(tmpStr);
		pLocator->Release();
	}

	if (bRet)
		LogMessage(MSG_INFO, "WMI(WDM) Namespace Init Completed");
	else
		LogMessage(MSG_NTSETUPERROR, "WMI(WDM) Namespace Init Failed");

	return bRet;
}

bool EnableESS()
{
	CPersistentConfig cfg;
	bool bRet = (cfg.SetPersistentCfgValue(PERSIST_CFGVAL_CORE_ESS_NEEDS_LOADING, 1) != 0);

	if (bRet)
		LogMessage(MSG_INFO, "ESS enabled");
	else
		LogMessage(MSG_ERROR, "Failed to enable ESS");

	return bRet;
}

#ifdef _X86_
bool RemoveOldODBC()
{
	bool bRet = true;
	bool bDoUninstall = false;
	
	WCHAR strBuff[MAX_PATH + 30];
	DWORD dwSize = GetWindowsDirectoryW((LPWSTR) &strBuff, MAX_PATH);

	if ((dwSize > 1) && (dwSize < MAX_PATH) && (strBuff[dwSize] == L'\0'))
	{
		//can be c:\ or c:\windows
		if (strBuff[dwSize - 1] != L'\\')
		{
			wcscat(strBuff, L"\\system32\\wbemdr32.dll");
			
			//we want dwSize to include the slash (may be used later)...
			dwSize++;
		}
		else
		{
			wcscat(strBuff, L"system32\\wbemdr32.dll");
		}

		DWORD dwDummy = 0;
		DWORD dwInfSize = GetFileVersionInfoSizeW(strBuff, &dwDummy);

		if (dwInfSize > 0)
		{
			BYTE *verBuff = new BYTE[dwInfSize];

			if (verBuff)
			{
				if (GetFileVersionInfoW(strBuff, 0, dwInfSize, (LPVOID)verBuff))
				{
					VS_FIXEDFILEINFO *verInfo = NULL;
					UINT uVerInfoSize = 0;

					if (VerQueryValueW((const LPVOID)verBuff, L"\\", (LPVOID *)&verInfo, &uVerInfoSize) &&
						(uVerInfoSize == sizeof(VS_FIXEDFILEINFO)))
					{
						if (0x043D0000 > verInfo->dwFileVersionLS) //1085 = 43D
						{
							bDoUninstall = true;
							LogMessage(MSG_INFO, "Detected incompatible WBEM ODBC - removing");

							if (!DeleteFileW(strBuff))
							{
								if (!MoveFileExW(strBuff, NULL, MOVEFILE_DELAY_UNTIL_REBOOT))
								{
									bRet = false;
									LogMessage(MSG_INFO, "Failed to delete <system32>\\wbemdr32.dll");
								}
								else
								{
									LogMessage(MSG_INFO, "Will delete <system32>\\wbemdr32.dll on next reboot");
								}
							}
						}
					}
					else
					{
						GetLastError();
						LogMessage(MSG_INFO, "Failed to read ODBC Driver version info from resource buffer");
						bRet = false;
					}
				}
				else
				{
					GetLastError();
					LogMessage(MSG_INFO, "Failed to get ODBC Driver version info");
					bRet = false;
				}

				delete [] verBuff;
				verBuff = NULL;
			}
			else
			{
				bRet = false;
			}
		}
		else
		{
			dwDummy = GetLastError();

			if ((ERROR_FILE_NOT_FOUND != dwDummy) && (ERROR_SUCCESS != dwDummy))
			{
				LogMessage(MSG_INFO, "Failed to get ODBC Driver version size info");
				bRet = false;
			}
			else
			{
				//the driver isn't present clean up anything lying around
				LogMessage(MSG_INFO, "ODBC Driver <system32>\\wbemdr32.dll not present");
				bDoUninstall = true;
			}
		}
	}
	else
	{
		bRet = false;
	}

	if (bDoUninstall)
	{
		//
		//delete files and registry entries
		//leave ini entries as they were not added by us but by ODBC Mgr
		//

		strBuff[dwSize] = L'\0';
		wcscat(strBuff, L"system32\\wbem\\wbemdr32.chm");

		if (!DeleteFileW(strBuff))
		{
			if (ERROR_FILE_NOT_FOUND != GetLastError())
			{
				if (!MoveFileExW(strBuff, NULL, MOVEFILE_DELAY_UNTIL_REBOOT))
				{
					bRet = false;
					LogMessage(MSG_INFO, "Failed to delete <system32>\\wbem\\wbemdr32.chm");
				}
				else
				{
					LogMessage(MSG_INFO, "Will delete <system32>\\wbem\\wbemdr32.chm on next reboot");
				}
			}
		}

		strBuff[dwSize] = L'\0';
		wcscat(strBuff, L"help\\wbemdr32.chm");

		if (!DeleteFileW(strBuff))
		{
			if (ERROR_FILE_NOT_FOUND != GetLastError())
			{
				if (!MoveFileExW(strBuff, NULL, MOVEFILE_DELAY_UNTIL_REBOOT))
				{
					bRet = false;
					LogMessage(MSG_INFO, "Failed to delete <windir>\\help\\wbemdr32.chm");
				}
				else
				{
					LogMessage(MSG_INFO, "Will delete <windir>\\help\\wbemdr32.chm on next reboot");
				}
			}
		}

		LONG lErr = RegDeleteKeyW(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\ODBC\\ODBC.INI\\WBEM Source");

		if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
		{
			LogMessage(MSG_INFO, "Failed to delete registry key: SSoftware\\Microsoft\\ODBC\\ODBC.INI\\WBEM Source");
			bRet = false;
		}

		lErr = RegDeleteKeyW(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\ODBC\\ODBCINST.INI\\WBEM ODBC Driver");

		if ((ERROR_SUCCESS != lErr) && (ERROR_FILE_NOT_FOUND != lErr))
		{
			LogMessage(MSG_INFO, "Failed to delete registry key: Software\\Microsoft\\ODBC\\ODBCINST.INI\\WBEM ODBC Driver");
			bRet = false;
		}

		Registry regODBC1("Software\\Microsoft\\ODBC\\ODBC.INI\\ODBC Data Sources");

		if (regODBC1.GetStatus() == no_error)
		{
			if (no_error != regODBC1.DeleteEntry("WBEM Source"))
			{
				if (ERROR_FILE_NOT_FOUND != regODBC1.GetLastError())
				{
					LogMessage(MSG_INFO, "Failed to delete registry value: Software\\Microsoft\\ODBC\\ODBC.INI\\ODBC Data Sources|WBEM Source");
					bRet = false;
				}
			}
		}
		else
		{
			bRet = false;
		}

		Registry regODBC2("Software\\Microsoft\\ODBC\\ODBCINST.INI\\ODBC Drivers");

		if (regODBC2.GetStatus() == no_error)
		{
			if (no_error != regODBC2.DeleteEntry("WBEM ODBC Driver"))
			{
				if (ERROR_FILE_NOT_FOUND != regODBC2.GetLastError())
				{
					LogMessage(MSG_INFO, "Failed to delete registry value: Software\\Microsoft\\ODBC\\ODBCINST.INI\\ODBC Drivers|WBEM ODBC Driver");
					bRet = false;
				}
			}
		}
		else
		{
			bRet = false;
		}
	}

	if (!bRet)
	{
		LogMessage(MSG_ERROR, "A failure in verifying or removing currently installed version of WBEM ODBC.");
	}
	else
	{
		LogMessage(MSG_INFO, "Successfully verified WBEM OBDC adapter (incompatible version removed if it was detected).");
	}

	return bRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\advanced.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "..\Common\ServiceThread.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "advanced.h"
#include "..\common\util.h"
#include "resource.h"
#include "EnvPage.h"
#include "PerfPage.h"
#include "StartupPage.h"
#include "helpid.h"


// Help IDs
DWORD aAdvancedHelpIds[] = {
    IDC_ADV_PERF_TEXT,             (IDH_ADVANCED + 0),
    IDC_ADV_PERF_BTN,              (IDH_ADVANCED + 1),
    IDC_ADV_ENV_TEXT,              (IDH_ADVANCED + 2),
    IDC_ADV_ENV_BTN,               (IDH_ADVANCED + 3),
    IDC_ADV_RECOVERY_TEXT,         (IDH_ADVANCED + 4),
    IDC_ADV_RECOVERY_BTN,          (IDH_ADVANCED + 5),
    0, 0
};

//------------------------------------------------------
AdvancedPage::AdvancedPage(WbemServiceThread *serviceThread,
						   LONG_PTR lNotifyHandle, bool bDeleteHandle, TCHAR* pTitle)
							: WBEMPageHelper(serviceThread),
							CSnapInPropertyPageImpl<AdvancedPage> (pTitle),
									m_lNotifyHandle(lNotifyHandle),
									m_bDeleteHandle(bDeleteHandle) // Should be true for only page.
{
}

//------------------------------------------------------
AdvancedPage::~AdvancedPage()
{
}

//----------------------------------------------
LRESULT AdvancedPage::OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	m_hDlg = m_hWnd;

	if(g_serviceThread)
	{
		g_serviceThread->SendPtr(m_hWnd);
	}

	::EnableWindow(GetDlgItem(IDC_ADV_PERF_BTN), FALSE);
	::EnableWindow(GetDlgItem(IDC_ADV_ENV_BTN), FALSE);
	::EnableWindow(GetDlgItem(IDC_ADV_RECOVERY_BTN), FALSE);

	return S_OK;
}

//----------------------------------------------
LRESULT AdvancedPage::OnConnected(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	if(lParam)
	{
		IStream *pStream = (IStream *)lParam;
		IWbemServices *pServices = 0;
		HRESULT hr = CoGetInterfaceAndReleaseStream(pStream,
											IID_IWbemServices,
											(void**)&pServices);
		if(SUCCEEDED(hr))
		{
			SetWbemService(pServices);

			if(ServiceIsReady(NO_UI, 0, 0))
			{
				::EnableWindow(GetDlgItem(IDC_ADV_PERF_BTN), TRUE);
				::EnableWindow(GetDlgItem(IDC_ADV_ENV_BTN), TRUE);
				::EnableWindow(GetDlgItem(IDC_ADV_RECOVERY_BTN), TRUE);
			}
		}
	}

	return S_OK;
}

//----------------------------------------------
LRESULT AdvancedPage::OnF1Help(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
				L"sysdm.hlp", 
				HELP_WM_HELP, 
				(ULONG_PTR)(LPSTR)aAdvancedHelpIds);

	return S_OK;
}

//----------------------------------------------
LRESULT AdvancedPage::OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	::WinHelp((HWND)wParam,
				L"sysdm.hlp", 
				HELP_CONTEXTMENU, 
				(ULONG_PTR)(LPSTR)aAdvancedHelpIds);

	return S_OK;
}

//----------------------------------------------
LRESULT AdvancedPage::CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    DWORD dwResult = 0;

    switch (wID) 
	{
    case IDC_ADV_PERF_BTN:
		{
			g_fRebootRequired = FALSE;
			PerfPage perfPage(g_serviceThread);
			perfPage.DoModal(m_hDlg);
		}
        break;

    case IDC_ADV_ENV_BTN:
		{
			g_fRebootRequired = FALSE;
			EnvPage envPage(g_serviceThread);
			envPage.DoModal(m_hDlg);
		}
        break;

    case IDC_ADV_RECOVERY_BTN:
		{
			StartupPage startupPage(g_serviceThread);
			if(startupPage.DoModal(m_hDlg) == CLOSE_SNAPIN)
			{
				::PostMessage(GetParent(), WM_COMMAND, MAKEWPARAM(IDCANCEL, 0), 0);
			}
		}
        break;

    default:
        return(FALSE);
    } // switch

    return(TRUE);
}

//----------------------------------------------
BOOL AdvancedPage::OnApply()
{
   // LPPSHNOTIFY psh;//TODO = (LPPSHNOTIFY)pnmh;

	// If the user is pressing "OK" and a reboot is required,
	// OLD WAY: send the PSM_REBOOTSYSTEM message.
	// NEW WAY: use WBEM.
	TCHAR msg[200] = {0};
	TCHAR caption[100] = {0};

	::LoadString(HINST_THISDLL,
					IDS_SYS_CHANGE_CAPTION, 
					caption, 100);

	::LoadString(HINST_THISDLL,
					IDS_MUST_RESTART, 
					msg, 200);

	if(/*(psh->lParam) && */
		g_fRebootRequired && 
		(::MessageBox(m_hDlg, msg, caption,
						MB_YESNO |
						MB_DEFBUTTON1 | 
						MB_ICONQUESTION) == IDYES))
	{
		//OLD WAY: PropSheet_RebootSystem(GetParent(hDlg));

		// call the helper in the base class.
		HRESULT hr = Reboot();

		if(FAILED(hr))
		{
			TCHAR format[100] = {0};
			memset(msg, 0, 200 * sizeof(TCHAR));
			memset(caption, 0, 100 * sizeof(TCHAR));

			::LoadString(HINST_THISDLL,
							IDS_ERR_EXECMETHOD_CAPTION, 
							caption, 100);

			::LoadString(HINST_THISDLL,
							IDS_ERR_EXECMETHOD, 
							format, 100);

			swprintf(msg, format, hr);

			::MessageBox(m_hWnd, msg, caption,
							MB_OK| MB_ICONEXCLAMATION);
		}
	} // if
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\upgrade.h ===
// Copyright (c) 1999 Microsoft Corporation
#ifndef __UPGRADE_H_
#define __UPGRADE_H_

#include <wbemidl.h>
#include <tchar.h>
#include "str.h"

#define ToHex(n)					((BYTE) (((n) > 9) ? ((n) - 10 + 'A') : ((n) + '0')))
#define WINMGMT_DBCONVERT_NAME		__TEXT("upgrade.imp")
#define MAX_MSG_TITLE_LENGTH		255		//defined by Bakul for localization
#define MAX_MSG_TEXT_LENGTH			1024	//defined by Bakul for localization
#define INTERNAL_DATABASE_VERSION   9

#define LANG_ID_STR_SIZE			5
extern "C" char g_szLangId[LANG_ID_STR_SIZE];

typedef struct 
{
	const char*	pszMofFilename;				//MOF filename
	int			nInstallType;				//Selection of InstallType items
} MofDataTable;

enum InstallType 
{
	Core	= 1, 
	MUI		= 2
};

enum MsgType
{
	MSG_INFO,
	MSG_WARNING,
	MSG_ERROR,
	MSG_NTSETUPERROR
};

enum
{
	no_error,
	failed,
	critical_error,
	out_of_memory
};

template<class T>
class CDeleteMe
{
protected:
    T* m_p;

public:
    CDeleteMe(T* p = NULL) : m_p(p){}
    ~CDeleteMe() {delete m_p;}

    //  overwrites the previous pointer, does NOT delete it
    void operator= (T* p) {m_p = p;}
};

template<class T>
class CVectorDeleteMe
{
protected:
    T* m_p;
    T** m_pp;

public:
    CVectorDeleteMe(T* p) : m_p(p), m_pp(NULL){}
    CVectorDeleteMe(T** pp) : m_p(NULL), m_pp(pp){}
    ~CVectorDeleteMe() {if(m_p) delete [] m_p; else if(m_pp) delete [] *m_pp;}
};

typedef void (WINAPI *ESCDOOR_BEFORE_MOF_COMPILATION) ();
typedef void (WINAPI *ESCDOOR_AFTER_MOF_COMPILATION) ();

void			CallEscapeRouteAfterMofCompilation();
void			CallEscapeRouteBeforeMofCompilation();
void			ClearWMISetupRegValue();
bool			CopyMultiString(CMultiString &mszFrom, CMultiString &mszTo);
void			DeleteMMFRepository();
bool			DoConvertRepository();
bool			DoCoreUpgrade(int nInstallType=1);
bool			DoWDMNamespaceInit();
bool			DoesFSRepositoryExist();
bool			DoesMMFRepositoryExist();
bool			DoMofLoad(wchar_t* pComponentName, CMultiString& mszSystemMofs);
bool			EnableESS();
bool			ExtractPathAndFilename(const char *pszFullPath, CString &path, CString &filename);
bool			FileExists(const char *pszFilename);
char*			GetFullFilename(const char *pszFilename, InstallType eInstallType=Core);
bool			GetMofList(const char* rgpszMofFilename[], CMultiString &mszMofs);
bool			GetNewMofLists(const char *pszMofList, CMultiString &mszSystemMofs, CMultiString &mszOtherMofs, CString &szMissingMofs);
HRESULT			GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1]);
bool			GetStandardMofs(CMultiString &mszSystemMofs, int nCurInstallType);
bool			IsStandardMof(CMultiString &mszStandardMofList, const char* pszMofFile);
bool			LoadMofList(IMofCompiler * pCompiler, const char *mszMofs, CString &szMOFsWhichFailedToLoad);
void			LogMessage(MsgType msgType, const char *pszMessage);
void			LogSetupError(const char *pszMessage);
void			RecordFileVersion();
void			RunLodctr();
void			SetWBEMBuildRegValue();
void			ShutdownWinMgmt();
bool			UpgradeAutoRecoveryRegistry(CMultiString &mszSystemMofs, CMultiString &mszExternalMofList, CString &szMissingMofs);
bool			UpgradeRepository();
bool			WipeOutAutoRecoveryRegistryEntries();
bool			WriteBackAutoRecoveryMofs(CMultiString &mszSystemMofs, CMultiString &mszExternalMofList);

HRESULT			DeleteRepository();
HRESULT			MoveRepository();
HRESULT			DeleteContentsOfDirectory(const wchar_t *wszRepositoryDirectory);
HRESULT			PackageDeleteDirectory(const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory);
extern HRESULT UpdateServiceSecurity () ;
extern HRESULT CheckForServiceSecurity () ;

#ifdef _X86_
bool			RemoveOldODBC();
#endif

#endif // __UPGRADE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\setup\bin\wbemupgradedll\str.h ===
// Copyright (c) 1999 Microsoft Corporation
extern 	char *__g_pszStringBlank;

class CString
{
private:
	char *m_pszString;

	void DeleteString() { if (m_pszString != __g_pszStringBlank) delete [] m_pszString; } 
	char *DuplicateString()
	{
		char *psz = new char[strlen(m_pszString) + 1];
		if (psz == NULL)
			return NULL;
		strcpy(psz, m_pszString);
		return psz;
	}
public:
	CString() 
	{
		m_pszString = __g_pszStringBlank;
	}
	CString (const char *psz)
	{
		m_pszString = new char[strlen(psz) + 1];
		if (m_pszString == 0)
		{
			m_pszString = __g_pszStringBlank;
		}
		else
		{
			strcpy(m_pszString, psz);
		}
	}
	CString (CString &sz)
	{
		m_pszString = __g_pszStringBlank;
		*this = sz.m_pszString;
	}
	~CString() { DeleteString(); }
    size_t Length() const { return strlen(m_pszString); }    //09/17//int Length() const { return strlen(m_pszString); }
    CString& operator +=(const char *psz)
	{
		char *pszNewString = new char[Length() + strlen(psz) + 1];
		if (pszNewString == NULL)
			return *this;
		strcpy(pszNewString, m_pszString);
		strcat(pszNewString, psz);

		DeleteString();
		m_pszString = pszNewString;

		return *this;
	}
	CString &operator = (const char *psz)
	{
		char *pszNewString = new char[strlen(psz) + 1];
		if (pszNewString == 0)
			return *this;
		strcpy(pszNewString, psz);
		DeleteString();
		m_pszString = pszNewString;

		return *this;
	}
	char *Unbind()
	{
		if (m_pszString != __g_pszStringBlank)
		{
			char *psz = m_pszString;
			m_pszString = NULL;
			return psz;
		}
		else
			return DuplicateString();
	}
	char operator[](size_t nIndex) const	//09/17//char operator[](int nIndex) const
	{
		if (nIndex > Length())
			nIndex = Length();
		return m_pszString[nIndex];
	}

	operator const char *() { return m_pszString; }
};


class CMultiString
{
private:
	char *m_pszString;

	void DeleteString() { if (m_pszString != __g_pszStringBlank) delete [] m_pszString; } 
	char *DuplicateString()
	{
		char *psz = new char[Length(m_pszString) + 1];
		if (psz == NULL)
			return NULL;
		memcpy(psz, m_pszString, Length(m_pszString) + 1);
		return psz;
	}
	size_t Length(const char *psz) const	//09/17//int Length(const char *psz) const
	{
		size_t nLen = 0;
		while (*psz != '\0')
		{
			nLen += strlen(psz) + 1;
			psz += strlen(psz) + 1;
		}
		return nLen; 
	}
public:
	CMultiString() 
	{
		m_pszString = __g_pszStringBlank;
	}
	CMultiString (const char *psz)
	{
		m_pszString = new char[strlen(psz) + 1];
		if (m_pszString == NULL)
		{
			m_pszString = __g_pszStringBlank;
		}
		else
		{
			strcpy(m_pszString, psz);
		}
	}
	~CMultiString() { DeleteString(); }
    size_t Length() const //09/17//int Length() const
	{ 
		return Length(m_pszString);
	}
    CMultiString& operator +=(const char *psz)
	{
		size_t nLength = Length() + strlen(psz) + 3;
		char *pszNewString = new char[nLength];
		if (pszNewString == NULL)
			return *this;
		memcpy(pszNewString, m_pszString, Length());
		memcpy(pszNewString + Length(), psz, strlen(psz) + 1);
		pszNewString[Length() + strlen(psz) + 1] = '\0';

		DeleteString();
		m_pszString = pszNewString;

		return *this;
	}

	void AddUnique(const char *pszNew)
	{
		bool bFound = false;
		const char *psz = m_pszString;
		while (psz && *psz)
		{
			if (_stricmp(psz, pszNew) == 0)
			{
				bFound = true;
				break;
			}
			psz += strlen(psz) + 1;
		}
		if (!bFound)
		{
			*this += pszNew;
		}
	}
	char *Unbind()
	{
		if (m_pszString != __g_pszStringBlank)
		{
			char *psz = m_pszString;
			m_pszString = NULL;
			return psz;
		}
		else
			return DuplicateString();
	}
	char operator[](size_t nIndex) const	//09/17//char operator[](int nIndex) const
	{
		if (nIndex > Length())
			nIndex = Length();
		return m_pszString[nIndex];
	}

	operator const char *() { return m_pszString; }

    CMultiString& Empty()
	{
		DeleteString();
		m_pszString = __g_pszStringBlank;
		return *this;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\advanced.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1999 Microsoft Corporation
All rights reserved

Module Name:

    advanced.h

Abstract:

    Public declarations for the Advanced tab of the System Control Panel 
    Applet.

Author:

    Scott Hallock (scotthal) 15-Oct-1997

--*/
#ifndef _SYSDM_ADVANCED_H_
#define _SYSDM_ADVANCED_H_
#pragma once

#include "atlsnap.h"
#include "resource.h"
#include "..\Common\WbemPageHelper.h"

//-----------------------------------------------------------------------------
class AdvancedPage : public CSnapInPropertyPageImpl<AdvancedPage>,
						public WBEMPageHelper
{
private:
	BOOL HandleCommand(HWND hDlg,
						WPARAM wParam,
						LPARAM lParam);
	BOOL HandleNotify(HWND hDlg,
						WPARAM wParam,
						LPARAM lParam);
public:

	AdvancedPage(WbemServiceThread *serviceThread,
				LONG_PTR lNotifyHandle, 
				bool bDeleteHandle = false, 
				TCHAR* pTitle = NULL);

	~AdvancedPage();

	enum { IDD = IDD_ADVANCED };

	typedef CSnapInPropertyPageImpl<AdvancedPage> _baseClass;

	BEGIN_MSG_MAP(AdvancedPage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInit)
		MESSAGE_HANDLER(WM_ASYNC_CIMOM_CONNECTED, OnConnected)
		MESSAGE_HANDLER(WM_HELP, OnF1Help)
		MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextHelp)
		COMMAND_HANDLER(IDC_ADV_PERF_BTN, BN_CLICKED, CommandHandler)
		COMMAND_HANDLER(IDC_ADV_ENV_BTN, BN_CLICKED, CommandHandler)
		COMMAND_HANDLER(IDC_ADV_RECOVERY_BTN, BN_CLICKED, CommandHandler)
		CHAIN_MSG_MAP(_baseClass)
	END_MSG_MAP()

	// Handler prototypes:
	LRESULT OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnConnected(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnF1Help(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

	LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	BOOL OnApply();

	LONG_PTR m_lNotifyHandle;
	bool m_bDeleteHandle;

};


#endif // _SYSDM_ADVANCED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\common.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Shared Dialog code
//
// 3-11-98 sburns


#include "precomp.h"
#include "resource.h"
#include "common.h"



void AppError(HWND           parent,
			   HRESULT        hr,
			   const CHString&  message)
{

   //TODOerror(parent, hr, message, IDS_APP_TITLE);
}

void AppMessage(HWND parent, int messageResID)
{
   //TODOAppMessage(parent, String::load(messageResID));
}

void AppMessage(HWND parent, const CHString& message)
{

   /*TODOMessageBox(parent,
			  message,
			  CHString::load(IDS_APP_TITLE),
			  MB_OK | MB_ICONINFORMATION);
			  */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\common.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Shared Dialog code
//
// 3-11-98 sburns



#ifndef COMMON_HPP_INCLUDED
#define COMMON_HPP_INCLUDED

#include <chstring.h>

void
AppError(
   HWND           parent,
   HRESULT        hr,
   const CHString&  message);



void
AppMessage(HWND parent, const CHString& message);



void
AppMessage(HWND parent, int messageResID);



#endif   // COMMON_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\edtenvar.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1999 Microsoft Corporation
All rights reserved

Module Name:

    edtenvar.h

Abstract:

    Public declarations for the Edit Environment Variables dialog of the
    System Control Panel Applet
    
Author:

    Scott Hallock (scotthal) 11-Nov-1997

Revision History:


--*/
#pragma once

//
// Preprocessor definitions
//
#define SYSTEM_VAR        1
#define USER_VAR          2
#define INVALID_VAR_TYPE  0xeeee

#define EDIT_VAR          1
#define NEW_VAR           2
#define INVALID_EDIT_TYPE 0xeeee

#define EDIT_NO_CHANGE    0
#define EDIT_CHANGE       1
#define EDIT_ERROR       (-1)

#define EDIT_ENVVAR_CAPTION_LENGTH 128

//
// Global variables
//
#define BUFZ        4096

extern UINT g_VarType;
extern UINT g_EditType;
extern TCHAR g_szVarName[BUFZ];
extern TCHAR g_szVarValue[BUFZ];

//
// Function prototypes
//
INT_PTR APIENTRY EnvVarsEditDlg(
						IN HWND hDlg,
						IN UINT uMsg,
						IN WPARAM wParam,
						IN LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\edtenvar.cpp ===
/*++

Microsoft Confidential
Copyright (c) 1992-1999 Microsoft Corporation
All rights reserved

Module Name:

    edtenvar.h

Abstract:

    Implements the Edit Environment Variables dialog of the
    System Control Panel Applet

Author:

    Scott Hallock (scotthal) 11-Nov-1997

Revision History:

--*/
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "edtenvar.h"
#include "resource.h"
#include "..\common\util.h"

// Global Variables
UINT g_VarType = INVALID_VAR_TYPE;
UINT g_EditType = INVALID_EDIT_TYPE;
TCHAR g_szVarName[BUFZ];
TCHAR g_szVarValue[BUFZ];

// Help IDs
/*DWORD aEditEnvVarsHelpIds[] = {
    IDC_ENVVAR_EDIT_NAME_LABEL,  (IDH_ENV_EDIT + 0),
    IDC_ENVVAR_EDIT_NAME,        (IDH_ENV_EDIT + 0),
    IDC_ENVVAR_EDIT_VALUE_LABEL, (IDH_ENV_EDIT + 1),
    IDC_ENVVAR_EDIT_VALUE,       (IDH_ENV_EDIT + 1),
    0, 0
};
*/

// Function prototypes
BOOL InitEnvVarsEdit(HWND hDlg);
BOOL EnvVarsEditHandleCommand(HWND hDlg,
								WPARAM wParam,
								LPARAM lParam);

// Function implementation
//------------------------------------------------
INT_PTR APIENTRY EnvVarsEditDlg(HWND hDlg,
							UINT uMsg,
							WPARAM wParam,
							LPARAM lParam)
/*++

Routine Description:

    Handles messages sent to the New.../Edit... dialog.

Arguments:

    hDlg -
        Supplies the window handle

    uMsg -
        Supplies the message being sent

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled.
    FALSE if message was unhandled.

--*/
{
    BOOL fInitializing = FALSE;

    switch (uMsg) {
        case WM_INITDIALOG: {
            BOOL fSuccess = FALSE;

            fInitializing = TRUE;

            fSuccess = InitEnvVarsEdit(hDlg);
            if (!fSuccess) {
                EndDialog(hDlg, EDIT_ERROR);
            } // if

            fInitializing = FALSE;
            break;
        } // case WM_INITDIALOG

        case WM_COMMAND:
            return EnvVarsEditHandleCommand(hDlg, wParam, lParam);
            break;

        case WM_HELP:      // F1
//            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP, (DWORD) (LPSTR) aEditEnvVarsHelpIds);
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
//            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU, (DWORD) (LPSTR) aEditEnvVarsHelpIds);
            break;

        default:
            return(FALSE);
            break;

    } // switch (uMsg)

    return(TRUE);
}

//------------------------------------------------
BOOL InitEnvVarsEdit(HWND hDlg)
/*++

Routine Description:

    Initializes the Edit Environment Variables dialog by placing initial
    values into the text editing controls if necessary.

Arguments:

    hDlg -
        Supplies window handle

Return Value:

    TRUE if successful
    FALSE if an error occurs

--*/
{
    TCHAR szCaption[EDIT_ENVVAR_CAPTION_LENGTH] = {0};
    BOOL fRetVal = FALSE;
    INT  nResult = 0;

    __try {
        switch (g_EditType) {
            //
            // If this is to be a New.. dialog, we only need to
            // load the proper capiton for the variable type
            //
            case NEW_VAR:

                switch (g_VarType) {
                    case SYSTEM_VAR:
                        nResult = LoadString(
                            HINST_THISDLL,
                            IDS_NEW_SYSVAR_CAPTION,
                            szCaption,
                            EDIT_ENVVAR_CAPTION_LENGTH
                        );
                        break;

                    case USER_VAR:
                        nResult = LoadString(
                            HINST_THISDLL,
                            IDS_NEW_USERVAR_CAPTION,
                            szCaption,
                            EDIT_ENVVAR_CAPTION_LENGTH
                        );
                        break;

                    default:
                        __leave;
                        break;
                } // switch (g_VarType)

                break;

            //
            // If this is to be an Edit.. dialog, then we need to load the
            // proper caption and fill in initial values for the edit
            // controls
            //
            case EDIT_VAR:

                switch (g_VarType) {
                    case SYSTEM_VAR:
                        nResult = LoadString(
                            HINST_THISDLL,
                            IDS_EDIT_SYSVAR_CAPTION,
                            szCaption,
                            EDIT_ENVVAR_CAPTION_LENGTH
                        );
                        break;

                     case USER_VAR:
                        nResult = LoadString(
                            HINST_THISDLL,
                            IDS_EDIT_USERVAR_CAPTION,
                            szCaption,
                            EDIT_ENVVAR_CAPTION_LENGTH
                        );
                        break;
    
                    default:
                         __leave;
                        break;
                } // switch (g_VarType)
        
                SetDlgItemText(
                    hDlg,
                    IDC_ENVVAR_EDIT_NAME,
                    g_szVarName
                );
                SetDlgItemText(
                    hDlg,
                    IDC_ENVVAR_EDIT_VALUE,
                    g_szVarValue
                );
        
                break;
        } // switch (g_EditType)

        fRetVal = SendMessage(
                GetDlgItem(hDlg, IDC_ENVVAR_EDIT_NAME),
                EM_SETSEL,
                0,
                -1
        ) ? TRUE : FALSE;
        fRetVal = SendMessage(
                GetDlgItem(hDlg, IDC_ENVVAR_EDIT_VALUE),
                EM_SETSEL,
                0,
                -1
        ) ? TRUE : FALSE;
        SetFocus(GetDlgItem(hDlg, IDC_ENVVAR_EDIT_NAME));

        fRetVal = SetWindowText(hDlg, szCaption);

    } // __try
    __finally {
        //
        // Nothing to clean up.  __try is only there for __leave on
        // failure capability.
        //
    } // __finally

    return(fRetVal);
}

//------------------------------------------------
BOOL EnvVarsEditHandleCommand(HWND hDlg,
								WPARAM wParam,
							    LPARAM lParam)
/*++

Routine Description:

    Handles WM_COMMAND messages sent to the Edit Environment Variables
    dialog

Arguments:

    hDlg -
        Supplies window handle

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled
    FALSE if message was unhandled

--*/
{
    switch (LOWORD(wParam)) {

        case IDOK:
            GetDlgItemText(
                hDlg,
                IDC_ENVVAR_EDIT_NAME,
                g_szVarName,
                BUFZ
            );
            GetDlgItemText(
                hDlg,
                IDC_ENVVAR_EDIT_VALUE,
                g_szVarValue,
                BUFZ
            );
            EndDialog(hDlg, EDIT_CHANGE);
            break;

        case IDCANCEL:
            EndDialog(hDlg, EDIT_NO_CHANGE);
            break;

        default:
            return(FALSE);
            break;

    } // switch (LOWORD(wParam))

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\cmprops.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// CMProps.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f CMPropsps.mk in the project directory.

#include "precomp.h"
#include "resource.h"
#include "initguid.h"
#include "CMProps.h"
#include "..\common\ServiceThread.h"
#include "CMProps_i.c"
#include "CMSnapin.h"


CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CMSnapin, CCMSnapin)
	OBJECT_ENTRY(CLSID_CMSnapinAbout, CCMSnapinAbout)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		CSnapInItem::Init();
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		_Module.Term();
	}
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\cmsnapin.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "CMProps.h"
#include "CMSnapin.h"
#include "GeneralPage.h"
#include "NetIDPage.h"
#include "Advanced.h"

/////////////////////////////////////////////////////////////////////////////
// CCMSnapinComponentData

static const GUID CCMSnapinExtGUID_NODETYPE = 
{ 0x476e6446, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };

//dep: static const GUID CCMSnapinExtGUID_NODETYPE = 
//{ 0x4e410f16, 0xabc1, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };

const GUID*  CCMSnapinExtData::m_NODETYPE = &CCMSnapinExtGUID_NODETYPE;

//dep: const OLECHAR* CCMSnapinExtData::m_SZNODETYPE = OLESTR("4e410f16-abc1-11d0-b944-00c04fd8d5b0");
const OLECHAR* CCMSnapinExtData::m_SZNODETYPE = OLESTR("476e6446-aaff-11d0-b944-00c04fd8d5b0");

const OLECHAR* CCMSnapinExtData::m_SZDISPLAY_NAME = OLESTR("CMSnapin");
const CLSID* CCMSnapinExtData::m_SNAPIN_CLASSID = &CLSID_CMSnapin;

WbemServiceThread *g_serviceThread = NULL;


HRESULT CCMSnapinExtData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
												LONG_PTR handle, 
												IUnknown* pUnk,
												DATA_OBJECT_TYPES type)
{
//	if (type == CCT_SCOPE || type == CCT_RESULT)
	{
		if(g_serviceThread == NULL)
			g_serviceThread = new WbemServiceThread;
		else
		{
			g_serviceThread->DisconnectServer();
		}

		GeneralPage* pPage = new GeneralPage(g_serviceThread, handle, true, NULL, m_pDataObject);
		lpProvider->AddPage(pPage->Create());

		NetworkIDPage* pPage2 = new NetworkIDPage(g_serviceThread, handle);
		lpProvider->AddPage(pPage2->Create());
		
		AdvancedPage* pPage3 = new AdvancedPage(g_serviceThread, handle);
		lpProvider->AddPage(pPage3->Create());
		
		// TODO : Add code here to add additional pages
		return S_OK;
	}
	return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\envpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "EnvPage.h"

// avoid some warnings.
#undef HDS_HORZ
#undef HDS_BUTTONS
#undef HDS_HIDDEN
#include "resource.h"
#include <stdlib.h>
#include <TCHAR.h>
#include "..\Common\util.h"
#include "..\common\SshWbemHelpers.h"
#include <windowsx.h>
#include <commctrl.h>
#include "edtenvar.h"
#include "helpid.h"

DWORD aEnvVarsHelpIds[] = {
    IDC_ENVVAR_SYS_USERGROUP,     IDH_NO_HELP,
    IDC_ENVVAR_SYS_LB_SYSVARS,    (IDH_ENV + 0),
    IDC_ENVVAR_SYS_SYSVARS,       (IDH_ENV + 0),
    IDC_ENVVAR_SYS_USERENV,       (IDH_ENV + 2),
    IDC_ENVVAR_SYS_LB_USERVARS,   (IDH_ENV + 2),
    IDC_ENVVAR_SYS_NEWUV,         (IDH_ENV + 7),
    IDC_ENVVAR_SYS_EDITUV,        (IDH_ENV + 8),
    IDC_ENVVAR_SYS_NDELUV,        (IDH_ENV + 9),
    IDC_ENVVAR_SYS_NEWSV,         (IDH_ENV + 10),
    IDC_ENVVAR_SYS_EDITSV,        (IDH_ENV + 11),
    IDC_ENVVAR_SYS_DELSV,         (IDH_ENV + 12),
    IDC_USERLIST,				  IDH_WBEM_ADVANCED_ENVARIABLE_USERVAR_LISTBOX,
	0,								0
};

//----------------------------------------------------------------------
INT_PTR CALLBACK StaticEnvDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) 
{ 
	// if this is the initDlg msg...
	if(message == WM_INITDIALOG)
	{
		// transfer the 'this' ptr to the extraBytes.
		SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
	}

	// DWL_USER is the 'this' ptr.
	EnvPage *me = (EnvPage *)GetWindowLongPtr(hwndDlg, DWLP_USER);

	if(me != NULL)
	{
		// call into the DlgProc() that has some context.
		return me->DlgProc(hwndDlg, message, wParam, lParam);
	} 
	else
	{
		return FALSE;
	}
}

//--------------------------------------------------------------
EnvPage::EnvPage(WbemServiceThread *serviceThread)
						: WBEMPageHelper(serviceThread)
{
	m_bEditSystemVars = FALSE;
	m_bUserVars = FALSE;
	m_currUserModified = false;
	m_SysModified = false;

}

//--------------------------------------------------------------
INT_PTR EnvPage::DoModal(HWND hDlg)
{
   return DialogBoxParam(HINST_THISDLL,
						(LPTSTR) MAKEINTRESOURCE(IDD_ENVVARS),
						hDlg, StaticEnvDlgProc, (LPARAM)this);
}

//--------------------------------------------------------------
EnvPage::~EnvPage()
{
}

//--------------------------------------------------------------
INT_PTR CALLBACK EnvPage::DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) 
{ 
    int i;

	m_hDlg = hwndDlg;

	switch (message) 
	{
	case WM_INITDIALOG:
		Init(m_hDlg);
		return TRUE; 
		break;

    case WM_NOTIFY:

        switch(((NMHDR FAR*)lParam)->code)
        {
        case LVN_KEYDOWN:
            switch(((NMHDR FAR*)lParam)->idFrom) 
			{
            case IDC_ENVVAR_SYS_LB_USERVARS:
                i = IDC_ENVVAR_SYS_NDELUV;
                break;
            case IDC_ENVVAR_SYS_LB_SYSVARS:
                i = IDC_ENVVAR_SYS_DELSV;
                break;
            default:
                return(FALSE);
                break;
            } // switch

            if(VK_DELETE == ((LV_KEYDOWN FAR *) lParam)->wVKey) 
			{
				HWND hwnd = GetDlgItem(m_hDlg, i);
				if(IsWindowEnabled(hwnd))
				{
					SendMessage(m_hDlg, WM_COMMAND,
									MAKEWPARAM(i, BN_CLICKED),
									(LPARAM)hwnd );
				}
				else
				{
					MessageBeep(MB_ICONASTERISK);
				}
            } // if (VK_DELETE...
            break;

        case NM_SETFOCUS:
            if(wParam == IDC_ENVVAR_SYS_LB_USERVARS) 
			{
                m_bUserVars = TRUE;
            } 
			else 
			{
                m_bUserVars = FALSE;
            }
            break;

        case NM_DBLCLK:
			{ //BEGIN
				HWND hWndTemp;

				switch(((NMHDR FAR*)lParam)->idFrom) 
				{
				case IDC_ENVVAR_SYS_LB_USERVARS:
					i = IDC_ENVVAR_SYS_EDITUV;
					break;

				case IDC_ENVVAR_SYS_LB_SYSVARS:
					i = IDC_ENVVAR_SYS_EDITSV;
					break;

				default:
					return(FALSE);
					break;
				} // switch

				hWndTemp = GetDlgItem(m_hDlg, i);

				if(IsWindowEnabled(hWndTemp)) 
				{
					SendMessage(m_hDlg, WM_COMMAND, 
								MAKEWPARAM(i, BN_CLICKED),
								(LPARAM)hWndTemp);
				} 
				else 
				{
					MessageBeep(MB_ICONASTERISK);
				}
			}//END
            break;

        default:
            return FALSE;
        } //endswitch(((NMHDR FAR*)lParam)->code)
        break;

    case WM_COMMAND:
        DoCommand(m_hDlg, (HWND)lParam, LOWORD(wParam), HIWORD(wParam));
        break;

    case WM_DESTROY:
        CleanUp(m_hDlg);
        break;

    case WM_HELP:      // F1
		::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
					L"sysdm.hlp", 
					HELP_WM_HELP, 
					(ULONG_PTR)(LPSTR)aEnvVarsHelpIds);

        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, 
					HELP_FILE, HELP_CONTEXTMENU, 
					(ULONG_PTR)(LPSTR)aEnvVarsHelpIds);
        break;

    default:
        return FALSE;
    }

	return FALSE; 
}

//------------------------------------------------------------
int EnvPage::AddUniqueUser(HWND hwnd, LPCTSTR str)
{
	// if it doesn't already exist...
	if(ComboBox_FindStringExact(hwnd, -1, str) == CB_ERR)
	{
		// add it.
		return ComboBox_AddString(hwnd, str);
	}
	return -1;
}

//------------------------------------------------------------
#define MAX_USER_NAME   100
#define BUFZ        4096
#define MAX_VALUE_LEN     1024
TCHAR szSysEnv[]  = TEXT( "System\\CurrentControlSet\\Control\\Session Manager\\Environment" );

BOOL EnvPage::Init(HWND hDlg)
{
    TCHAR szBuffer1[200] = {0};
    HWND hwndSys, hwndUser, hwndUserList;
	HRESULT hr = 0;

    LV_COLUMN col;
    LV_ITEM item;
    RECT rect;
    int cxFirstCol;

	IWbemClassObject *envInst = NULL;
	IEnumWbemClassObject *envEnum = NULL;
	bool bSysVar = false;
	DWORD uReturned = 0;
	bstr_t sSysUser("<SYSTEM>");  // magic string returned by provider
	bstr_t sUserName("UserName");
	bstr_t userName, firstUser;
	variant_t pVal, pVal1;

    // Create the first column
    LoadString(HINST_THISDLL, SYSTEM + 50, szBuffer1, 200);

    if (!GetClientRect(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS), &rect)) 
	{
        rect.right = 300;
    }

    cxFirstCol = (int)(rect.right * .3);

    col.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.cx = cxFirstCol;
    col.pszText = szBuffer1;
    col.iSubItem = 0;

    SendDlgItemMessage(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS, LVM_INSERTCOLUMN,
                        0, (LPARAM) &col);
    SendDlgItemMessage(hDlg, IDC_ENVVAR_SYS_LB_USERVARS, LVM_INSERTCOLUMN,
                        0, (LPARAM) &col);

    // Create the second column
    LoadString(HINST_THISDLL, SYSTEM + 51, szBuffer1, 200);

    col.cx = rect.right - cxFirstCol - GetSystemMetrics(SM_CYHSCROLL);
    col.iSubItem = 1;

    SendDlgItemMessage(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS, LVM_INSERTCOLUMN,
                        1, (LPARAM) &col);
    SendDlgItemMessage(hDlg, IDC_ENVVAR_SYS_LB_USERVARS, LVM_INSERTCOLUMN,
                        1, (LPARAM) &col);

    ////////////////////////////////////////////////////////////////////
    // Display System Variables from wbem in listbox
    ////////////////////////////////////////////////////////////////////
    hwndSys = GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS);
    hwndUser = GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS);
    hwndUserList = GetDlgItem(hDlg, IDC_USERLIST);

    //  Try to open the System Environment variables area with
    //  Read AND Write permission.  If successful, then we allow
    //  the User to edit them the same as their own variables.
	m_bEditSystemVars = FALSE;
	RemoteRegWriteable(szSysEnv, m_bEditSystemVars);


    // Disable System Var Editing buttons if
    // user is not an administrator
    //
    EnableWindow(GetDlgItem(hDlg, IDC_ENVVAR_SYS_NEWSV),
					m_bEditSystemVars);
    EnableWindow(GetDlgItem(hDlg, IDC_ENVVAR_SYS_EDITSV),
					m_bEditSystemVars);
    EnableWindow(GetDlgItem(hDlg, IDC_ENVVAR_SYS_DELSV),
					m_bEditSystemVars);

	if(g_serviceThread->m_machineName.length() > 0)
		m_bLocal = false;
	else
		m_bLocal = true;

	if((hr = m_WbemServices.CreateInstanceEnum(bstr_t("Win32_Environment"), 
												WBEM_FLAG_SHALLOW, 
												&envEnum)) == S_OK)
	{
		// get the first and only instance.
		while(SUCCEEDED(envEnum->Next(-1, 1, &envInst, &uReturned)) && 
			  (uReturned != 0))
		{
			//Get whether the 
			// who's variable.
			if(envInst->Get(sUserName, 0L, &pVal, NULL, NULL) == S_OK) 
			{
				userName = V_BSTR(&pVal);

				 // setup for which list box gets this instance.
				if(userName == sSysUser)
				{
					LoadUser(envInst, userName, hwndSys);
				}
				else 
				{
					if(m_bLocal == false)
					{
						if((firstUser.length() == 0) ||	// if the first user seen.
							(firstUser == userName))		// if seeing the firstUser again.
						{
							// save the first user.
							if(firstUser.length() == 0)
							{
								firstUser = userName;
							}
							AddUniqueUser(hwndUserList, userName);
							LoadUser(envInst, userName, hwndUser);
						}
						else
						{
							AddUniqueUser(hwndUserList, userName);
						}
					}
					else
					{
						if(IsLoggedInUser(userName))
						{
							if(firstUser.length() == 0)
							{
								firstUser = userName;
							}
							AddUniqueUser(hwndUserList, userName);
							LoadUser(envInst, userName, hwndUser);
						}
						else
						{
							AddUniqueUser(hwndUserList, userName);
						}
					}
				}
			} //endif who's variable.

			envInst->Release();

		} // endwhile envEnum

		envEnum->Release();

		if(m_bLocal == false)
		{
			ComboBox_SetCurSel(hwndUserList, 0);
		}
		else
		{
			_bstr_t strLoggedinUser;
			GetLoggedinUser(&strLoggedinUser);
			SendMessage(hwndUserList,CB_SELECTSTRING,-1L,(LPARAM)(LPCTSTR)strLoggedinUser);
		}
	} //endif CreateInstanceEnum()

    // Select the first items in the listviews
    // It is important to set the User listview first, and
    // then the system.  When the system listview is set,
    // we will receive a LVN_ITEMCHANGED notification and
    // clear the focus in the User listview.  But when someone
    // tabs to the control the arrow keys will work correctly.
    item.mask = LVIF_STATE;
    item.iItem = 0;
    item.iSubItem = 0;
    item.state = LVIS_SELECTED | LVIS_FOCUSED;
    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

    SendDlgItemMessage(hDlg, IDC_ENVVAR_SYS_LB_USERVARS,
                        LVM_SETITEMSTATE, 0, (LPARAM) &item);

    SendDlgItemMessage (hDlg, IDC_ENVVAR_SYS_LB_SYSVARS,
                        LVM_SETITEMSTATE, 0, (LPARAM) &item);

    EnableWindow(GetDlgItem(hDlg, IDC_ENVVAR_SYS_SETUV), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_ENVVAR_SYS_DELUV), FALSE);

    // Set extended LV style for whole line selection
    SendDlgItemMessage(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);
    SendDlgItemMessage(hDlg, IDC_ENVVAR_SYS_LB_USERVARS, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//  FindVar
//
//  Find the USER Environment variable that matches passed string
//  and return its listview index or -1
//
////////////////////////////////////////////////////////////////////////////
int EnvPage::FindVar(HWND hwndLV, LPTSTR szVar)
{
    LV_FINDINFO FindInfo;

    FindInfo.flags = LVFI_STRING;
    FindInfo.psz = szVar;

    return ((int)SendMessage (hwndLV, LVM_FINDITEM, (WPARAM) -1, (LPARAM) &FindInfo));
}

////////////////////////////////////////////////////////////////////////////
//  Saves the environment variables
////////////////////////////////////////////////////////////////////////////
void EnvPage::Save(HWND hDlg, int ID)
{
    int     i, n;
    HWND    hwndTemp;
    ENVARS *penvar;
	CWbemClassObject inst;
	bstr_t sSysUser("<SYSTEM>");  // magic string returned by provider
	bstr_t sUserName("UserName");
	bstr_t sVarName("Name");
	bstr_t sVarVal("VariableValue");
	bstr_t sSysVar("SystemVariable");
	HRESULT hr = 0;
    LV_ITEM item;
    item.mask = LVIF_PARAM;
    item.iSubItem = 0;

	// purge the kill list.
	KillThemAllNow();

    hwndTemp = GetDlgItem (hDlg, ID);
    n = (int)SendMessage (hwndTemp, LVM_GETITEMCOUNT, 0, 0L);

    for(i = 0; i < n; i++) 
	{
        item.iItem = i;

        if(SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) 
		{
            penvar = (ENVARS *) item.lParam;

			// if something changed.
			if(penvar->changed)
			{
				// if we need a new class object...
				if(penvar->objPath == NULL)
				{
					// must be a new one.
					CWbemClassObject cl = m_WbemServices.GetObject("Win32_Environment");
					inst = cl.SpawnInstance();
				}
				else
				{
					// get the old one.
					inst = m_WbemServices.GetObject(penvar->objPath);
				}

				if(!inst.IsNull())
				{
					if(ID == IDC_ENVVAR_SYS_LB_SYSVARS)
					{
						hr = inst.Put(sUserName, sSysUser);
						hr = inst.Put(sSysVar, true);
					}
					else if(ID == IDC_ENVVAR_SYS_LB_USERVARS)
					{
						hr = inst.Put(sUserName, m_currentUser);
						hr = inst.Put(sSysVar, false);
					}
					else
					{
						continue;
					}
					hr = inst.Put(sVarName, bstr_t(penvar->szValueName));
					hr = inst.Put(sVarVal, bstr_t(penvar->szExpValue));
					hr = m_WbemServices.PutInstance(inst);
				}
	
			} //endif changed
        } 

    } //endfor
}

////////////////////////////////////////////////////////////////////////////
//  EmptyListView
//
//  Frees memory allocated for environment variables
//
//  History:
//  19-Jan-1996 EricFlo Wrote it
////////////////////////////////////////////////////////////////////////////
void EnvPage::EmptyListView(HWND hDlg, int ID)
{
    int     i, n;
    HWND    hwndTemp;
    ENVARS *penvar;
    LV_ITEM item;

    //  Free alloc'd strings and memory for list box items.
    hwndTemp = GetDlgItem (hDlg, ID);
    n = (int) SendMessage (hwndTemp, LVM_GETITEMCOUNT, 0, 0L);

    item.mask = LVIF_PARAM;
    item.iSubItem = 0;

    for(i = 0; i < n; i++) 
	{
        item.iItem = i;

        if(SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) 
		{
            penvar = (ENVARS *) item.lParam;
        } 
		else 
		{
            penvar = NULL;
        }

        delete penvar;
    }
	ListView_DeleteAllItems(hwndTemp);
}

//------------------------------------------------------------
void EnvPage::CleanUp (HWND hDlg)
{
	EmptyListView(hDlg, IDC_ENVVAR_SYS_LB_USERVARS);
	EmptyListView(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS);
}

//----------------------------------------------------------------------
void EnvPage::DeleteVar(HWND hDlg,
						UINT VarType,
						LPCTSTR szVarName)
/*++

Routine Description:

    Deletes an environment variable of a given name and type

Arguments:

    hDlg -
        Supplies window handle

    VarType -
        Supplies variable type (user or system)

    szVarName -
        Supplies variable name

Return Value:

    None, although it really should have one someday.

--*/
{
    TCHAR   szTemp2[MAX_PATH] = {0};
    int     i, n;
    HWND    hwndTemp;
    ENVARS *penvar;
    LV_ITEM item;

    // Delete listbox entry that matches value in szVarName
    //  If found, delete entry else ignore
    wsprintf(szTemp2, TEXT("%s"), szVarName);

    if(szTemp2[0] == TEXT('\0'))
        return;

    //  Determine which Listbox to use (SYSTEM or USER vars)
    switch(VarType) 
	{
    case SYSTEM_VAR:
        i = IDC_ENVVAR_SYS_LB_SYSVARS;
        break;

    case USER_VAR:
    default:
        i = IDC_ENVVAR_SYS_LB_USERVARS;
        break;

    } // switch (VarType)

    hwndTemp = GetDlgItem(hDlg, i);

    n = FindVar(hwndTemp, szTemp2);

    if(n != -1)
    {
        // Free existing strings (listbox and ours)
        item.mask = LVIF_PARAM;
        item.iItem = n;
        item.iSubItem = 0;

        if(SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) 
		{
            penvar = (ENVARS *) item.lParam;

			// if cimom knows about it...
			if(penvar->objPath != NULL) 
			{
				// queue for later DeleteInstance().
				KillLater(penvar);

				if(m_bUserVars)
					m_currUserModified = true;
				else
					m_SysModified = true;

			}
			else // user must have added it and changed his mind..
			{
				// just forget about it.
				penvar = (ENVARS *) item.lParam;
		        delete penvar;
			} 
        } 
		else 
		{
            penvar = NULL;
        }

        SendMessage (hwndTemp, LVM_DELETEITEM, n, 0L);
        PropSheet_Changed(GetParent(hDlg), hDlg);

        // Fix selection state in listview
        if(n > 0) 
		{
            n--;
        }

        item.mask = LVIF_STATE;
        item.iItem = n;
        item.iSubItem = 0;
        item.state = LVIS_SELECTED | LVIS_FOCUSED;
        item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

        SendDlgItemMessage(hDlg, i,
                            LVM_SETITEMSTATE, n, (LPARAM) &item);

    }
}

//----------------------------------------------------------------------
void EnvPage::SetVar(HWND hDlg,
						UINT VarType,
						LPCTSTR szVarName,
						LPCTSTR szVarValue)
/*++

Routine Description:

    Given an environment variable's type (system or user), name, and value,
    creates a ENVVARS structure for that environment variable and inserts
    it into the proper list view control, deleteing any existing variable
    of the same name.

Arguments:

    hDlg -
        Supplies window handle

    VarType -
        Supplies the type of the environment variable (system or user)

    szVarName -
        Supplies the name of the environment variable

    szVarValue -
        Supplies the value of the environment variable

Return Value:

    None, although it really should have one someday.

--*/
{
    TCHAR   szTemp2[MAX_PATH] = {0};
    int     i, n;
    TCHAR  *bBuffer;
    TCHAR  *pszTemp;
    LPTSTR  pszString;
    HWND    hwndTemp;
    int     idTemp;
    ENVARS *penvar = NULL;
    LV_ITEM item;

    wsprintf(szTemp2, TEXT("%s"), szVarName);

    //  Strip trailing whitespace from end of Env Variable
    i = lstrlen(szTemp2) - 1;

    while(i >= 0)
    {
        if (_istspace(szTemp2[i]))
            szTemp2[i--] = TEXT('\0');
        else
            break;
    }

    // Make sure variable name does not contain the "=" sign.
    pszTemp = _tcspbrk (szTemp2, TEXT("="));

    if(pszTemp)
        *pszTemp = TEXT('\0');

    if(szTemp2[0] == TEXT('\0'))
        return;

    bBuffer = new TCHAR[BUFZ];
    pszString = (LPTSTR)new TCHAR[BUFZ];

    wsprintf(bBuffer, TEXT("%s"), szVarValue);

    //  Determine which Listbox to use (SYSTEM or USER vars)
    switch (VarType) 
	{
    case SYSTEM_VAR:
        idTemp = IDC_ENVVAR_SYS_LB_SYSVARS;
        break;

    case USER_VAR:
    default:
        idTemp = IDC_ENVVAR_SYS_LB_USERVARS;
        break;

    } // switch (VarType)

    hwndTemp = GetDlgItem(hDlg, idTemp);

    n = FindVar(hwndTemp, szTemp2);

    if (n != -1)
    {
        // Free existing strings (listview and ours)
        item.mask = LVIF_PARAM;
        item.iItem = n;
        item.iSubItem = 0;

        if(SendMessage(hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) 
		{
			// we're just changing an old one.
            penvar = (ENVARS *) item.lParam;
            delete penvar->szValueName;
            delete penvar->szValue;
            delete penvar->szExpValue;
        } 
		else 
		{
            penvar = NULL;
        }

        SendMessage (hwndTemp, LVM_DELETEITEM, n, 0L);
    }
    else
    {
        // Get some storage for new EnVar.
        penvar = new ENVARS;
	if (penvar == NULL)
		return;
	penvar->userName = CloneString(m_currentUser);
    }

	if((m_bLocal == true) && ((VarType == SYSTEM_VAR) || (IsLoggedInUser(penvar->userName))))
	{
		ExpandEnvironmentStrings(bBuffer, pszString, BUFZ);
	}
	else
	{
		_tcscpy(pszString,bBuffer);
	}

    if (penvar == NULL)
	return;
    penvar->szValueName = CloneString(szTemp2);
    penvar->szValue     = CloneString(bBuffer);
    penvar->szExpValue  = CloneString(pszString);
	penvar->changed		= true;

    item.mask = LVIF_TEXT | LVIF_PARAM;
    item.iItem = ListView_GetItemCount(hwndTemp);
    item.iSubItem = 0;
    item.pszText = penvar->szValueName;
    item.lParam = (LPARAM) penvar;

    n = (int) SendMessage(hwndTemp, LVM_INSERTITEM, 0, (LPARAM) &item);

    if (n != -1) 
	{
        item.mask = LVIF_TEXT;
        item.iItem = n;
        item.iSubItem = 1;
        item.pszText = penvar->szExpValue;

        SendMessage(hwndTemp, LVM_SETITEMTEXT, n, (LPARAM) &item);

        item.mask = LVIF_STATE;
        item.iItem = n;
        item.iSubItem = 0;
        item.state = LVIS_SELECTED | LVIS_FOCUSED;
        item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

        SendDlgItemMessage(hDlg, idTemp,
                            LVM_SETITEMSTATE, n, (LPARAM) &item);
    }

    delete bBuffer;
    delete pszString;

	if(m_bUserVars)
		m_currUserModified = true;
	else
		m_SysModified = true;

}

//----------------------------------------------------------------------
void EnvPage::DoEdit(HWND hWnd,
						UINT VarType,
						UINT EditType,
						int iSelection)
/*++

Routine Description:

    Sets up for, executes, and cleans up after an Environment Variable
    New... or Edit... dialog.  Called when user presses a New... or Edit...
    button.

Arguments:

    hWnd -
        Supplies window handle

    VarType -
        Supplies the type of the variable:  User (USER_VAR) or 
        System (SYSTEM_VAR)

    EditType -
        Supplies the type of the edit:  create New (NEW_VAR) or 
        Edit existing (EDIT_VAR)

    iSelection -
        Supplies the currently selected variable of type VarType.  This
        value is ignored if EditType is NEW_VAR.

Return Value:

    None.  May alter the contents of a list view control as a side effect.

--*/
{
    INT_PTR Result = 0;
    BOOL fVarChanged = FALSE;
    HWND hWndLB = NULL;
    ENVARS *penvar = NULL;

    g_VarType = VarType;
    g_EditType = EditType;

    penvar = GetVar(hWnd, VarType, iSelection);

	// init the edit dialog controls.
    switch(EditType) 
	{
    case NEW_VAR:

        ZeroMemory((LPVOID) g_szVarName, (DWORD) BUFZ * sizeof(TCHAR));
        ZeroMemory((LPVOID) g_szVarValue, (DWORD) BUFZ * sizeof(TCHAR));
        break;

    case EDIT_VAR:

        if(penvar) 
		{
            wsprintf(g_szVarName, TEXT("%s"), penvar->szValueName);
            wsprintf(g_szVarValue, TEXT("%s"), penvar->szValue);
		}
		else
		{
			MessageBeep(MB_ICONASTERISK);
			return;
        } // if
        break;

    case INVALID_EDIT_TYPE:
    default:
        return;
    } // switch
    
	// call the edit dialog.
    Result = DialogBox(HINST_THISDLL,
						(LPTSTR) MAKEINTRESOURCE(IDD_ENVVAREDIT),
						hWnd, EnvVarsEditDlg);

	// figure out what was changed.
	bool nameChanged = false;
    bool valueChanged = false;

    // Only update the list view control if the user
    // actually changed or created a variable
    switch (Result) 
	{
    case EDIT_CHANGE:

        if(EDIT_VAR == EditType) 
		{
			nameChanged = (lstrcmp(penvar->szValueName, g_szVarName) != 0);
			valueChanged = (lstrcmp(penvar->szValue, g_szVarValue) != 0);
        }
        else if(NEW_VAR == EditType)
		{
            nameChanged = (lstrlen(g_szVarName) != 0);
			valueChanged = (lstrlen(g_szVarValue) != 0);
        }

		 // if the name changed, its a whole new wbem class object.
		if(nameChanged)
		{
            if(EDIT_VAR == EditType) 
			{
				DeleteVar(hWnd, VarType, penvar->szValueName);
			}
            SetVar(hWnd, VarType, g_szVarName, g_szVarValue);
		}
        else if(valueChanged)
		{
			// keep the class object but change the value.
            SetVar(hWnd, VarType, g_szVarName, g_szVarValue);
		}

		// if anything changed...
		if(nameChanged || valueChanged)
		{
			// set the list's dirty flag.
			if(VarType == SYSTEM_VAR)
			{
				m_SysModified = true;
			}
			else if(VarType == USER_VAR)
			{
				m_currUserModified = true;
			}
        }
        break;

    default: 
		break;
    } // endswitch (Result)

    g_VarType = INVALID_VAR_TYPE;
    g_EditType = INVALID_EDIT_TYPE;
}

//-------------------------------------------------
EnvPage::ENVARS *EnvPage::GetVar(HWND hDlg, 
						UINT VarType, 
						int iSelection)
/*++

Routine Description:

    Returns a given System or User environment variable, as stored
    in the System or User environment variable listview control.

    Changing the structure returned by this routine is not
    recommended, because it will alter the values actually stored
    in the listview control.

Arguments:

    hDlg -
        Supplies window handle

    VarType -
        Supplies variable type--System or User

    iSelection -
        Supplies the selection index into the listview control of
        the desired environment variable

Return Value:

    Pointer to a valid ENVARS structure if successful.

    NULL if unsuccessful.

--*/
{
    HWND hWndLB = NULL;
    ENVARS *penvar = NULL;
    LV_ITEM item;

    switch(VarType) 
	{
    case SYSTEM_VAR:
        hWndLB = GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS);
        break;

    case USER_VAR:
        hWndLB = GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS);
        break;

    case INVALID_VAR_TYPE:
    default:
        return NULL;
    } // switch (VarType)

    item.mask = LVIF_PARAM;
    item.iItem = iSelection;
    item.iSubItem = 0;
    if (SendMessage (hWndLB, LVM_GETITEM, 0, (LPARAM) &item)) 
	{
        penvar = (ENVARS *) item.lParam;
    } 
	else 
	{
        penvar = NULL;
    }
    
    return(penvar);
}

//----------------------------------------------------------------------
void EnvPage::DoCommand(HWND hDlg, HWND hwndCtl, int idCtl, int iNotify )
{
    int     i;
    ENVARS *penvar = NULL;

    switch (idCtl) 
	{
    case IDOK:
		if(m_currUserModified)
		{
			Save(m_hDlg, IDC_ENVVAR_SYS_LB_USERVARS);
			m_currUserModified = false;
		}
		if(m_SysModified)
		{
			Save(m_hDlg, IDC_ENVVAR_SYS_LB_SYSVARS);
			m_SysModified = false;
		}

        EndDialog(hDlg, 0);
        break;

    case IDCANCEL:
        EndDialog(hDlg, 0);
        break;

    case IDC_ENVVAR_SYS_EDITSV:
        DoEdit(hDlg, SYSTEM_VAR, EDIT_VAR, 
					GetSelectedItem(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS)));

        SetFocus(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS));
        break;

    case IDC_ENVVAR_SYS_EDITUV:
        DoEdit(hDlg, USER_VAR, EDIT_VAR,
					GetSelectedItem(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS)));

        SetFocus(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS));
        break;

    case IDC_ENVVAR_SYS_NEWSV:
        DoEdit(hDlg, SYSTEM_VAR, NEW_VAR, -1);
        SetFocus(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS));
        break;

    case IDC_ENVVAR_SYS_NEWUV:
        DoEdit(hDlg, USER_VAR, NEW_VAR, -1); 
        SetFocus(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS));
        break;

    case IDC_ENVVAR_SYS_DELSV:
        i = GetSelectedItem(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS));
        if(-1 != i) 
		{
            penvar = GetVar(hDlg, SYSTEM_VAR, i);
	    if (penvar)
            	DeleteVar(hDlg, SYSTEM_VAR, penvar->szValueName);
        } // endif

        SetFocus(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS));
        break;

    case IDC_ENVVAR_SYS_NDELUV:
        i = GetSelectedItem(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS));
        if(-1 != i) 
		{
            penvar = GetVar(hDlg, USER_VAR, i);
            if (penvar)
		DeleteVar(hDlg, USER_VAR, penvar->szValueName);
        } // endif

        SetFocus(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS));
        break;

	// the combobox of user names.
	case IDC_USERLIST:
		{//BEGIN

			TCHAR userName[100] = {0};
			bstr_t sNewUser, sThisName;
			HRESULT hr = 0;
			IWbemClassObject *envInst = NULL;
			IEnumWbemClassObject *envEnum = NULL;
			DWORD uReturned = 0;
			bstr_t sUserName("UserName");
			variant_t pVal;
			int idx, changeMsg = IDNO;
		
			if (iNotify == CBN_SELENDOK)
			{
				// see if the user want to save his changes.
				if(m_currUserModified)
				{
					changeMsg = MsgBoxParam(m_hDlg, 
											IDS_CHANGINGUSER, IDS_TITLE, 
											MB_YESNOCANCEL | MB_ICONEXCLAMATION);
				}

				// well does he?
				switch(changeMsg)
				{
				case IDCANCEL:
					// stay put.
					return;
				case IDYES:
					Save(m_hDlg, IDC_ENVVAR_SYS_LB_USERVARS);
					// NOTE: after saving. allow to fall through to repopulate the list.

				case IDNO:

					// reset contents here.
					EmptyListView(hDlg, IDC_ENVVAR_SYS_LB_USERVARS);
					
					m_currUserModified = false;

					// get new user's name.
					idx = ComboBox_GetCurSel(hwndCtl);
					if(ComboBox_GetLBText(hwndCtl, idx, userName))
					{
						sNewUser = userName;

						HWND hwndUser = GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS);

						// load his variables.
						if((hr = m_WbemServices.CreateInstanceEnum(bstr_t("Win32_Environment"), 
																	WBEM_FLAG_SHALLOW, 
																	&envEnum)) == S_OK)
						{
							// get the instance
							while(SUCCEEDED(envEnum->Next(-1, 1, &envInst, &uReturned)) && 
								  (uReturned != 0))
							{
								// who's variable.
								if (envInst->Get(sUserName, 0L, &pVal, NULL, NULL) == S_OK) 
								{
									 sThisName = V_BSTR(&pVal);

									 // setup for which list box gets this instance.
									if(sThisName == sNewUser)
									{
										LoadUser(envInst, sThisName, hwndUser);

									} //endif(sThisName == sNewUser)

								} //endif (envInst->Get(sUserName,

								envInst->Release();

							} // endwhile envEnum

							envEnum->Release();

						} //endif CreateInstanceEnum()

					} //endif(ComboBox_GetText

				}//end switch(Messagebox())

			} //endif (iNotify == CBN_SELCHANGE)

		}//END
		break;

    default:
        break;
    }
}

//---------------------------------------------------------------------------
void EnvPage::LoadUser(IWbemClassObject *envInst, 
						bstr_t userName, 
						HWND hwndUser)
{
	bstr_t sVarName("Name");
	bstr_t sVarVal("VariableValue");
	bstr_t sPath("__PATH");
	bstr_t sSysUser("<SYSTEM>");  // magic string returned by provider
	variant_t pVal, pVal1, pVal2;
	ENVARS *penvar = NULL;
	bstr_t  pszValue;
	bstr_t szTemp;
	bstr_t objPath;
	TCHAR  pszString[MAX_VALUE_LEN] = {0};
	int     n;
	LV_ITEM item;
	DWORD dwIndex = 0;

	m_currentUser = userName;

	// get the variable.
	if ((envInst->Get(sVarVal, 0L, &pVal, NULL, NULL) == S_OK) &&
		(envInst->Get(sVarName, 0L, &pVal1, NULL, NULL) == S_OK) &&
		(envInst->Get(sPath, 0L, &pVal2, NULL, NULL) == S_OK)) 
	{
		// extract.
		pszValue = V_BSTR(&pVal);
		szTemp = V_BSTR(&pVal1);
		objPath = V_BSTR(&pVal2);

		// store with list item.
		penvar = new ENVARS;
		if (penvar == NULL) //outofmemory
			return;

		penvar->objPath		= CloneString(objPath);
		penvar->userName	= CloneString(userName);
		penvar->szValueName = CloneString( szTemp );
		penvar->szValue     = CloneString( pszValue );

		if((m_bLocal == true) && ((userName == sSysUser) || (IsLoggedInUser(userName))))
		{
			ExpandEnvironmentStrings(pszValue, pszString, MAX_VALUE_LEN);
		}
		else
		{
			_tcscpy(pszString,pszValue);
		}

		penvar->szExpValue  = CloneString( pszString );
		penvar->changed		= false;

		// put in first column value (name).
		item.mask = LVIF_TEXT | LVIF_PARAM;
		item.iItem = (dwIndex - 1);
		item.iSubItem = 0;
		item.pszText = penvar->szValueName;
		item.lParam = (LPARAM) penvar;

		n = (int)SendMessage(hwndUser, LVM_INSERTITEM, 0, (LPARAM) &item);

		// did it go?
		if (n != -1) 
		{
			// do the second column value.
			item.mask = LVIF_TEXT;
			item.iItem = n;
			item.iSubItem = 1;
			item.pszText = penvar->szExpValue;

			SendMessage(hwndUser, LVM_SETITEMTEXT, n, (LPARAM) &item);
		}
	}
}

//---------------------------------------------------------------------------
bool EnvPage::IsLoggedInUser(bstr_t userName)
{
	TCHAR strUserName[1024];
	TCHAR strDomain[1024];
	_tcscpy(strDomain,_T(""));
	DWORD dwSize = 1024;
	DWORD dwDomSize = 1024;
	DWORD dwSidSize = 0;
	BYTE *buff;
	
	SID *sid = NULL;
	SID_NAME_USE sidName;
	
	if (&userName == NULL)
		return false;

	GetUserName(strUserName,&dwSize);
	LookupAccountName(NULL,strUserName,sid,&dwSidSize,strDomain,&dwDomSize,&sidName);
	
	buff = new BYTE[dwSidSize];
	sid = (SID *)buff;
	
	BOOL bFlag = LookupAccountName(NULL,strUserName,sid,&dwSidSize,strDomain,&dwDomSize,&sidName);
	delete []buff;
	_tcscat(strDomain,_T("\\"));
	_tcscat(strDomain,strUserName);

	if(_tcsicmp(strDomain,userName) == 0)
		return true;
	else
		return false;
}

//---------------------------------------------------------------------------
void EnvPage::GetLoggedinUser(bstr_t *userName)
{
	TCHAR strUserName[1024];
	TCHAR strDomain[1024];
	_tcscpy(strDomain,_T(""));
	DWORD dwSize = 1024;
	DWORD dwDomSize = 1024;
	DWORD dwSidSize = 0;
	BYTE *buff;
	
	SID *sid = NULL;
	SID_NAME_USE sidName;
	
	GetUserName(strUserName,&dwSize);
	LookupAccountName(NULL,strUserName,sid,&dwSidSize,strDomain,&dwDomSize,&sidName);
	
	buff = new BYTE[dwSidSize];
	sid = (SID *)buff;
	
	BOOL bFlag = LookupAccountName(NULL,strUserName,sid,&dwSidSize,strDomain,&dwDomSize,&sidName);
	delete []buff;
	_tcscat(strDomain,_T("\\"));
	_tcscat(strDomain,strUserName);
	
	*userName = strDomain;

}

//---------------------------------------------------------------------------
void EnvPage::KillLater(ENVARS *var)
{
	// remember this guy.
	m_killers.Add(var);
}

//---------------------------------------------------------------------------
void EnvPage::KillThemAllNow(void)
{
	ENVARS *var = NULL;

	if(m_killers.GetSize() > 0)
	{
		for(int it = 0; it < m_killers.GetSize(); it++)
		{
			var = m_killers[it];
			if(var->objPath != NULL)
			{
				m_WbemServices.DeleteInstance(var->objPath);
			}
			delete var;
		}
		m_killers.RemoveAll();
	}
}

//------------------------------------------------------------------------
int EnvPage::GetSelectedItem(HWND hCtrl)
{
    int i, n;

    n = (int)SendMessage(hCtrl, LVM_GETITEMCOUNT, 0, 0L);

    if (n != LB_ERR)
    {
        for (i = 0; i < n; i++)
        {
            if (SendMessage(hCtrl, LVM_GETITEMSTATE,
                             i, (LPARAM) LVIS_SELECTED) == LVIS_SELECTED) 
			{
                return i;
            }
        }
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\cmsnapin.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __CMSNAPIN_H_
#define __CMSNAPIN_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include <atlsnap.h>
#include "..\common\ServiceThread.h"


class CCMSnapinExtData : public CSnapInItemImpl<CCMSnapinExtData, TRUE>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;


	CCMSnapinExtData()
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	}

	~CCMSnapinExtData()
	{
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
									LONG_PTR handle, 
									IUnknown* pUnk,
									DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}

	IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		// Modify to return a different CSnapInItem* pointer.
		return pDefault;
	}

};

class CCMSnapin : public CComObjectRootEx<CComSingleThreadModel>,
					public CSnapInObjectRoot<0, CCMSnapin>,
					public IExtendPropertySheetImpl<CCMSnapin>,
					public CComCoClass<CCMSnapin, &CLSID_CMSnapin>,
					public ISnapinHelp
{
public:
	CCMSnapin()
	{
		m_pComponentData = this;
	}

EXTENSION_SNAPIN_DATACLASS(CCMSnapinExtData)

BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CCMSnapin)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CCMSnapinExtData)
END_EXTENSION_SNAPIN_NODEINFO_MAP()

BEGIN_COM_MAP(CCMSnapin)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

//DECLARE_REGISTRY_RESOURCEID(IDR_CMSNAPIN)

DECLARE_NOT_AGGREGATABLE(CCMSnapin)

	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
	{
		HRESULT hr;
		TCHAR pName[100] = {0};
		if(::LoadString(_Module.GetModuleInstance(), IDS_DISPLAY_NAME, 
			pName, 100) <= 0)
		{
			wcscpy(pName, _T("System Properties"));
		}

		TCHAR dispName[100] = {0};
        TCHAR szModule[_MAX_PATH];
        ::GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
        _stprintf( dispName,_T("@%s,-%d"), szModule, IDS_DISPLAY_NAME);

		
		_ATL_REGMAP_ENTRY regMap[] = {{ OLESTR("PRETTYNAME"), pName },
										{ OLESTR("NAMESTRINGINDIRECT"),dispName},
										{ 0, 0 }};

		hr = _Module.UpdateRegistryFromResourceD(IDR_CMSNAPIN, TRUE, regMap);

		return hr;
	}


	static void WINAPI ObjectMain(bool bStarting)
	{
		if (bStarting)
			CSnapInItem::Init();
	}
    STDMETHOD(GetHelpTopic)(LPOLESTR *lpCompiledHelpFile)
	{
		if(lpCompiledHelpFile == NULL)
			return E_POINTER;    

		wchar_t helpDir[_MAX_PATH];
		memset(helpDir, 0, _MAX_PATH);

		if(GetWindowsDirectory(helpDir, _MAX_PATH) != 0)
		{
			wcscat(helpDir, L"\\Help");
			wcscat(helpDir, L"\\sysprop.chm");

			*lpCompiledHelpFile = reinterpret_cast<LPOLESTR>(
										CoTaskMemAlloc((wcslen(helpDir) + 1) * 
															sizeof(wchar_t)));

			if(*lpCompiledHelpFile == NULL)        
				return E_OUTOFMEMORY;

			USES_CONVERSION;
			wcscpy(*lpCompiledHelpFile, T2OLE((LPTSTR)(LPCTSTR)helpDir));
			return S_OK;
		}
		return E_UNEXPECTED;
	}
};

class ATL_NO_VTABLE CCMSnapinAbout : public ISnapinAbout,
									public CComObjectRoot,
									public CComCoClass< CCMSnapinAbout, &CLSID_CMSnapinAbout>
{
public:
	DECLARE_REGISTRY(CCMSnapinAbout, _T("CMSnapinAbout.1"), _T("CMSnapinAbout.1"), IDS_CMSNAPIN_DESC, THREADFLAGS_BOTH);

	BEGIN_COM_MAP(CCMSnapinAbout)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

	STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_DESCRIPTION, szBuf, 256) == 0)
			return E_FAIL;

		*lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpDescription == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpDescription, T2OLE(szBuf));

		return S_OK;
	}

    STDMETHOD(GetProvider)(LPOLESTR *lpName)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_CMSNAPIN_PROVIDER, szBuf, 256) == 0)
			return E_FAIL;

		*lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpName == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpName, T2OLE(szBuf));

		return S_OK;
	}

    STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_CMSNAPIN_VERSION, szBuf, 256) == 0)
			return E_FAIL;

		*lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpVersion == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpVersion, T2OLE(szBuf));

		return S_OK;
	}

    STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
	{
		*hAppIcon = LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_COMPUTER));
		return S_OK;
	}

    STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage,
        HBITMAP *hSmallImageOpen,
        HBITMAP *hLargeImage,
        COLORREF *cMask)
	{
		*hSmallImage = *hSmallImageOpen = LoadBitmap(_Module.GetResourceInstance(), 
														MAKEINTRESOURCE(IDB_CMSNAPIN_16));
		
		*hLargeImage = LoadBitmap(_Module.GetResourceInstance(), 
									MAKEINTRESOURCE(IDB_CMSNAPIN_32));
		*cMask = RGB(255,255,255);

		return S_OK;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\envvar.h ===
//*************************************************************
//
//  Envvar.h   -    Header file for envvar.c
//
//  Microsoft Confidential
//  Copyright (c) 1996-1999 Microsoft Corporation
//  All rights reserved
//
//*************************************************************

#define MAX_USER_NAME   100


HPROPSHEETPAGE CreateEnvVarsPage (HINSTANCE hInst);
BOOL APIENTRY EnvVarsDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
int GetSelectedItem (HWND hCtrl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\envpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __ENVPAGE__
#define __ENVPAGE__
#pragma once

#include "..\Common\WbemPageHelper.h"
#include "..\common\simplearray.h"
//-----------------------------------------------------------------------------
class EnvPage : public WBEMPageHelper
{
private:

	class ENVARS
	{
	public:
		bool   changed;
		LPTSTR userName;
		LPTSTR objPath;
		LPTSTR szValueName;
		LPTSTR szValue;
		LPTSTR szExpValue;
		ENVARS()
		{
			changed = false;
			objPath = NULL;
			userName = NULL;
            szValueName = NULL;
            szValue = NULL;
            szExpValue = NULL;
		}
		~ENVARS()
		{
			delete[] userName;
			delete[] objPath;
            delete[] szValueName;
            delete[] szValue;
            delete[] szExpValue;
		}
	};

	BOOL m_bEditSystemVars;
	BOOL m_bUserVars;
	bool m_currUserModified;
	bool m_SysModified;
	bstr_t m_currentUser;
	bool m_bLocal;

	void LoadUser(IWbemClassObject *envInst, 
					bstr_t userName, 
					HWND hwndUser);
	bool IsLoggedInUser(_bstr_t userName);
	void GetLoggedinUser(bstr_t *userName);

	BOOL Init(HWND hDlg);
	void CleanUp (HWND hDlg);
	void Save(HWND hDlg, int ID);
	int FindVar (HWND hwndLV, LPTSTR szVar);
	int GetSelectedItem (HWND hCtrl);
	void DoCommand(HWND hDlg, 
					HWND hwndCtl, 
					int idCtl, 
					int iNotify );
	int AddUniqueUser(HWND hwnd, LPCTSTR str);
	void EmptyListView(HWND hDlg, int ID);
	void DeleteVar(HWND hDlg,
					UINT VarType,
					LPCTSTR szVarName);
	void SetVar(HWND hDlg,
				UINT VarType,
				LPCTSTR szVarName,
				LPCTSTR szVarValue);
	void DoEdit(HWND hWnd,
				UINT VarType,
				UINT EditType,
				int iSelection);
	ENVARS *GetVar(HWND hDlg, 
					UINT VarType, 
					int iSelection);


	// deletions are saved here until committed.
	typedef CSimpleArray<ENVARS *> ENVLIST;
	ENVLIST m_killers;

	void KillLater(ENVARS *var);
	void KillThemAllNow(void);

public:

    EnvPage(WbemServiceThread *serviceThread);
	~EnvPage();
	INT_PTR DoModal(HWND hDlg);

	INT_PTR CALLBACK DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
};

INT_PTR CALLBACK StaticEnvDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);

#endif __ENVPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\generalpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __GENERALPAGE__
#define __GENERALPAGE__
#pragma once

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

#include "atlsnap.h"
#include "resource.h"
#include "..\Common\WbemPageHelper.h"
#include "..\common\serviceThread.h"

//-----------------------------------------------------------------------------
class GeneralPage : public CSnapInPropertyPageImpl<GeneralPage>,
						public WBEMPageHelper
{
private:

	IDataObject* m_pDataObject;
	CWbemClassObject m_OS;
	CWbemClassObject m_processor;
	CWbemClassObject m_memory;
	CWbemClassObject m_computer;
	// shared with the phone support dialog.
	bstr_t m_manufacturer;
	bool m_inited;
	HWND m_hAVI;
	void Init();
	bool CimomIsReady();
	void ConfigureProductID(LPTSTR lpPid);

public:

	GeneralPage(WbemServiceThread *serviceThread,
				LONG_PTR lNotifyHandle, 
				bool bDeleteHandle = false, 
				TCHAR* pTitle = NULL, 
				IDataObject* pDataObject = 0);

	~GeneralPage();

	enum { IDD = IDD_GENERAL };

	typedef CSnapInPropertyPageImpl<GeneralPage> _baseClass;

	BEGIN_MSG_MAP(GeneralPage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInit)
		MESSAGE_HANDLER(WM_ASYNC_CIMOM_CONNECTED, OnConnected)
		MESSAGE_HANDLER(WM_HELP, OnF1Help)
		MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextHelp)
		MESSAGE_HANDLER(WM_SYSCOLORCHANGE, OnSysColorChange)
		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
		COMMAND_HANDLER(IDC_GEN_OEM_SUPPORT, BN_CLICKED, OnSupport)
		CHAIN_MSG_MAP(_baseClass)
	END_MSG_MAP()

	// Handler prototypes:
	LRESULT OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnConnected(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnF1Help(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnSupport(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	BOOL OnApply();
	BOOL OnKillActive()
	{
		return (m_inited?TRUE:FALSE);
	}

    DWORD GetServerTypeResourceID(void);

	LONG_PTR m_lNotifyHandle;
	bool m_bDeleteHandle;

};

INT_PTR CALLBACK PhoneSupportProc(HWND hDlg, 
								UINT uMsg,
							    WPARAM wParam, 
								LPARAM lParam);

#endif __GENERALPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\generalpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "..\Common\ServiceThread.h"
#include "..\MMFUtil\MsgDlg.h"
#include "helpid.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "GeneralPage.h"

// avoid some warnings.
#undef HDS_HORZ
#undef HDS_BUTTONS
#undef HDS_HIDDEN
#include "resource.h"

#include "..\Common\util.h"
#include <windowsx.h>


//--------------------------------------------------------------
GeneralPage::GeneralPage(WbemServiceThread *serviceThread,
						 LONG_PTR lNotifyHandle, bool bDeleteHandle, TCHAR* pTitle,
						 IDataObject* pDataObject)
				: WBEMPageHelper(serviceThread),
					CSnapInPropertyPageImpl<GeneralPage> (pTitle),
					m_lNotifyHandle(lNotifyHandle),
					m_bDeleteHandle(bDeleteHandle) // Should be true for only page.
{
	m_inited = false;
	m_pDataObject = pDataObject;
}
//--------------------------------------------------------------
GeneralPage::~GeneralPage()
{
	if (m_bDeleteHandle)
		MMCFreeNotifyHandle(m_lNotifyHandle);
}

//-------------------------------------------------------------
bool GeneralPage::CimomIsReady()
{
	m_hDlg = m_hWnd;

	bool retval = ServiceIsReady(IDS_DISPLAY_NAME, 
								 IDS_CONNECTING,
								 IDS_BAD_CONNECT);

	if(retval)
	{
		if((bool)m_WbemServices)
		{
			IWbemClassObject *pInst = NULL;
			m_WbemServices.SetPriv();

			if((pInst = FirstInstanceOf((bstr_t)"Win32_OperatingSystem")) != NULL)
			{
				m_OS = pInst;
			}

			if((pInst = FirstInstanceOf("Win32_Processor")) != NULL)
			{
				m_processor = pInst;
			}

            if((pInst = FirstInstanceOf("Win32_LogicalMemoryConfiguration")) != NULL)
            {
                m_memory = pInst;
            }

			if((pInst = FirstInstanceOf("Win32_ComputerSystem")) != NULL)
			{
				m_computer = pInst;
			}
		}
		else
		{
			retval = false;
		}
	}
	return retval;
}

//-------------------------------------------------------------
void GeneralPage::ConfigureProductID(LPTSTR lpPid)
{
    TCHAR szBuf[64] = {0};

	// is it formatted already.
	if(lstrlen(lpPid) > 20)
	{
		return;
	}

    if (!lpPid || !(*lpPid) || (lstrlen(lpPid) < 20) ) {
        return;
    }

    szBuf[0] = lpPid[0];
    szBuf[1] = lpPid[1];
    szBuf[2] = lpPid[2];
    szBuf[3] = lpPid[3];
    szBuf[4] = lpPid[4];

    szBuf[5] = TEXT('-');

    szBuf[6] = lpPid[5];
    szBuf[7] = lpPid[6];
    szBuf[8] = lpPid[7];

    szBuf[9] = TEXT('-');

    szBuf[10] = lpPid[8];
    szBuf[11] = lpPid[9];
    szBuf[12] = lpPid[10];
    szBuf[13] = lpPid[11];
    szBuf[14] = lpPid[12];
    szBuf[15] = lpPid[13];
    szBuf[16] = lpPid[14];

    szBuf[17] = TEXT('-');

    szBuf[18] = lpPid[15];
    szBuf[19] = lpPid[16];
    szBuf[20] = lpPid[17];
    szBuf[21] = lpPid[18];
    szBuf[22] = lpPid[19];

    szBuf[23] = TEXT('\0');

    lstrcpy (lpPid, szBuf);

}


//Helper to split the caption of the OS to two controls to match the way shell displays it
void WrapTextToTwoControls(HWND hwndLine1, HWND hwndLine2, LPCTSTR szText)
{
	RECT rcCtl;
	SIZE size;
	int fit = 0;
	int length = 0;
	HDC hDC = NULL;
	HFONT hFont = NULL;
	HFONT hOldFont = NULL;
	LPTSTR pszTempBuffer = NULL;
	LPTSTR pszLineBreak = NULL;

	// Validate the arguments
	if(NULL == hwndLine1 || NULL == hwndLine2 || NULL == szText)
		goto FAIL;

	// Make sure we don't have a zero length string
	if(0 == (length = lstrlen(szText)))
		goto FAIL;

	// Get the size of the control for line 1
	if(!GetClientRect(hwndLine1, &rcCtl))
		goto FAIL;

	// Get the DC of line 1
	if(NULL == (hDC = ::GetDC(hwndLine1)))
		goto FAIL;

	// Get the font that is in use for line 1
	if(NULL == (hFont = (HFONT)::SendMessage(hwndLine1, WM_GETFONT, 0, 0)))
		goto FAIL;

	// Select the correct font into the DC
	if(NULL == (hOldFont = (HFONT)::SelectObject(hDC, hFont)))
		goto FAIL;

	// Find out how many characters of our string would fit into the control
	if(!GetTextExtentExPoint(hDC, szText, length, rcCtl.right, &fit, NULL, &size))
		goto FAIL;

	// If the 'fit' is not greater than 0 and less than length, just display everything on line 1 
	if(fit <= 0 || fit >= length)
		goto FAIL;

	// Allocate a buffer to play with
	if(NULL == (pszTempBuffer = new TCHAR[length+1]))
		goto FAIL;

	// Copy text into temporary buffer
	lstrcpy(pszTempBuffer, szText);

	// We will try to break line 1 right at the maximum number of characters
	pszLineBreak = pszTempBuffer + fit;

	// See if the natural break falls directly on a 'space'
	if(*pszLineBreak != _TEXT(' '))
	{
		// The number of characters that fit into line 1 falls in the middle of a word.  Find 
		// the last space that fits in the control.  If we do not find a space that fits in
		// line 1, just use the default behavior.

		// Terminate line 1 at the maximum characters
		*pszLineBreak = _TEXT('\0');

		// Find the last 'sace' on line 1
		if(NULL == (pszLineBreak = _tcsrchr(pszTempBuffer, _TEXT(' '))))
			goto FAIL;

		// Copy text into the temporary buffer again
		lstrcpy(pszTempBuffer, szText);
	}

	// Terminate line 1 right on the 'last' space that fits into the control
	*pszLineBreak = _TEXT('\0');

	// Set line one to everything up to the 'last' space that fits into the control
	SetWindowText(hwndLine1, pszTempBuffer);

	// Set line two to everything after the 'last' space that fit into line 1
	SetWindowText(hwndLine2, pszLineBreak+1);

	// Everything went OK;
	goto CLEANUP;
FAIL:
	// Default to putting all the text on line 1 if anything goes wrong
	::SetWindowText(hwndLine1, szText);
	::SetWindowText(hwndLine2, _TEXT(""));

CLEANUP:
	if(pszTempBuffer)
		delete[] pszTempBuffer;
	if(hOldFont && hDC)
		SelectObject(hDC, hOldFont);
	if(hDC && hwndLine1)
		ReleaseDC(hwndLine1, hDC);
}




//--------------------------------------------------------------
void GeneralPage::Init()
{
    TCHAR _scr1[640] = {0};
    TCHAR _scr2[640] = {0};
    TCHAR szNumBuf1[64] = {0};
    int   ctlid;

    // Set the default bitmap
    SetClearBitmap(GetDlgItem(IDC_GEN_WINDOWS_IMAGE ),
					MAKEINTRESOURCE( IDB_WINDOWS ), 0 );

    //
    // The caption is in the form:
    //      Microsoft Windows XP Server
    //
    // This is actually the caption + the product suite type.
    // Wrap the product suite type (Server above) into the
    // next static control.
    //
    // IDC_GEN_VERSION_0: Major branding ("Windows XP")
    // Default to Win32_OperatingSystem::Caption.
    //

    HWND hwndCtl1 = ::GetDlgItem(m_hWnd, IDC_GEN_VERSION_0);
    HWND hwndCtl2 = ::GetDlgItem(m_hWnd, IDC_GEN_VERSION_1);

    WrapTextToTwoControls(hwndCtl1, hwndCtl2, m_OS.GetString("Caption"));

    // Build and set the serial number string
    if (m_OS.GetBool("Debug")) 
    {
	_scr1[0] = TEXT(' ');
        LoadString(HINST_THISDLL,
                   IDS_DEBUG,
                   &_scr1[1],
                   ARRAYSIZE(_scr1));
    } 
    else 
    {
	_scr1[0] = TEXT('\0');
    }

    // IDC_GEN_VERSION_2: Version year ("Version 2002")
    //
    // Determine if we are targeting XP.  If not, default to
    // Win32_OperatingSystem::Version.
    //
    // Instead of checking if this is XP (based on "5.1" version), a safer bet
    // is to do this only if we are on the local box. Otherwise display the version from WMI.
    if(g_serviceThread->m_machineName.length() == 0)
    {
        LoadString(HINST_THISDLL, IDS_WINVER_YEAR, _scr2, ARRAYSIZE(_scr2));
        wcscat(_scr2, _scr1);
        SetDlgItemText(IDC_GEN_VERSION_2, _scr2);
    }
    else
    {
        wcscpy(_scr2, (wchar_t *)m_OS.GetString("Version"));
        wcscat(_scr2, _scr1);
        SetDlgItemText(IDC_GEN_VERSION_2, _scr2);
    }
	
    // IDC_GEN_SERVICE_PACK: Service pack (if any)
	SetDlgItemText(IDC_GEN_SERVICE_PACK, m_OS.GetString("CSDVersion"));

	// Do registered user info
	ctlid = IDC_GEN_REGISTERED_0;  // start here and use more as needed

	SetDlgItemText(ctlid++, m_OS.GetString("RegisteredUser"));

	// organization.
	SetDlgItemText(ctlid++, m_OS.GetString("Organization"));

	//productID
	wcscpy(_scr1, (wchar_t *)m_OS.GetString("SerialNumber"));
	ConfigureProductID(_scr1);
	SetDlgItemText(ctlid++, _scr1);

	// another product ID
	wcscpy(_scr1, (wchar_t *)m_OS.GetString("PlusProductID"));
	ConfigureProductID(_scr1);
	SetDlgItemText(ctlid++, _scr1);

	// Do machine info
	ctlid = IDC_GEN_MACHINE_0;  // start here and use controls as needed

	//TODO: get this property back.
	// if OEM ....
	m_manufacturer = m_computer.GetString("Manufacturer");
	if(m_manufacturer.length() > 0)
	{
		SetDlgItemText(ctlid++, m_manufacturer );
		SetDlgItemText(ctlid++, m_computer.GetString("Model"));

		// if there's support info...
		variant_t array;
		long LBound = 2147483647;
		long UBound = 2147483647;
		SAFEARRAY *supportArray = NULL;

		m_computer.Get("SupportContactDescription", (variant_t &)array);
		if(array.vt == (VT_ARRAY | VT_BSTR))
		{
			supportArray = V_ARRAY(&array);
			SafeArrayGetLBound(supportArray, 1, &LBound);
			SafeArrayGetUBound(supportArray, 1, &UBound);

			// turn on the button.
			HWND wnd = GetDlgItem(IDC_GEN_OEM_SUPPORT );
			::EnableWindow( wnd, TRUE );
			::ShowWindow( wnd, SW_SHOW );
		}

#ifdef DOES_NOT_WORK
		// Get the OEMLogo array.
		HBITMAP hDDBitmap;
		HRESULT hr;

		if(SUCCEEDED(hr = m_computer.GetDIB("OEMLogoBitmap", GetDC(),
								 hDDBitmap)))
		{
			::SendMessage(GetDlgItem(IDC_GEN_OEM_IMAGE), 
							STM_SETIMAGE, IMAGE_BITMAP, 
							(LPARAM)hDDBitmap);
            ::ShowWindow(GetDlgItem(IDC_GEN_OEM_NUDGE), SW_SHOWNA);
            ::ShowWindow(GetDlgItem(IDC_GEN_MACHINE), SW_HIDE);
		}
#endif // DOES_NOT_WORK

	} //endif OEM

	// Processor
	SetDlgItemText(ctlid++, m_processor.GetString("Name"));

	// Processor speed
	LoadString(HINST_THISDLL,
               IDS_XDOTX_MHZ,
               _scr2,
               ARRAYSIZE(_scr2));
    wsprintf(_scr1,
             _scr2,
             AddCommas(m_processor.GetLong("CurrentClockSpeed"), szNumBuf1));
	SetDlgItemText(ctlid++, _scr1);

	// Memory
    #define ONEMB   1048576 // 1MB == 1048576 bytes.
    _int64 nTotalBytes = m_computer.GetI64("TotalPhysicalMemory");

    //
    // WORKAROUND - NtQuerySystemInformation doesn't really return the
    // total available physical memory, it instead just reports the total
    // memory seen by the Operating System. Since some amount of memory
    // is reserved by BIOS, the total available memory is reported
    // incorrectly. To work around this limitation, we convert the total
    // bytes to the nearest 4MB value
    //
        
    double   nTotalMB = (double)(nTotalBytes / ONEMB);
    LONGLONG llMem = (LONGLONG)((ceil(ceil(nTotalMB) / 4.0) * 4.0) * ONEMB);

    StrFormatByteSize(llMem, szNumBuf1, ARRAYSIZE(szNumBuf1));
	LoadString(HINST_THISDLL, IDS_XDOTX_MB, _scr2, ARRAYSIZE(_scr2));
	wsprintf(_scr1, _scr2, szNumBuf1);
	SetDlgItemText(ctlid++, _scr1);
}


//--------------------------------------------------------------
LRESULT GeneralPage::OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	g_serviceThread->Connect(m_pDataObject, &m_hWnd);

	if(!m_inited)
	{
		HWND hAnim = GetDlgItem(IDC_ANIMATE);
		Animate_Open(hAnim, MAKEINTRESOURCE(IDR_AVIWAIT));

		TCHAR msg[50] = {0};
		::LoadString(HINST_THISDLL, IDS_UNAVAILABLE, msg, 50);
		SetDlgItemText(IDC_GEN_REGISTERED_0, msg);
	}
	return S_OK;
}

//--------------------------------------------------------------
LRESULT GeneralPage::OnConnected(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	if(lParam)
	{
		IStream *pStream = (IStream *)lParam;
		IWbemServices *pServices = 0;
		HRESULT hr = CoGetInterfaceAndReleaseStream(pStream,
											IID_IWbemServices,
											(void**)&pServices);
		if(SUCCEEDED(hr))
		{
			SetWbemService(pServices);

			// check anyway, just to get the side affects.
			if(CimomIsReady())
			{
				HWND hwnd = GetDlgItem(IDC_GEN_WINDOWS_IMAGE);
				SetClearBitmap(hwnd, MAKEINTRESOURCE(IDB_WINDOWS), 0);
				::ShowWindow(hwnd, SW_SHOWNA);

				hwnd = GetDlgItem(IDC_ANIMATE);
				Animate_Close(hwnd);
				::ShowWindow(hwnd, SW_HIDE);

				Init();
				m_inited = true;
			}
			else
			{
				PropSheet_RemovePage(::GetParent(m_hWnd), 2, 0);
				PropSheet_RemovePage(::GetParent(m_hWnd), 1, 0);
			}
		}
	}
	else // connection failed.
	{
		CimomIsReady();  //courtesy call.
		PropSheet_RemovePage(::GetParent(m_hWnd), 2, 0);
		PropSheet_RemovePage(::GetParent(m_hWnd), 1, 0);

		HWND hwnd = GetDlgItem(IDC_GEN_WINDOWS_IMAGE);
		SetClearBitmap(hwnd, MAKEINTRESOURCE(IDB_WINDOWS), 0);
		::ShowWindow(hwnd, SW_SHOWNA);

		hwnd = GetDlgItem(IDC_ANIMATE);
		Animate_Close(hwnd);
		::ShowWindow(hwnd, SW_HIDE);

	}
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);

	return S_OK;
}

//----------------------------------------------
DWORD aGeneralHelpIds[] = {
    IDC_GEN_WINDOWS_IMAGE,         IDH_NO_HELP,
    IDC_TEXT_1,                    (IDH_GENERAL + 0),
    IDC_GEN_VERSION_0,             (IDH_GENERAL + 1),
    IDC_GEN_VERSION_1,             (IDH_GENERAL + 1),
    IDC_GEN_VERSION_2,             (IDH_GENERAL + 1),
    IDC_GEN_SERVICE_PACK,          (IDH_GENERAL + 1),
    IDC_TEXT_3,                    (IDH_GENERAL + 3),
    IDC_GEN_REGISTERED_0,          (IDH_GENERAL + 3),
    IDC_GEN_REGISTERED_1,          (IDH_GENERAL + 3),
    IDC_GEN_REGISTERED_2,          (IDH_GENERAL + 3),
    IDC_GEN_REGISTERED_3,          (IDH_GENERAL + 3),
    IDC_GEN_OEM_IMAGE,             IDH_NO_HELP,
    IDC_TEXT_4,                    (IDH_GENERAL + 6),
    IDC_GEN_MACHINE_0,             (IDH_GENERAL + 7),
    IDC_GEN_MACHINE_1,             (IDH_GENERAL + 8),
    IDC_GEN_MACHINE_2,             (IDH_GENERAL + 9),
    IDC_GEN_MACHINE_3,             (IDH_GENERAL + 10),
    IDC_GEN_MACHINE_4,             (IDH_GENERAL + 11),
    IDC_GEN_MACHINE_5,             IDH_NO_HELP,
    IDC_GEN_MACHINE_6,             IDH_NO_HELP,
    IDC_GEN_MACHINE_7,             IDH_NO_HELP,
    IDC_GEN_MACHINE_8,             IDH_NO_HELP,
    IDC_GEN_OEM_SUPPORT,           (IDH_GENERAL + 12),
    IDC_GEN_REGISTERED_2,          (IDH_GENERAL + 14),
    IDC_GEN_REGISTERED_3,          (IDH_GENERAL + 15),
    IDC_GEN_MACHINE,               (IDH_GENERAL + 7),
    IDC_GEN_OEM_NUDGE,             IDH_NO_HELP,
    0, 0
};

LRESULT GeneralPage::OnF1Help(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
				L"sysdm.hlp", 
				HELP_WM_HELP, 
				(ULONG_PTR)(LPSTR)aGeneralHelpIds);

	return S_OK;
}

//--------------------------------------------------------------
LRESULT GeneralPage::OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	::WinHelp((HWND)wParam,
				L"sysdm.hlp", 
				HELP_CONTEXTMENU, 
				(ULONG_PTR)(LPSTR)aGeneralHelpIds);

	return S_OK;
}

//--------------------------------------------------------------
LRESULT GeneralPage::OnSupport(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	TCHAR text[4096] = {0};
	BSTR temp;
	variant_t array;
	SAFEARRAY *supportArray = NULL;
	long LBound = 2147483647;
	long UBound = 2147483647;

	wcscpy(text, _T(""));

	m_computer.Get("SupportContactDescription", (variant_t &)array);
	supportArray = V_ARRAY(&array);
	SafeArrayGetLBound(supportArray, 1, &LBound);
	SafeArrayGetUBound(supportArray, 1, &UBound);

	for(long i = LBound; i <= UBound; i++)
	{
		SafeArrayGetElement(supportArray, &i, &temp);
		wcscat(text, temp);
		wcscat(text, _T("\r\n"));
	}

	// display the supportContact text.
	DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(IDD_PHONESUP),
					GetParent(), PhoneSupportProc, (LPARAM)text);

	return S_OK;
}

//--------------------------------------------------------------
LRESULT GeneralPage::OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
			//TODO: reread the oemLogo property.
//        SetClearBitmap(GetDlgItem(IDC_GEN_OEM_IMAGE ), oemfile,
//						SCB_FROMFILE | SCB_REPLACEONLY );

        SetClearBitmap(GetDlgItem(IDC_GEN_WINDOWS_IMAGE ),
					    MAKEINTRESOURCE( IDB_WINDOWS ), 0 );
	return S_OK;
}

//--------------------------------------------------------------
LRESULT GeneralPage::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SetClearBitmap( GetDlgItem(IDC_GEN_OEM_IMAGE ), NULL, 0 );
    SetClearBitmap( GetDlgItem(IDC_GEN_WINDOWS_IMAGE ), NULL, 0 );
	return S_OK;
}

//--------------------------------------------------------------
BOOL GeneralPage::OnApply()
{
//	SetWindowLong(DWL_MSGRESULT, PSNRET_NOERROR);
	return TRUE;
}

//----------------------------------------------------------
INT_PTR CALLBACK PhoneSupportProc(HWND hDlg, UINT uMsg,
							    WPARAM wParam, LPARAM lParam)
{
    switch( uMsg ) 
	{
    case WM_INITDIALOG:
		{
			HWND editBox = GetDlgItem(hDlg, IDC_SUPPORT_TEXT);

			// load the edit box.
			SendMessage (editBox, WM_SETREDRAW, FALSE, 0);

			Edit_SetText(editBox, (LPCTSTR)lParam);

			SendMessage (editBox, WM_SETREDRAW, TRUE, 0);

		} //end case

		break;

    case WM_COMMAND:

        switch(LOWORD(wParam)) 
		{
        case IDOK:
        case IDCANCEL:
             EndDialog( hDlg, 0 );
             break;

        default:
             return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

//----------------------------------------------------------
DWORD GeneralPage::GetServerTypeResourceID(void)
{
    // This code was taken from the shell internal api, IsOS,
    // located in nt\shell\inc\IsOS.c. This code was derived
    // specifically from the following IsOS() switch statements:
    //     OS_ADVSERVER
    //     OS_DATACENTER
    //     OS_EMBEDDED
    //     OS_PERSONAL
    //     OS_PROFESSIONAL
    //     OS_SERVER
    // These are the only interesting cases used by system cpl.
    //
    // Conditions intentionally verbose (not optimized) for sake
    // of readability.
    //

    variant_t var;
    LONG      ProductType  = 0;
    LONG      fProductSuite = 0;

    if (SUCCEEDED(m_OS.Get("ProductType", var)))
    {
        if (var.vt == VT_I4)
            ProductType = var.iVal;
    }

    if (SUCCEEDED(m_OS.Get("SuiteMask", var)))
    {
        if (var.vt == VT_I4)
            fProductSuite = var.iVal;
    }

    if ((ProductType == VER_NT_SERVER ||
         ProductType == VER_NT_DOMAIN_CONTROLLER) &&
        (fProductSuite & VER_SUITE_ENTERPRISE) &&
        !(fProductSuite & VER_SUITE_DATACENTER))
    {
        return IDS_WINVER_ADVANCEDSERVER;
    }
    else
    if ((ProductType == VER_NT_SERVER ||
         ProductType == VER_NT_DOMAIN_CONTROLLER) &&
        (fProductSuite & VER_SUITE_DATACENTER))
    {
        return IDS_WINVER_DATACENTER;
    }
    else
    if (fProductSuite & VER_SUITE_EMBEDDEDNT)
    {
        return IDS_WINVER_EMBEDDED;
    }
    else
    if (fProductSuite & VER_SUITE_PERSONAL)
    {
        return IDS_WINVER_PERSONAL;
    }
    else
    if (ProductType == VER_NT_WORKSTATION)
    {
        return IDS_WINVER_PROFESSIONAL;
    }
    else
    if ((ProductType == VER_NT_SERVER ||
         ProductType == VER_NT_DOMAIN_CONTROLLER) &&
        !(fProductSuite & VER_SUITE_ENTERPRISE) &&
        !(fProductSuite & VER_SUITE_DATACENTER))
    {
        return IDS_WINVER_SERVER;
    }
    else
    {
        return IDS_WINVER_SERVER;   // Generic catch-all.
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\iddlg.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "..\Common\ServiceThread.h"
#include "moredlg.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "resource.h"
#include "..\common\util.h"
#include "IDDlg.h"
#include "NetUtility.h"
#include "NetHelpIDs.h"
#include "common.h"

static const DWORD _help_map[] =
{
   IDC_FULL_NAME,          IDH_IDENT_CHANGES_PREVIEW_NAME,
   IDC_NEW_NAME,           IDH_IDENT_CHANGES_NEW_NAME,
   IDC_MORE,               IDH_IDENT_CHANGES_MORE_BUTTON,
   IDC_DOMAIN_BUTTON,      IDH_IDENT_CHANGES_MEMBER_DOMAIN,
   IDC_WORKGROUP_BUTTON,   IDH_IDENT_CHANGES_MEMBER_WORKGRP,
   IDC_DOMAIN,             IDH_IDENT_CHANGES_MEMBER_DOMAIN_TEXTBOX,
   IDC_WORKGROUP,          IDH_IDENT_CHANGES_MEMBER_WORKGRP_TEXTBOX,
   IDC_FIND,               -1,
   0, 0
};


//---------------------------------------------------------------------
IDChangesDialog::IDChangesDialog(WbemServiceThread *serviceThread,
								 State &state) 
						: WBEMPageHelper(serviceThread),
						m_state(state)
{
}

//-------------------------------------------------------------
IDChangesDialog::~IDChangesDialog()
{
}

//----------------------------------------------------------
void IDChangesDialog::enable()
{
   bool networking_installed = m_state.IsNetworkingInstalled();
   BOOL workgroup = IsDlgButtonChecked(IDC_WORKGROUP_BUTTON) == BST_CHECKED;

   ::EnableWindow(GetDlgItem(IDC_DOMAIN),
					!workgroup && networking_installed);

   ::EnableWindow(GetDlgItem(IDC_FIND),
					!workgroup && networking_installed);

   ::EnableWindow(GetDlgItem(IDC_WORKGROUP),
					workgroup && networking_installed);

   bool b = false;
   if (workgroup)
   {
      b = !GetTrimmedDlgItemText(m_hWnd, IDC_WORKGROUP).IsEmpty();
   }
   else
   {
      b = !GetTrimmedDlgItemText(m_hWnd, IDC_DOMAIN).IsEmpty();
   }

   bool enable = m_state.ChangesNeedSaving() && b &&
					!GetTrimmedDlgItemText(m_hWnd, IDC_NEW_NAME).IsEmpty();
   
   ::EnableWindow(GetDlgItem(IDOK), enable);
}

//----------------------------------------------------------
LRESULT IDChangesDialog::OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   m_hDlg = m_hWnd;

   SetDlgItemText(IDC_FULL_NAME, m_state.GetFullComputerName());
   SetDlgItemText(IDC_NEW_NAME, m_state.GetShortComputerName());

   bool joined_to_workgroup = m_state.IsMemberOfWorkgroup();

   CheckDlgButton(IDC_WORKGROUP_BUTTON,
					joined_to_workgroup ? BST_CHECKED : BST_UNCHECKED);

   CheckDlgButton(IDC_DOMAIN_BUTTON,
					joined_to_workgroup ? BST_UNCHECKED : BST_CHECKED);

   SetDlgItemText(joined_to_workgroup ? IDC_WORKGROUP : IDC_DOMAIN,
					m_state.GetDomainName());

   bool networking_installed = m_state.IsNetworkingInstalled();
   bool tcp_installed = networking_installed && IsTCPIPInstalled();

   int show = tcp_installed ? SW_SHOW : SW_HIDE;
   ::ShowWindow(GetDlgItem(IDC_FULL_LABEL), show);
   ::ShowWindow(GetDlgItem(IDC_FULL_NAME), show);
   ::ShowWindow(GetDlgItem(IDC_MORE), show);

   HWND new_name_edit = GetDlgItem(IDC_NEW_NAME);
   HWND domain_name_edit = GetDlgItem(IDC_DOMAIN);
//   Edit_LimitText(domain_name_edit, tcp_installed ? DNS::MAX_NAME_LENGTH : DNLEN);

//   Edit_LimitText(new_name_edit, tcp_installed ? DNS::MAX_LABEL_LENGTH : MAX_COMPUTERNAME_LENGTH);

   if (!tcp_installed)
   {
      // Set the uppercase style on the new name & domain edit boxes
      LONG style = ::GetWindowLong(new_name_edit, GWL_STYLE);
      style |= ES_UPPERCASE;
      ::SetWindowLong(new_name_edit, GWL_STYLE, style);

      style = ::GetWindowLong(domain_name_edit, GWL_STYLE);
      style |= ES_UPPERCASE;
      ::SetWindowLong(domain_name_edit, GWL_STYLE, style);
   }

   //TODO::Edit_LimitText(GetDlgItem(IDC_WORKGROUP), DNLEN);

   // no networking at all further restricts the UI to just NetBIOS-like
   // computer name changes.
   if (!networking_installed)
   {
      ::EnableWindow(GetDlgItem(IDC_DOMAIN_BUTTON), false);
      ::EnableWindow(GetDlgItem(IDC_WORKGROUP_BUTTON), false);
      ::EnableWindow(GetDlgItem(IDC_DOMAIN), false);
      ::EnableWindow(GetDlgItem(IDC_WORKGROUP), false);
      ::EnableWindow(GetDlgItem(IDC_GROUP), false);

	  TCHAR temp[256] = {0};
	  StringLoad(IDS_NAME_MESSAGE, temp, 256);
      ::SetWindowText(GetDlgItem(IDC_MESSAGE), temp);
   }
   else
   {
	  TCHAR temp[256] = {0};
	  StringLoad(IDS_NAME_AND_MEMBERSHIP_MESSAGE, temp, 256);
      ::SetWindowText(GetDlgItem(IDC_MESSAGE), temp);
   }

   enable();
	return S_OK;
}

//----------------------------------------------------------
NET_API_STATUS IDChangesDialog::myNetValidateName(const CHString&        name,
													NETSETUP_NAME_TYPE   nameType)
{
/*   ATLASSERT(!name.IsEmpty());

   if(!name.IsEmpty())
   {
      NET_API_STATUS status;// = ::NetValidateName(0, name,
//												0, 0, nameType);
      return status;
   }
*/
   return ERROR_INVALID_PARAMETER;
}

//----------------------------------------------------------
bool IDChangesDialog::validateName(HWND dialog,
								   int nameResID,
								   const CHString &name,
								   NETSETUP_NAME_TYPE nameType)
{
/*   ATLASSERT(IsWindow(dialog));
   ATLASSERT(nameResID);

   NET_API_STATUS status;// = myNetValidateName(name, nameType);
   if(status != NERR_Success)
   {
	  TCHAR temp[256] = {0};
	  StringLoad(IDS_VALIDATE_NAME_FAILED, temp, 256);
      gripe(dialog,
			 nameResID,
			 HRESULT_FROM_WIN32(status),
			 temp,
			 IDS_APP_TITLE);
      return false;
   }
*/
   return true;
}
   

// this is also good for the tcp/ip not installed case, as the edit control
// limits the text length, and we decided not to allow '.' in netbios names
// any longer

//----------------------------------------------------------
bool IDChangesDialog::validateShortComputerName(HWND dialog)
{
/*   ATLASSERT(IsWindow(dialog));

   if(!m_state.WasShortComputerNameChanged())
   {
      return true;
   }

   CHString name = m_state.GetShortComputerName();

   CHString message;
   switch (DNS::ValidateDNSLabelSyntax(name))
   {
      case DNS::VALID_LABEL:
      {
         if (state.IsNetworkingInstalled())
         {
            return validateName(dialog, IDC_NEW_NAME, name, NetSetupMachine);
         }
         else
         {
            return true;
         }
      }
      case DNS::LABEL_TOO_LONG:
      {
         message = String::format(IDS_COMPUTER_NAME_TOO_LONG,
								   name.c_str(),
								   DNS::MAX_LABEL_LENGTH);
         break;
      }
      case DNS::NON_RFC_LABEL:
      {
         message = String::format(IDS_NON_RFC_COMPUTER_NAME_SYNTAX, 
									name.c_str());
         if(MessageBox(dialog, message,
					   String::load(IDS_APP_TITLE),
					   MB_ICONWARNING | MB_YESNO) == IDYES)
         {
            return validateName(dialog, IDC_NEW_NAME, name, NetSetupMachine);
         }

         HWND edit = GetDlgItem(IDC_NEW_NAME);
         ::SendMessage(edit, EM_SETSEL, 0, -1);
         ::SetFocus(edit);
         return false;
      }
      case DNS::INVALID_LABEL:
      {
         message = CHString::format(IDS_BAD_COMPUTER_NAME_SYNTAX, 
									name.c_str());
         break;
      }
      default:
      {
         ATLASSERT(false);
         message = CHString::format(IDS_BAD_COMPUTER_NAME_SYNTAX, 
									name.c_str());
         break;
      }
   }

   gripe(dialog, IDC_NEW_NAME,
			message, IDS_APP_TITLE);
*/
   return false;
}

//----------------------------------------------------------
bool IDChangesDialog::validateDomainOrWorkgroupName(HWND dialog)
{
/*   ATLASSERT(IsWindow(dialog));

   if (!State::GetInstance().WasMembershipChanged())
   {
      return true;
   }

   NETSETUP_NAME_TYPE name_type = NetSetupWorkgroup;
   int name_id = IDC_WORKGROUP;
   if(IsDlgButtonChecked(IDC_DOMAIN_BUTTON) == BST_CHECKED)
   {
      name_type = NetSetupDomain;
      name_id = IDC_DOMAIN;
   }

   CHString name = GetTrimmedDlgItemText(m_hWnd, name_id);
   return validateName(dialog, name_id, name, name_type);
   */
	return false;
}

//----------------------------------------------------------
bool IDChangesDialog::onOKButton()
{
   ATLASSERT(m_state.ChangesNeedSaving());

   HourGlass(true);

   // computer primary DNS name has already been validated by
   // MoreChangesDialog

   // this is redundant, really, but I'm paranoid.
   m_state.SetShortComputerName(GetTrimmedDlgItemText(m_hWnd, IDC_NEW_NAME));
   bool workgroup = IsDlgButtonChecked(IDC_WORKGROUP_BUTTON) == BST_CHECKED;
   m_state.SetIsMemberOfWorkgroup(workgroup);
   if(workgroup)
   {
      m_state.SetDomainName(GetTrimmedDlgItemText(m_hWnd, IDC_WORKGROUP));
   }
   else
   {
      m_state.SetDomainName(GetTrimmedDlgItemText(m_hWnd, IDC_DOMAIN));
   }

   if(!validateShortComputerName(m_hWnd) ||
       !validateDomainOrWorkgroupName(m_hWnd))
   {
	   HourGlass(false);
      return false;
   }

   if(m_state.SaveChanges(m_hWnd))
   {
      AppMessage(m_hWnd, IDS_MUST_REBOOT);
      m_state.SetMustRebootFlag(true);      
      return true;
   }

   HourGlass(false);
   return false;
}

//----------------------------------------------------------
LRESULT IDChangesDialog::OnCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
   switch(wID)
   {
      case IDC_MORE:
      {
         if (wNotifyCode == BN_CLICKED)
         {
            MoreChangesDialog dlg(g_serviceThread, m_state);
            if (dlg.DoModal() == MoreChangesDialog::CHANGES_MADE)
            {
               SetDlgItemText(IDC_FULL_NAME, m_state.GetFullComputerName());               
               enable();
            }
         }
         break;
      }
      case IDC_WORKGROUP_BUTTON:
      case IDC_DOMAIN_BUTTON:
      {
         if (wNotifyCode == BN_CLICKED)
         {
            bool workgroup = IsDlgButtonChecked(IDC_WORKGROUP_BUTTON) == BST_CHECKED;
            m_state.SetIsMemberOfWorkgroup(workgroup);
            if(workgroup)
            {
               m_state.SetDomainName(GetTrimmedDlgItemText(m_hWnd, IDC_WORKGROUP));
            }
            else
            {
               m_state.SetDomainName(GetTrimmedDlgItemText(m_hWnd, IDC_DOMAIN));
            }
            enable();
         }
         break;
      }
      case IDC_WORKGROUP:  // the editboxes
      case IDC_DOMAIN:
      {
         if (wNotifyCode == EN_CHANGE)
         {
            //TODOSetModified(wID);
            m_state.SetDomainName(GetTrimmedDlgItemText(m_hWnd, wID));
            enable();
         }
         break;
      }
      case IDC_NEW_NAME:
      {
         if (wNotifyCode == EN_CHANGE)
         {
            //TODOSetChanged(wID);
            m_state.SetShortComputerName(GetTrimmedDlgItemText(m_hWnd, wID));
            SetDlgItemText(IDC_FULL_NAME, m_state.GetFullComputerName());
            enable();
         }
         break;
      }
      case IDOK:
      {
         if(wNotifyCode == BN_CLICKED)
         {
            if(onOKButton())
            {
               EndDialog(wID);
            }
         }
         break;
      }
      case IDCANCEL:
      {
         if(wNotifyCode == BN_CLICKED)
         {
            EndDialog(wID);
         }
         break;
      }

      default:
      {
		  bHandled = false;
         break;
      }
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\iddlg.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef IDDLG_HPP_INCLUDED
#define IDDLG_HPP_INCLUDED
#pragma once

#include "resource.h"

#include "..\Common\WbemPageHelper.h"
#include <chstring.h>
#include "state.h"

#define NET_API_STATUS DWORD
#define NETSETUP_NAME_TYPE DWORD
//---------------------------------------------------------------------
class IDChangesDialog : public CDialogImpl<IDChangesDialog>,
						public WBEMPageHelper
{
public:

	IDChangesDialog(WbemServiceThread *serviceThread,
					State &state);
	virtual ~IDChangesDialog();

	enum { IDD = IDD_CHANGES };

	BEGIN_MSG_MAP(IDChangesDialog)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInit)
		COMMAND_HANDLER(IDC_CHANGE, BN_CLICKED, OnCommand)
	END_MSG_MAP()

	// Handler prototypes:
	LRESULT OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:
	State &m_state;
	void enable();
	NET_API_STATUS myNetValidateName(const CHString&        name,
									NETSETUP_NAME_TYPE   nameType);
	bool validateName(HWND dialog,
					   int nameResID,
					   const CHString &name,
					   NETSETUP_NAME_TYPE nameType);
	bool validateShortComputerName(HWND dialog);
	bool onOKButton();
	bool validateDomainOrWorkgroupName(HWND dialog);
};

#endif IDDLG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\helpid.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1999 Microsoft Corporation
All rights reserved

Module Name:

    helpid.h

Abstract:

    Resource IDs for the System Control Panel Applet

Author:

    Scott Hallock (scotthal) 17-Oct-1997

Revision History:

    15-Oct-1997 scotthal
        Split Help IDs into their own header

--*/
#ifndef _SYSDM_HELPID_H_
#define _SYSDM_HELPID_H_

#define HELP_FILE           TEXT("sysdm.hlp")

#define IDH_HELPFIRST       5000

//
// Help IDs for the General tab
//
#define IDH_GENERAL         (IDH_HELPFIRST + 0000)
#define IDH_PERF            (IDH_HELPFIRST + 1000)
#define IDH_ENV             (IDH_HELPFIRST + 2000)
#define IDH_ENV_EDIT        (IDH_HELPFIRST + 2500)
#define IDH_STARTUP         (IDH_HELPFIRST + 3000)
#define IDH_HWPROFILE       (IDH_HELPFIRST + 4000)
#define IDH_USERPROFILE     (IDH_HELPFIRST + 5000)
#define IDH_HARDWARE        (IDH_HELPFIRST + 6000)
#define IDH_ADVANCED        (IDH_HELPFIRST + 7000)
#define IDH_DLGFIRST        (IDH_HELPFIRST + 3000)
#define IDH_DLG_VIRTUALMEM  (IDH_DLGFIRST + 41)

#define IDH_WBEM_ADVANCED_ENVARIABLE_USERVAR_LISTBOX  13002
#define IDH_WBEM_ADVANCED_STARTRECOVER_REMOTE_REBOOT  13003

#endif // _SYSDM_HELPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\moredlg.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "..\Common\ServiceThread.h"
#include "moredlg.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "resource.h"
#include "..\common\util.h"
#include "IDDlg.h"
#include "MoreDlg.h"
#include "NetUtility.h"
#include "NetHelpIDs.h"

static const DWORD _help_map[] =
{
   IDC_DNS,                IDH_IDENT_NAMES_DNS_NAME,
   IDC_CHANGE,             IDH_IDENT_NAMES_CHANGE_DNS_CHECKBOX,
   IDC_NETBIOS,            IDH_IDENT_NAMES_NETBIOS_NAME,
   0, 0
};

//---------------------------------------------------------------------
MoreChangesDialog::MoreChangesDialog(WbemServiceThread *serviceThread,
									 State &state) 
						: WBEMPageHelper(serviceThread),
						m_state(state)
{
}

//-------------------------------------------------------------
MoreChangesDialog::~MoreChangesDialog()
{
}

//----------------------------------------------------------
void MoreChangesDialog::enable()
{
   bool enabled = false;// = WasChanged(IDC_CHANGE) ||
				//	WasChanged(IDC_DNS) &&
				//	!GetTrimmedDlgItemText(m_hWnd, IDC_DNS).IsEmpty();

   ::EnableWindow(GetDlgItem(IDOK), enabled);
}

//----------------------------------------------------------
LRESULT MoreChangesDialog::OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
   m_hDlg = m_hWnd;

   // Marshalling shouldn't happen here.
	m_WbemServices = g_serviceThread->m_WbemServices;

	SetDlgItemText(IDC_DNS, m_state.GetComputerDomainDNSName());
   
	SetDlgItemText(IDC_NETBIOS, m_state.GetNetBIOSComputerName());
	CheckDlgButton(IDC_CHANGE, (m_state.GetSyncDNSNames() ? BST_CHECKED : BST_UNCHECKED));

	enable();
	return S_OK;
}

//----------------------------------------------------------
int MoreChangesDialog::onOKButton()
{
   int end_code = 0;

//   if(WasChanged(IDC_CHANGE))
   {
      m_state.SetSyncDNSNames(IsDlgButtonChecked(IDC_CHANGE) == BST_CHECKED);
      end_code = 1;
   }
      
//   if (WasChanged(IDC_DNS))
   {
      // compare the new value to the old one.  If they're different,
      // validate and save the new value
      CHString new_domain = GetTrimmedDlgItemText(m_hWnd, IDC_DNS);
      CHString old_domain = m_state.GetComputerDomainDNSName();

      if(new_domain.CompareNoCase(old_domain) != 0)
      {
/*         switch (DNS::ValidateDNSNameSyntax(new_domain))
         {
            case DNS::NON_RFC_NAME:
            {
               MessageBox(String::format(IDS_NON_RFC_NAME, 
							new_domain.c_str()),
							String::load(IDS_APP_TITLE),
							MB_OK | MB_ICONWARNING);
               // fall-thru
            }
            case DNS::VALID_NAME:
            {
               m_state.SetComputerDomainDNSName(new_domain);
               end_code = 1;
               break;
            }
            case DNS::INVALID_NAME:
            {
               end_code = -1;
               gripe(hwnd, IDC_DNS,
						String::format(IDS_BAD_DNS_SYNTAX, 
						new_domain.c_str()),
						IDS_APP_TITLE);
               break;
            }
            case DNS::NAME_TOO_LONG:
            {
               end_code = -1;               
               gripe(hwnd, IDC_DNS,
					String::format(IDS_DNS_NAME_TOO_LONG,
									new_domain.c_str(),
									DNS::MAX_NAME_LENGTH),
					IDS_APP_TITLE);
               break;
            }
            default:
            {
               assert(false);
               break;
            }
         }
*/
      }
   }

   return end_code;
}

//----------------------------------------------------------
LRESULT MoreChangesDialog::OnCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
   switch (wID)
   {
      case IDOK:
      {
         if (wNotifyCode == BN_CLICKED)
         {
            int end_code = onOKButton();
            if (end_code != -1)
            {
               EndDialog(end_code);
            }
         }
         break;
      }
      case IDCANCEL:
      {
         if (wNotifyCode == BN_CLICKED)
         {
            // 0 => no changes made
            EndDialog(NO_CHANGES);
         }
         break;
      }
      case IDC_CHANGE:
      {
         if (wNotifyCode == BN_CLICKED)
         {
            enable();
         }
         break;
      }
      case IDC_DNS:
      {
         if (wNotifyCode == EN_CHANGE)
         {
            enable();
         }
         break;
      }
      default:
      {
		  bHandled = false;
         break;
      }
   }

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\nethelpids.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#define IDH_IDENT_FULL_NAME			5101
#define IDH_IDENT_MEMBER_OF			5102
#define IDH_IDENT_CHANGE_BUTTON			5103
#define IDH_IDENT_CHANGES_NEW_NAME		5104
#define IDH_IDENT_CHANGES_PREVIEW_NAME	5105
#define IDH_IDENT_CHANGES_MORE_BUTTON		5106
#define IDH_IDENT_CHANGES_MEMBER_DOMAIN	5107
#define IDH_IDENT_CHANGES_MEMBER_DOMAIN_TEXTBOX	5108
#define IDH_IDENT_CHANGES_MEMBER_WORKGRP	5109
#define IDH_IDENT_CHANGES_MEMBER_WORKGRP_TEXTBOX 5110
#define IDH_IDENT_NAMES_DNS_NAME		5111
#define IDH_IDENT_NAMES_CHANGE_DNS_CHECKBOX 5112
#define IDH_IDENT_NAMES_NETBIOS_NAME		5113

#define IDH_WBEM_NETID_COMPUTER_DESCRIPTION		13001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\netidpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __NETWORKIDPAGE__
#define __NETWORKIDPAGE__
#pragma once

#include "atlsnap.h"
#include "resource.h"
#include "state.h"
#include "..\Common\WbemPageHelper.h"

//---------------------------------------------------------------------
class NetworkIDPage : public CSnapInPropertyPageImpl<NetworkIDPage>,
						public WBEMPageHelper
{
public:

	NetworkIDPage(WbemServiceThread *serviceThread,
					LONG_PTR lNotifyHandle, 
					bool bDeleteHandle = false, 
					TCHAR* pTitle = NULL);

	~NetworkIDPage();

	enum { IDD = IDD_NETID };

	typedef CSnapInPropertyPageImpl<NetworkIDPage> _baseClass;

	BEGIN_MSG_MAP(NetworkIDPage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInit)
		MESSAGE_HANDLER(WM_ASYNC_CIMOM_CONNECTED, OnConnected)
		COMMAND_HANDLER(IDC_CHANGE, BN_CLICKED, OnChangeBtn)
		COMMAND_HANDLER(IDC_NETID_COMMENT, EN_CHANGE, OnComment)
		MESSAGE_HANDLER(WM_HELP, OnF1Help)
		MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextHelp)
		CHAIN_MSG_MAP(_baseClass)
	END_MSG_MAP()

	// Handler prototypes:
	LRESULT OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnConnected(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnChangeBtn(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnComment(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	BOOL OnApply();
	LRESULT OnF1Help(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
	State m_state;
	CWbemClassObject m_computer;
	CWbemClassObject m_OS;
	CWbemClassObject m_DNS;

	void refresh();
	bool CimomIsReady();

	LONG_PTR m_lNotifyHandle;
	bool m_bDeleteHandle;

};

#endif __NETWORKIDPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\moredlg.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef MOREDLG_HPP_INCLUDED
#define MOREDLG_HPP_INCLUDED
#pragma once

#include "resource.h"

#include "..\Common\WbemPageHelper.h"
#include <chstring.h>
#include "state.h"

//---------------------------------------------------------------------
class MoreChangesDialog : public CDialogImpl<MoreChangesDialog>,
						public WBEMPageHelper
{
public:

	MoreChangesDialog(WbemServiceThread *serviceThread,
						State &state);
	virtual ~MoreChangesDialog();

	enum ExecuteResult
    {
       NO_CHANGES,
       CHANGES_MADE
    };

	enum { IDD = IDD_MORE };

	BEGIN_MSG_MAP(MoreChangesDialog)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInit)
		COMMAND_HANDLER(IDC_CHANGE, BN_CLICKED, OnCommand)
	END_MSG_MAP()

	// Handler prototypes:
	LRESULT OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:
	void enable();
	int onOKButton();

	State &m_state;
};

#endif MOREDLG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\netidpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "..\Common\ServiceThread.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "resource.h"
#include "..\common\util.h"
#include "NetIDPage.h"
#include "NetHelpIDs.h"
#include "iddlg.h"
#include "NetUtility.h"
#include <dsrole.h>

//---------------------------------------------------------------------
NetworkIDPage::NetworkIDPage(WbemServiceThread *serviceThread,
							 LONG_PTR lNotifyHandle, 
							 bool bDeleteHandle, 
							 TCHAR* pTitle) 
						: WBEMPageHelper(serviceThread),
							CSnapInPropertyPageImpl<NetworkIDPage> (pTitle),
							m_lNotifyHandle(lNotifyHandle),
							m_bDeleteHandle(bDeleteHandle) // Should be true for only page.
{
}

//-------------------------------------------------------------
NetworkIDPage::~NetworkIDPage()
{
}

//-------------------------------------------------------------
bool NetworkIDPage::CimomIsReady()
{
	m_hDlg = m_hWnd;

	bool retval = ServiceIsReady(NO_UI, 0, 0);

	if(retval)
	{
		// This where it should be marshalling into THIS thread.
		m_WbemServices = g_serviceThread->m_WbemServices;

		IWbemClassObject *pInst = NULL;

		if((pInst = FirstInstanceOf("Win32_ComputerSystem")) != NULL)
		{
			m_computer = pInst;
		}

		if((pInst = FirstInstanceOf((bstr_t)"Win32_OperatingSystem")) != NULL)
		{
			m_OS = pInst;
		}

		if((pInst = FirstInstanceOf((bstr_t)"Win32_NetworkAdaptorConfiguration")) != NULL)
		{
			m_DNS = pInst;
		}
		m_state.Init(m_computer, m_OS, m_DNS);
	}
	return retval;
}

//-------------------------------------------------------
LRESULT NetworkIDPage::OnChangeBtn(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
/*    IDChangesDialog dlg(g_serviceThread, m_state);
    dlg.DoModal();
    if(m_state.MustReboot())
    {
       PropSheet_RebootSystem(GetParent());
    }
    m_state.Refresh();
    refresh();*/
	return S_OK;
}

//----------------------------------------------------------
TCHAR szCommentReg[]  = TEXT( "System\\ControlSet001\\Services\\LanmanServer\\Parameters" );

void NetworkIDPage::refresh()
{
    //
    // Pre-append the computer name onto the DNS domain name.
    //
    _bstr_t bstrComputer = m_computer.GetString("Name");
    _bstr_t bstrDomain   = m_computer.GetString("Domain");

    bstrComputer += _T(".");
    bstrComputer += bstrDomain;

    _tcslwr(bstrComputer);

    SetDlgItemText(IDC_COMPUTER, bstrComputer);

    SetDlgItemText(IDC_DOMAIN, bstrDomain);

    SetDlgItemText(IDC_NETID_COMMENT, 
					m_OS.GetString("Description"));


	BOOL enable = FALSE;
	HWND hwnd = ::GetDlgItem(m_hWnd, IDC_NETID_COMMENT);
	RemoteRegWriteable(szCommentReg, enable);
	::EnableWindow(hwnd, enable);
	::SendMessage(hwnd, EM_LIMITTEXT, 48, 0);


#ifdef NO_SYSTEM_CPL_EQUIVALENT_BEHAVIOR
	TCHAR temp[50] = {0};

	DWORD role = (DWORD)m_computer.GetLong("DomainRole");

	bool memberOfWorkgroup = ((role == DsRole_RoleStandaloneWorkstation) ||
								(role == DsRole_RoleStandaloneServer));

	::LoadString(HINST_THISDLL,
					(memberOfWorkgroup ?
						IDS_MEMBER_OF_WORKGROUP :
						IDS_MEMBER_OF_DOMAIN),
					temp, 50);

   SetDlgItemText(IDC_MEMBER_OF, temp);
#endif // NO_SYSTEM_CPL_EQUIVALENT_BEHAVIOR

   //bool show_change = IsCurrentUserAdministrator()
	//				  && !m_state.IsMachineDC()
	//				  && (m_state.IsNetworkingInstalled() || 
	//						m_state.IsMemberOfWorkgroup());

   //::EnableWindow(GetDlgItem(IDC_CHANGE), show_change);

   ::ShowWindow(GetDlgItem(IDC_SAVING_MESSAGE),
					m_state.NeedsReboot() ? SW_SHOW : SW_HIDE);
}


//----------------------------------------------------------
LRESULT NetworkIDPage::OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	if(CimomIsReady())
	{
		refresh();
	}
	else
	{
		if(g_serviceThread)
		{
			g_serviceThread->SendPtr(m_hWnd);
		}

		// no connection yet.
		TCHAR msg[50] = {0};

		::LoadString(HINST_THISDLL, IDS_UNAVAILABLE, msg, 50);

		SetDlgItemText(IDC_COMPUTER, msg);
		SetDlgItemText(IDC_DOMAIN, msg);
		SetDlgItemText(IDC_NETID_COMMENT, msg);

		HWND hwnd = ::GetDlgItem(m_hWnd, IDC_NETID_COMMENT);
		::EnableWindow(hwnd, FALSE);
		::SendMessage(hwnd, EM_LIMITTEXT, 48, 0);


		::EnableWindow(GetDlgItem(IDC_CHANGE), FALSE);
	    ::ShowWindow(GetDlgItem(IDC_SAVING_MESSAGE), SW_HIDE);
	}

	return S_OK;
}

//----------------------------------------------------------
LRESULT NetworkIDPage::OnConnected(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	if(lParam)
	{
		IStream *pStream = (IStream *)lParam;
		IWbemServices *pServices = 0;
		HRESULT hr = CoGetInterfaceAndReleaseStream(pStream,
											IID_IWbemServices,
											(void**)&pServices);
		if(SUCCEEDED(hr))
		{
			SetWbemService(pServices);

			if(CimomIsReady())
			{
				refresh();
			}
		}
	}
	else
	{
		::EnableWindow(GetDlgItem(IDC_NETID_COMMENT), FALSE);
	}

	return S_OK;
}

//--------------------------------------------------------------
LRESULT NetworkIDPage::OnComment(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	// activate Apply for the comment change
	::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
	return S_OK; 
}

//--------------------------------------------------------------
static const DWORD _help_map[] =
{
   IDC_COMPUTER,        IDH_IDENT_FULL_NAME,
   IDC_FULL_NAME,       IDH_IDENT_FULL_NAME,
   IDC_MEMBER_OF,       IDH_IDENT_MEMBER_OF,
   IDC_DOMAIN,          IDH_IDENT_MEMBER_OF,
   IDC_CHANGE,          IDH_IDENT_CHANGE_BUTTON,
   IDC_COMMENT,			IDH_WBEM_NETID_COMPUTER_DESCRIPTION,
   IDC_NETID_COMMENT,   IDH_WBEM_NETID_COMPUTER_DESCRIPTION,
   IDC_NETID_SELECT_ICON,   -1,
   IDC_PARA,				IDH_NO_HELP,
   0, 0
};

LRESULT NetworkIDPage::OnF1Help(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
				L"sysdm.hlp", 
				HELP_WM_HELP, 
				(ULONG_PTR)(LPSTR)_help_map);
	return S_OK;
}

//--------------------------------------------------------------
LRESULT NetworkIDPage::OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	::WinHelp((HWND)wParam,
				L"sysdm.hlp", 
				HELP_CONTEXTMENU, 
				(ULONG_PTR)(LPSTR)_help_map);
	return S_OK;
}

//--------------------------------------------------------------
BOOL NetworkIDPage::OnApply()
{
	WCHAR szMsg[49] = {0};
	HRESULT hr = 0;

	CWindow msgHWND(GetDlgItem(IDC_NETID_COMMENT));

	BOOL modified = (BOOL)msgHWND.SendMessage(EM_GETMODIFY);

	if((bool)m_WbemServices && modified)
	{
		::GetWindowText(msgHWND, szMsg, ARRAYSIZE(szMsg));

		//Now create a new Instance and populate only the properties which are modified
		CWbemClassObject newinst = m_OS.SpawnInstance();
		hr = newinst.Put("Description", (bstr_t)szMsg);
		_bstr_t name;
		hr = m_OS.Get("Name",name);
		hr = newinst.Put("Name",name);
		hr = m_WbemServices.PutInstance(newinst);
		if(FAILED(hr))
		{
			TCHAR caption[50] = {0}, text[500] = {0};

			::LoadString(HINST_THISDLL, 
							IDS_DISPLAY_NAME,
							caption, 50);

			::LoadString(HINST_THISDLL, 
							IDS_CANT_WRITE_COMMENT,
							text, 500);

			::MessageBox(NULL, text, caption,
						MB_OK | MB_ICONHAND);

		}
	}

	return TRUE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\netutility.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// global utility functions
// 
// 8-14-97 sburns

                           
// KMH: originally named burnslib\utility.* but that filename was
// getting a little overused.

#ifndef UTILITY_HPP_INCLUDED
#define UTILITY_HPP_INCLUDED

#include <chstring.h>
#include <dsrole.h>

//TODO
#define SRV_RECORD_RESERVE = 100
#define MAX_NAME_LENGTH = 2-SRV_RECORD_RESERVE
#define MAX_LABEL_LENGTH = 2

#define BREAK_ON_FAILED_HRESULT(hr)                               \
   if (FAILED(hr))                                                \
   {                                                              \
      TRACE_HRESULT(hr);                                          \
      break;                                                      \
   }



void
error(HWND           parent,
	   HRESULT        hr,
	   const CHString&  message,
	   const CHString&  title);



void error(HWND           parent,
		   HRESULT        hr,
		   const CHString&  message);


void error(HWND           parent,
		   HRESULT        hr,
		   const CHString&  message,
		   int            titleResID);



void error(HWND           parent,
		   HRESULT        hr,
		   int            messageResID,
		   int            titleResID);



void error(HWND           parent,
		   HRESULT        hr,
		   int            messageResID);



// Sets or clears a bit, or set of bits.
// 
// bits - bit set where bits will be set.
// 
// mask - mask of bits to be effected.
// 
// state - true to set the mask bits, false to clear them.

void FlipBits(long& bits, long mask, bool state);



// Present a message box dialog, set input focus back to a given edit
// box when the dialog is dismissed.
// 
// parentDialog - the parent window containing the control to receive focus.
//
// editResID - Resource ID of the edit box to which focus will be set.
// 
// errStringResID - Resource ID of the message text to be shown in the
// dialog.  The title of the dialog is "Error".

void gripe(HWND  parentDialog,
		   int   editResID,
		   int   errStringResID);



// Present a message box dialog, set input focus back to a given edit
// box when the dialog is dismissed.  The title of the message box is "Error".
// 
// parentDialog - the parent window containing the control to receive focus.

// editResID - Resource ID of the edit box to which focus will be set.
//
// message - Text to appear in the dialog.  The title is "Error".

void gripe(HWND           parentDialog,
		   int            editResID,
		   const CHString&  message);


void gripe(HWND           parentDialog,
		   int            editResID,
		   const CHString&  message,
		   int            titleResID);


// Present a message box dialog, set input focus back to a given edit
// box when the dialog is dismissed.
//
// parentDialog - the parent window containing the control to receive focus.
// 
// editResID - Resource ID of the edit box to which focus will be set.
//
// message - Text to appear in the dialog.
//
// title - The title of the message box.  An empty String causes the title
// to be "Error".

void gripe(HWND           parentDialog,
		   int            editResID,
		   const CHString&  message,
		   const CHString&  title);



void gripe(HWND           parentDialog,
		   int            editResID,
		   HRESULT        hr,
		   const CHString&  message,
		   const CHString&  title);



void gripe(HWND           parentDialog,
		   int            editResID,
		   HRESULT        hr,
		   const CHString&  message,
		   int            titleResID);



// Returns the HINSTANCE of the DLL designated to contain all resources. 
//
// This function requires that the first module loaded (whether it be a DLL or
// EXE) set the global variable hResourceModuleHandle to the HINSTANCE of the
// module (DLL or EXE) that contains all of the program's binary resources.
// This should be done as early as possible in the module's startup code.


// Returns true if current process token contains administrators membership.

bool IsCurrentUserAdministrator();



// Returns true if tcp/ip protocol is installed and bound.

bool IsTCPIPInstalled();


// Return the next highest whole number greater than n if the
// fractional portion of n >= 0.5, otherwise return n.

int Round(double n);

CHString GetTrimmedDlgItemText(HWND parentDialog, UINT itemResID);

void StringLoad(UINT resID, LPCTSTR buf, UINT size);

#endif UTILITY_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\perfpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __PERFPAGE__
#define __PERFPAGE__
#pragma once

#include "..\Common\WbemPageHelper.h"
#include "VirtualMemDlg.h"

//-----------------------------------------------------------------------------
//  Reboot switch for crashdump dlg
#define RET_ERROR               (-1)
#define RET_NO_CHANGE           0x00
#define RET_VIRTUAL_CHANGE      0x01
#define RET_RECOVER_CHANGE      0x02
#define RET_CHANGE_NO_REBOOT    0x04
#define RET_CONTINUE            0x08
#define RET_BREAK               0x10

#define RET_VIRT_AND_RECOVER (RET_VIRTUAL_CHANGE | RET_RECOVER_CHANGE)

class PerfPage : public WBEMPageHelper
{
private:

	VirtualMemDlg *m_VDlg;
	CWbemClassObject m_os;

	// the current values.
    long    m_appBoost;
    long    m_quantType;
    long    m_quantLength;
    DWORD   m_dwPrevCacheOption;
    DWORD   m_dwCurCacheOption;
    
	// before and after states of the radio buttons.
	bool    m_wasWorkstation;
	bool    m_nowWorkstation;

	void Init(void);

public:

    PerfPage(WbemServiceThread *serviceThread);
	~PerfPage();
	INT_PTR DoModal(HWND hDlg);

	INT_PTR CALLBACK DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
};

INT_PTR CALLBACK StaticPerfDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);

#endif __PERFPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\perfpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "PerfPage.h"

// avoid some warnings.
#undef HDS_HORZ
#undef HDS_BUTTONS
#undef HDS_HIDDEN
#include "resource.h"
#include <stdlib.h>
#include <TCHAR.h>
#include "..\Common\util.h"
#include <windowsx.h>
#include "helpid.h"

DWORD aPerformanceHelpIds[] = {
    IDOK,                        IDH_NO_HELP,
    IDCANCEL,                    IDH_NO_HELP,
    IDC_PERF_VM_ALLOCD,          (IDH_PERF + 1),
    IDC_PERF_VM_ALLOCD_LABEL,    (IDH_PERF + 1),
    IDC_PERF_GROUP,              IDH_NO_HELP,
    IDC_PERF_TEXT,               (IDH_PERF + 3),
    IDC_PERF_VM_ALLOCD_TEXT,     IDH_NO_HELP,
    IDC_PERF_WORKSTATION,        (IDH_PERF + 4),
    IDC_PERF_SERVER,             (IDH_PERF + 5),
    IDC_PERF_VM_GROUP,           IDH_NO_HELP,
    IDC_PERF_VM_ALLOCD_TEXT,     IDH_NO_HELP,
    IDC_PERF_CHANGE,             (IDH_PERF + 7),
    IDC_PERF_CACHE_GROUP,        IDH_NO_HELP,
    IDC_PERF_CACHE_TEXT,         IDH_NO_HELP,
    IDC_PERF_CACHE_TEXT2,        IDH_NO_HELP,
    IDC_PERF_APPS,               (IDH_PERF + 14),
    IDC_PERF_SYSCACHE,           (IDH_PERF + 15),
    0, 0
};


#define PROCESS_PRIORITY_SEPARATION_MIN     0
#define PROCESS_PRIORITY_SEPARATION_MAX     2

#define PERF_TYPEVARIABLE       1
#define PERF_TYPEFIXED          2

#define PERF_LENLONG            1
#define PERF_LENSHORT           2

#define OPTIMIZE_APPS           0
#define OPTIMIZE_CACHE          1

INT_PTR CALLBACK StaticPerfDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) 
{ 
	// if this is the initDlg msg...
	if(message == WM_INITDIALOG)
	{
		// transfer the 'this' ptr to the extraBytes.
		SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
	}

	// DWL_USER is the 'this' ptr.
	PerfPage *me = (PerfPage *)GetWindowLongPtr(hwndDlg, DWLP_USER);

	if(me != NULL)
	{
		// call into the DlgProc() that has some context.
		return me->DlgProc(hwndDlg, message, wParam, lParam);
	} 
	else
	{
		return FALSE;
	}
}
//--------------------------------------------------------------
PerfPage::PerfPage(WbemServiceThread *serviceThread)
				: WBEMPageHelper(serviceThread)
{
    m_dwPrevCacheOption = m_dwCurCacheOption = 0;
	m_nowWorkstation = m_wasWorkstation = false;
	IWbemClassObject *pInst = NULL;

	// NOTE: This one's a little different. I create it right away so
	// I can use it as a helper even before I put up its' dlg.
	m_VDlg = new VirtualMemDlg(g_serviceThread);

	// its all in one class.
	if((pInst = FirstInstanceOf("Win32_OperatingSystem")) != NULL)
	{
		m_os = pInst;
	}
}
//--------------------------------------------------------------
INT_PTR PerfPage::DoModal(HWND hDlg)
{
   return DialogBoxParam(HINST_THISDLL,
						(LPTSTR) MAKEINTRESOURCE(IDD_PERFORMANCE),
						hDlg, StaticPerfDlgProc, (LPARAM)this);
}

//--------------------------------------------------------------
PerfPage::~PerfPage()
{
	delete m_VDlg;
}
//--------------------------------------------------------------
INT_PTR CALLBACK PerfPage::DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) 
{ 
    static BOOL fVMInited = FALSE;
    DWORD dw;
	HRESULT hr = 0;
    BOOL bDirty = FALSE;

	m_hDlg = hwndDlg;

	switch (message) 
	{
	case WM_INITDIALOG:
		Init();
		return TRUE; 
		break;

    case WM_DESTROY:
        // If the dialog box is going away, then close the
        // registry key.
        if (fVMInited) 
		{
//            VirtualFreeStructures();
        }
        break;

    case WM_COMMAND: 
		
        switch (LOWORD(wParam)) 
		{
        case IDC_PERF_CHANGE: 

			dw = m_VDlg->DoModal(m_hDlg);

			if (fVMInited) 
			{
				unsigned long val = 0;
				m_VDlg->ComputeAllocated(&val);
	            SetDlgItemMB(m_hDlg, IDC_PERF_VM_ALLOCD, val);
			}

			if((dw != RET_NO_CHANGE) && 
			   (dw != RET_CHANGE_NO_REBOOT)) 
			{
				MsgBoxParam(m_hDlg, SYSTEM + 39, IDS_TITLE,
							MB_OK | MB_ICONINFORMATION);

                g_fRebootRequired = TRUE;
			}
          
            break;
        case IDC_PERF_WORKSTATION:
            if(BN_CLICKED == HIWORD(wParam)) 
			{
				m_nowWorkstation = true;

                // Workstations have maximum foreground boost
                m_appBoost = PROCESS_PRIORITY_SEPARATION_MAX;

                // Workstations have variable, short quanta
                m_quantLength = PERF_LENSHORT;
                m_quantType = PERF_TYPEVARIABLE;
            }  
            break;

        case IDC_PERF_SERVER:
            if(BN_CLICKED == HIWORD(wParam)) 
			{
				m_nowWorkstation = false;

                // Servers have minimum foreground boost
                m_appBoost = PROCESS_PRIORITY_SEPARATION_MIN;

                // Servers have fixed, long quanta
                m_quantLength = PERF_LENLONG;
                m_quantType = PERF_TYPEFIXED;
            }
            break;

        case IDC_PERF_APPS:
            if(BN_CLICKED == HIWORD(wParam)) 
            {
                m_dwCurCacheOption = OPTIMIZE_APPS;
            }
            break;

        case IDC_PERF_SYSCACHE:
            if(BN_CLICKED == HIWORD(wParam)) 
            {
                m_dwCurCacheOption = OPTIMIZE_CACHE;
            }
            break;

		case IDOK:
			if (m_wasWorkstation != m_nowWorkstation)       // Change?
            {
				if((bool)m_os)
				{
					hr = m_os.Put(_T("ForegroundApplicationBoost"),
                                     variant_t((BYTE)m_appBoost));
					hr = m_os.Put(_T("QuantumType"),
                                      variant_t((BYTE)m_quantType));
					hr = m_os.Put(_T("QuantumLength"),
                                      variant_t((BYTE)m_quantLength));
                    bDirty = TRUE;
                }
                else
                {
                    MsgBoxParam(m_hDlg, IDS_LOST_CONNECTION, IDS_TITLE,
                                MB_OK | MB_ICONINFORMATION);
                    EndDialog(m_hDlg, 0);
                }
            }

            if (m_dwPrevCacheOption != m_dwCurCacheOption)  // Change?
			{
				if((bool)m_os)
				{
                    hr = m_os.Put(_T("LargeSystemCache"),
                                  (long)m_dwCurCacheOption);
                    if (SUCCEEDED(hr))
                    {
                        bDirty = TRUE;
                    }
                }
                else
                {
                    MsgBoxParam(m_hDlg, IDS_LOST_CONNECTION, IDS_TITLE,
                                MB_OK | MB_ICONINFORMATION);
                    EndDialog(m_hDlg, 0);
                }
            }

            if (bDirty)
            {
                hr = m_WbemServices.PutInstance(m_os,
                                                WBEM_FLAG_CREATE_OR_UPDATE);
            }
            EndDialog(m_hDlg, 0);
            break;

        case IDCANCEL:
            EndDialog(m_hDlg, 0);
            break;

        default: 
            break;
        } //endswitch LOWORD

        break;

    case WM_HELP:      // F1
		::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
					L"sysdm.hlp", 
					HELP_WM_HELP, 
					(ULONG_PTR)(LPSTR)aPerformanceHelpIds);

        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND)wParam, HELP_FILE, HELP_CONTEXTMENU,
		        (ULONG_PTR)(LPSTR)aPerformanceHelpIds);
        break;

    default:
        return FALSE;
	} 

	return FALSE; 
}

//--------------------------------------------------------------------
TCHAR szPriKey[]  = TEXT("System\\CurrentControlSet\\Control\\PriorityControl");

void PerfPage::Init(void)
{
	HRESULT h1 = 0, h2 = 0, h3 = 0;
    HRESULT hr;

	// if anything goes wrong, act like a server.
    m_appBoost = PROCESS_PRIORITY_SEPARATION_MIN;
    m_quantType = PERF_TYPEVARIABLE;
    m_quantLength = PERF_LENLONG;

	// if the class was found...
	if((bool)m_os)
	{
		// NOTE: I want the return codes. Dont use GetLong() is the case.
		h1 = m_os.Get(_T("QuantumType"), m_quantType);
		h2 = m_os.Get(_T("QuantumLength"), m_quantLength);
		h3 = m_os.Get(_T("ForegroundApplicationBoost"), m_appBoost);

		// did it all work?
		if((h1 == 0) && (h2 == 0) && (h3 == 0))
		{
			//-----------------------------------------
			// Short, Variable Quanta (or 2 zeros) == Workstation-like interactive response.
			// Long, Fixed Quanta == Server-like interactive response.
			if(((m_quantLength == PERF_LENSHORT) && 
			   (m_quantType == PERF_TYPEVARIABLE)) ||

			   ((m_quantLength == 0) &&			// defaults to workstation...
			   (m_quantType == 0))
			  )
			{
				m_appBoost = PROCESS_PRIORITY_SEPARATION_MAX;
			
				// to optimize Puts later.
				m_nowWorkstation = m_wasWorkstation = true;

				Button_SetCheck(GetDlgItem(m_hDlg, IDC_PERF_WORKSTATION),
									BST_CHECKED);

				Button_SetCheck(GetDlgItem(m_hDlg, IDC_PERF_SERVER),
									BST_UNCHECKED);

			}
			else // its a server.
			{
				m_appBoost = PROCESS_PRIORITY_SEPARATION_MIN;
				m_nowWorkstation = m_wasWorkstation = false;

				Button_SetCheck(GetDlgItem(m_hDlg, IDC_PERF_WORKSTATION),
									BST_UNCHECKED);

				Button_SetCheck(GetDlgItem(m_hDlg, IDC_PERF_SERVER),
									BST_CHECKED);

			}

			BOOL writable = TRUE;
			// NOTE: for backwards compability with wmi builds that didn't have this
			// method (in RemoteRegWriteable()), assume 'true' unless a newer build says you cant do this.

			RemoteRegWriteable(szPriKey, writable);
			::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_WORKSTATION), writable);
			::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_SERVER), writable);

		} // endif it worked

    }
	else
	{
		::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_WORKSTATION), FALSE);
		::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_SERVER), FALSE);
        ::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_APPS), FALSE);
        ::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_SYSCACHE), FALSE);
	} //endif class was found.

    //
    // Get LargeSystemCache property and set controls correspondingly.
    //
    hr = m_os.Get(_T("LargeSystemCache"), (long&)m_dwPrevCacheOption);

    if (SUCCEEDED(hr))
    {
        if (m_dwPrevCacheOption == OPTIMIZE_APPS)
        {
            Button_SetCheck(GetDlgItem(m_hDlg, IDC_PERF_APPS),
                                       BST_CHECKED);
            Button_SetCheck(GetDlgItem(m_hDlg, IDC_PERF_SYSCACHE),
                                       BST_UNCHECKED);
        }
        else if (m_dwPrevCacheOption == OPTIMIZE_CACHE)
        {
            Button_SetCheck(GetDlgItem(m_hDlg, IDC_PERF_APPS),
                                       BST_UNCHECKED);
            Button_SetCheck(GetDlgItem(m_hDlg, IDC_PERF_SYSCACHE),
                                       BST_CHECKED);
        }
        else        // Unsupported/unknown value - disable the controls.
        {
            ::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_APPS), FALSE);
            ::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_SYSCACHE), FALSE);
        }
    }
    else
    {
        ::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_APPS), FALSE);
        ::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_SYSCACHE), FALSE);
    }

    // Init the virtual memory part.
	unsigned long vAlloc = 0;
	bool enable = m_VDlg->ComputeAllocated(&vAlloc);
	if(enable)
	{
		SetDlgItemMB( m_hDlg, IDC_PERF_VM_ALLOCD, vAlloc );
	}
	else
	{
		::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_VM_ALLOCD_LABEL), FALSE);
		::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_VM_ALLOCD), FALSE);
		::EnableWindow(GetDlgItem(m_hDlg, IDC_PERF_CHANGE), FALSE);
		MsgBoxParam(m_hDlg, IDS_NO_VM, IDS_TITLE, MB_OK|MB_ICONWARNING);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\precomp.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED_)
#define AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif

#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
};

extern CExeModule  _Module;

#include <atlcom.h>
#include <atlwin.h>
#include <math.h>


#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif



//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\netutility.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// global utility functions
// 
// 8-14-97 sburns


// KMH: originally named burnslib\utility.* but that filename was
// getting a little overused.

// threadsafe

#include "precomp.h"
#include "netUtility.h"

int Round(double n)
{
   int n1 = (int) n;
   if (n - n1 >= 0.5)
   {
      return n1 + 1;
   }

   return n1;
}



// threadsafe

void gripe(HWND parentDialog, int editResID, int errStringResID)
{
   //gripe(parentDialog, editResID, String::load(errStringResID));
}



void gripe(HWND           parentDialog,
		   int            editResID,
		   const CHString&  message,
		   int            titleResID)
{
   //gripe(parentDialog, editResID, message, String::load(titleResID));
}



void gripe(HWND parentDialog,
		   int editResID,
		   const CHString& message,
		   const CHString& title)
{
//   ATLASSERT(::IsWindow(parentDialog));   
//   ATLASSERT(!message.empty());
//   ATLASSERT(editResID > 0);

   ::MessageBox(parentDialog, message,
				title, MB_OK | MB_ICONERROR | MB_APPLMODAL);

   HWND edit = ::GetDlgItem(parentDialog, editResID);
   ::SendMessage(edit, EM_SETSEL, 0, -1);
   ::SetFocus(edit);
}



void gripe(HWND           parentDialog,
		   int            editResID,
		   HRESULT        hr,
		   const CHString&  message,
		   int            titleResID)
{
   //gripe(parentDialog, editResID, hr, message, String::load(titleResID));
}
   


void gripe(HWND           parentDialog,
		   int            editResID,
		   HRESULT        hr,
		   const CHString&  message,
		   const CHString&  title)
{
   //error(parentDialog, hr, message, title);

   HWND edit = ::GetDlgItem(parentDialog, editResID);
   ::SendMessage(edit, EM_SETSEL, 0, -1);
   ::SetFocus(edit);
}


// threadsafe

void gripe(HWND parentDialog, int editResID, const CHString& message)
{
   //gripe(parentDialog, editResID, message, String());
}



void FlipBits(long& bits, long mask, bool state)
{
 //  ATLASSERT(mask);

   if (state)
   {
      bits |= mask;
   }
   else
   {
      bits &= ~mask;
   }
}



void error(HWND           parent,
		   HRESULT        hr,
		   const CHString&  message)
{
   //error(parent, hr, message, String());
}



void error(HWND           parent,
		   HRESULT        hr,
		   const CHString&  message,
		   int            titleResID)
{
   //ATLASSERT(titleResID > 0);

   //error(parent, hr, message, String::load(titleResID));
}



void error(HWND           parent,
		   HRESULT        hr,
		   const CHString&  message,
		   const CHString&  title)
{
//   ATLASSERT(::IsWindow(parent));
//   ATLASSERT(!message.empty());

   CHString new_message = message + TEXT("\n\n");
   if (FAILED(hr))
   {
      if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
      {
//         new_message +=  GetErrorMessage(hr & 0x0000ffff);
      }
      else
      {
//         new_message += CHString::Format(IDS_HRESULT_SANS_MESSAGE, hr);
      }
   }

   MessageBox(parent, new_message,
				title, MB_ICONERROR | MB_OK | MB_APPLMODAL);
}



void error(HWND           parent,
		   HRESULT        hr,
		   int            messageResID,
		   int            titleResID)
{
//   error(parent, hr, String::load(messageResID), String::load(titleResID));
}



void error(HWND           parent,
		   HRESULT        hr,
		   int            messageResID)
{
  // error(parent, hr, String::load(messageResID));
}



bool IsCurrentUserAdministrator()
{
   bool result = false;
/*   do
   {
      // Create a SID for the local Administrators group
      SID_IDENTIFIER_AUTHORITY authority = SECURITY_NT_AUTHORITY;
      PSID admin_group_sid = 0;
      if (
         !::AllocateAndInitializeSid(
            &authority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0,
            0,
            0,
            0,
            0,
            0,
            &admin_group_sid) )
      {
         break;
      }

      BOOL is_member = FALSE;
      if (::CheckTokenMembership(0, admin_group_sid, &is_member))
      {
         result = is_member ? true : false;
      }

      ::FreeSid(admin_group_sid);
   }
   while (0);
*/
   return result;
}



bool IsTCPIPInstalled()
{

/*   HKEY key = 0;
   LONG result =
      Win::RegOpenKeyEx(
         HKEY_LOCAL_MACHINE,
         TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Linkage"),
         KEY_QUERY_VALUE,
         key);

   if (result == ERROR_SUCCESS)
   {
      DWORD data_size = 0;
      result =
         Win::RegQueryValueEx(
            key,
            TEXT("Export"),
            0,
            0,
            &data_size);
      ATLASSERT(result == ERROR_SUCCESS);

      if (data_size > 2)
      {
         // the value is non-null
         return true;
      }
   }
*/
   return false;
}



CHString GetTrimmedDlgItemText(HWND parentDialog, UINT itemResID)
{
//   ATLASSERT(IsWindow(parentDialog));
//   ATLASSERT(itemResID > 0);

   HWND item = GetDlgItem(parentDialog, itemResID);
   if (!item)
   {
      // The empty string
      return CHString();
   }
   TCHAR temp[256] = {0};

   ::GetWindowText(item, temp, 256);
   return CHString(temp);
}


void StringLoad(UINT resID, LPCTSTR buf, UINT size)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\rebootpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __REBOOTPAGE__
#define __REBOOTPAGE__
#pragma once

#include "..\Common\WbemPageHelper.h"

//-----------------------------------------------------------------------------
class RebootPage : public WBEMPageHelper
{
private:

	void Init(HWND hDlg);
	bool Doit(HWND hDlg);

	CWbemClassObject m_OS;

public:

    RebootPage(WbemServiceThread *serviceThread);
	~RebootPage();
	INT_PTR DoModal(HWND hDlg);

	INT_PTR CALLBACK DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
};

INT_PTR CALLBACK StaticRebootDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);

#endif __REBOOTPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\startup.h ===
//*************************************************************
//
//  Startup.h   -    Header file for Startup.c
//
//  Microsoft Confidential
//  Copyright (c) 1996-1999 Microsoft Corporation
//  All rights reserved
//
//*************************************************************


HPROPSHEETPAGE CreateStartupPage (HINSTANCE hInst);
BOOL APIENTRY StartupDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
void StartListInit( HWND hDlg, WPARAM wParam, LPARAM lParam );
int StartListExit(HWND hDlg, WPARAM wParam, LPARAM lParam );
void StartListDestroy(HWND hDlg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by CMProps.rc
//
#define CX_CDWN_OFFS                    0
#define IDS_DRIVES_DISPLAY_NAME         1
#define IDB_WINDOWS                     1
#define IDS_DISPLAY_NAME                1
#define IDI_COMPUTER                    2
#define IDS_DESCRIPTION                 2
#define IDS_DEBUG                       4
#define IDS_XDOTX_MB                    5
#define IDS_PAGESIZE                    6
#define IDS_CONNECTING                  7
#define IDS_USERENVVARS                 8
#define IDS_BAD_CONNECT                 8
#define IDS_TITLE                       9
#define IDC_TEXT_1                      10
#define IDC_TEXT_2                      11
#define IDC_TEXT_3                      12
#define IDC_TEXT_4                      13
#define PERF_ICON                       14
#define ENVVAR_ICON                     15
#define CRASHDUMP_ICON                  16
#define IDC_ADV_PERF_ICON               17
#define IDC_ADV_PERF_TEXT               18
#define IDC_ADV_PERF_BTN                19
#define IDC_ADV_ENV_ICON                20
#define IDC_ADV_ENV_TEXT                21
#define IDC_ADV_ENV_BTN                 30
#define IDC_ADV_RECOVERY_ICON           40
#define IDC_ADV_RECOVERY_TEXT           41
#define IDC_ADV_RECOVERY_BTN            50
#define IDC_GEN_WINDOWS_IMAGE           51
#define IDC_GEN_VERSION_0               52
#define IDC_GEN_VERSION_1               53
#define IDC_GEN_VERSION_2               54
#define IDC_GEN_SERVICE_PACK            55
#define IDC_GEN_REGISTERED_0            56
#define IDC_GEN_REGISTERED_1            57
#define IDC_GEN_REGISTERED_2            58
#define IDC_GEN_REGISTERED_3            59
#define IDC_GEN_OEM_NUDGE               60
#define IDC_GEN_MACHINE                 61
#define IDC_GEN_OEM_IMAGE               62
#define IDC_GEN_MACHINE_0               63
#define IDC_GEN_MACHINE_1               64
#define IDC_GEN_MACHINE_2               65
#define IDC_GEN_MACHINE_3               66
#define IDC_GEN_MACHINE_4               67
#define IDC_GEN_MACHINE_5               68
#define IDC_GEN_OEM_SUPPORT             69
#define IDC_GEN_MACHINE_6               70
#define IDC_GEN_MACHINE_7               71
#define IDC_GEN_MACHINE_8               72
#define IDC_SUPPORT_TEXT                73
#define IDC_NETIDC_PASSWORD_GB          74
#define IDC_NETIDC_DOMAIN_BTN           75
#define IDC_MEMBER_OF                   76
#define IDC_CHANGE                      77
#define IDD_NETID                       80
#define IDC_NETID_DESC_LABEL            80
#define IDC_COMMENT                     80
#define IDD_NETID_CHANGE                81
#define IDC_NETID_SELECT_ICON           82
#define IDC_NETID_DESCRIPTION           83
#define IDC_NETID_COMPUTERNAME          84
#define IDC_DOMAIN                      85
#define IDC_NETIDC_STATIC_DESC          86
#define IDC_NETID_COMMENT               86
#define IDC_NETIDC_STATIC_COMPUTER      87
#define IDC_COMPUTER                    88
#define IDC_NETIDC_DOMAIN_GB            89
#define IDC_NETIDC_WRKG_BTN             90
#define IDC_NETIDC_WRKG_EDIT            91
#define IDC_NETIDC_DOMAIN_EDIT          92
#define IDC_NETIDC_PASSWORD_CHK         93
#define IDC_NETIDC_PASSWORD_DESC        94
#define IDC_NETIDC_STATIC_USERNAME      95
#define IDC_NETIDC_USERNAME_EDIT        96
#define IDC_NETIDC_STATIC_PASSWORD      97
#define IDC_NETIDC_PASSWORD_EDIT        98
#define IDC_SAVING_MESSAGE              99
#define IDD_USERPROFILE                 100
#define IDD_GENERAL                     101
#define IDD_PHONESUP                    102
#define IDD_PERFORMANCE                 103
#define IDD_STARTUP                     104
#define IDD_ENVVARS                     105
#define DLG_VIRTUALMEM                  106
#define IDD_ADVANCED                    107
#define IDD_ENVVAREDIT                  108
#define IDD_SHUTDOWN                    109
#define IDS_PROJNAME                    110
#define IDB_CMSNAPIN_16                 111
#define IDB_CMSNAPIN_32                 112
#define IDS_CMSNAPIN_DESC               114
#define IDS_CMSNAPIN_PROVIDER           115
#define IDS_CMSNAPIN_VERSION            116
#define IDR_CMSNAPIN                    117
#define IDS_XDOTX_MHZ                   117
#define IDC_ACCOUNT_WIZARD_BUTTON       119
#define IDC_PERF_VM_ALLOCD_LABEL        197
#define IDC_PERF_VM_GROUP               198
#define IDC_PERF_SERVER                 199
#define INITS                           200
#define IDC_PERF_CONTROL                200
#define IDC_PERF_SYSCACHE               200
#define IDC_PERF_CHANGE                 201
#define IDC_PERF_VM_ALLOCD              202
#define IDC_PARA                        202
#define IDC_PERF_GROUP                  203
#define IDC_ANIMATE                     203
#define IDC_PERF_FIXED                  204
#define IDC_PERF_CACHE_GROUP            204
#define IDC_PERF_VARIABLE               205
#define IDC_EXAMPLE                     205
#define IDC_PERF_SHORT                  206
#define IDC_PERF_LONG                   207
#define IDC_PERF_TEXT                   208
#define IDC_PERF_WORKSTATION            209
#define SYSTEM                          210
#define IDC_PERF_VM_ALLOCD_TEXT         210
#define IDC_PERF_APPS                   211
#define IDC_PERF_CACHE_TEXT             212
#define IDC_PERF_TEXT2                  213
#define IDC_PERF_VM_ALLOCD2             214
#define IDC_PERF_CACHE_TEXT2            215
#define IDS_CHANGINGUSER                262
#define IDS_MAXKILLERS                  263
#define IDC_STARTUP_SYS_OS              300
#define IDC_STARTUP_SYS_SECONDS         301
#define IDC_STARTUP_SYS_SECSCROLL       302
#define IDC_STARTUP_SYS_ENABLECOUNTDOWN 303
#define IDC_STARTUP_SYSTEM_GRP          304
#define IDS_ERR_PAGECREATE              305
#define IDC_STARTUP_SYSTEM_GRP2         305
#define IDS_ERR_HEADING                 306
#define IDC_STARTUP_CDMP_OPTIONS        306
#define IDC_ENVVAR_SYS_LB_SYSVARS       400
#define IDC_ENVVAR_SYS_SYSVARS          401
#define IDC_ENVVAR_SYS_LB_USERVARS      402
#define IDC_ENVVAR_SYS_VAR              403
#define IDC_ENVVAR_SYS_VALUE            404
#define IDC_ENVVAR_SYS_SETUV            405
#define IDC_ENVVAR_SYS_DELUV            406
#define IDC_ENVVAR_SYS_NEWSV            407
#define IDC_ENVVAR_SYS_EDITSV           408
#define IDC_ENVVAR_SYS_DELSV            409
#define IDC_ENVVAR_SYS_USERENV          410
#define IDC_ENVVAR_SYS_USERGROUP        411
#define IDC_ENVVAR_SYS_NEWUV            412
#define IDC_ENVVAR_SYS_EDITUV           413
#define IDC_ENVVAR_SYS_NDELUV           414
#define IDC_ENVVAR_EDIT_NAME_LABEL      415
#define IDC_ENVVAR_EDIT_NAME            416
#define IDC_ENVVAR_EDIT_VALUE_LABEL     417
#define IDC_ENVVAR_EDIT_VALUE           418
#define IDS_NEW_SYSVAR_CAPTION          420
#define IDS_EDIT_SYSVAR_CAPTION         421
#define IDS_NEW_USERVAR_CAPTION         422
#define IDS_EDIT_USERVAR_CAPTION        423
#define IDS_ERR_EXECMETHOD              424
#define IDS_ERR_EXECMETHOD_CAPTION      425
#define IDC_STARTUP_CDMP_GRP            601
#define IDC_STARTUP_CDMP_TXT1           602
#define IDC_STARTUP_CDMP_LOG            603
#define IDC_STARTUP_CDMP_SEND           604
#define IDC_STARTUP_CDMP_WRITE          605
#define IDC_STARTUP_CDMP_FILENAME       606
#define IDC_STARTUP_CDMP_OVERWRITE      607
#define IDC_STARTUP_CDMP_AUTOREBOOT     608
#define IDC_STARTUP_CDMP_KERNELONLY     609
#define IDC_STARTUP_SYS_SECONDS_LABEL   610
#define IDD_CHANGES                     700
#define IDC_NEW_NAME                    701
#define IDC_FULL_NAME                   702
#define IDC_WORKGROUP_BUTTON            703
#define IDC_FIND                        704
#define IDC_WORKGROUP                   705
#define IDD_MORE                        706
#define IDC_DNS                         707
#define IDC_NETBIOS                     709
#define IDD_CREDENTIALS                 710
#define IDC_NAME                        711
#define IDC_PASSWORD                    712
#define IDC_MESSAGE                     713
#define IDC_FULL_LABEL                  714
#define IDC_MORE                        715
#define IDC_GROUP                       716
#define IDC_DOMAIN_BUTTON               717
#define IDS_UNKNOWN                     718
#define IDS_DEFAULT_WORKGROUP           719
#define IDS_ERROR_READING_MEMBERSHIP    720
#define IDS_APP_TITLE                   721
#define IDS_MEMBER_OF_WORKGROUP         722
#define IDS_MEMBER_OF_DOMAIN            723
#define IDS_NON_RFC_NAME                724
#define IDS_BAD_DNS_SYNTAX              725
#define IDS_DNS_NAME_TOO_LONG           726
#define IDS_COMPUTER_NAME_TOO_LONG      727
#define IDS_BAD_COMPUTER_NAME_SYNTAX    728
#define IDS_VALIDATE_NAME_FAILED        729
#define IDS_JOIN_DOMAIN_FAILED          730
#define IDS_SHORT_NAME_CHANGE_FAILED    731
#define IDS_RENAME_FAILED_JOINED_WITH_OLD_NAME 732
#define IDS_SET_DOMAIN_DNS_NAME_FAILED  733
#define IDS_UNJOIN_FAILED               734
#define IDS_JOIN_WORKGROUP_FAILED       735
#define IDS_RENAME_FAILED               736
#define IDS_COMPUTER_ACCOUNT_ORPHANED   737
#define IDS_NAME_CHANGED                738
#define IDS_WORKGROUP_WELCOME           739
#define IDS_DOMAIN_WELCOME              740
#define IDS_MUST_REBOOT                 741
#define IDS_NAME_AND_MEMBERSHIP_MESSAGE 742
#define IDS_NAME_MESSAGE                743
#define IDS_RENAME_CREDENTIALS          744
#define IDS_NAME_TRUNCATED              745
#define IDS_NON_RFC_COMPUTER_NAME_SYNTAX 746
#define IDS_CANT_WRITE_COMMENT          747
#define IDS_LOST_CONNECTION             748
#define IDS_NO_VM                       749
#define IDS_NO_DUMP                     750
#define IDS_SMALL_DUMP                  751
#define IDS_KERNEL_DUMP                 752
#define IDS_COMPLETE_DUMP               753
#define IDC_GEN_OS_NAME                 1001
#define IDC_USERLIST                    1002
#define IDC_REBOOT                      1005
#define IDC_EDIT_BOOT_INI               1006
#define IDC_EDIT_BOOT_INI_LABEL         1018
#define IDC_LOGOFF                      1017
#define IDC_SHUTDOWN                    1019
#define IDC_POWERDOWN                   1021
#define IDC_IFHUNG                      1022
#define IDC_ALWAYS                      1023
#define IDC_NEVER                       1024
#define IDC_ENABLEDELAY                 1027
#define IDD_VM_DRIVE_LABEL              1144
#define IDD_VM_SPACE_LABEL              1146
#define IDD_VM_MIN_LABEL                1148
#define IDD_VM_RECOMMEND_LABEL          1150
#define IDD_VM_ALLOCD_LABEL             1152
#define IDD_VM_DRIVE_HDR                1158
#define IDD_VM_PF_SIZE_LABEL            1159
#define IDD_VM_VOLUMES                  1160
#define IDD_VM_SF_DRIVE                 1161
#define IDD_VM_SF_SPACE                 1162
#define IDD_VM_SF_SIZE                  1163
#define IDD_VM_SF_SIZEMAX               1164
#define IDD_VM_SF_SET                   1165
#define IDD_VM_MIN                      1166
#define IDD_VM_RECOMMEND                1167
#define IDD_VM_ALLOCD                   1168
#define IDD_VM_ST_INITSIZE              1169
#define IDD_VM_ST_MAXSIZE               1170
#define IDD_VMEM_ICON                   1171
#define IDD_VMEM_MESSAGE                1172
#define IDD_VM_CUSTOMSIZE_RADIO         1173
#define IDD_VM_RAMBASED_RADIO           1174
#define IDD_VM_NOPAGING_RADIO           1175
#define IDD_HELP                        1176
#define IDR_AVIWAIT                     1177
#define IDS_BYTES                       10000
#define IDS_ORDERKB                     10001
#define IDS_ORDERMB                     10002
#define IDS_ORDERGB                     10003
#define IDS_ORDERTB                     10004
#define IDS_ORDERPB                     10005
#define IDS_ORDEREB                     10006
#define IDS_MB                          10007
#define IDS_UNAVAILABLE                 10008
#define IDS_SYS_CHANGE_CAPTION          10009
#define IDS_MUST_RESTART                10010
#define IDS_WINVER_VERSION              10011
#define IDS_WINVER_YEAR                 10012
#define IDS_WINVER_PERSONAL             10013
#define IDS_WINVER_PROFESSIONAL         10014
#define IDS_WINVER_SERVER               10015
#define IDS_WINVER_ADVANCEDSERVER       10016
#define IDS_WINVER_DATACENTER           10017
#define IDS_WINVER_EMBEDDED             10018

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         206
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\settings.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Tab state helper
// 
// 3-12-98 sburns


#include "precomp.h"

#include "headers.hxx"
#include "settings.h"
#include "resource.h"
#include "common.h"



// Caller needs to delete info with ::DsRoleFreeMemory.

static DWORD myDsRoleGetPrimaryDomainInformation(
							DSROLE_PRIMARY_DOMAIN_INFO_BASIC*&  info)
{
   TRACE_FUNCTION(myDsRoleGetPrimaryDomainInformation);

   BYTE* buffer = 0;
   info = 0;

   TRACE(TEXT("Calling DsRoleGetPrimaryDomainInformation"));
   DWORD err =
      ::DsRoleGetPrimaryDomainInformation(
							 0, // this server
							 DsRolePrimaryDomainInfoBasic,
							 &buffer);

   TRACE(String::format(TEXT("Error 0x%1!X! (!0 => error)"), err));
   if (err == NO_ERROR)
   {
      info = (DSROLE_PRIMARY_DOMAIN_INFO_BASIC*) buffer;
      assert(info);

      TRACE(String::format(TEXT("MachineRole   : %1!d!"), info->MachineRole));
      TRACE(String::format(TEXT("Flags         : 0x%1!X!"), info->Flags));
      TRACE(String::format(TEXT("DomainNameFlat: %1"), info->DomainNameFlat));
      TRACE(String::format(TEXT("DomainNameDns : %1"), info->DomainNameDns));
      TRACE(String::format(TEXT("DomainTreeName: %1"), info->DomainTreeName));
   }

   return err;
}



void Settings::Refresh()
{
   String unknown = String::load(IDS_UNKNOWN);
   ComputerPrimaryDomainDNSName = unknown;
   DomainDNSName = unknown;
   FullComputerName = unknown;
   NetBIOSComputerName = unknown;
   NetBIOSDomainName = unknown;
   ShortComputerName = unknown;

   SyncDNSNames = true; // @@ read from registry
   JoinedToWorkgroup = true;

   DSROLE_PRIMARY_DOMAIN_INFO_BASIC* info = 0;
   DWORD err = myDsRoleGetPrimaryDomainInformation(info);
   if (err == NO_ERROR)
   {
      // this is the workgroup name iff JoinedToWorkgroup == true
      NetBIOSDomainName = info->DomainNameFlat;
      DomainDNSName = info->DomainNameDns;

      switch (info->MachineRole)
      {
         case DsRole_RoleBackupDomainController:
         case DsRole_RolePrimaryDomainController:
         {
            machine_is_dc = true;
            JoinedToWorkgroup = false;
            break;
         }
         case DSRole_RoleStandaloneWorkstation:
         case DsRole_RoleStandaloneServer:
         {
            machine_is_dc = false;
            JoinedToWorkgroup = true;
            if (NetBIOSDomainName.empty())
            {
               NetBIOSDomainName =
                  String::load(IDS_DEFAULT_WORKGROUP);
            }
            break;
         }
         case DsRole_RoleMemberWorkstation:
         case DsRole_RoleMemberServer:
         {
            machine_is_dc = false;
            JoinedToWorkgroup = false;
            break;
         }
         default:
         {
            assert(false);
            break;
         }
      }

      ::DsRoleFreeMemory(info);
   }
   else
   {
      AppError(0, HRESULT_FROM_WIN32(err),
				 String::load(IDS_ERROR_READING_MEMBERSHIP));
   }

   // @@ call GetComputerNameEx here...

   NetBIOSComputerName = Win::GetComputerNameFromRegistry();
   ShortComputerName = NetBIOSComputerName;

   if (!JoinedToWorkgroup)
   {
      ComputerPrimaryDomainDNSName = DomainDNSName;
      FullComputerName =
            ShortComputerName
         +  TEXT(".")
         +  ComputerPrimaryDomainDNSName;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\settings.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Tab state helper
// 
// 3-12-98 sburns



#ifndef SETTINGS_HPP_INCLUDED
#define SETTINGS_HPP_INCLUDED






#endif   // SETTINGS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\rebootpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "RebootPage.h"

// avoid some warnings.
#undef HDS_HORZ
#undef HDS_BUTTONS
#undef HDS_HIDDEN
#include "resource.h"
#include <windowsx.h>
#include "..\common\util.h"

//----------------------------------------------------------------------------
INT_PTR CALLBACK StaticRebootDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) 
{ 
	// if this is the initDlg msg...
	if(message == WM_INITDIALOG)
	{
		// transfer the 'this' ptr to the extraBytes.
		SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
	}

	// DWL_USER is the 'this' ptr.
	RebootPage *me = (RebootPage *)GetWindowLongPtr(hwndDlg, DWLP_USER);

	if(me != NULL)
	{
		// call into the DlgProc() that has some context.
		return me->DlgProc(hwndDlg, message, wParam, lParam);
	} 
	else
	{
		return FALSE;
	}
}
//--------------------------------------------------------------
RebootPage::RebootPage(WbemServiceThread *serviceThread)
					: WBEMPageHelper(serviceThread)
{
	IWbemClassObject *pInst = NULL;
	pInst = FirstInstanceOf("Win32_OperatingSystem");
	if(pInst)
	{
		m_OS = pInst;
	}
}

//--------------------------------------------------------------
INT_PTR RebootPage::DoModal(HWND hDlg)
{
   return DialogBoxParam(HINST_THISDLL,
						(LPTSTR) MAKEINTRESOURCE(IDD_SHUTDOWN),
						hDlg, StaticRebootDlgProc, (LPARAM)this);
}

//--------------------------------------------------------------
RebootPage::~RebootPage()
{
}

//--------------------------------------------------------------
INT_PTR CALLBACK RebootPage::DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) 
{ 
	m_hDlg = hwndDlg;

    switch (message)
    {
    case WM_INITDIALOG:
        Init(hwndDlg);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) 
		{
        case IDOK:
            if(HIWORD(wParam) == BN_CLICKED) 
			{
				if(Doit(hwndDlg))
				{
			        EndDialog(hwndDlg, IDOK);
				}
            }
            break;

        case IDCANCEL:
	        EndDialog(hwndDlg, IDCANCEL);
			break;
        }
        break;

    case WM_HELP:      // F1
        break;

    case WM_CONTEXTMENU:      // right mouse click
//        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
//				(DWORD)(LPSTR)aStartupHelpIds);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
//--------------------------------------------------------------
void RebootPage::Init(HWND hDlg)
{
	// set initial radio buttons.
	Button_SetCheck(GetDlgItem(hDlg, IDC_LOGOFF), BST_CHECKED);
	Button_SetCheck(GetDlgItem(hDlg, IDC_NEVER), BST_CHECKED);

	// if NT && greater >= 5.0....
	bstr_t version = m_OS.GetString(_T("Version"));
	WCHAR major;
	if (&version != NULL)
		wcsncpy(&major, (wchar_t *)version, 1);
	int nMaj = _wtoi(&major);
	if(nMaj >= 5)
	{
		EnableWindow(GetDlgItem(hDlg, IDC_IFHUNG), TRUE);
	}
}
//-------------------------------------------------------------
// NOTE: maps the flag bit to the radio button IDs.
typedef struct 
{
	UINT bit;
	UINT ID;
} FLAGMAP;

FLAGMAP g_flagmap[] = {
	{EWX_LOGOFF,  IDC_LOGOFF},
	{EWX_POWEROFF,  IDC_POWERDOWN},
	{EWX_REBOOT,  IDC_REBOOT},
	{EWX_SHUTDOWN,  IDC_SHUTDOWN},

	{EWX_FORCE, IDC_ALWAYS},
	{/*EWX_FORCEIFHUNG*/ 0x10, IDC_IFHUNG}}; // needs NT5 hdr.


bool RebootPage::Doit(HWND hDlg)
{
	long flags = 0L;
	bstr_t path;
	HRESULT hr = 0;

	// find exactly ONE from the first 4...
	for(int i = 0; i <= 3; i++)
	{
		if(Button_GetCheck(GetDlgItem(hDlg, g_flagmap[i].ID)) & BST_CHECKED)
		{
			flags |= g_flagmap[i].bit;
			break; // found it; bail early.
		}
	}

	// and find ONE from the last 2.
	// NOTE: I dont check IDC_NEVER cuz that means 'no bit set'. Its just there
	// so the user can uncheck the last two.
	for(i = 4; i <= 5; i++)
	{
		if(Button_GetCheck(GetDlgItem(hDlg, g_flagmap[i].ID)) & BST_CHECKED)
		{
			flags |= g_flagmap[i].bit;
			break;  // found it; bail early.
		}
	}

	// call the helper in the base class.
	long retval = 0;

	hr = Reboot(flags, &retval);

	if(FAILED(hr) || (retval != 0))
	{
		TCHAR format[100] = {0};
		TCHAR msg[100] = {0};
		TCHAR caption[100] = {0};

		::LoadString(HINST_THISDLL,
						IDS_ERR_EXECMETHOD_CAPTION, 
						caption, 100);

		::LoadString(HINST_THISDLL,
						IDS_ERR_EXECMETHOD, 
						format, 100);

		if(hr)
		{
			swprintf(msg, format, hr);
		}
		else
		{
			swprintf(msg, format, retval);

			// calling code gets confused if the 'retval' error isn't
			// reported back SOMEHOW. 
			hr = E_FAIL;
		}

		::MessageBox(hDlg, msg, caption,
						MB_OK| MB_ICONEXCLAMATION);
	}

	return SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\startuppage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "StartupPage.h"

// avoid some warnings.
#undef HDS_HORZ
#undef HDS_BUTTONS
#undef HDS_HIDDEN
#include "resource.h"
#include <stdlib.h>
#include <TCHAR.h>
#include "..\Common\util.h"
#include <windowsx.h>
#include <commctrl.h>
#include <shellapi.h>
#include "RebootPage.h"
#include "helpid.h"

//  Reboot switch for crashdump dlg
#define RET_ERROR               (-1)
#define RET_NO_CHANGE           0x00
#define RET_VIRTUAL_CHANGE      0x01
#define RET_RECOVER_CHANGE      0x02
#define RET_CHANGE_NO_REBOOT    0x04
#define RET_CONTINUE            0x08
#define RET_BREAK               0x10
#define RET_VIRT_AND_RECOVER (RET_VIRTUAL_CHANGE | RET_RECOVER_CHANGE)


#define FORMIN       0
#define FORMAX     999
// Length of WCHAR buffer needed to hold "Display startup list for..." value
#define FOR_MAX_LENGTH 20

// Default "Display startup list for..." value
#define FORDEF      30

#define NO_DUMP_OPTION          0
#define COMPLETE_DUMP_OPTION    1
#define KERNEL_DUMP_OPTION      2
#define SMALL_DUMP_OPTION       3

//
// Help ID's
//

DWORD aStartupHelpIds[] = {
    IDC_STARTUP_SYS_OS,                    (IDH_STARTUP + 0),
    IDC_STARTUP_SYS_ENABLECOUNTDOWN,       (IDH_STARTUP + 1),
    IDC_STARTUP_SYS_SECONDS,               (IDH_STARTUP + 2),
    IDC_STARTUP_SYS_SECONDS_LABEL,         (IDH_STARTUP + 2),
    IDC_STARTUP_CDMP_TXT1,                 (IDH_STARTUP + 3),
    IDC_STARTUP_CDMP_LOG,                  (IDH_STARTUP + 4),
    IDC_STARTUP_CDMP_SEND,                 (IDH_STARTUP + 5),
    IDC_STARTUP_CDMP_FILENAME,             (IDH_STARTUP + 7),
    IDC_STARTUP_CDMP_OVERWRITE,            (IDH_STARTUP + 13),
    IDC_STARTUP_CDMP_AUTOREBOOT,           (IDH_STARTUP + 9),
    IDC_STARTUP_SYSTEM_GRP,                (IDH_STARTUP + 10),
    IDC_STARTUP_SYS_SECSCROLL,             (IDH_STARTUP + 11),
    IDC_STARTUP_CDMP_GRP,                  (IDH_STARTUP + 12),
    IDC_STARTUP_SYSTEM_GRP2,               (IDH_STARTUP + 14),
    IDC_STARTUP_CDMP_OPTIONS,              (IDH_STARTUP + 8),
    IDC_EDIT_BOOT_INI_LABEL,               (IDH_STARTUP + 15),
    IDC_EDIT_BOOT_INI,                     (IDH_STARTUP + 16),
    IDC_REBOOT,            IDH_WBEM_ADVANCED_STARTRECOVER_REMOTE_REBOOT,
    0, 0
};


//----------------------------------------------------------------------------
INT_PTR CALLBACK StaticStartupDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) 
{ 
	// if this is the initDlg msg...
	if(message == WM_INITDIALOG)
	{
		// transfer the 'this' ptr to the extraBytes.
		SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
	}

	// DWL_USER is the 'this' ptr.
	StartupPage *me = (StartupPage *)GetWindowLongPtr(hwndDlg, DWLP_USER);

	if(me != NULL)
	{
		// call into the DlgProc() that has some context.
		return me->DlgProc(hwndDlg, message, wParam, lParam);
	} 
	else
	{
		return FALSE;
	}
}
//--------------------------------------------------------------
StartupPage::StartupPage(WbemServiceThread *serviceThread)
					: WBEMPageHelper(serviceThread)
{
	IWbemClassObject *pInst = NULL;

	m_WbemServices.SetPriv();

	if((pInst = FirstInstanceOf("Win32_ComputerSystem")) != NULL)
	{
		m_computer = pInst;
	}

	if((pInst = FirstInstanceOf("Win32_OperatingSystem")) != NULL)
	{
		m_OS = pInst;
	}

	if((pInst = FirstInstanceOf("Win32_OSRecoveryConfiguration")) != NULL)
	{
		m_recovery = pInst;
	}

	if((pInst = FirstInstanceOf("Win32_LogicalMemoryConfiguration")) != NULL)
	{
		m_memory = pInst;
	}


	m_WbemServices.ClearPriv();

	m_writable = TRUE;
	m_lBound = 1;
    m_bDownlevelTarget = TRUE;  // Assume downlevel until proven otherwise.
}

//--------------------------------------------------------------
INT_PTR StartupPage::DoModal(HWND hDlg)
{
   return DialogBoxParam(HINST_THISDLL,
						(LPTSTR) MAKEINTRESOURCE(IDD_STARTUP),
						hDlg, StaticStartupDlgProc, (LPARAM)this);
}

//--------------------------------------------------------------
StartupPage::~StartupPage()
{
}

//--------------------------------------------------------------
BOOL StartupPage::CheckVal( HWND hDlg, WORD wID, WORD wMin, WORD wMax, WORD wMsgID )
{
    WORD nVal;
    BOOL bOK;
    HWND hVal;
    WCHAR szTemp[FOR_MAX_LENGTH];

    if( wMin > wMax )
    {
        nVal = wMin;
        wMin = wMax;
        wMax = nVal;
    }

    nVal = (WORD) GetDlgItemInt( hDlg, wID, &bOK, FALSE );

    //
    // This is a hack to make the null string act equivalent to zero
    //
    if (!bOK) {
       bOK = !GetDlgItemTextW( hDlg, wID, szTemp, FOR_MAX_LENGTH );
    }

    if( !bOK || ( nVal < wMin ) || ( nVal > wMax ) )
    {
		TCHAR megBuf[30] = {0};

        MsgBoxParam( hDlg, wMsgID, IDS_DISPLAY_NAME,
                      MB_OK | MB_ICONERROR);

        SendMessage( hDlg, WM_NEXTDLGCTL,
                     (WPARAM) ( hVal = GetDlgItem( hDlg, wID ) ), 1L );

//        SendMessage(hVal, EM_SETSEL, NULL, MAKELONG(0, 32767));

        SendMessage( hVal, EM_SETSEL, 0, 32767 );

        return( FALSE );
    }

    return( TRUE );
}

//--------------------------------------------------------------
INT_PTR CALLBACK StartupPage::DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{ 
	m_hDlg = hwndDlg;

    switch (message)
    {
    case WM_INITDIALOG:
        Init(hwndDlg);
        break;

    case WM_COMMAND:
        switch(HIWORD(wParam)) 
		{
        case EN_CHANGE:
        case BN_CLICKED:
        case CBN_SELCHANGE:
            PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
            break;
		}

        switch(LOWORD(wParam)) 
		{
        case IDC_STARTUP_SYS_ENABLECOUNTDOWN:
            if (HIWORD(wParam) == BN_CLICKED) 
			{
                BOOL bChecking = (WORD) !IsDlgButtonChecked(m_hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN);
                CheckDlgButton(m_hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN, bChecking);
                EnableWindow(GetDlgItem(m_hDlg, IDC_STARTUP_SYS_SECONDS), bChecking);
                EnableWindow(GetDlgItem(m_hDlg, IDC_STARTUP_SYS_SECSCROLL), bChecking);

                if(bChecking)
                {
                    Edit_SetText(GetDlgItem(m_hDlg, IDC_STARTUP_SYS_SECONDS), _T("30"));
                }
                else //unchecking it.
                {
                    Edit_SetText(GetDlgItem(m_hDlg, IDC_STARTUP_SYS_SECONDS), _T("0"));
                }
				SendMessage((HWND) lParam, EM_SETSEL, 0, -1);

            }
            break;

        case IDC_STARTUP_SYS_SECONDS:
            if(HIWORD(wParam) == EN_UPDATE) 
			{
                if(!CheckVal(m_hDlg, IDC_STARTUP_SYS_SECONDS, FORMIN, FORMAX, SYSTEM+4)) 
				{
                    SetDlgItemInt(m_hDlg, IDC_STARTUP_SYS_SECONDS, FORDEF, FALSE); 
                    SendMessage((HWND) lParam, EM_SETSEL, 0, -1);
                    
                } // endif (!CheckVal()

            } // endif 
			break;

        case IDC_REBOOT:
            if(HIWORD(wParam) == BN_CLICKED) 
			{
				RebootPage dlg(g_serviceThread);
				if(dlg.DoModal(hwndDlg) == IDOK)
				{
					EnableWindow(GetDlgItem(hwndDlg, IDC_REBOOT), FALSE);
					g_serviceThread->DisconnectServer();
					EndDialog(m_hDlg, CLOSE_SNAPIN);
				}
            }
            break;

        case IDOK:
            if(HIWORD(wParam) == BN_CLICKED) 
			{
				if(Save())
				{
			        EndDialog(m_hDlg, IDOK);
				}
            }
            break;

        case IDCANCEL:
	        EndDialog(m_hDlg, IDCANCEL);
			break;

        case IDC_STARTUP_CDMP_OPTIONS: 
            OnCDMPOptionUpdate();
			break;

        case IDC_EDIT_BOOT_INI:
            if (g_serviceThread && g_serviceThread->LocalConnection())
            {
                //
                // Local-only option. The button has been disabled but
                // perform this anyway.
                //
                OnBootEdit();
            }
            break;

        }
        break;

    case WM_HELP:      // F1
		::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
					L"sysdm.hlp", 
					HELP_WM_HELP, 
					(ULONG_PTR)(LPSTR)aStartupHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
				(ULONG_PTR)(LPSTR) aStartupHelpIds);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

//--------------------------------------------------------------
void StartupPage::OnCDMPOptionUpdate(void)
{
    HWND ComboHwnd = GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_OPTIONS);
    DWORD dwDumpOption = ComboBox_GetCurSel(ComboHwnd);

    EnableWindow(GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_FILENAME),
                             dwDumpOption != NO_DUMP_OPTION);
    EnableWindow(GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_OVERWRITE),
                             dwDumpOption != NO_DUMP_OPTION);

    bstr_t debugPath;
    if (dwDumpOption == SMALL_DUMP_OPTION)
    {
        debugPath = m_recovery.GetString("MiniDumpDirectory");
    }
    else
    {
        debugPath = m_recovery.GetString("DebugFilePath");
    }

    Edit_SetText(GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_FILENAME), debugPath);
}

//--------------------------------------------------------------
#define BOOT_INI    _T("boot.ini")

void StartupPage::OnBootEdit(void)
{
    HKEY hReg;

    if (RegOpenKey(HKEY_LOCAL_MACHINE,
                   _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup"),
                   &hReg) == ERROR_SUCCESS)
    {
        TCHAR szBootDir[4];
        DWORD dwType = REG_SZ;
        DWORD cbBootDir = sizeof(szBootDir);

        if (RegQueryValueEx(hReg,
                            _T("BootDir"),
                            NULL,
                            &dwType,
                            (LPBYTE)szBootDir,
                            &cbBootDir) == ERROR_SUCCESS)
        {
            if (dwType == REG_SZ)
            {
                TCHAR szBootIni[ARRAYSIZE(szBootDir) + ARRAYSIZE(BOOT_INI)];

                lstrcpy(szBootIni, szBootDir);
                lstrcat(szBootIni, BOOT_INI);
        
                ShellExecute(m_hDlg,
                             NULL,              // Default verb.
                             szBootIni,         // boot.ini path.
                             NULL,              // No parameters.
                             NULL,              // Default working dir.
                             SW_SHOWNORMAL);
            }
        }

        RegCloseKey(hReg);
    }
}

//--------------------------------------------------------------
#define ONE_MEG             1048576
long StartupPage::GetRAMSizeMB(void)
{
	IWbemClassObject *pInst = NULL;
	CWbemClassObject memory;
	long RAMsize = 0;

	if((pInst = FirstInstanceOf("Win32_LogicalMemoryConfiguration")) != NULL)
	{
		memory = pInst;
		long dwTotalPhys = memory.GetLong("TotalPhysicalMemory");
	    RAMsize = (dwTotalPhys / ONE_MEG) + 1;
	}
	return RAMsize;
}

//--------------------------------------------------------------
bool StartupPage::IsWorkstationProduct()
{
	bool retval = true;

	bstr_t name = m_OS.GetString("Name");

	if(name.length() > 0)
	{
		TCHAR sName[200] = {0};
		wcscpy(sName, name);
		if(wcsstr(sName, L"Server") != NULL)
		{
			retval = false;
		}
	}
	return retval;
}

//--------------------------------------------------------------
TCHAR szCrashKey[]  = TEXT("System\\CurrentControlSet\\Control\\CrashControl");

void StartupPage::Init(HWND hDlg)
{
    HWND ComboHwnd;
	variant_t array;
    DWORD dwDebugInfoType;

	// load the startup combobox.
    //
    // Must enable SE_SYSTEM_ENVIRONMENT_NAME privilege on ia64.
    //
#if defined(_IA64_)
    m_WbemServices.SetPriv();
#endif // IA64

	m_computer.Get("SystemStartupOptions", (variant_t &)array);

#if defined(_IA64_)
    m_WbemServices.ClearPriv();
#endif // IA64

	if(array.vt & VT_ARRAY)
	{
		SAFEARRAY *startupArray = V_ARRAY(&array);
		long uBound = 1;
		BSTR temp;
        ComboHwnd = GetDlgItem(hDlg, IDC_STARTUP_SYS_OS);

		SafeArrayGetLBound(startupArray, 1, &m_lBound);
		SafeArrayGetUBound(startupArray, 1, &uBound);

		for (long i = m_lBound; i <= uBound; i++)
		{
			SafeArrayGetElement(startupArray, &i, &temp);
			ComboBox_AddString(ComboHwnd, temp);
		}

		// the first one is the selection we want (watch out for 'lBound' values)
		long idx = m_computer.GetLong("SystemStartupSetting");
		ComboBox_SetCurSel(ComboHwnd, idx - m_lBound);

		// 3 chars in the second's edit box.
		Edit_LimitText(GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS), 3);

		// limit spinner to 0 - 999.
		SendDlgItemMessage (hDlg, IDC_STARTUP_SYS_SECSCROLL,
							  UDM_SETRANGE, 0, (LPARAM)MAKELONG(999,0));


		WCHAR buf[30] = {0};
		m_delay = 0;
		m_delay = (short)m_computer.GetLong("SystemStartupDelay");
		BOOL bChecked = (m_delay != 0);

		CheckDlgButton(m_hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN, bChecked);
		EnableWindow(GetDlgItem (m_hDlg, IDC_STARTUP_SYS_SECONDS), bChecked);
		EnableWindow(GetDlgItem (m_hDlg, IDC_STARTUP_SYS_SECSCROLL), bChecked);
		Edit_SetText(GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS), _itow(m_delay, buf, 10));
	}
	else
	{
		EnableWindow(GetDlgItem (m_hDlg, IDC_STARTUP_SYS_OS), FALSE);
		EnableWindow(GetDlgItem (m_hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN), FALSE);
		EnableWindow(GetDlgItem (m_hDlg, IDC_STARTUP_SYS_SECSCROLL), FALSE);
		EnableWindow(GetDlgItem (m_hDlg, IDC_STARTUP_SYS_SECONDS), FALSE);
		EnableWindow(GetDlgItem (m_hDlg, IDC_STARTUP_SYS_SECONDS_LABEL), FALSE);

	} // endif VT_ARRAY failure.

	// set all the recovery controls.
    // Special Case: Server Product does not want ability to disable logging
    // of crashdumps.
	WPARAM checkState;

	if(IsWorkstationProduct() == true)
	{
		checkState = (m_recovery.GetBool("WriteToSystemLog") ? BST_CHECKED : BST_UNCHECKED);
		Button_SetCheck(GetDlgItem(hDlg, IDC_STARTUP_CDMP_LOG), checkState);
	}
	else
	{
		Button_SetCheck(GetDlgItem(hDlg, IDC_STARTUP_CDMP_LOG), BST_CHECKED);
		EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_LOG),FALSE);
	}

    //
    // Load the dump options combo box.
    //
    dwDebugInfoType = GetDebugInfoType();

    TCHAR szBuf[MAX_PATH];  // The largest string loaded here is 24 chars.

    szBuf[0] = _T('\0');
    ComboHwnd = GetDlgItem(hDlg, IDC_STARTUP_CDMP_OPTIONS);
    LoadString(HINST_THISDLL,
               IDS_NO_DUMP,
               szBuf,
               sizeof(szBuf) / sizeof(TCHAR));
    ComboBox_AddString(ComboHwnd, szBuf);
    szBuf[0] = _T('\0');
    LoadString(HINST_THISDLL,
               IDS_COMPLETE_DUMP,
               szBuf,
               sizeof(szBuf) / sizeof(TCHAR));

    ComboBox_AddString(ComboHwnd, szBuf);
    szBuf[0] = _T('\0');
    LoadString(HINST_THISDLL,
               IDS_KERNEL_DUMP,
               szBuf,
               sizeof(szBuf) / sizeof(TCHAR));
    ComboBox_AddString(ComboHwnd, szBuf);

    if (!m_bDownlevelTarget)
    {
        szBuf[0] = _T('\0');
        LoadString(HINST_THISDLL,
                   IDS_SMALL_DUMP,
                   szBuf,
                   sizeof(szBuf) / sizeof(TCHAR));
        ComboBox_AddString(ComboHwnd, szBuf);
    }

    ComboBox_SetCurSel(ComboHwnd, dwDebugInfoType);

	checkState = (m_recovery.GetBool("SendAdminAlert") ? BST_CHECKED : BST_UNCHECKED);
	Button_SetCheck(GetDlgItem(hDlg, IDC_STARTUP_CDMP_SEND), checkState);

    bstr_t debugPath;
    if (dwDebugInfoType == SMALL_DUMP_OPTION)
    {
        debugPath = m_recovery.GetString("MiniDumpDirectory");
    }
    else
    {
        debugPath = m_recovery.GetString("DebugFilePath");
    }
	Edit_SetText(GetDlgItem(hDlg, IDC_STARTUP_CDMP_FILENAME), debugPath);

	checkState = (m_recovery.GetBool("OverwriteExistingDebugFile") ? BST_CHECKED : BST_UNCHECKED);
	Button_SetCheck(GetDlgItem(hDlg, IDC_STARTUP_CDMP_OVERWRITE), checkState);

	checkState = (m_recovery.GetBool("AutoReboot") ? BST_CHECKED : BST_UNCHECKED);
	Button_SetCheck(GetDlgItem(hDlg, IDC_STARTUP_CDMP_AUTOREBOOT), checkState);

    //
    // Special case disable the overwrite and logfile controls if no debug
    // info option specified.
    //
    EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_FILENAME),
                 dwDebugInfoType != NO_DUMP_OPTION);
    EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_OVERWRITE),
                 dwDebugInfoType != NO_DUMP_OPTION);

    //
	// Test to determine if the user is an admin.
    //
	RemoteRegWriteable(szCrashKey, m_writable);

	if (!m_writable)
	{
        // Non-admin - disable controls.
        //
		EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_LOG     ), FALSE);
	    EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_SEND    ), FALSE);
		EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_FILENAME), FALSE);
		EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_OVERWRITE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_OPTIONS), FALSE);
		EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_AUTOREBOOT), FALSE);
	}


	BOOL hasPriv = true, hasMethExecute = false;
	if(g_serviceThread && g_serviceThread->LocalConnection())
	{
		hasPriv = HasPriv(SE_SHUTDOWN_NAME);
	}

	hasMethExecute = HasPerm(WBEM_METHOD_EXECUTE);

    //
    // Enable the edit button for local-only.
    // Disable boot options label and edit button on i64.
    //
#if defined(_IA64_)
    EnableWindow(GetDlgItem (m_hDlg, IDC_EDIT_BOOT_INI), FALSE);
    EnableWindow(GetDlgItem (m_hDlg, IDC_EDIT_BOOT_INI_LABEL), FALSE);
#else
    EnableWindow(GetDlgItem (m_hDlg, IDC_EDIT_BOOT_INI_LABEL),
                m_writable ?
                    (g_serviceThread && g_serviceThread->LocalConnection()) :
                    FALSE);
	EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BOOT_INI),
                m_writable ?
                    (g_serviceThread && g_serviceThread->LocalConnection()) :
                    FALSE);
#endif // IA64

	EnableWindow(GetDlgItem(hDlg, IDC_REBOOT),
                 m_writable ? (hasPriv && hasMethExecute) : FALSE);
}

//----------------------------------------------------------------------------
DWORD StartupPage::GetDebugInfoType(void)
{
    // NB: Whistler on, the win32 provider supports new DebugInfoType
    //     (none,complete,kernel,small) and MiniDumpDirectory properties.
    //     Logic is needed to compensate for downlevel machines.
    //
    //     *Important note*  The small dump option cannot be supported
    //     on Win2K since the provider doesn't.
    //
    DWORD dwDebugInfoType = 0;

    if (FAILED(m_recovery.Get("DebugInfoType", (long&)dwDebugInfoType)))
    {
        // Downlevel or error case.
        //
        if (!m_bDownlevelTarget)
        {
            // Bail. We've previously established this isn't downlevel
            // but now fail to read the property.
            //
            return NO_DUMP_OPTION;
        }

        m_bDownlevelTarget   = TRUE;
        bool bWriteDebugInfo = FALSE;

        if (FAILED(m_recovery.Get("WriteDebugInfo", bWriteDebugInfo)))
        {
            // Now we're clueless; default to (none).
            //
            bWriteDebugInfo = FALSE;
            dwDebugInfoType = NO_DUMP_OPTION;
        }

        if (bWriteDebugInfo)
        {
            bool bKernelDumpOnly;

            if (FAILED(m_recovery.Get("KernelDumpOnly", bKernelDumpOnly)))
            {
                // If we fail to get KernelDumpOnly we must assume complete,
                // since they've elected to write debugging info.
                //
                bKernelDumpOnly = FALSE;
            }

            if (bKernelDumpOnly)
            {
                dwDebugInfoType = KERNEL_DUMP_OPTION;
            }
            else
            {
                dwDebugInfoType = COMPLETE_DUMP_OPTION;
            }
        }
    }
    else
    {
        m_bDownlevelTarget = FALSE;
    }

    return dwDebugInfoType;
}

//----------------------------------------------------------------------------
HRESULT StartupPage::PutDebugInfoType(DWORD dwDebugInfoType)
{
    HRESULT hr;

    if (m_bDownlevelTarget)
    {
        switch (dwDebugInfoType)    // Intentionally verbose - compiler will
                                    // optimize.
        {
            case NO_DUMP_OPTION:
                hr = m_recovery.Put("WriteDebugInfo", (bool)FALSE);
                break;

            case COMPLETE_DUMP_OPTION:
                hr = m_recovery.Put("WriteDebugInfo", (bool)TRUE);
                if (SUCCEEDED(hr))
                {
                    hr = m_recovery.Put("KernelDumpOnly", (bool)FALSE);
                }
                break;

            case KERNEL_DUMP_OPTION:
                hr = m_recovery.Put("WriteDebugInfo", (bool)TRUE);
                if (SUCCEEDED(hr))
                {
                    hr = m_recovery.Put("KernelDumpOnly", (bool)TRUE);
                }
                break;

            case SMALL_DUMP_OPTION:
                ATLASSERT(!"Downlevel small dump option!");
                hr = E_FAIL;
                break;

            default:
                ATLASSERT(!"Downlevel unknown dump option!");
                hr = E_FAIL;
        }
    }
    else
    {
        hr = m_recovery.Put("DebugInfoType", (long)dwDebugInfoType);
    }

    return hr;
}

//----------------------------------------------------------------------------
#define MIN_SWAPSIZE        2       // Min swap file size.

int StartupPage::CoreDumpHandleOk(HWND hDlg)
{
    DWORD requiredFileSize = 0;
    int iRet = RET_NO_CHANGE;

     // Validate core dump filename
    if(!CoreDumpValidFile(hDlg)) 
	{
        SetFocus(GetDlgItem(hDlg, IDC_STARTUP_CDMP_FILENAME));
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
        iRet = RET_ERROR;
        return(iRet);
    }

    // If we are to write the dump file, it must be >= sizeof
    // phyical memory.
	// writing debug info?
    HWND ComboHwnd = GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_OPTIONS);

    if (ComboBox_GetCurSel(ComboHwnd) != NO_DUMP_OPTION)
	{
		// go figure my pagefile requirements.
        requiredFileSize = ((DWORD)m_memory.GetLong("TotalPhysicalMemory") / 1024) + 1;
    } 
	else if(IsDlgButtonChecked(hDlg, IDC_STARTUP_CDMP_LOG) ||
            IsDlgButtonChecked(hDlg, IDC_STARTUP_CDMP_SEND)) 
	{
		// I'll need this much to write a reminder to myself to send an
		// alert or write to event log once I come back up.
        requiredFileSize = MIN_SWAPSIZE;
    }

	// size of swapfile on the boot partition.
	TCHAR bootDrv[4] = {0};
	DWORD bootPartitionPageFileSize = GetPageFileSize(bootDrv);

	// is it too small?
    if(bootPartitionPageFileSize < requiredFileSize) 
	{
	    DWORD Ret;
		TCHAR szTemp[30] = {0};

        // Warn that the dump file may be truncated.
        Ret = MsgBoxParam(hDlg, SYSTEM + 29, IDS_TITLE,
                           MB_ICONEXCLAMATION | MB_YESNO,
                           bootDrv, _itow(requiredFileSize, szTemp, 10));

        if(Ret == IDNO) 
		{
            return RET_ERROR;
        }
    }

    return(iRet);
}

//----------------------------------------------------------------------------
BOOL StartupPage::CoreDumpValidFile(HWND hDlg) 
{
    TCHAR szInputPath[MAX_PATH] = {0};
    TCHAR * pszPath = NULL;
    HWND ComboHwnd;

    ComboHwnd = GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_OPTIONS);

    if (ComboBox_GetCurSel(ComboHwnd) != NO_DUMP_OPTION)
	{
        /*
         * get the filename
         */
        if(GetDlgItemText(hDlg, IDC_STARTUP_CDMP_FILENAME, szInputPath,
						     ARRAYSIZE(szInputPath)) == 0) 
		{
			//ERR: enter a filename for the dumpfile.
            MsgBoxParam(hDlg, SYSTEM+30, IDS_DISPLAY_NAME, MB_ICONSTOP | MB_OK);
            return FALSE;
        }

        //
        // For local paths only, confirm/validate the path. Remote validation
        // can be done later - too complicated, if not possible in the
        // Whistler timeframe.
        //

        if (g_serviceThread != NULL && g_serviceThread->LocalConnection())
        {
            /*
             * Expand any environment vars, and then check to make sure it
             * is a fully quallified path
             */
            // if it has a '%' in it, then try to expand it
            if (_tcschr(szInputPath, _T('%')) != NULL)
            {
                TCHAR szExpandedPath[MAX_PATH] = {0};
                DWORD cExpanded;
                cExpanded = ExpandEnvironmentStrings(szInputPath,
                                                    szExpandedPath,
                                     sizeof(szExpandedPath) / sizeof(TCHAR));

                if (cExpanded == 0 || _tcschr(szExpandedPath, _T('%')) != NULL)
                {
                    //
                    // Environment variable name(s) undefined or an error
                    // occurred during replacement.
                    //
                    MsgBoxParam(hDlg, SYSTEM+40, IDS_DISPLAY_NAME,
                                MB_ICONSTOP | MB_OK );
                    return FALSE;
                }
                else if (cExpanded > (sizeof(szExpandedPath) / sizeof(TCHAR)))
                {
                    TCHAR buf[10];
                    MsgBoxParam(hDlg, SYSTEM+33, IDS_DISPLAY_NAME,
                                MB_ICONSTOP | MB_OK, _ltow((DWORD)MAX_PATH,
                                                            buf,
                                                            10));
                    return FALSE;
                }
                else
                {
                    pszPath = szExpandedPath;
                }
            }
            else
            {
                pszPath = szInputPath;
            }

            // check to see that it already was cannonicalized

            TCHAR drv[_MAX_DRIVE] = {0};
            TCHAR path[_MAX_PATH] = {0};
            TCHAR fname[_MAX_FNAME] = {0};

            // build the instance path.
            _wsplitpath(pszPath, drv, path, fname, NULL);

            if((_tcslen(drv) == 0) || (_tcslen(path) == 0) ||
                (_tcslen(fname) == 0) )
            {
                // ERR: must be a full path.
                MsgBoxParam(hDlg, SYSTEM+34, IDS_DISPLAY_NAME,
                            MB_ICONSTOP | MB_OK );
                return FALSE;
            }

            /*
             * check the drive (don't allow remote)
             */
            if(!LocalDrive(pszPath)) 
            {
                // ERR: Local drives only
                MsgBoxParam(hDlg, SYSTEM+31, IDS_DISPLAY_NAME,
                            MB_ICONSTOP | MB_OK );
                return FALSE;
            }

            /*
             * if path is non-existent, tell user and let him decide what to
             * do
             */
            if(!DirExists(pszPath))
            { 
                if(MsgBoxParam(hDlg, SYSTEM+32, IDS_DISPLAY_NAME,
                                MB_ICONQUESTION | MB_YESNO ) == IDNO)
                {
                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}

//----------------------------------------------------------------------------
DWORD StartupPage::GetPageFileSize(LPTSTR bootDrv)
{
	IWbemClassObject *pInst = NULL;
	CWbemClassObject OS;
	bstr_t path;
	DWORD cMegBootPF = 0;
	TCHAR szBootPath[_MAX_PATH] = {0};
	szBootPath[0] = 0;

	if(m_OS)
	{
		// WATCH: what's the value if GetWindowsDirectory fails?
		path = m_OS.GetString("WindowsDirectory");
		if(path.length())
		{
			// build the instance path.
			_tcscpy(szBootPath, _T("Win32_PageFileSetting=\""));
			_tcsncat(szBootPath, path, 3);
			_tcscat(szBootPath, _T("\\pagefile.sys\""));

			// while we're here....
			_tcsncpy(bootDrv, path, 3);

			m_page = m_WbemServices.GetObject(szBootPath);

			if(m_page)
			{
				// NOTE: We'll need this later to change the swapfile size.
/*				long dwTotalPhys = m_page.GetLong("Size");
				cMegBootPF = (dwTotalPhys / ONE_MEG) + 1;*/
				long dwMinPageFileSize = m_page.GetLong("InitialSize");
				cMegBootPF = dwMinPageFileSize;
			}
		}
	}
	return cMegBootPF;
}

//-------------------------------------------------------------
BOOL StartupPage::ExpandRemoteEnvPath(LPTSTR szPath, LPTSTR expPath, UINT size)
{
	//TODO: really expand the vars.
	_tcscpy(szPath, expPath);
	return TRUE;
}

//-------------------------------------------------------------
BOOL StartupPage::LocalDrive(LPCTSTR szPath)
{
	CWbemClassObject drive;
	TCHAR ltr[_MAX_PATH] = {0};
	long type = 0;
	BOOL retval = FALSE;
	__int64 free = 0;

	// build the instance path.
	_tcscpy(ltr, _T("win32_LogicalDisk=\""));
	_tcsncat(ltr, szPath, 2);
	_tcscat(ltr, _T("\""));

	// save the drive letter for msgs.
	_tcsncpy(m_DriveLtr, szPath, 2);

	drive = m_WbemServices.GetObject(ltr);
	if(drive)
	{
		type = drive.GetLong("DriveType");
		retval = ((type == DRIVE_REMOVABLE) ||
				  (type == DRIVE_FIXED));

		// WARNING: this is only here cuz the LocalDrive check happens
		// to come before the freespace check and I didn't want to do
		// another GetObject() over a potentially slow network.
		free = drive.GetI64("FreeSpace");
		m_freeSpace = (DWORD)(free / ONE_MEG);
	}
	return retval;
}

//-------------------------------------------------------------
BOOL StartupPage::DirExists(LPCTSTR szPath)
{
	BOOL exists = TRUE;
	CWbemClassObject drive;

	TCHAR objPath[_MAX_PATH] = {0}, drv[_MAX_DRIVE] = {0}, path[_MAX_PATH] = {0};

	// build the instance path.
	_wsplitpath(szPath, drv, path, NULL, NULL);
	path[_tcslen(path) - 1] = _T('\0');

	_tcscpy(objPath, _T("Win32_Directory=\""));
	_tcscat(objPath, drv);
	
	// double the whacks cuz wmi has bad syntax.
	TCHAR cooked[_MAX_PATH] = {0};
	TCHAR input[_MAX_PATH] = {0};

	int len = _tcslen(path);

	_tcscpy(input, path);

	for(int x = 0; x < len; x++)
	{
		_tcsncat(cooked, &input[x], 1);

		// if its a whack...
		if(input[x] == _T('\\'))
		{
			// have another pleeb.
			_tcscat(cooked, _T("\\"));			
		}
	} //endfor

	_tcscat(objPath, cooked);

	_tcscat(objPath, _T("\""));

	drive = m_WbemServices.GetObject(objPath);
	exists = (drive.IsNull() ? FALSE : TRUE);
	return exists;
}

//-------------------------------------------------------------
BOOL StartupPage::IsAlerterSvcStarted(HWND hDlg) 
{
	CWbemClassObject service;
	bool started = false;

	service = m_WbemServices.GetObject(_T("win32_Service=\"Alerter\""));
	if(service)
	{
		started = service.GetBool("started");

		if(!started)
		{
			// get the method signature. dummy wont actually be used.
			CWbemClassObject paramCls, inSig, dummy, outSig;

			// need to class def to get the method signature.
			paramCls = m_WbemServices.GetObject("win32_Service");

			if(paramCls)
			{
				HRESULT hr = paramCls.GetMethod(L"ChangeStartMode", inSig, outSig);

				// if got a good signature....
				if((bool)inSig)
				{
					bstr_t path = service.GetString(_T("__PATH"));

					inSig.Put(L"StartMode", (const _bstr_t&) L"Automatic");

					// make sure the service starts on bootup.
					hr = m_WbemServices.ExecMethod(path, L"ChangeStartMode",
													inSig, outSig);

					// did it work?
					if(SUCCEEDED(hr) && (bool)outSig)
					{
						// NOTE: this guy return STATUS codes.
						DWORD autoStart = outSig.GetLong(L"ReturnValue");

						if(autoStart == 0)
						{
							// now actually start the service.
							outSig = (IWbemClassObject *)0;

							// now call the method.
							hr = m_WbemServices.ExecMethod(path, L"StartService",
															dummy, outSig);

							// did the caller want the ReturnValue.
							if(SUCCEEDED(hr) && (bool)outSig)
							{
								// NOTE: this guy return STATUS codes.
								DWORD rv = outSig.GetLong(L"ReturnValue");
								started = ((rv == 0) ? true : false);
							}

						} //endif autoStart

					} //endif SUCCEEDED() execmMethod

				} //endif (bool)inSig

			} //endif paramCls

		} //endif !started

		if(!started) 
		{
			MsgBoxParam(hDlg, SYSTEM+35, IDS_DISPLAY_NAME, MB_ICONEXCLAMATION );
	    }
	}

    return started;
}

//-------------------------------------------------------------
bool StartupPage::Save(void)
{
    HRESULT hr;
    HWND    ComboHwnd;

	// if its writeable-- do the work.
	if(m_writable)
	{
		bool computerDirty = false, recoveryDirty = false;
		variant_t array;
		SAFEARRAY *startupArray = NULL;
		VARTYPE varType = VT_ARRAY;
        ComboHwnd = GetDlgItem(m_hDlg, IDC_STARTUP_SYS_OS);

		// see if the selection changed (watch out for 'lBound' values)
		long oldIdx = m_computer.GetLong("SystemStartupSetting");
		long newIdx = ComboBox_GetCurSel(ComboHwnd) + m_lBound;
		if(oldIdx != newIdx)
		{
			hr = m_computer.Put("SystemStartupSetting", variant_t((BYTE)newIdx));
			computerDirty = true;
		}

		// see if the delay changed.
		WCHAR oldBuf[30], newBuf[30];
		short delay = (short)m_computer.GetLong("SystemStartupDelay");
		_ltow(delay, oldBuf, 10);
		Edit_GetText(GetDlgItem(m_hDlg, IDC_STARTUP_SYS_SECONDS), newBuf, 30);
		if(wcscmp(oldBuf, newBuf) != 0)
		{
            short newVal = (short)_wtol(newBuf);
			hr = m_computer.Put("SystemStartupDelay", variant_t(newVal));
			computerDirty = true;
		}

		// evaluate all the recovery controls.
		WPARAM oldCheckState = (m_recovery.GetBool("WriteToSystemLog") ? BST_CHECKED : BST_UNCHECKED);
		WPARAM newCheckState = Button_GetCheck(GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_LOG));
		if(oldCheckState != newCheckState)
		{
			m_recovery.Put("WriteToSystemLog", (newCheckState == BST_CHECKED? true : false));
			recoveryDirty = true;
		}

		oldCheckState = (m_recovery.GetBool("SendAdminAlert") ? BST_CHECKED : BST_UNCHECKED);
		newCheckState = Button_GetCheck(GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_SEND));
		// did the state change?
		if(oldCheckState != newCheckState)
		{
			m_recovery.Put("SendAdminAlert", (newCheckState == BST_CHECKED? true : false));
			recoveryDirty = true;

			// turning ON
			if(newCheckState == TRUE)
			{
				// NOTE: had to move this fragment up to avoid being trapped under the wcsicmp() condition.
				// If the Alert button is checked, make sure the alerter service is started.
				IsAlerterSvcStarted(m_hDlg);
			}
		}

        ComboHwnd = GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_OPTIONS);
        DWORD dwOldDebugInfoType = GetDebugInfoType();
        DWORD dwNewDebugInfoType = ComboBox_GetCurSel(ComboHwnd);

        if (dwOldDebugInfoType != dwNewDebugInfoType)
        {
            // I detest this code. You add a member with a return code yet
            // nothing here checks them. At least keep the recover dirty
            // flag from being set and don't set the modify bit on the
            // filename edit control if the put fails.
            //
            hr = PutDebugInfoType(dwNewDebugInfoType);
            if (SUCCEEDED(hr))
            {
                recoveryDirty = true;
                Edit_SetModify(GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_FILENAME),
                                          TRUE);
            }
		}

        //
        // Only bother with these if other than "none" debug options is
        // specified.
        //
		if (dwNewDebugInfoType != NO_DUMP_OPTION)
		{
			oldCheckState = (m_recovery.GetBool("OverwriteExistingDebugFile") ? BST_CHECKED : BST_UNCHECKED);
			newCheckState = Button_GetCheck(GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_OVERWRITE));
			if(oldCheckState != newCheckState)
			{
				m_recovery.Put("OverwriteExistingDebugFile", (newCheckState == BST_CHECKED? true : false));
				recoveryDirty = true;
			}

			bstr_t oldDebugPath = m_recovery.GetString(
                                (dwOldDebugInfoType == SMALL_DUMP_OPTION) ?
                                    "MiniDumpDirectory" : "DebugFilePath");
			TCHAR newDebugPath[MAX_PATH];
			Edit_GetText(GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_FILENAME),
                        newDebugPath, sizeof(newDebugPath) / sizeof(TCHAR));

			if(_tcsicmp(oldDebugPath,newDebugPath) != 0)
			{
				if(RET_ERROR != CoreDumpHandleOk(m_hDlg))
				{
					m_recovery.Put(
                        (dwNewDebugInfoType == SMALL_DUMP_OPTION) ?
                            "MiniDumpDirectory" : "DebugFilePath",
                        (bstr_t)newDebugPath);
					recoveryDirty = true;
				}
				else 
				{
					long wl = GetWindowLongPtr(m_hDlg, DWLP_MSGRESULT);
					if(wl == PSNRET_INVALID_NOCHANGEPAGE)
					{
						return false;
					}
				}
			}
		} //endif 'WriteDebugInfo'

		oldCheckState = (m_recovery.GetBool("AutoReboot") ? BST_CHECKED : BST_UNCHECKED);
		newCheckState = Button_GetCheck(GetDlgItem(m_hDlg, IDC_STARTUP_CDMP_AUTOREBOOT));
		if(oldCheckState != newCheckState)
		{
			m_recovery.Put("AutoReboot", (newCheckState == BST_CHECKED? true : false));
			recoveryDirty = true;
		} 

		m_WbemServices.SetPriv();

		// who needs to be written?
		if(computerDirty)
		{
			hr = m_WbemServices.PutInstance(m_computer);
		}

		if(recoveryDirty)
		{
			// recovery changes always need a reboot.
            g_fRebootRequired = TRUE;

			MsgBoxParam(m_hDlg, SYSTEM + 39, IDS_TITLE,
							MB_OK | MB_ICONINFORMATION);

			hr = m_WbemServices.PutInstance(m_recovery);
		}
	
		m_WbemServices.ClearPriv();

	} //endif m_writable

	return true;  // close the dialog.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\startuppage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __STARTUPPAGE__
#define __STARTUPPAGE__
#pragma once

#include "..\Common\WbemPageHelper.h"

//-----------------------------------------------------------------------------
class StartupPage : public WBEMPageHelper
{
private:

	CWbemClassObject m_computer;
	CWbemClassObject m_OS;
	CWbemClassObject m_recovery;
	CWbemClassObject m_page;
	CWbemClassObject m_memory;

	BOOL m_writable;
    BOOL m_bDownlevelTarget;

	// helps deal with safe arrays that dont start at zero.
	long m_lBound;
    short m_delay;

	DWORD m_cMegBootPF;
	DWORD m_freeSpace;
	TCHAR m_DriveLtr[3];

	int CoreDumpHandleOk(HWND hDlg);
	long GetRAMSizeMB(void);

	BOOL CoreDumpValidFile(HWND hDlg);
    void OnCDMPOptionUpdate(void);
    void OnBootEdit(void);
	DWORD GetPageFileSize(LPTSTR bootDrv);

	BOOL ExpandRemoteEnvPath(LPTSTR szPath, LPTSTR expPath, UINT size);
	BOOL LocalDrive(LPCTSTR szPath);
	BOOL DirExists(LPCTSTR szPath);
	BOOL IsAlerterSvcStarted(HWND hDlg);

	void    Init(HWND hDlg);
    DWORD   GetDebugInfoType(void);
    HRESULT PutDebugInfoType(DWORD dwDebugInfoType);
	bool    Save(void);
	BOOL    CheckVal(HWND hDlg, WORD wID, WORD wMin, WORD wMax, WORD wMsgID);
	bool    IsWorkstationProduct(void);

public:

    StartupPage(WbemServiceThread *serviceThread);
	~StartupPage();
	INT_PTR DoModal(HWND hDlg);

	INT_PTR CALLBACK DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
};

INT_PTR CALLBACK StaticStartupDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);

#endif __STARTUPPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\stdafx.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\sysdm.h ===
//*************************************************************
//
//  Header file for sysdm applet
//
//  Microsoft Confidential
//  Copyright (c) 1996-1999 Microsoft Corporation
//  All rights reserved
//
//*************************************************************
#pragma once
#include <commctrl.h>
#include "startup.h"
#include "envvar.h"
#include "resource.h"
#include "..\Common\util.h"


//
// Global variables
//

extern HINSTANCE hInstance;
extern TCHAR g_szNull[];


//
// Macros
//

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#define SIZEOF(x)    sizeof(x)

#define SetLBWidth( hwndLB, szStr, cxCurWidth )     SetLBWidthEx( hwndLB, szStr, cxCurWidth, 0)

#define IsPathSep(ch)       ((ch) == TEXT('\\') || (ch) == TEXT('/'))
#define IsWhiteSpace(ch)    ((ch) == TEXT(' ') || (ch) == TEXT('\t') || (ch) == TEXT('\n') || (ch) == TEXT('\r'))
#define IsDigit(ch)         ((ch) >= TEXT('0') && (ch) <= TEXT('9'))

#define DigitVal(ch)        ((ch) - TEXT('0'))
#define FmtFree(s)          LocalFree(s)            /* Macro to free FormatMessage allocated strings */

//
//  Help IDs
//

#define HELP_FILE           TEXT("sysdm.hlp")

#define IDH_HELPFIRST       5000
#define IDH_GENERAL         (IDH_HELPFIRST + 0000)
#define IDH_PERF            (IDH_HELPFIRST + 1000)
#define IDH_ENV             (IDH_HELPFIRST + 2000)
#define IDH_STARTUP         (IDH_HELPFIRST + 3000)
#define IDH_HWPROFILE       (IDH_HELPFIRST + 4000)
#define IDH_USERPROFILE     (IDH_HELPFIRST + 5000)


//
// sysdm.c
//
int  StringToInt( LPTSTR sz );         // TCHAR aware atoi()
void IntToString( INT i, LPTSTR sz);   // TCHAR aware itoa()
LPTSTR SkipWhiteSpace( LPTSTR sz );

BOOL IsUserAdmin(VOID);


//
// envar.c
//

DWORD SetLBWidthEx (HWND hwndLB, LPTSTR szBuffer, DWORD cxCurWidth, DWORD cxExtra);
LPTSTR CloneString( LPTSTR pszSrc );


//
// virtual.c
//

VOID SetDlgItemMB(HWND hDlg, INT idControl, DWORD dwMBValue);
int MsgBoxParam( HWND hWnd, DWORD wText, DWORD wCaption, DWORD wType, ... );
void HourGlass( BOOL bOn );
void ErrMemDlg( HWND hParent );
VOID SetDefButton(HWND hwndDlg, int idButton);


//
// sid.c
//

LPTSTR GetSidString(void);
VOID DeleteSidString(LPTSTR SidString);
PSID GetUserSid (void);
VOID DeleteUserSid(PSID Sid);




//
// Debugging macros
//
#if DBG
#   define  DBG_CODE    1

void DbgPrintf( LPTSTR szFmt, ... );
void DbgStopX(LPSTR mszFile, int iLine, LPTSTR szText );
HLOCAL MemAllocWorker(LPSTR szFile, int iLine, UINT uFlags, UINT cBytes);
HLOCAL MemFreeWorker(LPSTR szFile, int iLine, HLOCAL hMem);
void MemExitCheckWorker(void);


#   define  MemAlloc( f, s )    MemAllocWorker( __FILE__, __LINE__, f, s )
#   define  MemFree( h )        MemFreeWorker( __FILE__, __LINE__, h )
#   define  MEM_EXIT_CHECK()    MemExitCheckWorker()
#   define  DBGSTOP( t )        DbgStopX( __FILE__, __LINE__, TEXT(t) )
#   define  DBGSTOPX( f, l, t ) DbgStopX( f, l, TEXT(t) )
#   define  DBGPRINTF(p)        DbgPrintf p
#   define  DBGOUT(t)           DbgPrintf( TEXT("SYSCPL.CPL: %s\n"), TEXT(t) )
#else
#   define  MemAlloc( f, s )    LocalAlloc( f, s )
#   define  MemFree( h )        LocalFree( h )
#   define  MEM_EXIT_CHECK()
#   define  DBGSTOP( t )
#   define  DBGSTOPX( f, l, t )
#   define  DBGPRINTF(p)
#   define  DBGOUT(t)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\state.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Tab state
//
// 3-11-98 sburns


#include "precomp.h"

#include "state.h"
#include "resource.h"
#include "common.h"
//#include "cred.h"

class Settings
{
public:
   void Refresh();

   CHString   ComputerDomainDNSName;
   CHString   DomainName;
   CHString   FullComputerName;
   CHString   ShortComputerName;
   CHString   NetBIOSComputerName;

   bool     SyncDNSNames;
   bool     JoinedToWorkgroup;
   bool     NeedsReboot;
};


//=========================================================
static bool       machine_is_dc = false;
static bool       networking_installed = false;
static Settings   original;
static Settings   current;
static const CHString SYNC_KEY(
   TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"));
static const CHString SYNC_VALUE(TEXT("SyncDomainWithMembership"));



//=========================================================
bool readSyncFlag()
{
   bool retval = true;
/*
   HKEY hKey = 0;
   do
   {
      LONG result =
         Win::RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            SYNC_KEY,
            KEY_READ,
            hKey);
      if (result != ERROR_SUCCESS)
      {
         break;
      }

      // default is to sync.
      DWORD data = 1;
      DWORD data_size = sizeof(data);
      result = Win::RegQueryValueEx(
         hKey,
         SYNC_VALUE,
         0,
         (BYTE*) &data,
         &data_size);
      if (result != ERROR_SUCCESS)
      {
         break;
      }

      retval = data ? true : false;
   }
   while (0);

   if (hKey)
   {
      Win::RegCloseKey(hKey);
   }
*/
   return retval;
}


//=========================================================
void writeSyncFlag(bool flag)
{
	/*
   HKEY hKey = 0;
   do
   {
      LONG result =
         Win::RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            SYNC_KEY,
            REG_OPTION_NON_VOLATILE,
            KEY_WRITE,
            0,
            hKey,
            0);
      if (result != ERROR_SUCCESS)
      {
         break;
      }

      DWORD data = flag ? 1 : 0;
      DWORD data_size = sizeof(data);
      Win::RegSetValueEx(
         hKey,
         SYNC_VALUE,
         REG_DWORD,
         (BYTE*) &data,
         data_size);
   }
   while (0);

   if (hKey)
   {
      Win::RegCloseKey(hKey);
   }
   */
}



//=========================================================
bool isNetworkingInstalled()
{
/*   SC_HANDLE handle = ::OpenSCManager(0, 0, GENERIC_READ);
   if (!handle)
   {
      TRACE(TEXT("can't open SCM"));
      return false;
   }

   SC_HANDLE wks =
      ::OpenService(
         handle,
         TEXT("LanmanWorkstation"),
         SERVICE_QUERY_STATUS);
   if (!wks)
   {
      TRACE(TEXT("can't open workstation service: not installed"));
      ::CloseServiceHandle(handle);
      return false;
   }

   bool result = false;
   SERVICE_STATUS status;
   memset(&status, 0, sizeof(status));
   if (::QueryServiceStatus(wks, &status))
   {
      if (status.dwCurrentState == SERVICE_RUNNING)
      {
         result = true;
      }
   }

   ::CloseServiceHandle(wks);
   ::CloseServiceHandle(handle);

   TRACE(
      CHString::format(
         TEXT("workstation service %1 running"),
         result ? TEXT("is") : TEXT("is NOT")));

   return result;
   */
	return true;
}



//---------------------------------------------------------
State::State()
   : must_reboot(false)
{
   original.Refresh();
   current = original;
}



//---------------------------------------------------------
State::~State()
{
}


//=========================================================
void Settings::Refresh()
{
/*
   CHString unknown = CHString::load(IDS_UNKNOWN);
   ComputerDomainDNSName = unknown;
   DomainName = unknown;
   FullComputerName = unknown;
   ShortComputerName = unknown;

   SyncDNSNames = readSyncFlag();
   JoinedToWorkgroup = true;

   DSROLE_PRIMARY_DOMAIN_INFO_BASIC* info = 0;
   DWORD err = MyDsRoleGetPrimaryDomainInformation(0, info);
   if (err == NO_ERROR)
   {
      if (info->DomainNameDns)
      {
         DomainName = info->DomainNameDns;
      }
      else if (info->DomainNameFlat)
      {
         DomainName = info->DomainNameFlat;
      }

      // this is the workgroup name iff JoinedToWorkgroup == true
      switch (info->MachineRole)
      {
         case DsRole_RoleBackupDomainController:
         case DsRole_RolePrimaryDomainController:
         {
            machine_is_dc = true;
            JoinedToWorkgroup = false;
            break;
         }
         case DSRole_RoleStandaloneWorkstation:
         case DsRole_RoleStandaloneServer:
         {
            machine_is_dc = false;
            JoinedToWorkgroup = true;
            if (DomainName.empty())
            {
               DomainName = CHString::load(IDS_DEFAULT_WORKGROUP);
            }
            break;
         }
         case DsRole_RoleMemberWorkstation:
         case DsRole_RoleMemberServer:
         {
            machine_is_dc = false;
            JoinedToWorkgroup = false;
            break;
         }
         default:
         {
            assert(false);
            break;
         }
      }

      ::DsRoleFreeMemory(info);
   }
   else
   {
      AppError(0, HRESULT_FROM_WIN32(err),
				CHString::load(IDS_ERROR_READING_MEMBERSHIP));
   }

   networking_installed = isNetworkingInstalled();
   bool tcp_installed = networking_installed && IsTCPIPInstalled();
   CHString active_full_name;

   HKEY hkey = 0;
   LONG result =
      Win::RegOpenKeyEx(
         HKEY_LOCAL_MACHINE,
         TEXT("System\\CurrentControlSet\\Control\\ComputerName\\ComputerName"),
         KEY_READ,
         hkey);
   if (result == ERROR_SUCCESS)
   {
      NetBIOSComputerName = Win::RegQueryValueSz(hkey, TEXT("ComputerName"));
   }
   Win::RegCloseKey(hkey);

   if (tcp_installed)
   {
      HKEY hkey = 0;
      LONG result =
         Win::RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
            KEY_READ,
            hkey);
      if (result == ERROR_SUCCESS)
      {
         CHString active_short_name =
            Win::RegQueryValueSz(hkey, TEXT("Hostname"));
         CHString short_name =
            Win::RegQueryValueSz(hkey, TEXT("NV Hostname"));
         ShortComputerName =
            short_name.empty() ? active_short_name : short_name;

         CHString active_domain_name =
            Win::RegQueryValueSz(hkey, TEXT("Domain"));
         CHString domain_name =
            Win::RegQueryValueSz(hkey, TEXT("NV Domain"));
         ComputerDomainDNSName =
            domain_name.empty() ? active_domain_name : domain_name;

         FullComputerName =
            ShortComputerName + TEXT(".") + ComputerDomainDNSName;
         active_full_name =
            active_short_name + TEXT(".") + active_domain_name;

      }
      Win::RegCloseKey(hkey);
   }
   else
   {
      LONG result =
         Win::RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("System\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName"),
            KEY_READ,
            hkey);
      if (result == ERROR_SUCCESS)
      {
         active_full_name = Win::RegQueryValueSz(hkey, TEXT("ComputerName"));
      }

      Win::RegCloseKey(hkey);
      
      ShortComputerName = NetBIOSComputerName;
      FullComputerName = ShortComputerName;
   }

   NeedsReboot = active_full_name != FullComputerName;
   */
}

//---------------------------------------------------------
void State::Init(CWbemClassObject &computer, 
					CWbemClassObject &os, 
					CWbemClassObject dns)
{
	m_computer = computer;
	m_OS = os;
	m_DNS = dns;
}



//---------------------------------------------------------
void State::Refresh()
{
}



//---------------------------------------------------------
bool State::NeedsReboot() const
{
   return original.NeedsReboot;
}



//---------------------------------------------------------
bool State::IsMachineDC() const
{
   return machine_is_dc;
}



//---------------------------------------------------------
bool State::IsNetworkingInstalled() const
{
   return networking_installed;
}



//---------------------------------------------------------
CHString State::GetFullComputerName() const
{
   return current.FullComputerName;
}



//---------------------------------------------------------
CHString State::GetDomainName() const
{
   return current.DomainName;
}



//---------------------------------------------------------
void State::SetDomainName(const CHString& name)
{
   current.DomainName = name;
}



//---------------------------------------------------------
bool State::IsMemberOfWorkgroup() const
{
   return current.JoinedToWorkgroup;
}



//---------------------------------------------------------
void State::SetIsMemberOfWorkgroup(bool yesNo)
{
   current.JoinedToWorkgroup = yesNo;
}



//---------------------------------------------------------
CHString State::GetShortComputerName() const
{
   return current.ShortComputerName;
}



//---------------------------------------------------------
void State::SetShortComputerName(const CHString& name)
{
   current.ShortComputerName = name;
//   current.NetBIOSComputerName = DNS::HostnameToNetBIOSName(name);
   setFullComputerName();
}



//---------------------------------------------------------
bool State::WasShortComputerNameChanged() const
{
   return true;
      //original.ShortComputerName.icompare(current.ShortComputerName) != 0;
}



//---------------------------------------------------------
CHString State::GetComputerDomainDNSName() const
{
   return current.ComputerDomainDNSName;
}



//---------------------------------------------------------
void State::SetComputerDomainDNSName(const CHString& newName)
{
   current.ComputerDomainDNSName = newName;
   setFullComputerName();
}



//---------------------------------------------------------
void State::setFullComputerName()
{
   current.FullComputerName =
            current.ShortComputerName
         +  TEXT(".")
         +  current.ComputerDomainDNSName;
}



//---------------------------------------------------------
bool State::WasMembershipChanged() const
{
   return true;
//         original.DomainName.icompare(current.DomainName) != 0
//      || original.JoinedToWorkgroup != current.JoinedToWorkgroup;
}



//---------------------------------------------------------
bool State::ChangesNeedSaving() const
{
/*   if (
         original.ComputerDomainDNSName.icompare(
            current.ComputerDomainDNSName) != 0
      || WasMembershipChanged()
      || WasShortComputerNameChanged()
      || SyncDNSNamesWasChanged())
   {
      return true;
   }
*/
   return false;
}



//---------------------------------------------------------
bool State::GetSyncDNSNames() const
{
   return current.SyncDNSNames;
}



//---------------------------------------------------------
void State::SetSyncDNSNames(bool yesNo)
{
   current.SyncDNSNames = yesNo;
}



//---------------------------------------------------------
bool State::SyncDNSNamesWasChanged() const
{
   return original.SyncDNSNames != current.SyncDNSNames;
}



//---------------------------------------------------------
CHString massageUserName(const CHString& domainName, const CHString& userName)
{
/*   if (!domainName.IsEmpty() && !userName.IsEmpty())
   {
      static const CHString DOMAIN_SEP_CHAR = TEXT("\\");
      CHString name = userName;
      int pos = userName.find(DOMAIN_SEP_CHAR);

      if (pos == CHString::npos)
      {
         return domainName + DOMAIN_SEP_CHAR + name;
      }
   }
*/
   return userName;
}


//=======================================================
NET_API_STATUS myNetJoinDomain(
						   const CHString&  domain,
						   const CHString&  username,
						   const CHString&  password,
						   ULONG          flags)
{
/*   assert(!domain.empty());

   NET_API_STATUS status =
      ::NetJoinDomain(
         0, // this machine
         domain.c_str(),
         0, // default OU
         username.empty() ? 0 : username.c_str(),
         password.c_str(),
         flags);

   TRACE(CHString::format(TEXT("Error 0x%1!X! (!0 => error)"), status));

   return status;
   */
	return 0;
}



//=======================================================
HRESULT join(HWND dialog, const CHString& name, bool isWorkgroupJoin)
{
/*   assert(!name.empty());
   assert(Win::IsWindow(dialog));

   Win::CursorSetting cursor(IDC_WAIT);

   State& state = State::GetInstance();
   CHString username = massageUserName(name, state.GetUsername());
   CHString password = state.GetPassword();

   ULONG flags = 0;
   if (!isWorkgroupJoin)
   {
      flags =
            NETSETUP_JOIN_DOMAIN
         |  NETSETUP_ACCT_CREATE
         |  NETSETUP_DOMAIN_JOIN_IF_JOINED;
   }

   NET_API_STATUS status =
      myNetJoinDomain(name, username, password, flags);

   if (
         status == ERROR_ACCESS_DENIED
      && (flags & NETSETUP_ACCT_CREATE) )
   {
      // retry without account create flag for the case where the account
      // already exists
      TRACE(TEXT("Retry without account create flag"));
      status =
         myNetJoinDomain(
            name,
            username,
            password,
            flags & ~NETSETUP_ACCT_CREATE);
   }

   if (status == NERR_Success)
   {
      AppMessage(
         dialog,
         CHString::format(
            isWorkgroupJoin ? IDS_WORKGROUP_WELCOME : IDS_DOMAIN_WELCOME,
            name.c_str()));
   }

   return HRESULT_FROM_WIN32(status);
   */
	return 0;
}



//=======================================================
HRESULT rename(HWND dialog, const CHString& newName)
{
/*   assert(!newName.empty());
   assert(Win::IsWindow(dialog));

   Win::CursorSetting cursor(IDC_WAIT);

   State& state = State::GetInstance();
   CHString username =
      massageUserName(state.GetDomainName(), state.GetUsername());
   CHString password = state.GetPassword();

   ULONG flags = NETSETUP_ACCT_CREATE;

   TRACE(TEXT("Calling NetRenameMachineInDomain"));
   TRACE(               TEXT("lpServer         : (null)"));
   TRACE(CHString::format(TEXT("lpNewMachineName : %1"), newName.c_str()));
   TRACE(CHString::format(TEXT("lpAccount        : %1"), username.c_str()));
   TRACE(CHString::format(TEXT("fRenameOptions   : 0x%1!X!"), flags));

   NET_API_STATUS status =
      ::NetRenameMachineInDomain(
         0, // this machine
         newName.c_str(),
         username.empty() ? 0 : username.c_str(),
         password.c_str(),
         flags);

   TRACE(CHString::format(TEXT("Error 0x%1!X! (!0 => error)"), status));

   // if (status == NERR_Success)
   // {
   //    AppMessage(dialog, IDS_NAME_CHANGED);
   //    state.SetMustRebootFlag(true);
   // }

   return HRESULT_FROM_WIN32(status);
   */
	return 0;
}



//=======================================================
static NET_API_STATUS myNetUnjoinDomain(ULONG flags)
{
   return 0;
}



//=======================================================
HRESULT unjoin(HWND dialog, const CHString& domain)
{
	return S_OK;
}



//=======================================================
HRESULT setDomainDNSName(HWND dialog, const CHString& newDomainDNSName)
{
   return S_OK;
}



//=======================================================
HRESULT setShortName(HWND dialog, const CHString& newShortName)
{
   return S_OK;
}



//=======================================================
bool getCredentials(HWND dialog, int promptResID = 0)
{
   return true;
}



//------------------------------------------------------
bool State::doSaveDomainChange(HWND dialog)
{
   return true;
}



//------------------------------------------------------
bool State::doSaveWorkgroupChange(HWND dialog)
{
   return true;
}



//------------------------------------------------------
bool State::doSaveNameChange(HWND dialog)
{
   return true;
}



//------------------------------------------------------
bool State::SaveChanges(HWND dialog)
{
   return true;
}



//------------------------------------------------------
CHString State::GetUsername() const
{
   return username;
}



//------------------------------------------------------
CHString State::GetPassword() const
{
   return password;
}



//------------------------------------------------------
void State::SetMustRebootFlag(bool yesNo)
{
   must_reboot = yesNo;
}



//------------------------------------------------------
bool State::MustReboot() const
{
   return must_reboot;
}

//------------------------------------------------------
CHString State::GetNetBIOSComputerName() const
{
   return current.NetBIOSComputerName;
}

//------------------------------------------------------
CHString State::GetOriginalShortComputerName() const
{
   return original.ShortComputerName;
}

//------------------------------------------------------
void State::SetUsername(const CHString& name)
{
   username = name;
}

//------------------------------------------------------
void State::SetPassword(const CHString& pass)
{
   password = pass;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\chstring1.h ===
// Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _CHSTRING1_H_
#define _CHSTRING1_H_
#pragma once

#include "CHString.h"

class CHString1 : public CHString
{
public:

	CHString1();
	CHString1(TCHAR ch, int nLength);
//	CHString1(LPCTSTR lpch, int nLength);

	#ifdef _UNICODE
		CHString1(LPCSTR lpsz);
	#else //_UNICODE
		CHString1(LPCWSTR lpsz);
	#endif //!_UNICODE

	CHString1(LPCTSTR lpsz);
	CHString1(const CHString& stringSrc);
	CHString1(const CHString1& stringSrc);

	BOOL LoadString(UINT nID);

protected:
	int LoadString(UINT nID,LPWSTR lpszBuf, UINT nMaxBuf);
};
#endif //_CHSTRING1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\virtualmemdlg.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#pragma once

#include "..\common\WBEMPageHelper.h"

// BUGBUG : Defining an NT-specific manifest just in case this compiles
//          for Win9x.  I'll remove it when I discover the proper manifest
//          or if this is whistler and on only.
//
#define NTONLY

class VirtualMemDlg : public WBEMPageHelper
{
private:
	//  Swap file structure
	class PAGING_FILE
	{
	public:
		PAGING_FILE()
		{
			// for information and error checking.
			name = NULL;
			volume = NULL;
			desc = NULL;
			pszPageFile = NULL;
			objPath = NULL;
			freeSpace = 0;
			totalSize = 0;
			bootDrive = false;
            fRamBasedPagefile = false;

			// user-definable.
			nMinFileSize = 0;
			nMaxFileSize = 0;
			nMinFileSizePrev = 0;
			nMaxFileSizePrev = 0;
			nAllocatedFileSize = 0;
		}
		~PAGING_FILE()
		{
			if(name) delete[] name;
			if(volume) delete[] volume;
			if(desc) delete[] desc;
			if(pszPageFile) delete[] pszPageFile;
			if(objPath) delete[] objPath;
		}
		LPTSTR name;				// drive letter from Win32_LogicalDisk.
		LPTSTR volume;				// volumeName from Win32_LogicalDisk.
		LPTSTR desc;				// driveType string from Win32_LogicalDisk.
		LPTSTR pszPageFile;         // Path to page file if it exists on that drv
		LPTSTR objPath;				// the wbem object path.
		ULONG freeSpace;			// freespace from Win32_LogicalDisk.
		ULONG totalSize;			// totalSize from Win32_LogicalDisk.
		bool bootDrive;
        bool fRamBasedPagefile;     // Inidicates computed page file min/max
                                    // sizes based on available RAM.

		int nMinFileSize;           // Minimum size of pagefile in MB.
		int nMaxFileSize;           // Max size of pagefile in MB.
		int nMinFileSizePrev;       // Previous minimum size of pagefile in MB.
		int nMaxFileSizePrev;       // Previous max size of pagefile in MB.
		int nAllocatedFileSize;		// The actual size allocated
	};

	DWORD m_cxLBExtent;
	int   m_cxExtra;

	IEnumWbemClassObject *m_pgEnumSettings;
	IEnumWbemClassObject *m_pgEnumUsage;
	CWbemClassObject m_memory;
	CWbemClassObject m_registry, m_recovery;

    bool EnsureEnumerator(const bstr_t bstrClass);
	int CheckForRSLChange(HWND hDlg);
	int ComputeTotalMax(void);
	void GetRecoveryFlags(bool &bWrite, bool &bLog, bool &bSend);

	
	void LoadVolumeList(void);
	BOOL Init(HWND hDlg);
	void SelChange(HWND hDlg);
	bool SetNewSize(HWND hDlg);
	int UpdateWBEM(void);
	int PromptForReboot(HWND hDlg);
	void GetCurrRSL( LPDWORD pcmRSL, LPDWORD pcmUsed, LPDWORD pcmPPLim );
	void BuildLBLine(LPTSTR pszBuf, const PAGING_FILE *pgVal);
	unsigned long RecomputeAllocated(void);

	void FindSwapfile(PAGING_FILE *pgVar);

public:
	VirtualMemDlg(WbemServiceThread *serviceThread);
	~VirtualMemDlg();

	bool ComputeAllocated(unsigned long *value);

	bool DlgProc(HWND hDlg,
				UINT message,
				WPARAM wParam,
				LPARAM lParam);

	int DoModal(HWND hDlg);
};

INT_PTR CALLBACK StaticVirtDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\chstring1.cpp ===
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "CHString1.h"

CHString1::CHString1() : CHString()
{
}

CHString1::CHString1(TCHAR ch, int nLength) : CHString(ch,nLength)
{
}

//CHString1::CHString1(LPCTSTR lpch, int nLength) : CHString(lpch,nLength)
//{
//}


#ifdef _UNICODE
CHString1::CHString1(LPCSTR lpsz) : CHString(lpsz)
{
}
#else //_UNICODE
CHString1::CHString1(LPCWSTR lpsz) : CHString(lpsz)
{
}
#endif //!_UNICODE

CHString1::CHString1(LPCTSTR lpsz) : CHString(lpsz)
{
}

CHString1::CHString1(const CHString& stringSrc) : CHString(stringSrc)
{
}

CHString1::CHString1(const CHString1& stringSrc) : CHString((CHString)stringSrc)
{
}

BOOL CHString1::LoadString(UINT nID)
{
    // try fixed buffer first (to avoid wasting space in the heap)

	#ifdef _UNICODE
		const UINT CHAR_FUDGE = 1;    // one WCHAR unused is good enough
	#else
		const UINT CHAR_FUDGE = 2;    // two BYTES unused for case of DBC last char
	#endif

	const UINT STR_BLK_SIZE = 256 ;

	int nLen = 0;
    int nSize = STR_BLK_SIZE;

    do
    {
        nSize += STR_BLK_SIZE;
        nLen = ::LoadStringW(_Module.GetModuleInstance(),nID, GetBuffer(nSize-1), nSize);

    } 
    while (nSize - nLen <= CHAR_FUDGE);

    ReleaseBuffer();

    return nLen > 0;
}

BOOL CHString1::LoadString(UINT nID,LPWSTR lpszBuf, UINT nMaxBuf)
{
	int nSize = 256;
	int nLen = ::LoadStringW(_Module.GetModuleInstance(), nID, lpszBuf, nMaxBuf);
	if (nLen == 0)
		lpszBuf[0] = '\0';
	return nLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\virtualmemdlg.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Application specific
#include "sysdm.h"
#include "VirtualMemDlg.h"
#include "..\common\util.h"
#include <windowsx.h>
#include "helpid.h"
#include "shlwapi.h"

#define RET_ERROR               (-1)
#define RET_NO_CHANGE           0x00
#define RET_VIRTUAL_CHANGE      0x01
#define RET_RECOVER_CHANGE      0x02
#define RET_CHANGE_NO_REBOOT    0x04
#define RET_CONTINUE            0x08
#define RET_BREAK               0x10

#define RET_VIRT_AND_RECOVER (RET_VIRTUAL_CHANGE | RET_RECOVER_CHANGE)

//==========================================================================
//                            Local Definitions
//==========================================================================

#define MAX_SIZE_LEN        4       // Max chars in the Swap File Size edit.
#define MAX_DRIVES          26      // Max number of drives.
#define MIN_SWAPSIZE        2       // Min swap file size (see note below).
#define MIN_FREESPACE       5       // Must have 5 meg free after swap file
#define MIN_SUGGEST         22      // Always suggest at least 22 meg
#define ONE_MEG             1048576
#define MAX_SWAPSIZE        (16 * 1024 * 1024)  // magic number from LouP
                                                // (see note below).

#define MAX_SWAPSIZE_STR   _T("4096")   // Note:  Insure constant strings
#define MIN_FREESPACE_STR  _T("5")      //        equal their manifests.

#define TABSTOP_VOL         22
#define TABSTOP_SIZE        122

TCHAR gszPageFileSettings[]  = _T("Win32_PageFileSetting");
TCHAR gszPageFileUsage[]     = _T("Win32_PageFileUsage");
TCHAR gszLogicalFile[]       = _T("CIM_LogicalFile");
TCHAR gszAllocatedBaseSize[] = _T("AllocatedBaseSize");
TCHAR gszFileSize[]          = _T("FileSize");
TCHAR gszInitialSize[]       = _T("InitialSize");
TCHAR gszMaximumSize[]       = _T("MaximumSize");
TCHAR gszName[]              = _T("Name");
TCHAR gszPFNameFormat[]      = _T("%s\\\\pagefile.sys");


// My privilege 'handle' structure
typedef struct 
{
    HANDLE hTok;
    TOKEN_PRIVILEGES tp;
} PRIVDAT, *PPRIVDAT;

DWORD aVirtualMemHelpIds[] = {
    IDD_VM_VOLUMES,         -1,
    IDD_VM_DRIVE_HDR,       (IDH_DLG_VIRTUALMEM + 0),
    IDD_VM_PF_SIZE_LABEL,   (IDH_DLG_VIRTUALMEM + 1), 
    IDD_VM_DRIVE_LABEL,     (IDH_DLG_VIRTUALMEM + 2),
    IDD_VM_SF_DRIVE,        (IDH_DLG_VIRTUALMEM + 2),
    IDD_VM_SPACE_LABEL,     (IDH_DLG_VIRTUALMEM + 3),
    IDD_VM_SF_SPACE,        (IDH_DLG_VIRTUALMEM + 3),
    IDD_VM_ST_INITSIZE,     (IDH_DLG_VIRTUALMEM + 4),
    IDD_VM_SF_SIZE,         (IDH_DLG_VIRTUALMEM + 4),
    IDD_VM_ST_MAXSIZE,      (IDH_DLG_VIRTUALMEM + 5),
    IDD_VM_SF_SIZEMAX,      (IDH_DLG_VIRTUALMEM + 5),
    IDD_VM_SF_SET,          (IDH_DLG_VIRTUALMEM + 6),
    IDD_VM_MIN_LABEL,       (IDH_DLG_VIRTUALMEM + 7),
    IDD_VM_MIN,             (IDH_DLG_VIRTUALMEM + 7),
    IDD_VM_RECOMMEND_LABEL, (IDH_DLG_VIRTUALMEM + 8),
    IDD_VM_RECOMMEND,       (IDH_DLG_VIRTUALMEM + 8),
    IDD_VM_ALLOCD_LABEL,    (IDH_DLG_VIRTUALMEM + 9),
    IDD_VM_ALLOCD,          (IDH_DLG_VIRTUALMEM + 9),
    IDD_VM_CUSTOMSIZE_RADIO,(IDH_DLG_VIRTUALMEM + 16),
    IDD_VM_RAMBASED_RADIO,  (IDH_DLG_VIRTUALMEM + 17),
    IDD_VM_NOPAGING_RADIO,  (IDH_DLG_VIRTUALMEM + 18),
    0,0
};

//==========================================================================
//                            Typedefs and Structs
//==========================================================================

// registry info for a page file (but not yet formatted).
//Note: since this structure gets passed to FormatMessage, all fields must
//be 4 bytes wide.
typedef struct
{
    LPTSTR pszName;
    DWORD  nMin;
    DWORD  nMax;
    DWORD  chNull;
} PAGEFILDESC;

//==========================================================================
//                     Global Data Declarations
//==========================================================================

//TCHAR  m_szSysHelp[] = TEXT("sysdm.hlp");
//TCHAR g_szSysDir[ MAX_PATH ];
//UINT g_wHelpMessage;

//==========================================================================
//                     Local Data Declarations
//==========================================================================
// Other VM Vars
BOOL gfCoreDumpChanged;

DWORD cmTotalVM;

//==========================================================================
//                      Local Function Prototypes
//==========================================================================
void GetAPrivilege( LPTSTR pszPrivilegeName, HANDLE hToken );
void ResetOldPrivilege( HANDLE hToken );
HRESULT QueryInstanceProperties(
                const TCHAR * pszClass,
                const TCHAR * pszRequestedProperties,
                const TCHAR * pszKeyPropertyName,
                const TCHAR * pszKeyPropertyValue,
                CWbemServices &Services,
                IWbemClassObject ** ppcoInst);

#define GetPageFilePrivilege( hToken )         \
        GetAPrivilege( SE_CREATE_PAGEFILE_NAME, hToken )

//--------------------------------------------------------------
INT_PTR CALLBACK StaticVirtDlgProc(HWND hwndDlg, UINT message, 
								WPARAM wParam, LPARAM lParam) 
{ 
	// if this is the initDlg msg...
	if(message == WM_INITDIALOG)
	{
		// transfer the 'this' ptr to the extraBytes.
		SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
	}

	// DWL_USER is the 'this' ptr.
	VirtualMemDlg *me = (VirtualMemDlg *)GetWindowLongPtr(hwndDlg, DWLP_USER);

	if(me != NULL)
	{
		// call into the DlgProc() that has some context.
		return me->DlgProc(hwndDlg, message, wParam, lParam);
	}
	else
	{
		return FALSE;
	}
}
//--------------------------------------------------------------
VirtualMemDlg::VirtualMemDlg(WbemServiceThread *serviceThread)
				: WBEMPageHelper(serviceThread)
{
	IWbemClassObject *pInst = NULL;

	m_pgEnumSettings       = NULL;
	m_pgEnumUsage          = NULL;
	m_cxLBExtent           = 0;
	if((pInst = FirstInstanceOf("Win32_LogicalMemoryConfiguration")) != NULL)
	{
		m_memory = pInst;
	}

	if((pInst = FirstInstanceOf("Win32_Registry")) != NULL)
	{
		m_registry = pInst;
	}

	if((pInst = FirstInstanceOf("Win32_OSRecoveryConfiguration")) != NULL)
	{
		m_recovery = pInst;
	}
}

//--------------------------------------------------------------
VirtualMemDlg::~VirtualMemDlg()
{
	if(m_pgEnumSettings != NULL)
	{
		m_pgEnumSettings->Release();
		m_pgEnumSettings = NULL;
	}
	if(m_pgEnumUsage != NULL)
	{
		m_pgEnumUsage->Release();
		m_pgEnumUsage = NULL;
	}
}
//--------------------------------------------------------------
int VirtualMemDlg::DoModal(HWND hDlg)
{
	return (int) DialogBoxParam(HINST_THISDLL,
							(LPTSTR) MAKEINTRESOURCE(DLG_VIRTUALMEM), 
							hDlg,
							(DLGPROC)StaticVirtDlgProc,
							(LPARAM)this);
}
//--------------------------------------------------------------
int TranslateDlgItemInt( HWND hDlg, int id ) 
{
    /*
     * We can't just call GetDlgItemInt because the
     * string we are trying to translate looks like:
     *  nnn (MB), and the '(MB)' would break GetDlgInt.
     */
    TCHAR szBuffer[256] = {0};
    int i = 0;

    if (GetDlgItemText(hDlg, id, szBuffer,
            sizeof(szBuffer) / sizeof(*szBuffer))) 
	{
		_stscanf(szBuffer, _T("%d"), &i);
    }

    return i;
}


//----------------------------------------------------
bool VirtualMemDlg::DlgProc(HWND hDlg,
							UINT message,
							WPARAM wParam,
							LPARAM lParam)
{
    static int fEdtCtlHasFocus = 0;
	m_hDlg = hDlg;

    switch (message)
    {
    case WM_INITDIALOG:
        Init(hDlg);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDD_VM_VOLUMES:
             // Make edit control reflect the listbox selection.
            if (HIWORD(wParam) == LBN_SELCHANGE)
                SelChange(hDlg);

            break;

        case IDD_VM_SF_SET:
            if (SetNewSize(hDlg))
            {
                ::EnableWindow(::GetDlgItem(hDlg, IDD_VM_SF_SET), FALSE);
	            SetDefButton(hDlg, IDOK);
            }
            break;

        case IDOK:
        {
            int iRet = UpdateWBEM();
//            iRet |= PromptForReboot(hDlg);

            if (iRet & RET_CHANGE_NO_REBOOT) 
			{
                // We created a pagefile, turn off temp page file flag
                DWORD dwRegData;
                dwRegData = 0;
            }

            if (gfCoreDumpChanged)
                iRet |= RET_RECOVER_CHANGE;

            EndDialog(hDlg, iRet );
            HourGlass(FALSE);
            break;
        }

        case IDCANCEL:
            // get rid of changes and restore original values.
            EndDialog(hDlg, RET_NO_CHANGE);
            HourGlass(FALSE);
            break;

        case IDD_HELP:
            break;

        case IDD_VM_SF_SIZE:
        case IDD_VM_SF_SIZEMAX:
            switch(HIWORD(wParam))
            {
            case EN_CHANGE:
                if (fEdtCtlHasFocus != 0)
				{
					::EnableWindow(::GetDlgItem(hDlg, IDD_VM_SF_SET), TRUE);
                    SetDefButton( hDlg, IDD_VM_SF_SET);
				}
                break;

            case EN_SETFOCUS:
                fEdtCtlHasFocus++;
                break;

            case EN_KILLFOCUS:
                fEdtCtlHasFocus--;
                break;
            }
            break;

        case IDD_VM_NOPAGING_RADIO:
        case IDD_VM_RAMBASED_RADIO:
            if( HIWORD(wParam) == BN_CLICKED )
            {
                EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZE ), FALSE );
                EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZEMAX ), FALSE );
				::EnableWindow(::GetDlgItem(hDlg, IDD_VM_SF_SET), TRUE);
                SetDefButton( hDlg, IDD_VM_SF_SET);
            }
            break;

        case IDD_VM_CUSTOMSIZE_RADIO:
            if( HIWORD(wParam) == BN_CLICKED )
            {
                EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZE ), TRUE );
                EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZEMAX ), TRUE );
                ::EnableWindow(::GetDlgItem(hDlg, IDD_VM_SF_SET), TRUE);
                SetDefButton( hDlg, IDD_VM_SF_SET);
            }
            break;

        default:
            break;
        }
        break;

    case WM_DESTROY:
		{
			PAGING_FILE *pgVal = NULL;
			HWND lbHWND = GetDlgItem(m_hDlg, IDD_VM_VOLUMES);
			int last = ListBox_GetCount(lbHWND);

			// zero-based loop.
			for(int x = 0; x < last; x++)
			{
				pgVal = (PAGING_FILE *)ListBox_GetItemData(lbHWND, x);
				delete pgVal;
			}
		}
		break;
    case WM_HELP:      // F1
		::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
					L"sysdm.hlp", 
					HELP_WM_HELP, 
					(ULONG_PTR)(LPSTR)aVirtualMemHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
				(ULONG_PTR)(LPSTR) aVirtualMemHelpIds);
        break;

    default:
	    return FALSE;
        break;
    }

    return TRUE;
}

//---------------------------------------------------------------
TCHAR szCrashControl[] = TEXT("System\\CurrentControlSet\\Control\\CrashControl");
TCHAR szMemMan[] = TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management");
TCHAR szRegSizeLim[] = TEXT("System\\CurrentControlSet\\Control");

BOOL VirtualMemDlg::Init(HWND hDlg)
{
    INT i;
    HWND hwndLB;
    INT aTabs[2];
    RECT rc;
	DWORD dwTotalPhys = 0;

    HourGlass(TRUE);

//    g_wHelpMessage    = RegisterWindowMessage( TEXT( "ShellHelp" ) );

    if(m_pgEnumUsage == NULL) 
	{
        //  Error - cannot even get list of paging files from WBEM
        MsgBoxParam(hDlg, SYSTEM+11, IDS_TITLE, MB_ICONEXCLAMATION);
        EndDialog(hDlg, RET_NO_CHANGE);
        HourGlass(FALSE);
        return FALSE;
    }

	BOOL vcVirtRO = TRUE, vcCoreRO = TRUE;

	RemoteRegWriteable(szCrashControl, vcCoreRO);
	RemoteRegWriteable(szMemMan, vcVirtRO);

	// EXCUSE: I wanted to preserve as much of the original logic but its
	// writability was reversed from my util so I do this wierd thing to
	// flip it back.
	vcCoreRO = !vcCoreRO;
	vcVirtRO = !vcVirtRO;

     // To change Virtual Memory size or Crash control, we need access
     // to both the CrashCtl key and the PagingFiles value in the MemMgr key
    if(vcVirtRO || vcCoreRO) 
	{
        // Disable some fields, because they only have Read access.
        EnableWindow(GetDlgItem(hDlg, IDD_VM_SF_SIZE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_VM_SF_SIZEMAX), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_VM_ST_INITSIZE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_VM_ST_MAXSIZE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_VM_SF_SET), FALSE);
    }

    hwndLB = GetDlgItem(hDlg, IDD_VM_VOLUMES);
    aTabs[0] = TABSTOP_VOL;
    aTabs[1] = TABSTOP_SIZE;
    SendMessage(hwndLB, LB_SETTABSTOPS, 2, (LPARAM)&aTabs);

     // Since SetGenLBWidth only counts tabs as one character, we must compute
     // the maximum extra space that the tab characters will expand to and
     // arbitrarily tack it onto the end of the string width.
     //
     // cxExtra = 1st Tab width + 1 default tab width (8 chrs) - strlen("d:\t\t");
     //
     // (I know the docs for LB_SETTABSTOPS says that a default tab == 2 dlg
     // units, but I have read the code, and it is really 8 chars)
    rc.top = rc.left = 0;
    rc.bottom = 8;
    rc.right = TABSTOP_VOL + (4 * 8) - (4 * 4);
    MapDialogRect( hDlg, &rc );

    m_cxExtra = rc.right - rc.left;

    // List all drives
	LoadVolumeList();

    SendDlgItemMessage(hDlg, IDD_VM_SF_SIZE, EM_LIMITTEXT, MAX_SIZE_LEN, 0L);
    SendDlgItemMessage(hDlg, IDD_VM_SF_SIZEMAX, EM_LIMITTEXT, MAX_SIZE_LEN, 0L);

    // Get the total physical memory in the machine.
	dwTotalPhys = m_memory.GetLong("TotalPhysicalMemory");

	SetDlgItemMB(hDlg, IDD_VM_MIN, MIN_SWAPSIZE);

	// convert to KBs for the calculation.
	dwTotalPhys /= 1024;
	dwTotalPhys *= 3;
	dwTotalPhys >>=1;	// x*3/2 == 1.5*x more or less.
	i = (DWORD)dwTotalPhys;
	SetDlgItemMB(hDlg, IDD_VM_RECOMMEND, max(i, MIN_SUGGEST));

    // Select the first drive in the listbox.
    SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_SETCURSEL, 0, 0L);
    SelChange(hDlg);

	//since the data is already loaded into the listbox, we use this lightweight
	// way of calculating.
    SetDlgItemMB(hDlg, IDD_VM_ALLOCD, RecomputeAllocated());

    // Show RegQuota
	cmTotalVM = ComputeTotalMax();

    HourGlass(FALSE);

    return TRUE;
}

//-------------------------------------------------------------------
int VirtualMemDlg::ComputeTotalMax( void ) 
{
    INT nTotalAllocated = 0;
    INT i;

	HWND VolHWND = GetDlgItem(m_hDlg, IDD_VM_VOLUMES);
	int cItems = ListBox_GetCount(VolHWND);

    for(i = 0; i < cItems; i++) 
    {
		PAGING_FILE *pgVal = (PAGING_FILE *)ListBox_GetItemData(VolHWND, i);
        nTotalAllocated += pgVal->nMaxFileSize;
    }

    return nTotalAllocated;
}

//--------------------------------------------------------
void VirtualMemDlg::BuildLBLine(LPTSTR pszBuf,
								const PAGING_FILE *pgVal)
{
    //
    // Build a string according to the following format:
    //
    // C:  [   Vol_label  ]   %d   -   %d
    //

    TCHAR szVolume[MAX_PATH] = {0};
    TCHAR szTemp[MAX_PATH] = {0};
	
    if (pgVal->name != NULL)
    {
        lstrcpy(pszBuf, pgVal->name);
    }
    else
    {
        *pszBuf = _T('\0');
    }
    lstrcat(pszBuf, _T("\t"));

    if (pgVal->volume != NULL && *pgVal->volume)
    {
        lstrcat(pszBuf, _T("["));
		lstrcat(pszBuf, pgVal->volume);
		lstrcat(pszBuf, _T("]"));
    }

    if (!pgVal->fRamBasedPagefile && pgVal->nMinFileSize)
    {
        //
        // Drive has a page file with specific settings.
        //
		wsprintf(szTemp, _T("\t%d - %d"),  pgVal->nMinFileSize,
                    pgVal->nMaxFileSize);
        lstrcat(pszBuf, szTemp);
    }
    else
    {
        //
        // Either the page file size is derived from the RAM size or the
        // drive doesn't have a page file.
        //
        // In either case, do nothing else.
        //
    }
}

//--------------------------------------------------------------
void VirtualMemDlg::SelChange(HWND hDlg)
{
    TCHAR szTemp[MAX_PATH] = {0};
    INT iSel;
    INT nCrtRadioButtonId;
    PAGING_FILE *iDrive;
    BOOL fEditsEnabled;

	// where are we pointing now.
    if ((iSel = (INT)SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, 
										LB_GETCURSEL, 0, 0)) == LB_ERR)
	{
        return;
	}

	// get its data.
    iDrive = (PAGING_FILE *)SendDlgItemMessage(hDlg, IDD_VM_VOLUMES,
												LB_GETITEMDATA, iSel, 0);

	TCHAR volBuf[40] = {0};
	
	if(_tcslen(iDrive->volume) != 0)
	{
		_tcscpy(volBuf, _T("["));
		_tcscat(volBuf, iDrive->volume);
		_tcscat(volBuf, _T("]"));
	}

	wsprintf(szTemp, _T("%s  %s"), 
				iDrive->name, 
				volBuf);

    //LATER: should we also put up total drive size as well as free space?
    SetDlgItemText(hDlg, IDD_VM_SF_DRIVE, szTemp);

    if ( iDrive->fRamBasedPagefile )
    {
        //
        // Paging file size based on RAM size
        //

        nCrtRadioButtonId = IDD_VM_RAMBASED_RADIO;
        fEditsEnabled = FALSE;
    }
    else
    {
        if ( iDrive->nMinFileSize )
        {
            //
            // Custom size paging file
            //

            nCrtRadioButtonId = IDD_VM_CUSTOMSIZE_RADIO;
            SetDlgItemInt(hDlg, IDD_VM_SF_SIZE, iDrive->nMinFileSize,
                            FALSE);
            SetDlgItemInt(hDlg, IDD_VM_SF_SIZEMAX, iDrive->nMaxFileSize,
                            FALSE);
            fEditsEnabled = TRUE;
        }
        else
        {
            //
            // No paging file
            //

            nCrtRadioButtonId = IDD_VM_NOPAGING_RADIO;
            SetDlgItemText(hDlg, IDD_VM_SF_SIZE, TEXT(""));
            SetDlgItemText(hDlg, IDD_VM_SF_SIZEMAX, TEXT(""));
            fEditsEnabled = FALSE;

            //
            // If the allocated size is zero, then this is a volume which
            // had a page file previously but does not now. In this case,
            // there is no settings/usage information in the repository.
            // Since the pagefile.sys file size is considered free space
            // in the free space size computation, then it needs to be
            // obtained here.
            //

            if ( iDrive->nAllocatedFileSize == 0 )
            {
                //
                // Fetch x:\pagefile.sys file size.
                //

	            CWbemClassObject LogicalFile;
                IWbemClassObject * pcoInst;
                HRESULT hr;

                wsprintf(szTemp, gszPFNameFormat, iDrive->name);

                hr = QueryInstanceProperties(gszLogicalFile,
                                             gszFileSize,
                                             gszName,
                                             szTemp,
                                             m_WbemServices,
                                             &pcoInst);

                LogicalFile = pcoInst;
                if (SUCCEEDED(hr))
                {
                    iDrive->nAllocatedFileSize =
                        (LogicalFile.GetLong(gszFileSize) / ONE_MEG);
                }
            }
        }
    }

    //
    // Set 'Space Available'.
    //

    SetDlgItemMB(hDlg, IDD_VM_SF_SPACE,
                    iDrive->freeSpace + iDrive->nAllocatedFileSize);
    //
    // Select the appropriate radio button
    //

    CheckRadioButton(
        hDlg,
        IDD_VM_CUSTOMSIZE_RADIO,
        IDD_VM_NOPAGING_RADIO,
        nCrtRadioButtonId );

    //
    // Enable/disable the min & max size edit boxes
    //

    EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZE ), fEditsEnabled );
    EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZEMAX ), fEditsEnabled );
}

//--------------------------------------------------------------
bool VirtualMemDlg::EnsureEnumerator(const bstr_t bstrClass)
{
	HRESULT hr = S_OK;
	
    //
    // This code used to retain/cache these interface ptrs and call
    // CreateInstanceEnum once. But the logic was commented out for
    // some reason with a comment that it was expensive to cache the
    // interfaces, although the data member was set each time with no
    // call to Release!).
    //

    if (lstrcmpi(gszPageFileSettings, bstrClass) == 0)
    {
        IEnumWbemClassObject * pgEnumSettings = NULL;
        hr = m_WbemServices.CreateInstanceEnum(bstrClass, WBEM_FLAG_SHALLOW, 
                                               &pgEnumSettings);
        if (SUCCEEDED(hr))
        {
            if (m_pgEnumSettings != NULL)
            {
                m_pgEnumSettings->Release();
            }
            m_pgEnumSettings = pgEnumSettings;
        }
    }
    else if (lstrcmpi(gszPageFileUsage, bstrClass) == 0)
    {
        IEnumWbemClassObject * pgEnumUsage = NULL;
        hr = m_WbemServices.CreateInstanceEnum(bstrClass,  WBEM_FLAG_SHALLOW, 
                                               &pgEnumUsage);
        if (SUCCEEDED(hr))
        {
            if (m_pgEnumUsage != NULL)
            {
                m_pgEnumUsage->Release();
            }
            m_pgEnumUsage = pgEnumUsage;
        }
    }
    else
    {
        // Do nothing.
    }

	return (SUCCEEDED(hr));
}
//--------------------------------------------------------------
void VirtualMemDlg::LoadVolumeList(void)
{
	IEnumWbemClassObject *diskEnum = NULL;
	IWbemClassObject *pInst = NULL;
	CWbemClassObject newInst;

	DWORD uReturned = 0;
	HRESULT hr = 0;

	bstr_t sNameProp(gszName);
	bstr_t sVolumeProp("VolumeName");
	bstr_t sDriveTypeProp("DriveType");
	bstr_t sFreeProp("FreeSpace");
	bstr_t sSizeProp("Size"), temp;
	long driveType;
	__int64 temp64 = 0;

	variant_t pVal;
	int idx;
	TCHAR volumeLine[100] = {0};

	PAGING_FILE *pgVar;

	HWND VolHWND = GetDlgItem(m_hDlg, IDD_VM_VOLUMES);

	// walk the disks.
	if(hr = m_WbemServices.ExecQuery(bstr_t("Select __PATH, DriveType from Win32_LogicalDisk"), 
												0, &diskEnum) == S_OK)
	{
		TCHAR bootLtr[2] = {0};
		if((pInst = FirstInstanceOf("Win32_OperatingSystem")) != NULL)
		{
			CWbemClassObject os = pInst;
			bstr_t temp = os.GetString(L"SystemDirectory");
			_tcsncpy(bootLtr, temp, 1);
		}

		// get the first and only instance.
		while(SUCCEEDED(diskEnum->Next(-1, 1, &pInst, &uReturned)) && 
			  (uReturned != 0))
		{
			// get the DriveType.
			if ((pInst->Get(sDriveTypeProp, 0L, &pVal, NULL, NULL) == S_OK))
			{
				// look at the DriveType to see if this drive can have a swapfile.
				driveType = pVal;
				if(driveType == DRIVE_FIXED)
				{
					// it can so get the expensive properties now.
					// NOTE: This releases pInst; cuz you EXCHANGED 
					//   it for a better one.
					newInst = ExchangeInstance(&pInst);

					// extract.
					pgVar = new PAGING_FILE;

					pgVar->name = CloneString(newInst.GetString(sNameProp));
					pgVar->volume = CloneString(newInst.GetString(sVolumeProp));
					if(bootLtr[0] == pgVar->name[0])
					{
						pgVar->bootDrive = true;
					}

					temp64 = 0;
					temp = newInst.GetString(sFreeProp);
					_stscanf(temp, _T("%I64d"), &temp64);
					pgVar->freeSpace = (ULONG)(temp64 / ONE_MEG);

					temp64 = 0;
					temp = newInst.GetString(sSizeProp);
					_stscanf(temp, _T("%I64d"), &temp64);
					pgVar->totalSize = (ULONG)(temp64 / ONE_MEG);

					// match with a Win32_PageFileSettings if possible.
					FindSwapfile(pgVar);

					// add it to the listbox.
					BuildLBLine(volumeLine, pgVar);
					idx = ListBox_AddString(VolHWND, volumeLine);
					int nRet = ListBox_SetItemData(VolHWND, idx, pgVar);
					if(nRet == LB_ERR)
					{
						MessageBox(NULL,_T("Error"),_T("Error"),MB_OK);
					}

					m_cxLBExtent = SetLBWidthEx(VolHWND, volumeLine, m_cxLBExtent, m_cxExtra);

				} //endif drive can have swapfile.

			} //endif get the cheap variable.

			// in case it wasn't exchanged, release it now.
			if(pInst)
			{
				pInst->Release();
				pInst = NULL;
			}

		} // endwhile Enum

		diskEnum->Release();

	} //endif CreateInstanceEnum() SUCCEEDED (one way or another :)
}
//---------------------------------------------------------------
void VirtualMemDlg::FindSwapfile(PAGING_FILE *pgVar)
{
	IWbemClassObject *pInst = NULL;
	CWbemClassObject PFSettings;
	CWbemClassObject PFUsage;
	DWORD uReturned = 0;
	HRESULT hr = 0;

	bstr_t sNameProp(gszName);
	bstr_t sMaxProp(gszMaximumSize);
	bstr_t sInitProp(gszInitialSize);
	bstr_t sPathProp("__PATH");
	bstr_t sAllocSize(gszAllocatedBaseSize);

	variant_t pVal, pVal1, pVal2, pVal3;
	bstr_t bName;

	// do we have one?
	if(EnsureEnumerator(gszPageFileSettings))
	{
		m_pgEnumSettings->Reset();

		// walk through the pagefiles...
		while((hr = m_pgEnumSettings->Next(-1, 1, &pInst,
                                            &uReturned) == S_OK) && 
              (uReturned != 0))
		{
			PFSettings = pInst;
			// trying to match the drive letter.
			bName = PFSettings.GetString(sNameProp);

			if(_wcsnicmp((wchar_t *)bName, pgVar->name, 1) == 0)
			{
				// letter matched; get some details.
				pgVar->nMinFileSize = 
					pgVar->nMinFileSizePrev = PFSettings.GetLong(sInitProp);
				
                //
                // If the page file InitialSize property is zero, it is an
                // indication that the page file size is to be computed based
                // on RAM size.
                //
                pgVar->fRamBasedPagefile = (pgVar->nMinFileSize ?
                                                        FALSE : TRUE);

				pgVar->nMaxFileSize = 
					pgVar->nMaxFileSizePrev = PFSettings.GetLong(sMaxProp);

				pgVar->objPath = CloneString(PFSettings.GetString(sPathProp));

				pgVar->pszPageFile = CloneString(bName);
					
                //
                // Fetch the Win32_PageFileUsage.AllocatedBaseSize property.
                //
                TCHAR szTemp[sizeof(gszPFNameFormat) / sizeof(TCHAR)];
                wsprintf(szTemp, gszPFNameFormat, pgVar->name);

                IWbemClassObject * pcoInst;
                hr = QueryInstanceProperties(gszPageFileUsage,
                                             gszAllocatedBaseSize,
                                             gszName,
                                             szTemp,
                                             m_WbemServices,
                                             &pcoInst);

                PFUsage = pcoInst;
                if (SUCCEEDED(hr))
                {
                    pgVar->nAllocatedFileSize = PFUsage.GetLong(sAllocSize);
                }
                else
                {
                    pgVar->nAllocatedFileSize = 0;
                }

                // found the one and only-- cleanup early and bail out.
                pInst->Release();
                break; // while()

			} //endif match the drive letter.

			// in case that BREAK didn't jump over the endwhile()
			pInst->Release();

		} // endwhile envEnum

		// NOTE: The BREAK jumps here. Duplicate any cleanup from before the
		// endwhile.

	} //endif CreateInstanceEnum() SUCCEEDED one way or another :)
}

//--------------------------------------------------------------
// this version calculates based on pre-existing wbem data.
bool VirtualMemDlg::ComputeAllocated(unsigned long *value)
{
	bool retval = false;

	IWbemClassObject *pgInst = NULL;
	DWORD uReturned = 0;

	bstr_t sAllocSize(gszAllocatedBaseSize);

	variant_t pVal, pVal1;

	// do we have one?
	if(EnsureEnumerator(gszPageFileUsage))
	{
		m_pgEnumUsage->Reset();

		// get the first and only instance.
		while(SUCCEEDED(m_pgEnumUsage->Next(-1, 1, &pgInst, &uReturned)) && 
			  (uReturned != 0))
		{
			// get the variables.
			if((pgInst->Get(sAllocSize, 0L, &pVal1, NULL, NULL) == S_OK) &&
				(pVal1.vt == VT_I4))
			{
				*value += pVal1.ulVal;
			} //endif get the variable.
			pgInst->Release();

		} // endwhile envEnum
		retval = true;
	
	} //endif CreateInstanceEnum() SUCCEEDED (one way or another :)

	return retval;
}

//--------------------------------------------------------------
// this version calculates based on the listbox.
unsigned long VirtualMemDlg::RecomputeAllocated(void)
{
    unsigned long nTotalAllocated = 0;
	PAGING_FILE *pgVal = NULL;

	HWND lbHWND = GetDlgItem(m_hDlg, IDD_VM_VOLUMES);

	int last = ListBox_GetCount(lbHWND);

	// zero-based loop.
	for(int x = 0; x < last; x++)
	{
		pgVal = (PAGING_FILE *)ListBox_GetItemData(lbHWND, x);
        if ( pgVal->fRamBasedPagefile || pgVal->nMinFileSize )
        {
            //
            // Add in only pagefiles in use.
            //
            nTotalAllocated += pgVal->nAllocatedFileSize;
        }
	}
    return nTotalAllocated;
}

//--------------------------------------------------------------
void VirtualMemDlg::GetRecoveryFlags(bool &bWrite, bool &bLog, bool &bSend)
{
	if((bool)m_recovery)
	{
		bWrite = m_recovery.GetBool("WriteDebugInfo");
		bLog = m_recovery.GetBool("WriteToSystemLog");
		bSend = m_recovery.GetBool("SendAdminAlert");
	}
	else
	{
		bWrite = bLog = bSend = false;
	}
}

//--------------------------------------------------------------
/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!! IMPORTANT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
/* THIS FUNCTION IS A REPLICA OF THE FUNCTION in \\depot\shell\cpls\system\virtual.c   */
/* OFCOURSE WITH A BIT OF MODIFICATION FOR USING WMI								   */
/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/	

bool VirtualMemDlg::SetNewSize(HWND hDlg)
{
    ULONG nSwapSize;
    ULONG nSwapSizeMax;
    BOOL fTranslated;
    INT iSel;
    PAGING_FILE *iDrive;
    TCHAR szTemp[MAX_PATH] = {0};
    ULONG nBootPF = 0;
    bool fRamBasedPagefile = FALSE;

    // Initialize variables for crashdump.
    // nBootPF == crash dump size required.
    //
	bool bWrite = false, bLog = false, bSend = false;

	GetRecoveryFlags(bWrite, bLog, bSend);

    if (bWrite) 
	{
        nBootPF = -1;
    } 
	else if (bLog || bSend) 
	{
        nBootPF = MIN_SWAPSIZE;
    }

    if (nBootPF == -1) 
	{
        nBootPF = ((DWORD)m_memory.GetLong("TotalPhysicalMemory") / 1024);
    }

    if ( IsDlgButtonChecked( hDlg, IDD_VM_NOPAGING_RADIO ) == BST_CHECKED )
    {
        //
        // No paging file on this drive.
        //

        nSwapSize = 0;
        nSwapSizeMax = 0;
        fTranslated = TRUE;
    }
    else
    {
        if ( IsDlgButtonChecked( hDlg,
                                IDD_VM_RAMBASED_RADIO ) == BST_CHECKED )
        {
            MEMORYSTATUSEX MemoryInfo;

            //
            // User requested a RAM based page file. We will compute a page
            // file size based on the RAM currently available so that we can
            // benefit of all the verifications done below related to disk
            // space available etc.
            //
            // The final page file specification written to the registry will
            // contain zero sizes though because this is the way we signal
            // that we want a RAM based page file.
            //

            ZeroMemory (&MemoryInfo, sizeof MemoryInfo);
            MemoryInfo.dwLength =  sizeof MemoryInfo;

            if (GlobalMemoryStatusEx (&MemoryInfo))
            {
                fRamBasedPagefile = TRUE;

                //
                // We do not lose info because we first divide the RAM size to
                // 1Mb and only after that we convert to a DWORD.
                //

                nSwapSize = (DWORD)(MemoryInfo.ullTotalPhys / 0x100000) + 12;
                nSwapSizeMax = nSwapSize;
                fTranslated = TRUE;
            }
            else
            {
                nSwapSize = 0;
                nSwapSizeMax = 0;
                fTranslated = TRUE;
            }
        }
        else
        {
            //
            // User requested a custom size page file.
            //

            nSwapSize = (ULONG)GetDlgItemInt(hDlg, IDD_VM_SF_SIZE,
								            &fTranslated, FALSE);

		    // was it an integer?
            if (!fTranslated)
            {
			    // need a valid integer for initial size.
                MsgBoxParam(hDlg, SYSTEM+37, IDS_TITLE, MB_ICONEXCLAMATION);
                SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZE));
                return FALSE;
            }

		    // was it in range > 2MB
            if ((nSwapSize < MIN_SWAPSIZE && nSwapSize != 0))
            {
			    // initial value out of range.
                MsgBoxParam(hDlg, SYSTEM+13, IDS_TITLE, MB_ICONEXCLAMATION);
                SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZE));
                return FALSE;
            }

		    // deleting swapfile?
            if (nSwapSize == 0)
            {
                nSwapSizeMax = 0;
            }
            else // adding/changing.
            {
                nSwapSizeMax = (ULONG)GetDlgItemInt(hDlg, IDD_VM_SF_SIZEMAX,
							                        &fTranslated, FALSE);

			    // was it an integer?
                if (!fTranslated)
                {
				    // need an integer.
                    MsgBoxParam(hDlg, SYSTEM+38, IDS_TITLE,
                                MB_ICONEXCLAMATION);
                    SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZEMAX));
                    return FALSE;
                }

			    // in range?
                if (nSwapSizeMax < nSwapSize || nSwapSizeMax > MAX_SWAPSIZE)
                {
                    MsgBoxParam(hDlg, SYSTEM+14, IDS_TITLE,
                                MB_ICONEXCLAMATION, MAX_SWAPSIZE_STR);
                    SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZEMAX));
                    return FALSE;
                }
            }
        }
    }

	// if we have integers and the listbox has a good focus...
    if (fTranslated &&
        (iSel = (INT)SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_GETCURSEL,
                                            0, 0)) != LB_ERR)
    {
		// get the item's data.
        iDrive = (PAGING_FILE *)SendDlgItemMessage(hDlg, IDD_VM_VOLUMES,
											        LB_GETITEMDATA, iSel, 0);

		// will it fit?
        if (nSwapSizeMax > iDrive->totalSize)
        {
			// nope.
            MsgBoxParam(hDlg, SYSTEM+16, IDS_TITLE, 
							MB_ICONEXCLAMATION, iDrive->name);
            SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZEMAX));
            return FALSE;
        }

		//Actual FreeSpace is freespace in the disk + page file size.
		ULONG freeSpace = iDrive->freeSpace + iDrive->nAllocatedFileSize;

		// room to spare??
        if (nSwapSize > freeSpace)
        {
			// nope.
            MsgBoxParam(hDlg, SYSTEM+15, IDS_TITLE, MB_ICONEXCLAMATION);
            SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZE));
            return FALSE;
        }

		// don't hog the last 5MB.
        if (nSwapSize != 0 && freeSpace - nSwapSize < MIN_FREESPACE)
        {
            MsgBoxParam(hDlg, SYSTEM+26, IDS_TITLE, MB_ICONEXCLAMATION,
                    MIN_FREESPACE_STR);
            SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZE));
            return FALSE;
        }

		// max too big, should I just use all the space anyway.
        if (nSwapSizeMax > freeSpace)
        {
            if (MsgBoxParam(hDlg, SYSTEM+20, IDS_TITLE, MB_ICONINFORMATION |
                       MB_OKCANCEL, iDrive->name) == IDCANCEL)
            {
                SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZEMAX));
                return FALSE;
            }
        }

		// enough room for core dumps??
        if (iDrive->bootDrive && nSwapSize < nBootPF) 
		{
             // The new boot drive page file size is less than we need for
             // crash control.  Inform the user.
            if (MsgBoxParam(hDlg, SYSTEM+29, IDS_TITLE, 
							MB_ICONEXCLAMATION |MB_YESNO, 
							iDrive->name, _itow(nBootPF, szTemp, 10)) != IDYES)
			{
                SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZE));
                return FALSE;
            }
        }

        iDrive->nMinFileSize = nSwapSize;
        iDrive->nMaxFileSize = nSwapSizeMax;
        iDrive->fRamBasedPagefile = fRamBasedPagefile;

        BuildLBLine(szTemp, iDrive);

        SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_DELETESTRING, iSel, 0);
        SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_INSERTSTRING, iSel,
					        (LPARAM)szTemp);
        SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_SETITEMDATA, iSel,
							(LPARAM)iDrive);
        SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_SETCURSEL, iSel, 0L);

        m_cxLBExtent = SetLBWidthEx(GetDlgItem(hDlg, IDD_VM_VOLUMES),
                                    szTemp, m_cxLBExtent, m_cxExtra);

        if (!iDrive->fRamBasedPagefile && iDrive->nMinFileSize) 
		{
            SetDlgItemInt(hDlg, IDD_VM_SF_SIZE, iDrive->nMinFileSize, FALSE);
            SetDlgItemInt(hDlg, IDD_VM_SF_SIZEMAX, iDrive->nMaxFileSize, FALSE);
        }
        else 
		{
            SetDlgItemText(hDlg, IDD_VM_SF_SIZE, _T(""));
            SetDlgItemText(hDlg, IDD_VM_SF_SIZEMAX, _T(""));
        }

	    SetDlgItemMB(hDlg, IDD_VM_ALLOCD, RecomputeAllocated());
        SetFocus(GetDlgItem(hDlg, IDD_VM_VOLUMES));
    }

    return true;
}

//--------------------------------------------------------------
int VirtualMemDlg::UpdateWBEM(void)
{
	int iRet = RET_NO_CHANGE;

	CWbemClassObject inst;
	bstr_t sNameProp(gszName);
	bstr_t sMaxProp(gszMaximumSize);
	bstr_t sInitProp(gszInitialSize);
	HRESULT hr = 0;
	PAGING_FILE *pgVal = NULL;
	HWND lbHWND = GetDlgItem(m_hDlg, IDD_VM_VOLUMES);
	int last = ListBox_GetCount(lbHWND);
    BOOL fNewPFInstance;
#ifdef NTONLY
    BOOL fCreatePFPrivEnabled = FALSE;
    HANDLE hToken = NULL;
#endif // NTONLY

	// zero-based loop.
	for(int x = 0; x < last; x++)
	{
		// get it's state structure.
		pgVal = (PAGING_FILE *)ListBox_GetItemData(lbHWND, x);

        //
        // Should assert objPath != NULL && *pgVal->objPath != 0.
        // Do NOT assume when objPath is non-NULL that objPath
        // is a non-empty string.
        //
        fNewPFInstance = (pgVal->objPath == NULL || !*pgVal->objPath);

        if (!fNewPFInstance)
        {
            //
            // Instance doesn't yet exist, of course, if no object path.
            //
            inst = m_WbemServices.GetObject(pgVal->objPath);
        }
	
        //
        // This condition evaluates pagefile previous/current state.
        // Evaluate to true if:
        //     1. (MINprev != MINcur or MAXprev != MAXcur) - Simple case
        //        where the values changed.
        //     2. (RAMBasedPagefile == TRUE) - Important special case from
        //        custom to RAM-based AND all min/max prev/cur values
        //        coincidentally equal.
        //     3. (MINcur == 0) - Another special case from RAM-based to no
        //        pagefile.  In this case, min/max prev/cur values are all
        //        zero and the RAM-Based pagefile flag is FALSE. 
        //
        if ((pgVal->nMinFileSizePrev != pgVal->nMinFileSize  ||
             pgVal->nMaxFileSizePrev != pgVal->nMaxFileSize) ||
             pgVal->fRamBasedPagefile                        ||
             pgVal->nMinFileSize == 0)
        {
            if (pgVal->nMinFileSize != 0 || pgVal->fRamBasedPagefile)
            {
                //
                // Custom or RAM-based.  Note, the RAM-based pagefile flag
                // check seems redundant but it is important for error cases
                // in the SetSize code.
                //
                // Create the instance if it does not exist.
                //
                BOOL fCreate = FALSE, fModified = FALSE;

                if (inst.IsNull())
                {
			        inst = m_WbemServices.CreateInstance(
                                                    gszPageFileSettings);
                }

                //
                // Now write out changes. Sigh, too close to RC1 to rewrite
                // this existing code.
                //
			    if(!inst.IsNull())
			    {
                    if (fNewPFInstance) // Write name at creation time only.
                    {
                        BOOL fRet = TRUE;
#ifdef NTONLY
                        if (!fCreatePFPrivEnabled)
                        {
                            //
                            // Pagefile creation requires pagefile creation
                            // privilege.
                            //
                            // Aargh! GetPagegFilePrivilege should have a
                            // return code!
                            //
                            GetPageFilePrivilege(hToken);
                            fCreatePFPrivEnabled = TRUE;
                        }
#endif // NTONLY
                        if (fRet)
                        {
				            TCHAR temp[30] = {0};
				            wsprintf(temp, _T("%s\\pagefile.sys"),
                                        pgVal->name);
				            hr = inst.Put(sNameProp, _bstr_t(temp));

                            if (SUCCEEDED(hr))
                            {
                                fModified = TRUE;
                            }
                        }
                    }

                    //
                    // Write zeros for min/max values when the page file
                    // size is to be computed based on RAM size.
                    //
                    if (pgVal->nMinFileSizePrev != pgVal->nMinFileSize)
                    {
				        hr = inst.Put(sInitProp,
                                        (pgVal->fRamBasedPagefile ? 0
                                            : (long)pgVal->nMinFileSize));

                        if (SUCCEEDED(hr))
                        {
                            fModified = TRUE;
                        }
                    }
                    if (pgVal->nMaxFileSizePrev != pgVal->nMaxFileSize)
                    {
				        hr = inst.Put(sMaxProp,
                                        (pgVal->fRamBasedPagefile ? 0
                                            : (long)pgVal->nMaxFileSize));

                        if (SUCCEEDED(hr))
                        {
                            fModified = TRUE;
                        }
                    }
                    if (fModified)
                    {
				        hr = m_WbemServices.PutInstance(
                                                inst,
                                                WBEM_FLAG_CREATE_OR_UPDATE,
                                                EOAC_STATIC_CLOAKING);
                    }
				    if(FAILED(hr))
				    {
					    TCHAR errorHeading[20];
					    TCHAR errorString[1024];
					    TCHAR formatString[1024];
					    ::LoadString(HINST_THISDLL,IDS_ERR_PAGECREATE,  
                                        formatString, 1024);
					    ::LoadString(HINST_THISDLL,IDS_ERR_HEADING,
                                        errorHeading, 20);

					    _stprintf(errorString,formatString,hr);

					    ::MessageBox(m_hDlg,errorString,errorHeading,MB_OK);
				    }
				    else
				    {
                        if (fModified)
                        {
					        iRet = RET_VIRTUAL_CHANGE;
				        }
				    }
			    }
            }
            else
            {
                //
                // No paging file. Delete the instance.
                //
                if (!inst.IsNull() && !fNewPFInstance &&
                        pgVal->objPath != NULL) // 3rd condition insures
                                                // extra safety.
                {
			        hr = m_WbemServices.DeleteInstance(pgVal->objPath);

                    if (SUCCEEDED(hr))
                    {
			            iRet = RET_VIRTUAL_CHANGE;
                    }
                }
            }
        }
	} // endfor

#ifdef NTONLY
    if (fCreatePFPrivEnabled)
    {
        ResetOldPrivilege(hToken);
    }
#endif // NTONLY

	return iRet;
}

//--------------------------------------------------------------
void GetAPrivilege( LPTSTR szPrivilegeName, HANDLE hToken ) 
{
    HANDLE hTmp;
    LUID luid;
    TOKEN_PRIVILEGES tpNew;
    DWORD cb;

    if (LookupPrivilegeValue( NULL, szPrivilegeName, &luid ) &&
         OpenThreadToken(GetCurrentThread(),
                         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
                         TRUE,
                         &hTmp)) 
	{

        tpNew.PrivilegeCount = 1;
        tpNew.Privileges[0].Luid = luid;
        tpNew.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        if (!AdjustTokenPrivileges(hTmp, FALSE, &tpNew, 0, NULL, NULL)) 
		{
            GetLastError();
        }

        hToken = hTmp;
    } 
	else 
	{
        hToken = NULL;
    }
}

//--------------------------------------------------------------
void ResetOldPrivilege( HANDLE hToken ) 
{
    TOKEN_PRIVILEGES tpNew;

    if (hToken != NULL ) 
	{
        AdjustTokenPrivileges(hToken, FALSE, &tpNew, 0, NULL, NULL);

        CloseHandle( hToken );
        hToken = NULL;
    }
}

//--------------------------------------------------------------
int VirtualMemDlg::PromptForReboot(HWND hDlg)
{
    int iReboot = RET_NO_CHANGE;
/*    int i;
    int iThisDrv;
    WCHAR us;
    LARGE_INTEGER liMin, liMax;
    NTSTATUS status;
    WCHAR wszPath[MAX_PATH*2];
    TCHAR szDrive[3] = {0};
    PRIVDAT pdOld;

    GetPageFilePrivilege( &pdOld );

    for (i = 0; i < MAX_DRIVES; i++)
    {
        // Did something change?
        if (apf[i].nMinFileSize != apf[i].nMinFileSizePrev ||
                apf[i].nMaxFileSize != apf[i].nMaxFileSizePrev ||
                apf[i].fCreateFile ) 
		{
             // If we are strictly creating a *new* page file, then
             // we can do it on the fly, otherwise we have to reboot.

            // assume we will have to reboot
            iThisDrv = RET_VIRTUAL_CHANGE;

            // IF we are not deleting a page file
            //          - AND -
            //    The Page file does not exist
            //          - OR -
            //    (This is a New page file AND We are allowed to erase the
            //      old, unused pagefile that exists there now)

            if (apf[i].nMinFileSize != 0 &&
                    ((GetFileAttributes(SZPageFileName(i)) == 0xFFFFFFFF &&
                    GetLastError() == ERROR_FILE_NOT_FOUND) ||
                    (apf[i].nMinFileSizePrev == 0 && MsgBoxParam(hDlg,
                    SYSTEM+25, IDS_TITLE, MB_ICONQUESTION | MB_YESNO,
                    SZPageFileName(i)) == IDYES)) ) 
			{

                DWORD cch;

                // Create the page file on the fly so JVert and MGlass will
                // stop bugging me!
                HourGlass(TRUE);

                // convert path drive letter to an NT device path
                wsprintf(szDrive, TEXT("%c:"), (TCHAR)(i + (int)TEXT('A')));
                cch = QueryDosDevice( szDrive, wszPath, sizeof(wszPath) /
                        sizeof(TCHAR));

                if (cch != 0) 
				{
                    // Concat the filename only (skip 'd:') to the nt device
                    // path, and convert it to a UNICODE_STRING
                    lstrcat( wszPath, SZPageFileName(i) + 2 );
                    RtlInitUnicodeString( &us, wszPath );

                    liMin.QuadPart = (LONGLONG)(apf[i].nMinFileSize * ONE_MEG);
                    liMax.QuadPart = (LONGLONG)(apf[i].nMaxFileSize * ONE_MEG);

                    status = NtCreatePagingFile ( &us, &liMin, &liMax, 0L );

                    if (NT_SUCCESS(status)) {
                        // made it on the fly, no need to reboot for this drive!
                        iThisDrv = RET_CHANGE_NO_REBOOT;
                    }
                }
                HourGlass(FALSE);
            }

            iReboot |= iThisDrv;
        }
    }

    ResetOldPrivilege( &pdOld );

    // If Nothing changed, then change our IDOK to IDCANCEL so System.cpl will
    // know not to reboot.
	*/
    return iReboot;
}

/************************************************************************
 *                                                                      *
 *  Function:       QueryInstanceProperties                             *
 *                                                                      *
 *  Description:    Returns requested object properties associated with *
 *                  the instance matching the key property value/name.  *
 *                                                                      *
 *  Arguments:      pszClass               -- Object class.             *
 *                  pszRequestedProperties -- Space-separated property  *
 *                                            names or *.               *
 *                  pszKeyPropertyName     -- Specific instance key     *
 *                                            property name.            *
 *                  pszKeyPropertyValue    -- Key property value.       *
 *                  Services               -- Wbem services.            *
 * 	                ppcoInstEnum           -- Returned instance.        *
 *                                                                      *
 *  Returns:        HRESULT                                             *
 *                                                                      *
 ***********************************************************************/

#define QUERY_INSTANCEPROPERTY  _T("SELECT %s FROM %s WHERE %s=\"%s\"")

HRESULT QueryInstanceProperties(
    const TCHAR * pszClass,
    const TCHAR * pszRequestedProperties,
    const TCHAR * pszKeyPropertyName,
    const TCHAR * pszKeyPropertyValue,
    CWbemServices &Services,
	IWbemClassObject ** ppcoInst)
{
    TCHAR * pszQuery;
    BSTR    bstrQuery;
    HRESULT hr;

    *ppcoInst = NULL;

    // Dislike multiple allocations of bstr_t.
    //
    pszQuery = new TCHAR[(sizeof(QUERY_INSTANCEPROPERTY) / sizeof(TCHAR)) +
                         lstrlen(pszClass)               +
                         lstrlen(pszRequestedProperties) +
                         lstrlen(pszKeyPropertyName)     +  // No +1 ala
                         lstrlen(pszKeyPropertyValue)];     // sizeof.

    if (pszQuery == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wsprintf(pszQuery, QUERY_INSTANCEPROPERTY, pszRequestedProperties,
                pszClass, pszKeyPropertyName, pszKeyPropertyValue); 

    // Sigh, must create a bstr.
    //
    bstrQuery = SysAllocString(pszQuery);
    delete pszQuery;

    if (bstrQuery == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    IEnumWbemClassObject * pecoInstEnum;
	hr = Services.ExecQuery(bstrQuery, 0, &pecoInstEnum);

    SysFreeString(bstrQuery);

    if (SUCCEEDED(hr))
    {
        DWORD uReturned = 0;
        hr = pecoInstEnum->Next(-1, 1, ppcoInst, &uReturned);
        pecoInstEnum->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\cmprops\state.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Tab state
// 
// 3-11-98 sburns



#ifndef STATE_HPP_INCLUDED
#define STATE_HPP_INCLUDED

#include <chstring.h>
#include "..\common\sshWbemHelpers.h"

// Singleton state of the UI.

#define NET_API_STATUS DWORD
class State
{
public:
   // Init() actually builds the instance
   State();

   // Delete destroys the instance
   ~State();

   void Init(CWbemClassObject &computer, 
				CWbemClassObject &os, 
				CWbemClassObject dns);

   void Refresh();

   bool ChangesNeedSaving() const;

   bool IsMachineDC() const;
   bool IsNetworkingInstalled() const;
   bool IsMemberOfWorkgroup() const;
   void SetIsMemberOfWorkgroup(bool yesNo);

   CHString GetComputerDomainDNSName() const;
   void SetComputerDomainDNSName(const CHString& newName);
   bool ComputerDomainDNSNameWasChanged() const;

   CHString GetFullComputerName() const;
   CHString GetNetBIOSComputerName() const;
   CHString GetShortComputerName() const;

   void SetShortComputerName(const CHString& name);
   bool WasShortComputerNameChanged() const;
   CHString GetOriginalShortComputerName() const;

   CHString GetDomainName() const;
   void SetDomainName(const CHString& name);
   bool WasMembershipChanged() const;

   bool GetSyncDNSNames() const;
   void SetSyncDNSNames(bool yesNo);
   bool SyncDNSNamesWasChanged() const;

   bool SaveChanges(HWND dialog);

   CHString GetUsername() const;
   void SetUsername(const CHString& name);

   CHString GetPassword() const;
   void SetPassword(const CHString& password);

   // indicates that changes have been made in this session.

   bool MustReboot() const;
   void SetMustRebootFlag(bool yesNo);

   // indicates that changes have been made in this or prior sessions.

   bool NeedsReboot() const;

private:
	CWbemClassObject m_computer;
	CWbemClassObject m_OS;
	CWbemClassObject m_DNS;

   // not implemented:  no copying allowed
   State(const State&);
   const State& operator=(const State&);

   bool doSaveDomainChange(HWND dialog);
   bool doSaveWorkgroupChange(HWND dialog);
   bool doSaveNameChange(HWND dialog);

   void setFullComputerName();

   CHString   username;
   CHString   password;
   bool     must_reboot;
};

#endif   // STATE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\declspec.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
//#define TRACKING 

// If we are building a the  DLL then define the 
// class as exported otherwise its imported.
// ============================================
#ifndef COREPOL_HEADERFILE_IS_INCLUDED
#define COREPOL_HEADERFILE_IS_INCLUDED
//#pragma message( "Including DECLSPEC.H..." )

#undef POLARITY

#ifdef SHARE_SOURCE
#define POLARITY
#elif BUILDING_DLL
//#pragma message( "Building static library or DLL..." )
#define POLARITY __declspec( dllexport )
#else 
//#pragma message( "Building Client..." )
#define POLARITY __declspec( dllimport )
#endif

#endif COREPOL_HEADERFILE_IS_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\connectthread.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
#include "ConnectThread.h"
#include <process.h>
#include "..\common\T_DataExtractor.h"
#include <cominit.h>
#include <stdio.h>

//const wchar_t* MMC_SNAPIN_MACHINE_NAME = L"MMC_SNAPIN_MACHINE_NAME";

CLIPFORMAT WbemConnectThread::MACHINE_NAME_1 = 0;

//--------------------------
WbemConnectThread::WbemConnectThread()
{
	m_hr = 0;
	m_status = notStarted;
	MACHINE_NAME_1 = (CLIPFORMAT) RegisterClipboardFormat(_T("MMC_SNAPIN_MACHINE_NAME"));
	m_machineName = L"AGAINWITHTEKLINGONS";
	m_credentials = 0;
	m_doWork = CreateEvent(NULL, FALSE, FALSE, NULL);
	m_threadCmd = false;
	m_hThread = 0;
}

//----------------------------------------------------------------
WbemConnectThread::~WbemConnectThread()
{
	m_hr = 0;
	m_status = notStarted;
	m_notify.RemoveAll();
	if(m_hThread)
	{
		//TODO: If the thread is running we will have to terminate it.
		m_threadCmd = CT_EXIT;
		SetEvent(m_doWork);
		WaitForSingleObject((HANDLE)m_hThread, 5000);
	}

	if(m_doWork)
	{
		CloseHandle(m_doWork);
		m_doWork = 0;
	}

	if (m_credentials)
	{
		WbemFreeAuthIdentity(m_credentials->authIdent);
		m_credentials->authIdent = 0;
	};
}

//----------------------------------------------------------------

typedef struct
{
    wchar_t t[100];
} test;

//TODO: I don't know what this function does. But will try to find out

void WbemConnectThread::MachineName(IDataObject *_pDataObject, bstr_t *name)
{
    HGLOBAL     hMem = GlobalAlloc(GMEM_SHARE,sizeof(test));
    wchar_t     *pRet = NULL;
	HRESULT hr = 0;

    if(hMem != NULL)
    {
        STGMEDIUM stgmedium = { TYMED_HGLOBAL, (HBITMAP) hMem};

        FORMATETC formatetc = { MACHINE_NAME_1,
								NULL,
								DVASPECT_CONTENT,
								-1,
								TYMED_HGLOBAL };

        if((hr = _pDataObject->GetDataHere(&formatetc, &stgmedium)) == S_OK )
        {
            *name = bstr_t((wchar_t *)hMem);
        }

		GlobalFree(hMem);
    }
}

//----------------------------------------------------------
HRESULT WbemConnectThread::EnsureThread(void)
{
	HRESULT retval = S_OK;

	if(m_hThread == 0)
	{
		// let the thread do the connect. The CWbemService class will
		// handle marshalling as its used by other threads.
		if((m_hThread = _beginthread(WbemConnectThreadProc, 0, (LPVOID)this)) == -1)
		{
			m_status = threadError;
			retval = E_FAIL;
		}
	}
	return retval;
}

//----------------------------------------------------------
HRESULT WbemConnectThread::Connect(bstr_t machineName,
								bstr_t ns,
								bool threaded /* = true */,
								LOGIN_CREDENTIALS *credentials /* = NULL */)
{
	m_nameSpace = ns;

	if((m_credentials != credentials) &&
		m_credentials && m_credentials->authIdent)
	{
		WbemFreeAuthIdentity(m_credentials->authIdent);
		m_credentials->authIdent = 0;
	}

	if(machineName.length() > 0)
	{
		m_credentials = credentials;
	}
	else
	{
		m_credentials = 0;
	}

	m_hr = 0;

	if(credentials)
	{
		m_machineName = _T("AGAINWITHTEKLINGONS");  // force a reconnect to
													// the same machine.
	}

	// put the name together.
	bstr_t newMachine;

	// disconnect from the old machine.
	DisconnectServer();
	m_machineName = machineName;
	int x;

	// if machine is whacked already...
	if(_tcsncmp(m_machineName, _T("\\"), 1) == 0)
	{
		// use it.
		m_nameSpace = m_machineName;

		if(((TCHAR*)ns != NULL) && (_tcslen(ns) > 0))
		{
			if(((LPCTSTR)ns)[0] != _T('\\')) // namespace is whacked.
			{
				m_nameSpace += _T("\\");
			}
		}
		m_nameSpace += ns;
	}
	else if(((x = m_machineName.length()) > 0))
	{
		// whack it myself.
		m_nameSpace = "\\\\";
		m_nameSpace += m_machineName;

		if(((LPCTSTR)ns)[0] != _T('\\')) // namespace is whacked.
		{
			m_nameSpace += _T("\\");
		}
		m_nameSpace += ns;
	}
	else
	{
		m_nameSpace = ns;
	}

	EnsureThread();
	m_threadCmd = CT_CONNECT;
	SetEvent(m_doWork);
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

	return E_FAIL;
}

bool WbemConnectThread::Connect(IDataObject *_pDataObject,
								HWND *hWnd /* = 0 */)
{
	m_nameSpace = "root\\cimv2";

	// put the name together.
	bstr_t newMachine;

	MachineName(_pDataObject, &newMachine);

	// if reconnecting to another machine...
	if(newMachine != m_machineName)
	{
		// disconnect from the old machine.
		DisconnectServer();
		m_machineName = newMachine;

		int x;
		// if its whacked already...
		if(_tcsncmp((LPCTSTR)m_machineName, _T("\\"), 1) == 0)
		{
			// use it.
			m_nameSpace = m_machineName;
			m_nameSpace += "\\root\\cimv2";
		}
		else if(((x = m_machineName.length()) > 0))
		{
			// whack it myself.
			m_nameSpace = "\\\\";
			m_nameSpace += m_machineName;
			m_nameSpace += "\\root\\cimv2";
		}

		EnsureThread();
		m_threadCmd = CT_CONNECT;
		NotifyWhenDone(hWnd);
		SetEvent(m_doWork);
		SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);
		return true;			//TODO: check this return value
	}
	else
	{
		// reconnecting to the same machine-- lie!!
		return true;
	}
	return false;
}

//----------------------------------------------------------
// Returns true if a msg will be sent.
// Returns false if its already over.
bool WbemConnectThread::NotifyWhenDone(HWND *dlg)
{
	switch(m_status)
	{
		case notStarted:
		case locating:
		case connecting:
			m_notify.Add(dlg);
			return true;
		case ready:
		case error:
		case cancelled:
			return false;
	}; // endswitch
	return false;
}

//------------------------------------------------
bool WbemConnectThread::isLocalConnection(void)
{
	return (m_machineName.length() == 0);
}

//------------------------------------------------
void WbemConnectThread::Cancel(void)
{
	m_status = cancelled;
	m_hr = WBEM_S_OPERATION_CANCELLED;
	Notify(0);
	m_machineName = L"AGAINWITHTEKLINGONS";
}

//------------------------------------------------
void WbemConnectThread::DisconnectServer(void)
{
	m_status = notStarted;
	m_notify.RemoveAll();
	m_machineName = L"AGAINWITHTEKLINGONS";

	m_WbemServices.DisconnectServer();
}

//------------------------------------------------
void WbemConnectThread::Notify(IStream *stream)
{
	HWND *hwnd;
	for(int i = 0; i < m_notify.GetSize(); i++)
	{
		hwnd = m_notify[i];
		if(hwnd && *hwnd)
		{
			PostMessage(*hwnd,
						WM_ASYNC_CIMOM_CONNECTED,
						0, (LPARAM)stream);
		}
	}
	m_notify.RemoveAll();
}

//-----------------------------------------------------------------
void WbemConnectThread::SendPtr(HWND hwnd)
{
	EnsureThread();
	m_hWndGetPtr = hwnd;
	m_threadCmd = CT_SEND_PTR;
	SetEvent(m_doWork);
}

//-----------------------------------------------------------------
HRESULT WbemConnectThread::ConnectNow()
{
	HRESULT retval = E_FAIL;

	m_status = connecting;

	try
	{
		m_hr = m_WbemServices.ConnectServer(m_nameSpace, m_credentials);
	}
	catch(CWbemException &e)
	{
		m_status = error;
		m_hr = e.GetErrorCode();
	}

	if(SUCCEEDED(m_hr))
	{
		m_status = ready;
		retval = S_OK;
	}
	else
	{
		m_status = error;
	}

	return retval;
}

void __cdecl WbemConnectThreadProc(LPVOID lpParameter)
{
	WbemConnectThread *pThreadObj = (WbemConnectThread *)lpParameter;
	IStream *pStream = 0;
	HRESULT hr = S_OK;
	HRESULT retval = E_FAIL; 
	CWbemServices pServices;

	CoInitialize(NULL);

    MSG msg;

	while(true)
	{
      
		DWORD res = MsgWaitForMultipleObjects (1,&pThreadObj->m_doWork, 
								   FALSE, -1, QS_ALLINPUT);
		if (res == WAIT_OBJECT_0 + 1)
		{
			while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) 
			{
				DispatchMessage(&msg);
			}
			continue;
		}
//		WaitForSingleObject(pThreadObj->m_doWork, -1);

		switch(pThreadObj->m_threadCmd)
		{
			case CT_CONNECT:
			{
				pStream = 0;

				/****************** VINOTH **************************************/
				retval = E_FAIL;
				pThreadObj->m_status = WbemConnectThread::connecting;

				try
				{
					pThreadObj->m_hr = pServices.ConnectServer(pThreadObj->m_nameSpace, pThreadObj->m_credentials);
				}
				catch(CWbemException &e)
				{
					pThreadObj->m_status = WbemConnectThread::error;
					pThreadObj->m_hr = e.GetErrorCode();
				}

				if(SUCCEEDED(pThreadObj->m_hr))
				{
					pThreadObj->m_status = WbemConnectThread::ready;
					retval = S_OK;
				}
				else
				{
					pThreadObj->m_status = WbemConnectThread::error;
				}

				/****************** END *****************************************/
				if(SUCCEEDED(retval))
				{
					IWbemServices *service = 0;
					pServices.GetServices(&service);
					hr = CoMarshalInterThreadInterfaceInStream(IID_IWbemServices,
																service, &pStream);
				}
				// does someone want a msg?
				pThreadObj->Notify(pStream);
				break;
			}
		case CT_SEND_PTR:
			if((bool)pServices)
			{
				IWbemServices *service = 0;
				pServices.GetServices(&service);

				hr = CoMarshalInterThreadInterfaceInStream(IID_IWbemServices,
															service, &pStream);
				PostMessage(pThreadObj->m_hWndGetPtr,
							WM_ASYNC_CIMOM_CONNECTED,
							0, (LPARAM)pStream);
			}
			break;
			case CT_EXIT:
			{
				break;
			}
		}

		if(pThreadObj->m_threadCmd == CT_EXIT)
		{
			pServices = (IWbemServices *)NULL;
			break;
		}
	}
	try
	{
		CoUninitialize();
	}
	catch(...)
	{
//		int x = 1;
	}

	_endthread();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\connectthread.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __CONNECTTHREAD__
#define __CONNECTTHREAD__
#pragma once

#include "SshWbemHelpers.h"
#include "SimpleArray.h"

#define WM_ASYNC_CIMOM_CONNECTED (WM_USER + 20)
#define WM_CIMOM_RECONNECT (WM_USER + 21)

#define CT_CONNECT 0
#define CT_EXIT 1
#define CT_GET_PTR 2
#define CT_SEND_PTR 3

extern const wchar_t* MMC_SNAPIN_MACHINE_NAME;

void __cdecl WbemConnectThreadProc(LPVOID lpParameter);

class WbemConnectThread
{
public:
	friend void __cdecl WbemConnectThreadProc(LPVOID lpParameter);

	WbemConnectThread();
	virtual ~WbemConnectThread();

	// Start the connection attempt.
	HRESULT Connect(bstr_t machineName, 
					bstr_t ns,
					bool threaded = true,
					LOGIN_CREDENTIALS *credentials = NULL);

	bool Connect(IDataObject *_pDataObject, HWND *hWnd = 0);

	// Returns true if a msg will be sent. 
	// Returns false if its already over.
	bool NotifyWhenDone(HWND *dlg);

	void Cancel(void);
	void SendPtr(HWND hwnd);

	void DisconnectServer(void);
	typedef CSimpleArray<HWND *> NOTIFYLIST;

	bool isLocalConnection(void);

	typedef enum {
					notStarted, 
					locating, 
					connecting, 
					threadError, 
					error,
					cancelled, 
					ready
				} ServiceStatus;
	CWbemServices m_WbemServices;
	HRESULT m_hr;
	ServiceStatus m_status;
	bstr_t m_machineName;
	bstr_t m_nameSpace;

private:
	HRESULT ConnectNow();
	void MachineName(IDataObject *_pDataObject, bstr_t *name);
	static CLIPFORMAT MACHINE_NAME_1;
	void Notify(IStream *stream);
	HRESULT EnsureThread(void);

	int m_threadCmd;
	HWND m_hWndGetPtr;
	HANDLE m_doWork;
	NOTIFYLIST m_notify;
	IStream *m_pStream;
	UINT_PTR m_hThread;
	LOGIN_CREDENTIALS *m_credentials;

};

#endif __CONNECTTHREAD__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\precomp.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__7F2AAB5C_A5AD_11D2_886A_00104B2AFB46__INCLUDED_)
#define AFX_STDAFX_H__7F2AAB5C_A5AD_11D2_886A_00104B2AFB46__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#undef STRICT
#define STRICT


#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
};
extern CExeModule _Module;

#include <commdlg.h>
#include <commctrl.h>
#include <atlcom.h>

#define IS_BITSET(x, y) 	((x & y) == y)

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7F2AAB5C_A5AD_11D2_886A_00104B2AFB46__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\servicethread.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __SERVICETHREAD__
#define __SERVICETHREAD__
#pragma once

#include "SshWbemHelpers.h"
#include "SimpleArray.h"

#define WM_ASYNC_CIMOM_CONNECTED (WM_USER + 20)
#define WM_CIMOM_RECONNECT (WM_USER + 21)

extern const wchar_t* MMC_SNAPIN_MACHINE_NAME;


void __cdecl WbemServiceConnectThread(LPVOID lpParameter);

class WbemServiceThread
{
public:
	friend void __cdecl WbemServiceConnectThread(LPVOID lpParameter);

	WbemServiceThread();
	virtual ~WbemServiceThread();

	bstr_t m_machineName;
	bstr_t m_nameSpace;
	HRESULT m_hr;

	typedef enum {notStarted, 
				locating, 
				connecting, 
				threadError, 
				error,
				cancelled, 
				ready} ServiceStatus;

	ServiceStatus m_status;
	
	// Start the connection attempt.
	HRESULT Connect(bstr_t machineName, 
					bstr_t ns,
					bool threaded = true,
					LOGIN_CREDENTIALS *credentials = NULL);

	bool Connect(IDataObject *_pDataObject, HWND *hWnd = 0);

	HRESULT ReConnect(void) 
	{
		DisconnectServer(); 
		return ConnectNow();
	}

	// Returns true if a msg will be sent. 
	// Returns false if its already over.
	bool NotifyWhenDone(HWND *dlg);

	void Cancel(void);
	void DisconnectServer(void);
	typedef CSimpleArray<HWND *> NOTIFYLIST;

	NOTIFYLIST m_notify;

	bool LocalConnection(void);
	void SendPtr(HWND hwnd);
	CWbemServices GetPtr(void);

	CWbemServices m_WbemServices;

	CWbemServices m_realServices;  // lives on the connection thread.
									// DONT had this out directly. Use
									// the Notify().

private:
	HRESULT ConnectNow(bool real = false);
	void MachineName(IDataObject *_pDataObject, bstr_t *name);
	static CLIPFORMAT MACHINE_NAME;

	HANDLE m_doWork, m_ptrReady;
#define CT_CONNECT 0
#define CT_EXIT 1
#define CT_GET_PTR 2
#define CT_SEND_PTR 3

	int m_threadCmd;
	UINT_PTR m_hThread;
	void Notify(IStream *stream);
	HRESULT EnsureThread(void);
	HWND m_hWndGetPtr;
	IStream *m_pStream;

	LOGIN_CREDENTIALS *m_credentials;
};

#endif __SERVICETHREAD__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\pagehelper.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __PAGEHELPER__
#define __PAGEHELPER__

#pragma once

#include "..\common\SshWbemHelpers.h"
#include "..\common\ConnectThread.h"

#define SCB_FROMFILE     (0x1)
#define SCB_REPLACEONLY  (0x2)
#define CLOSE_SNAPIN	0xfdfd

#define WBEM_ENABLE             ( 0x0001 )   
#define WBEM_METHOD_EXECUTE     ( 0x0002 )   
#define WBEM_FULL_WRITE_REP     ( 0x001c )   
#define WBEM_PARTIAL_WRITE_REP  ( 0x0008 )   
#define WBEM_WRITE_PROVIDER     ( 0x0010 )   

class PageHelper
{
public:
	IWbemServices *m_service;
	CWbemServices m_WbemServices;
	bool m_okPressed;
	HWND m_hDlg;
	bool m_userCancelled; // the connectServer() thread.
	HWND m_AVIbox;

	PageHelper(CWbemServices &service);
	PageHelper(WbemConnectThread *connectThread);

	virtual ~PageHelper();

	CWbemClassObject ExchangeInstance(IWbemClassObject **ppbadInst);

	virtual bool GetOnOkPressed(void) {return m_okPressed;};

	// get the first instance of the named class.
	IWbemClassObject *FirstInstanceOf(bstr_t className);

	static LPTSTR CloneString( LPTSTR pszSrc );

	BOOL SetClearBitmap(HWND control, 
						LPCTSTR resource, 
						UINT fl);

	void HourGlass( bool bOn );

	int MsgBoxParam(HWND hWnd, 
					DWORD wText, 
					DWORD wCaption, 
					DWORD wType,
					LPTSTR var1 = NULL,
					LPTSTR var2 = NULL);

	DWORD SetLBWidthEx(HWND hwndLB, 
						LPTSTR szBuffer, 
						DWORD cxCurWidth, 
						DWORD cxExtra);

	void SetDefButton(HWND hwndDlg, 
						int idButton);

	void SetDlgItemMB(HWND hDlg, 
						int idControl, 
						ULONG dwMBValue );

	void SetWbemService(IWbemServices *pServices);

#define NO_UI 0  // for uCaption
	bool ServiceIsReady(UINT uCaption, 
						UINT uWaitMsg,
						UINT uBadMsg);

	HRESULT Reboot(UINT flags = EWX_REBOOT,
				   long *retval = NULL);

	
	HRESULT RemoteRegWriteable(const _bstr_t regPath,
								BOOL& writable);

	bool HasPerm(DWORD mask);
	bool HasPriv(LPCTSTR privName);

	static BOOL g_fRebootRequired;
	WbemConnectThread *m_pgConnectThread;

private:
	// these support efficiency in RemoteRegWriteable().
	CWbemClassObject m_checkAccessIn;
	CWbemClassObject m_checkAccessOut;
	CWbemServices m_defaultNS;
};

#endif __PAGEHELPER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\servicethread.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
#include "ServiceThread.h"
#include <process.h>
#include "..\common\T_DataExtractor.h"
#include <cominit.h>

const wchar_t* MMC_SNAPIN_MACHINE_NAME = L"MMC_SNAPIN_MACHINE_NAME";

CLIPFORMAT WbemServiceThread::MACHINE_NAME = 0;

//--------------------------
WbemServiceThread::WbemServiceThread()
{
	m_hr = 0;
	m_status = notStarted;
	m_machineName = L"AGAINWITHTEKLINGONS";
	MACHINE_NAME = (CLIPFORMAT) RegisterClipboardFormat(_T("MMC_SNAPIN_MACHINE_NAME"));
	m_credentials = 0;
	m_doWork = CreateEvent(NULL, FALSE, FALSE, NULL);
	m_ptrReady = CreateEvent(NULL, FALSE, FALSE, NULL);
	m_threadCmd = false;
	m_hThread = 0;
}

//----------------------------------------------------------------
WbemServiceThread::~WbemServiceThread()
{
	m_hr = 0;
	m_status = notStarted;
	m_notify.RemoveAll();
	if(m_hThread)
	{
		m_threadCmd = CT_EXIT;
		SetEvent(m_doWork);
		WaitForSingleObject((HANDLE)m_hThread, 5000);
	}

	if(m_doWork)
	{
		CloseHandle(m_doWork);
		m_doWork = 0;
	}
	if(m_ptrReady)
	{
		CloseHandle(m_ptrReady);
		m_ptrReady = 0;
	}

	if (m_credentials)
	{
		WbemFreeAuthIdentity(m_credentials->authIdent);
		m_credentials->authIdent = 0;
	};

}

//----------------------------------------------------------------
typedef struct
{
    wchar_t t[100];
} test;

void WbemServiceThread::MachineName(IDataObject *_pDataObject, bstr_t *name)
{
    HGLOBAL     hMem = GlobalAlloc(GMEM_SHARE,sizeof(test));
    wchar_t     *pRet = NULL;
	HRESULT hr = 0;

    if(hMem != NULL)
    {
        STGMEDIUM stgmedium = { TYMED_HGLOBAL, (HBITMAP) hMem};

        FORMATETC formatetc = { MACHINE_NAME,
								NULL,
								DVASPECT_CONTENT,
								-1,
								TYMED_HGLOBAL };

        if((hr = _pDataObject->GetDataHere(&formatetc, &stgmedium)) == S_OK )
        {
            *name = bstr_t((wchar_t *)hMem);
        }

		GlobalFree(hMem);
    }
}

//----------------------------------------------------------
HRESULT WbemServiceThread::EnsureThread(void)
{
	HRESULT retval = S_OK;

	if(m_hThread == 0)
	{
		// let the thread do the connect. The CWbemService class will
		// handle marshalling as its used by other threads.
		if((m_hThread = _beginthread(WbemServiceConnectThread, 0,
									(LPVOID)this)) == -1)
		{
			m_status = threadError;
			retval = E_FAIL;
		}
	}
	return retval;
}

//----------------------------------------------------------
HRESULT WbemServiceThread::Connect(bstr_t machineName,
								bstr_t ns,
								bool threaded /* = true */,
								LOGIN_CREDENTIALS *credentials /* = NULL */)
{
	if(ns.length() == 0)
	{
		ns = _T(""); //this allocates...
		if (&ns == NULL)
			return E_FAIL;
	}

	m_nameSpace = ns;

	if((m_credentials != credentials) &&
		m_credentials && m_credentials->authIdent)
	{
		WbemFreeAuthIdentity(m_credentials->authIdent);
		m_credentials->authIdent = 0;
	}

	if(machineName.length() > 0)
	{
		m_credentials = credentials;
	}
	else
	{
		m_credentials = 0;
		m_WbemServices.m_authIdent = 0;
		m_realServices.m_authIdent = 0;
	}
	m_hr = 0;
	if(credentials)
	{
		m_machineName = _T("AGAINWITHTEKLINGONS");  // force a reconnect to
													// the same machine.
	}

	// put the name together.
	bstr_t newMachine;

	// if reconnecting to another machine...
	//if(machineName != m_machineName)
	{
		// disconnect from the old machine.
		DisconnectServer();
		m_machineName = machineName;
		int x;

		// if machine is whacked already...
		if(_tcsncmp(m_machineName, _T("\\"), 1) == 0)
		{
			// use it.
			m_nameSpace = m_machineName;

			if(ns.length() > 0)
			{
				if(((LPCTSTR)ns)[0] != _T('\\')) // namespace is whacked.
				{
					m_nameSpace += _T("\\");
				}
			}
			m_nameSpace += ns;
		}
		else if(((x = m_machineName.length()) > 0))
		{
			// whack it myself.
			m_nameSpace = "\\\\";
			m_nameSpace += m_machineName;

			if(((LPCTSTR)ns)[0] != _T('\\')) // namespace is whacked.
			{
				m_nameSpace += _T("\\");
			}
			m_nameSpace += ns;
		}

		EnsureThread();
		m_threadCmd = CT_CONNECT;
		SetEvent(m_doWork);
		SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

	}
//	else
//	{
//		// reconnecting to the same machine-- lie!!
//		return WBEM_S_SAME;
//	}
	return E_FAIL;
}

//----------------------------------------------------------
// TODO: merge the Connects()
bool WbemServiceThread::Connect(IDataObject *_pDataObject,
								HWND *hWnd /* = 0 */)
{
	m_nameSpace = "root\\cimv2";

	// put the name together.
	bstr_t newMachine;

	MachineName(_pDataObject, &newMachine);

	// if reconnecting to another machine...
	if(newMachine != m_machineName)
	{
		// disconnect from the old machine.
		DisconnectServer();
		m_machineName = newMachine;

		int x;
		// if its whacked already...
		if(_tcsncmp((LPCTSTR)m_machineName, _T("\\"), 1) == 0)
		{
			// use it.
			m_nameSpace = m_machineName;
			m_nameSpace += "\\root\\cimv2";
		}
		else if(((x = m_machineName.length()) > 0))
		{
			// whack it myself.
			m_nameSpace = "\\\\";
			m_nameSpace += m_machineName;
			m_nameSpace += "\\root\\cimv2";
		}

		EnsureThread();
		NotifyWhenDone(hWnd);
		m_threadCmd = CT_CONNECT;
		SetEvent(m_doWork);
		SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);
	}
	else
	{
		// reconnecting to the same machine-- lie!!
		return true;
	}
	return false;
}

//----------------------------------------------------------
// Returns true if a msg will be sent.
// Returns false if its already over.
bool WbemServiceThread::NotifyWhenDone(HWND *dlg)
{
	switch(m_status)
	{
	case notStarted:
	case locating:
	case connecting:
		m_notify.Add(dlg);
		return true;

	case error:
	case ready:
	case cancelled:
		return false;

	}; // endswitch
	return false;
}

//------------------------------------------------
bool WbemServiceThread::LocalConnection(void)
{
	return (m_machineName.length() == 0);
}

//------------------------------------------------
void WbemServiceThread::Cancel(void)
{
	m_status = cancelled;
	m_hr = WBEM_S_OPERATION_CANCELLED;
	Notify(0);
	m_machineName = L"AGAINWITHTEKLINGONS";
}

//------------------------------------------------
void WbemServiceThread::DisconnectServer(void)
{
	m_status = notStarted;
	m_notify.RemoveAll();
	m_machineName = L"AGAINWITHTEKLINGONS";
	m_WbemServices.DisconnectServer();
}

//------------------------------------------------
void WbemServiceThread::Notify(IStream *stream)
{
	HWND *hwnd;
	for(int i = 0; i < m_notify.GetSize(); i++)
	{
		hwnd = m_notify[i];

		if(hwnd && *hwnd)
		{
			PostMessage(*hwnd,
						WM_ASYNC_CIMOM_CONNECTED,
						0, (LPARAM)stream);
		}
	}
	m_notify.RemoveAll();
}

//-----------------------------------------------------------------
HRESULT WbemServiceThread::ConnectNow(bool real)
{
	HRESULT retval = E_FAIL;

	m_status = connecting;
    ATLTRACE(_T("ConnectServer() starting\n"));

	try
	{
		if(real)
		{
			m_hr = m_realServices.ConnectServer(m_nameSpace, m_credentials);
		}
		else
		{
			m_hr = m_WbemServices.ConnectServer(m_nameSpace, m_credentials);
		}
	}
	catch(CWbemException &e)
	{
		m_status = error;
		m_hr = e.GetErrorCode();
	}

	if(SUCCEEDED(m_hr))
	{
		if(m_status == cancelled)
		{
		}
		else
		{
			m_status = ready;
			retval = S_OK;
		}
        ATLTRACE(_T("ConnectServer() done\n"));
	}
	else
	{
		m_status = error;
        ATLTRACE(_T("ConnectServer() failed\n"));
	}

	return retval;
}

//-----------------------------------------------------------------
void WbemServiceThread::SendPtr(HWND hwnd)
{
	EnsureThread();
	m_hWndGetPtr = hwnd;
	m_threadCmd = CT_SEND_PTR;
	SetEvent(m_doWork);
}

//-----------------------------------------------------------------
CWbemServices WbemServiceThread::GetPtr(void)
{
	CWbemServices serv;
	EnsureThread();
	m_threadCmd = CT_GET_PTR;
	SetEvent(m_doWork);
	WaitForSingleObject(m_ptrReady, 10000);

	IWbemServices *pServices = 0;
	HRESULT hr = CoGetInterfaceAndReleaseStream(m_pStream,
										IID_IWbemServices,
										(void**)&pServices);
	if(SUCCEEDED(hr))
	{
		serv = pServices;
	}
	return serv;
}

//-----------------------------------------------------
void __cdecl WbemServiceConnectThread(LPVOID lpParameter)
{
	WbemServiceThread *me = (WbemServiceThread *)lpParameter;
	IStream *pStream = 0;
	HRESULT hr = S_OK;
	HRESULT retval = E_FAIL;
	CWbemServices pServices;

	CoInitialize(NULL);

    MSG msg;

	while(true)
	{
      
		DWORD res = MsgWaitForMultipleObjects (1,&me->m_doWork, 
								   FALSE, -1, QS_ALLINPUT);
		if (res == WAIT_OBJECT_0 + 1)
		{
			while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) 
			{
				DispatchMessage(&msg);
			}
			continue;
		}

		switch(me->m_threadCmd)
		{
		case CT_CONNECT:
			pStream = 0;
			/****************** VINOTH *****************************/

			me->m_status = WbemServiceThread::connecting;
			try
			{
				me->m_hr = pServices.ConnectServer(me->m_nameSpace, me->m_credentials);
			}
			catch(CWbemException &e)
			{
				me->m_status = WbemServiceThread::error;
				me->m_hr = e.GetErrorCode();
			}

			if(SUCCEEDED(me->m_hr))
			{
				if(me->m_status == WbemServiceThread::cancelled)
				{
				}
				else
				{
					me->m_status = WbemServiceThread::ready;
					retval = S_OK;
				}
			}
			else
			{
				me->m_status = WbemServiceThread::error;
			}


	/*************** END VINOTH ************************/
			if(SUCCEEDED(retval))
			{
				IWbemServices *service = 0;
				pServices.GetServices(&service);
				hr = CoMarshalInterThreadInterfaceInStream(IID_IWbemServices,
															service, &pStream);
			}
			// does someone want a msg?
			me->Notify(pStream);
			break;

		case CT_GET_PTR:
		case CT_SEND_PTR:
			if((bool)pServices)
			{
				IWbemServices *service = 0;
				pServices.GetServices(&service);

				if(me->m_threadCmd == CT_SEND_PTR)
				{
					hr = CoMarshalInterThreadInterfaceInStream(IID_IWbemServices,
																service, &pStream);
					PostMessage(me->m_hWndGetPtr,
								WM_ASYNC_CIMOM_CONNECTED,
								0, (LPARAM)pStream);
				}
				else if(me->m_threadCmd == CT_GET_PTR)
				{
					hr = CoMarshalInterThreadInterfaceInStream(IID_IWbemServices,
																service, &(me->m_pStream));
					SetEvent(me->m_ptrReady);
				}
			}
			break;

		case CT_EXIT:
			pServices = (IWbemServices *)NULL;
			break;

		} //endswitch

	} //endwhile

	try
	{
		CoUninitialize();
	}
	catch(...)
	{
		int x = 1;
	}

	_endthread();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\pagehelper.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "..\MMFUtil\MsgDlg.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "util.h"
//#include "ConnectThread.h"
#include "PageHelper.h"
#include <stdarg.h>


BOOL PageHelper::g_fRebootRequired = FALSE;

//------------------------------------------------
PageHelper::PageHelper(CWbemServices &service)

{
	m_service = 0;
	m_WbemServices = service;
	m_WbemServices.GetServices(&m_service);
	m_WbemServices.SetBlanket(m_service);

	m_okPressed = false;
	m_userCancelled = false;
	m_hDlg = NULL;
	m_AVIbox = 0;
}

//------------------------------------------------
PageHelper::PageHelper(WbemConnectThread *connectThread)

{
	m_pgConnectThread = connectThread;
	m_service = 0;

	if(m_pgConnectThread->m_status == WbemConnectThread::ready)
	{
		m_WbemServices = m_pgConnectThread->m_WbemServices;

/*		m_WbemServices = m_pgConnectThread->m_WbemServices;
		m_WbemServices.GetServices(&m_service);
		m_WbemServices.SetBlanket(m_service);
*/	}

	m_okPressed = false;
	m_userCancelled = false;
	m_hDlg = NULL;
	m_AVIbox = 0;
}

//------------------------------------------------
PageHelper::~PageHelper()
{
	// in case ServiceThread still has a ptr to this
	//   handle. It knows not to use NULL HWNDs.
	m_AVIbox = 0;
	m_hDlg = NULL;
	if(m_service)
	{
		m_service->Release();
		m_service = 0;
	}
	m_WbemServices.DisconnectServer();
}

//------------------------------------------------
CWbemClassObject PageHelper::ExchangeInstance(IWbemClassObject **ppbadInst)
{
	CWbemClassObject inst;
	_variant_t v1;

	if(SUCCEEDED((*ppbadInst)->Get(bstr_t("__PATH"), 0, &v1, NULL, NULL)))
	{
		inst = m_WbemServices.GetObject((_bstr_t) v1);
		(*ppbadInst)->Release();
		*ppbadInst = NULL;
	}
	return inst;
}
//------------------------------------------------
// get the first instance of the named class.
IWbemClassObject *PageHelper::FirstInstanceOf(bstr_t className)
{
	IWbemClassObject *pInst = NULL;
	ULONG uReturned;
	IEnumWbemClassObject *Enum = NULL;

	// get the class.
	if(SUCCEEDED(m_WbemServices.CreateInstanceEnum(className,
													WBEM_FLAG_SHALLOW,
													&Enum)))
	{
		// get the first and only instance.
		Enum->Next(-1, 1, &pInst, &uReturned);
		Enum->Release();
	}
	return pInst;
}

//---------------------------------------------------
LPTSTR PageHelper::CloneString( LPTSTR pszSrc )
{
    LPTSTR pszDst = NULL;

    if (pszSrc != NULL)
	{
        pszDst = new TCHAR[(lstrlen(pszSrc) + 1)];
        if (pszDst)
		{
            lstrcpy( pszDst, pszSrc );
        }
    }

    return pszDst;
}
//*************************************************************
//
//  SetClearBitmap()
//
//  Purpose:    Sets or clears an image in a static control.
//
//  Parameters: control  -   handle of static control
//              resource -   resource / filename of bitmap
//              fl       -   SCB_ flags:
//                SCB_FROMFILE      'resource' specifies a filename instead of a resource
//                SCB_REPLACEONLY   only put the new image up if there was an old one
//
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/24/95     ericflo    Ported
//
//*************************************************************

BOOL PageHelper::SetClearBitmap( HWND control,
									 LPCTSTR resource,
									 UINT fl )
{
    HBITMAP hbm = (HBITMAP)SendMessage(control, STM_GETIMAGE, IMAGE_BITMAP, 0);

    if( hbm )
    {
        DeleteObject( hbm );
    }
    else if( fl & SCB_REPLACEONLY )
    {
        return FALSE;
    }

    if( resource )
    {
        SendMessage(control, STM_SETIMAGE, IMAGE_BITMAP,
					(LPARAM)LoadImage(	HINST_THISDLL,
										resource,
										IMAGE_BITMAP,
										0, 0,
										LR_LOADTRANSPARENT | LR_LOADMAP3DCOLORS |
										( ( fl & SCB_FROMFILE )? LR_LOADFROMFILE : 0 ) )
					);
    }

    return
        ((HBITMAP)SendMessage(control, STM_GETIMAGE, IMAGE_BITMAP, 0) != NULL);
}

//------------------------------------------------------------
int PageHelper::MsgBoxParam(HWND hWnd,
								DWORD wText,
								DWORD wCaption,
								DWORD wType,
								LPTSTR var1,
								LPTSTR var2)
{
    TCHAR   szText[ 4 * MAX_PATH ] = {0}, szCaption[ 2 * MAX_PATH ] = {0};
    int     ival;

    if( !LoadString( HINST_THISDLL, wText, szCaption, ARRAYSIZE( szCaption ) ) )
	{
        return 0;
	}
	if(var2)
		wsprintf(szText, szCaption, var1, var2);
	else if(var1)
		wsprintf(szText, szCaption, var1);
	else
		wcscpy(szText, szCaption);

    if( !LoadString( HINST_THISDLL, wCaption, szCaption, ARRAYSIZE( szCaption ) ) )
	{
        return 0;
	}

    ival = MessageBox( hWnd, szText, szCaption, wType);

    return ival;
}

//------------------------------------------------------------
void PageHelper::HourGlass( bool bOn )
{
    if( !GetSystemMetrics( SM_MOUSEPRESENT ) )
        ShowCursor( bOn );

    SetCursor( LoadCursor( NULL, bOn ? IDC_WAIT : IDC_ARROW ) );
}

////////////////////////////////////////////////////////////////////////////
//  SetLBWidthEx
//
//  Set the width of the listbox, in pixels, acording to the size of the
//  string passed in.
//
//  Note: this function is also used by the Virtual Memory dialog
//
//  History:
//  11-Jan-1996 JonPa   Created from SetGenLBWidth
////////////////////////////////////////////////////////////////////////////

DWORD PageHelper::SetLBWidthEx( HWND hwndLB,
									LPTSTR szBuffer,
									DWORD cxCurWidth,
									DWORD cxExtra)
{
    HDC     hDC;
    SIZE    Size;
    HFONT   hfont, hfontOld;

    // Get the new Win4.0 thin dialog font
    hfont = (HFONT)SendMessage(hwndLB, WM_GETFONT, 0, 0);

    hDC = GetDC(hwndLB);

    // if we got a font back, select it in this clean hDC
    if (hfont != NULL)
        hfontOld = (HFONT)SelectObject(hDC, hfont);


    // If cxExtra is 0, then give our selves a little breathing space.
    if (cxExtra == 0)
	{
        GetTextExtentPoint(hDC, TEXT("1234"), 4 , &Size);
        cxExtra = Size.cx;
    }

    // Set scroll width of listbox
    GetTextExtentPoint(hDC, szBuffer, lstrlen(szBuffer), &Size);

    Size.cx += cxExtra;

    // Get the name length and adjust the longest name
    if ((DWORD) Size.cx > cxCurWidth)
    {
        cxCurWidth = Size.cx;
        SendMessage (hwndLB, LB_SETHORIZONTALEXTENT, (DWORD)Size.cx, 0L);
    }

    // retstore the original font if we changed it.
    if (hfont != NULL)
        SelectObject(hDC, hfontOld);

    ReleaseDC(NULL, hDC);

    return cxCurWidth;

	return 1; // bs
}
//---------------------------------------------------
void PageHelper::SetDefButton(HWND hwndDlg,
								  int idButton)
{
    LRESULT lr;

    if(HIWORD(lr = SendMessage(hwndDlg, DM_GETDEFID, 0, 0)) == DC_HASDEFID)
    {
        HWND hwndOldDefButton = GetDlgItem(hwndDlg, LOWORD(lr));

        SendMessage (hwndOldDefButton,
                     BM_SETSTYLE,
                     MAKEWPARAM(BS_PUSHBUTTON, 0),
                     MAKELPARAM(TRUE, 0));
    }

    SendMessage( hwndDlg, DM_SETDEFID, idButton, 0L );
    SendMessage( GetDlgItem(hwndDlg, idButton),
                 BM_SETSTYLE,
                 MAKEWPARAM( BS_DEFPUSHBUTTON, 0 ),
                 MAKELPARAM( TRUE, 0 ));
}

//-------------------------------------------------------------------
void PageHelper::SetDlgItemMB( HWND hDlg,
								  int idControl,
								  ULONG dwMBValue )
{
    TCHAR szBuf[20] = {0};
    wsprintf(szBuf, _T("%u MB"), dwMBValue);
    SetDlgItemText(hDlg, idControl, szBuf);
}

//--------------------------------------------------------------
void PageHelper::SetWbemService(IWbemServices *pServices)
{
/*	m_WbemServices = m_pgConnectThread->m_WbemServices;
	m_WbemServices.GetServices(&m_service);
	m_WbemServices.SetBlanket(m_service);
*/
	m_pgConnectThread->m_WbemServices = pServices;
	m_WbemServices = pServices;
/*
	if(m_pgConnectThread)
	{
		m_pgConnectThread->m_WbemServices = pServices;
	}
*/
}

//--------------------------------------------------------------
bool PageHelper::ServiceIsReady(UINT uCaption /* = 0*/,
									UINT uWaitMsg,
									UINT uBadMsg)
{
	switch(m_pgConnectThread->m_status)
	{
		// its already there.
		case WbemConnectThread::ready:
		{
			return true;
		}
		break;

		// its coming.
		case WbemConnectThread::notStarted:
		case WbemConnectThread::locating:
		case WbemConnectThread::connecting:
		{
			// let me know when its there.
			m_pgConnectThread->NotifyWhenDone(&m_hDlg);

			// also kill the cancel box at that time.
			m_AVIbox = 0;
			m_pgConnectThread->NotifyWhenDone(&m_AVIbox);

			if(uCaption != NO_UI)
			{
				TCHAR caption[100] = {0}, msg[256] = {0};

				::LoadString(HINST_THISDLL, uCaption,
								caption, 100);

				::LoadString(HINST_THISDLL, uWaitMsg,
								msg, 256);

				m_userCancelled = false;

				if(DisplayAVIBox(m_hDlg, caption, msg, &m_AVIbox) == IDCANCEL)
				{
					m_pgConnectThread->Cancel();
					m_userCancelled = true;
					return false;
				}
			}
			break;
		}
		case WbemConnectThread::error:			// cant connect.
		case WbemConnectThread::threadError:	// cant start that thread.
		default:
		{
			if(::IsWindow(m_AVIbox))
			{
				PostMessage(m_AVIbox,
							WM_ASYNC_CIMOM_CONNECTED,
							0, 0);
				m_AVIbox = 0;
			}

			if(uCaption != NO_UI)
			{
				DisplayUserMessage(m_hDlg, HINST_THISDLL,
									uCaption, BASED_ON_SRC,
									ConnectServer,
									m_pgConnectThread->m_hr,
									MB_ICONSTOP);
			}
			return false;
		}
	}; //endswitch
	return true;
}

//----------------------------------------------------
HRESULT PageHelper::Reboot(UINT flags,
							   long *retval)
{
	HRESULT hr = WBEM_E_PROVIDER_NOT_FOUND;
	bstr_t path;
	CWbemClassObject paramCls;

	// need to class def to get the method signature.
	paramCls = m_WbemServices.GetObject("Win32_OperatingSystem");

	if(paramCls)
	{
		// get the method signature. dummy wont actually be used.
		CWbemClassObject dummy, inSig;

		hr = paramCls.GetMethod(L"Win32Shutdown",
									inSig, dummy);

		// if got a good signature....
		if((bool)inSig)
		{
			// find the OperatingSystem for the current service ptr.
			IWbemClassObject *pInst = NULL;
			pInst = FirstInstanceOf("Win32_OperatingSystem");
			if(pInst)
			{
				// wrap it for convenience.
				CWbemClassObject OS(pInst);
				path = OS.GetString(_T("__PATH"));

				// fill in the values.
				inSig.Put(_T("Flags"), (const long)flags);
				inSig.Put(_T("Reserved"), (long)0);

				// adjust privilege.
				m_WbemServices.SetPriv(SE_SHUTDOWN_NAME);

				// now call the method.
				hr = m_WbemServices.ExecMethod(path, L"Win32Shutdown",
												inSig, dummy);

				m_WbemServices.ClearPriv();

				// did the caller want the ReturnValue.
				if(SUCCEEDED(hr) && (bool)dummy && retval)
				{
					// NOTE: this guy return STATUS codes.
					*retval = dummy.GetLong(_T("ReturnValue"));
				}
			}
		}
	} //endif paramCls
	return hr;
}

//---------------------------------------------------------------
bool PageHelper::HasPriv(LPCTSTR privName)
{
    ImpersonateSelf(SecurityImpersonation);
	HANDLE hAccessToken = 0;
	bool retval = false;

	if(OpenThreadToken(GetCurrentThread(),
						TOKEN_QUERY,
						FALSE, &hAccessToken))
	{
		DWORD dwLen;
		TOKEN_PRIVILEGES bogus;

		// guaranteed to fail. Just figuring the size.
		GetTokenInformation(hAccessToken, TokenPrivileges,
								&bogus, 1, &dwLen);

	    BYTE* pBuffer = new BYTE[dwLen];
		if(pBuffer != NULL)
		{
			if(GetTokenInformation(hAccessToken, TokenPrivileges,
									pBuffer, dwLen, &dwLen))
			{
				TOKEN_PRIVILEGES* pPrivs = (TOKEN_PRIVILEGES*)pBuffer;
				LUID luidTgt;
				LookupPrivilegeValue(NULL, privName, &luidTgt);

				for(DWORD i = 0; i < pPrivs->PrivilegeCount; i++)
				{
					if((pPrivs->Privileges[i].Luid.LowPart == luidTgt.LowPart) &&
						(pPrivs->Privileges[i].Luid.HighPart == luidTgt.HighPart))
					{
						retval = true;
						break;
					}
				}
			}
			delete [] pBuffer;
		}
		CloseHandle(hAccessToken);
	}
	else
	{
		DWORD err = GetLastError();
	}
	return retval;
}

//---------------------------------------------------------------
bool PageHelper::HasPerm(DWORD mask)
{
	// call the method..
	CWbemClassObject _in;
	CWbemClassObject _out;
	bool retval = true;
	// NOTE: for backwards compability with wmi builds that didn't have this
	// method, assume 'true' unless a newer build says you cant do this.

	HRESULT hr = m_WbemServices.GetMethodSignatures("__SystemSecurity",
													"GetCallerAccessRights",
													_in, _out);

	if(SUCCEEDED(hr))
	{
		hr = m_WbemServices.ExecMethod("__SystemSecurity",
										"GetCallerAccessRights",
										_in, _out);

		if(SUCCEEDED(hr) && (bool)_out)
		{
			hr = HRESULT_FROM_NT(_out.GetLong("ReturnValue"));
			if(SUCCEEDED(hr))
			{
				DWORD grantedMask = 0;
				grantedMask = (DWORD)_out.GetLong("Rights");

				retval = (bool)((mask & (DWORD)grantedMask) != 0);
			}
		}
	}
	return retval;
}

//--------------------------------------------------------------
HRESULT PageHelper::RemoteRegWriteable(const _bstr_t regPath,
											BOOL& writable)
{
	HRESULT hr = E_FAIL;

	// if not even connected yet...
	if(!(bool)m_defaultNS)
	{
		bstr_t defaultName;

		// already whacked...
		if(wcsncmp((wchar_t *)m_pgConnectThread->m_machineName, _T("\\"), 1) == 0)
		{
			// use it.
			defaultName = m_pgConnectThread->m_machineName;
			defaultName += "\\root\\default";
		}
		else if(m_pgConnectThread->m_machineName.length() > 0) // not whacked but remote...
		{
			// whack it myself.
			defaultName = "\\\\";
			defaultName += m_pgConnectThread->m_machineName;
			defaultName += "\\root\\default";
		}
		else  // must be local
		{
			defaultName = "root\\default";
		}

		m_defaultNS.ConnectServer(defaultName);

	}

	// do we need the signatures?
	if((bool)m_defaultNS && !(bool)m_checkAccessIn)
	{
		hr = m_defaultNS.GetMethodSignatures("StdRegProv", "CheckAccess",
												m_checkAccessIn,
												m_checkAccessOut);
	}
	// got connection and signatures already?
	if((bool)m_defaultNS && (bool)m_checkAccessIn)
	{
		// fill in the parms.
		m_checkAccessIn.Put("sSubKeyName", regPath);
		m_checkAccessIn.Put("uRequired", KEY_WRITE);

		// call.
        hr = m_defaultNS.ExecMethod("StdRegProv", "CheckAccess",
										m_checkAccessIn,
										m_checkAccessOut);

		// ExecMethod() itself worked.
		if(SUCCEEDED(hr))
		{
			// did CheckAccess() work.
			HRESULT hr1 = HRESULT_FROM_NT(m_checkAccessOut.GetLong("ReturnValue"));
			if(FAILED(hr1))
			{
				hr = hr1;
			}
			else
			{
				writable = m_checkAccessOut.GetBool("bGranted");
			}
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\sources.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

WMIMFC=1
WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=Common
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=$(INCLUDES); \
	$(STDLIBRARY_INC)

SOURCES= \
	ServiceThread.cpp \
	ConnectThread.cpp \
	sshWbemHelpers.cpp \
	CHString1.cpp

# Next, specify options for the compiler using C_DEFINES. 
C_DEFINES=$(C_DEFINES) /DBUILDING_DLL /DSHARE_SOURCE
WIN32_WINNT_VERSION=0x0501
USE_NATIVE_EH=ASYNC
USE_RTTI=1
USE_MSVCRT=1
USE_ATL=1
ATL_VER=30
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\simplearray.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#if (_ATL_VER < 0x0300)
/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CSimpleArray & CSimpleMap

#ifndef __SIMPLEARRAY__
#define __SIMPLEARRAY__

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

template <class T>
class CSimpleArray
{
public:
	T* m_aT;
	int m_nSize;
	int m_nAllocSize;

// Construction/destruction
	CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
	{ }

	~CSimpleArray()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(T& t)
	{
		if(m_nSize == m_nAllocSize)
		{
			T* aT;
			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
			aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
			if(aT == NULL)
				return FALSE;
			m_nAllocSize = nNewAllocSize;
			m_aT = aT;
		}
		m_nSize++;
		SetAtIndex(m_nSize - 1, t);
		return TRUE;
	}
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(int nIndex)
	{
		if(nIndex != (m_nSize - 1))
			memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aT != NULL)
		{
			free(m_aT);
			m_aT = NULL;
		}
		m_nSize = 0;
		m_nAllocSize = 0;
	}
	T& operator[] (int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aT[nIndex];
	}
	T* GetData() const
	{
		return m_aT;
	}

// Implementation
	void SetAtIndex(int nIndex, T& t)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_aT[nIndex] = t;
	}
	int Find(T& t) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;	// not found
	}
};
#endif __SIMPLEARRAY__

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\util.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __UTIL__
#define __UTIL__
#pragma once

#include "comdef.h"

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#define SIZEOF(x)    sizeof(x)

#define HIDWORD(_qw)    (DWORD)((_qw)>>32)
#define LODWORD(_qw)    (DWORD)(_qw)

// Sizes of various string-ized numbers
#define MAX_INT64_SIZE  30              // 2^64 is less than 30 chars long
#define MAX_COMMA_NUMBER_SIZE   (MAX_INT64_SIZE + 10)
#define MAX_COMMA_AS_K_SIZE     (MAX_COMMA_NUMBER_SIZE + 10)

HRESULT Extract(IDataObject *_DO, wchar_t* fmt, wchar_t* data);
HRESULT Extract(IDataObject *_DO, wchar_t* fmt, bstr_t &data);

INT WINAPI Int64ToString(_int64 n, LPTSTR szOutStr, UINT nSize, BOOL bFormat,
                                   NUMBERFMT *pFmt, DWORD dwNumFmtFlags);
void Int64ToStr( _int64 n, LPTSTR lpBuffer);

LPTSTR WINAPI AddCommas64(_int64 n, LPTSTR pszResult);
LPTSTR WINAPI AddCommas(DWORD dw, LPTSTR pszResult);

long StrToLong(LPTSTR x);
//int StrToInt(LPTSTR x);

//BOOL MyPathCompactPathEx(LPTSTR  pszOut,
//						LPCTSTR pszSrc,
//						UINT    cchMax,
//						DWORD   dwFlags);

#define HINST_THISDLL   _Module.GetModuleInstance()

#define NUMFMT_IDIGITS 1
#define NUMFMT_ILZERO 2
#define NUMFMT_SGROUPING 4
#define NUMFMT_SDECIMAL 8
#define NUMFMT_STHOUSAND 16
#define NUMFMT_INEGNUMBER 32
#define NUMFMT_ALL 0xFFFF

#endif __UTIL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\t_dataextractor.h ===
//-----------------------------------------------------------------------------
// NMGR_CClientDataExtractor.h
//
//
//  This header containes the template implementation of T_DataExtractor.
//
//  The name of this header will be changing!!!!!!
//
//
//
//
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//-----------------------------------------------------------------------------

#if !defined(__CClientDataExtractor_h)
#define      __CClientDataExtractor_h

#include "SimpleArray.h"

//-----------------------------------------------------------------------------
// template T_DataExtractor
//
//
//  This template class allows you to act as if a pointer to an IDataObject 
//  is the clipboard format that you are trying to extract from the IDataObject.
//  What????
//
//  Ok.  Given that any IDataObject exposes one of more CCF_'s (Clip board formats)
//  you want to ask the IDataObject for a specific CCF_.  Using this template
//  allows you to "auto-magically" handle both the asking of the question
//  "Does this data object support this CCF_?" and the subsequent extraction of 
//  particular clip board format.
//
//  Syntax:
//  
//      T_DataExtractor<__type,CCF_> data;
//  
//  __type  is the actual type of data you hope to extract from the IDataObject
//  CCF_    is the registered clip board format for the given type that you want
//          to extract.
//
//   
//    Examples:  
//      int       :  T_DataExtractor<int,     CCF_INT>          iMyInt;
//      CClass *  :  T_DataExtractor<CClass*, CCF_CCLASSPTR>    pMyClass;
//
//                             

template<typename TNData,const wchar_t* pClipFormat>
class T_DataExtractor
{
    private:
        typedef CSimpleArray<HGLOBAL> HGlobVector;

        IDataObject *       m_pDataObject;      // Wrapped Data Object
        HGlobVector         m_MemoryHandles;    // Memory Allocated

        TNData *            m_pData;            // "Cached" Value

        static UINT         m_nClipFormat;      // Registered Clipboard Format

    protected:

        //-------------------------------------
        // Extract  : Does the data extraction.

        TNData* Extract()
        {
            HGLOBAL     hMem = GlobalAlloc(GMEM_SHARE,sizeof(TNData));
            TNData *    pRet = NULL;

            if(hMem != NULL)
            {
                m_MemoryHandles.Add(hMem);

                STGMEDIUM stgmedium = { TYMED_HGLOBAL, (HBITMAP) hMem};
                FORMATETC formatetc = { m_nClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

                if(m_pDataObject->GetDataHere(&formatetc, &stgmedium) == S_OK )
                {
                    pRet = reinterpret_cast<TNData*>(hMem);
                }
            }

            return pRet;
        }


    public:


        //---------------------------------------------------------
        // TDataExtractor : C-Tor
        //
        //  Create an extractor object from an IDataObject pointer
        //
        //  After the object has been constructed, you must test
        //  to see if the IDataObject pointer exposed the 
        //  clipboard format that you were looking for.  If a call
        //  to IsValidData returns true you know two things.
        //
        //  1)  The data object exposed the clipboard format 
        //      you asked for.
        //
        //  2.) This class was able to extract a copy of the data 
        //      and now holds a local copy of the data.
        //
        //  _pObject        : Pointer to the IDataObject we "manage"
        //  bAutoExtract    : Automatically attempt to extract 
        //                    the data from the IDataObject pointer
        //

        T_DataExtractor(IDataObject * _pObject,bool bAutoExtract = true)
        {
            m_pDataObject   = _pObject;
            m_pData         = NULL;


            if(m_pDataObject)
            {
                if(bAutoExtract)
                {
                    m_pData = Extract();
                }

                m_pDataObject->AddRef();
            }
        }

        //-------------------------------------------------------
        // IsValidData:     True if the clipboard format
        //                  was exposed by the IDataObject and
        //                  was copied into our local version.
        //
        //                  This is only useful if you construct the 
        //                  class with bAutoExtract = true!!!!!!
        //  
        //  Note:           No guarentee is made for the quality
        //                  of the data.  This just indicates
        //                  that the data was extracted.

        bool IsValidData()   
        { 
            return m_pData != NULL; 
        }

        
        //-------------------------------------------------------
        // ~T_DataExtractor : D-Tor
        //
        //  Cleans up any allocated memory and releases our 
        //  AddRef on the IDataObject.
        //

        ~T_DataExtractor()
        {
            HGLOBAL walk;
  
			for(int i = 0; i > m_MemoryHandles.GetSize(); i++)
            {
				walk = m_MemoryHandles[i];
                GlobalFree(walk);
            }

            m_pDataObject->Release();
        }

        
        //-------------------------------------------------------
        // operator TNData
        //
        //  This conversion operator should allow you to act apon 
        //  this class as if it was the underlying data type that 
        //  was extracted from the IDataObject
        //
        //  i.e. Pretend CCF_INT exposes an integer:
        //
        //  void SomeIntFunction(int iMyData) {}
        //
        //  T_DataExtractor<int,CC_INT> iMyInt;
        //
        //  SomeIntFunction(iMyInt);
        //  
        //
        
        operator TNData()
        { 
            return *m_pData;  
        }

        //-------------------------------------------------------
        // TNData operator->
        //
        //  If a clpboard format is exposed as a pointer, this
        //  will allow you to use the T_DataExtractor class as 
        //  if it were the actual underlying pointer type.
        //  
        //  i.e. 
        // 
        //  class CMyClass;
        //
        //  T_DataExtractor<CMyClass *,CCF_MYCLASS> pMyClass;
        //
        //  pMyClass->SomeMemberFunction();
        //
        //

        TNData operator->()
        { 
            return *m_pData;  
        }


        //-------------------------------------------------------
        // GetDataPointer
        //
        //  In the case that you need to extract a pointer to
        //  the acutal data item.  (Say extracting the clipboard format
        //  increments a value or something.)  This will alow you to 
        //  Get a pointer to the data.
        //
        //  This is also very useful if the data item is quite large.
        //  It would be very expensive to be continuely accessing 
        //  the data via the above operators.
        //
        //  Each time you call this member a NEW data item will be
        //  extracted.  If your data item is large, make sure that 
        //  you construct the class without automatically extracting 
        //  the clipboard format.
        //


        TNData * GetDataPointer()   
        { 
            return Extract(); 
        }
};

template<typename TNData,const wchar_t* pClipFormat>
UINT T_DataExtractor<TNData,pClipFormat>::m_nClipFormat = RegisterClipboardFormatW(pClipFormat);




template<const wchar_t* pClipFormat>
class T_bstr_tExtractor
{
    private:
        IDataObject *   m_pDataObject;
        _bstr_t         m_sString;
        bool            m_bIsValidData;

        static UINT     m_nClipFormat;      // Registered Clipboard Format

    protected:

        void GetString()
        {
            STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
            FORMATETC formatetc = { m_nClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

            if(m_pDataObject->GetData(&formatetc, &stgmedium) == S_OK )
            {
                m_sString = reinterpret_cast<wchar_t*>(stgmedium.hGlobal);

                m_bIsValidData = true;

                GlobalFree(stgmedium.hGlobal);
            }
        }

    public:

        T_bstr_tExtractor(IDataObject * _pDO)
        {
            m_bIsValidData = false;

            m_pDataObject = _pDO;
            m_pDataObject->AddRef();

            GetString();

            m_pDataObject->Release();
        }

        ~T_bstr_tExtractor()
        {
        }

        operator _bstr_t&()
        {
            return m_sString;
        }

        bool IsValidData() { return m_bIsValidData; }

};

template<const wchar_t* pClipFormat>
UINT T_bstr_tExtractor<pClipFormat>::m_nClipFormat = RegisterClipboardFormatW(pClipFormat);




#endif // __CCientDataExtractor_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\sshwbemhelpers.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  SshWbemHelpers.cpp
//
//
//
//
//  History:
//
//
//
//  Copyright (c) 1997-1999 Microsoft Corporation
///////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <stdio.h>
#include <cominit.h>

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "SshWbemHelpers.h"

#define REFCOUNT(obj) obj->AddRef()?obj->Release():0xFFFFFFFF



//-----------------------------------------------------------------------------
IErrorInfo * CWbemException::GetErrorObject()
{
    IErrorInfo * pEI = NULL;
    GetErrorInfo(0, &pEI);
    return pEI;
}

//-----------------------------------------------------------------------------
IErrorInfo * CWbemException::MakeErrorObject(_bstr_t sDescription)
{
    ICreateErrorInfoPtr pcerrinfo;
    HRESULT hr;

    hr = CreateErrorInfo(&pcerrinfo);

    if(SUCCEEDED(hr))
    {
        pcerrinfo->SetDescription(sDescription);
        pcerrinfo->SetSource(_bstr_t("CWbemException"));

        IErrorInfoPtr perrinfo;
        hr = pcerrinfo->QueryInterface(IID_IErrorInfo, (LPVOID FAR*) &perrinfo);

        if(SUCCEEDED(hr))
        {
            SetErrorInfo(0, perrinfo);
        }
    }

    return GetErrorObject();
}

//-----------------------------------------------------------------------------
void CWbemException::GetWbemStatusObject()
{
    m_pWbemError = new CWbemClassObject();

    if(m_pWbemError)
    {
        IErrorInfoPtr pEI = ErrorInfo();

        if(pEI)
        {
            pEI->QueryInterface(IID_IWbemClassObject, (void**)&(*m_pWbemError));
        }
    }
}

//-----------------------------------------------------------------------------
CWbemException::CWbemException(HRESULT hr,_bstr_t sDescription) :
    _com_error(hr,GetErrorObject()),
    m_sDescription(sDescription),
    m_hr(hr)
{
    GetWbemStatusObject();
}

//-----------------------------------------------------------------------------
CWbemException::CWbemException(_bstr_t sDescription) :
					_com_error(WBEM_E_FAILED,MakeErrorObject(sDescription)),
					m_sDescription(sDescription)
{
    GetWbemStatusObject();
}

//-----------------------------------------------------------------------------
CWbemClassObject CWbemException::GetWbemError()
{
    return *m_pWbemError;
}


//-----------------------------------------------------------------------------
CWbemServices::CWbemServices(IWbemContext * _pContext)
{
    m_pCtx              = _pContext;
	m_authIdent = 0;
	m_pService = 0;
    m_cloak = 0;
}

//-----------------------------------------------------------------------------
CWbemServices::CWbemServices(const CWbemServices& _p, COAUTHIDENTITY *authIdent)
{
	m_authIdent = authIdent;
	m_pService = 0;
    IWbemServicesPtr pServices;
    m_cloak = 0;

    m_hr = S_OK;
    if(SUCCEEDED(const_cast<CWbemServices&>(_p).GetInterfacePtr(pServices)))
    {
        m_hr = CommonInit(pServices);
    }

    m_pCtx = _p.m_pCtx;
}

//-----------------------------------------------------------------------------
CWbemServices::CWbemServices(const IWbemServicesPtr& _in)
{
	m_authIdent = 0;
    m_hr = S_OK;
	m_pService = 0;
    m_cloak = 0;
    m_hr = CommonInit(const_cast<IWbemServicesPtr&>(_in));
}


//-----------------------------------------------------------------------------
CWbemServices::CWbemServices(IWbemServices *_in,IWbemContext * _pContext)
{
    m_pCtx = _pContext;
	m_authIdent = 0;
    m_hr = S_OK;
	m_pService = 0;
    m_cloak = 0;

    IWbemServicesPtr pServices = _in;
    m_hr = CommonInit(pServices);
}


//-----------------------------------------------------------------------------
CWbemServices::CWbemServices(const IUnknownPtr& _in)
{
    IWbemServicesPtr pServices = _in;
	m_authIdent = 0;
    m_hr = S_OK;
	m_pService = 0;
    m_cloak = 0;

    m_hr = CommonInit(pServices);
}


//-----------------------------------------------------------------------------
CWbemServices::CWbemServices(IUnknown * _in)
{
    IWbemServicesPtr pServices = _in;

	m_authIdent = 0;
    m_hr = S_OK;
	m_pService = 0;
    m_cloak = 0;

    m_hr = CommonInit(pServices);
}


//-----------------------------------------------------------------------------
CWbemServices::~CWbemServices()
{
}


//-----------------------------------------------------------------------------
CWbemServices&  CWbemServices::operator=(IWbemServices *_p)
{
    m_pCtx = NULL;

    IWbemServicesPtr pServices = _p;

    m_hr = CommonInit(pServices);
	return *this;
}


//-----------------------------------------------------------------------------
CWbemServices& CWbemServices::operator=(IUnknown * _p)
{
    IWbemServicesPtr pServices = _p;

    m_pCtx = NULL;

    m_hr = CommonInit(pServices);
	return *this;
}


//-----------------------------------------------------------------------------
CWbemServices& CWbemServices::operator=(IUnknownPtr& _p)
{
    IWbemServicesPtr pServices = _p;

    m_pCtx = NULL;

    m_hr = CommonInit(pServices);
	return *this;
}


//-----------------------------------------------------------------------------
CWbemServices& CWbemServices::operator=(const CWbemServices& _p)
{
    IWbemServicesPtr pServices;

    if(SUCCEEDED(const_cast<CWbemServices&>(_p).GetInterfacePtr(pServices)))
    {
        m_hr = CommonInit(pServices);
    }

    m_pCtx = _p.m_pCtx;
	return *this;
}


//-----------------------------------------------------------------------------
HRESULT CWbemServices::GetInterfacePtr(
                                IWbemServicesPtr& pServices,
                                DWORD dwProxyCapabilities)  // = EOAC_NONE
{
    HRESULT hr = E_FAIL;

	pServices = m_pService;
	SetBlanket(pServices, dwProxyCapabilities);
	hr = S_OK;
    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::CommonInit(IWbemServicesPtr& pServ)
{
	HRESULT hr;
    if(pServ)
    {
		m_pService = pServ;
		hr = SetBlanket((IWbemServices *)m_pService);
    }
	return hr;
}

//---------------------------------------------------------------------
bool CWbemServices::IsClientNT5OrMore(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return ( os.dwPlatformId == VER_PLATFORM_WIN32_NT ) && ( os.dwMajorVersion >= 5 ) ;
}

//---------------------------------------------------------------
void CWbemServices::SetPriv(LPCTSTR privName /* = SE_SYSTEM_ENVIRONMENT_NAME */)
{
    ImpersonateSelf(SecurityImpersonation);

	if(OpenThreadToken( GetCurrentThread(),
						TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
						FALSE, &m_hAccessToken ) )
	{
		m_fClearToken = true;

		// Now, get the LUID for the privilege from the local system
		ZeroMemory(&m_luid, sizeof(m_luid));

		LookupPrivilegeValue(NULL, privName, &m_luid);
		m_cloak = true;
		EnablePriv(true);
	}
	else
	{
		DWORD err = GetLastError();
	}
}

//---------------------------------------------------------------
DWORD CWbemServices::EnablePriv(bool fEnable)
{
	DWORD				dwError = ERROR_SUCCESS;
	TOKEN_PRIVILEGES	tokenPrivileges;

	tokenPrivileges.PrivilegeCount = 1;
	tokenPrivileges.Privileges[0].Luid = m_luid;
	tokenPrivileges.Privileges[0].Attributes = ( fEnable ? SE_PRIVILEGE_ENABLED : 0 );

	if(AdjustTokenPrivileges(m_hAccessToken,
								FALSE,
								&tokenPrivileges,
								0, NULL, NULL) != 0)
	{
		IWbemServices *service = NULL;
		GetServices(&service);

        //
        // Enable cloaking so the thread token is available to the
        // provider for the priv check. Reciprocate for disable.
        //
		SetBlanket(service, fEnable ? EOAC_STATIC_CLOAKING : EOAC_NONE);
	}
	else
	{
		dwError = ::GetLastError();
	}

	return dwError;
}

//---------------------------------------------------------------
void CWbemServices::ClearPriv(void)
{

	m_cloak = false;
	EnablePriv(false);

	if(m_fClearToken)
	{
		CloseHandle(m_hAccessToken);
		m_hAccessToken = 0;
		m_fClearToken = false;
	}
}

//---------------------------------------------------------------------
HRESULT CWbemServices::SetBlanket(IUnknown *service,
                                  DWORD dwProxyCapabilities) // = EOAC_NONE
{
	HRESULT hr = E_FAIL;
    if(service)
    {
        //
        // Sigh, maintain this hack for RC1.
        //
        DWORD eoac = EOAC_NONE;
        if(IsClientNT5OrMore() && m_cloak)
        {
            eoac = EOAC_STATIC_CLOAKING;
        }

		try
		{
            RPC_AUTH_IDENTITY_HANDLE AuthInfo = NULL;
            DWORD dwAuthnSvc = 0;
            DWORD dwAuthnLvl = 0;
            hr = CoQueryProxyBlanket(
                    service,
                    &dwAuthnSvc,
                    NULL,
                    NULL,
                    &dwAuthnLvl,
                    NULL,
                    &AuthInfo,
                    NULL);

            if (SUCCEEDED(hr))
            {
                hr = SetInterfaceSecurityEx(service,
                                            m_authIdent,
                                            NULL,
                                            dwAuthnLvl,
                                            RPC_C_IMP_LEVEL_IMPERSONATE,
                                            (eoac != EOAC_NONE) ? eoac :
                                                dwProxyCapabilities);
		    }
		}
		catch( ... )
		{
			hr = E_FAIL;
		}
    }
	return hr;
}

//-----------------------------------------------------------------------------
void CWbemServices::DisconnectServer(void)
{
	m_pCtx = NULL;
	m_pService = NULL;
}

//-----------------------------------------------------------------------------
CWbemClassObject CWbemServices::CreateInstance(_bstr_t  _sClass,
												IWbemCallResultPtr& _cr)
{
	CWbemClassObject coClassDef = GetObject(_sClass,_cr);
	CWbemClassObject coRet;

	if(!coClassDef.IsNull())
	{
		coRet = coClassDef.SpawnInstance();
	}

	return coRet;
}

//-----------------------------------------------------------------------------
CWbemClassObject CWbemServices::CreateInstance(_bstr_t _sClass)
{
    IWbemCallResultPtr crUnused;
	return CreateInstance(_sClass,crUnused);
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::DeleteInstance(_bstr_t _sClass)
{
    HRESULT hr;
    IWbemCallResultPtr pResult;

    hr = m_pService->DeleteInstance(_sClass, WBEM_FLAG_RETURN_IMMEDIATELY,
                                    NULL, &pResult);

    if (SUCCEEDED(hr))      // Useless probably, but eases my paranoia.
    {
        hr = this->SetBlanket(pResult);

        if (SUCCEEDED(hr))
        {
            HRESULT hrTemp;
            hr = pResult->GetCallStatus(WBEM_INFINITE, &hrTemp);

            if (SUCCEEDED(hr))
            {
                hr = hrTemp;
            }
        }
    }

    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::GetMethodSignatures(const _bstr_t& _sObjectName,
											const _bstr_t& _sMethodName,
											CWbemClassObject& _in,
											CWbemClassObject& _out)
{
    CWbemClassObject methodClass = GetObject(_sObjectName);

    if(methodClass)
    {
        m_hr = methodClass.GetMethod(_sMethodName,_in,_out);
    }

    return m_hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::PutInstance(CWbemClassObject&   _object,
									IWbemCallResultPtr& _cr,
									long _lFlags /*= WBEM_FLAG_CREATE_OR_UPDATE*/)
{
	HRESULT hr = E_FAIL;
	IWbemServicesPtr pServices;
	GetInterfacePtr(pServices);
#ifdef NOT_NECESSARY
	if(m_pCtx == NULL)
	{
		IWbemContext *pContext = NULL;
		hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

		if(FAILED(hr))
		{
//			::MessageBox(NULL,_T("Cannot CoCreateInstance"),_T("Error"),MB_OK);
			return hr;
		}
		
		m_pCtx = pContext;
	}
    hr = pServices->PutInstance(_object,_lFlags,m_pCtx,&_cr);
#endif // NOT_NECESSARY

	hr = pServices->PutInstance(_object,_lFlags,NULL,&_cr);
	return hr;
}

//---------------- VINOTH ------------------------------------------------------
HRESULT CWbemServices::PutInstance(
                            CWbemClassObject&   _object,
                            IWbemContext *pContext,
                            long _lFlags,   // = WBEM_FLAG_CREATE_OR_UPDATE
                            DWORD _dwProxyCapabilities)  // = EOAC_NONE
{
	HRESULT hr = E_FAIL;
	IWbemServicesPtr pServices;
	GetInterfacePtr(pServices, _dwProxyCapabilities);
#ifdef NOT_NECESSARY
    IWbemCallResultPtr crUnused;
	hr = pServices->PutInstance(_object,_lFlags,pContext,&crUnused);
#endif // NOT_NECESSARY
	hr = pServices->PutInstance(_object,_lFlags,pContext,NULL);
	return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::PutInstance(
                            CWbemClassObject&   _object,
                            long _lFlags,   // = WBEM_FLAG_CREATE_OR_UPDATE
                            DWORD dwProxyCapabilities)  // = EOAC_NONE
{
#ifdef NOT_NECESSARY
    IWbemCallResultPtr crUnused;
    return PutInstance(_object,crUnused,_lFlags);
#endif // NOT_NECESSARY
    return PutInstance(_object,NULL,_lFlags,dwProxyCapabilities);
}

//-----------------------------------------------------------------------------
bool CWbemServices::IsNull()
{
    bool bRet = m_pService == NULL;

    return bRet;
}

//-----------------------------------------------------------------------------
CWbemServices::operator bool()
{
    bool bRet = m_pService != NULL;
    return bRet;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::CreateInstanceEnum(_bstr_t Class,
											long lFlags,
											IEnumWbemClassObject **ppEnum)
{
	HRESULT hr = E_FAIL;
	if(m_pService)
	{
		SetBlanket(m_pService);
		if(m_pCtx == NULL)
		{
			IWbemContext *pContext = NULL;
			hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

			if(FAILED(hr))
			{
				return hr;
			}
			
			m_pCtx = pContext;
		}

		hr = m_pService->CreateInstanceEnum(Class, lFlags, m_pCtx, ppEnum);
		SetBlanket(*ppEnum);
	}
    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::CreateInstanceEnumAsync(_bstr_t Class,
												IWbemObjectSink *ppSink,
												long lFlags /*= 0*/)
{
	HRESULT hr = E_FAIL;
	if(m_pService)
	{
		if(m_pCtx == NULL)
		{
			IWbemContext *pContext = NULL;
			hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

			if(FAILED(hr))
			{
				return hr;
			}
			
			m_pCtx = pContext;
		}

		SetBlanket(m_pService);
		hr = m_pService->CreateInstanceEnumAsync(Class, lFlags, m_pCtx, ppSink);
	}
    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::CreateClassEnum(_bstr_t Class,
										long lFlags,
										IEnumWbemClassObject **ppEnum)
{
	HRESULT hr = E_FAIL;
	if(m_pService)
	{
		SetBlanket(m_pService);
		if(m_pCtx == NULL)
		{
			IWbemContext *pContext = NULL;
			hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

			if(FAILED(hr))
			{
				return hr;
			}
			
			m_pCtx = pContext;
		}

		hr = m_pService->CreateClassEnum(Class, lFlags, m_pCtx, ppEnum);
		SetBlanket(*ppEnum);
	}
    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::CreateClassEnumAsync(_bstr_t Class,
												IWbemObjectSink *ppSink,
												long lFlags /*= 0*/)
{
	HRESULT hr = E_FAIL;
	if(m_pService)
	{
		SetBlanket(m_pService);
		if(m_pCtx == NULL)
		{
			IWbemContext *pContext = NULL;
			hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

			if(FAILED(hr))
			{
				return hr;
			}
			
			m_pCtx = pContext;
		}

		hr = m_pService->CreateClassEnumAsync(Class, lFlags, m_pCtx, ppSink);
	}
    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::ExecQuery(_bstr_t QueryLanguage,
									_bstr_t Query,
									long lFlags,
									IEnumWbemClassObject **ppEnum)
{
    HRESULT hr = E_FAIL;
	if(m_pService)
	{
		if(m_pCtx == NULL)
		{
			IWbemContext *pContext = NULL;
			hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

			if(FAILED(hr))
			{
				return hr;
			}
			
			m_pCtx = pContext;
		}

		hr = m_pService->ExecQuery(QueryLanguage, Query,lFlags, m_pCtx, ppEnum);
		SetBlanket(*ppEnum);
	}
    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::ExecQuery(_bstr_t Query,
									long lFlags,
									IEnumWbemClassObject **ppEnum)
{
	HRESULT hr = E_FAIL;
	if(m_pService)
	{
		if(m_pCtx == NULL)
		{
			IWbemContext *pContext = NULL;
			hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

			if(FAILED(hr))
			{
				return hr;
			}
			
			m_pCtx = pContext;
		}

		hr = m_pService->ExecQuery(_bstr_t("WQL"), Query,lFlags, m_pCtx, ppEnum);
		SetBlanket(*ppEnum);
	}
    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::ExecQuery(_bstr_t Query,
									IEnumWbemClassObject **ppEnum)
{
	HRESULT hr = E_FAIL;
	if(m_pService)
	{
		if(m_pCtx == NULL)
		{
			IWbemContext *pContext = NULL;
			hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

			if(FAILED(hr))
			{
				return hr;
			}
			
			m_pCtx = pContext;
		}

		hr = m_pService->ExecQuery(_bstr_t("WQL"), Query,0, m_pCtx, ppEnum);
		SetBlanket(*ppEnum);
	}
    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::ExecQueryAsync(_bstr_t Query,
										IWbemObjectSink * pSink,
										long lFlags /*= 0*/)
{
	HRESULT hr = E_FAIL;
	if(m_pService)
	{
		if(m_pCtx == NULL)
		{
			IWbemContext *pContext = NULL;
			hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

			if(FAILED(hr))
			{
				return hr;
			}
			
			m_pCtx = pContext;
		}

		hr = m_pService->ExecQueryAsync(_bstr_t("WQL"), Query,0, m_pCtx, pSink);
	}
    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::ExecMethod(_bstr_t sPath,
									_bstr_t sMethod,
									CWbemClassObject& inParams,
									CWbemClassObject& outParams)
{
    IWbemCallResultPtr crUnused;
	HRESULT hr = E_FAIL;
	if(m_pService)
	{
		if(m_pCtx == NULL)
		{
			IWbemContext *pContext = NULL;
			hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

			if(FAILED(hr))
			{
				return hr;
			}
			
			m_pCtx = pContext;
		}

		hr = m_pService->ExecMethod(sPath, sMethod,0, m_pCtx, inParams,&outParams,&crUnused);
	}
	return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::CancelAsyncCall(IWbemObjectSink * pSink)
{
	HRESULT hr = E_FAIL;
	if(m_pService)
	{
		hr = m_pService->CancelAsyncCall(pSink);
	}
    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::GetServices(IWbemServices ** ppServices)
{
    IWbemServicesPtr pServices;
    GetInterfacePtr(pServices);

    *ppServices = pServices.Detach();

    return S_OK;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::ConnectServer(_bstr_t sNetworkResource)
{
    IWbemLocatorPtr pLocator;
    HRESULT hr;

    // Get a pointer locator and use it to get a pointer to WbemServices!
    hr = pLocator.CreateInstance(CLSID_WbemLocator);

    if(SUCCEEDED(hr))
    {
        IWbemServicesPtr pServices = 0;

        hr = pLocator->ConnectServer(sNetworkResource,               // Network
										NULL,                         // User
										NULL,                         // Password
										NULL,                         // Locale
										0,                            // Security Flags
										NULL,                         // Authority
										NULL,                         // Context
										&pServices);                  // Namespace

        if(SUCCEEDED(hr))
        {
            hr = CommonInit(pServices);
			m_path = sNetworkResource;
        }
    }
	return hr;
}

//-----------------------------------------------------------
CWbemServices CWbemServices::OpenNamespace(_bstr_t sNetworkResource)
{
	CWbemServices coRet;
    IWbemServicesPtr pServices = NULL, pTemp = NULL;

    GetInterfacePtr(pServices);

	m_hr = S_OK;

	if(pServices)
	{
		try {
			m_hr = pServices->OpenNamespace(sNetworkResource,// Network
											0, NULL,           // Password
											&pTemp, NULL);    // Namespace

			if(SUCCEEDED(m_hr))
			{
				coRet = (IWbemServices *)pTemp;
				coRet.m_authIdent = m_authIdent;
				coRet.SetBlanket(pTemp);
				coRet.m_path = sNetworkResource;
			}
		}
		catch( ... )
		{
		}
	}
	return coRet;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::ConnectServer(_bstr_t sNetworkResource,
									_bstr_t sUser,
									_bstr_t sPassword,
									long    lSecurityFlags)
{
    IWbemLocatorPtr pLocator;
    HRESULT hr = S_OK;

    // Get a pointer locator and use it to get a pointer to WbemServices!
    pLocator.CreateInstance(CLSID_WbemLocator);

    if(SUCCEEDED(hr))
    {
        IWbemServicesPtr pServices = 0;

        hr = pLocator->ConnectServer(sNetworkResource,               // Network
									sUser,                          // User
									sPassword,                      // Password
									NULL,                           // Locale
									lSecurityFlags,                 // Security Flags
									NULL,                           // Authority
									NULL,                           // Context
									&pServices);

        if(SUCCEEDED(hr))
        {
			//Now Store the User,Passowrd and Security Flags for later use
			m_User = sUser;
			m_Password = sPassword;
			m_lFlags = lSecurityFlags;
            hr = CommonInit(pServices);
			m_path = sNetworkResource;
        }
    }
	return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::ConnectServer(_bstr_t sNetworkResource,
									LOGIN_CREDENTIALS *user,
									long    lSecurityFlags/* = 0*/)

{
	HRESULT hr = S_OK;

	if((user == NULL) || user->currUser)
	{
		if(m_authIdent)
		{
			WbemFreeAuthIdentity(m_authIdent);
			m_authIdent = 0;
		}

		hr = ConnectServer(sNetworkResource);
	}
	else
	{
		IWbemLocatorPtr pLocator;

		m_authIdent = user->authIdent;

		// Get a pointer locator and use it to get a pointer to WbemServices!
		pLocator.CreateInstance(CLSID_WbemLocator);

		if(SUCCEEDED(hr))
		{
			IWbemServicesPtr pServices = 0;
			bstr_t usr(user->fullAcct), pwd;

			if(user->authIdent->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI)
			{
				WCHAR temp[100] = {0};
				mbstowcs(temp, (const char *)user->authIdent->Password, sizeof(temp));
				pwd = temp;
			}
			else
			{
				// unicode to unicode
				pwd = user->authIdent->Password;
			}

			hr = pLocator->ConnectServer(sNetworkResource, // Network
										(bstr_t)usr,       // User
										(bstr_t)pwd,       // Password
										NULL,              // Locale
										lSecurityFlags,    // Security Flags
										NULL,              // Authority
										NULL,              // Context
										&pServices);

            if (SUCCEEDED(hr))
            {
                // Now Store the User,Password and Security Flags for
                // later use
				m_User = usr;
				m_Password = pwd;
				m_lFlags = lSecurityFlags;
				hr = CommonInit(pServices);
				m_path = sNetworkResource;
		    }
		}
	}
	return hr;
}

//-----------------------------------------------------------------------------
CWbemClassObject CWbemServices::GetObject(_bstr_t _sName,
											IWbemCallResultPtr &_cr,
											long flags /*= 0*/)
{
    CWbemClassObject coRet;
	m_hr = S_OK;
    IWbemServicesPtr pServices;
    GetInterfacePtr(pServices);
	if(m_pCtx == NULL)
	{
		IWbemContext *pContext = NULL;
		m_hr = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, IID_IWbemContext, (void **)&pContext);

		if(FAILED(m_hr))
		{
//			::MessageBox(NULL,_T("Cannot CoCreateInstance"),_T("Error"),MB_OK);
			return coRet;
		}
		
		m_pCtx = pContext;
	}

    m_hr = pServices->GetObject(_sName, flags, m_pCtx,&coRet, &_cr);

    return coRet;
}

//------------------------------------------------
CWbemClassObject CWbemServices::GetObject(_bstr_t _sName, long flags /*= 0*/)
{
    IWbemCallResultPtr crUnused;
    return GetObject(_sName,crUnused, flags);
}

//------------------------------------------------
// get the first instance of the named class.
IWbemClassObject *CWbemServices::FirstInstanceOf(bstr_t className)
{
	IWbemClassObject *pInst = NULL;
	ULONG uReturned;
	IEnumWbemClassObject *Enum = NULL;

	m_hr = S_OK;
	// get the class.
	m_hr = CreateInstanceEnum(className, WBEM_FLAG_SHALLOW, &Enum);
	if(SUCCEEDED(m_hr))
	{
		// get the first and only instance.
		Enum->Next(-1, 1, &pInst, &uReturned);
		Enum->Release();
	}
	return pInst;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::SetContextValue(_bstr_t sName,_variant_t value)
{
    HRESULT hr = S_OK;

    if(!bool(m_pCtx))
    {
        hr = m_pCtx.CreateInstance(CLSID_WbemContext);
    }

    if( SUCCEEDED(hr) )
    {
        hr = m_pCtx->SetValue(sName,0,&value);
    }

    return hr;
}


//-----------------------------------------------------------------------------
HRESULT CWbemServices::SetContext(IWbemContext * pWbemContext)
{
    HRESULT hr = S_OK;

    m_pCtx = pWbemContext;

    return hr;
}


//-----------------------------------------------------------------------------
HRESULT CWbemServices::GetContextValue(_bstr_t sName,_variant_t& value)
{
    HRESULT hr = S_OK;

    if(m_pCtx)
    {
        hr = m_pCtx->GetValue(sName,0,&value);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


//-----------------------------------------------------------------------------
HRESULT CWbemServices::DeleteContextValue(_bstr_t sName)
{
    HRESULT hr = S_OK;

    if(m_pCtx)
    {
        hr = m_pCtx->DeleteValue(sName,0);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemServices::DeleteAllContextValues()
{
    HRESULT hr = S_OK;

    if(m_pCtx)
    {
        hr = m_pCtx->DeleteAll();
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


//-----------------------------------------------------------------------------
HRESULT CWbemServices::GetContext(IWbemContext **ppWbemContext)
{
    HRESULT hr = E_FAIL;

    if(m_pCtx)
    {
        m_pCtx->AddRef();
        *ppWbemContext = m_pCtx;
        hr = S_OK;
    }

    return hr;
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

DWORD g_ObjectCount = 0;

#define TESTOBJ if(m_pWbemObject==0)return WBEM_E_NOT_AVAILABLE;

//-----------------------------------------------------------------------------
CWbemClassObject::CWbemClassObject(const CWbemClassObject&  _in):
	m_pWbemObject(_in.m_pWbemObject)
{
	ref = 0;
    g_ObjectCount++;
}

//-----------------------------------------------------------------------------
CWbemClassObject::CWbemClassObject(IWbemClassObject * const _in):
	m_pWbemObject(_in)
{
	ref = 0;
    g_ObjectCount++;
}


//-----------------------------------------------------------------------------
CWbemClassObject::CWbemClassObject(IWbemClassObjectPtr& _in) :
    m_pWbemObject(_in)
{
	ref = 0;
    g_ObjectCount++;
}


//-----------------------------------------------------------------------------
CWbemClassObject::CWbemClassObject(IUnknown * _in):
	m_pWbemObject(_in)
{
	ref = 0;
    g_ObjectCount++;
}

//-----------------------------------------------------------------------------
CWbemClassObject::CWbemClassObject(IUnknownPtr& _in):
	m_pWbemObject(_in)
{
	ref = 0;
    g_ObjectCount++;
}


//-----------------------------------------------------------------------------
CWbemClassObject::CWbemClassObject():
	m_pWbemObject()
{
	ref = 0;
    g_ObjectCount++;
}


//-----------------------------------------------------------------------------
CWbemClassObject::~CWbemClassObject()
{
    g_ObjectCount--;
}

//-----------------------------------------------------------------------------
void CWbemClassObject::Attach(IWbemClassObject * pWbemObject)
{
    m_pWbemObject.Attach(pWbemObject);
}

//-----------------------------------------------------------------------------
void CWbemClassObject::Attach(IWbemClassObject * pWbemObject,bool bAddRef)
{
    m_pWbemObject.Attach(pWbemObject,bAddRef);
}

//-----------------------------------------------------------------------------
IWbemClassObject *CWbemClassObject::operator->()
{
    return m_pWbemObject;
}

//-----------------------------------------------------------------------------
_bstr_t CWbemClassObject::GetObjectText()
{
    _bstr_t bRet;

    BSTR bstr;

    if( !FAILED(m_pWbemObject->GetObjectText(0,&bstr)) )
    {
        bRet = _bstr_t(bstr,false);
    }

    return bRet;
}

//-----------------------------------------------------------------------------
IWbemClassObject * CWbemClassObject::Detach()
{
    return m_pWbemObject.Detach();
}

//-----------------------------------------------------------------------------
CWbemClassObject::operator IWbemClassObject*()
{
    return m_pWbemObject;
}

//-----------------------------------------------------------------------------
CWbemClassObject::operator IWbemClassObject**()
{
    return &m_pWbemObject;
}

//-----------------------------------------------------------------------------
CWbemClassObject::operator IWbemClassObjectPtr()
{
    return m_pWbemObject;
}

//-----------------------------------------------------------------------------
CWbemClassObject::operator IUnknown *()
{
    return (IUnknown *)(IWbemClassObject *)m_pWbemObject;
}


//-----------------------------------------------------------------------------
IWbemClassObject ** CWbemClassObject::operator &()
{
    return &m_pWbemObject;
}

//-----------------------------------------------------------------------------
bool CWbemClassObject::operator!()
{
    return m_pWbemObject == NULL;
}

//-----------------------------------------------------------------------------
CWbemClassObject::operator bool()
{
    return m_pWbemObject != NULL;
}

//-----------------------------------------------------------------------------
ULONG CWbemClassObject::AddRef()
{
	ref++;
    return m_pWbemObject->AddRef();
}

//-----------------------------------------------------------------------------
ULONG CWbemClassObject::Release()
{
	ref--;
    return m_pWbemObject->Release();
}

//-----------------------------------------------------------------------------
IWbemClassObject* CWbemClassObject::operator=(IWbemClassObject* _p)
{
    m_pWbemObject = _p;
	return m_pWbemObject;
}

//-----------------------------------------------------------------------------
IWbemClassObjectPtr CWbemClassObject::operator=(IWbemClassObjectPtr& _p)
{
    m_pWbemObject = _p;
	return m_pWbemObject;
}


//-----------------------------------------------------------------------------
IWbemClassObject* CWbemClassObject::operator=(IUnknown * _p)
{
    m_pWbemObject = _p;
	return m_pWbemObject;
}

//-----------------------------------------------------------------------------
IWbemClassObjectPtr CWbemClassObject::operator=(IUnknownPtr& _p)
{
    m_pWbemObject = _p;
	return m_pWbemObject;
}


//-----------------------------------------------------------------------------
IWbemClassObject* CWbemClassObject::operator=(const CWbemClassObject& _p)
{
    m_pWbemObject = _p.m_pWbemObject;
	return m_pWbemObject;
}

//-----------------------------------------------------------------------------
bool CWbemClassObject::IsNull() const
{
    return m_pWbemObject ==NULL;
}

//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::Clone(CWbemClassObject& _newObject)
{
    return m_pWbemObject->Clone(_newObject);
}

//-----------------------------------------------------------------------------
CWbemClassObject CWbemClassObject::SpawnInstance()
{
    CWbemClassObject coRet;

    HRESULT hr = m_pWbemObject->SpawnInstance(0,coRet);

    return coRet;
}

//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::GetMethod(const IN _bstr_t& _name,
									CWbemClassObject& coInSignature,
									CWbemClassObject& coOutSignature,
									long _lFlags /*= 0*/)
{
	TESTOBJ;
	return m_pWbemObject->GetMethod(_name, _lFlags, coInSignature, coOutSignature);
}

//-----------------------------------------------------------------------------
bool CWbemClassObject::operator<(const CWbemClassObject& _comp)
{
    return m_pWbemObject < _comp.m_pWbemObject;
}


//-----------------------------------------------------------------------------
// put overloads
HRESULT CWbemClassObject::Put(const _bstr_t& _Name,_variant_t _value,CIMTYPE vType /*= 0*/)
{
	TESTOBJ;
    return m_pWbemObject->Put(_Name,0,&_value,vType);
}

//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::Put(const _bstr_t& _Name,const _bstr_t& _value,CIMTYPE vType /*= 0*/)
{
	TESTOBJ;
	return m_pWbemObject->Put(_Name,0,&_variant_t(_value),vType);
}

//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::Put(const _bstr_t& _Name, const long _value, CIMTYPE vType /*= 0*/)
{
	TESTOBJ;
	return m_pWbemObject->Put(_Name,0,&_variant_t(_value), vType);
}

//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::Put(const _bstr_t& _Name, const bool _value,CIMTYPE vType /*= 0*/)
{
	TESTOBJ;
    return m_pWbemObject->Put(_Name,0,&_variant_t(_value),vType);
}

//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::Get(const _bstr_t& _Name, _bstr_t& _value)
{
	_variant_t v1;
	TESTOBJ;
	HRESULT hr = m_pWbemObject->Get (_Name, 0, &v1, NULL, NULL);
	_value = v1;
	return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::Get(const _bstr_t& _Name, long& _value)
{
	_variant_t v1;
	TESTOBJ;
	HRESULT hr = m_pWbemObject->Get (_Name, 0, &v1, NULL, NULL);
	_value = v1;
	return hr;

}

//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::Get(const _bstr_t& _Name, bool& _value)
{
	_variant_t v1;
	TESTOBJ;
	HRESULT hr = m_pWbemObject->Get (_Name, 0, &v1, NULL, NULL);
	_value = v1;
	return hr;
}

//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::Get(const _bstr_t& _Name,_variant_t& _value)
{
	TESTOBJ;
	return m_pWbemObject->Get (_Name, 0, &_value, NULL, NULL);
}


//-----------------------------------------------------------------------------
_variant_t CWbemClassObject::Get(const _bstr_t& _Name,CIMTYPE& vType,long& lFlavor)
{
    _variant_t vRet;

    m_pWbemObject->Get(_Name, 0, &vRet, &vType, &lFlavor);

    return vRet;
}

//-----------------------------------------------------------------------------
unsigned long CWbemClassObject::GetObjectSize()
{
    unsigned long ulRet = 0;

    IMarshalPtr pTest = (IUnknown*)m_pWbemObject;

    if(pTest)
    {
        pTest->GetMarshalSizeMax(IID_IWbemClassObject,(IUnknown*)m_pWbemObject,MSHCTX_LOCAL,NULL,MSHLFLAGS_NORMAL,&ulRet);
    }

    return ulRet;
}

//-----------------------------------------------------------------------------
_bstr_t CWbemClassObject::GetString(const _bstr_t& _Name)
{
    HRESULT hr;
    _variant_t v1;
    hr = Get(_Name, v1);
	if(v1.vt == VT_NULL)
	{
		return "";
	}
	return v1;
}

//-----------------------------------------------------------------------------
_int64 CWbemClassObject::GetI64(const _bstr_t& _Name)
{
    HRESULT hr;
    _variant_t v1;
	_bstr_t str;

    hr = Get(_Name, v1);
	if(v1.vt == VT_NULL)
	{
		return 0;
	}
	str = (_bstr_t) v1;
	return _atoi64(str);
}


//-----------------------------------------------------------------------------
long CWbemClassObject::GetLong(const _bstr_t& _Name)
{
    HRESULT hr;
    _variant_t v1;
    hr = Get(_Name,v1);
	if(v1.vt == VT_NULL)
	{
		return 0;
	}
    return v1;
}


//-----------------------------------------------------------------------------
bool CWbemClassObject::GetBool(const _bstr_t& _Name)
{
	HRESULT hr;
	_variant_t v1;
	hr = Get (_Name, v1);
	if(v1.vt == VT_NULL)
	{
		return false;
	}
	return v1;
}


//-----------------------------------------------------------------------------
_bstr_t CWbemClassObject::GetCIMTYPE(const _bstr_t& _Name)
{
    IWbemQualifierSetPtr pQualifierSet;
    _bstr_t              sRet;

    if(m_pWbemObject->GetPropertyQualifierSet(_Name, &pQualifierSet) == S_OK)
    {
        _variant_t vt;

        if(pQualifierSet->Get(_bstr_t("CIMTYPE"), 0, &vt, NULL) == S_OK)
        {
            sRet = vt;
        }
    }

    return sRet;
}


//-----------------------------------------------------------------------------
CWbemClassObject CWbemClassObject::GetEmbeddedObject(const _bstr_t& _Name)
{
    CWbemClassObject    coRet;
    HRESULT             hr;

    _variant_t v1;

    hr = Get(_Name,v1);

    if(hr == S_OK)
    {
        if(v1.vt == VT_UNKNOWN)
        {
            coRet = (IWbemClassObject*) v1.punkVal;
        }
    }

    return coRet;
}


//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::PutEmbeddedObject(const _bstr_t& _Name,
											CWbemClassObject &obj)
{
	HRESULT hr = S_OK;
	IWbemClassObject *temp = obj;
	LPUNKNOWN pUnk = 0;

	if(temp)
	{
		hr = temp->QueryInterface(IID_IUnknown, (void**)&pUnk);
		if(SUCCEEDED(hr))
		{
			_variant_t v1((IUnknown *)pUnk);

			hr = Put(_Name, v1);
		}
	}

	return hr;
}

//--------------------------------------------------------------------------
HRESULT CWbemClassObject::GetBLOB(const _bstr_t& _Name,
									BYTE **ptr,
									DWORD *outLen)
{
	void* pVoid;
	variant_t vValue;
  	SAFEARRAY* sa;
	DWORD len = 0;

	HRESULT hr = Get(_Name, vValue);

	// if got a BYTE array back....
	if(SUCCEEDED(hr) &&
		(vValue.vt & VT_ARRAY) &&
		(vValue.vt & VT_UI1))
	{
		// get it out.
		sa = V_ARRAY(&vValue);

		long lLowerBound = 0, lUpperBound = 0 ;

		SafeArrayGetLBound(sa, 1, &lLowerBound);
		SafeArrayGetUBound(sa, 1, &lUpperBound);

		len = lUpperBound - lLowerBound + 1;

		if(ptr)
		{
			// I want an null ptr ptr.
			if(*ptr)
			{
				hr = E_FAIL;
			}
			else
			{
  				 // Get a pointer to read the data into.
				*ptr = (LPBYTE)LocalAlloc(LPTR, len);
				if(*ptr != NULL)
				{
 					SafeArrayAccessData(sa, &pVoid);
					memcpy(*ptr, pVoid, len);
  					SafeArrayUnaccessData(sa);

					if(outLen)
						*outLen = len;

					hr = S_OK;
				}
				else
				{
					hr = E_FAIL;
				}
			}
		}
	}
	return hr;
}

//--------------------------------------------------------------------------
HRESULT CWbemClassObject::PutBLOB(const _bstr_t& _Name,
								const BYTE *ptr,
								const DWORD len)
{
	variant_t vValue;
	HRESULT hr = E_FAIL;
	void *pBuf = 0;

	// got something to do?
	if(ptr)
	{
		// set the UINT8 array for the BLOB.
		SAFEARRAY* sa;
		SAFEARRAYBOUND rgsabound[1];

		rgsabound[0].cElements = len;
		rgsabound[0].lLbound = 0;
		sa = SafeArrayCreate(VT_UI1, 1, rgsabound);

 		 // Get a pointer to read the data into
      	SafeArrayAccessData(sa, &pBuf);
      	memcpy(pBuf, ptr, rgsabound[0].cElements);
      	SafeArrayUnaccessData(sa);

		// Put the safearray into a variant, and send it off
		V_VT(&vValue) = VT_UI1 | VT_ARRAY;
		V_ARRAY(&vValue) = sa;

		hr = Put(_Name, vValue);
	}
	return hr;
}

//----------------------------------------------------------------------
HRESULT CWbemClassObject::GetDIB(const _bstr_t& _Name, HDC hDC,
								 HBITMAP &hDDBitmap)
{

	//NOTE: THIS DOESN'T WORK YET.

	variant_t blob;

	HRESULT hr = Get(_Name, blob);

	// if got a BYTE array back....
	if(SUCCEEDED(hr) &&
		(blob.vt & VT_ARRAY) &&
		(blob.vt & VT_UI1))
	{
		BITMAPFILEHEADER *lpFile;
		BYTE *blobData;
		DWORD len = 0;

		// get it out.
		SAFEARRAY *sa = V_ARRAY(&blob);

		// go right to the bytes.
 		SafeArrayAccessData(sa, (void **)&blobData);

		// cast to FileHeader
		lpFile = (BITMAPFILEHEADER *)blobData;

		// is it a DIB?
		if(lpFile->bfType == 0x4d42)	/* 'BM' */
		{
			DWORD bfileSize = lpFile->bfOffBits;
			BITMAPINFOHEADER *lpInfo;

			// pt to the BITMAPINFO which immediately follows the BITMAPFILEHEADER.
			lpInfo = (BITMAPINFOHEADER *)blobData + sizeof(BITMAPFILEHEADER);

			// let this guy do the work.
			hDDBitmap = CreateDIBitmap(hDC,
										(LPBITMAPINFOHEADER)lpInfo,
										CBM_INIT,
										(LPSTR)lpInfo + lpInfo->biSize + PaletteSize(lpInfo),
										(BITMAPINFO *)lpInfo,
										DIB_RGB_COLORS);
		}
		else
		{
			hDDBitmap = 0;
			hr = WBEM_E_TYPE_MISMATCH;  // not a DIB.
		}

  		SafeArrayUnaccessData(sa);

		hr = S_OK;
	}

    return hr;
}

//-------------------------------------------------------------------
WORD CWbemClassObject::PaletteSize(LPBITMAPINFOHEADER lpbi)
{
    WORD NumColors = DibNumColors(lpbi);

    if(lpbi->biSize == sizeof(BITMAPCOREHEADER))
	{
        return (WORD)(NumColors * sizeof(RGBTRIPLE));
	}
    else
	{
        return (WORD)(NumColors * sizeof(RGBQUAD));
	}
}

//-------------------------------------------------------------------
WORD CWbemClassObject::DibNumColors(LPBITMAPINFOHEADER lpbi)
{
    int bits = 0;
    LPBITMAPCOREHEADER  lpbc = (LPBITMAPCOREHEADER)lpbi;

    /*  With the BITMAPINFO format headers, the size of the palette
     *  is in biClrUsed, whereas in the BITMAPCORE - style headers, it
     *  is dependent on the bits per pixel ( = 2 raised to the power of
     *  bits/pixel).
     */
    if(lpbi->biSize != sizeof(BITMAPCOREHEADER))
	{
        if (lpbi->biClrUsed != 0)
            return (WORD)lpbi->biClrUsed;

        bits = lpbi->biBitCount;
    }
    else
	{
        bits = lpbc->bcBitCount;
	}

    switch(bits)
	{
        case 1: return 2;
        case 4: return 16;
        case 8: return 256;
        default: return 0;  /* A 24 bitcount DIB has no color table */
    }
}

//-------------------------------------------------------------------
HRESULT CWbemClassObject::GetValueMap(const _bstr_t& _Name,
									  long value,
									  _bstr_t &str)
{
    HRESULT hrMap, hr = WBEM_E_NOT_FOUND;
    _variant_t vArray, vMapArray;
	IWbemQualifierSet *qual = NULL;

	// get the qualifiers.
    hr = m_pWbemObject->GetPropertyQualifierSet(_Name, &qual);
	if(SUCCEEDED(hr) && qual)
	{
		// see if there's a valueMap.
		hrMap = qual->Get(L"ValueMap", 0, &vMapArray, NULL);

		// get the Value qualifier.
		hr = qual->Get(L"Values", 0, &vArray, NULL);
		if(SUCCEEDED(hr) && (vArray.vt == (VT_BSTR|VT_ARRAY)))
		{
			// get the property value we're mapping.
		    long index;

			// do we need to walk through the valueMap?
			if(SUCCEEDED(hrMap))
			{
				SAFEARRAY *pma = V_ARRAY(&vMapArray);
				long lLowerBound = 0, lUpperBound = 0 ;

				SafeArrayGetLBound(pma, 1, &lLowerBound);
				SafeArrayGetUBound(pma, 1, &lUpperBound);

				for(long x = lLowerBound; x <= lUpperBound; x++)
				{
					BSTR vMap;
					SafeArrayGetElement(pma, &x, &vMap);
					long vInt = _ttol((LPCTSTR)vMap);

					if(value == vInt)
					{
						index = x;
						break; // found it.
					}
				} //endfor
			}
			else
			{
				index = value;
			}

			// lookup the string.
			SAFEARRAY *psa = V_ARRAY(&vArray);
			long ix[1] = {index};
			BSTR str2;
			hr = SafeArrayGetElement(psa, ix, &str2);
			if(SUCCEEDED(hr))
			{
				str = str2;
				SysFreeString(str2);
				hr = S_OK;
			}
			else
			{
				hr = WBEM_E_VALUE_OUT_OF_RANGE;
			}
		}
		qual->Release();
	}
	return hr;
}

//-----------------------------------------------------------
#define ITSA_BAD_PREFIX -3
#define ITSA_GOT_LETTERS -2
#define ITSA_MISSING_DECIMAL -1
#define ITSA_WRONG_SIZE 0
#define ITSA_DATETIME 1
#define ITSA_INTERVAL 2

int CWbemClassObject::ValidDMTF(bstr_t dmtf)
{
    int retval = ITSA_DATETIME;
	TCHAR wszText[26] = {0};

	_tcscpy(wszText, (LPCTSTR)dmtf);

    if(_tcslen(wszText) != 25)
        retval = ITSA_WRONG_SIZE; // wrong size.

    else if(wszText[14] != _T('.'))
        retval = ITSA_MISSING_DECIMAL;   // missing decimal

    else if(_tcsspn(wszText, _T("0123456789-+:.")) != 25)
        retval = ITSA_GOT_LETTERS;

    else if(retval > 0)
    {
        if(wszText[21] == _T('+'))
            retval = ITSA_DATETIME;
        else if(wszText[21] == _T('-'))
            retval = ITSA_DATETIME;
        else if(wszText[21] == _T(':'))
            retval = ITSA_INTERVAL;
        else
            retval = ITSA_BAD_PREFIX;   // wrong utc prefix.
    }
    return retval;
}

//-----------------------------------------------------------
HRESULT CWbemClassObject::GetDateTimeFormat(const _bstr_t& _Name,
											bstr_t &timeStr)
{
    int v = 0;
	HRESULT hr = WBEM_E_NOT_FOUND;

	SYSTEMTIME st, local;
	TCHAR temp[100] = {0};

	bstr_t dmtf = GetString(_Name);

    // validate it.
    if((v = ValidDMTF(dmtf)) == ITSA_DATETIME)
    {
		_stscanf(dmtf, _T("%4hu%2hu%2hu%2hu%2hu%2hu"),
					&st.wYear, &st.wMonth, &st.wDay,
					&st.wHour, &st.wMinute, &st.wSecond);

		st.wMilliseconds = 0;

		// its always GMT so localize it.
		TIME_ZONE_INFORMATION tzi;
		DWORD zone = GetTimeZoneInformation(&tzi);

		if(SystemTimeToTzSpecificLocalTime(&tzi, &st, &local) == 0)
		{
			// argh 9x, we're on our own.
			LARGE_INTEGER UTC_FT, local_FT, bias;

			// failed cuz its 9x so GetTzInfo() return behavior is "obvious".
			bias.QuadPart = Int32x32To64((zone == TIME_ZONE_ID_DAYLIGHT ?
												(tzi.Bias + tzi.DaylightBias)*60 :
												(tzi.Bias + tzi.StandardBias)*60), // Bias in seconds
											10000000);

			// convert the UTC systemtime to UTC filetime.
			if(SystemTimeToFileTime(&st, (LPFILETIME)&UTC_FT))
			{
				// now we can trust the math.
				local_FT.QuadPart = UTC_FT.QuadPart - bias.QuadPart;

				if(!FileTimeToSystemTime((LPFILETIME)&local_FT, &local))
				{
					// failed. Pass through UTC.
					memcpy(&local, &st, sizeof(SYSTEMTIME));
				}
			}
			else
			{
				// failed. Pass through UTC.
				memcpy(&local, &st, sizeof(SYSTEMTIME));
			}
		}

		DWORD chUsed = GetDateFormat(NULL, 0, &local, NULL, temp, 100);

		if(chUsed <= 0)
		{
			hr = HRESULT_FROM_WIN32(chUsed);
		}
		else
		{
			temp[chUsed-1] = _T(' ');
			chUsed = GetTimeFormat(NULL, TIME_NOSECONDS, &local, NULL, &(temp[chUsed]), 100 - chUsed);
			//claim victory.

			if(chUsed <= 0)
			{
				hr = HRESULT_FROM_WIN32(chUsed);
			}
			else
			{
				timeStr = temp;
				hr = S_OK;
			}
		}
    }
	else
	{
		hr = WBEM_E_TYPE_MISMATCH;
	}

    return hr;
}

//-----------------------------------------------------------------------------
// these cast string props fm the parm.
HRESULT CWbemClassObject::PutEx(const _bstr_t& _Name, const long _value, CIMTYPE vType)
{
	_variant_t test;
	HRESULT hr = Get(_Name, test);

	// it wants a string...
	if(test.vt == VT_BSTR)
	{
		TCHAR temp[40] = {0};
		_ltot(_value, temp, 10);
		return Put(_Name, (bstr_t)temp);
	}
	else
		return Put(_Name, (long)_value);

}

//-----------------------------------------------------------------------------
HRESULT CWbemClassObject::PutEx(const _bstr_t& _Name, const bool _value,CIMTYPE vType)
{
	_variant_t test;
	HRESULT hr = Get(_Name, test);

	// it wants a string...
	if(test.vt == VT_BSTR)
	{
		bstr_t temp = (_value? _T("1"):_T("0"));
		return Put(_Name, temp);
	}
	else
		return Put(_Name, (long)_value);

}

//-----------------------------------------------------------------------------
long CWbemClassObject::GetLongEx(const _bstr_t& _Name)
{
	_variant_t _value(0L);
	HRESULT hr = Get(_Name, _value);

	if(FAILED(hr))
		return 0;
	if(_value.vt == VT_BSTR)
	{
		bstr_t temp = V_BSTR(&_value);
		return _ttol(temp);
	}
	else if (_value.vt == VT_NULL)
		return 0;
	else
		return _value;
}

//-----------------------------------------------------------------------------
bool CWbemClassObject::GetBoolEx(const _bstr_t& _Name)
{
	_variant_t _value;
	HRESULT hr = Get(_Name, _value);

	if(_value.vt == VT_BSTR)
	{
		LPWSTR temp = V_BSTR(&_value);
		return (temp[0] != L'0');
	}
	else if (_value.vt == VT_NULL)
		return false;
	else
		return _value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\util.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "util.h"
#include "shlwapi.h"

//----------------------------------------------------------------
HRESULT Extract(IDataObject *_DO, wchar_t* fmt, wchar_t* data)
{
    HGLOBAL     hMem = GlobalAlloc(GMEM_SHARE,1024);
    wchar_t	*pRet = NULL;
	HRESULT hr = 0;

    if(hMem != NULL)
    {
		memset(hMem, 0, 1024);
        STGMEDIUM stgmedium = { TYMED_HGLOBAL, (HBITMAP) hMem};

		CLIPFORMAT regFmt = (CLIPFORMAT)RegisterClipboardFormat(fmt);

        FORMATETC formatetc = { regFmt,
								NULL,
								DVASPECT_CONTENT,
								-1,
								TYMED_HGLOBAL };

        if((hr = _DO->GetDataHere(&formatetc, &stgmedium)) == S_OK )
        {
            wcscpy(data, (wchar_t*)hMem);
        }

		GlobalFree(hMem);
    }

    return hr;
}

HRESULT Extract(IDataObject *_DO, wchar_t* fmt, bstr_t &data)
{
	wchar_t temp[1024];
	memset(temp, 0, 1024 * sizeof(wchar_t));

	HRESULT hr = Extract(_DO, fmt, temp);
	data = temp;
	return hr;
}
///////////////////////////////////////////////////////////////////////////////
//
// FUNCTION: Int64ToString
//
// DESCRIPTION:
//    Converts the numeric value of a _int64 to a text string.
//    The string may optionally be formatted to include decimal places
//    and commas according to current user locale settings.
//
// ARGUMENTS:
//    n
//       The 64-bit integer to format.
//
//    szOutStr
//       Address of the destination buffer.
//
//    nSize
//       Number of characters in the destination buffer.
//
//    bFormat
//       TRUE  = Format per locale settings.
//       FALSE = Leave number unformatted.
//
//    pFmt
//       Address of a number format structure of type NUMBERFMT.
//       If NULL, the function automatically provides this information
//       based on the user's default locale settings.
//
//    dwNumFmtFlags
//       Encoded flag word indicating which members of *pFmt to use in
//       formatting the number.  If a bit is clear, the user's default
//       locale setting is used for the corresponding format value.  These
//       constants can be OR'd together.
//
//          NUMFMT_IDIGITS
//          NUMFMT_ILZERO
//          NUMFMT_SGROUPING
//          NUMFMT_SDECIMAL
//          NUMFMT_STHOUSAND
//          NUMFMT_INEGNUMBER
//
///////////////////////////////////////////////////////////////////////////////
INT WINAPI Int64ToString(_int64 n, LPTSTR szOutStr, UINT nSize, BOOL bFormat,
                                   NUMBERFMT *pFmt, DWORD dwNumFmtFlags)
{
   INT nResultSize;
   TCHAR szBuffer[_MAX_PATH + 1] = {0};
   NUMBERFMT NumFmt;
   TCHAR szDecimalSep[5] = {0};
   TCHAR szThousandSep[5] = {0};

   //
   // Use only those fields in caller-provided NUMBERFMT structure
   // that correspond to bits set in dwNumFmtFlags.  If a bit is clear,
   // get format value from locale info.
   //
   if (bFormat)
   {
      TCHAR szInfo[20] = {0};

      if (NULL == pFmt)
         dwNumFmtFlags = 0;  // Get all format data from locale info.

      if (dwNumFmtFlags & NUMFMT_IDIGITS)
      {
         NumFmt.NumDigits = pFmt->NumDigits;
      }
      else
      {
         GetLocaleInfo(LOCALE_USER_DEFAULT,
						LOCALE_IDIGITS,
						szInfo,
						ARRAYSIZE(szInfo));
		_stscanf(szInfo, _T("%ld"), &(NumFmt.NumDigits));

//        NumFmt.NumDigits = StrToLong(szInfo);
      }

      if (dwNumFmtFlags & NUMFMT_ILZERO)
      {
         NumFmt.LeadingZero = pFmt->LeadingZero;
      }
      else
      {
         GetLocaleInfo(LOCALE_USER_DEFAULT,
						LOCALE_ILZERO,
						szInfo,
						ARRAYSIZE(szInfo));
		_stscanf(szInfo, _T("%ld"), &(NumFmt.LeadingZero));

//         NumFmt.LeadingZero = StrToLong(szInfo);
      }

      if (dwNumFmtFlags & NUMFMT_SGROUPING)
      {
         NumFmt.Grouping = pFmt->Grouping;
      }
      else
      {
         GetLocaleInfo(LOCALE_USER_DEFAULT,
						LOCALE_SGROUPING,
						szInfo,
						ARRAYSIZE(szInfo));
		_stscanf(szInfo, _T("%ld"), &(NumFmt.Grouping));

//         NumFmt.Grouping = StrToLong(szInfo);
      }

      if (dwNumFmtFlags & NUMFMT_SDECIMAL)
      {
         NumFmt.lpDecimalSep = pFmt->lpDecimalSep;
      }
      else
      {
         GetLocaleInfo(LOCALE_USER_DEFAULT,
						LOCALE_SDECIMAL,
						szDecimalSep,
						ARRAYSIZE(szDecimalSep));
         NumFmt.lpDecimalSep = szDecimalSep;
      }

      if (dwNumFmtFlags & NUMFMT_STHOUSAND)
      {
         NumFmt.lpThousandSep = pFmt->lpThousandSep;
      }
      else
      {
         GetLocaleInfo(LOCALE_USER_DEFAULT,
						LOCALE_STHOUSAND,
						szThousandSep,
						ARRAYSIZE(szThousandSep));
         NumFmt.lpThousandSep = szThousandSep;
      }

      if (dwNumFmtFlags & NUMFMT_INEGNUMBER)
      {
         NumFmt.NegativeOrder = pFmt->NegativeOrder;
      }
      else
      {
         GetLocaleInfo(LOCALE_USER_DEFAULT,
						LOCALE_INEGNUMBER,
						szInfo,
						ARRAYSIZE(szInfo));


		_stscanf(szInfo, _T("%ld"), &(NumFmt.NegativeOrder));
//         NumFmt.NegativeOrder  = StrToLong(szInfo);
      }

      pFmt = &NumFmt;
   }

   Int64ToStr( n, szBuffer);

   //
   //  Format the number string for the locale if the caller wants a
   //  formatted number string.
   //
   if (bFormat)
   {
      if ( 0 != ( nResultSize = GetNumberFormat( LOCALE_USER_DEFAULT,  // User's locale
                                         0,                            // No flags
                                         szBuffer,                     // Unformatted number string
                                         pFmt,                         // Number format info
                                         szOutStr,                     // Output buffer
                                         nSize )) )                    // Chars in output buffer.
      {
          //  Remove nul terminator char from return size count.
          --nResultSize;
      }
	  else
	  {
		//
		//  GetNumberFormat call failed, so just return the number string
		//  unformatted.
		//
		DWORD err = GetLastError();
		lstrcpyn(szOutStr, szBuffer, nSize);
		nResultSize = lstrlen(szOutStr);
	  }
   }
   else
   {
	   // a-khint; give it back raw.
		lstrcpyn(szOutStr, szBuffer, nSize);
		nResultSize = lstrlen(szOutStr);
   }
   return nResultSize;
}
//---------------------------------------------------------------
void Int64ToStr( _int64 n, LPTSTR lpBuffer)
{
    TCHAR   szTemp[MAX_INT64_SIZE] = {0};
    _int64  iChr;

    iChr = 0;

    do {
        szTemp[iChr++] = TEXT('0') + (TCHAR)(n % 10);
        n = n / 10;
    } while (n != 0);

    do {
        iChr--;
        *lpBuffer++ = szTemp[iChr];
    } while (iChr != 0);

    *lpBuffer++ = '\0';
}

//---------------------------------------------------------------
// takes a DWORD add commas etc to it and puts the result in the buffer
LPTSTR WINAPI AddCommas64(_int64 n, LPTSTR pszResult)
{
    TCHAR  szTemp[MAX_COMMA_NUMBER_SIZE] = {0};
    TCHAR  szSep[5] = {0};
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, ARRAYSIZE(szSep));
	_stscanf(szSep, _T("%d"), &(nfmt.Grouping));
//    nfmt.Grouping = StrToInt(szSep);
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

    Int64ToStr(n, szTemp);

    if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszResult, ARRAYSIZE(szTemp)) == 0)
        lstrcpy(pszResult, szTemp);

    return pszResult;
}

//----------------------------------------------------------------------
// takes a DWORD add commas etc to it and puts the result in the buffer
LPTSTR WINAPI AddCommas(DWORD dw, LPTSTR pszResult)
{
    return AddCommas64( dw, pszResult );
}

//----------------------------------------------------------------------
long StrToLong(LPTSTR x)
{
	long val;
	_stscanf(x, _T("%ld"), &val);

	return val;
}

//----------------------------------------------------------------------
/*
int StrToInt(LPTSTR x)
{
	int val;
	_stscanf(x, _T("%d"), &val);

	return val;
}


//----------------------------------------------------------------------
#define LEN_MID_ELLIPSES        4
#define LEN_END_ELLIPSES        3
#define MIN_CCHMAX              LEN_MID_ELLIPSES + LEN_END_ELLIPSES

// PathCompactPathEx
// Output:
//          "."
//          ".."
//          "..."
//          "...\"
//          "...\."
//          "...\.."
//          "...\..."
//          "...\Truncated filename..."
//          "...\whole filename"
//          "Truncated path\...\whole filename"
//          "Whole path\whole filename"
// The '/' might be used instead of a '\' if the original string used it
// If there is no path, but only a file name that does not fit, the output is:
//          "truncated filename..."

BOOL MyPathCompactPathEx(LPTSTR  pszOut,
						LPCTSTR pszSrc,
						UINT    cchMax,
						DWORD   dwFlags)
{
    if(pszSrc)
    {
        TCHAR * pszFileName, *pszWalk;
        UINT uiFNLen = 0;
        int cchToCopy = 0, n;
        TCHAR chSlash = TEXT('0');

        ZeroMemory(pszOut, cchMax * sizeof(TCHAR));

        if((UINT)lstrlen(pszSrc)+1 < cchMax)
        {
            lstrcpy(pszOut, pszSrc);
            ATLASSERT(pszOut[cchMax-1] == TEXT('\0'));
            return TRUE;
        }

        // Determine what we use as a slash - a / or a \ (default \)
        pszWalk = (TCHAR*)pszSrc;
        chSlash = TEXT('\\');
        // Scan the entire string as we want the path separator closest to the end
        // eg. "file://\\Themesrv\desktop\desktop.htm"
        while(*pszWalk)
        {
            if((*pszWalk == TEXT('/')) || (*pszWalk == TEXT('\\')))
                chSlash = *pszWalk;

            pszWalk = FAST_CharNext(pszWalk);
        }

        pszFileName = PathFindFileName(pszSrc);
        uiFNLen = lstrlen(pszFileName);

        // if the whole string is a file name
        if(pszFileName == pszSrc && cchMax > LEN_END_ELLIPSES)
        {
            lstrcpyn(pszOut, pszSrc, cchMax - LEN_END_ELLIPSES);
#ifndef UNICODE
            if(IsTrailByte(pszSrc, pszSrc+cchMax-LEN_END_ELLIPSES))
                *(pszOut+cchMax-LEN_END_ELLIPSES-1) = TEXT('\0');
#endif
            lstrcat(pszOut, TEXT("..."));
            ASSERT(pszOut[cchMax-1] == TEXT('\0'));
            return TRUE;
        }

        // Handle all the cases where we just use ellipses ie '.' to '.../...'
        if((cchMax < MIN_CCHMAX))
        {
            for(n = 0; n < (int)cchMax-1; n++)
            {
                if((n+1) == LEN_MID_ELLIPSES)
                    pszOut[n] = chSlash;
                else
                    pszOut[n] = TEXT('.');
            }
            ASSERT(0==cchMax || pszOut[cchMax-1] == TEXT('\0'));
            return TRUE;
        }

        // Ok, how much of the path can we copy ? Buffer - (Lenght of MID_ELLIPSES + Len_Filename)
        cchToCopy = cchMax - (LEN_MID_ELLIPSES + uiFNLen);
        if (cchToCopy < 0)
            cchToCopy = 0;
#ifndef UNICODE
        if (cchToCopy > 0 && IsTrailByte(pszSrc, pszSrc+cchToCopy))
            cchToCopy--;
#endif

        lstrcpyn(pszOut, pszSrc, cchToCopy);

        // Now throw in the ".../" or "...\"
        lstrcat(pszOut, TEXT(".../"));
        pszOut[lstrlen(pszOut) - 1] = chSlash;

        //Finally the filename and ellipses if necessary
        if(cchMax > (LEN_MID_ELLIPSES + uiFNLen))
        {
            lstrcat(pszOut, pszFileName);
        }
        else
        {
            cchToCopy = cchMax - LEN_MID_ELLIPSES - LEN_END_ELLIPSES;
#ifndef UNICODE
            if(cchToCopy >0 && IsTrailByte(pszFileName, pszFileName+cchToCopy))
                cchToCopy--;
#endif
            lstrcpyn(pszOut + LEN_MID_ELLIPSES, pszFileName, cchToCopy);
            lstrcat(pszOut, TEXT("..."));
        }
        ASSERT(pszOut[cchMax-1] == TEXT('\0'));
        return TRUE;
    }
    return FALSE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\unsecwrap.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
class CUnsecWrap
{
protected:
    IWbemObjectSink* m_pSink;
    IWbemObjectSink* m_pWrapper;
    
    static IUnsecuredApartment* mstatic_pApartment;

protected:
    static void Init()
    {
        if(mstatic_pApartment == NULL)
        {
            HRESULT hres = CoCreateInstance(CLSID_UnsecuredApartment, NULL, 
                            CLSCTX_ALL,
                            IID_IUnsecuredApartment, 
                            (void**)&mstatic_pApartment);
        }
    }
public:
    CUnsecWrap(IWbemObjectSink* pSink) : 
			m_pSink(pSink), 
			m_pWrapper(NULL)
    {
        m_pSink->AddRef();
        Init();
    }
    ~CUnsecWrap()
    {
        m_pSink->Release();
        if(m_pWrapper)
            m_pWrapper->Release();
    }

    operator IWbemObjectSink*()
    {
        if(m_pWrapper)
            return m_pWrapper;
        
        IUnknown* pUnk;
        mstatic_pApartment->CreateObjectStub(m_pSink, &pUnk);
        pUnk->QueryInterface(IID_IWbemObjectSink, (void**)&m_pWrapper);
        pUnk->Release();
        return m_pWrapper;
    }
};
        
IUnsecuredApartment* CUnsecWrap::mstatic_pApartment = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\ansi\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\wbempagehelper.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __WBEMPAGEHELPER__
#define __WBEMPAGEHELPER__

#pragma once

#include "..\common\SshWbemHelpers.h"
#include "..\common\ServiceThread.h"

#define SCB_FROMFILE     (0x1)
#define SCB_REPLACEONLY  (0x2)
#define CLOSE_SNAPIN	0xfdfd

#define WBEM_ENABLE             ( 0x0001 )   
#define WBEM_METHOD_EXECUTE     ( 0x0002 )   
#define WBEM_FULL_WRITE_REP     ( 0x001c )   
#define WBEM_PARTIAL_WRITE_REP  ( 0x0008 )   
#define WBEM_WRITE_PROVIDER     ( 0x0010 )   

class WBEMPageHelper
{
public:
	IWbemServices *m_service;
	CWbemServices m_WbemServices;
	bool m_okPressed;
	HWND m_hDlg;
	bool m_userCancelled; // the connectServer() thread.
	HWND m_AVIbox;

	WBEMPageHelper(CWbemServices &service);
	WBEMPageHelper(WbemServiceThread *serviceThread);

	virtual ~WBEMPageHelper();

	CWbemClassObject ExchangeInstance(IWbemClassObject **ppbadInst);

	virtual bool GetOnOkPressed(void) {return m_okPressed;};

	// get the first instance of the named class.
	IWbemClassObject *FirstInstanceOf(bstr_t className);

	static LPTSTR CloneString( LPTSTR pszSrc );

	BOOL SetClearBitmap(HWND control, 
						LPCTSTR resource, 
						UINT fl);

	void HourGlass( bool bOn );

	int MsgBoxParam(HWND hWnd, 
					DWORD wText, 
					DWORD wCaption, 
					DWORD wType,
					LPTSTR var1 = NULL,
					LPTSTR var2 = NULL);

	DWORD SetLBWidthEx(HWND hwndLB, 
						LPTSTR szBuffer, 
						DWORD cxCurWidth, 
						DWORD cxExtra);

	void SetDefButton(HWND hwndDlg, 
						int idButton);

	void SetDlgItemMB(HWND hDlg, 
						int idControl, 
						ULONG dwMBValue );

	void SetWbemService(IWbemServices *pServices);

#define NO_UI 0  // for uCaption
	bool ServiceIsReady(UINT uCaption, 
						UINT uWaitMsg,
						UINT uBadMsg);

	HRESULT Reboot(UINT flags = EWX_REBOOT,
				   long *retval = NULL);

	
	HRESULT RemoteRegWriteable(const _bstr_t regPath,
								BOOL& writable);

	bool HasPerm(DWORD mask);
	bool HasPriv(LPCTSTR privName);

	static BOOL g_fRebootRequired;
	WbemServiceThread *g_serviceThread;

private:
	// these support efficiency in RemoteRegWriteable().
	CWbemClassObject m_checkAccessIn;
	CWbemClassObject m_checkAccessOut;
	CWbemServices m_defaultNS;
};

#endif __WBEMPAGEHELPER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\unicode\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\sshwbemhelpers.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#if !defined(__SdkWbemHelpers_H)
#define      __SdkWbemHelpers_H
#pragma once

#if defined(_SDKWBEMHELPERS) || defined(_BUILD_SDKWBEMHELPERS)
#undef SMSSDK_Export

    #if defined(_BUILD_SDKWBEMHELPERS)
        #define SMSSDK_Export __declspec(dllexport)
    #else
        #define SMSSDK_Export __declspec(dllimport)
    #endif
#else
    #define SMSSDK_Export
#endif

#include <wbemidl.h>
#include <comdef.h>

SMSSDK_Export _bstr_t GetWbemErrorText(HRESULT hr);


class CWbemClassObject;
class CWbemServices;



_COM_SMARTPTR_TYPEDEF(IUnsecuredApartment,          IID_IUnsecuredApartment);
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink,              IID_IWbemObjectSink);
_COM_SMARTPTR_TYPEDEF(IWbemClassObject,             IID_IWbemClassObject);
_COM_SMARTPTR_TYPEDEF(IWbemServices,                IID_IWbemServices);
_COM_SMARTPTR_TYPEDEF(IWbemContext,                 IID_IWbemContext );
_COM_SMARTPTR_TYPEDEF(IWbemCallResult,              IID_IWbemCallResult);
_COM_SMARTPTR_TYPEDEF(IWbemQualifierSet,            IID_IWbemQualifierSet);
_COM_SMARTPTR_TYPEDEF(IWbemLocator,                 IID_IWbemLocator);
_COM_SMARTPTR_TYPEDEF(IWbemObjectAccess,            IID_IWbemObjectAccess);
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject,         IID_IEnumWbemClassObject);


//-----------------------------------------------------------------------------
class SMSSDK_Export CWbemException : public _com_error
{
private:
    CWbemClassObject *  m_pWbemError;
    HRESULT             m_hr;
    _bstr_t             m_sDescription;

    static IErrorInfo * GetErrorObject();
    static IErrorInfo * MakeErrorObject(_bstr_t);
    void GetWbemStatusObject();

public:
    CWbemException(HRESULT hr,_bstr_t sMessage);
    CWbemException(_bstr_t sMessage);

    CWbemClassObject GetWbemError();

    _bstr_t GetDescription() { return m_sDescription;  }
    HRESULT GetErrorCode()   { return m_hr;            }
};


//-----------------------------------------------------------------------------
class SMSSDK_Export CWbemClassObject
{
private:
    IWbemClassObjectPtr     m_pWbemObject;
	ULONG ref;
public:
	CWbemClassObject(const CWbemClassObject&  _in);
	CWbemClassObject(IWbemClassObject * const _in);
    CWbemClassObject(IWbemClassObjectPtr& _in);
    CWbemClassObject(IUnknown * _in);
    CWbemClassObject(IUnknownPtr& _in);
	CWbemClassObject();
    ~CWbemClassObject();

    ULONG AddRef();
    ULONG Release();

    void Attach(IWbemClassObject * pWbemObject);
    void Attach(IWbemClassObject * pWbemObject,bool bAddRef);
    IWbemClassObject * Detach();

    IWbemClassObject * operator->();
    operator IWbemClassObject*();
    operator IWbemClassObject**();
    operator IWbemClassObjectPtr();
	operator IUnknown *();
    IWbemClassObject ** operator &();
	IWbemClassObject* operator=(IWbemClassObject* _p);
	IWbemClassObjectPtr operator=(IWbemClassObjectPtr& _p);
	IWbemClassObject* operator=(IUnknown * _p);
	IWbemClassObjectPtr operator=(IUnknownPtr& _p);
	IWbemClassObject* operator=(const CWbemClassObject& _p);

    bool operator<(const CWbemClassObject& _comp);

    bool IsNull() const ;
    bool operator !();
    operator bool();

    unsigned long GetObjectSize();
    _bstr_t GetObjectText();

    HRESULT Clone(CWbemClassObject& _newObject);
    CWbemClassObject SpawnInstance();

	// put overloads
    HRESULT Put(const _bstr_t& _Name,_variant_t _value,CIMTYPE vType = 0);
    HRESULT Put(const _bstr_t& _Name,const _bstr_t& _value,CIMTYPE vType = 0);
	HRESULT Put(const _bstr_t& _Name, const long _value, CIMTYPE vType = 0);
	HRESULT Put(const _bstr_t& _Name, const bool _value,CIMTYPE vType = 0);
    HRESULT Get(const _bstr_t& _Name, _bstr_t& _value);
	HRESULT Get(const _bstr_t& _Name, long& _value);
	HRESULT Get(const _bstr_t& _Name, bool& _value);
    HRESULT Get(const _bstr_t& _Name,_variant_t& _value);
    _variant_t Get(const _bstr_t& _Name,CIMTYPE& vType,long& lFlavor);

    _bstr_t GetString(const _bstr_t& _Name);
    _int64  GetI64(const _bstr_t& _Name);
    long    GetLong(const _bstr_t& _Name);
	bool    GetBool(const _bstr_t& _Name);
    _bstr_t GetCIMTYPE(const _bstr_t& _Name);
	HRESULT GetValueMap (const _bstr_t& _Name, long value, _bstr_t &str);

	// these cast string props to the retval.
    long    GetLongEx(const _bstr_t& _Name);
	bool    GetBoolEx(const _bstr_t& _Name);
	// these cast string props fm the parm.
	HRESULT PutEx(const _bstr_t& _Name, const long _value, CIMTYPE vType = 0);
	HRESULT PutEx(const _bstr_t& _Name, const bool _value,CIMTYPE vType = 0);
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    CWbemClassObject GetEmbeddedObject(const _bstr_t& _Name);
    HRESULT PutEmbeddedObject(const _bstr_t& _Name, CWbemClassObject &obj);

	HRESULT GetBLOB(const _bstr_t& _Name, BYTE **ptr, DWORD *outLen = NULL);
	HRESULT PutBLOB(const _bstr_t& _Name, const BYTE *ptr, const DWORD len);
	HRESULT GetDateTimeFormat(const _bstr_t& _Name, bstr_t &timeStr);
	HRESULT GetDIB(const _bstr_t& _Name, HDC hDC, HBITMAP &hDDBitmap);

    HRESULT BeginEnumeration(long _lFlags = WBEM_FLAG_LOCAL_ONLY);
    HRESULT Next(_bstr_t& _sName,_variant_t& _value);
    HRESULT Next(_bstr_t& _sName,_variant_t& _value,CIMTYPE& _vartype);
    HRESULT Next(_bstr_t& _sName,_variant_t& _value,CIMTYPE& _vartype,long& _flavor);
    HRESULT EndEnumeration();

	HRESULT GetMethod(const IN _bstr_t& _name, CWbemClassObject& coInSignature,
								CWbemClassObject& coOutSignature, long _lFlags = 0);


private:
	int ValidDMTF(bstr_t dmtf);

	// helpers for GetDIB().
	WORD DibNumColors(LPBITMAPINFOHEADER lpbi);
	WORD PaletteSize(LPBITMAPINFOHEADER lpbi);

};


__inline bool operator<(const CWbemClassObject& _X,const CWbemClassObject& _Y)
{
    return _X < _Y;
}

__inline bool operator==(const CWbemClassObject& _X,const CWbemClassObject& _Y)
{
    return _X == _Y;
}

//-----------------------------------------------------------------------------
typedef struct {
	bool currUser;
	COAUTHIDENTITY *authIdent;
	TCHAR fullAcct[100];
} LOGIN_CREDENTIALS;

class SMSSDK_Export CWbemServices 
{
private:

    HRESULT GetInterfacePtr(IWbemServicesPtr & pServices,
                            DWORD _dwProxyCapabilities = EOAC_NONE);
    HRESULT CommonInit(IWbemServicesPtr& pServ);
	bool IsClientNT5OrMore(void);
	HANDLE m_hAccessToken;
	LUID m_luid;
	bool m_fClearToken;
public:
	bool m_cloak;  // protects the cloak from eoac.
	COAUTHIDENTITY *m_authIdent;
	_bstr_t m_path;
    HRESULT m_hr;
    IWbemServicesPtr m_pService;
    IWbemContextPtr     m_pCtx;

	_bstr_t m_User;
	_bstr_t m_Password;
	long m_lFlags;

	CWbemServices(IWbemContext * _pContext = NULL);
    CWbemServices(const CWbemServices& _p, COAUTHIDENTITY *authIdent = 0);
	CWbemServices(const IWbemServicesPtr& _in);
    CWbemServices(const IUnknownPtr& _in);
    CWbemServices(IUnknown * _in);
	CWbemServices(IWbemServices *_in,IWbemContext * _pContext = NULL);
    
	~CWbemServices();

    CWbemServices& operator=(IUnknown * _p);
    CWbemServices& operator=(IUnknownPtr& _p);
	CWbemServices& operator=(IWbemServices *_p);
	CWbemServices& operator=(const CWbemServices& _p);

    bool IsNull()  ;
    operator bool();

    HRESULT GetServices(IWbemServices ** ppServices);
	HRESULT SetBlanket(IUnknown *service,
                       DWORD _dwProxyCapabilities = EOAC_NONE);
	void SetPriv(LPCTSTR privName = SE_SYSTEM_ENVIRONMENT_NAME);
	DWORD EnablePriv(bool fEnable );
	void ClearPriv(void);

    // Login as guest...
    HRESULT ConnectServer(_bstr_t sNetworkResource);
    // Login as user...
    HRESULT ConnectServer(_bstr_t sNetworkResource,
							_bstr_t sUser,
							_bstr_t sPassword,
							long SecurityFlags = 0);

    HRESULT ConnectServer(_bstr_t sNetworkResource,
							LOGIN_CREDENTIALS *user,
							long lSecurityFlags = 0);

    CWbemServices OpenNamespace(_bstr_t sNetworkResource);
	void DisconnectServer(void);

	CWbemClassObject CreateInstance(_bstr_t _sClass, IWbemCallResultPtr& _cr);
	CWbemClassObject CreateInstance(_bstr_t _sClass);

	HRESULT DeleteInstance(_bstr_t _sClass);

    CWbemClassObject GetObject(_bstr_t _sName, IWbemCallResultPtr &_cr, long flags = 0);
    CWbemClassObject GetObject(_bstr_t _sName, long flags = 0);
	IWbemClassObject *FirstInstanceOf(bstr_t className);

    HRESULT PutInstance(CWbemClassObject&   _object, IWbemCallResultPtr& _cr,
						long _lFlags = WBEM_FLAG_CREATE_OR_UPDATE);
	HRESULT PutInstance(CWbemClassObject&   _object,
                        IWbemContext *pContext,
                        long _lFlags = WBEM_FLAG_CREATE_OR_UPDATE,
                        DWORD _dwProxyCapabilities = EOAC_NONE);

    HRESULT PutInstance(CWbemClassObject&   _object,
                        long _lFlags = WBEM_FLAG_CREATE_OR_UPDATE,
                        DWORD _dwProxyCapabilities = EOAC_NONE);

    HRESULT CreateInstanceEnum(_bstr_t Class, long lFlags, IEnumWbemClassObject **ppEnum);
    HRESULT CreateInstanceEnumAsync(_bstr_t Class, IWbemObjectSink * ppSink, long lFlags = 0);

    HRESULT CreateClassEnum(_bstr_t Class, long lFlags, IEnumWbemClassObject **ppEnum);
	
    HRESULT ExecQuery(_bstr_t QueryLanguage,_bstr_t Query, long lFlags, IEnumWbemClassObject **ppEnum);
    HRESULT ExecQuery(_bstr_t Query, long lFlags, IEnumWbemClassObject **ppEnum);
    HRESULT ExecQuery(_bstr_t Query, IEnumWbemClassObject **ppEnum) ;
    HRESULT ExecQueryAsync(_bstr_t Query, IWbemObjectSink *pSink, long lFlags = 0);

    HRESULT GetMethodSignatures(const _bstr_t& _sObjectName,
								const _bstr_t& _sMethodName,
								CWbemClassObject& _in,
								CWbemClassObject& _out);
    HRESULT ExecMethod(_bstr_t sPath,
						_bstr_t sMethod,
						CWbemClassObject& inParams,
						CWbemClassObject& outParams);

    HRESULT CancelAsyncCall(IWbemObjectSink * pSink);

    HRESULT SetContextValue(_bstr_t sName,_variant_t value);
    HRESULT GetContextValue(_bstr_t sName,_variant_t& value);
	HRESULT DeleteContextValue(_bstr_t sName);
    HRESULT DeleteAllContextValues();
	HRESULT SetContext(IWbemContext * pWbemContext);
    HRESULT GetContext(IWbemContext ** ppWbemContext);
	HRESULT CreateClassEnumAsync(_bstr_t Class,
								IWbemObjectSink *ppSink,
								long lFlags /*= 0*/);

};


#endif //__SdkWbemHelpers_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\wbempagehelper.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "..\MMFUtil\MsgDlg.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "util.h"
#include "..\Common\ServiceThread.h"
#include "WBEMPageHelper.h"
#include <stdarg.h>


BOOL WBEMPageHelper::g_fRebootRequired = FALSE;

//------------------------------------------------
WBEMPageHelper::WBEMPageHelper(CWbemServices &service)

{
	m_service = 0;
	m_WbemServices = service;
	m_WbemServices.GetServices(&m_service);
	m_WbemServices.SetBlanket(m_service);

	m_okPressed = false;
	m_userCancelled = false;
	m_hDlg = NULL;
	m_AVIbox = 0;
}

//------------------------------------------------
WBEMPageHelper::WBEMPageHelper(WbemServiceThread *serviceThread)

{
	g_serviceThread = serviceThread;
	m_service = 0;
	if(g_serviceThread->m_status == WbemServiceThread::ready)
	{
		m_WbemServices = g_serviceThread->m_WbemServices;
		m_WbemServices.GetServices(&m_service);
		m_WbemServices.SetBlanket(m_service);
	}

	m_okPressed = false;
	m_userCancelled = false;
	m_hDlg = NULL;
	m_AVIbox = 0;
}

//------------------------------------------------
WBEMPageHelper::~WBEMPageHelper()
{
	// in case ServiceThread still has a ptr to this
	//   handle. It knows not to use NULL HWNDs.
	m_AVIbox = 0;
	m_hDlg = NULL;
	if(m_service)
	{
		m_service->Release();
		m_service = 0;
	}
	m_WbemServices.DisconnectServer();
}

//------------------------------------------------
CWbemClassObject WBEMPageHelper::ExchangeInstance(IWbemClassObject **ppbadInst)
{
	CWbemClassObject inst;
	_variant_t v1;

	if(SUCCEEDED((*ppbadInst)->Get(bstr_t("__PATH"), 0, &v1, NULL, NULL)))
	{
		inst = m_WbemServices.GetObject((_bstr_t) v1);
		(*ppbadInst)->Release();
		*ppbadInst = NULL;
	}
	return inst;
}
//------------------------------------------------
// get the first instance of the named class.
IWbemClassObject *WBEMPageHelper::FirstInstanceOf(bstr_t className)
{
	IWbemClassObject *pInst = NULL;
	ULONG uReturned;
	IEnumWbemClassObject *Enum = NULL;

	// get the class.
	if(SUCCEEDED(m_WbemServices.CreateInstanceEnum(className,
													WBEM_FLAG_SHALLOW,
													&Enum)))
	{
		// get the first and only instance.
		Enum->Next(-1, 1, &pInst, &uReturned);
		Enum->Release();
	}
	return pInst;
}

//---------------------------------------------------
LPTSTR WBEMPageHelper::CloneString( LPTSTR pszSrc )
{
    LPTSTR pszDst = NULL;

    if (pszSrc != NULL)
	{
        pszDst = new TCHAR[(lstrlen(pszSrc) + 1)];
        if (pszDst)
		{
            lstrcpy( pszDst, pszSrc );
        }
    }

    return pszDst;
}
//*************************************************************
//
//  SetClearBitmap()
//
//  Purpose:    Sets or clears an image in a static control.
//
//  Parameters: control  -   handle of static control
//              resource -   resource / filename of bitmap
//              fl       -   SCB_ flags:
//                SCB_FROMFILE      'resource' specifies a filename instead of a resource
//                SCB_REPLACEONLY   only put the new image up if there was an old one
//
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/24/95     ericflo    Ported
//
//*************************************************************

BOOL WBEMPageHelper::SetClearBitmap( HWND control,
									 LPCTSTR resource,
									 UINT fl )
{
    HBITMAP hbm = (HBITMAP)SendMessage(control, STM_GETIMAGE, IMAGE_BITMAP, 0);

    if( hbm )
    {
        DeleteObject( hbm );
    }
    else if( fl & SCB_REPLACEONLY )
    {
        return FALSE;
    }

    if( resource )
    {
        SendMessage(control, STM_SETIMAGE, IMAGE_BITMAP,
					(LPARAM)LoadImage(	HINST_THISDLL,
										resource,
										IMAGE_BITMAP,
										0, 0,
										LR_LOADTRANSPARENT | LR_LOADMAP3DCOLORS |
										( ( fl & SCB_FROMFILE )? LR_LOADFROMFILE : 0 ) )
					);
    }

    return
        ((HBITMAP)SendMessage(control, STM_GETIMAGE, IMAGE_BITMAP, 0) != NULL);
}

//------------------------------------------------------------
int WBEMPageHelper::MsgBoxParam(HWND hWnd,
								DWORD wText,
								DWORD wCaption,
								DWORD wType,
								LPTSTR var1,
								LPTSTR var2)
{
    TCHAR   szText[ 4 * MAX_PATH ] = {0}, szCaption[ 2 * MAX_PATH ] = {0};
    int     ival;

    if( !LoadString( HINST_THISDLL, wText, szCaption, ARRAYSIZE( szCaption ) ) )
	{
        return 0;
	}
	if(var2)
		wsprintf(szText, szCaption, var1, var2);
	else if(var1)
		wsprintf(szText, szCaption, var1);
	else
		wcscpy(szText, szCaption);

    if( !LoadString( HINST_THISDLL, wCaption, szCaption, ARRAYSIZE( szCaption ) ) )
	{
        return 0;
	}

    ival = MessageBox( hWnd, szText, szCaption, wType);

    return ival;
}

//------------------------------------------------------------
void WBEMPageHelper::HourGlass( bool bOn )
{
    if( !GetSystemMetrics( SM_MOUSEPRESENT ) )
        ShowCursor( bOn );

    SetCursor( LoadCursor( NULL, bOn ? IDC_WAIT : IDC_ARROW ) );
}

////////////////////////////////////////////////////////////////////////////
//  SetLBWidthEx
//
//  Set the width of the listbox, in pixels, acording to the size of the
//  string passed in.
//
//  Note: this function is also used by the Virtual Memory dialog
//
//  History:
//  11-Jan-1996 JonPa   Created from SetGenLBWidth
////////////////////////////////////////////////////////////////////////////

DWORD WBEMPageHelper::SetLBWidthEx( HWND hwndLB,
									LPTSTR szBuffer,
									DWORD cxCurWidth,
									DWORD cxExtra)
{
    HDC     hDC;
    SIZE    Size;
    HFONT   hfont, hfontOld;

    // Get the new Win4.0 thin dialog font
    hfont = (HFONT)SendMessage(hwndLB, WM_GETFONT, 0, 0);

    hDC = GetDC(hwndLB);

    // if we got a font back, select it in this clean hDC
    if (hfont != NULL)
        hfontOld = (HFONT)SelectObject(hDC, hfont);


    // If cxExtra is 0, then give our selves a little breathing space.
    if (cxExtra == 0)
	{
        GetTextExtentPoint(hDC, TEXT("1234"), 4 , &Size);
        cxExtra = Size.cx;
    }

    // Set scroll width of listbox
    GetTextExtentPoint(hDC, szBuffer, lstrlen(szBuffer), &Size);

    Size.cx += cxExtra;

    // Get the name length and adjust the longest name
    if ((DWORD) Size.cx > cxCurWidth)
    {
        cxCurWidth = Size.cx;
        SendMessage (hwndLB, LB_SETHORIZONTALEXTENT, (DWORD)Size.cx, 0L);
    }

    // retstore the original font if we changed it.
    if (hfont != NULL)
        SelectObject(hDC, hfontOld);

    ReleaseDC(NULL, hDC);

    return cxCurWidth;

	return 1; // bs
}
//---------------------------------------------------
void WBEMPageHelper::SetDefButton(HWND hwndDlg,
								  int idButton)
{
    LRESULT lr;

    if(HIWORD(lr = SendMessage(hwndDlg, DM_GETDEFID, 0, 0)) == DC_HASDEFID)
    {
        HWND hwndOldDefButton = GetDlgItem(hwndDlg, LOWORD(lr));

        SendMessage (hwndOldDefButton,
                     BM_SETSTYLE,
                     MAKEWPARAM(BS_PUSHBUTTON, 0),
                     MAKELPARAM(TRUE, 0));
    }

    SendMessage( hwndDlg, DM_SETDEFID, idButton, 0L );
    SendMessage( GetDlgItem(hwndDlg, idButton),
                 BM_SETSTYLE,
                 MAKEWPARAM( BS_DEFPUSHBUTTON, 0 ),
                 MAKELPARAM( TRUE, 0 ));
}

//-------------------------------------------------------------------
void WBEMPageHelper::SetDlgItemMB( HWND hDlg,
								  int idControl,
								  ULONG dwMBValue )
{
    TCHAR szBuf[20] = {0};
    wsprintf(szBuf, _T("%u MB"), dwMBValue);
    SetDlgItemText(hDlg, idControl, szBuf);
}

//--------------------------------------------------------------
void WBEMPageHelper::SetWbemService(IWbemServices *pServices)
{
	g_serviceThread->m_realServices = pServices;		//VINOTH
	m_WbemServices = pServices;
	if(g_serviceThread)
	{
		g_serviceThread->m_WbemServices = pServices;
	}
}

//--------------------------------------------------------------
bool WBEMPageHelper::ServiceIsReady(UINT uCaption /* = 0*/,
									UINT uWaitMsg,
									UINT uBadMsg)
{
	switch(g_serviceThread->m_status)
	{
	// its already there.
	case WbemServiceThread::ready:
		{
		ATLTRACE(L"start marshal\n");
		for(int i = 0; (i < 5); i++)
		{
			// if "Object is not connected to server"
			if(g_serviceThread->m_hr == 0x800401fd)
			{
				// lost my connection,
				ATLTRACE(_T("Reconnecting to cimom!!!!!!!!!!!\n"));
				g_serviceThread->ReConnect();
				ATLTRACE(_T("new service status: %d\n"), g_serviceThread->m_status);
				continue;
			}
			else if(FAILED(g_serviceThread->m_hr))
			{
				// some other problem.
				g_serviceThread->m_WbemServices = (IWbemServices *)NULL;
				g_serviceThread->m_status = WbemServiceThread::error;
			}


			ATLTRACE(_T("marshalled ok\n"));
			break;

		} //endfor

		if(m_AVIbox)
		{
			PostMessage(m_AVIbox,
						WM_ASYNC_CIMOM_CONNECTED,
						0, 0);
			m_AVIbox = 0;
		}
		// it marshaled, must still be connected/useable.
		return true;
		}
		break;

	// its coming.
	case WbemServiceThread::notStarted:
	case WbemServiceThread::locating:
	case WbemServiceThread::connecting:
		{
			// let me know when its there.
			g_serviceThread->NotifyWhenDone(&m_hDlg);

			// also kill the cancel box at that time.
			m_AVIbox = 0;
			g_serviceThread->NotifyWhenDone(&m_AVIbox);

			if(uCaption != NO_UI)
			{
				TCHAR caption[100] = {0}, msg[256] = {0};

				::LoadString(HINST_THISDLL, uCaption,
								caption, 100);

				::LoadString(HINST_THISDLL, uWaitMsg,
								msg, 256);

                m_userCancelled = false;

				if(DisplayAVIBox(m_hDlg, caption, msg, &m_AVIbox) == IDCANCEL)
				{
					g_serviceThread->Cancel();
					m_userCancelled = true;
				}
			}
		}
		return false;
		break;

	case WbemServiceThread::error:			// cant connect.
	case WbemServiceThread::threadError:	// cant start that thread.
	default:
		if(::IsWindow(m_AVIbox))
		{
			PostMessage(m_AVIbox,
						WM_ASYNC_CIMOM_CONNECTED,
						0, 0);
			m_AVIbox = 0;
		}

		if(uCaption != NO_UI)
		{
			DisplayUserMessage(m_hDlg, HINST_THISDLL,
								uCaption, BASED_ON_SRC,
								ConnectServer,
								g_serviceThread->m_hr,
								MB_ICONSTOP);
		}
		return false;

	}; //endswitch
}

//----------------------------------------------------
HRESULT WBEMPageHelper::Reboot(UINT flags,
							   long *retval)
{
	HRESULT hr = WBEM_E_PROVIDER_NOT_FOUND;
	bstr_t path;
	CWbemClassObject paramCls;

	// need to class def to get the method signature.
	paramCls = m_WbemServices.GetObject("Win32_OperatingSystem");

	if(paramCls)
	{
		// get the method signature. dummy wont actually be used.
		CWbemClassObject dummy, inSig;

		hr = paramCls.GetMethod(L"Win32Shutdown",
									inSig, dummy);

		// if got a good signature....
		if((bool)inSig)
		{
			// find the OperatingSystem for the current service ptr.
			IWbemClassObject *pInst = NULL;
			pInst = FirstInstanceOf("Win32_OperatingSystem");
			if(pInst)
			{
				// wrap it for convenience.
				CWbemClassObject OS(pInst);
				path = OS.GetString(_T("__PATH"));

				// fill in the values.
				inSig.Put(_T("Flags"), (const long)flags);
				inSig.Put(_T("Reserved"), (long)0);

				// adjust privilege.
				m_WbemServices.SetPriv(SE_SHUTDOWN_NAME);

				// now call the method.
				hr = m_WbemServices.ExecMethod(path, L"Win32Shutdown",
												inSig, dummy);

				m_WbemServices.ClearPriv();

				// did the caller want the ReturnValue.
				if(SUCCEEDED(hr) && (bool)dummy && retval)
				{
					// NOTE: this guy return STATUS codes.
					*retval = dummy.GetLong(_T("ReturnValue"));
				}
			}
		}
	} //endif paramCls
	return hr;
}

//---------------------------------------------------------------
bool WBEMPageHelper::HasPriv(LPCTSTR privName)
{
    ImpersonateSelf(SecurityImpersonation);
	HANDLE hAccessToken = 0;
	bool retval = false;

	if(OpenThreadToken(GetCurrentThread(),
						TOKEN_QUERY,
						FALSE, &hAccessToken))
	{
		DWORD dwLen;
		TOKEN_PRIVILEGES bogus;

		// guaranteed to fail. Just figuring the size.
		GetTokenInformation(hAccessToken, TokenPrivileges,
								&bogus, 1, &dwLen);

	    BYTE* pBuffer = new BYTE[dwLen];
		if(pBuffer != NULL)
		{
			if(GetTokenInformation(hAccessToken, TokenPrivileges,
									pBuffer, dwLen, &dwLen))
			{
				TOKEN_PRIVILEGES* pPrivs = (TOKEN_PRIVILEGES*)pBuffer;
				LUID luidTgt;
				LookupPrivilegeValue(NULL, privName, &luidTgt);

				for(DWORD i = 0; i < pPrivs->PrivilegeCount; i++)
				{
					if((pPrivs->Privileges[i].Luid.LowPart == luidTgt.LowPart) &&
						(pPrivs->Privileges[i].Luid.HighPart == luidTgt.HighPart))
					{
						retval = true;
						break;
					}
				}
			}
			delete [] pBuffer;
		}
		CloseHandle(hAccessToken);
	}
	else
	{
		DWORD err = GetLastError();
	}
	return retval;
}

//---------------------------------------------------------------
bool WBEMPageHelper::HasPerm(DWORD mask)
{
	// call the method..
	CWbemClassObject _in;
	CWbemClassObject _out;
	bool retval = true;
	// NOTE: for backwards compability with wmi builds that didn't have this
	// method, assume 'true' unless a newer build says you cant do this.

	HRESULT hr = m_WbemServices.GetMethodSignatures("__SystemSecurity",
													"GetCallerAccessRights",
													_in, _out);

	if(SUCCEEDED(hr))
	{
		hr = m_WbemServices.ExecMethod("__SystemSecurity",
										"GetCallerAccessRights",
										_in, _out);

		if(SUCCEEDED(hr) && (bool)_out)
		{
			hr = HRESULT_FROM_NT(_out.GetLong("ReturnValue"));
			if(SUCCEEDED(hr))
			{
				DWORD grantedMask = 0;
				grantedMask = (DWORD)_out.GetLong("Rights");

				retval = (bool)((mask & (DWORD)grantedMask) != 0);
			}
		}
	}
	return retval;
}



extern WbemServiceThread *g_serviceThread;

//--------------------------------------------------------------
HRESULT WBEMPageHelper::RemoteRegWriteable(const _bstr_t regPath,
											BOOL& writable)
{
	HRESULT hr = E_FAIL;

	// if not even connected yet...
	if(!(bool)m_defaultNS)
	{
		bstr_t defaultName;

		// already whacked...
		if(wcsncmp((wchar_t *)g_serviceThread->m_machineName, _T("\\"), 1) == 0)
		{
			// use it.
			defaultName = g_serviceThread->m_machineName;
			defaultName += "\\root\\default";
		}
		else if(g_serviceThread->m_machineName.length() > 0) // not whacked but remote...
		{
			// whack it myself.
			defaultName = "\\\\";
			defaultName += g_serviceThread->m_machineName;
			defaultName += "\\root\\default";
		}
		else  // must be local
		{
			defaultName = "root\\default";
		}

		m_defaultNS.ConnectServer(defaultName);

	}

	// do we need the signatures?
	if((bool)m_defaultNS && !(bool)m_checkAccessIn)
	{
		hr = m_defaultNS.GetMethodSignatures("StdRegProv", "CheckAccess",
												m_checkAccessIn,
												m_checkAccessOut);
	}
	// got connection and signatures already?
	if((bool)m_defaultNS && (bool)m_checkAccessIn)
	{
		// fill in the parms.
		m_checkAccessIn.Put("sSubKeyName", regPath);
		m_checkAccessIn.Put("uRequired", KEY_WRITE);

		// call.
        hr = m_defaultNS.ExecMethod("StdRegProv", "CheckAccess",
										m_checkAccessIn,
										m_checkAccessOut);

		// ExecMethod() itself worked.
		if(SUCCEEDED(hr))
		{
			// did CheckAccess() work.
			HRESULT hr1 = HRESULT_FROM_NT(m_checkAccessOut.GetLong("ReturnValue"));
			if(FAILED(hr1))
			{
				hr = hr1;
			}
			else
			{
				writable = m_checkAccessOut.GetBool("bGranted");
			}
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\wbemversion.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "stdpch.h"
#include "..\common\WbemVersion.h"
#include "..\common\Util.h"

//----------------------------------------------------------------------
LONG GetCimomFileName(LPTSTR filename, UINT size)
{
	HKEY hkeyLocalMachine;
	LONG lResult;
	lResult = RegConnectRegistry(NULL, HKEY_LOCAL_MACHINE, 
									&hkeyLocalMachine);
	if(lResult != ERROR_SUCCESS) 
	{
		return lResult;
	}

	HKEY hkeyHmomCwd;

	lResult = RegOpenKeyEx(hkeyLocalMachine,
							_T("SOFTWARE\\Microsoft\\WBEM\\CIMOM"),
							0,				
							KEY_READ | KEY_QUERY_VALUE,
							&hkeyHmomCwd);
	
	if(lResult != ERROR_SUCCESS) 
	{
		RegCloseKey(hkeyLocalMachine);
		return lResult;
	}

	BYTE buf[MAX_PATH];
	unsigned long lcbValue = MAX_PATH;
	unsigned long lType;

	lResult = RegQueryValueEx(hkeyHmomCwd,
								_T("Working Directory"), 
								NULL, &lType,
								buf, &lcbValue);
 
	RegCloseKey(hkeyHmomCwd);
	RegCloseKey(hkeyLocalMachine);

	TCHAR cimomName[20] = {0};
	wcscpy(cimomName, _T("\\cimom.exe"));

	if((lResult == ERROR_SUCCESS) &&
	   ((lcbValue + sizeof(cimomName)) <= size))
	{
		wcscpy(filename, (TCHAR *)buf);
		wcscat(filename, cimomName);
	}
	return lResult;
}

//----------------------------------------------------------------------
bstr_t GetDoubleVersion(void)
{
	//    <myversion/cimomVer>
	TCHAR filename[200] = {0};

	GetModuleFileName(HINST_THISDLL, filename, sizeof(filename));
	bstr_t DoubleVersion = GetStringFileInfo(filename, _T("FileVersion"));

	// append cimom's version.
	DoubleVersion += _T("\\");
	DoubleVersion += GetCimomVersion();
	return DoubleVersion;
}

//----------------------------------------------------------------------
bstr_t GetMyVersion(void)
{
	TCHAR filename[200] = {0};
	GetModuleFileName(HINST_THISDLL, filename, sizeof(filename));
	return GetStringFileInfo(filename, _T("FileVersion"));
}

//----------------------------------------------------------------------
bstr_t GetMyCompany(void)
{
	TCHAR filename[MAX_PATH] = {0};
	GetModuleFileName(HINST_THISDLL, filename, sizeof(filename));
	return GetStringFileInfo(filename, _T("CompanyName"));
}

//----------------------------------------------------------------------
bstr_t GetCimomVersion(void)
{
	TCHAR filename[MAX_PATH] = {0};
	//if the wbem key, etc is there...
	if(GetCimomFileName(filename, sizeof(filename)) == ERROR_SUCCESS)
	{
		return GetStringFileInfo(filename, _T("FileVersion"));
	}
	return "No CIMOM";
}

//----------------------------------------------------------------------
bstr_t GetStringFileInfo(LPCTSTR filename, LPCTSTR key)
{
	_bstr_t sDesc("Unknown");

	DWORD infoSize = 0;
	UINT  valSize = 0;
	LPBYTE info = NULL;
	DWORD handle = 0;
	LPVOID verStr = NULL;
	DWORD *TransBlk = NULL;
	TCHAR blockStr[100] = {0};

	infoSize = GetFileVersionInfoSize((LPTSTR)filename, &handle);

	if(infoSize)
	{
		info = new BYTE[infoSize];

		if(GetFileVersionInfo((LPTSTR)filename, handle,
								infoSize, info))
		{
			// get the translation block.
			// NOTE: This assumes that the localizers REPLACE the english with
			// the 'other' language so there will only be ONE entry in the
			// translation table. If we ever do a single binary that supports
			// multiple languages, it's a whole nother ballgame folks.
			if(VerQueryValue(info, _T("\\VarFileInfo\\Translation"),
								(void **)&TransBlk, &valSize))
			{

			   swprintf(blockStr, _T("\\StringFileInfo\\%04hX%04hX\\%s"),
						 LOWORD(*TransBlk),
						 HIWORD(*TransBlk),
						 key);

				if(VerQueryValue(info, (LPTSTR)blockStr,
									(void **)&verStr, &valSize))
				{
					sDesc = (TCHAR *)verStr;
				} //endif VerQueryValue()
			}

		} //endif GetFileVersionInfo()

		delete[] (LPBYTE)info;

	} // endif infoSize

	return sDesc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\common\wbemversion.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __WBEMVERSION__
#define __WBEMVERSION__
#pragma once

// version resource helpers.
bstr_t GetDoubleVersion(void);
bstr_t GetMyVersion(void);
bstr_t GetMyCompany(void);
bstr_t GetCimomVersion(void);
bstr_t GetStringFileInfo(LPCTSTR filename, LPCTSTR key);
LONG GetCimomFileName(LPTSTR filename, UINT size);

#endif __WBEMVERSION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\inc\snapins.inc\rpcasync.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    rpcasync.h

Abstract:

    This module contains the RPC runtime APIs needed to use
    [async] RPC features.

--*/

#ifndef __RPCASYNC_H__
#define __RPCASYNC_H__

#pragma message("rpcasync in snapins")

#ifdef __cplusplus
extern "C" {
#endif

#define RPC_ASYNC_VERSION_1_0     sizeof(RPC_ASYNC_STATE)

typedef
enum _RPC_NOTIFICATION_TYPES
{
    RpcNotificationTypeNone,
    RpcNotificationTypeEvent,
    RpcNotificationTypeApc, 
    RpcNotificationTypeIoc,
    RpcNotificationTypeHwnd,
    RpcNotificationTypeCallback
} RPC_NOTIFICATION_TYPES;

typedef
enum _RPC_ASYNC_EVENT {
    RpcCallComplete,
    RpcSendComplete,
    RpcReceiveComplete
    } RPC_ASYNC_EVENT;

typedef void RPC_ENTRY
RPCNOTIFICATION_ROUTINE (
                  struct _RPC_ASYNC_STATE *pAsync,
                  void *Context,                              
                  RPC_ASYNC_EVENT Event);
typedef RPCNOTIFICATION_ROUTINE *PFN_RPCNOTIFICATION_ROUTINE;
    
typedef struct _RPC_ASYNC_STATE {
    unsigned int    Size; // size of this structure
    unsigned long   Signature;
    long   Lock;
    unsigned long   Flags;
    void           *StubInfo;
    void           *UserInfo;
    void           *RuntimeInfo;
    RPC_ASYNC_EVENT Event;

    RPC_NOTIFICATION_TYPES NotificationType;
    union {
        //
        // Notification by APC
        //
        struct {
            PFN_RPCNOTIFICATION_ROUTINE NotificationRoutine;
            HANDLE hThread;
            } APC;

        //
        // Notification by IO completion port
        //
        struct {
            HANDLE hIOPort;
            DWORD dwNumberOfBytesTransferred;
            DWORD dwCompletionKey;
            LPOVERLAPPED lpOverlapped;
            } IOC;

        //
        // Notification by window message
        //
        struct {
            HWND hWnd;
            UINT Msg;
            } HWND;


        //
        // Notification by event
        //
        HANDLE hEvent;

        //
        // Notification by callback function
        //
        // This option is available only to OLE
        //
        PFN_RPCNOTIFICATION_ROUTINE NotificationRoutine;
        } u;

    long Reserved[4]; 
    } RPC_ASYNC_STATE, *PRPC_ASYNC_STATE;

// Possible values for Flags
#define RPC_C_NOTIFY_ON_SEND_COMPLETE      0x1
#define RPC_C_INFINITE_TIMEOUT             INFINITE

#define RpcAsyncGetCallHandle(pAsync) (((PRPC_ASYNC_STATE) pAsync)->RuntimeInfo)

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncInitializeHandle (
    PRPC_ASYNC_STATE pAsync,
    unsigned int     Size
    );
                      
RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncRegisterInfo (
    PRPC_ASYNC_STATE pAsync
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncGetCallStatus (
    PRPC_ASYNC_STATE pAsync
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncCompleteCall (
    PRPC_ASYNC_STATE pAsync,
    void *Reply
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncAbortCall (
    PRPC_ASYNC_STATE pAsync,
    unsigned long ExceptionCode
    ) ;

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcAsyncCancelCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN BOOL fAbort
    ) ;

//
// Internal APIs
//
RPC_STATUS RPC_ENTRY
I_RpcAsyncSetHandle (
    IN  PRPC_MESSAGE Message,
    IN  PRPC_ASYNC_STATE pAsync
    );

RPC_STATUS RPC_ENTRY
I_RpcAsyncAbortCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN unsigned long ExceptionCode
    ) ;


//
// This stuff is in here so we don't break ole, stubs and the tests
// remove before we ship
//
#define RpcInitializeAsyncHandle  RpcAsyncInitializeHandle
#define RpcRegisterAsyncInfo  RpcAsyncRegisterInfo
#define RpcGetAsyncCallStatus  RpcAsyncGetCallStatus
#define RpcCompleteAsyncCall  RpcAsyncCompleteCall
#define RpcAbortAsyncCall  RpcAsyncAbortCall
#define RpcCancelAsyncCall  RpcAsyncCancelCall
#define I_RpcSetAsyncHandle  I_RpcAsyncSetHandle
#define I_RpcAbortAsyncCall  I_RpcAsyncAbortCall

#ifdef __cplusplus
}
#endif

#endif /* __RPCASYNC_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\aclui.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) 1994-1999 Microsoft Corporation
//
//  File:       aclui.h
//
//  Contents:   Definitions and prototypes for the ACLUI.DLL
//
//---------------------------------------------------------------------------

#ifndef _ACLUI_H_
#define _ACLUI_H_

#include <objbase.h>
#include <commctrl.h>   // for HPROPSHEETPAGE


#if !defined(_ACLUI_)
#define ACLUIAPI    DECLSPEC_IMPORT WINAPI
#else
#define ACLUIAPI    WINAPI
#endif

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

//
// ISecurityInformation interface
//
//  Methods:
//
//     GetObjectInformation - Allows UI to determine type of object being
//       edited.  Also allows determining if object is a container.
//
//     GetSecurity - Allows retrieving of ACLs from the original object
//                       NOTE: ACLUI will LocalFree the security descriptor
//                       returned by GetSecurity.
//     SetSecurity - Allows setting of the ACLs on the original object
//
//     GetAccessRights - For retrieving the list of rights allowed
//              on this object.
//
//     MapGeneric - For mapping generic rights to standard & specific rights
//
//     GetInheritTypes - For retrieving the list of possible sub-object types
//              for a container.
//
//     PropertySheetCallback - A method which is called back during the various
//              security UI property pages so that specialized work can be
//              done.  Similar to PropSheetPageProc.  If uMsg == PSPCB_CREATE,
//              then any error return value other than E_NOTIMPL will abort
//              the creation of that page.  The type of page being created or
//              destroyed is indicated by the uPage parameter.
//

typedef struct _SI_OBJECT_INFO
{
    DWORD       dwFlags;
    HINSTANCE   hInstance;          // resources (e.g. strings) reside here
    LPWSTR      pszServerName;      // must be present
    LPWSTR      pszObjectName;      // must be present
    LPWSTR      pszPageTitle;       // only valid if SI_PAGE_TITLE is set
    DWORD       dwUgopServer;       // only valid if SI_UGOP_PROVIDED is set
    DWORD       dwUgopOther;        // only valid if SI_UGOP_PROVIDED is set
} SI_OBJECT_INFO, *PSI_OBJECT_INFO;

// SI_OBJECT_INFO flags
#define SI_EDIT_PERMS       0x00000000L // always implied
#define SI_EDIT_OWNER       0x00000001L
#define SI_EDIT_AUDITS      0x00000002L
#define SI_CONTAINER        0x00000004L
#define SI_READONLY         0x00000008L
#define SI_ADVANCED         0x00000010L
#define SI_RESET            0x00000020L
#define SI_OWNER_READONLY   0x00000040L
#define SI_EDIT_PROPERTIES  0x00000080L
#define SI_OWNER_RECURSE    0x00000100L
#define SI_NO_ACL_PROTECT   0x00000200L
#define SI_NO_TREE_APPLY    0x00000400L
#define SI_PAGE_TITLE       0x00000800L
#define SI_SERVER_IS_DC     0x00001000L
#define SI_UGOP_PROVIDED    0x00002000L
#define SI_RESET_DACL_TREE 0x00004000L
#define SI_RESET_SACL_TREE 0x00004000L

#define SI_EDIT_ALL     (SI_EDIT_PERMS | SI_EDIT_OWNER | SI_EDIT_AUDITS)


typedef struct _SI_ACCESS
{
    const GUID *pguid;
    ACCESS_MASK mask;
    LPCWSTR     pszName;            // may be resource ID
    DWORD       dwFlags;
} SI_ACCESS, *PSI_ACCESS;

// SI_ACCESS flags
#define SI_ACCESS_SPECIFIC  0x00010000L
#define SI_ACCESS_GENERAL   0x00020000L
#define SI_ACCESS_CONTAINER 0x00040000L // general access, container-only
#define SI_ACCESS_PROPERTY  0x00080000L
// ACE inheritance flags (CONTAINER_INHERIT_ACE, etc.) may also be set.
// They will be used as the inheritance when an access is turned on.

typedef struct _SI_INHERIT_TYPE
{
    const GUID *pguid;
    ULONG       dwFlags;
    LPCWSTR     pszName;            // may be resource ID
} SI_INHERIT_TYPE, *PSI_INHERIT_TYPE;

// SI_INHERIT_TYPE flags are a combination of INHERIT_ONLY_ACE,
// CONTAINER_INHERIT_ACE, and OBJECT_INHERIT_ACE.

typedef enum _SI_PAGE_TYPE
{
    SI_PAGE_PERM=0,
    SI_PAGE_ADVPERM,
    SI_PAGE_AUDIT,
    SI_PAGE_OWNER,
} SI_PAGE_TYPE;

// Message to PropertySheetPageCallback (in addition to
// PSPCB_CREATE and PSPCB_RELEASE)
#define PSPCB_SI_INITDIALOG	(WM_USER + 1)


#undef INTERFACE
#define INTERFACE   ISecurityInformation
DECLARE_INTERFACE_(ISecurityInformation, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (THIS_ PSI_OBJECT_INFO pObjectInfo ) PURE;
    STDMETHOD(GetSecurity) (THIS_ SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault ) PURE;
    STDMETHOD(SetSecurity) (THIS_ SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor ) PURE;
    STDMETHOD(GetAccessRights) (THIS_ const GUID* pguidObjectType,
                                DWORD dwFlags, // SI_EDIT_AUDITS, SI_EDIT_PROPERTIES
                                PSI_ACCESS *ppAccess,
                                ULONG *pcAccesses,
                                ULONG *piDefaultAccess ) PURE;
    STDMETHOD(MapGeneric) (THIS_ const GUID *pguidObjectType,
                           UCHAR *pAceFlags,
                           ACCESS_MASK *pMask) PURE;
    STDMETHOD(GetInheritTypes) (THIS_ PSI_INHERIT_TYPE *ppInheritTypes,
                                ULONG *pcInheritTypes ) PURE;
    STDMETHOD(PropertySheetPageCallback)(THIS_ HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage ) PURE;
};
typedef ISecurityInformation *LPSECURITYINFO;

// {965FC360-16FF-11d0-91CB-00AA00BBB723}
DEFINE_GUID(IID_ISecurityInformation, 0x965fc360, 0x16ff, 0x11d0, 0x91, 0xcb, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x23);

HPROPSHEETPAGE ACLUIAPI CreateSecurityPage( LPSECURITYINFO psi );
BOOL ACLUIAPI EditSecurity( HWND hwndOwner, LPSECURITYINFO psi );

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _ACLUI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\inc\snapins.inc\rpcndr.h ===
/*++

Copyright (c) 1992-1997 Microsoft Corporation

Module Name:

    rpcndr.h

Abstract:

    Definitions for stub data structures and prototypes of helper functions.

Author:

    DonnaLi (01-01-91)

Environment:

    DOS, Win 3.X, and Win/NT.

Revision History:

   DONNALI  08-29-91     Start recording history
   donnali  09-11-91     change conversion macros
   donnali  09-18-91     check in files for moving
   STEVEZ   10-15-91     Merge with NT tree
   donnali  10-28-91     add prototype
   donnali  11-19-91     bugfix for strings
   MIKEMON  12-17-91     DCE runtime API conversion
   donnali  03-24-92     change rpc public header f
   STEVEZ   04-04-92     add nsi include
   mikemon  04-18-92     security support and misc
   DovhH    04-24-24     Changed signature of <int>_from_ndr
                         (to unsigned <int>)
                         Added <base_type>_array_from_ndr routines
   RyszardK 06-17-93     Added support for hyper
   VibhasC  09-11-93     Created rpcndrn.h
   DKays    10-14-93     Fixed up rpcndrn.h MIDL 2.0
   RyszardK 01-15-94     Merged in the midl 2.0 changes from rpcndrn.h
   Stevebl  04-22-96     Hookole support changes to MIDL_*_INFO
   RyszardK 05-20-97     Added async support, started version at 450.

--*/

// This version of the rpcproxy.h file corresponds to MIDL version 3.3.106
// used with NT5 beta env from build #1574 on.

#ifndef __RPCNDR_H_VERSION__
#define __RPCNDR_H_VERSION__        ( 450 )
#endif // __RPCNDR_H_VERSION__


#ifndef __RPCNDR_H__
#define __RPCNDR_H__

#ifdef __REQUIRED_RPCNDR_H_VERSION__
    #if ( __RPCNDR_H_VERSION__ < __REQUIRED_RPCNDR_H_VERSION__ )
        #error incorrect <rpcndr.h> version. Use the header that matches with the MIDL compiler.
    #endif 
#endif

#pragma message("rpcndr in snapins")

//
// Set the packing level for RPC structures for Dos, Windows and Mac.
//

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__) || defined(__RPC_MAC__)
#pragma pack(2)
#endif

#if defined(__RPC_MAC__)
#define _MAC_
#endif

#include <rpcnsip.h>

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************

     Network Computing Architecture (NCA) definition:

     Network Data Representation: (NDR) Label format:
     An unsigned long (32 bits) with the following layout:

     3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
     1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
    +---------------+---------------+---------------+-------+-------+
    |   Reserved    |   Reserved    |Floating point | Int   | Char  |
    |               |               |Representation | Rep.  | Rep.  |
    +---------------+---------------+---------------+-------+-------+

     Where

         Reserved:

             Must be zero (0) for NCA 1.5 and NCA 2.0.

         Floating point Representation is:

             0 - IEEE
             1 - VAX
             2 - Cray
             3 - IBM

         Int Rep. is Integer Representation:

             0 - Big Endian
             1 - Little Endian

         Char Rep. is Character Representation:

             0 - ASCII
             1 - EBCDIC

     The Microsoft Local Data Representation (for all platforms which are
     of interest currently is edefined below:

 ****************************************************************************/

#define NDR_CHAR_REP_MASK               (unsigned long)0X0000000FL
#define NDR_INT_REP_MASK                (unsigned long)0X000000F0L
#define NDR_FLOAT_REP_MASK              (unsigned long)0X0000FF00L

#define NDR_LITTLE_ENDIAN               (unsigned long)0X00000010L
#define NDR_BIG_ENDIAN                  (unsigned long)0X00000000L

#define NDR_IEEE_FLOAT                  (unsigned long)0X00000000L
#define NDR_VAX_FLOAT                   (unsigned long)0X00000100L

#define NDR_ASCII_CHAR                  (unsigned long)0X00000000L
#define NDR_EBCDIC_CHAR                 (unsigned long)0X00000001L

#if defined(__RPC_MAC__)
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000000L
#define NDR_LOCAL_ENDIAN                NDR_BIG_ENDIAN
#else
#define NDR_LOCAL_DATA_REPRESENTATION   (unsigned long)0X00000010L
#define NDR_LOCAL_ENDIAN                NDR_LITTLE_ENDIAN
#endif


/****************************************************************************
 *  Macros for targeted platforms
 ****************************************************************************/

#if (0x500 <= _WIN32_WINNT)
#define TARGET_IS_NT50_OR_LATER                   1
#else
#define TARGET_IS_NT50_OR_LATER                   0
#endif

#if (defined(_WIN32_DCOM) || 0x400 <= _WIN32_WINNT)
#define TARGET_IS_NT40_OR_LATER                   1
#else
#define TARGET_IS_NT40_OR_LATER                   0
#endif

#if (0x400 <= WINVER)
#define TARGET_IS_NT351_OR_WIN95_OR_LATER         1
#else
#define TARGET_IS_NT351_OR_WIN95_OR_LATER         0
#endif

/****************************************************************************
 *  Other MIDL base types / predefined types:
 ****************************************************************************/

#define small char
typedef unsigned char byte;
typedef unsigned char boolean;

#ifndef _HYPER_DEFINED
#define _HYPER_DEFINED

#if !defined(__RPC_DOS__) && !defined(__RPC_WIN16__) && !defined(__RPC_MAC__) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
#define  hyper           __int64
#define MIDL_uhyper  unsigned __int64
#else
typedef double  hyper;
typedef double MIDL_uhyper;
#endif

#endif // _HYPER_DEFINED

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

#ifdef __RPC_DOS__
#define __RPC_CALLEE       __far __pascal
#endif

#ifdef __RPC_WIN16__
#define __RPC_CALLEE       __far __pascal __export
#endif

#ifdef __RPC_WIN32__
#if   (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define __RPC_CALLEE       __stdcall
#else
#define __RPC_CALLEE
#endif
#endif

#ifdef __RPC_MAC__
#define __RPC_CALLEE __far
#endif

#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void             __RPC_USER MIDL_user_free( void __RPC_FAR * );

#ifdef __RPC_WIN16__
#define RPC_VAR_ENTRY __export __cdecl
#else
#define RPC_VAR_ENTRY __cdecl
#endif


/* winnt only */
#if defined(_M_MRX000) || defined(_M_IX86) || defined(_M_ALPHA)
#define __MIDL_DECLSPEC_DLLIMPORT   __declspec(dllimport)
#define __MIDL_DECLSPEC_DLLEXPORT   __declspec(dllexport)
#else
#define __MIDL_DECLSPEC_DLLIMPORT
#define __MIDL_DECLSPEC_DLLEXPORT
#endif




/****************************************************************************
 * Context handle management related definitions:
 *
 * Client and Server Contexts.
 *
 ****************************************************************************/

typedef void __RPC_FAR * NDR_CCONTEXT;

typedef struct
    {
    void __RPC_FAR * pad[2];
    void __RPC_FAR * userContext;
    } __RPC_FAR * NDR_SCONTEXT;

#define NDRSContextValue(hContext) (&(hContext)->userContext)

#define cbNDRContext 20         /* size of context on WIRE */

typedef void (__RPC_USER __RPC_FAR * NDR_RUNDOWN)(void __RPC_FAR * context);

typedef struct _SCONTEXT_QUEUE {
    unsigned long   NumberOfObjects;
    NDR_SCONTEXT  * ArrayOfObjects;
    } SCONTEXT_QUEUE, __RPC_FAR * PSCONTEXT_QUEUE;

RPCRTAPI
RPC_BINDING_HANDLE
RPC_ENTRY
NDRCContextBinding (
    IN NDR_CCONTEXT     CContext
    );

RPCRTAPI
void
RPC_ENTRY
NDRCContextMarshall (
    IN  NDR_CCONTEXT    CContext,
    OUT void __RPC_FAR *pBuff
    );

RPCRTAPI
void
RPC_ENTRY
NDRCContextUnmarshall (
    OUT NDR_CCONTEXT __RPC_FAR *pCContext,
    IN  RPC_BINDING_HANDLE      hBinding,
    IN  void __RPC_FAR *        pBuff,
    IN  unsigned long           DataRepresentation
    );

RPCRTAPI
void
RPC_ENTRY
NDRSContextMarshall (
    IN  NDR_SCONTEXT    CContext,
    OUT void __RPC_FAR *pBuff,
    IN  NDR_RUNDOWN     userRunDownIn
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NDRSContextUnmarshall (
    IN  void __RPC_FAR *pBuff,
    IN  unsigned long   DataRepresentation
    );

RPCRTAPI
void 
RPC_ENTRY
NDRSContextMarshallEx (
    IN  RPC_BINDING_HANDLE  BindingHandle, 
    IN  NDR_SCONTEXT        CContext,
    OUT void __RPC_FAR     *pBuff,
    IN  NDR_RUNDOWN         userRunDownIn
    );

RPCRTAPI
NDR_SCONTEXT 
RPC_ENTRY
NDRSContextUnmarshallEx (
    IN  RPC_BINDING_HANDLE  BindingHandle, 
    IN  void __RPC_FAR     *pBuff,
    IN  unsigned long       DataRepresentation
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsDestroyClientContext (
    IN void __RPC_FAR * __RPC_FAR * ContextHandle
    );


/****************************************************************************
    NDR conversion related definitions.
 ****************************************************************************/

#define byte_from_ndr(source, target) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)&(source)->Buffer)++; \
    }

#define byte_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char __RPC_FAR *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long __RPC_FAR *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define boolean_from_ndr(source, target) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)&(source)->Buffer)++; \
    }

#define boolean_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char __RPC_FAR *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long __RPC_FAR *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

#define small_from_ndr(source, target) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)&(source)->Buffer)++; \
    }

#define small_from_ndr_temp(source, target, format) \
    { \
    *(target) = *(*(char __RPC_FAR * __RPC_FAR *)(source))++; \
    }

#define small_array_from_ndr(Source, LowerIndex, UpperIndex, Target) \
    { \
    NDRcopy ( \
        (((char __RPC_FAR *)(Target))+(LowerIndex)), \
        (Source)->Buffer, \
        (unsigned int)((UpperIndex)-(LowerIndex))); \
    *(unsigned long __RPC_FAR *)&(Source)->Buffer += ((UpperIndex)-(LowerIndex)); \
    }

/****************************************************************************
    Platform specific mapping of c-runtime functions.
 ****************************************************************************/

#ifdef __RPC_DOS__
#define MIDL_ascii_strlen(string) \
    _fstrlen(string)
#define MIDL_ascii_strcpy(target,source) \
    _fstrcpy(target,source)
#define MIDL_memset(s,c,n) \
    _fmemset(s,c,n)
#endif

#ifdef __RPC_WIN16__
#define MIDL_ascii_strlen(string) \
    _fstrlen(string)
#define MIDL_ascii_strcpy(target,source) \
    _fstrcpy(target,source)
#define MIDL_memset(s,c,n) \
    _fmemset(s,c,n)
#endif

#if defined(__RPC_WIN32__) || defined(__RPC_MAC__)
#define MIDL_ascii_strlen(string) \
    strlen(string)
#define MIDL_ascii_strcpy(target,source) \
    strcpy(target,source)
#define MIDL_memset(s,c,n) \
    memset(s,c,n)
#endif

/****************************************************************************
    Ndr Library helper function prototypes for MIDL 1.0 ndr functions.
 ****************************************************************************/

RPCRTAPI
void
RPC_ENTRY
NDRcopy (
    IN void __RPC_FAR *pTarget,
    IN void __RPC_FAR *pSource,
    IN unsigned int size
    );

RPCRTAPI
size_t
RPC_ENTRY
MIDL_wchar_strlen (
    IN wchar_t __RPC_FAR *   s
    );

RPCRTAPI
void
RPC_ENTRY
MIDL_wchar_strcpy (
    OUT void __RPC_FAR *     t,
    IN wchar_t __RPC_FAR *   s
    );

RPCRTAPI
void
RPC_ENTRY
char_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT unsigned char __RPC_FAR *                 Target
    );

RPCRTAPI
void
RPC_ENTRY
char_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned char __RPC_FAR *                 Target
    );

RPCRTAPI
void
RPC_ENTRY
short_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT unsigned short __RPC_FAR *                target
    );

RPCRTAPI
void
RPC_ENTRY
short_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned short __RPC_FAR *                Target
    );

RPCRTAPI
void
RPC_ENTRY
short_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT unsigned short __RPC_FAR *                target,
    IN unsigned long                              format
    );

RPCRTAPI
void
RPC_ENTRY
long_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT unsigned long __RPC_FAR *                 target
    );

RPCRTAPI
void
RPC_ENTRY
long_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT unsigned long __RPC_FAR *                 Target
    );

RPCRTAPI
void
RPC_ENTRY
long_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT unsigned long __RPC_FAR *                 target,
    IN unsigned long                              format
    );

RPCRTAPI
void
RPC_ENTRY
enum_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT unsigned int __RPC_FAR *                  Target
    );

RPCRTAPI
void
RPC_ENTRY
float_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT void __RPC_FAR *                          Target
    );

RPCRTAPI
void
RPC_ENTRY
float_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT void __RPC_FAR *                          Target
    );

RPCRTAPI
void
RPC_ENTRY
double_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    OUT void __RPC_FAR *                          Target
    );

RPCRTAPI
void
RPC_ENTRY
double_array_from_ndr (
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT void __RPC_FAR *                          Target
    );

RPCRTAPI
void
RPC_ENTRY
hyper_from_ndr (
    IN OUT PRPC_MESSAGE                           source,
    OUT    hyper __RPC_FAR *                      target
    );

RPCRTAPI
void
RPC_ENTRY
hyper_array_from_ndr(
    IN OUT PRPC_MESSAGE                           SourceMessage,
    IN unsigned long                              LowerIndex,
    IN unsigned long                              UpperIndex,
    OUT          hyper __RPC_FAR *                Target
    );

RPCRTAPI
void
RPC_ENTRY
hyper_from_ndr_temp (
    IN OUT unsigned char __RPC_FAR * __RPC_FAR *  source,
    OUT             hyper __RPC_FAR *             target,
    IN   unsigned   long                          format
    );

RPCRTAPI
void
RPC_ENTRY
data_from_ndr (
    PRPC_MESSAGE                                  source,
    void __RPC_FAR *                              target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
data_into_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
tree_into_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
data_size_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
tree_size_ndr (
    void __RPC_FAR *                              source,
    PRPC_MESSAGE                                  target,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void
RPC_ENTRY
tree_peek_ndr (
    PRPC_MESSAGE                                  source,
    unsigned char __RPC_FAR * __RPC_FAR *         buffer,
    char __RPC_FAR *                              format,
    unsigned char                                 MscPak
    );

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
midl_allocate (
    size_t      size
    );

/****************************************************************************
    MIDL 2.0 ndr definitions.
 ****************************************************************************/

typedef unsigned long error_status_t;

#define _midl_ma1( p, cast )    *(*( cast **)&p)++
#define _midl_ma2( p, cast )    *(*( cast **)&p)++
#define _midl_ma4( p, cast )    *(*( cast **)&p)++
#define _midl_ma8( p, cast )    *(*( cast **)&p)++

#define _midl_unma1( p, cast )  *(( cast *)p)++
#define _midl_unma2( p, cast )  *(( cast *)p)++
#define _midl_unma3( p, cast )  *(( cast *)p)++
#define _midl_unma4( p, cast )  *(( cast *)p)++

// Some alignment specific macros.


#define _midl_fa2( p )          (p = (RPC_BUFPTR )((unsigned long)(p+1) & 0xfffffffe))
#define _midl_fa4( p )          (p = (RPC_BUFPTR )((unsigned long)(p+3) & 0xfffffffc))
#define _midl_fa8( p )          (p = (RPC_BUFPTR )((unsigned long)(p+7) & 0xfffffff8))

#define _midl_addp( p, n )      (p += n)

// Marshalling macros

#define _midl_marsh_lhs( p, cast )  *(*( cast **)&p)++
#define _midl_marsh_up( mp, p )     *(*(unsigned long **)&mp)++ = (unsigned long)p
#define _midl_advmp( mp )           *(*(unsigned long **)&mp)++
#define _midl_unmarsh_up( p )       (*(*(unsigned long **)&p)++)


////////////////////////////////////////////////////////////////////////////
// Ndr macros.
////////////////////////////////////////////////////////////////////////////

#define NdrMarshConfStringHdr( p, s, l )    (_midl_ma4( p, unsigned long) = s, \
                                            _midl_ma4( p, unsigned long) = 0, \
                                            _midl_ma4( p, unsigned long) = l)

#define NdrUnMarshConfStringHdr(p, s, l)    ((s=_midl_unma4(p,unsigned long),\
                                            (_midl_addp(p,4)),               \
                                            (l=_midl_unma4(p,unsigned long))

#define NdrMarshCCtxtHdl(pc,p)  (NDRCContextMarshall( (NDR_CCONTEXT)pc, p ),p+20)

#define NdrUnMarshCCtxtHdl(pc,p,h,drep) \
        (NDRCContextUnmarshall((NDR_CONTEXT)pc,h,p,drep), p+20)

#define NdrUnMarshSCtxtHdl(pc, p,drep)  (pc = NdrSContextUnMarshall(p,drep ))


#define NdrMarshSCtxtHdl(pc,p,rd)   (NdrSContextMarshall((NDR_SCONTEXT)pc,p, (NDR_RUNDOWN)rd)

#define NdrFieldOffset(s,f)     (long)(& (((s __RPC_FAR *)0)->f))
#define NdrFieldPad(s,f,p,t)    (NdrFieldOffset(s,f) - NdrFieldOffset(s,p) - sizeof(t))

#if defined(__RPC_MAC__)
#define NdrFcShort(s)   (unsigned char)(s >> 8), (unsigned char)(s & 0xff)
#define NdrFcLong(s)    (unsigned char)(s >> 24), (unsigned char)((s & 0x00ff0000) >> 16), \
                        (unsigned char)((s & 0x0000ff00) >> 8), (unsigned char)(s & 0xff)
#else
#define NdrFcShort(s)   (unsigned char)(s & 0xff), (unsigned char)(s >> 8)
#define NdrFcLong(s)    (unsigned char)(s & 0xff), (unsigned char)((s & 0x0000ff00) >> 8), \
                        (unsigned char)((s & 0x00ff0000) >> 16), (unsigned char)(s >> 24)
#endif //  Mac

//
// On the server side, the following exceptions are mapped to
// the bad stub data exception if -error stub_data is used.
//

#define RPC_BAD_STUB_DATA_EXCEPTION_FILTER  \
                 ( (RpcExceptionCode() == STATUS_ACCESS_VIOLATION)  || \
                   (RpcExceptionCode() == STATUS_DATATYPE_MISALIGNMENT) || \
                   (RpcExceptionCode() == RPC_X_BAD_STUB_DATA) )

/////////////////////////////////////////////////////////////////////////////
// Some stub helper functions.
/////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// Stub helper structures.
////////////////////////////////////////////////////////////////////////////

struct _MIDL_STUB_MESSAGE;
struct _MIDL_STUB_DESC;
struct _FULL_PTR_XLAT_TABLES;

typedef unsigned char __RPC_FAR * RPC_BUFPTR;
typedef unsigned long             RPC_LENGTH;

// Expression evaluation callback routine prototype.
typedef void (__RPC_USER __RPC_FAR * EXPR_EVAL)( struct _MIDL_STUB_MESSAGE __RPC_FAR * );

typedef const unsigned char __RPC_FAR * PFORMAT_STRING;

/*
 * Multidimensional conformant/varying array struct.
 */
typedef struct
    {
    long                            Dimension;

    /* These fields MUST be (unsigned long *) */
    unsigned long __RPC_FAR *       BufferConformanceMark;
    unsigned long __RPC_FAR *       BufferVarianceMark;

    /* Count arrays, used for top level arrays in -Os stubs */
    unsigned long __RPC_FAR *       MaxCountArray;
    unsigned long __RPC_FAR *       OffsetArray;
    unsigned long __RPC_FAR *       ActualCountArray;
    } ARRAY_INFO, __RPC_FAR *PARRAY_INFO;

/*
 *  Pipe related definitions.
 */

typedef struct _NDR_PIPE_DESC *       PNDR_PIPE_DESC;
typedef struct _NDR_PIPE_MESSAGE *    PNDR_PIPE_MESSAGE;

typedef struct _NDR_ASYNC_MESSAGE *   PNDR_ASYNC_MESSAGE;

/*
 * MIDL Stub Message
 */
#if !defined(__RPC_DOS__) && !defined(__RPC_WIN16__) && !defined(__RPC_MAC__)
#include <pshpack4.h>
#endif

typedef struct _MIDL_STUB_MESSAGE
    {
    /* RPC message structure. */
    PRPC_MESSAGE                RpcMsg;

    /* Pointer into RPC message buffer. */
    unsigned char __RPC_FAR *   Buffer;

    /*
     * These are used internally by the Ndr routines to mark the beginning
     * and end of an incoming RPC buffer.
     */
    unsigned char __RPC_FAR *   BufferStart;
    unsigned char __RPC_FAR *   BufferEnd;

    /*
     * Used internally by the Ndr routines as a place holder in the buffer.
     * On the marshalling side it's used to mark the location where conformance
     * size should be marshalled.
     * On the unmarshalling side it's used to mark the location in the buffer
     * used during pointer unmarshalling to base pointer offsets off of.
     */
    unsigned char __RPC_FAR *   BufferMark;

    /* Set by the buffer sizing routines. */
    unsigned long               BufferLength;

    /* Set by the memory sizing routines. */
    unsigned long               MemorySize;

    /* Pointer to user memory. */
    unsigned char __RPC_FAR *   Memory;

    /* Is the Ndr routine begin called from a client side stub. */
    int                         IsClient;

    /* Can the buffer be re-used for memory on unmarshalling. */
    int                         ReuseBuffer;

    /* Holds the current pointer to an allocate all nodes memory block. */
    unsigned char __RPC_FAR *   AllocAllNodesMemory;

    /* Used for debugging asserts only, remove later. */
    unsigned char __RPC_FAR *   AllocAllNodesMemoryEnd;

    /*
     * Stuff needed while handling complex structures
     */

    /* Ignore imbeded pointers while computing buffer or memory sizes. */
    int                         IgnoreEmbeddedPointers;

    /*
     * This marks the location in the buffer where pointees of a complex
     * struct reside.
     */
    unsigned char __RPC_FAR *   PointerBufferMark;

    /*
     * Used to catch errors in SendReceive.
     */
    unsigned char               fBufferValid;

    /*
     * Obsolete unused field (formerly MaxContextHandleNumber).
     */
    unsigned char               Unused;

    /*
     * Used internally by the Ndr routines.  Holds the max counts for
     * a conformant array.
     */
    unsigned long               MaxCount;

    /*
     * Used internally by the Ndr routines.  Holds the offsets for a varying
     * array.
     */
    unsigned long               Offset;

    /*
     * Used internally by the Ndr routines.  Holds the actual counts for
     * a varying array.
     */
    unsigned long               ActualCount;

    /* Allocation and Free routine to be used by the Ndr routines. */
    void __RPC_FAR *    (__RPC_FAR __RPC_API * pfnAllocate)(size_t);
    void                (__RPC_FAR __RPC_API * pfnFree)(void __RPC_FAR *);

    /*
     * Top of parameter stack.  Used for "single call" stubs during marshalling
     * to hold the beginning of the parameter list on the stack.  Needed to
     * extract parameters which hold attribute values for top level arrays and
     * pointers.
     */
    unsigned char __RPC_FAR *       StackTop;

    /*
     *  Fields used for the transmit_as and represent_as objects.
     *  For represent_as the mapping is: presented=local, transmit=named.
     */
    unsigned char __RPC_FAR *       pPresentedType;
    unsigned char __RPC_FAR *       pTransmitType;

    /*
     * When we first construct a binding on the client side, stick it
     * in the rpcmessage and later call RpcGetBuffer, the handle field
     * in the rpcmessage is changed. That's fine except that we need to
     * have that original handle for use in unmarshalling context handles
     * (the second argument in NDRCContextUnmarshall to be exact). So
     * stash the contructed handle here and extract it when needed.
     */
    handle_t                        SavedHandle;

    /*
     * Pointer back to the stub descriptor.  Use this to get all handle info.
     */
    const struct _MIDL_STUB_DESC __RPC_FAR *    StubDesc;

    /*
     * Full pointer stuff.
     */
    struct _FULL_PTR_XLAT_TABLES __RPC_FAR *    FullPtrXlatTables;

    unsigned long                   FullPtrRefId;

    /*
     * flags
     */

    int                             fCheckBounds;

    int                             fInDontFree       :1;
    int                             fDontCallFreeInst :1;
    int                             fInOnlyParam      :1;
    int                             fHasReturn        :1;

    unsigned long                   dwDestContext;
    void __RPC_FAR *                pvDestContext;

    NDR_SCONTEXT *                  SavedContextHandles;

    long                            ParamNumber;

    struct IRpcChannelBuffer __RPC_FAR *    pRpcChannelBuffer;

    PARRAY_INFO                     pArrayInfo;

    /*
     * This is where the Beta2 stub message ends.
     */

    unsigned long __RPC_FAR *       SizePtrCountArray;
    unsigned long __RPC_FAR *       SizePtrOffsetArray;
    unsigned long __RPC_FAR *       SizePtrLengthArray;

    /*
     * Interpreter argument queue.  Used on server side only.
     */
    void __RPC_FAR *                pArgQueue;

    unsigned long                   dwStubPhase;

    /*
     * Pipe descriptor, defined for the 4.0 release.
     */
    PNDR_PIPE_DESC                  pPipeDesc;

    /*
     *  Async message pointer, an NT 5.0 feature.
     */
    PNDR_ASYNC_MESSAGE              pAsyncMsg;

    unsigned long                   Reserved[3];

    /*
     *  Fields up to this point present since the 3.50 release.
     */

    } MIDL_STUB_MESSAGE, __RPC_FAR *PMIDL_STUB_MESSAGE;

#if !defined(__RPC_DOS__) && !defined(__RPC_WIN16__) && !defined(__RPC_MAC__)
#include <poppack.h>
#endif

/*
 * Generic handle bind/unbind routine pair.
 */
typedef void __RPC_FAR *
        (__RPC_FAR __RPC_API * GENERIC_BINDING_ROUTINE)
        (void __RPC_FAR *);
typedef void
        (__RPC_FAR __RPC_API * GENERIC_UNBIND_ROUTINE)
        (void __RPC_FAR *, unsigned char __RPC_FAR *);

typedef struct _GENERIC_BINDING_ROUTINE_PAIR
    {
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_ROUTINE_PAIR, __RPC_FAR *PGENERIC_BINDING_ROUTINE_PAIR;

typedef struct __GENERIC_BINDING_INFO
    {
    void __RPC_FAR *            pObj;
    unsigned int                Size;
    GENERIC_BINDING_ROUTINE     pfnBind;
    GENERIC_UNBIND_ROUTINE      pfnUnbind;
    } GENERIC_BINDING_INFO, __RPC_FAR *PGENERIC_BINDING_INFO;

// typedef EXPR_EVAL - see above
// typedefs for xmit_as

#if (defined(_MSC_VER)) && !defined(MIDL_PASS)
// a Microsoft C++ compiler
#define NDR_SHAREABLE __inline
#else
#define NDR_SHAREABLE static
#endif


typedef void (__RPC_FAR __RPC_USER * XMIT_HELPER_ROUTINE)
    ( PMIDL_STUB_MESSAGE );

typedef struct _XMIT_ROUTINE_QUINTUPLE
    {
    XMIT_HELPER_ROUTINE     pfnTranslateToXmit;
    XMIT_HELPER_ROUTINE     pfnTranslateFromXmit;
    XMIT_HELPER_ROUTINE     pfnFreeXmit;
    XMIT_HELPER_ROUTINE     pfnFreeInst;
    } XMIT_ROUTINE_QUINTUPLE, __RPC_FAR *PXMIT_ROUTINE_QUINTUPLE;

typedef unsigned long
(__RPC_FAR __RPC_USER * USER_MARSHAL_SIZING_ROUTINE)
    (unsigned long __RPC_FAR *,
     unsigned long,
     void __RPC_FAR * );

typedef unsigned char __RPC_FAR *
(__RPC_FAR __RPC_USER * USER_MARSHAL_MARSHALLING_ROUTINE)
    (unsigned long __RPC_FAR *,
     unsigned char  __RPC_FAR * ,
     void __RPC_FAR * );

typedef unsigned char __RPC_FAR *
(__RPC_FAR __RPC_USER * USER_MARSHAL_UNMARSHALLING_ROUTINE)
    (unsigned long __RPC_FAR *,
     unsigned char  __RPC_FAR * ,
     void __RPC_FAR * );

typedef void (__RPC_FAR __RPC_USER * USER_MARSHAL_FREEING_ROUTINE)
    (unsigned long __RPC_FAR *,
     void __RPC_FAR * );

typedef struct _USER_MARSHAL_ROUTINE_QUADRUPLE
    {
    USER_MARSHAL_SIZING_ROUTINE          pfnBufferSize;
    USER_MARSHAL_MARSHALLING_ROUTINE     pfnMarshall;
    USER_MARSHAL_UNMARSHALLING_ROUTINE   pfnUnmarshall;
    USER_MARSHAL_FREEING_ROUTINE         pfnFree;
    } USER_MARSHAL_ROUTINE_QUADRUPLE;

typedef struct _USER_MARSHAL_CB
{
    unsigned long       Flags;
    PMIDL_STUB_MESSAGE  pStubMsg;
    PFORMAT_STRING      pReserve;
} USER_MARSHAL_CB;


#define USER_CALL_CTXT_MASK(f)  ((f) & 0x00ff)
#define USER_CALL_AUX_MASK(f)   ((f) & 0xff00)
#define GET_USER_DATA_REP(f)    ((f) >> 16)

#define USER_CALL_IS_ASYNC      0x0100      /* aux flag: in an [async] call */


typedef struct _MALLOC_FREE_STRUCT
    {
    void __RPC_FAR *    (__RPC_FAR __RPC_USER * pfnAllocate)(size_t);
    void                (__RPC_FAR __RPC_USER * pfnFree)(void __RPC_FAR *);
    } MALLOC_FREE_STRUCT;

typedef struct _COMM_FAULT_OFFSETS
    {
    short       CommOffset;
    short       FaultOffset;
    } COMM_FAULT_OFFSETS;

/*
 * MIDL Stub Descriptor
 */

typedef struct _MIDL_STUB_DESC
    {

    void __RPC_FAR *    RpcInterfaceInformation;

    void __RPC_FAR *    (__RPC_FAR __RPC_API * pfnAllocate)(size_t);
    void                (__RPC_FAR __RPC_API * pfnFree)(void __RPC_FAR *);

    union
        {
        handle_t __RPC_FAR *            pAutoHandle;
        handle_t __RPC_FAR *            pPrimitiveHandle;
        PGENERIC_BINDING_INFO           pGenericBindingInfo;
        } IMPLICIT_HANDLE_INFO;

    const NDR_RUNDOWN __RPC_FAR *                   apfnNdrRundownRoutines;
    const GENERIC_BINDING_ROUTINE_PAIR __RPC_FAR *  aGenericBindingRoutinePairs;

    const EXPR_EVAL __RPC_FAR *                     apfnExprEval;

    const XMIT_ROUTINE_QUINTUPLE __RPC_FAR *        aXmitQuintuple;

    const unsigned char __RPC_FAR *                 pFormatTypes;

    int                                             fCheckBounds;

    /* Ndr library version. */
    unsigned long                                   Version;

    /*
     * Reserved for future use. (no reserves )
     */

    MALLOC_FREE_STRUCT __RPC_FAR *                  pMallocFreeStruct;

    long                                MIDLVersion;

    const COMM_FAULT_OFFSETS __RPC_FAR *    CommFaultOffsets;

    // New fields for version 3.0+

    const USER_MARSHAL_ROUTINE_QUADRUPLE __RPC_FAR * aUserMarshalQuadruple;

    long                                    Reserved1;
    long                                    Reserved2;
    long                                    Reserved3;
    long                                    Reserved4;
    long                                    Reserved5;

    } MIDL_STUB_DESC;

typedef const MIDL_STUB_DESC __RPC_FAR * PMIDL_STUB_DESC;

typedef void __RPC_FAR * PMIDL_XMIT_TYPE;

/*
 * MIDL Stub Format String.  This is a const in the stub.
 */
#if !defined( RC_INVOKED )
#pragma warning( disable:4200 )
#endif
typedef struct _MIDL_FORMAT_STRING
    {
    short               Pad;
    unsigned char       Format[];
    } MIDL_FORMAT_STRING;
#if !defined( RC_INVOKED )
#pragma warning( default:4200 )
#endif

/*
 * Stub thunk used for some interpreted server stubs.
 */
typedef void (__RPC_FAR __RPC_API * STUB_THUNK)( PMIDL_STUB_MESSAGE );

typedef long (__RPC_FAR __RPC_API * SERVER_ROUTINE)();

/*
 * Server Interpreter's information strucuture.
 */
typedef struct  _MIDL_SERVER_INFO_
    {
    PMIDL_STUB_DESC             pStubDesc;
    const SERVER_ROUTINE *      DispatchTable;
    PFORMAT_STRING              ProcString;
    const unsigned short *      FmtStringOffset;
    const STUB_THUNK *          ThunkTable;
    PFORMAT_STRING              LocalFormatTypes;
    PFORMAT_STRING              LocalProcString;
    const unsigned short *      LocalFmtStringOffset;
    } MIDL_SERVER_INFO, *PMIDL_SERVER_INFO;

/*
 * Stubless object proxy information structure.
 */
typedef struct _MIDL_STUBLESS_PROXY_INFO
    {
    PMIDL_STUB_DESC                     pStubDesc;
    PFORMAT_STRING                      ProcFormatString;
    const unsigned short __RPC_FAR *    FormatStringOffset;
    PFORMAT_STRING                      LocalFormatTypes;
    PFORMAT_STRING                      LocalProcString;
    const unsigned short __RPC_FAR *    LocalFmtStringOffset;
    } MIDL_STUBLESS_PROXY_INFO;

typedef MIDL_STUBLESS_PROXY_INFO __RPC_FAR * PMIDL_STUBLESS_PROXY_INFO;

/*
 * This is the return value from NdrClientCall.
 */
typedef union _CLIENT_CALL_RETURN
    {
    void __RPC_FAR *        Pointer;
    long                    Simple;
    } CLIENT_CALL_RETURN;

/*
 * Full pointer data structures.
 */

typedef enum
        {
        XLAT_SERVER = 1,
        XLAT_CLIENT
        } XLAT_SIDE;

/*
 * Stores the translation for the conversion from a full pointer into it's
 * corresponding ref id.
 */
typedef struct _FULL_PTR_TO_REFID_ELEMENT
    {
    struct _FULL_PTR_TO_REFID_ELEMENT __RPC_FAR *  Next;

    void __RPC_FAR *            Pointer;
    unsigned long       RefId;
    unsigned char       State;
    } FULL_PTR_TO_REFID_ELEMENT, __RPC_FAR *PFULL_PTR_TO_REFID_ELEMENT;

/*
 * Full pointer translation tables.
 */
typedef struct _FULL_PTR_XLAT_TABLES
    {
    /*
     * Ref id to pointer translation information.
     */
    struct
        {
        void __RPC_FAR *__RPC_FAR *             XlatTable;
        unsigned char __RPC_FAR *     StateTable;
        unsigned long       NumberOfEntries;
        } RefIdToPointer;

    /*
     * Pointer to ref id translation information.
     */
    struct
        {
        PFULL_PTR_TO_REFID_ELEMENT __RPC_FAR *  XlatTable;
        unsigned long                   NumberOfBuckets;
        unsigned long                   HashMask;
        } PointerToRefId;

    /*
     * Next ref id to use.
     */
    unsigned long           NextRefId;

    /*
     * Keep track of the translation size we're handling : server or client.
     * This tells us when we have to do reverse translations when we insert
     * new translations.  On the server we must insert a pointer-to-refid
     * translation whenever we insert a refid-to-pointer translation, and
     * vica versa for the client.
     */
    XLAT_SIDE               XlatSide;
    } FULL_PTR_XLAT_TABLES, __RPC_FAR *PFULL_PTR_XLAT_TABLES;

/***************************************************************************
 ** New MIDL 2.0 Ndr routine templates
 ***************************************************************************/

/*
 * Marshall routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleTypeMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    unsigned char                       FormatChar
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrPointerMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Structures */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrSimpleStructMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantStructMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantVaryingStructMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrHardStructMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrComplexStructMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Arrays */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrFixedArrayMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantArrayMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrComplexArrayMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Strings */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrNonConformantStringMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantStringMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Unions */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrEncapsulatedUnionMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrNonEncapsulatedUnionMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Byte count pointer */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrByteCountPointerMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrXmitOrRepAsMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* User_marshal */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrUserMarshalMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Cairo interface pointer */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrInterfacePointerMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Context handles */

RPCRTAPI
void
RPC_ENTRY
NdrClientContextMarshall(
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_CCONTEXT          ContextHandle,
    int                   fCheck
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerContextMarshall(
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_SCONTEXT          ContextHandle,
    NDR_RUNDOWN           RundownRoutine
    );

/*
 * Unmarshall routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleTypeUnmarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    unsigned char                       FormatChar
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrPointerUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Structures */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrSimpleStructUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantStructUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantVaryingStructUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrHardStructUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrComplexStructUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Arrays */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrFixedArrayUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantArrayUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrComplexArrayUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Strings */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrNonConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Unions */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrEncapsulatedUnionUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrNonEncapsulatedUnionUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Byte count pointer */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrByteCountPointerUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrXmitOrRepAsUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* User_marshal */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrUserMarshalUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Cairo interface pointer */

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrInterfacePointerUnmarshall(
    PMIDL_STUB_MESSAGE                      pStubMsg,
    unsigned char __RPC_FAR * __RPC_FAR *   ppMemory,
    PFORMAT_STRING                          pFormat,
    unsigned char                           fMustAlloc
    );

/* Context handles */

RPCRTAPI
void
RPC_ENTRY
NdrClientContextUnmarshall(
    PMIDL_STUB_MESSAGE          pStubMsg,
    NDR_CCONTEXT __RPC_FAR *    pContextHandle,
    RPC_BINDING_HANDLE          BindHandle
    );

RPCRTAPI
NDR_SCONTEXT
RPC_ENTRY
NdrServerContextUnmarshall(
    PMIDL_STUB_MESSAGE          pStubMsg
    );

/*
 * Buffer sizing routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrPointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Structures */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleStructBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantStructBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingStructBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrHardStructBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexStructBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Arrays */

RPCRTAPI
void
RPC_ENTRY
NdrFixedArrayBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantArrayBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingArrayBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrVaryingArrayBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexArrayBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Strings */

RPCRTAPI
void
RPC_ENTRY
NdrConformantStringBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonConformantStringBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Unions */

RPCRTAPI
void
RPC_ENTRY
NdrEncapsulatedUnionBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonEncapsulatedUnionBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Byte count pointer */

RPCRTAPI
void
RPC_ENTRY
NdrByteCountPointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
void
RPC_ENTRY
NdrXmitOrRepAsBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* User_marshal */

RPCRTAPI
void
RPC_ENTRY
NdrUserMarshalBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Cairo Interface pointer */

RPCRTAPI
void
RPC_ENTRY
NdrInterfacePointerBufferSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

// Context Handle size
//
RPCRTAPI
void
RPC_ENTRY
NdrContextHandleSize(
    PMIDL_STUB_MESSAGE          pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/*
 * Memory sizing routines
 */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrPointerMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Structures */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrSimpleStructMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantStructMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantVaryingStructMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrHardStructMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrComplexStructMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Arrays */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrFixedArrayMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantArrayMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrComplexArrayMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Strings */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrConformantStringMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrNonConformantStringMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Unions */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrNonEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
unsigned long
RPC_ENTRY
NdrXmitOrRepAsMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* User_marshal */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrUserMarshalMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/* Cairo Interface pointer */

RPCRTAPI
unsigned long
RPC_ENTRY
NdrInterfacePointerMemorySize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

/*
 * Freeing routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrPointerFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Structures */

RPCRTAPI
void
RPC_ENTRY
NdrSimpleStructFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantStructFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingStructFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrHardStructFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexStructFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Arrays */

RPCRTAPI
void
RPC_ENTRY
NdrFixedArrayFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantArrayFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrConformantVaryingArrayFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrVaryingArrayFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrComplexArrayFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Unions */

RPCRTAPI
void
RPC_ENTRY
NdrEncapsulatedUnionFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

RPCRTAPI
void
RPC_ENTRY
NdrNonEncapsulatedUnionFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Byte count */

RPCRTAPI
void
RPC_ENTRY
NdrByteCountPointerFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Transmit as and represent as*/

RPCRTAPI
void
RPC_ENTRY
NdrXmitOrRepAsFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* User_marshal */

RPCRTAPI
void
RPC_ENTRY
NdrUserMarshalFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/* Cairo Interface pointer */

RPCRTAPI
void
RPC_ENTRY
NdrInterfacePointerFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

/*
 * Endian conversion routine.
 */

RPCRTAPI
void
RPC_ENTRY
NdrConvert2(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat,
    long                                NumberParams
    );

RPCRTAPI
void
RPC_ENTRY
NdrConvert(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pFormat
    );

#define USER_MARSHAL_FC_BYTE         1
#define USER_MARSHAL_FC_CHAR         2
#define USER_MARSHAL_FC_SMALL        3
#define USER_MARSHAL_FC_USMALL       4
#define USER_MARSHAL_FC_WCHAR        5
#define USER_MARSHAL_FC_SHORT        6
#define USER_MARSHAL_FC_USHORT       7
#define USER_MARSHAL_FC_LONG         8
#define USER_MARSHAL_FC_ULONG        9
#define USER_MARSHAL_FC_FLOAT       10
#define USER_MARSHAL_FC_HYPER       11
#define USER_MARSHAL_FC_DOUBLE      12

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrUserMarshalSimpleTypeConvert(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    unsigned char   FormatChar
    );

/*
 * Auxilary routines
 */

RPCRTAPI
void
RPC_ENTRY
NdrClientInitializeNew(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    unsigned int                        ProcNum
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrServerInitializeNew(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerInitializePartial(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    unsigned long                       RequestedBufferSize
    );

RPCRTAPI
void
RPC_ENTRY
NdrClientInitialize(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    unsigned int                        ProcNum
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrServerInitialize(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrServerInitializeUnmarshall (
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    PRPC_MESSAGE                        pRpcMsg
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerInitializeMarshall (
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrGetBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength,
    RPC_BINDING_HANDLE                  Handle
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrNsGetBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength,
    RPC_BINDING_HANDLE                  Handle
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrGetPipeBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength,
    RPC_BINDING_HANDLE                  Handle );

RPCRTAPI
void
RPC_ENTRY
NdrGetPartialBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrSendReceive(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR*            pBufferEnd
    );

RPCRTAPI
unsigned char __RPC_FAR *
RPC_ENTRY
NdrNsSendReceive(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pBufferEnd,
    RPC_BINDING_HANDLE __RPC_FAR *      pAutoHandle
    );

RPCRTAPI
void
RPC_ENTRY
NdrPipeSendReceive(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PNDR_PIPE_DESC                      pPipeDesc
    );

RPCRTAPI
void
RPC_ENTRY
NdrFreeBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
NdrGetDcomProtocolVersion( 
    PMIDL_STUB_MESSAGE   pStubMsg,
    RPC_VERSION *        pVersion );


/*
 * Pipe specific calls
 */

RPCRTAPI
void
RPC_ENTRY
NdrPipesInitialize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PFORMAT_STRING                      pParamDesc,
    PNDR_PIPE_DESC                      pPipeDesc,
    PNDR_PIPE_MESSAGE                   pPipeMsg,
    char             __RPC_FAR *        pStackTop,
    unsigned long                       NumberParams );

RPCRTAPI
void
RPC_ENTRY
NdrPipePull(
    char          __RPC_FAR *           pState,
    void          __RPC_FAR *           buf,
    unsigned long                       esize,
    unsigned long __RPC_FAR *           ecount );

RPCRTAPI
void
RPC_ENTRY
NdrPipePush(
    char          __RPC_FAR *           pState,
    void          __RPC_FAR *           buf,
    unsigned long                       ecount );

RPCRTAPI
void
RPC_ENTRY
NdrIsAppDoneWithPipes(
    PNDR_PIPE_DESC                      pPipeDesc
    );

RPCRTAPI
void
RPC_ENTRY
NdrPipesDone(
    PMIDL_STUB_MESSAGE                  pStubMsg
    );


/*
 * Interpeter calls.
 */

/* client */

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall2(
    PMIDL_STUB_DESC                     pStubDescriptor,
    PFORMAT_STRING                      pFormat,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall(
    PMIDL_STUB_DESC                     pStubDescriptor,
    PFORMAT_STRING                      pFormat,
    ...
    );

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrAsyncClientCall(
    PMIDL_STUB_DESC     pStubDescriptor,
    PFORMAT_STRING      pFormat,
    ...
    );

/* server */
typedef enum {
    STUB_UNMARSHAL,
    STUB_CALL_SERVER,
    STUB_MARSHAL,
    STUB_CALL_SERVER_NO_HRESULT
}STUB_PHASE;

typedef enum {
    PROXY_CALCSIZE,
    PROXY_GETBUFFER,
    PROXY_MARSHAL,
    PROXY_SENDRECEIVE,
    PROXY_UNMARSHAL
}PROXY_PHASE;

struct IRpcStubBuffer;      // Forward declaration

RPCRTAPI
long
RPC_ENTRY
NdrAsyncStubCall(
    struct IRpcStubBuffer *             pThis,
    struct IRpcChannelBuffer *          pChannel,
    PRPC_MESSAGE                        pRpcMsg,
    unsigned long *                     pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrAsyncServerCall(
    PRPC_MESSAGE                        pRpcMsg
    );

RPCRTAPI
long
RPC_ENTRY
NdrStubCall2(
    struct IRpcStubBuffer __RPC_FAR *    pThis,
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PRPC_MESSAGE                         pRpcMsg,
    unsigned long __RPC_FAR *            pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCall2(
    PRPC_MESSAGE                        pRpcMsg
    );

RPCRTAPI
long
RPC_ENTRY
NdrStubCall (
    struct IRpcStubBuffer __RPC_FAR *    pThis,
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PRPC_MESSAGE                         pRpcMsg,
    unsigned long __RPC_FAR *            pdwStubPhase
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerCall(
    PRPC_MESSAGE                        pRpcMsg
    );

RPCRTAPI
int
RPC_ENTRY
NdrServerUnmarshall(
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PRPC_MESSAGE                         pRpcMsg,
    PMIDL_STUB_MESSAGE                   pStubMsg,
    PMIDL_STUB_DESC                      pStubDescriptor,
    PFORMAT_STRING                       pFormat,
    void __RPC_FAR *                     pParamList
    );

RPCRTAPI
void
RPC_ENTRY
NdrServerMarshall(
    struct IRpcStubBuffer __RPC_FAR *    pThis,
    struct IRpcChannelBuffer __RPC_FAR * pChannel,
    PMIDL_STUB_MESSAGE                   pStubMsg,
    PFORMAT_STRING                       pFormat
    );

/* Comm and Fault status */

RPCRTAPI
RPC_STATUS
RPC_ENTRY
NdrMapCommAndFaultStatus(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long __RPC_FAR *                       pCommStatus,
    unsigned long __RPC_FAR *                       pFaultStatus,
    RPC_STATUS                          Status
    );

/* Helper routines */

RPCRTAPI
int
RPC_ENTRY
NdrSH_UPDecision(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    RPC_BUFPTR                          pBuffer
    );

RPCRTAPI
int
RPC_ENTRY
NdrSH_TLUPDecision(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem
    );

RPCRTAPI
int
RPC_ENTRY
NdrSH_TLUPDecisionBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem
    );

RPCRTAPI
int
RPC_ENTRY
NdrSH_IfAlloc(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPCRTAPI
int
RPC_ENTRY
NdrSH_IfAllocRef(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPCRTAPI
int
RPC_ENTRY
NdrSH_IfAllocSet(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPCRTAPI
RPC_BUFPTR
RPC_ENTRY
NdrSH_IfCopy(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPCRTAPI
RPC_BUFPTR
RPC_ENTRY
NdrSH_IfAllocCopy(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char           __RPC_FAR *__RPC_FAR *          pPtrInMem,
    unsigned long                       Count
    );

RPCRTAPI
unsigned long
RPC_ENTRY
NdrSH_Copy(
    unsigned char           __RPC_FAR *         pStubMsg,
    unsigned char           __RPC_FAR *         pPtrInMem,
    unsigned long                       Count
    );

RPCRTAPI
void
RPC_ENTRY
NdrSH_IfFree(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char           __RPC_FAR *         pPtr );


RPCRTAPI
RPC_BUFPTR
RPC_ENTRY
NdrSH_StringMarshall(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char           __RPC_FAR *         pMemory,
    unsigned long                       Count,
    int                                 Size );

RPCRTAPI
RPC_BUFPTR
RPC_ENTRY
NdrSH_StringUnMarshall(
    PMIDL_STUB_MESSAGE                  pMessage,
    unsigned char           __RPC_FAR *__RPC_FAR *          pMemory,
    int                                 Size );

/****************************************************************************
    MIDL 2.0 memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

typedef void __RPC_FAR * RPC_SS_THREAD_HANDLE;

typedef void __RPC_FAR * __RPC_API
RPC_CLIENT_ALLOC (
    IN size_t Size
    );

typedef void __RPC_API
RPC_CLIENT_FREE (
    IN void __RPC_FAR * Ptr
    );

/*++
     RpcSs* package
--*/

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
RpcSsAllocate (
    IN size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsDisableAllocate (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsEnableAllocate (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsFree (
    IN void __RPC_FAR * NodeToFree
    );

RPCRTAPI
RPC_SS_THREAD_HANDLE
RPC_ENTRY
RpcSsGetThreadHandle (
    void
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSetClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSetThreadHandle (
    IN RPC_SS_THREAD_HANDLE Id
    );

RPCRTAPI
void
RPC_ENTRY
RpcSsSwapClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree,
    OUT RPC_CLIENT_ALLOC __RPC_FAR * __RPC_FAR * OldClientAlloc,
    OUT RPC_CLIENT_FREE __RPC_FAR * __RPC_FAR * OldClientFree
    );

/*++
     RpcSm* package
--*/

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
RpcSmAllocate (
    IN  size_t          Size,
    OUT RPC_STATUS __RPC_FAR *    pStatus
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmClientFree (
    IN  void __RPC_FAR * pNodeToFree
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmDestroyClientContext (
    IN void __RPC_FAR * __RPC_FAR * ContextHandle
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmDisableAllocate (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmEnableAllocate (
    void
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmFree (
    IN void __RPC_FAR * NodeToFree
    );

RPCRTAPI
RPC_SS_THREAD_HANDLE
RPC_ENTRY
RpcSmGetThreadHandle (
    OUT RPC_STATUS __RPC_FAR *    pStatus
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSetClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSetThreadHandle (
    IN RPC_SS_THREAD_HANDLE Id
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcSmSwapClientAllocFree (
    IN RPC_CLIENT_ALLOC __RPC_FAR * ClientAlloc,
    IN RPC_CLIENT_FREE __RPC_FAR * ClientFree,
    OUT RPC_CLIENT_ALLOC __RPC_FAR * __RPC_FAR * OldClientAlloc,
    OUT RPC_CLIENT_FREE __RPC_FAR * __RPC_FAR * OldClientFree
    );

/*++
     Ndr stub entry points
--*/

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsEnableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsDisableAllocate(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSmSetClientToOsf(
    PMIDL_STUB_MESSAGE      pMessage );

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
NdrRpcSmClientAllocate (
    IN size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSmClientFree (
    IN void __RPC_FAR * NodeToFree
    );

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
NdrRpcSsDefaultAllocate (
    IN size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrRpcSsDefaultFree (
    IN void __RPC_FAR * NodeToFree
    );

/****************************************************************************
    end of memory package: rpc_ss_* rpc_sm_*
 ****************************************************************************/

/****************************************************************************
 * Full Pointer APIs
 ****************************************************************************/

RPCRTAPI
PFULL_PTR_XLAT_TABLES
RPC_ENTRY
NdrFullPointerXlatInit(
    unsigned long           NumberOfPointers,
    XLAT_SIDE               XlatSide
    );

RPCRTAPI
void
RPC_ENTRY
NdrFullPointerXlatFree(
    PFULL_PTR_XLAT_TABLES   pXlatTables
    );

RPCRTAPI
int
RPC_ENTRY
NdrFullPointerQueryPointer(
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    void __RPC_FAR *                    pPointer,
    unsigned char           QueryType,
    unsigned long __RPC_FAR *           pRefId
    );

RPCRTAPI
int
RPC_ENTRY
NdrFullPointerQueryRefId(
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    unsigned long           RefId,
    unsigned char           QueryType,
    void __RPC_FAR *__RPC_FAR *                 ppPointer
    );

RPCRTAPI
void
RPC_ENTRY
NdrFullPointerInsertRefId(
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    unsigned long           RefId,
    void __RPC_FAR *                    pPointer
    );

RPCRTAPI
int
RPC_ENTRY
NdrFullPointerFree(
    PFULL_PTR_XLAT_TABLES   pXlatTables,
    void __RPC_FAR *                    Pointer
    );

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
NdrAllocate(
    PMIDL_STUB_MESSAGE      pStubMsg,
    size_t                  Len
    );

RPCRTAPI
void
RPC_ENTRY
NdrClearOutParameters(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat,
    void __RPC_FAR *        ArgAddr
    );


/****************************************************************************
 * Proxy APIs
 ****************************************************************************/

RPCRTAPI
void __RPC_FAR *
RPC_ENTRY
NdrOleAllocate (
    IN size_t Size
    );

RPCRTAPI
void
RPC_ENTRY
NdrOleFree (
    IN void __RPC_FAR * NodeToFree
    );

#ifdef CONST_VTABLE
#define CONST_VTBL const
#else
#define CONST_VTBL
#endif

/****************************************************************************
 * Special things for VC5 Com support
 ****************************************************************************/

#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#define MIDL_INTERFACE(x)   struct __declspec(uuid(x)) __declspec(novtable)
#else
#define DECLSPEC_UUID(x)
#define MIDL_INTERFACE(x)   struct
#endif

#if _MSC_VER >= 1100
#define EXTERN_GUID(itf,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8)  \
  EXTERN_C const IID __declspec(selectany) itf = {l1,s1,s2,{c1,c2,c3,c4,c5,c6,c7,c8}}
#else
#define EXTERN_GUID(itf,l1,s1,s2,c1,c2,c3,c4,c5,c6,c7,c8) EXTERN_C const IID itf
#endif



#ifdef __cplusplus
}
#endif

// Reset the packing level for DOS, Windows and Mac.

#if defined(__RPC_DOS__) || defined(__RPC_WIN16__) || defined(__RPC_MAC__)
#pragma pack()
#endif

#endif /* __RPCNDR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\inc\snapins.inc\mmc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0266 */
/* at Tue Jun 15 16:57:25 1999
 */
/* Compiler settings for mmc.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mmc_h__
#define __mmc_h__

/* Forward Declarations */ 

#ifndef __IComponentData_FWD_DEFINED__
#define __IComponentData_FWD_DEFINED__
typedef interface IComponentData IComponentData;
#endif 	/* __IComponentData_FWD_DEFINED__ */


#ifndef __IComponent_FWD_DEFINED__
#define __IComponent_FWD_DEFINED__
typedef interface IComponent IComponent;
#endif 	/* __IComponent_FWD_DEFINED__ */


#ifndef __IResultDataCompare_FWD_DEFINED__
#define __IResultDataCompare_FWD_DEFINED__
typedef interface IResultDataCompare IResultDataCompare;
#endif 	/* __IResultDataCompare_FWD_DEFINED__ */


#ifndef __IResultOwnerData_FWD_DEFINED__
#define __IResultOwnerData_FWD_DEFINED__
typedef interface IResultOwnerData IResultOwnerData;
#endif 	/* __IResultOwnerData_FWD_DEFINED__ */


#ifndef __IConsole_FWD_DEFINED__
#define __IConsole_FWD_DEFINED__
typedef interface IConsole IConsole;
#endif 	/* __IConsole_FWD_DEFINED__ */


#ifndef __IHeaderCtrl_FWD_DEFINED__
#define __IHeaderCtrl_FWD_DEFINED__
typedef interface IHeaderCtrl IHeaderCtrl;
#endif 	/* __IHeaderCtrl_FWD_DEFINED__ */


#ifndef __IContextMenuCallback_FWD_DEFINED__
#define __IContextMenuCallback_FWD_DEFINED__
typedef interface IContextMenuCallback IContextMenuCallback;
#endif 	/* __IContextMenuCallback_FWD_DEFINED__ */


#ifndef __IContextMenuProvider_FWD_DEFINED__
#define __IContextMenuProvider_FWD_DEFINED__
typedef interface IContextMenuProvider IContextMenuProvider;
#endif 	/* __IContextMenuProvider_FWD_DEFINED__ */


#ifndef __IExtendContextMenu_FWD_DEFINED__
#define __IExtendContextMenu_FWD_DEFINED__
typedef interface IExtendContextMenu IExtendContextMenu;
#endif 	/* __IExtendContextMenu_FWD_DEFINED__ */


#ifndef __IImageList_FWD_DEFINED__
#define __IImageList_FWD_DEFINED__
typedef interface IImageList IImageList;
#endif 	/* __IImageList_FWD_DEFINED__ */


#ifndef __IResultData_FWD_DEFINED__
#define __IResultData_FWD_DEFINED__
typedef interface IResultData IResultData;
#endif 	/* __IResultData_FWD_DEFINED__ */


#ifndef __IConsoleNameSpace_FWD_DEFINED__
#define __IConsoleNameSpace_FWD_DEFINED__
typedef interface IConsoleNameSpace IConsoleNameSpace;
#endif 	/* __IConsoleNameSpace_FWD_DEFINED__ */


#ifndef __IConsoleNameSpace2_FWD_DEFINED__
#define __IConsoleNameSpace2_FWD_DEFINED__
typedef interface IConsoleNameSpace2 IConsoleNameSpace2;
#endif 	/* __IConsoleNameSpace2_FWD_DEFINED__ */


#ifndef __IPropertySheetCallback_FWD_DEFINED__
#define __IPropertySheetCallback_FWD_DEFINED__
typedef interface IPropertySheetCallback IPropertySheetCallback;
#endif 	/* __IPropertySheetCallback_FWD_DEFINED__ */


#ifndef __IPropertySheetProvider_FWD_DEFINED__
#define __IPropertySheetProvider_FWD_DEFINED__
typedef interface IPropertySheetProvider IPropertySheetProvider;
#endif 	/* __IPropertySheetProvider_FWD_DEFINED__ */


#ifndef __IExtendPropertySheet_FWD_DEFINED__
#define __IExtendPropertySheet_FWD_DEFINED__
typedef interface IExtendPropertySheet IExtendPropertySheet;
#endif 	/* __IExtendPropertySheet_FWD_DEFINED__ */


#ifndef __IControlbar_FWD_DEFINED__
#define __IControlbar_FWD_DEFINED__
typedef interface IControlbar IControlbar;
#endif 	/* __IControlbar_FWD_DEFINED__ */


#ifndef __IExtendControlbar_FWD_DEFINED__
#define __IExtendControlbar_FWD_DEFINED__
typedef interface IExtendControlbar IExtendControlbar;
#endif 	/* __IExtendControlbar_FWD_DEFINED__ */


#ifndef __IToolbar_FWD_DEFINED__
#define __IToolbar_FWD_DEFINED__
typedef interface IToolbar IToolbar;
#endif 	/* __IToolbar_FWD_DEFINED__ */


#ifndef __IConsoleVerb_FWD_DEFINED__
#define __IConsoleVerb_FWD_DEFINED__
typedef interface IConsoleVerb IConsoleVerb;
#endif 	/* __IConsoleVerb_FWD_DEFINED__ */


#ifndef __ISnapinAbout_FWD_DEFINED__
#define __ISnapinAbout_FWD_DEFINED__
typedef interface ISnapinAbout ISnapinAbout;
#endif 	/* __ISnapinAbout_FWD_DEFINED__ */


#ifndef __IMenuButton_FWD_DEFINED__
#define __IMenuButton_FWD_DEFINED__
typedef interface IMenuButton IMenuButton;
#endif 	/* __IMenuButton_FWD_DEFINED__ */


#ifndef __ISnapinHelp_FWD_DEFINED__
#define __ISnapinHelp_FWD_DEFINED__
typedef interface ISnapinHelp ISnapinHelp;
#endif 	/* __ISnapinHelp_FWD_DEFINED__ */


#ifndef __IExtendPropertySheet2_FWD_DEFINED__
#define __IExtendPropertySheet2_FWD_DEFINED__
typedef interface IExtendPropertySheet2 IExtendPropertySheet2;
#endif 	/* __IExtendPropertySheet2_FWD_DEFINED__ */


#ifndef __IHeaderCtrl2_FWD_DEFINED__
#define __IHeaderCtrl2_FWD_DEFINED__
typedef interface IHeaderCtrl2 IHeaderCtrl2;
#endif 	/* __IHeaderCtrl2_FWD_DEFINED__ */


#ifndef __ISnapinHelp2_FWD_DEFINED__
#define __ISnapinHelp2_FWD_DEFINED__
typedef interface ISnapinHelp2 ISnapinHelp2;
#endif 	/* __ISnapinHelp2_FWD_DEFINED__ */


#ifndef __IEnumTASK_FWD_DEFINED__
#define __IEnumTASK_FWD_DEFINED__
typedef interface IEnumTASK IEnumTASK;
#endif 	/* __IEnumTASK_FWD_DEFINED__ */


#ifndef __IExtendTaskPad_FWD_DEFINED__
#define __IExtendTaskPad_FWD_DEFINED__
typedef interface IExtendTaskPad IExtendTaskPad;
#endif 	/* __IExtendTaskPad_FWD_DEFINED__ */


#ifndef __IConsole2_FWD_DEFINED__
#define __IConsole2_FWD_DEFINED__
typedef interface IConsole2 IConsole2;
#endif 	/* __IConsole2_FWD_DEFINED__ */


#ifndef __IDisplayHelp_FWD_DEFINED__
#define __IDisplayHelp_FWD_DEFINED__
typedef interface IDisplayHelp IDisplayHelp;
#endif 	/* __IDisplayHelp_FWD_DEFINED__ */


#ifndef __IRequiredExtensions_FWD_DEFINED__
#define __IRequiredExtensions_FWD_DEFINED__
typedef interface IRequiredExtensions IRequiredExtensions;
#endif 	/* __IRequiredExtensions_FWD_DEFINED__ */


#ifndef __IStringTable_FWD_DEFINED__
#define __IStringTable_FWD_DEFINED__
typedef interface IStringTable IStringTable;
#endif 	/* __IStringTable_FWD_DEFINED__ */


#ifndef __IColumnData_FWD_DEFINED__
#define __IColumnData_FWD_DEFINED__
typedef interface IColumnData IColumnData;
#endif 	/* __IColumnData_FWD_DEFINED__ */


#ifndef __IMessageView_FWD_DEFINED__
#define __IMessageView_FWD_DEFINED__
typedef interface IMessageView IMessageView;
#endif 	/* __IMessageView_FWD_DEFINED__ */


#ifndef __IResultDataCompareEx_FWD_DEFINED__
#define __IResultDataCompareEx_FWD_DEFINED__
typedef interface IResultDataCompareEx IResultDataCompareEx;
#endif 	/* __IResultDataCompareEx_FWD_DEFINED__ */


/* header files for imported files */
#include "basetsd.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_mmc_0000 */
/* [local] */ 

#ifndef MMC_VER
#define MMC_VER 0x0120
#endif













#if (MMC_VER >= 0x0110)





#endif // MMC_VER >= 0x0110
#if (MMC_VER >= 0x0120)


#endif // MMC_VER >= 0x0120









#if (MMC_VER >= 0x0110)





#endif // MMC_VER >= 0x0110
typedef IConsole __RPC_FAR *LPCONSOLE;

typedef IHeaderCtrl __RPC_FAR *LPHEADERCTRL;

typedef IToolbar __RPC_FAR *LPTOOLBAR;

typedef IImageList __RPC_FAR *LPIMAGELIST;

typedef IResultData __RPC_FAR *LPRESULTDATA;

typedef IConsoleNameSpace __RPC_FAR *LPCONSOLENAMESPACE;

typedef IPropertySheetProvider __RPC_FAR *LPPROPERTYSHEETPROVIDER;

typedef IPropertySheetCallback __RPC_FAR *LPPROPERTYSHEETCALLBACK;

typedef IContextMenuProvider __RPC_FAR *LPCONTEXTMENUPROVIDER;

typedef IContextMenuCallback __RPC_FAR *LPCONTEXTMENUCALLBACK;

typedef IControlbar __RPC_FAR *LPCONTROLBAR;

typedef IConsoleVerb __RPC_FAR *LPCONSOLEVERB;

typedef IMenuButton __RPC_FAR *LPMENUBUTTON;

#if (MMC_VER >= 0x0110)
typedef IConsole2 __RPC_FAR *LPCONSOLE2;

typedef IHeaderCtrl2 __RPC_FAR *LPHEADERCTRL2;

typedef IConsoleNameSpace2 __RPC_FAR *LPCONSOLENAMESPACE2;

typedef IDisplayHelp __RPC_FAR *LPDISPLAYHELP;

typedef IStringTable __RPC_FAR *LPSTRINGTABLE;

#endif // MMC_VER >= 0x0110
#if (MMC_VER >= 0x0120)
typedef IColumnData __RPC_FAR *LPCOLUMNDATA;

typedef IResultDataCompareEx __RPC_FAR *LPRESULTDATACOMPAREEX;

#endif // MMC_VER >= 0x0120
typedef IComponent __RPC_FAR *LPCOMPONENT;

typedef IComponentData __RPC_FAR *LPCOMPONENTDATA;

typedef IExtendPropertySheet __RPC_FAR *LPEXTENDPROPERTYSHEET;

typedef IExtendContextMenu __RPC_FAR *LPEXTENDCONTEXTMENU;

typedef IExtendControlbar __RPC_FAR *LPEXTENDCONTROLBAR;

typedef IResultDataCompare __RPC_FAR *LPRESULTDATACOMPARE;

typedef IResultOwnerData __RPC_FAR *LPRESULTOWNERDATA;

typedef ISnapinAbout __RPC_FAR *LPSNAPABOUT;

typedef ISnapinAbout __RPC_FAR *LPSNAPINABOUT;

typedef ISnapinHelp __RPC_FAR *LPSNAPHELP;

typedef ISnapinHelp __RPC_FAR *LPSNAPINHELP;

#if (MMC_VER >= 0x0110)
typedef IEnumTASK __RPC_FAR *LPENUMTASK;

typedef IExtendPropertySheet2 __RPC_FAR *LPEXTENDPROPERTYSHEET2;

typedef ISnapinHelp2 __RPC_FAR *LPSNAPINHELP2;

typedef IExtendTaskPad __RPC_FAR *LPEXTENDTASKPAD;

typedef IRequiredExtensions __RPC_FAR *LPREQUIREDEXTENSIONS;

#endif // MMC_VER >= 0x0110
#define	MMCLV_AUTO	( -1 )

#define	MMCLV_NOPARAM	( -2 )

#define	MMCLV_NOICON	( -1 )

#define	MMCLV_VIEWSTYLE_ICON	( 0 )

#define	MMCLV_VIEWSTYLE_SMALLICON	( 0x2 )

#define	MMCLV_VIEWSTYLE_LIST	( 0x3 )

#define	MMCLV_VIEWSTYLE_REPORT	( 0x1 )

#define	MMCLV_VIEWSTYLE_FILTERED	( 0x4 )

#define	MMCLV_NOPTR	( 0 )

#define	MMCLV_UPDATE_NOINVALIDATEALL	( 0x1 )

#define	MMCLV_UPDATE_NOSCROLL	( 0x2 )

static unsigned short __RPC_FAR *MMC_CALLBACK	=	( unsigned short __RPC_FAR * )-1;

#if (MMC_VER >= 0x0120)
#define MMC_IMAGECALLBACK (-1)
#define MMC_TEXTCALLBACK  MMC_CALLBACK
#endif // MMC_VER >= 0x0120
typedef LONG_PTR HSCOPEITEM;

typedef long COMPONENTID;

typedef LONG_PTR HRESULTITEM;

#define	RDI_STR	( 0x2 )

#define	RDI_IMAGE	( 0x4 )

#define	RDI_STATE	( 0x8 )

#define	RDI_PARAM	( 0x10 )

#define	RDI_INDEX	( 0x20 )

#define	RDI_INDENT	( 0x40 )

typedef enum _MMC_RESULT_VIEW_STYLE      
{                                        
    MMC_SINGLESEL           = 0x0001,    
    MMC_SHOWSELALWAYS       = 0x0002,    
    MMC_NOSORTHEADER        = 0x0004,    
#if (MMC_VER >= 0x0120)                  
    MMC_ENSUREFOCUSVISIBLE  = 0x0008     
#endif // MMC_VER >= 0x0120              
} MMC_RESULT_VIEW_STYLE;                 
#if 0
typedef 
enum _MMC_RESULT_VIEW_STYLE
    {	_MMC_VIEW_STYLE__dummy_	= 0
    }	MMC_RESULT_VIEW_STYLE;

#endif
#define	MMC_VIEW_OPTIONS_NONE	( 0 )

#define	MMC_VIEW_OPTIONS_NOLISTVIEWS	( 0x1 )

#define	MMC_VIEW_OPTIONS_MULTISELECT	( 0x2 )

#define	MMC_VIEW_OPTIONS_OWNERDATALIST	( 0x4 )

#define	MMC_VIEW_OPTIONS_FILTERED	( 0x8 )

#define	MMC_VIEW_OPTIONS_CREATENEW	( 0x10 )

#if (MMC_VER >= 0x0110)
#define	MMC_VIEW_OPTIONS_USEFONTLINKING	( 0x20 )

#endif // MMC_VER >= 0x0110
#if (MMC_VER >= 0x0120)
#define	MMC_VIEW_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST	( 0x40 )

#define	MMC_VIEW_OPTIONS_LEXICAL_SORT	( 0x80 )

#endif // MMC_VER >= 0x0120
#define	MMC_PSO_NOAPPLYNOW	( 0x1 )

#define	MMC_PSO_HASHELP	( 0x2 )

#define	MMC_PSO_NEWWIZARDTYPE	( 0x4 )

#define	MMC_PSO_NO_PROPTITLE	( 0x8 )

typedef 
enum _MMC_CONTROL_TYPE
    {	TOOLBAR	= 0,
	MENUBUTTON	= TOOLBAR + 1,
	COMBOBOXBAR	= MENUBUTTON + 1
    }	MMC_CONTROL_TYPE;

typedef enum _MMC_CONSOLE_VERB                               
{                                                            
    MMC_VERB_NONE            = 0x0000,                       
    MMC_VERB_OPEN            = 0x8000,                       
    MMC_VERB_COPY            = 0x8001,                       
    MMC_VERB_PASTE           = 0x8002,                       
    MMC_VERB_DELETE          = 0x8003,                       
    MMC_VERB_PROPERTIES      = 0x8004,                       
    MMC_VERB_RENAME          = 0x8005,                       
    MMC_VERB_REFRESH         = 0x8006,                       
    MMC_VERB_PRINT           = 0x8007,                       
#if (MMC_VER >= 0x0110)                                      
    MMC_VERB_CUT             = 0x8008,  // Used only to explicitly disable/hide
                                        // the cut verb, when copy & paste are enabled.
                                                             
    // must be last                                          
    MMC_VERB_MAX,                                            
    MMC_VERB_FIRST           = MMC_VERB_OPEN,                
    MMC_VERB_LAST            = MMC_VERB_MAX - 1              
#endif // MMC_VER >= 0x0110                                  
} MMC_CONSOLE_VERB;                                          
#if 0
typedef 
enum _MMC_CONSOLE_VERB
    {	MMC_VERB__dummy_	= 0
    }	MMC_CONSOLE_VERB;

#endif
#include <pshpack8.h>
typedef struct _MMCButton
    {
    int nBitmap;
    int idCommand;
    BYTE fsState;
    BYTE fsType;
    LPOLESTR lpButtonText;
    LPOLESTR lpTooltipText;
    }	MMCBUTTON;

#include <poppack.h>
typedef MMCBUTTON __RPC_FAR *LPMMCBUTTON;

typedef 
enum _MMC_BUTTON_STATE
    {	ENABLED	= 0x1,
	CHECKED	= 0x2,
	HIDDEN	= 0x4,
	INDETERMINATE	= 0x8,
	BUTTONPRESSED	= 0x10
    }	MMC_BUTTON_STATE;

typedef struct _RESULTDATAITEM
    {
    DWORD mask;
    BOOL bScopeItem;
    HRESULTITEM itemID;
    int nIndex;
    int nCol;
    LPOLESTR str;
    int nImage;
    UINT nState;
    LPARAM lParam;
    int iIndent;
    }	RESULTDATAITEM;

typedef RESULTDATAITEM __RPC_FAR *LPRESULTDATAITEM;

#define	RFI_PARTIAL	( 0x1 )

#define	RFI_WRAP	( 0x2 )

typedef struct _RESULTFINDINFO
    {
    LPOLESTR psz;
    int nStart;
    DWORD dwOptions;
    }	RESULTFINDINFO;

typedef RESULTFINDINFO __RPC_FAR *LPRESULTFINDINFO;

#define	RSI_DESCENDING	( 0x1 )

#define	SDI_STR	( 0x2 )

#define	SDI_IMAGE	( 0x4 )

#define	SDI_OPENIMAGE	( 0x8 )

#define	SDI_STATE	( 0x10 )

#define	SDI_PARAM	( 0x20 )

#define	SDI_CHILDREN	( 0x40 )

#define	SDI_PARENT	( 0 )

#define	SDI_PREVIOUS	( 0x10000000 )

#define	SDI_NEXT	( 0x20000000 )

#define	SDI_FIRST	( 0x8000000 )

typedef struct _SCOPEDATAITEM
    {
    DWORD mask;
    LPOLESTR displayname;
    int nImage;
    int nOpenImage;
    UINT nState;
    int cChildren;
    LPARAM lParam;
    HSCOPEITEM relativeID;
    HSCOPEITEM ID;
    }	SCOPEDATAITEM;

typedef SCOPEDATAITEM __RPC_FAR *LPSCOPEDATAITEM;

typedef 
enum _MMC_SCOPE_ITEM_STATE
    {	MMC_SCOPE_ITEM_STATE_NORMAL	= 0x1,
	MMC_SCOPE_ITEM_STATE_BOLD	= 0x2,
	MMC_SCOPE_ITEM_STATE_EXPANDEDONCE	= 0x3
    }	MMC_SCOPE_ITEM_STATE;

typedef struct _CONTEXTMENUITEM
    {
    LPWSTR strName;
    LPWSTR strStatusBarText;
    LONG lCommandID;
    LONG lInsertionPointID;
    LONG fFlags;
    LONG fSpecialFlags;
    }	CONTEXTMENUITEM;

typedef CONTEXTMENUITEM __RPC_FAR *LPCONTEXTMENUITEM;

typedef 
enum _MMC_MENU_COMMAND_IDS
    {	MMCC_STANDARD_VIEW_SELECT	= -1
    }	MMC_MENU_COMMAND_IDS;

typedef struct _MENUBUTTONDATA
    {
    int idCommand;
    int x;
    int y;
    }	MENUBUTTONDATA;

typedef MENUBUTTONDATA __RPC_FAR *LPMENUBUTTONDATA;

typedef LONG_PTR MMC_COOKIE;

#define	MMC_MULTI_SELECT_COOKIE	( -2 )

#define	MMC_WINDOW_COOKIE	( -3 )

#if (MMC_VER >= 0x0110)
#define	SPECIAL_COOKIE_MIN	( -10 )

#define	SPECIAL_COOKIE_MAX	( -1 )

typedef 
enum _MMC_FILTER_TYPE
    {	MMC_STRING_FILTER	= 0,
	MMC_INT_FILTER	= 0x1,
	MMC_FILTER_NOVALUE	= 0x8000
    }	MMC_FILTER_TYPE;

typedef struct _MMC_FILTERDATA
    {
    LPOLESTR pszText;
    INT cchTextMax;
    LONG lValue;
    }	MMC_FILTERDATA;

typedef 
enum _MMC_FILTER_CHANGE_CODE
    {	MFCC_DISABLE	= 0,
	MFCC_ENABLE	= 1,
	MFCC_VALUE_CHANGE	= 2
    }	MMC_FILTER_CHANGE_CODE;

typedef struct _MMC_RESTORE_VIEW
    {
    DWORD dwSize;
    MMC_COOKIE cookie;
    LPOLESTR pViewType;
    long lViewOptions;
    }	MMC_RESTORE_VIEW;

typedef struct _MMC_EXPANDSYNC_STRUCT
    {
    BOOL bHandled;
    BOOL bExpanding;
    HSCOPEITEM hItem;
    }	MMC_EXPANDSYNC_STRUCT;

#endif // MMC_VER >= 0x0110
#if (MMC_VER >= 0x0120)
typedef struct _MMC_VISIBLE_COLUMNS
    {
    INT nVisibleColumns;
    INT rgVisibleCols[ 1 ];
    }	MMC_VISIBLE_COLUMNS;

#endif // MMC_VER >= 0x0120
typedef enum _MMC_NOTIFY_TYPE                                
{                                                            
    MMCN_ACTIVATE           = 0x8001,                        
    MMCN_ADD_IMAGES         = 0x8002,                        
    MMCN_BTN_CLICK          = 0x8003,                        
    MMCN_CLICK              = 0x8004,   // NOT USED          
    MMCN_COLUMN_CLICK       = 0x8005,                        
    MMCN_CONTEXTMENU        = 0x8006,   // NOT USED          
    MMCN_CUTORMOVE          = 0x8007,                        
    MMCN_DBLCLICK           = 0x8008,                        
    MMCN_DELETE             = 0x8009,                        
    MMCN_DESELECT_ALL       = 0x800A,                        
    MMCN_EXPAND             = 0x800B,                        
    MMCN_HELP               = 0x800C,   // NOT USED          
    MMCN_MENU_BTNCLICK      = 0x800D,                        
    MMCN_MINIMIZED          = 0x800E,                        
    MMCN_PASTE              = 0x800F,                        
    MMCN_PROPERTY_CHANGE    = 0x8010,                        
    MMCN_QUERY_PASTE        = 0x8011,                        
    MMCN_REFRESH            = 0x8012,                        
    MMCN_REMOVE_CHILDREN    = 0x8013,                        
    MMCN_RENAME             = 0x8014,                        
    MMCN_SELECT             = 0x8015,                        
    MMCN_SHOW               = 0x8016,                        
    MMCN_VIEW_CHANGE        = 0x8017,                        
    MMCN_SNAPINHELP         = 0x8018,                        
    MMCN_CONTEXTHELP        = 0x8019,                        
    MMCN_INITOCX            = 0x801A,                        
#if (MMC_VER >= 0x0110)                                      
    MMCN_FILTER_CHANGE      = 0x801B,                        
    MMCN_FILTERBTN_CLICK    = 0x801C,                        
    MMCN_RESTORE_VIEW       = 0x801D,                        
    MMCN_PRINT              = 0x801E,                        
    MMCN_PRELOAD            = 0x801F,                        
    MMCN_LISTPAD            = 0x8020,                        
    MMCN_EXPANDSYNC         = 0x8021,                        
#if (MMC_VER >= 0x0120)                                      
    MMCN_COLUMNS_CHANGED    = 0x8022,                        
#endif // MMC_VER >= 0x0120                                  
#endif // MMC_VER >= 0x0110                                  
} MMC_NOTIFY_TYPE;                                           
#if 0
typedef 
enum _MMC_NOTIFY_TYPE
    {	MMCN__dummy_	= 0
    }	MMC_NOTIFY_TYPE;

#endif
typedef 
enum _DATA_OBJECT_TYPES
    {	CCT_SCOPE	= 0x8000,
	CCT_RESULT	= 0x8001,
	CCT_SNAPIN_MANAGER	= 0x8002,
	CCT_UNINITIALIZED	= 0xffff
    }	DATA_OBJECT_TYPES;

#define	MMC_NW_OPTION_NONE	( 0 )

#define	MMC_NW_OPTION_NOSCOPEPANE	( 0x1 )

#define	MMC_NW_OPTION_NOTOOLBARS	( 0x2 )

#define	MMC_NW_OPTION_SHORTTITLE	( 0x4 )

#define	MMC_NW_OPTION_CUSTOMTITLE	( 0x8 )

#define	MMC_NW_OPTION_NOPERSIST	( 0x10 )

#define	CCF_NODETYPE	( L"CCF_NODETYPE" )

#define	CCF_SZNODETYPE	( L"CCF_SZNODETYPE" )

#define	CCF_DISPLAY_NAME	( L"CCF_DISPLAY_NAME" )

#define	CCF_SNAPIN_CLASSID	( L"CCF_SNAPIN_CLASSID" )

#define	CCF_WINDOW_TITLE	( L"CCF_WINDOW_TITLE" )

#define	CCF_MMC_MULTISELECT_DATAOBJECT	( L"CCF_MMC_MULTISELECT_DATAOBJECT" )

typedef struct _SMMCDataObjects
    {
    DWORD count;
    LPDATAOBJECT lpDataObject[ 1 ];
    }	SMMCDataObjects;

#define	CCF_MULTI_SELECT_SNAPINS	( L"CCF_MULTI_SELECT_SNAPINS" )

typedef struct _SMMCObjectTypes
    {
    DWORD count;
    GUID guid[ 1 ];
    }	SMMCObjectTypes;

#define	CCF_OBJECT_TYPES_IN_MULTI_SELECT	( L"CCF_OBJECT_TYPES_IN_MULTI_SELECT" )

#if (MMC_VER >= 0x0110)
typedef SMMCObjectTypes SMMCDynamicExtensions;

#define	CCF_MMC_DYNAMIC_EXTENSIONS	( L"CCF_MMC_DYNAMIC_EXTENSIONS" )

#define	CCF_SNAPIN_PRELOADS	( L"CCF_SNAPIN_PRELOADS" )

typedef struct _SNodeID
    {
    DWORD cBytes;
    BYTE id[ 1 ];
    }	SNodeID;

#if (MMC_VER >= 0x0120)
typedef struct _SNodeID2
    {
    DWORD dwFlags;
    DWORD cBytes;
    BYTE id[ 1 ];
    }	SNodeID2;

#define	MMC_NODEID_SLOW_RETRIEVAL	( 0x1 )

#define	CCF_NODEID2	( L"CCF_NODEID2" )

#endif // MMC_VER >= 0x0120
#define	CCF_NODEID	( L"CCF_NODEID" )

#if (MMC_VER >= 0x0120)
typedef struct _SColumnSetID
    {
    DWORD dwFlags;
    DWORD cBytes;
    BYTE id[ 1 ];
    }	SColumnSetID;

#define	CCF_COLUMN_SET_ID	( L"CCF_COLUMN_SET_ID" )

#endif // MMC_VER >= 0x0120
#endif // MMC_VER >= 0x0110
STDAPI MMCPropertyChangeNotify(LONG_PTR lNotifyHandle, LPARAM param);
#if (MMC_VER >= 0x0110)
STDAPI MMCPropertyHelp(LPOLESTR pszHelpTopic);
#endif // MMC_VER >= 0x0110
STDAPI MMCFreeNotifyHandle(LONG_PTR lNotifyHandle);
STDAPI MMCPropPageCallback(void* vpsp);
EXTERN_C const CLSID CLSID_NodeManager;
#if (MMC_VER >= 0x0120)
EXTERN_C const CLSID CLSID_MessageView;
#endif // MMC_VER >= 0x0120
#define DOBJ_NULL        (LPDATAOBJECT)   0
#define DOBJ_CUSTOMOCX   (LPDATAOBJECT)  -1
#define DOBJ_CUSTOMWEB   (LPDATAOBJECT)  -2
#if (MMC_VER >= 0x0110)
#if (MMC_VER >= 0x0120)
#define DOBJ_NOCONSOLE   (LPDATAOBJECT)  -3
#endif // MMC_VER >= 0x0120
#define SPECIAL_DOBJ_MIN                -10
#define SPECIAL_DOBJ_MAX                  0
#endif // MMC_VER >= 0x0110
#define IS_SPECIAL_DATAOBJECT(d) (((LONG_PTR)(d) >= SPECIAL_DOBJ_MIN)   && ((LONG_PTR)(d) <= SPECIAL_DOBJ_MAX))
#define IS_SPECIAL_COOKIE(c)     (((c)          >= SPECIAL_COOKIE_MIN) && ((c)          <= SPECIAL_COOKIE_MAX))


extern RPC_IF_HANDLE __MIDL_itf_mmc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mmc_0000_v0_0_s_ifspec;

#ifndef __IComponentData_INTERFACE_DEFINED__
#define __IComponentData_INTERFACE_DEFINED__

/* interface IComponentData */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IComponentData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("955AB28A-5218-11D0-A985-00C04FD8D565")
    IComponentData : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPUNKNOWN pUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
            /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponentData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponentData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponentData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IComponentData __RPC_FAR * This,
            /* [in] */ LPUNKNOWN pUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateComponent )( 
            IComponentData __RPC_FAR * This,
            /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify )( 
            IComponentData __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Destroy )( 
            IComponentData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryDataObject )( 
            IComponentData __RPC_FAR * This,
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayInfo )( 
            IComponentData __RPC_FAR * This,
            /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompareObjects )( 
            IComponentData __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        END_INTERFACE
    } IComponentDataVtbl;

    interface IComponentData
    {
        CONST_VTBL struct IComponentDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponentData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponentData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComponentData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComponentData_Initialize(This,pUnknown)	\
    (This)->lpVtbl -> Initialize(This,pUnknown)

#define IComponentData_CreateComponent(This,ppComponent)	\
    (This)->lpVtbl -> CreateComponent(This,ppComponent)

#define IComponentData_Notify(This,lpDataObject,event,arg,param)	\
    (This)->lpVtbl -> Notify(This,lpDataObject,event,arg,param)

#define IComponentData_Destroy(This)	\
    (This)->lpVtbl -> Destroy(This)

#define IComponentData_QueryDataObject(This,cookie,type,ppDataObject)	\
    (This)->lpVtbl -> QueryDataObject(This,cookie,type,ppDataObject)

#define IComponentData_GetDisplayInfo(This,pScopeDataItem)	\
    (This)->lpVtbl -> GetDisplayInfo(This,pScopeDataItem)

#define IComponentData_CompareObjects(This,lpDataObjectA,lpDataObjectB)	\
    (This)->lpVtbl -> CompareObjects(This,lpDataObjectA,lpDataObjectB)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_Initialize_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [in] */ LPUNKNOWN pUnknown);


void __RPC_STUB IComponentData_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_CreateComponent_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);


void __RPC_STUB IComponentData_CreateComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_Notify_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObject,
    /* [in] */ MMC_NOTIFY_TYPE event,
    /* [in] */ LPARAM arg,
    /* [in] */ LPARAM param);


void __RPC_STUB IComponentData_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_Destroy_Proxy( 
    IComponentData __RPC_FAR * This);


void __RPC_STUB IComponentData_Destroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_QueryDataObject_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [in] */ MMC_COOKIE cookie,
    /* [in] */ DATA_OBJECT_TYPES type,
    /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);


void __RPC_STUB IComponentData_QueryDataObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_GetDisplayInfo_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);


void __RPC_STUB IComponentData_GetDisplayInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponentData_CompareObjects_Proxy( 
    IComponentData __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObjectA,
    /* [in] */ LPDATAOBJECT lpDataObjectB);


void __RPC_STUB IComponentData_CompareObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComponentData_INTERFACE_DEFINED__ */


#ifndef __IComponent_INTERFACE_DEFINED__
#define __IComponent_INTERFACE_DEFINED__

/* interface IComponent */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IComponent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB2-D36C-11CF-ADBC-00AA00A80033")
    IComponent : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IComponentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IComponent __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IComponent __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IComponent __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IComponent __RPC_FAR * This,
            /* [in] */ LPCONSOLE lpConsole);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify )( 
            IComponent __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Destroy )( 
            IComponent __RPC_FAR * This,
            /* [in] */ MMC_COOKIE cookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryDataObject )( 
            IComponent __RPC_FAR * This,
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultViewType )( 
            IComponent __RPC_FAR * This,
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayInfo )( 
            IComponent __RPC_FAR * This,
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompareObjects )( 
            IComponent __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        END_INTERFACE
    } IComponentVtbl;

    interface IComponent
    {
        CONST_VTBL struct IComponentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IComponent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IComponent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IComponent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IComponent_Initialize(This,lpConsole)	\
    (This)->lpVtbl -> Initialize(This,lpConsole)

#define IComponent_Notify(This,lpDataObject,event,arg,param)	\
    (This)->lpVtbl -> Notify(This,lpDataObject,event,arg,param)

#define IComponent_Destroy(This,cookie)	\
    (This)->lpVtbl -> Destroy(This,cookie)

#define IComponent_QueryDataObject(This,cookie,type,ppDataObject)	\
    (This)->lpVtbl -> QueryDataObject(This,cookie,type,ppDataObject)

#define IComponent_GetResultViewType(This,cookie,ppViewType,pViewOptions)	\
    (This)->lpVtbl -> GetResultViewType(This,cookie,ppViewType,pViewOptions)

#define IComponent_GetDisplayInfo(This,pResultDataItem)	\
    (This)->lpVtbl -> GetDisplayInfo(This,pResultDataItem)

#define IComponent_CompareObjects(This,lpDataObjectA,lpDataObjectB)	\
    (This)->lpVtbl -> CompareObjects(This,lpDataObjectA,lpDataObjectB)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_Initialize_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ LPCONSOLE lpConsole);


void __RPC_STUB IComponent_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_Notify_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObject,
    /* [in] */ MMC_NOTIFY_TYPE event,
    /* [in] */ LPARAM arg,
    /* [in] */ LPARAM param);


void __RPC_STUB IComponent_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_Destroy_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ MMC_COOKIE cookie);


void __RPC_STUB IComponent_Destroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_QueryDataObject_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ MMC_COOKIE cookie,
    /* [in] */ DATA_OBJECT_TYPES type,
    /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);


void __RPC_STUB IComponent_QueryDataObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_GetResultViewType_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ MMC_COOKIE cookie,
    /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
    /* [out] */ long __RPC_FAR *pViewOptions);


void __RPC_STUB IComponent_GetResultViewType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_GetDisplayInfo_Proxy( 
    IComponent __RPC_FAR * This,
    /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);


void __RPC_STUB IComponent_GetDisplayInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IComponent_CompareObjects_Proxy( 
    IComponent __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObjectA,
    /* [in] */ LPDATAOBJECT lpDataObjectB);


void __RPC_STUB IComponent_CompareObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IComponent_INTERFACE_DEFINED__ */


#ifndef __IResultDataCompare_INTERFACE_DEFINED__
#define __IResultDataCompare_INTERFACE_DEFINED__

/* interface IResultDataCompare */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IResultDataCompare;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E8315A52-7A1A-11D0-A2D2-00C04FD909DD")
    IResultDataCompare : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Compare( 
            /* [in] */ LPARAM lUserParam,
            /* [in] */ MMC_COOKIE cookieA,
            /* [in] */ MMC_COOKIE cookieB,
            /* [out][in] */ int __RPC_FAR *pnResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResultDataCompareVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResultDataCompare __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResultDataCompare __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResultDataCompare __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Compare )( 
            IResultDataCompare __RPC_FAR * This,
            /* [in] */ LPARAM lUserParam,
            /* [in] */ MMC_COOKIE cookieA,
            /* [in] */ MMC_COOKIE cookieB,
            /* [out][in] */ int __RPC_FAR *pnResult);
        
        END_INTERFACE
    } IResultDataCompareVtbl;

    interface IResultDataCompare
    {
        CONST_VTBL struct IResultDataCompareVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResultDataCompare_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResultDataCompare_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResultDataCompare_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResultDataCompare_Compare(This,lUserParam,cookieA,cookieB,pnResult)	\
    (This)->lpVtbl -> Compare(This,lUserParam,cookieA,cookieB,pnResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataCompare_Compare_Proxy( 
    IResultDataCompare __RPC_FAR * This,
    /* [in] */ LPARAM lUserParam,
    /* [in] */ MMC_COOKIE cookieA,
    /* [in] */ MMC_COOKIE cookieB,
    /* [out][in] */ int __RPC_FAR *pnResult);


void __RPC_STUB IResultDataCompare_Compare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResultDataCompare_INTERFACE_DEFINED__ */


#ifndef __IResultOwnerData_INTERFACE_DEFINED__
#define __IResultOwnerData_INTERFACE_DEFINED__

/* interface IResultOwnerData */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IResultOwnerData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9CB396D8-EA83-11d0-AEF1-00C04FB6DD2C")
    IResultOwnerData : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindItem( 
            /* [in] */ LPRESULTFINDINFO pFindInfo,
            /* [out] */ int __RPC_FAR *pnFoundIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CacheHint( 
            /* [in] */ int nStartIndex,
            /* [in] */ int nEndIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SortItems( 
            /* [in] */ int nColumn,
            /* [in] */ DWORD dwSortOptions,
            /* [in] */ LPARAM lUserParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResultOwnerDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResultOwnerData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResultOwnerData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResultOwnerData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindItem )( 
            IResultOwnerData __RPC_FAR * This,
            /* [in] */ LPRESULTFINDINFO pFindInfo,
            /* [out] */ int __RPC_FAR *pnFoundIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CacheHint )( 
            IResultOwnerData __RPC_FAR * This,
            /* [in] */ int nStartIndex,
            /* [in] */ int nEndIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SortItems )( 
            IResultOwnerData __RPC_FAR * This,
            /* [in] */ int nColumn,
            /* [in] */ DWORD dwSortOptions,
            /* [in] */ LPARAM lUserParam);
        
        END_INTERFACE
    } IResultOwnerDataVtbl;

    interface IResultOwnerData
    {
        CONST_VTBL struct IResultOwnerDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResultOwnerData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResultOwnerData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResultOwnerData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResultOwnerData_FindItem(This,pFindInfo,pnFoundIndex)	\
    (This)->lpVtbl -> FindItem(This,pFindInfo,pnFoundIndex)

#define IResultOwnerData_CacheHint(This,nStartIndex,nEndIndex)	\
    (This)->lpVtbl -> CacheHint(This,nStartIndex,nEndIndex)

#define IResultOwnerData_SortItems(This,nColumn,dwSortOptions,lUserParam)	\
    (This)->lpVtbl -> SortItems(This,nColumn,dwSortOptions,lUserParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultOwnerData_FindItem_Proxy( 
    IResultOwnerData __RPC_FAR * This,
    /* [in] */ LPRESULTFINDINFO pFindInfo,
    /* [out] */ int __RPC_FAR *pnFoundIndex);


void __RPC_STUB IResultOwnerData_FindItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultOwnerData_CacheHint_Proxy( 
    IResultOwnerData __RPC_FAR * This,
    /* [in] */ int nStartIndex,
    /* [in] */ int nEndIndex);


void __RPC_STUB IResultOwnerData_CacheHint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultOwnerData_SortItems_Proxy( 
    IResultOwnerData __RPC_FAR * This,
    /* [in] */ int nColumn,
    /* [in] */ DWORD dwSortOptions,
    /* [in] */ LPARAM lUserParam);


void __RPC_STUB IResultOwnerData_SortItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResultOwnerData_INTERFACE_DEFINED__ */


#ifndef __IConsole_INTERFACE_DEFINED__
#define __IConsole_INTERFACE_DEFINED__

/* interface IConsole */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IConsole;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB1-D36C-11CF-ADBC-00AA00A80033")
    IConsole : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetHeader( 
            /* [in] */ LPHEADERCTRL pHeader) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetToolbar( 
            /* [in] */ LPTOOLBAR pToolbar) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryResultView( 
            /* [out] */ LPUNKNOWN __RPC_FAR *pUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryScopeImageList( 
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryResultImageList( 
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UpdateAllViews( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ LPARAM data,
            /* [in] */ LONG_PTR hint) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MessageBox( 
            /* [in] */ LPCWSTR lpszText,
            /* [in] */ LPCWSTR lpszTitle,
            /* [in] */ UINT fuStyle,
            /* [out] */ int __RPC_FAR *piRetval) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryConsoleVerb( 
            /* [out] */ LPCONSOLEVERB __RPC_FAR *ppConsoleVerb) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SelectScopeItem( 
            /* [in] */ HSCOPEITEM hScopeItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMainWindow( 
            /* [out] */ HWND __RPC_FAR *phwnd) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NewWindow( 
            /* [in] */ HSCOPEITEM hScopeItem,
            /* [in] */ unsigned long lOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConsoleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IConsole __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IConsole __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IConsole __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHeader )( 
            IConsole __RPC_FAR * This,
            /* [in] */ LPHEADERCTRL pHeader);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetToolbar )( 
            IConsole __RPC_FAR * This,
            /* [in] */ LPTOOLBAR pToolbar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryResultView )( 
            IConsole __RPC_FAR * This,
            /* [out] */ LPUNKNOWN __RPC_FAR *pUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryScopeImageList )( 
            IConsole __RPC_FAR * This,
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryResultImageList )( 
            IConsole __RPC_FAR * This,
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateAllViews )( 
            IConsole __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ LPARAM data,
            /* [in] */ LONG_PTR hint);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MessageBox )( 
            IConsole __RPC_FAR * This,
            /* [in] */ LPCWSTR lpszText,
            /* [in] */ LPCWSTR lpszTitle,
            /* [in] */ UINT fuStyle,
            /* [out] */ int __RPC_FAR *piRetval);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryConsoleVerb )( 
            IConsole __RPC_FAR * This,
            /* [out] */ LPCONSOLEVERB __RPC_FAR *ppConsoleVerb);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectScopeItem )( 
            IConsole __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hScopeItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMainWindow )( 
            IConsole __RPC_FAR * This,
            /* [out] */ HWND __RPC_FAR *phwnd);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewWindow )( 
            IConsole __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hScopeItem,
            /* [in] */ unsigned long lOptions);
        
        END_INTERFACE
    } IConsoleVtbl;

    interface IConsole
    {
        CONST_VTBL struct IConsoleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConsole_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConsole_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConsole_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConsole_SetHeader(This,pHeader)	\
    (This)->lpVtbl -> SetHeader(This,pHeader)

#define IConsole_SetToolbar(This,pToolbar)	\
    (This)->lpVtbl -> SetToolbar(This,pToolbar)

#define IConsole_QueryResultView(This,pUnknown)	\
    (This)->lpVtbl -> QueryResultView(This,pUnknown)

#define IConsole_QueryScopeImageList(This,ppImageList)	\
    (This)->lpVtbl -> QueryScopeImageList(This,ppImageList)

#define IConsole_QueryResultImageList(This,ppImageList)	\
    (This)->lpVtbl -> QueryResultImageList(This,ppImageList)

#define IConsole_UpdateAllViews(This,lpDataObject,data,hint)	\
    (This)->lpVtbl -> UpdateAllViews(This,lpDataObject,data,hint)

#define IConsole_MessageBox(This,lpszText,lpszTitle,fuStyle,piRetval)	\
    (This)->lpVtbl -> MessageBox(This,lpszText,lpszTitle,fuStyle,piRetval)

#define IConsole_QueryConsoleVerb(This,ppConsoleVerb)	\
    (This)->lpVtbl -> QueryConsoleVerb(This,ppConsoleVerb)

#define IConsole_SelectScopeItem(This,hScopeItem)	\
    (This)->lpVtbl -> SelectScopeItem(This,hScopeItem)

#define IConsole_GetMainWindow(This,phwnd)	\
    (This)->lpVtbl -> GetMainWindow(This,phwnd)

#define IConsole_NewWindow(This,hScopeItem,lOptions)	\
    (This)->lpVtbl -> NewWindow(This,hScopeItem,lOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_SetHeader_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ LPHEADERCTRL pHeader);


void __RPC_STUB IConsole_SetHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_SetToolbar_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ LPTOOLBAR pToolbar);


void __RPC_STUB IConsole_SetToolbar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_QueryResultView_Proxy( 
    IConsole __RPC_FAR * This,
    /* [out] */ LPUNKNOWN __RPC_FAR *pUnknown);


void __RPC_STUB IConsole_QueryResultView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_QueryScopeImageList_Proxy( 
    IConsole __RPC_FAR * This,
    /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);


void __RPC_STUB IConsole_QueryScopeImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_QueryResultImageList_Proxy( 
    IConsole __RPC_FAR * This,
    /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);


void __RPC_STUB IConsole_QueryResultImageList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_UpdateAllViews_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObject,
    /* [in] */ LPARAM data,
    /* [in] */ LONG_PTR hint);


void __RPC_STUB IConsole_UpdateAllViews_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_MessageBox_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ LPCWSTR lpszText,
    /* [in] */ LPCWSTR lpszTitle,
    /* [in] */ UINT fuStyle,
    /* [out] */ int __RPC_FAR *piRetval);


void __RPC_STUB IConsole_MessageBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_QueryConsoleVerb_Proxy( 
    IConsole __RPC_FAR * This,
    /* [out] */ LPCONSOLEVERB __RPC_FAR *ppConsoleVerb);


void __RPC_STUB IConsole_QueryConsoleVerb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_SelectScopeItem_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ HSCOPEITEM hScopeItem);


void __RPC_STUB IConsole_SelectScopeItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_GetMainWindow_Proxy( 
    IConsole __RPC_FAR * This,
    /* [out] */ HWND __RPC_FAR *phwnd);


void __RPC_STUB IConsole_GetMainWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole_NewWindow_Proxy( 
    IConsole __RPC_FAR * This,
    /* [in] */ HSCOPEITEM hScopeItem,
    /* [in] */ unsigned long lOptions);


void __RPC_STUB IConsole_NewWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConsole_INTERFACE_DEFINED__ */


#ifndef __IHeaderCtrl_INTERFACE_DEFINED__
#define __IHeaderCtrl_INTERFACE_DEFINED__

/* interface IHeaderCtrl */
/* [unique][helpstring][uuid][object] */ 

#define	AUTO_WIDTH	( -1 )

#if (MMC_VER >= 0x0120)
#define	HIDE_COLUMN	( -4 )

#endif // MMC_VER >= 0x0120

EXTERN_C const IID IID_IHeaderCtrl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB3-D36C-11CF-ADBC-00AA00A80033")
    IHeaderCtrl : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InsertColumn( 
            /* [in] */ int nCol,
            /* [in] */ LPCWSTR title,
            /* [in] */ int nFormat,
            /* [in] */ int nWidth) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteColumn( 
            /* [in] */ int nCol) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetColumnText( 
            /* [in] */ int nCol,
            /* [in] */ LPCWSTR title) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetColumnText( 
            /* [in] */ int nCol,
            /* [out] */ LPOLESTR __RPC_FAR *pText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetColumnWidth( 
            /* [in] */ int nCol,
            /* [in] */ int nWidth) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetColumnWidth( 
            /* [in] */ int nCol,
            /* [out] */ int __RPC_FAR *pWidth) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHeaderCtrlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHeaderCtrl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHeaderCtrl __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertColumn )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [in] */ LPCWSTR title,
            /* [in] */ int nFormat,
            /* [in] */ int nWidth);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteColumn )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumnText )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [in] */ LPCWSTR title);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnText )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [out] */ LPOLESTR __RPC_FAR *pText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumnWidth )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [in] */ int nWidth);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnWidth )( 
            IHeaderCtrl __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [out] */ int __RPC_FAR *pWidth);
        
        END_INTERFACE
    } IHeaderCtrlVtbl;

    interface IHeaderCtrl
    {
        CONST_VTBL struct IHeaderCtrlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHeaderCtrl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHeaderCtrl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHeaderCtrl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHeaderCtrl_InsertColumn(This,nCol,title,nFormat,nWidth)	\
    (This)->lpVtbl -> InsertColumn(This,nCol,title,nFormat,nWidth)

#define IHeaderCtrl_DeleteColumn(This,nCol)	\
    (This)->lpVtbl -> DeleteColumn(This,nCol)

#define IHeaderCtrl_SetColumnText(This,nCol,title)	\
    (This)->lpVtbl -> SetColumnText(This,nCol,title)

#define IHeaderCtrl_GetColumnText(This,nCol,pText)	\
    (This)->lpVtbl -> GetColumnText(This,nCol,pText)

#define IHeaderCtrl_SetColumnWidth(This,nCol,nWidth)	\
    (This)->lpVtbl -> SetColumnWidth(This,nCol,nWidth)

#define IHeaderCtrl_GetColumnWidth(This,nCol,pWidth)	\
    (This)->lpVtbl -> GetColumnWidth(This,nCol,pWidth)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_InsertColumn_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [in] */ LPCWSTR title,
    /* [in] */ int nFormat,
    /* [in] */ int nWidth);


void __RPC_STUB IHeaderCtrl_InsertColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_DeleteColumn_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol);


void __RPC_STUB IHeaderCtrl_DeleteColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_SetColumnText_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [in] */ LPCWSTR title);


void __RPC_STUB IHeaderCtrl_SetColumnText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_GetColumnText_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [out] */ LPOLESTR __RPC_FAR *pText);


void __RPC_STUB IHeaderCtrl_GetColumnText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_SetColumnWidth_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [in] */ int nWidth);


void __RPC_STUB IHeaderCtrl_SetColumnWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl_GetColumnWidth_Proxy( 
    IHeaderCtrl __RPC_FAR * This,
    /* [in] */ int nCol,
    /* [out] */ int __RPC_FAR *pWidth);


void __RPC_STUB IHeaderCtrl_GetColumnWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHeaderCtrl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mmc_0112 */
/* [local] */ 


enum __MIDL___MIDL_itf_mmc_0112_0001
    {	CCM_INSERTIONPOINTID_MASK_SPECIAL	= 0xffff0000,
	CCM_INSERTIONPOINTID_MASK_SHARED	= 0x80000000,
	CCM_INSERTIONPOINTID_MASK_CREATE_PRIMARY	= 0x40000000,
	CCM_INSERTIONPOINTID_MASK_ADD_PRIMARY	= 0x20000000,
	CCM_INSERTIONPOINTID_MASK_ADD_3RDPARTY	= 0x10000000,
	CCM_INSERTIONPOINTID_MASK_RESERVED	= 0xfff0000,
	CCM_INSERTIONPOINTID_MASK_FLAGINDEX	= 0x1f,
	CCM_INSERTIONPOINTID_PRIMARY_TOP	= 0xa0000000,
	CCM_INSERTIONPOINTID_PRIMARY_NEW	= 0xa0000001,
	CCM_INSERTIONPOINTID_PRIMARY_TASK	= 0xa0000002,
	CCM_INSERTIONPOINTID_PRIMARY_VIEW	= 0xa0000003,
	CCM_INSERTIONPOINTID_3RDPARTY_NEW	= 0x90000001,
	CCM_INSERTIONPOINTID_3RDPARTY_TASK	= 0x90000002,
	CCM_INSERTIONPOINTID_ROOT_MENU	= 0x80000000
    };

enum __MIDL___MIDL_itf_mmc_0112_0002
    {	CCM_INSERTIONALLOWED_TOP	= 1L << (CCM_INSERTIONPOINTID_PRIMARY_TOP & CCM_INSERTIONPOINTID_MASK_FLAGINDEX),
	CCM_INSERTIONALLOWED_NEW	= 1L << (CCM_INSERTIONPOINTID_PRIMARY_NEW & CCM_INSERTIONPOINTID_MASK_FLAGINDEX),
	CCM_INSERTIONALLOWED_TASK	= 1L << (CCM_INSERTIONPOINTID_PRIMARY_TASK & CCM_INSERTIONPOINTID_MASK_FLAGINDEX),
	CCM_INSERTIONALLOWED_VIEW	= 1L << (CCM_INSERTIONPOINTID_PRIMARY_VIEW & CCM_INSERTIONPOINTID_MASK_FLAGINDEX)
    };

enum __MIDL___MIDL_itf_mmc_0112_0003
    {	CCM_COMMANDID_MASK_RESERVED	= 0xffff0000
    };

enum __MIDL___MIDL_itf_mmc_0112_0004
    {	CCM_SPECIAL_SEPARATOR	= 0x1,
	CCM_SPECIAL_SUBMENU	= 0x2,
	CCM_SPECIAL_DEFAULT_ITEM	= 0x4,
	CCM_SPECIAL_INSERTION_POINT	= 0x8,
	CCM_SPECIAL_TESTONLY	= 0x10
    };


extern RPC_IF_HANDLE __MIDL_itf_mmc_0112_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mmc_0112_v0_0_s_ifspec;

#ifndef __IContextMenuCallback_INTERFACE_DEFINED__
#define __IContextMenuCallback_INTERFACE_DEFINED__

/* interface IContextMenuCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IContextMenuCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB7-D36C-11CF-ADBC-00AA00A80033")
    IContextMenuCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddItem( 
            /* [in] */ CONTEXTMENUITEM __RPC_FAR *pItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextMenuCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContextMenuCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContextMenuCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContextMenuCallback __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddItem )( 
            IContextMenuCallback __RPC_FAR * This,
            /* [in] */ CONTEXTMENUITEM __RPC_FAR *pItem);
        
        END_INTERFACE
    } IContextMenuCallbackVtbl;

    interface IContextMenuCallback
    {
        CONST_VTBL struct IContextMenuCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextMenuCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextMenuCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextMenuCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextMenuCallback_AddItem(This,pItem)	\
    (This)->lpVtbl -> AddItem(This,pItem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuCallback_AddItem_Proxy( 
    IContextMenuCallback __RPC_FAR * This,
    /* [in] */ CONTEXTMENUITEM __RPC_FAR *pItem);


void __RPC_STUB IContextMenuCallback_AddItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextMenuCallback_INTERFACE_DEFINED__ */


#ifndef __IContextMenuProvider_INTERFACE_DEFINED__
#define __IContextMenuProvider_INTERFACE_DEFINED__

/* interface IContextMenuProvider */
/* [unique][helpstring][object][uuid][object] */ 


EXTERN_C const IID IID_IContextMenuProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB6-D36C-11CF-ADBC-00AA00A80033")
    IContextMenuProvider : public IContextMenuCallback
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EmptyMenuList( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPrimaryExtensionItems( 
            /* [in] */ LPUNKNOWN piExtension,
            /* [in] */ LPDATAOBJECT piDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddThirdPartyExtensionItems( 
            /* [in] */ LPDATAOBJECT piDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ShowContextMenu( 
            /* [in] */ HWND hwndParent,
            /* [in] */ long xPos,
            /* [in] */ long yPos,
            /* [retval][out] */ long __RPC_FAR *plSelected) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IContextMenuProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContextMenuProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContextMenuProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContextMenuProvider __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddItem )( 
            IContextMenuProvider __RPC_FAR * This,
            /* [in] */ CONTEXTMENUITEM __RPC_FAR *pItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EmptyMenuList )( 
            IContextMenuProvider __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPrimaryExtensionItems )( 
            IContextMenuProvider __RPC_FAR * This,
            /* [in] */ LPUNKNOWN piExtension,
            /* [in] */ LPDATAOBJECT piDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddThirdPartyExtensionItems )( 
            IContextMenuProvider __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT piDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowContextMenu )( 
            IContextMenuProvider __RPC_FAR * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ long xPos,
            /* [in] */ long yPos,
            /* [retval][out] */ long __RPC_FAR *plSelected);
        
        END_INTERFACE
    } IContextMenuProviderVtbl;

    interface IContextMenuProvider
    {
        CONST_VTBL struct IContextMenuProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContextMenuProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContextMenuProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IContextMenuProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IContextMenuProvider_AddItem(This,pItem)	\
    (This)->lpVtbl -> AddItem(This,pItem)


#define IContextMenuProvider_EmptyMenuList(This)	\
    (This)->lpVtbl -> EmptyMenuList(This)

#define IContextMenuProvider_AddPrimaryExtensionItems(This,piExtension,piDataObject)	\
    (This)->lpVtbl -> AddPrimaryExtensionItems(This,piExtension,piDataObject)

#define IContextMenuProvider_AddThirdPartyExtensionItems(This,piDataObject)	\
    (This)->lpVtbl -> AddThirdPartyExtensionItems(This,piDataObject)

#define IContextMenuProvider_ShowContextMenu(This,hwndParent,xPos,yPos,plSelected)	\
    (This)->lpVtbl -> ShowContextMenu(This,hwndParent,xPos,yPos,plSelected)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuProvider_EmptyMenuList_Proxy( 
    IContextMenuProvider __RPC_FAR * This);


void __RPC_STUB IContextMenuProvider_EmptyMenuList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuProvider_AddPrimaryExtensionItems_Proxy( 
    IContextMenuProvider __RPC_FAR * This,
    /* [in] */ LPUNKNOWN piExtension,
    /* [in] */ LPDATAOBJECT piDataObject);


void __RPC_STUB IContextMenuProvider_AddPrimaryExtensionItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuProvider_AddThirdPartyExtensionItems_Proxy( 
    IContextMenuProvider __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT piDataObject);


void __RPC_STUB IContextMenuProvider_AddThirdPartyExtensionItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IContextMenuProvider_ShowContextMenu_Proxy( 
    IContextMenuProvider __RPC_FAR * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ long xPos,
    /* [in] */ long yPos,
    /* [retval][out] */ long __RPC_FAR *plSelected);


void __RPC_STUB IContextMenuProvider_ShowContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IContextMenuProvider_INTERFACE_DEFINED__ */


#ifndef __IExtendContextMenu_INTERFACE_DEFINED__
#define __IExtendContextMenu_INTERFACE_DEFINED__

/* interface IExtendContextMenu */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IExtendContextMenu;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4F3B7A4F-CFAC-11CF-B8E3-00C04FD8D5B0")
    IExtendContextMenu : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddMenuItems( 
            /* [in] */ LPDATAOBJECT piDataObject,
            /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
            /* [out][in] */ long __RPC_FAR *pInsertionAllowed) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Command( 
            /* [in] */ long lCommandID,
            /* [in] */ LPDATAOBJECT piDataObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtendContextMenuVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExtendContextMenu __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExtendContextMenu __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExtendContextMenu __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddMenuItems )( 
            IExtendContextMenu __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT piDataObject,
            /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
            /* [out][in] */ long __RPC_FAR *pInsertionAllowed);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Command )( 
            IExtendContextMenu __RPC_FAR * This,
            /* [in] */ long lCommandID,
            /* [in] */ LPDATAOBJECT piDataObject);
        
        END_INTERFACE
    } IExtendContextMenuVtbl;

    interface IExtendContextMenu
    {
        CONST_VTBL struct IExtendContextMenuVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtendContextMenu_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendContextMenu_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExtendContextMenu_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExtendContextMenu_AddMenuItems(This,piDataObject,piCallback,pInsertionAllowed)	\
    (This)->lpVtbl -> AddMenuItems(This,piDataObject,piCallback,pInsertionAllowed)

#define IExtendContextMenu_Command(This,lCommandID,piDataObject)	\
    (This)->lpVtbl -> Command(This,lCommandID,piDataObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendContextMenu_AddMenuItems_Proxy( 
    IExtendContextMenu __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT piDataObject,
    /* [in] */ LPCONTEXTMENUCALLBACK piCallback,
    /* [out][in] */ long __RPC_FAR *pInsertionAllowed);


void __RPC_STUB IExtendContextMenu_AddMenuItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendContextMenu_Command_Proxy( 
    IExtendContextMenu __RPC_FAR * This,
    /* [in] */ long lCommandID,
    /* [in] */ LPDATAOBJECT piDataObject);


void __RPC_STUB IExtendContextMenu_Command_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExtendContextMenu_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mmc_0115 */
/* [local] */ 

#if (MMC_VER >= 0x0120)
#define ILSIF_LEAVE_LARGE_ICON  0x40000000
#define ILSIF_LEAVE_SMALL_ICON  0x20000000
#define ILSIF_LEAVE_MASK        (ILSIF_LEAVE_LARGE_ICON | ILSIF_LEAVE_SMALL_ICON)
#define ILSI_LARGE_ICON(nLoc)   (nLoc | ILSIF_LEAVE_SMALL_ICON)
#define ILSI_SMALL_ICON(nLoc)   (nLoc | ILSIF_LEAVE_LARGE_ICON)
#endif // MMC_VER >= 0x0120


extern RPC_IF_HANDLE __MIDL_itf_mmc_0115_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mmc_0115_v0_0_s_ifspec;

#ifndef __IImageList_INTERFACE_DEFINED__
#define __IImageList_INTERFACE_DEFINED__

/* interface IImageList */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IImageList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB8-D36C-11CF-ADBC-00AA00A80033")
    IImageList : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ImageListSetIcon( 
            /* [in] */ LONG_PTR __RPC_FAR *pIcon,
            /* [in] */ long nLoc) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ImageListSetStrip( 
            /* [in] */ LONG_PTR __RPC_FAR *pBMapSm,
            /* [in] */ LONG_PTR __RPC_FAR *pBMapLg,
            /* [in] */ long nStartLoc,
            /* [in] */ COLORREF cMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImageList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImageList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImageList __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImageListSetIcon )( 
            IImageList __RPC_FAR * This,
            /* [in] */ LONG_PTR __RPC_FAR *pIcon,
            /* [in] */ long nLoc);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ImageListSetStrip )( 
            IImageList __RPC_FAR * This,
            /* [in] */ LONG_PTR __RPC_FAR *pBMapSm,
            /* [in] */ LONG_PTR __RPC_FAR *pBMapLg,
            /* [in] */ long nStartLoc,
            /* [in] */ COLORREF cMask);
        
        END_INTERFACE
    } IImageListVtbl;

    interface IImageList
    {
        CONST_VTBL struct IImageListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImageList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImageList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImageList_ImageListSetIcon(This,pIcon,nLoc)	\
    (This)->lpVtbl -> ImageListSetIcon(This,pIcon,nLoc)

#define IImageList_ImageListSetStrip(This,pBMapSm,pBMapLg,nStartLoc,cMask)	\
    (This)->lpVtbl -> ImageListSetStrip(This,pBMapSm,pBMapLg,nStartLoc,cMask)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IImageList_ImageListSetIcon_Proxy( 
    IImageList __RPC_FAR * This,
    /* [in] */ LONG_PTR __RPC_FAR *pIcon,
    /* [in] */ long nLoc);


void __RPC_STUB IImageList_ImageListSetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IImageList_ImageListSetStrip_Proxy( 
    IImageList __RPC_FAR * This,
    /* [in] */ LONG_PTR __RPC_FAR *pBMapSm,
    /* [in] */ LONG_PTR __RPC_FAR *pBMapLg,
    /* [in] */ long nStartLoc,
    /* [in] */ COLORREF cMask);


void __RPC_STUB IImageList_ImageListSetStrip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImageList_INTERFACE_DEFINED__ */


#ifndef __IResultData_INTERFACE_DEFINED__
#define __IResultData_INTERFACE_DEFINED__

/* interface IResultData */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IResultData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("31DA5FA0-E0EB-11cf-9F21-00AA003CA9F6")
    IResultData : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InsertItem( 
            /* [out][in] */ LPRESULTDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ int nCol) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindItemByLParam( 
            /* [in] */ LPARAM lParam,
            /* [out] */ HRESULTITEM __RPC_FAR *pItemID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteAllRsltItems( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetItem( 
            /* [in] */ LPRESULTDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetItem( 
            /* [out][in] */ LPRESULTDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextItem( 
            /* [out][in] */ LPRESULTDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ModifyItemState( 
            /* [in] */ int nIndex,
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ UINT uAdd,
            /* [in] */ UINT uRemove) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ModifyViewStyle( 
            /* [in] */ MMC_RESULT_VIEW_STYLE add,
            /* [in] */ MMC_RESULT_VIEW_STYLE remove) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetViewMode( 
            /* [in] */ long lViewMode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetViewMode( 
            /* [out] */ long __RPC_FAR *lViewMode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UpdateItem( 
            /* [in] */ HRESULTITEM itemID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Sort( 
            /* [in] */ int nColumn,
            /* [in] */ DWORD dwSortOptions,
            /* [in] */ LPARAM lUserParam) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDescBarText( 
            /* [in] */ LPOLESTR DescText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetItemCount( 
            /* [in] */ int nItemCount,
            /* [in] */ DWORD dwOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResultDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResultData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResultData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResultData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertItem )( 
            IResultData __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            IResultData __RPC_FAR * This,
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ int nCol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindItemByLParam )( 
            IResultData __RPC_FAR * This,
            /* [in] */ LPARAM lParam,
            /* [out] */ HRESULTITEM __RPC_FAR *pItemID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAllRsltItems )( 
            IResultData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItem )( 
            IResultData __RPC_FAR * This,
            /* [in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItem )( 
            IResultData __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextItem )( 
            IResultData __RPC_FAR * This,
            /* [out][in] */ LPRESULTDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModifyItemState )( 
            IResultData __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ HRESULTITEM itemID,
            /* [in] */ UINT uAdd,
            /* [in] */ UINT uRemove);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModifyViewStyle )( 
            IResultData __RPC_FAR * This,
            /* [in] */ MMC_RESULT_VIEW_STYLE add,
            /* [in] */ MMC_RESULT_VIEW_STYLE remove);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetViewMode )( 
            IResultData __RPC_FAR * This,
            /* [in] */ long lViewMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetViewMode )( 
            IResultData __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *lViewMode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateItem )( 
            IResultData __RPC_FAR * This,
            /* [in] */ HRESULTITEM itemID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Sort )( 
            IResultData __RPC_FAR * This,
            /* [in] */ int nColumn,
            /* [in] */ DWORD dwSortOptions,
            /* [in] */ LPARAM lUserParam);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDescBarText )( 
            IResultData __RPC_FAR * This,
            /* [in] */ LPOLESTR DescText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItemCount )( 
            IResultData __RPC_FAR * This,
            /* [in] */ int nItemCount,
            /* [in] */ DWORD dwOptions);
        
        END_INTERFACE
    } IResultDataVtbl;

    interface IResultData
    {
        CONST_VTBL struct IResultDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResultData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResultData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResultData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResultData_InsertItem(This,item)	\
    (This)->lpVtbl -> InsertItem(This,item)

#define IResultData_DeleteItem(This,itemID,nCol)	\
    (This)->lpVtbl -> DeleteItem(This,itemID,nCol)

#define IResultData_FindItemByLParam(This,lParam,pItemID)	\
    (This)->lpVtbl -> FindItemByLParam(This,lParam,pItemID)

#define IResultData_DeleteAllRsltItems(This)	\
    (This)->lpVtbl -> DeleteAllRsltItems(This)

#define IResultData_SetItem(This,item)	\
    (This)->lpVtbl -> SetItem(This,item)

#define IResultData_GetItem(This,item)	\
    (This)->lpVtbl -> GetItem(This,item)

#define IResultData_GetNextItem(This,item)	\
    (This)->lpVtbl -> GetNextItem(This,item)

#define IResultData_ModifyItemState(This,nIndex,itemID,uAdd,uRemove)	\
    (This)->lpVtbl -> ModifyItemState(This,nIndex,itemID,uAdd,uRemove)

#define IResultData_ModifyViewStyle(This,add,remove)	\
    (This)->lpVtbl -> ModifyViewStyle(This,add,remove)

#define IResultData_SetViewMode(This,lViewMode)	\
    (This)->lpVtbl -> SetViewMode(This,lViewMode)

#define IResultData_GetViewMode(This,lViewMode)	\
    (This)->lpVtbl -> GetViewMode(This,lViewMode)

#define IResultData_UpdateItem(This,itemID)	\
    (This)->lpVtbl -> UpdateItem(This,itemID)

#define IResultData_Sort(This,nColumn,dwSortOptions,lUserParam)	\
    (This)->lpVtbl -> Sort(This,nColumn,dwSortOptions,lUserParam)

#define IResultData_SetDescBarText(This,DescText)	\
    (This)->lpVtbl -> SetDescBarText(This,DescText)

#define IResultData_SetItemCount(This,nItemCount,dwOptions)	\
    (This)->lpVtbl -> SetItemCount(This,nItemCount,dwOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_InsertItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [out][in] */ LPRESULTDATAITEM item);


void __RPC_STUB IResultData_InsertItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_DeleteItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ HRESULTITEM itemID,
    /* [in] */ int nCol);


void __RPC_STUB IResultData_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_FindItemByLParam_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ LPARAM lParam,
    /* [out] */ HRESULTITEM __RPC_FAR *pItemID);


void __RPC_STUB IResultData_FindItemByLParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_DeleteAllRsltItems_Proxy( 
    IResultData __RPC_FAR * This);


void __RPC_STUB IResultData_DeleteAllRsltItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_SetItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ LPRESULTDATAITEM item);


void __RPC_STUB IResultData_SetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_GetItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [out][in] */ LPRESULTDATAITEM item);


void __RPC_STUB IResultData_GetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_GetNextItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [out][in] */ LPRESULTDATAITEM item);


void __RPC_STUB IResultData_GetNextItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_ModifyItemState_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [in] */ HRESULTITEM itemID,
    /* [in] */ UINT uAdd,
    /* [in] */ UINT uRemove);


void __RPC_STUB IResultData_ModifyItemState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_ModifyViewStyle_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ MMC_RESULT_VIEW_STYLE add,
    /* [in] */ MMC_RESULT_VIEW_STYLE remove);


void __RPC_STUB IResultData_ModifyViewStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_SetViewMode_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ long lViewMode);


void __RPC_STUB IResultData_SetViewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_GetViewMode_Proxy( 
    IResultData __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *lViewMode);


void __RPC_STUB IResultData_GetViewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_UpdateItem_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ HRESULTITEM itemID);


void __RPC_STUB IResultData_UpdateItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_Sort_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ int nColumn,
    /* [in] */ DWORD dwSortOptions,
    /* [in] */ LPARAM lUserParam);


void __RPC_STUB IResultData_Sort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_SetDescBarText_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ LPOLESTR DescText);


void __RPC_STUB IResultData_SetDescBarText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultData_SetItemCount_Proxy( 
    IResultData __RPC_FAR * This,
    /* [in] */ int nItemCount,
    /* [in] */ DWORD dwOptions);


void __RPC_STUB IResultData_SetItemCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResultData_INTERFACE_DEFINED__ */


#ifndef __IConsoleNameSpace_INTERFACE_DEFINED__
#define __IConsoleNameSpace_INTERFACE_DEFINED__

/* interface IConsoleNameSpace */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IConsoleNameSpace;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BEDEB620-F24D-11cf-8AFC-00AA003CA9F6")
    IConsoleNameSpace : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InsertItem( 
            /* [out][in] */ LPSCOPEDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ long fDeleteThis) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetItem( 
            /* [in] */ LPSCOPEDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetItem( 
            /* [out][in] */ LPSCOPEDATAITEM item) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetChildItem( 
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemChild,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextItem( 
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemNext,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetParentItem( 
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemParent,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConsoleNameSpaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IConsoleNameSpace __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IConsoleNameSpace __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [out][in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ long fDeleteThis);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [out][in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChildItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemChild,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemNext,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParentItem )( 
            IConsoleNameSpace __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemParent,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);
        
        END_INTERFACE
    } IConsoleNameSpaceVtbl;

    interface IConsoleNameSpace
    {
        CONST_VTBL struct IConsoleNameSpaceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConsoleNameSpace_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConsoleNameSpace_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConsoleNameSpace_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConsoleNameSpace_InsertItem(This,item)	\
    (This)->lpVtbl -> InsertItem(This,item)

#define IConsoleNameSpace_DeleteItem(This,hItem,fDeleteThis)	\
    (This)->lpVtbl -> DeleteItem(This,hItem,fDeleteThis)

#define IConsoleNameSpace_SetItem(This,item)	\
    (This)->lpVtbl -> SetItem(This,item)

#define IConsoleNameSpace_GetItem(This,item)	\
    (This)->lpVtbl -> GetItem(This,item)

#define IConsoleNameSpace_GetChildItem(This,item,pItemChild,pCookie)	\
    (This)->lpVtbl -> GetChildItem(This,item,pItemChild,pCookie)

#define IConsoleNameSpace_GetNextItem(This,item,pItemNext,pCookie)	\
    (This)->lpVtbl -> GetNextItem(This,item,pItemNext,pCookie)

#define IConsoleNameSpace_GetParentItem(This,item,pItemParent,pCookie)	\
    (This)->lpVtbl -> GetParentItem(This,item,pItemParent,pCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_InsertItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [out][in] */ LPSCOPEDATAITEM item);


void __RPC_STUB IConsoleNameSpace_InsertItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_DeleteItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [in] */ HSCOPEITEM hItem,
    /* [in] */ long fDeleteThis);


void __RPC_STUB IConsoleNameSpace_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_SetItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [in] */ LPSCOPEDATAITEM item);


void __RPC_STUB IConsoleNameSpace_SetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_GetItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [out][in] */ LPSCOPEDATAITEM item);


void __RPC_STUB IConsoleNameSpace_GetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_GetChildItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [in] */ HSCOPEITEM item,
    /* [out] */ HSCOPEITEM __RPC_FAR *pItemChild,
    /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);


void __RPC_STUB IConsoleNameSpace_GetChildItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_GetNextItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [in] */ HSCOPEITEM item,
    /* [out] */ HSCOPEITEM __RPC_FAR *pItemNext,
    /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);


void __RPC_STUB IConsoleNameSpace_GetNextItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace_GetParentItem_Proxy( 
    IConsoleNameSpace __RPC_FAR * This,
    /* [in] */ HSCOPEITEM item,
    /* [out] */ HSCOPEITEM __RPC_FAR *pItemParent,
    /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);


void __RPC_STUB IConsoleNameSpace_GetParentItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConsoleNameSpace_INTERFACE_DEFINED__ */


#ifndef __IConsoleNameSpace2_INTERFACE_DEFINED__
#define __IConsoleNameSpace2_INTERFACE_DEFINED__

/* interface IConsoleNameSpace2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IConsoleNameSpace2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("255F18CC-65DB-11D1-A7DC-00C04FD8D565")
    IConsoleNameSpace2 : public IConsoleNameSpace
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Expand( 
            /* [in] */ HSCOPEITEM hItem) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddExtension( 
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ LPCLSID lpClsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConsoleNameSpace2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IConsoleNameSpace2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IConsoleNameSpace2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IConsoleNameSpace2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertItem )( 
            IConsoleNameSpace2 __RPC_FAR * This,
            /* [out][in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            IConsoleNameSpace2 __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ long fDeleteThis);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItem )( 
            IConsoleNameSpace2 __RPC_FAR * This,
            /* [in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItem )( 
            IConsoleNameSpace2 __RPC_FAR * This,
            /* [out][in] */ LPSCOPEDATAITEM item);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChildItem )( 
            IConsoleNameSpace2 __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemChild,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextItem )( 
            IConsoleNameSpace2 __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemNext,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParentItem )( 
            IConsoleNameSpace2 __RPC_FAR * This,
            /* [in] */ HSCOPEITEM item,
            /* [out] */ HSCOPEITEM __RPC_FAR *pItemParent,
            /* [out] */ MMC_COOKIE __RPC_FAR *pCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Expand )( 
            IConsoleNameSpace2 __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddExtension )( 
            IConsoleNameSpace2 __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ LPCLSID lpClsid);
        
        END_INTERFACE
    } IConsoleNameSpace2Vtbl;

    interface IConsoleNameSpace2
    {
        CONST_VTBL struct IConsoleNameSpace2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConsoleNameSpace2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConsoleNameSpace2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConsoleNameSpace2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConsoleNameSpace2_InsertItem(This,item)	\
    (This)->lpVtbl -> InsertItem(This,item)

#define IConsoleNameSpace2_DeleteItem(This,hItem,fDeleteThis)	\
    (This)->lpVtbl -> DeleteItem(This,hItem,fDeleteThis)

#define IConsoleNameSpace2_SetItem(This,item)	\
    (This)->lpVtbl -> SetItem(This,item)

#define IConsoleNameSpace2_GetItem(This,item)	\
    (This)->lpVtbl -> GetItem(This,item)

#define IConsoleNameSpace2_GetChildItem(This,item,pItemChild,pCookie)	\
    (This)->lpVtbl -> GetChildItem(This,item,pItemChild,pCookie)

#define IConsoleNameSpace2_GetNextItem(This,item,pItemNext,pCookie)	\
    (This)->lpVtbl -> GetNextItem(This,item,pItemNext,pCookie)

#define IConsoleNameSpace2_GetParentItem(This,item,pItemParent,pCookie)	\
    (This)->lpVtbl -> GetParentItem(This,item,pItemParent,pCookie)


#define IConsoleNameSpace2_Expand(This,hItem)	\
    (This)->lpVtbl -> Expand(This,hItem)

#define IConsoleNameSpace2_AddExtension(This,hItem,lpClsid)	\
    (This)->lpVtbl -> AddExtension(This,hItem,lpClsid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace2_Expand_Proxy( 
    IConsoleNameSpace2 __RPC_FAR * This,
    /* [in] */ HSCOPEITEM hItem);


void __RPC_STUB IConsoleNameSpace2_Expand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleNameSpace2_AddExtension_Proxy( 
    IConsoleNameSpace2 __RPC_FAR * This,
    /* [in] */ HSCOPEITEM hItem,
    /* [in] */ LPCLSID lpClsid);


void __RPC_STUB IConsoleNameSpace2_AddExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConsoleNameSpace2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mmc_0120 */
/* [local] */ 


typedef struct _PSP __RPC_FAR *HPROPSHEETPAGE;



extern RPC_IF_HANDLE __MIDL_itf_mmc_0120_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mmc_0120_v0_0_s_ifspec;

#ifndef __IPropertySheetCallback_INTERFACE_DEFINED__
#define __IPropertySheetCallback_INTERFACE_DEFINED__

/* interface IPropertySheetCallback */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IPropertySheetCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85DE64DD-EF21-11cf-A285-00C04FD8DBE6")
    IPropertySheetCallback : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPage( 
            /* [in] */ HPROPSHEETPAGE hPage) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemovePage( 
            /* [in] */ HPROPSHEETPAGE hPage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySheetCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertySheetCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertySheetCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertySheetCallback __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPage )( 
            IPropertySheetCallback __RPC_FAR * This,
            /* [in] */ HPROPSHEETPAGE hPage);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemovePage )( 
            IPropertySheetCallback __RPC_FAR * This,
            /* [in] */ HPROPSHEETPAGE hPage);
        
        END_INTERFACE
    } IPropertySheetCallbackVtbl;

    interface IPropertySheetCallback
    {
        CONST_VTBL struct IPropertySheetCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySheetCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertySheetCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertySheetCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertySheetCallback_AddPage(This,hPage)	\
    (This)->lpVtbl -> AddPage(This,hPage)

#define IPropertySheetCallback_RemovePage(This,hPage)	\
    (This)->lpVtbl -> RemovePage(This,hPage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetCallback_AddPage_Proxy( 
    IPropertySheetCallback __RPC_FAR * This,
    /* [in] */ HPROPSHEETPAGE hPage);


void __RPC_STUB IPropertySheetCallback_AddPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetCallback_RemovePage_Proxy( 
    IPropertySheetCallback __RPC_FAR * This,
    /* [in] */ HPROPSHEETPAGE hPage);


void __RPC_STUB IPropertySheetCallback_RemovePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertySheetCallback_INTERFACE_DEFINED__ */


#ifndef __IPropertySheetProvider_INTERFACE_DEFINED__
#define __IPropertySheetProvider_INTERFACE_DEFINED__

/* interface IPropertySheetProvider */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPropertySheetProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85DE64DE-EF21-11cf-A285-00C04FD8DBE6")
    IPropertySheetProvider : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertySheet( 
            /* [in] */ LPCWSTR title,
            /* [in] */ boolean type,
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ LPDATAOBJECT pIDataObjectm,
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindPropertySheet( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ LPCOMPONENT lpComponent,
            /* [in] */ LPDATAOBJECT lpDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddPrimaryPages( 
            LPUNKNOWN lpUnknown,
            BOOL bCreateHandle,
            HWND hNotifyWindow,
            BOOL bScopePane) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddExtensionPages( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ LONG_PTR window,
            /* [in] */ int page) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySheetProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertySheetProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertySheetProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertySheetProvider __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertySheet )( 
            IPropertySheetProvider __RPC_FAR * This,
            /* [in] */ LPCWSTR title,
            /* [in] */ boolean type,
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ LPDATAOBJECT pIDataObjectm,
            /* [in] */ DWORD dwOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindPropertySheet )( 
            IPropertySheetProvider __RPC_FAR * This,
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ LPCOMPONENT lpComponent,
            /* [in] */ LPDATAOBJECT lpDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPrimaryPages )( 
            IPropertySheetProvider __RPC_FAR * This,
            LPUNKNOWN lpUnknown,
            BOOL bCreateHandle,
            HWND hNotifyWindow,
            BOOL bScopePane);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddExtensionPages )( 
            IPropertySheetProvider __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Show )( 
            IPropertySheetProvider __RPC_FAR * This,
            /* [in] */ LONG_PTR window,
            /* [in] */ int page);
        
        END_INTERFACE
    } IPropertySheetProviderVtbl;

    interface IPropertySheetProvider
    {
        CONST_VTBL struct IPropertySheetProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySheetProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertySheetProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertySheetProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertySheetProvider_CreatePropertySheet(This,title,type,cookie,pIDataObjectm,dwOptions)	\
    (This)->lpVtbl -> CreatePropertySheet(This,title,type,cookie,pIDataObjectm,dwOptions)

#define IPropertySheetProvider_FindPropertySheet(This,cookie,lpComponent,lpDataObject)	\
    (This)->lpVtbl -> FindPropertySheet(This,cookie,lpComponent,lpDataObject)

#define IPropertySheetProvider_AddPrimaryPages(This,lpUnknown,bCreateHandle,hNotifyWindow,bScopePane)	\
    (This)->lpVtbl -> AddPrimaryPages(This,lpUnknown,bCreateHandle,hNotifyWindow,bScopePane)

#define IPropertySheetProvider_AddExtensionPages(This)	\
    (This)->lpVtbl -> AddExtensionPages(This)

#define IPropertySheetProvider_Show(This,window,page)	\
    (This)->lpVtbl -> Show(This,window,page)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProvider_CreatePropertySheet_Proxy( 
    IPropertySheetProvider __RPC_FAR * This,
    /* [in] */ LPCWSTR title,
    /* [in] */ boolean type,
    /* [in] */ MMC_COOKIE cookie,
    /* [in] */ LPDATAOBJECT pIDataObjectm,
    /* [in] */ DWORD dwOptions);


void __RPC_STUB IPropertySheetProvider_CreatePropertySheet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProvider_FindPropertySheet_Proxy( 
    IPropertySheetProvider __RPC_FAR * This,
    /* [in] */ MMC_COOKIE cookie,
    /* [in] */ LPCOMPONENT lpComponent,
    /* [in] */ LPDATAOBJECT lpDataObject);


void __RPC_STUB IPropertySheetProvider_FindPropertySheet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProvider_AddPrimaryPages_Proxy( 
    IPropertySheetProvider __RPC_FAR * This,
    LPUNKNOWN lpUnknown,
    BOOL bCreateHandle,
    HWND hNotifyWindow,
    BOOL bScopePane);


void __RPC_STUB IPropertySheetProvider_AddPrimaryPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProvider_AddExtensionPages_Proxy( 
    IPropertySheetProvider __RPC_FAR * This);


void __RPC_STUB IPropertySheetProvider_AddExtensionPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IPropertySheetProvider_Show_Proxy( 
    IPropertySheetProvider __RPC_FAR * This,
    /* [in] */ LONG_PTR window,
    /* [in] */ int page);


void __RPC_STUB IPropertySheetProvider_Show_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertySheetProvider_INTERFACE_DEFINED__ */


#ifndef __IExtendPropertySheet_INTERFACE_DEFINED__
#define __IExtendPropertySheet_INTERFACE_DEFINED__

/* interface IExtendPropertySheet */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IExtendPropertySheet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85DE64DC-EF21-11cf-A285-00C04FD8DBE6")
    IExtendPropertySheet : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
            /* [in] */ LONG_PTR handle,
            /* [in] */ LPDATAOBJECT lpIDataObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
            /* [in] */ LPDATAOBJECT lpDataObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtendPropertySheetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExtendPropertySheet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExtendPropertySheet __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExtendPropertySheet __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertyPages )( 
            IExtendPropertySheet __RPC_FAR * This,
            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
            /* [in] */ LONG_PTR handle,
            /* [in] */ LPDATAOBJECT lpIDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryPagesFor )( 
            IExtendPropertySheet __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject);
        
        END_INTERFACE
    } IExtendPropertySheetVtbl;

    interface IExtendPropertySheet
    {
        CONST_VTBL struct IExtendPropertySheetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtendPropertySheet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendPropertySheet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExtendPropertySheet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExtendPropertySheet_CreatePropertyPages(This,lpProvider,handle,lpIDataObject)	\
    (This)->lpVtbl -> CreatePropertyPages(This,lpProvider,handle,lpIDataObject)

#define IExtendPropertySheet_QueryPagesFor(This,lpDataObject)	\
    (This)->lpVtbl -> QueryPagesFor(This,lpDataObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendPropertySheet_CreatePropertyPages_Proxy( 
    IExtendPropertySheet __RPC_FAR * This,
    /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
    /* [in] */ LONG_PTR handle,
    /* [in] */ LPDATAOBJECT lpIDataObject);


void __RPC_STUB IExtendPropertySheet_CreatePropertyPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendPropertySheet_QueryPagesFor_Proxy( 
    IExtendPropertySheet __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpDataObject);


void __RPC_STUB IExtendPropertySheet_QueryPagesFor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExtendPropertySheet_INTERFACE_DEFINED__ */


#ifndef __IControlbar_INTERFACE_DEFINED__
#define __IControlbar_INTERFACE_DEFINED__

/* interface IControlbar */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IControlbar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("69FB811E-6C1C-11D0-A2CB-00C04FD909DD")
    IControlbar : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ MMC_CONTROL_TYPE nType,
            /* [in] */ LPEXTENDCONTROLBAR pExtendControlbar,
            /* [out] */ LPUNKNOWN __RPC_FAR *ppUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Attach( 
            /* [in] */ MMC_CONTROL_TYPE nType,
            /* [in] */ LPUNKNOWN lpUnknown) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Detach( 
            /* [in] */ LPUNKNOWN lpUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IControlbarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IControlbar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IControlbar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IControlbar __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Create )( 
            IControlbar __RPC_FAR * This,
            /* [in] */ MMC_CONTROL_TYPE nType,
            /* [in] */ LPEXTENDCONTROLBAR pExtendControlbar,
            /* [out] */ LPUNKNOWN __RPC_FAR *ppUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Attach )( 
            IControlbar __RPC_FAR * This,
            /* [in] */ MMC_CONTROL_TYPE nType,
            /* [in] */ LPUNKNOWN lpUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Detach )( 
            IControlbar __RPC_FAR * This,
            /* [in] */ LPUNKNOWN lpUnknown);
        
        END_INTERFACE
    } IControlbarVtbl;

    interface IControlbar
    {
        CONST_VTBL struct IControlbarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IControlbar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IControlbar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IControlbar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IControlbar_Create(This,nType,pExtendControlbar,ppUnknown)	\
    (This)->lpVtbl -> Create(This,nType,pExtendControlbar,ppUnknown)

#define IControlbar_Attach(This,nType,lpUnknown)	\
    (This)->lpVtbl -> Attach(This,nType,lpUnknown)

#define IControlbar_Detach(This,lpUnknown)	\
    (This)->lpVtbl -> Detach(This,lpUnknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IControlbar_Create_Proxy( 
    IControlbar __RPC_FAR * This,
    /* [in] */ MMC_CONTROL_TYPE nType,
    /* [in] */ LPEXTENDCONTROLBAR pExtendControlbar,
    /* [out] */ LPUNKNOWN __RPC_FAR *ppUnknown);


void __RPC_STUB IControlbar_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IControlbar_Attach_Proxy( 
    IControlbar __RPC_FAR * This,
    /* [in] */ MMC_CONTROL_TYPE nType,
    /* [in] */ LPUNKNOWN lpUnknown);


void __RPC_STUB IControlbar_Attach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IControlbar_Detach_Proxy( 
    IControlbar __RPC_FAR * This,
    /* [in] */ LPUNKNOWN lpUnknown);


void __RPC_STUB IControlbar_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IControlbar_INTERFACE_DEFINED__ */


#ifndef __IExtendControlbar_INTERFACE_DEFINED__
#define __IExtendControlbar_INTERFACE_DEFINED__

/* interface IExtendControlbar */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IExtendControlbar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49506520-6F40-11D0-A98B-00C04FD8D565")
    IExtendControlbar : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControlbar( 
            /* [in] */ LPCONTROLBAR pControlbar) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ControlbarNotify( 
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtendControlbarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExtendControlbar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExtendControlbar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExtendControlbar __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetControlbar )( 
            IExtendControlbar __RPC_FAR * This,
            /* [in] */ LPCONTROLBAR pControlbar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ControlbarNotify )( 
            IExtendControlbar __RPC_FAR * This,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
        
        END_INTERFACE
    } IExtendControlbarVtbl;

    interface IExtendControlbar
    {
        CONST_VTBL struct IExtendControlbarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtendControlbar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendControlbar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExtendControlbar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExtendControlbar_SetControlbar(This,pControlbar)	\
    (This)->lpVtbl -> SetControlbar(This,pControlbar)

#define IExtendControlbar_ControlbarNotify(This,event,arg,param)	\
    (This)->lpVtbl -> ControlbarNotify(This,event,arg,param)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendControlbar_SetControlbar_Proxy( 
    IExtendControlbar __RPC_FAR * This,
    /* [in] */ LPCONTROLBAR pControlbar);


void __RPC_STUB IExtendControlbar_SetControlbar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendControlbar_ControlbarNotify_Proxy( 
    IExtendControlbar __RPC_FAR * This,
    /* [in] */ MMC_NOTIFY_TYPE event,
    /* [in] */ LPARAM arg,
    /* [in] */ LPARAM param);


void __RPC_STUB IExtendControlbar_ControlbarNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExtendControlbar_INTERFACE_DEFINED__ */


#ifndef __IToolbar_INTERFACE_DEFINED__
#define __IToolbar_INTERFACE_DEFINED__

/* interface IToolbar */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IToolbar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43136EB9-D36C-11CF-ADBC-00AA00A80033")
    IToolbar : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddBitmap( 
            /* [in] */ int nImages,
            /* [in] */ HBITMAP hbmp,
            /* [in] */ int cxSize,
            /* [in] */ int cySize,
            /* [in] */ COLORREF crMask) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddButtons( 
            /* [in] */ int nButtons,
            /* [in] */ LPMMCBUTTON lpButtons) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE InsertButton( 
            /* [in] */ int nIndex,
            /* [in] */ LPMMCBUTTON lpButton) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteButton( 
            /* [in] */ int nIndex) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetButtonState( 
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [out] */ BOOL __RPC_FAR *pState) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetButtonState( 
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IToolbarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IToolbar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IToolbar __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddBitmap )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int nImages,
            /* [in] */ HBITMAP hbmp,
            /* [in] */ int cxSize,
            /* [in] */ int cySize,
            /* [in] */ COLORREF crMask);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddButtons )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int nButtons,
            /* [in] */ LPMMCBUTTON lpButtons);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertButton )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ LPMMCBUTTON lpButton);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteButton )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int nIndex);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetButtonState )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [out] */ BOOL __RPC_FAR *pState);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetButtonState )( 
            IToolbar __RPC_FAR * This,
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState);
        
        END_INTERFACE
    } IToolbarVtbl;

    interface IToolbar
    {
        CONST_VTBL struct IToolbarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IToolbar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IToolbar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IToolbar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IToolbar_AddBitmap(This,nImages,hbmp,cxSize,cySize,crMask)	\
    (This)->lpVtbl -> AddBitmap(This,nImages,hbmp,cxSize,cySize,crMask)

#define IToolbar_AddButtons(This,nButtons,lpButtons)	\
    (This)->lpVtbl -> AddButtons(This,nButtons,lpButtons)

#define IToolbar_InsertButton(This,nIndex,lpButton)	\
    (This)->lpVtbl -> InsertButton(This,nIndex,lpButton)

#define IToolbar_DeleteButton(This,nIndex)	\
    (This)->lpVtbl -> DeleteButton(This,nIndex)

#define IToolbar_GetButtonState(This,idCommand,nState,pState)	\
    (This)->lpVtbl -> GetButtonState(This,idCommand,nState,pState)

#define IToolbar_SetButtonState(This,idCommand,nState,bState)	\
    (This)->lpVtbl -> SetButtonState(This,idCommand,nState,bState)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_AddBitmap_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int nImages,
    /* [in] */ HBITMAP hbmp,
    /* [in] */ int cxSize,
    /* [in] */ int cySize,
    /* [in] */ COLORREF crMask);


void __RPC_STUB IToolbar_AddBitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_AddButtons_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int nButtons,
    /* [in] */ LPMMCBUTTON lpButtons);


void __RPC_STUB IToolbar_AddButtons_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_InsertButton_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [in] */ LPMMCBUTTON lpButton);


void __RPC_STUB IToolbar_InsertButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_DeleteButton_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int nIndex);


void __RPC_STUB IToolbar_DeleteButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_GetButtonState_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int idCommand,
    /* [in] */ MMC_BUTTON_STATE nState,
    /* [out] */ BOOL __RPC_FAR *pState);


void __RPC_STUB IToolbar_GetButtonState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IToolbar_SetButtonState_Proxy( 
    IToolbar __RPC_FAR * This,
    /* [in] */ int idCommand,
    /* [in] */ MMC_BUTTON_STATE nState,
    /* [in] */ BOOL bState);


void __RPC_STUB IToolbar_SetButtonState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IToolbar_INTERFACE_DEFINED__ */


#ifndef __IConsoleVerb_INTERFACE_DEFINED__
#define __IConsoleVerb_INTERFACE_DEFINED__

/* interface IConsoleVerb */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IConsoleVerb;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E49F7A60-74AF-11D0-A286-00C04FD8FE93")
    IConsoleVerb : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetVerbState( 
            /* [in] */ MMC_CONSOLE_VERB eCmdID,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [out] */ BOOL __RPC_FAR *pState) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetVerbState( 
            /* [in] */ MMC_CONSOLE_VERB eCmdID,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDefaultVerb( 
            /* [in] */ MMC_CONSOLE_VERB eCmdID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDefaultVerb( 
            /* [out] */ MMC_CONSOLE_VERB __RPC_FAR *peCmdID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConsoleVerbVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IConsoleVerb __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IConsoleVerb __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IConsoleVerb __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVerbState )( 
            IConsoleVerb __RPC_FAR * This,
            /* [in] */ MMC_CONSOLE_VERB eCmdID,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [out] */ BOOL __RPC_FAR *pState);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVerbState )( 
            IConsoleVerb __RPC_FAR * This,
            /* [in] */ MMC_CONSOLE_VERB eCmdID,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultVerb )( 
            IConsoleVerb __RPC_FAR * This,
            /* [in] */ MMC_CONSOLE_VERB eCmdID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultVerb )( 
            IConsoleVerb __RPC_FAR * This,
            /* [out] */ MMC_CONSOLE_VERB __RPC_FAR *peCmdID);
        
        END_INTERFACE
    } IConsoleVerbVtbl;

    interface IConsoleVerb
    {
        CONST_VTBL struct IConsoleVerbVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConsoleVerb_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConsoleVerb_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConsoleVerb_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConsoleVerb_GetVerbState(This,eCmdID,nState,pState)	\
    (This)->lpVtbl -> GetVerbState(This,eCmdID,nState,pState)

#define IConsoleVerb_SetVerbState(This,eCmdID,nState,bState)	\
    (This)->lpVtbl -> SetVerbState(This,eCmdID,nState,bState)

#define IConsoleVerb_SetDefaultVerb(This,eCmdID)	\
    (This)->lpVtbl -> SetDefaultVerb(This,eCmdID)

#define IConsoleVerb_GetDefaultVerb(This,peCmdID)	\
    (This)->lpVtbl -> GetDefaultVerb(This,peCmdID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleVerb_GetVerbState_Proxy( 
    IConsoleVerb __RPC_FAR * This,
    /* [in] */ MMC_CONSOLE_VERB eCmdID,
    /* [in] */ MMC_BUTTON_STATE nState,
    /* [out] */ BOOL __RPC_FAR *pState);


void __RPC_STUB IConsoleVerb_GetVerbState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleVerb_SetVerbState_Proxy( 
    IConsoleVerb __RPC_FAR * This,
    /* [in] */ MMC_CONSOLE_VERB eCmdID,
    /* [in] */ MMC_BUTTON_STATE nState,
    /* [in] */ BOOL bState);


void __RPC_STUB IConsoleVerb_SetVerbState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleVerb_SetDefaultVerb_Proxy( 
    IConsoleVerb __RPC_FAR * This,
    /* [in] */ MMC_CONSOLE_VERB eCmdID);


void __RPC_STUB IConsoleVerb_SetDefaultVerb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsoleVerb_GetDefaultVerb_Proxy( 
    IConsoleVerb __RPC_FAR * This,
    /* [out] */ MMC_CONSOLE_VERB __RPC_FAR *peCmdID);


void __RPC_STUB IConsoleVerb_GetDefaultVerb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConsoleVerb_INTERFACE_DEFINED__ */


#ifndef __ISnapinAbout_INTERFACE_DEFINED__
#define __ISnapinAbout_INTERFACE_DEFINED__

/* interface ISnapinAbout */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISnapinAbout;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1245208C-A151-11D0-A7D7-00C04FD909DD")
    ISnapinAbout : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinDescription( 
            /* [out] */ LPOLESTR __RPC_FAR *lpDescription) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProvider( 
            /* [out] */ LPOLESTR __RPC_FAR *lpName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinVersion( 
            /* [out] */ LPOLESTR __RPC_FAR *lpVersion) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSnapinImage( 
            /* [out] */ HICON __RPC_FAR *hAppIcon) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStaticFolderImage( 
            /* [out] */ HBITMAP __RPC_FAR *hSmallImage,
            /* [out] */ HBITMAP __RPC_FAR *hSmallImageOpen,
            /* [out] */ HBITMAP __RPC_FAR *hLargeImage,
            /* [out] */ COLORREF __RPC_FAR *cMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISnapinAboutVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISnapinAbout __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISnapinAbout __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISnapinAbout __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSnapinDescription )( 
            ISnapinAbout __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *lpDescription);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProvider )( 
            ISnapinAbout __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *lpName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSnapinVersion )( 
            ISnapinAbout __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *lpVersion);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSnapinImage )( 
            ISnapinAbout __RPC_FAR * This,
            /* [out] */ HICON __RPC_FAR *hAppIcon);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStaticFolderImage )( 
            ISnapinAbout __RPC_FAR * This,
            /* [out] */ HBITMAP __RPC_FAR *hSmallImage,
            /* [out] */ HBITMAP __RPC_FAR *hSmallImageOpen,
            /* [out] */ HBITMAP __RPC_FAR *hLargeImage,
            /* [out] */ COLORREF __RPC_FAR *cMask);
        
        END_INTERFACE
    } ISnapinAboutVtbl;

    interface ISnapinAbout
    {
        CONST_VTBL struct ISnapinAboutVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISnapinAbout_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISnapinAbout_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISnapinAbout_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISnapinAbout_GetSnapinDescription(This,lpDescription)	\
    (This)->lpVtbl -> GetSnapinDescription(This,lpDescription)

#define ISnapinAbout_GetProvider(This,lpName)	\
    (This)->lpVtbl -> GetProvider(This,lpName)

#define ISnapinAbout_GetSnapinVersion(This,lpVersion)	\
    (This)->lpVtbl -> GetSnapinVersion(This,lpVersion)

#define ISnapinAbout_GetSnapinImage(This,hAppIcon)	\
    (This)->lpVtbl -> GetSnapinImage(This,hAppIcon)

#define ISnapinAbout_GetStaticFolderImage(This,hSmallImage,hSmallImageOpen,hLargeImage,cMask)	\
    (This)->lpVtbl -> GetStaticFolderImage(This,hSmallImage,hSmallImageOpen,hLargeImage,cMask)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetSnapinDescription_Proxy( 
    ISnapinAbout __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *lpDescription);


void __RPC_STUB ISnapinAbout_GetSnapinDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetProvider_Proxy( 
    ISnapinAbout __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *lpName);


void __RPC_STUB ISnapinAbout_GetProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetSnapinVersion_Proxy( 
    ISnapinAbout __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *lpVersion);


void __RPC_STUB ISnapinAbout_GetSnapinVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetSnapinImage_Proxy( 
    ISnapinAbout __RPC_FAR * This,
    /* [out] */ HICON __RPC_FAR *hAppIcon);


void __RPC_STUB ISnapinAbout_GetSnapinImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinAbout_GetStaticFolderImage_Proxy( 
    ISnapinAbout __RPC_FAR * This,
    /* [out] */ HBITMAP __RPC_FAR *hSmallImage,
    /* [out] */ HBITMAP __RPC_FAR *hSmallImageOpen,
    /* [out] */ HBITMAP __RPC_FAR *hLargeImage,
    /* [out] */ COLORREF __RPC_FAR *cMask);


void __RPC_STUB ISnapinAbout_GetStaticFolderImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISnapinAbout_INTERFACE_DEFINED__ */


#ifndef __IMenuButton_INTERFACE_DEFINED__
#define __IMenuButton_INTERFACE_DEFINED__

/* interface IMenuButton */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IMenuButton;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("951ED750-D080-11d0-B197-000000000000")
    IMenuButton : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddButton( 
            /* [in] */ int idCommand,
            /* [in] */ LPOLESTR lpButtonText,
            /* [in] */ LPOLESTR lpTooltipText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetButton( 
            /* [in] */ int idCommand,
            /* [in] */ LPOLESTR lpButtonText,
            /* [in] */ LPOLESTR lpTooltipText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetButtonState( 
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMenuButtonVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMenuButton __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMenuButton __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMenuButton __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddButton )( 
            IMenuButton __RPC_FAR * This,
            /* [in] */ int idCommand,
            /* [in] */ LPOLESTR lpButtonText,
            /* [in] */ LPOLESTR lpTooltipText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetButton )( 
            IMenuButton __RPC_FAR * This,
            /* [in] */ int idCommand,
            /* [in] */ LPOLESTR lpButtonText,
            /* [in] */ LPOLESTR lpTooltipText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetButtonState )( 
            IMenuButton __RPC_FAR * This,
            /* [in] */ int idCommand,
            /* [in] */ MMC_BUTTON_STATE nState,
            /* [in] */ BOOL bState);
        
        END_INTERFACE
    } IMenuButtonVtbl;

    interface IMenuButton
    {
        CONST_VTBL struct IMenuButtonVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMenuButton_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMenuButton_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMenuButton_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMenuButton_AddButton(This,idCommand,lpButtonText,lpTooltipText)	\
    (This)->lpVtbl -> AddButton(This,idCommand,lpButtonText,lpTooltipText)

#define IMenuButton_SetButton(This,idCommand,lpButtonText,lpTooltipText)	\
    (This)->lpVtbl -> SetButton(This,idCommand,lpButtonText,lpTooltipText)

#define IMenuButton_SetButtonState(This,idCommand,nState,bState)	\
    (This)->lpVtbl -> SetButtonState(This,idCommand,nState,bState)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMenuButton_AddButton_Proxy( 
    IMenuButton __RPC_FAR * This,
    /* [in] */ int idCommand,
    /* [in] */ LPOLESTR lpButtonText,
    /* [in] */ LPOLESTR lpTooltipText);


void __RPC_STUB IMenuButton_AddButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMenuButton_SetButton_Proxy( 
    IMenuButton __RPC_FAR * This,
    /* [in] */ int idCommand,
    /* [in] */ LPOLESTR lpButtonText,
    /* [in] */ LPOLESTR lpTooltipText);


void __RPC_STUB IMenuButton_SetButton_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMenuButton_SetButtonState_Proxy( 
    IMenuButton __RPC_FAR * This,
    /* [in] */ int idCommand,
    /* [in] */ MMC_BUTTON_STATE nState,
    /* [in] */ BOOL bState);


void __RPC_STUB IMenuButton_SetButtonState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMenuButton_INTERFACE_DEFINED__ */


#ifndef __ISnapinHelp_INTERFACE_DEFINED__
#define __ISnapinHelp_INTERFACE_DEFINED__

/* interface ISnapinHelp */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISnapinHelp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A6B15ACE-DF59-11D0-A7DD-00C04FD909DD")
    ISnapinHelp : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetHelpTopic( 
            /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISnapinHelpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISnapinHelp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISnapinHelp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISnapinHelp __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHelpTopic )( 
            ISnapinHelp __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile);
        
        END_INTERFACE
    } ISnapinHelpVtbl;

    interface ISnapinHelp
    {
        CONST_VTBL struct ISnapinHelpVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISnapinHelp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISnapinHelp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISnapinHelp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISnapinHelp_GetHelpTopic(This,lpCompiledHelpFile)	\
    (This)->lpVtbl -> GetHelpTopic(This,lpCompiledHelpFile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinHelp_GetHelpTopic_Proxy( 
    ISnapinHelp __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile);


void __RPC_STUB ISnapinHelp_GetHelpTopic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISnapinHelp_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mmc_0130 */
/* [local] */ 

#if (MMC_VER >= 0x0110)


extern RPC_IF_HANDLE __MIDL_itf_mmc_0130_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mmc_0130_v0_0_s_ifspec;

#ifndef __IExtendPropertySheet2_INTERFACE_DEFINED__
#define __IExtendPropertySheet2_INTERFACE_DEFINED__

/* interface IExtendPropertySheet2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IExtendPropertySheet2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B7A87232-4A51-11D1-A7EA-00C04FD909DD")
    IExtendPropertySheet2 : public IExtendPropertySheet
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
            /* [in] */ LPDATAOBJECT lpIDataObject,
            /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
            /* [out] */ HBITMAP __RPC_FAR *lphHeader,
            /* [out] */ HPALETTE __RPC_FAR *lphPalette,
            /* [out] */ BOOL __RPC_FAR *bStretch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtendPropertySheet2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExtendPropertySheet2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExtendPropertySheet2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExtendPropertySheet2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertyPages )( 
            IExtendPropertySheet2 __RPC_FAR * This,
            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
            /* [in] */ LONG_PTR handle,
            /* [in] */ LPDATAOBJECT lpIDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryPagesFor )( 
            IExtendPropertySheet2 __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWatermarks )( 
            IExtendPropertySheet2 __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpIDataObject,
            /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
            /* [out] */ HBITMAP __RPC_FAR *lphHeader,
            /* [out] */ HPALETTE __RPC_FAR *lphPalette,
            /* [out] */ BOOL __RPC_FAR *bStretch);
        
        END_INTERFACE
    } IExtendPropertySheet2Vtbl;

    interface IExtendPropertySheet2
    {
        CONST_VTBL struct IExtendPropertySheet2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtendPropertySheet2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendPropertySheet2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExtendPropertySheet2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExtendPropertySheet2_CreatePropertyPages(This,lpProvider,handle,lpIDataObject)	\
    (This)->lpVtbl -> CreatePropertyPages(This,lpProvider,handle,lpIDataObject)

#define IExtendPropertySheet2_QueryPagesFor(This,lpDataObject)	\
    (This)->lpVtbl -> QueryPagesFor(This,lpDataObject)


#define IExtendPropertySheet2_GetWatermarks(This,lpIDataObject,lphWatermark,lphHeader,lphPalette,bStretch)	\
    (This)->lpVtbl -> GetWatermarks(This,lpIDataObject,lphWatermark,lphHeader,lphPalette,bStretch)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendPropertySheet2_GetWatermarks_Proxy( 
    IExtendPropertySheet2 __RPC_FAR * This,
    /* [in] */ LPDATAOBJECT lpIDataObject,
    /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
    /* [out] */ HBITMAP __RPC_FAR *lphHeader,
    /* [out] */ HPALETTE __RPC_FAR *lphPalette,
    /* [out] */ BOOL __RPC_FAR *bStretch);


void __RPC_STUB IExtendPropertySheet2_GetWatermarks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExtendPropertySheet2_INTERFACE_DEFINED__ */


#ifndef __IHeaderCtrl2_INTERFACE_DEFINED__
#define __IHeaderCtrl2_INTERFACE_DEFINED__

/* interface IHeaderCtrl2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IHeaderCtrl2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9757abb8-1b32-11d1-a7ce-00c04fd8d565")
    IHeaderCtrl2 : public IHeaderCtrl
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetChangeTimeOut( 
            /* [in] */ unsigned long uTimeout) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetColumnFilter( 
            /* [in] */ UINT nColumn,
            /* [in] */ DWORD dwType,
            /* [in] */ MMC_FILTERDATA __RPC_FAR *pFilterData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetColumnFilter( 
            /* [in] */ UINT nColumn,
            /* [out][in] */ LPDWORD pdwType,
            /* [out][in] */ MMC_FILTERDATA __RPC_FAR *pFilterData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHeaderCtrl2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHeaderCtrl2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHeaderCtrl2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHeaderCtrl2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertColumn )( 
            IHeaderCtrl2 __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [in] */ LPCWSTR title,
            /* [in] */ int nFormat,
            /* [in] */ int nWidth);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteColumn )( 
            IHeaderCtrl2 __RPC_FAR * This,
            /* [in] */ int nCol);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumnText )( 
            IHeaderCtrl2 __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [in] */ LPCWSTR title);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnText )( 
            IHeaderCtrl2 __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [out] */ LPOLESTR __RPC_FAR *pText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumnWidth )( 
            IHeaderCtrl2 __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [in] */ int nWidth);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnWidth )( 
            IHeaderCtrl2 __RPC_FAR * This,
            /* [in] */ int nCol,
            /* [out] */ int __RPC_FAR *pWidth);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetChangeTimeOut )( 
            IHeaderCtrl2 __RPC_FAR * This,
            /* [in] */ unsigned long uTimeout);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumnFilter )( 
            IHeaderCtrl2 __RPC_FAR * This,
            /* [in] */ UINT nColumn,
            /* [in] */ DWORD dwType,
            /* [in] */ MMC_FILTERDATA __RPC_FAR *pFilterData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnFilter )( 
            IHeaderCtrl2 __RPC_FAR * This,
            /* [in] */ UINT nColumn,
            /* [out][in] */ LPDWORD pdwType,
            /* [out][in] */ MMC_FILTERDATA __RPC_FAR *pFilterData);
        
        END_INTERFACE
    } IHeaderCtrl2Vtbl;

    interface IHeaderCtrl2
    {
        CONST_VTBL struct IHeaderCtrl2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHeaderCtrl2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHeaderCtrl2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHeaderCtrl2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHeaderCtrl2_InsertColumn(This,nCol,title,nFormat,nWidth)	\
    (This)->lpVtbl -> InsertColumn(This,nCol,title,nFormat,nWidth)

#define IHeaderCtrl2_DeleteColumn(This,nCol)	\
    (This)->lpVtbl -> DeleteColumn(This,nCol)

#define IHeaderCtrl2_SetColumnText(This,nCol,title)	\
    (This)->lpVtbl -> SetColumnText(This,nCol,title)

#define IHeaderCtrl2_GetColumnText(This,nCol,pText)	\
    (This)->lpVtbl -> GetColumnText(This,nCol,pText)

#define IHeaderCtrl2_SetColumnWidth(This,nCol,nWidth)	\
    (This)->lpVtbl -> SetColumnWidth(This,nCol,nWidth)

#define IHeaderCtrl2_GetColumnWidth(This,nCol,pWidth)	\
    (This)->lpVtbl -> GetColumnWidth(This,nCol,pWidth)


#define IHeaderCtrl2_SetChangeTimeOut(This,uTimeout)	\
    (This)->lpVtbl -> SetChangeTimeOut(This,uTimeout)

#define IHeaderCtrl2_SetColumnFilter(This,nColumn,dwType,pFilterData)	\
    (This)->lpVtbl -> SetColumnFilter(This,nColumn,dwType,pFilterData)

#define IHeaderCtrl2_GetColumnFilter(This,nColumn,pdwType,pFilterData)	\
    (This)->lpVtbl -> GetColumnFilter(This,nColumn,pdwType,pFilterData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl2_SetChangeTimeOut_Proxy( 
    IHeaderCtrl2 __RPC_FAR * This,
    /* [in] */ unsigned long uTimeout);


void __RPC_STUB IHeaderCtrl2_SetChangeTimeOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl2_SetColumnFilter_Proxy( 
    IHeaderCtrl2 __RPC_FAR * This,
    /* [in] */ UINT nColumn,
    /* [in] */ DWORD dwType,
    /* [in] */ MMC_FILTERDATA __RPC_FAR *pFilterData);


void __RPC_STUB IHeaderCtrl2_SetColumnFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCtrl2_GetColumnFilter_Proxy( 
    IHeaderCtrl2 __RPC_FAR * This,
    /* [in] */ UINT nColumn,
    /* [out][in] */ LPDWORD pdwType,
    /* [out][in] */ MMC_FILTERDATA __RPC_FAR *pFilterData);


void __RPC_STUB IHeaderCtrl2_GetColumnFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHeaderCtrl2_INTERFACE_DEFINED__ */


#ifndef __ISnapinHelp2_INTERFACE_DEFINED__
#define __ISnapinHelp2_INTERFACE_DEFINED__

/* interface ISnapinHelp2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISnapinHelp2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4861A010-20F9-11d2-A510-00C04FB6DD2C")
    ISnapinHelp2 : public ISnapinHelp
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLinkedTopics( 
            /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFiles) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISnapinHelp2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISnapinHelp2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISnapinHelp2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISnapinHelp2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHelpTopic )( 
            ISnapinHelp2 __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLinkedTopics )( 
            ISnapinHelp2 __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFiles);
        
        END_INTERFACE
    } ISnapinHelp2Vtbl;

    interface ISnapinHelp2
    {
        CONST_VTBL struct ISnapinHelp2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISnapinHelp2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISnapinHelp2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISnapinHelp2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISnapinHelp2_GetHelpTopic(This,lpCompiledHelpFile)	\
    (This)->lpVtbl -> GetHelpTopic(This,lpCompiledHelpFile)


#define ISnapinHelp2_GetLinkedTopics(This,lpCompiledHelpFiles)	\
    (This)->lpVtbl -> GetLinkedTopics(This,lpCompiledHelpFiles)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISnapinHelp2_GetLinkedTopics_Proxy( 
    ISnapinHelp2 __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFiles);


void __RPC_STUB ISnapinHelp2_GetLinkedTopics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISnapinHelp2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mmc_0133 */
/* [local] */ 

typedef 
enum _MMC_TASK_DISPLAY_TYPE
    {	MMC_TASK_DISPLAY_UNINITIALIZED	= 0,
	MMC_TASK_DISPLAY_TYPE_SYMBOL	= MMC_TASK_DISPLAY_UNINITIALIZED + 1,
	MMC_TASK_DISPLAY_TYPE_VANILLA_GIF	= MMC_TASK_DISPLAY_TYPE_SYMBOL + 1,
	MMC_TASK_DISPLAY_TYPE_CHOCOLATE_GIF	= MMC_TASK_DISPLAY_TYPE_VANILLA_GIF + 1,
	MMC_TASK_DISPLAY_TYPE_BITMAP	= MMC_TASK_DISPLAY_TYPE_CHOCOLATE_GIF + 1
    }	MMC_TASK_DISPLAY_TYPE;

typedef struct _MMC_TASK_DISPLAY_SYMBOL
    {
    LPOLESTR szFontFamilyName;
    LPOLESTR szURLtoEOT;
    LPOLESTR szSymbolString;
    }	MMC_TASK_DISPLAY_SYMBOL;

typedef struct _MMC_TASK_DISPLAY_BITMAP
    {
    LPOLESTR szMouseOverBitmap;
    LPOLESTR szMouseOffBitmap;
    }	MMC_TASK_DISPLAY_BITMAP;

typedef struct _MMC_TASK_DISPLAY_OBJECT
    {
    MMC_TASK_DISPLAY_TYPE eDisplayType;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ MMC_TASK_DISPLAY_BITMAP uBitmap;
        /* [case()] */ MMC_TASK_DISPLAY_SYMBOL uSymbol;
        /* [default] */  /* Empty union arm */ 
        }	;
    }	MMC_TASK_DISPLAY_OBJECT;

typedef 
enum _MMC_ACTION_TYPE
    {	MMC_ACTION_UNINITIALIZED	= -1,
	MMC_ACTION_ID	= MMC_ACTION_UNINITIALIZED + 1,
	MMC_ACTION_LINK	= MMC_ACTION_ID + 1,
	MMC_ACTION_SCRIPT	= MMC_ACTION_LINK + 1
    }	MMC_ACTION_TYPE;

typedef struct _MMC_TASK
    {
    MMC_TASK_DISPLAY_OBJECT sDisplayObject;
    LPOLESTR szText;
    LPOLESTR szHelpString;
    MMC_ACTION_TYPE eActionType;
    union 
        {
        LONG_PTR nCommandID;
        LPOLESTR szActionURL;
        LPOLESTR szScript;
        }	;
    }	MMC_TASK;

typedef struct _MMC_LISTPAD_INFO
    {
    LPOLESTR szTitle;
    LPOLESTR szButtonText;
    LONG_PTR nCommandID;
    }	MMC_LISTPAD_INFO;

typedef DWORD MMC_STRING_ID;



extern RPC_IF_HANDLE __MIDL_itf_mmc_0133_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mmc_0133_v0_0_s_ifspec;

#ifndef __IEnumTASK_INTERFACE_DEFINED__
#define __IEnumTASK_INTERFACE_DEFINED__

/* interface IEnumTASK */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumTASK;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("338698b1-5a02-11d1-9fec-00600832db4a")
    IEnumTASK : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ MMC_TASK __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTASKVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumTASK __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumTASK __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumTASK __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumTASK __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ MMC_TASK __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumTASK __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumTASK __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumTASK __RPC_FAR * This,
            /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumTASKVtbl;

    interface IEnumTASK
    {
        CONST_VTBL struct IEnumTASKVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTASK_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTASK_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTASK_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTASK_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumTASK_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumTASK_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTASK_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTASK_Next_Proxy( 
    IEnumTASK __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ MMC_TASK __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumTASK_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTASK_Skip_Proxy( 
    IEnumTASK __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumTASK_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTASK_Reset_Proxy( 
    IEnumTASK __RPC_FAR * This);


void __RPC_STUB IEnumTASK_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTASK_Clone_Proxy( 
    IEnumTASK __RPC_FAR * This,
    /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumTASK_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTASK_INTERFACE_DEFINED__ */


#ifndef __IExtendTaskPad_INTERFACE_DEFINED__
#define __IExtendTaskPad_INTERFACE_DEFINED__

/* interface IExtendTaskPad */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IExtendTaskPad;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8dee6511-554d-11d1-9fea-00600832db4a")
    IExtendTaskPad : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TaskNotify( 
            /* [in] */ IDataObject __RPC_FAR *pdo,
            /* [in] */ VARIANT __RPC_FAR *arg,
            /* [in] */ VARIANT __RPC_FAR *param) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumTasks( 
            /* [in] */ IDataObject __RPC_FAR *pdo,
            /* [string][in] */ LPOLESTR szTaskGroup,
            /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppEnumTASK) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTitle( 
            /* [string][in] */ LPOLESTR pszGroup,
            /* [string][out] */ LPOLESTR __RPC_FAR *pszTitle) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDescriptiveText( 
            /* [string][in] */ LPOLESTR pszGroup,
            /* [string][out] */ LPOLESTR __RPC_FAR *pszDescriptiveText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetBackground( 
            /* [string][in] */ LPOLESTR pszGroup,
            /* [out] */ MMC_TASK_DISPLAY_OBJECT __RPC_FAR *pTDO) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetListPadInfo( 
            /* [string][in] */ LPOLESTR pszGroup,
            /* [out] */ MMC_LISTPAD_INFO __RPC_FAR *lpListPadInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExtendTaskPadVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExtendTaskPad __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExtendTaskPad __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExtendTaskPad __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TaskNotify )( 
            IExtendTaskPad __RPC_FAR * This,
            /* [in] */ IDataObject __RPC_FAR *pdo,
            /* [in] */ VARIANT __RPC_FAR *arg,
            /* [in] */ VARIANT __RPC_FAR *param);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumTasks )( 
            IExtendTaskPad __RPC_FAR * This,
            /* [in] */ IDataObject __RPC_FAR *pdo,
            /* [string][in] */ LPOLESTR szTaskGroup,
            /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppEnumTASK);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTitle )( 
            IExtendTaskPad __RPC_FAR * This,
            /* [string][in] */ LPOLESTR pszGroup,
            /* [string][out] */ LPOLESTR __RPC_FAR *pszTitle);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescriptiveText )( 
            IExtendTaskPad __RPC_FAR * This,
            /* [string][in] */ LPOLESTR pszGroup,
            /* [string][out] */ LPOLESTR __RPC_FAR *pszDescriptiveText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBackground )( 
            IExtendTaskPad __RPC_FAR * This,
            /* [string][in] */ LPOLESTR pszGroup,
            /* [out] */ MMC_TASK_DISPLAY_OBJECT __RPC_FAR *pTDO);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListPadInfo )( 
            IExtendTaskPad __RPC_FAR * This,
            /* [string][in] */ LPOLESTR pszGroup,
            /* [out] */ MMC_LISTPAD_INFO __RPC_FAR *lpListPadInfo);
        
        END_INTERFACE
    } IExtendTaskPadVtbl;

    interface IExtendTaskPad
    {
        CONST_VTBL struct IExtendTaskPadVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExtendTaskPad_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExtendTaskPad_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExtendTaskPad_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExtendTaskPad_TaskNotify(This,pdo,arg,param)	\
    (This)->lpVtbl -> TaskNotify(This,pdo,arg,param)

#define IExtendTaskPad_EnumTasks(This,pdo,szTaskGroup,ppEnumTASK)	\
    (This)->lpVtbl -> EnumTasks(This,pdo,szTaskGroup,ppEnumTASK)

#define IExtendTaskPad_GetTitle(This,pszGroup,pszTitle)	\
    (This)->lpVtbl -> GetTitle(This,pszGroup,pszTitle)

#define IExtendTaskPad_GetDescriptiveText(This,pszGroup,pszDescriptiveText)	\
    (This)->lpVtbl -> GetDescriptiveText(This,pszGroup,pszDescriptiveText)

#define IExtendTaskPad_GetBackground(This,pszGroup,pTDO)	\
    (This)->lpVtbl -> GetBackground(This,pszGroup,pTDO)

#define IExtendTaskPad_GetListPadInfo(This,pszGroup,lpListPadInfo)	\
    (This)->lpVtbl -> GetListPadInfo(This,pszGroup,lpListPadInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendTaskPad_TaskNotify_Proxy( 
    IExtendTaskPad __RPC_FAR * This,
    /* [in] */ IDataObject __RPC_FAR *pdo,
    /* [in] */ VARIANT __RPC_FAR *arg,
    /* [in] */ VARIANT __RPC_FAR *param);


void __RPC_STUB IExtendTaskPad_TaskNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendTaskPad_EnumTasks_Proxy( 
    IExtendTaskPad __RPC_FAR * This,
    /* [in] */ IDataObject __RPC_FAR *pdo,
    /* [string][in] */ LPOLESTR szTaskGroup,
    /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppEnumTASK);


void __RPC_STUB IExtendTaskPad_EnumTasks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendTaskPad_GetTitle_Proxy( 
    IExtendTaskPad __RPC_FAR * This,
    /* [string][in] */ LPOLESTR pszGroup,
    /* [string][out] */ LPOLESTR __RPC_FAR *pszTitle);


void __RPC_STUB IExtendTaskPad_GetTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendTaskPad_GetDescriptiveText_Proxy( 
    IExtendTaskPad __RPC_FAR * This,
    /* [string][in] */ LPOLESTR pszGroup,
    /* [string][out] */ LPOLESTR __RPC_FAR *pszDescriptiveText);


void __RPC_STUB IExtendTaskPad_GetDescriptiveText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendTaskPad_GetBackground_Proxy( 
    IExtendTaskPad __RPC_FAR * This,
    /* [string][in] */ LPOLESTR pszGroup,
    /* [out] */ MMC_TASK_DISPLAY_OBJECT __RPC_FAR *pTDO);


void __RPC_STUB IExtendTaskPad_GetBackground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IExtendTaskPad_GetListPadInfo_Proxy( 
    IExtendTaskPad __RPC_FAR * This,
    /* [string][in] */ LPOLESTR pszGroup,
    /* [out] */ MMC_LISTPAD_INFO __RPC_FAR *lpListPadInfo);


void __RPC_STUB IExtendTaskPad_GetListPadInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExtendTaskPad_INTERFACE_DEFINED__ */


#ifndef __IConsole2_INTERFACE_DEFINED__
#define __IConsole2_INTERFACE_DEFINED__

/* interface IConsole2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IConsole2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("103D842A-AA63-11D1-A7E1-00C04FD8D565")
    IConsole2 : public IConsole
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Expand( 
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ BOOL bExpand) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsTaskpadViewPreferred( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetStatusText( 
            /* [string][in] */ LPOLESTR pszStatusText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConsole2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IConsole2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IConsole2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IConsole2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHeader )( 
            IConsole2 __RPC_FAR * This,
            /* [in] */ LPHEADERCTRL pHeader);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetToolbar )( 
            IConsole2 __RPC_FAR * This,
            /* [in] */ LPTOOLBAR pToolbar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryResultView )( 
            IConsole2 __RPC_FAR * This,
            /* [out] */ LPUNKNOWN __RPC_FAR *pUnknown);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryScopeImageList )( 
            IConsole2 __RPC_FAR * This,
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryResultImageList )( 
            IConsole2 __RPC_FAR * This,
            /* [out] */ LPIMAGELIST __RPC_FAR *ppImageList);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateAllViews )( 
            IConsole2 __RPC_FAR * This,
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ LPARAM data,
            /* [in] */ LONG_PTR hint);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MessageBox )( 
            IConsole2 __RPC_FAR * This,
            /* [in] */ LPCWSTR lpszText,
            /* [in] */ LPCWSTR lpszTitle,
            /* [in] */ UINT fuStyle,
            /* [out] */ int __RPC_FAR *piRetval);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryConsoleVerb )( 
            IConsole2 __RPC_FAR * This,
            /* [out] */ LPCONSOLEVERB __RPC_FAR *ppConsoleVerb);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectScopeItem )( 
            IConsole2 __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hScopeItem);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMainWindow )( 
            IConsole2 __RPC_FAR * This,
            /* [out] */ HWND __RPC_FAR *phwnd);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewWindow )( 
            IConsole2 __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hScopeItem,
            /* [in] */ unsigned long lOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Expand )( 
            IConsole2 __RPC_FAR * This,
            /* [in] */ HSCOPEITEM hItem,
            /* [in] */ BOOL bExpand);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsTaskpadViewPreferred )( 
            IConsole2 __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatusText )( 
            IConsole2 __RPC_FAR * This,
            /* [string][in] */ LPOLESTR pszStatusText);
        
        END_INTERFACE
    } IConsole2Vtbl;

    interface IConsole2
    {
        CONST_VTBL struct IConsole2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConsole2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IConsole2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IConsole2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IConsole2_SetHeader(This,pHeader)	\
    (This)->lpVtbl -> SetHeader(This,pHeader)

#define IConsole2_SetToolbar(This,pToolbar)	\
    (This)->lpVtbl -> SetToolbar(This,pToolbar)

#define IConsole2_QueryResultView(This,pUnknown)	\
    (This)->lpVtbl -> QueryResultView(This,pUnknown)

#define IConsole2_QueryScopeImageList(This,ppImageList)	\
    (This)->lpVtbl -> QueryScopeImageList(This,ppImageList)

#define IConsole2_QueryResultImageList(This,ppImageList)	\
    (This)->lpVtbl -> QueryResultImageList(This,ppImageList)

#define IConsole2_UpdateAllViews(This,lpDataObject,data,hint)	\
    (This)->lpVtbl -> UpdateAllViews(This,lpDataObject,data,hint)

#define IConsole2_MessageBox(This,lpszText,lpszTitle,fuStyle,piRetval)	\
    (This)->lpVtbl -> MessageBox(This,lpszText,lpszTitle,fuStyle,piRetval)

#define IConsole2_QueryConsoleVerb(This,ppConsoleVerb)	\
    (This)->lpVtbl -> QueryConsoleVerb(This,ppConsoleVerb)

#define IConsole2_SelectScopeItem(This,hScopeItem)	\
    (This)->lpVtbl -> SelectScopeItem(This,hScopeItem)

#define IConsole2_GetMainWindow(This,phwnd)	\
    (This)->lpVtbl -> GetMainWindow(This,phwnd)

#define IConsole2_NewWindow(This,hScopeItem,lOptions)	\
    (This)->lpVtbl -> NewWindow(This,hScopeItem,lOptions)


#define IConsole2_Expand(This,hItem,bExpand)	\
    (This)->lpVtbl -> Expand(This,hItem,bExpand)

#define IConsole2_IsTaskpadViewPreferred(This)	\
    (This)->lpVtbl -> IsTaskpadViewPreferred(This)

#define IConsole2_SetStatusText(This,pszStatusText)	\
    (This)->lpVtbl -> SetStatusText(This,pszStatusText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole2_Expand_Proxy( 
    IConsole2 __RPC_FAR * This,
    /* [in] */ HSCOPEITEM hItem,
    /* [in] */ BOOL bExpand);


void __RPC_STUB IConsole2_Expand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole2_IsTaskpadViewPreferred_Proxy( 
    IConsole2 __RPC_FAR * This);


void __RPC_STUB IConsole2_IsTaskpadViewPreferred_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IConsole2_SetStatusText_Proxy( 
    IConsole2 __RPC_FAR * This,
    /* [string][in] */ LPOLESTR pszStatusText);


void __RPC_STUB IConsole2_SetStatusText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IConsole2_INTERFACE_DEFINED__ */


#ifndef __IDisplayHelp_INTERFACE_DEFINED__
#define __IDisplayHelp_INTERFACE_DEFINED__

/* interface IDisplayHelp */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDisplayHelp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cc593830-b926-11d1-8063-0000f875a9ce")
    IDisplayHelp : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ShowTopic( 
            /* [in] */ LPOLESTR pszHelpTopic) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDisplayHelpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDisplayHelp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDisplayHelp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDisplayHelp __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowTopic )( 
            IDisplayHelp __RPC_FAR * This,
            /* [in] */ LPOLESTR pszHelpTopic);
        
        END_INTERFACE
    } IDisplayHelpVtbl;

    interface IDisplayHelp
    {
        CONST_VTBL struct IDisplayHelpVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDisplayHelp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDisplayHelp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDisplayHelp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDisplayHelp_ShowTopic(This,pszHelpTopic)	\
    (This)->lpVtbl -> ShowTopic(This,pszHelpTopic)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDisplayHelp_ShowTopic_Proxy( 
    IDisplayHelp __RPC_FAR * This,
    /* [in] */ LPOLESTR pszHelpTopic);


void __RPC_STUB IDisplayHelp_ShowTopic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDisplayHelp_INTERFACE_DEFINED__ */


#ifndef __IRequiredExtensions_INTERFACE_DEFINED__
#define __IRequiredExtensions_INTERFACE_DEFINED__

/* interface IRequiredExtensions */
/* [unique][helpstring][uuid][object][local] */ 


EXTERN_C const IID IID_IRequiredExtensions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("72782D7A-A4A0-11d1-AF0F-00C04FB6DD2C")
    IRequiredExtensions : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnableAllExtensions( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFirstExtension( 
            /* [out] */ LPCLSID pExtCLSID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetNextExtension( 
            /* [out] */ LPCLSID pExtCLSID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequiredExtensionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequiredExtensions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequiredExtensions __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequiredExtensions __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableAllExtensions )( 
            IRequiredExtensions __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFirstExtension )( 
            IRequiredExtensions __RPC_FAR * This,
            /* [out] */ LPCLSID pExtCLSID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextExtension )( 
            IRequiredExtensions __RPC_FAR * This,
            /* [out] */ LPCLSID pExtCLSID);
        
        END_INTERFACE
    } IRequiredExtensionsVtbl;

    interface IRequiredExtensions
    {
        CONST_VTBL struct IRequiredExtensionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequiredExtensions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequiredExtensions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequiredExtensions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequiredExtensions_EnableAllExtensions(This)	\
    (This)->lpVtbl -> EnableAllExtensions(This)

#define IRequiredExtensions_GetFirstExtension(This,pExtCLSID)	\
    (This)->lpVtbl -> GetFirstExtension(This,pExtCLSID)

#define IRequiredExtensions_GetNextExtension(This,pExtCLSID)	\
    (This)->lpVtbl -> GetNextExtension(This,pExtCLSID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRequiredExtensions_EnableAllExtensions_Proxy( 
    IRequiredExtensions __RPC_FAR * This);


void __RPC_STUB IRequiredExtensions_EnableAllExtensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRequiredExtensions_GetFirstExtension_Proxy( 
    IRequiredExtensions __RPC_FAR * This,
    /* [out] */ LPCLSID pExtCLSID);


void __RPC_STUB IRequiredExtensions_GetFirstExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRequiredExtensions_GetNextExtension_Proxy( 
    IRequiredExtensions __RPC_FAR * This,
    /* [out] */ LPCLSID pExtCLSID);


void __RPC_STUB IRequiredExtensions_GetNextExtension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequiredExtensions_INTERFACE_DEFINED__ */


#ifndef __IStringTable_INTERFACE_DEFINED__
#define __IStringTable_INTERFACE_DEFINED__

/* interface IStringTable */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IStringTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DE40B7A4-0F65-11d2-8E25-00C04F8ECD78")
    IStringTable : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddString( 
            /* [in] */ LPCOLESTR pszAdd,
            /* [out] */ MMC_STRING_ID __RPC_FAR *pStringID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetString( 
            /* [in] */ MMC_STRING_ID StringID,
            /* [in] */ ULONG cchBuffer,
            /* [size_is][out] */ LPOLESTR lpBuffer,
            /* [out] */ ULONG __RPC_FAR *pcchOut) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStringLength( 
            /* [in] */ MMC_STRING_ID StringID,
            /* [out] */ ULONG __RPC_FAR *pcchString) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteString( 
            /* [in] */ MMC_STRING_ID StringID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteAllStrings( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindString( 
            /* [in] */ LPCOLESTR pszFind,
            /* [out] */ MMC_STRING_ID __RPC_FAR *pStringID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Enumerate( 
            /* [out] */ IEnumString __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStringTableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IStringTable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IStringTable __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IStringTable __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddString )( 
            IStringTable __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszAdd,
            /* [out] */ MMC_STRING_ID __RPC_FAR *pStringID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetString )( 
            IStringTable __RPC_FAR * This,
            /* [in] */ MMC_STRING_ID StringID,
            /* [in] */ ULONG cchBuffer,
            /* [size_is][out] */ LPOLESTR lpBuffer,
            /* [out] */ ULONG __RPC_FAR *pcchOut);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStringLength )( 
            IStringTable __RPC_FAR * This,
            /* [in] */ MMC_STRING_ID StringID,
            /* [out] */ ULONG __RPC_FAR *pcchString);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteString )( 
            IStringTable __RPC_FAR * This,
            /* [in] */ MMC_STRING_ID StringID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAllStrings )( 
            IStringTable __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindString )( 
            IStringTable __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszFind,
            /* [out] */ MMC_STRING_ID __RPC_FAR *pStringID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enumerate )( 
            IStringTable __RPC_FAR * This,
            /* [out] */ IEnumString __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IStringTableVtbl;

    interface IStringTable
    {
        CONST_VTBL struct IStringTableVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStringTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStringTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStringTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStringTable_AddString(This,pszAdd,pStringID)	\
    (This)->lpVtbl -> AddString(This,pszAdd,pStringID)

#define IStringTable_GetString(This,StringID,cchBuffer,lpBuffer,pcchOut)	\
    (This)->lpVtbl -> GetString(This,StringID,cchBuffer,lpBuffer,pcchOut)

#define IStringTable_GetStringLength(This,StringID,pcchString)	\
    (This)->lpVtbl -> GetStringLength(This,StringID,pcchString)

#define IStringTable_DeleteString(This,StringID)	\
    (This)->lpVtbl -> DeleteString(This,StringID)

#define IStringTable_DeleteAllStrings(This)	\
    (This)->lpVtbl -> DeleteAllStrings(This)

#define IStringTable_FindString(This,pszFind,pStringID)	\
    (This)->lpVtbl -> FindString(This,pszFind,pStringID)

#define IStringTable_Enumerate(This,ppEnum)	\
    (This)->lpVtbl -> Enumerate(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IStringTable_AddString_Proxy( 
    IStringTable __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszAdd,
    /* [out] */ MMC_STRING_ID __RPC_FAR *pStringID);


void __RPC_STUB IStringTable_AddString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IStringTable_GetString_Proxy( 
    IStringTable __RPC_FAR * This,
    /* [in] */ MMC_STRING_ID StringID,
    /* [in] */ ULONG cchBuffer,
    /* [size_is][out] */ LPOLESTR lpBuffer,
    /* [out] */ ULONG __RPC_FAR *pcchOut);


void __RPC_STUB IStringTable_GetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IStringTable_GetStringLength_Proxy( 
    IStringTable __RPC_FAR * This,
    /* [in] */ MMC_STRING_ID StringID,
    /* [out] */ ULONG __RPC_FAR *pcchString);


void __RPC_STUB IStringTable_GetStringLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IStringTable_DeleteString_Proxy( 
    IStringTable __RPC_FAR * This,
    /* [in] */ MMC_STRING_ID StringID);


void __RPC_STUB IStringTable_DeleteString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IStringTable_DeleteAllStrings_Proxy( 
    IStringTable __RPC_FAR * This);


void __RPC_STUB IStringTable_DeleteAllStrings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IStringTable_FindString_Proxy( 
    IStringTable __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszFind,
    /* [out] */ MMC_STRING_ID __RPC_FAR *pStringID);


void __RPC_STUB IStringTable_FindString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IStringTable_Enumerate_Proxy( 
    IStringTable __RPC_FAR * This,
    /* [out] */ IEnumString __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IStringTable_Enumerate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStringTable_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mmc_0139 */
/* [local] */ 

#endif // MMC_VER >= 0x0110
#if (MMC_VER >= 0x0120)
#define	HDI_HIDDEN	( 0x1 )

typedef struct _MMC_COLUMN_DATA
    {
    int nColIndex;
    DWORD dwFlags;
    int nWidth;
    ULONG_PTR ulReserved;
    }	MMC_COLUMN_DATA;

typedef struct _MMC_COLUMN_SET_DATA
    {
    int cbSize;
    int nNumCols;
    MMC_COLUMN_DATA __RPC_FAR *pColData;
    }	MMC_COLUMN_SET_DATA;

typedef struct _MMC_SORT_DATA
    {
    int nColIndex;
    DWORD dwSortOptions;
    ULONG_PTR ulReserved;
    }	MMC_SORT_DATA;

typedef struct _MMC_SORT_SET_DATA
    {
    int cbSize;
    int nNumItems;
    MMC_SORT_DATA __RPC_FAR *pSortData;
    }	MMC_SORT_SET_DATA;



extern RPC_IF_HANDLE __MIDL_itf_mmc_0139_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mmc_0139_v0_0_s_ifspec;

#ifndef __IColumnData_INTERFACE_DEFINED__
#define __IColumnData_INTERFACE_DEFINED__

/* interface IColumnData */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IColumnData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("547C1354-024D-11d3-A707-00C04F8EF4CB")
    IColumnData : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetColumnConfigData( 
            /* [in] */ SColumnSetID __RPC_FAR *pColID,
            /* [in] */ MMC_COLUMN_SET_DATA __RPC_FAR *pColSetData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetColumnConfigData( 
            /* [in] */ SColumnSetID __RPC_FAR *pColID,
            /* [out] */ MMC_COLUMN_SET_DATA __RPC_FAR *__RPC_FAR *ppColSetData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetColumnSortData( 
            /* [in] */ SColumnSetID __RPC_FAR *pColID,
            /* [in] */ MMC_SORT_SET_DATA __RPC_FAR *pColSortData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetColumnSortData( 
            /* [in] */ SColumnSetID __RPC_FAR *pColID,
            /* [out] */ MMC_SORT_SET_DATA __RPC_FAR *__RPC_FAR *ppColSortData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IColumnDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IColumnData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IColumnData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IColumnData __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumnConfigData )( 
            IColumnData __RPC_FAR * This,
            /* [in] */ SColumnSetID __RPC_FAR *pColID,
            /* [in] */ MMC_COLUMN_SET_DATA __RPC_FAR *pColSetData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnConfigData )( 
            IColumnData __RPC_FAR * This,
            /* [in] */ SColumnSetID __RPC_FAR *pColID,
            /* [out] */ MMC_COLUMN_SET_DATA __RPC_FAR *__RPC_FAR *ppColSetData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColumnSortData )( 
            IColumnData __RPC_FAR * This,
            /* [in] */ SColumnSetID __RPC_FAR *pColID,
            /* [in] */ MMC_SORT_SET_DATA __RPC_FAR *pColSortData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColumnSortData )( 
            IColumnData __RPC_FAR * This,
            /* [in] */ SColumnSetID __RPC_FAR *pColID,
            /* [out] */ MMC_SORT_SET_DATA __RPC_FAR *__RPC_FAR *ppColSortData);
        
        END_INTERFACE
    } IColumnDataVtbl;

    interface IColumnData
    {
        CONST_VTBL struct IColumnDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColumnData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IColumnData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IColumnData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IColumnData_SetColumnConfigData(This,pColID,pColSetData)	\
    (This)->lpVtbl -> SetColumnConfigData(This,pColID,pColSetData)

#define IColumnData_GetColumnConfigData(This,pColID,ppColSetData)	\
    (This)->lpVtbl -> GetColumnConfigData(This,pColID,ppColSetData)

#define IColumnData_SetColumnSortData(This,pColID,pColSortData)	\
    (This)->lpVtbl -> SetColumnSortData(This,pColID,pColSortData)

#define IColumnData_GetColumnSortData(This,pColID,ppColSortData)	\
    (This)->lpVtbl -> GetColumnSortData(This,pColID,ppColSortData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IColumnData_SetColumnConfigData_Proxy( 
    IColumnData __RPC_FAR * This,
    /* [in] */ SColumnSetID __RPC_FAR *pColID,
    /* [in] */ MMC_COLUMN_SET_DATA __RPC_FAR *pColSetData);


void __RPC_STUB IColumnData_SetColumnConfigData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IColumnData_GetColumnConfigData_Proxy( 
    IColumnData __RPC_FAR * This,
    /* [in] */ SColumnSetID __RPC_FAR *pColID,
    /* [out] */ MMC_COLUMN_SET_DATA __RPC_FAR *__RPC_FAR *ppColSetData);


void __RPC_STUB IColumnData_GetColumnConfigData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IColumnData_SetColumnSortData_Proxy( 
    IColumnData __RPC_FAR * This,
    /* [in] */ SColumnSetID __RPC_FAR *pColID,
    /* [in] */ MMC_SORT_SET_DATA __RPC_FAR *pColSortData);


void __RPC_STUB IColumnData_SetColumnSortData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IColumnData_GetColumnSortData_Proxy( 
    IColumnData __RPC_FAR * This,
    /* [in] */ SColumnSetID __RPC_FAR *pColID,
    /* [out] */ MMC_SORT_SET_DATA __RPC_FAR *__RPC_FAR *ppColSortData);


void __RPC_STUB IColumnData_GetColumnSortData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IColumnData_INTERFACE_DEFINED__ */


#ifndef __IMessageView_INTERFACE_DEFINED__
#define __IMessageView_INTERFACE_DEFINED__

/* interface IMessageView */
/* [unique][helpstring][uuid][object] */ 

typedef 
enum tagIconIdentifier
    {	Icon_None	= 0,
	Icon_Error	= 32513,
	Icon_Question	= 32514,
	Icon_Warning	= 32515,
	Icon_Information	= 32516,
	Icon_First	= Icon_Error,
	Icon_Last	= Icon_Information
    }	IconIdentifier;


EXTERN_C const IID IID_IMessageView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("80F94174-FCCC-11d2-B991-00C04F8ECD78")
    IMessageView : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetTitleText( 
            /* [in] */ LPCOLESTR pszTitleText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetBodyText( 
            /* [in] */ LPCOLESTR pszBodyText) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetIcon( 
            /* [in] */ IconIdentifier id) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMessageViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMessageView __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMessageView __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMessageView __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTitleText )( 
            IMessageView __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszTitleText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBodyText )( 
            IMessageView __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszBodyText);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIcon )( 
            IMessageView __RPC_FAR * This,
            /* [in] */ IconIdentifier id);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            IMessageView __RPC_FAR * This);
        
        END_INTERFACE
    } IMessageViewVtbl;

    interface IMessageView
    {
        CONST_VTBL struct IMessageViewVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMessageView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMessageView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMessageView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMessageView_SetTitleText(This,pszTitleText)	\
    (This)->lpVtbl -> SetTitleText(This,pszTitleText)

#define IMessageView_SetBodyText(This,pszBodyText)	\
    (This)->lpVtbl -> SetBodyText(This,pszBodyText)

#define IMessageView_SetIcon(This,id)	\
    (This)->lpVtbl -> SetIcon(This,id)

#define IMessageView_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMessageView_SetTitleText_Proxy( 
    IMessageView __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszTitleText);


void __RPC_STUB IMessageView_SetTitleText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMessageView_SetBodyText_Proxy( 
    IMessageView __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszBodyText);


void __RPC_STUB IMessageView_SetBodyText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMessageView_SetIcon_Proxy( 
    IMessageView __RPC_FAR * This,
    /* [in] */ IconIdentifier id);


void __RPC_STUB IMessageView_SetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMessageView_Clear_Proxy( 
    IMessageView __RPC_FAR * This);


void __RPC_STUB IMessageView_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMessageView_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mmc_0141 */
/* [local] */ 

typedef struct _RDCITEMHDR
    {
    DWORD dwFlags;
    MMC_COOKIE cookie;
    LPARAM lpReserved;
    }	RDITEMHDR;

#define	RDCI_ScopeItem	( 0x80000000 )

typedef struct _RDCOMPARE
    {
    DWORD cbSize;
    DWORD dwFlags;
    int nColumn;
    LPARAM lUserParam;
    RDITEMHDR __RPC_FAR *prdch1;
    RDITEMHDR __RPC_FAR *prdch2;
    }	RDCOMPARE;



extern RPC_IF_HANDLE __MIDL_itf_mmc_0141_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mmc_0141_v0_0_s_ifspec;

#ifndef __IResultDataCompareEx_INTERFACE_DEFINED__
#define __IResultDataCompareEx_INTERFACE_DEFINED__

/* interface IResultDataCompareEx */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IResultDataCompareEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("96933476-0251-11d3-AEB0-00C04F8ECD78")
    IResultDataCompareEx : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Compare( 
            /* [in] */ RDCOMPARE __RPC_FAR *prdc,
            /* [out] */ int __RPC_FAR *pnResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResultDataCompareExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResultDataCompareEx __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResultDataCompareEx __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResultDataCompareEx __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Compare )( 
            IResultDataCompareEx __RPC_FAR * This,
            /* [in] */ RDCOMPARE __RPC_FAR *prdc,
            /* [out] */ int __RPC_FAR *pnResult);
        
        END_INTERFACE
    } IResultDataCompareExVtbl;

    interface IResultDataCompareEx
    {
        CONST_VTBL struct IResultDataCompareExVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResultDataCompareEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResultDataCompareEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResultDataCompareEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResultDataCompareEx_Compare(This,prdc,pnResult)	\
    (This)->lpVtbl -> Compare(This,prdc,pnResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResultDataCompareEx_Compare_Proxy( 
    IResultDataCompareEx __RPC_FAR * This,
    /* [in] */ RDCOMPARE __RPC_FAR *prdc,
    /* [out] */ int __RPC_FAR *pnResult);


void __RPC_STUB IResultDataCompareEx_Compare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResultDataCompareEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mmc_0142 */
/* [local] */ 

#endif // MMC_VER >= 0x0120


extern RPC_IF_HANDLE __MIDL_itf_mmc_0142_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mmc_0142_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HBITMAP_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HBITMAP __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HBITMAP_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HBITMAP __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HBITMAP_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HBITMAP __RPC_FAR * ); 
void                      __RPC_USER  HBITMAP_UserFree(     unsigned long __RPC_FAR *, HBITMAP __RPC_FAR * ); 

unsigned long             __RPC_USER  HICON_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HICON __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HICON_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HICON __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HICON_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HICON __RPC_FAR * ); 
void                      __RPC_USER  HICON_UserFree(     unsigned long __RPC_FAR *, HICON __RPC_FAR * ); 

unsigned long             __RPC_USER  HPALETTE_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HPALETTE __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HPALETTE_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HPALETTE __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HPALETTE_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HPALETTE __RPC_FAR * ); 
void                      __RPC_USER  HPALETTE_UserFree(     unsigned long __RPC_FAR *, HPALETTE __RPC_FAR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\inc\snapins.inc\rpc.h ===
/*++

Copyright (c) 1991-1997 Microsoft Corporation

Module Name:

    rpc.h

Abstract:

    Master include file for RPC applications.

--*/

#if !defined( RPC_NO_WINDOWS_H ) && !defined( MAC ) && !defined( _MAC )
#include <windows.h>
#endif // RPC_NO_WINDOWS_H

#ifndef __RPC_H__
#define __RPC_H__

#pragma message("rpc in snapins")

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------------------------
// platform specific defines
//-------------------------------------------------------------

//-------------------  MAC ---------------------------
#if defined( MAC ) || defined( _MAC )

#define __RPC_MAC__
// Set the packing level for RPC structures.

#include <pshpack2.h>

//-------------------  WIN32 ---------------------------
#else // win32 platforms

#define __RPC_WIN32__

#endif


#ifndef __MIDL_USER_DEFINED
#define midl_user_allocate MIDL_user_allocate
#define midl_user_free     MIDL_user_free
#define __MIDL_USER_DEFINED
#endif

typedef void * I_RPC_HANDLE;
typedef long RPC_STATUS;

#ifndef _MAC
#define RPC_UNICODE_SUPPORTED
#endif //_MAC


#ifdef __RPC_MAC__
#	define __RPC_FAR
#	define __RPC_API
#	define __RPC_USER
#	define __RPC_STUB
#	define RPC_ENTRY
#elif   (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#	define __RPC_FAR
#	define __RPC_API  __stdcall
#	define __RPC_USER __stdcall
#	define __RPC_STUB __stdcall
#	define  RPC_ENTRY __stdcall
#else
#	define __RPC_FAR
#	define __RPC_API
#	define __RPC_USER
#	define __RPC_STUB
#endif

// Some RPC platforms don't define DECLSPEC_IMPORT
#if !defined(DECLSPEC_IMPORT)
#if (defined(_M_MRX000) || defined(_M_IX86) || defined(_M_ALPHA) || defined(_M_PPC)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif
#endif

#if !defined(_RPCRT4_)
#define RPCRTAPI DECLSPEC_IMPORT
#else
#define RPCRTAPI
#endif

#if !defined(_RPCNS4_)
#define RPCNSAPI DECLSPEC_IMPORT
#else
#define RPCNSAPI
#endif

#ifdef IN
#undef IN
#undef OUT
#undef OPTIONAL
#endif /* IN */

#ifdef __RPC_MAC__

#include <setjmp.h>

#define RPCXCWORD (sizeof(jmp_buf)/sizeof(int))

#pragma warning( disable: 4005 ) 
#include <rpcdce.h>
#include <rpcnsi.h>
#include <rpcerr.h>
#include <rpcmac.h>
#pragma warning( default :  4005 )

typedef void  (RPC_ENTRY *MACYIELDCALLBACK)(/*OSErr*/ short *) ; 
RPC_STATUS RPC_ENTRY
RpcMacSetYieldInfo(
	MACYIELDCALLBACK pfnCallback) ;

#if !defined(UNALIGNED)
#define UNALIGNED
#endif

#include <poppack.h>

#else // __RPC_MAC__

#include <rpcdce.h>
#include <rpcnsi.h>
#include <rpcnterr.h>
#include <excpt.h>
#include <winerror.h>

#define RpcTryExcept \
    __try \
        {

// trystmts

#define RpcExcept(expr) \
        } \
    __except (expr) \
        {

// exceptstmts

#define RpcEndExcept \
        }

#define RpcTryFinally \
    __try \
        {

// trystmts

#define RpcFinally \
        } \
    __finally \
        {

// finallystmts

#define RpcEndFinally \
        }

#define RpcExceptionCode() GetExceptionCode()
#define RpcAbnormalTermination() AbnormalTermination()

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcImpersonateClient (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcRevertToSelfEx (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    );

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcRevertToSelf (
    );

RPCRTAPI
long
RPC_ENTRY
I_RpcMapWin32Status (
    IN RPC_STATUS Status
    );

#endif // __RPC_MAC__

// Definitions which depend on windows.h
#if !defined( RPC_NO_WINDOWS_H ) && !defined( MAC ) && !defined( _MAC )

#include <rpcasync.h>

#endif // RPC_NO_WINDOWS_H

#ifdef __cplusplus
}
#endif

#endif // __RPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\drawpie.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#pragma once

int IntSqrt(unsigned long dwNum);

#define DP_USEDCOLOR  0
#define DP_FREECOLOR  1
#define DP_USEDSHADOW 2
#define DP_FREESHADOW 3

VOID DrawPie(HDC hDC, LPCRECT prcItem, 
			 UINT uPctX10, BOOL TrueZr100,
             UINT uOffset, const COLORREF *lpColors);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\drawpie.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "drawpie.h"

#ifdef  WIN32
#define MoveTo(_hdc,_x,_y) MoveToEx(_hdc, _x, _y, NULL)
#endif  // WIN32

// I looked at the ASM this thing generates, and it is actually better than
// what I have above (I did not know about SHL EDI,2 and forgot about the LEA
// ECX,[EAX*2] trick)!  It only uses registers, and it probably also takes into
// account little nuances about what kinds of operations should be separated so
// the processor does not get hung up.  WOW!
int IntSqrt(unsigned long dwNum)
{
	// We will keep shifting dwNum left and look at the top two bits.

	// initialize sqrt and remainder to 0.
	DWORD dwSqrt = 0, dwRemain = 0, dwTry;
	int i;

	// We iterate 16 times, once for each pair of bits.
	for (i=0; i<16; ++i)
	{
		// Mask off the top two bits of dwNum and rotate them into the
		// bottom of the remainder
		dwRemain = (dwRemain<<2) | (dwNum>>30);

		// Now we shift the sqrt left; next we'll determine whether the
		// new bit is a 1 or a 0.
		dwSqrt <<= 1;

		// This is where we double what we already have, and try a 1 in
		// the lowest bit.
		dwTry = dwSqrt*2 + 1;

		if (dwRemain >= dwTry)
		{
			// The remainder was big enough, so subtract dwTry from
			// the remainder and tack a 1 onto the sqrt.
			dwRemain -= dwTry;
			dwSqrt |= 0x01;
		}

		// Shift dwNum to the left by 2 so we can work on the next few
		// bits.
		dwNum <<= 2;
	}

	return(dwSqrt);
}

VOID DrawPie(HDC hDC, LPCRECT lprcItem, UINT uPctX10, BOOL TrueZr100,
                  UINT uOffset, const COLORREF *lpColors)
{
	int cx, cy, rx, ry, x, y;
	int uQPctX10;
	RECT rcItem;
	HRGN hEllRect, hEllipticRgn, hRectRgn;
	HBRUSH hBrush, hOldBrush;
	HPEN hPen, hOldPen;

	rcItem = *lprcItem;
	rcItem.left = lprcItem->left;
	rcItem.top = lprcItem->top;
	rcItem.right = lprcItem->right - rcItem.left;
	rcItem.bottom = lprcItem->bottom - rcItem.top - uOffset;

	rx = rcItem.right / 2;
	cx = rcItem.left + rx - 1;
	ry = rcItem.bottom / 2;
	cy = rcItem.top + ry - 1;
	if (rx<=10 || ry<=10)
	{
		return;
	}

	rcItem.right = rcItem.left+2*rx;
	rcItem.bottom = rcItem.top+2*ry;

	if (uPctX10 > 1000)
	{
		uPctX10 = 1000;
	}

	/* Translate to first quadrant of a Cartesian system
	*/
	uQPctX10 = (uPctX10 % 500) - 250;
	if (uQPctX10 < 0)
	{
		uQPctX10 = -uQPctX10;
	}

	/* Calc x and y.  I am trying to make the area be the right percentage.
	** I don't know how to calculate the area of a pie slice exactly, so I
	** approximate it by using the triangle area instead.
	*/
	if (uQPctX10 < 120)
	{
		x = IntSqrt(((DWORD)rx*(DWORD)rx*(DWORD)uQPctX10*(DWORD)uQPctX10)
			/((DWORD)uQPctX10*(DWORD)uQPctX10+(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)));

		y = IntSqrt(((DWORD)rx*(DWORD)rx-(DWORD)x*(DWORD)x)*(DWORD)ry*(DWORD)ry/((DWORD)rx*(DWORD)rx));
	}
	else
	{
		y = IntSqrt((DWORD)ry*(DWORD)ry*(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)
			/((DWORD)uQPctX10*(DWORD)uQPctX10+(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)));

		x = IntSqrt(((DWORD)ry*(DWORD)ry-(DWORD)y*(DWORD)y)*(DWORD)rx*(DWORD)rx/((DWORD)ry*(DWORD)ry));
	}

	/* Switch on the actual quadrant
	*/
	switch (uPctX10 / 250)
	{
	case 1:
		y = -y;
		break;

	case 2:
		break;

	case 3:
		x = -x;
		break;

	default: // case 0 and case 4
		x = -x;
		y = -y;
		break;
	}

	/* Now adjust for the center.
	*/
	x += cx;
	y += cy;

    x = x < 0 ? 0 : x;

	/* Draw the shadows using regions (to reduce flicker).
	*/
	hEllipticRgn = CreateEllipticRgnIndirect(&rcItem);
	if(hEllipticRgn == NULL)
	{
		//VINOTH : May be we might have to show some error message
		return;
	}
	OffsetRgn(hEllipticRgn, 0, uOffset);
	hEllRect = CreateRectRgn(rcItem.left, cy, rcItem.right, cy+uOffset);
	if(hEllRect == NULL)
	{
		//VINOTH : May be we might have to show some error message
		DeleteObject(hEllipticRgn);
		return;
	}
	hRectRgn = CreateRectRgn(0, 0, 0, 0);
	if(hRectRgn == NULL)
	{
		//VINOTH : May be we might have to show some error message
		DeleteObject(hEllipticRgn);
		DeleteObject(hEllRect);
		return;
	}
	CombineRgn(hRectRgn, hEllipticRgn, hEllRect, RGN_OR);
	OffsetRgn(hEllipticRgn, 0, -(int)uOffset);
	CombineRgn(hEllRect, hRectRgn, hEllipticRgn, RGN_DIFF);

	/* Always draw the whole area in the free shadow/
	*/
	hBrush = CreateSolidBrush(lpColors[DP_FREESHADOW]);
	if (hBrush)
	{
		FillRgn(hDC, hEllRect, hBrush);
		DeleteObject(hBrush);
	}

	/* Draw the used shadow only if the disk is at least half used.
	*/
	if (uPctX10>500 && (hBrush=CreateSolidBrush(lpColors[DP_USEDSHADOW]))!=NULL)
	{
		DeleteObject(hRectRgn);
		hRectRgn = CreateRectRgn(x, cy, rcItem.right, lprcItem->bottom);
		CombineRgn(hEllipticRgn, hEllRect, hRectRgn, RGN_AND);
		FillRgn(hDC, hEllipticRgn, hBrush);
		DeleteObject(hBrush);
	}

	DeleteObject(hRectRgn);
	DeleteObject(hEllipticRgn);
	DeleteObject(hEllRect);

	hPen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME));
	hOldPen = (HPEN)SelectObject(hDC, hPen);

	if((uPctX10 < 100) && (cy == y))
	{
	    hBrush = CreateSolidBrush(lpColors[DP_FREECOLOR]);
	    hOldBrush = (HBRUSH)SelectObject(hDC, hBrush);
	    if((TrueZr100 == FALSE) || (uPctX10 != 0))
	    {
		Pie(hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom,
			rcItem.left, cy, x, y);
	    }
	    else
	    {
		Ellipse(hDC, rcItem.left, rcItem.top, rcItem.right,
			     rcItem.bottom);
	    }
	}
	else if((uPctX10 > (1000 - 100)) && (cy == y))
	{
	    hBrush = CreateSolidBrush(lpColors[DP_USEDCOLOR]);
	    hOldBrush = (HBRUSH)SelectObject(hDC, hBrush);
	    if((TrueZr100 == FALSE) || (uPctX10 != 1000))
	    {
		Pie(hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom,
			rcItem.left, cy, x, y);
	    }
	    else
	    {
		Ellipse(hDC, rcItem.left, rcItem.top, rcItem.right,
			     rcItem.bottom);
	    }
	}
	else
	{
	    hBrush = CreateSolidBrush(lpColors[DP_USEDCOLOR]);
	    hOldBrush = (HBRUSH)SelectObject(hDC, hBrush);

	    Ellipse(hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom);
	    SelectObject(hDC, hOldBrush);
	    DeleteObject(hBrush);

	    hBrush = CreateSolidBrush(lpColors[DP_FREECOLOR]);
	    hOldBrush = (HBRUSH)SelectObject(hDC, hBrush);
	    Pie(hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom,
		    rcItem.left, cy, x, y);
	}
	SelectObject(hDC, hOldBrush);
	DeleteObject(hBrush);

	/* Do not draw the lines if the %age is truely 0 or 100 (completely
	** empty disk or completely full disk)
	*/
	if((TrueZr100 == FALSE) || ((uPctX10 != 0) && (uPctX10 != 1000)))
	{
	    Arc(hDC, rcItem.left, rcItem.top+uOffset, rcItem.right, rcItem.bottom+uOffset,
		    rcItem.left, cy+uOffset, rcItem.right, cy+uOffset-1);
	    MoveTo(hDC, rcItem.left, cy);
	    LineTo(hDC, rcItem.left, cy+uOffset);
	    MoveTo(hDC, rcItem.right-1, cy);
	    LineTo(hDC, rcItem.right-1, cy+uOffset);

	    if (uPctX10 > 500)
	    {
		    MoveTo(hDC, x, y);
		    LineTo(hDC, x, y+uOffset);
	    }
	}
	SelectObject(hDC, hOldPen);
	DeleteObject(hPen);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\debug.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
/*----------------------------------------------------------------------------
/ Title;
/   debug.cpp
/
/ Authors;
/   David De Vorchik (daviddv)
/
/ Notes;
/   Provides printf style debug output
/----------------------------------------------------------------------------*/
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
//#include "pch.h"
#include "stdio.h"


#ifdef DEBUG


/*-----------------------------------------------------------------------------
/ Locals & helper functions
/----------------------------------------------------------------------------*/

LONG  g_cDepth = -1;
DWORD g_dwTraceMask = 0;

#define MAX_CALL_DEPTH  64

struct
{
    BOOL    m_fTracedYet : 1;
    LPCTSTR m_pFunctionName;
    DWORD   m_dwMask;
}
g_CallStack[MAX_CALL_DEPTH];

#define BUFFER_SIZE 4096

static TCHAR szIndentBuffer[BUFFER_SIZE];
static TCHAR szTraceBuffer[BUFFER_SIZE];

/*-----------------------------------------------------------------------------
/ _indent
/ -------
/   Output to the debug stream indented by n columns.
/
/ In:
/   i = column to indent to.
/   pString -> string to be indented
/
/ Out:
/   -
/----------------------------------------------------------------------------*/

void _indent(LONG i, LPCTSTR pString)
{
    szIndentBuffer[0] = TEXT('\0');

    wsprintf(szIndentBuffer, TEXT("%08x "), GetCurrentThreadId());

    for ( ; i > 0 ; i-- )
        lstrcat(szIndentBuffer, TEXT("  "));
    
    lstrcat(szIndentBuffer, pString);
    lstrcat(szIndentBuffer, TEXT("\n"));

    OutputDebugString(szIndentBuffer);
}


/*-----------------------------------------------------------------------------
/ _output_proc_name
/ -----------------
/   Handle the output of a procedure name, including indenting and handling
/   the opening braces.
/
/ In:
/   iCallDepth = callstack depth, defines the indent and the name index
/                to be extracted.
/   fOpenBrace = suffix with opening brace.
/ Out:
/   -
/----------------------------------------------------------------------------*/
void _output_proc_name(LONG iCallDepth)
{
    _indent(iCallDepth, g_CallStack[iCallDepth].m_pFunctionName);
}


/*-----------------------------------------------------------------------------
/ _trace_prolog
/ -------------
/   Handle the prolog to a prefix string, including outputting the
/   function name if we haven't already.
/
/ In:
/   iDepth = depth in the call stack
/   fForce = ignore flags
/
/ Out:
/   BOOL if trace output should be made
/----------------------------------------------------------------------------*/
BOOL _trace_prolog(LONG iDepth, BOOL fForce)
{
    if  ( (g_dwTraceMask & g_CallStack[iDepth].m_dwMask) || fForce )
    {
        if ( iDepth > 0 )
        {
            if ( !g_CallStack[iDepth-1].m_fTracedYet )
                _trace_prolog(iDepth-1, TRUE);
        }

        if ( !g_CallStack[iDepth].m_fTracedYet )
        {
            _output_proc_name(iDepth);
            g_CallStack[iDepth].m_fTracedYet = TRUE;
        }

        return TRUE;
    }

    return FALSE;
}


/*-----------------------------------------------------------------------------
/ DoTraceSetMask
/ --------------
/   Adjust the trace mask to reflect the state given.
/
/ In:
/   dwMask = mask for enabling / disable trace output
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceSetMask(DWORD dwMask)
{
    g_dwTraceMask = dwMask;
}


/*-----------------------------------------------------------------------------
/ DoTraceEnter
/ ------------
/   Set the debugging call stack up to indicate which function we are in.
/
/ In:
/   pName -> function name to be displayed in subsequent trace output.
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceEnter(DWORD dwMask, LPCTSTR pName)
{
    g_cDepth++;

    if ( g_cDepth < MAX_CALL_DEPTH )
    {
        if ( !pName )    
            pName = TEXT("<no name>");         // no function name given

        g_CallStack[g_cDepth].m_fTracedYet = FALSE;
        g_CallStack[g_cDepth].m_pFunctionName = pName;
        g_CallStack[g_cDepth].m_dwMask = dwMask;

        if ( (g_cDepth > 0) && ( g_cDepth < MAX_CALL_DEPTH ) )
            _trace_prolog(g_cDepth-1, FALSE);
    }
}


/*-----------------------------------------------------------------------------
/ DoTraceLeave
/ ------------
/   On exit from a function this will adjust the function stack pointer to 
/   point to our previous function.  If no trace output has been made then 
/   we will output the function name on a single line (to indicate we went somewhere).
/
/ In:
/    -
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceLeave(void)
{
    if ( ( g_cDepth >= 0 ) && ( g_cDepth <= MAX_CALL_DEPTH ) )
        _trace_prolog(g_cDepth, FALSE);

    if ( !g_cDepth && g_CallStack[0].m_fTracedYet )
        OutputDebugString(TEXT("\n"));
    
    g_cDepth = max(g_cDepth-1, -1);         // account for underflow
}


/*-----------------------------------------------------------------------------
/ DoTrace
/ -------
/   Perform printf formatting to the debugging stream.  We indent the output
/   and stream the function name as required to give some indication of 
/   call stack depth.
/
/ In:
/   pFormat -> printf style formatting string
/   ... = arguments as required for the formatting
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTrace(LPCTSTR pFormat, ...)
{
    va_list va;

    if ( ( g_cDepth >= 0 ) && ( g_cDepth < MAX_CALL_DEPTH ) )
    {
        if ( _trace_prolog(g_cDepth, FALSE) )
        {
            va_start(va, pFormat);
            wvsprintf(szTraceBuffer, pFormat, va);
            va_end(va);
            
            _indent(g_cDepth+1, szTraceBuffer);
        }
    }
}


/*-----------------------------------------------------------------------------
/ DoTraceGuid
/ -----------
/   Given a GUID output it into the debug string, first we try and map it
/   to a name (ie. IShellFolder), if that didn't work then we convert it
/   to its human readable form.
/
/ In:
/   pszPrefix -> prefix string
/   lpGuid -> guid to be streamed   
/
/ Out:
/   -
/----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
/ DoTraceAssert
/ -------------
/   Our assert handler, out faults it the trace mask as enabled assert
/   faulting.
/
/ In:
/   iLine = line 
/   pFilename -> filename of the file we asserted in
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceAssert(int iLine, LPTSTR pFilename)
{
    TCHAR szBuffer[1024] = {0};

    wsprintf(szBuffer, TEXT("Assert failed in %s, line %d"), pFilename, iLine);

    _trace_prolog(g_cDepth, TRUE);          // nb: TRUE asserts always displabed
    _indent(g_cDepth+1, szBuffer);

//    if ( g_dwTraceMask & TRACE_COMMON_ASSERT )
//        DebugBreak();
}
    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\debug.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __debug_h
#define __debug_h


/*-----------------------------------------------------------------------------
/ Debugging APIs (use the Macros, they make it easier and cope with correctly
/ removing debugging when it is disabled at built time).
/----------------------------------------------------------------------------*/
void DoTraceSetMask(DWORD dwMask);
void DoTraceEnter(DWORD dwMask, LPCTSTR pName);
void DoTraceLeave(void);
void DoTrace(LPCTSTR pFormat, ...);
void DoTraceGUID(LPCTSTR pPrefix, REFGUID rGUID);
void DoTraceAssert(int iLine, LPTSTR pFilename);


/*-----------------------------------------------------------------------------
/ Macros to ease the use of the debugging APIS.
/----------------------------------------------------------------------------*/

#pragma warning(disable:4127)	// conditional expression is constant

#if DBG
#define DEBUG
#define debug if ( TRUE )
#else
#undef  DEBUG
#define debug if ( FALSE )
#endif

#define TraceSetMask(dwMask)    debug DoTraceSetMask(dwMask)
#define TraceEnter(dwMask, fn)  debug DoTraceEnter(dwMask, TEXT(fn))
#define TraceLeave              debug DoTraceLeave

#define Trace                   debug DoTrace
#define TraceMsg(s)             debug DoTrace(TEXT(s))
#define TraceGUID(s, rGUID)     debug DoTraceGUID(TEXT(s), rGUID)

#ifdef DEBUG

#define TraceAssert(x) \
                { if ( !(x) ) DoTraceAssert(__LINE__, TEXT(__FILE__)); }

#define TraceLeaveResult(hr) \
                { HRESULT __hr = hr; if (FAILED(__hr)) Trace(TEXT("Failed (%08x)"), hr); TraceLeave(); return __hr; }

#define TraceLeaveVoid() \
                { TraceLeave(); return; }

#define TraceLeaveValue(value) \
                { TraceLeave(); return(value); }

#else
#define TraceAssert(x)
#define TraceLeaveResult(hr)    { return hr; }
#define TraceLeaveVoid()	{ return; }
#define TraceLeaveValue(value)  { return(value); }
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\drivespage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "DrivesPage.h"
#include "resource.h"
#include "..\Common\util.h"
#include <stdlib.h>
#include <TCHAR.h>
#include "drawpie.h"
#include <windowsx.h>
#include "help.h"

#define MAXLEN_NTFS_LABEL 32

//--------------------------------------------------------------
DrivesPage::DrivesPage(WbemServiceThread *thread,
					   CWbemClassObject &inst,
					   UINT iconID,
					   HWND *propSheet,
					   bstr_t bstrDesc,
					   wchar_t *mangled,
						LONG_PTR lNotifyHandle, 
						bool bDeleteHandle, 
						TCHAR* pTitle) :
					    WBEMPageHelper(thread),
							m_propSheet(propSheet),
							m_bstrDesc(bstrDesc),
							CSnapInPropertyPageImpl<DrivesPage> (pTitle),
							m_lNotifyHandle(lNotifyHandle),
							m_bDeleteHandle(bDeleteHandle) // Should be true for only page.
{
	// I really dont want this one.
	if(m_service)
	{
		m_service->Release();
		m_service = 0;
	}

	m_WbemServices.DisconnectServer();
	m_WbemServices = (IWbemServices *)0;  
	m_qwTot  = 0;
	m_qwFree = 0;
	m_iconID = iconID;
	m_inst = inst;
	m_mangled = mangled;
}

//--------------------------------------------------------------
DrivesPage::~DrivesPage()
{
	*m_propSheet = 0;
	if (m_bDeleteHandle)
		HRESULT x = MMCFreeNotifyHandle(m_lNotifyHandle);
}

//--------------------------------------------------------------
LRESULT DrivesPage::OnDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{ 
    DrawItem((DRAWITEMSTRUCT *)lParam);
	return S_OK; 
}

//--------------------------------------------------------------
LRESULT DrivesPage::OnCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0L);
	// NOTE: original code (drivesx.c) has many other commands if
	// we ever support those buttons.
	return S_OK; 
}

//--------------------------------------------------------------
BOOL DrivesPage::OnApply()
{
	WCHAR szLabel[MAXLEN_NTFS_LABEL+1];
	HRESULT hr = 0;
	CWindow volHWND(GetDlgItem(IDC_DRV_LABEL));

	BOOL modified = (BOOL)volHWND.SendMessage(EM_GETMODIFY);

	if(modified)
	{
		m_WbemServices = g_serviceThread->GetPtr();
		::GetWindowText(volHWND, szLabel, ARRAYSIZE(szLabel));
		hr = m_inst.Put("VolumeName", (bstr_t)szLabel);
		hr = m_WbemServices.PutInstance(m_inst);

		if(FAILED(hr))
		{
			TCHAR caption[50] = {0}, fmt[100] = {0}, text[100] = {0};

			::LoadString(HINST_THISDLL, 
							IDS_DISPLAY_NAME,
							caption, ARRAYSIZE(caption));

			::LoadString(HINST_THISDLL, 
							IDS_WRITE_PROTECTED_MEDIA,
							fmt, ARRAYSIZE(fmt));
			wsprintf(text, fmt, szLabel);

			::MessageBox(m_hDlg, text, caption,
						MB_OK | MB_ICONHAND);

			return FALSE;
		}
	}

	return TRUE; 
}

//-----------------------------------------------------------------------------
const static DWORD aDrvPrshtHelpIDs[] = {  // Context Help IDs
    IDC_DRV_ICON,          IDH_FCAB_DRV_ICON,
    IDC_DRV_LABEL,         IDH_FCAB_DRV_LABEL,
    IDC_DRV_TYPE_TXT,      IDH_FCAB_DRV_TYPE,
    IDC_DRV_TYPE,          IDH_FCAB_DRV_TYPE,
    IDC_DRV_FS_TXT,        IDH_FCAB_DRV_FS,
    IDC_DRV_FS,            IDH_FCAB_DRV_FS,
    IDC_DRV_USEDCOLOR,     IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_USEDBYTES_TXT, IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_USEDBYTES,     IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_USEDMB,        IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_FREECOLOR,     IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_FREEBYTES_TXT, IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_FREEBYTES,     IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_FREEMB,        IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_TOTSEP,        NO_HELP,
    IDC_DRV_TOTBYTES_TXT,  IDH_FCAB_DRV_TOTSEP,
    IDC_DRV_TOTBYTES,      IDH_FCAB_DRV_TOTSEP,
    IDC_DRV_TOTMB,         IDH_FCAB_DRV_TOTSEP,
    IDC_DRV_PIE,           IDH_FCAB_DRV_PIE,
    IDC_DRV_LETTER,        IDH_FCAB_DRV_LETTER,
    IDC_DRV_CLEANUP,       IDH_FCAB_DRV_CLEANUP,
    0, 0
};

//-----------------------------------------------------------------------------
LRESULT DrivesPage::OnF1Help(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
				NULL, 
				HELP_WM_HELP, 
				(ULONG_PTR)(LPSTR)aDrvPrshtHelpIDs);

	return S_OK;
}

//-----------------------------------------------------------------------------
LRESULT DrivesPage::OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	::WinHelp((HWND)wParam,
				NULL, 
				HELP_CONTEXTMENU, 
				(ULONG_PTR)(LPSTR)aDrvPrshtHelpIDs);

	return S_OK;
}

//-----------------------------------------------------------------------------
/*#undef Static_SetIcon
#define Static_SetIcon(hwndCtl, hIcon)          ((HICON)(UINT)(DWORD)::SendMessage((hwndCtl), STM_SETICON, (WPARAM)(HICON)(hIcon), 0L))
*/
LRESULT DrivesPage::OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TCHAR szFormat[80] = {0};
    TCHAR szTemp[30] = {0};
    _bstr_t driveName;
    HDC hDC;
    SIZE size;
	//_bstr_t temp;
	TCHAR driveLtr[3] = {0};

	HourGlass(true);
	m_hDlg = m_hWnd;

	*m_propSheet = GetParent();

	if(g_serviceThread)
	{
		g_serviceThread->SendPtr(m_hWnd);
	}

    driveName = m_inst.GetString("Name");

	// isolate the drive letter for later.
	_tcsncpy(driveLtr, driveName, driveName.length());

    hDC = GetDC();
    GetTextExtentPoint(hDC, TEXT("W"), 1, &size);
    m_dwPieShadowHgt = size.cy * 2 / 3;
    ReleaseDC(hDC);

    // get the icon
	HICON hiconT, hIcon = LoadIcon(HINST_THISDLL, MAKEINTRESOURCE(m_iconID));

	// set it into the picture control.
    if(hIcon)
    {
		hiconT = Static_SetIcon(GetDlgItem(IDC_DRV_ICON), hIcon);

		// destroy the old icon.
        if(hiconT)
        {
            DestroyIcon(hiconT);
        }
    }

    CWindow hCtl(GetDlgItem(IDC_DRV_LABEL));

	_bstr_t szFileSystem = m_inst.GetString("FileSystem");

	if(szFileSystem.length() != 0)
		SetDlgItemText(IDC_DRV_FS, szFileSystem);

	//-------------------------------
	// deal with Volume Label.
	variant_t vol;
    m_inst.Get("VolumeName", vol);

	// if media isn't inserted...
	if(vol.vt == VT_NULL)
	{
		hCtl.SetWindowText(L"");
		hCtl.EnableWindow(FALSE);
	}
	else // media inserted.
	{
		// cast to bstr_t
		wcscpy(szTemp, V_BSTR(&vol));
		if(wcsncmp(szFileSystem, L"FAT", 1) == 0)
		{
			hCtl.SendMessage(EM_LIMITTEXT, 11);
		}
		else
		{
			hCtl.SendMessage(EM_LIMITTEXT, MAXLEN_NTFS_LABEL);
		}

		hCtl.SendMessage(EM_SETMODIFY, FALSE);

		// cant change volumeName on various drives.
		if((m_iconID == IDI_DRIVENET) ||
		   (m_iconID == IDI_DRIVECD) ||
		   (m_iconID == IDI_DRIVERAM))
		{
			hCtl.SendMessage(EM_SETREADONLY, TRUE);
		}

		wchar_t fmt[100], caption[100];
		memset(fmt, 0, 100 * sizeof(wchar_t));
		memset(caption, 0, 100 * sizeof(wchar_t));

		if(::LoadString(HINST_THISDLL, 
						IDS_SHEET_CAPTION_FMT,
						fmt, 100) == 0)
		{
			wcscpy(fmt, L"%s (%c:) Properties");
		}

		// if its locally mapped...
		if(wcslen(m_mangled) == 0)
		{
			swprintf(caption, fmt, (wchar_t *)szTemp, driveLtr[0]);
		}
		else
		{
			// format sheet caption using m_mangled. (network drives)
			swprintf(caption, fmt, m_mangled, driveLtr[0]);
		}
		hCtl.SetWindowText(szTemp);
		::SetWindowText(GetParent(), caption);
	}

    SetDlgItemText(IDC_DRV_TYPE, (LPCTSTR)m_bstrDesc);

    UpdateSpaceValues(m_inst);

#if OPSYS==NT
    //UpdateCompressStatus(pdpsp);
#endif

	// Do the 'Drive C' label. IDS_DRIVELETTER is formatted to extract the
	// first letter of the driveName which is the drive letter w/o the ':'.
    if (LoadString(HINST_THISDLL, IDS_DRIVELETTER, szFormat, ARRAYSIZE(szFormat)))
    {
        _stprintf(szTemp, szFormat, driveLtr[0]);
        SetDlgItemText(IDC_DRV_LETTER, szTemp);
    }

    // on memphis, turn on the Disk Cleanup button
//    if(g_bRunOnMemphis)
//    {
//        ShowWindow(GetDlgItem(m_hDlg, IDC_DRV_CLEANUP), SW_SHOW);
//        EnableWindow(GetDlgItem(m_hDlg, IDC_DRV_CLEANUP), TRUE);
//    }

	HourGlass(false);
	
	return S_OK;	
}

///////////////////////////////////////////////////////////////////////////////
// FUNCTION: UpdateSpaceValues
//
// DESCRIPTION:
//    Updates the Used space, Free space and Capacity values on the drive
//    general property page..
//
// NOTE:
//    This function was separated from _DrvPrshtInit because drive space values
//    must be updated after a compression/uncompression operation as well as
//    during dialog initialization.
///////////////////////////////////////////////////////////////////////////////
void DrivesPage::UpdateSpaceValues(CWbemClassObject &inst)
{
   BOOL fResult  = FALSE;

   TCHAR szTemp[80] = {0};
   TCHAR szTemp2[30] = {0};
   TCHAR szFormat[30] = {0};

   m_qwTot = inst.GetI64("Size");
   m_qwFree = inst.GetI64("FreeSpace");

   if(m_qwTot == 0)
	   return;

   if(LoadString(HINST_THISDLL, IDS_BYTES, szFormat, ARRAYSIZE(szFormat)))
   {

      //
      // NT must be able to display 64-bit numbers; at least as much
      // as is realistic.  We've made the decision
      // that volumes up to 100 Terrabytes will display the byte value
      // and the short-format value.  Volumes of greater size will display
      // "---" in the byte field and the short-format value.  Note that the
      // short format is always displayed.
      TCHAR szNumStr[MAX_PATH + 1] = {_T('\0')};  // For 64-bit int format.
      NUMBERFMT NumFmt;                             // For 64-bit int format.
      TCHAR szLocaleInfo[20] = {0};                       // For 64-bit int format.
      TCHAR szDecimalSep[5] = {0};                        // Locale-specific.
      TCHAR szThousandSep[5] = {0};                       // Locale-specific.
      const _int64 MaxDisplayNumber = 99999999999999; // 100TB - 1.

      // Prepare number format info for current locale.
      NumFmt.NumDigits     = 0;  // This is locale-insensitive.
      NumFmt.LeadingZero   = 0;  // So is this.

      GetLocaleInfo(LOCALE_USER_DEFAULT, 
					LOCALE_SGROUPING, 
					szLocaleInfo, 
					ARRAYSIZE(szLocaleInfo));
	  _stscanf(szLocaleInfo, _T("%ld"), &(NumFmt.Grouping));

//      NumFmt.Grouping = StrToLong(szLocaleInfo);

      GetLocaleInfo(LOCALE_USER_DEFAULT, 
					LOCALE_SDECIMAL, 
					szDecimalSep, 
					ARRAYSIZE(szDecimalSep));
      NumFmt.lpDecimalSep  = szDecimalSep;

      GetLocaleInfo(LOCALE_USER_DEFAULT, 
					LOCALE_STHOUSAND, 
					szThousandSep, 
					ARRAYSIZE(szThousandSep));
      NumFmt.lpThousandSep = szThousandSep;

      GetLocaleInfo(LOCALE_USER_DEFAULT, 
					LOCALE_INEGNUMBER, 
					szLocaleInfo, 
					ARRAYSIZE(szLocaleInfo));
  	  _stscanf(szLocaleInfo, _T("%ld"), &(NumFmt.NegativeOrder));
//      NumFmt.NegativeOrder = StrToLong(szLocaleInfo);

#if 0
      //
      // Use this to test range of display behaviors.
      // Total bytes displays "---" for too-large number.
      // Used bytes displays max displayable number.
      // Free bytes displays 1.
      //
      m_qwTot  = MaxDisplayNumber + 1;
      m_qwFree = 1;
#endif

      if ((m_qwTot - m_qwFree) <= MaxDisplayNumber)
      {
         Int64ToString(m_qwTot - m_qwFree, 
						szNumStr, 
						ARRAYSIZE(szNumStr) + 1, 
						TRUE, 
						&NumFmt, 
						NUMFMT_ALL);
         _stprintf(szTemp, szFormat, szNumStr, szTemp2);
         SetDlgItemText(IDC_DRV_USEDBYTES, szTemp);
      }

      if (m_qwFree <= MaxDisplayNumber)
      {
         Int64ToString(m_qwFree, 
						szNumStr, 
						ARRAYSIZE(szNumStr) + 1, 
						TRUE, 
						&NumFmt, 
						NUMFMT_ALL);
         _stprintf(szTemp, szFormat, szNumStr, szTemp2);
         SetDlgItemText(IDC_DRV_FREEBYTES, szTemp);
      }

      if (m_qwTot <= MaxDisplayNumber)
      {
         Int64ToString(m_qwTot, 
						szNumStr, 
						ARRAYSIZE(szNumStr) + 1, 
						TRUE, 
						&NumFmt, 
						NUMFMT_ALL);
         _stprintf(szTemp, szFormat, szNumStr, szTemp2);
         SetDlgItemText(IDC_DRV_TOTBYTES, szTemp);
      }
   }

   ShortSizeFormat64(m_qwTot - m_qwFree, szTemp);
   SetDlgItemText(IDC_DRV_USEDMB, szTemp);

   ShortSizeFormat64(m_qwFree, szTemp);
   SetDlgItemText(IDC_DRV_FREEMB, szTemp);

   ShortSizeFormat64(m_qwTot, szTemp);
   SetDlgItemText(IDC_DRV_TOTMB, szTemp);
}
//--------------------------------------------------------------------
// Used to map int i to the formatting string.
const short pwOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB,
                          IDS_ORDERGB, IDS_ORDERTB, IDS_ORDERPB, IDS_ORDEREB};

/* converts numbers into short formats
 *      532     -> 523 bytes
 *      1340    -> 1.3KB
 *      23506   -> 23.5KB
 *              -> 2.4MB
 *              -> 5.2GB
 */
LPTSTR DrivesPage::ShortSizeFormat64(__int64 dw64, LPTSTR szBuf)
{
    int i;				// rough size of the number.
    _int64 wInt;
    UINT wLen, wDec;
    TCHAR szTemp[MAX_COMMA_NUMBER_SIZE] = {0}, szOrder[20] = {0}, szFormat[5] = {0};

    if (dw64 < 1000) {
        _stprintf(szTemp, _T("%d"), LODWORD(dw64));
        i = 0;
        goto AddOrder;
    }

    for (i = 1; 
			(i < ARRAYSIZE(szOrder) - 1) && (dw64 >= (1000L * 1024L)); 
				dw64 >>= 10, i++);
        /* do nothing */

    wInt = dw64 >> 10;
    AddCommas64(wInt, szTemp);
    wLen = lstrlen(szTemp);
    if (wLen < 3)
    {
        wDec = LODWORD(dw64 - wInt * 1024L) * 1000 / 1024;
        // At this point, wDec should be between 0 and 1000
        // we want get the top one (or two) digits.
        wDec /= 10;
        if (wLen == 2)
            wDec /= 10;

        // Note that we need to set the format before getting the
        // intl char.
        lstrcpy(szFormat, _T("%02d"));

        szFormat[2] = _T('0') + 3 - wLen;

        GetLocaleInfo(LOCALE_USER_DEFAULT, 
						LOCALE_SDECIMAL,
						szTemp + wLen, 
						ARRAYSIZE(szTemp) - wLen);

        wLen = lstrlen(szTemp);
        wLen += _stprintf(szTemp + wLen, szFormat, wDec);
    }

AddOrder:
    LoadString(HINST_THISDLL, pwOrders[i], szOrder, ARRAYSIZE(szOrder));
    _stprintf(szBuf, szOrder, (LPTSTR)szTemp);

    return szBuf;
}

//---------------------------------------------------------
const COLORREF c_crPieColors[] =
{
    RGB(  0,   0, 255),      // Blue
    RGB(255,   0, 255),      // Red-Blue
    RGB(  0,   0, 128),      // 1/2 Blue
    RGB(128,   0, 128),      // 1/2 Red-Blue
};
//---------------------------------------------------------
void DrivesPage::DrawItem(const DRAWITEMSTRUCT * lpdi)
{
    COLORREF crDraw = RGB(0,0,0);
    RECT rcItem = lpdi->rcItem;
    HBRUSH hbDraw, hbOld;

	// draw the pie.
    if(lpdi->CtlID == IDC_DRV_PIE)
    {
        DWORD dwPctX10 = m_qwTot ?
                         (DWORD)((__int64)1000 *
                                 (m_qwTot - m_qwFree) /m_qwTot) : 
							1000;

        DrawPie(lpdi->hDC, &lpdi->rcItem,
                dwPctX10,
                m_qwFree == 0 || m_qwFree == m_qwTot,
                m_dwPieShadowHgt, c_crPieColors);
	}
	else // draw one of the solid 'icons'
	{
		if(lpdi->CtlID == IDC_DRV_USEDCOLOR)
		{
			crDraw = c_crPieColors[DP_USEDCOLOR];
		}
		else if(lpdi->CtlID == IDC_DRV_FREECOLOR)
		{
			crDraw = c_crPieColors[DP_FREECOLOR];
		}

		// common draw code.
        hbDraw = CreateSolidBrush(crDraw);
        if (hbDraw)
        {
            hbOld = (HBRUSH)SelectObject(lpdi->hDC, hbDraw);
            if (hbOld)
            {
                PatBlt(lpdi->hDC, rcItem.left, rcItem.top,
                        rcItem.right-rcItem.left,
                        rcItem.bottom-rcItem.top,
                        PATCOPY);

                SelectObject(lpdi->hDC, hbOld);
            }

            DeleteObject(hbDraw);
			
        } // endif hDraw

	} //endif 'which control
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\errorpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "ErrorPage.h"
#include "resource.h"
#include "..\common\util.h"
#include "..\MMFutil\wbemError.h"

//--------------------------------------------------------------
ErrorPage::ErrorPage(long lNotifyHandle, 
						bool bDeleteHandle, 
						TCHAR* pTitle,
						ERROR_SRC src,
						UINT msg,
						HRESULT errorCode) :
							CSnapInPropertyPageImpl<ErrorPage> (pTitle),
							m_lNotifyHandle(lNotifyHandle),
							m_bDeleteHandle(bDeleteHandle) // Should be true for only page.
{
	m_msg = msg;
	m_hr = errorCode;
	m_src = src;
}
//--------------------------------------------------------------
ErrorPage::~ErrorPage()
{
}

//--------------------------------------------------------------
LRESULT ErrorPage::OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{

	CWindow msgHWND(GetDlgItem(IDC_MSG));
	CWindow errHWND(GetDlgItem(IDC_ERROR));

	WCHAR errorMsg[255], msgBuf[1024];
	memset(errorMsg, 0, 255 * sizeof(WCHAR));
	memset(msgBuf, 0, 1024 * sizeof(WCHAR));

	ErrorStringEx(m_hr, errorMsg, 255);

	if(m_msg == 0)
	{
		WCHAR resName[16];
		memset(resName, 0, 16);

		// FMT: "S<src>E<sc>"
		wsprintf(resName, L"S%dE%x", m_src, m_hr);
		HRSRC res = 0;
		DWORD x;

		HINSTANCE UtilInst = GetModuleHandle(_T("MMFUtil.dll"));
		if(res = ::FindResource(UtilInst, resName, L"MMFDATA"))
		{
			HGLOBAL hStr = 0;
			if(hStr = ::LoadResource(UtilInst, res))
			{
				LPTSTR pStr = (LPTSTR)::LockResource(hStr);
				UINT len = wcslen(pStr);
				wcsncpy(msgBuf, pStr, len);
			}
			else
			{
				x = GetLastError();
			}
		}
		else
		{
			x = GetLastError();
		}
	}
	else // use the one passed in.
	{
		if(::LoadString(HINST_THISDLL, m_msg, msgBuf, 1024) == 0)
		{
			msgBuf[0] = 0;
		}
	}

	msgHWND.SetWindowText(msgBuf);

	errHWND.SetWindowText(errorMsg);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\errorpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __ERRORPAGE__
#define __ERRORPAGE__
#pragma once

#include <atlsnap.h>
#include "resource.h"
#include "..\common\WbemPageHelper.h"
#include "..\MMFUtil\MsgDlg.h"

//-----------------------------------------------------------------------------
class ErrorPage : public CSnapInPropertyPageImpl<ErrorPage>
{
private:
	UINT m_msg;
	HRESULT m_hr;
	ERROR_SRC m_src;

public:

	ErrorPage(long lNotifyHandle, 
				bool bDeleteHandle = false, 
				TCHAR* pTitle = NULL,
				ERROR_SRC src = ConnectServer,
				UINT msg = 0,
				HRESULT errorCode = S_OK);

	~ErrorPage();

	enum { IDD = DLG_ERROR };

	typedef CSnapInPropertyPageImpl<ErrorPage> _baseClass;

	BEGIN_MSG_MAP(ErrorPage) 
		MESSAGE_HANDLER(WM_INITDIALOG, OnInit)
		CHAIN_MSG_MAP(_baseClass)
	END_MSG_MAP()

	LRESULT OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	long m_lNotifyHandle;
	bool m_bDeleteHandle;

};


#endif __ERRORPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\drivespage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __DRIVESPAGE__
#define __DRIVESPAGE__
#pragma once

#include "..\common\ServiceThread.h"
#include "..\common\WbemPageHelper.h"
#include <atlsnap.h>
#include "resource.h"

//-----------------------------------------------------------------------------
class DrivesPage : public CSnapInPropertyPageImpl<DrivesPage>,
					public WBEMPageHelper
{
public:

    DrivesPage(WbemServiceThread *thread, 
				CWbemClassObject &inst,
				UINT iconID,
				HWND *propSheet,
				bstr_t bstrDesc,
				wchar_t *mangled,
				LONG_PTR lNotifyHandle, 
				bool bDeleteHandle = false, 
				TCHAR* pTitle = NULL);

	~DrivesPage();

	enum { IDD = DLG_DRV_GENERAL };

	typedef CSnapInPropertyPageImpl<DrivesPage> _baseClass;
	
	BEGIN_MSG_MAP(DrivesPage) 
		MESSAGE_HANDLER(WM_INITDIALOG, OnInit)
		MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
		COMMAND_HANDLER(IDC_DRV_LABEL, EN_CHANGE, OnCommand)
		MESSAGE_HANDLER(WM_HELP, OnF1Help)
		MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextHelp)
		CHAIN_MSG_MAP(_baseClass)
	END_MSG_MAP()

	BOOL OnApply();
	LRESULT OnF1Help(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:

	LONG_PTR m_lNotifyHandle;
	bool m_bDeleteHandle;
	HWND *m_propSheet;

	UINT m_iconID;
	_int64 m_qwTot;
	_int64 m_qwFree;
	DWORD m_dwPieShadowHgt;
	CWbemClassObject m_inst;
	wchar_t *m_mangled;
	bstr_t m_bstrDesc;

	LRESULT OnDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

	void UpdateSpaceValues(CWbemClassObject &inst);
	void DrawItem(const DRAWITEMSTRUCT * lpdi);
	LPTSTR ShortSizeFormat64(__int64 dw64, LPTSTR szBuf);
};

#endif __DRIVESPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\fakesecuritysetting.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
//
//	FakeSecuritySetting
//
//////////////////////////////////////////////////////
#ifndef __FAKESECSETTING_H_
#define __FAKESECSETTING_H_

#include <sshWbemHelpers.h>


class FakeSecuritySetting
{
public:
	FakeSecuritySetting();
	~FakeSecuritySetting();

	HRESULT Wbem2SD(SECURITY_INFORMATION si,
							CWbemClassObject &w32sd, 
							CWbemServices &service,
							SECURITY_DESCRIPTOR **ppSD);

	HRESULT SD2Wbem(SECURITY_INFORMATION si,
							SECURITY_DESCRIPTOR *pSD,
							CWbemServices &service,
							CWbemClassObject &w32sd);
	
private:
	CWbemServices m_service;

	bool Wbem2ACL(_variant_t &w32ACL, PACL *pAcl);
	bool ACL2Wbem(PACL pAcl, VARIANT *w32ACL);

	DWORD Wbem2Sid(CWbemClassObject &w32Trust, PSID ppSid);
	void Sid2Wbem(PSID pSid, CWbemClassObject &w32Trust);
	DWORD WbemSidSize(CWbemClassObject &w32Trust);

	DWORD SetSecDescCtrl(PSECURITY_DESCRIPTOR psd,
						 SECURITY_DESCRIPTOR_CONTROL wControlMask,
						 SECURITY_DESCRIPTOR_CONTROL wControlBits);

};	// end class FakeSecuritySetting

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\fakesecuritysetting.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
//	FakeSecSetting.cpp
//
/////////////////////////////////////////////////
#include "precomp.h"
#include "FakeSecuritySetting.h"

//--------------------------------------------------------------------------
FakeSecuritySetting::FakeSecuritySetting()
{
}

//--------------------------------------------------------------------------
FakeSecuritySetting::~FakeSecuritySetting()
{
}

//--------------------------------------------------------------------------
HRESULT FakeSecuritySetting::Wbem2SD(SECURITY_INFORMATION si,
									  CWbemClassObject &w32sd, 
										CWbemServices &service,
										SECURITY_DESCRIPTOR **ppSD)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	// converts the security descriptor from the file into a 
	// Win32_Security object.
	if(si)
	{
		m_service = service;
		SECURITY_DESCRIPTOR absSD;
		bool present;

        BOOL x = InitializeSecurityDescriptor(&absSD, SECURITY_DESCRIPTOR_REVISION);
		DWORD e = GetLastError();

		// strict copy for ControlFlags.
		if(si & OWNER_SECURITY_INFORMATION)
		{
			CWbemClassObject pTrusteeOwner;
			PSID sidOwner = NULL;
			pTrusteeOwner = w32sd.GetEmbeddedObject("Owner");
			if(pTrusteeOwner)
			{
				DWORD sidLen = Wbem2Sid(pTrusteeOwner, sidOwner);
				if(sidLen != 0)
				{
					sidOwner = LocalAlloc(LPTR, sidLen);
					if(sidOwner)
					{
						Wbem2Sid(pTrusteeOwner, sidOwner);
						SetSecurityDescriptorOwner(&absSD, sidOwner, FALSE);
					}
				}
			}
		}

		if(si & GROUP_SECURITY_INFORMATION)
		{
			CWbemClassObject pTrusteeGroup;
			PSID sidGroup = NULL;
			pTrusteeGroup = w32sd.GetEmbeddedObject("Group");
			if(pTrusteeGroup)
			{
				DWORD sidLen = Wbem2Sid(pTrusteeGroup, sidGroup);
				if(sidLen != 0)
				{
					sidGroup = LocalAlloc(LPTR, sidLen);
					if(sidGroup)
					{
						Wbem2Sid(pTrusteeGroup, sidGroup);
						SetSecurityDescriptorGroup(&absSD, sidGroup, FALSE);
					}
				}
			}
			else
			{
				CWbemClassObject pTrusteeOwner;
				PSID sidOwner = NULL;
				pTrusteeOwner = w32sd.GetEmbeddedObject("Owner");
				if(pTrusteeOwner)
				{
					DWORD sidLen = Wbem2Sid(pTrusteeOwner, sidOwner);
					if(sidLen != 0)
					{
						sidOwner = LocalAlloc(LPTR, sidLen);
						if(sidOwner)
						{
							Wbem2Sid(pTrusteeOwner, sidOwner);
							SetSecurityDescriptorGroup(&absSD, sidOwner, FALSE);
						}
					}
				}
			}
		}

		if(si & DACL_SECURITY_INFORMATION)
		{
			variant_t pDacl;
			PACL dacl = 0;
			w32sd.Get("DACL", pDacl);
			//if(pDacl.vt != VT_NULL)
			{
				present = Wbem2ACL(pDacl, &dacl);
				SetSecurityDescriptorDacl(&absSD, present, dacl, false);
			}
		}

		if(si & SACL_SECURITY_INFORMATION)
		{
			variant_t pSacl;
			PACL sacl = 0;
			w32sd.Get("SACL", pSacl);
//			if(pSacl.vt != VT_NULL)
			{
				present = Wbem2ACL(pSacl, &sacl);
				SetSecurityDescriptorSacl(&absSD, present, sacl, false);
			}
		}

		variant_t ControlFlags;
		w32sd.Get("ControlFlags", ControlFlags);

		SECURITY_DESCRIPTOR_CONTROL control = (SECURITY_DESCRIPTOR_CONTROL)V_I4(&ControlFlags);
		// provider sets flag like its self-relative when it actually doesnt apply; but it
		// messes up this code. So clear it.
		control &= ~SE_SELF_RELATIVE;
		SetSecDescCtrl(&absSD, 0xFFFF, control);

		DWORD srLen = 0;
		SetLastError(0);
		// get the size needed.
		BOOL x1 = MakeSelfRelativeSD(&absSD, NULL, &srLen);

		DWORD eee = GetLastError();

		*ppSD = (SECURITY_DESCRIPTOR *)LocalAlloc(LPTR, srLen);
		
        if(ppSD)
		{
			BOOL converted = MakeSelfRelativeSD(&absSD, *ppSD, &srLen);
			hr = S_OK;
		}
        else
		{
            hr = E_OUTOFMEMORY;
			return hr;
		}
	} //endif (si)

	return hr;
}

//---------------------------------------------------------------------------
// NT4 SP4 doesn't support SetSecurityDescriptorControl, so
// emulate it here
//
DWORD FakeSecuritySetting::SetSecDescCtrl(PSECURITY_DESCRIPTOR psd,
										 SECURITY_DESCRIPTOR_CONTROL wControlMask,
										 SECURITY_DESCRIPTOR_CONTROL wControlBits)
{
    DWORD dwErr = NOERROR;
    PISECURITY_DESCRIPTOR pSD = (PISECURITY_DESCRIPTOR)psd;

    if(pSD)
        pSD->Control = (pSD->Control & ~wControlMask) | wControlBits;
    else
        dwErr = ERROR_INVALID_PARAMETER;

    return dwErr;
}

//--------------------------------------------------------------------------
HRESULT FakeSecuritySetting::SD2Wbem(SECURITY_INFORMATION si,
								  SECURITY_DESCRIPTOR *pSD,
								  CWbemServices &service,
								  CWbemClassObject &w32sd)
{
	HRESULT hr = WBEM_S_NO_ERROR;
	// converts the security descriptor from the file into a 
	// Win32_Security object.
	if(si && w32sd.IsNull() && pSD)
	{
		m_service = service;
		w32sd = m_service.CreateInstance("Win32_SecurityDescriptor");
		SECURITY_DESCRIPTOR_CONTROL ControlFlags = 0;
		BOOL present = FALSE, defaulted = FALSE;
		BOOL lpBool = FALSE;

		if(si & OWNER_SECURITY_INFORMATION)
		{
			CWbemClassObject pTrusteeOwner;
			PSID sidOwner = NULL;
			GetSecurityDescriptorOwner(pSD, &sidOwner, &lpBool);
			Sid2Wbem(sidOwner, pTrusteeOwner);
			hr = w32sd.PutEmbeddedObject("Owner", pTrusteeOwner);
		}

		if(SUCCEEDED(hr) && (si & GROUP_SECURITY_INFORMATION))
		{
			CWbemClassObject pTrusteeGroup;
			PSID sidGroup = NULL;
			GetSecurityDescriptorGroup(pSD, &sidGroup, &lpBool);
			Sid2Wbem(sidGroup, pTrusteeGroup);
			hr = w32sd.PutEmbeddedObject("Group", pTrusteeGroup);
		}

		if(SUCCEEDED(hr) && (si & DACL_SECURITY_INFORMATION))
		{
			PACL dacl = 0;
			GetSecurityDescriptorDacl(pSD, &present, &dacl, &defaulted);
			if(present)
			{
				VARIANT pDacl;
				ACL2Wbem(dacl, &pDacl);
				hr = w32sd.Put("DACL", pDacl);
			}
		}

		if(SUCCEEDED(hr) && (si & SACL_SECURITY_INFORMATION))
		{
			PACL sacl = 0;
			GetSecurityDescriptorSacl(pSD, &present, &sacl, &defaulted);
			if(present)
			{
				VARIANT pSacl;
				ACL2Wbem(sacl, &pSacl);
				hr = w32sd.Put("SACL", pSacl);
			}
		}

		if(SUCCEEDED(hr))
		{
			// strict copy for ControlFlags.
			DWORD revision = 0;
			GetSecurityDescriptorControl(pSD, &ControlFlags, &revision);
			ControlFlags |= SE_SELF_RELATIVE;

			hr = w32sd.Put("ControlFlags", (long)ControlFlags);
		}
	}
	return hr;
}

//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
bool FakeSecuritySetting::Wbem2ACL(_variant_t &w32ACL, PACL *pAcl)
{
	SAFEARRAY* pDACL = V_ARRAY(&w32ACL);
	IWbemClassObject *pACEObject;
	CWbemClassObject pTrustee;

	DWORD aclSize = sizeof(ACL);

	// walk DACL 
	LONG lDimension = 1; 
	LONG lLowerBound;
	LONG lUpperBound;
	LONG lIndex = 0;

	if(w32ACL.vt != VT_NULL)
	{
		SafeArrayGetLBound(pDACL, lDimension, &lLowerBound);
		SafeArrayGetUBound(pDACL, lDimension, &lUpperBound);

		for(lIndex = lLowerBound; lIndex <= lUpperBound; lIndex++)
		{
			SafeArrayGetElement(pDACL, &lIndex, &pACEObject);

			CWbemClassObject ACEInstance = pACEObject;

			pTrustee = ACEInstance.GetEmbeddedObject("Trustee");

			if(pTrustee)
			{
				//aclSize += pTrustee.GetLong("SidLength");
				aclSize += WbemSidSize(pTrustee);
			}
			aclSize += sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD);
		}
	}

	*pAcl = (PACL)LocalAlloc(LPTR, aclSize);

	if(*pAcl)
	{
		InitializeAcl(*pAcl, aclSize, ACL_REVISION);
	}
	else
	{
		return false;
	}
	
	if(w32ACL.vt != VT_NULL)
	{
		for(lIndex = lLowerBound; lIndex <= lUpperBound; lIndex++)
		{
			SafeArrayGetElement(pDACL, &lIndex, &pACEObject);

			CWbemClassObject ACEInstance = pACEObject;
			ACCESS_ALLOWED_ACE *ace = NULL;  // NOTE: all 3 we deal with are the same.
			DWORD dwSidLength = 0;
			
			// get Win32_Trustee object from Win32_ACE
			pTrustee = ACEInstance.GetEmbeddedObject("Trustee");

			// process the goofy SID
			if(pTrustee)
			{
				dwSidLength = WbemSidSize(pTrustee);
				//dwSidLength = pTrustee.GetLong("SidLength");
				WORD wAceSize = sizeof( ACCESS_DENIED_ACE ) + dwSidLength - sizeof(DWORD);

				// Allocate the appropriate Ace and fill out its values.
				ACCESS_DENIED_ACE* ace = (ACCESS_DENIED_ACE*) LocalAlloc(LPTR, wAceSize );

				if(NULL != ace)
				{
					Wbem2Sid(pTrustee, &(ace->SidStart));
					ace->Header.AceType = (BYTE)ACEInstance.GetLong("AceType");
					ace->Header.AceFlags = (BYTE)ACEInstance.GetLong("AceFlags");
					ace->Mask = ACEInstance.GetLong("AccessMask");
					ace->Header.AceSize = wAceSize;
					BOOL x = AddAce(*pAcl, ACL_REVISION, lIndex, ace, ace->Header.AceSize);
				}
			}
			DWORD err = GetLastError();
		}
	}
	return true;
}

//--------------------------------------------------------------------------
bool FakeSecuritySetting::ACL2Wbem(PACL pAcl, VARIANT *w32ACL)
{
	ACCESS_ALLOWED_ACE *ace;
	CWbemClassObject pAce;
	CWbemClassObject pTrustee;

	ACL_SIZE_INFORMATION aclSize;
	bool retval = false;

	VariantInit(w32ACL);

	if(GetAclInformation(pAcl, &aclSize, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
	{
		// create an empty array.
		long ix[1];
		ix[0] = 0;
		SAFEARRAY* saDACL;
		SAFEARRAYBOUND rgsabound[1];
		rgsabound->cElements = aclSize.AceCount;
		rgsabound->lLbound = 0;
		saDACL = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);

		// load the safearray
		for(DWORD pos = 0; 
				(pos < aclSize.AceCount) && GetAce(pAcl, pos, (LPVOID *)&ace); 
					pos++)
		{
			// now that we have the ACE, let's create a Win32_ACE object so we can
			// add it to the embedded object list.
			if(pAce = m_service.CreateInstance("Win32_Ace"))
			{
				// fill trustee from SID
				Sid2Wbem((PSID)&ace->SidStart, pTrustee);
				pAce.PutEmbeddedObject("Trustee", pTrustee);

				pAce.Put("AceType", (long)ace->Header.AceType);
				pAce.Put("AceFlags", (long)ace->Header.AceFlags);
				pAce.Put("AccessMask", (long)ace->Mask);
			
				IWbemClassObject *temp = pAce;
				
				SafeArrayPutElement(saDACL, ix, temp);

			}	// end if
			ix[0]++;
			retval = true;
		}	// endfor

		// return the safearray in a array variant.
		V_VT(w32ACL) = VT_UNKNOWN|VT_ARRAY;
		V_ARRAY(w32ACL) = saDACL;

	} //endif GetAclInformation
	return retval;
}

//--------------------------------------------------------------------------
DWORD FakeSecuritySetting::Wbem2Sid(CWbemClassObject &w32Trust, PSID ppSid)
{
	// get SID information out of the Trustee
	void* pVoid;
	variant_t vValue;
  	SAFEARRAY* sa;
	long sidLen = 0, sidLen2 = 0;

	HRESULT hr = w32Trust.Get("Sid",vValue);

	if(SUCCEEDED(hr))
	{
		sa = V_ARRAY(&vValue);

		long lLowerBound = 0, lUpperBound = 0 ;

		SafeArrayGetLBound(sa, 1, &lLowerBound);
		SafeArrayGetUBound(sa, 1, &lUpperBound);

		sidLen = w32Trust.GetLong("SidLength");
		sidLen2 = lUpperBound - lLowerBound + 1;

		// make sure the calculations match.
	//	ATLASSERT(sidLen == sidLen2);

		if(ppSid)
		{
  			 // Get a pointer to read the data into
 			SafeArrayAccessData(sa, &pVoid);
			memcpy(ppSid, pVoid, sidLen2);
  			SafeArrayUnaccessData(sa);
		}
	}
	return sidLen2;
}

//--------------------------------------------------------------------------
DWORD FakeSecuritySetting::WbemSidSize(CWbemClassObject &w32Trust)
{
	// get SID information out of the Trustee
	variant_t vValue;
  	SAFEARRAY* sa;

	w32Trust.Get("Sid",vValue);

	sa = V_ARRAY(&vValue);

	long lLowerBound, lUpperBound = 0 ;

	SafeArrayGetLBound(sa, 1, &lLowerBound);
	SafeArrayGetUBound(sa, 1, &lUpperBound);

	return lUpperBound - lLowerBound + 1;
}

//--------------------------------------------------------------------------
void FakeSecuritySetting::Sid2Wbem(PSID pSid, CWbemClassObject &w32Trust)
{
	variant_t vValue;

	void *pSIDTrustee = 0;

	if(IsValidSid(pSid))
	{
		w32Trust = m_service.CreateInstance("Win32_Trustee");

		// set the UINT8 array for the pSid
		DWORD dwSidLength = GetLengthSid(pSid);
		SAFEARRAY* sa;
		SAFEARRAYBOUND rgsabound[1];
		PSID pSidTrustee = NULL;

		rgsabound[0].cElements = dwSidLength;
		rgsabound[0].lLbound = 0;
		sa = SafeArrayCreate(VT_UI1, 1, rgsabound);

 		 // Get a pointer to read the data into
      	SafeArrayAccessData(sa, &pSidTrustee);
      	memcpy(pSidTrustee, pSid, rgsabound[0].cElements);
      	SafeArrayUnaccessData(sa);

		// Put the safearray into a variant, and send it off
		V_VT(&vValue) = VT_UI1 | VT_ARRAY; 
		V_ARRAY(&vValue) = sa;
		w32Trust.Put("Sid", vValue);
		//w32Trust.Put("SidLength", (long)dwSidLength);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\help.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
// This file contains help context id's in the master windows.h file.

// Id's over 61440 are reserved and will ALWAYS use windows.hlp when
// used for context-sensitive help.

// Id's from 1-999 are reserved for Object help

// REVIEW: has to be 28440 until new help compiler is available

#define NO_HELP                         ((DWORD) -1) // Disables Help for a control

#define IDH_BACK 	0x3023
#define IDH_NEXT 	0x3024
#define IDH_FINISH 	0x3025

#define IDH_NO_HELP                     28440
#define IDH_MISSING_CONTEXT             28441 // Control doesn't have matching help context
#define IDH_GENERIC_HELP_BUTTON         28442 // Property sheet help button
#define IDH_OK                          28443
#define IDH_CANCEL                      28444
#define IDH_HELP                        28445
#define IDH_COMM_APPLYNOW               28447
#define IDH_FONT_STYLE                  28448
#define IDH_FONT_SIZE                   28449
#define IDH_FONT_SAMPLE                 28450
#define IDH_FONT_EFFECTS                28451
#define IDH_FONT_FONT                   28452
#define IDH_PRINT_SETUP_AVAIL           28453
#define IDH_PRINT_SETUP_OPTIONS         28454
#define IDH_PRINT_SETUP_DETAILS         28455
#define IDH_OPEN_LOCATION               28456
#define IDH_OPEN_FILES                  28457
#define IDH_OPEN_READONLY               28459
#define IDH_OPEN_FILETYPE               28460
#define IDH_OPEN_PATH                   28461
#define IDH_OPEN_FILENAME               28462
#define IDH_FIND_SEARCHTEXT             28463
#define IDH_FIND_NEXT_BUTTON            28464
#define IDH_FIND_WHOLE                  28467
#define IDH_FIND_CASE                   28468
#define IDH_REPLACE_REPLACE             28469
#define IDH_REPLACE_REPLACE_ALL         28470
#define IDH_REPLACE_REPLACEWITH         28471
#define IDH_PRINT_PRINTER               28472
#define IDH_PRINT_PRINTER_SETUP         28473
#define IDH_PRINT_COPIES                28474
#define IDH_PRINT_COLLATE               28475
#define IDH_PRINT_TO_FILE               28476
#define IDH_PRINT_QUALITY               28477
#define IDH_PRINT_RANGE                 28478
#define IDH_PAGE_SAMPLE                 28485
#define IDH_PAGE_ORIENTATION            28486
#define IDH_PAGE_PAPER_SIZE             28487
#define IDH_PAGE_PAPER_SOURCE           28488
#define IDH_PAGE_MARGINS                28489
#define IDH_OPEN_DRIVES                 28490
#define IDH_COMM_DRIVE                  28491
#define IDH_COMM_PASSWDBUTT             28492
#define IDH_COMM_OLDPASSWD              28493
#define IDH_BROWSE                      28496
#define IDH_COLOR_CUSTOM                28497
#define IDH_COLOR_SAMPLE_COLOR          28498
#define IDH_COLOR_HUE                   28500
#define IDH_COLOR_SAT                   28501
#define IDH_COLOR_RED                   28502
#define IDH_COLOR_GREEN                 28503
#define IDH_COLOR_BLUE                  28504
#define IDH_COLOR_LUM                   28505
#define IDH_COLOR_ADD                   28506
#define IDH_COLOR_COLOR_SOLID           28507
#define IDH_COLOR_DEFINE                28508
#define IDH_QUICKINFO                   28509
#define IDH_NO_CROSSREF                 28510
#define IDH_CHARMAP_INSERT              28511
#define IDH_COMM_USER_NAME              28512
#define IDH_COMM_USER_SERVERNAME        28513
#define IDH_COMM_USER_SELECT_FROM       28514
#define IDH_COMM_USER_SELECTED          28515
#define IDH_PRINT32_RANGE               28516
#define IDH_PRINT_PROPERTIES            28517
#define IDH_PRINT_FILENAME              28518
#define IDH_PRINT_CHOOSE_PRINTER        28519
#define IDH_FIND_DIRECTION              28520
#define IDH_FONT_COLOR                  28521
#define IDH_PRINT_SETUP_PAPER           28522
#define IDH_PRINT_SETUP_ORIENT          28523
#define IDH_OPEN_BUTTON                 28529
#define IDH_SAVE_BUTTON                 28531
#define IDH_COLOR_BASIC                 28532
#define IDH_COLOR_CUSTOM_CUSTOM         28533
#define IDH_COLOR_SAMPLE_SCROLL         28534
#define IDH_FONT_SCRIPT                 28535
#define IDH_KERNEL_TASK_LIST            28536
#define IDH_KERNEL_END_TASK             28537
#define IDH_KERNEL_SHUTDOWN             28538
#define IDH_QVIEW_DISPLAY               28539
#define IDH_CHARMAP_COPY                28540
#define IDH_CHARMAP_FONT                28541
#define IDH_CHARMAP_CHARACTERS          28542
#define IDH_CHARMAP_SELECTED_CHARS      28543
#define IDH_CHARMAP_SELECT_BUTTON       28544
#define IDH_CHARMAP_HELP_BUTTON         28545
#define IDH_BOLD                        28546
#define IDH_ITALIC                      28547
#define IDH_COMM_GROUPBOX               28548
#define IDH_OPEN_FILES32                28549
#define IDH_SAVE_FILETYPE               28550
#define IDH_SYSTEM_CFG_OLDNAME          28551
#define IDH_DIAL_WHAT_WRONG             28552
#define IDH_COMCTL_RESET                28553
#define IDH_COMCTL_MOVEUP               28554
#define IDH_COMCTL_MOVEDOWN             28555
#define IDH_COMCTL_BUTTON_LIST          28556
#define IDH_COMCTL_ADD                  28557
#define IDH_COMCTL_REMOVE               28558
#define IDH_COMCTL_AVAIL_BUTTONS        28559
#define IDH_COMCTL_CLOSE                28560
#define IDH_PAGE_PRINTER                28561
#define IDH_DCC_WHAT_WRONG              28562
#define IDH_FILEVIEWER_PREVIEW          28563
#define IDH_PRINT_NETWORK               28564
#define IDH_PRINT_SETUP_DUPLEX          28565

#define IDH_OLEPROP_SUMMARY             28569
#define IDH_OLEPROP_STATISTICS          28570
#define IDH_CONFIGURE_LPT_PORT          28571
#define IDH_ADD_LOCAL_PORT              28572
#define IDH_PRINT_PORT_NAME             28573
#define IDH_PRINT_OUTPUT_FILE           28574
#define IDH_DISKCOPY_START              28575
#define IDH_DISKCOPY_FROM               28576
#define IDH_DISKCOPY_TO                 28577

#define IDH_PRINT_FIND_PRINTER          29010
#define IDH_PRINT_PRINTER_FOLDER        29015

#define IDH_OPEN_SHORTCUT_BAR           29500
#define IDH_OPEN_BACK_BUTTON            29501
#define IDH_PRINT_BTN                   29510

// ID value for Win 3.1 user transition piece: jump from First experience screen
#define WIN31_TRANSITION_PIECE          30000

// ID values 2100-2199 are reserved for Disk Compression.
// See dos\dos86\dblspace\utility\comphelp.h

// ID values 2200-2299 are reserved for Find File. See findhlp.h.

// ID values 2400-2499 are reserved for MultiMedia control panel. See medhelp.h

// ID values 2500-2699 are reserved for Print Trouble Shooter

// ID values 2700-2799 are reserved for Network control panel. See nethelp.h

// ID values 2800-2899 are reserved for Online Registration.

// ID values 2900-2999 are reserved for Clipbook and Chat.

#define IDH_COMM_NEWPASSWD              3018    // See pwdids.h
#define IDH_COMM_NEWPASSCONF            3019    // See pwdids.h

// Briefcase ids

#define IDH_BFC_UPDATE_SCREEN           3100
#define IDH_BFC_UPDATE_BUTTON           3101
#define IDH_BFC_PROP_FILEICON           3102
#define IDH_BFC_PROP_SPLIT_BUTTON       3103
#define IDH_BFC_PROP_FINDORIG_BUTTON    3104
#define IDH_BFC_FILTER_TYPE             3105
#define IDH_BFC_FILTER_INCLUDE          3106

// ID values 3300-3499 are reserved for international. See intlhlp.h

// ID values for the Keyboard property sheet

#define IDH_DLGKEY_REPDEL               4000
#define IDH_DLGKEY_REPSPEED             4001
#define IDH_DLGKEY_REPTEST              4002
#define IDH_DLGKEY_TYPE                 4008
#define IDH_DLGKEY_CHANGE               4010
#define IDH_DLGKEY_CURSBLNK             4011
#define IDH_DLGKEY_CURSOR_GRAPHIC       4012

#define IDH_KEYB_INPUT_LIST             4028
#define IDH_KEYB_INPUT_ADD              4029
#define IDH_KEYB_INPUT_PROP             4030
#define IDH_KEYB_INPUT_DEL              4031
#define IDH_KEYB_INPUT_DEFAULT          4032
#define IDH_KEYB_CAPSLOCK_LAYOUT        4033
#define IDH_KEYB_INPUT_LANG             4034
#define IDH_KEYB_INPUT_INDICATOR        4035
#define IDH_KEYB_INPUT_ONSCRN_KEYB      4036
#define IDH_KEYB_INPUT_PROP_LANG        4039
#define IDH_KEYB_INPUT_PROP_KEYLAY      4042
#define IDH_KEYB_INPUT_DEF_LANG         4043
#define IDH_KEYB_INPUT_SHORTCUT         4044
#define IDH_KEYB_INDICATOR_ON_TASKBAR   4045
#define IDH_KEYB_IME_SETTINGS           4046
#define IDH_KEYB_HOTKEY_LIST            4047
#define IDH_KEYB_CHANGE_HOTKEY          4048
#define IDH_KEYB_CHANGE_KEY             4049

// ID values for Desktop Property sheet

// Settings Page
#define IDH_SETTINGS_DISPLAYDESK		4064	//Monitor icon display area
#define IDH_SETTINGS_DISPLAYLIST		4065	//Monitor dropdown
#define IDH_SETTINGS_COLORBOX		    4066	//Colors dropdown	
#define IDH_SETTINGS_SCREENSIZE		    4067	//Screen Area dropdown		
#define IDH_SETTINGS_DISPLAYUSEME	    4068	//Use this monitor chkbx
#define IDH_SETTINGS_DISPLAYPROPERTIES	4069	//Advanced button

// General Page
#define IDH_GENERAL_FONTSIZEGRP	        4080	//Font size dropdown
#define IDH_GENERAL_DYNA			    4081	//Compatibility option group
#define IDH_GENERAL_NODYNA	            4082	//Restart the computer option
#define IDH_GENERAL_YESDYNA             4083	//Apply the changes option	
#define IDH_GENERAL_SHUTUP              4084	//Always prompt before option

// Background Page

#define IDH_DSKTPBACKGROUND_MONITOR     4100
#define IDH_DSKTPBACKGROUND_PATTLIST    4102
#define IDH_DSKTPBACKGROUND_WALLLIST    4104
#define IDH_DSKTPBACKGROUND_BROWSE      4105
#define IDH_DSKTPBACKGROUND_TILE        4106
#define IDH_DSKTPBACKGROUND_CENTER      4107
#define IDH_DSKTPBACKGROUND_DISPLAY     4108
#define IDH_DSKTPBACKGROUND_EDITPAT     4109

// Screen Saver Page

#define IDH_DSKTPSCRSAVER_LISTBX        4111
#define IDH_DSKTPSCRSAVER_WAIT          4112
#define IDH_DSKTPSCRSAVER_TEST          4113
#define IDH_DSKTPSCRSAVER_SETTINGS      4114
#define IDH_DSKTPSCRSAVER_MONITOR       4115
#define IDH_SCRSAVER_GRAPHIC            4116
#define IDH_SCRSAVER_LOWPOWSTANDBY      4117
#define IDH_SCRSAVER_SHUTOFFPOW         4118

// Appearance Page

#define IDH_APPEAR_SCHEME               4120
#define IDH_APPEAR_SAVEAS               4121
#define IDH_APPEAR_DELETE               4122
#define IDH_APPEAR_GRAPHIC              4123
#define IDH_APPEAR_ITEMSIZE             4124
#define IDH_APPEAR_FONTBOLD             4125
#define IDH_APPEAR_FONTSIZE             4126
#define IDH_APPEAR_FONTCOLOR            4127
#define IDH_APPEAR_FONTITALIC           4128
#define IDH_APPEAR_BACKGRNDCOLOR        4129
#define IDH_APPEAR_ITEM                 4130
#define IDH_APPEAR_FONT                 4131

// Monitor Settings Page




#define IDH_DSKTPMONITOR_CHANGE_DISPLAY 4134
#define IDH_DSKTPMONITOR_COLOR          4135
#define IDH_DSKTPMONITOR_AREA           4136
#define IDH_DSKTPMONITOR_REFRESH        4137
#define IDH_DSKTPMONITOR_LIST_MODES     4138
#define IDH_DSKTPMONITOR_ENERGY         4139
#define IDH_DSKTPMONITOR_MONITOR        4140
#define IDH_DSKTPMONITOR_TEST           4141
#define IDH_DSKTPMONITOR_ADTYPE         4143
#define IDH_DSKTPMONITOR_CHANGE1        4144
#define IDH_DSKTPMONITOR_CHANGE2        4145
#define IDH_DSKTPMONITOR_MONTYPE        4146
#define IDH_DSKTPMONITOR_CUSTOM         4148
#define IDH_DSKTPMONITOR_FONTSIZE       4149
#define IDH_DSKTPMONITOR_AD_FACTS       4150
#define IDH_DSKTPMONITOR_DRIVER         4151
#define IDH_DSKTPMONITOR_DETECT         4152


#define IDH_SAVESCHEME_EDITFIELD        4170
#define IDH_CUSTOMFONTS_FONTSCALE       4171
#define IDH_CUSTOMFONTS_RULER           4172
#define IDH_CUSTOMFONTS_SAMPLE          4173

#define IDH_PATTERN_EDIT_NAME           4174
#define IDH_PATTERN_EDIT_SAMPLE         4175
#define IDH_PATTERN_EDIT_PIXEL_SCREEN   4176
#define IDH_PATTERN_EDIT_EXIT           4177
#define IDH_PATTERN_EDIT_ADD            4178
#define IDH_PATTERN_EDIT_CHANGE         4179
#define IDH_PATTERN_EDIT_REMOVE         4180

// ID values for Defrag

#define IDH_DEFRAG_START                        4200
#define IDH_DEFRAG_STOP                         4201
#define IDH_DEFRAG_PAUSE                        4202
#define IDH_DEFRAG_SHOWDETAILS                  4203
#define IDH_DEFRAG_HIDEDETAILS                  4204
#define IDH_DEFRAG_LEGEND                       4205
#define IDH_DEFRAG_SPARKLESCRN                  4206
#define IDH_DEFRAG_DEFRAGNOW_ANYWY              4207
#define IDH_DEFRAG_SELECTDRIVE                  4208
#define IDH_DEFRAG_ADVANCED                     4209
#define IDH_DEFRAG_EXIT                         4210
#define IDH_DEFRAG_DRIVELIST                    4211
#define IDH_DEFRAG_RESUME                       4212
#define IDH_DEFRAG_FULL                         4213
#define IDH_DEFRAG_FILESONLY                    4214
#define IDH_DEFRAG_FRSPCONLY                    4215
#define IDH_DEFRAG_USEONCE                      4218
#define IDH_DEFRAG_USEALWAYS                    4219
#define IDH_DEFRAG_GASGAUGE                     4220
#define IDH_DEFRAG_CHECK_DRIVE_FOR_ERRORS       4221

// RNA id values

#define IDH_RNA_CONNECT_NAME            4250
#define IDH_RNA_CONNECT_USER            4251
#define IDH_RNA_CONNECT_PASSWORD        4252
#define IDH_RNA_CONNECT_SAVEPW          4253
#define IDH_RNA_CONNECT_FROM            4254
#define IDH_RNA_OUT_PHONE_NUMBER        4255
#define IDH_RNA_OUT_DIALASST            4256
#define IDH_RNA_OUT_COMPLETE_PHONE      4257
#define IDH_RNA_OUT_CONNECT_BUTTON      4258
#define IDH_RNA_CHOOSE_MODEM            4273
#define IDH_RNA_CONFIG_MODEM            4274
#define IDH_RNA_MODEM_SERVER            4275
#define IDH_RNA_SERVERS                 4276
#define IDH_RNA_CONNECTION_LIST         4277
#define IDH_RNA_SERVER_COMPRESS         4278
#define IDH_RNA_SERVER_ENCRYPT          4279
#define IDH_RNA_SERVER_NETLOGON         4280
#define IDH_RNA_SERVER_PROTOCOL         4281
#define IDH_RNA_SERVER_TCPIPSET         4282
#define IDH_RNA_TCPIP_ASSIGNED_IP       4283
#define IDH_RNA_TCPIP_SPECIFY_IP        4284
#define IDH_RNA_TCPIP_ASSIGNED_DNS      4285
#define IDH_RNA_TCPIP_SPECIFY_DNS       4286
#define IDH_RNA_TCPIP_COMPRESS          4287
#define IDH_RNA_TCPIP_GATEWAY           4288
#define IDH_RNA_SETTINGS_REDIAL         4290
#define IDH_RNA_SETTINGS_TIMES          4291
#define IDH_RNA_SETTINGS_MINSEC         4292
#define IDH_RNA_SETTINGS_PROMPT         4293

// ID values for printing property sheets

#define IDH_PRTPROPS_TYPE_LOCATION              4501
#define IDH_PRTPROPS_COMMENT                    4502
#define IDH_PRTPROPS_NAME_STATIC                4505
#define IDH_PRTPROPS_PORT                       4506
#define IDH_PRTPROPS_DRIVER                     4507
#define IDH_PRTPROPS_NEW_PORT                   4508
#define IDH_PRTPROPS_NEW_DRIVER                 4509
#define IDH_PRTPROPS_SEPARATOR                  4510
#define IDH_PRTPROPS_ICON                       4512
#define IDH_PRTPROPS_SPOOL_SETTINGS             4513
#define IDH_PRTPROPS_PORT_SETTINGS              4514
#define IDH_PRTPROPS_SETUP                      4515
#define IDH_PRTPROPS_SEPARATOR_BROWSE           4516
#define IDH_PRTPROPS_TIMEOUT_NOTSELECTED        4517
#define IDH_PRTPROPS_TIMEOUT_TRANSRETRY         4518
#define IDH_PRTPROPS_TEST_PAGE                  4519
#define IDH_SPOOLSETTINGS_SPOOL                 4520
#define IDH_SPOOLSETTINGS_NOSPOOL               4521
#define IDH_SPOOLSETTINGS_PRINT_FASTER          4522
#define IDH_SPOOLSETTINGS_LESS_SPACE            4523
#define IDH_SPOOLSETTINGS_DATA_FORMAT           4524
#define IDH_SPOOLSETTINGS_RESTORE               4525
#define IDH_PRTPROPS_DEL_PORT                   4528
#define IDH_ADDPORT_NETWORK                     4529
#define IDH_ADDPORT_PORTMON                     4530
#define IDH_ADDPORT_NETPATH                     4531
#define IDH_ADDPORT_BROWSE                      4532
#define IDH_ADDPORT_LB                          4533
#define IDH_DELPORT_LB                          4534
#define IDH_PRTPROPS_MAP_PRN_PORT               4535
#define IDH_PRTPROPS_UNMAP_PRN_PORT             4536
#define IDH_SPOOLSETTINGS_ENABLE_BIDI           4537
#define IDH_SPOOLSETTINGS_DISABLE_BIDI          4538

// ID values for System property sheets

#define IDH_SYSTEM_SYSTEM               4600
#define IDH_SYSTEM_RESOURCES            4602
#define IDH_SYSTEM_OWNER                4603
#define IDH_SYSTEM_PRO_COPY             4624
#define IDH_SYSTEM_PRO_RENAME           4625
#define IDH_SYSTEM_PRO_DELETE           4626
#define IDH_SYSTEM_PRO_LIST             4627
#define IDH_SYSTEM_LOGO                 4628
#define IDH_SYSTEM_CFG_EDIT             4629
#define IDH_SYSTEM_PROCESSOR            4630
#define IDH_SYSTEM_VIEW_RESOURCETYPE    4631
#define IDH_SYSTEM_PAGING               4632
#define IDH_SYSTEM_ADVANCED             4633
#define IDH_SYSTEM_VIRTMEM_ADJUST       4634
#define IDH_SYSTEM_VIRTMEM_DISABLE      4635

#define IDH_SYSTEM_RESERVE_PICKONE      4636

#define IDH_SYSTEM_RESERVE_MODIFY       4639
#define IDH_SYSTEM_RESERVE_ADD          4640
#define IDH_SYSTEM_RESERVE_REMOVE       4641
#define IDH_SYSTEM_CLASSLIST            4642
#define IDH_SYS_PERF_GRAPHICS           4643
#define IDH_SYS_PERF_GRAPHICS_SLIDER    4644

#define IDH_SYSTEM_FILESYSTEM           4661
#define IDH_SYSTEM_DISK                 4662
#define IDH_SYSTEM_CDROM                4663
#define IDH_SYSTEM_CACHE                4664
#define IDH_SYSTEM_BALANCE              4665
#define IDH_SYSTEM_TROUBLESHOOT         4666
#define IDH_SYSTEM_FSCHANGE             4667
#define IDH_DEVMGR_REMOVEONE            4671
#define IDH_DEVMGR_REMOVEALL            4672
#define IDH_SYSTEM_VIEW_RESRES          4673
#define IDH_DEVMGR_CLASS                4674
#define IDH_DEVMGR_ENABLE_HEAD          4675
#define IDH_DEVMGR_PRINT_SELECT         4676
#define IDH_DEVMGR_PRINT_FILE           4677
#define IDH_DEVMGR_SCSI_INFO            4678
#define IDH_DEVMGR_DISKOPTIONS          4679
#define IDH_DEVMGR_DISCONNECT           4680
#define IDH_DEVMGR_SYNC                 4681
#define IDH_DEVMGR_AUTOINSERT           4682
#define IDH_DEVMGR_REMOVABLE            4683
#define IDH_DEVMGR_INT13                4684
#define IDH_DEVMGR_DRIVE_LETTER         4685
#define IDH_DEVMGR_DRIVE_RESERVED       4686
#define IDH_NHF_HELP                4687
#define IDH_NHF_WINDOWS             4688
#define IDH_NHF_DISK                4689
#define IDH_NHF_NODRIVER            4690
#define IDH_NHF_SIMILAR             4691
#define IDH_DMA_MEMORY              4692
#define IDH_DMA_ADDRESS             4693
#define IDH_DMA_DEFAULT             4694
#define IDH_SCSIPROP_SETTINGS       4695
#define IDH_PCI_ENUMTYPE            4697
#define IDH_PCI_IRQ_STEERING        4698
#define IDH_PCI_SETDEFAULTS         4699

// ID's for File properties

#define IDH_FPROP_VER_INFO                      4700
#define IDH_FPROP_GEN_COMPRESSED                4701
#define IDH_FPROP_GEN_COMPRESSED_SIZE           4702
#define IDH_FPROP_SECURITY_PERMISSIONS          4703
#define IDH_FPROP_SECURITY_AUDITING             4704
#define IDH_FPROP_SECURITY_OWNERSHIP            4705
#define IDH_FPROP_GEN_NAME                      4708
#define IDH_FPROP_GEN_TYPE                      4709
#define IDH_FPROP_GEN_SIZE                      4710
#define IDH_FPROP_GEN_LOCATION                  4711
#define IDH_FPROP_GEN_DOSNAME                   4712
#define IDH_FPROP_GEN_LASTCHANGE                4713
#define IDH_FPROP_GEN_LASTACCESS                4714
#define IDH_FPROP_GEN_READONLY                  4715
#define IDH_FPROP_GEN_ARCHIVE                   4716
#define IDH_FPROP_GEN_HIDDEN                    4717
#define IDH_FPROP_GEN_SYSTEM                    4718
#define IDH_FPROP_GEN_PATH                      4719
#define IDH_FPROP_VER_ABOUT                     4720
#define IDH_FCAB_LINK_NAME                      4721
#define IDH_FCAB_DRV_CLEANUP                    4722
#define IDH_FCAB_LINK_LOCATION                  4723
#define IDH_FCAB_LINK_LINKTO                    4724
#define IDH_FCAB_LINK_LINKTYPE                  4725
#define IDH_FCAB_LINK_SIZE                      4726
#define IDH_FCAB_LINK_WORKING                   4727
#define IDH_FCAB_LINK_HOTKEY                    4728
#define IDH_FCAB_LINK_RUN                       4729
#define IDH_FCAB_LINK_CHANGEICON                4730
#define IDH_FCAB_LINK_FIND                      4731
#define IDH_FCAB_LINK_ICONNAME                  4732
#define IDH_FCAB_LINK_CURRENT_ICON              4733
#define IDH_FCAB_DRV_ICON                       4734
#define IDH_FCAB_DRV_LABEL                      4735
#define IDH_FCAB_DRV_TYPE                       4736
#define IDH_FCAB_DRV_USEDCOLORS                 4737
#define IDH_FCAB_DRV_TOTSEP                     4738
#define IDH_FCAB_DRV_PIE                        4739
#define IDH_FCAB_DRV_LETTER                     4740
#define IDH_FCAB_DRV_FS                         4741
#define IDH_FCAB_DISKTOOLS_CHKNOW               4742
#define IDH_FCAB_DISKTOOLS_BKPNOW               4743
#define IDH_FCAB_DISKTOOLS_OPTNOW               4744
#define IDH_FCAB_DELFILEPROP_DELETED            4745
#define IDH_FCAB_DRV_COMPRESS                   4746
#define IDH_FPROP_GEN_DATE_CREATED              4747
#define IDH_FCAB_FOLDEROPTIONS_ALWAYS           4748
#define IDH_FCAB_FOLDEROPTIONS_NEVER            4749
#define IDH_FCAB_VIEWOPTIONS_SHOWALL            4750
#define IDH_FCAB_VIEWOPTIONS_HIDDENEXTS         4751
#define IDH_FCAB_VIEWOPTIONS_SHOWFULLPATH       4752
#define IDH_FCAB_VIEWOPTIONS_HIDEEXTS           4753
#define IDH_FCAB_VIEWOPTIONS_SHOWDESCBAR        4754
#define IDH_FCAB_FT_PROP_LV_FILETYPES           4755
#define IDH_FCAB_FT_PROP_NEW                    4756
#define IDH_FCAB_FT_PROP_REMOVE                 4757
#define IDH_FCAB_FT_PROP_FINDEXT                4758
#define IDH_FCAB_FT_PROP_EDIT                   4759
#define IDH_FCAB_FT_PROP_DETAILS                4760
#define IDH_FCAB_FT_CMD_ACTION                  4761
#define IDH_FCAB_FT_CMD_EXE                     4762
#define IDH_FCAB_FT_CMD_BROWSE                  4763
#define IDH_FCAB_FT_CMD_USEDDE                  4764
#define IDH_FCAB_FT_CMD_DDEMSG                  4765
#define IDH_FCAB_FT_CMD_DDEAPP                  4766
#define IDH_FCAB_FT_CMD_DDEAPPNOT               4767
#define IDH_FCAB_FT_CMD_DDETOPIC                4768
#define IDH_FCAB_FT_EDIT_DOCICON                4769
#define IDH_FCAB_FT_EDIT_CHANGEICON             4770
#define IDH_FCAB_FT_EDIT_DESC                   4771
#define IDH_FCAB_FT_EDIT_EXT                    4772
#define IDH_FCAB_FT_EDIT_LV_CMDS                4773
#define IDH_FCAB_FT_EDIT_DEFAULT                4774
#define IDH_FCAB_FT_EDIT_NEW                    4775
#define IDH_FCAB_FT_EDIT_EDIT                   4776
#define IDH_FCAB_FT_EDIT_REMOVE                 4777
#define IDH_FCAB_DELFILEPROP_COMPRESSED         4778
#define IDH_FPROP_GEN_ICON                      4779
#define IDH_MULTPROP_NAME                       4780
#define IDH_FPROP_FOLDER_CONTAINS               4781
#define IDH_FCAB_LINK_ICON                      4782
#define IDH_FCAB_DELFILEPROP_LOCATION           4783
#define IDH_FCAB_DELFILEPROP_READONLY           4784
#define IDH_FCAB_DELFILEPROP_HIDDEN             4785
#define IDH_FCAB_DELFILEPROP_ARCHIVE            4786
#define IDH_FCAB_DELFILEPROP_SYSTEM             4787
#define IDH_FCAB_OPENAS_DESCRIPTION             4788
#define IDH_FCAB_OPENAS_APPLIST                 4789
#define IDH_FCAB_OPENAS_OTHER                   4790
#define IDH_FCAB_FT_EDIT_QUICKVIEW              4791
#define IDH_GENDRV_CHKWARN                      4792
#define IDH_GENDRV_MBFREE                       4793
#define IDH_FCAB_OPENAS_MAKEASSOC               4794
#define IDH_FCAB_FT_EDIT_SHOWEXT                4795
#define IDH_FCAB_FT_PROP_CONTTYPERO             4796    // T.B.D. IExplorer merge
#define IDH_FCAB_FT_EDIT_CONTTYPE               4797    // T.B.D. IExplorer merge
#define IDH_FCAB_FT_EDIT_DEFEXT                 4798    // T.B.D. IExplorer merge
#define IDH_FCAB_VIEWOPTIONS_SHOWCOMPCOLOR      4799


// Screen saver ids

#define IDH_BEZIER_SPEED                4800
#define IDH_BEZIER_LINES                4801
#define IDH_BEZIER_CURVES               4802
#define IDH_BEZIER_DENSITY              4803
#define IDH_BEZIER_ONECOLOR             4804
#define IDH_BEZIER_CHOOSECLR            4805
#define IDH_BEZIER_MULTCOLOR            4806
#define IDH_BEZIER_CLRSCRN              4807
#define IDH_FLYINGWIN_WARP              4808
#define IDH_FLYINGWIN_DENSTY            4809
#define IDH_COMM_PASSWDCHKBOX           4810
#define IDH_MARQUEE_CENTER              4811
#define IDH_MARQUEE_RANDOM              4812
#define IDH_MARQUEE_SPEED               4813
#define IDH_MARQUEE_COLOR               4814
#define IDH_MARQUEE_TEXT                4815
#define IDH_MARQUEE_FORMAT              4817
#define IDH_MYST_SHAPE                  4818
#define IDH_MYST_ACTVBOX                4819
#define IDH_MYST_LINES                  4820
#define IDH_MYST_TWOCOLORS              4821
#define IDH_MYST_MULTIPLE               4822
#define IDH_MYST_CLEARSCRN              4823
#define IDH_STARS_WARP                  4824
#define IDH_STARS_DENSTY                4825
#define IDH_HOP_DELAY                   4826
#define IDH_HOP_SCALE                   4827

// More ids for file properties (first range wasn't big enough)
#define IDH_FCAB_VIEWOPTIONS_WEBVIEW                    4850
#define IDH_FCAB_VIEWOPTIONS_WIN95VIEW                  4851
#define IDH_FCAB_VIEWOPTIONS_DOUBLECLICKINWEBVIEW       4852
#define IDH_FCAB_VIEWOPTIONS_SINGLECLICKINWEBVIEW       4853
#define IDH_FCAB_LINK_DESCRIPTION                       4854

// New filetype's dialog help ID's
#define IDH_FCAB_FT_NE_ADV_BUT                          4855
#define IDH_FCAB_FT_NE_FILETYPE                         4856
#define IDH_FPROP_GEN_OPENSWITH                         4857
#define IDH_FPROP_GEN_ADVANCED                          4858
#define IDH_FPROP_GEN_INDEX                             4859
#define IDH_FPROP_GEN_ENCRYPT                           4860
#define IDH_FCAB_FT_NE_FILEEXT                          4772

// id's for date-time property sheet

#define IDH_DATETIME_MONTH              4901
#define IDH_DATETIME_YEAR               4902
#define IDH_DATETIME_DATE               4903
#define IDH_DATETIME_TIME               4904
#define IDH_DATETIME_TIMEZONE           4907
#define IDH_DATETIME_BITMAP             4908
#define IDH_DATETIME_DAYLIGHT_SAVE      4909
#define IDH_DATETIME_CURRENT_TIME_ZONE  4910
#define IDH_DATETIME_DATE_GROUP         4911

// id's for Modem Setup

#define IDH_MODEM_SELECT                5000
#define IDH_MODEM_DETECT                5001
#define IDH_MODEM_PORT                  5002
#define IDH_MODEM_NAME                  5003
#define IDH_MODEM_INSTALLED             5004
#define IDH_MODEM_PROP                  5005
#define IDH_MODEM_NEW                   5006
#define IDH_MODEM_DELETE                5007

// id's for Unimodem property pages

#define IDH_UNI_GEN_MODEM               5050
#define IDH_UNI_GEN_PORT                5051
#define IDH_UNI_GEN_VOLUME              5052
#define IDH_UNI_GEN_MAX_SPEED           5053
#define IDH_UNI_GEN_THIS_SPEED          5054
#define IDH_UNI_CON_PREFS               5055
#define IDH_UNI_CON_CALL_PREFS          5056
//#define IDH_UNI_CON_TONE                5057      Deleted
#define IDH_UNI_CON_DIALTONE            5058
#define IDH_UNI_CON_CANCEL              5059
#define IDH_UNI_CON_DISCONNECT          5060
#define IDH_UNI_CON_PORT                5061
#define IDH_UNI_CON_ADVANCED            5062
#define IDH_UNI_CON_ADV_ERROR           5063
#define IDH_UNI_CON_ADV_REQUIRED        5064
#define IDH_UNI_CON_ADV_COMPRESS        5065
#define IDH_UNI_CON_ADV_CELLULAR        5066
#define IDH_UNI_CON_ADV_FLOW            5067
#define IDH_UNI_CON_ADV_MODULATION      5068
#define IDH_UNI_CON_ADV_CSITT           5069
#define IDH_UNI_CON_ADV_BELL            5070
#define IDH_UNI_CON_ADV_EXTRA           5071
#define IDH_UNI_CON_ADV_AUDIT           5072
//#define IDH_UNI_OPT_CONNECTION          5073      Deleted
#define IDH_UNI_OPT_PRE_DIAL            5074
#define IDH_UNI_OPT_POST_DIAL           5075
#define IDH_UNI_OPT_MANUAL              5076
#define IDH_UNI_OPT_STATUS              5077
#define IDH_UNI_TERMINAL                5078
#define IDH_UNI_STATUS_TALK             5079
#define IDH_UNI_STATUS_HANGUP           5080
#define IDH_UNI_GEN_PORT_INT            5081
#define IDH_UNI_OPT_WAIT                5082

#define IDH_LIGHTS                      5099

// id's for TAPI Dial Helper (5100-5199)

#define IDH_TAPI_ACCESS_LINE            5100
#define IDH_TAPI_AREA_CODE              5101
#define IDH_TAPI_CALLCARD_ADD           5102
#define IDH_TAPI_CALLCARD_ADV           5103
#define IDH_TAPI_CALLCARD_NUMBER        5104
#define IDH_TAPI_CALLCARD_REMOVE        5105
#define IDH_TAPI_CALLCARD_RULES         5106
#define IDH_TAPI_CALLCARDS              5107
#define IDH_TAPI_COPY_FROM_BUTTON       5108
#define IDH_TAPI_COPYFROM               5109
#define IDH_TAPI_COUNTRY                5110
#define IDH_TAPI_CREATE_CARD            5111
#define IDH_TAPI_CREATE_LOCATION        5112
#define IDH_TAPI_LOCATION_CALL_WAIT     5113
#define IDH_TAPI_LOCATION_CARD          5114
#define IDH_TAPI_LOCATION_CARD_CHANGE   5115
#define IDH_TAPI_LOCATION_NEW           5116
#define IDH_TAPI_LOCATION_PHONE         5117
#define IDH_TAPI_LOCATION_PULSE         5118
#define IDH_TAPI_LOCATION_REMOVE        5119
#define IDH_TAPI_LOCATIONS              5120
#define IDH_TAPI_LONG_DISTANCE          5121

// id's 5200 - 5500 are reserved for DOS

//  Add/Remove Program IDs reserved 5600-5699

// Miscellaneous ids

#define IDH_TRAY_RUN_COMMAND            6002
#define IDH_TRAY_RUN_SEPMEM             6003
#define IDH_TRAY_TASKBAR_ONTOP          6004
#define IDH_TRAY_TASKBAR_AUTOHIDE       6005
#define IDH_TRAY_SHUTDOWN_SHUTDOWN      6007
#define IDH_TRAY_SHUTDOWN_RESTART       6008
#define IDH_TRAY_SHUTDOWN_LOGOFF        6009
#define IDH_STARTMENU_SMALLICONS        6010
#define IDH_MENUCONFIG_CLEAR            6011
#define IDH_TRAY_ADD_PROGRAM            6012
#define IDH_TRAY_REMOVE_PROGRAM         6013
#define IDH_TRAY_ADVANCED               6014
#define IDH_TRAY_SHUTDOWN_HELP          6015
#define IDH_TRAY_SHOW_CLOCK             6016
#define IDH_TRAY_REMOVEDLG_LIST         6017
#define IDH_TRAY_REMOVEDLG_DEL          6018
#define IDH_TASKBAR_OPTIONS_BITMAP      6019
#define IDH_TRAY_USE_ADAPTIVE_MENUS     6020
#define IDH_TRAY_RESORT_BUTTON          6021

// ID values for Virtual Memory Property sheet

#define IDH_DEVMGR_VIEW_BY              6204
#define IDH_SYSTEM_DM_PRINT             6205
#define IDH_DEVMGR_PATH                 6206

#define IDH_DEVMGR_CONFLICT_TRB         6260
#define IDH_DEVMGR_DRIVERINFO           6261
#define IDH_DEVMGR_CHANGEDRIVER         6262
#define IDH_DEVMGR_DRIVERS              6264
#define IDH_DEVMGR_PRINTER              6265
#define IDH_DEVMGR_PRINTOVERVIEW        6266
#define IDH_DEVMGR_PRINT_SYS            6267
#define IDH_DEVMGR_PRINT_CLASS          6268
#define IDH_DEVMGR_SHOW                 6271
#define IDH_DEVMGR_HAVEDISK             6272
#define IDH_DEVMGR_CHOOSE_DEVICE        6273

//  Ids for the performance page
#define IDH_PERFLOWRES                  6301
#define IDH_PERFLOWMEM                  6302
#define IDH_4MBHELP                     6303
#define IDH_PERFCOMPATVIRTMEM           6304
#define IDH_PERFVIRTMEMOFF              6305
#define IDH_PERFPCMCIAOFF               6306
#define IDH_PERFRMCOMPRESS              6307
#define IDH_PERFNOPMODEDRIVES           6308
#define IDH_PERFMBRHOOK                 6309
#define IDH_PERFREALMODEDRIVE           6310
#define IDH_PERFNOPMODETSR              6311

#define IDH_SYS_PERF_MEMORY             6320
#define IDH_SYS_PERF_SR                 6321
#define IDH_SYS_PERF_FS                 6322
#define IDH_SYS_PERF_VMEM               6323
#define IDH_SYS_PERF_COMPRESS           6324
#define IDH_SYS_PERF_PCMCIA             6325
#define IDH_SYS_PERF_PROBLEM            6326
#define IDH_SYS_PERF_DETAILS            6327


//  sysclass.dll
#define IDH_FPU_DIAGTEXT                6350
#define IDH_FPU_SETTING                 6351
#define IDH_POWERCFG_ENABLE_PM          6352
#define IDH_POWERCFG_FORCE_APM          6353
#define IDH_POWERCFG_DISABLE_INTEL      6354
#define IDH_POWERCFG_POLLING            6355


// More ids for system cpl (ran out of #'s above)
#define IDH_SYSTEM_DMCONFIG_RETRY               6400
#define IDH_SYSTEM_DMCONFIG_IGNORE              6401

#define IDH_SYSTEM_OEMSUPPORT           6407
#define IDH_SYSTEM_DEVGEN_STATUS                6408
#define IDH_SYSTEM_DEGEN_SPECIALMF      6409
#define IDH_SYSTEM_DEVRES_SETTINGS              6410
#define IDH_SYSTEM_USESYSSETTINGS               6411
#define IDH_SYSTEM_DEVRES_CHANGE                6412
#define IDH_SYSTEM_LOGCONFIGLIST                6413
#define IDH_SYSTEM_REGRSTR_RESTORE              6417
#define IDH_SYSTEM_TREE                         6418
#define IDH_SYSTEM_PROPERTIES                   6419
#define IDH_SYSTEM_DM_REFRESH                   6420

#define IDH_SYSTEM_VIRTMEM_ON                   6421
#define IDH_SYSTEM_VIRTMEM_DEFAULT              6422
#define IDH_SYSTEM_VIRTMEM_SWAPDRIVE            6424
#define IDH_SYSTEM_VIRTMEM_MINSIZE              6427
#define IDH_SYSTEM_VIRTMEM_MAXSIZE              6428

#define IDH_SYSTEM_DEVRES_DESC                  6442
#define IDH_SYSTEM_CONFLICT_IO                  6443
#define IDH_SYSTEM_EDITRANGE_STARTVAL           6444
#define IDH_SYSTEM_CONFLICT_USED                6445
#define IDH_SYSTEM_DM_REMOVE                    6446

#define IDH_POWERCFG_ENABLEMETER                        6452
#define IDH_POWERCFG_POWERSTATUSBAR                     6453
#define IDH_POWERCFG_PMLEVELLIST                        6454
#define IDH_POWERCFG_OPTIONS                            6455

#define IDH_PCMCIA_SELECT                               6458
#define IDH_PCMCIA_MEMORY                               6459
#define IDH_PCMCIA_SOUND                                6460
#define IDH_PCMCIA_CARDSERV                             6461

#define IDH_SYSTEM_DEVGEN_DEVDESC                       6462
#define IDH_SYSTEM_DEVRES_MAKEFC                        6463

#define IDH_SYSTEM_DEVRES_LISTCONFLICT                  6474

#define IDH_SYSTEM_VIEW_LIST                            6483
#define IDH_SYSTEM_RCW_LIST                             6485
#define IDH_SYSTEM_RCW_DETAILS                          6488

#define IDH_POWERCFG_STARTMENU          6491
#define IDH_BATMETER_LOWBATWARN         6492

#define IDH_PCMCIA_TRAY                                 6493
#define IDH_PCMCIA_EJECT                                6494
#define IDH_PCMCIA_WARN                                 6495
#define IDH_PCMCIA_LIST                                 6496

// browseui.dll
#define IDH_BROWSEUI_TB_TEXTOPTIONS                             6800
#define IDH_BROWSEUI_TB_ICONOPTIONS                             6801

// More WinDisk IDs

#define IDH_WINDISK_DDEMDBPB_IGNORE                             7000
#define IDH_WINDISK_DDEMDBPB_REPAIR                             7005
#define IDH_WINDISK_DDERRBOOT_IGNORE                            7010
#define IDH_WINDISK_DDERRBOOT_REPAIR                            7015
#define IDH_WINDISK_DDERRCVFNM_IGNORE                           7020
#define IDH_WINDISK_DDERRCVFNM_REPAIR                           7025
#define IDH_WINDISK_DDERRLSTSQZ_DISCARD                         7030
#define IDH_WINDISK_DDERRLSTSQZ_IGNORE                          7035
#define IDH_WINDISK_DDERRLSTSQZ_KEEP                            7040
#define IDH_WINDISK_DDERRMDFAT_IGNORE                           7045
#define IDH_WINDISK_DDERRMDFAT_REPAIR                           7050
#define IDH_WINDISK_DDERRSIG_IGNORE                             7055
#define IDH_WINDISK_DDERRSIG_REPAIR                             7060
#define IDH_WINDISK_DDERRXLSQZ_COPY                             7065
#define IDH_WINDISK_DDERRXLSQZ_DELETE                           7070
#define IDH_WINDISK_DDERRXLSQZ_IGNORE                           7075
#define IDH_WINDISK_DDESIZE2_IGNORE                             7080
#define IDH_WINDISK_DDESIZE2_REPAIR                             7085
#define IDH_WINDISK_FATERRCDLIMIT_DELETE                        7090
#define IDH_WINDISK_FATERRCDLIMIT_IGNORE                        7095
#define IDH_WINDISK_FATERRCDLIMIT_REPAIR                        7100
#define IDH_WINDISK_FATERRFILE_DELETE_FILE                      7105
#define IDH_WINDISK_FATERRFILE_DELETE_FOLDER                    7107
#define IDH_WINDISK_FATERRFILE_IGNORE                           7110
#define IDH_WINDISK_FATERRFILE_REPAIR                           7115
#define IDH_WINDISK_FATERRLSTCLUS_CONVERT                       7120
#define IDH_WINDISK_FATERRLSTCLUS_DISCARD                       7125
#define IDH_WINDISK_FATERRLSTCLUS_IGNORE                        7130
#define IDH_WINDISK_FATERRMISMAT_DONT_REPAIR                    7135
#define IDH_WINDISK_FATERRMISMAT_REPAIR                         7140
#define IDH_WINDISK_FATERRMXPLEN_DELETE_FILE                    7145
#define IDH_WINDISK_FATERRMXPLEN_DELETE_FOLDER                  7150
#define IDH_WINDISK_FATERRMXPLEN_IGNORE_FILE                    7155
#define IDH_WINDISK_FATERRMXPLEN_IGNORE_FOLDER                  7160
#define IDH_WINDISK_FATERRMXPLEN_REPAIR_FILE                    7165
#define IDH_WINDISK_FATERRMXPLEN_REPAIR_FOLDER                  7170
#define IDH_WINDISK_FATERRRESVAL_DONT_REPAIR                    7175
#define IDH_WINDISK_FATERRRESVAL_REPAIR                         7180
#define IDH_WINDISK_FATERRXLNK_COPY                             7185
#define IDH_WINDISK_FATERRXLNK_DELETE                           7190
#define IDH_WINDISK_FATERRXLNK_IGNORE                           7195
#define IDH_WINDISK_FATERRXLNK_KEEP_SEL_DEL_OTH                 7200
#define IDH_WINDISK_FATERRXLNK_KEEP_SEL_TRUNC_OTH               7205
#define IDH_WINDISK_FATERRXLNK_TRUNCATE_ALL                     7210
#define IDH_WINDISK_ISBAD_COMP_HOST_DONE_REPAIR                 7215
#define IDH_WINDISK_ISBAD_COMP_HOST_NOTDONE_REPAIR              7220
#define IDH_WINDISK_ISBAD_COMP_HOST_NOTDONE_RESTART             7225
#define IDH_WINDISK_ISBAD_COMP_RETRY                            7230
#define IDH_WINDISK_ISBAD_IGNORE                                7235
#define IDH_WINDISK_ISBAD_SYSTEM_IGNORE                         7240
#define IDH_WINDISK_ISBAD_SYSTEM_RETRY                          7245
#define IDH_WINDISK_ISBAD_UNCOMP_DATA_REPAIR                    7250
#define IDH_WINDISK_ISBAD_UNCOMP_RETRY                          7255
#define IDH_WINDISK_ISNTBAD_RETRY                               7260
#define IDH_WINDISK_ISNTBAD_CLEAR                               7265
#define IDH_WINDISK_ISNTBAD_LEAVE                               7270
#define IDH_WINDISK_ISTR_FATERRCIRCC_DELETE                     7275
#define IDH_WINDISK_ISTR_FATERRCIRCC_IGNORE                     7280
#define IDH_WINDISK_ISTR_FATERRCIRCC_TRUNCATE                   7285
#define IDH_WINDISK_ISTR_FATERRDIR_DELETE                       7290
#define IDH_WINDISK_ISTR_FATERRDIR_IGNORE                       7295
#define IDH_WINDISK_ISTR_FATERRDIR_REPAIR                       7300
#define IDH_WINDISK_ISTR_FATERRINVCLUS_DELETE                   7305
#define IDH_WINDISK_ISTR_FATERRINVCLUS_IGNORE                   7310
#define IDH_WINDISK_ISTR_FATERRINVCLUS_TRUNCATE                 7315
#define IDH_WINDISK_ISTR_FATERRVOLLAB_DELETE_ISFRST_NOTSET      7320
#define IDH_WINDISK_ISTR_FATERRVOLLAB_DELETE_ISFRST_SET         7330
#define IDH_WINDISK_ISTR_FATERRVOLLAB_IGNORE_ISFRST_NOTSET      7340
#define IDH_WINDISK_ISTR_FATERRVOLLAB_IGNORE_ISFRST_SET         7350
#define IDH_WINDISK_ISTR_FATERRVOLLAB_REPAIR_ISFRST_NOTSET      7360
#define IDH_WINDISK_ISTR_FATERRVOLLAB_REPAIR_ISFRST_SET         7370
#define IDH_WINDISK_MEMORYERROR_IGNORE                          7380
#define IDH_WINDISK_MEMORYERROR_RETRY                           7385
#define IDH_WINDISK_READERROR_RETRY                             7390
#define IDH_WINDISK_READWRITEERROR_COMP_SYSTEM_IGNORE           7395
#define IDH_WINDISK_READWRITEERROR_COMP_THOROUGH                7400
#define IDH_WINDISK_READWRITEERROR_DATA_IGNORE                  7405
#define IDH_WINDISK_READWRITEERROR_UNCOMP_SYSTEM_IGNORE         7410
#define IDH_WINDISK_READWRITEERROR_UNCOMP_THOROUGH              7415
#define IDH_WINDISK_WRITEERROR_RETRY                            7420
#define IDH_WINDISK_FATERRMXPLEN_SHORT_IGNORE_FILE              7425
#define IDH_WINDISK_FATERRMXPLEN_SHORT_IGNORE_FOLDER            7430
#define IDH_SCANDISK                                            7431
#define IDH_SCANDISK_FINISH                                     7432
#define IDH_SCANDISK_FINISH_SURF_HOST                           7433
#define IDH_SCANDISK_FINISH_SURF                                7434
#define IDH_COMPRESS_CORRECT_SIZE                               7435
#define IDH_COMPRESS_CORRECT_RATIO                              7436
#define IDH_UTILITIES_DEFRAG_DISK_ERROR                         7437
#define IDH_CVF_TOO_SMALL_CHECK_HOST                            7438
#define IDH_THOROUGH_TEST_CHECK_HOST                            7439
#define IDH_DISK_LOGICAL                                        7440
#define IDH_DISK_PHYSICAL                                       7441
#define IDH_WINDISK_DDERRMDFAT_LOST_REPAIR                      7442
#define IDH_WINDISK_DDERRMDFAT_LOST_IGNORE                      7443
#define IDH_WINDISK_ISBAD_NO_FREE_CLUSTER                       7444
#define IDH_WINDISK_MAIN_LIST                                   7445
#define IDH_WINDISK_MAIN_STANDARD                               7446
#define IDH_WINDISK_MAIN_OPTIONS                                7447
#define IDH_WINDISK_MAIN_THOROUGH                               7448
#define IDH_WINDISK_MAIN_AUTOFIX                                7449
#define IDH_WINDISK_MAIN_ADVANCED                               7450
#define IDH_WINDISK_ADV_ALWAYS                                  7451
#define IDH_WINDISK_ADV_NEVER                                   7452
#define IDH_WINDISK_ADV_ONLY_IF_FOUND                           7453
#define IDH_WINDISK_ADV_DELETE                                  7454
#define IDH_WINDISK_ADV_MAKE_COPIES                             7455
#define IDH_WINDISK_ADV_IGNORE                                  7456
#define IDH_WINDISK_ADV_FILENAME                                7457
#define IDH_WINDISK_ADV_DATE_TIME                               7458
#define IDH_WINDISK_ADV_CHECK_HOST                              7459
#define IDH_WINDISK_ADV_FREE                                    7460
#define IDH_WINDISK_ADV_CONVERT                                 7461
#define IDH_WINDISK_OPTIONS_SYS_AND_DATA                        7462
#define IDH_WINDISK_OPTIONS_SYS_ONLY                            7463
#define IDH_WINDISK_OPTIONS_DATA_ONLY                           7464
#define IDH_WINDISK_OPTIONS_NO_WRITE_TEST                       7465
#define IDH_WINDISK_OPTIONS_NO_HID_SYS                          7466
#define IDH_FORMATDLG_CAPACITY                                  7467
#define IDH_FORMATDLG_QUICK                                     7468
#define IDH_FORMATDLG_FULL                                      7469
#define IDH_FORMATDLG_DOSYS                                     7470
#define IDH_FORMATDLG_LABEL                                     7471
#define IDH_FORMATDLG_NOLAB                                     7472
#define IDH_FORMATDLG_REPORT                                    7473
#define IDH_FORMATDLG_MKSYS                                     7474
#define IDH_WINDISK_MAIN_START                                  7475
#define IDH_WINDISK_MAIN_CLOSE                                  7476
#define IDH_WINDISK_OK_FOR_ERRORS                               7477
#define IDH_WINDISK_CANCEL_FOR_ERRORS                           7478
#define IDH_WINDISK_MORE_INFO                                   7479
#define IDH_FORMATDLG_START                                     7480
#define IDH_WINDISK_REPLACE_LOG                                 7481
#define IDH_WINDISK_APPEND_LOG                                  7482
#define IDH_WINDISK_NO_LOG                                      7483
#define IDH_FORMATDLG_FILESYS                                   7484
#define IDH_FORMATDLG_ALLOCSIZE                                 7485
#define IDH_FORMATDLG_QUICKFULL                                 7486
#define IDH_FORMATDLG_COMPRESS                                  7487

#define IDH_CHKDSKDLG_START                                     7488
#define IDH_CHKDSKDLG_FIXERRORS                                 7489
#define IDH_CHKDSKDLG_SCAN                                      7490
#define IDH_CHKDSKDLG_CANCEL                                    7491
#define IDH_CHKDSKDLG_PROGRESS                                  7492
#define IDH_FORMATDLG_PROGRESS                                  7493

// IDs for Port Settings

#define IDH_PORT_BAUD                                           7900
#define IDH_PORT_DATA                                           7901
#define IDH_PORT_PARITY                                         7902
#define IDH_PORT_STOPBITS                                       7903
#define IDH_PORT_FLOW                                           7904
#define IDH_PORT_RESTORE                                        7905

// IDs for Modem Diagnostics

#define IDH_MODEM_DIAG_INSTALLED                                7950
#define IDH_MODEM_DIAG_HELP                                     7951
#define IDH_MODEM_DIAG_MOREINFO                                 7952
#define IDH_MODEM_DIAG_DRIVER                                   7953

// IDs for Wastebasket/Recycle

#define IDH_WASTE_FREEING_DISK_SPACE                            8000
#define IDH_RECYCLE_CONFIG_INDEP                                8001
#define IDH_RECYCLE_CONFIG_ALL                                  8002
#define IDH_RECYCLE_PURGE_ON_DEL                                8003
#define IDH_RECYCLE_MAX_SIZE                                    8004
#define IDH_RECYCLE_DRIVE_SIZE                                  8005
#define IDH_RECYCLE_BIN_SIZE                                    8006
#define IDH_DELETE_CONFIRM_DLG                                  8007

#define IDH_FPROP_GEN_CHANGE                                    475102
#define IDH_CONFIRM_OPEN                                        51065
#define IDH_SAME_WINDOW                                         51066

// ID values 8100-8199 are reserved for Font dialog.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\helpernodes.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "logDrive.h"
#include "HelperNodes.h"
#include "..\common\util.h"
#include "..\common\ServiceThread.h"
#include "ErrorPage.h"
#include "..\MMFUtil\MsgDlg.h"

CWaitNode::CWaitNode() : CLogDriveScopeNode(0, false)
{
	// Image indexes may need to be modified depending on the images specific to 
	// the snapin.
	memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
	m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
	m_scopeDataItem.displayname = MMC_CALLBACK;
	m_scopeDataItem.nOpenImage = 0;		// May need modification
	m_scopeDataItem.lParam = (LPARAM) this;

	memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
	m_resultDataItem.str = MMC_CALLBACK;
	m_resultDataItem.nImage = IDI_WAITING;
	m_resultDataItem.lParam = (LPARAM) this;

	TCHAR temp[100] = {0};
	if(::LoadString(HINST_THISDLL, IDS_PLSE_WAIT, temp, 100) > 0)
	{
		m_bstrDisplayName = temp;
	}

	memset(temp, 0, 100 * sizeof(TCHAR));
	if(::LoadString(HINST_THISDLL, IDS_CONNECTING, temp, 100) > 0)
	{
		m_bstrDesc = temp;
	}

	m_painted = false;

}

//------------------------------------------------------------------
HRESULT CWaitNode::Notify( MMC_NOTIFY_TYPE event,
								long arg,
								long param,
								IComponentData* pComponentData,
								IComponent* pComponent,
								DATA_OBJECT_TYPES type)
{
	// Add code to handle the different notifications.
	// Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
	// In response to MMCN_SHOW you have to enumerate both the scope
	// and result pane items.

	// For MMCN_EXPAND you only need to enumerate the scope items
	// Use IConsoleNameSpace::InsertItem to insert scope pane items
	// Use IResultData::InsertItem to insert result pane item.

	HRESULT hr = E_NOTIMPL;
	
	_ASSERTE(pComponentData != NULL || pComponent != NULL);

	CComPtr<IConsole> spConsole;
	CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeader;

	if(pComponentData != NULL)
		spConsole = ((CNSDrive*)pComponentData)->m_spConsole;
	else
	{
		spConsole = ((CNSDriveComponent*)pComponent)->m_spConsole;
		spHeader = spConsole;
	}

	switch(event)
	{
	case MMCN_SELECT:
		{
			IConsoleVerb *menu = NULL;
			if(SUCCEEDED(spConsole->QueryConsoleVerb(&menu)))
			{
				menu->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
				menu->SetDefaultVerb(MMC_VERB_PROPERTIES);
			}
			break;
		}

		// NOTE: The CLogDriveScopeNode loads the icons using the resID as the idx.

	} //endswitch

	return hr;
}

//------------------------------------------------------------------
LPOLESTR CWaitNode::GetResultPaneColInfo(int nCol)
{
	m_painted = true;
	switch(nCol)
	{
	case 0:
		return m_bstrDisplayName;
		break;
	case 1:
		return m_bstrDesc;
		break;
	case 2:
		return L"";
		break;
	} //endswitch nCol

	return OLESTR("missed one in CResultDrive::GetResultPaneColInfo");
}

//------------------------------------------------------------------
HRESULT CWaitNode::QueryPagesFor(DATA_OBJECT_TYPES type)
{
	return S_FALSE;
}

//------------------------------------------------------------------
HRESULT CWaitNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
											long handle, 
											IUnknown* pUnk,
											DATA_OBJECT_TYPES type)
{
	return E_UNEXPECTED;
}


//=============================================================================
//=============================================================================
CErrorNode::CErrorNode(WbemServiceThread *serviceThread) : 
				CLogDriveScopeNode(serviceThread, false)
{
	// Image indexes may need to be modified depending on the images specific to 
	// the snapin.
	memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
	m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
	m_scopeDataItem.displayname = MMC_CALLBACK;
	m_scopeDataItem.nOpenImage = 0;		// May need modification
	m_scopeDataItem.lParam = (LPARAM) this;

	memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
	m_resultDataItem.str = MMC_CALLBACK;
	m_resultDataItem.nImage = (UINT)(DWORD_PTR)IDI_ERROR; // HACK:BUGBUGnowin64bug - Should this be
	m_resultDataItem.lParam = (LPARAM) this;

	m_hr = 0;
	TCHAR temp[100] = {0};
	if(::LoadString(HINST_THISDLL, IDS_ERROR, temp, 100) > 0)
	{
		m_bstrDisplayName = temp;
	}

	memset(temp, 0, 100 * sizeof(TCHAR));
	if(::LoadString(HINST_THISDLL, IDS_CLICKME, temp, 100) > 0)
	{
		m_bstrDesc = temp;
	}
}

//------------------------------------------------------------------
HRESULT CErrorNode::Notify( MMC_NOTIFY_TYPE event,
								long arg,
								long param,
								IComponentData* pComponentData,
								IComponent* pComponent,
								DATA_OBJECT_TYPES type)
{
	// Add code to handle the different notifications.
	// Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
	// In response to MMCN_SHOW you have to enumerate both the scope
	// and result pane items.

	// For MMCN_EXPAND you only need to enumerate the scope items
	// Use IConsoleNameSpace::InsertItem to insert scope pane items
	// Use IResultData::InsertItem to insert result pane item.

	HRESULT hr = E_NOTIMPL;
	
	_ASSERTE(pComponentData != NULL || pComponent != NULL);

	CComPtr<IConsole> spConsole;
	CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeader;

	if(pComponentData != NULL)
		spConsole = ((CNSDrive*)pComponentData)->m_spConsole;
	else
	{
		spConsole = ((CNSDriveComponent*)pComponent)->m_spConsole;
		spHeader = spConsole;
	}

	switch(event)
	{
	case MMCN_SELECT:
		{
			IConsoleVerb *menu = NULL;
			if(SUCCEEDED(spConsole->QueryConsoleVerb(&menu)))
			{
				menu->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
				menu->SetDefaultVerb(MMC_VERB_PROPERTIES);
			}
			break;
		}
		// NOTE: The CLogDriveScopeNode loads the icons using the resID as the idx.

	case MMCN_DBLCLICK:
		hr = S_FALSE; // do the default verb. (Properties)
		break;

	} //endswitch

	return hr;
}

//------------------------------------------------------------------
LPOLESTR CErrorNode::GetResultPaneColInfo(int nCol)
{
	switch(nCol)
	{
	case 0:
		return m_bstrDisplayName;
		break;
	case 1:
		return m_bstrDesc;
		break;
	case 2:
		return L"";
		break;
	} //endswitch nCol

	return OLESTR("missed one in CResultDrive::GetResultPaneColInfo");
}

//------------------------------------------------------------------
HRESULT CErrorNode::QueryPagesFor(DATA_OBJECT_TYPES type)
{
	if(type == CCT_RESULT)
		return S_OK;

	return S_FALSE;
}

//------------------------------------------------------------------
HRESULT CErrorNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
											long handle, 
											IUnknown* pUnk,
											DATA_OBJECT_TYPES type)
{
	if(type == CCT_RESULT)
	{
        HRESULT        hr = S_OK;

		// instance the class for the error page.
		ErrorPage *dvPg = new ErrorPage(handle, true, NULL, ConnectServer, 0,
										(m_hr == 0 ? g_serviceThread->m_hr : m_hr));

		lpProvider->AddPage(dvPg->Create());

        return hr;
	}

	return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\msgpopup.h ===
// Copyright (c) 1997-1999 Microsoft Corporation

#ifndef _MSGPOPUP_H_
#define _MSGPOPUP_H_
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

int
WINAPIV
MsgPopup(HWND hwnd,                 // Owner window
         LPCTSTR pszMsg,            // May be resource ID
         LPCTSTR pszTitle,          // May be resource ID or NULL
         UINT uType,                // MessageBox flags
         HINSTANCE hInstance,       // Resource strings loaded from here
         ...);                      // Arguments to insert into pszMsg
int
WINAPI
SysMsgPopup(HWND hwnd,
            LPCTSTR pszMsg,
            LPCTSTR pszTitle,
            UINT uType,
            HINSTANCE hInstance,
            DWORD dwErrorID,
            LPCTSTR pszInsert2 = NULL);

#ifdef __cplusplus
}
#endif

#endif  // _MSGPOPUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\helpernodes.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
//#include "NSDrive.h"
#include "ResultNode.h"

class CWaitNode : public CLogDriveScopeNode
{
public:
	CWaitNode();
	virtual LPOLESTR GetResultPaneColInfo(int nCol);

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
						long arg,
						long param,
						IComponentData* pComponentData,
						IComponent* pComponent,
						DATA_OBJECT_TYPES type);

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
									long handle, 
									IUnknown* pUnk,
									DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type);

	bool m_painted;

private:
	_bstr_t m_bstrDesc;
	_bstr_t m_bstrMapping;
};


//----------------------------------------------------------
class CErrorNode : public CLogDriveScopeNode
{
public:
	CErrorNode(WbemServiceThread *serviceThread);
	virtual LPOLESTR GetResultPaneColInfo(int nCol);

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
						long arg,
						long param,
						IComponentData* pComponentData,
						IComponent* pComponent,
						DATA_OBJECT_TYPES type);

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
									long handle, 
									IUnknown* pUnk,
									DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type);

	HRESULT m_hr;
private:
	_bstr_t m_bstrDesc;
	_bstr_t m_bstrMapping;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\msgpopup.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright (c) 1991-1999 Microsoft Corporation
/**********************************************************************/

/*

    MSGPOPUP.CPP

    This file contains MessageBox helper functions.

*/
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "..\Common\util.h"
#include "msgpopup.h"

/*******************************************************************

    NAME:       MsgPopup

    SYNOPSIS:   Displays a message to the user

    ENTRY:      hwnd        - Owner window handle
                pszMsg      - Main message text
                pszTitle    - MessageBox title
                uType       - MessageBox flags
                hInstance   - Module to load strings from.  Only required if
                              pszMsg or pszTitle is a string resource ID.
                Optional format insert parameters.

    EXIT:

    RETURNS:    MessageBox result

    NOTES:      Either of the string parameters may be string resource ID's.

    HISTORY:
        JeffreyS    11-Jun-1997     Created

********************************************************************/

int
WINAPIV
MsgPopup(HWND hwnd,
         LPCTSTR pszMsg,
         LPCTSTR pszTitle,
         UINT uType,
         HINSTANCE hInstance,
         ...)
{
    TCHAR szTemp[1024] = {0};
    TCHAR szMsg[1024] = {0};
    DWORD dwFormatResult;
    va_list ArgList;

    if (pszMsg == NULL)
        return -1;

    //
    // Load the format string if necessary
    //
    if (!HIWORD(pszMsg))
    {
        szTemp[0] = TEXT('\0');

        if (!LoadString(hInstance, (UINT)pszMsg, szTemp, ARRAYSIZE(szTemp)))
            return -1;

        pszMsg = szTemp;
    }

    //
    // Insert arguments into the format string
    //
    va_start(ArgList, hInstance);
    dwFormatResult = FormatMessage(FORMAT_MESSAGE_FROM_STRING,
                                   pszMsg,
                                   0,
                                   0,
                                   szMsg,
                                   ARRAYSIZE(szMsg),
                                   &ArgList);
    va_end(ArgList);

    if (!dwFormatResult)
        return -1;

    //
    // Load the caption if necessary
    //
    if (pszTitle && !HIWORD(pszTitle))
    {
        if (LoadString(hInstance, (UINT)pszTitle, szTemp, ARRAYSIZE(szTemp)))
            pszTitle = szTemp;
        else
            pszTitle = NULL;
    }

    //
    // Display message box
    //
    return MessageBox(hwnd, szMsg, pszTitle, uType);
}


/*******************************************************************

    NAME:       SysMsgPopup

    SYNOPSIS:   Displays a message to the user using a system error
                message as an insert.

    ENTRY:      hwnd        - Owner window handle
                pszMsg      - Main message text
                pszTitle    - MessageBox title
                uType       - MessageBox flags
                hInstance   - Module to load strings from.  Only required if
                              pszMsg or pszTitle is a string resource ID.
                dwErrorID   - System defined error code (Insert 1)
                pszInsert2  - Optional string to be inserted into pszMsg

    EXIT:

    RETURNS:    MessageBox result

    NOTES:      Any of the string parameters may be string resource ID's.

    HISTORY:
        JeffreyS    11-Jun-1997     Created

********************************************************************/

int
WINAPI
SysMsgPopup(HWND hwnd,
            LPCTSTR pszMsg,
            LPCTSTR pszTitle,
            UINT uType,
            HINSTANCE hInstance,
            DWORD dwErrorID,
            LPCTSTR pszInsert2)
{
    TCHAR szTemp[MAX_PATH] = {0};

    //
    // Load the 2nd insert string if necessary
    //
    if (pszInsert2 && !HIWORD(pszInsert2))
    {
        if (LoadString(hInstance, (UINT)pszInsert2, szTemp, ARRAYSIZE(szTemp)))
        {
            pszInsert2 = (LPCTSTR)_alloca((lstrlen(szTemp)+1)*SIZEOF(TCHAR));

            if (pszInsert2 != NULL) // can alloca ever fail?
                lstrcpy((LPTSTR)pszInsert2, szTemp);
        }
        else
            pszInsert2 = NULL;
    }

    szTemp[0] = TEXT('\0');

    //
    // Get the error message string
    //
    if (dwErrorID)
    {
        FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
                      NULL,
                      dwErrorID,
                      0,
                      szTemp,
                      ARRAYSIZE(szTemp),
                      NULL);
    }

    return MsgPopup(hwnd, pszMsg, pszTitle, uType, hInstance, szTemp, pszInsert2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\logdrive.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// LogDrive.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f LogDriveps.mk in the project directory.

#include "precomp.h"
#include "resource.h"
#include "initguid.h"
#include "LogDrive.h"

#include "LogDrive_i.c"
#include "NSDrive.h"

#include "..\common\sshwbemhelpers.h"

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_NSDrive, CNSDrive)
	OBJECT_ENTRY(CLSID_NSDriveAbout, CNSDriveAbout)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if(dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		CSnapInItem::Init();
		DisableThreadLibraryCalls(hInstance);
	}
	else if(dwReason == DLL_PROCESS_DETACH)
	{
		_Module.Term();
	}
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	if(_Module.GetLockCount()==0)
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\precomp.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED_)
#define AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif

#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
};

extern CExeModule  _Module;

#include <atlcom.h>
#include <atlwin.h>


#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif



//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\nsdrive.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "LogDrive.h"
#include "NSDrive.h"
#include "ResultNode.h"
#include "HelperNodes.h"
#include "..\common\util.h"
#include <process.h>
#include "..\common\ServiceThread.h"

/////////////////////////////////////////////////////////////////////////////
// CNSDriveComponentData
static const GUID CNSDriveGUID_NODETYPE = 
{ 0x692a8957, 0x1089, 0x11d2, { 0x88, 0x37, 0x0, 0x10, 0x4b, 0x2a, 0xfb, 0x46 } };
const GUID*  CLogDriveScopeNode::m_NODETYPE = &CNSDriveGUID_NODETYPE;
const OLECHAR* CLogDriveScopeNode::m_SZNODETYPE = OLESTR("692A8957-1089-11D2-8837-00104B2AFB46");
const OLECHAR* CLogDriveScopeNode::m_SZDISPLAY_NAME = OLESTR("NSDrive");
const CLSID* CLogDriveScopeNode::m_SNAPIN_CLASSID = &CLSID_NSDrive;

//NOTE: This is the CM Storage node I'm extending.
static const GUID CNSDriveExtGUID_NODETYPE = 
{ 0x476e644a, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
const GUID*  CStorageNodeExt::m_NODETYPE = &CNSDriveExtGUID_NODETYPE;
const OLECHAR* CStorageNodeExt::m_SZNODETYPE = OLESTR("476e644a-aaff-11d0-b944-00c04fd8d5b0");
const OLECHAR* CStorageNodeExt::m_SZDISPLAY_NAME = OLESTR("NSDrive");
const CLSID* CStorageNodeExt::m_SNAPIN_CLASSID = &CLSID_NSDrive;



//-------------------------------------------------------------------------
void Snitch(LPCTSTR src, MMC_NOTIFY_TYPE event)
{
	TCHAR ev[30] = {0};
	switch(event)
	{
    case MMCN_ACTIVATE: _tcsncpy(ev, L"ACTIVATE", 30); break;
	case MMCN_ADD_IMAGES: _tcsncpy(ev, L"ADD_IMAGES", 30); break;
	case MMCN_BTN_CLICK: _tcsncpy(ev, L"BTN_CLICK", 30); break;
	case MMCN_CLICK: _tcsncpy(ev, L"CLICK", 30); break;
	case MMCN_COLUMN_CLICK: _tcsncpy(ev, L"COLUMN_CLICK", 30); break;
	case MMCN_CONTEXTMENU: _tcsncpy(ev, L"CONTEXTMENU", 30); break;
	case MMCN_CUTORMOVE: _tcsncpy(ev, L"CUTORMOVE", 30); break;
	case MMCN_DBLCLICK: _tcsncpy(ev, L"DBLCLICK", 30); break;
	case MMCN_DELETE: _tcsncpy(ev, L"DLETE", 30); break;
	case MMCN_DESELECT_ALL: _tcsncpy(ev, L"DESELECT_ALL", 30); break;
	case MMCN_EXPAND: _tcsncpy(ev, L"EXPAND", 30); break;
	case MMCN_HELP: _tcsncpy(ev, L"HELP", 30); break;
	case MMCN_MENU_BTNCLICK: _tcsncpy(ev, L"MENU_BTNCLICK", 30); break;
	case MMCN_MINIMIZED: _tcsncpy(ev, L"MINIMIZED", 30); break;
	case MMCN_PASTE: _tcsncpy(ev, L"PASTE", 30); break;
	case MMCN_PROPERTY_CHANGE: _tcsncpy(ev, L"PROPERTY_CHANGE", 30); break;
	case MMCN_QUERY_PASTE: _tcsncpy(ev, L"QUERY_PASTE", 30); break;
	case MMCN_REFRESH: _tcsncpy(ev, L"REFRESH", 30); break;
	case MMCN_REMOVE_CHILDREN: _tcsncpy(ev, L"REMOVE_CHILDREN", 30); break;
	case MMCN_RENAME: _tcsncpy(ev, L"RENAME", 30); break;
	case MMCN_SELECT: _tcsncpy(ev, L"SELECT", 30); break;
	case MMCN_SHOW: _tcsncpy(ev, L"SHOW", 30); break;
	case MMCN_VIEW_CHANGE: _tcsncpy(ev, L"VIEW_CHANGE", 30); break;
	case MMCN_SNAPINHELP: _tcsncpy(ev, L"SNAPINHELP", 30); break;
	case MMCN_CONTEXTHELP: _tcsncpy(ev, L"CONTEXTHELP", 30); break;
	case MMCN_INITOCX: _tcsncpy(ev, L"INITOCX", 30); break;
	case MMCN_FILTER_CHANGE: _tcsncpy(ev, L"FILTER_CHANGE", 30); break;
	case MMCN_FILTERBTN_CLICK: _tcsncpy(ev, L"FILTERBTN_CLICK", 30); break;
	case MMCN_RESTORE_VIEW: _tcsncpy(ev, L"RESTORE_VIEW", 30); break;
	case MMCN_PRINT: _tcsncpy(ev, L"PRINT", 30); break;
	case MMCN_PRELOAD: _tcsncpy(ev, L"PRELOAD", 30); break;
	case MMCN_LISTPAD: _tcsncpy(ev, L"LISTPAD", 30); break;
	case MMCN_EXPANDSYNC: _tcsncpy(ev, L"EXPANDSYNC", 30); break;
	}

	ATLTRACE(_T("====== %s : %s\n"), src, ev);
}

//------------------------------------------------------------------
// NOTE: This is the "logical and Mapped Drives" scope node.
CLogDriveScopeNode::CLogDriveScopeNode(WbemServiceThread *serviceThread,
									   bool orig)
{
	g_serviceThread = serviceThread;
	m_theOriginalServiceThread = orig;
	m_waitNode = 0;

	// Image indexes may need to be modified depending on the images specific to 
	// the snapin.
	memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
	m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM |SDI_CHILDREN ;
	m_scopeDataItem.displayname = MMC_CALLBACK;
	m_scopeDataItem.nImage = IDI_DRIVEFIXED;
	m_scopeDataItem.nOpenImage = IDI_DRIVEFIXED;
	m_scopeDataItem.lParam = (LPARAM) this;
	m_scopeDataItem.cChildren = 0;

	memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
	m_resultDataItem.str = MMC_CALLBACK;
	m_resultDataItem.nImage = IDI_DRIVEFIXED;
	m_resultDataItem.lParam = (LPARAM) this;

	TCHAR temp[50] = {0};
	if(::LoadString(HINST_THISDLL, IDS_SHORT_NAME, temp, 50) > 0)
	{
		m_bstrDisplayName = temp;
	}

	// load column name resources for the result nodes.
	memset(m_colName, 0, 20 * sizeof(wchar_t));
	if(::LoadString(HINST_THISDLL, IDS_NAME, m_colName, 20) == 0)
	{
		wcscpy(m_colName, L"Name");
	}

	memset(m_colType, 0, 20 * sizeof(wchar_t));
	if(::LoadString(HINST_THISDLL, IDS_TYPE, m_colType, 20) == 0)
	{
		wcscpy(m_colType, L"Type");
	}

	memset(m_colMapping, 0, 20 * sizeof(wchar_t));
	if(::LoadString(HINST_THISDLL, IDS_MAPPING, m_colMapping, 20) == 0)
	{
		wcscpy(m_colMapping, L"Mapping");
	}

	memset(m_nodeType, 0, 50 * sizeof(wchar_t));
	if(::LoadString(HINST_THISDLL, IDS_SNAPIN_TYPE, m_nodeType, 50) == 0)
	{
		wcscpy(m_nodeType, L"Snapin Extension");
	}

	memset(m_nodeDesc, 0, 100 * sizeof(wchar_t));
	if(::LoadString(HINST_THISDLL, IDS_DESCRIPTION, m_nodeDesc, 100) == 0)
	{
		wcscpy(m_nodeDesc, L"<unavailable>");
	}

	memset(m_descBar, 0, 100 * sizeof(wchar_t));
	if(::LoadString(HINST_THISDLL, IDS_DISPLAY_NAME, m_descBar, 100) == 0)
	{
		wcscpy(m_descBar, L"Logical and Mapped Drives");
	}

	m_bPopulated = false;
	m_spConsole = NULL;
#ifdef _DEBUG
	SetProcessShutdownParameters(0x0400, 0);
#endif
}

//------------------------------------------------------------------
CLogDriveScopeNode::~CLogDriveScopeNode()
{
	CSnapInItem* p;
	int last = m_resultonlyitems.GetSize();
	for(int i = 0; i < last ; i++)
	{
		p = m_resultonlyitems[i];
		try
		{
			delete p;
		}
		catch( ... )
		{
		}
	}

	m_resultonlyitems.RemoveAll();

	if(g_serviceThread)
	{
		try
		{
			delete g_serviceThread;
		}
		catch( ... )
		{
		}
		g_serviceThread = NULL;
	}

	if(m_waitNode)
	{
		try
		{
			delete m_waitNode;
		}
		catch( ... )
		{
		}
		m_waitNode = NULL;
	}
}


//--------------------------------------------------------------
CLogDriveScopeNode *g_self;

void CLogDriveScopeNode::Initialize(void)
{
	if(g_serviceThread->m_status == WbemServiceThread::notStarted)
	{
		WaitNode();

		WNDCLASSEX wndClass;
		wndClass.cbSize = sizeof(WNDCLASSEX);
		wndClass.style = 0;
		wndClass.lpfnWndProc = (WNDPROC)AfterConnectProc;
		wndClass.cbClsExtra = 0;
		wndClass.cbWndExtra = 0;
		wndClass.hInstance = HINST_THISDLL;
		wndClass.hIcon = NULL;
		wndClass.hCursor = NULL;
		wndClass.hbrBackground = 0;
		wndClass.lpszMenuName =  NULL;
		wndClass.lpszClassName = L"AFTERCONNECT";
		wndClass.hIconSm = 0;

		if((RegisterClassEx(&wndClass)) ||
			(GetLastError() == ERROR_CLASS_ALREADY_EXISTS))
		{
			m_afterConnectHwnd = CreateWindow(L"AFTERCONNECT",
												L"AfterConnect",
												0,
												0, 0, 10, 10,
												NULL,
												0, HINST_THISDLL, 0);

			HRESULT hr = m_parent->QueryInterface(IID_IDataObject, (void**)&m_pDataObject);


			g_self = this;

			if(g_serviceThread->Connect(m_pDataObject, &m_afterConnectHwnd))
			{
				ATLTRACE(L"root connected\n");
			}
		}
		else
		{
			// cant register window class.

		}
	}
	else
	{
		EnumerateResultChildren();
	}
}

//---------------------------------------------------------
LRESULT CALLBACK AfterConnectProc(HWND hwndDlg,UINT msg, 
								  WPARAM wParam, LPARAM lParam)
{
	switch(msg)
	{
	case WM_ASYNC_CIMOM_CONNECTED:
		{
			CLogDriveScopeNode *me = (CLogDriveScopeNode *)g_self;

			ATLTRACE(L"WNDProc thread %d\n", GetCurrentThreadId());

			if(lParam)
			{
				IStream *pStream = (IStream *)lParam;
				IWbemServices *pServices = 0;
				HRESULT hr = CoGetInterfaceAndReleaseStream(pStream,
													IID_IWbemServices,
													(void**)&pServices);
				if(SUCCEEDED(hr) && 
				  (me->g_serviceThread->m_status == WbemServiceThread::ready))
				{
					//VINOTH
					me->g_serviceThread->m_realServices = pServices;
					me->m_WbemServices = pServices;
					me->g_serviceThread->m_WbemServices = pServices;
					me->EnumerateResultChildren();
				}
				else
				{
					//complain about no service.
					ATLTRACE(L"root no CIMOM\n");
					me->ErrorNode();
				}
				return TRUE;
			}
			else
			{
				me->ErrorNode();
			}
		}
		break;

	default:
		return DefWindowProc(hwndDlg, msg, wParam, lParam);
		break;
	} //endswitch

	return FALSE;  // didn't process it.
}

//--------------------------------------------------------------
void CLogDriveScopeNode::WaitNode()
{
	CSnapInItem* p;
	for(int i = 0; i < m_resultonlyitems.GetSize(); i++)
	{
		p = m_resultonlyitems[i];
		delete p;
	}

	m_resultonlyitems.RemoveAll();

	m_waitNode = (CResultDrive *)new CWaitNode;
	
	m_waitNode->m_resultDataItem.lParam = (LPARAM)m_waitNode;
	m_waitNode->m_resultDataItem.str = MMC_CALLBACK;

	CComQIPtr<IResultData, &IID_IResultData> spResultData(m_spConsole);
	RESULTDATAITEM* pResultDataItem;

	m_waitNode->GetResultData(&pResultDataItem);

	if(pResultDataItem != NULL)
	{
		HRESULT hr = spResultData->InsertItem(pResultDataItem);
	}
}

//--------------------------------------------------------------
void CLogDriveScopeNode::ErrorNode()
{
	CSnapInItem* p;
	for(int i = 0; i < m_resultonlyitems.GetSize(); i++)
	{
		p = m_resultonlyitems[i];
		delete p;
	}

	m_resultonlyitems.RemoveAll();


	CResultDrive* p1 = (CResultDrive *)new CErrorNode(g_serviceThread);

	p1->m_resultDataItem.lParam = (LPARAM)p1;
	p1->m_resultDataItem.str = MMC_CALLBACK;

	// add to the result cache.
	m_resultonlyitems.Add(p1);
	
	RefreshResult();
}

//------------------------------------------------------------------
HRESULT CLogDriveScopeNode::GetScopePaneInfo(SCOPEDATAITEM *pScopeDataItem)
{
	if(pScopeDataItem->mask & SDI_STR)
		pScopeDataItem->displayname = m_bstrDisplayName;
	if(pScopeDataItem->mask & SDI_IMAGE)
		pScopeDataItem->nImage = m_scopeDataItem.nImage;
	if(pScopeDataItem->mask & SDI_OPENIMAGE)
		pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
	if(pScopeDataItem->mask & SDI_PARAM)
		pScopeDataItem->lParam = m_scopeDataItem.lParam;
	if(pScopeDataItem->mask & SDI_STATE )
		pScopeDataItem->nState = m_scopeDataItem.nState;
	if(pScopeDataItem->mask & SDI_CHILDREN )
		pScopeDataItem->cChildren = m_scopeDataItem.cChildren;

	return S_OK;
}

//------------------------------------------------------------------
HRESULT CLogDriveScopeNode::GetResultPaneInfo(RESULTDATAITEM *pResultDataItem)
{
	if(pResultDataItem->bScopeItem)
	{
		if(pResultDataItem->mask & RDI_STR)
		{
			pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
		}
		if(pResultDataItem->mask & RDI_IMAGE)
		{
			pResultDataItem->nImage = m_scopeDataItem.nImage;
		}
		if(pResultDataItem->mask & RDI_PARAM)
		{
			pResultDataItem->lParam = m_scopeDataItem.lParam;
		}

		return S_OK;
	}

	if(pResultDataItem->mask & RDI_STR)
	{
		pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
	}
	if(pResultDataItem->mask & RDI_IMAGE)
	{
		pResultDataItem->nImage = m_resultDataItem.nImage;
	}
	if(pResultDataItem->mask & RDI_PARAM)
	{
		pResultDataItem->lParam = m_resultDataItem.lParam;
	}
	if(pResultDataItem->mask & RDI_INDEX)
	{
		pResultDataItem->nIndex = m_resultDataItem.nIndex;
	}

	return S_OK;
}

//---------------------------------------------------------------
HRESULT CLogDriveScopeNode::LoadIcon(IImageList *spImageList, 
									   UINT resID)
{
	HRESULT hr = 0;
	HICON icon = ::LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(resID));
	if(icon != NULL)
	{
		hr = spImageList->ImageListSetIcon((LONG_PTR*)icon, resID);
		if(FAILED(hr))
			ATLTRACE(_T("CLogDriveScopeNode::ImageListSetIcon failed\n"));
	}

	return hr;
}

//------------------------------------------------------------------
HRESULT CLogDriveScopeNode::Notify( MMC_NOTIFY_TYPE event,
									LONG_PTR arg,
									LONG_PTR param,
									IComponentData* pComponentData,
									IComponent* pComponent,
									DATA_OBJECT_TYPES type)
{
	// Add code to handle the different notifications.
	// Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
	// In response to MMCN_SHOW you have to enumerate both the scope
	// and result pane items.

	// For MMCN_EXPAND you only need to enumerate the scope items
	// Use IConsoleNameSpace::InsertItem to insert scope pane items
	// Use IResultData::InsertItem to insert result pane item.
	HRESULT hr = S_FALSE;

	
	_ASSERTE(pComponentData != NULL || pComponent != NULL);

	CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeader;

	if(pComponentData != NULL)
	{
		m_spConsole = ((CNSDrive*)pComponentData)->m_spConsole;
	}
	else
	{
		m_spConsole = ((CNSDriveComponent*)pComponent)->m_spConsole;

		spHeader = m_spConsole;
	}

	Snitch(L"logdrive", event);

	switch(event)
	{
	case MMCN_CONTEXTHELP:
		{
			WCHAR topic[] = L"drivprop.chm::/drivprop_overview.htm";
			CComQIPtr<IDisplayHelp, &IID_IDisplayHelp> displayHelp(m_spConsole);

			LPOLESTR lpCompiledHelpFile = reinterpret_cast<LPOLESTR>(
										CoTaskMemAlloc((wcslen(topic) + 1) * 
															sizeof(wchar_t)));

			if(lpCompiledHelpFile == NULL)
			{
				hr = E_OUTOFMEMORY;
			}
			else
			{
				USES_CONVERSION;
				wcscpy(lpCompiledHelpFile, T2OLE((LPTSTR)(LPCTSTR)topic));
				hr = displayHelp->ShowTopic(lpCompiledHelpFile);
			}
		}
		break;

	case MMCN_REFRESH:
			m_bPopulated = false;
			Initialize();
			hr = S_OK;
			break;

	case MMCN_EXPAND:
			hr = S_OK;
			break;

	case MMCN_DBLCLICK:
			hr = S_FALSE;
			break;

	case MMCN_SELECT:
		{
			CComQIPtr<IResultData, &IID_IResultData> spResultData(m_spConsole);
			spResultData->SetDescBarText(m_descBar);

			IConsoleVerb *menu = NULL;
			if(SUCCEEDED(m_spConsole->QueryConsoleVerb(&menu)))
			{
				menu->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
				menu->SetVerbState(MMC_VERB_REFRESH, HIDDEN, TRUE);
			}
			hr = S_OK;
		}
		break;

	case MMCN_SHOW:
		{
			// if selecting
			if(arg != 0)
			{
				spHeader->InsertColumn(1, m_colName,  LVCFMT_LEFT, 100);
				spHeader->InsertColumn(2, m_colType,  LVCFMT_LEFT, 150);
				spHeader->InsertColumn(3, m_colMapping,  LVCFMT_LEFT, 150);
				Initialize();
			}
			else
			{
			}
			hr = S_OK;
			break;
		}

	case MMCN_ADD_IMAGES:
		{
			// Add Images for the result nodes.
			IImageList* pImageList = (IImageList*) arg;
			hr = S_OK;

			LoadIcon(pImageList, IDI_DRIVE35);
			LoadIcon(pImageList, IDI_DRIVE525);
			LoadIcon(pImageList, IDI_DRIVECD);
			LoadIcon(pImageList, IDI_DRIVEFIXED);
			LoadIcon(pImageList, IDI_DRIVENET);
			LoadIcon(pImageList, IDI_DRIVENETDISABLED);
			LoadIcon(pImageList, IDI_DRIVERAM);
			LoadIcon(pImageList, IDI_DRIVEREMOVE);
			LoadIcon(pImageList, IDI_DRIVEUNKN);

			LoadIcon(pImageList, IDI_WAITING);

			// and an OEM icon for errors.
			HICON icon = ::LoadIcon(NULL, MAKEINTRESOURCE(IDI_ERROR));
			if(icon != NULL)
			{
				hr = pImageList->ImageListSetIcon((LONG_PTR*)icon, (long)(DWORD_PTR)IDI_ERROR); // win64 bug bug - SECOND PARAMETER?
				if(FAILED(hr))
					ATLTRACE(_T("CLogDriveScopeNode::ImageListSetIcon failed\n"));
			}
			hr = S_OK;
			break;
		}
	}
	return hr;
}

//------------------------------------------------------------------
LPOLESTR CLogDriveScopeNode::GetResultPaneColInfo(int nCol)
{
	switch(nCol)
	{
	case 0:
		return m_bstrDisplayName;
		break;
	case 1:
		return m_nodeType;
		break;
	case 2:
		return m_nodeDesc;
		break;
	} //endswitch nCol

	return OLESTR("missed one in CLogDriveScopeNode::GetResultPaneColInfo");
}


//--------------------------------------------------------------
void CLogDriveScopeNode::PopulateChildren()
{
	// if not already populated...
	if(!m_bPopulated)
	{
		IEnumWbemClassObject *en = NULL;
		IWbemClassObject *inst = NULL;
		ULONG uReturned = 0;
		HRESULT hr = 0;

		CSnapInItem* p;
		for(int i = 0; i < m_resultonlyitems.GetSize(); i++)
		{
			p = m_resultonlyitems[i];
			delete p;
		}

		m_resultonlyitems.RemoveAll();

		IWbemServices *service;
		m_WbemServices.GetServices(&service);
		m_WbemServices.SetBlanket(service);

		hr = m_WbemServices.ExecQuery(L"select Name, MediaType, DriveType, Description, __PATH, __CLASS, ProviderName from Win32_LogicalDisk", 
										0, &en);

		service->Release();

		if(SUCCEEDED(hr))
		{
			CResultDrive* p1 = NULL;

			// walk win32_logicalDisk.
			while((SUCCEEDED(en->Next(-1, 1, &inst, &uReturned))) &&
				  (uReturned > 0))
			{
				p1 = new CResultDrive(g_serviceThread);
				p1->Initialize(inst);
				p1->m_resultDataItem.lParam = (LPARAM)p1;
				p1->m_resultDataItem.str = MMC_CALLBACK;

				inst->Release();
				inst = NULL;

				// add to the result cache.
				m_resultonlyitems.Add(p1);
					
			}
			en->Release();

			m_bPopulated = TRUE;

		}//endif SUCCEEDED

	} //endif !m_bPopulated
}

//-------------------------------------------------------
HRESULT CLogDriveScopeNode::EnumerateResultChildren()
{
	HRESULT retval = E_FAIL;
	// load the local cache.
	if((bool)m_WbemServices)
	{
		PopulateChildren();
		retval = RefreshResult();
	}
	return retval;
}

//-------------------------------------------------------
HRESULT CLogDriveScopeNode::RefreshResult()
{
	CComQIPtr<IResultData, &IID_IResultData> spResultData(m_spConsole);

	spResultData->DeleteAllRsltItems();

	// transfer this cache to the result pane.
	CSnapInItem* p;
	int last = m_resultonlyitems.GetSize();
	for(int i = 0; i < last; i++)
	{
		p = m_resultonlyitems[i];
		if(p == NULL)
			continue;

		RESULTDATAITEM* pResultDataItem;
		p->GetResultData(&pResultDataItem);

		if(pResultDataItem == NULL)
			continue;

		HRESULT hr = spResultData->InsertItem(pResultDataItem);
		if(FAILED(hr))
			return hr;
	}

	return S_OK;
}	

//==============================================================
//=================== STORAGE NODE being extended===============
HRESULT CStorageNodeExt::Notify(MMC_NOTIFY_TYPE event,
								LONG_PTR arg,
								LONG_PTR param,
								IComponentData* pComponentData,
								IComponent* pComponent,
								DATA_OBJECT_TYPES type)
{
	// Add code to handle the different notifications.
	// Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
	// In response to MMCN_SHOW you have to enumerate both the scope
	// and result pane items.
	// For MMCN_EXPAND you only need to enumerate the scope items
	// Use IConsoleNameSpace::InsertItem to insert scope pane items
	// Use IResultData::InsertItem to insert result pane item.
	HRESULT hr = S_FALSE;
	
	_ASSERTE(pComponentData != NULL || pComponent != NULL);

	CComPtr<IConsole> spConsole;
	CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeader;
	if (pComponentData != NULL)
		spConsole = ((CNSDrive*)pComponentData)->m_spConsole;
	else
	{
		spConsole = ((CNSDriveComponent*)pComponent)->m_spConsole;
		spHeader = spConsole;
	}

	Snitch(L"Storage", event);

	switch(event)
	{
	case MMCN_REFRESH:
			hr = S_OK;
			break;

	case MMCN_EXPAND:
		{
			// NOTE: I dont enum in the scope.
			CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
			if(m_pScopeItem == NULL)
			{
				CLogDriveScopeNode* p = new CLogDriveScopeNode(new WbemServiceThread);
				p->m_scopeDataItem.relativeID = param;
				p->m_scopeDataItem.lParam = (LPARAM)p;
				p->m_bstrDisplayName = m_nodeName;
				p->m_parent = this;
				hr = spConsoleNameSpace->InsertItem(&p->m_scopeDataItem);

				ATLTRACE(L"!!!!!!!!!!!!!!!!!!!!!scope using %x\n", this);

				MachineName();
				m_pScopeItem = p;
			}
			hr = S_OK;
			break;
		}

	case MMCN_REMOVE_CHILDREN:
		{
			CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
			delete m_pScopeItem;
			m_pScopeItem = NULL;

			hr = spConsoleNameSpace->DeleteItem(arg, false);
		}
		break;

	case MMCN_ADD_IMAGES:
		{
			// Add Images
			IImageList* pImageList = (IImageList*) arg;
			hr = E_FAIL;

			CComQIPtr<IResultData, &IID_IResultData> spResultData(spConsole);
			spResultData->DeleteAllRsltItems();

			HICON icon = LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_DRIVEFIXED));
			if(icon != NULL)
			{
				hr = pImageList->ImageListSetIcon((LONG_PTR*)icon, IDI_DRIVEFIXED);
				if(FAILED(hr))
					ATLTRACE(_T("CLogDriveScopeNode::ImageListSetIcon failed\n"));
			}
			break;
		}
	}
	return hr;
}
//----------------------------------------------------------------
HRESULT CStorageNodeExt::GetDataHere(FORMATETC* pformatetc, STGMEDIUM* pmedium)
{
	ATLTRACE(_T("SnapInDataObjectImpl::GetDataHere\n"));
	if (pmedium == NULL)
		return E_POINTER;

	CLIPFORMAT MACHINE_NAME = (CLIPFORMAT) RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");
	ULONG uWritten = 0;
	HRESULT hr = DV_E_TYMED;
	// Make sure the type medium is HGLOBAL
	if (pmedium->tymed == TYMED_HGLOBAL)
	{
		// Create the stream on the hGlobal passed in
		CComPtr<IStream> spStream;
		hr = CreateStreamOnHGlobal(pmedium->hGlobal, FALSE, &spStream);
		if (SUCCEEDED(hr))
			if (pformatetc->cfFormat == CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA)
			{
				hr = DV_E_CLIPFORMAT;
				ULONG uWritten;
				hr = spStream->Write(&m_objectData, sizeof(CObjectData), &uWritten);
			}
			else if (pformatetc->cfFormat == MACHINE_NAME)
			{
				hr = spStream->Write(m_MachineName, (wcslen(m_MachineName) + 1) * sizeof(OLECHAR), &uWritten);
			}
			else
			{
				hr = m_objectData.m_pItem->FillData(pformatetc->cfFormat, spStream);
			}

	}
	return hr;
}

//--------------------------------------------------------------------------------
wchar_t* CStorageNodeExt::MachineName()
{
	Extract(m_pDataObject, L"MMC_SNAPIN_MACHINE_NAME", m_MachineName);
    return m_MachineName;
}

//==============================================================
//=================== STATIC NODE ==============================
HRESULT CNSDrive::LoadIcon(CComPtr<IImageList> &spImageList, 
						   UINT resID)
{
	HRESULT hr = 0;
	HICON icon = ::LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(resID));
	if(icon != NULL)
	{
		hr = spImageList->ImageListSetIcon((LONG_PTR*)icon, resID);
		if(FAILED(hr))
			ATLTRACE(_T("CLogDriveScopeNode::ImageListSetIcon failed\n"));
	}
	return hr;
}

//-----------------------------------------------------------------
HRESULT CNSDrive::Initialize(LPUNKNOWN pUnknown)
{
	HRESULT hr = IComponentDataImpl<CNSDrive, CNSDriveComponent >::Initialize(pUnknown);
	if(FAILED(hr))
		return hr;

	CComPtr<IImageList> spImageList;

	if(m_spConsole->QueryScopeImageList(&spImageList) != S_OK)
	{
		ATLTRACE(_T("IConsole::QueryScopeImageList failed\n"));
		return E_UNEXPECTED;
	}

	LoadIcon(spImageList, IDI_DRIVEFIXED);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\nsdrive.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __NSDRIVE_H_
#define __NSDRIVE_H_

#include "resource.h"
#include <atlsnap.h>
#include "..\common\SimpleArray.h"
#include "..\common\ServiceThread.h"
#include "..\common\util.h"

class CResultDrive;
class CStorageNodeExt;

void __cdecl ConnectAndRegisterThread(LPVOID lpParameter);
LRESULT CALLBACK AfterConnectProc(HWND hwndDlg,UINT msg, 
								  WPARAM wParam, LPARAM lParam);


//==================================================================================
// NOTE: This is the basic node for the scope pane.
class CLogDriveScopeNode : public CSnapInItemImpl<CLogDriveScopeNode>,
							public CComObject<CSnapInDataObjectImpl>

{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

	WbemServiceThread *g_serviceThread;

	CComPtr<IControlbar> m_spControlBar;

	CLogDriveScopeNode(WbemServiceThread *serviceThread = 0,
						bool orig = true);
	virtual ~CLogDriveScopeNode();

    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem);

    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem);

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
						LONG_PTR arg,
						LONG_PTR param,
						IComponentData* pComponentData,
						IComponent* pComponent,
						DATA_OBJECT_TYPES type);


	// KMH: I made these virtual.
	virtual LPOLESTR GetResultPaneColInfo(int nCol);
	virtual void Initialize(void);
	HWND m_afterConnectHwnd;
	HRESULT EnumerateResultChildren();
	HRESULT RefreshResult();
	void ErrorNode();

	IDataObject *m_pDataObject;
	CStorageNodeExt *m_parent;
	CWbemServices m_WbemServices;

protected:

	bool m_bPopulated;
	CSimpleArray<CResultDrive *> m_resultonlyitems;
	wchar_t m_descBar[100];
	bool m_theOriginalServiceThread;
private:
	void WaitNode();
	HRESULT LoadIcon(IImageList *spImageList, 
						UINT resID);

	virtual void PopulateChildren();
	CComPtr<IConsole> m_spConsole;
	CResultDrive* m_waitNode;

	// the titles for the columns over ResultDrive nodes.
	wchar_t m_colName[20];
	wchar_t m_colType[20];
	wchar_t m_colMapping[20];

	wchar_t m_nodeType[50];
	wchar_t m_nodeDesc[100];

};


//==================================================================================
//NOTE: This is the CM Storage node I'm extending.
class CStorageNodeExt : public CSnapInItemImpl<CStorageNodeExt, TRUE>,
							public CComObject<CSnapInDataObjectImpl>
{
private:
	wchar_t m_colType[50];
	wchar_t m_colDesc[100];
	wchar_t m_nodeName[50];
	CLogDriveScopeNode *m_pScopeItem;
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

	CStorageNodeExt()
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
		m_scopeDataItem.displayname = MMC_CALLBACK;
		m_scopeDataItem.nImage = IDI_DRIVEFIXED; 		// May need modification
		m_scopeDataItem.nOpenImage = IDI_DRIVEFIXED; 	// May need modification
		m_scopeDataItem.lParam = (LPARAM) this;

		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
		m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
		m_resultDataItem.str = MMC_CALLBACK;
		m_resultDataItem.nImage = IDI_DRIVEFIXED;		// May need modification
		m_resultDataItem.lParam = (LPARAM) this;

		m_pScopeItem = NULL;
		memset(m_nodeName, 0, 50 * sizeof(wchar_t));
		if(::LoadString(HINST_THISDLL, IDS_SHORT_NAME, m_nodeName, 50) == 0)
		{
			wcscpy(m_nodeName, L"Logical Drives");
		}
	}

	~CStorageNodeExt()
	{
		if(m_pScopeItem)
		{
			try
			{
				delete m_pScopeItem;
				m_pScopeItem = NULL;
			}
			catch(...)
			{}
		}
	}

	IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		// Modify to return a different CSnapInItem* pointer.
		return pDefault;
	}

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
						LONG_PTR arg,
						LONG_PTR param,
						IComponentData* pComponentData,
						IComponent* pComponent,
						DATA_OBJECT_TYPES type);

	STDMETHOD(GetDataHere)(FORMATETC* pformatetc, STGMEDIUM* pmedium);
	wchar_t* MachineName();
	wchar_t m_MachineName[100];

};

//========================================================================
class CNSDrive;

class CNSDriveComponent : public CComObjectRootEx<CComSingleThreadModel>,
	public CSnapInObjectRoot<2, CNSDrive >,
	public IExtendPropertySheetImpl<CNSDriveComponent>,
    public IExtendContextMenuImpl<CNSDriveComponent>,
	public IComponentImpl<CNSDriveComponent>
{
public:
	BEGIN_COM_MAP(CNSDriveComponent)
		COM_INTERFACE_ENTRY(IComponent)
		COM_INTERFACE_ENTRY(IExtendPropertySheet)
		COM_INTERFACE_ENTRY(IExtendContextMenu)
	END_COM_MAP()

public:
	CNSDriveComponent()
	{
	}

	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, 
						LONG_PTR arg, LONG_PTR param)
	{
		if (lpDataObject != NULL)
			return IComponentImpl<CNSDriveComponent>::Notify(lpDataObject, event, arg, param);
		// TODO : Add code to handle notifications that set lpDataObject == NULL.
		return E_NOTIMPL;
	}
    STDMETHOD(CompareObjects)( LPDATAOBJECT lpDataObjectA,
								LPDATAOBJECT lpDataObjectB)
	{
		CSnapInItem *alpha = NULL, *beta = NULL;
		DATA_OBJECT_TYPES able, baker;

		HRESULT hr = GetDataClass(lpDataObjectA, &alpha, &able);
		hr = GetDataClass(lpDataObjectB, &beta, &baker);
		return (alpha == beta ? S_OK : S_FALSE);
	}
};

//======================================================================
class CNSDrive : public CComObjectRootEx<CComSingleThreadModel>,
					public CSnapInObjectRoot<1, CNSDrive>,
					public IComponentDataImpl<CNSDrive, CNSDriveComponent>,
					public CComCoClass<CNSDrive, &CLSID_NSDrive>,
					public ISnapinHelp
{
public:
	CNSDrive()
	{
		m_pNode = new CLogDriveScopeNode;
		_ASSERTE(m_pNode != NULL);
		m_pComponentData = this;
	}

	~CNSDrive()
	{
		try {
			delete m_pNode;
		} catch(...) {}
		m_pNode = NULL;
	}

EXTENSION_SNAPIN_DATACLASS(CStorageNodeExt)

BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CNSDrive)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CStorageNodeExt)
END_EXTENSION_SNAPIN_NODEINFO_MAP()

BEGIN_COM_MAP(CNSDrive)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()


DECLARE_NOT_AGGREGATABLE(CNSDrive)


	//DECLARE_REGISTRY_RESOURCEID(IDR_NSDRIVE)
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
	{
		HRESULT hr;
		TCHAR pName[100] = {0};
		if(::LoadString(_Module.GetModuleInstance(), IDS_DISPLAY_NAME, 
			pName, 100) <= 0)
		{
			wcscpy(pName, _T("Logical and Mapped Drives"));
		}

		TCHAR dispName[100] = {0};
        TCHAR szModule[_MAX_PATH];
        ::GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
        _stprintf( dispName,_T("@%s,-%d"), szModule, IDS_DISPLAY_NAME);

		
		_ATL_REGMAP_ENTRY regMap[] = {{ OLESTR("PRETTYNAME"), pName },
										{ OLESTR("NAMESTRINGINDIRECT"),dispName},
										{ 0, 0 }};

		hr = _Module.UpdateRegistryFromResourceD(IDR_NSDRIVE, TRUE, regMap);

		return hr;
	}


    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);

	static void WINAPI ObjectMain(bool bStarting)
	{
		if (bStarting)
			CSnapInItem::Init();

	}

    STDMETHOD(GetHelpTopic)(LPOLESTR *lpCompiledHelpFile)
	{
		if(lpCompiledHelpFile == NULL)
			return E_POINTER;    

		wchar_t helpDir[_MAX_PATH];
		memset(helpDir, 0, _MAX_PATH * sizeof(wchar_t));

		if(GetSystemWindowsDirectory(helpDir, _MAX_PATH) != 0)
		{
			wcscat(helpDir, L"\\Help");
			wcscat(helpDir, L"\\drivprop.chm");

			*lpCompiledHelpFile = reinterpret_cast<LPOLESTR>(
										CoTaskMemAlloc((wcslen(helpDir) + 1) * 
															sizeof(wchar_t)));

			if(*lpCompiledHelpFile == NULL)        
				return E_OUTOFMEMORY;

			USES_CONVERSION;
			wcscpy(*lpCompiledHelpFile, T2OLE((LPTSTR)(LPCTSTR)helpDir));
			return S_OK;
		}
		return E_UNEXPECTED;
	}


private:
	HRESULT LoadIcon(CComPtr<IImageList> &spImageList, 
						   UINT resID);
};

//==================================================================================
class ATL_NO_VTABLE CNSDriveAbout : public ISnapinAbout,
									public CComObjectRoot,
									public CComCoClass< CNSDriveAbout, &CLSID_NSDriveAbout>
{
public:
	DECLARE_REGISTRY(CNSDriveAbout, _T("NSDriveAbout.1"), _T("NSDriveAbout.1"), IDS_NSDRIVE_DESC, THREADFLAGS_BOTH);

	BEGIN_COM_MAP(CNSDriveAbout)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

	STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
	{
		USES_CONVERSION;
		TCHAR szBuf[256] = {0};
		if (::LoadString(_Module.GetResourceInstance(), IDS_DESCRIPTION, szBuf, 256) == 0)
			return E_FAIL;

		*lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpDescription == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpDescription, T2OLE(szBuf));

		return S_OK;
	}

    STDMETHOD(GetProvider)(LPOLESTR *lpName)
	{
		USES_CONVERSION;
		TCHAR szBuf[256] = {0};
		if (::LoadString(_Module.GetResourceInstance(), IDS_NSDRIVE_PROVIDER, szBuf, 256) == 0)
			return E_FAIL;

		*lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpName == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpName, T2OLE(szBuf));

		return S_OK;
	}

    STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
	{
		USES_CONVERSION;
		TCHAR szBuf[256] = {0};
		if (::LoadString(_Module.GetResourceInstance(), IDS_NSDRIVE_VERSION, szBuf, 256) == 0)
			return E_FAIL;

		*lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpVersion == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpVersion, T2OLE(szBuf));

		return S_OK;
	}

    STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
	{
		*hAppIcon = LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_DRIVEFIXED));
		return S_OK;
	}

    STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage,
									HBITMAP *hSmallImageOpen,
									HBITMAP *hLargeImage,
									COLORREF *cMask)
	{
		*hSmallImageOpen = *hSmallImage = LoadBitmap(_Module.GetResourceInstance(), 
													MAKEINTRESOURCE(IDB_NSDRIVE_16));
		
		*hLargeImage = LoadBitmap(_Module.GetResourceInstance(), 
									MAKEINTRESOURCE(IDB_NSDRIVE_32));
		*cMask = RGB(255,255,255);
		return S_OK;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\stdafx.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\resultnode.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __RESULTDRIVE__
#define __RESULTDRIVE__

#include "DrivesPage.h"
#include "NSDrive.h"
#include "..\common\SshWbemHelpers.h"
#include "aclui.h"

//===============================================================================
//NOTE: This overrides the basic driveData class for those details that
// are different for the result pane nodes.
class CResultDrive : public CSnapInItemImpl<CResultDrive>,
						public CComObject<CSnapInDataObjectImpl>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

	CResultDrive(WbemServiceThread *thread);
	virtual ~CResultDrive();

	virtual bool Initialize(IWbemClassObject *inst);
    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem);
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem);
	virtual LPOLESTR GetResultPaneColInfo(int nCol);

	// CSnapInItemImpl<CLogDriveScopeNode> METHODS
    STDMETHOD(Notify)(MMC_NOTIFY_TYPE event,
						LONG_PTR arg,
						LONG_PTR param,
						IComponentData* pComponentData,
						IComponent* pComponent,
						DATA_OBJECT_TYPES type);

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
									LONG_PTR handle, 
									IUnknown* pUnk,
									DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type);
	HWND m_propSheet;

private:
	HRESULT CreateSecPage(LPPROPERTYSHEETCALLBACK lpProvider);
	HINSTANCE m_AcluiDLL;
	bstr_t m_deviceID;
	bstr_t m_objPath;
	_bstr_t m_bstrDesc;
	_bstr_t m_bstrMapping;
	wchar_t m_descBar[100];
	WbemServiceThread *g_serviceThread;
	CWbemServices m_WbemServices;
	wchar_t m_provider[100];
	_bstr_t m_rawShare;

	bool SelectIcon();
	void MangleProviderName();
	CWbemClassObject m_inst;
	wchar_t m_mangled[255];
	wchar_t m_idiotName[100];
};

#endif __RESULTDRIVE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\resource.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LogDrive.rc
//
#define IDS_CONNECTING                  6
#define IDS_BAD_CONNECT                 7
#define IDS_CLICKME                     8
#define IDS_PLSE_WAIT                   9
#define IDS_ERROR                       10
#define IDS_SNAPIN_TYPE                 11
#define IDS_PROJNAME                    100
#define IDB_NSDRIVE_16                  101
#define IDB_NSDRIVE_32                  102
#define IDS_NSDRIVE_DESC                103
#define IDS_NSDRIVE_PROVIDER            104
#define IDS_NSDRIVE_VERSION             105
#define IDR_NSDRIVE                     106
#define IDB_SID_ICONS                   113
#define IDB_LOCKS                       114
#define IDI_INFOICON                    116
#define IDI_STOPICON                    117
#define IDI_WARNINGICON                 118
#define IDI_WAITING                     119
#define IDR_LOGDRIVERESULT_MENU         201
#define IDC_DRV_FIRST                   1000
#define IDS_DISPLAY_NAME                1000
#define IDC_CUSTOM1                     1000
#define IDS_DRIVELETTER                 1001
#define IDC_MSG                         1001
#define IDS_DESCRIPTION                 1002
#define IDC_ERROR                       1002
#define IDS_SHORT_NAME                  1003
#define IDS_DRIVE_DESCRIPTION           1004
#define IDS_NO_DRIVE                    1005
#define IDS_WRITE_PROTECTED_MEDIA       1006
#define IDS_NO_CIMOM                    1007
#define DLG_DRV_GENERAL                 1010
#define IDI_DRIVE525                    1011
#define IDS_SCOPE_DRIVE_RAM             1012
#define IDI_DRIVE35                     1013
#define IDI_DRIVEREMOVE                 1014
#define IDI_DRIVEFIXED                  1015
#define IDI_DRIVENET                    1016
#define IDI_DRIVENETDISABLED            1017
#define IDI_DRIVECD                     1018
#define IDI_DRIVERAM                    1019
#define IDC_DRV_ICON                    1020
#define IDI_DRIVE8                      1020
#define IDC_DRV_LABEL                   1021
#define IDI_DRIVEUNKN                   1021
#define IDC_DRV_TYPE                    1022
#define IDC_DRV_USEDCOLOR               1023
#define IDC_DRV_FREECOLOR               1024
#define IDC_DRV_USEDMB                  1025
#define IDC_DRV_USEDBYTES               1026
#define IDC_DRV_FREEBYTES               1027
#define IDC_DRV_FREEMB                  1028
#define IDC_DRV_TOTBYTES                1029
#define IDC_DRV_TOTMB                   1030
#define IDC_DRV_PIE                     1031
#define IDC_DRV_LETTER                  1032
#define IDC_DRV_TOTSEP                  1033
#define IDC_DRV_TYPE_TXT                1034
#define IDC_DRV_TOTBYTES_TXT            1035
#define IDC_DRV_USEDBYTES_TXT           1036
#define IDC_DRV_FREEBYTES_TXT           1037
#define IDC_DRV_FS_TXT                  1042
#define IDC_DRV_FS                      1043
#define IDC_DRV_CLEANUP                 1044
#define IDC_SEC_FIRST                   2000
#define DLG_ERROR                       2008
#define IDS_SECURITY                    2032
#define IDS_NAME                        2033
#define IDS_VIEW                        2034
#define IDS_INITDLG_FAILED              2035
#define IDS_OUT_OF_MEMORY               2036
#define IDS_OPERATION_FAILED            2037
#define IDS_SID_UNKNOWN                 2038
#define IDS_SID_DELETED                 2039
#define IDS_TYPE                        2078
#define IDS_NTFS_GENERIC_ALL            2304
#define IDS_NTFS_GENERIC_READ           2305
#define IDS_NTFS_GENERIC_WRITE          2306
#define IDS_NTFS_GENERIC_EXECUTE        2307
#define IDS_NTFS_GENERAL_MODIFY         2308
#define IDS_NTFS_GENERAL_PUBLISH        2309
#define IDS_NTFS_GENERAL_DEPOSIT        2310
#define IDS_NTFS_GENERAL_READ           2311
#define IDS_NTFS_GENERAL_LIST           2312
#define IDS_NTFS_STD_DELETE             2320
#define IDS_NTFS_STD_READ_CONTROL       2321
#define IDS_NTFS_STD_WRITE_DAC          2322
#define IDS_NTFS_STD_WRITE_OWNER        2323
#define IDS_NTFS_STD_SYNCHRONIZE        2324
#define IDS_NTFS_FILE_READ_DATA         2326
#define IDS_NTFS_FILE_WRITE_DATA        2327
#define IDS_NTFS_FILE_APPEND_DATA       2328
#define IDS_NTFS_FILE_READ_EA           2329
#define IDS_NTFS_FILE_WRITE_EA          2330
#define IDS_NTFS_FILE_EXECUTE           2331
#define IDS_NTFS_FILE_DELETE_CHILD      2332
#define IDS_NTFS_FILE_READ_ATTR         2333
#define IDS_NTFS_FILE_WRITE_ATTR        2334
#define IDS_NTFS_FOLDER                 2336
#define IDS_NTFS_FOLDER_SUBITEMS        2337
#define IDS_NTFS_FOLDER_SUBFOLDER       2338
#define IDS_NTFS_FOLDER_FILE            2339
#define IDS_NTFS_SUBITEMS_ONLY          2340
#define IDS_NTFS_SUBFOLDER_ONLY         2341
#define IDS_NTFS_FILE_ONLY              2342
#define IDS_NONE                        2343
#define IDS_BYTES                       10000
#define IDS_ORDERKB                     10001
#define IDS_ORDERMB                     10002
#define IDS_ORDERGB                     10003
#define IDS_ORDERTB                     10004
#define IDS_ORDERPB                     10005
#define IDS_ORDEREB                     10006
#define IDS_MB                          10007
#define IDS_MAXKILLERS                  10008
#define IDS_MAPPING                     10008
#define IDS_LOCAL                       10009
#define IDS_PROVIDER_FMT                10010
#define IDS_SHEET_CAPTION_FMT           10011
#define IDS_LOCAL_DISK                  10012
#define IDS_CANT_LOAD_SEC_DLLS          10013
#define IDS_IDIOT_CAPTION_FMT           10014
#define IDS_UNAVAILABLE                 10015
#define IDS_CD                          10016
#define IDS_CLOSE_SHEETS                10017

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        204
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\resultnode.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "logDrive.h"
#include "ResultNode.h"
#include <winioctl.h>
#include "..\common\util.h"
#include "..\common\ServiceThread.h"
#include "..\MMFUtil\MsgDlg.h"
#include <wbemcli.h>
#include "SI.h"

static const GUID CResultGUID_NODETYPE = 
{ 0x692a8957, 0x1089, 0x11d2, { 0x88, 0x37, 0x0, 0x10, 0x4b, 0x2a, 0xfb, 0x47 } };
const GUID*  CResultDrive::m_NODETYPE = &CResultGUID_NODETYPE;
const OLECHAR* CResultDrive::m_SZNODETYPE = OLESTR("692A8957-1089-11D2-8837-00104B2AFB47");
const OLECHAR* CResultDrive::m_SZDISPLAY_NAME = OLESTR("Result");
const CLSID* CResultDrive::m_SNAPIN_CLASSID = &CLSID_NSDrive;

//-----------------------------------------------------------------------------
CResultDrive::CResultDrive(WbemServiceThread *thread) :
							g_serviceThread(thread),
							m_AcluiDLL(0),
							m_propSheet(0)
{
	// Image indexes may need to be modified depending on the images specific to 
	// the snapin.
	memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
	m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
	m_scopeDataItem.displayname = MMC_CALLBACK;
	m_scopeDataItem.nOpenImage = 0;		// May need modification
	m_scopeDataItem.lParam = (LPARAM) this;

	memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
	m_resultDataItem.str = L"RN";//MMC_CALLBACK;
	m_resultDataItem.nImage = 0;
	m_resultDataItem.lParam = (LPARAM) this;

	memset(m_descBar, 0, 100 * sizeof(wchar_t));
	if(::LoadString(HINST_THISDLL, IDS_DRIVE_DESCRIPTION, m_descBar, 100) == 0)
	{
		wcscpy(m_descBar, L"Detailed information about the selected drive");
	}

	m_WbemServices = g_serviceThread->GetPtr();
}

//-----------------------------------------------------------------------------
CResultDrive::~CResultDrive()
{
	if(m_propSheet)
	{
		::SendMessage(m_propSheet, WM_COMMAND, MAKEWPARAM(IDCANCEL,0),0);
	}
	m_propSheet = 0;
}

//-----------------------------------------------------------------------------
bool CResultDrive::Initialize(IWbemClassObject *inst)
{
	m_inst = inst;

	m_bstrDisplayName = (BSTR)m_inst.GetString("Name");
	m_bstrMapping = L"Local";

	TCHAR temp[50] = {0};
	if(::LoadString(HINST_THISDLL, IDS_LOCAL, temp, 50) > 0)
	{
		m_bstrMapping = temp;
	}

	ATLTRACE(L"Result %s using %x\n", m_bstrDisplayName, this);
	SelectIcon();
	return true;
}

//------------------------------------------------------------------
HRESULT CResultDrive::GetScopePaneInfo(SCOPEDATAITEM *pScopeDataItem)
{
	if(pScopeDataItem->mask & SDI_STR)
		pScopeDataItem->displayname = m_bstrDisplayName;
	if(pScopeDataItem->mask & SDI_IMAGE)
		pScopeDataItem->nImage = m_scopeDataItem.nImage;
	if(pScopeDataItem->mask & SDI_OPENIMAGE)
		pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
	if(pScopeDataItem->mask & SDI_PARAM)
		pScopeDataItem->lParam = m_scopeDataItem.lParam;
	if(pScopeDataItem->mask & SDI_STATE )
		pScopeDataItem->nState = m_scopeDataItem.nState;

	return S_OK;
}

//------------------------------------------------------------------
HRESULT CResultDrive::GetResultPaneInfo(RESULTDATAITEM *pResultDataItem)
{
	if(pResultDataItem->bScopeItem)
	{
		if(pResultDataItem->mask & RDI_STR)
		{
			pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
		}
		if(pResultDataItem->mask & RDI_IMAGE)
		{
			pResultDataItem->nImage = m_scopeDataItem.nImage;
		}
		if(pResultDataItem->mask & RDI_PARAM)
		{
			pResultDataItem->lParam = m_scopeDataItem.lParam;
		}

		return S_OK;
	}

	if(pResultDataItem->mask & RDI_STR)
	{
		pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
	}
	if(pResultDataItem->mask & RDI_IMAGE)
	{
		pResultDataItem->nImage = m_resultDataItem.nImage;
	}
	if(pResultDataItem->mask & RDI_PARAM)
	{
		pResultDataItem->lParam = m_resultDataItem.lParam;
	}
	if(pResultDataItem->mask & RDI_INDEX)
	{
		pResultDataItem->nIndex = m_resultDataItem.nIndex;
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
bool CResultDrive::SelectIcon()
{
	// NOTE: The CLogDriveScopeNode loads the icons using the resID as the idx.

	// NOTE: Called by the enumerator template.
	if(m_inst)
	{
		BYTE driveType = (BYTE)m_inst.GetLong(_T("DriveType"));

		CWbemClassObject cls = m_WbemServices.GetObject(m_inst.GetString(_T("__CLASS")),
														0x20000); //WBEM_FLAG_USE_AMENDED_QUALIFIERS);
		
		switch(driveType)
		{
		case DRIVE_REMOVABLE: // The disk can be removed from the drive. 
			{//BEGIN

				// NOTE: Only removeables resort to MediaType.
				long mediaType = Unknown;
				variant_t temp;
				HRESULT hr = m_inst.Get(_T("mediatype"), temp);
				
				// zip drives will do this.
				if(temp.vt == VT_NULL)
				{
					hr = E_FAIL;  // just to force the following code path.
				}

				if(SUCCEEDED(hr))
				{
					mediaType = V_I4(&temp);

					// what size of removeable media?
					switch(mediaType)
					{
					case F3_1Pt44_512:           // 3.5",  1.44MB, 512 bytes/sector
					case F3_2Pt88_512:           // 3.5",  2.88MB, 512 bytes/sector
					case F3_20Pt8_512:           // 3.5",  20.8MB, 512 bytes/sector
					case F3_720_512:             // 3.5",  720KB,  512 bytes/sector
					case F3_120M_512:            // 3.5",  120M Floppy
						m_resultDataItem.nImage = IDI_DRIVE35;
						break;

					case F5_1Pt2_512:            // 5.25", 1.2MB,  512 bytes/sector
					case F5_360_512:             // 5.25", 360KB,  512 bytes/sector
					case F5_320_512:             // 5.25", 320KB,  512 bytes/sector
					case F5_320_1024:            // 5.25", 320KB,  1024 bytes/sector
					case F5_180_512:             // 5.25", 180KB,  512 bytes/sector
					case F5_160_512:             // 5.25", 160KB,  512 bytes/sector
						m_resultDataItem.nImage = IDI_DRIVE525;
						break;

					case Unknown:                // Format is unknown
					case RemovableMedia:         // Removable media other than floppy
					case FixedMedia:             // Fixed hard disk media
					default:
						m_resultDataItem.nImage = IDI_DRIVEREMOVE;
						break;
					} //endswitch mediaType

					if(cls)
					{
						cls.GetValueMap(_T("MediaType"), mediaType, m_bstrDesc);
					}
					else
					{
						m_bstrDesc = m_inst.GetString("Description");
					}
				}
				else // fall back to a generic removeable drive. NT hates ZIPs. :)
				{
					m_resultDataItem.nImage = IDI_DRIVEREMOVE;
					if(cls)
					{
						cls.GetValueMap(_T("DriveType"), driveType, m_bstrDesc);
					}
					else
					{
						m_bstrDesc = m_inst.GetString("Description");
					}

				}

			} //END

			break; // driveType

		case DRIVE_FIXED: // The disk cannot be removed from the drive. 
			m_resultDataItem.nImage = IDI_DRIVEFIXED;
			if(cls)
			{
				cls.GetValueMap(_T("DriveType"), driveType, m_bstrDesc);
			}
			else
			{
				m_bstrDesc = m_inst.GetString("Description");
			}
			break;

		case DRIVE_REMOTE: // The drive is a remote (network) drive. 
			m_resultDataItem.nImage = IDI_DRIVENET;
			if(cls)
			{
				cls.GetValueMap(_T("DriveType"), driveType, m_bstrDesc);
			}
			else
			{
				m_bstrDesc = m_inst.GetString("Description");
			}

			break;

		case DRIVE_CDROM:  // The drive is a CD-ROM drive. 
			m_resultDataItem.nImage = IDI_DRIVECD;
			if(cls)
			{
				cls.GetValueMap(_T("DriveType"), driveType, m_bstrDesc);
			}
			else
			{
				m_bstrDesc = m_inst.GetString("Description");
			}
			break;

		case DRIVE_RAMDISK: 
			m_resultDataItem.nImage = IDI_DRIVERAM;
			if(cls)
			{
				cls.GetValueMap(_T("DriveType"), driveType, m_bstrDesc);
			}
			else
			{
				m_bstrDesc = m_inst.GetString("Description");
			}
			break;

		default: break;
		} // endswitch driveType;
	}
	MangleProviderName();
	return true;
}

//-----------------------------------------------------------------------------
void CResultDrive::MangleProviderName()
{
	HRESULT hr = 0;
	_variant_t v1;
	TCHAR fmt[20] = {0};
	wchar_t clean[100] = {0}, share[100] = {0};

	memset(m_provider, 0, 100 * sizeof(wchar_t));
	memset(m_mangled, 0, 255 * sizeof(wchar_t));

	if(m_inst)
	{
		hr = m_inst->Get(L"ProviderName", 0, &v1, NULL, NULL);

		// "" means local. Otherwise mangle the name.
		if(v1.vt == VT_BSTR)
		{
			// mangle "\\machine\share" into "share on 'machine'"
			m_rawShare = V_BSTR(&v1);

			// get the formatting string.
			if(::LoadString(HINST_THISDLL, IDS_PROVIDER_FMT, fmt, 20) == 0)
			{
				// oops, load a reasonable default fmt.
				_tcscpy(fmt, _T("%1 on '%2'"));
			}
			// NOTE: some kinda format loaded now.

			_wsplitpath(m_rawShare, NULL, m_provider, share, NULL);

			wcsncpy(clean, &m_provider[2], wcslen(&m_provider[2]) - 1);

			long *args[] = {(long*)&share[0], (long *)&clean[0]};

			FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
				          fmt, 0, 0, m_mangled, ARRAYSIZE(m_mangled),
					       (va_list *)&args);

			m_bstrMapping = m_mangled;
		}
		else if(m_resultDataItem.nImage == IDI_DRIVENET)
		{
			int x = LoadString(HINST_THISDLL, IDS_UNAVAILABLE, m_mangled, 255);
			m_bstrMapping = m_mangled;
		}
	}
}

//-----------------------------------------------------------------------------
HRESULT CResultDrive::Notify( MMC_NOTIFY_TYPE event,
								LONG_PTR arg,
								LONG_PTR param,
								IComponentData* pComponentData,
								IComponent* pComponent,
								DATA_OBJECT_TYPES type)
{
	// Add code to handle the different notifications.
	// Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
	// In response to MMCN_SHOW you have to enumerate both the scope
	// and result pane items.

	// For MMCN_EXPAND you only need to enumerate the scope items
	// Use IConsoleNameSpace::InsertItem to insert scope pane items
	// Use IResultData::InsertItem to insert result pane item.

	HRESULT hr = E_NOTIMPL;
	
	_ASSERTE(pComponentData != NULL || pComponent != NULL);

	CComPtr<IConsole> spConsole;
	CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeader;

	if(pComponentData != NULL)
		spConsole = ((CNSDrive*)pComponentData)->m_spConsole;
	else
	{
		spConsole = ((CNSDriveComponent*)pComponent)->m_spConsole;
		spHeader = spConsole;
	}

	switch(event)
	{
	case MMCN_CONTEXTHELP:
		{
			WCHAR topic[] = L"drivprop.chm::/drivprop_overview.htm";
			CComQIPtr<IDisplayHelp, &IID_IDisplayHelp> displayHelp(spConsole);

			LPOLESTR lpCompiledHelpFile = reinterpret_cast<LPOLESTR>(
										CoTaskMemAlloc((wcslen(topic) + 1) * 
															sizeof(wchar_t)));

			if(lpCompiledHelpFile == NULL)
			{
				hr = E_OUTOFMEMORY;
			}
			else
			{
				USES_CONVERSION;
				wcscpy(lpCompiledHelpFile, T2OLE((LPTSTR)(LPCTSTR)topic));
				hr = displayHelp->ShowTopic(lpCompiledHelpFile);
			}
		}
		break;

	case MMCN_SELECT:
		{
			CComQIPtr<IResultData, &IID_IResultData> spResultData(spConsole);
			spResultData->SetDescBarText(m_descBar);

			IConsoleVerb *menu = NULL;
			if(SUCCEEDED(spConsole->QueryConsoleVerb(&menu)))
			{
				menu->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
				menu->SetDefaultVerb(MMC_VERB_PROPERTIES);
			}
			break;
		}

		// NOTE: The CLogDriveScopeNode loads the icons using the resID as the idx.

	case MMCN_DBLCLICK:
		hr = S_FALSE; // do the default verb. (Properties)
		break;

	} //endswitch

	return hr;
}

//-----------------------------------------------------------------------------
LPOLESTR CResultDrive::GetResultPaneColInfo(int nCol)
{
	switch(nCol)
	{
	case 0:
		return m_bstrDisplayName;
		break;
	case 1:
		return m_bstrDesc;
		break;
	case 2:
		return m_bstrMapping;
		break;
	} //endswitch nCol

	return OLESTR("missed one in CResultDrive::GetResultPaneColInfo");
}

//-----------------------------------------------------------------------------
HRESULT CResultDrive::QueryPagesFor(DATA_OBJECT_TYPES type)
{
	if(type == CCT_RESULT)
		return S_OK;

	return S_FALSE;
}

//-----------------------------------------------------------------------------
HRESULT CResultDrive::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
											LONG_PTR handle, 
											IUnknown* pUnk,
											DATA_OBJECT_TYPES type)
{
	if(type == CCT_RESULT)
	{
        HRESULT        hr = S_OK;
		CWbemClassObject inst2;
		bstr_t temp;
		ATLTRACE(L"drive factory Enum\n");

		if((bool)m_WbemServices)
		{
			IWbemServices *service;
			m_WbemServices.GetServices(&service);
			m_WbemServices.SetBlanket(service);

			// get the expensive version.
			m_objPath = m_inst.GetString("__PATH");
			inst2 = m_WbemServices.GetObject(m_objPath); 

			service->Release();

			// if it's still there...
			if(inst2 != NULL)
			{
				m_deviceID = inst2.GetString("DeviceID");
				// instance the class for the pages.
				DrivesPage *dvPg = new DrivesPage(g_serviceThread, 
													inst2, 
													m_resultDataItem.nImage,
													&m_propSheet,
													m_bstrDesc,
													m_mangled,
													handle,
													true);
				

				lpProvider->AddPage(dvPg->Create());

				bool hasAcls = false;
				bstr_t fs;
				variant_t temp;

				inst2.Get("FileSystem", temp);


				// if its a null FS from a non-removeable drive...
				if((temp.vt == VT_NULL) && 
				   ((m_resultDataItem.nImage == IDI_DRIVEFIXED) ||
				    (m_resultDataItem.nImage == IDI_DRIVENET)
				   )
				  )
				{
					// check Win32_directory...
					CWbemClassObject dirInst;
					TCHAR objPath[100] = {0};
					_tcscpy(objPath, L"Win32_Directory=\"");
					_tcscat(objPath, (LPCTSTR)m_deviceID);
					_tcscat(objPath, L"\\\\\"");
					dirInst = m_WbemServices.GetObject(objPath);

					// not found implies the null FS was caused by accessDenied on the "FileSystem" property.
					// acessDenied with only happen if the volume security protection to deny you. A FAT drive
					// would have let you in cuz it cant keep you out. Hows that for deductive reasoning. :)
					if(!(bool)dirInst)
					{
						hasAcls = true;
					}
				}
				else if(temp.vt != VT_NULL)
				{
					// cast to bstr_t
					fs = temp;

					if(fs == (bstr_t)_T("NTFS"))  // actually says its NTFS.
					{
						hasAcls = true;
					}
				}
				// NOTE: This doesn't account for future FSs (non-NTFS) having security.
				// A null FS from a REMOVEABLE drive (meaning its removed right now)
				// will leave fs as blank & hasAcls == false (no security tab).


				// security tab if the volume has security.
				if(hasAcls)
				{
					CreateSecPage(lpProvider);
					// NOTE: Ignore any error. Atleast you'll get the "general" page.
				}
				
				LONG_PTR x = m_resultDataItem.lParam;
			}
			else // it went away.
			{
				TCHAR caption[50] = {0}, text[500] = {0};

				::LoadString(HINST_THISDLL, 
								IDS_DISPLAY_NAME,
								caption, 50);

				::LoadString(HINST_THISDLL, 
								IDS_NO_DRIVE,
								text, 500);

				MessageBox(NULL, text, caption,
							MB_OK | MB_ICONHAND);

				hr = E_UNEXPECTED;

			} //endif inst2 != NULL;
		}
        return hr;
	}

	return E_UNEXPECTED;
}

//-----------------------------------------------------------------------------
typedef HPROPSHEETPAGE (WINAPI *CREATEPAGE_PROC) (LPSECURITYINFO);

HRESULT CResultDrive::CreateSecPage(LPPROPERTYSHEETCALLBACK lpProvider)
{
	HRESULT hr = S_OK;

	if(m_AcluiDLL == NULL)
	{
		m_AcluiDLL = LoadLibrary(L"aclui.dll");
		if(m_AcluiDLL == NULL)
		{
			DWORD e = GetLastError();
		}
	}

	if(m_AcluiDLL == NULL)
	{
		// dont have both so give up.
		if(m_AcluiDLL != NULL)
		{
			FreeLibrary(m_AcluiDLL);
		}
		// TODO: error msg.
		TCHAR caption[50] = {0}, text[500] = {0};

		::LoadString(HINST_THISDLL, 
						IDS_DISPLAY_NAME,
						caption, 50);

		::LoadString(HINST_THISDLL, 
						IDS_CANT_LOAD_SEC_DLLS,
						text, 500);

		::MessageBox(NULL, text, caption,
					MB_OK | MB_ICONHAND);
		return S_OK;
	}
	else
	{
		CREATEPAGE_PROC createPage = (CREATEPAGE_PROC)GetProcAddress(m_AcluiDLL, "CreateSecurityPage");
		if(createPage)
		{
			CSecurity *pSecInfo = new CSecurity;

			if(pSecInfo)
			{
				pSecInfo->AddRef();
				// give the SI the "context" from this result node.
				pSecInfo->Initialize(g_serviceThread,
									m_inst, m_deviceID,
									m_idiotName, m_provider,
									m_mangled);
;
				HPROPSHEETPAGE hPage = createPage(pSecInfo);
				if(hPage)
					lpProvider->AddPage(hPage);
				else
					hr = HRESULT_FROM_WIN32(GetLastError());
			}
		}
		else
		{
			// TODO: couldnt get the exported routines.
		}

	}// m_AcluiDLL != NULL
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\unknown.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef _unknown_h
#define _unknown_h


// Global count of number of active objects

extern LONG g_cRefCount;
#define GLOBAL_REFCOUNT     (g_cRefCount)


// CUnknown

typedef struct
{
    const IID* piid;            // interface ID
    LPVOID  pvObject;           // pointer to the object
} INTERFACES, * LPINTERFACES;

class CUnknown 
{
    protected:
        LONG m_cRefCount;

    public:
        CUnknown();
        virtual ~CUnknown();
        
        STDMETHODIMP         HandleQueryInterface(REFIID riid, LPVOID* ppvObject, LPINTERFACES aInterfaces, int cif);
        STDMETHODIMP_(ULONG) HandleAddRef();
        STDMETHODIMP_(ULONG) HandleRelease();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\si.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "SI.h"
#include "..\common\util.h"
#include "..\common\ServiceThread.h"
#include "..\MMFUtil\MsgDlg.h"
#include "resource.h"
#include <winbase.h>

//----------------------------------------------------------------------------
EXTERN_C const GUID IID_ISecurityInformation =
	{ 0x965fc360, 0x16ff, 0x11d0, 0x91, 0xcb, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x23 };

#define MY_FILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED                    \
                            | SYNCHRONIZE                               \
                            | FILE_READ_DATA    | FILE_LIST_DIRECTORY   \
                            | FILE_WRITE_DATA   | FILE_ADD_FILE         \
                            | FILE_APPEND_DATA  | FILE_ADD_SUBDIRECTORY \
                            | FILE_CREATE_PIPE_INSTANCE                 \
                            | FILE_READ_EA                              \
                            | FILE_WRITE_EA                             \
                            | FILE_EXECUTE      | FILE_TRAVERSE         \
                            | FILE_DELETE_CHILD                         \
                            | FILE_READ_ATTRIBUTES                      \
                            | FILE_WRITE_ATTRIBUTES)

#if(FILE_ALL_ACCESS != MY_FILE_ALL_ACCESS)
#error ACL editor needs to sync with file permissions changes in ntioapi.h (or ntioapi.h is broken)
#endif

#define INHERIT_FULL            (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE)

//
// Treat SYNCHRONIZE specially. In particular, always allow SYNCHRONIZE and
// never Deny SYNCHRONIZE. Do this by removing it from the Generic Mapping,
// turning it off in all ACEs and SI_ACCESS entries, and then adding it to
// all Allow ACEs before saving a new ACL.
//
#define FILE_GENERIC_READ_      (FILE_GENERIC_READ    & ~SYNCHRONIZE)
#define FILE_GENERIC_WRITE_     (FILE_GENERIC_WRITE   & ~(SYNCHRONIZE | READ_CONTROL))
#define FILE_GENERIC_EXECUTE_   (FILE_GENERIC_EXECUTE & ~SYNCHRONIZE)
#define FILE_GENERIC_ALL_       (FILE_ALL_ACCESS      & ~SYNCHRONIZE)

#define FILE_GENERAL_MODIFY     (FILE_GENERIC_READ_  | FILE_GENERIC_WRITE_ | FILE_GENERIC_EXECUTE_ | DELETE)
#define FILE_GENERAL_PUBLISH    (FILE_GENERIC_READ_  | FILE_GENERIC_WRITE_ | FILE_GENERIC_EXECUTE_)
#define FILE_GENERAL_DEPOSIT    (FILE_GENERIC_WRITE_ | FILE_GENERIC_EXECUTE_)
#define FILE_GENERAL_READ_EX    (FILE_GENERIC_READ_  | FILE_GENERIC_EXECUTE_)

// The following array defines the permission names for NTFS objects.
SI_ACCESS siNTFSAccesses[] =
{
    { &GUID_NULL, FILE_GENERIC_ALL_,    MAKEINTRESOURCE(IDS_NTFS_GENERIC_ALL),      SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_GENERAL_MODIFY,  MAKEINTRESOURCE(IDS_NTFS_GENERAL_MODIFY),   SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_GENERAL_READ_EX, MAKEINTRESOURCE(IDS_NTFS_GENERAL_READ),     SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_GENERAL_READ_EX, MAKEINTRESOURCE(IDS_NTFS_GENERAL_LIST),     SI_ACCESS_CONTAINER | CONTAINER_INHERIT_ACE },
    { &GUID_NULL, FILE_GENERIC_READ_,   MAKEINTRESOURCE(IDS_NTFS_GENERIC_READ),     SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_GENERIC_WRITE_,  MAKEINTRESOURCE(IDS_NTFS_GENERIC_WRITE),    SI_ACCESS_GENERAL | INHERIT_FULL },
    { &GUID_NULL, FILE_EXECUTE,         MAKEINTRESOURCE(IDS_NTFS_FILE_EXECUTE),     SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_READ_DATA,       MAKEINTRESOURCE(IDS_NTFS_FILE_READ_DATA),   SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_READ_ATTRIBUTES, MAKEINTRESOURCE(IDS_NTFS_FILE_READ_ATTR),   SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_READ_EA,         MAKEINTRESOURCE(IDS_NTFS_FILE_READ_EA),     SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_WRITE_DATA,      MAKEINTRESOURCE(IDS_NTFS_FILE_WRITE_DATA),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_APPEND_DATA,     MAKEINTRESOURCE(IDS_NTFS_FILE_APPEND_DATA), SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_WRITE_ATTRIBUTES,MAKEINTRESOURCE(IDS_NTFS_FILE_WRITE_ATTR),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, FILE_WRITE_EA,        MAKEINTRESOURCE(IDS_NTFS_FILE_WRITE_EA),    SI_ACCESS_SPECIFIC },
#if(FILE_CREATE_PIPE_INSTANCE != FILE_APPEND_DATA)
    { &GUID_NULL, FILE_CREATE_PIPE_INSTANCE, MAKEINTRESOURCE(IDS_NTFS_FILE_CREATE_PIPE), SI_ACCESS_SPECIFIC },
#endif
    { &GUID_NULL, FILE_DELETE_CHILD,    MAKEINTRESOURCE(IDS_NTFS_FILE_DELETE_CHILD),SI_ACCESS_SPECIFIC },
    { &GUID_NULL, DELETE,               MAKEINTRESOURCE(IDS_NTFS_STD_DELETE),       SI_ACCESS_SPECIFIC },
    { &GUID_NULL, READ_CONTROL,         MAKEINTRESOURCE(IDS_NTFS_STD_READ_CONTROL), SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_DAC,            MAKEINTRESOURCE(IDS_NTFS_STD_WRITE_DAC),    SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_OWNER,          MAKEINTRESOURCE(IDS_NTFS_STD_WRITE_OWNER),  SI_ACCESS_SPECIFIC },
//    { &GUID_NULL, SYNCHRONIZE,          MAKEINTRESOURCE(IDS_NTFS_STD_SYNCHRONIZE),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, 0,                    MAKEINTRESOURCE(IDS_NONE),                  0 },
    { &GUID_NULL, FILE_GENERIC_EXECUTE_,MAKEINTRESOURCE(IDS_NTFS_GENERIC_EXECUTE),  0 },
    { &GUID_NULL, FILE_GENERAL_DEPOSIT, MAKEINTRESOURCE(IDS_NTFS_GENERAL_DEPOSIT),  0 },
    { &GUID_NULL, FILE_GENERAL_PUBLISH, MAKEINTRESOURCE(IDS_NTFS_GENERAL_PUBLISH),  0 },
};
#define iNTFSDefAccess      2   // FILE_GENERAL_READ_EX


// The following array defines the inheritance types for NTFS directories.
SI_INHERIT_TYPE siNTFSInheritTypes[] =
{
    &GUID_NULL, 0,                                                             MAKEINTRESOURCE(IDS_NTFS_FOLDER),
    &GUID_NULL, CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,                    MAKEINTRESOURCE(IDS_NTFS_FOLDER_SUBITEMS),
    &GUID_NULL, CONTAINER_INHERIT_ACE,                                         MAKEINTRESOURCE(IDS_NTFS_FOLDER_SUBFOLDER),
    &GUID_NULL, OBJECT_INHERIT_ACE,                                            MAKEINTRESOURCE(IDS_NTFS_FOLDER_FILE),
    &GUID_NULL, INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE, MAKEINTRESOURCE(IDS_NTFS_SUBITEMS_ONLY),
    &GUID_NULL, INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE,                      MAKEINTRESOURCE(IDS_NTFS_SUBFOLDER_ONLY),
    &GUID_NULL, INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE,                         MAKEINTRESOURCE(IDS_NTFS_FILE_ONLY),
};

GENERIC_MAPPING NTFSMap =
{
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_ALL_ACCESS
};

//---------------------------------------------------------------
CSecurity::CSecurity() :m_initingDlg(false), 
						g_serviceThread(0)
{
	m_dwprevSize = 0;
	m_prevTokens = NULL;
	m_prevBuffer = NULL;

}

//---------------------------------------------------------------
void CSecurity::Initialize(WbemServiceThread *serviceThread,
						CWbemClassObject &inst,
						bstr_t deviceID,
						LPWSTR idiotName,
						LPWSTR provider,
						LPWSTR mangled)
{
	m_deviceID = deviceID;
	wcsncpy(m_idiotName, idiotName, 100);
	wcsncpy(m_provider, provider, 100);
	wcsncpy(m_mangled, mangled, 255);

	g_serviceThread = serviceThread;
	m_inst = inst;
}

//------------------ Accessors to the above arrays---------------
//---------------------------------------------------------------
HRESULT CSecurity::MapGeneric(const GUID *pguidObjectType,
								  UCHAR *pAceFlags,
								  ACCESS_MASK *pMask)
{
	ATLASSERT(pMask);

    MapGenericMask(pMask, &NTFSMap);
   *pMask &= ~SYNCHRONIZE;

	return S_OK;
}

//-----------------------------------------------------------------------------
HRESULT CSecurity::GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
										ULONG *pcInheritTypes)
{
    ATLASSERT(ppInheritTypes != NULL);
    ATLASSERT(pcInheritTypes != NULL);

    *ppInheritTypes = siNTFSInheritTypes;
    *pcInheritTypes = ARRAYSIZE(siNTFSInheritTypes);

	return S_OK;
}

//-----------------------------------------------------------------------------
#define ALL_SECURITY_ACCESS (READ_CONTROL | WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY)

DWORD CSecurity::GetAccessMask(CWbemClassObject &inst)
{
	CWbemClassObject paramCls, dummy;

	DWORD dwAccessGranted = 0;
    DWORD dwAccessDesired[] = { ALL_SECURITY_ACCESS,
                                READ_CONTROL,
                                WRITE_DAC,
                                WRITE_OWNER,
                                ACCESS_SYSTEM_SECURITY};

	paramCls = m_WbemServices.GetObject("CIM_LogicalFile");

	if(paramCls)
	{
		CWbemClassObject param;
		CWbemClassObject setting;

		HRESULT hr = paramCls.GetMethod(L"GetEffectivePermission", param, dummy);

		if(SUCCEEDED(hr) && (bool)param)
		{
			bstr_t path(L"CIM_LogicalFile=\"");
			path += m_deviceID;
			path += L"\\\\\"";

			for(int i = 0; i < ARRAYSIZE(dwAccessDesired); i++)
			{
				if((dwAccessDesired[i] & dwAccessGranted) == dwAccessDesired[i])
					continue;   // already have this access

				CWbemClassObject retCls;

				hr = S_OK;
				hr = param.Put(L"Permissions", (long)dwAccessDesired[i]);

				if(SUCCEEDED(hr))
				{
					hr = m_WbemServices.ExecMethod(path, 
													L"GetEffectivePermission",
													param, retCls);
					if(SUCCEEDED(hr))
					{
						// extract the real error code.
						bool granted = retCls.GetBool("ReturnValue");

						if(granted)
							dwAccessGranted |= dwAccessDesired[i];
					}
				}

			} //endfor

		} //endif (SUCCEEDED
	}

	return dwAccessGranted;
}

//-----------------------------------------------------------------------------
#define ALL_SI (OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION|\
				DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION)


// NOTE: To efficiently get the SD ONLY ONCE, GetObjectInformation calls 
// CacheSecurity() which keeps and SD ptr in m_ppCachedSD. GetSecurity()
// simply returns this pointer and zero's m_ppCachedSD. Aclui will clean up
// the actually memory as usual.
HRESULT CSecurity::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
{
    ATLASSERT(pObjectInfo != NULL &&
             !IsBadWritePtr(pObjectInfo, sizeof(*pObjectInfo)));

	wchar_t fmt[100];
	_bstr_t temp;
    _bstr_t driveName;
	TCHAR driveLtr[3] = {0};
    TCHAR szTemp[30] = {0};
	HRESULT hr = S_OK;

	if(m_initingDlg)
	{
		memset(fmt, 0, 100 * sizeof(wchar_t));
		memset(m_idiotName, 0, 100 * sizeof(wchar_t));

		HRESULT hr2 = E_FAIL;
		IWbemServices *service = 0;

		if(g_serviceThread)
		{
			m_WbemServices = g_serviceThread->GetPtr();
			m_WbemServices.GetServices(&service);
			SetPriv(service);

			// NOTE: This also sets m_hAccessToken as a side effect.
			hr2 = CacheSecurity(ALL_SI, (PSECURITY_DESCRIPTOR *)&m_ppCachedSD, false);
		}

		if(SUCCEEDED(hr2) && (bool)m_inst)
		{
			DWORD granted = 0;

			pObjectInfo->dwFlags |= SI_EDIT_ALL |		// dacl, sacl, owner pages.
									SI_ADVANCED;	// more than generic rights.
									
			granted = GetAccessMask(m_inst);

		    if (!(granted & WRITE_DAC))
				pObjectInfo->dwFlags |= SI_READONLY;

			if (!(granted & WRITE_OWNER))
			{
				if (!(granted & READ_CONTROL))
					pObjectInfo->dwFlags &= ~SI_EDIT_OWNER;
				else
					pObjectInfo->dwFlags |= SI_OWNER_READONLY;
			}

			if (!(granted & ACCESS_SYSTEM_SECURITY))
				pObjectInfo->dwFlags &= ~SI_EDIT_AUDITS;


			pObjectInfo->dwFlags |= SI_NO_ACL_PROTECT |	// no parent.
									 SI_CONTAINER;		// it's a container since I
														// only do the root dir.

			long driveType = m_inst.GetLong(L"DriveType");
			
			// if its a network connection (remote)....
			if(driveType == 4)
			{
				// use the leftovers from the mangling routine.
				pObjectInfo->pszServerName = CloneWideString(m_provider);
			}
			else
			{
				bstr_t server;
				server = m_inst.GetString(L"__SERVER");
				pObjectInfo->pszServerName = CloneWideString(server);
			}

			driveName = m_inst.GetString("Name");
			
			// isolate the drive letter for later.
			_tcsncpy(driveLtr, driveName, driveName.length());
		}
		else
		{
			pObjectInfo->pszServerName = NULL;
		}

		ClearPriv(service);

		pObjectInfo->hInstance = HINST_THISDLL;

		if(::LoadString(HINST_THISDLL, 
						IDS_IDIOT_CAPTION_FMT,
						fmt, 100) == 0)
		{
			wcscpy(fmt, L"%s (%c:)");
		}


		// if its locally mapped...
		if(wcslen(m_mangled) == 0)
		{
			// format sheet caption using volumeName (temp).
			if(temp.length() == 0)
			{
				// if not volume name... just say "Local Disk".
				if(::LoadString(HINST_THISDLL, 
								IDS_LOCAL_DISK,
								szTemp, 30) == 0)
				{
					wcscpy(szTemp, L"Local Disk");
				}
				temp = szTemp;
			}
			swprintf(m_idiotName, fmt, (wchar_t *)temp, driveLtr[0]);
		}
		else
		{
			// format sheet caption using m_mangled. (network drives)
			swprintf(m_idiotName, fmt, m_mangled, driveLtr[0]);
		}
		pObjectInfo->pszObjectName = m_idiotName;
	}
	else  // just the initial creation.
	{
		// its only looking for the _TITLE bit which we dont set anyway.
		pObjectInfo->dwFlags = 0;		
	}

    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CSecurity::GetAccessRights(const GUID *pguidObjectType,
									  DWORD dwFlags,
									  PSI_ACCESS *ppAccess,
									  ULONG *pcAccesses,
									  ULONG *piDefaultAccess)
{
	ATLASSERT(ppAccess);
	ATLASSERT(pcAccesses);
	ATLASSERT(piDefaultAccess);

    *ppAccess = siNTFSAccesses;
    *pcAccesses = ARRAYSIZE(siNTFSAccesses);
    *piDefaultAccess = iNTFSDefAccess;

	return S_OK;
}

//------------------ Real workers -------------------------------
//---------------------------------------------------------------
void CSecurity::SetPriv(IWbemServices *service)
{
    ImpersonateSelf(SecurityImpersonation);

	if(OpenThreadToken( GetCurrentThread(), 
						TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
						FALSE, &m_hAccessToken ) )
	{
		m_fClearToken = true;

		// Now, get the LUID for the privilege from the local system
		ZeroMemory(&m_luid, sizeof(m_luid));
		ZeroMemory(&m_luid, sizeof(m_luid2));

		LookupPrivilegeValue(NULL, SE_SECURITY_NAME, &m_luid);
		LookupPrivilegeValue(NULL, SE_TAKE_OWNERSHIP_NAME, &m_luid2);
		m_WbemServices.m_cloak = true;

		EnablePriv(service, true);
	}
	else
	{
		DWORD err = GetLastError();
	}
}

//---------------------------------------------------------------
#define EOAC_DYNAMIC_CLOAKING 0x40

DWORD CSecurity::EnablePriv(IWbemServices *service, bool fEnable )
{
	DWORD				dwError = ERROR_SUCCESS;
	DWORD				dwSize = 2 * sizeof(TOKEN_PRIVILEGES);
	BYTE				*buffer; 
	BYTE				*prevbuffer; 
	TOKEN_PRIVILEGES	*tokenPrivileges;

	//Itz better to save the previous state and restore it on EnablePriv(...,false);

	if((fEnable == false) && (m_prevTokens != NULL))
	{
		dwSize = m_dwprevSize;
		buffer = new BYTE[dwSize];
		tokenPrivileges = (TOKEN_PRIVILEGES*)buffer;
		memcpy(tokenPrivileges,m_prevTokens,dwSize);
	}
	else
	{
		buffer = new BYTE[dwSize];
		tokenPrivileges = (TOKEN_PRIVILEGES*)buffer;
		tokenPrivileges->PrivilegeCount = 2;
		tokenPrivileges->Privileges[0].Luid = m_luid;
		tokenPrivileges->Privileges[0].Attributes = (fEnable ? SE_PRIVILEGE_ENABLED : 0);
		tokenPrivileges->Privileges[1].Luid = m_luid2;
		tokenPrivileges->Privileges[1].Attributes = (fEnable ? SE_PRIVILEGE_ENABLED : 0);
		if(m_prevTokens != NULL)
		{
			delete []m_prevBuffer;
			m_prevTokens = NULL;
		}
		m_dwprevSize = 0;
		//Find the size of the PrevState Buffer
		AdjustTokenPrivileges(m_hAccessToken, 
								FALSE, 
								tokenPrivileges, 
								dwSize, 
								m_prevTokens, &m_dwprevSize);
		m_prevBuffer = new BYTE[m_dwprevSize];
		m_prevTokens = (TOKEN_PRIVILEGES*)m_prevBuffer;
	}

	if(AdjustTokenPrivileges(m_hAccessToken, 
								FALSE, 
								tokenPrivileges, 
								dwSize, 
								m_prevTokens, &m_dwprevSize))
	{
		long lRes = GetLastError();

		IClientSecurity* pSec;
		HRESULT hres = service->QueryInterface(IID_IClientSecurity, (void**)&pSec);
		if(FAILED(hres))
		{
			return E_FAIL;
		}

		hres = pSec->SetBlanket(service, RPC_C_AUTHN_WINNT,
						RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CONNECT,
						RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_DYNAMIC_CLOAKING);
		pSec->Release();

	}
	else
	{
		dwError = ::GetLastError();
	}

	delete[] buffer;

	if(fEnable == false)
	{
		delete []m_prevBuffer;
		m_prevTokens = NULL;
	}

	return dwError;
}

//---------------------------------------------------------------
void CSecurity::ClearPriv(IWbemServices *service)
{

	EnablePriv(service, false);
	m_WbemServices.m_cloak = false;

	if(m_fClearToken)
	{
		CloseHandle(m_hAccessToken);
		m_hAccessToken = 0;
		m_fClearToken = false;
	}
}

//---------------------------------------------------------------
#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))
#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

void CSecurity::ProtectACLs(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD)
{
    SECURITY_DESCRIPTOR_CONTROL wSDControl;
    DWORD dwRevision;
    PACL pAcl;
    BOOL bDefaulted;
    BOOL bPresent;
    PACE_HEADER pAce;
    UINT cAces;


    if (0 == si || NULL == pSD)
        return;   // Nothing to do

    // Get the ACL protection control bits
    GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision);
    wSDControl &= SE_DACL_PROTECTED | SE_SACL_PROTECTED;

    if ((si & DACL_SECURITY_INFORMATION) && !(wSDControl & SE_DACL_PROTECTED))
    {
        wSDControl |= SE_DACL_PROTECTED;
        pAcl = NULL;
        GetSecurityDescriptorDacl(pSD, &bPresent, &pAcl, &bDefaulted);

        // Theoretically, modifying the DACL in this way can cause it to be
        // no longer canonical.  However, the only way this can happen is if
        // there is an inherited Deny ACE and a non-inherited Allow ACE.
        // Since this function is only called for root objects, this means
        // a) the server DACL must have a Deny ACE and b) the DACL on this
        // object must have been modified later.  But if the DACL was
        // modified through the UI, then we would have eliminated all of the
        // Inherited ACEs already.  Therefore, it must have been modified
        // through some other means.  Considering that the DACL originally
        // inherited from the server never has a Deny ACE, this situation
        // should be extrememly rare.  If it ever does happen, the ACL
        // Editor will just tell the user that the DACL is non-canonical.
        //
        // Therefore, let's ignore the possibility here.

        if (NULL != pAcl)
        {
            for (cAces = pAcl->AceCount, pAce = (PACE_HEADER)FirstAce(pAcl);
                 cAces > 0;
                 --cAces, pAce = (PACE_HEADER)NextAce(pAce))
            {
                pAce->AceFlags &= ~INHERITED_ACE;
            }
        }
    }

    if ((si & SACL_SECURITY_INFORMATION) && !(wSDControl & SE_SACL_PROTECTED))
    {
        wSDControl |= SE_SACL_PROTECTED;
        pAcl = NULL;
        GetSecurityDescriptorSacl(pSD, &bPresent, &pAcl, &bDefaulted);

        if (NULL != pAcl)
        {
            for (cAces = pAcl->AceCount, pAce = (PACE_HEADER)FirstAce(pAcl);
                 cAces > 0;
                 --cAces, pAce = (PACE_HEADER)NextAce(pAce))
            {
                pAce->AceFlags &= ~INHERITED_ACE;
            }
        }
    }

    SetSecurityDescriptorControl(pSD, SE_DACL_PROTECTED | SE_SACL_PROTECTED, wSDControl);
}

//---------------------------------------------------------------
HRESULT CSecurity::GetSecurity(THIS_ SECURITY_INFORMATION RequestedInformation,
									PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
									BOOL fDefault )
{
    if(fDefault)
	{
        ATLTRACE(L"Default security descriptor not supported");
		return E_NOTIMPL;
	}

	// NOTE: After apply, aclui comes right here. When initially starting up, it'll go
	// through GetObjectInformation() first.

	// so, make sure to get a fresh SD from AFTER to apply.
	if(m_ppCachedSD == 0)
	{
		HRESULT hr2 = CacheSecurity(ALL_SI, (PSECURITY_DESCRIPTOR *)&m_ppCachedSD, false);
	}

	// if there's an SD available...
	if(m_ppCachedSD && SUCCEEDED(m_cacheHR))
	{
		// give ownership of the ptr.
		*ppSecurityDescriptor = m_ppCachedSD;
		m_ppCachedSD = NULL;
	} 
	return m_cacheHR;
}

//---------------------------------------------------------------
HRESULT CSecurity::CacheSecurity(THIS_ SECURITY_INFORMATION RequestedInformation,
									PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
									BOOL fDefault )
{
    ATLASSERT(ppSecurityDescriptor != NULL);

    *ppSecurityDescriptor = NULL;

	// does it want something?
    if(RequestedInformation != 0)
    {
		CWbemClassObject dummy, setting, param;

		// call wbem.GetSecurityDescriptor() method
		m_settingPath = L"Win32_LogicalFileSecuritySetting=\"";
		m_settingPath += m_deviceID;
		m_settingPath += L"\\\\\"";

		m_cacheHR = m_WbemServices.ExecMethod(m_settingPath, 
										L"GetSecurityDescriptor",
										dummy, param);

		if(SUCCEEDED(m_cacheHR))
		{
			setting = param.GetEmbeddedObject("Descriptor");

			if(setting)
			{
				// translate SD to CInstance
				m_sec.Wbem2SD(RequestedInformation,
								setting, 
								m_WbemServices, 
								(SECURITY_DESCRIPTOR **)ppSecurityDescriptor);

				SECURITY_DESCRIPTOR **test = (SECURITY_DESCRIPTOR **)ppSecurityDescriptor;

			}
			else
			{
				return E_NOTIMPL;
			}
		}
		else
		{
			DisplayUserMessage(NULL, HINST_THISDLL,
								IDS_DISPLAY_NAME, BASED_ON_SRC, 
								GetSecurityDescriptor,
								m_cacheHR, MB_ICONWARNING);
		    return m_cacheHR;
		}
    }
    else
    {
        *ppSecurityDescriptor = LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);

        if(*ppSecurityDescriptor)
            InitializeSecurityDescriptor(*ppSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);
        else
            m_cacheHR = E_OUTOFMEMORY;
    }

    ProtectACLs(RequestedInformation & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION), 
				*ppSecurityDescriptor);

    return m_cacheHR;
}

//
// See comments about SYNCHRONIZE at the top of this file
//
void CSecurity::FixSynchronizeAccess(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD)
{
    if (NULL != pSD && 0 != (si & DACL_SECURITY_INFORMATION))
    {
        BOOL bPresent;
        BOOL bDefault;
        PACL pDacl = NULL;

        GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefault);

        if (pDacl)
        {
            PACE_HEADER pAce;
            int i;

            for (i = 0, pAce = (PACE_HEADER)FirstAce(pDacl);
                 i < pDacl->AceCount;
                 i++, pAce = (PACE_HEADER)NextAce(pAce))
            {
                if (ACCESS_ALLOWED_ACE_TYPE == pAce->AceType)
                    ((ACCESS_ALLOWED_ACE *)pAce)->Mask |= SYNCHRONIZE;
            }
        }
    }
}


//-----------------------------------------------------------------------------
HRESULT CSecurity::SetSecurity(SECURITY_INFORMATION SecurityInformation,
									PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
	HRESULT hr = S_OK;

	try 
	{
		// since taking ownership grants implicit WRITE_DAC access, which may
		// be helpful when a new DACL is propagated downward.
	//    if ((SecurityInformation & (OWNER_SECURITY_INFORMATION | SI_OWNER_RECURSE))
	//            == (OWNER_SECURITY_INFORMATION | SI_OWNER_RECURSE))
	//    {
	//        BOOL bNotAllApplied = FALSE;

			// dont pass the SI_OWNER_RECURSE bit to wbem.
			SecurityInformation &= ~(SI_OWNER_RECURSE);

			// wbem cant do recursive ownership.
	//        hr = TakeOwnership(pSD, &bNotAllApplied);

	//        if (FAILED(hr) || bNotAllApplied)
	//        {
	//			ATLTRACE(L"Unable to take ownership of all items in tree.");
	//        }

	//    }

		// if something was changed...
		if(SecurityInformation != 0)
		{
			CWbemClassObject dummy, paramCls;

			paramCls = m_WbemServices.GetObject("Win32_LogicalFileSecuritySetting");

			if(paramCls)
			{
				CWbemClassObject param;
				CWbemClassObject setting;

				hr = paramCls.GetMethod(L"SetSecurityDescriptor",
										param, dummy);

				if(SUCCEEDED(hr) && (bool)param)
				{
			        // See comments about SYNCHRONIZE at the top of this file.
					if(SecurityInformation & DACL_SECURITY_INFORMATION)
						FixSynchronizeAccess(SecurityInformation, pSecurityDescriptor);

					// translate SD to CInstance
					m_sec.SD2Wbem(SecurityInformation,
									(SECURITY_DESCRIPTOR *)pSecurityDescriptor, 
									m_WbemServices,
									setting);

					hr = S_OK;
					hr = param.PutEmbeddedObject(L"Descriptor", setting);
					if(SUCCEEDED(hr))
					{

						IWbemServices *service;
						m_WbemServices.GetServices(&service);

						// NOTE: m_settingPath was built during GetSecurity.

						// call wbem.SetSecurityDescriptor() method
						SetPriv(service);
						hr = m_WbemServices.ExecMethod(m_settingPath, 
														L"SetSecurityDescriptor",
														param, dummy);
						if(SUCCEEDED(hr))
						{
							// extract the real error code.
							DWORD err = (DWORD)dummy.GetLong("ReturnValue");

							// NOTE: there's a issue about which error values should be
							// returned in 'returnValue'. 
							if(err == 0x5)
							{
								// Access Denied at the OS level.
								DisplayUserMessage(NULL, HINST_THISDLL,
													IDS_DISPLAY_NAME, BASED_ON_SRC, 
													SetSecurityDescriptor,
													WBEM_E_ACCESS_DENIED, MB_ICONWARNING);

							}
						}

						ClearPriv(service);
						service->Release();
						service = NULL;
					}
				}
				else
				{
					hr = E_FAIL;
				}
			}
			else
			{
				hr = WBEM_E_INVALID_METHOD;
			}
		}
	}
	catch( ... )
	{
		ATLASSERT(FALSE);
		hr = WBEM_E_UNEXPECTED;
	}

    return hr;
}

//-----------------------------------------------------------------------------
HRESULT CSecurity::PropertySheetPageCallback(HWND hwnd, 
												  UINT uMsg, 
												  SI_PAGE_TYPE uPage)
{
	if(uMsg == PSPCB_SI_INITDIALOG)
	{
		// make GetObjectInformation() cache the SD cuz we're going to display RSN.
		m_initingDlg = true;
	}
	else if((uMsg == PSPCB_CREATE) || uMsg == 0)
	{
	}
	else if(uMsg == PSPCB_RELEASE)
	{
	}

    return S_OK;
}
//---------------------------------------------------
LPWSTR CSecurity::CloneWideString(_bstr_t pszSrc ) 
{
    LPWSTR pszDst = NULL;

    pszDst = new WCHAR[(lstrlen(pszSrc) + 1)];
    if (pszDst) 
	{
        wcscpy( pszDst, pszSrc );
    }

    return pszDst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\si.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __SI__
#define __SI__

#include "..\common\ServiceThread.h"
#include "..\common\SshWbemHelpers.h"
#include "FakeSecuritySetting.h"
#include "aclui.h"

struct __declspec(uuid("965FC360-16FF-11d0-91CB-00AA00BBB723")) ISecurityInformation;

//===============================================================================
class ATL_NO_VTABLE CSecurityInformation : public ISecurityInformation, 
											public CComObjectRoot
{
protected:

    DECLARE_NOT_AGGREGATABLE(CSecurityInformation)
    BEGIN_COM_MAP(CSecurityInformation)
        COM_INTERFACE_ENTRY(ISecurityInformation)
    END_COM_MAP()

  // *** ISecurityInformation methods ***
  STDMETHOD(GetObjectInformation)(PSI_OBJECT_INFO pObjectInfo) = 0;

  STDMETHOD(GetSecurity) (THIS_ SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault ) = 0;

  STDMETHOD(SetSecurity)(SECURITY_INFORMATION SecurityInformation,
						 PSECURITY_DESCRIPTOR pSecurityDescriptor) = 0;

  STDMETHOD(GetAccessRights)(const GUID  *pguidObjectType,
							  DWORD       dwFlags,
							  PSI_ACCESS  *ppAccess,
							  ULONG       *pcAccesses,
							  ULONG       *piDefaultAccess) = 0;

  STDMETHOD(MapGeneric)(const GUID  *pguidObjectType,
						  UCHAR       *pAceFlags,
						  ACCESS_MASK *pMask) = 0;

  STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE  *ppInheritTypes,
								ULONG *pcInheritTypes) = 0;

  STDMETHOD(PropertySheetPageCallback)(HWND hwnd, 
									  UINT uMsg, 
									  SI_PAGE_TYPE  uPage) = 0;

	bstr_t m_settingPath;
};

//===============================================================================
class CSecurity : public CComObject<CSecurityInformation>
{
public:
	CSecurity();

	void Initialize(WbemServiceThread *serviceThread,
					CWbemClassObject &m_inst,
					bstr_t m_deviceID,
					LPWSTR m_idiotName,
					LPWSTR m_provider,
					LPWSTR m_mangled);
	
	// *** ISecurityInformation methods ***
	STDMETHOD(GetObjectInformation)(PSI_OBJECT_INFO pObjectInfo);

    STDMETHOD(GetSecurity) (THIS_ SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault);

	STDMETHOD(SetSecurity)(SECURITY_INFORMATION SecurityInformation,
						 PSECURITY_DESCRIPTOR pSecurityDescriptor);

	STDMETHOD(GetAccessRights)(const GUID *pguidObjectType,
							  DWORD       dwFlags,
							  PSI_ACCESS  *ppAccess,
							  ULONG       *pcAccesses,
							  ULONG       *piDefaultAccess);

	STDMETHOD(MapGeneric)(const GUID  *pguidObjectType,
						  UCHAR       *pAceFlags,
						  ACCESS_MASK *pMask);

	STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE *ppInheritTypes,
								ULONG *pcInheritTypes);

	STDMETHOD(PropertySheetPageCallback)(HWND hwnd, 
									  UINT uMsg, 
									  SI_PAGE_TYPE uPage);

protected:
	// NOTE: From ResultDrive
	bstr_t m_deviceID;
	wchar_t m_idiotName[100];
	wchar_t m_provider[100];
	wchar_t m_mangled[255];

	//Variables required for storing the initial previlege
	DWORD m_dwprevSize;
	TOKEN_PRIVILEGES* m_prevTokens;
	BYTE *m_prevBuffer;

	WbemServiceThread *g_serviceThread;
	CWbemClassObject m_inst;  //of Win32_logicalDisk
	
	//-------------------------
	CWbemServices m_WbemServices;
	HRESULT m_cacheHR;
	bool m_initingDlg;

	FakeSecuritySetting m_sec;	

	void SetPriv(IWbemServices *service);
	DWORD EnablePriv(IWbemServices *service,
						bool fEnable);
	void ClearPriv(IWbemServices *service);

	HANDLE m_hAccessToken;
	LUID m_luid, m_luid2;
	bool m_fClearToken;

	PSECURITY_DESCRIPTOR m_ppCachedSD;

	LPWSTR CloneWideString(_bstr_t pszSrc);

	void ProtectACLs(SECURITY_INFORMATION si, 
						PSECURITY_DESCRIPTOR pSD);
	DWORD GetAccessMask(CWbemClassObject &inst);

    STDMETHOD(CacheSecurity)(THIS_ SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault );
	void FixSynchronizeAccess(SECURITY_INFORMATION si, 
								PSECURITY_DESCRIPTOR pSD);

};

#endif __SI__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\logdrive\strings.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __strings_h
#define __strings_h

HRESULT LocalAllocString(LPTSTR* ppResult, LPCTSTR pString);
HRESULT LocalAllocStringLen(LPTSTR* ppResult, UINT cLen);
void    LocalFreeString(LPTSTR* ppString);
HRESULT LocalQueryString(LPTSTR* ppResult, HKEY hk, LPCTSTR lpSubKey);

//HRESULT StrRetFromString(LPSTRRET lpStrRet, LPCTSTR pString);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\mmfutil\precomp.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED_)
#define AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif

#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
};

extern CExeModule  _Module;

#include <atlcom.h>
#include <atlwin.h>


#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif



//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\mmfutil\declspec.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
//#define TRACKING 

// If we are building a the  DLL then define the 
// class as exporteded otherwise its inmported
// ============================================
#ifndef COREPOL_HEADERFILE_IS_INCLUDED
#define COREPOL_HEADERFILE_IS_INCLUDED
//#pragma message( "Including DECLSPEC.H..." )


 #ifdef BUILDING_DLL
//  #pragma message( "Building static library or DLL..." )
  #define POLARITY __declspec( dllexport )
 #else 
 // #pragma message( "Building Client..." )
  #define POLARITY __declspec( dllimport )
 #endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\mmfutil\msgdlg.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __MSGDLGEXTERNS__
#define __MSGDLGEXTERNS__

#include "DeclSpec.h"

// pick icon based on severity code.
#define BASED_ON_HRESULT 0	// use with uType
#define BASED_ON_SRC 0		// use with ERROR_SRC

typedef enum {
	ConnectServer = 1,
	PutInstance = 2,
	GetSecurityDescriptor = 3,
	SetSecurityDescriptor = 4,
} ERROR_SRC;

POLARITY int DisplayUserMessage(HWND hWnd,
							HINSTANCE inst,
							UINT caption, 
							UINT clientMsg, 
							ERROR_SRC src,
							HRESULT sc, 
							UINT uType = BASED_ON_HRESULT);

POLARITY int DisplayUserMessage(HWND hWnd,
								LPCTSTR lpCaption,
								LPCTSTR lpClientMsg,
								ERROR_SRC src,
								HRESULT sc,
								UINT uType = BASED_ON_HRESULT);

// NOTE: send WM_USER + 1 to make it go away.
POLARITY INT_PTR DisplayAVIBox(HWND hWnd,
							LPCTSTR lpCaption,
							LPCTSTR lpClientMsg,
							HWND *boxHwnd);

#endif __MSGDLGEXTERNS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\mmfutil\msgdlg.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// MsgDlg.cpp : Defines the initialization routines for the DLL.
//

#include "precomp.h"
#include "MsgDlg.h"
#include "wbemError.h"
#include "resource.h"
#include "commctrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//------------------------------------------------------------
POLARITY int DisplayUserMessage(HWND hWnd,
							HINSTANCE inst,
							UINT caption, 
							UINT clientMsg, 
							ERROR_SRC src,
							HRESULT sc, 
							UINT uType)
{
	//EXTASSERT(inst);
	//EXTASSERT(caption);

	TCHAR tCaption[100] = {0};
	TCHAR tClientMsg[256] = {0};
	DWORD resError = 0;

	if(LoadString(inst, caption, tCaption, 100) == 0)
	{
		return 0;
	}
	if(clientMsg == BASED_ON_SRC)
	{
		HINSTANCE UtilInst = GetModuleHandle(_T("MMFUtil.dll"));
		WCHAR resName[16] = {0};

		// FMT: "S<src>E<sc>"
		wsprintf(resName, L"S%dE%x", src, sc);

		if(_wcsicmp(resName,L"S1E8004100e") == 0)
		{
			LoadString(UtilInst,S1E8004100e,tClientMsg,256);
		}
		else if(_wcsicmp(resName,L"S1E80080005") == 0)
		{
			LoadString(UtilInst,S1E80080005,tClientMsg,256);
		}
		else if(_wcsicmp(resName,L"S4E80041003") == 0)
		{
			LoadString(UtilInst,S4E80041003,tClientMsg,256);
		}
	}
	else 		    // use the one passed in.
	{
		LoadString(inst, clientMsg, tClientMsg, 256);
	}

	return DisplayUserMessage(hWnd, tCaption, 
								(wcslen(tClientMsg) > 0 ? tClientMsg : NULL), 
								src, sc, uType);
}

//------------------------------------------------------------
POLARITY int DisplayUserMessage(HWND hWnd,
								LPCTSTR lpCaption,
								LPCTSTR lpClientMsg,
								ERROR_SRC src,
								HRESULT sc,
								UINT uType)
{
#define MAX_MSG 512

	TCHAR errMsg[MAX_MSG] = {0};
   UINT sevIcon = 0;

	if(ErrorStringEx(sc, errMsg, MAX_MSG,
					   &sevIcon))
	{
		// if no icon explicitly selected...
		if(!(uType & MB_ICONMASK))
		{
			// use the recommendation.
			uType |= sevIcon;
		}

		// append the clientmsg if there is one.
		if(lpClientMsg)
		{
			_tcscat(errMsg, _T("\n\n"));
			_tcscat(errMsg, lpClientMsg);
		}

		// do it.
		return MessageBox(hWnd, errMsg,
							lpCaption, uType);
	}
	else
	{
		// failed.
		return 0;
	}
	return 0;
}

//---------------------------------------------------------
typedef struct {
	LPCTSTR lpCaption;
	LPCTSTR lpClientMsg;
	UINT uAnim;
	HWND *boxHwnd;
} ANIMCONFIG;

INT_PTR CALLBACK AnimDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam)
{
	INT_PTR retval = FALSE;
	switch(uMsg)
	{
	case WM_INITDIALOG:
		{//BEGIN
			//lParam = ANIMCONFIG *

			ANIMCONFIG *cfg = (ANIMCONFIG *)lParam;
			*(cfg->boxHwnd) = hwndDlg;

			// save this pointer for the WM_DESTROY.
			SetWindowLongPtr(hwndDlg, DWLP_USER, (LPARAM)cfg->boxHwnd);

			HWND hAnim = GetDlgItem(hwndDlg, IDC_ANIMATE);
			HWND hMsg = GetDlgItem(hwndDlg, IDC_MSG);

			Animate_Open(hAnim, MAKEINTRESOURCE(cfg->uAnim));

			SetWindowText(hwndDlg, cfg->lpCaption);
			SetWindowText(hMsg, cfg->lpClientMsg);

			retval = TRUE;
		}//END
		break;

	case WM_USER + 20:  //WM_ASYNC_CIMOM_CONNECTED
		// the client has completed 'whatever' and I should
		// claim victory and go away now.
		EndDialog(hwndDlg, IDOK);
		break;

	case WM_COMMAND:
		// they're only one button.
		if(HIWORD(wParam) == BN_CLICKED)
		{
			// I'm going away now so anybody that has a ptr to my
			// hwnd (which I gave out in my WM_INITDIALOG) shouldn't
			// use it anymore.
			HWND *me = (HWND *)GetWindowLongPtr(hwndDlg, DWLP_USER);
			*me = 0;
			EndDialog(hwndDlg, IDCANCEL);
		}
		retval = TRUE; // I processed it.
		break;

	case WM_DESTROY:
		{// BEGIN
			// I'm going away now so anybody that has a ptr to my
			// hwnd (which I gave out in my WM_INITDIALOG) shouldn't
			// use it anymore.
			HWND *me = (HWND *)GetWindowLongPtr(hwndDlg, DWLP_USER);
			*me = 0;
			retval = TRUE; // I processed it.
		} //END
		break;

	default:
		retval = FALSE; // I did NOT process this msg.
		break;
	} //endswitch uMsg

	return retval;
}

//---------------------------------------------------------
POLARITY INT_PTR DisplayAVIBox(HWND hWnd,
							LPCTSTR lpCaption,
							LPCTSTR lpClientMsg,
							HWND *boxHwnd)
{
	ANIMCONFIG cfg = {lpCaption, lpClientMsg, IDR_AVIWAIT, boxHwnd};

	return DialogBoxParam(_Module.GetModuleInstance(), 
							MAKEINTRESOURCE(IDD_ANIMATE), 
							hWnd, AnimDlgProc, 
							(LPARAM)&cfg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\mmfutil\precomp.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\servdeps\precomp.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED_)
#define AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif

#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
};

extern CExeModule  _Module;

#include <atlcom.h>
#include <atlwin.h>


#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif



//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__692A894C_1089_11D2_8837_00104B2AFB46__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\mmfutil\wbemerror.cpp ===
//=============================================================================
//
//                              WbemError.cpp
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//	Implements string table based, error msgs for all of wbem.
//
//  History:
//
//      a-khint  5-mar-98       Created.
//
//============================================================================= 
#include "precomp.h"
#include "WbemError.h"
#include "resource.h"
#include <wbemcli.h>

//--------------PUBLIC-----------------------------
#define TEMP_BUF 512

POLARITY bool ErrorStringEx(HRESULT hr, 
						   TCHAR *errMsg, UINT errSize,
						   UINT *sevIcon)
{
    WCHAR szError[TEMP_BUF];
	WCHAR szFacility[TEMP_BUF];
    WCHAR szFormat[100];
	IWbemStatusCodeText * pStatus = NULL;

    // initialize buffers.
	errMsg[0] = 0;
	szFacility[0] = 0;
	szError[0] = 0;

	HRESULT hr1 = CoInitialize(NULL);
	SCODE sc1 = CoCreateInstance(CLSID_WbemStatusCodeText, 
								0, CLSCTX_INPROC_SERVER,
								IID_IWbemStatusCodeText, 
								(LPVOID *) &pStatus);

	// loaded OK?
	if(sc1 == S_OK)
	{
		BSTR bstr = 0;
		sc1 = pStatus->GetErrorCodeText(hr, 0, 0, &bstr);
		if(sc1 == S_OK)
		{
			_tcsncpy(szError, bstr, TEMP_BUF-1);
			SysFreeString(bstr);
			bstr = 0;
		}

		sc1 = pStatus->GetFacilityCodeText(hr, 0, 0, &bstr);
		if(sc1 == S_OK)
		{
			_tcsncpy(szFacility, bstr, TEMP_BUF-1);
			SysFreeString(bstr);
			bstr = 0;
		}

		// RELEASE
		pStatus->Release();
		pStatus = NULL;
	}
	else
	{
		::MessageBox(NULL, _T("WBEM error features not available. Upgrade WMI to a newer build."),
					 _T("Internal Error"), MB_ICONSTOP|MB_OK);
	}

	// if not msgs returned....
	if(wcslen(szFacility) == 0 || wcslen(szError) == 0)
	{
		// format the error nbr as a reasonable default.
		LoadString(GetModuleHandle(_T("MMFUtil.dll")), IDS_ERROR_UNKN_ERROR_FMT, szFormat, 99);
		_stprintf(errMsg, szFormat, hr);
	}
	else
	{
		// format a readable msg.
		LoadString(GetModuleHandle(_T("MMFUtil.dll")), IDS_ERROR_FMT, szFormat, 99);
		_stprintf(errMsg, szFormat, szFacility, szError);
	}

	// want an icon recommendation with that?
	if(sevIcon)
	{
		switch(SCODE_SEVERITY(hr))
		{
		case 0: // - Success
			*sevIcon = MB_ICONINFORMATION;
			break;
		case 1: //- Failed
			*sevIcon = MB_ICONEXCLAMATION;
			break;
		} //endswitch severity

	} //endif sevIcon

	if(hr1 == S_OK)
		CoUninitialize();

	return (SUCCEEDED(sc1) && SUCCEEDED(hr1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\mmfutil\wbemerror.h ===
#ifndef __WBEMERROR__
#define __WBEMERROR__
//=============================================================================
//
//                              WbemError.h
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//	Implements string table based, error msgs for all of wbem.
//
//  History:
//
//      a-khint  5-mar-98       Created.
//
//============================================================================= 
#include "precomp.h"
#include "DeclSpec.h"

//---------------------------------------------------------
// ErrorString: Extracts convenient information out of the
//				SCODE (HRESULT). If its not a wbem error,
//				system error msgs will be checked.
// Parms:
//		sc - The error code from any facility.
//		errMsg - pointer to an allocated string buffer for
//					the error msg. Can be NULL.
//		errSize - the size of errMsg in chars.
//
//		facility - pointer to an allocated string buffer for
//					the facility name. Can be NULL.
//		facSize - the size of errMsg in chars.
//
//		sevIcon - ptr to receive the appropriate MB_ICON*
//					value for the sc. Can be NULL. Value
//					should be OR'ed with the MessageBox()
//					uType.
//---------------------------------------------------------
extern "C"
{

// formats the facility part for you too.
POLARITY bool ErrorStringEx(HRESULT hr, 
						   TCHAR *errMsg, UINT errSize,
						   UINT *sevIcon = NULL);

}
#endif __WBEMERROR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\mmfutil\resource.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MMFUtil.rc
//
#define IDS_PROJNAME                    100
#define IDD_ANIMATE                     101
#define IDD_DIALOG1                     129
#define IDS_ERROR_UNKN_ERROR_FMT        130
#define IDS_ERROR_FMT                   131
#define IDC_BUTTONADVANCED              1000
#define IDC_ANIMATE                     1000
#define IDC_STATICCLIENTMSG             1001
#define IDC_STATICPROVIDERNAME          1002
#define IDC_STATICOPERATION             1003
#define IDC_STATICPARAMETER             1004
#define IDC_STATICFRAME                 1005
#define IDC_STATICHMOMMSG               1006
#define IDC_CODEPLUSMESSAGE             1007
#define IDC_MYICON                      1009
#define IDC_MSG                         1019
#define IDR_AVIWAIT                     1020
#define S1E8004100e						1021
#define S1E80080005						1022
#define S4E80041003						1023

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         132
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\mmfutil\mmfutil.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// MMFUtil.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f MMFUtilps.mk in the project directory.

#include "precomp.h"
#include "resource.h"
#include "initguid.h"
#include "MMFUtil.h"

#include "MMFUtil_i.c"


CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\servdeps\stdafx.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\servdeps\deppage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "DepPage.h"

// avoid some warnings.
#undef HDS_HORZ
#undef HDS_BUTTONS
#undef HDS_HIDDEN
#include "resource.h"
#include <stdlib.h>
#include <TCHAR.h>
#include "..\Common\util.h"
#include <regstr.h>
#include "..\common\ConnectThread.h"
#include "..\MMFUtil\MsgDlg.h"
#include "winuser.h"


BOOL AfxIsValidAddress(const void* lp, 
							  UINT nBytes, 
							  BOOL bReadWrite)
{
	// simple version using Win-32 APIs for pointer validation.
	return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
		(!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}


const wchar_t *CFServiceName = L"FILEMGMT_SNAPIN_SERVICE_NAME";
const wchar_t *CFServiceDisplayName = L"FILEMGMT_SNAPIN_SERVICE_DISPLAYNAME";


//--------------------------------------------------------------
DependencyPage::DependencyPage(WbemConnectThread *pConnectThread,
								IDataObject *pDataObject, 
								long lNotifyHandle, bool bDeleteHandle, TCHAR* pTitle)
					  : PageHelper(pConnectThread),
						CSnapInPropertyPageImpl<DependencyPage> (pTitle),
						m_lNotifyHandle(lNotifyHandle),
						m_bDeleteHandle(bDeleteHandle),
						m_qLang("WQL"),
						m_NameProp("Name"),
						m_DispNameProp("DisplayName")
{
	m_servIcon = 0;
	m_sysDriverIcon = 0;
	m_emptyIcon = 0;
	m_groupIcon = 0;

	ATLTRACE(L"dependency Page CTOR\n");

	m_queryFormat = new TCHAR[QUERY_SIZE];
	m_queryTemp = new TCHAR[QUERY_SIZE];

	Extract(pDataObject, L"FILEMGMT_SNAPIN_SERVICE_NAME", m_ServiceName);
	Extract(pDataObject, L"FILEMGMT_SNAPIN_SERVICE_DISPLAYNAME", m_ServiceDispName);
}

//--------------------------------------------------------------
DependencyPage::~DependencyPage()
{
	ATLTRACE(L"dependency Page DTOR\n");
	delete[] m_queryFormat;
	delete[] m_queryTemp;
}

//--------------------------------------------------------------
void DependencyPage::BuildQuery(TV_ITEM *fmNode, 
								QUERY_TYPE queryType,
								bool depends, 
								bstr_t &query)
{
	// clean the working space.
	memset(m_queryFormat, 0, QUERY_SIZE * sizeof(TCHAR));
	memset(m_queryTemp, 0, QUERY_SIZE * sizeof(TCHAR));

	// here's the WQL syntax format.
	switch(queryType)
	{
	case DepService:
		wcscpy(m_queryFormat, 
			L"Associators of {Win32_BaseService.Name=\"%s\"} where Role=%s AssocClass=Win32_DependentService");
		
		// build the query for this level.
		wsprintf(m_queryTemp, m_queryFormat, 
								(LPCTSTR)((ITEMEXTRA *)fmNode->lParam)->realName, 
								(depends ? _T("Dependent") : _T("Antecedent")));

		break;
	case DepGroup:
		wcscpy(m_queryFormat, 
			L"Associators of {Win32_BaseService.Name=\"%s\"} where ResultClass=Win32_LoadOrderGroup Role=%s AssocClass=Win32_LoadOrderGroupServiceDependencies");

		// build the query for this level.
		wsprintf(m_queryTemp, m_queryFormat, 
								(LPCTSTR)((ITEMEXTRA *)fmNode->lParam)->realName, 
								(depends ? _T("Dependent") : _T("Antecedent")));		
		break;

	case GroupMember:
		wcscpy(m_queryFormat, 
			L"Associators of {Win32_LoadOrderGroup.Name=\"%s\"} where Role=GroupComponent AssocClass=Win32_LoadOrderGroupServiceMembers");
//			L"Associators of {Win32_LoadOrderGroup.Name=\"%s\"} where ResultClass=Win32_Service Role=GroupComponent AssocClass=Win32_LoadOrderGroupServiceMembers");

		// build the query for this level.
		wsprintf(m_queryTemp, m_queryFormat, 
							(LPCTSTR)((ITEMEXTRA *)fmNode->lParam)->realName);
		break;
	} // endswitch

	// cast to bstr_t and return.
	query = m_queryTemp;
}

//--------------------------------------------------------------
void DependencyPage::LoadLeaves(HWND hTree, TV_ITEM *fmNode, bool depends )
{
	bstr_t query;
	NODE_TYPE nodeType = ((ITEMEXTRA *)fmNode->lParam)->nodeType;
	bool foundIt = false;

//	HourGlass(true);

	switch(nodeType)
	{
	case ServiceNode:
		// NOTE: services can depend on groups but not the
		// other way around.
		if(depends)
		{
			//load groups.
			BuildQuery(fmNode, DepGroup, depends, query);
			foundIt = Load(hTree, fmNode, query, GroupNode);
		}

		// load services.
		BuildQuery(fmNode, DepService, depends, query);
		foundIt |= Load(hTree, fmNode, query, ServiceNode);
		break;

	case GroupNode:
		// NOTE: 'depends' doesn't matter in this case.
		// load group members.
		BuildQuery(fmNode, GroupMember, depends, query);
		foundIt = Load(hTree, fmNode, query, ServiceNode);
		break;

	}//endswitch

	//TODO: Decide opn what to do for this
//	HourGlass(false);

	if(!foundIt)
	{
		NothingMore(hTree, fmNode);
		if(depends)
		{
			if(fmNode->hItem == TVI_ROOT)
			{
				::EnableWindow(GetDlgItem(IDC_DEPENDS_LBL), FALSE);
			}
		}
		else
		{
			if(fmNode->hItem == TVI_ROOT)
			{
				::EnableWindow(GetDlgItem(IDC_NEEDED_LBL), FALSE);
			}
		}
	}
}

//--------------------------------------------------------------
// READ: In 'hTree', run 'query' and make the children
// 'childType' nodes under 'fmNode'.
bool DependencyPage::Load(HWND hTree, TV_ITEM *fmNode, bstr_t query,
							NODE_TYPE childType)
{
	HRESULT  hRes;
	variant_t pRealName, pDispName;
	ULONG uReturned;

	IWbemClassObject *pOther = NULL;
	IEnumWbemClassObject *pEnumOther = NULL;

	TV_INSERTSTRUCT leaf;
	leaf.hInsertAfter = TVI_SORT;
	leaf.hParent = fmNode->hItem;
	bool foundOne = false;

    ATLTRACE(L"query started\n");

	hRes = m_WbemServices.ExecQuery(m_qLang, query,
										WBEM_FLAG_RETURN_IMMEDIATELY |
										WBEM_FLAG_FORWARD_ONLY,
										&pEnumOther);
	//-------------------
	// query for all related services or groups.
	if(hRes == S_OK)
	{
        ATLTRACE(L"query worked %x\n", hRes);
		//-------------------
		// enumerate through services.
		while(SUCCEEDED(hRes = pEnumOther->Next(500, 1, &pOther, &uReturned)))
		{
			if(hRes == WBEM_S_TIMEDOUT)
				continue;

			if(uReturned != 1)
			{
			    ATLTRACE(L"uReturned failed %x: %s \n", hRes, query);
				break;
			}

			foundOne = true;

			//-------------------
			// get the node's name(s).
			switch(childType)
			{
			case ServiceNode:
			    hRes = pOther->Get(m_DispNameProp, 0, &pDispName, NULL, NULL);
				hRes = pOther->Get(m_NameProp, 0, &pRealName, NULL, NULL);
				if(SUCCEEDED(hRes))
				{
				    hRes = pOther->Get(m_DispNameProp, 0, &pDispName, NULL, NULL);
				}
				break;

			case GroupNode:
				hRes = pOther->Get(m_NameProp, 0, &pRealName, NULL, NULL);
				if(SUCCEEDED(hRes))
				{
					pDispName = pRealName;
				}
				break;

			}// endswitch


			// got the properties ok?
			if(SUCCEEDED(hRes))
			{
				// add the leaf.
				leaf.item.mask =  TVIF_TEXT | TVIF_PARAM | 
									TVIF_CHILDREN |TVIF_IMAGE |TVIF_SELECTEDIMAGE; 
				leaf.item.hItem = 0; 
				leaf.item.state = 0; 
				leaf.item.stateMask = 0; 
				if(pDispName.vt == VT_BSTR)
				{
					leaf.item.pszText = CloneString((bstr_t)pDispName);
				}
				else
				{
					leaf.item.pszText = CloneString((bstr_t)pRealName);
				}
				leaf.item.cchTextMax = ARRAYSIZE(leaf.item.pszText); 

				TCHAR pszCreationClassName[20];
				_tcscpy(pszCreationClassName,_T("CreationClassName"));

				variant_t pCreationName;
				_bstr_t strCreationClassName;

				// set the icon based on 'childType'
				switch(childType)
				{
				case ServiceNode:
					//Here we will have to change the icon depending on whether it is a win32_service or
					//Win32_SystemDriver

					pOther->Get(pszCreationClassName, 0, &pCreationName, NULL, NULL);
					strCreationClassName = pCreationName.bstrVal;

					if(_tcsicmp(strCreationClassName,_T("Win32_Service")) == 0)
					{
						leaf.item.iImage = m_servIcon; 
						leaf.item.iSelectedImage = m_servIcon; 
					}
					else
					{
						leaf.item.iImage = m_sysDriverIcon; 
						leaf.item.iSelectedImage = m_sysDriverIcon; 
					}
					break;

				case GroupNode:
					leaf.item.iImage = m_groupIcon; 
					leaf.item.iSelectedImage = m_groupIcon; 
					break;

				} // endswitch

				// turn on the '+' sign.
				leaf.item.cChildren = 1; 

				// set internal data.
				ITEMEXTRA *extra = new ITEMEXTRA;
                if (extra != NULL)
                {
                    extra->loaded = false;
                    extra->nodeType = childType;
                    // true name.
                    extra->realName = CloneString((bstr_t)pRealName);
                    leaf.item.lParam = (LPARAM) extra;

                    TreeView_InsertItem(hTree, &leaf);

                    // if there is a parent...
                    if(fmNode->hItem != TVI_ROOT)
                    {
                    // indicate that the parent's children have been
                    // loaded.  This helps optimize for collapsing/re-
                    // expanding.
                    fmNode->mask =  TVIF_PARAM | TVIF_HANDLE;
                    ((ITEMEXTRA *)fmNode->lParam)->loaded = true;
                    TreeView_SetItem(hTree, fmNode);
                    }
                }

			} // endif Get() user name

			// done with the ClassObject
			if (pOther)
			{ 
				pOther->Release(); 
				pOther = NULL;
			}

		} //endwhile Next()
			    
		ATLTRACE(L"while %x: %s \n", hRes, (wchar_t *)query);


		// release the enumerator.
		if(pEnumOther)
		{ 
			pEnumOther->Release(); 
			pEnumOther = NULL;
		}
	}
	else
	{
	    ATLTRACE(L"query failed %x: %s \n", hRes, query);

	} //endif ExecQuery()

		// if nothing found...
	return foundOne;
}

//---------------------------------------------------
void DependencyPage::NothingMore(HWND hTree, TV_ITEM *fmNode)
{
	TV_INSERTSTRUCT leaf;
	leaf.hInsertAfter = TVI_SORT;
	leaf.hParent = fmNode->hItem;

	// and its the root...
	if(fmNode->hItem == TVI_ROOT)
	{
		// indicate an 'empty' tree.
		leaf.item.pszText = new TCHAR[100];
		leaf.item.cchTextMax = 100;
		::LoadString(HINST_THISDLL, IDS_NO_DEPS, 
						leaf.item.pszText, 
						leaf.item.cchTextMax);

		leaf.item.mask =  TVIF_TEXT | TVIF_PARAM |
							TVIF_CHILDREN | TVIF_IMAGE |
							TVIF_SELECTEDIMAGE;
		leaf.item.hItem = 0;
		leaf.item.state = 0;
		leaf.item.stateMask = 0; 
		leaf.item.iImage = m_emptyIcon; 
		leaf.item.iSelectedImage = m_emptyIcon; 
		leaf.item.cChildren = 0; 

		ITEMEXTRA *extra = new ITEMEXTRA;
		if(extra == NULL)
			return;
		extra->loaded = false;
		extra->nodeType = ServiceNode;
		extra->realName = NULL; // to be safe during cleanup.
		leaf.item.lParam = (LPARAM) extra;
		TreeView_InsertItem(hTree, &leaf);
		::EnableWindow(hTree, FALSE);
		delete[] leaf.item.pszText;
	}
	else // not the root.
	{
		// Cant drill down anymore.
		// Turn off the [+] symbol.
		fmNode->mask =  TVIF_CHILDREN | TVIF_HANDLE; 
		fmNode->cChildren = 0; 
		TreeView_SetItem(hTree, fmNode);
	}
}

//--------------------------------------------------------------
void DependencyPage::TwoLines(UINT uID, LPCTSTR staticString, LPCTSTR inStr, LPTSTR outStr,bool bStaticFirst)
{
	HWND ctl = ::GetDlgItem(m_hWnd, uID);
	HDC hDC = ::GetDC(ctl);

	//THIS IS A HACK. I COULD NOT CALCULATE THE ACTUAL WIDTH OF THE CONTROL
	//IN LOGICAL UNITS. SO AS OF NOW, CALCULATED MANUALLY AND HARDCODING IT.
	int ctlWidth = 509;
	TCHAR strTemp[1024];
	TCHAR *strCurr;
	int lenstrTemp;
	SIZE sizeTemp;
	int nFit = 0;

	//First we will try whether the whole string fits in the space
	if(bStaticFirst == true)
	{
		_stprintf(strTemp,_T("%s \"%s\""),staticString,inStr);
	}
	else
	{
		_stprintf(strTemp,_T("\"%s\" %s"),inStr,staticString);
	}
	strCurr = strTemp;

	lenstrTemp = lstrlen(strTemp);

	GetTextExtentExPoint(hDC,strTemp,lenstrTemp,ctlWidth,&nFit,NULL,&sizeTemp);

	if(lenstrTemp <= nFit)
	{
		//The whole string will fit in a line. So we will all a \r\n in the beginning
		_stprintf(outStr,_T("\r\n%s"),strTemp);
		return;
	}

	//Now we will try if the whole string atleast fits in 2 lines.
	strCurr += nFit;

	int nFit1;
	lenstrTemp = lstrlen(strCurr);

	GetTextExtentExPoint(hDC,strCurr,lenstrTemp,ctlWidth,&nFit1,NULL,&sizeTemp);

	if(lenstrTemp <= nFit1)
	{
		//The whole string will fit in 2 lines. So we will all a \r\n in the end of the first line

		TCHAR strTemp1[1024];
		_tcsncpy(strTemp1,strTemp,nFit);
		strTemp1[nFit] = _T('\0');
		_stprintf(outStr,_T("%s\r\n%s"),strTemp1,strCurr);
		return;
	}

	//NOW since it won't fit in 2 lines, we will have to do some calculations and
	//add a "..." to the end of the instr so that it will fit in 2 lines.

	//If the static string is in the from, then we can easily do it.
	TCHAR strLast[5];
	_tcscpy(strLast,_T("...\""));
	int sizeLast = lstrlen(strLast);

	SIZE sz1;
	GetTextExtentPoint32(hDC,strLast,sizeLast,&sz1);
	TCHAR strTemp1[1024];
	_tcsncpy(strTemp1,strTemp,nFit);
	strTemp1[nFit] = _T('\0');

	if(bStaticFirst == true)
	{
		TCHAR strTemp2[10];

		//Now take characters from the end of the array and match it until the 
		//width needed to print is greater than the "..."" string
		bool bFit = false;
		int nStart = nFit1 - 4;
		int nStart1;
		SIZE sz2;
		while(bFit == false)
		{
			nStart1 = nStart;
			for(int i=0; i < nFit1 - nStart; i++)
			{
				strTemp2[i] = strCurr[nStart1];
				nStart1 ++;
			}

			strTemp2[i] = _T('\0');

			GetTextExtentPoint32(hDC,strTemp2,nFit1 - nStart,&sz2);

			if(sz2.cx < sz1.cx)
			{
				nStart --;
			}
			else
			{
				break;
			}
		}
		
		strCurr[nStart] = _T('\0');
		_stprintf(outStr,_T("%s\r\n%s%s"),strTemp1,strCurr,strLast);
		return;
	}
	else
	{
		//Now we will have to add strLast to the end of trimmed string.
		//Since it will be the same in the first line, we will first calculate fit1 again.

		SIZE szFinal;
		TCHAR strFinal[1024];

		_stprintf(strFinal,_T("%s %s"),strLast,staticString);

		GetTextExtentPoint32(hDC,strFinal,lstrlen(strFinal),&szFinal);

		//Now subtract szFinal from the ctlWidth and calculate the number of characters
		//that will fit in to that space
	
		GetTextExtentExPoint(hDC,strCurr,lstrlen(strCurr),ctlWidth - szFinal.cx ,&nFit1,NULL,&sizeTemp);
		strCurr[nFit1-1] = _T('\0');

		_stprintf(outStr,_T("%s\r\n%s%s"),strTemp1,strCurr,strFinal);
		return;
	}
}

//--------------------------------------------------------------
LRESULT DependencyPage::OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	m_hDlg = m_hWnd;

	//TODO: Check this out
	if(m_pgConnectThread)
	{
		m_pgConnectThread->SendPtr(m_hWnd);
	}

	TCHAR szBuffer1[100] = {0}, szBuffer2[256] = {0};

    SetDlgItemText(IDC_DEPENDS_SRVC, (wchar_t *)m_ServiceDispName);

	// set the nice bitmap.
    SetClearBitmap(GetDlgItem(IDC_PICT ), MAKEINTRESOURCE( IDB_SERVICE ), 0);

	// create an empty imagelist.
	HIMAGELIST hImageList = ImageList_Create(16, 16, ILC_COLOR8|ILC_MASK, 3, 0);

	// add an icon
	m_servIcon = ImageList_AddIcon(hImageList, 
								   LoadIcon(HINST_THISDLL, 
									MAKEINTRESOURCE(IDI_SERVICE)));

	m_sysDriverIcon = ImageList_AddIcon(hImageList, 
								   LoadIcon(HINST_THISDLL, 
									MAKEINTRESOURCE(IDI_SYSTEMDRIVER)));


	m_emptyIcon = ImageList_AddIcon(hImageList, 
								   LoadIcon(NULL, 
									MAKEINTRESOURCE(IDI_INFORMATION)));
	
	m_groupIcon = ImageList_AddIcon(hImageList, 
								   LoadIcon(HINST_THISDLL, 
									MAKEINTRESOURCE(IDI_SERVGROUP)));

	// sent it to the trees.
	TreeView_SetImageList(GetDlgItem(IDC_DEPENDS_TREE), 
							hImageList, 
							TVSIL_NORMAL);

	TreeView_SetImageList(GetDlgItem(IDC_NEEDED_TREE), 
							hImageList, 
							TVSIL_NORMAL);

	InvalidateRect(NULL);
    UpdateWindow();
    ATLTRACE(L"UpdateWindow() fm Init\n");

	// can we get data yet?
    ::PostMessage(m_hDlg, WM_ENUM_NOW, 0, 0);


	HourGlass(true);
	return S_OK;
}
//--------------------------------------------------------------
void DependencyPage::LoadTrees(void)
{

    ATLTRACE(L"checking service\n");

	// did that background connection thread work yet?
	if(ServiceIsReady(IDS_DISPLAY_NAME, IDS_CONNECTING, IDS_BAD_CONNECT))
	{	
		//Now we will check if there is already some nodes.
		//If it is, then it means that we don't have to enumerate it again.
		//This normally happens in the first time when we connect to a remote machine
		
/*		//We will clear the nodes if it already exists
		TreeView_DeleteAllItems(GetDlgItem(IDC_DEPENDS_TREE));
		TreeView_DeleteAllItems(GetDlgItem(IDC_NEEDED_TREE));
*/
		if(TreeView_GetCount(GetDlgItem(IDC_DEPENDS_TREE)) == 0)
		{
			HourGlass(true);

			TV_ITEM root;
			ITEMEXTRA *extra = new ITEMEXTRA;
			if(extra == NULL)
				return;
			root.hItem = TVI_ROOT;           // I'm making a root.
			root.pszText = m_ServiceDispName;
			extra->realName = CloneString(m_ServiceName);
			extra->loaded = false;
			extra->nodeType = ServiceNode;
			root.lParam = (LPARAM)extra;

			InvalidateRect(NULL);
    
			UpdateWindow();

			// load the first levels.
			LoadLeaves(GetDlgItem(IDC_DEPENDS_TREE), 
						&root, true);

			LoadLeaves(GetDlgItem(IDC_NEEDED_TREE), 
						&root, false);

			SetFocus();
			HourGlass(false);
		}
	}
}

//--------------------------------------------------------------
BOOL DependencyPage::OnApply()
{
	::SetWindowLongPtr(m_hDlg, DWLP_USER, 0);
	return TRUE;
}

//--------------------------------------------------------------
BOOL DependencyPage::OnKillActive()
{
	//SetWindowLong(DWL_MSGRESULT, 0);
	return TRUE;
}

//--------------------------------------------------------------
LRESULT DependencyPage::OnEnumNow(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	if(lParam)
	{
		IStream *pStream = (IStream *)lParam;
		IWbemServices *pServices = 0;
		HRESULT hr = CoGetInterfaceAndReleaseStream(pStream,
											IID_IWbemServices,
											(void**)&pServices);
		if(SUCCEEDED(hr))
		{
			//TODO: this has to be moved to WBemPageHelper
			SetWbemService(pServices);
		}

		LoadTrees();  //calls ServiceIsReady() itself.
	}
	else if(FAILED(m_pgConnectThread->m_hr))
	{
		DisplayUserMessage(m_hDlg, HINST_THISDLL,
							IDS_DISPLAY_NAME, BASED_ON_SRC, 
							ConnectServer,
							m_pgConnectThread->m_hr, 
							MB_ICONSTOP);
	}
	else
	{
		m_pgConnectThread->NotifyWhenDone(&m_hDlg);
	}

	return S_OK;
}

//--------------------------------------------------------------
LRESULT DependencyPage::OnItemExpanding(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{ 
	// which node?
	NM_TREEVIEW *notice = (NM_TREEVIEW *)pnmh;

	// we're expanding, not collapsing...
	if(notice->action == TVE_EXPAND)
	{
		// which tree?
		HWND treeHWND = GetDlgItem(idCtrl);

		TV_ITEM item;
		item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_CHILDREN |TVIF_IMAGE;
		item.pszText = new TCHAR[200];
		item.cchTextMax = 200;
		item.hItem = notice->itemNew.hItem;

		TreeView_GetItem(treeHWND, &item);

		// if we've never tried...
		if(((ITEMEXTRA *)item.lParam)->loaded == false)
		{
			// NOTE: really cant get here if its not ready
			// but better safe than sorry.
			if(ServiceIsReady(IDS_DISPLAY_NAME, IDS_CONNECTING, IDS_BAD_CONNECT))
			{	
				// load it.
				LoadLeaves(treeHWND, &item, (idCtrl == IDC_DEPENDS_TREE));
			}
		}

		delete[] item.pszText;
	} //end action
	return S_OK;
}

//-------------------------------------------------------------------------------
LRESULT DependencyPage::OnDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{ 
	NM_TREEVIEW *notice = (NM_TREEVIEW *)pnmh;
	delete[] (TCHAR *)((ITEMEXTRA *)notice->itemOld.lParam)->realName;
	delete (ITEMEXTRA *)notice->itemOld.lParam;
	return S_OK;
}

//-------------------------------------------------------------------------------
DWORD aDepHelpIds[] = {
    IDC_PICT,			-1,
    IDC_DESC,			-1,
    IDC_DEPENDS_LBL,    (985),	// dependsOn
    IDC_DEPENDS_TREE,   (985),	// dependsOn
    IDC_NEEDED_LBL,     (988),	// neededBy
    IDC_NEEDED_TREE,    (988),	// neededBy
    0, 0
};

LRESULT DependencyPage::OnF1Help(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
				L"filemgmt.hlp", 
				HELP_WM_HELP, 
				(ULONG_PTR)(LPSTR)aDepHelpIds);

	return S_OK;
}

//-------------------------------------------------------------------------------
LRESULT DependencyPage::OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	::WinHelp((HWND)wParam,
				L"filemgmt.hlp", 
				HELP_CONTEXTMENU, 
				(ULONG_PTR)(LPSTR)aDepHelpIds);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\servdeps\deppage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __DEPPAGE__
#define __DEPPAGE__
#pragma once

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

#include "atlsnap.h"
#include "resource.h"
#include "..\common\PageHelper.h"

#define WM_ENUM_NOW WM_USER + 20

//-----------------------------------------------------------------------------
class DependencyPage : public CSnapInPropertyPageImpl<DependencyPage>,
					   public PageHelper
{
private:

	// supports the query builder routine.
#define	ServiceNode 0
#define	GroupNode 1
typedef BYTE NODE_TYPE;

#define	DepService 0
#define	DepGroup 1
#define	GroupMember 2
typedef BYTE QUERY_TYPE;

typedef struct 
{
	LPCTSTR realName;
	bool loaded;
	NODE_TYPE nodeType;
} ITEMEXTRA;


#define QUERY_SIZE 200
	TCHAR *m_queryFormat;
	TCHAR *m_queryTemp;

	bstr_t m_ServiceName;
	bstr_t m_ServiceDispName;

	// icons for the trees.
	int m_servIcon;
	int m_sysDriverIcon;
	int m_emptyIcon;
	int m_groupIcon;

	// convenient strings.
	bstr_t m_qLang;
	bstr_t m_NameProp;
	bstr_t m_DispNameProp;
	CWbemServices m_Services;
	WbemConnectThread *m_pConnectThread;

	void Init(HWND hDlg);

	// builds the various queries.
	void BuildQuery(TV_ITEM *fmNode, 
					QUERY_TYPE queryType,
					bool depends, 
					bstr_t &query);

	// Figures out WHAT to load.
	void LoadLeaves(HWND hTree, 
					TV_ITEM *fmNode, 
					bool depends);

	// actually queries and loads child nodes.
	bool Load(HWND hTree, 
				TV_ITEM *fmNode, 
				bstr_t query,
				NODE_TYPE childType);

	// indicate that there's nothing below 'fmNode'.
	void NothingMore(HWND hTree, TV_ITEM *fmNode);

	// loads the roots.
	void LoadTrees(void);
	void TwoLines(UINT uID, LPCTSTR staticString, LPCTSTR inStr, LPTSTR outStr,bool bStaticFirst);
	
public:

	// this page uses the global IWbemService.
	DependencyPage(WbemConnectThread *pConnectThread,
					IDataObject *pDataObject, 
					long lNotifyHandle, 
					bool bDeleteHandle = false, 
					TCHAR* pTitle = NULL);

	virtual ~DependencyPage();

	HRESULT PropertyChangeNotify(long param)
	{
		return MMCPropertyChangeNotify(m_lNotifyHandle, param);
	}

	enum { IDD = IDD_DEPENDENCY };

	typedef CSnapInPropertyPageImpl<DependencyPage> _baseClass;

	BEGIN_MSG_MAP(DependencyPage)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInit)
		MESSAGE_HANDLER(WM_ENUM_NOW, OnEnumNow)
		MESSAGE_HANDLER(WM_ASYNC_CIMOM_CONNECTED, OnEnumNow)
		NOTIFY_HANDLER(IDC_DEPENDS_TREE, TVN_ITEMEXPANDING, OnItemExpanding)
		NOTIFY_HANDLER(IDC_NEEDED_TREE, TVN_ITEMEXPANDING, OnItemExpanding)
		NOTIFY_HANDLER(IDC_DEPENDS_TREE, TVN_DELETEITEM, OnDeleteItem)
		NOTIFY_HANDLER(IDC_NEEDED_TREE, TVN_DELETEITEM, OnDeleteItem)
		MESSAGE_HANDLER(WM_HELP, OnF1Help)
		MESSAGE_HANDLER(WM_CONTEXTMENU , OnContextHelp)
		CHAIN_MSG_MAP(_baseClass)
	END_MSG_MAP()

	// Handler prototypes:
	LRESULT OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnEnumNow(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnItemExpanding(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
	LRESULT OnDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
	LRESULT OnF1Help(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

	BOOL OnApply();
	BOOL OnKillActive();

	long m_lNotifyHandle;
	bool m_bDeleteHandle;
};


#endif __DEPPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\servdeps\servdeps.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// ServDeps.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f ServDepsps.mk in the project directory.

#include "precomp.h"
#include "resource.h"
#include "initguid.h"
#include "ServDeps.h"

#include "ServDeps_i.c"
#include "SDSnapin.h"


CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_SDSnapin, CSDSnapin)
	OBJECT_ENTRY(CLSID_SDSnapinAbout, CSDSnapinAbout)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		CSnapInItem::Init();
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\servdeps\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ServDeps.rc
//
#define CX_CDWN_OFFS                    0
#define IDS_DISPLAY_NAME                1
#define IDS_TITLE                       2
#define IDS_DEPENDS_LBL                 3
#define IDS_NEEDED_LBL                  4
#define IDS_DESCRIPTION                 5
#define IDS_CONNECTING                  6
#define IDS_BAD_CONNECT                 7
#define IDD_DEPENDENCY                  101
#define IDB_SERVICE                     102
#define IDI_SERVICE                     103
#define IDI_SERVDEPS                    104
#define IDI_EMPTY                       105
#define IDI_SERVGROUP                   106
#define IDI_SYSTEMDRIVER				107
#define IDS_PROJNAME                    110
#define IDB_SDSNAPIN_16                 111
#define IDB_SDSNAPIN_32                 112
#define IDD_SDSNAPIN                    113
#define IDS_SDSNAPIN_DESC               114
#define IDS_SDSNAPIN_PROVIDER           115
#define IDS_SDSNAPIN_VERSION            116
#define IDR_SDSNAPIN                    117
#define IDS_WORKING                     117
#define IDS_NO_DEPS                     118
#define IDI_WAITING                     202
#define IDC_DEPENDS_TREE                1003
#define IDC_NEEDED_TREE                 1004
#define IDC_NEEDED_LBL                  1005
#define IDC_DEPENDS_LBL                 1006
#define IDC_DESC                        1007
#define IDC_PICT                        1008
#define IDC_DEPENDS_SRVC                1009
#define IDS_BYTES                       10000
#define IDS_ORDERKB                     10001
#define IDS_ORDERMB                     10002
#define IDS_ORDERGB                     10003
#define IDS_ORDERTB                     10004
#define IDS_ORDERPB                     10005
#define IDS_ORDEREB                     10006
#define IDS_MB                          10007
#define IDS_SERVICE_READY               10008

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\aboutdlg.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
class CAboutDlg : public CDialogImpl<CAboutDlg>
{
public:
	enum { IDD = IDD_ABOUTBOX };

	BEGIN_MSG_MAP(CAboutDlg)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER(IDOK, OnCloseCmd)
		COMMAND_ID_HANDLER(IDCANCEL, OnCloseCmd)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		CenterWindow(GetParent());
		return TRUE;
	}

	LRESULT OnCloseCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		EndDialog(wID);
		return 0;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\servdeps\sdsnapin.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "DepPage.h"
#include "ServDeps.h"
#include "SDSnapin.h"
#include "..\common\ConnectThread.h"

/////////////////////////////////////////////////////////////////////////////
// CSDSnapinComponentData
static const GUID CSDSnapinExtGUID_NODETYPE = 
{ 0x4e410f16, 0xabc1, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
const GUID*  CSDSnapinExtData::m_NODETYPE = &CSDSnapinExtGUID_NODETYPE;
const OLECHAR* CSDSnapinExtData::m_SZNODETYPE = OLESTR("4e410f16-abc1-11d0-b944-00c04fd8d5b0");
const OLECHAR* CSDSnapinExtData::m_SZDISPLAY_NAME = OLESTR("SDSnapin");
const CLSID* CSDSnapinExtData::m_SNAPIN_CLASSID = &CLSID_SDSnapin;

WbemConnectThread *g_connectThread = NULL;

HRESULT CSDSnapinExtData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
											LONG_PTR handle, 
											IUnknown* pUnk,
											DATA_OBJECT_TYPES type)
{
	if(g_connectThread == NULL)
	{
		g_connectThread = new WbemConnectThread;
		if(g_connectThread == NULL)
			return E_FAIL;
	}

	g_connectThread->Connect(m_pDataObject);

	DependencyPage* pPage = new DependencyPage(g_connectThread, 
												m_pDataObject, 
												handle, 
												true);

	lpProvider->AddPage(pPage->Create());
	// The second parameter  to the property page class constructor
	// should be true for only one page.

	// TODO : Add code here to add additional pages
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\servdeps\sdsnapin.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __SDSNAPIN_H_
#define __SDSNAPIN_H_
#include "resource.h"
#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif
#include <atlsnap.h>

class CSDSnapinExtData : public CSnapInItemImpl<CSDSnapinExtData, TRUE>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

	CSDSnapinExtData()
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	}

	~CSDSnapinExtData()
	{
	}

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
									LONG_PTR handle, 
									IUnknown* pUnk,
									DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}

	IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		// Modify to return a different CSnapInItem* pointer.
		return pDefault;
	}

};
class CSDSnapin : public CComObjectRootEx<CComSingleThreadModel>,
					public CSnapInObjectRoot<0, CSDSnapin>,
					public IExtendPropertySheetImpl<CSDSnapin>,
					public CComCoClass<CSDSnapin, &CLSID_SDSnapin>
{
public:
	CSDSnapin()
	{
		m_pComponentData = this;
	}
EXTENSION_SNAPIN_DATACLASS(CSDSnapinExtData)

BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CSDSnapin)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CSDSnapinExtData)
END_EXTENSION_SNAPIN_NODEINFO_MAP()

BEGIN_COM_MAP(CSDSnapin)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
END_COM_MAP()

//DECLARE_REGISTRY_RESOURCEID(IDR_SDSNAPIN)

DECLARE_NOT_AGGREGATABLE(CSDSnapin)

	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
	{
		HRESULT hr;
		TCHAR pName[100] = {0};
		if(::LoadString(_Module.GetModuleInstance(), IDS_DISPLAY_NAME, 
			pName, 100) <= 0)
		{
			wcscpy(pName, _T("Service Dependencies"));
		}
		TCHAR dispName[100] = {0};
        TCHAR szModule[_MAX_PATH];
        ::GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
        _stprintf( dispName,_T("@%s,-%d"), szModule, IDS_DISPLAY_NAME);

		
		_ATL_REGMAP_ENTRY regMap[] = {{ OLESTR("PRETTYNAME"), pName },
										{ OLESTR("NAMESTRINGINDIRECT"),dispName},
										{ 0, 0 }};

		hr = _Module.UpdateRegistryFromResourceD(IDR_SDSNAPIN, TRUE, regMap);

		return hr;
	}


	static void WINAPI ObjectMain(bool bStarting)
	{
		if(bStarting)
			CSnapInItem::Init();
	}
};

class ATL_NO_VTABLE CSDSnapinAbout : public ISnapinAbout,
									public CComObjectRoot,
									public CComCoClass< CSDSnapinAbout, &CLSID_SDSnapinAbout>
{
public:
	DECLARE_REGISTRY(CSDSnapinAbout, _T("SDSnapinAbout.1"), _T("SDSnapinAbout.1"), IDS_SDSNAPIN_DESC, THREADFLAGS_BOTH);

	BEGIN_COM_MAP(CSDSnapinAbout)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

	STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
	{
		USES_CONVERSION;
		TCHAR szBuf[256] = {0};
		if (::LoadString(_Module.GetResourceInstance(), IDS_DESCRIPTION, szBuf, 256) == 0)
			return E_FAIL;

		*lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpDescription == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpDescription, T2OLE(szBuf));

		return S_OK;
	}

    STDMETHOD(GetProvider)(LPOLESTR *lpName)
	{
		USES_CONVERSION;
		TCHAR szBuf[256] = {0};
		if (::LoadString(_Module.GetResourceInstance(), IDS_SDSNAPIN_PROVIDER, szBuf, 256) == 0)
			return E_FAIL;

		*lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpName == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpName, T2OLE(szBuf));

		return S_OK;
	}

    STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
	{
		USES_CONVERSION;
		TCHAR szBuf[256] = {0};
		if (::LoadString(_Module.GetResourceInstance(), IDS_SDSNAPIN_VERSION, szBuf, 256) == 0)
			return E_FAIL;

		*lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpVersion == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpVersion, T2OLE(szBuf));

		return S_OK;
	}

    STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
	{
		*hAppIcon = LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_SERVDEPS));
		return S_OK;
	}

    STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage,
									HBITMAP *hSmallImageOpen,
									HBITMAP *hLargeImage,
									COLORREF *cMask)
	{
		*hSmallImage = *hSmallImageOpen = LoadBitmap(_Module.GetResourceInstance(), 
														MAKEINTRESOURCE(IDB_SDSNAPIN_16));
		
		*hLargeImage = LoadBitmap(_Module.GetResourceInstance(), 
									MAKEINTRESOURCE(IDB_SDSNAPIN_32));
		*cMask = RGB(255,255,255);

		return S_OK;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\advpage.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright (c) 1997-1999 Microsoft Corporation
/**********************************************************************/


#include "precomp.h"
#include "AdvPage.h"
#include "chstring1.h"
#include "resource.h"
#include "WMIHelp.h"
#include "ShlWapi.h"

const static DWORD advPageHelpIDs[] = {  // Context Help IDs
	IDC_SCRIPT_LABEL,		IDH_WMI_CTRL_ADVANCED_SCRIPTING_PATH,
	IDC_SCRIPT_NS,			IDH_WMI_CTRL_ADVANCED_SCRIPTING_PATH,
	IDC_CHANGE_SCRIPT_NS,	IDH_WMI_CTRL_ADVANCED_CHANGE_BUTTON,
	IDC_ASP,				IDH_WMI_CTRL_ADVANCED_ASP_ACCESS,
	IDC_ASP_LABEL,			IDH_WMI_CTRL_ADVANCED_ASP_ACCESS,
	IDC_9X_ANON_CONNECTION, IDH_WMI_CTRL_ADVANCED_ENABLE_CONNECT,
	IDC_9X_ONLY,			IDH_WMI_CTRL_ADVANCED_RESTART_BOX,
	IDC_NORESTART,			IDH_WMI_CTRL_ADVANCED_RESTART_BOX,
	IDC_ESSRESTART,			IDH_WMI_CTRL_ADVANCED_RESTART_BOX,
	IDC_ALWAYSAUTORESTART,	IDH_WMI_CTRL_ADVANCED_RESTART_BOX,
	IDC_ADV_PARA,			-1,
    0, 0};


// WARNING: This class handles IDD_ADVANCED_NT and IDD_ADVANCED_9X so protect
// yourself from controls that aren't on both templates.

CAdvancedPage::CAdvancedPage(DataSource *ds, bool htmlSupport) :
								CUIHelpers(ds, &(ds->m_rootThread), htmlSupport),
								m_DS(ds)
{
}

CAdvancedPage::~CAdvancedPage(void)
{
}

//-------------------------------------------------------------------------
void CAdvancedPage::InitDlg(HWND hDlg)
{
	m_hDlg = hDlg;
	ATLTRACE(_T("ADV: init\n"));
}

//---------------------------------------------------------------------------
void CAdvancedPage::Refresh(HWND hDlg)
{
	if(m_DS && m_DS->IsNewConnection(&m_sessionID))
	{
		CHString1 temp;
		CHString1 szNotRemoteable, szUnavailable;
		HRESULT hr = S_OK;
		BOOL enable = TRUE;
		HWND hWnd;

		szNotRemoteable.LoadString(IDS_NOT_REMOTEABLE);
		szUnavailable.LoadString(IDS_UNAVAILABLE);

		PageChanged(PB_ADVANCED, false);

		if(m_DS->m_OSType == OSTYPE_WINNT)
		{
			ATLTRACE(_T("ADV: winnt\n"));
			::ShowWindow(GetDlgItem(hDlg,IDC_NORESTART), SW_HIDE);
			::ShowWindow(GetDlgItem(hDlg,IDC_ESSRESTART), SW_HIDE);
			::ShowWindow(GetDlgItem(hDlg,IDC_ALWAYSAUTORESTART), SW_HIDE);
			::ShowWindow(GetDlgItem(hDlg,IDC_9X_ANON_CONNECTION), SW_HIDE);
			::ShowWindow(GetDlgItem(hDlg,IDC_9X_ONLY), SW_HIDE);

			CHString1 para;
			para.LoadString(IDS_ADV_PARA_NT);
			SetDlgItemText(hDlg, IDC_ADV_PARA, para);
			// - - - - - - - - - - - - - -
			// Enable for ASP:
			hWnd = GetDlgItem(hDlg,IDC_ASP);
			if(hWnd)
			{
				// only display it for NT 3.51 and NT4.0.
				CHString1 ver;
				m_DS->GetOSVersion(ver);
				if((_tcsncmp((LPCTSTR)ver, _T("3.51"), 4) == 0) || 
					ver[0] == _T('4'))
				{
					ATLTRACE(_T("ADV: winnt  4.0\n"));

					::ShowWindow(hWnd, SW_SHOW);
					::ShowWindow(GetDlgItem(hDlg, IDC_ASP_LABEL), SW_SHOW);

					hr = m_DS->GetScriptASPEnabled(m_enableASP);
					if(SUCCEEDED(hr))
					{
						Button_SetCheck(hWnd, (m_enableASP ? BST_CHECKED : BST_UNCHECKED));
					}
				}
				else // this must be w2k
				{
					ATLTRACE(_T("ADV: winnt 5.0\n"));
					::ShowWindow(hWnd, SW_HIDE);
					::ShowWindow(GetDlgItem(hDlg, IDC_ASP_LABEL), SW_HIDE);
				}
			}
		}
		else // 9x box
		{
			ATLTRACE(_T("ADV: 9x\n"));

			::ShowWindow(GetDlgItem(hDlg,IDC_NORESTART), SW_SHOW);
			::ShowWindow(GetDlgItem(hDlg,IDC_ESSRESTART), SW_SHOW);
			::ShowWindow(GetDlgItem(hDlg,IDC_ALWAYSAUTORESTART), SW_SHOW);
			::ShowWindow(GetDlgItem(hDlg,IDC_9X_ANON_CONNECTION), SW_SHOW);
			::ShowWindow(GetDlgItem(hDlg,IDC_9X_ONLY), SW_SHOW);

			ShowWindow(GetDlgItem(hDlg,IDC_ASP), SW_HIDE);
			ShowWindow(GetDlgItem(hDlg,IDC_ASP_LABEL), SW_HIDE);

			CHString1 para;
			para.LoadString(IDS_ADV_PARA_9X);
			SetDlgItemText(hDlg, IDC_ADV_PARA, para);

			// - - - - - - - - - - - - - -
			// 9x restart.
			int ID;
			hr = m_DS->GetRestart(m_oldRestart);
			if(SUCCEEDED(hr))
			{
				switch(m_oldRestart)
				{
				case DataSource::Dont:			ID = IDC_NORESTART; break;
				case DataSource::AsNeededByESS:	ID = IDC_ESSRESTART;   break;
				case DataSource::Always:		ID = IDC_ALWAYSAUTORESTART; break;
				}
				CheckRadioButton(hDlg, IDC_NORESTART, IDC_ALWAYSAUTORESTART, ID);
			}

			// - - - - - - - - - - - - - -
			// 9x Anonymous connection:
			hWnd = GetDlgItem(hDlg, IDC_9X_ANON_CONNECTION);
			if(hWnd)
			{
				hr = m_DS->GetAnonConnections(m_anonConnection);
				if(SUCCEEDED(hr))
				{
					Button_SetCheck(hWnd, (m_anonConnection ? BST_CHECKED : BST_UNCHECKED));
				}
			}
		} //endif OSTtype

		// - - - - - - - - - - - - - -
		// ASP def namespace:
		hWnd = GetDlgItem(hDlg, IDC_SCRIPT_NS);
		if(hWnd)
		{
			hr = m_DS->GetScriptDefNS(temp);
			if(SUCCEEDED(hr))
			{
				TCHAR shortPath[50] = {0};
				PathCompactPathEx(shortPath, temp, 40,0);
				SetWindowText(hWnd, shortPath);
			}
		}
		else //failed
		{
			SetWindowText(hWnd, szUnavailable);
		}
	}
}

//------------------------------------------------------------------------
void CAdvancedPage::OnNSSelChange(HWND hDlg)
{
	TCHAR path[MAX_PATH] = {0};

	if(DisplayNSBrowser(hDlg, path, MAX_PATH) == IDOK)
	{
		HWND hWnd = GetDlgItem(hDlg, IDC_SCRIPT_NS);
		TCHAR shortPath[50] = {0};
		PathCompactPathEx(shortPath, path, 40,0);
		::SetWindowText(hWnd, shortPath);
		Edit_SetModify(hWnd, TRUE);
		PageChanged(PB_ADVANCED, true);
	}

}

//------------------------------------------------------------------------
void CAdvancedPage::OnApply(HWND hDlg, bool bClose)
{
	// enable ASP
	HWND hWnd = GetDlgItem(hDlg, IDC_ASP);
	bool needToPut = false;

	if(hWnd)
	{
		bool newEnable = (IsDlgButtonChecked(hDlg, IDC_ASP) & BST_CHECKED ?true:false);

		if(m_enableASP != newEnable)
		{
			m_DS->SetScriptASPEnabled(newEnable);
			m_enableASP = newEnable;
			needToPut = true;
		}
	}

	// default scripting namespace.
	TCHAR buf[_MAX_PATH] = {0};
	hWnd = GetDlgItem(hDlg, IDC_SCRIPT_NS);
	//if(Edit_GetModify(hWnd))
	{
		::GetWindowText(hWnd, buf, ARRAYSIZE(buf));
		m_DS->SetScriptDefNS(buf);
		needToPut = true;
	}

	// Anon Connections
	hWnd = GetDlgItem(hDlg, IDC_9X_ANON_CONNECTION);
	if(hWnd)
	{
		bool anonConn = (IsDlgButtonChecked(hDlg, IDC_9X_ANON_CONNECTION) & BST_CHECKED ?true:false);

		if(m_anonConnection != anonConn)
		{
			m_DS->SetAnonConnections(anonConn);
			m_anonConnection = anonConn;
			needToPut = true;
		}
	}

	// 9x restart
	hWnd = GetDlgItem(hDlg, IDC_NORESTART);
	if(hWnd)
	{
		DataSource::RESTART restart = DataSource::Dont;

		if(IsDlgButtonChecked(hDlg, IDC_NORESTART) & BST_CHECKED)
			restart = DataSource::Dont;
		else if(IsDlgButtonChecked(hDlg, IDC_ESSRESTART) & BST_CHECKED)
			restart = DataSource::AsNeededByESS;
		else if(IsDlgButtonChecked(hDlg, IDC_ALWAYSAUTORESTART) & BST_CHECKED)
			restart = DataSource::Always;

		if(m_oldRestart != restart)
		{
			m_DS->SetRestart(restart);
			m_oldRestart = restart;
			needToPut = true;
		}
	}

	if(needToPut)
	{
		NeedToPut(PB_ADVANCED, !bClose);
		if(!bClose)
			Refresh(hDlg);
	}
}

//------------------------------------------------------------------------
BOOL CAdvancedPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        InitDlg(hDlg);
        break;

    case WM_NOTIFY:
        switch(((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            Refresh(hDlg);
            break;

        case PSN_HELP:
			HTMLHelper(hDlg);
            break;

        case PSN_APPLY:
            OnApply(hDlg, (((LPPSHNOTIFY)lParam)->lParam == 1));
            break;
        }
        break;

    case WM_COMMAND:
		switch(LOWORD(wParam))
		{
		case IDC_ASP:
		case IDC_9X_ANON_CONNECTION:
		case IDC_NORESTART:
		case IDC_ESSRESTART:
		case IDC_ALWAYSAUTORESTART:
			if(HIWORD(wParam) == BN_CLICKED)
			{
				PageChanged(PB_ADVANCED, true);
				return TRUE;
			}
			break;

		case IDC_CHANGE_SCRIPT_NS:
			if(HIWORD(wParam) == BN_CLICKED)
			{
				OnNSSelChange(hDlg);
				return TRUE;
			}
			break;

		} //endswitch(LOWORD(wParam))
	
        break;

    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_HelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)advPageHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp(hDlg, c_HelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)advPageHelpIDs);
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\advpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __ADVANCEDPAGE__
#define __ADVANCEDPAGE__

#include "UIHelpers.h"
#include "DataSrc.h"

class CAdvancedPage : public CUIHelpers
{
private:

public:
    CAdvancedPage(DataSource *ds, bool htmlSupport);
    virtual ~CAdvancedPage(void);

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void InitDlg(HWND hDlg);
	void Refresh(HWND hDlg);
    void OnApply(HWND hDlg, bool bClose);
	void OnNSSelChange(HWND hDlg);

	DataSource *m_DS;
	bool m_enableASP, m_anonConnection;
	DataSource::RESTART m_oldRestart;

};
#endif __ADVANCEDPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\asyncobjectsink.h ===
#ifndef __ASYN_OBJECT_ASYNC_DJFDVINOTHDLKJ
#define __ASYN_OBJECT_ASYNC_DJFDVINOTHDLKJ

#include "Wbemidl.h"
#include "DataSrc.h"

enum ENUMTYPE
{
	ENUM_NAMESPACE,
	ENUM_CLASS,
	ENUM_INSTANCE,
	ENUM_SCOPE_INSTANCE
};

class CAsyncObjectSink : public IWbemObjectSink
{
	// Declare the reference count for the object.
	LONG m_lRef;
	struct NSNODE *m_pParent;
	HTREEITEM m_hItem;
	HWND m_hTreeWnd;
	DataSource *m_pDataSrc;
	ENUMTYPE m_enumType;
	bool m_bChildren;
	IWbemObjectSink *m_pStub;
	
public:
	CAsyncObjectSink(HWND hTreeWnd, HTREEITEM hItem,struct NSNODE *parent,DataSource *dataSrc, ENUMTYPE eType);
	~CAsyncObjectSink(); 

	// IUnknown methods
	virtual ULONG STDMETHODCALLTYPE AddRef();
	virtual ULONG STDMETHODCALLTYPE Release();        
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

	// IWbemObjectSink methods
	virtual HRESULT STDMETHODCALLTYPE Indicate( 
		  /* [in] */ long lObjectCount,
		  /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray);
	virtual HRESULT STDMETHODCALLTYPE SetStatus( 
		  /* [in] */ long lFlags,
		  /* [in] */ HRESULT hResult,
		  /* [in] */ BSTR strParam,
		  /* [in] */ IWbemClassObject __RPC_FAR *pObjParam);

	HRESULT SetSinkStub(IWbemObjectSink *pStub);
	IWbemObjectSink* GetSinkStub();

};

#endif //__ASYN_OBJECT_ASYNC_DJFDVINOTHDLKJ
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\asyncobjectsink.cpp ===
#include "precomp.h"
#include "AsyncObjectSink.h"
#include <stdio.h>

CAsyncObjectSink::CAsyncObjectSink(HWND hTreeWnd, HTREEITEM hItem,struct NSNODE *parent,DataSource *dataSrc, ENUMTYPE eType) 
{ 
	m_lRef = 0; 
	m_pParent = parent;
	m_hTreeWnd = hTreeWnd;
	m_hItem = hItem;
	m_pDataSrc = dataSrc;
	m_enumType = eType;
	m_bChildren = false;
	m_pStub = NULL;
}

CAsyncObjectSink::~CAsyncObjectSink()
{
}

ULONG CAsyncObjectSink::AddRef()
{
	return InterlockedIncrement(&m_lRef);
}

ULONG CAsyncObjectSink::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT CAsyncObjectSink::QueryInterface(REFIID riid, void** ppv)
{
    if (riid == IID_IUnknown || riid == IID_IWbemObjectSink)
    {
        *ppv = (IWbemObjectSink *) this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

HRESULT CAsyncObjectSink::Indicate(long lObjCount, IWbemClassObject **pArray)
{

//	OutputDebugString(_T("Indicate Received"));
	// Loop through the array, examining the objects.
	for (long i = 0; i < lObjCount; i++)
	{
		IWbemClassObject *pTemp = pArray[i];
		// Use the object
		switch(m_enumType)
		{
			case ENUM_NAMESPACE:
				m_pDataSrc->InsertNamespaceNode(m_hTreeWnd,m_hItem,m_pParent,pTemp);
				break;
			case ENUM_CLASS :
				m_pDataSrc->InsertClassNode(m_hTreeWnd,m_hItem,m_pParent,pTemp);
				break;
			case ENUM_INSTANCE:
				m_pDataSrc->InsertInstanceNode(m_hTreeWnd,m_hItem,m_pParent,pTemp);
				break;
			case ENUM_SCOPE_INSTANCE:
				m_pDataSrc->InsertScopeInstanceNode(m_hTreeWnd,m_hItem,m_pParent,pTemp);
				break;
			default:
				break;
		}
		if(m_bChildren == false)
		{
			m_bChildren = true;
			TreeView_Expand(m_hTreeWnd,m_hItem,TVE_EXPAND);
		}
	}

  return WBEM_S_NO_ERROR;
}

HRESULT CAsyncObjectSink::SetStatus(
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam
    )
{
//	printf("CAsyncObjectSink::SetStatus hResult = 0x%X\n", hResult);
	if(lFlags == WBEM_STATUS_COMPLETE)
	{
		if(m_bChildren == false)
		{
			m_pDataSrc->RemovePlus(m_hTreeWnd,m_hItem);
		}
		m_pDataSrc->ProcessEndEnumAsync((IWbemObjectSink *) this);
	}
	return WBEM_S_NO_ERROR;
}

HRESULT CAsyncObjectSink::SetSinkStub(IWbemObjectSink *pStub)
{
    if (m_pStub != NULL)
        m_pStub->Release();

    m_pStub = pStub;

    if (m_pStub != NULL)
	    m_pStub->AddRef();

	return S_OK;
}

IWbemObjectSink* CAsyncObjectSink::GetSinkStub()
{
	return m_pStub;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\chklisthandler.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __CHECKLISTHANDLER__
#define __CHECKLISTHANDLER__
#pragma once

#include "ChkList.h"

// knows how to do security stuff with the 'generic' chklist.
class CCheckListHandler
{
public:
	CCheckListHandler();
    ~CCheckListHandler();

	void Attach(HWND hDlg, int chklistID);
	void Reset(void);
	void Empty(void);

	// handles the complex relationship between allow and deny
	// checkboxes.
	void HandleListClick(PNM_CHECKLIST pnmc);
private:

	HWND m_hDlg, m_hwndList;

};
#endif __CHECKLISTHANDLER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\chklist.h ===
//-----------------------------------------------------------------------------
//
// chklist.h - Definitions and prototypes for the checklist pseudo-control
//
// Copyright 1996, Microsoft Corporation
//
//
//-----------------------------------------------------------------------------

#ifndef _CHKLIST_H_
#define _CHKLIST_H_

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

//
// CheckList window class name
//
#define WC_CHECKLIST        "CHECKLIST_SCE"

//
// CheckList check states
//
#define CLST_UNCHECKED      0   // == BST_UNCHECKED
#define CLST_CHECKED        1   // == BST_CHECKED
#define CLST_DISABLED       2   // == BST_INDETERMINATE
#define CLST_CHECKDISABLED  (CLST_CHECKED | CLST_DISABLED)

//
// CheckList window styles
//
#define CLS_1CHECK          0x0001
#define CLS_2CHECK          0x0002
//#define CLS_3CHECK          0x0003
//#define CLS_4CHECK          0x0004
#define CLS_CHECKMASK       0x000f

//
// CheckList messages
//
// row is 0-based
// column is 1-based
//
#define CLM_SETCOLUMNWIDTH  (WM_USER + 1)   // lParam = width (dlg units) of a check column (default=32)
#define CLM_ADDITEM         (WM_USER + 2)   // wParam = pszName, lParam = item data, return = row
#define CLM_GETITEMCOUNT    (WM_USER + 3)   // no parameters
#define CLM_SETSTATE        (WM_USER + 4)   // wParam = row/column, lParam = state
#define CLM_GETSTATE        (WM_USER + 5)   // wParam = row/column, return = state
#define CLM_SETITEMDATA     (WM_USER + 6)   // wParam = row, lParam = item data
#define CLM_GETITEMDATA     (WM_USER + 7)   // wParam = row, return = item data
#define CLM_RESETCONTENT    (WM_USER + 8)   // no parameters
#define CLM_GETVISIBLECOUNT (WM_USER + 9)   // no parameters, return = # of visible rows
#define CLM_GETTOPINDEX     (WM_USER + 10)  // no parameters, return = index of top row
#define CLM_SETTOPINDEX     (WM_USER + 11)  // wParam = index of new top row
#define CLM_ENSUREVISIBLE   (WM_USER + 12)  // wParam = index of item to make fully visible

//
// CheckList notification messages
//
#define CLN_CLICK           (0U-1000U)      // lparam = PNM_CHECKLIST

typedef struct _NM_CHECKLIST
{
    NMHDR hdr;
    int iItem;                              // row (0-based)
    int iSubItem;                           // column (1-based)
    DWORD dwState;
    DWORD_PTR dwItemData;
} NM_CHECKLIST, *PNM_CHECKLIST;

#define CBL_GetItemCount(x) (SendMessage(x, CLM_GETITEMCOUNT, 0,0))
#define CBL_GetItemData(x,y) (SendMessage(x, CLM_GETITEMDATA,(WPARAM)y, 0))
#define CBL_GetState(x, r, c) (SendMessage(x, CLM_GETSTATE, MAKEWPARAM(r, c), 0))
#define CBL_SetState(x, r, c, s) (SendMessage(x, CLM_SETSTATE, MAKEWPARAM(r, c),(LPARAM)s))


BOOL RegisterCheckListWndClass(void);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _CHKLIST_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\backuppage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __BACKUPPAGE__
#define __BACKUPPAGE__

#include "UIHelpers.h"
#include "DataSrc.h"

class CBackupPage : public CUIHelpers
{
public:
    CBackupPage(DataSource *ds, bool htmlSupport) :
			CUIHelpers(ds, &(ds->m_rootThread), htmlSupport)
    {
        m_AVIbox        = NULL;
        m_wszArgs       = NULL;
        m_cred          = NULL;
        m_bWhistlerCore = false;
    }
    virtual ~CBackupPage(void);

	// for the BackupRestoreThread.
	HRESULT m_backupHr;
	HWND m_AVIbox;
	wchar_t *m_wszArgs;
	bool m_doingBackup;
	LOGIN_CREDENTIALS *m_cred;
	bool m_bWhistlerCore;

	void SetPriv(LPCTSTR privName, IWbemBackupRestore *br);
	void ClearPriv(void);

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void InitDlg(HWND hDlg);
	void Refresh(HWND hDlg, bool force = false);
    void OnApply(HWND hDlg, bool bClose);
	BOOL BackupMethod(HWND hDlg, LPCTSTR pathFile);
	HRESULT RestoreMethod(HWND hDlg, LPCTSTR pathFile);
	void DealWithPath(LPCTSTR pathFile);
	void DealWithDomain(void);
	void Reconnect(void);
	void Reconnect2(void);
	void OnFinishConnected(HWND hDlg, LPARAM lParam);
	void HideAutomaticBackupControls(HWND hDlg);
	void SetInterval(HWND hDlg, UINT minutes);
	bool GetInterval(HWND hDlg, UINT &iValue, bool &valid);
	int m_CBIdx;

	// for the backup thread.
	bool IsClientNT5OrMore(void);
	DWORD EnablePriv(bool fEnable, IWbemBackupRestore *br = 0);
	HANDLE m_hAccessToken;
	LUID m_luid;
	bool m_fClearToken;
	bool m_cloak;  // protects the cloak from eoac.

};
#endif __BACKUPPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\backuppage.cpp ===
// Copyright (c) 1999 Microsoft Corporation

#include "precomp.h"
#include "BackupPage.h"
#include <chstring1.h>
#include "resource.h"
#include "wbemerror.h"
#include <process.h>
#include "WMIHelp.h"
#include "ShlWapi.h"
#include <cominit.h>
#include <stdlib.h>
#include <stdio.h>

#define REC_WILDCARD    _T("*.rec")
#define ALL_WILDCARD    _T("*.*")

const static DWORD buPageHelpIDs[] = {  // Context Help IDs
	IDC_BACKUP_ENABLED,		IDH_WMI_CTRL_BACKUP_AUTOMATIC_CHECKBOX,
	IDC_BACKUPINTERVAL,		IDH_WMI_CTRL_BACKUP_TIME,
	IDC_BACKUP_UNITS,		IDH_WMI_CTRL_BACKUP_MINUTES_HOURS,
	IDC_LASTBACKUP_LABEL,	IDH_WMI_CTRL_BACKUP_LAST,
	IDC_LASTBACKUP,			IDH_WMI_CTRL_BACKUP_LAST,
	IDC_RESTORE_FM_AUTO,	IDH_WMI_CTRL_BACKUP_RESTORE_AUTO,
	IDC_BACKUP_BTN,			IDH_WMI_CTRL_BACKUP_BACKUP_MANUAL,
	IDC_RESTORE_BTN,		IDH_WMI_CTRL_BACKUP_RESTORE_MANUAL,
	IDC_DBDIRECTORY_LABEL,	IDH_WMI_CTRL_ADVANCED_REPOSITORY_LOC,
	IDC_DB_DIR,				IDH_WMI_CTRL_ADVANCED_REPOSITORY_LOC,
	IDC_ADV_NOW_TEXT,		-1,
	IDC_ADV_NOW_TEXT2,		-1,
	65535, -1,
    0, 0
};

const double WIN2K_CORE_VERSION = 1085.0005;		//Win2K Core Version


CBackupPage::~CBackupPage(void)
{
}

//-------------------------------------------------------------------------
void CBackupPage::InitDlg(HWND hDlg)
{
	m_hDlg = hDlg;

	::SendMessage(GetDlgItem(hDlg, IDC_BACKUPINTERVAL),
					EM_LIMITTEXT, 3, 0);

	HWND hWnd = GetDlgItem(hDlg, IDC_BACKUP_UNITS);
	if(hWnd)
	{
		CHString1 str;
		str.LoadString(IDS_MINUTES);
		ComboBox_AddString(hWnd, str);

		str.LoadString(IDS_HOURS);
		ComboBox_AddString(hWnd, str);
	}


	if(m_DS)
	{
		USES_CONVERSION;
		CHString1 strVersion = _T("0.0");
		m_DS->GetBldNbr(strVersion);
		double ver = atof(W2A(strVersion));
		if(ver > WIN2K_CORE_VERSION)		
		{
			HideAutomaticBackupControls(hDlg);
		}
	}
}

//---------------------------------------------------------------------------
// NOTE: This must match to order of the combobox.
#define UNIT_MINUTE 0
#define UNIT_HOUR 1
#define UNIT_DAY 2

#define MINS_IN_HOUR 60
#define MINS_IN_DAY 1440
#define DISABLE_BACKUP -1

void CBackupPage::SetInterval(HWND hDlg, UINT minutes)
{
	int m_CBIdx = UNIT_MINUTE;
	UINT value = minutes;

	if((minutes % MINS_IN_HOUR) == 0)
	{
		m_CBIdx = UNIT_HOUR;
		value = minutes / MINS_IN_HOUR;
	}
	else if((minutes % MINS_IN_DAY) == 0)
	{
		m_CBIdx = UNIT_DAY;
		value = minutes / MINS_IN_DAY;
	}

	CHString1 temp;
	temp.Format(_T("%d"), value);
	SetWindowText(GetDlgItem(hDlg, IDC_BACKUPINTERVAL), temp);
	ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_BACKUP_UNITS), m_CBIdx);
}

//---------------------------------------------------------------------------
bool CBackupPage::GetInterval(HWND hDlg, UINT &iValue, bool &valid)
{
	int idx = ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_BACKUP_UNITS));
	TCHAR value[4] = {0};
	valid = false;
	iValue = 0;
	::GetWindowText(GetDlgItem(hDlg, IDC_BACKUPINTERVAL), value, 4);
	iValue = _ttoi(value);

	// scale to minutes based on the combo box.
	switch(idx)
	{
	case UNIT_HOUR:
		iValue *= MINS_IN_HOUR;
		break;
	case UNIT_DAY:
		iValue *= MINS_IN_DAY;
		break;
	}

	if((iValue == 0) ||
	   ((iValue >= 5) && (iValue <= 1440)))
	{
		valid = true;
	}
	else
	{
		CHString1 caption, threat;
		caption.LoadString(IDS_SHORT_NAME);
		threat.LoadString(IDS_BAD_INTERVAL);

		MessageBox(hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
							MB_OK|MB_ICONEXCLAMATION);

	}

	return (m_CBIdx != idx);
}

//---------------------------------------------------------------------------
void CBackupPage::Refresh(HWND hDlg, bool force)
{
	if(force || 
		(m_DS && m_DS->IsNewConnection(&m_sessionID)))
	{
		CHString1 temp;
		UINT iTemp = 0;
		CHString1 szNotRemoteable, szUnavailable;
		HRESULT hr = S_OK;
		BOOL enable = TRUE;

		szNotRemoteable.LoadString(IDS_NOT_REMOTEABLE);
		szUnavailable.LoadString(IDS_UNAVAILABLE);

		PageChanged(PB_BACKUP, false);

		// - - - - - - - - - - - - - -
		// Interval:
		iTemp = 0;
		hr = m_DS->GetBackupInterval(iTemp);
		if(SUCCEEDED(hr))
		{
			if(iTemp == 0)
			{
				Button_SetCheck(GetDlgItem(hDlg, IDC_BACKUP_ENABLED), BST_UNCHECKED);
				SetWindowText(GetDlgItem(hDlg, IDC_BACKUPINTERVAL), _T("0"));
				ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_BACKUP_UNITS), -1);
				enable = FALSE;
			}
			else
			{
				Button_SetCheck(GetDlgItem(hDlg, IDC_BACKUP_ENABLED), BST_CHECKED);
				SetInterval(hDlg, iTemp);
				enable = TRUE;
			}
		}
		else //failed
		{
			enable = FALSE;
			SetWindowText(GetDlgItem(hDlg, IDC_BACKUPINTERVAL),
							szUnavailable);
			::EnableWindow(GetDlgItem(hDlg, IDC_BACKUP_ENABLED), enable);
		}

		::EnableWindow(GetDlgItem(hDlg, IDC_BACKUPINTERVAL), enable);
		::EnableWindow(GetDlgItem(hDlg, IDC_BACKUP_UNITS), enable);

		// - - - - - - - - - - - - - -
		// DB dir:
		HWND hWnd = GetDlgItem(hDlg, IDC_DB_DIR);
		if(hWnd)
		{
			CHString1 dir;
			hr = m_DS->GetDBLocation(dir);
			if(SUCCEEDED(hr))
			{
				TCHAR shortPath[40] = {0};
				PathCompactPathEx(shortPath, dir, 35,0);
				Edit_SetText(hWnd, (LPCTSTR)shortPath);
			}
		}

		// - - - - - - - - - - - - - -
		// Last backup:
		temp.Empty();

		hr = m_DS->GetLastBackup(temp);
		if(SUCCEEDED(hr))
		{
			enable = (hr != WBEM_S_FALSE);
			SetWindowText(GetDlgItem(hDlg, IDC_LASTBACKUP),
							temp);
		}
		else //failed
		{
			enable = FALSE;
			SetWindowText(GetDlgItem(hDlg, IDC_LASTBACKUP),
							szUnavailable);
		}
		::EnableWindow(GetDlgItem(hDlg, IDC_LASTBACKUP_LABEL), enable);
		::EnableWindow(GetDlgItem(hDlg, IDC_LASTBACKUP), enable);
	}
}

//------------------------------------------------------------------------
void CBackupPage::OnApply(HWND hDlg, bool bClose)
{
	if(m_bWhistlerCore == false)
	{
		HWND intervalHWND = GetDlgItem(hDlg, IDC_BACKUPINTERVAL);
		bool needToPut = false;
		UINT iValue = 0;
		bool valid = false;
		
		bool changed = GetInterval(hDlg, iValue, valid);

		if((changed || Edit_GetModify(intervalHWND)) && valid)
		{
			m_DS->SetBackupInterval(iValue);
			needToPut = true;
		}

		if(needToPut)
		{
			NeedToPut(PB_BACKUP, !bClose);
			if(!bClose)
				Refresh(hDlg);
		}
	}
}

//-----------------------------------------------------
void CBackupPage::Reconnect(void)
{
	HRESULT hr = 0;

	LOGIN_CREDENTIALS *credentials = m_DS->GetCredentials();

	m_DS->Disconnect();
	
	hr = m_DS->Connect(credentials);

	if(SUCCEEDED(hr))
	{
		m_alreadyAsked = false;

		if(ServiceIsReady(NO_UI, 0,0))
		{
			m_DS->Initialize(0);
		}
		else
		{
 			TCHAR caption[100] = {0}, msg[256] = {0};

			::LoadString(_Module.GetModuleInstance(), IDS_SHORT_NAME,
							caption, 100);

			::LoadString(_Module.GetModuleInstance(), IDS_CONNECTING, 
							msg, 256);

			if(DisplayAVIBox(m_hDlg, caption, msg, &m_AVIbox) == IDCANCEL)
			{
				g_serviceThread->Cancel();
			}
		}
	}
}

//-----------------------------------------------------
void CBackupPage::Reconnect2(void)
{
	m_DS->Disconnect();

 	TCHAR caption[100] = {0}, msg[256] = {0};

	::LoadString(_Module.GetModuleInstance(), IDS_SHORT_NAME,
					caption, 100);

	::LoadString(_Module.GetModuleInstance(), IDS_POST_RESTORE, 
					msg, 256);

	MessageBox(m_hDlg, (LPCTSTR)msg, (LPCTSTR)caption, 
							MB_OK|MB_DEFBUTTON1|MB_ICONEXCLAMATION);

	PropSheet_SetCurSel(GetParent(m_hDlg), 0, 0);
}

//---------------------------------------------------------------------------
void CBackupPage::OnFinishConnected(HWND hDlg, LPARAM lParam)
{
	if(m_AVIbox)
	{
		PostMessage(m_AVIbox, 
					WM_ASYNC_CIMOM_CONNECTED, 
					0, 0);
		m_AVIbox = 0;
	}

	IStream *pStream = (IStream *)lParam;
	IWbemServices *pServices = 0;
	HRESULT hr = CoGetInterfaceAndReleaseStream(pStream,
										IID_IWbemServices,
										(void**)&pServices);
	SetWbemService(pServices);

	if(ServiceIsReady(NO_UI, 0,0))
	{
		m_DS->Initialize(pServices);
	}

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
}	

//---------------------------------------------------------------
void CBackupPage::SetPriv(LPCTSTR privName, IWbemBackupRestore *br)
{
    ImpersonateSelf(SecurityImpersonation);

	if(OpenThreadToken( GetCurrentThread(), 
						TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
						FALSE, &m_hAccessToken ) )
	{
		m_fClearToken = true;

		// Now, get the LUID for the privilege from the local system
		ZeroMemory(&m_luid, sizeof(m_luid));

		LookupPrivilegeValue(NULL, privName, &m_luid);
//		m_cloak = true;
		EnablePriv(true, br);
	}
	else
	{
		DWORD err = GetLastError();
	}
}

//---------------------------------------------------------------------
bool CBackupPage::IsClientNT5OrMore(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen
    return ( os.dwPlatformId == VER_PLATFORM_WIN32_NT ) && ( os.dwMajorVersion >= 5 ) ;
}


//---------------------------------------------------------------
DWORD CBackupPage::EnablePriv(bool fEnable, IWbemBackupRestore *br)
{
	DWORD				dwError = ERROR_SUCCESS;
	TOKEN_PRIVILEGES	tokenPrivileges;

	tokenPrivileges.PrivilegeCount = 1;
	tokenPrivileges.Privileges[0].Luid = m_luid;
	tokenPrivileges.Privileges[0].Attributes = ( fEnable ? SE_PRIVILEGE_ENABLED : 0 );

	if(AdjustTokenPrivileges(m_hAccessToken, 
								FALSE, 
								&tokenPrivileges, 
								0, NULL, NULL) != 0)
	{
		HRESULT hr = E_FAIL;
		if(br)
		{
			//Privileges for backup/restore are only set for the local box
			//case, so in this case we need to set cloaking on the
			//interface for the privileges to be transfered with the call.
			//Make sure this is never called remotely, since in that case
			//the authident needs to be used and privileges are transferred
			//remotely so cloaking is NOT needed for remote (and if set
			//will null the user authident out !!)	    	
			try 
			{
			    
				hr = SetInterfaceSecurityEx(
                                br, 
                                m_cred->authIdent, //for local this is actually not relevant... 
                                NULL,
                                RPC_C_AUTHN_LEVEL_DEFAULT, 
                                RPC_C_IMP_LEVEL_IMPERSONATE,
                                IsClientNT5OrMore() ? EOAC_DYNAMIC_CLOAKING :
                                    EOAC_NONE);
                                  
			}
			catch( ... )
			{
				hr = E_FAIL;
			}
		}
	}
	else
	{
		dwError = ::GetLastError();
	}

	return dwError;
}

//---------------------------------------------------------------
void CBackupPage::ClearPriv(void)
{
//    m_cloak = true;
	EnablePriv(false);

	if(m_fClearToken)
	{
		CloseHandle(m_hAccessToken);
		m_hAccessToken = 0;
		m_fClearToken = false;
	}
}


//-----------------------------------------------------
void __cdecl BackupRestoreThread(LPVOID lpParameter)
{
	CBackupPage *me = (CBackupPage *)lpParameter;

	MULTI_QI qi = {&IID_IWbemBackupRestore, 0, 0};

	CoInitialize(0);

	if(me->m_DS->IsLocal())
	{
		me->m_backupHr = CoCreateInstanceEx(CLSID_WbemBackupRestore, 0, 
											CLSCTX_LOCAL_SERVER, 0, 1, &qi);
	}
	else
	{
		COSERVERINFO server = {0,0,0,0};
		WCHAR machine[100] = {0};

		#ifdef UNICODE
			wcscpy(machine, me->m_DS->m_whackedMachineName);
		#else
			mbstowcs(machine, 
						(LPCTSTR)me->m_DS->m_whackedMachineName, 
						_tcslen(me->m_DS->m_whackedMachineName) + 1);
		#endif

		server.pwszName = machine;

		COAUTHINFO authInfo = {10,0, 0, RPC_C_AUTHN_LEVEL_DEFAULT,
								RPC_C_IMP_LEVEL_IMPERSONATE, 
								me->m_cred->authIdent, 0};

		server.pAuthInfo = &authInfo;

		me->m_backupHr = CoCreateInstanceEx(CLSID_WbemBackupRestore, 0, 
											CLSCTX_REMOTE_SERVER, 
											&server, 1, &qi);
	}

	if(SUCCEEDED(me->m_backupHr) && SUCCEEDED(qi.hr))
	{
		IWbemBackupRestore *pBR = (IWbemBackupRestore *)qi.pItf;

            		    SetInterfaceSecurityEx(pBR, 
											me->m_cred->authIdent, 
											NULL,
											RPC_C_AUTHN_LEVEL_DEFAULT, 
											RPC_C_IMP_LEVEL_IMPERSONATE,
											0); 

		ATLTRACE(_T("begin backup/restore\n"));

		//Sleep(1000);

		CHString1 verStr;
		bool TgtisNT5 = true;
		if(me->m_DS)
		{
			me->m_DS->GetOSVersion(verStr);
			if(verStr[0] == _T('4'))
				TgtisNT5 = false;
		}

		if(me->m_doingBackup)
		{
			//Only set the privilege if we are local - otherwise the privilege is there already
			//in the thread token...
			if( me->m_DS->IsLocal() && TgtisNT5)
				me->SetPriv(SE_BACKUP_NAME, pBR);

			me->m_backupHr = pBR->Backup(me->m_wszArgs, 0);
		}
		else
		{
			//Only set the privilege if we are local - otherwise the privilege is there already
			//in the thread token...
			if( me->m_DS->IsLocal() && TgtisNT5)
				me->SetPriv(SE_RESTORE_NAME, pBR);

			me->m_backupHr = pBR->Restore(me->m_wszArgs,
								WBEM_FLAG_BACKUP_RESTORE_FORCE_SHUTDOWN);
		}

		if(TgtisNT5)
			me->ClearPriv();

		ATLTRACE(_T("done backup/restore\n"));

		qi.pItf->Release();
	}

	CoUninitialize();

	// kill the distraction.
	if(me->m_AVIbox)
	{
		::PostMessage(me->m_AVIbox, WM_ASYNC_CIMOM_CONNECTED, 0, 0);
	}

	_endthread();
}


//------------------------------------------------------------------------
void CBackupPage::DealWithPath(LPCTSTR pathFile)
{
	#ifdef UNICODE
        if (m_wszArgs != NULL)
            delete m_wszArgs;

        m_wszArgs = new TCHAR[lstrlen(pathFile) + 1];

        if (m_wszArgs != NULL)
            lstrcpy(m_wszArgs, pathFile);
	#else
		size_t nSize = mbstowcs(NULL, (LPCTSTR)pathFile, _tcslen(pathFile) + 1);
		m_wszArgs = new wchar_t[nSize + 1];
		mbstowcs(m_wszArgs, (LPCTSTR)pathFile, _tcslen(pathFile) + 1);
	#endif
}

//------------------------------------------------------------------------
void CBackupPage::DealWithDomain(void)
{
	m_cred = m_DS->GetCredentials();

    // 54062- Nt 4.0 rpc crashes if given a null domain name along with a valid user name

    if((m_cred->authIdent != 0) &&
		(m_cred->authIdent->DomainLength == 0) && 
		(m_cred->authIdent->UserLength > 0) && IsNT(4))
    {
	    LPTSTR pNTDomain = NULL;

        CNtSid sid(CNtSid::CURRENT_USER);

        DWORD dwRet = sid.GetInfo(NULL, &pNTDomain, NULL);

        if(dwRet == 0)
        {
		#ifdef UNICODE
			if(m_cred->authIdent->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI)
			{
				// convert UNICODE to ansi.
				int size = wcstombs(NULL, pNTDomain, 0);
				
				m_cred->authIdent->Domain =
                        (LPWSTR)CoTaskMemAlloc((size+1) * sizeof(TCHAR));
                if (m_cred->authIdent->Domain != NULL)
                {
				    memset(m_cred->authIdent->Domain, 0,
                            (size+1) * sizeof(TCHAR));
				    wcstombs((char *)m_cred->authIdent->Domain, pNTDomain,
                                size);
				    m_cred->authIdent->DomainLength = size;
                }
			}
			else
			{
				//straight unicode copy.
				m_cred->authIdent->DomainLength = wcslen(pNTDomain);
				m_cred->authIdent->Domain = (LPWSTR)pNTDomain;
			}
		#else // ANSI
			if(m_cred->authIdent->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI)
			{
				//straight ansi copy.
				m_cred->authIdent->DomainLength = strlen(pNTDomain);
				m_cred->authIdent->Domain = (LPWSTR)pNTDomain;
			}
			else
			{
				// convert ansi to UNICODE.
				int size = mbstowcs(NULL, pNTDomain, 0);
				WCHAR temp[100] = {0};
				m_cred->authIdent->Domain =
                        (LPWSTR)CoTaskMemAlloc((size+1) * sizeof(WCHAR));
                if (m_cred->authIdent->Domain != NULL)
                {
				    memset(m_cred->authIdent->Domain, 0,
                            (size+1) * sizeof(WCHAR));
				    mbstowcs(temp, pNTDomain, min(100, size));
				    wcscpy(m_cred->authIdent->Domain, temp);
				    m_cred->authIdent->DomainLength = size;
			    }
			}

		#endif UNICODE
        }
    }
}

//----------------------------------------------------------
BOOL CBackupPage::BackupMethod(HWND hDlg, LPCTSTR pathFile)
{
	UINT prompt = IDYES;

	TCHAR drive[_MAX_DRIVE] = {0}, path[_MAX_PATH] = {0},
		  temp[_MAX_PATH] = {0};

	// rip it apart.
	_tsplitpath(pathFile, drive, path, NULL, NULL);

	_tcscpy(temp, drive);
	_tcscat(temp, path);

	if(!m_DS->IsValidDir(CHString1(temp)))
	{
		CHString1 caption, threat;
		caption.LoadString(IDS_SHORT_NAME);
		threat.LoadString(IDS_NEED_EXISTING_DIR);

		MessageBox(hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
							MB_OK|MB_DEFBUTTON1|MB_ICONEXCLAMATION);

		return FALSE;
	}
	else if(m_DS->IsValidFile(pathFile))
	{
		CHString1 caption, threat;
		caption.LoadString(IDS_SHORT_NAME);
		threat.LoadString(IDS_BACKUP_OVERWRITE);

		prompt = MessageBox(hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
							MB_YESNO|MB_DEFBUTTON2|MB_ICONEXCLAMATION);

	}		

	if(prompt == IDYES)
	{
		DealWithPath(pathFile);

		// UI
		CHString1 title, msg, fmt;
		m_AVIbox = 0;
		TCHAR shortPath[33] = {0};
		m_backupHr = S_OK;

		title.LoadString(IDS_BACKUP_TITLE);
		fmt.LoadString(IDS_BACKUP_FMT);
		
		PathCompactPathEx(shortPath, pathFile, 32,0);
		msg.Format(fmt, shortPath);
		DealWithDomain();
		m_DS->m_rootThread.m_WbemServices.SetPriv(SE_BACKUP_NAME);
		m_doingBackup = true;

		if(_beginthread(BackupRestoreThread, 0,
						(LPVOID)this) != -1)
		{
			DisplayAVIBox(hDlg, title, msg, &m_AVIbox, FALSE);
		}

		if(FAILED(m_backupHr))
		{
			TCHAR msg[256] = {0};
			if(ErrorStringEx(m_backupHr,  msg, 256))
			{
				CHString1 caption;
				caption.LoadString(IDS_SHORT_NAME);
				MessageBox(hDlg, msg, caption, MB_OK| MB_ICONWARNING);
			}
		}
		m_DS->m_rootThread.m_WbemServices.ClearPriv();
	}  //endif doIt

	return SUCCEEDED(m_backupHr);
}

//------------------------------------------------------------------------
HRESULT CBackupPage::RestoreMethod(HWND hDlg, LPCTSTR pathFile)
{
	HRESULT hr = WBEM_E_NOT_FOUND;
	if(m_DS->IsValidFile(pathFile))
	{
		DealWithPath(pathFile);

		// UI
		CHString1 title, msg, fmt;
		m_AVIbox = 0;
		TCHAR shortPath[33] = {0};
		
		title.LoadString(IDS_RESTORE_TITLE);
		fmt.LoadString(IDS_RESTORE_FMT);

		PathCompactPathEx(shortPath, pathFile, 32,0);
		msg.Format(fmt, shortPath);
		DealWithDomain();

		m_doingBackup = false;
		if(_beginthread(BackupRestoreThread, 0,
						(LPVOID)this) != -1)
		{
			DisplayAVIBox(hDlg, title, msg, &m_AVIbox, FALSE);
			Reconnect2();
		}

		if(FAILED(m_backupHr))
		{
			TCHAR msg[256] = {0};
			if(ErrorStringEx(m_backupHr,  msg, 256))
			{
				CHString1 caption;
				caption.LoadString(IDS_SHORT_NAME);
				MessageBox(hDlg, msg, caption, MB_OK| MB_ICONWARNING);
			}
		}
		hr = m_backupHr;
	}
	else
	{
		// NOTE: shouldn't ever get here... but..
		CHString1 caption, threat;
		caption.LoadString(IDS_SHORT_NAME);
		threat.LoadString(IDS_NO_BACKUP_FILE);

		MessageBox(hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
						MB_OK|MB_ICONEXCLAMATION);
	}
	return hr;
}

//------------------------------------------------------------------------
BOOL CBackupPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR * pszFilter;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        InitDlg(hDlg);
        break;

	case WM_ASYNC_CIMOM_CONNECTED:
		{
			OnFinishConnected(hDlg, lParam);
			Refresh(hDlg);
		}
		break;

    case WM_NOTIFY:
        switch(((LPNMHDR)lParam)->code)
        {
        case PSN_SETACTIVE:
            Refresh(hDlg);
            break;

        case PSN_HELP:
			HTMLHelper(hDlg);
            break;

        case PSN_APPLY:
            OnApply(hDlg, (((LPPSHNOTIFY)lParam)->lParam == 1));
            break;
        }
        break;

    case WM_COMMAND:
		switch(LOWORD(wParam))
		{
		case IDC_BACKUPINTERVAL:
			if(HIWORD(wParam) == EN_KILLFOCUS)
			{
				TCHAR buf[4] = {0};
				int iVal = 0;
				::GetWindowText((HWND)lParam, buf, ARRAYSIZE(buf));
				iVal = _ttoi(buf);

				if(iVal == 0) 
				{
					BOOL enable = TRUE;
					CHString1 caption, threat;
					caption.LoadString(IDS_SHORT_NAME);
					threat.LoadString(IDS_BACKUP_THREAT);

					if(MessageBox(hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
									MB_YESNO|MB_DEFBUTTON2|MB_ICONEXCLAMATION) == IDYES)
					{
						ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_BACKUP_UNITS), -1);
						::EnableWindow((HWND)lParam, FALSE);
						::EnableWindow(GetDlgItem(hDlg, IDC_BACKUP_UNITS), FALSE);
						Button_SetCheck(GetDlgItem(hDlg, IDC_BACKUP_ENABLED), BST_UNCHECKED);
					}
					else
					{
						Button_SetCheck(GetDlgItem(hDlg, IDC_BACKUP_ENABLED), BST_CHECKED);
						Refresh(hDlg, true);
						return TRUE;
					}
				}

				PageChanged(PB_BACKUP, true);
			}
			else if((HIWORD(wParam) == EN_CHANGE) && 
					Edit_GetModify((HWND)lParam))
			{
				PageChanged(PB_BACKUP, true);
				return TRUE;
			}
			break;

		case IDC_BACKUP_UNITS:
			if(HIWORD(wParam) == CBN_SELCHANGE)
			{
				PageChanged(PB_BACKUP, true);
				return TRUE;
			}
			break;

		case IDC_RESTORE_FM_AUTO:
			if(HIWORD(wParam) == BN_CLICKED)
			{
				CHString1 dbPath;

				m_DS->GetDBDir(dbPath);
				dbPath += _T("\\Cim.rec");

				CHString1 caption, threat;
				caption.LoadString(IDS_AUTORESTORE);
				threat.LoadString(IDS_SURE);

				if(MessageBox(hDlg, threat, caption, 
								MB_YESNO|MB_DEFBUTTON2|MB_ICONQUESTION) == IDYES)
				{
					RestoreMethod(hDlg, dbPath);
				}
			}
			break;

		case IDC_BACKUP_BTN:
			if(HIWORD(wParam) == BN_CLICKED)
			{
				TCHAR pathFile[MAX_PATH] = {0};
				CHString1 dbPath;

				TCHAR recFilter[200] = {0}, all[100] = {0};

				TCHAR *pTemp = recFilter;

				m_DS->GetDBDir(dbPath);

				int recSize = ::LoadString(_Module.GetModuleInstance(), IDS_REC_FILTER,
								recFilter, 100);
				
				int allSize = ::LoadString(_Module.GetModuleInstance(), IDS_ALL_FILTER,
								all, 100);

				// Build this string with the words coming from the string table.
				//_T("WMI Recovery Files (*.rec)\0*.rec\0All Files (*.*)\0*.*\0\0");

                pszFilter = new TCHAR[_tcslen(recFilter) + 1 +
                                      ARRAYSIZE(REC_WILDCARD) +
                                      _tcslen(all) + 1 +
                                      ARRAYSIZE(ALL_WILDCARD) + 1];

                if (pszFilter != NULL)
                {
                    TCHAR * psz = pszFilter;
                    _tcscpy(psz, recFilter);
                    psz += recSize + 1;
                    _tcscpy(psz,REC_WILDCARD);
                    psz += ARRAYSIZE(REC_WILDCARD);
                    _tcscpy(psz, all);
                    psz += allSize + 1;
                    _tcscpy(psz, ALL_WILDCARD);
                    psz += ARRAYSIZE(ALL_WILDCARD);
                    *psz = _T('\0');
                                    
				    if(BrowseForFile(hDlg,
                                     IDS_OPEN_BACKUP,
                                     recFilter,
								     (LPCTSTR)dbPath,
                                     pathFile,
                                     MAX_PATH))
				    {
					    BackupMethod(hDlg, pathFile);
				    }

                    delete pszFilter;
                }
			}
			break;

		case IDC_RESTORE_BTN:
			if(HIWORD(wParam) == BN_CLICKED)
			{
				TCHAR pathFile[MAX_PATH] = {0};
				CHString1 dbPath, title;
				TCHAR recFilter[100] = {0}, all[100] = {0};

				m_DS->GetDBDir(dbPath);

				int recSize = ::LoadString(_Module.GetModuleInstance(), IDS_REC_FILTER,
								recFilter, 100);
				
				int allSize = ::LoadString(_Module.GetModuleInstance(), IDS_ALL_FILTER,
								all, 100);

				// Build this string with the words coming from the string table.
				//_T("WMI Recovery Files (*.rec)\0*.rec\0All Files (*.*)\0*.*\0\0");

                pszFilter = new TCHAR[_tcslen(recFilter) + 1 +
                                      ARRAYSIZE(REC_WILDCARD) +
                                      _tcslen(all) + 1 +
                                      ARRAYSIZE(ALL_WILDCARD) + 1];

                if (pszFilter != NULL)
                {
                    TCHAR * psz = pszFilter;
                    _tcscpy(psz, recFilter);
                    psz += recSize + 1;
                    _tcscpy(psz,REC_WILDCARD);
                    psz += ARRAYSIZE(REC_WILDCARD);
                    _tcscpy(psz, all);
                    psz += allSize + 1;
                    _tcscpy(psz, ALL_WILDCARD);
                    psz += ARRAYSIZE(ALL_WILDCARD);
                    *psz = _T('\0');
                                    
				    if(BrowseForFile(hDlg,
                                     IDS_OPEN_RESTORE,
                                     pszFilter,
								     (LPCTSTR)dbPath,
                                     pathFile,
                                     MAX_PATH,
								     0))
				    {
					    RestoreMethod(hDlg, pathFile);
				    }

                    delete pszFilter;
                }
			}
			break;

		case IDC_BACKUP_ENABLED:
			if(HIWORD(wParam) == BN_CLICKED)
			{
				int x = Button_GetState((HWND)lParam);
				BOOL checked = (x & BST_CHECKED);
				BOOL enable = FALSE;
				if(checked)
				{
					// turn on and repopulate the edit fields.
					CHString1 temp;
					UINT iTemp = 30;
					SetInterval(hDlg, iTemp);
					enable = TRUE;
				}
				else  // turning off.
				{
					CHString1 caption, threat;
					caption.LoadString(IDS_SHORT_NAME);
					threat.LoadString(IDS_BACKUP_THREAT);

					if(MessageBox(hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
									MB_YESNO|MB_DEFBUTTON2|MB_ICONEXCLAMATION) == IDYES)
					{
						SetWindowText(GetDlgItem(hDlg, IDC_BACKUPINTERVAL), _T("0"));
						ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_BACKUP_UNITS), -1);
						enable = FALSE;
					}
					else
					{
						Button_SetCheck(GetDlgItem(hDlg, IDC_BACKUP_ENABLED), BST_CHECKED);
						Refresh(hDlg);
						return TRUE;
					}
				}
				::EnableWindow(GetDlgItem(hDlg, IDC_BACKUPINTERVAL), enable);
				::EnableWindow(GetDlgItem(hDlg, IDC_BACKUP_UNITS), enable);

				PageChanged(PB_BACKUP, true);
				return TRUE;
			}
			break;

		default: break;
		} //endswitch(LOWORD(wParam))
	
        break;

    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_HelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)buPageHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp(hDlg, c_HelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)buPageHelpIDs);
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void CBackupPage::HideAutomaticBackupControls(HWND hDlg)
{
	ShowWindow(GetDlgItem(hDlg,IDC_AUTOMATIC_GROUPBOX),SW_HIDE);
	ShowWindow(GetDlgItem(hDlg,IDC_ADV_NOW_TEXT),SW_HIDE);
	ShowWindow(GetDlgItem(hDlg,IDC_BACKUP_ENABLED),SW_HIDE);
	ShowWindow(GetDlgItem(hDlg,IDC_BACKUPINTERVAL),SW_HIDE);
	ShowWindow(GetDlgItem(hDlg,IDC_BACKUP_UNITS),SW_HIDE);
	ShowWindow(GetDlgItem(hDlg,IDC_LASTBACKUP_LABEL),SW_HIDE);
	ShowWindow(GetDlgItem(hDlg,IDC_LASTBACKUP),SW_HIDE);
	ShowWindow(GetDlgItem(hDlg,IDC_RESTORE_FM_AUTO),SW_HIDE);
	ShowWindow(GetDlgItem(hDlg,IDC_BACKUP_UNITS),SW_HIDE);
	ShowWindow(GetDlgItem(hDlg,IDC_DBDIRECTORY_LABEL),SW_HIDE);
	ShowWindow(GetDlgItem(hDlg,IDC_DB_DIR),SW_HIDE);

	SetWindowPos(GetDlgItem(hDlg,IDC_MANUAL_GROUPBOX),NULL,7,12,0,0,SWP_NOSIZE | SWP_NOZORDER);
	SetWindowPos(GetDlgItem(hDlg,IDC_ADV_NOW_TEXT2),NULL,32,35,0,0,SWP_NOSIZE | SWP_NOZORDER);
	SetWindowPos(GetDlgItem(hDlg,IDC_BACKUP_BTN),NULL,40,97,87,14,SWP_NOSIZE | SWP_NOZORDER);
	SetWindowPos(GetDlgItem(hDlg,IDC_RESTORE_BTN),NULL,195,97,87,14,SWP_NOSIZE | SWP_NOZORDER);
	m_bWhistlerCore = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\chklisthandler.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"

#ifdef EXT_DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "ChkListHandler.h"
#include "resource.h"

//---------------------------------------
CCheckListHandler::CCheckListHandler()
{
	m_hDlg = 0;
	m_hwndList = 0;
}

//---------------------------------------
void CCheckListHandler::Attach(HWND hDlg, int chklistID)
{
	m_hDlg = hDlg;
	m_hwndList = GetDlgItem(hDlg, chklistID);
}

//---------------------------------------
CCheckListHandler::~CCheckListHandler()
{
	Empty();
}

//---------------------------------------
void CCheckListHandler::Empty(void)
{
    if (m_hwndList != NULL)
    {
        UINT_PTR cItems = SendMessage(m_hwndList, CLM_GETITEMCOUNT, 0, 0);

        while (cItems > 0)
        {
            cItems--;
        }
    }
    SendMessage(m_hwndList, CLM_RESETCONTENT, 0, 0);
}

//-----------------------------------------------------------------------------
void CCheckListHandler::Reset(void)
{
    SendMessage(m_hwndList, CLM_RESETCONTENT, 0, 0);
}

//-------------------------------------------------------
#define AllFlagsOn(dw1, dw2)        (((dw1) & (dw2)) == (dw2))  // equivalent to ((dw1 | dw2) == dw1)

void CCheckListHandler::HandleListClick(PNM_CHECKLIST pnmc)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\chklist.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*

    CHKLIST.CPP

    This file contains the implementation of the CheckList control.

*/

#include "precomp.h"
#include <windowsx.h>
#include "chklist.h"
#include "debug.h"
#include "Richedit.h"

//
// Text and Background colors
//
#define TEXT_COLOR  COLOR_WINDOWTEXT
#define BK_COLOR    COLOR_WINDOW

//
// Default dimensions for child controls. All are in dialog units.
// Currently only the column width is user-adjustable (via the
// CLM_SETCOLUMNWIDTH message).
//
#define DEFAULT_COLUMN_WIDTH    32
#define DEFAULT_CHECK_WIDTH     9
#define DEFAULT_HORZ_SPACE      7
#define DEFAULT_VERTICAL_SPACE  3
#define DEFAULT_ITEM_HEIGHT     8

//
// 16 bits are used for the control ID's, divided into n bits for
// the subitem (least significant) and 16-n bits for the item index.
//
// ID_SUBITEM_BITS can be adjusted to control the maximum number of
// items and subitems. For example, to allow up to 7 subitems and 8k
// items, set ID_SUBITEM_BITS to 3.
//

// Use the low 2 bits for the subitem index, the rest for the item index.
// (4 subitems max, 16k items max)
#define ID_SUBITEM_BITS         2

#define ID_SUBITEM_MASK         ((1 << ID_SUBITEM_BITS) - 1)
#define GET_ITEM(id)            ((id) >> ID_SUBITEM_BITS)
#define GET_SUBITEM(id)         ((id) & ID_SUBITEM_MASK)

#define MAKE_CTRL_ID(i, s)      (0xffff & (((i) << ID_SUBITEM_BITS) | ((s) & ID_SUBITEM_MASK)))
#define MAKE_LABEL_ID(i)        MAKE_CTRL_ID(i, 0)
// Note that the subitem (column) index is one-based for the checkboxes
// (the zero column is the label).  The item (row) index is zero-based.

#define MAX_CHECK_COLUMNS       ID_SUBITEM_MASK


typedef struct _USERDATA_STRUCT_LABEL
{
    LPARAM      lParam;
    int         nLabelHeight;
} USERDATA_STRUCT_LABEL, *LPUSERDATA_STRUCT_LABEL;

class CCheckList
{
private:
    LONG m_cItems;
    LONG m_cSubItems;
    RECT m_rcItemLabel;
    LONG m_nCheckPos[MAX_CHECK_COLUMNS];
    LONG m_cxCheckBox;
    LONG m_cxCheckColumn;

    int m_nDefaultVerticalSpace;
    int m_nDefaultItemHeight;
    int m_nNewItemYPos;

    HWND m_hwndCheckFocus;

    BOOL m_fInMessageEnable;

    int m_cWheelDelta;
    static UINT g_ucScrollLines;

private:
    CCheckList(HWND hWnd, LPCREATESTRUCT lpcs);

    LRESULT MsgCommand(HWND hWnd, WORD idCmd, WORD wNotify, HWND hwndCtrl);
    void MsgPaint(HWND hWnd, HDC hdc);
    void MsgVScroll(HWND hWnd, int nCode, int nPos);
    void MsgMouseWheel(HWND hWnd, WORD fwFlags, int zDelta);
    void MsgButtonDown(HWND hWnd, WPARAM fwFlags, int xPos, int yPos);
    void MsgEnable(HWND hWnd, BOOL fEnabled);
    void MsgSize(HWND hWnd, DWORD dwSizeType, LONG nWidth, LONG nHeight);

    LONG AddItem(HWND hWnd, LPCTSTR pszLabel, LPARAM lParam);
    void SetState(HWND hWnd, WORD iItem, WORD iSubItem, LONG lState);
    LONG GetState(HWND hWnd, WORD iItem, WORD iSubItem);
    void SetColumnWidth(HWND hWnd, LONG cxDialog, LONG cxColumn);
    void ResetContent(HWND hWnd);
    LONG GetVisibleCount(HWND hWnd);
    LONG GetTopIndex(HWND hWnd, LONG *pnAmountObscured = NULL);
    void SetTopIndex(HWND hWnd, LONG nIndex);
    void EnsureVisible(HWND hWnd, LONG nIndex);
    void DrawCheckFocusRect(HWND hWnd, HWND hwndCheck, BOOL fDraw);

public:
    static LRESULT CALLBACK WindowProc(HWND hWnd,
                                       UINT uMsg,
                                       WPARAM wParam,
                                       LPARAM lParam);
};

BOOL RegisterCheckListWndClass(void)
{
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CCheckList::WindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
//    AFX_MANAGE_STATE(AfxGetStaticModuleState()); // Required for AfxGetInstanceHandle()
    wc.hInstance        = _Module.GetModuleInstance(); //hModule;
    wc.hIcon            = NULL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(BK_COLOR+1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = TEXT(WC_CHECKLIST);

    return (BOOL)RegisterClass(&wc);
}


UINT CCheckList::g_ucScrollLines = (UINT)-1;


CCheckList::CCheckList(HWND hWnd, LPCREATESTRUCT lpcs)
: m_cItems(0), m_hwndCheckFocus(NULL), m_fInMessageEnable(FALSE), m_cWheelDelta(0)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::CCheckList");
    TraceAssert(hWnd != NULL);
    TraceAssert(lpcs != NULL);

    //
    // Get number of check columns
    //
    m_cSubItems = lpcs->style & CLS_CHECKMASK;

    // for wsecedit only
    if ( m_cSubItems > 3 ) {
        m_cSubItems = 3;
    }

    //
    // Convert default coordinates from dialog units to pixels
    //
    RECT rc;
    rc.left = DEFAULT_CHECK_WIDTH;
    rc.right = DEFAULT_COLUMN_WIDTH;
    rc.top = rc.bottom = 0;
    MapDialogRect(lpcs->hwndParent, &rc);

    // Save the converted values
    m_cxCheckBox = rc.left;
    m_cxCheckColumn = rc.right;

    rc.left = DEFAULT_HORZ_SPACE;
    rc.top = DEFAULT_VERTICAL_SPACE;
    rc.right = 10;              // bogus (unused)
    rc.bottom = DEFAULT_VERTICAL_SPACE + DEFAULT_ITEM_HEIGHT;
    MapDialogRect(lpcs->hwndParent, &rc);

    // Save the converted values
    m_rcItemLabel = rc;

    m_nDefaultVerticalSpace = rc.top;
    m_nDefaultItemHeight = rc.bottom - rc.top;
    m_nNewItemYPos = rc.top;

    //
    // Get info for mouse wheel scrolling
    //
    if ((UINT)-1 == g_ucScrollLines)
    {
        g_ucScrollLines = 3; // default
        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &g_ucScrollLines, 0);
    }

    TraceLeaveVoid();
}


LRESULT
CCheckList::MsgCommand(HWND hWnd, WORD idCmd, WORD wNotify, HWND hwndCtrl)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::MsgCommand");

    // Should only get notifications from visible, enabled, check boxes
    TraceAssert(GET_ITEM(idCmd) < m_cItems);
    TraceAssert(0 < GET_SUBITEM(idCmd) && GET_SUBITEM(idCmd) <= m_cSubItems);
    TraceAssert(hwndCtrl && IsWindowEnabled(hwndCtrl));

    switch (wNotify)
    {
    case EN_SETFOCUS:
        {
            // Make the focus go to one of the checkboxes
            POINT pt;
            DWORD dwPos = GetMessagePos();
            pt.x = GET_X_LPARAM(dwPos);
            pt.y = GET_Y_LPARAM(dwPos);
            MapWindowPoints(NULL, hWnd, &pt, 1);
            MsgButtonDown(hWnd, 0, pt.x, pt.y);
        }
        break;

    case BN_CLICKED:
        {
            LPUSERDATA_STRUCT_LABEL lpUserData;
            NM_CHECKLIST nmc;
            nmc.hdr.hwndFrom = hWnd;
            nmc.hdr.idFrom = GetDlgCtrlID(hWnd);
            nmc.hdr.code = CLN_CLICK;
            nmc.iItem = GET_ITEM(idCmd);
            nmc.iSubItem = GET_SUBITEM(idCmd);
            nmc.dwState = (DWORD)SendMessage(hwndCtrl, BM_GETCHECK, 0, 0);
            if (!IsWindowEnabled(hwndCtrl))
                nmc.dwState |= CLST_DISABLED;
            lpUserData = (LPUSERDATA_STRUCT_LABEL)
                            GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID(nmc.iItem)),
                                                GWLP_USERDATA);
            nmc.dwItemData = lpUserData->lParam;

            SendMessage(GetParent(hWnd),
                        WM_NOTIFY,
                        nmc.hdr.idFrom,
                        (LPARAM)&nmc);

        }
        break;

    case BN_SETFOCUS:
        if (GetFocus() != hwndCtrl)
        {
            // This causes another BN_SETFOCUS
            SetFocus(hwndCtrl);
        }
        else
        {
            if (m_hwndCheckFocus != hwndCtrl)   // Has the focus moved?
            {
                // Remember where the focus is
                m_hwndCheckFocus = hwndCtrl;

                // Make sure the row is scrolled into view
                EnsureVisible(hWnd, GET_ITEM(idCmd));
            }
            // Always draw the focus rect
            DrawCheckFocusRect(hWnd, hwndCtrl, TRUE);
        }
        break;

    case BN_KILLFOCUS:
        // Remove the focus rect
        m_hwndCheckFocus = NULL;
        DrawCheckFocusRect(hWnd, hwndCtrl, FALSE);
        break;
    }

    TraceLeaveValue(0);
}


void
CCheckList::MsgPaint(HWND hWnd, HDC hdc)
{
    if (hdc == NULL && m_hwndCheckFocus != NULL)
    {
        // This will cause a focus rect to be drawn after the window and
        // all checkboxes have been painted.
        PostMessage(hWnd,
                    WM_COMMAND,
                    GET_WM_COMMAND_MPS(GetDlgCtrlID(m_hwndCheckFocus), m_hwndCheckFocus, BN_SETFOCUS));
    }

    // Default paint
    DefWindowProc(hWnd, WM_PAINT, (WPARAM)hdc, 0);
}


void
CCheckList::MsgVScroll(HWND hWnd, int nCode, int nPos)
{
    UINT cScrollUnitsPerLine;
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;

    if (!GetScrollInfo(hWnd, SB_VERT, &si))
        return;

    cScrollUnitsPerLine = m_rcItemLabel.bottom;

    // One page is always visible, so adjust the range to a more useful value
    si.nMax -= si.nPage - 1;

    switch (nCode)
    {
    case SB_LINEUP:
        // "line" is the height of one item (includes the space in between)
        nPos = si.nPos - cScrollUnitsPerLine;
        break;

    case SB_LINEDOWN:
        nPos = si.nPos + cScrollUnitsPerLine;
        break;

    case SB_PAGEUP:
        nPos = si.nPos - si.nPage;
        break;

    case SB_PAGEDOWN:
        nPos = si.nPos + si.nPage;
        break;

    case SB_TOP:
        nPos = si.nMin;
        break;

    case SB_BOTTOM:
        nPos = si.nMax;
        break;

    case SB_ENDSCROLL:
        nPos = si.nPos;     // don't go anywhere
        break;

    case SB_THUMBTRACK:
        // Do nothing here to allow tracking
        // nPos = si.nPos;    // Do this to prevent tracking
    case SB_THUMBPOSITION:
        // nothing to do here... nPos is passed in
        break;
    }

    // Make sure the new position is within the range
    if (nPos < si.nMin)
        nPos = si.nMin;
    else if (nPos > si.nMax)
        nPos = si.nMax;

    if (nPos != si.nPos)  // are we moving?
    {
        SetScrollPos(hWnd, SB_VERT, nPos, TRUE);
        ScrollWindow(hWnd, 0, si.nPos - nPos, NULL, NULL);
    }
}


void
CCheckList::MsgMouseWheel(HWND hWnd, WORD fwFlags, int iWheelDelta)
{
    int cDetants;

    if ((fwFlags & (MK_SHIFT | MK_CONTROL)) || 0 == g_ucScrollLines)
        return;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::MsgMouseWheel");

    // Update count of scroll amount
    m_cWheelDelta -= iWheelDelta;
    cDetants = m_cWheelDelta / WHEEL_DELTA;
    if (0 == cDetants)
        TraceLeaveVoid();
    m_cWheelDelta %= WHEEL_DELTA;

    if (WS_VSCROLL & GetWindowLong(hWnd, GWL_STYLE))
    {
        SCROLLINFO  si;
        UINT        cScrollUnitsPerLine;
        UINT        cLinesPerPage;
        UINT        cLinesPerDetant;

        // Get the scroll amount of one line
        cScrollUnitsPerLine = m_rcItemLabel.bottom;
        TraceAssert(cScrollUnitsPerLine > 0);

        si.cbSize = sizeof(SCROLLINFO);
        si.fMask = SIF_PAGE | SIF_POS;
        if (!GetScrollInfo(hWnd, SB_VERT, &si))
            TraceLeaveVoid();

        // The size of a page is at least one line, and
        // leaves one line of overlap
        cLinesPerPage = (si.nPage - cScrollUnitsPerLine) / cScrollUnitsPerLine;
        cLinesPerPage = max(1, cLinesPerPage);

        // Don't scroll more than one page per detant
        cLinesPerDetant = min(cLinesPerPage, g_ucScrollLines);

        si.nPos += cDetants * cLinesPerDetant * cScrollUnitsPerLine;

        MsgVScroll(hWnd, SB_THUMBTRACK, si.nPos);
    }
    TraceLeaveVoid();
}


void
CCheckList::MsgButtonDown(HWND hWnd, WPARAM /*fwFlags*/, int /*xPos*/, int yPos)
{
    LONG nItemIndex;
    HWND hwndCheck;
    RECT rc;

    // Get position of the top visible item in client coords
    nItemIndex = GetTopIndex(hWnd);
    if (nItemIndex == -1)
    {
        return;
    }
    hwndCheck = GetDlgItem(hWnd, MAKE_CTRL_ID(nItemIndex, 0));
    GetWindowRect(hwndCheck, &rc);
    MapWindowPoints(NULL, hWnd, (LPPOINT)&rc, 2);

    // Find nearest item
    nItemIndex += (yPos - rc.top + m_rcItemLabel.top/2)/m_rcItemLabel.bottom;
    nItemIndex = max(0, min(nItemIndex, m_cItems - 1)); // 0 <= y < m_cItems

    // Set focus to first subitem that is enabled
    for (LONG j = 1; j <= m_cSubItems; j++)
    {
        int id = MAKE_CTRL_ID(nItemIndex, j);
        HWND hwndCheck = GetDlgItem(hWnd, id);
        if (IsWindowEnabled(hwndCheck))
        {
            // Don't just SetFocus here.  We sometimes call this during
            // EN_SETFOCUS, and USER doesn't like it when you mess with
            // focus during a focus change.
            //
            //SetFocus(hwndCheck);
            PostMessage(hWnd,
                        WM_COMMAND,
                        GET_WM_COMMAND_MPS(id, hwndCheck, BN_SETFOCUS));
            break;
        }
    }
}


void
CCheckList::MsgEnable(HWND hWnd, BOOL fEnabled)
{
    HWND hwndCurrentCheck;
    BOOL fCheckEnabled;

    if (!m_fInMessageEnable)
    {
        m_fInMessageEnable = TRUE;
        for (LONG i = 0; i < m_cItems; i++)
        {
            for (LONG j = 1; j <= m_cSubItems; j++)
            {
                hwndCurrentCheck = GetDlgItem(hWnd, MAKE_CTRL_ID(i, j));
                fCheckEnabled =   (BOOL) GetWindowLongPtr(hwndCurrentCheck, GWLP_USERDATA);

                //
                // If the user of the checklist control is disabling the control
                // altogether, or the current checkbox has been disabled singularly
                // then disable the checkbox
                //
                if (!fEnabled || !fCheckEnabled)
                {
                    EnableWindow(hwndCurrentCheck, FALSE);
                }
                else
                {
                    EnableWindow(hwndCurrentCheck, TRUE);
                }
            }
        }
        // Note that the main chklist window must remain enabled
        // for scrolling to work while "disabled".
        if (!fEnabled)
            EnableWindow(hWnd, TRUE);

        m_fInMessageEnable = FALSE;
    }
}


void
CCheckList::MsgSize(HWND hWnd, DWORD dwSizeType, LONG nWidth, LONG nHeight)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::MsgSize");
    TraceAssert(hWnd != NULL);

    if (dwSizeType == SIZE_RESTORED)
    {
        RECT rc;
        SCROLLINFO si;

        si.cbSize = sizeof(si);
        si.fMask = SIF_RANGE | SIF_PAGE;
        si.nMin = 0;
        si.nMax = m_nNewItemYPos - 1;
        si.nPage = nHeight;

        SetScrollInfo(hWnd, SB_VERT, &si, FALSE);

        // Don't trust the width value passed in, since SetScrollInfo may
        // affect it if the scroll bar is turning on or off.
        GetClientRect(hWnd, &rc);
        nWidth = rc.right;

        // If the scrollbar is turned on, artificially bump up the width
        // by the width of the scrollbar, so the boxes don't jump to the left
        // when we have a scrollbar.
        if ((UINT)si.nMax >= si.nPage)
            nWidth += GetSystemMetrics(SM_CYHSCROLL);

        SetColumnWidth(hWnd, nWidth, m_cxCheckColumn);
    }

    TraceLeaveVoid();
}

LONG
CCheckList::AddItem(HWND hWnd, LPCTSTR pszLabel, LPARAM lParam)
{
    HWND                    hwndNew;
    HWND                    hwndPrev;
    RECT                    rc;
    LONG                    nLabelHeight;
    HINSTANCE               hModule;
    HDC                     hdc;
    TEXTRANGE               tr;
    SIZE                    size;
    LPUSERDATA_STRUCT_LABEL lpUserData;
    SCROLLINFO              si;
    LONG                    nLineCount = 1;
    LONG                    i, j;
    DWORD                   dwCheckStyle;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::AddItem");
    TraceAssert(hWnd != NULL);
    TraceAssert(pszLabel != NULL && !IsBadStringPtr(pszLabel, MAX_PATH));

    lpUserData = new (USERDATA_STRUCT_LABEL);
    if (lpUserData == NULL)
        TraceLeaveValue(-1);

    si.cbSize = sizeof(si);
    si.fMask = SIF_POS;
    si.nPos = 0;
    GetScrollInfo(hWnd, SB_VERT, &si);

    // Set the initial label height extra big so the control can wrap the text,
    // then reset it after creating the control.
    GetClientRect(hWnd, &rc);
    nLabelHeight = rc.bottom;

//    AFX_MANAGE_STATE(AfxGetStaticModuleState()); // Required for AfxGetInstanceHandle()
    hModule = _Module.GetModuleInstance();

    // Create a new label control
    hwndNew = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
                             TEXT("edit"),
                             pszLabel,
                             WS_CHILD | WS_VISIBLE | WS_GROUP | ES_MULTILINE | ES_READONLY | ES_LEFT,// | WS_GROUP,
                             m_rcItemLabel.left,
                             m_nNewItemYPos - si.nPos,
                             m_rcItemLabel.right - m_rcItemLabel.left,
                             nLabelHeight,
                             hWnd,
                             (HMENU)IntToPtr(MAKE_LABEL_ID(m_cItems)),
                             hModule,
                             NULL);
    if (!hwndNew)
    {
        delete (lpUserData);
        TraceLeaveValue(-1);
    }

    //
    // Reset window height after word wrap has been done.
    //
    nLineCount = (LONG) SendMessage(hwndNew, EM_GETLINECOUNT, 0, (LPARAM) 0);
    nLabelHeight = nLineCount * m_nDefaultItemHeight;
    SetWindowPos(hwndNew,
                 NULL,
                 0,
                 0,
                 m_rcItemLabel.right - m_rcItemLabel.left,
                 nLabelHeight,
                 SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

    //
    // Save item data
    //
    lpUserData->lParam = lParam;
    lpUserData->nLabelHeight = nLabelHeight;
    SetWindowLongPtr(hwndNew, GWLP_USERDATA, (LPARAM) lpUserData);

    // Set the font
    SendMessage(hwndNew,
                WM_SETFONT,
                SendMessage(GetParent(hWnd), WM_GETFONT, 0, 0),
                0);

    // Set Z-order position just after the last checkbox. This keeps
    // tab order correct.
    if (m_cItems > 0)
    {
        hwndPrev = GetDlgItem(hWnd, MAKE_CTRL_ID(m_cItems - 1, m_cSubItems));
        SetWindowPos(hwndNew,
                     hwndPrev,
                     0, 0, 0, 0,
                     SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    }

    // Create new checkboxes
    dwCheckStyle = WS_CHILD | WS_VISIBLE | WS_GROUP | WS_TABSTOP | BS_NOTIFY | BS_FLAT | BS_AUTOCHECKBOX;
    for (j = 0; j < m_cSubItems; j++)
    {
        hwndPrev = hwndNew;
        hwndNew = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
                                 TEXT("BUTTON"),
                                 NULL,
                                 dwCheckStyle,
                                 m_nCheckPos[j],
                                 m_nNewItemYPos - si.nPos,
                                 m_cxCheckBox,
                                 m_rcItemLabel.bottom - m_rcItemLabel.top,
                                 hWnd,
                                 (HMENU)IntToPtr(MAKE_CTRL_ID(m_cItems, j + 1)),
                                 hModule,
                                 NULL);
        if (!hwndNew)
        {
            while (j >= 0)
            {
                DestroyWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(m_cItems, j)));
                j--;
            }

            TraceLeaveValue(-1);
        }

        SetWindowPos(hwndNew,
                     hwndPrev,
                     0, 0, 0, 0,
                     SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

        //
        // Default "enabled" to TRUE
        //
        SetWindowLongPtr(hwndNew, GWLP_USERDATA, (LPARAM) TRUE);

        // Only want this style on the first checkbox
        dwCheckStyle &= ~WS_GROUP;
    }

    // We now officially have a new item
    m_cItems++;

    // calculate Y pos for next item to be inserted
    m_nNewItemYPos += nLabelHeight + m_nDefaultVerticalSpace;

    //
    // The last thing is to set the scroll range
    //
    GetClientRect(hWnd, &rc);
    si.cbSize = sizeof(si);
    si.fMask = SIF_PAGE | SIF_RANGE;
    si.nMin = 0;
    si.nMax = m_nNewItemYPos - 1;
    si.nPage = rc.bottom;

    SetScrollInfo(hWnd, SB_VERT, &si, FALSE);

    TraceLeaveValue(m_cItems - 1);  // return the index of the new item
}


void
CCheckList::SetState(HWND hWnd, WORD iItem, WORD iSubItem, LONG lState)
{
    HWND hwndCtrl;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::SetState");
    TraceAssert(hWnd != NULL);
    TraceAssert(iItem < m_cItems);
    TraceAssert(0 < iSubItem && iSubItem <= m_cSubItems);

    if (iSubItem > 0)
    {
        hwndCtrl = GetDlgItem(hWnd, MAKE_CTRL_ID(iItem, iSubItem));
        if (hwndCtrl != NULL)
        {
            SetWindowLongPtr(hwndCtrl, GWLP_USERDATA, (LPARAM) !(lState & CLST_DISABLED));
            SendMessage(hwndCtrl, BM_SETCHECK, lState & CLST_CHECKED, 0);
            EnableWindow(hwndCtrl, !(lState & CLST_DISABLED));
        }
    }

    TraceLeaveVoid();
}


LONG
CCheckList::GetState(HWND hWnd, WORD iItem, WORD iSubItem)
{
    LONG lState = 0;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::GetState");
    TraceAssert(hWnd != NULL);
    TraceAssert(iItem < m_cItems);
    TraceAssert(0 < iSubItem && iSubItem <= m_cSubItems);

    HWND hwndCtrl = GetDlgItem(hWnd, MAKE_CTRL_ID(iItem, iSubItem));

    if (hwndCtrl != NULL)
    {
        lState = (LONG)SendMessage(hwndCtrl, BM_GETCHECK, 0, 0);
        TraceAssert(!(lState & BST_INDETERMINATE));

        if (!IsWindowEnabled(hwndCtrl))
            lState |= CLST_DISABLED;
    }

    TraceLeaveValue(lState);
}


void
CCheckList::SetColumnWidth(HWND hWnd, LONG cxDialog, LONG cxColumn)
{
    LONG                    j;
    LPUSERDATA_STRUCT_LABEL pUserData;
    LONG                    nLabelHeight;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::SetColumnWidth");
    TraceAssert(hWnd != NULL);
    TraceAssert(cxColumn > 10);

    m_cxCheckColumn = cxColumn;

    if (m_cSubItems > 0)
    {
        m_nCheckPos[m_cSubItems-1] = cxDialog                       // dlg width
                                    - m_rcItemLabel.left            // right margin
                                    - (cxColumn + m_cxCheckBox)/2;  // 1/2 col & 1/2 checkbox

        for (j = m_cSubItems - 1; j > 0; j--)
            m_nCheckPos[j-1] = m_nCheckPos[j] - cxColumn;

        //              (leftmost check pos) - (horz margin)
        m_rcItemLabel.right = m_nCheckPos[0] - m_rcItemLabel.left;
    }
    else
        m_rcItemLabel.right = cxDialog - m_rcItemLabel.left;

    LONG nTop = m_rcItemLabel.top;
    LONG nBottom = m_rcItemLabel.bottom;

    for (LONG i = 0; i < m_cItems; i++)
    {
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)i)),
                                        GWLP_USERDATA);
        if (pUserData != NULL)
        {
            nLabelHeight = pUserData->nLabelHeight;
        }
        else
        {
            nLabelHeight = nBottom - nTop;
        }

        MoveWindow(GetDlgItem(hWnd, MAKE_LABEL_ID(i)),
                   m_rcItemLabel.left,
                   nTop,
                   m_rcItemLabel.right - m_rcItemLabel.left,
                   nLabelHeight,
                   FALSE);

        for (j = 0; j < m_cSubItems; j++)
        {
            MoveWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j + 1)),
                       m_nCheckPos[j],
                       nTop,
                       m_cxCheckBox,
                       nBottom - nTop,
                       FALSE);
        }

        nTop += nLabelHeight + m_nDefaultVerticalSpace;
        nBottom += nLabelHeight + m_nDefaultVerticalSpace;
    }

    TraceLeaveVoid();
}


void
CCheckList::ResetContent(HWND hWnd)
{
    LPUSERDATA_STRUCT_LABEL pUserData;
    HWND                    hwndCurrentLabel;

    for (LONG i = 0; i < m_cItems; i++)
    {
        hwndCurrentLabel = GetDlgItem(hWnd, MAKE_LABEL_ID((int)i));
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   hwndCurrentLabel,
                                        GWLP_USERDATA);
        if (pUserData != NULL)
        {
            delete(pUserData);
        }
        DestroyWindow(hwndCurrentLabel);

        for (LONG j = 1; j <= m_cSubItems; j++)
        {
            DestroyWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j)));
        }
    }

    // Hide the scroll bar
    SetScrollRange(hWnd, SB_VERT, 0, 0, FALSE);
    m_cItems = 0;
}


LONG
CCheckList::GetVisibleCount(HWND hWnd)
{
    LONG                    nCount = 0;
    RECT                    rc;
    LONG                    nTopIndex;
    LONG                    nAmountShown = 0;
    LONG                    nAmountObscured = 0;
    LPUSERDATA_STRUCT_LABEL pUserData;

    if (!GetClientRect(hWnd, &rc))
    {
        return 1;
    }

    nTopIndex = GetTopIndex(hWnd, &nAmountObscured);
    if (nTopIndex == -1)
    {
        return 1;
    }

    while ((nTopIndex < m_cItems) && (nAmountShown < rc.bottom))
    {
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nTopIndex)),
                                        GWLP_USERDATA);
        nAmountShown += (m_nDefaultVerticalSpace + pUserData->nLabelHeight - nAmountObscured);
        nAmountObscured = 0;    // nAmountObscured only matters for the first iteration where
                                // the real top index's amount shown is being calculated
        nCount++;
        nTopIndex++;
    }

    //
    // since that last one may be obscured see if we need to adjust nCount
    //
    if (nAmountShown > rc.bottom)
    {
        nCount--;
    }

    return max(1, nCount);
}

LONG
CCheckList::GetTopIndex(HWND hWnd, LONG *pnAmountObscured)
{
    LONG                    nIndex = 0;
    LPUSERDATA_STRUCT_LABEL pUserData;
    SCROLLINFO              si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_POS;

    //
    // initialize
    //
    if (pnAmountObscured != NULL)
    {
        *pnAmountObscured = 0;
    }

    if (GetScrollInfo(hWnd, SB_VERT, &si) && m_rcItemLabel.bottom > 0)
    {
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nIndex)),
                                        GWLP_USERDATA);
        //
        // if there are no items get out
        //
        if (pUserData == NULL)
        {
            return -1;
        }

        while (si.nPos >= (m_nDefaultVerticalSpace + pUserData->nLabelHeight))
        {
            si.nPos -= (m_nDefaultVerticalSpace + pUserData->nLabelHeight);
            nIndex++;
            pUserData = (LPUSERDATA_STRUCT_LABEL)
                        GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nIndex)),
                                            GWLP_USERDATA);
        }

        if (pnAmountObscured != NULL)
        {
            *pnAmountObscured = si.nPos;
        }
    }

    return nIndex;
}

void
CCheckList::SetTopIndex(HWND hWnd, LONG nIndex)
{
    int                     i;
    int                     nPos = 0;
    LPUSERDATA_STRUCT_LABEL pUserData;

    for (i=0; i<nIndex; i++)
    {
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)i)),
                                        GWLP_USERDATA);
        nPos += (m_nDefaultVerticalSpace + pUserData->nLabelHeight);
    }

    m_cWheelDelta = 0;
    MsgVScroll(hWnd, SB_THUMBPOSITION, nPos);
}


void
CCheckList::EnsureVisible(HWND hWnd, LONG nItemIndex)
{
    LONG                    nAmountObscured = 0;
    LONG                    nTopIndex;
    RECT                    rc;
    LPUSERDATA_STRUCT_LABEL pUserData;

    nTopIndex = GetTopIndex(hWnd, &nAmountObscured);
    if (nTopIndex == -1)
    {
        return;
    }

    // Note that the top item may only be partially visible,
    // so we need to test for equality here.  Raid #208449
    if (nItemIndex < nTopIndex)
    {
        SetTopIndex(hWnd, nItemIndex);
    }
    else if (nItemIndex == nTopIndex)
    {
        if (nAmountObscured != 0)
        {
            SetTopIndex(hWnd, nItemIndex);
        }
    }
    else
    {
        LONG nVisible = GetVisibleCount(hWnd);

        if (nItemIndex >= nTopIndex + nVisible)
        {
            if (!GetClientRect(hWnd, &rc))
            {
                //
                // This is just best effort
                //
                SetTopIndex(hWnd, nItemIndex - nVisible + 1);
            }
            else
            {
                //
                // Calculate what the top index should be to allow
                // nItemIndex to be fully visible
                //
                nTopIndex = nItemIndex + 1;
                do
                {
                    nTopIndex--;
                    pUserData = (LPUSERDATA_STRUCT_LABEL)
                                GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)nTopIndex)),
                                                    GWLP_USERDATA);
                    if (pUserData != NULL)
                    {
                        rc.bottom -= (pUserData->nLabelHeight + m_nDefaultVerticalSpace);
                        if (rc.bottom < 0)
                        {
                            nTopIndex++;
                        }
                    }
                    else
                    {
                        //
                        // Should not hit this, just added to make things safe
                        //
                        rc.bottom = 0;
                        nTopIndex = 0;
                    }
                } while (rc.bottom > 0);

                SetTopIndex(hWnd, nTopIndex);
            }
        }
    }
}


void
CCheckList::DrawCheckFocusRect(HWND hWnd, HWND hwndCheck, BOOL fDraw)
{
    RECT rcCheck;
    HDC hdc;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::DrawCheckFocusRect");
    TraceAssert(hWnd != NULL);
    TraceAssert(hwndCheck != NULL);

    GetWindowRect(hwndCheck, &rcCheck);
    MapWindowPoints(NULL, hWnd, (LPPOINT)&rcCheck, 2);
    InflateRect(&rcCheck, 2, 2);    // draw *outside* the checkbox

    hdc = GetDC(hWnd);
    if (hdc)
    {
        // Always erase before drawing, since we may already be
        // partially visible and drawing is an XOR operation.
        // (Don't want to leave any turds on the screen.)

        FrameRect(hdc, &rcCheck, GetSysColorBrush(BK_COLOR));

        if (fDraw)
        {
            SetTextColor(hdc, GetSysColor(TEXT_COLOR));
            SetBkColor(hdc, GetSysColor(BK_COLOR));
            DrawFocusRect(hdc, &rcCheck);
        }

        ReleaseDC(hWnd, hdc);
    }

    TraceLeaveVoid();
}

LRESULT
CALLBACK
CCheckList::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT                 lResult = 0;
    LPUSERDATA_STRUCT_LABEL pUserData = NULL;
    CCheckList *pThis = (CCheckList*)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    TraceEnter(TRACE_CHECKLIST, "CCheckList::WindowProc");
    TraceAssert(hWnd != NULL);

    switch (uMsg)
    {
    case WM_NCCREATE:
        pThis = new CCheckList(hWnd, (LPCREATESTRUCT)lParam);
        if (pThis != NULL)
        {
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pThis);
            lResult = TRUE;
        }
        break;

    case WM_DESTROY:
        pThis->ResetContent(hWnd);
        break;

    case WM_NCDESTROY:
        delete pThis;
        break;

    case WM_COMMAND:
        TraceAssert(pThis != NULL);
        lResult = pThis->MsgCommand(hWnd,
                                    GET_WM_COMMAND_ID(wParam, lParam),
                                    GET_WM_COMMAND_CMD(wParam, lParam),
                                    GET_WM_COMMAND_HWND(wParam, lParam));
        break;

    case WM_CTLCOLORSTATIC:
        TraceAssert(pThis != NULL);
        SetBkMode((HDC)wParam, TRANSPARENT);
        SetTextColor((HDC)wParam, GetSysColor(TEXT_COLOR));
        SetBkColor((HDC)wParam, GetSysColor(BK_COLOR));
        lResult = (LRESULT)GetSysColorBrush(BK_COLOR);
        break;

    case WM_PAINT:
        TraceAssert(pThis != NULL);
        pThis->MsgPaint(hWnd, (HDC)wParam);
        break;

    case WM_VSCROLL:
        TraceAssert(pThis != NULL);
        pThis->MsgVScroll(hWnd,
                          (int)(short)GET_WM_VSCROLL_CODE(wParam, lParam),
                          (int)(short)GET_WM_VSCROLL_POS(wParam, lParam));
        break;

    case WM_MOUSEWHEEL:
        TraceAssert(pThis != NULL);
        pThis->MsgMouseWheel(hWnd,
                             LOWORD(wParam),
                             (int)(short)HIWORD(wParam));
        break;

    case WM_LBUTTONDOWN:
        TraceAssert(pThis != NULL);
        pThis->MsgButtonDown(hWnd,
                             wParam,
                             (int)(short)LOWORD(lParam),
                             (int)(short)HIWORD(lParam));
        break;

    case WM_ENABLE:
        TraceAssert(pThis != NULL);
        pThis->MsgEnable(hWnd, (BOOL)wParam);
        break;

    case WM_SETFONT:
        TraceAssert(pThis != NULL);
        {
            for (LONG i = 0; i < pThis->m_cItems; i++)
                SendDlgItemMessage(hWnd,
                                   MAKE_LABEL_ID(i),
                                   WM_SETFONT,
                                   wParam,
                                   lParam);
        }
        break;

    case WM_SIZE:
        TraceAssert(pThis != NULL);
        pThis->MsgSize(hWnd, (DWORD)wParam, LOWORD(lParam), HIWORD(lParam));
        break;

    case CLM_ADDITEM:
        TraceAssert(pThis != NULL);
        lResult = pThis->AddItem(hWnd, (LPCTSTR)wParam, lParam);
        break;

    case CLM_GETITEMCOUNT:
        TraceAssert(pThis != NULL);
        lResult = pThis->m_cItems;
        break;

    case CLM_SETSTATE:
        TraceAssert(pThis != NULL);
        pThis->SetState(hWnd, LOWORD(wParam), HIWORD(wParam), (LONG)lParam);
        break;

    case CLM_GETSTATE:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetState(hWnd, LOWORD(wParam), HIWORD(wParam));
        break;

    case CLM_SETCOLUMNWIDTH:
        TraceAssert(pThis != NULL);
        {
            RECT rc;
            LONG cxDialog;

            GetClientRect(hWnd, &rc);
            cxDialog = rc.right;

            rc.right = (LONG)lParam;
            MapDialogRect(GetParent(hWnd), &rc);

            pThis->SetColumnWidth(hWnd, cxDialog, rc.right);
        }
        break;

    case CLM_SETITEMDATA:
        TraceAssert(GET_ITEM(wParam) < (ULONG)pThis->m_cItems);
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)wParam)),
                                        GWLP_USERDATA);
        if (pUserData != NULL)
            pUserData->lParam = lParam;
        break;

    case CLM_GETITEMDATA:
        TraceAssert(GET_ITEM(wParam) < (ULONG)pThis->m_cItems);
        pUserData = (LPUSERDATA_STRUCT_LABEL)
                    GetWindowLongPtr(   GetDlgItem(hWnd, MAKE_LABEL_ID((int)wParam)),
                                        GWLP_USERDATA);
        if (pUserData != NULL)
            lResult = pUserData->lParam;
        break;

    case CLM_RESETCONTENT:
        TraceAssert(pThis != NULL);
        pThis->ResetContent(hWnd);
        break;

    case CLM_GETVISIBLECOUNT:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetVisibleCount(hWnd);
        break;

    case CLM_GETTOPINDEX:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetTopIndex(hWnd);
        break;

    case CLM_SETTOPINDEX:
        TraceAssert(pThis != NULL);
        pThis->SetTopIndex(hWnd, (LONG)wParam);
        break;

    case CLM_ENSUREVISIBLE:
        TraceAssert(pThis != NULL);
        pThis->EnsureVisible(hWnd, (LONG)wParam);
        break;

    //
    // Always refer to the chklist window for help. Don't pass
    // one of the child window handles here.
    //
    case WM_HELP:
        ((LPHELPINFO)lParam)->hItemHandle = hWnd;
        lResult = SendMessage(GetParent(hWnd), uMsg, wParam, lParam);
        break;
    case WM_CONTEXTMENU:
        lResult = SendMessage(GetParent(hWnd), uMsg, (WPARAM)hWnd, lParam);
        break;

    case WM_SETCURSOR:
        if (LOWORD(lParam) == HTCLIENT)
        {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            lResult = TRUE;
            break;
        }
    // Fall Through
    default:
        lResult = DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    TraceLeaveValue(lResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\errorsecpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#if !defined(AFX_ERRORSECPAGE_H)
#define AFX_ERRORSECPAGE_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// RootSecPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CErrorSecurityPage dialog
#include "UIHelpers.h"

class CErrorSecurityPage : public CUIHelpers
{
// Construction
public:
	CErrorSecurityPage(UINT msg);   // standard constructor

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
	void InitDlg(HWND hDlg);

	UINT m_msg;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ERRORSECPAGE_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\genpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __GENERALPAGE__
#define __GENERALPAGE__

#include "UIHelpers.h"
#include "CHString1.h"
#include <mmc.h>

class DataSource;
class CGenPage : public CUIHelpers
{
private:

public:
    CGenPage(DataSource *ds, bool htmlSupport);
    virtual ~CGenPage(void);

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void InitDlg(HWND hDlg);
	void Refresh(HWND hDlg);
	void OnConnect(HWND hDlg, LOGIN_CREDENTIALS *credentials = NULL);
	void OnFinishConnected(HWND hDlg, LPARAM lParam);
	void StatusIcon(HWND hDlg, UINT icon);
	void SetUserName(HWND hDlg, LOGIN_CREDENTIALS *credentials);
	size_t UserLen(LOGIN_CREDENTIALS *credentials);
	void MinorError(CHString1 &initMsg, UINT fmtID, 
					HRESULT hr, CHString1 &success);

	bool m_connected;
	CHString1 m_machineName;
	HRESULT m_DSStatus;
};


#endif __GENERALPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\datasrc.cpp ===
// Copyright (c) 1999 Microsoft Corporation
#include "precomp.h"
#include "DataSrc.h"
#include "..\common\util.h"
#include "resource.h"
#include <stdio.h>
#include "si.h"
#include <cominit.h>
#include "ShlWapi.h"
#include "AsyncObjectSink.h"

#define FULLACCTSIZE 100
//---------------------------------------------------------
DataSource::DataSource()
{
	CoInitialize(NULL);
	m_OSType = 0;				//UNKNOWN;
	m_user.authIdent = NULL;
	m_user.currUser = true;
	memset(m_user.fullAcct, 0, FULLACCTSIZE * sizeof(TCHAR));
	m_hImageList = 0;
	m_folderIcon = 0;
	m_earthIcon = 0;
	m_classIcon = 0;
	m_instanceIcon = 0;
	m_scopeInstanceIcon = 0;
	m_scopeClassIcon = 0;
	m_sessionID = 0;

	m_NSCache.display = 0;
	m_NSCache.fullPath = 0;
	m_NSCache.ns = 0;
}

//---------------------------------------------------------
DataSource::~DataSource()
{
	CancelAllAsyncCalls();
	Disconnect();
	CoUninitialize();
}

//---------------------------------------------------------
// connecting.
void DataSource::SetMachineName(CHString1 &machine)
{
	TCHAR curComp[256] = {0};
	DWORD size = 256*sizeof(TCHAR);

	// check the whacks
	GetComputerName(curComp, &size);

	// if local...
	if((machine.GetLength() == 0) ||
		(machine == curComp))
	{
		m_whackedMachineName = "";
	}
	else if(machine[0] == _T('\\')) // its whacked.
	{
		m_whackedMachineName = machine;
	}
	else  //its not whacked.
	{
		m_whackedMachineName = _T("\\\\");
		m_whackedMachineName += machine;
	}
}

//---------------------------------------------------------
// connecting.
HRESULT DataSource::Connect(LOGIN_CREDENTIALS *credentials)
{
	// start the connection thread.
	if(m_rootThread.Connect((bstr_t)m_whackedMachineName, "root", true, credentials))
	{
	}

	m_sessionID++;
	return m_rootThread.m_hr;
}

//----------------------------------------------------------
bool DataSource::IsNewConnection(long *sessionID)
{
	bool retval = false;
	if(m_sessionID != *sessionID)
	{
		*sessionID = m_sessionID;
		retval = true;
	}
	return retval;
}

//----------------------------------------------------------
HRESULT DataSource::Reconnect(void)
{
	Disconnect();
	Connect(GetCredentials());
	return m_rootThread.m_hr;
}

//----------------------------------------------------------
HRESULT DataSource::Initialize(IWbemServices *pServices)
{
	IWbemClassObject *pInst = NULL;
	HRESULT retval = S_OK;
	
	m_securityHr = S_OK;
	m_osHr = S_OK;
	m_cpuHr = S_OK;
	m_settingHr = S_OK;

	if(pServices == 0) return E_FAIL;

	try 
	{
		m_rootThread.m_WbemServices.DisconnectServer();
		m_rootThread.m_WbemServices = pServices;
		m_rootThread.m_WbemServices.m_authIdent = m_user.authIdent;

		if(m_rootThread.m_status == WbemServiceThread::ready)
		{

			m_cimv2NS.DisconnectServer();
			// we'll use some general info from root\cimv2
			m_cimv2NS = m_rootThread.m_WbemServices.OpenNamespace("cimv2");
			m_cimv2NS.m_authIdent = m_user.authIdent;

			if((bool)m_cimv2NS)
			{
				if((pInst = m_cimv2NS.FirstInstanceOf("Win32_OperatingSystem")) != NULL)
				{
					m_OS = pInst;
					m_OSType = (short)m_OS.GetLong("OSType");
				}
				m_osHr = m_cimv2NS.m_hr;

				if((pInst = m_cimv2NS.FirstInstanceOf("Win32_Processor")) != NULL)
				{
					m_cpu = pInst;
				}
				m_cpuHr = m_cimv2NS.m_hr;

				m_winMgmt = m_cimv2NS.GetObject("Win32_WMISetting=@");

				// if the wmisetting class doesn't even exist....	
				if(!(bool)m_winMgmt)
				{
					// create what we can on the fly.
					UpdateOldBuild();
					
					// try again.
					m_winMgmt = m_cimv2NS.GetObject("Win32_WMISetting=@");
				}
				m_settingHr = m_cimv2NS.m_hr;
			}
			else
			{
				m_osHr = m_rootThread.m_WbemServices.m_hr;
				m_cpuHr = m_rootThread.m_WbemServices.m_hr;
				m_settingHr = m_rootThread.m_WbemServices.m_hr;
			}

			// find security...
			CWbemClassObject sysSec = m_rootThread.m_WbemServices.GetObject("__SystemSecurity=@");
			if((bool)sysSec)
			{
				// its the new SD security
				m_NSSecurity = true;
			}
			else
			{
				// its old fashioned namespace security.
				m_rootSecNS = m_rootThread.m_WbemServices.OpenNamespace("security");
				m_NSSecurity = false;
			}
			m_securityHr = m_rootThread.m_WbemServices.m_hr;

		}
	}
	catch ( ... )
	{
		retval = WBEM_E_INITIALIZATION_FAILURE;
	}
	return retval;
}

//----------------------------------------------------------
#include "mofstr.inc"
#include "mofsec.inc"

HRESULT DataSource::UpdateOldBuild(void)
{
	HRESULT hr = S_OK;
	UINT mofSize = strlen(CLASSMOF);
	mofSize += strlen(INSTMOF);

	char *mofStr = new char[mofSize + 2];
	strcpy(mofStr, CLASSMOF);
	strcat(mofStr, INSTMOF);

	wchar_t svrNS[100] = {0};

	wcscpy(svrNS,(LPCWSTR)m_rootThread.m_nameSpace);  // this will point to \root.
	wcscat(svrNS, L"\\cimv2");

    IMofCompiler *pCompiler = NULL;
	hr = CoCreateInstance(CLSID_MofCompiler, 0, CLSCTX_INPROC_SERVER,
							IID_IMofCompiler, (LPVOID *) &pCompiler);

	hr = pCompiler->CompileBuffer(strlen(mofStr), (LPBYTE)mofStr,
									svrNS,			//ServerAndNamespace,
									NULL,			//User,
									NULL,			//Authority,
									NULL,			//Password,
									0, 0, 0, NULL);	//lOptionFlags,lClassFlags, lInstanceFlags

	delete[] mofStr;

	// now for the security trick.
	mofSize = strlen(SECMOF);
	mofStr = new char[mofSize + 2];
	strcpy(mofStr, SECMOF);
	wcscpy(svrNS,(LPCWSTR)m_rootThread.m_nameSpace);  // this will point to \root.
	wcscat(svrNS, L"\\security");

	hr = pCompiler->CompileBuffer(strlen(mofStr), (LPBYTE)mofStr,
									svrNS,			//ServerAndNamespace,
									NULL,			//User,
									NULL,			//Authority,
									NULL,			//Password,
									0, 0, 0, NULL);	//lOptionFlags,lClassFlags, lInstanceFlags

	delete[] mofStr;

	pCompiler->Release();
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::Disconnect(bool clearCredentials)
{
	if(m_user.authIdent && clearCredentials)
	{
		m_rootThread.m_WbemServices.m_authIdent = 0;
		m_cimv2NS.m_authIdent = 0;
		m_rootSecNS.m_authIdent = 0;

		WbemFreeAuthIdentity(m_user.authIdent);
		m_user.authIdent = 0;
		m_user.currUser = true;
		memset(m_user.fullAcct, 0, FULLACCTSIZE * sizeof(TCHAR));

	}

	if(IsConnected())
	{
		m_rootSecNS.DisconnectServer();
		m_cimv2NS.DisconnectServer();

		// this is the root NS.
		m_rootThread.DisconnectServer();
		m_sessionID++;
	}
	return ERROR_SUCCESS;
}

//----------------------------------------------------------
bool DataSource::IsConnected(void) const
{
	return (m_rootThread.m_status == WbemServiceThread::ready);
}

//----------------------------------------------------------
bool DataSource::IsLocal(void) const
{
	return (m_whackedMachineName.GetLength() == 0);
}

//----------------------------------------------------------
bool DataSource::IsAncient(void) const
{
	return (!m_NSSecurity);
}

//----------------------------------------------------------
LOGIN_CREDENTIALS *DataSource::GetCredentials(void)
{
	return &m_user;
}

//----------------------------------------------------------
bstr_t DataSource::GetRootNS(void)
{
	return m_rootSecNS.m_path;
}

//----------------------------------------------------------
ISecurityInformation *DataSource::GetSI(struct NSNODE *nsNode)
{
	ISecurityInformation *si = NULL;
	
	if(m_NSSecurity && (m_OSType == OSTYPE_WINNT))
	{
		// access the acl methods.
		//Check whether the namespace is already opened
		if(nsNode->nsLoaded == false)
		{
			if(nsNode->sType == TYPE_SCOPE_INSTANCE)
			{
			}
			else
			{
				//Connect to the namespace now...
				*(nsNode->ns) = nsNode->ns->OpenNamespace(nsNode->display);
				if(nsNode->sType == TYPE_STATIC_INSTANCE)
				{
					//Now open the WbemClassObject with flags to read the __SD
					if(nsNode->pclsObj != NULL)
					{
						delete nsNode->pclsObj;
					}
					nsNode->pclsObj = new CWbemClassObject();
					*(nsNode->pclsObj) = nsNode->ns->GetObject(nsNode->relPath/*,Flag*/);
				}
			}
			nsNode->nsLoaded = true;
		}

		bstr_t server = m_cpu.GetString("__SERVER");
		si = new CSDSecurity(nsNode,server,IsLocal());
/*								ns, m_user.authIdent,
								path, display, 
								server, IsLocal());
*/
	}
	return si;
}

//----------------------------------------------------------
// general tab.
HRESULT DataSource::GetCPU(CHString1 &cpu)
{
	HRESULT hr = m_cpuHr;

	if((bool)m_cpu)
	{
		cpu = (LPCTSTR)m_cpu.GetString("Name");
		if(cpu.GetLength() != 0)
		{
			hr = S_OK;
		}
	}

	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::GetOS(CHString1 &os)
{
	HRESULT hr = m_osHr;

	if((bool)m_OS)
	{
		os = (LPCTSTR)m_OS.GetString("Caption");
		if(os.GetLength() != 0)
		{
			hr = S_OK;
		}
	}

	return hr;
}

//----------------------------------------------------
HRESULT DataSource::GetOSVersion(CHString1 &ver)
{
	HRESULT hr = m_osHr;

	if((bool)m_OS)
	{
		TCHAR _scr1[100] = {0};
		TCHAR _scr2[100] = {0};

		// Build and set the serial number string
		if (m_OS.GetBool("Debug")) 
		{
			_scr1[0] = TEXT(' ');
			LoadString(HINST_THISDLL, IDS_DEBUG, &(_scr1[1]), ARRAYSIZE(_scr1));
		} 
		else 
		{
			_scr1[0] = TEXT('\0');
		}

		// Version.buildNumber (DEBUG).
		_tcscpy(_scr2, (LPCTSTR)m_OS.GetString("Version"));
		_stprintf(_scr2, TEXT("%s%s"), _scr2, _scr1);

		ver = (LPCTSTR)_scr2;
		hr = S_OK;
	}

	return hr;
}

//----------------------------------------------------
HRESULT DataSource::GetServicePackNumber(CHString1 &ServPack)
{
	HRESULT hr = m_osHr;

	if((bool)m_OS)
	{
		TCHAR _scr1[100] = {0};
		_stprintf(_scr1, TEXT("%ld.%ld"), m_OS.GetLong("ServicePackMajorVersion"), m_OS.GetLong("ServicePackMinorVersion"));

		ServPack = (LPCTSTR)_scr1;
		hr = S_OK;
	}

	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::GetBldNbr(CHString1 &bldNbr)
{
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		bldNbr = (LPCTSTR)m_winMgmt.GetString("BuildVersion");
		if(bldNbr.GetLength() != 0)
		{
			hr = S_OK;
		}
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::GetInstallDir(CHString1 &dir)
{
	bstr_t value;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		dir = (LPCTSTR)m_winMgmt.GetString("InstallationDirectory");
		if(dir.GetLength() != 0)
		{
			hr = S_OK;
		}
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::GetDBDir(CHString1 &dir)
{
	bstr_t value;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		dir = (LPCTSTR)m_winMgmt.GetString("DatabaseDirectory");
		if(dir.GetLength() != 0)
		{
			hr = S_OK;
		}
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::GetBackupInterval(UINT &interval)
{
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		interval = m_winMgmt.GetLongEx("BackupInterval");
		hr = S_OK;
	}

	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::SetBackupInterval(UINT interval)
{
	CHString1 value;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		hr = m_winMgmt.PutEx("BackupInterval", (long)interval);
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::GetLastBackup(CHString1 &time)
{
	HRESULT hr = m_settingHr;
	bstr_t dmtf;
	if((bool)m_winMgmt)
	{
		hr = m_winMgmt.GetDateTimeFormat("BackupLastTime", dmtf);
		if(SUCCEEDED(hr))
			time = (LPCTSTR)dmtf;
	}
	return hr;
}

//----------------------------------------------------------
// logging tab.
HRESULT DataSource::GetLoggingStatus(LOGSTATUS &status)
{
	bstr_t temp;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		status = (LOGSTATUS)m_winMgmt.GetLongEx("LoggingLevel");
		hr = S_OK;
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::SetLoggingStatus(LOGSTATUS status)
{
	CHString1 value;
	bstr_t temp;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		hr = m_winMgmt.PutEx("LoggingLevel", (long)status);
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::GetLoggingSize(ULONG &size)
{
	bstr_t value;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		size = m_winMgmt.GetLongEx("MaxLogFileSize");
		hr = S_OK;
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::SetLoggingSize(const ULONG size)
{
	CHString1 value;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		hr = m_winMgmt.PutEx("MaxLogFileSize", (long)size);
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::GetDBLocation(CHString1 &dir)
{
	bstr_t value;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		dir = (LPCTSTR)m_winMgmt.GetString("DatabaseDirectory");
		if(dir.GetLength() != 0)
		{
			hr = S_OK;
		}
	}
	return hr;
}


//----------------------------------------------------------
HRESULT DataSource::GetLoggingLocation(CHString1 &dir)
{
	bstr_t value;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		CHString1 dir2;
		dir2 = (LPCTSTR)m_winMgmt.GetString("LoggingDirectory");
		TCHAR temp[_MAX_PATH] = {0};
		_tcscpy(temp, (LPCTSTR)dir2);
		PathAddBackslash(temp);
		dir = temp;
		hr  = S_OK;
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::SetLoggingLocation(CHString1 dir)
{
	HRESULT hr = m_settingHr;
	bstr_t value = dir;

	if((bool)m_winMgmt && dir.GetLength() != 0)
	{
		hr = m_winMgmt.Put("LoggingDirectory", (bstr_t)(LPCTSTR)dir);
	}
	return hr;
}

//----------------------------------------------------------
bool DataSource::IsValidDir(CHString1 &dir)
{
	bool retval = true;

	if((bool)m_cimv2NS)
	{
		// double the whacks because wmi has bad syntax.
		TCHAR cooked[_MAX_PATH] = {0};
		TCHAR input[_MAX_PATH] = {0};
		TCHAR path[_MAX_PATH] = {0};

		int len = dir.GetLength();

		_tcscpy(input, (LPCTSTR)dir);
		_tcscpy(path, _T("Win32_directory=\""));

		for(int x = 0; x < len; x++)
		{
			_tcsncat(cooked, &input[x], 1);

			// if its a whack...
			if(input[x] == _T('\\'))
			{
				// have another pleeb.
				_tcscat(cooked, _T("\\"));			
			}
		} //endfor

		_tcscat(path, cooked);
		path[_tcslen(path) - 2] = 0;
		_tcscat(path, _T("\""));

		CWbemClassObject inst = m_cimv2NS.GetObject(path);
		retval = (bool)inst;
	}
	else
	{
		//warn & maybe.
		retval = false;
	}
	return retval;
}

#define CIM_LOGICALFILE _T("CIM_LogicalFile=\"")
//----------------------------------------------------------
bool DataSource::IsValidFile(LPCTSTR szDir)
{
    TCHAR szBuffer[MAX_PATH + ARRAYSIZE(CIM_LOGICALFILE) + 1];

	bool retval = true;
	if((bool)m_cimv2NS)
	{
        _tcscpy(szBuffer, CIM_LOGICALFILE);
        TCHAR * psz = szBuffer + ARRAYSIZE(CIM_LOGICALFILE) - 1;

        while (*psz = *szDir)
        {
            if (*szDir == _T('\\'))
            {
                *psz++ = _T('\\');
                *psz   = _T('\\');
            }
            psz++;
            szDir++;
        }
        *psz++ = _T('\"');
        *psz   = _T('\0');

		CWbemClassObject inst = m_cimv2NS.GetObject(szBuffer);
		retval = (bool)inst;
	}
	else
	{
		//warn & maybe.
		retval = false;
	}
	return retval;
}

//----------------------------------------------------------
bool DataSource::CanBrowseFS(void) const
{
	return IsLocal();
}

//----------------------------------------------------------
// advanced tab.
HRESULT DataSource::GetScriptASPEnabled(bool &enabled)
{
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		enabled = m_winMgmt.GetBoolEx("ASPScriptEnabled");
		hr = S_OK;
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::SetScriptASPEnabled(bool &enabled)
{
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		m_winMgmt.PutEx("ASPScriptEnabled", enabled);
		hr = S_OK;
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::GetAnonConnections(bool &enabled)
{
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		enabled = m_winMgmt.GetBoolEx("EnableAnonWin9xConnections");
		hr = S_OK;
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::SetAnonConnections(bool &enabled)
{
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		m_winMgmt.PutEx("EnableAnonWin9xConnections", enabled);
		hr = S_OK;
	}
	return hr;
}

//----------------------------------------------------------

HRESULT DataSource::GetScriptDefNS(CHString1 &ns)
{
	HRESULT hr = m_settingHr;
	bstr_t value;

	if((bool)m_winMgmt)
	{
		ns = (LPCTSTR)m_winMgmt.GetString("ASPScriptDefaultNamespace");
		if(ns.GetLength() != 0)
		{
			hr = S_OK;
		}
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::SetScriptDefNS(LPCTSTR ns)
{
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		hr = m_winMgmt.Put("ASPScriptDefaultNamespace", (bstr_t)(LPCTSTR)ns);
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::GetRestart(RESTART &restart)
{
	bstr_t value;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		restart = (RESTART)m_winMgmt.GetLongEx("AutoStartWin9X");
		hr = S_OK;
	}
	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::SetRestart(RESTART restart)
{
	CHString1 value;
	HRESULT hr = m_settingHr;

	if((bool)m_winMgmt)
	{
		hr = m_winMgmt.PutEx("AutoStartWin9X", (long)restart);
	}

	return hr;
}

//----------------------------------------------------------
HRESULT DataSource::PutWMISetting(BOOL refresh)
{
	HRESULT hr = m_cimv2NS.PutInstance(m_winMgmt);
	
	if(refresh)
		m_winMgmt = m_cimv2NS.GetObject("Win32_WMISetting=@");

	return hr;
}

//----------------------------------------------------------
//----------------------------------------------------------
// NAMESPACE CACHE -----------------------------------------
LPTSTR DataSource::CopyString( LPTSTR pszSrc ) 
{
    LPTSTR pszDst = NULL;

    if (pszSrc != NULL) 
	{
        pszDst = new TCHAR[(lstrlen(pszSrc) + 1)];
        if (pszDst) 
		{
            lstrcpy( pszDst, pszSrc );
        }
    }

    return pszDst;
}

//---------------------------------------------------------------------------
void DataSource::DeleteAllNodes(void)
{
	DeleteNode(&m_NSCache);
}

//---------------------------------------------------------------------------
void DataSource::DeleteNode(NSNODE *node)
{
	if(node)
	{
		delete[] node->display;
		delete[] node->fullPath;
		node->ns = 0;

		int size = node->children.GetSize();
		// walk the children.
		for(int x = 0; x < size; x++)
		{
			struct NSNODE *child = node->children[x];
			DeleteNode(child);
		}

		if(node != &m_NSCache)
		{
			delete node;
		}
		else
		{
			m_NSCache.children.RemoveAll();
		}
	}
}

//---------------------------------------------------------------------------
void DataSource::LoadImageList(HWND hTree)
{

	if(m_hImageList == 0)
	{
		// create an empty imagelist.
		m_hImageList = ImageList_Create(16, 16, ILC_COLOR8|ILC_MASK, 3, 0);

		// add an icon
		m_folderIcon = ImageList_AddIcon(m_hImageList, 
									   LoadIcon(_Module.GetModuleInstance(), 
										MAKEINTRESOURCE(IDI_CLSD_FOLDER)));

		m_earthIcon = ImageList_AddIcon(m_hImageList, 
									   LoadIcon(_Module.GetModuleInstance(), 
										MAKEINTRESOURCE(IDI_EARTH)));
		m_classIcon = ImageList_AddIcon(m_hImageList, 
									   LoadIcon(_Module.GetModuleInstance(), 
										MAKEINTRESOURCE(IDI_CLSD_CLASS)));
		m_instanceIcon = ImageList_AddIcon(m_hImageList, 
									   LoadIcon(_Module.GetModuleInstance(), 
										MAKEINTRESOURCE(IDI_CLSD_INSTANCE)));
		m_scopeInstanceIcon = ImageList_AddIcon(m_hImageList, 
									   LoadIcon(_Module.GetModuleInstance(), 
										MAKEINTRESOURCE(IDI_CLSD_SCOPEINSTANCE)));
		m_scopeClassIcon = ImageList_AddIcon(m_hImageList, 
									   LoadIcon(_Module.GetModuleInstance(), 
										MAKEINTRESOURCE(IDI_CLSD_SCOPECLASS)));
	}

	// sent it to the tree.
	TreeView_SetImageList(hTree, m_hImageList, TVSIL_NORMAL);
}

//---------------------------------------------------------------------------
HRESULT DataSource::LoadNode(HWND hTree, HTREEITEM hItem /* = TVI_ROOT */,
							 int flags)
{
	HRESULT hr = E_FAIL;

	// loading the root?
	if(hItem == TVI_ROOT)
	{
		// initialize the node.
		m_NSCache.display = CopyString(_T("Root"));
		m_NSCache.fullPath = CopyString(_T("Root"));
		m_NSCache.ns = &m_rootThread.m_WbemServices;
		m_NSCache.hideMe = false;
		m_NSCache.sType = TYPE_NAMESPACE;

		ITEMEXTRA *extra = new ITEMEXTRA;
		if(extra == NULL)
			return E_FAIL;
		extra->nsNode = &m_NSCache;
		extra->loaded = false;

		// initialize the invariant parts.
		TVINSERTSTRUCT tvInsert;
		tvInsert.hParent = TVI_ROOT;
		tvInsert.hInsertAfter = TVI_SORT;
		tvInsert.item.mask =  TVIF_TEXT | TVIF_CHILDREN |TVIF_PARAM|TVIF_IMAGE|TVIF_SELECTEDIMAGE;
		tvInsert.item.hItem = 0;
		tvInsert.item.state = 0;
		tvInsert.item.iImage = FolderIcon();
		tvInsert.item.iSelectedImage = FolderIcon();
		tvInsert.item.stateMask = 0;
		tvInsert.item.cChildren = (flags == ROOT_ONLY? 0: 1);
		tvInsert.item.pszText = CopyString(m_NSCache.display);
		if (!tvInsert.item.pszText)
 			return E_FAIL;

		tvInsert.item.cchTextMax = _tcslen(tvInsert.item.pszText); 
		tvInsert.item.lParam = (LPARAM)extra;

		HTREEITEM hItem2;
		hItem2 = TreeView_InsertItem(hTree, &tvInsert);
		hr = (hItem != 0 ? S_OK : E_FAIL);
	}
	else if(flags != ROOT_ONLY)  // expanding an existing node.
	{
		TV_ITEM item;
		struct NSNODE *node = NULL;
		// find the cached node.
		item.mask = TVIF_PARAM | TVIF_CHILDREN;
		item.hItem = hItem;
		BOOL x = TreeView_GetItem(hTree, &item);

		ITEMEXTRA *extra = (ITEMEXTRA *)item.lParam;
		node = extra->nsNode;

		// are the kids in the cache??
/*		int size = node->children.GetSize();
		ATLTRACE(_T("NODE STATE: %d, %d\n"), size, extra->loaded);
		if((size == 0) &&
			(extra->loaded == false))
*/
		if(extra->loaded == false)
		{
			//Now delete all the children in the cache as they might be due to a previously cancelled enumeration
			node->children.RemoveAll();
			// nope!!! Enum that 'node' to the cache.
//			ShowControls(true);
			hr = PopulateCacheNode(hTree,hItem,extra);
			// NOTE: empties will be WBEM_E_NOT_FOUND here.
		}

/*		// got kids now?
		size = node->children.GetSize();
		if(size == 0)
		{
			// get rid of the plus sign.
			item.mask = TVIF_CHILDREN;
			item.cChildren = 0; 
			TreeView_SetItem(hTree, &item);
		}
		else if(extra->loaded == false)  // && size != 0
		{
			// load the tree now.
			hr = PopulateTreeNode(hTree, hItem, node, flags);
			extra->loaded = true;
		}
*/
	}

	return hr;
}

//---------------------------------------------------------------------------
bool DataSource::MFLNamepace(LPTSTR name)
{
	bool t1 = (_tcslen(name) == 6);					// just the right length...
	bool t2 = (_tcsnicmp(name, _T("MS_"), 3) == 0);		// starts right...
	int scan = _tcsspn(&name[3], _T("0123456789"));
	bool t3 = (scan == 3);

	return t1 && t2 && t3;
}

//---------------------------------------------------------------------------
HRESULT DataSource::PopulateCacheNode(HWND hTreeWnd,HTREEITEM hItem,struct ITEMEXTRA *extra)
{
	// load up the principals.
	IWbemClassObject *inst = NULL;
	IEnumWbemClassObject *nsEnum = NULL;

	ULONG uReturned = 0;
	HRESULT hr = E_FAIL;
	HRESULT hr1 = E_FAIL;

	struct NSNODE *parent= extra->nsNode;

	CWbemServices *ns = NULL;
	extra->loaded = true;						

	switch(parent->sType)
	{
		case TYPE_NAMESPACE:
		{
			//Check whether the namespace is already opened
			if(parent->nsLoaded == false)
			{
				//Connect to the namespace now...
				*(parent->ns) = parent->ns->OpenNamespace(parent->display);
				parent->nsLoaded = true;
			}
			ns = parent->ns;

			//Create the Namespace Enum
			CAsyncObjectSink *objSinkNS;
			objSinkNS = new CAsyncObjectSink(hTreeWnd,hItem,parent,this,ENUM_NAMESPACE);
            if (objSinkNS != NULL)
            {
			    IWbemObjectSink *pSyncStubNS = NULL;
			    hr = GetAsyncSinkStub(objSinkNS,&pSyncStubNS);

                if (SUCCEEDED(hr))
                {
			        objSinkNS->SetSinkStub(pSyncStubNS);
			        hr = ns->CreateInstanceEnumAsync(L"__namespace",pSyncStubNS);
			        pSyncStubNS->Release();

                    if (parent->objSink != NULL)
                    {
			            ((CAsyncObjectSink *)parent->objSink)->SetSinkStub(NULL);
			            parent->objSink->Release();
                    }

			        parent->objSink = NULL;

                    if (parent->objSinkNS != NULL)
                    {
			            ((CAsyncObjectSink *)parent->objSinkNS)->SetSinkStub(NULL);
                        parent->objSinkNS->Release();
                    }
                    parent->objSinkNS = objSinkNS;
                    parent->objSinkNS->AddRef();
                }
                else
                    delete objSinkNS;
            }
            else
                hr = E_OUTOFMEMORY;

			if(SUCCEEDED(hr))
			{
				asyncList.push_back(extra);
			}
			else
			{
				//Some problem with the enumerations. So remove the Plus sign as no nodes will be populated
				RemovePlus(hTreeWnd,hItem);
			}
			break;
		}
		case TYPE_SCOPE_CLASS:
		case TYPE_STATIC_CLASS:
		{
			//Check whether the namespace is already opened
			if(parent->nsLoaded == false)
			{
				//Connect to the namespace now...
				*(parent->ns) = parent->ns->OpenNamespace(parent->display);
				parent->nsLoaded = true;
			}
			ns = parent->ns;
			//Since we can set the secutiry for the static Instances Enumerate the Instances of this static class now
			CAsyncObjectSink *objSink;
			objSink = new CAsyncObjectSink(hTreeWnd,hItem,parent,this,ENUM_INSTANCE);
            if (objSink != NULL)
            {
			    IWbemObjectSink *pSyncStub = NULL;
			    hr = GetAsyncSinkStub(objSink,&pSyncStub);

                if (SUCCEEDED(hr))
                {
			        objSink->SetSinkStub(pSyncStub);
			        hr = ns->CreateInstanceEnumAsync(parent->display,pSyncStub);
			        pSyncStub->Release();

                    if (parent->objSink != NULL)
                    {
                        ((CAsyncObjectSink *)parent->objSink)->SetSinkStub(NULL);
                        parent->objSink->Release();
                    }

                    parent->objSink = objSink;
                    parent->objSink->AddRef();
                }
                else
                    delete objSink;
            }
            else
                hr = E_OUTOFMEMORY;

			if(FAILED(hr))
			{
				//Some problem with the enumeration. So remove the Plus sign as no nodes will be populated
				RemovePlus(hTreeWnd,hItem);
			}
			else
			{
				asyncList.push_back(extra);
			}
			break;
		}
		case TYPE_SCOPE_INSTANCE:
		{
			//Check whether the namespace is already opened
/*			if(parent->nsLoaded == false)
			{
				IWbemServices *pServ = NULL;
//				IWbemServicesEx *pServEx = NULL,*pServEx1 = NULL;
				//Connect to the scope now.
				pServ = m_rootThread.m_WbemServices.m_pService;
//				hr = pServ->QueryInterface(IID_IWbemServicesEx,(void **)&pServEx);
//				if(SUCCEEDED(hr))
				{
//					parent->pServicesEx = NULL;
					TCHAR strTemp[1024];
					_tcscpy(strTemp,_T("ScopeClass.Name=\"ScopeInst1\""));
					//Now open the scope
					hr = pServEx->Open(strTemp,0,0,NULL,&pServEx1,NULL);
//					hr = pServEx->Open(parent->fullPath,NULL,0,NULL,&pServEx1,NULL);
					if(SUCCEEDED(hr))
					{
						//Now we have opened the scope
						parent->nsLoaded = true;

						//Enumerate the Instances in the scope now
						CAsyncObjectSink *objSink;
						parent->objSink = new CAsyncObjectSink(hTreeWnd,hItem,parent,this,ENUM_SCOPE_INSTANCE);
						IWbemObjectSink *pSyncStub = NULL;
						GetAsyncSinkStub(parent->objSink,&pSyncStub);
						objSink = (CAsyncObjectSink *)parent->objSink;
						objSink->SetSinkStub(pSyncStub);
						hr = parent->pServicesEx->CreateInstanceEnumAsync(L"",0,NULL,pSyncStub);
						pSyncStub->Release();
						if(FAILED(hr))
						{
							//Some problem with the enumeration. So remove the Plus sign as no nodes will be populated
							RemovePlus(hTreeWnd,hItem);
						}
						else
						{
							asyncList.push_back(extra);
						}
					}
				}

			}

			if(parent->nsLoaded == false)
			{
				//Do we have to display an error message here???
				MessageBox(NULL,_T("Unable to open scope"),_T("NULL"),MB_OK);
			}
*/
			break;
		}
		case TYPE_DYNAMIC_CLASS:
		{
			//The control should not come here. Even if it comes we won't do anything
			break;
		}
		case TYPE_STATIC_INSTANCE:
		{
			break;
		}

	}

	return hr;
}

//---------------------------------------------------------------------------
HRESULT DataSource::PopulateTreeNode(HWND hTree, HTREEITEM hParentItem, 
										struct NSNODE *parent,
										int flags)
{
	HRESULT hr = E_FAIL;

	if(parent)
	{
		// initialize the invariant parts.
		TVINSERTSTRUCT tvInsert;
		tvInsert.hParent = hParentItem;
		tvInsert.hInsertAfter = TVI_SORT;
		tvInsert.item.hItem = 0;
		tvInsert.item.state = 0;
		tvInsert.item.iImage = 1;
		tvInsert.item.stateMask = 0;

		int size = parent->children.GetSize();
		
		if(size == 0) 
			return WBEM_E_NOT_FOUND;

		hr = E_FAIL; // in case we bounce right over the for(...).

		// walk the children.
		for(int x = 0; x < size; x++)
		{
			struct NSNODE *child = parent->children[x];

			if(!((flags == HIDE_SOME) && child->hideMe) )
			{
				ITEMEXTRA *extra = new ITEMEXTRA;
				if(extra == NULL)
					return E_FAIL;
				extra->nsNode = child;
				extra->loaded = false;

				ATLTRACE(_T("NStree: %s %s\n"), parent->display, child->display);

				tvInsert.item.mask =  TVIF_TEXT | TVIF_CHILDREN | TVIF_PARAM|TVIF_IMAGE|TVIF_SELECTEDIMAGE;
				tvInsert.item.pszText = CopyString(child->display);
				if (!tvInsert.item.pszText)
					return E_FAIL;

				tvInsert.item.cchTextMax = _tcslen(tvInsert.item.pszText);
				tvInsert.item.lParam = (LPARAM)extra;
				tvInsert.item.cChildren = 1;
				if(MFLNamepace(child->display))
				{
					tvInsert.item.iImage = EarthIcon();
					tvInsert.item.iSelectedImage = EarthIcon();
				}
				else
				{
					if((child->sType == TYPE_DYNAMIC_CLASS) || (child->sType == TYPE_STATIC_CLASS))
					{
						tvInsert.item.iImage = ClassIcon();
						tvInsert.item.iSelectedImage = ClassIcon();
					}
					else
					{ //Defaulted to Namespace
						tvInsert.item.iImage = FolderIcon();
						tvInsert.item.iSelectedImage = FolderIcon();
					}
				}

				// Insert principal into list.
				HTREEITEM hItem2;
				hItem2 = TreeView_InsertItem(hTree, &tvInsert);
			}

		} //endwhile

	hr = S_OK;
	} //endif (bool)ns

	return hr;
}

void DataSource::InsertNamespaceNode(HWND hTreeWnd,HTREEITEM hItem,struct NSNODE *parent, IWbemClassObject *pclsObj)
{
	struct NSNODE *node = new struct NSNODE;

	CWbemClassObject easy(pclsObj);
	bstr_t name = easy.GetString("Name");
	bstr_t path = easy.GetString("__NAMESPACE");
	bstr_t full = path + _T("\\");
	full += name;
	bstr_t relPath = easy.GetString("__RELPATH");

	node->fullPath = CopyString(full);
	node->relPath = CopyString(relPath);
	node->display = CopyString(name);
	node->hideMe = false; //HideableNode(node->display);
	node->nsLoaded = false;
	node->sType = TYPE_NAMESPACE;
	parent->children.Add(node);
	node->ns = new CWbemServices(*(parent->ns));

	//Now add the node to the tree
	TVINSERTSTRUCT tvInsert;
	tvInsert.hParent = hItem;
	tvInsert.hInsertAfter = TVI_SORT;
	tvInsert.item.hItem = 0;
	tvInsert.item.state = 0;
	tvInsert.item.iImage = 1;
	tvInsert.item.stateMask = 0;

	ITEMEXTRA *extra = new ITEMEXTRA;
	if(extra == NULL)
		return;
	extra->nsNode = node;
	extra->loaded = false;

	tvInsert.item.mask =  TVIF_TEXT | TVIF_CHILDREN | TVIF_PARAM|TVIF_IMAGE|TVIF_SELECTEDIMAGE;
	tvInsert.item.pszText = CopyString(node->display);
	tvInsert.item.cchTextMax = _tcslen(tvInsert.item.pszText);
	tvInsert.item.lParam = (LPARAM)extra;
	tvInsert.item.cChildren = 1;
	if(MFLNamepace(node->display))
	{
		tvInsert.item.iImage = EarthIcon();
		tvInsert.item.iSelectedImage = EarthIcon();
	}
	else
	{
		tvInsert.item.iImage = FolderIcon();
		tvInsert.item.iSelectedImage = FolderIcon();
	}

	// Insert principal into list.
	HTREEITEM hItem2;
	hItem2 = TreeView_InsertItem(hTreeWnd, &tvInsert);
}

void DataSource::InsertClassNode(HWND hTreeWnd,HTREEITEM hItem,struct NSNODE *parent, IWbemClassObject *pclsObj)
{
	IWbemQualifierSet *qSet;
	pclsObj->GetQualifierSet(&qSet);
	VARIANT vt;
	VariantInit(&vt);
	HRESULT hr = qSet->Get(L"Abstract",0,&vt,NULL);

	if(hr != WBEM_E_NOT_FOUND)
	{
		if(vt.boolVal == VARIANT_TRUE)
		{
			qSet->Release();
			return;
		}
	}

	struct NSNODE *node = new struct NSNODE;

	CWbemClassObject easy(pclsObj);
	bstr_t name = easy.GetString("__CLASS");
	bstr_t path = easy.GetString("__PATH");
	bstr_t relPath = easy.GetString("__RELPATH");

	node->fullPath = CopyString(path);
	node->relPath = CopyString(relPath);
	node->display = CopyString(name);
	node->hideMe = false;
	node->nsLoaded = true;

	VariantClear(&vt);
	hr = qSet->Get(L"Dynamic",0,&vt,NULL);
	if((hr != WBEM_E_NOT_FOUND) && (vt.boolVal == VARIANT_TRUE))
	{
		node->sType = TYPE_DYNAMIC_CLASS;
		node->ns = NULL;
	}
	else
	{
		//Now check whether it is a scope class
		hr = qSet->Get(L"Scope",0,&vt,NULL);
		if((hr != WBEM_E_NOT_FOUND) && (vt.boolVal == VARIANT_TRUE))
		{
			//This class is marked as scope. So all instances of this class can be scopes
			node->sType = TYPE_SCOPE_CLASS;
		}
		else
		{
			//It is a static class
			node->sType = TYPE_STATIC_CLASS;
		}
		node->ns = new CWbemServices(*(parent->ns));
		node->pclsObj = new CWbemClassObject(pclsObj);
	}

	parent->children.Add(node);

	//Now Add the node to the Tree
	TVINSERTSTRUCT tvInsert;
	tvInsert.hParent = hItem;
	tvInsert.hInsertAfter = TVI_SORT;
	tvInsert.item.hItem = 0;
	tvInsert.item.state = 0;
	tvInsert.item.iImage = 1;
	tvInsert.item.stateMask = 0;

	ITEMEXTRA *extra = new ITEMEXTRA;
	if(extra == NULL)
		return;
	extra->nsNode = node;
	extra->loaded = false;

	tvInsert.item.mask =  TVIF_TEXT | TVIF_CHILDREN | TVIF_PARAM|TVIF_IMAGE|TVIF_SELECTEDIMAGE;
	tvInsert.item.pszText = CopyString(node->display);
	tvInsert.item.cchTextMax = _tcslen(tvInsert.item.pszText);
	tvInsert.item.lParam = (LPARAM)extra;
	if(node->sType == TYPE_DYNAMIC_CLASS)
	{
		//Remove the plus sign for the Dynamic Classes
		tvInsert.item.cChildren = 0;
	}
	else
	{
		tvInsert.item.cChildren = 1;
	}

	if(node->sType == TYPE_SCOPE_CLASS)
	{
		tvInsert.item.iImage = ScopeClassIcon();
		tvInsert.item.iSelectedImage = ScopeClassIcon();
	}
	else
	{
		tvInsert.item.iImage = ClassIcon();
		tvInsert.item.iSelectedImage = ClassIcon();
	}
	
	// Insert principal into list.
	HTREEITEM hItem2;
	hItem2 = TreeView_InsertItem(hTreeWnd, &tvInsert);

}

void DataSource::InsertInstanceNode(HWND hTreeWnd,HTREEITEM hItem,struct NSNODE *parent, IWbemClassObject *pclsObj)
{
	TCHAR strKey[10240];
	struct NSNODE *node = new struct NSNODE;

	CWbemClassObject easy(pclsObj);
	HRESULT hr = E_FAIL;
	_bstr_t strName;
	_variant_t vtValue;
	VARIANT Value;
	_tcscpy(strKey,_T(""));
	VariantInit(&Value);
	bool bfirstTime = true;
	//Now Enumerate the Keys and for a name like "key1,key2,key3,..."
	if(SUCCEEDED(hr = pclsObj->BeginEnumeration(WBEM_FLAG_KEYS_ONLY)))
	{
		while(pclsObj->Next(0,NULL,&Value,NULL,NULL) != WBEM_S_NO_MORE_DATA)
		{
			vtValue = Value;
			if(bfirstTime)
			{
				bfirstTime = false;
			}
			else
			{
				_tcscat(strKey,_T(","));
			}
			vtValue.ChangeType(VT_BSTR,NULL);
			_bstr_t temp = _bstr_t(vtValue); //for PREFIX
			if (!temp)
				return;
			_tcscat(strKey,temp);
			VariantClear(&Value);
		}
	}
	if(_tcscmp(strKey,_T("")) == 0)
	{
		//Some Problem or it is the instance of a singleton class
		_tcscpy(strKey,_T("@"));
	}

	bstr_t name = strKey;
	bstr_t path = easy.GetString("__PATH");
	bstr_t relPath = easy.GetString("__RELPATH");

	node->fullPath = CopyString(path);
	node->relPath = CopyString(relPath);
	node->display = CopyString(name);
	node->hideMe = false;
	node->nsLoaded = false;
	node->ns = new CWbemServices(*(parent->ns));
	if(parent->sType == TYPE_SCOPE_CLASS)
	{
		node->sType = TYPE_SCOPE_INSTANCE;
	}
	else
	{
		node->sType = TYPE_STATIC_INSTANCE;
	}
	node->pclsObj = new CWbemClassObject(pclsObj);

	parent->children.Add(node);

	TVITEM item;
	item.mask = TVIF_CHILDREN | TVIF_HANDLE;
	item.hItem = hItem;
	item.cChildren = 1;				
	TreeView_SetItem(hTreeWnd, &item);

	//Now Add the node to the Tree
	TVINSERTSTRUCT tvInsert;
	tvInsert.hParent = hItem;
	tvInsert.hInsertAfter = TVI_SORT;
	tvInsert.item.hItem = 0;
	tvInsert.item.state = 0;
	tvInsert.item.iImage = 1;
	tvInsert.item.stateMask = 0;

	ITEMEXTRA *extra = new ITEMEXTRA;
	if(extra == NULL)
		return;
	extra->nsNode = node;
	extra->loaded = false;

	tvInsert.item.mask =  TVIF_TEXT | TVIF_CHILDREN | TVIF_PARAM|TVIF_IMAGE|TVIF_SELECTEDIMAGE;
	tvInsert.item.pszText = CopyString(node->display);
	tvInsert.item.cchTextMax = _tcslen(tvInsert.item.pszText);
	tvInsert.item.lParam = (LPARAM)extra;
	if(node->sType == TYPE_SCOPE_INSTANCE)
	{
		tvInsert.item.iImage = ScopeInstanceIcon();
		tvInsert.item.iSelectedImage = ScopeInstanceIcon();
		tvInsert.item.cChildren = 1;
	}
	else
	{
		tvInsert.item.iImage = InstanceIcon();
		tvInsert.item.iSelectedImage = InstanceIcon();
		tvInsert.item.cChildren = 0;	//Since these are regular static instances, remove the plus sign
	}

	// Insert principal into list.
	HTREEITEM hItem2;
	hItem2 = TreeView_InsertItem(hTreeWnd, &tvInsert);
}

void DataSource::InsertScopeInstanceNode(HWND hTreeWnd,HTREEITEM hItem,struct NSNODE *parent, IWbemClassObject *pclsObj)
{
}

void DataSource::RemovePlus(HWND hTreeWnd,HTREEITEM hItem)
{
	// get rid of the plus sign.
	TVITEM item;
	item.mask = TVIF_CHILDREN | TVIF_HANDLE;
	item.hItem = hItem;
	item.cChildren = 0; 
	TreeView_SetItem(hTreeWnd, &item);
}

void DataSource::CancelAllAsyncCalls()
{
	struct NSNODE *pNode;
	ASYNCLIST::iterator iter = asyncList.begin();
	TV_ITEM item;
	ITEMEXTRA *extra;
	CAsyncObjectSink *objSink;

	for(;iter != asyncList.end();iter++)
	{
		extra = *iter;
		pNode = extra->nsNode;

		if(pNode->objSinkNS != NULL)
		{
			objSink = (CAsyncObjectSink *)pNode->objSinkNS;

            if (objSink->GetSinkStub() != NULL)
            {
			    HRESULT hr = pNode->ns->CancelAsyncCall(objSink->GetSinkStub());

			    if((hr == WBEM_E_FAILED) || (hr == WBEM_E_INVALID_PARAMETER) || (hr == WBEM_E_OUT_OF_MEMORY) || (hr == WBEM_E_TRANSPORT_FAILURE))
			    {
				    hr = E_FAIL;
			    }
    			else
			    {
				    objSink->SetSinkStub(NULL);
				    extra->loaded = false;
			    }
            }
		}
		if(pNode->objSink != NULL)
		{
			objSink = (CAsyncObjectSink *)pNode->objSink;

            if (objSink->GetSinkStub() != NULL)
            {
			    HRESULT hr = pNode->ns->CancelAsyncCall(objSink->GetSinkStub());

			    if((hr == WBEM_E_FAILED) || (hr == WBEM_E_INVALID_PARAMETER) || (hr == WBEM_E_OUT_OF_MEMORY) || (hr == WBEM_E_TRANSPORT_FAILURE))
			    {
				    hr = E_FAIL;
			    }
			    else
			    {
				    objSink->SetSinkStub(NULL);
				    extra->loaded = false;
			    }
			}
		}
	}
	asyncList.clear();
}

void DataSource::ProcessEndEnumAsync(IWbemObjectSink *pSink)
{
	//First delete the node for this enum
//	OutputDebugString(_T("End Enum Received!!!\n"));

	struct ITEMEXTRA *extra;
	struct NSNODE *pNode;
	
	if(asyncList.empty() == true)
		return;

	ASYNCLIST::iterator iter = asyncList.begin();
	CAsyncObjectSink *objSink;

	for(;iter != asyncList.end();iter++)
	{
		extra = *iter;
		pNode = extra->nsNode;
		if(pNode->objSinkNS == pSink)
		{
			objSink = (CAsyncObjectSink *)pNode->objSinkNS;
			objSink->SetSinkStub(NULL);
			pNode->objSinkNS->Release();
			pNode->objSinkNS = NULL;
			break;
		}
		if(pNode->objSink == pSink)
		{
			objSink = (CAsyncObjectSink *)pNode->objSink;
			objSink->SetSinkStub(NULL);
			pNode->objSink->Release();
			pNode->objSink = NULL;
			break;
		}
	}

	if((pNode->objSinkNS == NULL) && (pNode->objSink == NULL))
	{
		asyncList.remove(*iter);
		extra->loaded = true;
	}

	if(asyncList.empty())
	{
		//Now Hide the Windows
//		ShowControls(false);
	}
}

void DataSource::SetControlHandles(HWND hwndStatic, HWND hwndButton)
{
	m_hWndStatic = hwndStatic;
	m_hWndButton = hwndButton;
}

void DataSource::ShowControls(bool bShow)
{
	if(bShow == true)
	{
		ShowWindow(m_hWndStatic,SW_SHOW);
		ShowWindow(m_hWndButton,SW_SHOW);
	}
	else
	{
		ShowWindow(m_hWndStatic,SW_HIDE);
		ShowWindow(m_hWndButton,SW_HIDE);
	}
}

HRESULT DataSource::GetAsyncSinkStub(IWbemObjectSink *pSink, IWbemObjectSink **pStubSink)
{
    HRESULT hr;
	IUnsecuredApartment* pUnsecApp = NULL;

    if (pSink != NULL)
    {
	    hr = CoCreateInstance(CLSID_UnsecuredApartment,
                              NULL,
                              CLSCTX_LOCAL_SERVER,
                              IID_IUnsecuredApartment, 
					          (void**)&pUnsecApp);

        if (SUCCEEDED(hr))
        {
	        IUnknown* pStubUnk = NULL;
	        hr = pUnsecApp->CreateObjectStub(pSink, &pStubUnk);

            if (SUCCEEDED(hr))
            {
	            *pStubSink = NULL;
	            hr = pStubUnk->QueryInterface(IID_IWbemObjectSink,
                                              (void **)pStubSink);
	            pStubUnk->Release();
            }

	        pUnsecApp->Release();
        }
    }
    else
        hr = E_UNEXPECTED;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\genpage.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright (c) 1997-1999 Microsoft Corporation
/**********************************************************************/

#include "precomp.h"
#include "GenPage.h"
#include "LogPage.h"
#include "AdvPage.h"
#include "resource.h"
#include "CHString1.h"
#include "DataSrc.h"
#include "wbemerror.h"
#include "WMIHelp.h"
#include <windowsx.h>

#ifdef SNAPIN
const static DWORD genPageHelpIDs[] = {  // Context Help IDs
	IDC_COMP_LABEL,	IDH_WMI_CTRL_GENERAL_CONNECTED_AS,
	IDC_MACHINE,	IDH_WMI_CTRL_GENERAL_CONNECTED_AS,
	IDC_CHANGE,		IDH_WMI_CTRL_GENERAL_CHANGE_BUTTON,
	IDC_STATUS,		IDH_WMI_CTRL_GENERAL_DISPLAY_INFO,
	IDC_GEN_PARA,	-1,
    0, 0};
#else
const static DWORD genPageHelpIDs[] = {  // Context Help IDs
	IDC_COMP_LABEL,	IDH_WMI_EXE_GENERAL_CONNECTED_TO,
	IDC_MACHINE,	IDH_WMI_EXE_GENERAL_CONNECTED_TO,
	IDC_CHANGE,		IDH_WMI_EXE_GENERAL_CHANGE_BUTTON,
	IDC_STATUS,		IDH_WMI_CTRL_GENERAL_DISPLAY_INFO,
	IDC_GEN_PARA,	-1,
    0, 0};

#endif

void EnablePrivilege(LPCTSTR privName)
{
    // Open thread token
    // =================

    HANDLE hToken = NULL;
	BOOL bRes;
    ImpersonateSelf(SecurityImpersonation);

    bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &hToken); 
    if(!bRes)
        return;// WBEM_E_ACCESS_DENIED;

    // Get the privileges
    // ==================
	LUID luid;

	ZeroMemory(&luid, sizeof(luid));

	LookupPrivilegeValue(NULL, privName, &luid);

	DWORD				dwError = ERROR_SUCCESS;
	TOKEN_PRIVILEGES	tokenPrivileges;

	tokenPrivileges.PrivilegeCount = 1;
	tokenPrivileges.Privileges[0].Luid = luid;
	tokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	if(AdjustTokenPrivileges(hToken, 
								FALSE, 
								&tokenPrivileges, 
								0, NULL, NULL) == 0)
	{
		dwError = ::GetLastError();
	}
	CloseHandle(hToken);
}


//-------------------------------------------------------------------------
CGenPage::CGenPage(DataSource *ds, bool htmlSupport) :
				CUIHelpers(ds, &(ds->m_rootThread), htmlSupport)
{
	m_connected = false;
}

//-------------------------------------------------------------------------
CGenPage::~CGenPage(void)
{
}

//-------------------------------------------------------------------------
/*#undef Static_SetIcon
#define Static_SetIcon(hwndCtl, hIcon) ((HICON)(UINT)(DWORD)::SendMessage((hwndCtl), STM_SETICON, (WPARAM)(HICON)(hIcon), 0L))
*/

void CGenPage::StatusIcon(HWND hDlg, UINT icon)
{
	HICON hiconT, hIcon = LoadIcon(NULL, MAKEINTRESOURCE(icon));

	// set it into the picture control.
    if(hIcon)
    {
		hiconT = Static_SetIcon(GetDlgItem(hDlg, IDC_STATUSICON), hIcon);

		// destroy the old icon.
        if(hiconT)
        {
            DestroyIcon(hiconT);
        }
    }
}

//---------------------------------------------------------------------------
void CGenPage::InitDlg(HWND hDlg)
{
	CHString1 local, label;

//	SetCHString1ResourceHandle(_Module.GetModuleInstance());
	m_hDlg = hDlg;

#ifdef SNAPIN
	local.LoadString(IDS_CURRENT_USER);
	label.LoadString(IDS_USER_LABEL);
	::SetWindowText(GetDlgItem(hDlg, IDC_COMP_LABEL), label);

	label.LoadString(IDS_GEN_PARA_SNAPIN);
	::SetWindowText(GetDlgItem(hDlg, IDC_GEN_PARA), label);
	::SetWindowText(GetDlgItem(hDlg, IDC_MACHINE), local);
#else
	local.LoadString(IDS_LOCAL_CONN);
	::SetWindowText(GetDlgItem(hDlg, IDC_MACHINE), local);
#endif
	OnConnect(hDlg, m_DS->GetCredentials());
}

//---------------------------------------------------------------------------
void CGenPage::OnConnect(HWND hDlg,
						 LOGIN_CREDENTIALS *credentials)
{
	m_connected = false;

	CHString1 wait;
	wait.LoadString(IDS_WAIT);
	::SetDlgItemText(hDlg, IDC_STATUS, wait);

#ifndef SNAPIN
    EnablePrivilege(SE_BACKUP_NAME);
    EnablePrivilege(SE_RESTORE_NAME);
#endif

	HRESULT hr = m_DS->Connect(credentials);

	if(SUCCEEDED(hr))
	{
		// goto the connecting icon.
		StatusIcon(hDlg, IDI_WAITING);

		m_alreadyAsked = false;

		if(ServiceIsReady(NO_UI, 0,0))
		{
			m_DS->Initialize(0);
		}
		else
		{
 			TCHAR caption[100] ={0}, msg[256] = {0};

			::LoadString(_Module.GetModuleInstance(), IDS_SHORT_NAME,
							caption, 100);

			::LoadString(_Module.GetModuleInstance(), IDS_CONNECTING, 
							msg, 256);

			if(DisplayAVIBox(hDlg, caption, msg, &m_AVIbox) == IDCANCEL)
			{
				g_serviceThread->Cancel();
			}
		}
	}
	else
	{
		// goto the no-connection icon.
		StatusIcon(hDlg, IDI_FAILED);
	}
}

//---------------------------------------------------------------------------
void CGenPage::OnFinishConnected(HWND hDlg, LPARAM lParam)
{
	if(lParam)
	{
		IStream *pStream = (IStream *)lParam;
		IWbemServices *pServices = 0;
		HRESULT hr = CoGetInterfaceAndReleaseStream(pStream,
											IID_IWbemServices,
											(void**)&pServices);
		
		m_connected = true;

		SetWbemService(pServices);

		if(ServiceIsReady(NO_UI, 0,0))
		{
			m_DSStatus = m_DS->Initialize(pServices);
		}
		if(m_AVIbox)
		{
			PostMessage(m_AVIbox, 
						WM_ASYNC_CIMOM_CONNECTED, 
						0, 0);
			m_AVIbox = 0;
		}
		HWND hOK = GetDlgItem(GetParent(hDlg), IDOK);
		EnableWindow(hOK, TRUE);
	}
	else
	{
		HWND hOK = GetDlgItem(GetParent(hDlg), IDOK);
		EnableWindow(hOK, FALSE);
	}
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
}	

//---------------------------------------------------------------------------
void CGenPage::MinorError(CHString1 &initMsg, UINT fmtID, 
							HRESULT hr, CHString1 &success)
{
	CHString1 fmt, temp;

	fmt.LoadString(fmtID);

	if(FAILED(hr))
	{
		TCHAR errMsg[256] = {0};
		ErrorStringEx(hr, errMsg, 256);
		temp.Format(fmt, errMsg);
	}
	else
	{
		temp.Format(fmt, success);
	}
	initMsg += temp;
	initMsg += "\r\n";
}

//---------------------------------------------------------------------------
void CGenPage::Refresh(HWND hDlg)
{
	if(m_DS && m_DS->IsNewConnection(&m_sessionID))
	{

		CHString1 initMsg;

		if(m_DS->m_rootThread.m_status != WbemServiceThread::ready)
		{
			TCHAR errMsg[256] = {0};
			CHString1 fmt, name;

			fmt.LoadString(IDS_CONN_FAILED_FMT);
			if(FAILED(m_DS->m_rootThread.m_hr))
			{
				ErrorStringEx(m_DS->m_rootThread.m_hr, errMsg, 256);
			}
			else if(m_DS->m_rootThread.m_status == WbemServiceThread::notStarted)
			{
				::LoadString(_Module.GetModuleInstance(), IDS_STATUS_NOTSTARTED, 
								errMsg, ARRAYSIZE(errMsg));
			}
			else if(m_DS->m_rootThread.m_status == WbemServiceThread::cancelled)
			{
				::LoadString(_Module.GetModuleInstance(), IDS_STATUS_CANCELLED, 
								errMsg, ARRAYSIZE(errMsg));
			}

			if(m_DS->IsLocal())
			{
				name.LoadString(IDS_LOCAL_CONN);
				initMsg.Format(fmt, name, errMsg);
			}
			else
			{
				initMsg.Format(fmt, m_DS->m_whackedMachineName, errMsg);
			}
			::SetWindowText(GetDlgItem(hDlg, IDC_MACHINE), _T(""));
			m_connected = false;

		}
		else if(FAILED(m_DSStatus))   // major DS failure.
		{
			TCHAR errMsg[256] = {0};
			CHString1 fmt, name;

			fmt.LoadString(IDS_CONN_FAILED_FMT);
			ErrorStringEx(m_DSStatus, errMsg, 256);

			if(m_DS->IsLocal())
			{
				name.LoadString(IDS_LOCAL_CONN);
				initMsg.Format(fmt, name, errMsg);
			}
			else
			{
				initMsg.Format(fmt, m_DS->m_whackedMachineName, errMsg);
			}
			m_connected = false;
		}
		else if(FAILED(m_DS->m_settingHr) ||
				FAILED(m_DS->m_osHr) ||
				FAILED(m_DS->m_cpuHr) ||
				FAILED(m_DS->m_securityHr))   // minor DS failures
		{
			CHString1 success;
				
			success.LoadString(IDS_NO_ERR);
			
			initMsg.LoadString(IDS_PARTIAL_DS_FAILURE);
			initMsg += "\r\n\r\n";

			// format the details into a coherent msg.
			MinorError(initMsg, IDS_CPU_ERR_FMT, m_DS->m_cpuHr, success);
			MinorError(initMsg, IDS_SETTING_ERR_FMT, m_DS->m_settingHr, success);
			MinorError(initMsg, IDS_SEC_ERR_FMT, m_DS->m_securityHr, success);
			MinorError(initMsg, IDS_OS_ERR_FMT, m_DS->m_osHr, success);
			m_connected = false;
		}
		else  // it all worked
		{
			CHString1 temp, label;
			CHString1 szNotRemoteable, szUnavailable;
			HRESULT hr = S_OK;
			BOOL enable = TRUE;

			szNotRemoteable.LoadString(IDS_NOT_REMOTEABLE);
			szUnavailable.LoadString(IDS_UNAVAILABLE);

			// - - - - - - - - - - - - - -
			// computer name:
			label.LoadString(IDS_CONNECTED_TO_LABEL);
			initMsg += label;

			if(m_DS->IsLocal())
			{
				label.LoadString(IDS_LOCAL_CONN);
	#ifndef SNAPIN
				::SetWindowText(GetDlgItem(hDlg, IDC_MACHINE), label);
	#endif
				initMsg += label;
			}
			else
			{
				initMsg += m_DS->m_whackedMachineName;
	#ifndef SNAPIN
				SetWindowText(GetDlgItem(hDlg, IDC_MACHINE), 
								(LPCTSTR)m_DS->m_whackedMachineName);
	#endif
			}
			initMsg += "\r\n\r\n";

	#ifdef SNAPIN
			LOGIN_CREDENTIALS *credentials = m_DS->GetCredentials();
			SetUserName(hDlg, credentials);
	#endif
			// - - - - - - - - - - - - - -
			// operating system:
			hr = m_DS->GetCPU(temp);
			
			label.LoadString(IDS_CPU_LABEL);
			initMsg += label;

			if(SUCCEEDED(hr))
			{
				initMsg += temp;
			}
			else //failed
			{
				initMsg += szUnavailable;
			}

			initMsg += "\r\n";

			// - - - - - - - - - - - - - -
			// operating system:
			hr = m_DS->GetOS(temp);

			label.LoadString(IDS_OS_LABEL);
			initMsg += label;

			if(SUCCEEDED(hr))
			{
				initMsg += temp;
			}
			else //failed
			{
				initMsg += szUnavailable;
			}
			initMsg += "\r\n";

			// - - - - - - - - - - - - - - -
			hr = m_DS->GetOSVersion(temp);
			
			label.LoadString(IDS_OS_VER_LABEL);
			initMsg += label;
			
			if(SUCCEEDED(hr))
			{
				initMsg += temp;
			}
			else //failed
			{
				initMsg += szUnavailable;
			}
			initMsg += "\r\n";

			// -------------- Service Pack Number ---------------
			hr = m_DS->GetServicePackNumber(temp);

			if(SUCCEEDED(hr))
			{
				label.LoadString(IDS_OS_SERVICE_PACK_LABEL);
				initMsg += label;
				initMsg += temp;
				initMsg += "\r\n";
			}
			// - - - - - - - - - - - - - -
			// wmi build number:
			hr = m_DS->GetBldNbr(temp);

			label.LoadString(IDS_WMI_VER_LABEL);
			initMsg += label;

			if(SUCCEEDED(hr))
			{
				initMsg += temp;
			}
			else //failed
			{
				initMsg += szUnavailable;
			}

			initMsg += "\r\n";

			// - - - - - - - - - - - - - -
			// wmi install dir:
			hr = m_DS->GetInstallDir(temp);

			label.LoadString(IDS_WMI_INSTALL_DIR);
			initMsg += label;

			if(SUCCEEDED(hr))
			{
				initMsg += temp;
			}
			else //failed
			{
				initMsg += szUnavailable;
			}

			m_connected = true;

		} //endif ServiceIsReady() 

		// - - - - - - - - - - - - - -
		SetWindowText(GetDlgItem(hDlg, IDC_STATUS), initMsg);

		if(m_DS->IsLocal() == TRUE)
		{
			EnableWindow(GetDlgItem(hDlg,IDC_CHANGE),FALSE);
		}
		else
		{
			EnableWindow(GetDlgItem(hDlg,IDC_CHANGE),TRUE);
		}
	}
}

//------------------------------------------------------------------------
void CGenPage::SetUserName(HWND hDlg, LOGIN_CREDENTIALS *credentials)
{
	if(credentials->currUser)
	{
		CHString1 local;
		local.LoadString(IDS_CURRENT_USER);
		SetDlgItemText(hDlg, IDC_MACHINE, (LPCTSTR)local);
	}
	else if(credentials->authIdent &&
			credentials->authIdent->User &&
			credentials->authIdent->UserLength != 0)
	{
		bstr_t trustee(credentials->authIdent->Domain);
		trustee += _T("\\");
		trustee += (LPTSTR)credentials->authIdent->User;

		SetDlgItemText(hDlg, IDC_MACHINE, (LPCTSTR)trustee);
	}
	else
	{
		CHString1 szUnavailable;

		szUnavailable.LoadString(IDS_UNAVAILABLE);
		SetDlgItemText(hDlg, IDC_MACHINE, (LPCTSTR)szUnavailable);
	}
}

//------------------------------------------------------------------------
BOOL CGenPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        InitDlg(hDlg);
        break;

	case WM_ASYNC_CIMOM_CONNECTED:
//		if(!m_connected)
		{
			OnFinishConnected(hDlg, lParam);
			Refresh(hDlg);   // doesnt get a PSN_SETACTIVE from this.
		}
		break;

	case WM_CIMOM_RECONNECT:
			m_DS->Disconnect();
			OnConnect(hDlg, m_DS->GetCredentials());
		break;

    case WM_NOTIFY:
        {
            switch(((LPNMHDR)lParam)->code)
            {
			case PSN_SETACTIVE:
				Refresh(hDlg);
				break;

			case PSN_KILLACTIVE:
				// dont switch away if the connection didn't work.
				if(m_connected)
				{
					::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
					return FALSE;
				}
				else
				{
					::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
					return TRUE;
				}

				break;

			case PSN_HELP:
				HTMLHelper(hDlg);
				break;

            }
        }
        break;

    case WM_COMMAND:
		switch(LOWORD(wParam))
		{
		case IDC_CHANGE:
			if(HIWORD(wParam) == BN_CLICKED)
			{
				TCHAR name[256] = {0};
				bool isLocal = m_DS->IsLocal();
				LOGIN_CREDENTIALS *credentials = m_DS->GetCredentials();
#ifdef SNAPIN
				if(DisplayLoginDlg(hDlg, credentials) == IDOK)
				{
					SetUserName(hDlg, credentials);

					// reconnect with new credentials.
					m_DS->Disconnect(false);
					OnConnect(hDlg, credentials);

				} //endif DisplayLoginDlg()
#else
				INT_PTR x = DisplayCompBrowser(hDlg, name, 
											256, 
											&isLocal, credentials);
				if(x == IDOK)
				{
					if(isLocal)
					{
						// an empty string will cause a local connection.
						name[0] = '\0';
					}
					m_DS->SetMachineName(CHString1(name));
					OnConnect(hDlg, credentials);
				}
#endif
			} //endif HIWORD
		
	        break;
		default: break;
		} //endswitch
		break;

    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
			//WIERD: for some reaon, I'm getting this msg after closing the
			// connect dlg.
			WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
					c_HelpFile,
					HELP_WM_HELP,
					(ULONG_PTR)genPageHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp(hDlg, c_HelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)genPageHelpIDs);
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\errorsecpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// RootSecPage.cpp : implementation file
//

#include "precomp.h"
#include "ErrorSecPage.h"
#include "DataSrc.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CErrorSecurityPage dialog


CErrorSecurityPage::CErrorSecurityPage(UINT msg) :
					CUIHelpers(NULL, NULL, false),
					m_msg(msg)
{
}

//---------------------------------------------------------------------------
void CErrorSecurityPage::InitDlg(HWND hDlg)
{
    HWND hwnd = GetDlgItem(hDlg, IDC_NO_SECURITY);

	CHString1 msgStr;
	if(msgStr.LoadString(m_msg))
	{
		::SetWindowText(hwnd, (LPCTSTR)msgStr);
	}
	else
	{
		::SetWindowText(hwnd, _T("Cannot display the correct problem due to an internal error."));
	}
}

//------------------------------------------------------------------------
BOOL CErrorSecurityPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        InitDlg(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\logpage.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright (c) 1997-1999 Microsoft Corporation
/**********************************************************************/

#include "precomp.h"
#include "LogPage.h"
#include "CHString1.h"
#include "resource.h"
#include <shlobj.h>
#include "WMIHelp.h"
#include <errno.h>
#include "ShlWapi.h"

const static DWORD logPageHelpIDs[] = {  // Context Help IDs
	IDC_LOG_PARA,				-1,
	IDC_STATUS_FRAME,			-1,
	IDC_DISABLELOGGING,			IDH_WMI_CTRL_LOGGING_LOGGING_LEVEL,
	IDC_ERRORLOGGING,			IDH_WMI_CTRL_LOGGING_LOGGING_LEVEL,
	IDC_VERBOSELOGGING,			IDH_WMI_CTRL_LOGGING_LOGGING_LEVEL,
	IDC_MAXFILESIZE_LABEL,		IDH_WMI_CTRL_LOGGING_MAX_SIZE,
	IDC_MAXFILESIZE,			IDH_WMI_CTRL_LOGGING_MAX_SIZE,
	IDC_LOGGINGDIRECTORY_LABEL,	IDH_WMI_CTRL_LOGGING_LOCATION,
	IDC_LOGGINGDIRECTORY,		IDH_WMI_CTRL_LOGGING_LOCATION,
	IDC_BROWSE,					IDH_WMI_CTRL_LOGGING_BROWSE,
    0, 0
};

CLogPage::~CLogPage(void)
{
}

//-------------------------------------------------------------------------
void CLogPage::InitDlg(HWND hDlg)
{
	m_hDlg = hDlg;

	::SendMessage(GetDlgItem(hDlg, IDC_MAXFILESIZE),
					EM_LIMITTEXT, 10, 0);

	::SendMessage(GetDlgItem(hDlg, IDC_LOGGINGDIRECTORY),
					EM_LIMITTEXT, _MAX_PATH, 0);
}

//---------------------------------------------------------------------------
void CLogPage::Refresh(HWND hDlg)
{
	if(m_DS && m_DS->IsNewConnection(&m_sessionID))
	{
		CHString1 temp;
		ULONG iTemp;
		CHString1 szNotRemoteable, szUnavailable;
		HRESULT hr = S_OK;
		BOOL enable = TRUE;

		szNotRemoteable.LoadString(IDS_NOT_REMOTEABLE);
		szUnavailable.LoadString(IDS_UNAVAILABLE);

		PageChanged(PB_LOGGING, false);

		// - - - - - - - - - - - - - -
		// logging status:
		UINT ID = IDC_DISABLELOGGING;

		hr = m_DS->GetLoggingStatus(m_oldStatus);
		if(SUCCEEDED(hr))
		{
			switch(m_oldStatus)
			{
			case DataSource::Disabled:   ID = IDC_DISABLELOGGING; break;
			case DataSource::ErrorsOnly: ID = IDC_ERRORLOGGING;   break;
			case DataSource::Verbose:	 ID = IDC_VERBOSELOGGING; break;
			}
			enable = TRUE;
			CheckRadioButton(hDlg, IDC_DISABLELOGGING, IDC_VERBOSELOGGING,
								ID);
		}
		else //failed
		{
			enable = FALSE;
		}

		::EnableWindow(GetDlgItem(hDlg, IDC_STATUS_FRAME), enable);
		::EnableWindow(GetDlgItem(hDlg, IDC_DISABLELOGGING), enable);
		::EnableWindow(GetDlgItem(hDlg, IDC_ERRORLOGGING), enable);
		::EnableWindow(GetDlgItem(hDlg, IDC_VERBOSELOGGING), enable);

		// - - - - - - - - - - - - - -
		// max file size:
		hr = m_DS->GetLoggingSize(iTemp);
		if(SUCCEEDED(hr))
		{
			enable = TRUE;
			temp.Format(_T("%u"), iTemp);
			SetWindowText(GetDlgItem(hDlg, IDC_MAXFILESIZE),
							temp);
		}
		else //failed
		{
			enable = FALSE;
			SetWindowText(GetDlgItem(hDlg, IDC_MAXFILESIZE),
							szUnavailable);
		}

		::EnableWindow(GetDlgItem(hDlg, IDC_MAXFILESIZE),
						enable);
		::EnableWindow(GetDlgItem(hDlg, IDC_MAXFILESIZE_LABEL),
						enable);

		// - - - - - - - - - - - - - -
		// Location:
		hr = m_DS->GetLoggingLocation(temp);
		if(SUCCEEDED(hr))
		{
			SetWindowText(GetDlgItem(hDlg, IDC_LOGGINGDIRECTORY),
							temp);
		}

		// browse only works for local connections.
		::EnableWindow(GetDlgItem(hDlg, IDC_BROWSE),
						((BOOL)m_DS->IsLocal()) );
	}
}

//------------------------------------------------------------------------
bool CLogPage::GoodPathSyntax(LPCTSTR path)
{
	bool retval = true;
	
	if(PathIsUNC(path))
	{
		TCHAR caption[50] = {0}, threat[100] = {0};
		::LoadString(_Module.GetResourceInstance(),
						IDS_SHORT_NAME, caption, 50);
		::LoadString(_Module.GetResourceInstance(),
						IDS_NO_UNC, threat, 100);

		MessageBox(m_hDlg, threat, caption, 
					MB_OK|MB_DEFBUTTON1|MB_ICONEXCLAMATION);
		retval = false;
	}
	else
	{
		TCHAR pth[_MAX_PATH] = {0},
			file[_MAX_FNAME] = {0}, ext[_MAX_EXT] = {0};	
		TCHAR drive[_MAX_DRIVE] = {0};

		// rip it apart.
		_tsplitpath(path, drive, pth, file, ext);

		// missing a letter?
		if((!_istalpha(drive[0])) || 
		   (drive[1] != _T(':')))
		{
			TCHAR caption[50] = {0}, threat[100] = {0};
			::LoadString(_Module.GetResourceInstance(),
							IDS_SHORT_NAME, caption, 50);
			::LoadString(_Module.GetResourceInstance(),
							IDS_NO_DRIVE_LTR, threat, 50);

			MessageBox(m_hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
						MB_OK|MB_DEFBUTTON1|MB_ICONEXCLAMATION);

			retval = false;
		}
		// has a filename?
		else if((_tcslen(file) != 0) || (_tcslen(ext) != 0))
		{
			TCHAR caption[50] = {0}, threat[100] = {0};
			::LoadString(_Module.GetResourceInstance(),
							IDS_SHORT_NAME, caption, ARRAYSIZE(caption));
			::LoadString(_Module.GetResourceInstance(),
							IDS_DIRS_ONLY, threat, ARRAYSIZE(threat));

			MessageBox(m_hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
						MB_OK|MB_DEFBUTTON1|MB_ICONEXCLAMATION);

			retval = false;
		}

		// what kind of drive?
		CWbemClassObject inst;
		TCHAR drvRoot[40] = {0};
		_tcscpy(drvRoot, _T("Win32_LogicalDisk=\""));
		_tcsncat(drvRoot, path, 2);
		_tcscat(drvRoot, _T("\""));

		inst = m_DS->m_cimv2NS.GetObject(drvRoot);
		if(inst)
		{
			DWORD driveType = inst.GetLong(_T("DriveType"));
			if(driveType != 3)
			{
				// cant use removeables.
				TCHAR caption[50] = {0}, threat[100] = {0};
				::LoadString(_Module.GetResourceInstance(),
								IDS_SHORT_NAME, caption, ARRAYSIZE(caption));
				::LoadString(_Module.GetResourceInstance(),
								IDS_LOGS_WRONG_DRIVETYPE, threat, ARRAYSIZE(threat));

				MessageBox(m_hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
							MB_OK|MB_DEFBUTTON1|MB_ICONEXCLAMATION);

				retval = false;
			}
		}
		else
		{
		}
	}
	return retval;
}

//------------------------------------------------------------------------
BOOL CLogPage::OnValidate(HWND hDlg)
{
	BOOL keepFocus = FALSE;
	HWND hwnd = GetDlgItem(hDlg, IDC_LOGGINGDIRECTORY);

	if(Edit_GetModify(hwnd))
	{
		TCHAR buf[_MAX_PATH] = {0};

		::GetWindowText(hwnd, buf, _MAX_PATH);
		if(_tcslen(buf) == 0)
		{
			CHString1 caption, threat;
			caption.LoadString(IDS_SHORT_NAME);
			threat.LoadString(IDS_DIR_EMPTY);

			MessageBox(hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
							MB_OK|MB_DEFBUTTON1|MB_ICONEXCLAMATION);

			CHString1 temp;
			HRESULT hr = m_DS->GetLoggingLocation(temp);
			if(SUCCEEDED(hr))
			{
				SetWindowText(GetDlgItem(hDlg, IDC_LOGGINGDIRECTORY),
								temp);
			}
			// send him back to fix it.
			Edit_SetModify(hwnd, FALSE);

			::SetFocus(hwnd);
			keepFocus = TRUE;

		}
		else if(!GoodPathSyntax(buf))
		{
			::SetFocus(hwnd);
			keepFocus = TRUE;

		}
		else if(m_DS->IsValidDir(CHString1(buf)))
		{
			keepFocus = FALSE;
		}
		else 
		{
			CHString1 strLogDir;
			m_DS->GetLoggingLocation(strLogDir);

			if(CHString1(buf) != strLogDir)
			{
				// msg box here.
				CHString1 caption, threat;
				caption.LoadString(IDS_SHORT_NAME);
				threat.LoadString(IDS_DIR_DOESNT_EXIST);

				if(MessageBox(hDlg, (LPCTSTR)threat, (LPCTSTR)caption, 
								MB_YESNO|MB_DEFBUTTON2|MB_ICONEXCLAMATION) == IDYES)
				{
					// let it go through then.
					Edit_SetModify(hwnd, TRUE);
					keepFocus = FALSE;
				}
				else
				{
					// send him back to fix it.
					Edit_SetModify(hwnd, FALSE);

					::SetFocus(hwnd);
					keepFocus = TRUE;
				}
			}
			else
			{
				keepFocus = FALSE;
			}
		}
	}
	
	// check the logsize.
	hwnd = GetDlgItem(hDlg, IDC_MAXFILESIZE);

	if((keepFocus == FALSE) && Edit_GetModify(hwnd))
	{
		TCHAR buf[16] = {0};
		ULONG temp = 0;

		::GetWindowText(hwnd, buf, 16);
		errno = 0;
		temp = _tcstoul(buf, NULL, 10);

		if(errno == ERANGE)
		{
			TCHAR caption[50] = {0}, threat[100] = {0};
			::LoadString(_Module.GetResourceInstance(),
							IDS_SHORT_NAME, caption, ARRAYSIZE(caption));
			::LoadString(_Module.GetResourceInstance(),
							IDS_BAD_LOGSIZE, threat, ARRAYSIZE(threat));

			MessageBox(m_hDlg, threat, caption, 
						MB_OK|MB_DEFBUTTON1|MB_ICONEXCLAMATION);

			::SetFocus(hwnd);
			keepFocus = TRUE;
		}
	}
	return keepFocus;
}

//------------------------------------------------------------------------
void CLogPage::OnApply(HWND hDlg, bool bClose)
{
	DataSource::LOGSTATUS status = DataSource::Disabled;
	bool needToPut = false;

	if(IsDlgButtonChecked(hDlg, IDC_DISABLELOGGING) == BST_CHECKED)
		status = DataSource::Disabled;
	else if(IsDlgButtonChecked(hDlg, IDC_ERRORLOGGING) == BST_CHECKED)
		status = DataSource::ErrorsOnly;
	else if(IsDlgButtonChecked(hDlg, IDC_VERBOSELOGGING) == BST_CHECKED)
		status = DataSource::Verbose;

	if(m_oldStatus != status)
	{
		m_DS->SetLoggingStatus(status);
		m_oldStatus = status;
		needToPut = true;
	}

	HWND hwnd = GetDlgItem(hDlg, IDC_MAXFILESIZE);

	TCHAR buf[_MAX_PATH] = {0};
	ULONG temp = 0;

	if(Edit_GetModify(hwnd))
	{
		::GetWindowText(hwnd, buf, ARRAYSIZE(buf));
		temp = _tcstoul(buf, NULL, 10);
		if(SUCCEEDED(m_DS->SetLoggingSize(temp)))
		{
			needToPut = true;
		}
	}

	hwnd = GetDlgItem(hDlg, IDC_LOGGINGDIRECTORY);
	if(Edit_GetModify(hwnd))
	{
		::GetWindowText(hwnd, buf, ARRAYSIZE(buf));
		if(SUCCEEDED(m_DS->SetLoggingLocation(buf)))
		{
			needToPut = true;
		}
	}

	if(needToPut)
	{
		NeedToPut(PB_LOGGING, !bClose);
		if(!bClose)
			Refresh(hDlg);
	}
}

//------------------------------------------------------------------------
BOOL CLogPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        InitDlg(hDlg);
        break;

    case WM_NOTIFY:
        {
            switch (((LPNMHDR)lParam)->code)
            {
			case PSN_SETACTIVE:
				Refresh(hDlg);
				break;

			case PSN_HELP:
				HTMLHelper(hDlg);
				break;

            case PSN_APPLY:
                OnApply(hDlg, (((LPPSHNOTIFY)lParam)->lParam == 1));
                break;

            case PSN_KILLACTIVE:
				{
					BOOL retval = OnValidate(hDlg);
					::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, retval);
					return retval;
				}
                break;
            }
        }
        break;

    case WM_COMMAND:
		switch(LOWORD(wParam))
		{
		case IDC_DISABLELOGGING:
		case IDC_ERRORLOGGING:
		case IDC_VERBOSELOGGING:
			if(HIWORD(wParam) == BN_CLICKED)
			{
				PageChanged(PB_LOGGING, true);
				return TRUE;
			}
			break;
		
		case IDC_MAXFILESIZE:
			if(HIWORD(wParam) == EN_UPDATE)
			{
			    bool valid = true;
				HWND hwnd = GetDlgItem(hDlg, IDC_MAXFILESIZE);
				TCHAR buf[_MAX_PATH] = {0};

				::GetWindowText(hwnd, buf, _MAX_PATH);
				for(UINT x = 0; valid && x < _tcslen(buf); x++)
				{
					switch(buf[x])
					{
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						valid = true;
						break;

					default: 
						valid = false;
						break;
					} //endswitch
				} //endfor

                if(!valid) 
				{
					buf[_tcslen(buf) - 1] = _T('\0');
                    SetWindowText(hwnd, buf); 
                    SendMessage(hwnd, EM_SETSEL, 0, -1);
					MessageBeep(MB_ICONASTERISK);
                    
                } // endif

			}
			else if((HIWORD(wParam) == EN_CHANGE) && 
					 Edit_GetModify((HWND)lParam))
			{
				PageChanged(PB_LOGGING, true);
				return TRUE;
			}
			break;

		case IDC_LOGGINGDIRECTORY:
			if((HIWORD(wParam) == EN_CHANGE) && Edit_GetModify((HWND)lParam))
			{
				PageChanged(PB_LOGGING, true);
				return TRUE;
			}
			break;

		case IDC_BROWSE:
			if(HIWORD(wParam) == BN_CLICKED)
			{
				LPMALLOC pMalloc;    /* Gets the Shell's default allocator */
				if(::SHGetMalloc(&pMalloc) == NOERROR)    
				{        
					BROWSEINFO bi;
					TCHAR pszBuffer[MAX_PATH] = {0};
					LPITEMIDLIST pidl;
					ITEMIDLIST *root;

					// Get the PIDL for the Programs folder. 
					if(SUCCEEDED(SHGetSpecialFolderLocation(hDlg, CSIDL_DRIVES, 
																&root))) 
					{ 
						bi.pidlRoot = root;
					} 
					else
					{					
						bi.pidlRoot = NULL;

					}
					// Get help on BROWSEINFO struct - it's got all the bit settings.
					TCHAR title[100] = {0};
					::LoadString(_Module.GetModuleInstance(), IDS_LOG_SELECT_FDR, 
									title, 100);
					bi.hwndOwner = hDlg;
					bi.pszDisplayName = pszBuffer;
					bi.lpszTitle = title;
					bi.ulFlags = BIF_RETURNFSANCESTORS | BIF_RETURNONLYFSDIRS;
					bi.lpfn = NULL;
					bi.lParam = 0;
					// This next call issues the dialog box.
					if((pidl = ::SHBrowseForFolder(&bi)) != NULL)
					{
						if(::SHGetPathFromIDList(pidl, pszBuffer))
						{ 
							// At this point pszBuffer contains the selected path */.
							HWND hwnd = GetDlgItem(hDlg, IDC_LOGGINGDIRECTORY);
							PathAddBackslash(pszBuffer);
							SetWindowText(hwnd, pszBuffer);
							Edit_SetModify(hwnd, TRUE);
							PageChanged(PB_LOGGING, true);
						}
						// Free the PIDL allocated by SHBrowseForFolder.
						pMalloc->Free(pidl);
					}
					// Release the shell's allocator.
					pMalloc->Release();
				}
			}
			break;

		default: break;
		} //endswitch(LOWORD(wParam))
	
        break;

    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_HelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)logPageHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp(hDlg, c_HelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)logPageHelpIDs);
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\debug.h ===
#ifndef __debug_h
#define __debug_h


/*-----------------------------------------------------------------------------
/ Debugging APIs (use the Macros, they make it easier and cope with correctly
/ removing debugging when it is disabled at built time).
/----------------------------------------------------------------------------*/
/*
void DoTraceSetMask(DWORD dwMask);
void DoTraceEnter(DWORD dwMask, LPCTSTR pName);
void DoTraceLeave(void);
void DoTrace(LPCTSTR pFormat, ...);
void DoTraceGUID(LPCTSTR pPrefix, REFGUID rGUID);
void DoTraceAssert(int iLine, LPTSTR pFilename);
*/

/*-----------------------------------------------------------------------------
/ Macros to ease the use of the debugging APIS.
/----------------------------------------------------------------------------*/

#pragma warning(disable:4127)	// conditional expression is constant

#if DBG
#ifndef DEBUG
#define DEBUG
#endif
#define debug if ( TRUE )
#else
#undef  DEBUG
#define debug if ( FALSE )
#endif

#ifdef NEVER //DEBUG
#define TraceSetMask(dwMask)    debug DoTraceSetMask(dwMask)
#define TraceEnter(dwMask, fn)  debug DoTraceEnter(dwMask, TEXT(fn))
#define TraceLeave              debug DoTraceLeave

#define Trace                   debug DoTrace
#define TraceMsg(s)             debug DoTrace(TEXT(s))
#define TraceGUID(s, rGUID)     debug DoTraceGUID(TEXT(s), rGUID)


#define TraceAssert(x) \
                { if ( !(x) ) DoTraceAssert(__LINE__, TEXT(__FILE__)); }

#define TraceLeaveResult(hr) \
                { HRESULT __hr = hr; if (FAILED(__hr)) Trace(TEXT("Failed (%08x)"), hr); TraceLeave(); return __hr; }

#define TraceLeaveVoid() \
                { TraceLeave(); return; }

#define TraceLeaveValue(value) \
                { TraceLeave(); return(value); }

#else
#define TraceAssert(x)
#define TraceLeaveResult(hr)    { return hr; }
#define TraceLeaveVoid()	{ return; }
#define TraceLeaveValue(value)  { return(value); }

#define TraceSetMask(dwMask)  
#define TraceEnter(dwMask, fn)
#define TraceLeave           

#define Trace               
#define TraceMsg(s)        
#define TraceGUID(s, rGUID)


#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\datasrc.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __DATASOURCE__
#define __DATASOURCE__

#include <CHString1.h>
#include "..\common\sshWbemHelpers.h"
#include "ServiceThread.h"
#include <aclui.h>
#include <list>

#define OSTYPE_WIN95 16
#define OSTYPE_WIN98 17
#define OSTYPE_WINNT 18

#define	ROOT_ONLY 0 
#define	HIDE_SOME 1
#define	SHOW_ALL 2

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

// this structure is saved.
enum NODE_TYPE
{
	TYPE_NAMESPACE,
	TYPE_STATIC_CLASS,
	TYPE_DYNAMIC_CLASS,
	TYPE_SCOPE_CLASS,
	TYPE_STATIC_INSTANCE,
	TYPE_SCOPE_INSTANCE,
};

//struct NSNODE;

struct NSNODE 
{
	NSNODE()
	{
		sType = TYPE_NAMESPACE;		//For backward Compatibility
		nsLoaded = false;
		pclsObj = NULL;
		objSinkNS = NULL;
		objSink = NULL;
	}

	LPTSTR display;			// single word
	LPTSTR fullPath;		// whole objpath
	LPTSTR relPath;
	CWbemServices *ns;
	CWbemClassObject *pclsObj;
//	IWbemServicesEx *pServicesEx;
	IWbemObjectSink *objSinkNS;
	IWbemObjectSink *objSink;
	bool hideMe;
	bool nsLoaded;
	NODE_TYPE sType;
	CSimpleArray<NSNODE *> children;
};

// for the namespace tree nodes.
typedef struct ITEMEXTRA
{
	struct NSNODE *nsNode;
	bool loaded;
} ITEMEXTRA;


// INTERFACE NOTES:
// WBEM_S_ACCESS_DENIED = no access to data.
// WBEM_S_FALSE = readonly access.
class DataSource
{
public:
	DataSource();
	virtual ~DataSource();
	short m_OSType;

	// connecting.
	// NOTE: WBEM_S_DIFFERENT means it changed 'machine'. Refresh your UI.
	void SetMachineName(CHString1 &machine);
	HRESULT Connect(LOGIN_CREDENTIALS *credentials = NULL);
	HRESULT Initialize(IWbemServices *pServices);
	HRESULT Disconnect(bool clearCredentials = true);
	HRESULT Reconnect(void);
	bool IsNewConnection(long *sessionID);

	bool IsConnected(void) const;
	bool IsLocal(void) const;
	bool IsAncient(void) const;
	LOGIN_CREDENTIALS *GetCredentials(void);
	bstr_t GetRootNS(void);
	CWbemServices RootSecNS(void) const 
	{
		return m_rootSecNS;
	};

	ISecurityInformation *GetSI(struct NSNODE *nsNode);

	void LoadImageList(HWND hTree);

	// load a tree control from NSCache.
	HRESULT LoadNode(HWND hTree, HTREEITEM hItem = TVI_ROOT, 
						int flags = SHOW_ALL);
	void DeleteAllNodes(void);

	// general tab.
	HRESULT GetCPU(CHString1 &cpu);
	HRESULT GetOS(CHString1 &os);
	HRESULT GetOSVersion(CHString1 &ver);
	HRESULT GetServicePackNumber(CHString1 &ServPack);

	HRESULT GetBldNbr(CHString1 &bldNbr);
	HRESULT GetInstallDir(CHString1 &dir);
	HRESULT GetDBDir(CHString1 &dir);

	HRESULT GetBackupInterval(UINT &interval);
	HRESULT SetBackupInterval(UINT interval);
	
	HRESULT GetLastBackup(CHString1 &time);

	// logging tab.
	enum LOGSTATUS
	{
		Disabled = 0,
		ErrorsOnly,
		Verbose
	};
	HRESULT GetLoggingStatus(LOGSTATUS &status);
	HRESULT SetLoggingStatus(LOGSTATUS status);

	HRESULT GetLoggingSize(ULONG &size);
	HRESULT SetLoggingSize(ULONG size);

	HRESULT GetDBLocation(CHString1 &dir);

	HRESULT GetLoggingLocation(CHString1 &dir);
	HRESULT SetLoggingLocation(CHString1 dir);
	bool CanBrowseFS(void) const;

	// advanced tab.
	HRESULT GetScriptASPEnabled(bool &enabled);
	HRESULT SetScriptASPEnabled(bool &enabled);
	HRESULT GetAnonConnections(bool &enabled);
	HRESULT SetAnonConnections(bool &enabled);

	HRESULT GetScriptDefNS(CHString1 &ns);
	HRESULT SetScriptDefNS(LPCTSTR ns);

	enum RESTART
	{
		Dont = 0,
		AsNeededByESS,
		Always
	};
	HRESULT GetRestart(RESTART &restart);
	HRESULT SetRestart(RESTART restart);

	HRESULT PutWMISetting(BOOL refresh);
	bool IsValidDir(CHString1 &dir);
	bool IsValidFile(LPCTSTR szDir);
	
	WbemServiceThread m_rootThread;  // this will be \root.
	CHString1 m_whackedMachineName;
	CWbemServices m_rootSecNS, m_cimv2NS;
	HRESULT m_settingHr, m_securityHr, m_osHr, m_cpuHr;

	void InsertNamespaceNode(HWND hTreeWnd,HTREEITEM hItem,struct NSNODE *parent, IWbemClassObject *pclsObj);
	void InsertClassNode(HWND hTreeWnd,HTREEITEM hItem,struct NSNODE *parent, IWbemClassObject *pclsObj);
	void InsertInstanceNode(HWND hTreeWnd,HTREEITEM hItem,struct NSNODE *parent, IWbemClassObject *pclsObj);
	void InsertScopeInstanceNode(HWND hTreeWnd,HTREEITEM hItem,struct NSNODE *parent, IWbemClassObject *pclsObj);
	void RemovePlus(HWND hTreeWnd,HTREEITEM hItem);
	void CancelAllAsyncCalls();
	void ProcessEndEnumAsync(IWbemObjectSink *pSink);
	void SetControlHandles(HWND hwndStatic, HWND hwndButton);
	void ShowControls(bool bShow = true);
private:
	long m_sessionID;
	LOGIN_CREDENTIALS m_user;
	HWND m_hWndStatic;
	HWND m_hWndButton;

	typedef std::list<struct ITEMEXTRA*> ASYNCLIST;
	ASYNCLIST asyncList;
	IUnsecuredApartment* m_pUnsecApp;

	HRESULT UpdateOldBuild(void);

	bool m_NSSecurity;
	CWbemClassObject m_OS, m_cpu, m_winMgmt;
	struct NSNODE m_NSCache;
	
	HIMAGELIST m_hImageList;
	UINT m_folderIcon, m_earthIcon, m_classIcon, m_instanceIcon,m_scopeInstanceIcon,m_scopeClassIcon;

	UINT FolderIcon(void) const { return m_folderIcon;};
	UINT EarthIcon(void) const { return m_earthIcon;};
	UINT ClassIcon(void) const { return m_classIcon;};
	UINT InstanceIcon(void) const { return m_instanceIcon;};
	UINT ScopeInstanceIcon(void) const { return m_scopeInstanceIcon;};
	UINT ScopeClassIcon(void) const { return m_scopeClassIcon;};


	LPTSTR CopyString( LPTSTR pszSrc );
	bool MFLNamepace(LPTSTR name);


	// load the NSCache from WMI.
	HRESULT PopulateCacheNode(HWND hTreeWnd,HTREEITEM hItem,struct ITEMEXTRA *extra);

	HRESULT PopulateTreeNode(HWND hTree, HTREEITEM hParentItem, 
								struct NSNODE *parent,
								int flags);
	void DeleteNode(NSNODE *node);
	HRESULT GetAsyncSinkStub(IWbemObjectSink *pSink, IWbemObjectSink **pStubSink);


//	void EnumerateClasses(LPWSTR strClass,struct NSNODE *parent);
//	CALLPROC InsertNode;

};


#endif __DATASOURCE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\logpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __LOGGINGPAGE__
#define __LOGGINGPAGE__

#include "UIHelpers.h"
#include "DataSrc.h"

class CLogPage : public CUIHelpers
{
private:

public:
    CLogPage(DataSource *ds, bool htmlSupport) :
		CUIHelpers(ds, &(ds->m_rootThread), htmlSupport){}
    virtual ~CLogPage(void);

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void InitDlg(HWND hDlg);
	void Refresh(HWND hDlg);
    void OnApply(HWND hDlg, bool bClose);
	BOOL OnValidate(HWND hDlg);
	bool GoodPathSyntax(LPCTSTR path);

	DataSource::LOGSTATUS m_oldStatus;  //original logging status.
};

#endif __LOGGINGPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\nspage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __NAMESPACEPAGE__
#define __NAMESPACEPAGE__

#include "UIHelpers.h"
#include "CHString1.h"
#include <commctrl.h>

class DataSource;
class CNamespacePage : public CUIHelpers
{
private:

public:
    CNamespacePage(DataSource *ds, bool htmlSupport);
    virtual ~CNamespacePage(void);

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void InitDlg(HWND hDlg);
    void OnApply(HWND hDlg, bool bClose);
	void Refresh(HWND hDlg);
	void OnProperties(HWND hDlg);
	HPROPSHEETPAGE CreateSecurityPage(struct NSNODE *node);
	
	int m_NSflag;
	HINSTANCE m_HWNDAlcui;
	bool m_connected;
	HTREEITEM m_hSelectedItem;
};


#endif __NAMESPACEPAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\nspicker.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "NSPicker.h"

// Help IDs
/*DWORD aAdvancedHelpIds[] = {
    IDC_ADV_PERF_ICON,             (IDH_ADVANCED + 0),
    0, 0
};
*/

//------------------------------------------------------
CNSPicker::CNSPicker(CWbemServices &root) :
						m_WbemService(root)
{
}

//------------------------------------------------------
CNSPicker::~CNSPicker(void)
{
}

//----------------------------------------------
LRESULT CNSPicker::OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
//	PopulateTree(m_hWnd, IDC_NSTREE, m_WbemService);
	return TRUE;
}

//----------------------------------------------
LRESULT CNSPicker::OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
/*	::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
				_T("sysdm.hlp"),
				HELP_WM_HELP,
				(DWORD)(LPSTR)aAdvancedHelpIds);
*/
	return TRUE;
}

//----------------------------------------------
LRESULT CNSPicker::OnCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	switch(wID)
	{
	case IDOK:
		{
			// save the currently selected fullpath name.
			HWND hTree = ::GetDlgItem(m_hWnd, IDC_NSTREE);
			TV_ITEM item;
			item.mask = TVIF_PARAM;
			item.hItem = m_hSelectedItem;
			BOOL x = TreeView_GetItem(hTree, &item);

			_tcsncpy(m_path, ((ITEMEXTRA *)item.lParam)->fullPath, MAX_PATH);
		}
		EndDialog(IDOK);
		break;

	case IDCANCEL:
		EndDialog(IDCANCEL);
		break;
	}

    return TRUE;
}

//----------------------------------------------
LRESULT CNSPicker::OnSelChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    switch(pnmh->code)
    {
	case TVN_SELCHANGED:
		if(pnmh->idFrom == IDC_NSTREE)
		{
			LPNMTREEVIEW pnmtv = (LPNMTREEVIEW)pnmh;
			m_hSelectedItem = pnmtv->itemNew.hItem;
		}
		break;
    }
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\mofsec.inc ===
#if 0
Copyright (c) 1997-1999 Microsoft Corporation
#endif

#define SECMOF "instance of __NTLMUser{\n\
GroupType = 0;Name = \"Administrators\";\n\
Authority = \".\";Enabled = TRUE;Permissions = 2;ExecuteMethods = TRUE;EditSecurity = TRUE;};\n\
instance of __NTLMUser{\n\
GroupType = 0;Name = \"Everybody\";\n\
Authority = \".\";Enabled = TRUE;Permissions = 0;ExecuteMethods = FALSE;EditSecurity = FALSE;};"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\precomp.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__7F2AAB5C_A5AD_11D2_886A_00104B2AFB46__INCLUDED_)
#define AFX_STDAFX_H__7F2AAB5C_A5AD_11D2_886A_00104B2AFB46__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#undef STRICT
#define STRICT


#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
};
extern CExeModule _Module;

#include <commdlg.h>
#include <commctrl.h>
#include <atlcom.h>

#define IS_BITSET(x, y) 	((x & y) == y)

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7F2AAB5C_A5AD_11D2_886A_00104B2AFB46__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\nspage.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright (c) 1997-1999 Microsoft Corporation
/**********************************************************************/


#include "precomp.h"
#include "NSPage.h"
#include "resource.h"
#include "CHString1.h"
#include "wbemerror.h"
#include "RootSecPage.h"
#include "ErrorSecPage.h"
#include "DataSrc.h"
#include "WMIHelp.h"
#include <cominit.h>
#include <stdio.h>

const static DWORD nsPageHelpIDs[] = {  // Context Help IDs
	IDC_NS_PARA,	-1,
	IDC_NSTREE,		IDH_WMI_CTRL_SECURITY_NAMESPACE_BOX,
	IDC_PROPERTIES, IDH_WMI_CTRL_SECURITY_SECURITY_BUTTON,
    0, 0
};

//-------------------------------------------------------------------------
CNamespacePage::CNamespacePage(DataSource *ds, bool htmlSupport) :
						CUIHelpers(ds, &(ds->m_rootThread), htmlSupport),
						m_HWNDAlcui(0)

{
	m_connected = false;
	m_hSelectedItem = 0;
}

//-------------------------------------------------------------------------
CNamespacePage::~CNamespacePage(void)
{
	if(m_HWNDAlcui)
	{
		FreeLibrary(m_HWNDAlcui);
		m_HWNDAlcui = NULL;
	}
}

//---------------------------------------------------------------------------
void CNamespacePage::InitDlg(HWND hDlg)
{
	m_hDlg = hDlg;
	m_DS->SetControlHandles(GetDlgItem(hDlg,IDC_ENUM_STATIC),GetDlgItem(hDlg,IDC_CANCEL_ENUM));
	Refresh(m_hDlg);
}

//---------------------------------------------------------------------------
typedef HPROPSHEETPAGE (WINAPI *CREATEPAGE_PROC) (LPSECURITYINFO);

HPROPSHEETPAGE CNamespacePage::CreateSecurityPage(struct NSNODE *node)
/*												  CWbemServices &ns,
												  _bstr_t path,
												  _bstr_t display)
*/
{
    HPROPSHEETPAGE hPage = NULL;

	// NOTE: (si == NULL) means the target is pre-M3 (RootSecStyle).
	ISecurityInformation *si = m_DS->GetSI(node);

	// NS_MethodStyle on NT....this is full ACL security.
	if(si != NULL)
	{
		// try to load aclui.
		if(m_HWNDAlcui == NULL)
		{
			m_HWNDAlcui = LoadLibrary(_T("aclui.dll"));
		}

		// client has a aclui
		if(m_HWNDAlcui != NULL)
		{
			// create aclui with full si.
			CREATEPAGE_PROC createPage = (CREATEPAGE_PROC)GetProcAddress(m_HWNDAlcui, "CreateSecurityPage");
			if(createPage)
			{
				si->AddRef();
				hPage = createPage(si);
			}
			else 
			{
				// couldnt get the exported routines.
				CErrorSecurityPage *pPage = new CErrorSecurityPage(IDS_NO_CREATE_SEC);
				hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_SEC_ERROR));
			}
		}
		else  // no editor dude. Upgrade the client to atleast nt4sp4.
		{
			// cant run aclui from here.
			CErrorSecurityPage *pPage = NULL;
			if(IsNT())
			{
				pPage = new CErrorSecurityPage(IDS_NO_ACLUI);
			}
			else
			{
				pPage = new CErrorSecurityPage(IDS_NO_98TONT_SEC);
			}
			if(pPage)
			{
				hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_SEC_ERROR));
			}
		}
	}
/*	else // not new NT
	{ 
		// RootSecStyle on 9x or NT (basically pre-M3 on anything)
		if(m_DS->IsAncient())
		{
			// must use internal editor for schema security.
			CRootSecurityPage *pPage = new CRootSecurityPage(	ns,
																CPrincipal::RootSecStyle, path,
																m_htmlSupport,
																m_DS->m_OSType);

			hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_9XSEC));
		}
		else // NS_MethodStyle on 9x...
		{
			// must use internal editor for schema security.
			CRootSecurityPage *pPage = new CRootSecurityPage(ns, CPrincipal::NS_MethodStyle, path,
																m_htmlSupport,
																m_DS->m_OSType);

			hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_9XSEC));
		}
	}
*/
	return hPage;
}

//--------------------------------------------------------------------
void CNamespacePage::OnProperties(HWND hDlg)
{
    HPROPSHEETPAGE hPage;
    UINT cPages = 0;
    BOOL bResult = FALSE;

	// get the selected item.
	HWND treeHWND = GetDlgItem(hDlg, IDC_NSTREE);
	TV_ITEM item;
	item.mask = TVIF_PARAM;
	if(!m_hSelectedItem)
	{
		m_hSelectedItem = TreeView_GetRoot(treeHWND);
		TreeView_SelectItem(treeHWND,m_hSelectedItem);
	}
	item.hItem = m_hSelectedItem;
	BOOL x = TreeView_GetItem(treeHWND, &item);
	
	struct NSNODE *node = ((ITEMEXTRA *)item.lParam)->nsNode;
	//TreeView_SelectItem(TreeView_GetRoot(treeHWND))
/*	_bstr_t relName(node->fullPath);

	// WARNING: [5] ignores the 'root\' part cuz this call is relative to
	// the 'root' namespace anyway. If the root name changes length, this
	// assumption will break.
	CWbemServices ns;

	_bstr_t tempName = m_DS->m_whackedMachineName;
	if(tempName.length() > 0)
	{
		tempName += L"\\";
	}
	tempName += relName;

	if(m_DS->IsAncient())
	{
		ns = m_DS->RootSecNS();
		tempName += L"\\security";


		// VERY WIERD HACK: if I dont 'exercise' it here, it will hang later on
		// when connected to a wmi 698 build.
		IEnumWbemClassObject *users = NULL;
		HRESULT hr = ns.CreateInstanceEnum(L"__NTLMUser", 0, &users);
		users->Release();
		users = 0;
	}
	else
	{
		ns.ConnectServer(tempName, m_DS->GetCredentials());
	}

*/	// - - - - - - - - - - - - - - - - 
	// build the sheet.
//	if((bool)ns)
//	{
		hPage = CreateSecurityPage(node);
		if(hPage)
		{
			// Build dialog title string
			TCHAR szTitle[MAX_PATH] = {0};
			LoadString(_Module.GetModuleInstance(), IDS_NS_PROP_TITLE, 
							szTitle, ARRAYSIZE(szTitle));

			struct NSNODE *node = ((ITEMEXTRA *)item.lParam)->nsNode;
			if(node)
			{
				lstrcat(szTitle, node->fullPath);
			}

			PROPSHEETHEADER psh = {0};
			psh.dwSize = sizeof(psh);
			psh.dwFlags = PSH_DEFAULT;
			psh.hwndParent = hDlg;
			psh.hInstance = _Module.GetModuleInstance();
			psh.pszCaption = szTitle;
			psh.nPages = 1;
			psh.nStartPage = 0;
			psh.phpage = &hPage;

			bResult = (BOOL)(PropertySheet(&psh) + 1);
		}
//	}
}

//---------------------------------------------------------------------------
void CNamespacePage::Refresh(HWND hDlg)
{
	if(m_DS && m_DS->IsNewConnection(&m_sessionID))
	{
		// 9x machines cant manage security on NT machines.
		bool is9xToNT = (IsNT() == false) && (m_DS->m_OSType == OSTYPE_WINNT);

		EnableWindow(GetDlgItem(hDlg, IDC_NSTREE), !is9xToNT);
		EnableWindow(GetDlgItem(hDlg, IDC_PROPERTIES), !is9xToNT);

		CHString1 para;
		
		if(is9xToNT)
		{
			para.LoadString(IDS_NO_98TONT_SEC);
			SetWindowText(GetDlgItem(hDlg, IDC_NS_PARA), para);
			return;  // early.
		}
		else
		{
			para.LoadString(IDS_NS_PARA);
			SetWindowText(GetDlgItem(hDlg, IDC_NS_PARA), para);
		}


		CHString1 initMsg;
		if(m_DS->m_rootThread.m_status == WbemServiceThread::ready)
		{
			HWND hTree = GetDlgItem(hDlg, IDC_NSTREE);
			TreeView_DeleteAllItems(hTree);
			m_DS->DeleteAllNodes();
		//	bool hideMfls = false;  //TODO

			m_NSflag = SHOW_ALL;

			// old targets only use the the root node for security.
			if(m_DS->IsAncient())
			{
				m_NSflag = ROOT_ONLY;
				// TODO: hide the 'hide mfls' checkbox. Moot point on old targets.
			}
		//	else if(hideMfls)
		//	{
		//		m_NSflag = DataSource::HIDE_SOME;
		//	}

			m_DS->LoadImageList(hTree);
			m_DS->LoadNode(hTree, TVI_ROOT, m_NSflag);
		}
		else
		{
		} //endif ServiceIsReady() 
	}
}

//------------------------------------------------------------------------
void CNamespacePage::OnApply(HWND hDlg, bool bClose)
{
	::SendMessage(GetParent(hDlg), PSM_UNCHANGED, (WPARAM)hDlg, 0L);
}

//------------------------------------------------------------------------
BOOL CNamespacePage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	HWND hTree = GetDlgItem(hDlg,IDC_NSTREE);
	struct NSNODE *node;
	LPNMTREEVIEW  pnm = (LPNMTREEVIEW)lParam;
	TCHAR strTemp[1024];

    switch(uMsg)
    {
    case WM_INITDIALOG:
//		OutputDebugString(_T("Inside InitDialog!!!!\n"));
        InitDlg(hDlg);
        break;

	case WM_ASYNC_CIMOM_CONNECTED:
		if(!m_connected)
		{
			m_connected = true;
			Refresh(hDlg);
		}
		break;

    case WM_NOTIFY:
        {
			if(pnm->hdr.code == NM_CUSTOMDRAW)
			{
				LPNMTREEVIEW  pnm = (LPNMTREEVIEW)lParam;
				LPNMLVCUSTOMDRAW lplvcd = (LPNMLVCUSTOMDRAW)lParam;

				switch(lplvcd->nmcd.dwDrawStage)
				{
					case CDDS_PREPAINT :
					
						SetWindowLong(hDlg,DWLP_MSGRESULT,CDRF_NOTIFYITEMDRAW);
						return CDRF_NOTIFYITEMDRAW;
						break;	
					case CDDS_ITEMPREPAINT:
					{
						if(lplvcd->nmcd.uItemState != CDIS_SELECTED)
						{
							ITEMEXTRA *pExtra = (ITEMEXTRA *)lplvcd->nmcd.lItemlParam;
							node = pExtra->nsNode;
							if(node->sType == TYPE_DYNAMIC_CLASS)
							{
								lplvcd->clrText = RGB(128,128,128);
								SetWindowLong(hDlg,DWLP_MSGRESULT,CDRF_NEWFONT);
								return CDRF_NEWFONT;
							}
						}
						break;
					}
					case CDDS_SUBITEM | CDDS_ITEMPREPAINT :
					{
						if(lplvcd->nmcd.uItemState != CDIS_SELECTED)
						{
							node = (struct NSNODE *)lplvcd->nmcd.lItemlParam;
							if(node->sType == TYPE_DYNAMIC_CLASS)
							{
								lplvcd->clrText = RGB(128,128,128);
								SetWindowLong(hDlg,DWLP_MSGRESULT,CDRF_NEWFONT);
								return CDRF_NEWFONT;
							}
						}
						break;
					}
					default:
//						_stprintf(strTemp,_T("*********************** Default : %x *****************\n"),lplvcd->nmcd.dwDrawStage);
//						OutputDebugString(strTemp);
						break;
				}	

			}
			else
			{
				switch(((LPNMHDR)lParam)->code)
				{
					// TODO: this one's more complex.
					case PSN_SETACTIVE:
						Refresh(hDlg);
						break;

					case PSN_HELP:
						HTMLHelper(hDlg);
						break;

					case PSN_APPLY:
						OnApply(hDlg, (((LPPSHNOTIFY)lParam)->lParam == 1));
						break;

					case TVN_SELCHANGED:
						if(((LPNMHDR)lParam)->idFrom == IDC_NSTREE)
						{
							ITEMEXTRA *extra;
							// remember the selection change for OnProperties()
							LPNMTREEVIEW pnmtv = (LPNMTREEVIEW)lParam;
							m_hSelectedItem = pnmtv->itemNew.hItem;
							extra = (ITEMEXTRA *)pnmtv->itemNew.lParam;
							if((extra->nsNode->sType == TYPE_STATIC_CLASS) || 
							   (extra->nsNode->sType == TYPE_DYNAMIC_CLASS) || 
							   (extra->nsNode->sType == TYPE_SCOPE_CLASS))
							{
								//Disable the Security Button
								EnableWindow(GetDlgItem(hDlg,IDC_PROPERTIES),FALSE);
							}
							else
							{
								//In all other cases,enable the Security Button
								EnableWindow(GetDlgItem(hDlg,IDC_PROPERTIES),TRUE);
							}
						}
						break;

					case TVN_ITEMEXPANDING:
						if(((LPNMHDR)lParam)->idFrom == IDC_NSTREE)
						{
							// expand the node.
							LPNMTREEVIEW pnmtv = (LPNMTREEVIEW)lParam;
							if(pnmtv->action == TVE_EXPAND)
							{
								HWND hTree = GetDlgItem(hDlg, IDC_NSTREE);
								m_DS->LoadNode(hTree, pnmtv->itemNew.hItem, m_NSflag);
							}
						}
						break;
				}

			}
        }
        break;

    case WM_COMMAND:
		switch(LOWORD(wParam))
		{
		case IDC_PROPERTIES:
			if(HIWORD(wParam) == BN_CLICKED)
			{
				OnProperties(hDlg);
				SetFocus(GetDlgItem(hDlg, IDC_NSTREE));
			}
			break;
		case IDC_CANCEL_ENUM:
			{
				m_DS->CancelAllAsyncCalls();
				break;
			}
		default: break;
		};

        break;

    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_HelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)nsPageHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp(hDlg, c_HelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)nsPageHelpIDs);
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\nspicker.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef _NSPICKER_H_
#define _NSPICKER_H_
#pragma once

#include "resource.h"
#include "sshWbemHelpers.h"

//-----------------------------------------------------------------------------
class CNSPicker : public CUIHelpers
{
private:
	// Handler prototypes:
	LRESULT OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnSelChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
	LRESULT OnCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	CWbemServices m_WbemService;
	HTREEITEM m_hSelectedItem;

public:
	CNSPicker(CWbemServices &root);
	~CNSPicker(void);

	int DoModal(HWND hDlg);
	BOOL CALLBACK DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);

	TCHAR m_path[MAX_PATH];
};

BOOL CALLBACK StaticPickerDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);

#endif _NSPICKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\pagebase.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright (c) 1997-1999 Microsoft Corporation
/**********************************************************************/

/*

    PAGEBASE.CPP

    This file contains the implementation of the CBasePage base class.

*/

#include "precomp.h"
#include "pagebase.h"
#include "ServiceThread.h"
#include "resource.h"
#include <commctrl.h>
#include "DataSrc.h"
#include <commdlg.h>
#include <cominit.h>
//#include <afxres.h>
#include "WMIHelp.h"

#ifdef SNAPIN
const TCHAR c_HelpFile2[] = _T("newfeat1.hlp");
#else
const TCHAR c_HelpFile2[] = _T("WbemCntl.hlp");
#endif


//-------------------------------------------------------------------
CBasePage::CBasePage(DataSource *ds, WbemServiceThread *serviceThread) :
	m_DS(ds), m_userCancelled(false),m_hDlg(NULL), 
	m_alreadyAsked(false), m_service(NULL), g_serviceThread(serviceThread)
{
	if((g_serviceThread != 0) && 
		g_serviceThread->m_status == WbemServiceThread::ready)
	{
		m_WbemServices = g_serviceThread->m_WbemServices;
		m_WbemServices.GetServices(&m_service);
		m_WbemServices.SetBlanket(m_service);
	}
}

//-------------------------------------------------------------------
CBasePage::CBasePage(CWbemServices &service) :
	m_DS(NULL), m_userCancelled(false),m_hDlg(NULL), 
	m_alreadyAsked(false), m_service(NULL), g_serviceThread(NULL)
{
	m_WbemServices = service;
}

//-------------------------------------------------------------------
CBasePage::~CBasePage( void )
{
	if(m_service)
	{
		m_service->Release();
		m_service = 0;
	}
	m_WbemServices.DisconnectServer();
	m_alreadyAsked = false;
}

//-------------------------------------------------------------------
HPROPSHEETPAGE CBasePage::CreatePropSheetPage(LPCTSTR pszDlgTemplate, 
												LPCTSTR pszDlgTitle,
												DWORD moreFlags)
{
    PROPSHEETPAGE psp;

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_USECALLBACK | moreFlags;
    psp.hInstance   = _Module.GetModuleInstance();
    psp.pszTemplate = pszDlgTemplate;
    psp.pszTitle    = pszDlgTitle;
    psp.pfnDlgProc  = CBasePage::_DlgProc;
    psp.lParam      = (LPARAM)this;
    psp.pfnCallback = CBasePage::_PSPageCallback;

    if (pszDlgTitle != NULL)
        psp.dwFlags |= PSP_USETITLE;

    return CreatePropertySheetPage(&psp);
}

//-------------------------------------------------------------------
UINT CBasePage::PSPageCallback(HWND hwnd,
                              UINT uMsg,
                              LPPROPSHEETPAGE ppsp)
{
    return S_OK;
}

//-------------------------------------------------------------------
INT_PTR CALLBACK CBasePage::_DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CBasePage *pThis = (CBasePage *)GetWindowLongPtr(hDlg, DWLP_USER);

    // The following messages arrive before WM_INITDIALOG
    // which means pThis is NULL for them.  We don't need these
    // messages so let DefDlgProc handle them.
    //
    // WM_SETFONT
    // WM_NOTIFYFORMAT
    // WM_NOTIFY (LVN_HEADERCREATED)

    if (uMsg == WM_INITDIALOG)
    {
        pThis = (CBasePage *)(((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pThis);
    }

    if (pThis != NULL)
        return pThis->DlgProc(hDlg, uMsg, wParam, lParam);

    return FALSE;
}

//-------------------------------------------------------------------
UINT CALLBACK CBasePage::_PSPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    CBasePage *pThis = (CBasePage *)ppsp->lParam;

    if (pThis)
    {
        UINT nResult = pThis->PSPageCallback(hWnd, uMsg, ppsp);

        switch (uMsg)
        {
        case PSPCB_CREATE:
//            if (!nResult)
  //              pThis->m_bAbortPage = TRUE;
            break;

        case PSPCB_RELEASE:
//            delete pThis;
            break;
        }
    }

    //
    // Always return non-zero or else our tab will disappear and whichever
    // property page becomes active won't repaint properly.  Instead, use
    // the m_bAbortPage flag during WM_INITDIALOG to disable the page if
    // the callback failed.
    //
    return 1;
}

//---------------------------------------------------------
typedef struct {
	LOGIN_CREDENTIALS *credentials;
} LOGIN_CFG;

//------------------------------------------------------------------------
size_t CredentialUserLen3(LOGIN_CREDENTIALS *credentials)
{
	return credentials->authIdent->UserLength;
}

//------------------------------------------------------------------------
void CredentialUser3(LOGIN_CREDENTIALS *credentials, LPTSTR *user)
{
	bstr_t trustee = _T("");
	if ((TCHAR *)trustee == NULL)
		return;

	if(credentials->authIdent->DomainLength > 0)
	{
		trustee += credentials->authIdent->Domain;
		trustee += _T("\\");
		trustee += credentials->authIdent->User;
	}
	else
	{
		trustee = credentials->authIdent->User;
		if ((TCHAR *)trustee == NULL)
			return;
	}

#ifdef UNICODE
	if(credentials->authIdent->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI)
	{
		size_t size = mbstowcs(NULL, trustee, 0);
		*user = new wchar_t[size+1];
		if(*user != NULL)
			mbstowcs(*user, trustee, size+1);
	}
	else   // already UNICODE
	{
		size_t size = wcslen(trustee);
		*user = new wchar_t[size+1];
		if(*user != NULL)
			wcscpy(*user, trustee);
	}
#else
	if(credentials->authIdent->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI)
	{
		size_t size = strlen(trustee);
		*user = new char[size+1];
		if(*user != NULL)
			strcpy(*user, (char *)trustee);
	}
	else   // convert the UNICODE
	{
		size_t size = wcstombs(NULL, trustee, 0);
		*user = new char[size+1];
		if(*user != NULL)
			wcstombs(*user, trustee, size+1);
	}
#endif
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void SetCurrentUser2(HWND hDlg, bool currUser)
{
	Button_SetCheck(GetDlgItem(hDlg, IDC_CHECKCURRENTUSER), 
						(currUser? BST_CHECKED:BST_UNCHECKED));

	BOOL enable = (currUser? FALSE: TRUE);

	::EnableWindow(GetDlgItem(hDlg, IDC_EDITUSERNAME), enable);
	::EnableWindow(GetDlgItem(hDlg, IDC_EDITPASSWORD), enable);
	::EnableWindow(GetDlgItem(hDlg, IDC_USER_LABEL), enable);
	::EnableWindow(GetDlgItem(hDlg, IDC_PW_LABEL), enable);

}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const static DWORD logonHelpIDs[] = {  // Context Help IDs
	IDC_CHECKCURRENTUSER, IDH_WMI_CTRL_GENERAL_WMILOGIN_CHECKBOX,
	IDC_USER_LABEL, IDH_WMI_CTRL_GENERAL_WMILOGIN_USERNAME,
	IDC_EDITUSERNAME, IDH_WMI_CTRL_GENERAL_WMILOGIN_USERNAME,
	IDC_PW_LABEL, IDH_WMI_CTRL_GENERAL_WMILOGIN_PASSWORD,
	IDC_EDITPASSWORD, IDH_WMI_CTRL_GENERAL_WMILOGIN_PASSWORD,
    0, 0
};

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
INT_PTR CALLBACK LoginDlgProc2(HWND hwndDlg,
							 UINT uMsg,
							 WPARAM wParam,
							 LPARAM lParam)
{
	BOOL retval = FALSE;
	switch(uMsg)
	{
	case WM_INITDIALOG:
		{ //BEGIN
			SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
			LOGIN_CFG *data = (LOGIN_CFG *)GetWindowLongPtr(hwndDlg, DWLP_USER);

			SetCurrentUser2(hwndDlg, data->credentials->currUser);

		} //END
		retval = TRUE;
		break;

	case WM_COMMAND:
		{
			LOGIN_CFG *data = (LOGIN_CFG *)GetWindowLongPtr(hwndDlg, DWLP_USER);

			switch(LOWORD(wParam))
			{
			case IDC_CHECKCURRENTUSER:
				{
					if(HIWORD(wParam) == BN_CLICKED)
					{
						bool currUser = (IsDlgButtonChecked(hwndDlg, IDC_CHECKCURRENTUSER) == BST_CHECKED ?true:false);
						// toggle and respond.
						SetCurrentUser2(hwndDlg, currUser);
					}
				}
				break;

			case IDOK:
				{
					if(HIWORD(wParam) == BN_CLICKED)
					{
						data->credentials->currUser = (IsDlgButtonChecked(hwndDlg, IDC_CHECKCURRENTUSER) == BST_CHECKED ?true:false);

						if(data->credentials->currUser == false)
						{
							TCHAR user[100] = {0}, pw[100] = {0};
							GetWindowText(GetDlgItem(hwndDlg, IDC_EDITUSERNAME), user, 100);
							GetWindowText(GetDlgItem(hwndDlg, IDC_EDITPASSWORD), pw, 100);
							
							BSTR bDomUser, bUser = NULL, bDomain = NULL, bAuth = NULL;
//#ifdef SNAPIN
							wchar_t *temp = pw;
							bDomUser = SysAllocString(user);
/*#else
							wchar_t temp[100] = {0};
							mbstowcs(temp, user, 100);
							bDomUser = SysAllocString(temp);
							mbstowcs(temp, pw, 100);
#endif*/
							if (bDomUser != NULL &&
                                SUCCEEDED(DetermineLoginType(bDomain,
                                                             bUser,
                                                             bAuth,
                                                             bDomUser)))
							{
								if(data->credentials->authIdent != 0)
								{
									if(data->credentials->fullAcct)
									{
										data->credentials->fullAcct[0] = 0;
									}
									WbemFreeAuthIdentity(data->credentials->authIdent);
									data->credentials->authIdent = 0;
								}

								if (SUCCEEDED(WbemAllocAuthIdentity(bUser,
                                                                    temp,
                                                                    bDomain, 
                                            &(data->credentials->authIdent))))
                                {
                                    _tcscpy(data->credentials->fullAcct,
                                            user);
                                }
							}
						}

						EndDialog(hwndDlg, IDOK);
					}
				}
				break;

			case IDCANCEL:
				{
					if(HIWORD(wParam) == BN_CLICKED)
					{
						EndDialog(hwndDlg, IDCANCEL);
					}
				}
				break;

			default:
				return(FALSE);
			} // switch
			break;
		} // - - - - - - - - endswitch LOWORD()
		break;

    case WM_HELP:
        if(IsWindowEnabled(hwndDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_HelpFile2,
                    HELP_WM_HELP,
                    (ULONG_PTR)logonHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if(IsWindowEnabled(hwndDlg))
        {
            WinHelp(hwndDlg, c_HelpFile2,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)logonHelpIDs);
        }
        break;

	default: break;
	} //endswitch uMsg

	return retval;
}

//---------------------------------------------------------
INT_PTR CBasePage::DisplayLoginDlg(HWND hWnd, 
								LOGIN_CREDENTIALS *credentials)
{
	LOGIN_CFG cfg;

	cfg.credentials = credentials;

	return DialogBoxParam(_Module.GetModuleInstance(), 
							MAKEINTRESOURCE(IDD_LOGIN), 
							hWnd, LoginDlgProc2, 
							(LPARAM)&cfg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\mofstr.inc ===
#if 0
Copyright (c) 1997-1999 Microsoft Corporation
#endif

#define CLASSMOF "instance of __Win32provider as $P{\n\
Name = \"RegPropProv\";\n\
Clsid = \"{72967901-68EC-11d0-B729-00AA0062CBB7}\";\n\
ImpersonationLevel = 1;\n\
PerUserInitialization = TRUE;};\n\
instance of __PropertyProviderRegistration {\n\
Provider = $P;\n\
SupportsGet = TRUE;\n\
SupportsPut = TRUE;};\n\
[DYNPROPS, singleton] class Win32_WMISetting{\n\
[read] string InstallationDirectory;\n\
[read] string BuildVersion;\n\
[read, write] uint32 AutoStartWin9X;\n\
[read, write] boolean EnableAnonWin9xConnections;\n\
[read, write] string MaxLogFileSize;\n\
[read, write] string LoggingLevel;\n\
[read, write] string LoggingDirectory;\n\
[read] string DatabaseDirectory;\n\
[read, write] string BackupInterval;\n\
[read, write] boolean ASPScriptEnabled;\n\
[read, write] string ASPScriptDefaultNamespace = \"\\\\\\\\root\\\\cimv2\";};"

#define INSTMOF "[DYNPROPS]instance of Win32_WMISetting{\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem|Installation Directory\")] \n\
InstallationDirectory;\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem|Build\")] \n\
BuildVersion;\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem\\\\cimom|Log File Max Size\")]\n\
MaxLogFileSize;\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem\\\\cimom|Logging\")]\n\
LoggingLevel;\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem\\\\cimom|Logging Directory\")]\n\
LoggingDirectory;\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem\\\\cimom|Repository Directory\")]\n\
DatabaseDirectory;\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem\\\\cimom|Backup Interval Threshold\")]\n\
BackupInterval;\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem\\\\Scripting|Enable for ASP\")]\n\
ASPScriptEnabled;\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem\\\\Scripting|Default Namespace\")]\n\
ASPScriptDefaultNamespace;\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem\\\\cimom|AutostartWin9X\")]\n\
AutoStartWin9X;\n\
[DYNAMIC, Provider(\"RegPropProv\"),\n\
PropertyContext(\"local|hkey_local_Machine\\\\software\\\\microsoft\\\\wbem\\\\cimom|EnableAnonConnections\")]\n\
EnableAnonWin9xConnections;};"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\principal.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "chklist.h"
#include "Principal.h"
#include "CHString1.h"

//-------------------------------------------------------------
CPrincipal::CPrincipal(CWbemClassObject &userInst, SecurityStyle secStyle) :
						m_secStyle(secStyle), 
						m_perms(0),
						m_inheritedPerms(0),
						m_editable(true)
{
	//------------------------------------------------
	// figure out what security strategy we're dealing with and load it
	// into my "generic" definition.

	memset(m_name, 0, 100 * sizeof(TCHAR));
	_tcsncpy(m_name, (LPCTSTR)userInst.GetString("Name"), 100);

	memset(m_domain, 0, 100 * sizeof(TCHAR));
	_tcsncpy(m_domain, (LPCTSTR)userInst.GetString("Authority"), 100);

	// if pre-M3 security...
	if(m_secStyle == RootSecStyle)
	{
		// this is the only instance for this guy so save it.

		// convert the convoluted "bits" into my real "generic" bits.
		m_perms |= (userInst.GetBool("EditSecurity") ? ACL_WRITE_DAC : 0);
		m_perms |= (userInst.GetBool("Enabled") ? ACL_ENABLE : 0);
		m_perms |= (userInst.GetBool("ExecuteMethods") ? ACL_METHOD_EXECUTE : 0);

		// NOTE: each "level" implies all the levels below so I INTENTIONALLY 
		// left out the 'breaks' so the bits would fall through and accumulate.
		switch(userInst.GetLong("Permissions"))
		{
		case 2:		// class write
			m_perms |= ACL_CLASS_WRITE;

		case 1:		// instance write
			m_perms |= ACL_INSTANCE_WRITE;
		}

		// remember for dirty bit processing later.
		m_origPerms = m_perms;
	}
	else  //new M3+ security
	{
		// ACL bits perfectly match m_perms.
		// NOTE: this securityStyle can have multiple aces per principal.
		AddAce(userInst);
	}
}

//------------------------------------------
// move m_perms into the checkboxes
void CPrincipal::LoadChecklist(HWND list, int OSType)
{
	INT_PTR itemCount = CBL_GetItemCount(list);
	CPermission *permItem = 0;
	UINT state;

	::EnableWindow(list, m_editable);

	// for each permission item...
	for(INT_PTR x = 0; x < itemCount; x++)
	{
		// which permission item is this
		permItem = (CPermission *)CBL_GetItemData(list, x);

		state = BST_UNCHECKED; // and enabled (local)

		// if its a local perm...
		if(IS_BITSET(m_perms, permItem->m_permBit))
		{
			// local perms override inherited perms.
			state = BST_CHECKED;
		}
		else if(IS_BITSET(m_inheritedPerms, permItem->m_permBit))
		{
			// you got it from your parent.
			state = CLST_CHECKDISABLED;
		}
		// set it.
		CBL_SetState(list, x, ALLOW_COL, state);
	} //endfor
}

//------------------------------------------
// move the checkboxes into m_perms.
void CPrincipal::SaveChecklist(HWND list, int OSType)
{
	INT_PTR itemCount = CBL_GetItemCount(list);
	CPermission *permItem = 0;
	LPARAM state = 0, state1 = 0;

	// clear this principal's perm bits.
	m_perms = 0;

	// for each perm...
	for(INT_PTR x = 0; x < itemCount; x++)
	{
		// get permission item.
		permItem = (CPermission *)CBL_GetItemData(list, x);

		// what's the check state?
		state = CBL_GetState(list, x, ALLOW_COL);

		// if its enabled (local) & checked, set the matching bit.
		// NOTE: This "explicit compare will eliminate CLST_DISABLEDed states which
		// shouldn't be saved off.
		if((state == BST_CHECKED) ||
		  ((state == CLST_CHECKDISABLED) && (OSType != OSTYPE_WINNT)))
		{
			m_perms |= permItem->m_permBit;
		}
	} //endfor
}

//------------------------------------------
// WARNING: this logic assumes it will only be called when the principal is
// being read in. If you want to add aces interactively, its a whole different
// game.
void CPrincipal::AddAce(CWbemClassObject &princ)
{
	DWORD flags = princ.GetLong("Flags");

	// if inherited...
	if(IS_BITSET(flags, INHERITED_ACE))
	{
		// simply accumulate bits.
		m_inheritedPerms |= princ.GetLong("Mask");
		m_editable = false;
	}
	else if(flags == CONTAINER_INHERIT_ACE)
	{
		m_perms |= princ.GetLong("Mask");

		// this is the first local ace, we can edit it so save the source instance.
		// NOTE: Any additional "local" aces that exactly match CONTAINER_INHERIT_ACE
		// will be merged in but the the ClassObject will be tossed.
		//if(!(bool)m_userInst)
		//{
	//		m_userInst = princ;
	//	}

		// remember for dirty bit processing later.
		m_origPerms = m_perms;
	}
	else
	{
		// this will disable the checklist control for this principal.
		m_editable = false;
	}
}

//------------------------------------------
HRESULT CPrincipal::DeleteSelf(CWbemServices &service)
{
	HRESULT hr = S_OK;

	if(m_secStyle == RootSecStyle)
	{
		CHString1 path, fmt("__NTLMuser.Name=\"%s\",Authority=\"%s\"");
		path.Format(fmt, m_name, m_domain);

		hr = service.DeleteInstance((LPCTSTR)path);
	}
	return hr;
}

//------------------------------------------
// move m_perms into the checkboxes
HRESULT CPrincipal::Put(CWbemServices &service, CWbemClassObject &userInst)
{
	HRESULT hr = E_FAIL;
	
	if(m_editable)
	{
		// if pre-M3 security...
		if(m_secStyle == RootSecStyle)
		{
			DWORD perm = 0;
			// convert my "generic" bits back to convoluted "bits".
			userInst = service.CreateInstance("__NTLMUser");
			userInst.Put("Name", (bstr_t)m_name);
			userInst.Put("Authority", (bstr_t)m_domain);
			userInst.Put("EditSecurity", (bool)((m_perms & ACL_WRITE_DAC) != 0));
			userInst.Put("Enabled", (bool)((m_perms & ACL_ENABLE) != 0));
			userInst.Put("ExecuteMethods", (bool)((m_perms & ACL_METHOD_EXECUTE) != 0));

			if(m_perms & ACL_CLASS_WRITE)
			{
				perm = 2;
			}
			else if(m_perms & ACL_INSTANCE_WRITE)
			{
				perm = 1;
			}
			else
			{
				perm = 0;
			}
			userInst.Put("Permissions", (long)perm);

			hr = service.PutInstance(userInst);
		}
		else  //new M3+ security
		{
			// ACL bits perfectly match m_perms.
			userInst = service.CreateInstance("__NTLMUser9x");
			userInst.Put("Name", (bstr_t)m_name);
			userInst.Put("Authority", (bstr_t)m_domain);
			userInst.Put("Flags", (long)CONTAINER_INHERIT_ACE);
			userInst.Put("Mask", (long)m_perms);
			userInst.Put("Type", (long)ACCESS_ALLOWED_ACE_TYPE);
			hr = S_OK;
		}
	}

	return hr;
}

//-----------------------------------------------------------------------------
// Indexes into the SID image list IDB_SID_ICONS.
#define IDB_GROUP                       0
#define IDB_USER                        1
#define IDB_ALIAS                       2
#define IDB_UNKNOWN                     3
#define IDB_SYSTEM                      4
#define IDB_REMOTE                      5
#define IDB_WORLD                       6
#define IDB_CREATOR_OWNER               7
#define IDB_NETWORK                     8
#define IDB_INTERACTIVE                 9
#define IDB_DELETEDACCOUNT              10

//TODO: match the magic strings when provider catches up.

int CPrincipal::GetImageIndex(void)
{
	UINT idBitmap = 0;
	return IDB_USER;
/*
	switch (m_SidType)
	{
	case SidTypeUser:
		return IDB_USER;
		break;

	case SidTypeGroup:
		return IDB_GROUP;
		break;

	case SidTypeAlias:
		return IDB_ALIAS;
		break;

	case SidTypeWellKnownGroup:
		if(_tcsicmp(m_name, _T("Everyone")) == 0)
		{
			return IDB_WORLD;
		}
		else if(_tcsicmp(m_name, _T("Creator Owner")) == 0)
		{
			return IDB_CREATOR_OWNER;
		}
		else if(_tcsicmp(m_name, _T("NETWORK")) == 0)
		{
			return IDB_NETWORK;
		}
		else if(_tcsicmp(m_name, _T("INTERACTIVE")) == 0)
		{
			return IDB_INTERACTIVE;
		}
		else if(_tcsicmp(m_name, _T("SYSTEM")) == 0)
		{
			return IDB_SYSTEM;
		}
		else
		{
			// wasn't that well known afterall  :)
			return IDB_GROUP;
		}
		break;

	case SidTypeDeletedAccount:
		return IDB_DELETEDACCOUNT;
		break;

	case SidTypeInvalid:
	case SidTypeUnknown:
		return IDB_UNKNOWN;
		break;

	case SidTypeDomain:
	default:
		// Should never get here.
		return IDB_UNKNOWN;
		break;
	}
	return IDB_UNKNOWN;
	*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\rootsecpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// RootSecPage.cpp : implementation file
//

#include "precomp.h"
#include "RootSecPage.h"
#include "resource.h"
#include "DataSrc.h"
#include <cominit.h>
#include "WMIHelp.h"

const static DWORD rootSecPageHelpIDs[] = {  // Context Help IDs
    IDC_SPP_PRINCIPALS, IDH_WMI_CTRL_SECURITY_NAMEBOX,
    IDC_SPP_ADD,        IDH_WMI_CTRL_SECURITY_ADD_BUTTON,
    IDC_SPP_REMOVE,     IDH_WMI_CTRL_SECURITY_REMOVE_BUTTON,
    IDC_SPP_ACCESS,     IDH_WMI_CTRL_SECURITY_PERMISSIONSLIST,
    IDC_SPP_ALLOW,      IDH_WMI_CTRL_SECURITY_PERMISSIONSLIST,
    IDC_SPP_PERMS,      IDH_WMI_CTRL_SECURITY_PERMISSIONSLIST,
    0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CRootSecurityPage dialog


CRootSecurityPage::CRootSecurityPage(CWbemServices &ns, 
                                     CPrincipal::SecurityStyle secStyle,
                                     _bstr_t path, bool htmlSupport,
                                     int OSType) :
                            CUIHelpers(ns, htmlSupport), 
                            m_secStyle(secStyle), 
                            m_path(path),
                            m_OSType(OSType)
{
}

//---------------------------------------------------------------------------
#define MAX_COLUMN_CHARS    100

void CRootSecurityPage::InitDlg(HWND hDlg)
{
    m_hDlg = hDlg;
    HWND hPrinc = GetDlgItem(m_hDlg, IDC_SPP_PRINCIPALS);
    RECT rc;
    LV_COLUMN col;
    TCHAR szBuffer[MAX_COLUMN_CHARS] = {0};

    ListView_SetImageList(hPrinc,
                          LoadImageList(_Module.GetModuleInstance(), 
                          MAKEINTRESOURCE(IDB_SID_ICONS)),
                          LVSIL_SMALL);

    GetClientRect(hPrinc, &rc);

    LoadString(_Module.GetModuleInstance(), IDS_NAME, szBuffer, ARRAYSIZE(szBuffer));
    col.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.pszText = szBuffer;
    col.iSubItem = 0;
    col.cx = rc.right;
    int x = ListView_InsertColumn(hPrinc, 0, &col);

    // pre-load the appropriate permissions.
    LoadPermissionList(hDlg);
    HRESULT hr = LoadSecurity(hDlg);

    if(m_OSType != OSTYPE_WINNT)
    {
        ::ShowWindow(::GetDlgItem(hDlg, IDC_MSG), SW_SHOWNA);
    }
}

//-----------------------------------------------------------------------------
typedef struct {
    UINT ID;
    DWORD permBit;
} PERM_DEF;

PERM_DEF rootSecPerms[] = 
{
    {IDS_WBEM_GENERIC_EXECUTE,  ACL_METHOD_EXECUTE},
    {IDS_WBEM_INSTANCE_WRITE,   ACL_INSTANCE_WRITE},
    {IDS_WBEM_CLASS_WRITE,      ACL_CLASS_WRITE},
    {IDS_WBEM_ENABLE,           ACL_ENABLE},
    {IDS_WBEM_EDIT_SECURITY,    ACL_WRITE_DAC}
};

PERM_DEF NSMethodPerms[] = 
{
    {IDS_WBEM_GENERIC_EXECUTE,  ACL_METHOD_EXECUTE},
    {IDS_WBEM_FULL_WRITE,       ACL_FULL_WRITE},
    {IDS_WBEM_PARTIAL_WRITE,    ACL_PARTIAL_WRITE},
    {IDS_WBEM_PROVIDER_WRITE,   ACL_PROVIDER_WRITE},
    {IDS_WBEM_ENABLE,           ACL_ENABLE},
    {IDS_WBEM_REMOTE_ENABLE,    ACL_REMOTE_ENABLE},
    {IDS_WBEM_READ_SECURITY,    ACL_READ_CONTROL},
    {IDS_WBEM_EDIT_SECURITY,    ACL_WRITE_DAC}
};

#define FULL_WRITE_IDX 1
#define PARTIAL_WRITE_IDX 2
#define PROVIDER_WRITE_IDX 3

#define PERM_LABEL_SIZE 100

void CRootSecurityPage::LoadPermissionList(HWND hDlg)
{
    HWND hwndList = GetDlgItem(hDlg, IDC_SPP_PERMS);    // checklist window
    HRESULT hr = S_OK;
    PERM_DEF *currRights = (m_secStyle == CPrincipal::RootSecStyle ? 
                                rootSecPerms : 
                                NSMethodPerms);

    int permCount = (m_secStyle == CPrincipal::RootSecStyle ? 5:8);

    TCHAR label[PERM_LABEL_SIZE] = {0};
    CPermission *permItem = NULL;

	for(int x = 0; x < permCount; x++)
	{
		UINT len = ::LoadString(_Module.GetModuleInstance(), 
								currRights[x].ID, label, PERM_LABEL_SIZE);
		if(len != 0)
		{
			permItem = new CPermission;
			if(permItem == NULL)
				return;
			permItem->m_permBit = currRights[x].permBit;

            SendMessage(hwndList, CLM_ADDITEM, (WPARAM)label, (LPARAM)permItem);
        }
    }
}

//----------------------------------------------------------------
HRESULT CRootSecurityPage::LoadSecurity(HWND hDlg)
{
    HRESULT hr = WBEM_E_NOT_AVAILABLE;  // bad IWbemServices ptr.
    HWND hPrinc = GetDlgItem(m_hDlg, IDC_SPP_PRINCIPALS);
    IWbemClassObject *inst = NULL;  // NTLMUser instance when enumerating.

    if((bool)m_WbemServices)
    {
        int iItem;
        bool fPageModified = false;

        if(m_secStyle == CPrincipal::NS_MethodStyle)  // M3
        {
            // call the method..
            CWbemClassObject _in;
            CWbemClassObject _out;

            hr = m_WbemServices.GetMethodSignatures("__SystemSecurity", "Get9XUserList",
                                                    _in, _out);

            if(SUCCEEDED(hr))
            {
                hr = m_WbemServices.ExecMethod("__SystemSecurity", "Get9XUserList",
                                                _in, _out);

                if(SUCCEEDED(hr))
                {
                    HRESULT hr1 = HRESULT_FROM_NT(_out.GetLong("ReturnValue"));
                    if(FAILED(hr1))
                    {
                        hr = hr1;
                        // and fall out.
                    }
                    else
                    {
                        _variant_t userList;
                        HRESULT hr3 = _out.Get("ul", userList);
                        if(SUCCEEDED(hr3))
                        {
                            hr3 = AddPrincipalsFromArray(hPrinc, userList);
                            if(SUCCEEDED(hr3))
                            {
                                fPageModified = true;
                            }
                            else if(hr3 == WBEM_E_NOT_FOUND)
                            {
                                // no principals-- disable the checklist.
                                EnableWindow(GetDlgItem(hDlg, IDC_SPP_PERMS), FALSE);
                                EnableWindow(GetDlgItem(hDlg, IDC_SPP_REMOVE), FALSE);
                            }
                            else
                            {
                                hr = hr3;
                            }
                        }
                        else
                        {
                            hr = hr3;
                        }
                    }
                }
            }
        }
        else    //rootSecStyle  M1
        {
            IEnumWbemClassObject *users = NULL;
            ULONG uReturned = 0;

            // NOTE: m_WbemServices better be the root\security ns.
            hr = m_WbemServices.CreateInstanceEnum(L"__NTLMUser", 0, &users);

            if(SUCCEEDED(hr))
            {
                // walk __NTLMUser
                while((SUCCEEDED(hr = users->Next(-1, 1, &inst, &uReturned))) &&
                      (uReturned > 0))
                {
                    CWbemClassObject princ(inst);
                    fPageModified |= AddPrincipal(hPrinc, princ, CPrincipal::RootSecStyle, iItem);

                    // release our copy.
                    inst->Release();
                    inst = NULL;

                } //endwhile

                // cleanup
                users->Release();
            }

        } //endif m_secStyle

        int count = ListView_GetItemCount(hPrinc);
        // no principals-- disable the checklist.
        EnableWindow(GetDlgItem(hDlg, IDC_SPP_PERMS), (count != 0? TRUE: FALSE));
        EnableWindow(GetDlgItem(hDlg, IDC_SPP_REMOVE), (count != 0? TRUE: FALSE));

        if(fPageModified)
        {
            PropSheet_Changed(GetParent(hDlg), hDlg);
            ListView_SetItemState(hPrinc, iItem, LVIS_SELECTED, LVIS_SELECTED);
        }

    } //endif (bool)m_WbemServices

    return hr;
}

//--------------------------------------------------------------------------
HRESULT CRootSecurityPage::AddPrincipalsFromArray(HWND hPrinc, 
                                                  variant_t &vValue)
{
    IUnknown *pVoid = NULL;
    SAFEARRAY* sa;
    HRESULT hr = E_FAIL;

	// if got a BYTE array back....
	if((vValue.vt & VT_ARRAY) &&
		(vValue.vt & VT_UNKNOWN))
	{
		// get it out.
		sa = V_ARRAY(&vValue);

        long lLowerBound = 0, lUpperBound = 0 ;

        SafeArrayGetLBound(sa, 1, &lLowerBound);
        SafeArrayGetUBound(sa, 1, &lUpperBound);

        if(lUpperBound != -1)
        {
            int iItem;
            long ix[1];
            for(long x = lLowerBound; x <= lUpperBound; x++)
            {
                ix[0] = x;
                hr = SafeArrayGetElement(sa, ix, &pVoid);
                if(SUCCEEDED(hr))
                {
                    CWbemClassObject princ((IWbemClassObject *)pVoid);

                    //load principals.
                    iItem = x;
                    AddPrincipal(hPrinc, princ, CPrincipal::NS_MethodStyle, iItem);
                }
                else
                {
                    ATLASSERT(false);
                }
            }
            hr = S_OK;
        }
        else
        {
            hr = WBEM_E_NOT_FOUND;
        }
    }
    return hr;
}

//----------------------------------------------------------------
bool CRootSecurityPage::AddPrincipal(HWND hPrinc, 
                                    CWbemClassObject &princ,
                                    CPrincipal::SecurityStyle secStyle,
                                    int &iItem)
{
    bool fPageModified = false;
    CPrincipal *pPrincipal = NULL;
    int idx = - 1;
    bstr_t name;

    name = princ.GetString("Authority");
    name += _T("\\");
    name += princ.GetString("Name");
    
    // if methodStyle security, its possible to get more than 1 ace
    // per user so see if the principal already exists.
    // NOTE: Otherwise the idx = -1 will force into the "new principal" code.
    if(secStyle == CPrincipal::NS_MethodStyle)
    {
        LVFINDINFO findInfo;
        findInfo.flags = LVFI_STRING;
        findInfo.psz = (LPCTSTR)name;

        idx = ListView_FindItem(hPrinc, -1, &findInfo);
    }

    // if not already there...
    if(idx == -1)
    {
    // addref when CPrincipal takes a copy.
        pPrincipal = new CPrincipal(princ, secStyle);

        LV_ITEM lvItem;
        // initialize the variable parts.
        lvItem.mask = LVIF_TEXT | LVIF_PARAM|LVIF_IMAGE;
        lvItem.iItem = iItem;
        lvItem.iSubItem = 0;
        lvItem.pszText = CloneString(name);
        if (lvItem.pszText)
        {
            lvItem.cchTextMax = _tcslen(lvItem.pszText);
            lvItem.iImage = pPrincipal->GetImageIndex();
            lvItem.lParam = (LPARAM)pPrincipal;
            lvItem.iIndent = 0;

            // Insert principal into list.
            if((iItem = ListView_InsertItem(hPrinc, &lvItem)) != -1)
            {
                ATLTRACE(_T("ListView_InsertItem %d\n"), iItem);
                fPageModified = TRUE;
            }
        }

        if (!fPageModified) // it failed
        {
            delete pPrincipal;
            pPrincipal = NULL;
        }
    }
    else  // add it to the existing principal.
    {
        // get the existing principal instance.
        LVITEM item;
        item.mask = LVIF_PARAM;
        item.iItem = idx;
        item.iSubItem = 0;
        item.lParam = NULL;
        ListView_GetItem(hPrinc, &item);
        
        ATLTRACE(_T("extra ace\n"));

        pPrincipal = (CPrincipal *)item.lParam;

        // add the new ace to the existing principal.
        if(pPrincipal != NULL)
        {
            pPrincipal->AddAce(princ);
        } //endif pPrincipal
    }

    return fPageModified;
}

//----------------------------------------------------------------
void CRootSecurityPage::OnApply(HWND hDlg, bool bClose)
{
    CPrincipal *pPrincipal = NULL;
    
    VARIANT userList;
    SAFEARRAYBOUND rgsabound[1];
    SAFEARRAY *psa;

    CommitCurrent(hDlg);

    HWND hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);

    int count = ListView_GetItemCount(hwndList);
    LVITEM item;
    item.mask = LVIF_PARAM;

    // M3-9x will need an object array. Get ready.
    if(m_secStyle == CPrincipal::NS_MethodStyle)
    {
        VariantInit(&userList);
        rgsabound[0].lLbound = 0;
        rgsabound[0].cElements = count;
        psa = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);    
    }

    // all principal, put their bits back into their instance.
    for(long i = 0; i < count; i++)
    {
        item.iItem = i;
        item.iSubItem = 0;
        item.lParam = NULL;
        ListView_GetItem(hwndList, &item);

        pPrincipal = (CPrincipal *)item.lParam;

        if(pPrincipal != NULL)
        {
            CWbemClassObject userInst;
            if(SUCCEEDED(pPrincipal->Put(m_WbemServices, userInst)))
            {
                // for M3-9x, also add it to an array of objects.
                if(m_secStyle == CPrincipal::NS_MethodStyle)
                {
                    VARIANT v;
                    VariantInit(&v);

                    v.vt = VT_UNKNOWN;
                    IWbemClassObject *pCO = userInst;
                    v.punkVal = pCO;

                    SafeArrayPutElement(psa, &i, pCO);
                }

            } //SUCCEEDED()

        } //endif pPrincipal

    } //endfor

    // M3-9x also needs an execMethod.
    if(m_secStyle == CPrincipal::NS_MethodStyle)
    {
        CWbemClassObject _in;
        CWbemClassObject _out;

        V_VT(&userList) = VT_UNKNOWN | VT_ARRAY; 
        V_ARRAY(&userList) = psa;

        HRESULT hr = m_WbemServices.GetMethodSignatures("__SystemSecurity", "Set9XUserList",
                                                        _in, _out);

        if(SUCCEEDED(hr))
        {
            hr = _in.Put("ul", userList);
            
            hr = m_WbemServices.ExecMethod("__SystemSecurity", "Set9XUserList",
                                            _in, _out);
            if(SUCCEEDED(hr))
            {
                HRESULT hr1 = HRESULT_FROM_NT(_out.GetLong("ReturnValue"));
                if(FAILED(hr1))
                {
                    hr = hr1;
                }
            }

            VariantClear(&userList);
        }
        // HACK: because of how the core caches/uses security, I have to close &
        // reopen my connection because GetSecurity() will be immediately called
        // to refresh the UI. If I dont do this, GetSecurity() will return to old
        // security settings even though they're really saved. 
        m_WbemServices.DisconnectServer();
        m_WbemServices.ConnectServer(m_path);
    } //endif NS_MethodStyle
}

//------------------------------------------------------------------------
HRESULT CRootSecurityPage::ParseLogon(CHString1 &domUser,
                                      CHString1 &domain,
                                      CHString1 &user)
{

    int slashPos = -1;
    int len = domUser.GetLength();

    for(int x = 0; x < len; x++)
    {
        if(domUser[x] == _T('\\'))
        {
            slashPos = x;
            break;
        }
    }


	// no slash??
	if(slashPos == -1)
	{
//		domain = _T('.');
		domain = _T(".");
		user = domUser;
	}
	else if(slashPos == 0)  // leading slash...
	{
//		domain = _T('.');
		domain = _T(".");
		TCHAR *strTemp = (LPTSTR)(LPCTSTR)domUser;
		strTemp++;
		user = strTemp;
//		user = domUser[1];
	}
	else   //    domain\user
	{
		TCHAR buf[256] = {0}, buf2[256] = {0};
		domain = _tcsncpy(buf, domUser, slashPos);
		_tcscpy(buf, domUser);
		user = _tcscpy(buf2, &buf[slashPos+1]);
	}
    return S_OK;
}

//------------------------------------------------------------------------
void CRootSecurityPage::OnAddPrincipal(HWND hDlg)
{
    CHString1 domUser, domain, user;

    // Commit any outstanding bit changes.
    CommitCurrent(hDlg);

    // put up the user picker.
    if(GetUser(hDlg, domUser))
    {
        CWbemClassObject inst;
        HWND hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);

        ParseLogon(domUser, domain, user);

        // build default ace for the new guy.
        if(m_secStyle == CPrincipal::RootSecStyle)
        {
            inst = m_WbemServices.CreateInstance("__NTLMUser");
            inst.Put("Name", (bstr_t)user);
            inst.Put("Authority", (bstr_t)domain);
            inst.Put("EditSecurity", false);
            inst.Put("Enabled", true);
            inst.Put("ExecuteMethods", false);
            inst.Put("Permissions", (long)0);
        }
        else
        {
            inst = m_WbemServices.CreateInstance("__NTLMUser9x");
            inst.Put("Name", (bstr_t)user);
            inst.Put("Authority", (bstr_t)domain);
            inst.Put("Flags", (long)CONTAINER_INHERIT_ACE);
            inst.Put("Mask", (long)0);
            inst.Put("Type", (long)ACCESS_ALLOWED_ACE_TYPE);
        } //endif m_secStyle

        int iItem;
        if(AddPrincipal(hwndList, inst, m_secStyle, iItem))
        {
            EnableWindow(GetDlgItem(hDlg, IDC_SPP_PERMS), TRUE);

            // Tell the property sheet that we've changed.
            PropSheet_Changed(GetParent(hDlg), hDlg);
        }

        // if SOMETHING happened...
        if(iItem != -1)
        {
            // Select the already existing principal, or the last one inserted.
            ListView_SetItemState(hwndList, iItem, LVIS_SELECTED, LVIS_SELECTED);
            // NOTE: this should cause OnSelect() to be called to populate the 
            // Permissions list.
        }

        int cItems = ListView_GetItemCount(hwndList);
        // no principals-- disable the checklist.
        EnableWindow(GetDlgItem(hDlg, IDC_SPP_PERMS), (cItems != 0? TRUE: FALSE));
        EnableWindow(GetDlgItem(hDlg, IDC_SPP_REMOVE), (cItems != 0? TRUE: FALSE));
    }
}

//------------------------------------------------------------------------
bool CRootSecurityPage::GetUser(HWND hDlg, CHString1 &user)
{
    TCHAR userName[100] = {0};
    bool retval = false;
    if(DisplayEditDlg(hDlg, IDS_USERPICKER_TITLE, IDS_USERPICKER_MSG,
                        userName, 100) == IDOK)
    {
        user = CHString1(userName);
        retval = true;
    }
    return retval;
}

//------------------------------------------------------------------------
void CRootSecurityPage::OnRemovePrincipal(HWND hDlg)
{
    HWND hwndList;
    int iIndex;
    CPrincipal *pPrincipal;
    bool doit = false;

    hwndList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
    pPrincipal = GetSelectedPrincipal(hDlg, &iIndex);

    if(pPrincipal != NULL)
    {
        if(m_secStyle == CPrincipal::RootSecStyle)
        {
            CHString1 caption, msg;
            caption.LoadString(IDS_SHORT_NAME);
            msg.Format(MAKEINTRESOURCE(IDS_REMOVE_USER_FMT), pPrincipal->m_domain, pPrincipal->m_name);

            if(::MessageBox(hDlg, msg, caption,
                            MB_YESNO|MB_DEFBUTTON2|MB_ICONEXCLAMATION) == IDYES)
            {
                pPrincipal->DeleteSelf(m_WbemServices);
                doit = true;
            }
        }
        else // MethodStyle can delete as expected.
        {
            doit = true;
        }// endif m_secStyle

        if(doit)
        {
            ListView_DeleteItem(hwndList, iIndex);
            // NOTE: LVN_DELETEITEM will cleanup the CPrincipal.

            // If we just removed the only item, move the focus to the Add button
            // (the Remove button will be disabled in LoadPermissionList).
            int cItems = ListView_GetItemCount(hwndList);
            if(cItems == 0)
            {
                SetFocus(GetDlgItem(hDlg, IDC_SPP_ADD));
            }
            else
            {
                // If we deleted the last one, select the previous one
                if(cItems <= iIndex)
                    --iIndex;

                ListView_SetItemState(hwndList, iIndex, LVIS_SELECTED, LVIS_SELECTED);
            }

            // no principals-- disable the checklist.
            EnableWindow(GetDlgItem(hDlg, IDC_SPP_PERMS), (cItems != 0? TRUE: FALSE));
            EnableWindow(GetDlgItem(hDlg, IDC_SPP_REMOVE), (cItems != 0? TRUE: FALSE));

            PropSheet_Changed(GetParent(hDlg), hDlg);

        } //endif doit      

    } // endif pPrincipal != NULL
}

//---------------------------------------------------------------------------------
#define IDN_CHECKSELECTION 1  // this seems wierd.

BOOL CRootSecurityPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        m_chkList.Attach(hDlg, IDC_SPP_PERMS);
        InitDlg(hDlg);
        break;

    case WM_NOTIFY:
        OnNotify(hDlg, wParam, (LPNMHDR)lParam);
        break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDC_SPP_ADD:
            if(HIWORD(wParam) == BN_CLICKED)
                OnAddPrincipal(m_hDlg);

            break;

        case IDC_SPP_REMOVE:
            if(HIWORD(wParam) == BN_CLICKED)
                OnRemovePrincipal(m_hDlg);

            break;

    //    case IDC_SPP_ADVANCED:
    //      if(HIWORD(wParam) == BN_CLICK)
    //            OnAdvanced(m_hDlg);
    //        break;

        case IDC_SPP_PRINCIPALS:
            if(HIWORD(wParam) == IDN_CHECKSELECTION)
            {
                // See if we have gotten a new selection. If not, then the
                // user must have clicked inside the listview but not on an item,
                // thus causing the listview to remove the selection. In that
                // case, disable the other controls.
                if(ListView_GetSelectedCount(GET_WM_COMMAND_HWND(wParam, lParam)) == 0)
                {
                    EnablePrincipalControls(m_hDlg, FALSE);
                }
            }
            break;

        default: return FALSE;  // Command not handled.
        }
        break;


    case WM_HELP:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_HelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)rootSecPageHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hDlg))
        {
            WinHelp(hDlg, c_HelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)rootSecPageHelpIDs);
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CRootSecurityPage::OnNotify(HWND hDlg, WPARAM idCtrl, LPNMHDR pnmh)
{
    LPNM_LISTVIEW pnmlv = (LPNM_LISTVIEW)pnmh;

    // Set default return value.
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

    switch (pnmh->code)
    {
    case LVN_ITEMCHANGED:
        if(pnmlv->uChanged & LVIF_STATE)
        {
            // item *gaining* selection
            if((pnmlv->uNewState & LVIS_SELECTED) &&
                !(pnmlv->uOldState & LVIS_SELECTED))
            {
                // set bits based on principal.
                OnSelChange(hDlg);
            }
            // item *losing* selection
            else if(!(pnmlv->uNewState & LVIS_SELECTED) &&
                     (pnmlv->uOldState & LVIS_SELECTED))
            {
                // put bits back into the principal.
                CommitCurrent(hDlg, pnmlv->iItem);

                // Post ourselves a message to check for a new selection later.
                // If we haven't gotten a new selection by the time we process
                // this message, then assume the user clicked inside the listview
                // but not on an item, thus causing the listview to remove the
                // selection.  In that case, disable the combobox & Remove button.
                //
                // Do this via WM_COMMAND rather than WM_NOTIFY so we don't
                // have to allocate/free a NMHDR structure.
                PostMessage(hDlg, WM_COMMAND,
                            GET_WM_COMMAND_MPS(pnmh->idFrom, 
                                                pnmh->hwndFrom, 
                                                IDN_CHECKSELECTION));
            }
        }
        break;

    case LVN_DELETEITEM:
        {
//          LPNMLISTVIEW pnmv = (LPNMLISTVIEW)pnmh;
//          int pIndex = pnmv->iItem;
//          CPrincipal *pPrincipal = GetSelectedPrincipal(hDlg, &pIndex);
//          delete pPrincipal;
        }
        break;

    case LVN_KEYDOWN:
        if(((LPNMLVKEYDOWN)pnmh)->wVKey == VK_DELETE)
        {
            OnRemovePrincipal(hDlg);
        }
        break;

    case CLN_CLICK:
        if(pnmh->idFrom == IDC_SPP_PERMS)
        {
            // ASSUMPTION: You wont see and disable change from this msg.
            PNM_CHECKLIST pnmc = (PNM_CHECKLIST)pnmh;
            CPermission *perm = (CPermission *)pnmc->dwItemData;
            int pIndex = pnmc->iItem;
            HWND hwndList = pnmc->hdr.hwndFrom;
            //HWND hPrinc = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
            DWORD_PTR workingState = pnmc->dwState;

            // get the current principal.
            int cPrinc = -1;
            CPrincipal *pPrincipal = GetSelectedPrincipal(hDlg, &cPrinc);

			if(pPrincipal == NULL)
				break;

			HandleCheckList(hwndList, pPrincipal, perm, pnmc->iItem, &workingState);

            // if FULL_WRITE turned enabled & ON...
            // NOTE: if its DISABLED & ON, it must have been ENABLED & on before therefore
            // the partials would already be ENABLED & ON.
            if((perm->m_permBit == ACL_FULL_WRITE) &&
                (workingState == CLST_CHECKED))
            {
                CBL_SetState(hwndList, PARTIAL_WRITE_IDX, ALLOW_COL, CLST_CHECKED);
                CBL_SetState(hwndList, PROVIDER_WRITE_IDX, ALLOW_COL, CLST_CHECKED);
            }
            else if((perm->m_permBit == ACL_PARTIAL_WRITE) ||
                    (perm->m_permBit == ACL_PROVIDER_WRITE))
            {
                // partials turned DISABLED & ON but FULL_WRITE inherits...
                if((workingState == CLST_CHECKDISABLED) &&
                   (IS_BITSET(pPrincipal->m_inheritedPerms, ACL_FULL_WRITE)))
                {
                    // turn FULL_WRITE DISABLED & ON.
                    CBL_SetState(hwndList, FULL_WRITE_IDX, ALLOW_COL, CLST_CHECKDISABLED);
                }
                // if (ENABLED & OFF) or (DISABLED & ON without FULL_WRITE inherited)...
                else if(workingState != CLST_CHECKED)
                {
                    // turn off FULL_WRITE.
                    CBL_SetState(hwndList, FULL_WRITE_IDX, ALLOW_COL, CLST_UNCHECKED);
                }
            }

            PropSheet_Changed(GetParent(hDlg), hDlg);
        }
        break;

    case PSN_HELP:
        HTMLHelper(hDlg);
        break;

    case PSN_APPLY:
        OnApply(hDlg, (((LPPSHNOTIFY)pnmh)->lParam == 1));
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
void CRootSecurityPage::HandleCheckList(HWND hwndList,
                                        CPrincipal *pPrincipal,
                                        CPermission *perm,
                                        int iItem, DWORD_PTR *dwState)
{

    // was ENABLED & ON, now turning OFF.
    if(*dwState == CLST_UNCHECKED)
    {
        // is there a inherited perm to shine through?
        if(IS_BITSET(pPrincipal->m_inheritedPerms, perm->m_permBit))
        {
            // yup, DISABLE & ON the checkbox.
            CBL_SetState(hwndList, iItem, ALLOW_COL, CLST_CHECKDISABLED);
            *dwState = CLST_CHECKDISABLED;
        }
        // else nothing extra to do.
    }
    // was DISABLED & ON, now turning OFF
    else if(*dwState == CLST_DISABLED)
    {
        // ENABLE & ON the checkbox.
        CBL_SetState(hwndList, iItem, ALLOW_COL, CLST_CHECKED);
        *dwState = CLST_CHECKED;
    }
}

//-----------------------------------------------------------------------------
void CRootSecurityPage::OnSelChange(HWND hDlg)
{
    BOOL bDisabled = FALSE; ///m_siObjectInfo.dwFlags & SI_READONLY;

    // If the principal list is empty or there is no selection, then we need
    // to disable all of the controls that operate on items in the listbox.

    // Get the selected principal.
    CPrincipal *pPrincipal = GetSelectedPrincipal(hDlg, NULL);

    if(pPrincipal)
    {
        HWND hwndList = GetDlgItem(hDlg, IDC_SPP_PERMS);
        // set it into the checklist.
        pPrincipal->LoadChecklist(hwndList, m_OSType);

        // Enable/disable the other controls.
        if(!bDisabled)
        {
            EnablePrincipalControls(hDlg, pPrincipal != NULL);
        }
    }

}

//-----------------------------------------------------------------------------
void CRootSecurityPage::CommitCurrent(HWND hDlg, int iPrincipal /* = -1 */)
{
    HWND hwndPrincipalList = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);
    HWND hwndPermList = GetDlgItem(hDlg, IDC_SPP_PERMS);

    // If an index isn't provided, get the index of the currently
    // selected principal.
    if(iPrincipal == -1)
    {
        iPrincipal = ListView_GetNextItem(hwndPrincipalList, 
                                            -1, LVNI_SELECTED);
    }

    // if a principal is selected...
    if(iPrincipal != -1)
    {
        // Get the Principal from the selection.
        LV_ITEM lvItem;
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iPrincipal;
        lvItem.iSubItem = 0;
        lvItem.lParam = 0;

        ListView_GetItem(hwndPrincipalList, &lvItem);
        CPrincipal *pPrincipal = (CPrincipal *)lvItem.lParam;

        if(pPrincipal != NULL)
        {
            // store the bit settings into the principal.
            pPrincipal->SaveChecklist(hwndPermList, m_OSType);

        } //end pPrincipal != NULL
    }
}

//-----------------------------------------------------------------------------
void CRootSecurityPage::EnablePrincipalControls(HWND hDlg, BOOL fEnable)
{
    EnableWindow(GetDlgItem(hDlg, IDC_SPP_PERMS), fEnable);

    if(!fEnable)
    {
        ShowWindow(GetDlgItem(hDlg, IDC_SPP_MORE_MSG), SW_HIDE);
    }
    EnableWindow(GetDlgItem(hDlg, IDC_SPP_REMOVE), fEnable);
}

//-----------------------------------------------------------------------------
CPrincipal *CRootSecurityPage::GetSelectedPrincipal(HWND hDlg, int *pIndex)
{
    HWND hListView = GetDlgItem(hDlg, IDC_SPP_PRINCIPALS);

    int iSelected = ListView_GetNextItem(hListView, -1, LVNI_SELECTED);

     if (iSelected == -1)
        return NULL;

    if (pIndex)
        *pIndex = iSelected;

    LV_ITEM lvi;

    lvi.mask     = LVIF_PARAM;
    lvi.iItem    = iSelected;
    lvi.iSubItem = 0;
    lvi.lParam   = NULL;

    BOOL x = ListView_GetItem(hListView, &lvi);

    return (CPrincipal *)lvi.lParam;
}

//-------------------------------------------------------------------------------------
HIMAGELIST CRootSecurityPage::LoadImageList(HINSTANCE hInstance, LPCTSTR pszBitmapID)
{
    HIMAGELIST himl = NULL;
    HBITMAP hbm = LoadBitmap(hInstance, pszBitmapID);

    if (hbm != NULL)
    {
        BITMAP bm;
        GetObject(hbm, sizeof(bm), &bm);

        himl = ImageList_Create(bm.bmHeight,    // height == width
                                bm.bmHeight,
                                ILC_COLOR | ILC_MASK,
                                bm.bmWidth / bm.bmHeight,
                                0);  // don't need to grow
        if (himl != NULL)
            ImageList_AddMasked(himl, hbm, CLR_DEFAULT);

        DeleteObject(hbm);
    }

    return himl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\rootsecpage.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#if !defined(AFX_ROOTSECPAGE_H__CF09EE6C_BA3F_11D2_887F_00104B2AFB46__INCLUDED_)
#define AFX_ROOTSECPAGE_H__CF09EE6C_BA3F_11D2_887F_00104B2AFB46__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// RootSecPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRootSecurityPage dialog
#include "UIHelpers.h"
#include "ChkListHandler.h"
#include "Principal.h"
#include "simplearray.h"
#include "CHString1.h"
#include <commctrl.h>

class DataSource;

class CRootSecurityPage : public CUIHelpers
{
// Construction
public:
	CRootSecurityPage(CWbemServices &ns, 
						CPrincipal::SecurityStyle secStyle, 
						_bstr_t path,
						bool htmlSupport,
						int OSType);

private:
    virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
	void InitDlg(HWND hDlg);
	HRESULT LoadSecurity(HWND hDlg);
	void LoadPermissionList(HWND hDlg);
    void OnApply(HWND hDlg, bool bClose);
	BOOL OnNotify(HWND hDlg, WPARAM idCtrl, LPNMHDR pnmh);
	void OnRemovePrincipal(HWND hDlg);
	bool AddPrincipal(HWND hPrinc, CWbemClassObject &princ,
						CPrincipal::SecurityStyle secStyle,
						int &iItem);
	HRESULT AddPrincipalsFromArray(HWND hPrinc, variant_t &vValue);
	HIMAGELIST LoadImageList(HINSTANCE hInstance, LPCTSTR pszBitmapID);
	CPrincipal *GetSelectedPrincipal(HWND hDlg, int *pIndex);
	void EnablePrincipalControls(HWND hDlg, BOOL fEnable);
	void OnSelChange(HWND hDlg);
	void CommitCurrent(HWND hDlg, int iPrincipal = -1 );
	void HandleCheckList(HWND hwndList,
						CPrincipal *pPrincipal,
						CPermission *perm,
						int iItem, DWORD_PTR *dwState);

	//typedef CSimpleArray<CHString1> USERLIST;
	void OnAddPrincipal(HWND hDlg);
	bool GetUser(HWND hDlg, CHString1 &user);
	HRESULT ParseLogon(CHString1 &domUser,
						  CHString1 &domain,
						  CHString1 &user);


	CCheckListHandler m_chkList;
	CPrincipal::SecurityStyle m_secStyle;
	_bstr_t m_path;
	int m_OSType;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ROOTSECPAGE_H__CF09EE6C_BA3F_11D2_887F_00104B2AFB46__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\shlwapi2.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __SHLWAPI2__
#define __SHLWAPI2__


// NOTE: a much hated clone of shlwapi.dll routines.

	// from nt5inc\shlwapi.h.
	BOOL PathCompactPathEx(LPTSTR pszOut, LPCTSTR pszSrc,
							UINT cchMax, DWORD dwFlags = 0);

	bool PathIsUNC(LPCTSTR pszPath);
	LPTSTR PathAddBackslash(LPTSTR lpszPath);

	LPTSTR PathFindFileName(LPCTSTR pPath);
#ifndef UNICODE
	BOOL IsTrailByte(LPCTSTR pszSt, LPCTSTR pszCur);
#endif


#endif __SHLWAPI2__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\pagebase.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef _PAGEBASE_H_
#define _PAGEBASE_H_

#include "..\common\sshWbemHelpers.h"
#include <windowsx.h>

// supports the page coordinating routines.
#define PB_LOGGING 0
#define PB_BACKUP 1
#define PB_ADVANCED 2
#define PB_LASTPAGE 2


class WbemServiceThread;
class DataSource;

class CBasePage
{
public:
    CBasePage(DataSource *ds, WbemServiceThread *serviceThread);
    CBasePage(CWbemServices &service);
    virtual ~CBasePage( void );

    HPROPSHEETPAGE CreatePropSheetPage(LPCTSTR pszDlgTemplate, 
										LPCTSTR pszDlgTitle = NULL,
										DWORD moreFlags = 0);
	DataSource *m_DS;

protected:
    virtual BOOL DlgProc(HWND, UINT, WPARAM, LPARAM) { return FALSE; }
    virtual UINT PSPageCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
    static INT_PTR CALLBACK _DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static UINT CALLBACK _PSPageCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);

	INT_PTR DisplayLoginDlg(HWND hWnd, 
						LOGIN_CREDENTIALS *credentials);

	HWND m_hDlg;
	bool m_alreadyAsked;
	WbemServiceThread *g_serviceThread;
	CWbemServices m_WbemServices;

	IWbemServices *m_service;
	bool m_userCancelled; // the connectServer() thread.
};


#endif  /* _PAGEBASE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\principal.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __PRINCIPAL_H
#define __PRINCIPAL_H


// "generic" definition combining the perms from old and new security strategies.
#define ACL_ENABLE				0x1		//NS_MethodStyle
#define ACL_METHOD_EXECUTE		0x2		//NS_MethodStyle
#define ACL_FULL_WRITE			0x4		//NS_MethodStyle
#define ACL_PARTIAL_WRITE		0x8		//NS_MethodStyle
#define ACL_PROVIDER_WRITE		0x10	//NS_MethodStyle
#define ACL_REMOTE_ENABLE		0x20	//NS_MethodStyle
#define ACL_READ_CONTROL		0x20000	//NS_MethodStyle

#define ACL_WRITE_DAC			0x40000	//NS_MethodStyle & RootSecStyle:Edit Security

#define ACL_INSTANCE_WRITE		0x40	//RootSecStyle
#define ACL_CLASS_WRITE			0x80	//RootSecStyle

#define ACL_MAX_BIT	ACL_WRITE_DAC

#define VALID_NSMETHOD_STYLE (ACL_ENABLE | ACL_METHOD_EXECUTE | ACL_FULL_WRITE | \
								ACL_PARTIAL_WRITE | ACL_PROVIDER_WRITE | ACL_READ_CONTROL | \
								ACL_WRITE_DAC)

#define VALID_ROOTSEC_STYLE (ACL_INSTANCE_WRITE |\
								ACL_CLASS_WRITE | ACL_WRITE_DAC)

#define ALLOW_COL 1
#define DENY_COL 2

#include "DataSrc.h"
//------------------------------------------------------------------------
class CPrincipal
{
public:
	typedef enum {
		RootSecStyle,		// pre-M3
		NS_MethodStyle		// M3+		
	} SecurityStyle;

	// for initializing.
	CPrincipal(CWbemClassObject &userInst, SecurityStyle secStyle);
	
	// move m_perms into the checkboxes
	void LoadChecklist(HWND list, int OSType);

	// move the checkboxes into m_perms.
	void SaveChecklist(HWND list, int OSType);
	HRESULT Put(CWbemServices &service, CWbemClassObject &userInst);

	bool Changed(void) 
		{ 
			return (m_origPerms != m_perms); 
		};
	int GetImageIndex(void);
	void AddAce(CWbemClassObject &princ);

	HRESULT DeleteSelf(CWbemServices &service);  // M1 targets only.

	TCHAR m_name[100];
	TCHAR m_domain[100];
	SecurityStyle m_secStyle;
	UINT m_SidType;
	bool m_editable;

	// perms mask for this principal (aka account)
	DWORD m_perms, m_origPerms, m_inheritedPerms;
};

//------------------------------------------------------------------------
// An instance is attached to each item in the permissions list so they
// can be matched up reliably.
typedef struct 
{
	// Identifies the "generic" perm bit. Only set ONE bit.
	DWORD m_permBit;
} CPermission;

#endif __PRINCIPAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\simplearray.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#if (_ATL_VER < 0x0300)
/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CSimpleArray & CSimpleMap

#ifndef __SIMPLEARRAY__
#define __SIMPLEARRAY__

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

template <class T>
class CSimpleArray
{
public:
	T* m_aT;
	int m_nSize;
	int m_nAllocSize;

// Construction/destruction
	CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
	{ }

	~CSimpleArray()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(T& t)
	{
		if(m_nSize == m_nAllocSize)
		{
			T* aT;
			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
			aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
			if(aT == NULL)
				return FALSE;
			m_nAllocSize = nNewAllocSize;
			m_aT = aT;
		}
		m_nSize++;
		SetAtIndex(m_nSize - 1, t);
		return TRUE;
	}
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(int nIndex)
	{
		if(nIndex != (m_nSize - 1))
			memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aT != NULL)
		{
			free(m_aT);
			m_aT = NULL;
		}
		m_nSize = 0;
		m_nAllocSize = 0;
	}
	T& operator[] (int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aT[nIndex];
	}
	T* GetData() const
	{
		return m_aT;
	}

// Implementation
	void SetAtIndex(int nIndex, T& t)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_aT[nIndex] = t;
	}
	int Find(T& t) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;	// not found
	}
};
#endif __SIMPLEARRAY__

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\resource.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WmiCntl.rc
//
#define IDC_ADV_RECOVERY_ICON           40
#define IDC_ADV_NOW_TEXT                41
#define IDC_ADV_RECOVERY_ICON2          42
#define IDC_ADV_NOW_TEXT2               42
#define IDC_ADV_NOW_TEXT3               43
#define IDI_WMICNTL                     44
#define IDC_RESTORE_BTN                 50
#define IDC_BACKUP_BTN                  51
#define IDC_BACKUP_BTN2                 53
#define IDC_RESTORE_BTN2                54
#define IDC_RESTORE_FM_AUTO             54
#define IDS_CONNECTING                  55
#define IDS_PROJNAME                    56
#define IDB_WMISNAPIN_16                57
#define IDB_WMISNAPIN_32                58
#define IDS_WMISNAPIN_DESC              59
#define IDS_WMISNAPIN_PROVIDER          60
#define IDS_WMISNAPIN_VERSION           61
#define IDR_WMISNAPIN                   62
#define IDS_SNAPIN_TYPE                 63
#define IDS_DESCRIPTION                 64
#define IDD_ABOUTBOX                    100
#define IDD_ANIMATE                     101
#define IDC_ANIMATE                     102
#define IDC_MYICON                      103
#define IDR_MENU_MENU                   103
#define IDC_MSG                         104
#define IDR_AVIWAIT                     105
#define IDR_MAINFRAME                   128
#define IDD_MAINDLG                     129
#define IDS_UNAVAILABLE                 129
#define IDS_NOT_REMOTEABLE              130
#define IDS_LOCAL_CONN                  131
#define IDS_ERROR                       132
#define IDS_SHORT_NAME                  133
#define IDS_BAD_INTERVAL_FMT            134
#define IDS_BAD_INTERVAL                134
#define IDS_WBEM_GENERIC_ALL            135
#define IDS_WBEM_GENERIC_EXECUTE        136
#define IDS_WBEM_GENERIC_READ           137
#define IDS_WBEM_GENERIC_WRITE          138
#define IDS_WBEM_FULL_WRITE             139
#define IDS_WBEM_PARTIAL_WRITE          140
#define IDS_WBEM_PROVIDER_WRITE         141
#define IDS_NONE                        142
#define IDS_WBEM_SYSTEM_WRITE           142
#define IDS_DISPLAY_NAME                143
#define IDS_CANT_LOAD_SEC_DLLS          144
#define IDS_NO_ACLUI                    145
#define IDS_NO_CREATE_SEC               146
#define IDS_DEBUG                       147
#define IDS_OS_LABEL                    148
#define IDS_OS_VER_LABEL                149
#define IDS_CPU_LABEL                   150
#define IDS_WMI_VER_LABEL               151
#define IDS_CONNECTED_TO_LABEL          152
#define IDS_CONN_FAILED_FMT             153
#define IDS_BECAUSE_LABEL               154
#define IDS_WBEM_INSTANCE_WRITE         154
#define IDS_WBEM_CLASS_WRITE            155
#define IDS_WBEM_ENABLE                 156
#define IDS_WBEM_READONLY               157
#define IDS_WBEM_EDIT_SECURITY          158
#define IDS_WBEM_READ_SECURITY          159
#define IDS_WBEM_REMOTE_ENABLE          160
#define IDS_WBEM_NAMESPACE              161
#define IDS_WBEM_NAMESPACE_SUBNAMESPACE 162
#define IDS_WBEM_SUBNAMESPACE_ONLY      163
#define IDS_OS_SERVICE_PACK_LABEL		164
#define IDD_GENERAL                     201
#define IDD_LOGGING                     202
#define IDD_ADVANCED                    203
#define IDD_ADVANCED_NT                 203
#define IDI_LOGGING                     204
#define IDB_LOGGING                     205
#define IDI_WAITING                     207
#define IDI_FAILED                      208
#define IDD_CONNECT                     209
#define IDD_EDITBOX                     211
#define IDD_USER_PICKER                 212
#define IDB_SID_ICONS                   213
#define IDI_CLSD_FOLDER                 214
#define IDI_EARTH                       215
#define IDI_CLSD_CLASS					216
#define IDI_CLSD_INSTANCE				217
#define IDI_CLSD_SCOPEINSTANCE			218
#define IDI_CLSD_SCOPECLASS				219
#define IDD_9XSEC                       250
#define IDC_SPP_PRINCIPALS              251
#define IDD_SEC_ERROR                   251
#define IDC_SPP_ADD                     252
#define IDD_BACKUP                      252
#define IDC_SPP_REMOVE                  253
#define IDC_SPP_RESET                   254
#define IDD_NAMESPACE                   254
#define IDC_SPP_ACCESS                  255
#define IDD_ADVANCED_9X                 255
#define IDC_SPP_ALLOW                   256
#define IDD_ADVANCED_EMPTY              256
#define IDC_SPP_DENY                    257
#define IDD_NS_PICKER                   257
#define IDC_SPP_PERMS                   258
#define IDC_SPP_ADVANCED                259
#define IDC_SPP_MORE_MSG                260
#define IDC_SPP_PROTECT                 262
#define IDC_SPP_NO_SECURITY             263
#define IDS_ERROR_UNKN_ERROR_FMT        264
#define IDS_ERROR_FMT                   265
#define IDS_WMI_INSTALL_DIR             266
#define IDS_NS_PROP_TITLE               267
#define IDS_MINUTES                     268
#define IDS_HOURS                       269
#define IDS_DAYS                        270
#define IDS_BACKUP_THREAT               271
#define IDS_BACKUP_TITLE                272
#define IDS_BACKUP_FMT                  273
#define IDS_RESTORE_TITLE               274
#define IDS_RESTORE_FMT                 275
#define IDS_OPEN_BACKUP                 276
#define IDS_OPEN_RESTORE                277
#define IDS_DIR_DOESNT_EXIST            278
#define IDS_NO_BACKUP_FILE              279
#define IDS_BACKUP_OVERWRITE            280
#define IDS_CANT_BROWSE_REMOTELY        281
#define IDS_OPTIONS_SMALL               282
#define IDS_OPTIONS_BIG                 283
#define IDS_IMP_DELEGATE                284
#define IDS_IMP_IDENTIFY                285
#define IDS_IMP_IMPERSONATE             286
#define IDS_AUTH_CALL                   287
#define IDS_AUTH_CONNECT                288
#define IDS_AUTH_NONE                   289
#define IDS_AUTH_PACKET                 290
#define IDS_AUTH_INTEGRITY              291
#define IDS_AUTH_PRIVACY                292
#define IDS_USERPICKER_TITLE            293
#define IDS_USERPICKER_MSG              294
#define IDS_NAME                        295
#define IDS_REMOVE_USER_FMT             296
#define IDS_CURRENT_USER                297
#define IDS_GEN_PARA_SNAPIN             298
#define IDS_USER_LABEL                  299
#define IDS_ADV_PARA_NT                 300
#define IDS_ADV_PARA_9X                 301
#define IDS_MULTI_INSTANCES             302
#define IDS_WAIT                        303
#define IDS_DIR_EMPTY                   304
#define IDS_SURE                        305
#define IDS_AUTORESTORE                 306
#define IDS_PARTIAL_DS_FAILURE          307
#define IDS_SEC_ERR_FMT                 308
#define IDS_OS_ERR_FMT                  309
#define IDS_CPU_ERR_FMT                 310
#define IDS_SETTING_ERR_FMT             311
#define IDS_NO_ERR                      312
#define IDS_NO_HHCTRL                   313
#define IDS_NO_HELP                     314
#define IDS_LOG_SELECT_FDR              315
#define IDS_LOCAL_COMPUTER              316
#define IDS_NO_UNC                      317
#define IDS_NO_DRIVE_LTR                318
#define IDS_DIRS_ONLY                   319
#define IDS_LOGS_WRONG_DRIVETYPE        320
#define ID_TOP_RECONNECT                321
#define IDS_BAD_LOGSIZE                 322
#define IDS_REC_FILTER                  323
#define IDS_USE_RADIO                   324
#define IDS_POST_RESTORE                325
#define IDS_STATUS_NOTSTARTED           326
#define IDS_STATUS_CANCELLED            327
#define IDS_NO_98TONT_SEC               328
#define IDS_ALL_FILTER                  329
#define IDS_NEED_EXISTING_DIR           330
#define IDS_NS_PARA                     331
#define ID_PERF_COUNTERS                332
#define IDD_WMICTR                      333
#define IDR_SEC_MENU                    334
#define IDC_ERROR_CAPTION               335
#define IDC_ERROR_CONNECT               336
#define IDC_ERROR_ENUM                  337
#define IDC_CONNECTIONS                 338
#define IDC_DELBACKUP                   339
#define IDC_INTERNALOBJS                340
#define IDC_INTERNALSINKS               341
#define IDC_TASKSINPROG                 342
#define IDC_TASKSWAITING                343
#define IDC_TOTALAPICALLS               344
#define IDC_USERS                       345
#define IDS_CONNECTIONS                 346
#define IDS_DELBACKUP                   347
#define IDS_INTERNALOBJS                348
#define IDS_INTERNALSINKS               349
#define IDS_TASKSINPROG                 350
#define IDS_TASKSWAITING                351
#define IDS_TOTALAPICALLS               352
#define IDS_USERS                       353
#define IDD_WMICTR_SYSMON	            354
#define IDC_SYSMON_OCX                  355
#define IDC_RETRY_TEXT					356
#define IDC_ENUM_STATIC					357
#define IDC_CANCEL_ENUM					358
#define IDC_BACKUPINTERVAL              1000
#define IDC_LASTBACKUP                  1001
#define IDC_DISABLELOGGING              1002
#define IDC_ERRORLOGGING                1003
#define IDC_VERBOSELOGGING              1004
#define IDC_MAXFILESIZE                 1005
#define IDC_LOGGINGDIRECTORY            1006
#define IDC_BROWSE                      1007
#define IDC_NORESTART                   1008
#define IDC_ESSRESTART                  1009
#define IDC_ALWAYSAUTORESTART           1010
#define IDC_CIMOMRESTART                1011
#define IDC_9X_ONLY                     1011
#define IDC_VERSION                     1012
#define IDC_COMBO1                      1013
#define IDC_MACHINES                    1013
#define IDC_BACKUP_UNITS                1013
#define IDC_CONNECT                     1014
#define IDC_CHANGE                      1014
#define IDC_ASP                         1015
#define IDC_OS                          1015
#define IDC_STATUS                      1016
#define IDC_STATUSICON                  1017
#define IDC_OS_LABEL                    1018
#define IDC_VERSION_LABEL               1019
#define IDC_STATUS_LABEL                1020
#define IDC_BACKUPINTERVAL_LABEL        1021
#define IDC_LASTBACKUP_LABEL            1022
#define IDC_MAXFILESIZE_LABEL           1023
#define IDC_LOGGINGDIRECTORY_LABEL      1024
#define IDC_STATUS_FRAME                1025
#define IDC_DEFNS                       1026
#define IDC_DEFNS_LABEL                 1027
#define IDC_SCRIPTING_FRAME             1028
#define IDC_OS_VERSION                  1029
#define IDC_LIST2                       1030
#define IDC_NO_SECURITY                 1031
#define IDC_OS_VERSION_LABEL            1032
#define IDC_MACHINE                     1033
#define IDC_RESTART_IIS                 1035
#define IDC_LOCAL                       1036
#define IDC_REMOTE                      1037
#define IDC_NAME                        1038
#define IDC_BACKUP_ENABLED              1039
#define IDC_NSTREE                      1040
#define IDC_PROPERTIES                  1041
#define IDC_9X_ANON_CONNECTION          1044
#define IDC_DB_DIR                      1045
#define IDC_DBDIRECTORY_LABEL           1049
#define IDC_SCRIPT_NS                   1051
#define IDC_CHANGE_SCRIPT_NS            1052
#define IDC_BUTTON1                     1054
#define IDC_LOGON                       1054
#define IDC_ASP_LABEL                   1056
#define IDC_EDIT                        1057
#define IDC_ACCOUNT                     1058
#define IDC_EDIT1                       1059
#define IDC_EDITUSERNAME                1060
#define IDC_COMP_LABEL                  1060
#define IDC_EDITPASSWORD                1061
#define IDC_GEN_PARA                    1061
#define IDC_CHECKCURRENTUSER            1062
#define IDC_ADV_PARA                    1062
#define IDD_LOGIN                       1063
#define IDC_SCRIPT_LABEL                1063
#define IDC_USER_LABEL                  1064
#define IDD_CONNECT_WIZ                 1064
#define IDC_PW_LABEL                    1065
#define IDC_CONN_FRAME                  1066
#define IDC_ACCOUNT_LABEL               1067
#define IDC_LOG_PARA                    1068
#define IDC_NS_PARA                     1069
#define IDC_AUTOMATIC_GROUPBOX			1070
#define IDC_MANUAL_GROUPBOX				1071

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        216
#define _APS_NEXT_COMMAND_VALUE         32773
#define _APS_NEXT_CONTROL_VALUE         1072
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\shlwapi2.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation

#include "precomp.h"
#include "shlwapi2.h"
#include <platform.h>

//---------------------------------------------------------
#ifdef UNICODE
//***   FAST_CharNext -- fast CharNext for path operations
// DESCRIPTION
//  when we're just stepping thru chars in a path, a simple '++' is fine.
#define FAST_CharNext(p)    (DBNotNULL(p) + 1)

#ifdef DEBUG
LPWSTR WINAPI DBNotNULL(LPCWSTR lpszCurrent)
{
    ATLASSERT(*lpszCurrent);
    return (LPWSTR) lpszCurrent;
}
#else
#define DBNotNULL(p)    (p)
#endif

#else
#define FAST_CharNext(p)    CharNext(p)
#endif

//---------------------------------------------------------
LPTSTR PathFindFileName(LPCTSTR pPath)
{
    LPCTSTR pT = pPath;
    
    if(pPath)
    {
        for( ; *pPath; pPath = FAST_CharNext(pPath))
        {
            if ((pPath[0] == TEXT('\\') || pPath[0] == TEXT(':') || pPath[0] == TEXT('/'))
                && pPath[1] &&  pPath[1] != TEXT('\\')  &&   pPath[1] != TEXT('/'))
                pT = pPath + 1;
        }
    }

    return (LPTSTR)pT;   // const -> non const
}

//---------------------------------------------------------
#ifndef UNICODE
// light weight logic for charprev that is not painful for sbcs
BOOL IsTrailByte(LPCTSTR pszSt, LPCTSTR pszCur)
{
    LPCTSTR psz = pszCur;
    // if the given pointer is at the top of string, at least it's not a trail
    // byte.
    //
    if (psz <= pszSt) return FALSE;

    while (psz > pszSt)
    {
        psz--;
        if (!IsDBCSLeadByte(*psz))
        {
            // This is either a trail byte of double byte char
            // or a single byte character we've first seen.
            // Thus, the next pointer must be at either of a leadbyte
            // or pszCur itself.
            psz++;
            break;
        }
    }
    // Now psz can point to:
    //     1) a leadbyte of double byte character.
    //     2) pszSt
    //     3) pszCur
    //
    // if psz == pszSt, psz should point to a valid double byte char.
    //                  because we didn't hit the above if statement.
    //
    // if psz == pszCur, the *(pszCur-1) was non lead byte so pszCur can't
    //                   be a trail byte.
    //
    // Thus, we can see pszCur as trail byte pointer if the distance from
    // psz is not DBCS boundary that is 2.
    //
    return (BOOL) ((pszCur-psz) & 1);
}
#endif

//----------------------------------------------------------------------
#define LEN_MID_ELLIPSES        4
#define LEN_END_ELLIPSES        3
#define MIN_CCHMAX              LEN_MID_ELLIPSES + LEN_END_ELLIPSES

// PathCompactPathEx
// Output:
//          "."
//          ".."
//          "..."
//          "...\"
//          "...\."
//          "...\.."
//          "...\..."
//          "...\Truncated filename..."
//          "...\whole filename"
//          "Truncated path\...\whole filename"
//          "Whole path\whole filename"
// The '/' might be used instead of a '\' if the original string used it
// If there is no path, but only a file name that does not fit, the output is:
//          "truncated filename..."

BOOL PathCompactPathEx(LPTSTR  pszOut,
						LPCTSTR pszSrc,
						UINT    cchMax,
						DWORD   dwFlags)
{
    if(pszSrc)
    {
        TCHAR * pszFileName, *pszWalk;
        UINT uiFNLen = 0;
        int cchToCopy = 0, n;
        TCHAR chSlash = TEXT('0');

        ZeroMemory(pszOut, cchMax * sizeof(TCHAR));

        if((UINT)lstrlen(pszSrc)+1 < cchMax)
        {
            lstrcpy(pszOut, pszSrc);
            ATLASSERT(pszOut[cchMax-1] == TEXT('\0'));
            return TRUE;
        }

        // Determine what we use as a slash - a / or a \ (default \)
        pszWalk = (TCHAR*)pszSrc;
        chSlash = TEXT('\\');
        // Scan the entire string as we want the path separator closest to the end
        // eg. "file://\\Themesrv\desktop\desktop.htm"
        while(*pszWalk)
        {
            if((*pszWalk == TEXT('/')) || (*pszWalk == TEXT('\\')))
                chSlash = *pszWalk;

            pszWalk = FAST_CharNext(pszWalk);
        }

        pszFileName = PathFindFileName(pszSrc);
        uiFNLen = lstrlen(pszFileName);

        // if the whole string is a file name
        if(pszFileName == pszSrc && cchMax > LEN_END_ELLIPSES)
        {
            lstrcpyn(pszOut, pszSrc, cchMax - LEN_END_ELLIPSES);
#ifndef UNICODE
            if(IsTrailByte(pszSrc, pszSrc+cchMax-LEN_END_ELLIPSES))
                *(pszOut+cchMax-LEN_END_ELLIPSES-1) = TEXT('\0');
#endif
            lstrcat(pszOut, TEXT("..."));
            ATLASSERT(pszOut[cchMax-1] == TEXT('\0'));
            return TRUE;
        }

        // Handle all the cases where we just use ellipses ie '.' to '.../...'
        if((cchMax < MIN_CCHMAX))
        {
            for(n = 0; n < (int)cchMax-1; n++)
            {
                if((n+1) == LEN_MID_ELLIPSES)
                    pszOut[n] = chSlash;
                else
                    pszOut[n] = TEXT('.');
            }
            ATLASSERT(0==cchMax || pszOut[cchMax-1] == TEXT('\0'));
            return TRUE;
        }

        // Ok, how much of the path can we copy ? Buffer - (Lenght of MID_ELLIPSES + Len_Filename)
        cchToCopy = cchMax - (LEN_MID_ELLIPSES + uiFNLen);
        if (cchToCopy < 0)
            cchToCopy = 0;
#ifndef UNICODE
        if (cchToCopy > 0 && IsTrailByte(pszSrc, pszSrc+cchToCopy))
            cchToCopy--;
#endif

        lstrcpyn(pszOut, pszSrc, cchToCopy);

        // Now throw in the ".../" or "...\"
        lstrcat(pszOut, TEXT(".../"));
        pszOut[lstrlen(pszOut) - 1] = chSlash;

        //Finally the filename and ellipses if necessary
        if(cchMax > (LEN_MID_ELLIPSES + uiFNLen))
        {
            lstrcat(pszOut, pszFileName);
        }
        else
        {
            cchToCopy = cchMax - LEN_MID_ELLIPSES - LEN_END_ELLIPSES;
#ifndef UNICODE
            if(cchToCopy >0 && IsTrailByte(pszFileName, pszFileName+cchToCopy))
                cchToCopy--;
#endif
            lstrcpyn(pszOut + LEN_MID_ELLIPSES, pszFileName, cchToCopy);
            lstrcat(pszOut, TEXT("..."));
        }
        ATLASSERT(pszOut[cchMax-1] == TEXT('\0'));
        return TRUE;
    }
    return FALSE;
}

//----------------------------------------------------------------------
// Returns TRUE if the given string is a UNC path.
//
// TRUE
//      "\\foo\bar"
//      "\\foo"         <- careful
//      "\\"
// FALSE
//      "\foo"
//      "foo"
//      "c:\foo"
//
//
bool PathIsUNC(LPCTSTR pszPath)
{
    if(pszPath)
    {
	    return ((pszPath[0] == _T('\\')) && (pszPath[1] == _T('\\')));
    }
    return false;
}

// add a backslash to a qualified path
//
// in:
//  lpszPath    path (A:, C:\foo, etc)
//
// out:
//  lpszPath    A:\, C:\foo\    ;
//
// returns:
//  pointer to the NULL that terminates the path
//
//----------------------------------------------------------------------
LPTSTR PathAddBackslash(LPTSTR lpszPath)
{

    if(lpszPath)
    {
        LPTSTR lpszEnd;

        // perf: avoid lstrlen call for guys who pass in ptr to end
        // of buffer (or rather, EOB - 1).
        // note that such callers need to check for overflow themselves.
        int ichPath = (*lpszPath && !*(lpszPath + 1)) ? 1 : lstrlen(lpszPath);

        // try to keep us from tromping over MAX_PATH in size.
        // if we find these cases, return NULL.  Note: We need to
        // check those places that call us to handle their GP fault
        // if they try to use the NULL!
        if(ichPath >= (_MAX_PATH - 1))
        {
            return(NULL);
        }

        lpszEnd = lpszPath + ichPath;

        // this is really an error, caller shouldn't pass
        // an empty string
        if(!*lpszPath)
            return lpszEnd;

        // Get the end of the source directory
        switch(*CharPrev(lpszPath, lpszEnd))
        {
            case _T(FILENAME_SEPARATOR):
                break;

            default:
                *lpszEnd++ = _T(FILENAME_SEPARATOR);
                *lpszEnd = _T('\0');
        }

        return lpszEnd;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\wbemerror.h ===
#ifndef __WBEMERROR__
#define __WBEMERROR__
//=============================================================================
//
//                              WbemError.h
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//	Implements string table based, error msgs for all of wbem.
//
//  History:
//
//      a-khint  5-mar-98       Created.
//
//============================================================================= 
#include "precomp.h"
#include "DeclSpec.h"

//---------------------------------------------------------
// ErrorString: Extracts convenient information out of the
//				SCODE (HRESULT). If its not a wbem error,
//				system error msgs will be checked.
// Parms:
//		sc - The error code from any facility.
//		errMsg - pointer to an allocated string buffer for
//					the error msg. Can be NULL.
//		errSize - the size of errMsg in chars.
//
//		facility - pointer to an allocated string buffer for
//					the facility name. Can be NULL.
//		facSize - the size of errMsg in chars.
//
//		sevIcon - ptr to receive the appropriate MB_ICON*
//					value for the sc. Can be NULL. Value
//					should be OR'ed with the MessageBox()
//					uType.
//---------------------------------------------------------
extern "C"
{

// formats the facility part for you too.
POLARITY bool ErrorStringEx(HRESULT hr, 
						   TCHAR *errMsg, UINT errSize,
						   UINT *sevIcon = NULL);

}
#endif __WBEMERROR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\stdafx.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include <precomp.h>

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

LONG CExeModule::Unlock()
{
	LONG l = CComModule::Unlock();

#ifndef SNAPIN
	if (l == 0)
	{
#if _WIN32_WINNT >= 0x0400
		if (CoSuspendClassObjects() == S_OK)
			PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
#else
		PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
#endif
	}
#endif

	return l;
}

CExeModule _Module;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\si.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include <winioctl.h>
#include "si.h"
#include "resource.h"
#include <cguid.h>
#include <stdio.h>

//-----------------------------------------------------------------------------
CSecurityInformation::~CSecurityInformation() 
{
}

#define HINST_THISDLL   _Module.GetModuleInstance()
//-----------------------------------------------------------------------------
HRESULT CSecurityInformation::PropertySheetPageCallback(HWND hwnd, 
												  UINT uMsg, 
												  SI_PAGE_TYPE uPage)
{
    return S_OK;
}


//======================================================================
//------------------- ISECURITYINFORMATION follows ---------------------------
//EXTERN_C const GUID IID_ISecurityInformation =
//	{ 0x965fc360, 0x16ff, 0x11d0, 0x91, 0xcb, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x23 };

#define WBEM_ENABLE             ( 0x0001 )   
#define WBEM_METHOD_EXECUTE     ( 0x0002 )   
#define WBEM_FULL_WRITE_REP     ( 0x001c )   
#define WBEM_PARTIAL_WRITE_REP  ( 0x0008 )   
#define WBEM_WRITE_PROVIDER     ( 0x0010 )   
#define WBEM_REMOTE_ENABLE      ( 0x0020 )   

#define WBEM_GENERAL_WRITE     (WBEM_FULL_WRITE_REP|WBEM_PARTIAL_WRITE_REP|WBEM_WRITE_PROVIDER)   

#define WBEM_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED  |\
							SYNCHRONIZE            |\
							WBEM_ENABLE            |\
							WBEM_METHOD_EXECUTE    |\
							WBEM_FULL_WRITE_REP    |\
							WBEM_PARTIAL_WRITE_REP |\
							WBEM_WRITE_PROVIDER)

#define WBEM_GENERIC_READ         (STANDARD_RIGHTS_READ     |\
                                   WBEM_ENABLE)


#define WBEM_GENERIC_WRITE        (STANDARD_RIGHTS_WRITE    |\
                                   WBEM_FULL_WRITE_REP      |\
                                   WBEM_PARTIAL_WRITE_REP   |\
                                   WBEM_WRITE_PROVIDER)


#define WBEM_GENERIC_EXECUTE      (STANDARD_RIGHTS_EXECUTE  |\
                                   WBEM_METHOD_EXECUTE)

// The following array defines the permission names for WMI.
SI_ACCESS siWMIAccesses[] = 
{
    { &GUID_NULL, WBEM_METHOD_EXECUTE,		MAKEINTRESOURCEW(IDS_WBEM_GENERIC_EXECUTE), SI_ACCESS_GENERAL | SI_ACCESS_CONTAINER },
    { &GUID_NULL, WBEM_FULL_WRITE_REP,		MAKEINTRESOURCEW(IDS_WBEM_FULL_WRITE),		SI_ACCESS_GENERAL | SI_ACCESS_CONTAINER },
    { &GUID_NULL, WBEM_PARTIAL_WRITE_REP,	MAKEINTRESOURCEW(IDS_WBEM_PARTIAL_WRITE),	SI_ACCESS_GENERAL | SI_ACCESS_CONTAINER },
    { &GUID_NULL, WBEM_WRITE_PROVIDER,		MAKEINTRESOURCEW(IDS_WBEM_PROVIDER_WRITE),  SI_ACCESS_GENERAL | SI_ACCESS_CONTAINER },
    { &GUID_NULL, WBEM_ENABLE,				MAKEINTRESOURCEW(IDS_WBEM_ENABLE),			SI_ACCESS_GENERAL | SI_ACCESS_CONTAINER },
    { &GUID_NULL, WBEM_REMOTE_ENABLE,		MAKEINTRESOURCEW(IDS_WBEM_REMOTE_ENABLE),	SI_ACCESS_GENERAL | SI_ACCESS_CONTAINER },
    { &GUID_NULL, READ_CONTROL,				MAKEINTRESOURCEW(IDS_WBEM_READ_SECURITY),   SI_ACCESS_GENERAL | SI_ACCESS_CONTAINER },
    { &GUID_NULL, WRITE_DAC,				MAKEINTRESOURCEW(IDS_WBEM_EDIT_SECURITY),   SI_ACCESS_GENERAL | SI_ACCESS_CONTAINER },
    { &GUID_NULL, 0,						MAKEINTRESOURCEW(IDS_NONE),                 0 }
};
#define iWMIDefAccess      4   // FILE_GENERAL_READ_EX

SI_ACCESS siWMIAccessesAdvanced[] = 
{
    { &GUID_NULL, WBEM_METHOD_EXECUTE,		MAKEINTRESOURCEW(IDS_WBEM_GENERIC_EXECUTE), SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WBEM_FULL_WRITE_REP,		MAKEINTRESOURCEW(IDS_WBEM_FULL_WRITE),		SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WBEM_PARTIAL_WRITE_REP,	MAKEINTRESOURCEW(IDS_WBEM_PARTIAL_WRITE),	SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WBEM_WRITE_PROVIDER,		MAKEINTRESOURCEW(IDS_WBEM_PROVIDER_WRITE),  SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WBEM_ENABLE,				MAKEINTRESOURCEW(IDS_WBEM_ENABLE),			SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WBEM_REMOTE_ENABLE,		MAKEINTRESOURCEW(IDS_WBEM_REMOTE_ENABLE),	SI_ACCESS_SPECIFIC },
    { &GUID_NULL, READ_CONTROL,				MAKEINTRESOURCEW(IDS_WBEM_READ_SECURITY),   SI_ACCESS_SPECIFIC },
    { &GUID_NULL, WRITE_DAC,				MAKEINTRESOURCEW(IDS_WBEM_EDIT_SECURITY),   SI_ACCESS_SPECIFIC },
    { &GUID_NULL, 0,						MAKEINTRESOURCEW(IDS_NONE),                 0 }
};
#define iWMIDefAccessAdvanced      4   // FILE_GENERAL_READ_EX

SI_INHERIT_TYPE siWMIInheritTypes[] =
{
    &GUID_NULL, 0,                                        MAKEINTRESOURCEW(IDS_WBEM_NAMESPACE),
    &GUID_NULL, CONTAINER_INHERIT_ACE,                    MAKEINTRESOURCEW(IDS_WBEM_NAMESPACE_SUBNAMESPACE),
    &GUID_NULL, INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE, MAKEINTRESOURCEW(IDS_WBEM_SUBNAMESPACE_ONLY),
};

GENERIC_MAPPING WMIMap =
{
    WBEM_GENERIC_READ,
    WBEM_GENERIC_WRITE,
    WBEM_GENERIC_EXECUTE,
    WBEM_ALL_ACCESS
};


//---------------------------------------------------------------
CSDSecurity::CSDSecurity(struct NSNODE *nsNode,
						 _bstr_t server,
						 bool local)
									  : m_nsNode(nsNode),
									    m_server(server),
										m_local(local),
										m_pSidOwner(NULL),
										m_pSidGroup(NULL)
{
}

//------------------ Accessors to the above arrays---------------
//---------------------------------------------------------------
HRESULT CSDSecurity::MapGeneric(const GUID *pguidObjectType,
								  UCHAR *pAceFlags,
								  ACCESS_MASK *pMask)
{
    *pAceFlags &= ~OBJECT_INHERIT_ACE;
    MapGenericMask(pMask, &WMIMap);

	return S_OK;
}

//-----------------------------------------------------------------------------
HRESULT CSDSecurity::GetInheritTypes(PSI_INHERIT_TYPE *ppInheritTypes,
										ULONG *pcInheritTypes)
{
    *ppInheritTypes = siWMIInheritTypes;
    *pcInheritTypes = ARRAYSIZE(siWMIInheritTypes);

	return S_OK;
}

//---------------------------------------------------
LPWSTR CSDSecurity::CloneWideString(_bstr_t pszSrc ) 
{
    LPWSTR pszDst = NULL;

    pszDst = new WCHAR[(lstrlen(pszSrc) + 1)];
    if (pszDst) 
	{
        wcscpy( pszDst, pszSrc );
    }

    return pszDst;
}


//-----------------------------------------------------------------------------
HRESULT CSDSecurity::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
{
//    ATLASSERT(pObjectInfo != NULL &&
//             !IsBadWritePtr(pObjectInfo, sizeof(*pObjectInfo)));

	pObjectInfo->dwFlags = SI_EDIT_PERMS | /*SI_EDIT_OWNER |*/	// dacl, owner pages.
							SI_ADVANCED | SI_CONTAINER | 
							SI_NO_TREE_APPLY | SI_NO_ACL_PROTECT;

	USES_CONVERSION;

	// NOTE: This weirdness is so nt4sp5+ can put up the 
	//    user browser for Add User.
	if(m_local)
	{
		pObjectInfo->pszServerName = NULL;
	}
	else
	{
		// NOTE: NT4 seems to want the "\\" and w2k doesn't care.
		bstr_t temp(_T("\\\\"));
		temp += m_server;
		pObjectInfo->pszServerName = CloneWideString(temp);
	}
    pObjectInfo->hInstance = HINST_THISDLL;
    pObjectInfo->pszObjectName = CloneWideString(m_nsNode->display);

    return S_OK;
}

//-----------------------------------------------------------------------------

HRESULT CSDSecurity::GetAccessRights(const GUID *pguidObjectType,
									  DWORD dwFlags,
									  PSI_ACCESS *ppAccess,
									  ULONG *pcAccesses,
									  ULONG *piDefaultAccess)
{
	// dwFlags is zero if the basic security page is being initialized,
	// Otherwise, it is a combination of the following values:
	//    SI_ADVANCED  - Advanced sheet is being initialized.
	//    SI_EDIT_AUDITS - Advanced sheet includes the Audit property page.
	//    SI_EDIT_PROPERTIES - Advanced sheet enables editing of ACEs that
	//                         apply to object's properties and property sets

	// We only currently support '0' or 'SI_ADVANCED'
	ATLASSERT(0 == dwFlags || SI_ADVANCED == dwFlags);
	if(0 == dwFlags)
	{
		*ppAccess = siWMIAccesses;
		*pcAccesses = ARRAYSIZE(siWMIAccesses);
		*piDefaultAccess = iWMIDefAccess;
	}
	else
	{
		*ppAccess = siWMIAccessesAdvanced;
		*pcAccesses = ARRAYSIZE(siWMIAccessesAdvanced);
		*piDefaultAccess = iWMIDefAccessAdvanced;
	}

	return S_OK;
}

//------------------ Real workers -------------------------------
//---------------------------------------------------------------
#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))
#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

/*  Commenting out since winbase.h makes one available for 0x0500 and above

BOOL WINAPI SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR psd,
										 SECURITY_DESCRIPTOR_CONTROL wControlMask,
										 SECURITY_DESCRIPTOR_CONTROL wControlBits)
{
    DWORD dwErr = NOERROR;
    PISECURITY_DESCRIPTOR pSD = (PISECURITY_DESCRIPTOR)psd;

    if (pSD)
        pSD->Control = (pSD->Control & ~wControlMask) | wControlBits;
    else
        dwErr = ERROR_INVALID_PARAMETER;

    return dwErr;
}
*/

void CSDSecurity::ProtectACLs(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD)
{
    SECURITY_DESCRIPTOR_CONTROL wSDControl;
    DWORD dwRevision;
    PACL pAcl;
    BOOL bDefaulted;
    BOOL bPresent;
    PACE_HEADER pAce;
    UINT cAces;


    if (0 == si || NULL == pSD)
        return;   // Nothing to do

    // Get the ACL protection control bits
    GetSecurityDescriptorControl(pSD, &wSDControl, &dwRevision);
    wSDControl &= SE_DACL_PROTECTED | SE_SACL_PROTECTED;

    if ((si & DACL_SECURITY_INFORMATION) && !(wSDControl & SE_DACL_PROTECTED))
    {
        wSDControl |= SE_DACL_PROTECTED;
        pAcl = NULL;
        GetSecurityDescriptorDacl(pSD, &bPresent, &pAcl, &bDefaulted);

        // Theoretically, modifying the DACL in this way can cause it to be
        // no longer canonical.  However, the only way this can happen is if
        // there is an inherited Deny ACE and a non-inherited Allow ACE.
        // Since this function is only called for root objects, this means
        // a) the server DACL must have a Deny ACE and b) the DACL on this
        // object must have been modified later.  But if the DACL was
        // modified through the UI, then we would have eliminated all of the
        // Inherited ACEs already.  Therefore, it must have been modified
        // through some other means.  Considering that the DACL originally
        // inherited from the server never has a Deny ACE, this situation
        // should be extrememly rare.  If it ever does happen, the ACL
        // Editor will just tell the user that the DACL is non-canonical.
        //
        // Therefore, let's ignore the possibility here.

        if (NULL != pAcl)
        {
            for (cAces = pAcl->AceCount, pAce = (PACE_HEADER)FirstAce(pAcl);
                 cAces > 0;
                 --cAces, pAce = (PACE_HEADER)NextAce(pAce))
            {
                pAce->AceFlags &= ~INHERITED_ACE;
            }
        }
    }

    if ((si & SACL_SECURITY_INFORMATION) && !(wSDControl & SE_SACL_PROTECTED))
    {
        wSDControl |= SE_SACL_PROTECTED;
        pAcl = NULL;
        GetSecurityDescriptorSacl(pSD, &bPresent, &pAcl, &bDefaulted);

        if (NULL != pAcl)
        {
            for (cAces = pAcl->AceCount, pAce = (PACE_HEADER)FirstAce(pAcl);
                 cAces > 0;
                 --cAces, pAce = (PACE_HEADER)NextAce(pAce))
            {
                pAce->AceFlags &= ~INHERITED_ACE;
            }
        }
    }

    SetSecurityDescriptorControl(pSD, SE_DACL_PROTECTED | SE_SACL_PROTECTED, wSDControl);
}

//---------------------------------------------------------------
HRESULT CSDSecurity::GetSecurity(THIS_ SECURITY_INFORMATION RequestedInformation,
									PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
									BOOL fDefault )
{
//    ATLASSERT(ppSecurityDescriptor != NULL);

    HRESULT hr = E_FAIL;

    *ppSecurityDescriptor = NULL;

    if(fDefault)
	{
        ATLTRACE(_T("Default security descriptor not supported"));
		return E_NOTIMPL;
	}

	// does it want something?
    if(RequestedInformation != 0)
    {
		if(m_pSidOwner != NULL)
		{
			BYTE *p = (LPBYTE)m_pSidOwner;
			delete []p;
			m_pSidOwner = NULL;
		}

		if(m_pSidGroup != NULL)
		{
			BYTE *p = (LPBYTE)m_pSidGroup;
			delete []p;
			m_pSidGroup = NULL;
		}

		switch(m_nsNode->sType)
		{
			case TYPE_NAMESPACE:
			{

				CWbemClassObject _in;
				CWbemClassObject _out;

				hr = m_nsNode->ns->GetMethodSignatures("__SystemSecurity", "GetSD",
														_in, _out);

				if(SUCCEEDED(hr))
				{
					hr = m_nsNode->ns->ExecMethod("__SystemSecurity", "GetSD",
													_in, _out);

					if(SUCCEEDED(hr))
					{
						HRESULT hr1 = HRESULT_FROM_NT(_out.GetLong("ReturnValue"));
						if(FAILED(hr1))
						{
							hr = hr1;
						}
						else
						{
							_out.GetBLOB("SD", (LPBYTE *)ppSecurityDescriptor);
							hr = InitializeOwnerandGroup(ppSecurityDescriptor);
						}
					}
				}
				break;
			}
			case TYPE_STATIC_INSTANCE:
			{
				m_nsNode->pclsObj->GetBLOB("__SD",(LPBYTE *)ppSecurityDescriptor);
				hr = InitializeOwnerandGroup(ppSecurityDescriptor);
				break;
			}
		}

    }
    else
    {
        *ppSecurityDescriptor = LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);

        if(*ppSecurityDescriptor)
            InitializeSecurityDescriptor(*ppSecurityDescriptor, 
											SECURITY_DESCRIPTOR_REVISION);
        else
            hr = E_OUTOFMEMORY;
    }

	//ProtectACLs(RequestedInformation, *ppSecurityDescriptor);
    return hr;
}

//-----------------------------------------------------------------------------
#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))
#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

HRESULT CSDSecurity::SetSecurity(SECURITY_INFORMATION SecurityInformation,
									PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    HRESULT hr = E_FAIL;

	// dont pass the SI_OWNER_RECURSE bit to wbem.
//    SecurityInformation &= ~(OWNER_SECURITY_INFORMATION | SI_OWNER_RECURSE);

	// if something was changed...
    if(SecurityInformation != 0)
	{
		// set the CONTAINER_INHERIT_ACE bit.
		if(SecurityInformation & DACL_SECURITY_INFORMATION)
		{
			PACL pAcl = NULL;
			BOOL bDefaulted;
			BOOL bPresent;
			PACE_HEADER pAce;
			UINT cAces;

			GetSecurityDescriptorDacl(pSecurityDescriptor, &bPresent, &pAcl, &bDefaulted);

			if(NULL != pAcl)
			{
				for(cAces = pAcl->AceCount, pAce = (PACE_HEADER)FirstAce(pAcl);
					 cAces > 0;
					 --cAces, pAce = (PACE_HEADER)NextAce(pAce))
				{
						 // Make sure we don't get 'object inherit'
						 // This happens when creating a new ace from advance page
						 pAce->AceFlags &= ~OBJECT_INHERIT_ACE; 
				}
			}
		}

		SECURITY_DESCRIPTOR *pSD = NULL;

		// ACLUI sends absolute format so change to self-relative so the
		// PutBLOB() has contiguous memory to copy.
		DWORD srLen = 0;
		SetLastError(0);
		BOOL bCheck;
		if(m_pSidOwner != NULL)
		{
			bCheck = SetSecurityDescriptorOwner(pSecurityDescriptor,m_pSidOwner,m_bOwnerDefaulted);
			if(bCheck == FALSE)
			{
				return E_FAIL;
			}
		}

		if(m_pSidGroup != NULL)
		{
			bCheck = SetSecurityDescriptorGroup(pSecurityDescriptor,m_pSidGroup,m_bGroupDefaulted);

			if(bCheck == FALSE)
			{
				return E_FAIL;
			}
		}			

		// get the size needed.
		BOOL x1 = MakeSelfRelativeSD(pSecurityDescriptor, NULL, &srLen);

		DWORD eee = GetLastError();

		pSD = (SECURITY_DESCRIPTOR *)LocalAlloc(LPTR, srLen);
			
		if(pSD)
		{
			BOOL converted = MakeSelfRelativeSD(pSecurityDescriptor, pSD, &srLen);
			hr = S_OK;
		}
		else
		{
			hr = E_OUTOFMEMORY;
			return hr;
		}

		switch(m_nsNode->sType)
		{
			case TYPE_NAMESPACE:
			{
				CWbemClassObject _in;
				CWbemClassObject _out;

				hr = m_nsNode->ns->GetMethodSignatures("__SystemSecurity", "SetSD",
												_in, _out);
				if(SUCCEEDED(hr))
				{
					_in.PutBLOB("SD", (LPBYTE)pSD, GetSecurityDescriptorLength(pSD));

					hr = m_nsNode->ns->ExecMethod("__SystemSecurity", "SetSD",
											_in, _out);
					if(SUCCEEDED(hr))
					{
						HRESULT hr1 = HRESULT_FROM_NT(_out.GetLong("ReturnValue"));
						if(FAILED(hr1))
						{
							hr = hr1;
						}
					}
				}
				m_nsNode->ns->DisconnectServer();
				m_nsNode->ns->ConnectServer(m_nsNode->fullPath);
				break;
			}
			case TYPE_STATIC_INSTANCE:
			{
				m_nsNode->pclsObj->PutBLOB("__SD",(LPBYTE)pSD, GetSecurityDescriptorLength(pSD));
				//Now put the instance back
				hr = m_nsNode->ns->PutInstance(*(m_nsNode->pclsObj)/*,flag*/);
				delete m_nsNode->pclsObj;
				*(m_nsNode->pclsObj) = m_nsNode->ns->GetObject(m_nsNode->relPath/*,flag*/);
				break;
			}
		}
		// HACK: because of how the core caches/uses security, I have to close &
		// reopen my connection because GetSecurity() will be immediately called
		// to refresh the UI. If I dont do this, GetSecurity() will return to old
		// security settings even though they're really saved. 
		if(m_pSidOwner != NULL)
		{
			BYTE *p = (LPBYTE)m_pSidOwner;
			delete []p;
			m_pSidOwner = NULL;
		}

		if(m_pSidGroup != NULL)
		{
			BYTE *p = (LPBYTE)m_pSidGroup;
			delete []p;
			m_pSidGroup = NULL;
		}
	}

    return hr;
}

HRESULT CSDSecurity::InitializeOwnerandGroup(PSECURITY_DESCRIPTOR *ppSecurityDescriptor)
{

	SID *pSid;
	BOOL bDefaulted;

    BOOL bCheck = GetSecurityDescriptorOwner(*ppSecurityDescriptor,
                                        (void **)&pSid,&m_bOwnerDefaulted);
	if(bCheck == TRUE)
	{
        if (pSid != NULL)
        {
		    m_nLengthOwner = GetSidLengthRequired(pSid->SubAuthorityCount);

		    if(m_pSidOwner != NULL)
		    {
			    BYTE *p = (LPBYTE)m_pSidOwner;
			    delete []p;
			    m_pSidOwner = NULL;
		    }

		    m_pSidOwner = (SID *)new BYTE[m_nLengthOwner];

		    if(m_pSidOwner == NULL ||
               CopySid(m_nLengthOwner,m_pSidOwner,pSid) == FALSE)
		    {
                delete m_pSidOwner;
			    m_pSidOwner = NULL;
			    m_nLengthOwner = -1;
			    return E_FAIL;
		    }
        }
        else
        {
            m_pSidOwner    = NULL;
            m_nLengthOwner = 0;
        }
	}
	else
	{
		m_pSidOwner = NULL;
		m_nLengthOwner = -1;
		return E_FAIL;
	}

	SID *pGroup;

    bCheck = GetSecurityDescriptorGroup(*ppSecurityDescriptor,
                                    (void **)&pGroup,&m_bGroupDefaulted);

	if(bCheck == TRUE)
	{
        if (pGroup != NULL)
        {
		    m_nLengthGroup = GetSidLengthRequired(pGroup->SubAuthorityCount);

		    if(m_pSidGroup != NULL)
		    {
			    BYTE *p = (LPBYTE)m_pSidGroup;
			    delete []p;
			    m_pSidGroup = NULL;
		    }

		    m_pSidGroup = (SID *)new BYTE[m_nLengthGroup];

		    if(m_pSidGroup == NULL ||
               CopySid(m_nLengthGroup,m_pSidGroup,pGroup) == FALSE)
		    {
                delete m_pSidGroup;
			    m_pSidGroup = NULL;
			    m_nLengthGroup = -1;
			    return E_FAIL;
            }
        }
        else
        {
            m_pSidGroup    = NULL;
            m_nLengthGroup = 0;
        }
	}
	else
	{
		m_pSidGroup = NULL;
		m_nLengthGroup = -1;
		return E_FAIL;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\uihelpers.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef _UIHELPERS_H_
#define _UIHELPERS_H_

#include "..\common\sshWbemHelpers.h"
#include <windowsx.h>
#include "PageBase.h"

// supports the page coordinating routines.
#define PB_LOGGING 0
#define PB_BACKUP 1
#define PB_ADVANCED 2
#define PB_LASTPAGE 2


extern const TCHAR c_HelpFile[];


typedef struct {
	LPTSTR lpName;
	UINT cName;
	bool *local;
	LOGIN_CREDENTIALS *credentials;
} CONN_NAME;


class WbemServiceThread;
class DataSource;

void CredentialUserA(LOGIN_CREDENTIALS *credentials, char **user);
void CredentialUserW(LOGIN_CREDENTIALS *credentials, wchar_t **user);

#ifdef UNICODE
#define CredentialUser CredentialUserW
#else
#define CredentialUser CredentialUserA
#endif

// 0 means any version of NT will do.
bool IsNT(DWORD ver = 0);

//-------------------------------------------------------------------
// NOTE: These 'sid' routines came from \winmgmt\common\wbemntsec.*.
class CNtSid
{
    PSID    m_pSid;
    LPTSTR  m_pMachine;
    LPTSTR  m_pDomain;
    DWORD   m_dwStatus;

public:
    enum {NoError, Failed, NullSid, InvalidSid, InternalError, AccessDenied = 0x5};

    enum SidType {CURRENT_USER, CURRENT_THREAD};

    CNtSid(SidType st);
   ~CNtSid();

    BOOL IsValid() { return (m_pSid && IsValidSid(m_pSid)); }
        // Checks the validity of the internal SID.
    
    int GetInfo(LPTSTR *pRetAccount,        // Account, use operator delete
				LPTSTR *pRetDomain,         // Domain, use operator delete
				DWORD  *pdwUse);            // See SID_NAME_USE for values
				
};


class CUIHelpers : public CBasePage
{
public:
    CUIHelpers(DataSource *ds, WbemServiceThread *serviceThread, bool htmlSupport);
    CUIHelpers(CWbemServices &service, bool htmlSupport);
    virtual ~CUIHelpers( void );

	CONN_NAME m_cfg;
	bool m_ImaWizard;
	static INT_PTR DisplayCompBrowser(HWND hWnd,
						LPTSTR lpName, UINT cName,
						bool *local, LOGIN_CREDENTIALS *credentials);

protected:

	void SetWbemService(IWbemServices *pServices);
	long m_sessionID;

	void HTMLHelper(HWND hDlg);
	bool m_htmlSupport;

#define NO_UI 0  // for uCaption
	bool ServiceIsReady(UINT uCaption, 
						UINT uWaitMsg,
						UINT uBadMsg);

#ifndef SNAPIN
	INT_PTR DisplayLoginDlg(HWND hWnd, 
						LOGIN_CREDENTIALS *credentials);
#endif

	INT_PTR DisplayNSBrowser(HWND hWnd,
							LPTSTR lpName, UINT cName);

	INT_PTR DisplayEditDlg(HWND hWnd,
						UINT idCaption,
						UINT idMsg,
						LPTSTR lpEdit,
						UINT cEdit);

	bool BrowseForFile(HWND hDlg, 
						UINT idTitle,
						LPCTSTR lpstrFilter,
						LPCTSTR initialFile,
						LPTSTR pathFile,
						UINT pathFileSize,
						DWORD moreFlags = 0);

	LPTSTR CloneString( LPTSTR pszSrc );

	HWND m_AVIbox;
	INT_PTR DisplayAVIBox(HWND hWnd,
						LPCTSTR lpCaption,
						LPCTSTR lpClientMsg,
						HWND *boxHwnd,
						BOOL cancelBtn = TRUE);


	// call when a control changes. It sends the PSM_CHANGED for you.
	void PageChanged(int page, bool needToPut);

	// call from OnApply(). Caches property Puts into one PutInstance.
	// It sends the PSM_UNCHANGED for you.
	HRESULT NeedToPut(int page, BOOL refresh);

private:
	static int m_needToPut[3];
	bool m_userCancelled; // the connectServer() thread.

};

//===========================================================
class ConnectPage : public CUIHelpers
{
public:
	ConnectPage(DataSource *ds, bool htmlSupport);
	~ConnectPage(void);

private:
	virtual BOOL DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
	bool m_isLocal;
};


#endif  /* _UIHELPERS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\wbemerror.cpp ===
//=============================================================================
//
//                              WbemError.cpp
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//	Implements string table based, error msgs for all of wbem.
//
//  History:
//
//      a-khint  5-mar-98       Created.
//
//============================================================================= 
#include "precomp.h"
#include "WbemError.h"
#include "resource.h"
#include <wbemcli.h>
#include <stdio.h>

//--------------PUBLIC-----------------------------
#define TEMP_BUF 512

POLARITY bool ErrorStringEx(HRESULT hr, 
						   TCHAR *errMsg, UINT errSize,
						   UINT *sevIcon)
{
    TCHAR szError[TEMP_BUF] = {0};
	TCHAR szFacility[TEMP_BUF] = {0};
    TCHAR szFormat[100] = {0};
	IWbemStatusCodeText * pStatus = NULL;

    // initialize buffers.
	errMsg[0] = 0;
	szFacility[0] = 0;
	szError[0] = 0;

	HRESULT hr1 = CoInitialize(NULL);
	SCODE sc1 = CoCreateInstance(CLSID_WbemStatusCodeText, 
								0, CLSCTX_INPROC_SERVER,
								IID_IWbemStatusCodeText, 
								(LPVOID *) &pStatus);

	// loaded OK?
	if(sc1 == S_OK)
	{
		BSTR bstr = 0;
		sc1 = pStatus->GetErrorCodeText(hr, 0, 0, &bstr);
		if(sc1 == S_OK)
		{
#ifdef UNICODE
			wcsncpy(szError, bstr, TEMP_BUF-1);
			size_t x = wcslen(szError);
#else
			size_t x = wcstombs(szError, bstr, TEMP_BUF-1);
#endif
			szError[x-2] = _T('\0');
			SysFreeString(bstr);
			bstr = 0;
		}

		sc1 = pStatus->GetFacilityCodeText(hr, 0, 0, &bstr);
		if(sc1 == S_OK)
		{
#ifdef UNICODE
			wcsncpy(szFacility, bstr, TEMP_BUF-1);
			size_t x = wcslen(szFacility);
#else
			wcstombs(szFacility, bstr, TEMP_BUF-1);
#endif
			SysFreeString(bstr);
			bstr = 0;
		}

		// RELEASE
		pStatus->Release();
		pStatus = NULL;
	}
	else
	{
		::MessageBox(NULL, _T("WMI error features not available. Upgrade WMI to a newer build."),
					 _T("Internal Error"), MB_ICONSTOP|MB_OK);
	}

	// if not msgs returned....
	if(_tcslen(szFacility) == 0 || _tcslen(szError) == 0)
	{
		// format the error nbr as a reasonable default.
		LoadString(_Module.GetModuleInstance(), IDS_ERROR_UNKN_ERROR_FMT, szFormat, 99);
		_stprintf(errMsg, szFormat, hr);
	}
	else
	{
		// format a readable msg.
		LoadString(_Module.GetModuleInstance(), IDS_ERROR_FMT, szFormat, 99);
		_stprintf(errMsg, szFormat, szFacility, szError);
	}

	// want an icon recommendation with that?
	if(sevIcon)
	{
		switch(SCODE_SEVERITY(hr))
		{
		case 0: // - Success
			*sevIcon = MB_ICONINFORMATION;
			break;
		case 1: //- Failed
			*sevIcon = MB_ICONEXCLAMATION;
			break;
		} //endswitch severity

	} //endif sevIcon

	if(hr1 == S_OK)
		CoUninitialize();

	return (SUCCEEDED(sc1) && SUCCEEDED(hr1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\si.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __SECURITYOBJECT__
#define __SECURITYOBJECT__

#include "precomp.h"
#include "..\common\SshWbemHelpers.h"
#include <wbemcli.h>
#include "aclui.h"
#include "DataSrc.h"

struct __declspec(uuid("965FC360-16FF-11d0-91CB-00AA00BBB723")) ISecurityInformation;

// This class just define the interface and creates the aclui tab.
class ATL_NO_VTABLE CSecurityInformation : public ISecurityInformation, 
											public CComObjectRoot
{
protected:
	virtual ~CSecurityInformation();

    DECLARE_NOT_AGGREGATABLE(CSecurityInformation)
    BEGIN_COM_MAP(CSecurityInformation)
        COM_INTERFACE_ENTRY(ISecurityInformation)
    END_COM_MAP()

	// *** ISecurityInformation methods ***
	STDMETHOD(GetObjectInformation)(PSI_OBJECT_INFO pObjectInfo) = 0;

	STDMETHOD(GetSecurity) (THIS_ SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault ) = 0;

	STDMETHOD(SetSecurity)(SECURITY_INFORMATION SecurityInformation,
						 PSECURITY_DESCRIPTOR pSecurityDescriptor) = 0;

	STDMETHOD(GetAccessRights)(const GUID  *pguidObjectType,
							  DWORD       dwFlags,
							  PSI_ACCESS  *ppAccess,
							  ULONG       *pcAccesses,
							  ULONG       *piDefaultAccess) = 0;

	STDMETHOD(MapGeneric)(const GUID  *pguidObjectType,
						  UCHAR       *pAceFlags,
						  ACCESS_MASK *pMask) = 0;

	STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE  *ppInheritTypes,
								ULONG *pcInheritTypes) = 0;

	STDMETHOD(PropertySheetPageCallback)(HWND hwnd, 
									  UINT uMsg, 
									  SI_PAGE_TYPE  uPage);

};


//==========================================================
// This class handles the security descriptors directly. (Nova M3 and later)
class CSDSecurity : public CComObject<CSecurityInformation>
{
public:
	CSDSecurity(struct NSNODE *nsNode,
						 _bstr_t server,
						 bool local);

	// *** ISecurityInformation methods ***
	STDMETHOD(GetObjectInformation)(PSI_OBJECT_INFO pObjectInfo);

    STDMETHOD(GetSecurity) (THIS_ SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault );

	STDMETHOD(SetSecurity)(SECURITY_INFORMATION SecurityInformation,
						 PSECURITY_DESCRIPTOR pSecurityDescriptor);

	STDMETHOD(GetAccessRights)(const GUID  *pguidObjectType,
							  DWORD       dwFlags,
							  PSI_ACCESS  *ppAccess,
							  ULONG       *pcAccesses,
							  ULONG       *piDefaultAccess);

	STDMETHOD(MapGeneric)(const GUID  *pguidObjectType,
						  UCHAR       *pAceFlags,
						  ACCESS_MASK *pMask);

	STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE  *ppInheritTypes,
								ULONG *pcInheritTypes);

	HRESULT InitializeOwnerandGroup(PSECURITY_DESCRIPTOR *ppSecurityDescriptor);
protected:
/*	CWbemServices m_WbemServices;
	_bstr_t m_path;					// for the reconnect trick.
	_bstr_t m_display;
*/	_bstr_t m_server;

	struct NSNODE *m_nsNode;
	bool m_local;
	LPWSTR CloneWideString(_bstr_t pszSrc);
	void ProtectACLs(SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD);
	SID *m_pSidOwner;
	SID *m_pSidGroup;
	DWORD m_nLengthOwner;
	DWORD m_nLengthGroup;
	BOOL m_bOwnerDefaulted;
	BOOL m_bGroupDefaulted;
};


#endif __SECURITYOBJECT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\sources.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=wbemcntl
TARGETPATH=obj

TARGETLIBS= \
	$(WMIIDL_LIB) \
	$(STDLIBRARY_LIB) \
	$(ATLUICOMMON_LIB) \
	$(UTILLIB_LIB) \
	$(SDK_LIB_PATH)\htmlhelp.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\comctl32.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\gdi32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\shell32.lib \
	$(SDK_LIB_PATH)\comdlg32.lib \
	$(SDK_LIB_PATH)\version.lib

INCLUDES=$(INCLUDES); \
	$(ATLUISNAPINS_INC); \
	$(STDLIBRARY_INC); \
	$(ATLUICOMMON_INC)

SOURCES= \
	..\WMICntl.idl \
	..\advPage.cpp \
	..\stdafx.cpp \
	..\BackupPage.cpp \
	..\chklist.cpp \
	..\ChkListHandler.cpp \
	..\DataSrc.cpp \
	..\ErrorSecPage.cpp \
	..\GenPage.cpp \
	..\LogPage.cpp \
	..\NSPage.cpp \
	..\pagebase.cpp \
	..\principal.cpp \
	..\RootSecPage.cpp \
	..\SI.cpp \
	..\UIHelpers.cpp \
	..\WbemError.cpp \
	..\WMICtrSysmonDlg.cpp \
	..\WmiCtrsDlg.cpp \
	..\AsyncObjectSink.cpp

# Next, specify options for the compiler using C_DEFINES.
C_DEFINES=$(C_DEFINES) /DSHARE_SOURCE
WIN32_WINNT_VERSION=0x0501
USE_RTTI=1
USE_NATIVE_EH=ASYNC
USE_VCCOM=1
USE_MSVCRT=1
USE_ATL=1
ATL_VER=30
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\app\aboutdlg.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
class CAboutDlg : public CDialogImpl<CAboutDlg>
{
public:
	enum { IDD = IDD_ABOUTBOX };

	BEGIN_MSG_MAP(CAboutDlg)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER(IDOK, OnCloseCmd)
		COMMAND_ID_HANDLER(IDCANCEL, OnCloseCmd)
	END_MSG_MAP()

	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		CenterWindow(GetParent());
		return TRUE;
	}

	LRESULT OnCloseCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		EndDialog(wID);
		return 0;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\app\nspicker.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "NSPicker.h"

// Help IDs
/*DWORD aAdvancedHelpIds[] = {
    IDC_ADV_PERF_ICON,             (IDH_ADVANCED + 0),
    0, 0
};
*/

//------------------------------------------------------
CNSPicker::CNSPicker(CWbemServices &root) :
						m_WbemService(root)
{
}

//------------------------------------------------------
CNSPicker::~CNSPicker(void)
{
}

//----------------------------------------------
LRESULT CNSPicker::OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
//	PopulateTree(m_hWnd, IDC_NSTREE, m_WbemService);
	return TRUE;
}

//----------------------------------------------
LRESULT CNSPicker::OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
/*	::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
				_T("sysdm.hlp"),
				HELP_WM_HELP,
				(DWORD)(LPSTR)aAdvancedHelpIds);
*/
	return TRUE;
}

//----------------------------------------------
LRESULT CNSPicker::OnCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	switch(wID)
	{
	case IDOK:
		{
			// save the currently selected fullpath name.
			HWND hTree = ::GetDlgItem(m_hWnd, IDC_NSTREE);
			TV_ITEM item;
			item.mask = TVIF_PARAM;
			item.hItem = m_hSelectedItem;
			BOOL x = TreeView_GetItem(hTree, &item);

			_tcsncpy(m_path, ((ITEMEXTRA *)item.lParam)->fullPath, MAX_PATH);
		}
		EndDialog(IDOK);
		break;

	case IDCANCEL:
		EndDialog(IDCANCEL);
		break;
	}

    return TRUE;
}

//----------------------------------------------
LRESULT CNSPicker::OnSelChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    switch(pnmh->code)
    {
	case TVN_SELCHANGED:
		if(pnmh->idFrom == IDC_NSTREE)
		{
			LPNMTREEVIEW pnmtv = (LPNMTREEVIEW)pnmh;
			m_hSelectedItem = pnmtv->itemNew.hItem;
		}
		break;
    }
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\wmictrsdlg.cpp ===
// WmiCtrsDlg.cpp : implementation file
//

#include "precomp.h"
#include "WmiCtrsDlg.h"
#include "resource.h"
#include <process.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

WCHAR g_szCounters[][40] = {	L"Connections",
								L"DeliveryBackupBytes",
								L"InternalObjects",
								L"InternalSinks",
								L"TasksInProgress",
								L"TasksWaiting",
								L"TotalAPIcalls",
								L"Users"
							};

UINT g_uCtrIds[] =			{	IDC_CONNECTIONS,  
								IDC_DELBACKUP,   
								IDC_INTERNALOBJS, 
								IDC_INTERNALSINKS,
								IDC_TASKSINPROG,  
								IDC_TASKSWAITING, 
								IDC_TOTALAPICALLS,
								IDC_USERS        
							};

/////////////////////////////////////////////////////////////////////////////
// WmiCtrsDlg dialog

CWmiCtrsDlg::CWmiCtrsDlg()
{
	m_pCredentials = NULL;
	_tcscpy(m_szMachineName,_T(""));
	m_pDlg = NULL;
	m_hWndBusy = NULL;
}

CWmiCtrsDlg::CWmiCtrsDlg(LPCTSTR szMachineName, LOGIN_CREDENTIALS *pCredentials)
{
	m_pCredentials = pCredentials;
	_tcscpy(m_szMachineName,szMachineName);
	m_pDlg = NULL;
	m_hWndBusy = NULL;
}

CWmiCtrsDlg::~CWmiCtrsDlg()
{
	if(m_pDlg != NULL)
		delete m_pDlg;
	
	if(m_hWndBusy != NULL)
	{
		//Now close the busy Dialog
		SendMessage(*(m_hWndBusy),WM_CLOSE_BUSY_DLG,0,0);
		delete m_hWndBusy;
	}
}

INT_PTR CWmiCtrsDlg::DoModal(HWND hWnd)
{
	m_bRun = true;
	INT_PTR retVal = DialogBoxParam(_Module.GetModuleInstance(), 
							MAKEINTRESOURCE(IDD_WMICTR), 
							hWnd, CtrDlgProc, 
							(LPARAM)this);

	m_bRun = false;
	return retVal;
}

INT_PTR CALLBACK CtrDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam)
{
	INT_PTR retVal = TRUE;
	CWmiCtrsDlg *pDlg = (CWmiCtrsDlg *)lParam;
	switch(uMsg)
	{
		case WM_INITDIALOG:
		{ 
			pDlg->InitDlg(hwndDlg);
			break;
		}
		case WM_COMMAND :
		{
			switch(LOWORD(wParam))
			{
				case IDOK:
				{
					EndDialog(hwndDlg, IDOK);
					break;
				}
				case IDCANCEL:
				{
					EndDialog(hwndDlg, IDCANCEL);
					break;
				}
				default:
					retVal = FALSE;
			}
			break;
		}
		default:
		{
			retVal = FALSE;
			break;
		}
	}
	return retVal;
}

/////////////////////////////////////////////////////////////////////////////
// CWmiCtrsDlg message handlers

DWORD WINAPI CountersThread(LPVOID lpParameter)
{
	CoInitialize(NULL);
	
	CWmiCtrsDlg *pDlg = (CWmiCtrsDlg *)lpParameter;

	CWbemServices Services;

	TCHAR nameSpace[1024];

	// if machine is whacked already...
	if(_tcsncmp(pDlg->m_szMachineName, _T("\\"), 1) == 0)
	{
		// use it.
		_tcscpy(nameSpace,pDlg->m_szMachineName);
		_tcscat(nameSpace,_T("\\root\\CimV2"));
	}
	else if(_tcslen(pDlg->m_szMachineName) > 0)
	{
		// whack it myself.
		_tcscpy(nameSpace,_T("\\\\"));
		_tcscat(nameSpace,pDlg->m_szMachineName);
		_tcscat(nameSpace,_T("\\root\\CimV2"));
	}
	else
	{
		_tcscpy(nameSpace,_T("root\\CimV2"));
	}

	HRESULT hr = Services.ConnectServer(nameSpace,pDlg->m_pCredentials);

	if(FAILED(hr))
	{
		//Display a MessageBox to the user that the connection has been failed
		pDlg->DisplayErrorMessage(IDC_ERROR_CONNECT);
		return 0;
	}
	
	//Now try to Get the instances of the class Win32_PerfRawData_WinMgmt_WINMGMTCounters
	IEnumWbemClassObject *Enum = NULL;
	ULONG uReturned;
	
	IWbemClassObject *pInst = NULL;
	hr = Services.CreateInstanceEnum(L"Win32_PerfRawData_WinMgmt_WINMGMTCounters",
													WBEM_FLAG_SHALLOW,
													&Enum);

	if(SUCCEEDED(hr))
	{
		// get the first and only instance.
		Enum->Next(-1, 1, &pInst, &uReturned);
		Enum->Release();
	}
	else
	{
		pDlg->DisplayErrorMessage(IDC_ERROR_ENUM);
		return 0;
	}

	if(pDlg->m_hWndBusy != NULL)
	{
		//Now close the nusy Dialog
		SendMessage(*(pDlg->m_hWndBusy),WM_CLOSE_BUSY_DLG,0,0);
	}

	int i;
	VARIANT vt;
	TCHAR strVal[1024];
	VariantInit(&vt);

	while(pDlg->m_bRun == true)
	{
		for(i=0; i < NUM_COUNTERS; i++)
		{
			VariantClear(&vt);
			hr = pInst->Get(g_szCounters[i],0,&vt,NULL,NULL);
/*			if(FAILED(hr))
			{
				::MessageBox(NULL,_T("error"),_T("Unable to get"),MB_OK);
			}
*/			_itot(vt.lVal,strVal,10);
			SetWindowText(pDlg->m_hWndCounters[i],strVal);
		}

		Sleep(900);
	}

	Services.DisconnectServer();

	return 1;
}

void CWmiCtrsDlg::InitDlg(HWND hDlg)
{
	DWORD dwThreadId;
	
	//Do the member Initializations
	m_pDlg = new HWND;
	if (!m_pDlg)
    		return;
	*m_pDlg = hDlg;
	m_hWndBusy = new HWND;
	::LoadString(_Module.GetModuleInstance(), IDC_ERROR_CAPTION, m_szError, 100);

	for(int i=0;i < NUM_COUNTERS; i++)
	{
		m_hWndCounters[i] = GetDlgItem(hDlg,g_uCtrIds[i]);
	}

	m_hThread = CreateThread(NULL,0,CountersThread,(LPVOID)this,0,&dwThreadId);

	//Now Display the "Connecting to WMI" Dialog
	DisplayBusyDialog(hDlg);
}

void CWmiCtrsDlg::DisplayErrorMessage(UINT ErrorId)
{

	TCHAR szErrorText[1024];
	if(m_hWndBusy != NULL)
	{
		//Now close the busy Dialog
		SendMessage(*(m_hWndBusy),WM_CLOSE_BUSY_DLG,0,0);
	}
	::LoadString(_Module.GetModuleInstance(), ErrorId, szErrorText, 1024);
	EndDialog(*m_pDlg,IDCANCEL);
	::MessageBox(NULL,szErrorText,m_szError,MB_OK);
}	

INT_PTR CALLBACK BusyDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam)
{
	BOOL retval = FALSE;
	switch(uMsg)
	{
		case WM_INITDIALOG:
		{//BEGIN
			//lParam = ANIMCONFIG *
			CWmiCtrsDlg *pDlg = (CWmiCtrsDlg *)lParam;
			SetWindowLongPtr(hwndDlg, DWLP_USER, (LPARAM)pDlg);
			*(pDlg->m_hWndBusy) = hwndDlg;

			HWND hAnim = GetDlgItem(hwndDlg, IDC_ANIMATE);
			HWND hMsg = GetDlgItem(hwndDlg, IDC_MSG);

			Animate_Open(hAnim, MAKEINTRESOURCE(IDR_AVIWAIT));

			TCHAR caption[100] = {0}, msg[256] = {0};

			::LoadString(_Module.GetModuleInstance(), IDS_DISPLAY_NAME, caption, 100);

			::LoadString(_Module.GetModuleInstance(), IDS_CONNECTING, msg, 256);

			SetWindowText(hwndDlg, caption);
			SetWindowText(hMsg, msg);

			retval = TRUE;
			break;
		}
		case WM_CLOSE_BUSY_DLG:
		{
			HWND *me = (HWND *)GetWindowLongPtr(hwndDlg, DWLP_USER);
			*me = 0;
			EndDialog(hwndDlg, IDCANCEL);
			break;
		}
		case WM_COMMAND:
		{
			// they're only one button.
			if(HIWORD(wParam) == BN_CLICKED)
			{
				// I'm going away now so anybody that has a ptr to my
				// hwnd (which I gave out in my WM_INITDIALOG) shouldn't
				// use it anymore.
				HWND *me = (HWND *)GetWindowLongPtr(hwndDlg, DWLP_USER);
				*me = 0;
				EndDialog(hwndDlg, IDCANCEL);
			}
			retval = TRUE; // I processed it.
			break;
		}
		case WM_DESTROY:
		{// BEGIN
			// I'm going away now so anybody that has a ptr to my
			// hwnd (which I gave out in my WM_INITDIALOG) shouldn't
			// use it anymore.
			HWND *me = (HWND *)GetWindowLongPtr(hwndDlg, DWLP_USER);
			*me = 0;
			retval = TRUE; // I processed it.
			break;
		} //END
		default:
		{
			retval = FALSE; // I did NOT process this msg.
			break;
		}
	} //endswitch uMsg

	return retval;
}

INT_PTR CWmiCtrsDlg::DisplayBusyDialog(HWND hWnd)
{
	return DialogBoxParam(_Module.GetModuleInstance(), 
							MAKEINTRESOURCE(IDD_ANIMATE), 
							NULL, BusyDlgProc, 
							(LPARAM)this);
}

void CWmiCtrsDlg::CloseBusyDialog()
{
	if(m_hWndBusy != NULL)
	{
		//Now close the nusy Dialog
		SendMessage(*(m_hWndBusy),WM_CLOSE_BUSY_DLG,0,0);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\app\nspicker.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef _NSPICKER_H_
#define _NSPICKER_H_
#pragma once

#include "resource.h"
#include "sshWbemHelpers.h"

//-----------------------------------------------------------------------------
class CNSPicker : public CUIHelpers
{
private:
	// Handler prototypes:
	LRESULT OnInit(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnContextHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnSelChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
	LRESULT OnCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	CWbemServices m_WbemService;
	HTREEITEM m_hSelectedItem;

public:
	CNSPicker(CWbemServices &root);
	~CNSPicker(void);

	int DoModal(HWND hDlg);
	BOOL CALLBACK DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);

	TCHAR m_path[MAX_PATH];
};

BOOL CALLBACK StaticPickerDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);

#endif _NSPICKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\app\simplearray.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#if (_ATL_VER < 0x0300)
/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CSimpleArray & CSimpleMap

#ifndef __SIMPLEARRAY__
#define __SIMPLEARRAY__

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

template <class T>
class CSimpleArray
{
public:
	T* m_aT;
	int m_nSize;
	int m_nAllocSize;

// Construction/destruction
	CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
	{ }

	~CSimpleArray()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(T& t)
	{
		if(m_nSize == m_nAllocSize)
		{
			T* aT;
			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
			aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
			if(aT == NULL)
				return FALSE;
			m_nAllocSize = nNewAllocSize;
			m_aT = aT;
		}
		m_nSize++;
		SetAtIndex(m_nSize - 1, t);
		return TRUE;
	}
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(int nIndex)
	{
		if(nIndex != (m_nSize - 1))
			memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aT != NULL)
		{
			free(m_aT);
			m_aT = NULL;
		}
		m_nSize = 0;
		m_nAllocSize = 0;
	}
	T& operator[] (int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aT[nIndex];
	}
	T* GetData() const
	{
		return m_aT;
	}

// Implementation
	void SetAtIndex(int nIndex, T& t)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_aT[nIndex] = t;
	}
	int Find(T& t) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;	// not found
	}
};
#endif __SIMPLEARRAY__

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\snapin\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\wmictrsdlg.h ===
#if !defined(AFX_WMICTRSDLG_H__676668D2_5328_47AA_B52D_C85A39D60E7D__INCLUDED_)
#define AFX_WMICTRSDLG_H__676668D2_5328_47AA_B52D_C85A39D60E7D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WmiCtrsDlg.h : header file
//
#include "SshWbemHelpers.h"

#define NUM_COUNTERS	8
#define WM_CLOSE_BUSY_DLG	WM_USER+1976

INT_PTR CALLBACK CtrDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam);

DWORD WINAPI CountersThread(LPVOID lpParameter);

INT_PTR CALLBACK BusyDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam);

typedef struct {
	bool currUser;
	COAUTHIDENTITY *authIdent;
	TCHAR fullAcct[100];
} CREDENTIALS;

class CWmiCtrsDlg
{
// Construction
public:
	CWmiCtrsDlg();
    CWmiCtrsDlg(LPCTSTR szMachineName, LOGIN_CREDENTIALS *credentials);
    virtual ~CWmiCtrsDlg(void);

	friend INT_PTR CALLBACK CtrDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam);

	friend DWORD WINAPI CountersThread(LPVOID lpParameter);

	friend INT_PTR CALLBACK BusyDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam);

	INT_PTR DoModal(HWND hWnd);

	INT_PTR DisplayBusyDialog(HWND hWnd);
	void CloseBusyDialog();

protected:
    void InitDlg(HWND hDlg);
	void DisplayErrorMessage(UINT ErrorId);

	bool m_bRun;
	HANDLE m_hThread;
	TCHAR m_szMachineName[1024];
	LOGIN_CREDENTIALS *m_pCredentials;
	HWND *m_pDlg;
	HWND *m_hWndBusy;
	TCHAR m_szError[1024];
	HWND m_hWndCounters[NUM_COUNTERS];
};

#endif // !defined(AFX_WMICTRSDLG_H__676668D2_5328_47AA_B52D_C85A39D60E7D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\uihelpers.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "UIHelpers.h"
#include "DataSrc.h"
#include "resource.h"
#include <cominit.h>
#include "WMIHelp.h"
#include <HTMLHelp.h>
#include <prsht.h>
#include "WbemError.h"

#ifdef SNAPIN
const TCHAR c_HelpFile[] = _T("newfeat1.hlp");
#else
const TCHAR c_HelpFile[] = _T("WbemCntl.hlp");
#endif


//-------------------------------------------------------------------
bool IsNT(DWORD  ver /* = 0 */)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen

	if(os.dwPlatformId != VER_PLATFORM_WIN32_NT)
	{
		return false;
	}
	else if(ver == 0)
	{
		// any version of NT will do.
		return true;
	}
	else
	{
		return (os.dwMajorVersion == ver);
	}
}


//-------------------------------------------------------------------
CNtSid::CNtSid(SidType st)
{
    m_pSid = 0;
    m_dwStatus = InternalError;
    m_pMachine = 0;

    if(st == CURRENT_USER ||st == CURRENT_THREAD)
    {
        HANDLE hToken;
		if(st == CURRENT_USER)
		{
			if(!OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken))
	            return;
		}
		else
		{
			if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
	            return;
		}

        // Get the user sid
        // ================

        TOKEN_USER tu;
        DWORD dwLen = 0;
        GetTokenInformation(hToken, TokenUser, &tu, sizeof(tu), &dwLen);

        if(dwLen == 0)
        {
            CloseHandle(hToken);
            return;
        }

        BYTE* pTemp = new BYTE[dwLen];
        if (!pTemp)
        {
            CloseHandle(hToken);
            return;
        }

        DWORD dwRealLen = dwLen;
        if(!GetTokenInformation(hToken, TokenUser, pTemp, dwRealLen, &dwLen))
        {
            CloseHandle(hToken);
            delete [] pTemp;
            return;
        }

        CloseHandle(hToken);

        // Make a copy of the SID
        // ======================

        PSID pSid = ((TOKEN_USER*)pTemp)->User.Sid;
        DWORD dwSidLen = GetLengthSid(pSid);
        m_pSid = new BYTE[dwSidLen];
        CopySid(dwSidLen, m_pSid, pSid);
        delete [] pTemp;
        m_dwStatus = 0;
    }
    return;
}

//-------------------------------------------------------------------
CNtSid::~CNtSid()
{
    if (m_pSid)
        delete [] m_pSid;
    if (m_pMachine)
        delete [] m_pMachine;
}

//-------------------------------------------------------------------
int CNtSid::GetInfo(LPTSTR *pRetAccount,       // Account, use operator delete
						LPTSTR *pRetDomain,    // Domain, use operator delete
						DWORD  *pdwUse)        // See SID_NAME_USE for values
{
    if(pRetAccount)
        *pRetAccount = 0;

    if(pRetDomain)
        *pRetDomain = 0;
    
	if(pdwUse)
        *pdwUse = 0;

    if(!m_pSid || !IsValidSid(m_pSid))
        return InvalidSid;

    DWORD  dwNameLen = 0;
    DWORD  dwDomainLen = 0;
    LPTSTR pUser = 0;
    LPTSTR pDomain = 0;
    SID_NAME_USE Use;


    // Do the first lookup to get the buffer sizes required.
    // =====================================================

    BOOL bRes = LookupAccountSid(m_pMachine,
									m_pSid,
									pUser,
									&dwNameLen,
									pDomain,
									&dwDomainLen,
									&Use);

    DWORD dwLastErr = GetLastError();

    if(dwLastErr != ERROR_INSUFFICIENT_BUFFER)
    {
        return Failed;
    }

    // Allocate the required buffers and look them up again.
    // =====================================================

    pUser = new TCHAR[dwNameLen + 1];
    pDomain = new TCHAR[dwDomainLen + 1];

    bRes = LookupAccountSid(m_pMachine,
								m_pSid,
								pUser,
								&dwNameLen,
								pDomain,
								&dwDomainLen,
								&Use);

    if(!bRes)
    {
        delete[] pUser;
        delete[] pDomain;
        return Failed;
    }

    if(pRetAccount)
        *pRetAccount = pUser;
    else
        delete[] pUser;

    if(pRetDomain)
        *pRetDomain  = pDomain;
    else
        delete[] pDomain;

    if(pdwUse)
        *pdwUse = Use;

    return NoError;
}

//-------------------------------------------------------------------
CUIHelpers::CUIHelpers(DataSource *ds, WbemServiceThread *serviceThread,
					   bool htmlSupport) :
					CBasePage(ds, serviceThread), m_sessionID(0),
					m_htmlSupport(htmlSupport), m_ImaWizard(false)
{
}

//-------------------------------------------------------------------
CUIHelpers::CUIHelpers(CWbemServices &service,
					   bool htmlSupport) :
					CBasePage(service), m_sessionID(0), m_htmlSupport(htmlSupport),
						m_ImaWizard(false)
{
}

//-------------------------------------------------------------------
CUIHelpers::~CUIHelpers( void )
{
}

//---------------------------------------------------
LPTSTR CUIHelpers::CloneString( LPTSTR pszSrc ) 
{
    LPTSTR pszDst = NULL;

    if (pszSrc != NULL) 
	{
        pszDst = new TCHAR[(lstrlen(pszSrc) + 1)];
        if (pszDst) 
		{
            lstrcpy( pszDst, pszSrc );
        }
    }

    return pszDst;
}

//--------------------------------------------------------------
void CUIHelpers::SetWbemService(IWbemServices *pServices)
{
	g_serviceThread->m_realServices = pServices;		//VINOTH
	m_WbemServices = pServices;
}

//--------------------------------------------------------------
bool CUIHelpers::ServiceIsReady(UINT uCaption, 
									UINT uWaitMsg,
									UINT uBadMsg)
{
	switch(g_serviceThread->m_status)
	{
	// its already there.
	case WbemServiceThread::ready:
		{
		ATLTRACE(_T("start marshal\n"));
		for(int i = 0; (i < 5); i++)
		{
			// if "Object is not connected to server"
			if(g_serviceThread->m_hr == 0x800401fd)
			{
				// lost my connection,
				ATLTRACE(_T("Reconnecting to cimom!!!!!!!!!!!\n"));
				g_serviceThread->ReConnect();
				ATLTRACE(_T("new service status: %d\n"), g_serviceThread->m_status);
				continue;
			}
			else if(FAILED(g_serviceThread->m_hr))
			{
				// some other problem.
				g_serviceThread->m_status = WbemServiceThread::error;
			}

			ATLTRACE(_T("marshalled ok\n"));
			break;  //for

		} //endfor

		if(m_AVIbox)
		{
			PostMessage(m_AVIbox, 
						WM_ASYNC_CIMOM_CONNECTED, 
						0, 0);
			m_AVIbox = 0;
		}

		// it marshaled, must still be connected/useable.
		return true;
		}
		break;

	// its coming.
	case WbemServiceThread::notStarted:
	case WbemServiceThread::locating:
	case WbemServiceThread::connecting:
		{
			if(m_alreadyAsked)
			{
				return false;
			}

			// let me know when its there.
			g_serviceThread->NotifyWhenDone(&m_hDlg);

			// also kill the cancel box at that time.
			m_AVIbox = 0;
			g_serviceThread->NotifyWhenDone(&m_AVIbox);

			m_alreadyAsked = true;

			if(uCaption != NO_UI)
			{
				TCHAR caption[100] ={0}, msg[256] = {0};

				::LoadString(_Module.GetModuleInstance(), uCaption, 
								caption, 100);

				::LoadString(_Module.GetModuleInstance(), uWaitMsg, 
								msg, 256);

                m_userCancelled = false;

				if(DisplayAVIBox(m_hDlg, caption, msg, &m_AVIbox) == IDCANCEL)
				{
					g_serviceThread->Cancel();
					m_userCancelled = true;
				}
			}
		}
		return false;
		break;

	case WbemServiceThread::error:			// cant connect.
	case WbemServiceThread::threadError:	// cant start that thread.
	default:
		m_AVIbox = 0;
		if(uCaption != NO_UI)
		{
//			DisplayUserMessage(m_hDlg, HINST_THISDLL,
//								uCaption, uBadMsg, 
//								g_serviceThread->m_hr, 
//								MB_ICONSTOP);
		}
			return false;

	}; //endswitch 
	return false;
}

//---------------------------------------------------
#define PB_NOTHING_PENDING 0
#define PB_PENDING 1
#define PB_COMMIT 2

// STATIC INITIALIZE
int CUIHelpers::m_needToPut[3] = {PB_NOTHING_PENDING,
								 PB_NOTHING_PENDING,
								 PB_NOTHING_PENDING};

void CUIHelpers::PageChanged(int page, bool needToPut)
{
	if(needToPut)
	{
		::SendMessage(GetParent(m_hDlg), PSM_CHANGED, (WPARAM)m_hDlg, 0L);
		m_needToPut[page] = PB_PENDING;
		ATLTRACE(_T("%d pending now\n"), page);
	}
	else
	{
		m_needToPut[page] = PB_NOTHING_PENDING;
	}
}

//---------------------------------------------------
HRESULT CUIHelpers::NeedToPut(int page, BOOL refresh)
{
	bool allPagesReady = true;
	int x;
	HRESULT hr = S_OK;

	switch(m_needToPut[page])
	{
	case PB_NOTHING_PENDING:
	case PB_COMMIT:
		return S_OK;      // unnecessary call.
		break;
	case PB_PENDING:
		m_needToPut[page] = PB_COMMIT;   // lets do it.
		ATLTRACE(_T("%d committed now\n"), page);

		break;
	}
	
	// it that the last one?
	for(x = 0; x <= PB_LASTPAGE; x++)
	{
		// somebody hasn't committed yet.
		// NOTE: ignoring the PB_NOTHING_PENDING's.
		if(m_needToPut[x] == PB_PENDING)
		{
			// wait awhile longer.
			allPagesReady = false;
			break;
		}
	}

	if(allPagesReady)
	{
		hr = m_DS->PutWMISetting(refresh);
		if(FAILED(hr))
		{
			CHString1 caption;
			TCHAR errMsg[256] = {0};
			caption.LoadString(IDS_SHORT_NAME);

			ErrorStringEx(hr, errMsg, 256);

			MessageBox(m_hDlg, errMsg, caption, MB_OK|MB_ICONWARNING);
		}

		ATLTRACE(_T("PUTINSTANCE now\n"));

		// clear the flags.
		for(x = 0; x <= PB_LASTPAGE; x++)
		{
			m_needToPut[x] = PB_NOTHING_PENDING;
		}
	}

	::SendMessage(GetParent(m_hDlg), PSM_UNCHANGED, (WPARAM)m_hDlg, 0L);

	return hr;
}


//------------------------------------------------------------------------
bool CUIHelpers::BrowseForFile(HWND hDlg, 
								UINT idTitle,
								LPCTSTR lpstrFilter,
								LPCTSTR initialFile,
								LPTSTR pathFile,
								UINT pathFileSize,
								DWORD moreFlags /*= 0*/)
{
	bool retval = false;

	if(m_DS->IsLocal())
	{
		OPENFILENAME OpenFileName;
		CHString1 title;
		title.LoadString(idTitle);

		OpenFileName.lStructSize       = sizeof(OPENFILENAME);
		OpenFileName.hwndOwner         = hDlg;
		OpenFileName.hInstance         = 0;
		OpenFileName.lpstrFilter       = lpstrFilter;
		OpenFileName.lpstrCustomFilter = NULL;
		OpenFileName.nMaxCustFilter    = 0;
		OpenFileName.nFilterIndex      = 0;
		OpenFileName.lpstrFile         = pathFile;
		OpenFileName.nMaxFile          = pathFileSize;
		OpenFileName.lpstrFileTitle    = NULL;
		OpenFileName.nMaxFileTitle     = 0;
		OpenFileName.lpstrInitialDir   = initialFile;
		OpenFileName.lpstrTitle        = (LPCTSTR)title;
		OpenFileName.nFileOffset       = 0;
		OpenFileName.nFileExtension    = 0;
		OpenFileName.lpstrDefExt       = _T("rec");
		OpenFileName.lCustData         = NULL;
		OpenFileName.lpfnHook 		   = NULL;
		OpenFileName.lpTemplateName    = NULL;
	#if (_WIN32_WINNT >= 0x0500)
		OpenFileName.Flags             = OFN_HIDEREADONLY|OFN_DONTADDTORECENT;
	#else
		OpenFileName.Flags             = OFN_HIDEREADONLY;
	#endif
		OpenFileName.Flags             |= moreFlags;

		// Call the common dialog function.
		if(GetOpenFileName(&OpenFileName))
		{
			retval = true;
		}
		else
   		{
			DWORD x = CommDlgExtendedError();
			retval = false;
		}
	}
	else // remote connection
	{
		retval = (DisplayEditDlg(hDlg, idTitle, IDS_CANT_BROWSE_REMOTELY,
								pathFile, pathFileSize) == IDOK);
	}
	return retval;
}

//---------------------------------------------------------
typedef struct {
	LPCTSTR lpCaption;
	LPCTSTR lpClientMsg;
	UINT uAnim;
	HWND *boxHwnd;
	BOOL cancelBtn;
} ANIMCONFIG;

INT_PTR CALLBACK AnimDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam)
{
	BOOL retval = FALSE;
	switch(uMsg)
	{
	case WM_INITDIALOG:
		{//BEGIN
			//lParam = ANIMCONFIG *

			ANIMCONFIG *cfg = (ANIMCONFIG *)lParam;
			*(cfg->boxHwnd) = hwndDlg;

			if(cfg->cancelBtn == FALSE)
			{
				::ShowWindow(::GetDlgItem(hwndDlg, IDCANCEL), SW_HIDE);
			}

			// save this pointer for the WM_DESTROY.
			SetWindowLongPtr(hwndDlg, DWLP_USER, (LPARAM)cfg->boxHwnd);

			HWND hAnim = GetDlgItem(hwndDlg, IDC_ANIMATE);
			HWND hMsg = GetDlgItem(hwndDlg, IDC_MSG);

			Animate_Open(hAnim, MAKEINTRESOURCE(cfg->uAnim));

			SetWindowText(hwndDlg, cfg->lpCaption);
			SetWindowText(hMsg, cfg->lpClientMsg);

			retval = TRUE;
		}//END
		break;

	case WM_ASYNC_CIMOM_CONNECTED:
		// the client has completed 'whatever' and I should
		// claim victory and go away now.
		EndDialog(hwndDlg, IDOK);
		break;

	case WM_COMMAND:
		// they're only one button.
		if(HIWORD(wParam) == BN_CLICKED)
		{
			// I'm going away now so anybody that has a ptr to my
			// hwnd (which I gave out in my WM_INITDIALOG) shouldn't
			// use it anymore.
			HWND *me = (HWND *)GetWindowLongPtr(hwndDlg, DWLP_USER);
			*me = 0;
			EndDialog(hwndDlg, IDCANCEL);
		}
		retval = TRUE; // I processed it.
		break;

	case WM_DESTROY:
		{// BEGIN
			// I'm going away now so anybody that has a ptr to my
			// hwnd (which I gave out in my WM_INITDIALOG) shouldn't
			// use it anymore.
			HWND *me = (HWND *)GetWindowLongPtr(hwndDlg, DWLP_USER);
			*me = 0;
			retval = TRUE; // I processed it.
		} //END
		break;

	default:
		retval = FALSE; // I did NOT process this msg.
		break;
	} //endswitch uMsg

	return retval;
}

//---------------------------------------------------------
INT_PTR CUIHelpers::DisplayAVIBox(HWND hWnd,
							LPCTSTR lpCaption,
							LPCTSTR lpClientMsg,
							HWND *boxHwnd,
							BOOL cancelBtn)
{
	ANIMCONFIG cfg = {lpCaption, lpClientMsg, IDR_AVIWAIT, boxHwnd, cancelBtn};

	return DialogBoxParam(_Module.GetModuleInstance(), 
							MAKEINTRESOURCE(IDD_ANIMATE), 
							hWnd, AnimDlgProc, 
							(LPARAM)&cfg);
}

//---------------------------------------------------------
typedef struct {
	LPTSTR lpName;
	UINT cName;
	DataSource *ds;
	HTREEITEM hSelectedItem;
} PICK_CFG;

INT_PTR CALLBACK NSPickDlgProc(HWND hwndDlg,
							 UINT uMsg,
							 WPARAM wParam,
							 LPARAM lParam)
{
	BOOL retval = FALSE;
	switch(uMsg)
	{
	case WM_INITDIALOG:
		{ //BEGIN
			SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
			PICK_CFG *data = (PICK_CFG *)GetWindowLongPtr(hwndDlg, DWLP_USER);
			HWND hTree = GetDlgItem(hwndDlg, IDC_NSTREE);
			data->ds->LoadImageList(hTree);
			data->ds->LoadNode(hTree, TVI_ROOT, HIDE_SOME);

		} //END
		retval = TRUE;
		break;

    case WM_NOTIFY:
        {
			PICK_CFG *data = (PICK_CFG *)GetWindowLongPtr(hwndDlg, DWLP_USER);

            switch(((LPNMHDR)lParam)->code)
            {
			case TVN_SELCHANGED:
				if(((LPNMHDR)lParam)->idFrom == IDC_NSTREE)
				{
					LPNMTREEVIEW pnmtv = (LPNMTREEVIEW)lParam;
					data->hSelectedItem = pnmtv->itemNew.hItem;
				}
				break;
			case TVN_ITEMEXPANDING:
				if(((LPNMHDR)lParam)->idFrom == IDC_NSTREE)
				{
					// expand the node.
					LPNMTREEVIEW pnmtv = (LPNMTREEVIEW)lParam;
					if(pnmtv->action == TVE_EXPAND)
					{
						HWND hTree = GetDlgItem(hwndDlg, IDC_NSTREE);
						data->ds->LoadNode(hTree, pnmtv->itemNew.hItem, HIDE_SOME);
					}
				}
				break;
            }
        }
		retval = TRUE;
        break;

	case WM_COMMAND:
		// they're only one button.
		switch(LOWORD(wParam))
		{
		case IDOK:
			{
				PICK_CFG *data = (PICK_CFG *)GetWindowLongPtr(hwndDlg, DWLP_USER);

				// save the currently selected fullpath name.
				HWND hTree = ::GetDlgItem(hwndDlg, IDC_NSTREE);
				TV_ITEM item;
				item.mask = TVIF_PARAM;
				item.hItem = data->hSelectedItem;
				BOOL x = TreeView_GetItem(hTree, &item);

				struct NSNODE *node = ((ITEMEXTRA *)item.lParam)->nsNode;

				if(node && data)
					_tcsncpy(data->lpName, node->fullPath, data->cName);

				EndDialog(hwndDlg, IDOK);
			}
			break;

		case IDCANCEL:
			{
				EndDialog(hwndDlg, IDCANCEL);
			}
			break;

		default:
			return(FALSE);
		} // switch
        break;

	default:
		retval = FALSE; // I did NOT process this msg.
		break;
	} //endswitch uMsg

	return retval;
}

//---------------------------------------------------------
INT_PTR CUIHelpers::DisplayNSBrowser(HWND hWnd,
									LPTSTR lpName,
									UINT cName)
{
	PICK_CFG cfg;
	cfg.lpName = lpName;
	cfg.cName = cName;
	cfg.ds = m_DS;
	cfg.hSelectedItem = 0;

	return DialogBoxParam(_Module.GetModuleInstance(), 
							MAKEINTRESOURCE(IDD_NS_PICKER), 
							hWnd, NSPickDlgProc, 
							(LPARAM)&cfg);
}

//---------------------------------------------------------
typedef struct {
	LPCTSTR lpCaption;
	LPCTSTR lpMsg;
	LPTSTR lpEdit;
	UINT cEdit;
} EDIT_CFG;

const static DWORD nsBrowseHelpIDs[] = {  // Context Help IDs
	IDC_NSTREE, IDH_WMI_CTRL_ADVANCED_CHANGE_NAMESPACE,
	65535, -1,
    0, 0
};

INT_PTR CALLBACK EditDlgProc(HWND hwndDlg,
							 UINT uMsg,
							 WPARAM wParam,
							 LPARAM lParam)
{
	BOOL retval = FALSE;
	switch(uMsg)
	{
	case WM_INITDIALOG:
		{ //BEGIN
			SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
			EDIT_CFG *data = (EDIT_CFG *)GetWindowLongPtr(hwndDlg, DWLP_USER);
			if(data->lpMsg)
			{
				::SetWindowText(GetDlgItem(hwndDlg, IDC_MSG), data->lpMsg);
			}
			if(data->lpCaption)
			{
				SetWindowText(hwndDlg, data->lpCaption);
			}

		} //END
		retval = TRUE;
		break;

	case WM_COMMAND:
		// they're only one button.
		switch(LOWORD(wParam))
		{
		case IDC_EDIT:
			if(HIWORD(wParam) == EN_CHANGE)
			{
				HWND hwnd = GetDlgItem(hwndDlg, IDOK);
				int len = GetWindowTextLength((HWND)lParam);

				::EnableWindow(hwnd, (len > 0));
			}
			break;

		case IDOK:
			{
				EDIT_CFG *data = (EDIT_CFG *)GetWindowLongPtr(hwndDlg, DWLP_USER);

				if(data->lpEdit)
				{
					::GetWindowText(GetDlgItem(hwndDlg, IDC_EDIT), 
									data->lpEdit, data->cEdit);
				}
				EndDialog(hwndDlg, IDOK);
			}
			break;

		case IDCANCEL:
			{
				EndDialog(hwndDlg, IDCANCEL);
			}
			break;

		default:
			return(FALSE);
		} // switch
        break;

    case WM_HELP:
        if (IsWindowEnabled(hwndDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_HelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)nsBrowseHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if (IsWindowEnabled(hwndDlg))
        {
            WinHelp(hwndDlg, c_HelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)nsBrowseHelpIDs);
        }
        break;

	default:
		retval = FALSE; // I did NOT process this msg.
		break;
	} //endswitch uMsg

	return retval;
}

//---------------------------------------------------------
INT_PTR CUIHelpers::DisplayEditDlg(HWND hWnd,
								UINT idCaption,
								UINT idMsg,
								LPTSTR lpEdit,
								UINT cEdit)
{
	CHString1 caption, msg;
	caption.LoadString(idCaption);
	msg.LoadString(idMsg);

	EDIT_CFG cfg = {(LPCTSTR)caption, (LPCTSTR)msg, lpEdit, cEdit};

	return DialogBoxParam(_Module.GetModuleInstance(), 
							MAKEINTRESOURCE(IDD_EDITBOX), 
							hWnd, EditDlgProc, 
							(LPARAM)&cfg);
}

//---------------------------------------------------------
typedef struct {
	LOGIN_CREDENTIALS *credentials;
} LOGIN_CFG;


//------------------------------------------------------------------------
void CredentialUserA(LOGIN_CREDENTIALS *credentials, char **user)
{
	UINT finalSize = credentials->authIdent->DomainLength + 
						credentials->authIdent->UserLength + 1;

	*user = new char[finalSize];
	if(*user == NULL)
		return;

	memset(*user, 0, finalSize * sizeof(char));

	if(credentials->authIdent->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI)
	{
		if(credentials->authIdent->DomainLength > 0)
		{
			strcpy(*user, (char *)credentials->authIdent->Domain);
			strcat(*user, "\\");
			strcat(*user, (char *)credentials->authIdent->User);
		}
		else
		{
			strcpy(*user, (char *)credentials->authIdent->User);
		}
	}
	else   // convert the UNICODE
	{
		if(credentials->authIdent->DomainLength > 0)
		{
			char temp[100] = {0};
			wcstombs(*user, credentials->authIdent->Domain,
								credentials->authIdent->DomainLength);
			strcat(*user, "\\");

			wcstombs(temp, credentials->authIdent->User,
								credentials->authIdent->UserLength);

			strcat(*user, temp);
		}
		else
		{
			wcstombs(*user, credentials->authIdent->User,
							credentials->authIdent->UserLength);
		}
	}
}

//------------------------------------------------------------------------
void CredentialUserW(LOGIN_CREDENTIALS *credentials, wchar_t **user)
{
	UINT finalSize = credentials->authIdent->DomainLength + 
						credentials->authIdent->UserLength + 1;

	*user = new wchar_t[finalSize];
	if(*user == NULL)
		return;
	memset(*user, 0, finalSize * sizeof(wchar_t));

	if(credentials->authIdent->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI)
	{
		if(credentials->authIdent->DomainLength > 0)
		{
			wchar_t temp[100] = {0};
			mbstowcs(*user, (const char *)credentials->authIdent->Domain,
								credentials->authIdent->DomainLength);

			wcscat(*user, L"\\");
			
			mbstowcs(temp, (const char *)credentials->authIdent->User,
								credentials->authIdent->UserLength);

			wcscat(*user, temp);
		}
		else
		{
			mbstowcs(*user, (const char *)credentials->authIdent->User,
								credentials->authIdent->UserLength);
		}
	}
	else   //
	{
		if(credentials->authIdent->DomainLength > 0)
		{
			wcscpy(*user, credentials->authIdent->Domain);
			wcscat(*user, L"\\");
			wcscat(*user, credentials->authIdent->User);
		}
		else
		{
			wcscpy(*user, credentials->authIdent->User);
		}
	}
}
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
void SetCurrentUser(HWND hDlg, bool currUser)
{
	Button_SetCheck(GetDlgItem(hDlg, IDC_CHECKCURRENTUSER), 
						(currUser? BST_CHECKED:BST_UNCHECKED));

	BOOL enable = (currUser? FALSE: TRUE);

	::EnableWindow(GetDlgItem(hDlg, IDC_EDITUSERNAME), enable);
	::EnableWindow(GetDlgItem(hDlg, IDC_EDITPASSWORD), enable);
	::EnableWindow(GetDlgItem(hDlg, IDC_USER_LABEL), enable);
	::EnableWindow(GetDlgItem(hDlg, IDC_PW_LABEL), enable);
}

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
const static DWORD logonHelpIDs[] = {  // Context Help IDs
	IDC_CHECKCURRENTUSER, IDH_WMI_CTRL_GENERAL_WMILOGIN_CHECKBOX,
	IDC_USER_LABEL, IDH_WMI_CTRL_GENERAL_WMILOGIN_USERNAME,
	IDC_EDITUSERNAME, IDH_WMI_CTRL_GENERAL_WMILOGIN_USERNAME,
	IDC_PW_LABEL, IDH_WMI_CTRL_GENERAL_WMILOGIN_PASSWORD,
	IDC_EDITPASSWORD, IDH_WMI_CTRL_GENERAL_WMILOGIN_PASSWORD,
    0, 0
};

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
INT_PTR CALLBACK LoginDlgProc(HWND hwndDlg,
							 UINT uMsg,
							 WPARAM wParam,
							 LPARAM lParam)
{
	BOOL retval = FALSE;
	switch(uMsg)
	{
	case WM_INITDIALOG:
		{ //BEGIN
			SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
			LOGIN_CFG *data = (LOGIN_CFG *)GetWindowLongPtr(hwndDlg, DWLP_USER);

			SetCurrentUser(hwndDlg, data->credentials->currUser);

		} //END
		retval = TRUE;
		break;

	case WM_COMMAND:
		{
			LOGIN_CFG *data = (LOGIN_CFG *)GetWindowLongPtr(hwndDlg, DWLP_USER);

			switch(LOWORD(wParam))
			{
			case IDC_CHECKCURRENTUSER:
				{
					if(HIWORD(wParam) == BN_CLICKED)
					{
						bool currUser = (IsDlgButtonChecked(hwndDlg, IDC_CHECKCURRENTUSER) == BST_CHECKED ?true:false);
						// toggle and respond.
						SetCurrentUser(hwndDlg, currUser);
					}
				}
				break;

			case IDOK:
				{
					if(HIWORD(wParam) == BN_CLICKED)
					{
						data->credentials->currUser = (IsDlgButtonChecked(hwndDlg, IDC_CHECKCURRENTUSER) == BST_CHECKED ?true:false);

						if(data->credentials->currUser == false)
						{
							TCHAR user[100] = {0}, pw[100] = {0};
							GetWindowText(GetDlgItem(hwndDlg, IDC_EDITUSERNAME), user, 100);
							GetWindowText(GetDlgItem(hwndDlg, IDC_EDITPASSWORD), pw, 100);
							
							BSTR bDomUser, bUser = NULL, bDomain = NULL, bAuth = NULL;
//#ifdef SNAPIN
							wchar_t *temp = pw;
							bDomUser = SysAllocString(user);
/*#else
							wchar_t temp[100] = {0};
							mbstowcs(temp, user, 100);
							bDomUser = SysAllocString(temp);
							mbstowcs(temp, pw, 100);
#endif*/
							if(SUCCEEDED(DetermineLoginType(bDomain, bUser, bAuth, bDomUser)))
							{
								if(data->credentials->authIdent != 0)
								{
									if(data->credentials->fullAcct)
									{
										data->credentials->fullAcct[0] = 0;
									}
									WbemFreeAuthIdentity(data->credentials->authIdent);
									data->credentials->authIdent = 0;
								}

								HRESULT hr = WbemAllocAuthIdentity(bUser, temp, bDomain, 
																	&(data->credentials->authIdent));

								_tcscpy(data->credentials->fullAcct, user);
							}
						}

						EndDialog(hwndDlg, IDOK);
					}
				}
				break;

			case IDCANCEL:
				{
					if(HIWORD(wParam) == BN_CLICKED)
					{
						EndDialog(hwndDlg, IDCANCEL);
					}
				}
				break;

			default:
				return(FALSE);
			} // switch
			break;
		} // - - - - - - - - endswitch LOWORD()
		break;

    case WM_HELP:
        if(IsWindowEnabled(hwndDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_HelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)logonHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if(IsWindowEnabled(hwndDlg))
        {
            WinHelp(hwndDlg, c_HelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)logonHelpIDs);
        }
        break;

	default: break;
	} //endswitch uMsg

	return retval;
}

//---------------------------------------------------------
INT_PTR DisplayLoginDlg(HWND hWnd, 
					LOGIN_CREDENTIALS *credentials)
{
	LOGIN_CFG cfg;

	cfg.credentials = credentials;

	return DialogBoxParam(_Module.GetModuleInstance(), 
							MAKEINTRESOURCE(IDD_LOGIN), 
							hWnd, LoginDlgProc, 
							(LPARAM)&cfg);
}
//---------------------------------------------------------
void SetUserAccount(HWND hwndDlg, 
					LOGIN_CREDENTIALS *credentials)
{

	HWND hwnd = GetDlgItem(hwndDlg, IDC_ACCOUNT);
	if(credentials->currUser)
	{
		CHString1 name;
		name.LoadString(IDS_CURRENT_USER);
		SetWindowText(hwnd, (LPCTSTR)name);
	}
	else if(credentials->authIdent != 0 &&
			credentials->authIdent->UserLength != 0)
	{
		LPTSTR temp;
		CredentialUser(credentials, &temp);
		SetWindowText(hwnd, (LPCTSTR)temp);
	}
}


//---------------------------------------------------------
void WarnAboutLocalMachine(HWND hwndDlg)
{
	TCHAR caption[50] = {0}, threat[100] = {0};
	HWND hwnd = GetDlgItem(hwndDlg, IDC_NAME);

	::LoadString(_Module.GetResourceInstance(),
					IDS_SHORT_NAME, caption, 50);
	::LoadString(_Module.GetResourceInstance(),
					IDS_USE_RADIO, threat, 100);

	MessageBox(hwndDlg, threat, caption, 
				MB_OK|MB_DEFBUTTON1|MB_ICONEXCLAMATION);

	SendMessage(hwnd, EM_SETSEL, 0, -1);
	SendMessage(hwnd, EM_REPLACESEL, 0, (LPARAM)"");
	SendMessage(hwnd, EM_SETSEL, -1, 0);

	CheckRadioButton(hwndDlg, IDC_LOCAL, IDC_REMOTE, IDC_LOCAL);

	hwnd = GetDlgItem(hwndDlg, IDC_LOCAL);

	SendMessage(hwndDlg, WM_COMMAND, 
					MAKEWPARAM(IDC_LOCAL, BN_CLICKED),
					(LPARAM)hwnd);
	SetFocus(hwnd);
}

//---------------------------------------------------------
bool LocalMachineName(LPCTSTR buf)
{
	TCHAR name[64] = {0};
	DWORD size = 64;
	bool retval = false;
	UINT len = _tcslen(buf);

	if(GetComputerName(name, &size))
	{
		if((_tcslen(buf) >= 2) && 
		   (buf[1] == _T('\\')))
		{
			// ignore the leading whacks.
			retval = (_tcsicmp(&buf[2], name) == 0);
		}
		else if( ((len == 1) && (buf[0] == _T('.'))) ||
			((len == 3) && (buf[2] == _T('.')))
		  )
		{
			retval = true;
		}
		else
		{
			retval = (_tcsicmp(buf, name) == 0);
		}
	}
	return retval;
}

//---------------------------------------------------------
const static DWORD connDlgHelpIDs[] = {  // Context Help IDs
	IDC_CONN_FRAME,		IDH_WMI_EXE_GENERAL_CHGCOMP_CONNECTTO,
	IDC_LOCAL,			IDH_WMI_EXE_GENERAL_CHGCOMP_CONNECTTO,
	IDC_REMOTE,			IDH_WMI_EXE_GENERAL_CHGCOMP_CONNECTTO,
	IDC_NAME,			IDH_WMI_EXE_GENERAL_CHGCOMP_CONNECTTO,
	IDC_ACCOUNT_LABEL,	IDH_WMI_CTRL_GENERAL_CONNECTED_AS,
	IDC_ACCOUNT,		IDH_WMI_CTRL_GENERAL_CONNECTED_AS,
	IDC_LOGON,			IDH_WMI_CTRL_GENERAL_CHANGE_BUTTON,
    0, 0};

INT_PTR CALLBACK ConnDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam)
{
	BOOL retval = FALSE;
	switch(uMsg)
	{
	case WM_INITDIALOG:
		{ //BEGIN
			CUIHelpers *me = (CUIHelpers *)GetWindowLongPtr(hwndDlg, DWLP_USER);
			CONN_NAME *name = 0;

			if(me == 0)
			{
				me = (CUIHelpers *)lParam;
				SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
			}

			name = (CONN_NAME *)&(me->m_cfg);

			if(me->m_ImaWizard)
			{
				::PropSheet_SetWizButtons(::GetParent(hwndDlg), PSWIZB_FINISH);
			}

			BOOL local = *(name->local);

			::EnableWindow(GetDlgItem(hwndDlg, IDC_LOCAL), TRUE);
			::EnableWindow(GetDlgItem(hwndDlg, IDC_REMOTE), TRUE);
			::EnableWindow(GetDlgItem(hwndDlg, IDC_NAME), !local);
			::EnableWindow(GetDlgItem(hwndDlg, IDC_LOGON), !local);

			CheckRadioButton(hwndDlg, IDC_LOCAL, IDC_REMOTE, 
								(local ? IDC_LOCAL : IDC_REMOTE));

			HWND hName = GetDlgItem(hwndDlg, IDC_NAME);
			SendMessage(hName, EM_LIMITTEXT, 64, 0);
			SetWindowText(hName, name->lpName);

			BOOL enableOK = (GetWindowTextLength(hName) != 0);
			::EnableWindow(GetDlgItem(hwndDlg, IDOK), enableOK);

			// deal with the user account.
			SetUserAccount(hwndDlg, name->credentials);

			if(!local)
			{
				::SetFocus(GetDlgItem(hwndDlg, IDC_NAME));
				return FALSE;
			}

		} //END
		retval = TRUE;
		break;

	case WM_NOTIFY:
		{
			switch(((NMHDR FAR *) lParam)->code) 
			{
			case PSN_WIZFINISH:
				{
					CUIHelpers *me = (CUIHelpers *)GetWindowLongPtr(hwndDlg, DWLP_USER);
					CONN_NAME *name = (CONN_NAME *)&(me->m_cfg);

					*(name->local) = (IsDlgButtonChecked(hwndDlg, IDC_LOCAL) == BST_CHECKED ?true:false);

					if(*(name->local) == false)
					{
						GetWindowText(GetDlgItem(hwndDlg, IDC_NAME), name->lpName, name->cName);
					}
				}
				break;

			default: break;
			}
		}
		break;

	case WM_COMMAND:
		{
			// they're only one button.
			CUIHelpers *me = (CUIHelpers *)GetWindowLongPtr(hwndDlg, DWLP_USER);
			CONN_NAME *name = (CONN_NAME *)&(me->m_cfg);

			switch(LOWORD(wParam))
			{
			case IDC_LOCAL:
				{
					::EnableWindow(GetDlgItem(hwndDlg, IDC_NAME), FALSE);
					::EnableWindow(GetDlgItem(hwndDlg, IDC_LOGON), FALSE);
					BOOL local = (IsDlgButtonChecked(hwndDlg, IDC_LOCAL) == BST_CHECKED);
					int len = GetWindowTextLength(GetDlgItem(hwndDlg, IDC_NAME));
					BOOL enableOK = local || (len != 0);
					::EnableWindow(GetDlgItem(hwndDlg, IDOK), enableOK);
				}
				break;

			case IDC_REMOTE:
				{
					::EnableWindow(GetDlgItem(hwndDlg, IDC_NAME), TRUE);
					::EnableWindow(GetDlgItem(hwndDlg, IDC_LOGON), TRUE);
					BOOL local = (IsDlgButtonChecked(hwndDlg, IDC_LOCAL) == BST_CHECKED);
					int len = GetWindowTextLength(GetDlgItem(hwndDlg, IDC_NAME));
					BOOL enableOK = local || (len != 0);
					::EnableWindow(GetDlgItem(hwndDlg, IDOK), enableOK);
				}
				break;

			case IDC_NAME:
				switch(HIWORD(wParam))
				{
				case EN_CHANGE:
					{
						BOOL local = (IsDlgButtonChecked(hwndDlg, IDC_LOCAL) == BST_CHECKED);
						int len = GetWindowTextLength(GetDlgItem(hwndDlg, IDC_NAME));
						BOOL enableOK = local || (len != 0);
						if(len)
						{
							TCHAR buf[64] = {0};
							HWND hwnd = GetDlgItem(hwndDlg, IDC_NAME);
							GetWindowText(hwnd, buf, 64);
						}
						::EnableWindow(GetDlgItem(hwndDlg, IDOK), enableOK);
					}
					break;

				default: break;

				} //endswitch HIWORD(wParam)
				break;

			case IDC_LOGON:
				if(DisplayLoginDlg(hwndDlg, name->credentials) == IDOK)
				{
					HWND hwnd = GetDlgItem(hwndDlg, IDC_ACCOUNT);
					if(name->credentials->currUser)
					{
						CHString1 name;
						name.LoadString(IDS_CURRENT_USER);
						SetWindowText(hwnd, (LPCTSTR)name);
					}
					else if(name->credentials->authIdent->UserLength != 0)
					{
						LPTSTR temp;
						CredentialUser(name->credentials, &temp);
						if(_tcslen(temp) > 0)
						{
							SetWindowText(hwnd, (LPCTSTR)temp);
						}
					}
				} //endif DisplayLoginDlg()
				break;

			case IDOK:

				*(name->local) = (IsDlgButtonChecked(hwndDlg, IDC_LOCAL) == BST_CHECKED ?true:false);

				if(*(name->local) == false)
				{
					HWND hwnd = GetDlgItem(hwndDlg, IDC_NAME);
					GetWindowText(hwnd, name->lpName, name->cName);

					if(LocalMachineName(name->lpName))
					{
						WarnAboutLocalMachine(hwndDlg);
						return TRUE;
					}
				}
				else
				{
					name->credentials->currUser = true;

					WbemFreeAuthIdentity(name->credentials->authIdent);
					name->credentials->authIdent = 0;
					memset(name->credentials->fullAcct, 0, 100 * sizeof(TCHAR));
				}
				EndDialog(hwndDlg, IDOK);
				break;

			case IDCANCEL:
				EndDialog(hwndDlg, IDCANCEL);
				break;

			default:
				return(FALSE);
			} // switch
		}
        break;

    case WM_HELP:
        if(IsWindowEnabled(hwndDlg))
        {
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                    c_HelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)connDlgHelpIDs);
        }
        break;

    case WM_CONTEXTMENU:
        if(IsWindowEnabled(hwndDlg))
        {
            WinHelp(hwndDlg, c_HelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)connDlgHelpIDs);
        }
        break;

	default:
		retval = FALSE; // I did NOT process this msg.
		break;
	} //endswitch uMsg

	return retval;
}

//---------------------------------------------------------
INT_PTR CUIHelpers::DisplayCompBrowser(HWND hWnd,
									LPTSTR lpName,
									UINT cName,
									bool *local,
									LOGIN_CREDENTIALS *credentials)
{
	CUIHelpers *dummy = new CUIHelpers(NULL, NULL, false);
	dummy->m_cfg.lpName = lpName;
	dummy->m_cfg.cName = cName;
	dummy->m_cfg.local = local;
	dummy->m_cfg.credentials = credentials;

	return DialogBoxParam(_Module.GetModuleInstance(), 
							MAKEINTRESOURCE(IDD_CONNECT), 
							hWnd, ConnDlgProc, 
							(LPARAM)dummy);
}

//=======================================================================
ConnectPage::ConnectPage(DataSource *ds, bool htmlSupport) :
				CUIHelpers(ds, &(ds->m_rootThread), htmlSupport)
{
	m_isLocal = true;
	m_ImaWizard = true;

	m_cfg.lpName = new TCHAR[256];
	memset(m_cfg.lpName, 0, 256 * sizeof(TCHAR));

	m_cfg.cName = 256;

	m_cfg.local = new bool;
	*m_cfg.local = m_isLocal;
	m_cfg.credentials = m_DS->GetCredentials();
}

//-------------------------------------------------------------------------
ConnectPage::~ConnectPage(void)
{
	if(m_cfg.lpName)
	{
		delete m_cfg.lpName;
	}
}

//------------------------------------------------------------------------
BOOL ConnectPage::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	BOOL retval = false;

	retval = (BOOL)ConnDlgProc(hDlg, uMsg, wParam, lParam);

	if((uMsg == WM_NOTIFY && 
		((NMHDR FAR *) lParam)->code == PSN_WIZFINISH))
	{
		if(*m_cfg.local)
		{
			// an empty string will cause a local connection.
			m_cfg.lpName[0] = '\0';
		}
		m_DS->SetMachineName(CHString1(m_cfg.lpName));
	}
	return retval;
}

//=======================================================================
void CUIHelpers::HTMLHelper(HWND hDlg)   
{
	if(m_htmlSupport)
	{
		TCHAR helpDir[_MAX_PATH] = {0};

		if(GetWindowsDirectory(helpDir, _MAX_PATH) != 0)
		{
			_tcscat(helpDir, _T("\\Help"));

#ifdef SNAPIN
			_tcscat(helpDir, _T("\\newfeat1.chm::wmi_control_overview.htm"));
#else
			_tcscat(helpDir, _T("\\WbemCntl.chm::wmi_control_overview.htm"));
#endif

			HWND hwnd = HtmlHelp(NULL, helpDir, HH_DISPLAY_TOPIC, NULL);
			if(hwnd == 0)
			{
				CHString1 caption, threat;
				caption.LoadString(IDS_SHORT_NAME);
				threat.LoadString(IDS_NO_HELP);
				MessageBox(hDlg, threat, caption, MB_OK|MB_ICONWARNING);
			}
		}
	}
	else
	{
		CHString1 caption, threat;
		caption.LoadString(IDS_SHORT_NAME);
		threat.LoadString(IDS_NO_HHCTRL);
		MessageBox(hDlg, threat, caption, MB_OK|MB_ICONWARNING);

	} //endif m_htmlSupport
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\wmictrsysmondlg.cpp ===
// WMICtrSysmonDlg.cpp : Implementation of CWMICtrSysmonDlg
#include "precomp.h"
#include "WMICtrSysmonDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CWMICtrSysmonDlg

CWMICtrSysmonDlg::CWMICtrSysmonDlg()
{
	_tcscpy(m_strMachineName,_T(""));
	m_eStatus = Status_Success;
	m_hWndBusy = new HWND;
}

CWMICtrSysmonDlg::CWMICtrSysmonDlg(LPCTSTR strMachName)
{
	_tcscpy(m_strMachineName,strMachName);
	m_eStatus = Status_Success;
	m_hWndBusy = new HWND;
}

CWMICtrSysmonDlg::~CWMICtrSysmonDlg()
{
	if(m_hWndBusy != NULL)
	{
		SendMessage(*(m_hWndBusy),WM_CLOSE_BUSY_DLG,0,0);
		delete m_hWndBusy;
	}
}

LRESULT CWMICtrSysmonDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	CWmiCtrsDlg pDlg;
	DisplayBusyDialog();
	TCHAR strCtr[1024];
	ISystemMonitor *pSysMon = NULL;
	HRESULT hr = GetDlgControl(IDC_SYSMON_OCX,__uuidof(ISystemMonitor)/*IID_ISystemMonitor*/,(void **)&pSysMon);
	if(SUCCEEDED(hr))
	{
		ICounters *pCounters = NULL;
		pCounters = pSysMon->GetCounters();
		try
		{
			_tcscpy(strCtr,m_strMachineName);
			_tcscat(strCtr,_T("\\WINMGMT Counters\\Connections"));
			pCounters->Add(strCtr);
			_tcscpy(strCtr,m_strMachineName);
			_tcscat(strCtr,_T("\\WINMGMT Counters\\Delivery Backup (Bytes)"));
			pCounters->Add(strCtr);
			_tcscpy(strCtr,m_strMachineName);
			_tcscat(strCtr,_T("\\WINMGMT Counters\\Internal Objects"));
			pCounters->Add(strCtr);
			_tcscpy(strCtr,m_strMachineName);
			_tcscat(strCtr,_T("\\WINMGMT Counters\\Internal Sinks"));
			pCounters->Add(strCtr);
			_tcscpy(strCtr,m_strMachineName);
			_tcscat(strCtr,_T("\\WINMGMT Counters\\Tasks In Progress"));
			pCounters->Add(strCtr);
			_tcscpy(strCtr,m_strMachineName);
			_tcscat(strCtr,_T("\\WINMGMT Counters\\Tasks Waiting"));
			pCounters->Add(strCtr);
			_tcscpy(strCtr,m_strMachineName);
			_tcscat(strCtr,_T("\\WINMGMT Counters\\Total API calls"));
			pCounters->Add(strCtr);
			_tcscpy(strCtr,m_strMachineName);
			_tcscat(strCtr,_T("\\WINMGMT Counters\\Users"));
			pCounters->Add(strCtr);
			CloseBusyDialog();
		}
		catch(...)
		{
			m_eStatus = Status_CounterNotFound;
			CloseBusyDialog();
			EndDialog(0);
		}
	}
/*	else
	{
		MessageBox(_T("Could not get the Interface Pointer"),_T("Failure"));
	}
*/
	return 1;  // Let the system set the focus
}

LRESULT CWMICtrSysmonDlg::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	EndDialog(wID);
	return 0;
}

LRESULT CWMICtrSysmonDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	EndDialog(wID);
	return 0;
}

void CWMICtrSysmonDlg::DisplayBusyDialog()
{
	DWORD dwThreadId;
	m_hThread = CreateThread(NULL,0,BusyThread,(LPVOID)this,0,&dwThreadId);

}

DWORD WINAPI BusyThread(LPVOID lpParameter)
{
	CWMICtrSysmonDlg *pDlg = (CWMICtrSysmonDlg *)lpParameter;

	INT_PTR ret = DialogBoxParam(_Module.GetModuleInstance(), 
							MAKEINTRESOURCE(IDD_ANIMATE), 
							NULL, BusyAVIDlgProc, 
							(LPARAM)pDlg);

	return (DWORD) ret;
}
void CWMICtrSysmonDlg::CloseBusyDialog()
{
	if(m_hWndBusy != NULL)
	{
		//Now close the busy Dialog
		::SendMessage(*(m_hWndBusy),WM_CLOSE_BUSY_DLG,0,0);
	}

	::SetForegroundWindow(this->m_hWnd);
}

INT_PTR CALLBACK BusyAVIDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam)
{
	BOOL retval = FALSE;
	switch(uMsg)
	{
		case WM_INITDIALOG:
		{//BEGIN
			//lParam = ANIMCONFIG *
			CWMICtrSysmonDlg *pDlg = (CWMICtrSysmonDlg *)lParam;
			SetWindowLongPtr(hwndDlg, DWLP_USER, (LPARAM)pDlg);
			*(pDlg->m_hWndBusy) = hwndDlg;

			HWND hAnim = GetDlgItem(hwndDlg, IDC_ANIMATE);
			HWND hMsg = GetDlgItem(hwndDlg, IDC_MSG);

			Animate_Open(hAnim, MAKEINTRESOURCE(IDR_AVIWAIT));

			TCHAR caption[100] = {0}, msg[256] = {0};

			::LoadString(_Module.GetModuleInstance(), IDS_DISPLAY_NAME, caption, 100);

			::LoadString(_Module.GetModuleInstance(), IDS_CONNECTING, msg, 256);

			SetWindowText(hwndDlg, caption);
			SetWindowText(hMsg, msg);

			retval = TRUE;
			break;
		}
		case WM_CLOSE_BUSY_DLG:
		{
			EndDialog(hwndDlg, IDCANCEL);
			break;
		}
		case WM_COMMAND:
		{
			// they're only one button.
			if(HIWORD(wParam) == BN_CLICKED)
			{
				EndDialog(hwndDlg, IDCANCEL);
			}
			retval = TRUE; // I processed it.
			break;
		}
		case WM_DESTROY:
		{// BEGIN
			retval = TRUE; // I processed it.
			break;
		} //END
		default:
		{
			retval = FALSE; // I did NOT process this msg.
			break;
		}
	} //endswitch uMsg

	return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\wmictrsysmondlg.h ===
// WMICtrSysmonDlg.h : Declaration of the CWMICtrSysmonDlg

#ifndef __WMICTRSYSMONDLG_H_
#define __WMICTRSYSMONDLG_H_

#include "resource.h"       // main symbols
#include <atlwin.h>
#include "sysmon.tlh"	//#import "d:\\winnt\\system32\\sysmon.ocx"
#include "WmiCtrsDlg.h"
using namespace SystemMonitor;

enum eStatusInfo
{
	Status_CounterNotFound,
	Status_Success
};

/////////////////////////////////////////////////////////////////////////////
// CWMICtrSysmonDlg
class CWMICtrSysmonDlg : 
	public CAxDialogImpl<CWMICtrSysmonDlg>
{
protected:
	TCHAR m_strMachineName[1024];
	eStatusInfo m_eStatus;
	HANDLE m_hThread;
public:
	HWND *m_hWndBusy;

	CWMICtrSysmonDlg();
	CWMICtrSysmonDlg(LPCTSTR strMachName);
	~CWMICtrSysmonDlg();

	enum { IDD = IDD_WMICTR_SYSMON };

	BEGIN_MSG_MAP(CWMICtrSysmonDlg)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER(IDOK, OnOK)
		COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	END_MSG_MAP()

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	eStatusInfo GetStatus() { return m_eStatus; }

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	friend INT_PTR CALLBACK BusyAVIDlgProc(HWND hwndDlg,
                         UINT uMsg,
                         WPARAM wParam,
                         LPARAM lParam);

	friend DWORD WINAPI BusyThread(LPVOID lpParameter);

	void DisplayBusyDialog();
	void CloseBusyDialog();

};

#endif //__WMICTRSYSMONDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\wmihelp.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
//Map file for WMI Control tabs and dialog boxes

//GENERAL tab
#define IDH_WMI_CTRL_GENERAL_CONNECTED_AS	7101
#define IDH_WMI_CTRL_GENERAL_CHANGE_BUTTON	7102
#define IDH_WMI_CTRL_GENERAL_DISPLAY_INFO	7103

//GENERAL tab for exe
#define IDH_WMI_EXE_GENERAL_CONNECTED_TO	7105
#define IDH_WMI_EXE_GENERAL_CHANGE_BUTTON	7106
#define IDH_WMI_EXE_GENERAL_CHGCOMP_CONNECTTO	7111

//WMI Login dialog
#define IDH_WMI_CTRL_GENERAL_WMILOGIN_CHECKBOX	7121
#define IDH_WMI_CTRL_GENERAL_WMILOGIN_USERNAME	7122
#define IDH_WMI_CTRL_GENERAL_WMILOGIN_PASSWORD	7123

//LOGGING tab
#define IDH_WMI_CTRL_LOGGING_LOGGING_LEVEL	7201
#define IDH_WMI_CTRL_LOGGING_MAX_SIZE		7202
#define IDH_WMI_CTRL_LOGGING_LOCATION		7203
#define IDH_WMI_CTRL_LOGGING_BROWSE		7204

//BACKUP/RESTORE tab
#define IDH_WMI_CTRL_BACKUP_AUTOMATIC_CHECKBOX	7301
#define IDH_WMI_CTRL_BACKUP_TIME		7302
#define IDH_WMI_CTRL_BACKUP_MINUTES_HOURS	7303
#define IDH_WMI_CTRL_BACKUP_LAST		7304
#define IDH_WMI_CTRL_BACKUP_RESTORE_AUTO	7305
#define IDH_WMI_CTRL_BACKUP_BACKUP_MANUAL	7306
#define IDH_WMI_CTRL_BACKUP_RESTORE_MANUAL	7307

//SECURITY tab
#define IDH_WMI_CTRL_SECURITY_NAMESPACE_BOX	7401
#define IDH_WMI_CTRL_SECURITY_SECURITY_BUTTON	7402

//Security dialog
#define IDH_WMI_CTRL_SECURITY_NAMEBOX		7411
#define IDH_WMI_CTRL_SECURITY_ADD_BUTTON	7412
#define IDH_WMI_CTRL_SECURITY_REMOVE_BUTTON	7413
#define IDH_WMI_CTRL_SECURITY_PERMISSIONSLIST	7414

//ADVANCED tab
#define IDH_WMI_CTRL_ADVANCED_REPOSITORY_LOC	7501
#define IDH_WMI_CTRL_ADVANCED_SCRIPTING_PATH	7502
#define IDH_WMI_CTRL_ADVANCED_CHANGE_BUTTON	7503
#define IDH_WMI_CTRL_ADVANCED_ASP_ACCESS	7504
#define IDH_WMI_CTRL_ADVANCED_ENABLE_CONNECT	7505
#define IDH_WMI_CTRL_ADVANCED_RESTART_BOX	7506

//Browser for Namespace dialog
#define IDH_WMI_CTRL_ADVANCED_CHANGE_NAMESPACE	7511
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\bvtcimv2.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTCIMv2.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <bvt.h>


#define NO_ERRORS_EXPECTED       FALSE,__FILE__,__LINE__
#define ERRORS_CAN_BE_EXPECTED   TRUE,__FILE__,__LINE__
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 200
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CIMV2_OpenNamespace()
{
    //==========================================================================
    // Open CIMV2 namespace
    //==========================================================================
    int nRc = FATAL_ERROR;
    IWbemServices   * pNamespace    = NULL;
    CAutoDeleteString sNamespace;

    if( g_Options.GetOptionsForAPITest(sNamespace, APITEST200) )
    {
	    // =====================================================================
        //  Open the namespace
	    // =====================================================================
        nRc = OpenNamespaceAndKeepOpen( &pNamespace, sNamespace.GetPtr(),FALSE);
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 201
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CIMV2_EnumerateClasses()
{
    int nRc = FATAL_ERROR;
    //==========================================================================
    // Get class enumerator for the namespace to get list of classes
    //==========================================================================
    CAutoDeleteString sNamespace;

    if( g_Options.GetOptionsForAPITest(sNamespace, APITEST200) )
    {
        IWbemServices   * pNamespace    = NULL;
	    // =====================================================================
        //  Open the namespace
	    // =====================================================================
        nRc = OpenNamespaceAndKeepOpen( &pNamespace, sNamespace.GetPtr(),FALSE);

        if( SUCCESS == nRc )
        {
            // =============================================================
            //  Get the list of classes to make sure they are in namespace
            // =============================================================
            CAutoDeleteString sClassesToCompare;
            if( g_Options.GetOptionsForAPITest( sClassesToCompare, APITEST201 ) )
            {
                // =========================================================
                // Make sure those classes are in the namespace
                // =========================================================
                nRc = EnumerateClassesAndCompare(sClassesToCompare, pNamespace, sNamespace.GetPtr());
            }
        }
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 202
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CIMV2_EnumerateInstances()
{
    int nRc = FATAL_ERROR;
    //==========================================================================
    // Get instance enumerator for classes Win32_logicalDisk,  Win32_Process 
    //==========================================================================
    IWbemServices   * pNamespace    = NULL;
    CAutoDeleteString sNamespace;

    if( g_Options.GetOptionsForAPITest(sNamespace, APITEST200) )
    {
        IWbemServices   * pNamespace    = NULL;
	    // =====================================================================
        //  Open the namespace
	    // =====================================================================
        nRc = OpenNamespaceAndKeepOpen( &pNamespace, sNamespace.GetPtr(),FALSE);
        if( SUCCESS == nRc )
        {
            // =============================================================
            //  Get the list of classes to get instances for
            // =============================================================
            CAutoDeleteString sInstanceList;
            CAutoDeleteString sInstanceCompareList;

            if( g_Options.GetOptionsForAPITest( sInstanceList, sInstanceCompareList, APITEST202 ) )
            {
                // =========================================================
                // Make sure those instances are in the namespace
                // =========================================================
                nRc = EnumerateInstancesAndCompare(pNamespace, sInstanceList, sInstanceCompareList, sNamespace.GetPtr());
            }
        }
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 203
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CIMV2_GetObjects()
{
    int nRc = FATAL_ERROR;
    //==========================================================================
    // Get classes/instances using path of the object
    //==========================================================================
    CAutoDeleteString sNamespace;

    if( g_Options.GetOptionsForAPITest(sNamespace, APITEST200) )
    {
        IWbemServices   * pNamespace    = NULL;
	    // =====================================================================
        //  Open the namespace
	    // =====================================================================
        nRc = OpenNamespaceAndKeepOpen( &pNamespace, sNamespace.GetPtr(),FALSE);

        if( SUCCESS == nRc )
        {
            // =============================================================
            //  Get the list of objexts to get
            // =============================================================
            CAutoDeleteString sObjects;
            if( g_Options.GetOptionsForAPITest( sObjects, APITEST203 ) )
            {
                // =========================================================
                // Get the requested objects
                // =========================================================
                nRc = GetSpecificObjects(sObjects, pNamespace, sNamespace.GetPtr());
            }
        }
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }

    return nRc;   
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 204
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CIMV2_ExecuteQueries()
{
    int nRc = FATAL_ERROR;
// Execute Association/Reference queries
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 205
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CIMV2_EnumerateClassAMethods()
{
    int nRc = FATAL_ERROR;
// Enumerate methods for a class/instance.
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 206
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CIMV2_EnumerateInstanceMethods()
{
    int nRc = FATAL_ERROR;
// Enumerate methods for a class/instance.
    return nRc;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 207
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CIMV2_ExecuteMethod()
{
    int nRc = FATAL_ERROR;
// Execute a method on one of the instance say Terminate method on Win32_process and check if the instance is removed.
    return nRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\snapin\wmisnapin.h ===
// Copyright (c) 1997-1999 Microsoft Corporation
#ifndef __WMISNAPIN_H_
#define __WMISNAPIN_H_
#include "..\resource.h"
#include "atlwin.h"
#include "atlsnap.h"
#include "CHString1.h"
#include "UIHelpers.h"
#include "..\datasrc.h"
#include "WMICtrSysmonDlg.h"
#include "WmiCtrsDlg.h"

class CWMISnapinExtData;
class CWMISnapinExtData;


class CWMISnapinData : public CSnapInItemImpl<CWMISnapinData>,
						public CComObject<CSnapInDataObjectImpl>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;
	bool m_extension;
	DataSource *g_DS;
	wchar_t m_initMachineName[255];
	TCHAR m_MachineName[255];


	CWMISnapinData(bool extension = false);

	~CWMISnapinData()
	{
		if(g_DS)
		{
			delete g_DS;
		}
	}

	SNAPINMENUID(IDR_MENU_MENU);

/*	const UINT GetMenuID()
	{ 
		return m_MenuId; 
	}

	void SetMenuID(UINT menuId)
	{
		m_MenuId = menuId;
	}
*/
	STDMETHOD(AddMenuItems)(LPCONTEXTMENUCALLBACK piCallback,
							long *pInsertionAllowed,
							DATA_OBJECT_TYPES type)
	{
		if(m_myID == 0 || m_extension)
		{
			//return CSnapInItemImpl<CWMISnapinData>::AddMenuItems(piCallback, pInsertionAllowed,type);
			return S_OK;
		}
		else
		{
			return CSnapInItemImpl<CWMISnapinData>::AddMenuItems(piCallback, pInsertionAllowed,type);
		}
	}

    STDMETHOD(Command)(long lCommandID,		
						CSnapInObjectRootBase* pObj,		
						DATA_OBJECT_TYPES type)
	{
		HRESULT hr = S_OK;
		if(type == CCT_SCOPE)
		{
			switch(lCommandID)
			{
			case ID_TOP_RECONNECT:
				{
					if(m_myID == 0)
					{
					}
					else
					{
						TCHAR name[256] = {0};
						bool isLocal = g_DS->IsLocal();
						LOGIN_CREDENTIALS *credentials = g_DS->GetCredentials();

						INT_PTR x = CUIHelpers::DisplayCompBrowser(NULL, name, 
													256, 
													&isLocal, credentials);
						if(x == IDOK)
						{
							if(isLocal)
							{
								// an empty string will cause a local connection.
								name[0] = '\0';
							}
							_tcscpy(m_MachineName,name);
							g_DS->SetMachineName(CHString1(name));

							CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(m_spConsole);
							SCOPEDATAITEM scope;
							TCHAR name[150] = {0};
							BuildRootNodeName(name);

							memset(&scope, 0, sizeof(SCOPEDATAITEM));
							scope.mask = SDI_STR;
							scope.displayname = name;
							scope.ID = m_myID;

							HRESULT z = spConsoleNameSpace->SetItem(&scope);
						}
					}
				}
				break;

			case ID_PERF_COUNTERS:
			{
				try
				{
					CWMICtrSysmonDlg *test;
					test = new CWMICtrSysmonDlg((LPCTSTR)g_DS->m_whackedMachineName);
					test->DoModal();
					eStatusInfo st = test->GetStatus();
					if(st == Status_CounterNotFound)
					{
						TCHAR strTemp[1024];
						if(::LoadString(_Module.GetModuleInstance(),IDC_RETRY_TEXT,strTemp,1024) <= 0)
						{
							_tcscpy(strTemp,_T("Could Not Connect to WMI Using Logged on User. WMIControl will try to display the counters as Text"));
						}

						TCHAR strHead[1024];
						if(::LoadString(_Module.GetModuleInstance(),IDC_ERROR_CAPTION,strHead,1024) <= 0)
						{
							_tcscpy(strHead,_T("WMIControl - Error"));
						}

						MessageBox(NULL,strTemp,strHead,MB_OK);
						CWmiCtrsDlg *CtrsDlg;	//g_DS
						CtrsDlg = new CWmiCtrsDlg((LPCTSTR)g_DS->m_whackedMachineName,g_DS->GetCredentials());
						CtrsDlg->DoModal(NULL);
					}
				}
				catch(...)
				{
					MessageBox(NULL,_T("Error Occured"),_T("Exception"),MB_OK);
				}
			}
			default: break;
			}
		}
		return hr;
	}
    
	STDMETHOD (BuildRootNodeName)(TCHAR *name)
	{
		HRESULT hr = E_FAIL;

		LoadString(_Module.GetResourceInstance(), 
					IDS_DISPLAY_NAME, 
					name, 150);
		if(g_DS)
		{
			if(g_DS->IsLocal())
			{
				TCHAR local[20] = {0};
				LoadString(_Module.GetResourceInstance(), 
							IDS_LOCAL_COMPUTER, 
							local, 20);

				_tcscat(name, local);
			}
			else
			{
				TCHAR machine[100] = {0};
				_tcscpy(machine, (LPCTSTR)g_DS->m_whackedMachineName);

				_tcsupr(machine);
				_tcscat(name, _T(" ("));

				// NOTE: skip the leading whacks
				_tcscat(name, (LPCTSTR)&machine[2]);
				_tcscat(name, _T(")"));
			}
			hr = S_OK;
		}

		return hr;
	}



	STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream)
	{
		HRESULT hr = DV_E_CLIPFORMAT;

		if(cf == m_CCF_DISPLAY_NAME)
		{
			ULONG uWritten;
			TCHAR name[150] = {0};

			BuildRootNodeName(name);

			hr = pStream->Write(name, (ocslen((OLECHAR*)name) + 1) * sizeof(OLECHAR), &uWritten);
		}
		else
		{
			hr = CSnapInItemImpl<CWMISnapinData>::FillData(cf, pStream);
		}
		return hr;
	}

	STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem);

	STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem);

    STDMETHOD(GetResultViewType)(LPOLESTR *ppViewType,
							        long *pViewOptions)
	{
		*pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

		LPOLESTR psz = NULL;
		StringFromCLSID(CLSID_MessageView, &psz);
		
		*ppViewType = (LPOLESTR)CoTaskMemAlloc(sizeof(OLECHAR)*(lstrlen(psz)+1));
		if (!*ppViewType)
			return E_OUTOFMEMORY;
		lstrcpy(*ppViewType, psz);
		return S_OK;
  	}

	STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
						LPARAM arg,
						LPARAM param,
						IComponentData* pComponentData,
						IComponent* pComponent,
						DATA_OBJECT_TYPES type);

	LPOLESTR GetResultPaneColInfo(int nCol);

    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
									LONG_PTR handle, 
									IUnknown* pUnk,
									DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		return S_OK;
	}


	CWMISnapinExtData *m_parent;
	CComPtr<IConsole> m_spConsole;
	LPPROPERTYSHEETCALLBACK m_lpProvider;

	wchar_t m_nodeType[50];
	wchar_t m_nodeDesc[100];
	wchar_t m_descBar[100];
	HSCOPEITEM m_myID;
	UINT m_MenuId;


};

class CWMISnapinExtData : public CSnapInItemImpl<CWMISnapinExtData, TRUE>,
							public CComObject<CSnapInDataObjectImpl>
{
private:
	wchar_t m_nodeName[50];
	CWMISnapinData *m_pScopeItem;

public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

	CWMISnapinExtData() 
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
		m_scopeDataItem.displayname = MMC_CALLBACK;
		m_scopeDataItem.nImage = IDI_WMICNTL; 		// May need modification
		m_scopeDataItem.nOpenImage = IDI_WMICNTL; 	// May need modification
		m_scopeDataItem.lParam = (LPARAM) this;

		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
		m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
		m_resultDataItem.str = MMC_CALLBACK;
		m_resultDataItem.nImage = IDI_WMICNTL;		// May need modification
		m_resultDataItem.lParam = (LPARAM) this;

		m_pScopeItem = NULL;
		memset(m_nodeName, 0, 50 * sizeof(wchar_t));
		if(::LoadString(_Module.GetModuleInstance(), IDS_DISPLAY_NAME, m_nodeName, 50) == 0)
		{
			wcscpy(m_nodeName, L"WMI Control");
		}
	}

	~CWMISnapinExtData()
	{
	}

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		return S_OK;
	}

	IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		// Modify to return a different CSnapInItem* pointer.
		return pDefault;
	}

    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
						LPARAM arg,
						LPARAM param,
						IComponentData* pComponentData,
						IComponent* pComponent,
						DATA_OBJECT_TYPES type);

	STDMETHOD(GetDataHere)(FORMATETC* pformatetc, STGMEDIUM* pmedium);
	wchar_t* MachineName();
	wchar_t m_MachineName[255];

};

class CWMISnapin;

class CWMISnapinComponent : public CComObjectRootEx<CComSingleThreadModel>,
							public CSnapInObjectRoot<2, CWMISnapin >,
							public IExtendPropertySheetImpl<CWMISnapinComponent>,
							public IComponentImpl<CWMISnapinComponent>
{
public:
BEGIN_COM_MAP(CWMISnapinComponent)
	COM_INTERFACE_ENTRY(IComponent)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
END_COM_MAP()


public:
	CWMISnapinComponent()
	{
	}

	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
	{
		if (lpDataObject != NULL && lpDataObject != DOBJ_CUSTOMOCX)
			return IComponentImpl<CWMISnapinComponent>::Notify(lpDataObject, event, arg, param);
		// TODO : Add code to handle notifications that set lpDataObject == NULL.
		return E_NOTIMPL;
	}

};

class CWMISnapin : public CComObjectRootEx<CComSingleThreadModel>,
					public CSnapInObjectRoot<1, CWMISnapin>,
					public IComponentDataImpl<CWMISnapin, CWMISnapinComponent>,
					public IExtendPropertySheetImpl<CWMISnapin>,
					public IExtendContextMenuImpl<CWMISnapin>,
					public CComCoClass<CWMISnapin, &CLSID_WMISnapin>,
					public IPersistStream,
					public ISnapinHelp
{
public:
	CWMISnapin() : m_bDirty(false)

	{
		m_pNode = new CWMISnapinData;
		_ASSERTE(m_pNode != NULL);
		m_pComponentData = this;
	}

	~CWMISnapin()
	{
		delete m_pNode;
		m_pNode = NULL;
	}

EXTENSION_SNAPIN_DATACLASS(CWMISnapinExtData)

BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CWMISnapin)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CWMISnapinExtData)
END_EXTENSION_SNAPIN_NODEINFO_MAP()


BEGIN_COM_MAP(CWMISnapin)
	COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(ISnapinHelp)
	COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()

// NOTE: using UpdateRegistry() directly so I can localize for "PRETTYNAME".
//DECLARE_REGISTRY_RESOURCEID(IDR_WMISNAPIN)

DECLARE_NOT_AGGREGATABLE(CWMISnapin)

	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
	{
		HRESULT hr;
		TCHAR pName[100] = {0};
		if(::LoadString(_Module.GetModuleInstance(), IDS_DISPLAY_NAME, 
							pName, 100) <= 0)
		{
			wcscpy(pName, _T("WMI Control"));
		}

		TCHAR dispName[100] = {0};
        TCHAR szModule[_MAX_PATH];
        ::GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
        _stprintf( dispName,_T("@%s,-%d"), szModule, IDS_DISPLAY_NAME);

		
		_ATL_REGMAP_ENTRY regMap[] = {{ OLESTR("PRETTYNAME"), pName },
										{ OLESTR("NAMESTRINGINDIRECT"),dispName},
										{ 0, 0 }};

		hr = _Module.UpdateRegistryFromResourceD(IDR_WMISNAPIN, TRUE, regMap);

		return hr;
	}

	STDMETHOD(Initialize)(LPUNKNOWN pUnknown);

	static void WINAPI ObjectMain(bool bStarting)
	{
		if (bStarting)
			CSnapInItem::Init();
	}

    STDMETHOD(GetHelpTopic)(LPOLESTR *lpCompiledHelpFile)
	{
		if(lpCompiledHelpFile == NULL)
			return E_POINTER;    

		wchar_t helpDir[_MAX_PATH];
		memset(helpDir, 0, _MAX_PATH * sizeof(wchar_t));

		if(GetSystemWindowsDirectory(helpDir, _MAX_PATH) != 0)
		{
			wcscat(helpDir, L"\\Help");
			wcscat(helpDir, L"\\newfeat1.chm");

			*lpCompiledHelpFile = reinterpret_cast<LPOLESTR>(
										CoTaskMemAlloc((wcslen(helpDir) + 1) * 
															sizeof(wchar_t)));

			if(*lpCompiledHelpFile == NULL)        
				return E_OUTOFMEMORY;

			USES_CONVERSION;
			wcscpy(*lpCompiledHelpFile, T2OLE((LPTSTR)(LPCTSTR)helpDir));
			return S_OK;
		}
		return E_UNEXPECTED;
	}

	// IPersistStream methods
	STDMETHOD(GetClassID)(CLSID *pClassID);
	STDMETHOD(IsDirty)();
	STDMETHOD(Load)(IStream *pStm);
	STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

    STDMETHOD(CompareObjects)( LPDATAOBJECT lpDataObjectA,
								LPDATAOBJECT lpDataObjectB)
	{
		CSnapInItem *alpha = NULL, *beta = NULL;
		DATA_OBJECT_TYPES able, baker;

		HRESULT hr = GetDataClass(lpDataObjectA, &alpha, &able);
		hr = GetDataClass(lpDataObjectB, &beta, &baker);
		return (alpha == beta ? S_OK : S_FALSE);
	}

private:
	HRESULT ReadStream(IStream *pStm, void *data, ULONG *size);
	bool m_bDirty;  // for the IPersistStream

	HRESULT LoadIcon(CComPtr<IImageList> &spImageList, 
					   UINT resID);

};

class ATL_NO_VTABLE CWMISnapinAbout : public ISnapinAbout,
										public CComObjectRoot,
										public CComCoClass< CWMISnapinAbout, &CLSID_WMISnapinAbout>
{
public:
	DECLARE_REGISTRY(CWMISnapinAbout, _T("WMISnapinAbout.1"), _T("WMISnapinAbout.1"), IDS_WMISNAPIN_DESC, THREADFLAGS_BOTH);

	BEGIN_COM_MAP(CWMISnapinAbout)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

	STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
	{
		USES_CONVERSION;
		TCHAR szBuf[256] = {0};
		if (::LoadString(_Module.GetResourceInstance(), IDS_WMISNAPIN_DESC, szBuf, 256) == 0)
			return E_FAIL;

		*lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpDescription == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpDescription, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetProvider)(LPOLESTR *lpName)
	{
		USES_CONVERSION;
		TCHAR szBuf[256] = {0};
		if (::LoadString(_Module.GetResourceInstance(), IDS_WMISNAPIN_PROVIDER, szBuf, 256) == 0)
			return E_FAIL;

		*lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpName == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpName, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
	{
		USES_CONVERSION;
		TCHAR szBuf[256] = {0};
		if (::LoadString(_Module.GetResourceInstance(), IDS_WMISNAPIN_VERSION, szBuf, 256) == 0)
			return E_FAIL;

		*lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpVersion == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpVersion, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
	{
		*hAppIcon = LoadIcon(_Module.GetResourceInstance(),
								MAKEINTRESOURCE(IDI_WMICNTL));
		return S_OK;
	}

	STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage,
									HBITMAP *hSmallImageOpen,
									HBITMAP *hLargeImage,
									COLORREF *cMask)
	{
		*hSmallImageOpen = LoadBitmap(_Module.GetResourceInstance(), 
										MAKEINTRESOURCE(IDB_WMISNAPIN_16));
		
		*hSmallImage = LoadBitmap(_Module.GetResourceInstance(), 
									MAKEINTRESOURCE(IDB_WMISNAPIN_16));
		
		*hLargeImage = LoadBitmap(_Module.GetResourceInstance(), 
									MAKEINTRESOURCE(IDB_WMISNAPIN_32));
		*cMask = RGB(255,255,255);
		return S_OK;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\bvtadapt.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Test app to test the hi perf portion of the WMIPROV.DLL
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <process.h>
//#include <objbase.h>
#include <stdio.h>
#include <wbemcli.h>
//#include <wbemint.h>
//#include <wbemcomn.h>
//#include <cominit.h>


///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT WbemSetProxyBlanket( IUnknown *pInterface, DWORD dwAuthnSvc, DWORD dwAuthzSvc, OLECHAR *pServerPrincName,
                             DWORD dwAuthLevel, DWORD dwImpLevel, RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
                             DWORD dwCapabilities )
{
    IUnknown * pUnk = NULL;
    IClientSecurity * pCliSec = NULL;

    HRESULT sc = pInterface->QueryInterface(IID_IUnknown, (void **) &pUnk);
    if(sc != S_OK)
        return sc;

    sc = pInterface->QueryInterface(IID_IClientSecurity, (void **) &pCliSec);
    if(sc != S_OK)
    {
        pUnk->Release();
        return sc;
    }


    sc = pCliSec->SetBlanket(pInterface, dwAuthnSvc, dwAuthzSvc, pServerPrincName, dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities);
    pCliSec->Release();
    pCliSec = NULL;
    sc = pUnk->QueryInterface(IID_IClientSecurity, (void **) &pCliSec);
    if(sc == S_OK)
    {
        sc = pCliSec->SetBlanket(pUnk, dwAuthnSvc, dwAuthzSvc, pServerPrincName, dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities);
        pCliSec->Release();
    }
    else if (sc == 0x80004002)
        sc = S_OK;
    pUnk->Release();
    return sc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Function:	main
//
///////////////////////////////////////////////////////////////////////////////////////////////////////

#define	NUMINSTANCES	1

IWbemServices*	g_pNameSpace = NULL;
WCHAR			g_wcsObjectPath[2048];
DWORD			g_dwNumReps = 1;
DWORD			g_dwNumThreads = 1;
BOOL			g_fAddDel = FALSE;

unsigned __stdcall RefreshThread( void * pvData )
{
	DWORD	dwThreadId = (DWORD) pvData;

	IWbemRefresher*				pRefresher = NULL;
	IWbemConfigureRefresher*	pConfig = NULL;
	BOOL						fEnum = FALSE;

	CoInitializeEx( NULL, COINIT_MULTITHREADED );

	HRESULT hr = CoCreateInstance( CLSID_WbemRefresher, NULL, CLSCTX_INPROC_SERVER, IID_IWbemRefresher, (void**) &pRefresher );
	if ( SUCCEEDED( hr ) )
	{
		IWbemConfigureRefresher*	pConfig = NULL;

		// Need an interface through which we can configure the refresher
		hr = pRefresher->QueryInterface( IID_IWbemConfigureRefresher, (void**) &pConfig );

		if ( SUCCEEDED( hr ) )
		{
			IWbemClassObject*		pRefreshable = NULL;
			IWbemHiPerfEnum*		pEnum = NULL;
			long					lID = 0;
			IWbemObjectAccess*		pObjAccess = NULL;
			IWbemClassObject*		pObj = NULL;

			// Add an object or an enumerator.  If the path to the object contains
			// an L'=', then it is an object path, otherwise we assume it is a class
			// name and therefore return an enumerator.

			if ( NULL != wcschr( g_wcsObjectPath, L'=' ) )
			{
				if ( !g_fAddDel )
				{
					hr = pConfig->AddObjectByPath( g_pNameSpace, g_wcsObjectPath, 0, NULL, &pObj, &lID );

					if ( SUCCEEDED( hr ) )
					{
						pObj->QueryInterface( IID_IWbemObjectAccess, (void**) &pObjAccess );
						pObj->Release();
					}
					else
					{
						printf( "AddObjectByPath() failed, 0x%x\n", hr );
					}

				}

			}
			else
			{
				if ( !g_fAddDel )
				{
					hr = pConfig->AddEnum( g_pNameSpace, g_wcsObjectPath, 0, NULL, &pEnum, &lID );

					if ( FAILED(hr) )
					{
						printf( "AddEnum() failed, 0x%x\n", hr );
					}
				}

				fEnum = TRUE;
			}

			// Add an object and then the enumerator
			if ( SUCCEEDED( hr ) )
			{
				DWORD				dwNumReturned = NUMINSTANCES;
				BOOL				fGotHandles = 0;

				DWORD	dwValue = 0,
						dwNumObjects = 0;
				WORD	wValue = 0;
				BYTE	bVal = 0;
				IWbemObjectAccess**	apEnumAccess = NULL;

				for ( DWORD x = 0; SUCCEEDED( hr ) && x < g_dwNumReps; x++ )
				{
					if ( g_fAddDel )
					{
						if ( fEnum )
						{
							hr = pConfig->AddEnum( g_pNameSpace, g_wcsObjectPath, 0, NULL, &pEnum, &lID );
						}
						else
						{
							hr = pConfig->AddObjectByPath( g_pNameSpace, g_wcsObjectPath, 0, NULL, &pObj, &lID );

							if ( SUCCEEDED( hr ) )
							{
								pObj->QueryInterface( IID_IWbemObjectAccess, (void**) &pObjAccess );
								pObj->Release();
							}
						}
					}

					// Refresh and if we have an enumerator, retrieve the
					// objects and release them

					hr = pRefresher->Refresh( 0L );

					if ( pEnum )
					{
						hr = pEnum->GetObjects( 0L, dwNumObjects, apEnumAccess, &dwNumReturned );

						if ( FAILED( hr ) && WBEM_E_BUFFER_TOO_SMALL == hr )
						{
							IWbemObjectAccess**	apTempAccess = new IWbemObjectAccess*[dwNumReturned];

							if ( NULL != apTempAccess )
							{
								ZeroMemory( apTempAccess, dwNumReturned * sizeof(IWbemObjectAccess*) );

								if ( NULL != apEnumAccess )
								{
									CopyMemory( apTempAccess, apEnumAccess, dwNumObjects * sizeof(IWbemObjectAccess*) );
									delete [] apEnumAccess;
								}

								// Store the new values and retry
								apEnumAccess = apTempAccess;
								dwNumObjects = dwNumReturned;

								hr = pEnum->GetObjects( 0L, dwNumObjects, apEnumAccess, &dwNumReturned );
							}
							else
							{
								hr = WBEM_E_OUT_OF_MEMORY;
							}

						}	// IF Buffer too small


						for ( DWORD nCtr = 0; nCtr < dwNumReturned; nCtr++ )
						{
							apEnumAccess[nCtr]->Release();
						}

					}	// IF refresh succeeded


					printf ( "Thread %d Refreshed %d instances of %S from provider: rep# %d\n", dwThreadId, dwNumReturned, g_wcsObjectPath, x );

					if ( g_fAddDel )
					{
						if ( fEnum )
						{
							pConfig->Remove( lID, 0L );
							if (pEnum)
								pEnum->Release();
						}
						else
						{
							if (pObjAccess)
								pObjAccess->Release();
							pObjAccess = NULL;
						}
					}


				}	// FOR Refresh

				// Release anything we got back from the refresher and any
				// memory we may have allocated.
				if ( fEnum )
				{
					if ( !g_fAddDel && pEnum )
						pEnum->Release();

					if ( NULL != apEnumAccess )
					{
						delete [] apEnumAccess;
					}

				}
				else
				{
					if ( !g_fAddDel && pObjAccess)
						pObjAccess->Release();
				}

			}

			if (pConfig)
				pConfig->Release();
		}

		// Cleanup
		g_pNameSpace->Release();

	}

	if ( NULL != pRefresher )
		pRefresher->Release();

	CoUninitialize();

	return 0;

}

extern "C" int __cdecl main( int argc, char *argv[] )
{
	WCHAR	wcsSvrName[256];
	BOOL	fEnum = FALSE;

	wcscpy( wcsSvrName, L"." );

	CoInitializeEx( NULL, COINIT_MULTITHREADED );
//	InitializeSecurity(RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE );

	// See if we were told to go remote or not.
	if ( argc > 1 )
	{
		MultiByteToWideChar( CP_ACP, 0L, argv[1], -1, g_wcsObjectPath, 2048 );

		if ( argc > 2 )
		{
			g_fAddDel = strtoul( argv[2], NULL, 10 );

			if ( argc > 3 )
			{
				g_dwNumReps = strtoul( argv[3], NULL, 10 );

				if ( argc > 4 )
				{
					g_dwNumThreads = strtoul( argv[4], NULL, 10 );

					if ( argc > 5 )
					{
						MultiByteToWideChar( CP_ACP, 0L, argv[5], -1, wcsSvrName, 2048 );
					}
				}
			}
		}
	}
	else
	{
		printf( "No object path!\n" );
		printf( "Usage: refreshertest.exe <object_path> <delete_object> <Num_Refreshes> <Num_threads> <Server - Opt>\n" );
		return 0;
	} 

	IWbemLocator*		pWbemLocator = NULL;

	HRESULT hr = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void**) &pWbemLocator );

	WCHAR	wszNameSpace[255];

	swprintf( wszNameSpace, L"\\\\%s\\root\\wmi", wcsSvrName );

	// Name space to connect to
	BSTR	bstrNameSpace = SysAllocString( wszNameSpace );

	hr = pWbemLocator->ConnectServer(	bstrNameSpace,	// NameSpace Name
										NULL,			// UserName
										NULL,			// Password
										NULL,			// Locale
										0L,				// Security Flags
										NULL,			// Authority
										NULL,			// Wbem Context
										&g_pNameSpace		// Namespace
										);

	SysFreeString( bstrNameSpace );

	if ( SUCCEEDED( hr ) )
	{

		WbemSetProxyBlanket(g_pNameSpace, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CONNECT, 
						RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

		HANDLE*	ahThreads = new HANDLE[g_dwNumThreads];

		for ( DWORD	dwCtr = 0; dwCtr < g_dwNumThreads; dwCtr++ )
		{
			ahThreads[dwCtr] = (HANDLE) _beginthreadex( NULL, 0, RefreshThread, (void*) dwCtr, 0, NULL );
			Sleep(1000);
		}

		// Wait for all the threads to get signalled
		WaitForMultipleObjects( g_dwNumThreads, ahThreads, TRUE, INFINITE );

		delete [] ahThreads;

	}

	// Cleanup main objects
	if ( NULL != pWbemLocator )
		pWbemLocator->Release();

	CoUninitialize();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\bvtcore.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int BasicConnectUsingIWbemLocator( )
{
    int nRc = SUCCESS;
    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    //	InitializeSecurity(RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE );
    HRESULT hr = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void**) &pWbemLocator );
    if( hr != S_OK )
    {
        g_LogFile.LogError( _T(__FILE__),__LINE__,FATAL_ERROR, L"InitializeAndConnectToWMI failed. HRESULT from CoCreateInstance was: 0x%x" hr );
        nRc = FATAL_ERROR;
    }

    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            nRc = TestSimpleRepositoryPhase();
            //=================================================================
            // [1] Basic connect using IWbemLocator 
            //=================================================================
            nRc = BasicConnectUsingIWbemLocator();

            //=============================================================
            // [2] Basic connect sync & async using IWbemConnection
            //=============================================================
            nRc = BasicConnectSyncAndAsyncViaIWbemConnection();

           //=============================================================
           // [3] Create a new test namespace
           //=============================================================
            nRc = CreateNewTestNamespace();

           //=============================================================
           // [4] Create 10 classes with different properties. Some of 
           // these should be in the following inheritance chain and 
           // some should not inherit from the others at all:  
           // classes = {A, B, C, D:A, E:A, F:E, G:F, H:G, I:F}.  
           // A mix of simple string & sint32 keys are fine.
           //=============================================================
            nRc = CreateNewClassesInTestNamespace();

           //=============================================================
           // [5] "memorize the class definitions".  In a complex loop, 
           // delete the classes and recreate them in various sequences, 
           // ending with the full set.
           //=============================================================
            nRc = DeleteAndRecreateNewClassesInTestNamespace();

           //=============================================================
           // [6] Query all classes and ensure the starting hierarchy is intact and that classes are binary-identical to what they started as.
[7] Create instances of the above classes, randomly creating and deleting in a loop, finishing up with a known set.  Query the instances and ensure that no instances disappeared or appeared that shouldn't be there.
[8] Verify that deletion of instances works.
[9] Verify that deletion of a class takes out all the instances.
[10] Call each of the sync & async APIs at least once.
[11] Create some simple association classes 
[12] Execute some simple refs/assocs queries over these and ensure they work.
[13] Open an association endpoint as a collection (Whistler-specific) and enumerate, ensure that results are identical to [11].
[14] Open a scope and do sets of simple instances operations (create, enum,query, update, delete)


Complex Repository Phase
[15] Rerun the above tests in parallel from several threads in different namespaces.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\snapin\wmicntl.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// WMICntl.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f WMICntlps.mk in the project directory.

#include "precomp.h"
#include "..\resource.h"
#include <initguid.h>
#include "WMICntl.h"

#include "WMICntl_i.c"
#include "WMISnapin.h"


//CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_WMISnapin, CWMISnapin)
OBJECT_ENTRY(CLSID_WMISnapinAbout, CWMISnapinAbout)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
		CSnapInItem::Init();
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\app\wmicntl.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// WMICtl5.cpp : 
//

#include "precomp.h"
//#include <winres.h>

#include "resource.h"

#include "GenPage.h"
#include "LogPage.h"
#include "BackupPage.h"
#include "NSPage.h"
#include "AdvPage.h"
#include "chklist.h"
#include <stdio.h>
#include <tchar.h>

//CExeModule _Module;

#include "DataSrc.h"
DataSource *g_DS = NULL;

//--------------------------------------------------
int CALLBACK PropSheetProc(HWND hwndDlg,
							UINT uMsg,
							LPARAM lParam)
{
	if(uMsg == PSCB_INITIALIZED) 
	{
		SendMessage(hwndDlg, WM_SETICON, TRUE, 
					SendMessage(hwndDlg, WM_GETICON, FALSE, 0));
	}
	return 0;
}

//----------------------------------------------------------------------
void GetStringFileInfo(LPCTSTR filename, LPCTSTR key, LPTSTR str, UINT size)
{
	DWORD infoSize = 0;
	UINT  valSize = 0;
	LPBYTE info = NULL;
	DWORD handle = 0;
	LPVOID verStr = NULL;
	DWORD *TransBlk = NULL;
	TCHAR blockStr[100] = {0};
	TCHAR helpDir[_MAX_PATH] = {0};

	if(GetSystemDirectory(helpDir, _MAX_PATH) != 0)
	{
		_tcscat(helpDir, _T("\\"));
		_tcscat(helpDir, filename);

		infoSize = GetFileVersionInfoSize((LPTSTR)helpDir, &handle);
		DWORD x = GetLastError();
	}

	if(infoSize)
	{
		info = new BYTE[infoSize];

		if(info == NULL)
			return;

		if(GetFileVersionInfo((LPTSTR)helpDir, handle,
								infoSize, info))
		{
			// get the translation block.
			// NOTE: This assumes that the localizers REPLACE the english with
			// the 'other' language so there will only be ONE entry in the
			// translation table. If we ever do a single binary that supports
			// multiple languages, it's a whole nother ballgame folks.
			if(VerQueryValue(info, _T("\\VarFileInfo\\Translation"),
								(void **)&TransBlk, &valSize))
			{

			   _stprintf(blockStr, _T("\\StringFileInfo\\%04hX%04hX\\%s"),
						 LOWORD(*TransBlk),
						 HIWORD(*TransBlk),
						 key);

				if(VerQueryValue(info, (LPTSTR)blockStr,
									(void **)&verStr, &valSize))
				{
					if(size >= valSize)
					{
						_tcscat(str, (LPTSTR)verStr);
					}
					else
					{
						_tcscat(str, _T("Unknown"));
					}
				} //endif VerQueryValue()
			}

		} //endif GetFileVersionInfo()

		delete[] (LPBYTE)info;

	} // endif infoSize
}
//----------------------------------------------------------------------------
bool HTMLSupported(void)
{
	bool retval = false;
	TCHAR ver[30] = {0};

	GetStringFileInfo(_T("hhctrl.ocx"), _T("FileVersion"), ver, 30);
	
	if(_tcslen(ver))
	{
		if(_tcsncmp(ver, _T("4.73.8252"), 9) >= 0)
		{
			retval = true;
		}
	}
	return retval;
}

//----------------------------------------------------------------------------
BOOL BuildSheet()
{
    HPROPSHEETPAGE hPage[5];
    UINT cPages = 0;
    BOOL bResult = FALSE;

	bool htmlSupport = HTMLSupported();
	// General tab.
	CGenPage *pPage = new CGenPage(g_DS, htmlSupport);
	if(pPage)
	{
		hPage[cPages] = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_GENERAL), 0, PSP_HASHELP);
	}
    if(hPage[cPages])
        cPages++;

	// Logging Tab.
	CLogPage *pPage1 = new CLogPage(g_DS, htmlSupport);
	if(pPage1)
	{
		hPage[cPages] = pPage1->CreatePropSheetPage(MAKEINTRESOURCE(IDD_LOGGING), 0, PSP_HASHELP);
	}
    if(hPage[cPages])
        cPages++;

	// Backup Tab.
	CBackupPage *pPage2 = new CBackupPage(g_DS, htmlSupport);
	if(pPage2)
	{
		hPage[cPages] = pPage2->CreatePropSheetPage(MAKEINTRESOURCE(IDD_BACKUP), 0, PSP_HASHELP);
	}
    if(hPage[cPages])
        cPages++;

	// Security Tab.
	CNamespacePage *pPage3 = new CNamespacePage(g_DS, htmlSupport);
	if(pPage3)
	{
		hPage[cPages] = pPage3->CreatePropSheetPage(MAKEINTRESOURCE(IDD_NAMESPACE), 0, PSP_HASHELP);
	}
    if(hPage[cPages])
        cPages++;

	// Advanced Tab.
	CAdvancedPage *pPage4 = new CAdvancedPage(g_DS, htmlSupport);
	if(pPage4)
	{
		hPage[cPages] = pPage4->CreatePropSheetPage(MAKEINTRESOURCE(IDD_ADVANCED_9X), 0, PSP_HASHELP);
	}
    if(hPage[cPages])
        cPages++;

	// the sheet.
    if(cPages)
    {
        // Build dialog title string
        TCHAR szTitle[MAX_PATH] = {0};
        LoadString(_Module.GetModuleInstance(), IDR_MAINFRAME, 
					szTitle, sizeof(szTitle));

        PROPSHEETHEADER psh;
        psh.dwSize = sizeof(psh);
        psh.dwFlags = PSH_DEFAULT | PSH_USEHICON |PSH_USECALLBACK|PSH_HASHELP;
        psh.hwndParent = NULL;
        psh.hInstance = _Module.GetModuleInstance();
        psh.pszCaption = szTitle;
        psh.nPages = cPages;
        psh.hIcon = LoadIcon(_Module.GetModuleInstance(), 
							  MAKEINTRESOURCE(IDI_WMICNTL));
        psh.nStartPage = 0;
        psh.phpage = &hPage[0];
        psh.nStartPage = 0;
		psh.pfnCallback = PropSheetProc;
        bResult = PropertySheet(&psh)>0?TRUE:FALSE;
    }

    return bResult;
}

//------------------------------------------------------------------------------
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
#if (_WIN32_IE >= 0x0300)
	INITCOMMONCONTROLSEX iccx;
	iccx.dwSize = sizeof(iccx);
	iccx.dwICC = ICC_BAR_CLASSES | ICC_USEREX_CLASSES|ICC_LISTVIEW_CLASSES;
	::InitCommonControlsEx(&iccx);
#else
	::InitCommonControls();
#endif
	HANDLE mutex;
	// if the mutex exists.
	if((mutex = OpenMutex(MUTEX_ALL_ACCESS, NULL, 
							_T("WMICNTL:AGAINWITHTHEKLINGONS"))) != NULL)
	{
		// close and exit cuz a wmiCntl is already running.
		CHString caption, msg;
		caption.LoadString(IDS_SHORT_NAME);
		msg.LoadString(IDS_MULTI_INSTANCES);
		MessageBox(NULL, msg, caption, MB_OK|MB_ICONSTOP);
		CloseHandle(mutex);
		return 1;
	}
	else
	{
		// I'm the first, create my mutex.
		mutex = CreateMutex(NULL, TRUE, _T("WMICNTL:AGAINWITHTHEKLINGONS"));
	}

	_Module.Init(NULL, hInstance);
	RegisterCheckListWndClass();
	g_DS = new DataSource;
	g_DS->SetMachineName(CHString1(""));

	BuildSheet();

	CloseHandle(mutex);
	_Module.Term();
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\shell\atlui\wmicntl\snapin\wmisnapin.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
#include "precomp.h"
#include "WMICntl.h"
#include "WMISnapin.h"
#include "..\common\util.h"
#include "..\GenPage.h"
#include "..\LogPage.h"
#include "..\BackupPage.h"
#include "..\NSPage.h"
#include "..\AdvPage.h"
#include "..\chklist.h"
#include "..\DataSrc.h"

/////////////////////////////////////////////////////////////////////////////
// CWMISnapinComponentData
static const GUID CWMISnapinGUID_NODETYPE = 
{ 0x5c659259, 0xe236, 0x11d2, { 0x88, 0x99, 0x0, 0x10, 0x4b, 0x2a, 0xfb, 0x46 } };
const GUID*  CWMISnapinData::m_NODETYPE = &CWMISnapinGUID_NODETYPE;
const OLECHAR* CWMISnapinData::m_SZNODETYPE = OLESTR("5C659259-E236-11D2-8899-00104B2AFB46");
const OLECHAR* CWMISnapinData::m_SZDISPLAY_NAME = OLESTR("WMISnapin2222");
const CLSID* CWMISnapinData::m_SNAPIN_CLASSID = &CLSID_WMISnapin;

static const GUID CWMISnapinExtGUID_NODETYPE = 
{ 0x476e6449, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
const GUID*  CWMISnapinExtData::m_NODETYPE = &CWMISnapinExtGUID_NODETYPE;
const OLECHAR* CWMISnapinExtData::m_SZNODETYPE = OLESTR("476e6449-aaff-11d0-b944-00c04fd8d5b0");
const OLECHAR* CWMISnapinExtData::m_SZDISPLAY_NAME = OLESTR("WMISnapin33333");
const CLSID* CWMISnapinExtData::m_SNAPIN_CLASSID = &CLSID_WMISnapin;



//-------------------------------------------------------------
CWMISnapinData::CWMISnapinData(bool extension)
							: m_extension(extension),
							m_parent(0)
{
	// Image indexes may need to be modified depending on the images specific to 
	// the snapin.
//	SetMenuID(IDR_MENU_MENU);
	memset(m_MachineName, 0, 255 * sizeof(wchar_t));
	memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
	m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM|SDI_CHILDREN;
	m_scopeDataItem.displayname = MMC_CALLBACK;
	m_scopeDataItem.nImage = IDI_WMICNTL; 		// May need modification
	m_scopeDataItem.nOpenImage = IDI_WMICNTL; 	// May need modification
	m_scopeDataItem.cChildren = 0; 				// May need modification
	m_scopeDataItem.lParam = (LPARAM) this;

	memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
	m_resultDataItem.str = MMC_CALLBACK;
	m_resultDataItem.nImage = IDI_WMICNTL;		// May need modification
	m_resultDataItem.lParam = (LPARAM) this;
	memset(m_nodeType, 0, 50 * sizeof(wchar_t));

	if(::LoadString(_Module.GetModuleInstance(), IDS_SNAPIN_TYPE, m_nodeType, 50) == 0)
	{
		wcscpy(m_nodeType, L"Snapin Extension");
	}

	memset(m_nodeDesc, 0, 100 * sizeof(wchar_t));
	if(::LoadString(_Module.GetModuleInstance(), IDS_DESCRIPTION, m_nodeDesc, 100) == 0)
	{
		wcscpy(m_nodeDesc, L"<unavailable>");
	}

	memset(m_descBar, 0, 100 * sizeof(wchar_t));
	if(::LoadString(_Module.GetModuleInstance(), IDS_PROJNAME, m_descBar, 100) == 0)
	{
		wcscpy(m_descBar, L"WMI Control");
	}

	m_spConsole = NULL;
	m_lpProvider = NULL;
	m_myID = 0;
	g_DS = NULL;
	memset(m_initMachineName, 0, 255 * sizeof(wchar_t));
}


//-------------------------------------------------------------
HRESULT CWMISnapinData::GetScopePaneInfo(SCOPEDATAITEM *pScopeDataItem)
{
	if (pScopeDataItem->mask & SDI_STR)
		pScopeDataItem->displayname = m_bstrDisplayName;
	if (pScopeDataItem->mask & SDI_IMAGE)
		pScopeDataItem->nImage = m_scopeDataItem.nImage;
	if (pScopeDataItem->mask & SDI_OPENIMAGE)
		pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
	if (pScopeDataItem->mask & SDI_PARAM)
		pScopeDataItem->lParam = m_scopeDataItem.lParam;
	if (pScopeDataItem->mask & SDI_STATE )
		pScopeDataItem->nState = m_scopeDataItem.nState;

	// TODO : Add code for SDI_CHILDREN 
	return S_OK;
}

//-------------------------------------------------------------
HRESULT CWMISnapinData::GetResultPaneInfo(RESULTDATAITEM *pResultDataItem)
{
	if (pResultDataItem->bScopeItem)
	{
		if (pResultDataItem->mask & RDI_STR)
		{
			pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
		}
		if (pResultDataItem->mask & RDI_IMAGE)
		{
			pResultDataItem->nImage = m_scopeDataItem.nImage;
		}
		if (pResultDataItem->mask & RDI_PARAM)
		{
			pResultDataItem->lParam = m_scopeDataItem.lParam;
		}

		return S_OK;
	}

	if (pResultDataItem->mask & RDI_STR)
	{
		pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
	}
	if (pResultDataItem->mask & RDI_IMAGE)
	{
		pResultDataItem->nImage = m_resultDataItem.nImage;
	}
	if (pResultDataItem->mask & RDI_PARAM)
	{
		pResultDataItem->lParam = m_resultDataItem.lParam;
	}
	if (pResultDataItem->mask & RDI_INDEX)
	{
		pResultDataItem->nIndex = m_resultDataItem.nIndex;
	}

	return S_OK;
}

//------------------------------------------------------------------
LPOLESTR CWMISnapinData::GetResultPaneColInfo(int nCol)
{
	switch(nCol)
	{
	case 0:
		return m_bstrDisplayName;
		break;
	case 1:
		return m_nodeType;
		break;
	case 2:
		return m_nodeDesc;
		break;
	} //endswitch nCol

	return OLESTR("missed one in CWMISnapinData::GetResultPaneColInfo");
}

//------------------------------------------------------------------
HRESULT CWMISnapinData::Notify( MMC_NOTIFY_TYPE event,
								LPARAM arg,
								LPARAM param,
								IComponentData* pComponentData,
								IComponent* pComponent,
								DATA_OBJECT_TYPES type)
{
	// Add code to handle the different notifications.
	// Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
	// In response to MMCN_SHOW you have to enumerate both the scope
	// and result pane items.
	// For MMCN_EXPAND you only need to enumerate the scope items
	// Use IConsoleNameSpace::InsertItem to insert scope pane items
	// Use IResultData::InsertItem to insert result pane item.
	HRESULT hr = E_NOTIMPL;

	
	_ASSERTE(pComponentData != NULL || pComponent != NULL);

	CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeader;
	if (pComponentData != NULL)
		m_spConsole = ((CWMISnapin*)pComponentData)->m_spConsole;
	else
	{
		m_spConsole = ((CWMISnapinComponent*)pComponent)->m_spConsole;
		spHeader = m_spConsole;
	}

	switch(event)
	{
	case MMCN_CONTEXTHELP:
		{
			WCHAR topic[] = L"newfeat1.chm::wmi_control_overview.htm";
			CComQIPtr<IDisplayHelp, &IID_IDisplayHelp> displayHelp(m_spConsole);

			LPOLESTR lpCompiledHelpFile = reinterpret_cast<LPOLESTR>(
										CoTaskMemAlloc((wcslen(topic) + 1) * 
															sizeof(wchar_t)));

			if(lpCompiledHelpFile == NULL)
			{
				hr = E_OUTOFMEMORY;
			}
			else
			{
				USES_CONVERSION;
				wcscpy(lpCompiledHelpFile, T2OLE((LPTSTR)(LPCTSTR)topic));
				hr = displayHelp->ShowTopic(lpCompiledHelpFile);
			}
		}
		break;

	case MMCN_SHOW:
		{
			CComQIPtr<IResultData, &IID_IResultData> spResultData(m_spConsole);
			LPUNKNOWN pUnk = 0;
			if(SUCCEEDED(m_spConsole->QueryResultView(&pUnk)))
			{
				CComQIPtr<IMessageView, &IID_IMessageView> spMsg(pUnk);
				if(spMsg)
				{
					TCHAR title[100] = {0}, desc[256] = {0};
					::LoadString(_Module.GetResourceInstance(), IDS_PROJNAME,
									title, 100);

					::LoadString(_Module.GetResourceInstance(), IDS_DESCRIPTION,
									desc, 256);

					spMsg->SetTitleText(title);
					spMsg->SetBodyText(desc);
					spMsg->SetIcon(Icon_Information);
				}
				pUnk->Release();
			}

			hr = S_OK;
			break;
		}
	case MMCN_EXPAND:
		{
			m_myID = (HSCOPEITEM)param;
			hr = S_OK;
			break;
		}
	case MMCN_SELECT:
		{
			CComQIPtr<IResultData, &IID_IResultData> spResultData(m_spConsole);
			spResultData->SetDescBarText(m_descBar);

			if(g_DS && wcslen(m_initMachineName) != 0)
			{
				g_DS->SetMachineName(CHString1(m_initMachineName));
				memset(m_initMachineName, 0, 255 * sizeof(wchar_t));
			}

			IConsoleVerb *menu = NULL;
			if(SUCCEEDED(m_spConsole->QueryConsoleVerb(&menu)))
			{
				menu->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
				menu->SetVerbState(MMC_VERB_REFRESH, HIDDEN, TRUE);
				if(m_myID)
				{
					menu->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
					menu->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
				}
				else
				{
					menu->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);
					menu->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
				}
				menu->Release();
			}
			hr = S_OK;
		}
		break;

	case MMCN_DBLCLICK:
		hr = S_FALSE; // do the default verb. (Properties)
		break;

	case MMCN_ADD_IMAGES:
		{
			// Add Images
			IImageList* pImageList = (IImageList*) arg;
			hr = E_FAIL;
			// Load bitmaps associated with the scope pane
			// and add them to the image list
			// Loads the default bitmaps generated by the wizard
			// Change as required
			if(g_DS == 0)
			{
				g_DS = new DataSource;
				g_DS->SetMachineName(CHString1(m_parent->m_MachineName));
			}

			HICON icon = LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_WMICNTL));
			if(icon != NULL)
			{
				hr = pImageList->ImageListSetIcon((LONG_PTR*)icon, IDI_WMICNTL);
				if(FAILED(hr))
					ATLTRACE(_T("CLogDriveScopeNode::ImageListSetIcon failed\n"));
			}
			break;
		}
	}
	return hr;
}

//-----------------------------------------------------------------------------
//DataSource *g_DS = NULL;
HRESULT CWMISnapinData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
											LONG_PTR handle, 
											IUnknown* pUnk,
											DATA_OBJECT_TYPES type)
{
	HRESULT hr = E_UNEXPECTED;
	bool htmlSupport = false;

	switch(type)
	{
	case CCT_SCOPE:
		{
			bstr_t temp;
			HPROPSHEETPAGE hPage;
			BOOL bResult = FALSE;
			
			if(g_DS == 0)
			{
				g_DS = new DataSource;
				g_DS->SetMachineName(CHString1(L""));
			}

			// General tab.
			CGenPage *pPage = new CGenPage(g_DS, htmlSupport);
			if(pPage)
			{
				hPage = pPage->CreatePropSheetPage(MAKEINTRESOURCE(IDD_GENERAL));
				lpProvider->AddPage(hPage);
			}

			// Logging Tab.
			CLogPage *pPage1 = new CLogPage(g_DS, htmlSupport);
			if(pPage1)
			{
				hPage = pPage1->CreatePropSheetPage(MAKEINTRESOURCE(IDD_LOGGING));
				lpProvider->AddPage(hPage);
			}

			// Backup Tab.
			CBackupPage *pPage2 = new CBackupPage(g_DS, htmlSupport);
			if(pPage2)
			{
				hPage = pPage2->CreatePropSheetPage(MAKEINTRESOURCE(IDD_BACKUP));
				lpProvider->AddPage(hPage);
			}

			// Security Tab.
			CNamespacePage *pPage3 = new CNamespacePage(g_DS, htmlSupport);
			if(pPage3)
			{
				hPage = pPage3->CreatePropSheetPage(MAKEINTRESOURCE(IDD_NAMESPACE));
				lpProvider->AddPage(hPage);
			}
			CAdvancedPage *pPage4 = new CAdvancedPage(g_DS, htmlSupport);
			if(pPage4)
			{
				hPage = pPage4->CreatePropSheetPage(MAKEINTRESOURCE(IDD_ADVANCED_9X));
				lpProvider->AddPage(hPage);
			}
			hr = S_OK;

		}
		break;

	case CCT_SNAPIN_MANAGER: 
		{
			HPROPSHEETPAGE hPage;
			if(g_DS == 0)
			{
				g_DS = new DataSource;
			}

			ConnectPage *connPg = new ConnectPage(g_DS, htmlSupport);
			if(connPg)
			{
				hPage = connPg->CreatePropSheetPage(MAKEINTRESOURCE(IDD_CONNECT_WIZ));
				lpProvider->AddPage(hPage);
			}

			hr = S_OK;
		}
		break;

	default: break;
	} //endswitch

	return hr;
}


//==============================================================
//=================== SERVER NODE being extended===============
HRESULT CWMISnapinExtData::Notify(MMC_NOTIFY_TYPE event,
									LPARAM arg,
									LPARAM param,
									IComponentData* pComponentData,
									IComponent* pComponent,
									DATA_OBJECT_TYPES type)
{
	// Add code to handle the different notifications.
	// Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
	// In response to MMCN_SHOW you have to enumerate both the scope
	// and result pane items.
	// For MMCN_EXPAND you only need to enumerate the scope items
	// Use IConsoleNameSpace::InsertItem to insert scope pane items
	// Use IResultData::InsertItem to insert result pane item.
	HRESULT hr = E_NOTIMPL;
	
	_ASSERTE(pComponentData != NULL || pComponent != NULL);

	CComPtr<IConsole> spConsole;
	CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeader;
	if (pComponentData != NULL)
		spConsole = ((CWMISnapin*)pComponentData)->m_spConsole;
	else
	{
		spConsole = ((CWMISnapinComponent*)pComponent)->m_spConsole;
		spHeader = spConsole;
	}

//	Snitch(L"Storage", event);

	switch(event)
	{
	case MMCN_REFRESH:
			hr = S_OK;
			break;

	case MMCN_EXPAND:
		{
			// NOTE: I dont enum in the scope.
			CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
			if(m_pScopeItem == NULL)
			{
				//MOD VINOTH
				CWMISnapinData* p = new CWMISnapinData(true);
//				CWMISnapinData* p = new CWMISnapinData();
//				p->SetMenuID(IDR_SEC_MENU);

				p->m_scopeDataItem.relativeID = param;
				p->m_scopeDataItem.lParam = (LPARAM)p;
				p->m_bstrDisplayName = m_nodeName;
				p->m_parent = this;
				hr = spConsoleNameSpace->InsertItem(&p->m_scopeDataItem);

				ATLTRACE(L"!!!!!!!!!!!!!!!!!!!!!scope using %x\n", this);

				MachineName();
				if(p->g_DS)
					p->g_DS->SetMachineName(CHString1(MachineName()));

				m_pScopeItem = p;
			}
			hr = S_OK;
			break;
		}

	case MMCN_REMOVE_CHILDREN:
		{
			CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
			delete m_pScopeItem;
			m_pScopeItem = NULL;

			hr = spConsoleNameSpace->DeleteItem(arg, false);
		}
		break;

	case MMCN_ADD_IMAGES:
		{
			// Add Images
			IImageList* pImageList = (IImageList*) arg;
			hr = E_FAIL;

			CComQIPtr<IResultData, &IID_IResultData> spResultData(spConsole);
			spResultData->DeleteAllRsltItems();

			HICON icon = LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_WMICNTL));
			if(icon != NULL)
			{
				hr = pImageList->ImageListSetIcon((LONG_PTR*)icon, IDI_WMICNTL);
				if(FAILED(hr))
					ATLTRACE(_T("CLogDriveScopeNode::ImageListSetIcon failed\n"));
			}
			break;
		}
	}
	return hr;
}

//----------------------------------------------------------------
HRESULT CWMISnapinExtData::GetDataHere(FORMATETC* pformatetc, STGMEDIUM* pmedium)
{
	ATLTRACE(_T("SnapInDataObjectImpl::GetDataHere\n"));
	if (pmedium == NULL)
		return E_POINTER;

	CLIPFORMAT MACHINE_NAME = (CLIPFORMAT) RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");
	ULONG uWritten = 0;
	HRESULT hr = DV_E_TYMED;
	
	// Make sure the type medium is HGLOBAL
	if (pmedium->tymed == TYMED_HGLOBAL)
	{
		// Create the stream on the hGlobal passed in
		CComPtr<IStream> spStream;
		hr = CreateStreamOnHGlobal(pmedium->hGlobal, FALSE, &spStream);
		if(SUCCEEDED(hr))
		{
			if (pformatetc->cfFormat == CSnapInItem::m_CCF_SNAPIN_GETOBJECTDATA)
			{
				hr = DV_E_CLIPFORMAT;
				ULONG uWritten;
				hr = spStream->Write(&m_objectData, sizeof(CObjectData), &uWritten);
			}
			else if (pformatetc->cfFormat == MACHINE_NAME)
			{
				hr = spStream->Write(m_MachineName, (wcslen(m_MachineName) + 1) * sizeof(OLECHAR), &uWritten);
			}
			else
			{
				hr = m_objectData.m_pItem->FillData(pformatetc->cfFormat, spStream);
			}
		}
	}
	return hr;
}

//--------------------------------------------------------------------------------
wchar_t* CWMISnapinExtData::MachineName()
{
	Extract(m_pDataObject, L"MMC_SNAPIN_MACHINE_NAME", m_MachineName);
    return m_MachineName;
}

//==============================================================
//=================== STATIC NODE ==============================
HRESULT CWMISnapin::LoadIcon(CComPtr<IImageList> &spImageList, 
							   UINT resID)
{
	HRESULT hr = 0;
	HICON icon = ::LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(resID));
	if(icon != NULL)
	{
		hr = spImageList->ImageListSetIcon((LONG_PTR*)icon, resID);
		if(FAILED(hr))
			ATLTRACE(_T("CLogDriveScopeNode::ImageListSetIcon failed\n"));
	}
	return hr;
}

//----------------------------------------------------------------
HRESULT CWMISnapin::Initialize(LPUNKNOWN pUnknown)
{
#if (_WIN32_IE >= 0x0300)
	INITCOMMONCONTROLSEX iccx;
	iccx.dwSize = sizeof(iccx);
	iccx.dwICC = ICC_BAR_CLASSES | ICC_USEREX_CLASSES|ICC_LISTVIEW_CLASSES;
	::InitCommonControlsEx(&iccx);
#else
	::InitCommonControls();
#endif

	RegisterCheckListWndClass();
/*	if(g_DS == 0)
	{
		g_DS = new DataSource;
		g_DS->SetMachineName(CHString1(L""));
	}
*/
	HRESULT hr = IComponentDataImpl<CWMISnapin, CWMISnapinComponent>::Initialize(pUnknown);
	if (FAILED(hr))
		return hr;

	CComPtr<IImageList> spImageList;

	if(m_spConsole->QueryScopeImageList(&spImageList) != S_OK)
	{
		ATLTRACE(_T("IConsole::QueryScopeImageList failed\n"));
		return E_UNEXPECTED;
	}

	// Load bitmaps associated with the scope pane
	// and add them to the image list
	// Loads the default bitmaps generated by the wizard
	// Change as required
	HBITMAP hBitmap16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_WMISNAPIN_16));
	if (hBitmap16 == NULL)
		return S_OK;

	HBITMAP hBitmap32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_WMISNAPIN_32));
	if(hBitmap32 == NULL)
		return S_OK;

	if(spImageList->ImageListSetStrip((LONG_PTR*)hBitmap16, 
		(LONG_PTR*)hBitmap32, IDI_WMICNTL, RGB(0, 128, 128)) != S_OK)
	{
		ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
		return E_UNEXPECTED;
	}
	return S_OK;
}

//----------------------------------------------------------------
HRESULT CWMISnapin::GetClassID(CLSID *pClassID)
{

    HRESULT hr = E_POINTER;
	ATLTRACE(_T("ClassID******\n"));

    if(NULL != pClassID)
    {
      // Use overloaded '=' operator to copy the Class ID.
      *pClassID = CLSID_WMISnapin;
      hr = S_OK;
    }

    return hr;
}	

//----------------------------------------------------------------
HRESULT CWMISnapin::IsDirty()
{
	ATLTRACE(_T("Dirty******\n"));
	return (m_bDirty == true)? S_OK : S_FALSE;
//	return S_OK;
}

//----------------------------------------------------------------
HRESULT CWMISnapin::ReadStream(IStream *pStm, void *data, ULONG *size)
{
	HRESULT hr = E_FAIL;
    ULONG ulToRead = *size, ulReadIn = 0;

	// read the version nbr like a good boy.
	hr = pStm->Read((void *)data, ulToRead, &ulReadIn);

	if(SUCCEEDED(hr))
	{
		if(ulReadIn <= *size)
		{
			*size = ulReadIn;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	return hr;
}

//----------------------------------------------------------------
HRESULT CWMISnapin::Load(IStream *pStm)
{
	HRESULT hr = E_POINTER;

	ULONG size = 0;
	BYTE version = 0;
	short machineLength = 0;
	ATLTRACE(_T("Load******\n"));

    if(NULL != pStm)
    {
		size = 1;
		if(SUCCEEDED(hr = ReadStream(pStm, (void *)&version, &size)))
		{
			// Deal with the differentversions.
			switch (version)
			{
			case 1:
				size = sizeof(short);
				if(SUCCEEDED(hr = ReadStream(pStm, (void *)&machineLength, &size)))
				{
					size = (ULONG)machineLength;
					hr = ReadStream(pStm, 
									(void *)((CWMISnapinData *)m_pNode)->m_initMachineName,
									&size);
				}

				break;
			default:
				hr = E_FAIL;  // Bad version.
				break;

			} //endswitch

		} //endif ReadStream(version)
    }

    return hr;
}

//----------------------------------------------------------------
HRESULT CWMISnapin::Save(IStream *pStm, BOOL fClearDirty)
{
	HRESULT hr = E_POINTER;
    ULONG ulToWrite, ulWritten;
	short data = 1;

	ATLTRACE(_T("Save******\n"));

    if(NULL != pStm)
    {
		ulToWrite = 1;
		hr = pStm->Write(&data, ulToWrite, &ulWritten);

		if(SUCCEEDED(hr) && ulToWrite != ulWritten)
		{
			hr = STG_E_CANTSAVE;
		}
		// NOTE: g_DS == 0 when we're an extension and we dont need to save the machine name anyway.
		else if(SUCCEEDED(hr) && ((CWMISnapinData *)m_pNode)->g_DS)
		{
			ulToWrite = sizeof(short);
			ulWritten = 0;
			data = (short)sizeof(wchar_t) * (((CWMISnapinData *)m_pNode)->g_DS->m_whackedMachineName.GetLength() + 1);

			hr = pStm->Write(&data, ulToWrite, &ulWritten);

			if(SUCCEEDED(hr) && ulToWrite != ulWritten)
			{
				hr = STG_E_CANTSAVE;
			}
			else if(SUCCEEDED(hr))
			{
				LPBYTE str = new BYTE[data * sizeof(wchar_t)];
				if (!str)
					return E_OUTOFMEMORY;
				memset(str, 0, data * sizeof(wchar_t));
				ulToWrite = (ULONG)data;
				ulWritten = 0;
				wcscpy((wchar_t *)str, (LPCTSTR)((CWMISnapinData *)m_pNode)->g_DS->m_whackedMachineName);

				hr = pStm->Write((void *)str, ulToWrite, &ulWritten);

				delete[] str;

				if(SUCCEEDED(hr) && ulToWrite != ulWritten)
				{
					hr = STG_E_CANTSAVE;
				}
				else if(SUCCEEDED(hr))
				{
					// Clear this COM object's dirty flag if instructed. Otherwise,
					// preserve its content.
					if(fClearDirty)
						m_bDirty = false;
				}
			}
		}

	}
    return hr;
}

//----------------------------------------------------------------
HRESULT CWMISnapin::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
	HRESULT hr = E_POINTER;
	ATLTRACE(_T("GetSizeMax******\n"));

	if(NULL != pcbSize)
    {
		ULISet32(*pcbSize, (256 * sizeof(wchar_t)) + sizeof(short) + 1);
		hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\bvtscript.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTReposit.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "bvt.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 1001
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ExecuteScript(int nTest)
{
    int nRc = FATAL_ERROR;
    CAutoDeleteString sScript;
    CAutoDeleteString sNamespace;

    if( g_Options.GetOptionsForScriptingTests(sScript, sNamespace, nTest))
    {
        g_LogFile.LogError( __FILE__, __LINE__ ,SUCCESS, L"Executing script: %s for namespace: %s", sScript.GetPtr(),sNamespace.GetPtr());
    
        if( sScript.AddToString(sNamespace.GetPtr()))
        {
            nRc = _wsystem(sScript.GetPtr());
            if( nRc != SUCCESS )
            {
                 g_LogFile.LogError( __FILE__, __LINE__ ,FATAL_ERROR, L"Executing script failed: %s for namespace: %s", sScript.GetPtr(), sNamespace.GetPtr());
            }
        }
        else
        {
            g_LogFile.LogError( __FILE__, __LINE__ ,FATAL_ERROR, L"Couldn't build command line for script: %s for namespace: %s", sScript.GetPtr(), sNamespace.GetPtr());
        }
    }
    return nRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\bvtess.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Test app to test the hi perf portion of the WMIPROV.DLL
//
///////////////////////////////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <process.h>
//#include <objbase.h>
#include <stdio.h>
#include <wbemcli.h>
//#include <wbemint.h>
//#include <wbemcomn.h>
//#include <cominit.h>


///////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT WbemSetProxyBlanket( IUnknown *pInterface, DWORD dwAuthnSvc, DWORD dwAuthzSvc, OLECHAR *pServerPrincName,
                             DWORD dwAuthLevel, DWORD dwImpLevel, RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
                             DWORD dwCapabilities )
{
    IUnknown * pUnk = NULL;
    IClientSecurity * pCliSec = NULL;

    HRESULT sc = pInterface->QueryInterface(IID_IUnknown, (void **) &pUnk);
    if(sc != S_OK)
        return sc;

    sc = pInterface->QueryInterface(IID_IClientSecurity, (void **) &pCliSec);
    if(sc != S_OK)
    {
        pUnk->Release();
        return sc;
    }


    sc = pCliSec->SetBlanket(pInterface, dwAuthnSvc, dwAuthzSvc, pServerPrincName, dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities);
    pCliSec->Release();
    pCliSec = NULL;
    sc = pUnk->QueryInterface(IID_IClientSecurity, (void **) &pCliSec);
    if(sc == S_OK)
    {
        sc = pCliSec->SetBlanket(pUnk, dwAuthnSvc, dwAuthzSvc, pServerPrincName, dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities);
        pCliSec->Release();
    }
    else if (sc == 0x80004002)
        sc = S_OK;
    pUnk->Release();
    return sc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Function:	main
//
///////////////////////////////////////////////////////////////////////////////////////////////////////

#define	NUMINSTANCES	1

IWbemServices*	g_pNameSpace = NULL;
WCHAR			g_wcsObjectPath[2048];
DWORD			g_dwNumReps = 1;
DWORD			g_dwNumThreads = 1;
BOOL			g_fAddDel = FALSE;

unsigned __stdcall RefreshThread( void * pvData )
{
	DWORD	dwThreadId = (DWORD) pvData;

	IWbemRefresher*				pRefresher = NULL;
	IWbemConfigureRefresher*	pConfig = NULL;
	BOOL						fEnum = FALSE;

	CoInitializeEx( NULL, COINIT_MULTITHREADED );

	HRESULT hr = CoCreateInstance( CLSID_WbemRefresher, NULL, CLSCTX_INPROC_SERVER, IID_IWbemRefresher, (void**) &pRefresher );
	if ( SUCCEEDED( hr ) )
	{
		IWbemConfigureRefresher*	pConfig = NULL;

		// Need an interface through which we can configure the refresher
		hr = pRefresher->QueryInterface( IID_IWbemConfigureRefresher, (void**) &pConfig );

		if ( SUCCEEDED( hr ) )
		{
			IWbemClassObject*		pRefreshable = NULL;
			IWbemHiPerfEnum*		pEnum = NULL;
			long					lID = 0;
			IWbemObjectAccess*		pObjAccess = NULL;
			IWbemClassObject*		pObj = NULL;

			// Add an object or an enumerator.  If the path to the object contains
			// an L'=', then it is an object path, otherwise we assume it is a class
			// name and therefore return an enumerator.

			if ( NULL != wcschr( g_wcsObjectPath, L'=' ) )
			{
				if ( !g_fAddDel )
				{
					hr = pConfig->AddObjectByPath( g_pNameSpace, g_wcsObjectPath, 0, NULL, &pObj, &lID );

					if ( SUCCEEDED( hr ) )
					{
						pObj->QueryInterface( IID_IWbemObjectAccess, (void**) &pObjAccess );
						pObj->Release();
					}
					else
					{
						printf( "AddObjectByPath() failed, 0x%x\n", hr );
					}

				}

			}
			else
			{
				if ( !g_fAddDel )
				{
					hr = pConfig->AddEnum( g_pNameSpace, g_wcsObjectPath, 0, NULL, &pEnum, &lID );

					if ( FAILED(hr) )
					{
						printf( "AddEnum() failed, 0x%x\n", hr );
					}
				}

				fEnum = TRUE;
			}

			// Add an object and then the enumerator
			if ( SUCCEEDED( hr ) )
			{
				DWORD				dwNumReturned = NUMINSTANCES;
				BOOL				fGotHandles = 0;

				DWORD	dwValue = 0,
						dwNumObjects = 0;
				WORD	wValue = 0;
				BYTE	bVal = 0;
				IWbemObjectAccess**	apEnumAccess = NULL;

				for ( DWORD x = 0; SUCCEEDED( hr ) && x < g_dwNumReps; x++ )
				{
					if ( g_fAddDel )
					{
						if ( fEnum )
						{
							hr = pConfig->AddEnum( g_pNameSpace, g_wcsObjectPath, 0, NULL, &pEnum, &lID );
						}
						else
						{
							hr = pConfig->AddObjectByPath( g_pNameSpace, g_wcsObjectPath, 0, NULL, &pObj, &lID );

							if ( SUCCEEDED( hr ) )
							{
								pObj->QueryInterface( IID_IWbemObjectAccess, (void**) &pObjAccess );
								pObj->Release();
							}
						}
					}

					// Refresh and if we have an enumerator, retrieve the
					// objects and release them

					hr = pRefresher->Refresh( 0L );

					if ( pEnum )
					{
						hr = pEnum->GetObjects( 0L, dwNumObjects, apEnumAccess, &dwNumReturned );

						if ( FAILED( hr ) && WBEM_E_BUFFER_TOO_SMALL == hr )
						{
							IWbemObjectAccess**	apTempAccess = new IWbemObjectAccess*[dwNumReturned];

							if ( NULL != apTempAccess )
							{
								ZeroMemory( apTempAccess, dwNumReturned * sizeof(IWbemObjectAccess*) );

								if ( NULL != apEnumAccess )
								{
									CopyMemory( apTempAccess, apEnumAccess, dwNumObjects * sizeof(IWbemObjectAccess*) );
									delete [] apEnumAccess;
								}

								// Store the new values and retry
								apEnumAccess = apTempAccess;
								dwNumObjects = dwNumReturned;

								hr = pEnum->GetObjects( 0L, dwNumObjects, apEnumAccess, &dwNumReturned );
							}
							else
							{
								hr = WBEM_E_OUT_OF_MEMORY;
							}

						}	// IF Buffer too small


						for ( DWORD nCtr = 0; nCtr < dwNumReturned; nCtr++ )
						{
							apEnumAccess[nCtr]->Release();
						}

					}	// IF refresh succeeded


					printf ( "Thread %d Refreshed %d instances of %S from provider: rep# %d\n", dwThreadId, dwNumReturned, g_wcsObjectPath, x );

					if ( g_fAddDel )
					{
						if ( fEnum )
						{
							pConfig->Remove( lID, 0L );
							if (pEnum)
								pEnum->Release();
						}
						else
						{
							if (pObjAccess)
								pObjAccess->Release();
							pObjAccess = NULL;
						}
					}


				}	// FOR Refresh

				// Release anything we got back from the refresher and any
				// memory we may have allocated.
				if ( fEnum )
				{
					if ( !g_fAddDel && pEnum )
						pEnum->Release();

					if ( NULL != apEnumAccess )
					{
						delete [] apEnumAccess;
					}

				}
				else
				{
					if ( !g_fAddDel && pObjAccess)
						pObjAccess->Release();
				}

			}

			if (pConfig)
				pConfig->Release();
		}

		// Cleanup
		g_pNameSpace->Release();

	}

	if ( NULL != pRefresher )
		pRefresher->Release();

	CoUninitialize();

	return 0;

}

extern "C" int __cdecl main( int argc, char *argv[] )
{
	WCHAR	wcsSvrName[256];
	BOOL	fEnum = FALSE;

	wcscpy( wcsSvrName, L"." );

	CoInitializeEx( NULL, COINIT_MULTITHREADED );
//	InitializeSecurity(RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE );

	// See if we were told to go remote or not.
	if ( argc > 1 )
	{
		MultiByteToWideChar( CP_ACP, 0L, argv[1], -1, g_wcsObjectPath, 2048 );

		if ( argc > 2 )
		{
			g_fAddDel = strtoul( argv[2], NULL, 10 );

			if ( argc > 3 )
			{
				g_dwNumReps = strtoul( argv[3], NULL, 10 );

				if ( argc > 4 )
				{
					g_dwNumThreads = strtoul( argv[4], NULL, 10 );

					if ( argc > 5 )
					{
						MultiByteToWideChar( CP_ACP, 0L, argv[5], -1, wcsSvrName, 2048 );
					}
				}
			}
		}
	}
	else
	{
		printf( "No object path!\n" );
		printf( "Usage: refreshertest.exe <object_path> <delete_object> <Num_Refreshes> <Num_threads> <Server - Opt>\n" );
		return 0;
	} 

	IWbemLocator*		pWbemLocator = NULL;

	HRESULT hr = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void**) &pWbemLocator );

	WCHAR	wszNameSpace[255];

	swprintf( wszNameSpace, L"\\\\%s\\root\\wmi", wcsSvrName );

	// Name space to connect to
	BSTR	bstrNameSpace = SysAllocString( wszNameSpace );

	hr = pWbemLocator->ConnectServer(	bstrNameSpace,	// NameSpace Name
										NULL,			// UserName
										NULL,			// Password
										NULL,			// Locale
										0L,				// Security Flags
										NULL,			// Authority
										NULL,			// Wbem Context
										&g_pNameSpace		// Namespace
										);

	SysFreeString( bstrNameSpace );

	if ( SUCCEEDED( hr ) )
	{

		WbemSetProxyBlanket(g_pNameSpace, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CONNECT, 
						RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

		HANDLE*	ahThreads = new HANDLE[g_dwNumThreads];

		for ( DWORD	dwCtr = 0; dwCtr < g_dwNumThreads; dwCtr++ )
		{
			ahThreads[dwCtr] = (HANDLE) _beginthreadex( NULL, 0, RefreshThread, (void*) dwCtr, 0, NULL );
			Sleep(1000);
		}

		// Wait for all the threads to get signalled
		WaitForMultipleObjects( g_dwNumThreads, ahThreads, TRUE, INFINITE );

		delete [] ahThreads;

	}

	// Cleanup main objects
	if ( NULL != pWbemLocator )
		pWbemLocator->Release();

	CoUninitialize();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\bvtprov.cpp ===
Provider Phase
[1]  Open CIMV2 namespace.
[2]  Execute some simple queries from providers for Win32_Process, Win32_LogicalDisk.   Write independent code to get the process list and disk list and verify that the instances that come back are correct.

[3]  Enumerate all the Win32_ classes.
[4]  Execute queries of select * from for all of these, one at a time.
[5]  Execute "associators of {Win32_ComputerSystem = <current machine name>"

[6]  Close the connection to CIMV2

[7]  Rerun [1]-[6] from several threads in parallel.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\bvtapilib\bvt.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTUtil.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "bvt.h"
#include <time.h>


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Documentation arrays
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IniInfo g_Doc1[] = {  
    { L"FYI",         L"NAMESPACE is the Namespace the BVT will use"} };

IniInfo g_Doc2[] = {
    { L"FYI", L"NAMESPACE is the Namespace the BVT will use. CLASS is the class used to create the namespace" }};

IniInfo g_Doc3[] = {
    { L"FYI", L"NAMESPACE is the Namespace the BVT will use. CLASS is the class used to create the namespace" }};

IniInfo g_Doc4[] = {
    { L"FYI",         L"NAMESPACE is the Namespace the BVT will create" }};

IniInfo g_Doc5[] = {
    {L"FYI",            L"Classes = the list of comma separated class names, all of these classes should exist in this section as defined in the FYI_Format entry below" },
    {L"FYI_Format",     L"Classes are defined in this format: ClassName = Parent:XClass, Key:TmpKey:CIM_SINT32:3, Property:PropertyName3:CIM_UINT32:3" },
    {L"FYI_Class",      L"Using format as defined in FYI_Format, ClassName is the actual name of the class to be created" },
    {L"FYI_InHeritance",L"Using format as defined in FYI_Format, Parent:XClass where Parent means this entity describes the inheritance of the class. XClass is the name of the ParentClass." },
    {L"FYI_Qualifier",  L"Doc this" },
    {L"FYI_Property",   L"Using format as defined in FYI_Format, Property:PropName:CIM_UINT32:5 where Property means this entity describes the Property.  PropName is the name of the Property.  CIM_UINT32 is the type and 5 is the value." },
    {L"FYI_Comments",   L"Classes may contain more than one qualifier and more than one property.  These must be comma separated and identified as described." }};

IniInfo g_Doc6[] = {
    {L"FYI_Delete_Classes",           L"First,  Classes will be deleted as specified by the ini entry DELETE_CLASSES" },
    {L"FYI_Classes_After_Delete",     L"Second, Classes will then be compared to what is expected to be left, by looking at the values in the ini entry CLASSES_AFTER_DELETE" },
    {L"FYI_Add_Classes",              L"Third,  Classes to be added are then specified by the ini entry ADD_CLASSES" },
    {L"FYI_Classes_After_Add",        L"Fourth, Classes will then be compared to what is expected to be left, by looking at the values in the ini entry CLASSES_AFTER_ADD" },
    {L"FYI_Classes_Add_Delete_Order", L"Fifth,  Classes to be deleted and added in specified order DELETE_ADD_CLASS_ORDER" },
    {L"FYI_Classes_After_Delete_Add", L"Sixth,  Classes will then be compared to what is expected to be left, by looking at the values in the ini entry CLASSES_AFTER_DELETE_ADD" },
    {L"FYI_Comments",   L"All of these entries, with the exception of DELETE_ADD_CLASS_ORDER are comma separated class names. See FYI_FORMAT for DELETE_ADD_CLASS_ORDER format" },
    {L"FYI_FORMAT",     L"DELETE_ADD_CLASS_ORDER format: 'Delete:Class1, Add:Class2, Add:Class3'  where Delete means to delete the following class, and Add to add the following class, this may be in any order." }};

IniInfo g_Doc7[] = {
                    {L"FYI",  L"ASSOCIATION_CLASSES is a comma separated list of associations to create.  These must exist in this section.  See FYI_Format to see how to create an association" },
                    {L"FYI_Format",   L"Example: Property:FirstPoint:TestClass1:Reference:REF:TestClass1, Property:SecondPoint:TestClass2:REF:TestClass2" },
                    {L"FYI_Property", L"Using format as defined in FYI_Format, Property:FirstPoint:TestClass1:REF:TestClass1 where Property means this entity describes the Property. FirstPoint is the name of first Key, TestClass1 is that key's value, Reference creates a strongly typed reference as defined in REF:TestClass1." },
                    {L"FYI_Comments", L"REF is optional" }};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  The repository tests
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
IniInfo g_Test1[] = {{L"NAMESPACE",L"ROOT\\DEFAULT" },
                    {L"Description", L"Basic connect using IWbemLocator"}};

IniInfo g_Test2[] = { { L"NAMESPACE",L"ROOT\\DEFAULT" },
                      { L"Description", L"Basic connect using IWbemConnection for IWbemServices, IWbemServicesEx, IWbemClassObject"},
                      { L"CLASS"    ,L"__NAMESPACE" } };

IniInfo g_Test3[] = { { L"NAMESPACE",L"ROOT\\DEFAULT" },
                      { L"Description", L"Basic async connect using IWbemConnection for IWbemServices, IWbemServicesEx, IWbemClassObject"},
                      { L"CLASS"    ,L"__NAMESPACE" } };

IniInfo g_Test4[] = {{L"NAMESPACE",L"ROOT\\BVTAPITEST" },
                     {L"Description", L"Creation of a test namespace"},
                     {L"PARENT_NAMESPACE",L"ROOT"},
                     {L"CLASSES", L"__NAMESPACE"},
                     {L"__NAMESPACE", L"Class:__NAMESPACE,Property:Name:CIM_STRING:BVTAPITEST" }};

IniInfo g_Test5[] = {
    { L"RUNTESTS", L"4" },
    {L"Description", L"Creates test classes in the test namespace"},
    { L"NAMESPACE", L"ROOT\\BVTAPITEST"},
    { L"Classes",     L"1,2,3,4,5,6,7,8,9,10" },
    { L"1",  L"Class:TestClass1" }, // an abstract class, so 4 and 5 can define additional keys
    { L"2",  L"Class:TestClass2, Property:LaKey1:CIM_STRING:Key1, PropertyQualifier:KEY:LaKey1:CIM_BOOLEAN:1,    Property:LaKey2:CIM_STRING:Key2, PropertyQualifier:Key:LaKey2:CIM_BOOLEAN:1" },
    { L"3",  L"Class:TestClass3, Property:KeyName1:CIM_SINT32:3,  PropertyQualifier:KEY:KeyName1:CIM_BOOLEAN:1,  Property:PropertyName3:CIM_UINT32:3,  Property:PropertyName3B:CIM_STRING:Test" },
    { L"4",  L"Class:TestClass4, Parent:TestClass1,  Property:KeyName4:CIM_UINT32:4,    PropertyQualifier:KEY:KeyName4:CIM_BOOLEAN:1, Property:PropertyName4:CIM_STRING:0" },
    { L"5",  L"Class:TestClass5, Parent:TestClass1,  Property:KeyName5:CIM_STRING:Temp, PropertyQualifier:KEY:KeyName5:CIM_BOOLEAN:1, Property:PropertyName5:CIM_STRING:Value5" },
    { L"6",  L"Class:TestClass6, Parent:TestClass5,  Property:PropertyName6:CIM_STRING:Value6,PropertyQualifier:ID:PropertyName6:CIM_SINT32:1" },    // no additional key can be defined
    { L"7",  L"Class:TestClass7, Parent:TestClass6,  Property:PropertyName7:CIM_STRING:1,PropertyQualifier:ID:PropertyName7:CIM_SINT32:1" },        // no additional key can be defined
    { L"8",  L"Class:TestClass8, Parent:TestClass7,  Property:PropertyName8:CIM_SINT32:2" },        // no additional key can be defined
    { L"9",  L"Class:TestClass9, Parent:TestClass8,  Property:PropertyName9:CIM_STRING:Value9" },    // no additional key can be defined
    { L"10", L"Class:TestClass10, Parent:TestClass9,  Property:PropertyName10:CIM_STRING:0" } };     // no additional key can be defined

IniInfo g_Test6[] = {
    {L"Description", L"Deletes and Creates the classes in the requested order."},
    { L"RUNTESTS", L"20,5" },
    { L"NAMESPACE", L"ROOT\\BVTAPITEST"},
    { L"DEFINITION_SECTION",        L"5"},
    { L"DELETE_CLASSES",            L"1,3" },
    { L"CLASSES_AFTER_DELETE",      L"2" },
    { L"ADD_CLASSES",               L"1,3,4,5,6,7,8,9,10" },
    { L"CLASSES_AFTER_ADD",         L"1,2,3,4,5,6,7,8,9,10" },
    { L"DELETE_ADD_CLASS_ORDER",    L"Delete:2, Delete:9, Add:2, Delete:7, Delete: 6" },
    { L"CLASSES_AFTER_DELETE_ADD",  L"1,2,3,4,5" }};


IniInfo g_Test7[] = 
{
    { L"RUNTESTS", L"5" },
    { L"Description",L"Creates simple associations"},
    { L"NAMESPACE", L"ROOT\\BVTAPITEST"},
    { L"DEFINITION_SECTION",  L"7"},
    { L"CLASSES",       L"1,2" },
    { L"1",  L"Class:Association1, Property:FirstPoint:CIM_REFERENCE:Value,   PropertyQualifier:KEY:FirstPoint:CIM_BOOLEAN:1, PropertyQualifier:CIMTYPE:FirstPoint:CIM_STRING:ref:TestClass4,Property:EndPoint:CIM_REFERENCE:Value, PropertyQualifier:CIMTYPE:EndPoint:CIM_STRING:ref:TestClass5, PropertyQualifier:Key:EndPoint:CIM_BOOLEAN:1" },
    { L"2",  L"Class:Association2, Property:AssocProp1:CIM_STRING:TestClass4, PropertyQualifier:Key:AssocProp1:CIM_BOOLEAN:1, Property:AssocProp2:CIM_STRING:TestClass5, PropertyQualifier:Key:AssocProp2:CIM_BOOLEAN:1" }};

IniInfo g_Test8[] = {
    { L"RUNTESTS", L"12" },
    { L"Description",L"Executes queries"},
    { L"NAMESPACE", L"ROOT\\BVTAPITEST"},
    { L"QUERY_LIST",        L"QUERY,ASSOCIATORS_QUERY,REFERENCES_QUERY"},
    { L"QUERY",              L"RESULTS:60,QUERY:select * from meta_class" },
    { L"ASSOCIATORS_QUERY",  L"RESULTS:4,QUERY:Associators of" },
    { L"REFERENCES_QUERY",   L"RESULTS:4,QUERY:References of" }};

IniInfo g_Test9[] = {
    { L"RUNTESTS",            L"5" },
    { L"Description",         L"Create Instances"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"DEFINITION_SECTION",  L"9"},
    { L"INSTANCE_LIST",       L"4,5,6,7"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"Class:TestClass4, Property:KeyName4:CIM_UINT32:555, Property:PropertyName4:CIM_STRING:1, InstanceName:TestClass4.KeyName4=555$EndInstanceName" },
    { L"5",                   L"Class:TestClass5, Property:KeyName5:CIM_STRING:InstanceTest, Property:PropertyName5:CIM_STRING:TestTest, InstanceName:TestClass5.KeyName5=\"InstanceTest\"$EndInstanceName" },
    { L"6",                   L"Class:TestClass4, Property:KeyName4:CIM_UINT32:556, Property:PropertyName4:CIM_STRING:1, InstanceName:TestClass4.KeyName4=556$EndInstanceName" },
    { L"7",                   L"Class:TestClass5, Property:KeyName5:CIM_STRING:InstanceTest2, Property:PropertyName5:CIM_STRING:TestTest, InstanceName:TestClass5.KeyName5=\"InstanceTest2\"$EndInstanceName" }};


IniInfo g_Test10[] = {
    { L"RUNTESTS",            L"9" },
    { L"Description",         L"Deletes Instances"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"INSTANCE_LIST",       L"4,5"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"TestClass4.KeyName4=555" },
    { L"5",                   L"TestClass5.KeyName5=\"InstanceTest\"" }};


IniInfo g_Test11[] = {
    { L"RUNTESTS",            L"9" },
    { L"Description",         L"Enumerates Instances"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"INSTANCE_LIST",       L"4,5"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"Class:TestClass4,RESULTS:2" },
    { L"5",                   L"Class:TestClass5,RESULTS:2" }};

IniInfo g_Test12[] = {
    { L"RUNTESTS",            L"7,9" },
    { L"Description",         L"Create Association Instances"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"DEFINITION_SECTION",  L"12"},
    { L"INSTANCE_LIST",       L"4,5"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"Class:Association1, Property:FirstPoint:CIM_REFERENCE:TestClass4.KeyName4=555,Property:EndPoint:CIM_REFERENCE:TestClass5.KeyName5=\"InstanceTest\", InstanceName:Association1.EndPoint=\"TestClass5.KeyName5=\\\"InstanceTest\\\"\",FirstPoint=\"TestClass4.KeyName4=555\"$EndInstanceName"},
    { L"5",                   L"Class:Association2, Property:AssocProp1:CIM_STRING:TestClass4.KeyName4=556,Property:AssocProp2:CIM_STRING:TestClass5.KeyName5=\"InstanceTest\", InstanceName:Association2.AssocProp2=TestClass5.KeyName5=\"InstanceTest\",AssocProp1=TestClass4.KeyName4=555$EndInstanceName"}};

IniInfo g_Test13[] = {
    { L"RUNTESTS",            L"12" },
    { L"Description",         L"Deletes Association Instances"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"INSTANCE_LIST",       L"4,5"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},

    { L"4",                   L"Association1.EndPoint=\"TestClass5.KeyName5=\\\"InstanceTest\\\"\",FirstPoint=\"TestClass4.KeyName4=555\"" },
    { L"5",                   L"Association2.AssocProp1=\"TestClass4.KeyName4=556\",AssocProp2=\"TestClass5.KeyName5=\\\"InstanceTest\\\"\"" }};

IniInfo g_Test14[] = {
    { L"RUNTESTS",            L"12" },
    { L"Description",         L"Enumerates Association Instances"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"INSTANCE_LIST",       L"4,5"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"CLASS:Association1, RESULTS:1" },
    { L"5",                   L"CLASS:Association2, RESULTS:1" }};

IniInfo g_Test15[] = {
    { L"RUNTESTS",            L"9" },
    { L"Description",         L"Deletes Class deletes all the instances"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"DEFINITION_SECTION",  L"15"},
    { L"CLASSES",             L"4,5"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"Class:TestClass4" },
    { L"5",                   L"Class:TestClass5" }};


IniInfo g_Test16[] = {
    { L"RUNTESTS",            L"9" },
    { L"Description",         L"Gets specific objects by various specific paths"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"OBJECT_LIST",         L"4,5"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"TestClass4.KeyName4=555" },
    { L"5",                   L"TestClass5.KeyName5=\"InstanceTest\"" }};

IniInfo g_Test17[] = {
    { L"RUNTESTS",            L"5" },
    { L"Description",         L"Create methods for a class"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"METHOD_LIST",         L"4"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"CLASS:TestClass2, METHOD:TestMethod, \
                                INPUT:Property:InputArg1:CIM_UINT32:555, \
                                INPUT:PropertyQualifier:ID:InputArg1:CIM_SINT32:0,\
                                INPUT:PropertyQualifier:In:InputArg1:CIM_BOOLEAN:1, \
                                OUTPUT:Property:OutputArg1:CIM_UINT32:111,\
                                OUTPUT:PropertyQualifier:ID:OutputArg1:CIM_SINT32:1,\
                                OUTPUT:PropertyQualifier:Out:OutputArg1:CIM_BOOLEAN:1"}};

IniInfo g_Test18[] = {
    { L"RUNTESTS",            L"17" },
    { L"Description",         L"Delete methods for a class"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"METHOD_LIST",         L"4"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"CLASS:TestClass2, METHOD:TestMethod"}};

IniInfo g_Test19[] = {
    { L"RUNTESTS",            L"17" },
    { L"Description",         L"Enumerate methods for a class"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"METHOD_LIST",         L"4"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"CLASS:TestClass2, RESULTS:1"}};

IniInfo g_Test20[] = {
    { L"NAMESPACE", L"ROOT\\BVTAPITEST"},
    { L"DESCRIPTION", L"Deletes all non-system classes in the namespace"}};

IniInfo g_Test21[] = {
    { L"NAMESPACE",    L"ROOT"},
    { L"NAMESPACE_TO_DELETE", L"__NAMESPACE.Name=\"BVTAPITEST\""},
    { L"DESCRIPTION", L"Deletes requested namespace"}};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  The Other Provider tests
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
IniInfo g_Test200[] = {
    {L"PROVIDERS",     L"WDM,CIMV2"},
    {L"WDM",           L"NAMESPACE:ROOT\\WMI"},
    {L"CIMV2",         L"NAMESPACE:ROOT\\CIMV2"},
    {L"Description",   L"Basic connect using IWbemLocator"}};

IniInfo g_Test201[] = {
    {L"PROVIDERS",     L"WDM,CIMV2"},
    { L"Description",                   L"Enumerates Classes for Providers"},
    { L"RUNTESTS",                      L"200"},
    { L"NAMESPACE_DEFINITION_SECTION",  L"201"},
    { L"FLAGS",                         L"WBEM_FLAG_SHALLOW, WBEM_FLAG_DEEP, WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY "},
    { L"WDM",                           L"1,2"},
    { L"CIMV2",                         L"3,4"},
    { L"1",                             L"CLASS:__ExtrinsicEvent, RESULTS:2, RESULTS:18, RESULTS: 18" },
    { L"2",                             L"Empty" },
    { L"3",                             L"Empty" },
    { L"4",                             L"CLASS:CIM_Action, RESULTS: 16, RESULTS:24, RESULTS:24" }};

IniInfo g_Test202[] = {
    {L"PROVIDERS",                      L"WDM,CIMV2"},
    {L"Description",                    L"Executes queries for Providers"},
    {L"RUNTESTS",                       L"200"},
    {L"NAMESPACE_DEFINITION_SECTION",   L"201"},
    {L"WDM",                            L"WDMQUERY"},
    {L"CIMV2",                          L"QUERY"},
    {L"WDMQUERY",                       L"RESULTS:235,QUERY:select * from meta_class" },
    {L"QUERY",                          L"RESULTS:627,QUERY:select * from meta_class" }};


IniInfo g_Test204[] = {
    { L"PROVIDERS",                     L"WDM,CIMV2"},
    { L"Description",                   L"Enumerates Instances for Providers"},
    { L"RUNTESTS",                      L"200"},
    { L"NAMESPACE_DEFINITION_SECTION",  L"201"},
    { L"FLAGS",                         L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"WDM",                           L"1,2"},
    { L"CIMV2",                         L"3,4"},
    { L"1",                             L"CLASS:RegisteredGuids, RESULTS:-1" },
    { L"2",                             L"CLASS:WmiBinaryMofResource, RESULTS:-1" },
    { L"3",                             L"CLASS:Win32_Process, RESULTS:-1" },
    { L"4",                             L"CLASS:Win32_Directory, RESULTS:-1" }};

IniInfo g_Test205[] = {
    {L"PROVIDERS",                      L"WDM,CIMV2"},
    { L"RUNTESTS",                      L"200" },
    { L"Description",                   L"Gets specific objects by various specific paths for Providers"},
    { L"NAMESPACE_DEFINITION_SECTION",  L"201"},
    { L"WDM",                           L"1"},
    { L"CIMV2",                         L"2"},
    { L"FLAGS",                         L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"1",                             L"MSNdis_CoDriverVersion.InstanceName=\"WAN Miniport (IP)\""},
    { L"2",                             L"Win32_Directory.Name=\"c:\\\\\"" }};

IniInfo g_Test206[] = {
    {L"PROVIDERS",                      L"CIMV2"},
    { L"RUNTESTS",                      L"200" },
    { L"Description",                   L"Enumerate methods for a class for Providers"},
    { L"NAMESPACE_DEFINITION_SECTION",  L"201"},
    { L"CIMV2",                         L"3,4"},
    { L"FLAGS",                         L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"3",                             L"CLASS:CIM_DataFile, RESULTS:14"},
    { L"4",                             L"CLASS:Win32_Process, RESULTS:4"}};

    
IniInfo g_Test207[] = {
    { L"PROVIDERS",                     L"CIMV2"},
    { L"RUNTESTS",                      L"200" },
    { L"Description",                   L"Execute methods for Providers"},
    { L"NAMESPACE_DEFINITION_SECTION",  L"201"},
    { L"CIMV2",                         L"1"},
    { L"FLAGS",                         L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"1",                             L"Class:CIM_DataFile, InstanceName:CIM_DataFile.Name=\"c:\\\\BVT.TST\"$EndInstanceName, METHOD:Copy, INPUT:Property:FileName:CIM_STRING:c:\\\\BVT2.TST"}};

IniInfo g_Test208[] = {
    { L"PROVIDERS",                     L"WDM,CIMV2"},
    { L"RUNTESTS",                      L"200" },
    { L"NAMESPACE_DEFINITION_SECTION",  L"201"},
    { L"Description",                   L"Test temporary semi-sync events for Providers"},
    { L"WDM",                           L"1"},
    { L"CIMV2",                         L"2"},
    { L"1",                             L"LANGUAGE:WQL, QUERY:\"select * from __InstanceCreationEvent within 10\",  EXECUTE_SECTION: 212, RESULTS:2, NAMESPACE:ROOT\\WMI"},
    { L"2",                             L"LANGUAGE:WQL, QUERY:\"select * from __InstanceCreationEvent within 10\",  EXECUTE_SECTION: 212, RESULTS:2, NAMESPACE:ROOT\\CIMV2"}};

IniInfo g_Test209[] = {
    {L"PROVIDERS",                      L"WDM,CIMV2"},
    { L"RUNTESTS",                      L"200" },
    { L"NAMESPACE_DEFINITION_SECTION",  L"201"},
    { L"Description",                   L"Test temporary async events for Providers"},
    { L"WDM",                           L"1"},
    { L"CIMV2",                         L"2"},
    { L"1",                             L"LANGUAGE:WQL, QUERY:\"select * from __InstanceCreationEvent within 10\",  EXECUTE_SECTION: 212, RESULTS:2, NAMESPACE:ROOT\\WMI"},
    { L"2",                             L"LANGUAGE:WQL, QUERY:\"select * from __InstanceCreationEvent within 10\",  EXECUTE_SECTION: 212, RESULTS:2, NAMESPACE:ROOT\\CIMV2"}};

IniInfo g_Test210[] = {
    { L"PROVIDERS",                     L"WDM"},
    { L"RUNTESTS",                      L"200" },
    { L"NAMESPACE_DEFINITION_SECTION",  L"201"},
    { L"Description",                   L"Create Refresher for Providers"},
    { L"WDM",                           L"1"},
    { L"1",                             L"Class:Win32_BasicHiPerf"}};

IniInfo g_Test211[] = {
    { L"PROVIDERS",                     L"WDM, CIMV2"},
    { L"RUNTESTS",                      L"200" },
    { L"NAMESPACE_DEFINITION_SECTION",  L"201"},
    { L"Description",                   L"Create Classes for Providers"},
    { L"WDM",                           L"1,2"},
    { L"CIMV2",                         L"3,4"},
    { L"1",                             L"Class:WDMTemp1, Property:Key1:CIM_UINT32:0, PropertyQualifier:KEY:Key1:CIM_BOOLEAN:1, Property:Prop1:CIM_STRING:x" },
    { L"2",                             L"Class:WDMTemp2, Property:Key2:CIM_UINT32:0, PropertyQualifier:KEY:Key2:CIM_BOOLEAN:1, Property:Prop2:CIM_STRING:x" },
    { L"3",                             L"Class:CIMTemp1, Property:Key1:CIM_UINT32:0, PropertyQualifier:KEY:Key1:CIM_BOOLEAN:1, Property:Prop1:CIM_STRING:x" },
    { L"4",                             L"Class:CIMTemp2, Property:Key2:CIM_UINT32:0, PropertyQualifier:KEY:Key2:CIM_BOOLEAN:1, Property:Prop2:CIM_STRING:x" }};
    
IniInfo g_Test212[] = {
    { L"PROVIDERS",                     L"WDM,CIMV2"},
    { L"RUNTESTS",                      L"211" },
    { L"NAMESPACE_DEFINITION_SECTION",  L"201"},
    { L"DEFINITION_SECTION",            L"212"},
    { L"FLAGS",                         L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"Description",                   L"Create Instances for Providers"},
    { L"WDM",                           L"1,2"},
    { L"CIMV2",                         L"3,4"},
    { L"1",                             L"Class:WDMTemp1, Property:Key1:CIM_UINT32:1, Property:Prop1:CIM_STRING:Test1, InstanceName:WDMTemp1.Key1=1$EndInstanceName" },
    { L"2",                             L"Class:WDMTemp2, Property:Key2:CIM_UINT32:2, Property:Prop2:CIM_STRING:Test2, InstanceName:WDMTemp2.Key2=2$EndInstanceName" },
    { L"3",                             L"Class:CIMTemp1, Property:Key1:CIM_UINT32:1, Property:Prop1:CIM_STRING:Test1, InstanceName:CIMTemp1.Key1=1$EndInstanceName" },
    { L"4",                             L"Class:CIMTemp2, Property:Key2:CIM_UINT32:2, Property:Prop2:CIM_STRING:Test2, InstanceName:CIMTemp2.Key2=2$EndInstanceName" }};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  The Event tests
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
IniInfo g_Test300[] = {
    { L"RUNTESTS",             L"21" },
    { L"NAMESPACE",            L"ROOT"},
    { L"Description",          L"Test temporary semi-sync events"},
    { L"EVENT_LIST",           L"NAMESPACE_CREATION, CLASS_CREATION,INSTANCE_CREATION"},
    { L"NAMESPACE_CREATION",   L"LANGUAGE:WQL, QUERY:\"select * from __NamespaceCreationEvent\", EXECUTE_SECTION: 4, RESULTS:1,  NAMESPACE:ROOT"},
    { L"INSTANCE_CREATION",    L"LANGUAGE:WQL, QUERY:\"select * from __InstanceCreationEvent\",  EXECUTE_SECTION: 9, RESULTS:4,  NAMESPACE:ROOT\\BVTAPITEST"},
    { L"CLASS_CREATION",       L"LANGUAGE:WQL, QUERY:\"select * from __ClassCreationEvent\",     EXECUTE_SECTION: 5, RESULTS:10, NAMESPACE:ROOT\\BVTAPITEST"}};

IniInfo g_Test301[] = {
    { L"RUNTESTS",             L"21" },
    { L"NAMESPACE",            L"ROOT"},
    { L"Description",          L"Test temporary async events"},
    { L"EVENT_LIST",           L"NAMESPACE_CREATION, CLASS_CREATION,INSTANCE_CREATION"},
    { L"NAMESPACE_CREATION",   L"LANGUAGE:WQL, QUERY:\"select * from __NamespaceCreationEvent\", EXECUTE_SECTION: 4, RESULTS:1,  NAMESPACE:ROOT"},
    { L"INSTANCE_CREATION",    L"LANGUAGE:WQL, QUERY:\"select * from __InstanceCreationEvent\",  EXECUTE_SECTION: 9, RESULTS:4,  NAMESPACE:ROOT\\BVTAPITEST"},
    { L"CLASS_CREATION",       L"LANGUAGE:WQL, QUERY:\"select * from __ClassCreationEvent\",     EXECUTE_SECTION: 5, RESULTS:10, NAMESPACE:ROOT\\BVTAPITEST"}};

IniInfo g_Test302[] = {
    { L"RUNTESTS",                       L"21" },
    { L"NAMESPACE",                      L"ROOT\\BVTAPITEST"},
    { L"DEFINITION_SECTION",             L"302"},
    { L"Description",                    L"Permanent events"},
    { L"MOF_COMMAND",                    L"mofcomp bvtperm\\BVT.MOF"},
    { L"REGISTER_PERM_EVENT_CONSUMER",   L"bvtperm\\cmdlineconsumer.exe"},
    { L"RETRY",                          L"10"},
    { L"SLEEP_IN_MILLISECONDS",          L"1000"},
    { L"FIRE_EVENTS",                    L"1"},
    { L"1",                              L"EXECUTE_SECTION: 303, RESULTS:2, NAMESPACE:ROOT\\BVTAPITEST"}};

IniInfo g_Test303[] = {
    { L"RUNTESTS",            L"304" },
    { L"Description",         L"Create Instances for PermEventConsumer"},
    { L"NAMESPACE",           L"ROOT\\BVTAPITEST"},
    { L"DEFINITION_SECTION",  L"303"},
    { L"INSTANCE_LIST",       L"4,5"},
    { L"FLAGS",               L"WBEM_FLAG_NONSYSTEM_ONLY"},
    { L"4",                   L"Class:PermClass1, Property:Key1:CIM_SINT32:1, InstanceName:PermClass1.Key1=1$EndInstanceName" },
    { L"5",                   L"Class:PermClass1, Property:Key1:CIM_SINT32:2, InstanceName:PermClass1.Key1=2$EndInstanceName" }};


IniInfo g_Test304[] = {
    { L"Description",   L"Creates test classes for perm event consumer"},
    { L"NAMESPACE",     L"ROOT\\BVTAPITEST"},
    { L"Classes",       L"1" },
    { L"1",             L"Class:PermClass1, Property:Key1:CIM_SINT32:1, PropertyQualifier:KEY:Key1:CIM_BOOLEAN:1" }};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  The Adapter tests
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  The scripting tests
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IniInfo g_Test1000[] = { 
    { L"SCRIPTS",L"1,2,3,4"},
    { L"1,", L"scripts\\Test1.vbs" },
    { L"2,", L"scripts\\Test1.vbs" },
    { L"3,", L"scripts\\Test1.vbs" },
    { L"4,", L"scripts\\Test1.vbs" }};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CIniFileAndGlobalOptions::GetSpecificOptionForAPITest(const WCHAR * wcsKey, CHString & sInfo, int nTest)
{
    BOOL fRc = FALSE;
    int nNum = 0;
    int nMax = 0;
    IniInfo * pArray = NULL;
    WCHAR * wcsSection = NULL;

    switch( nTest )
    {
            //==================================================================
            //   The repository tests
            //==================================================================
        case 1:
            pArray = g_Test1;
            nMax = sizeof(g_Test1)/sizeof(IniInfo);
            wcsSection = L"1";
            break;

        case 2:
            pArray = g_Test2;
             nMax = sizeof(g_Test2)/sizeof(IniInfo);
           wcsSection = L"2";
            break;

        case 3:
            pArray = g_Test3;
            nMax = sizeof(g_Test3)/sizeof(IniInfo);
            wcsSection = L"3";
            break;

        case 4:
            pArray = g_Test4;
            nMax = sizeof(g_Test4)/sizeof(IniInfo);
            wcsSection = L"4";
            break;

        case 5:
            pArray = g_Test5;
            nMax = sizeof(g_Test5)/sizeof(IniInfo);
            wcsSection = L"5";
            break;

        case 6:
            pArray = g_Test6;
            nMax = sizeof(g_Test6)/sizeof(IniInfo);
            wcsSection = L"6";
            break;

        case 7:
            pArray = g_Test7;
            nMax = sizeof(g_Test7)/sizeof(IniInfo);
            wcsSection = L"7";
            break;

        case 8:
            pArray = g_Test8;
            nMax = sizeof(g_Test8)/sizeof(IniInfo);
            wcsSection = L"8";
            break;

        case 9:
            pArray = g_Test9;
            nMax = sizeof(g_Test9)/sizeof(IniInfo);
            wcsSection = L"9";
            break;

        case 10:
            pArray = g_Test10;
            nMax = sizeof(g_Test10)/sizeof(IniInfo);
            wcsSection = L"10";
            break;

        case 11:
            pArray = g_Test11;
            nMax = sizeof(g_Test11)/sizeof(IniInfo);
            wcsSection = L"11";
            break;

        case 12:
            pArray = g_Test12;
            nMax = sizeof(g_Test12)/sizeof(IniInfo);
            wcsSection = L"12";
            break;

        case 13:
            pArray = g_Test13;
            nMax = sizeof(g_Test13)/sizeof(IniInfo);
            wcsSection = L"13";
            break;

        case 14:
            pArray = g_Test14;
            nMax = sizeof(g_Test14)/sizeof(IniInfo);
            wcsSection = L"14";
            break;

        case 15:
            pArray = g_Test15;
            nMax = sizeof(g_Test15)/sizeof(IniInfo);
            wcsSection = L"15";
            break;

        case 16:
            pArray = g_Test16;
            nMax = sizeof(g_Test16)/sizeof(IniInfo);
            wcsSection = L"16";
            break;

        case 17:
            pArray = g_Test17;
            nMax = sizeof(g_Test17)/sizeof(IniInfo);
            wcsSection = L"17";
            break;

        case 18:
            pArray = g_Test18;
            nMax = sizeof(g_Test18)/sizeof(IniInfo);
            wcsSection = L"18";
            break;

        case 19:
            pArray = g_Test19;
            nMax = sizeof(g_Test19)/sizeof(IniInfo);
            wcsSection = L"19";
            break;

        case 20:
            pArray = g_Test20;
            nMax = sizeof(g_Test20)/sizeof(IniInfo);
            wcsSection = L"20";
            break;

        case 21:
            pArray = g_Test21;
            nMax = sizeof(g_Test21)/sizeof(IniInfo);
            wcsSection = L"21";
            break;

            //==================================================================
            //   The Other Provider tests
            //==================================================================
        case 200:
            pArray = g_Test200;
            nMax = sizeof(g_Test200)/sizeof(IniInfo);
            wcsSection = L"200";
            break;

        case 201:
            pArray = g_Test201;
            nMax = sizeof(g_Test201)/sizeof(IniInfo);
            wcsSection = L"201";
            break;

        case 202:
            pArray = g_Test202;
            nMax = sizeof(g_Test202)/sizeof(IniInfo);
            wcsSection = L"202";
            break;

        case 204:
            pArray = g_Test204;
            nMax = sizeof(g_Test204)/sizeof(IniInfo);
            wcsSection = L"204";
            break;

        case 205:
            pArray = g_Test205;
            nMax = sizeof(g_Test205)/sizeof(IniInfo);
            wcsSection = L"205";
            break;

        case 206:
            pArray = g_Test206;
            nMax = sizeof(g_Test206)/sizeof(IniInfo);
            wcsSection = L"206";
            break;

        case 207:
            pArray = g_Test207;
            nMax = sizeof(g_Test207)/sizeof(IniInfo);
            wcsSection = L"207";
            break;

        case 208:
            pArray = g_Test208;
            nMax = sizeof(g_Test208)/sizeof(IniInfo);
            wcsSection = L"208";
            break;

        case 209:
            pArray = g_Test209;
            nMax = sizeof(g_Test209)/sizeof(IniInfo);
            wcsSection = L"209";
            break;

        case 210:
            pArray = g_Test210;
            nMax = sizeof(g_Test210)/sizeof(IniInfo);
            wcsSection = L"210";
            break;

        case 211:
            pArray = g_Test211;
            nMax = sizeof(g_Test211)/sizeof(IniInfo);
            wcsSection = L"211";
            break;

        case 212:
            pArray = g_Test212;
            nMax = sizeof(g_Test212)/sizeof(IniInfo);
            wcsSection = L"212";
            break;

            //==================================================================
            //   The event tests
            //==================================================================
        case 300:
            pArray = g_Test300;
            nMax = sizeof(g_Test300)/sizeof(IniInfo);
            wcsSection = L"300";
            break;

        case 301:
            pArray = g_Test301;
            nMax = sizeof(g_Test301)/sizeof(IniInfo);
            wcsSection = L"301";
            break;

        case 302:
            pArray = g_Test302;
            nMax = sizeof(g_Test302)/sizeof(IniInfo);
            wcsSection = L"302";
            break;

        case 303:
            pArray = g_Test303;
            nMax = sizeof(g_Test303)/sizeof(IniInfo);
            wcsSection = L"303";
            break;

        case 304:
            pArray = g_Test304;
            nMax = sizeof(g_Test304)/sizeof(IniInfo);
            wcsSection = L"304";
            break;

            //==================================================================
            //   The scripting tests
            //==================================================================
       case 1000:
            pArray = g_Test1000;
            nMax = sizeof(g_Test1000)/sizeof(IniInfo);
            wcsSection = L"1000";
            break;

 
    }

    if( GetDefaultMatch(pArray,wcsKey,nNum, nMax))
    {
        fRc = ReadIniFile(wcsSection,wcsKey,pArray[nNum].Value,sInfo);
    }
    else
    {
        fRc = ReadIniFile(wcsSection,wcsKey,L"Empty",sInfo);
    }

    return fRc;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CIniFileAndGlobalOptions::WriteDefaultIniFile()
{
    BOOL fRc;
   //================================================================================
   // Write out test 1
   //================================================================================
    for( int i=0; i<sizeof(g_Doc1)/sizeof(IniInfo); i++ )
    {
        fRc = WritePrivateProfileString(L"1", g_Doc1[i].Key, g_Doc1[i].Value,m_wcsFileName);
    }
    fRc = WritePrivateProfileString(L"1", g_Test1[1].Key, g_Test1[1].Value,m_wcsFileName);
    
   //================================================================================
   // Write out test 2
   //================================================================================
    for( int i=0; i<sizeof(g_Doc2)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"2", g_Doc2[i].Key, g_Doc2[i].Value,m_wcsFileName);
    }
    for( int i=0; i<sizeof(g_Test2)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"2", g_Test2[i].Key, g_Test2[i].Value,m_wcsFileName);
    }
   //================================================================================
   // Write out test 3
   //================================================================================
    for( int i=0; i<sizeof(g_Doc3)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"3", g_Doc3[i].Key, g_Doc3[i].Value,m_wcsFileName);
    }
    for( int i=0; i<sizeof(g_Test3)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"3", g_Test3[i].Key, g_Test3[i].Value,m_wcsFileName);
    }
   //================================================================================
   // Write out test 4
   //================================================================================
    for( int i=0; i<sizeof(g_Doc4)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"4", g_Doc4[i].Key, g_Doc4[i].Value,m_wcsFileName);
    }
    WritePrivateProfileString(L"4", g_Test4[0].Key, g_Test4[0].Value,m_wcsFileName);
   //================================================================================
   // Write out test 5
   //================================================================================
    for( int i=0; i<sizeof(g_Doc5)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"5", g_Doc5[i].Key, g_Doc5[i].Value,m_wcsFileName);
    }
    for( int i=0; i<sizeof(g_Test5)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"5", g_Test5[i].Key, g_Test5[i].Value,m_wcsFileName);
    }

    //================================================================================
    // Write out test 6
    //================================================================================
    for( int i=0; i<sizeof(g_Doc6)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"6", g_Doc6[i].Key, g_Doc6[i].Value,m_wcsFileName);
    }
    for( int i=0; i<sizeof(g_Test6)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"6", g_Test6[i].Key, g_Test6[i].Value,m_wcsFileName);
    }

   //================================================================================
   // Write out test 7
   //================================================================================
    for( int i=0; i<sizeof(g_Doc7)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"7", g_Doc7[i].Key, g_Doc7[i].Value,m_wcsFileName);
    }
    for( int i=0; i<sizeof(g_Test7)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"7", g_Test7[i].Key, g_Test7[i].Value,m_wcsFileName);
    }

   //================================================================================
   // Scripting: Write out test 1000
   //================================================================================
   for( int i=0; i<sizeof(g_Test1000)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"7", g_Test1000[i].Key, g_Test1000[i].Value,m_wcsFileName);
    }
 
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//
//  Run the tests
//
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int RunTests(int nWhichTest,BOOL fCompareResults, BOOL fSuppressHeader)
{

    int nRc = FATAL_ERROR;

    Sleep(200);
    switch( nWhichTest )
    {
        //*************************************************************
        //=============================================================
        // The Repository Tests
        //=============================================================
        //*************************************************************

        //=================================================================
        // Basic connect using IWbemLocator 
        //=================================================================
        case 1:
            nRc = BasicConnectUsingIWbemLocator(fCompareResults,fSuppressHeader);
            break;

        //=================================================================
        // Basic Sync connect using IWbemConnection
        //=================================================================
        case 2:
            nRc = BasicSyncConnectUsingIWbemConnection(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        // Basic connect sync & async using IWbemConnection
        //=============================================================
        case 3:
            nRc = BasicAsyncConnectUsingIWbemConnection(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        // Create a new test namespace
        //=============================================================
        case 4:
            nRc = CreateNewTestNamespace(fCompareResults,fSuppressHeader);
            break;
        
        //=============================================================
        // Create 10 classes with different properties. Some of 
        // these should be in the following inheritance chain and 
        // some should not inherit from the others at all:  
        // classes = {A, B, C, D:A, E:A, F:E, G:F, H:G, I:F}.  
        // A mix of simple string & sint32 keys are fine.
        //=============================================================
        case 5:
            nRc = CreateNewClassesInTestNamespace(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        // "memorize the class definitions".  In a complex loop, 
        // delete the classes and recreate them in various sequences, 
        // ending with the full set.
        //=============================================================
        case 6:
            nRc = DeleteAndRecreateNewClassesInTestNamespace(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        // Create associations
        //=============================================================
        case 7:
            nRc= CreateSimpleAssociations(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        // Execute queries
        //=============================================================
        case 8:
            nRc = QueryAllClassesInTestNamespace(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        // Create instances of the above classes, randomly creating 
        // and deleting in a loop, finishing up with a known set.  
        // Query the instances and ensure that no instances disappeared 
        // or appeared that shouldn't be there.    
        //=============================================================
        case 9:
            nRc = CreateClassInstances(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        // Verify that deletion of instances works.
        //=============================================================
        case 10:
            nRc = DeleteClassInstances(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        // Enumerate the instances
        //=============================================================
        case 11:
            nRc = EnumerateClassInstances(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        // Create some simple association classes 
        //=============================================================
        case 12:
            nRc = CreateAssociationInstances(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        //  Delete association instances
        //=============================================================
         case 13:
          nRc = DeleteAssociationInstances(fCompareResults,fSuppressHeader);
          break;

        //=============================================================
        //  Enumerate the association instances
        //=============================================================
        case 14:
            nRc = EnumerateAssociationInstances(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        // Verify that deletion of a class takes out all the instances.
        //=============================================================
        case 15:
            nRc = DeleteClassDeletesInstances(fCompareResults,fSuppressHeader);
            break;

        //=============================================================
        //
        //=============================================================
        case 16:
            nRc = GetObjects(fCompareResults,fSuppressHeader);
            break;

        case 17:
            nRc = CreateMethods(fCompareResults,fSuppressHeader);
            break;

        case 18:
            nRc = DeleteMethods(fCompareResults,fSuppressHeader);
            break;

        case 19:
            nRc = ListMethods(fCompareResults,fSuppressHeader);
            break;

        case 20:
            nRc = DeleteAllNonSystemClasses(fCompareResults,fSuppressHeader);
            break;

        case 21:
            nRc = DeleteRequestedNamespace(fCompareResults,fSuppressHeader);
            break;
        //*************************************************************
        //=============================================================
        // The Other Provider Tests
        //=============================================================
        //*************************************************************
        case 200:
            nRc = ProviderOpenNamespace(fCompareResults,fSuppressHeader);
            break;

        case 201:
            nRc = ProviderEnumerateClasses(fCompareResults,fSuppressHeader);
            break;

        case 202:
            nRc = ProviderExecuteQueries(fCompareResults,fSuppressHeader);
            break;

        case 203:
            nRc = SUCCESS;
            break;

        case 204:
            nRc = ProviderEnumerateInstances(fCompareResults,fSuppressHeader);
            break;

        case 205:
            nRc = ProviderGetObjects(fCompareResults,fSuppressHeader);
            break;

        case 206:
            nRc = ProviderEnumerateMethods(fCompareResults,fSuppressHeader);
            break;

        case 207:
            nRc = ProviderExecuteMethods(fCompareResults,fSuppressHeader);
            break;

        case 208:
            nRc = ProviderSemiSyncEvents(fCompareResults,fSuppressHeader);
            nRc = SUCCESS;
            break;

        case 209:
             nRc = ProviderTempAsyncEvents(fCompareResults,fSuppressHeader);
            nRc = SUCCESS;
            break;

        case 210:
            nRc = ProviderRefresher(fCompareResults,fSuppressHeader);
            break;

        case 211:
            nRc = ProviderCreateClasses(fCompareResults,fSuppressHeader);
            break;

        case 212:
            nRc = ProviderCreateInstances(fCompareResults,fSuppressHeader);
            break;

        //*************************************************************
        //=============================================================
        // The Event Tests
        //=============================================================
        //*************************************************************
        case 300:
            nRc = TempSemiSyncEvents(fCompareResults,fSuppressHeader);
            break;

        case 301:
            nRc = TempAsyncEvents(fCompareResults,fSuppressHeader);
            break;

        case 302:
            nRc = PermanentEvents(fCompareResults,fSuppressHeader);
            break;

        case 303:
            nRc = PermanentInstances(fCompareResults,fSuppressHeader);
            break;

        case 304:
            nRc = PermanentClasses(fCompareResults,fSuppressHeader);
            break;
        //*************************************************************
        //=============================================================
        // The XML Adapter Tests
        //=============================================================
        //*************************************************************

        //*************************************************************
        //=============================================================
        // The OLEDB Adapter Tests
        //=============================================================
        //*************************************************************

        //*************************************************************
        //=============================================================
        // The Scripting Tests
        //=============================================================
        //*************************************************************
        case 1000:
            ExecuteScript(nWhichTest);
            break;

        default:
            g_LogFile.LogError(__FILE__,__LINE__,WARNING, L"Requested test does not exist." );
            break;
    }
        
    return nRc;  
}

////////////////////////////////////////////////////////////////////////////////////////////////////
DWORD WINAPI CMulti::RandomRunTest(LPVOID pHold)
{
    CMulti * pTmp = (CMulti*) pHold;

    int nTest = 0, nMax = 0;

    nMax = pTmp->GetMax();

	if(nMax > 0)
    {
	    float f=((float)rand())/(RAND_MAX+1);
    
	    int nRet=(((int)(nMax*f))+1);

	    nTest = ((nTest+GetCurrentThreadId()) % nMax)+1;
    }
    
    return RunTests(g_nMultiThreadTests[nTest-1],FALSE,FALSE);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
int CMulti::MultiThreadTest(int nThreads, int nConnections )
{
	HRESULT hr = S_OK;	
	DWORD dwFlags = 0;
	DWORD lpExitCode;	

	HANDLE * hpHandles = new HANDLE[nThreads];

	for(int n = 0; n < nConnections; n++)
	{
		for(int i = 0; i < nThreads; i++)
		{		
            Sleep(100);
			hpHandles[i] = CreateThread(0, 0, RandomRunTest, (LPVOID)this, 0, &dwFlags);		
		}	

		for(i = 0; i < nThreads; i++)
		{
			do 
			{				
				GetExitCodeThread(hpHandles[i], &lpExitCode);
			} 
			while(lpExitCode == STILL_ACTIVE);

			CloseHandle(hpHandles[i]);
		}
	}

    SAFE_DELETE_ARRAY(hpHandles);
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\bvtreposit.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTReposit.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <bvt.h>


#define NO_ERRORS_EXPECTED       FALSE,__FILE__,__LINE__
#define ERRORS_CAN_BE_EXPECTED   TRUE,__FILE__,__LINE__

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  UTility functions for this file only
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int OpenNamespaceAndCreateTestClasses( CAutoDeleteString & sNamespace, IWbemServices ** ppNamespace)
{
    int nRc = FATAL_ERROR;
    //=========================================================
    //  Get the name of the test namespace that was created
    //=========================================================

    if( g_Options.GetOptionsForAPITest(sNamespace,APITEST4))
    {
        //=========================================================
        // Create classes with different properties. Some of 
        // these should be in the following inheritance chain and 
        // some should not inherit from the others at all:  
        // classes = {A, B, C, D:A, E:A, F:E, G:F, H:G, I:F}.  
        // A mix of simple string & sint32 keys are fine.
        //=========================================================
        CAutoDeleteString sClassList;
        if( g_Options.GetOptionsForAPITest(sClassList, APITEST5))
        {
            ClassList MasterList;
            //=======================================================
            //  Get the list of the classes to be created
            //=======================================================
            if( InitMasterListOfClasses(sClassList.GetPtr(),MasterList))
            {
	            // ==================================================
                //  Open the namespace 
	            // ==================================================
                nRc = OpenNamespaceAndKeepOpen( ppNamespace, sNamespace.GetPtr(),TRUE);
                if( SUCCESS == nRc )
                {
                    for( int i = 0; i < MasterList.Size(); i++ )
                    {
                        ClassInfo * p = MasterList.GetAt(i);
                        CAutoDeleteString sClassInformation;

                        if( g_Options.GetSpecificOptionForAPITest(p->Class,sClassInformation,APITEST5) )
                        {
                            //===========================================================
                            //  Add the keys and properties
                            //===========================================================
                            nRc = CreateClassAndLogErrors(*ppNamespace,p->Class, sClassInformation.GetPtr(), sNamespace.GetPtr(),NO_ERRORS_EXPECTED);
                            if( nRc != SUCCESS )
                            {
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int OpenNamespaceAndCreateTestClassesAndAssociations( CAutoDeleteString & sNamespace, IWbemServices ** ppNamespace)
{

	// =====================================================================
    //  Open the namespace and create all of the test classes, this happens
    //  a lot, so is is a utility function
	// =====================================================================
    int nRc = OpenNamespaceAndCreateTestClasses( sNamespace, ppNamespace );
    if( nRc == SUCCESS )
    {
       //=================================================
        //  Get the list of associations to create
        //=================================================
        CAutoDeleteString sClassList;

        if( g_Options.GetOptionsForAPITest(sClassList, APITEST7))
        {
            ClassList MasterList;
            //=======================================================
            //  Parse the list of the associations to be created
            //=======================================================
            if( InitMasterListOfClasses(sClassList.GetPtr(),MasterList))
            {

                for( int i = 0; i < MasterList.Size(); i++ )
                {
                    ClassInfo * p = MasterList.GetAt(i);
                    CAutoDeleteString sClassInformation;

                    // =============================================================
                    //  Get definition of the association
                    // =============================================================
                    if( g_Options.GetSpecificOptionForAPITest(p->Class,sClassInformation,APITEST7) )
                    {
                        //===========================================================
                        //  Create the association
                        //===========================================================
                        nRc = CreateAssociationAndLogErrors(*ppNamespace,p->Class,sClassInformation.GetPtr(), sNamespace.GetPtr());
                        if( nRc != SUCCESS )
                        {
                            break;
                        }
                    }
                }
            }
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 1
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int BasicConnectUsingIWbemLocator(void)
{
    int nRc = FATAL_ERROR;
    IWbemServices   * pNamespace    = NULL;
    CAutoDeleteString sNamespace;

    if( g_Options.GetOptionsForAPITest(sNamespace, APITEST1) )
    {
	    // =====================================================================
        //  Open the namespace
	    // =====================================================================
        nRc = OpenNamespaceAndKeepOpen( &pNamespace, sNamespace.GetPtr(),FALSE);
	    // =====================================================================
        //  Release the pointers
	    // =====================================================================
        SAFE_RELEASE_PTR(pNamespace);
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 2
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int BasicSyncConnectUsingIWbemConnection(void)
{
    int nRc = FATAL_ERROR;
    IWbemConnection * pConnection   = NULL;
    CAutoDeleteString sNamespace;
    CAutoDeleteString sClass;
  
    if( g_Options.GetOptionsForAPITest(sNamespace,sClass,APITEST2) )
    {
        nRc = CoCreateInstanceAndLogErrors(CLSID_WbemConnection,IID_IWbemConnection,(void**)&pConnection,NO_ERRORS_EXPECTED);
        if( SUCCESS == nRc )
        {
	        // =================================================================
            //  Test Open with all three types:
            //
            //      IWbemServices
            //      IWbemServicesEx
            //      IWbemClassObject
            //
            //  Initialize all vars
            // =================================================================
            short FatalErrors = 0;

 	        // =================================================================
            //  Open the namespace with IWbemServices
	        // =================================================================
            IWbemServices   * pNamespace        = NULL;
            nRc = OpenObjectAndLogErrors(pConnection, IID_IWbemServices, (void**) &pNamespace, sNamespace.GetPtr(),NO_ERRORS_EXPECTED);
	        if ( nRc != SUCCESS )
            {
                FatalErrors++;
            }
            SAFE_RELEASE_PTR(pNamespace);

	        // =================================================================
            //  Open the namespace with IWbemServicesEx
	        // =================================================================
            IWbemServicesEx * pNamespaceEx      = NULL;
            nRc = OpenObjectAndLogErrors(pConnection, IID_IWbemServicesEx, (void**) &pNamespaceEx,sNamespace.GetPtr(),NO_ERRORS_EXPECTED);
	        if ( nRc != SUCCESS )
            {
                FatalErrors++;
            }
            SAFE_RELEASE_PTR(pNamespaceEx);

	        // =================================================================
            //  Open the Class for IWbemClassObject
	        // =================================================================
            IWbemClassObject* pWbemClassObject  = NULL;
            nRc = OpenObjectAndLogErrors(pConnection, IID_IWbemClassObject, (void**) &pWbemClassObject,sClass.GetPtr(),NO_ERRORS_EXPECTED);
	        if ( nRc != SUCCESS )
            {
                FatalErrors++;
            }
            SAFE_RELEASE_PTR(pWbemClassObject);

	        // =================================================================
            //  Check to see if there were any fatal errors
	        // =================================================================
            if( !FatalErrors )
            {
                nRc = SUCCESS;
            }
        }
    	// =====================================================================
        //  Release the locator
	    // =====================================================================
        SAFE_RELEASE_PTR(pConnection);
    }

    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 3
//*****************************************************************************************************************
int BasicAsyncConnectUsingIWbemConnection(void)
{
    int nRc    = FATAL_ERROR;
    HRESULT hr = S_OK;
    IWbemConnection * pConnection   = NULL;
    CAutoDeleteString sNamespace;
    CAutoDeleteString sClass;
  
    if( g_Options.GetOptionsForAPITest(sNamespace,sClass,APITEST2) )
    {
        nRc = CoCreateInstanceAndLogErrors(CLSID_WbemConnection,IID_IWbemConnection,(void**)&pConnection,NO_ERRORS_EXPECTED);
        if( SUCCESS == nRc )
        {
 	        // =================================================================
            //  Test Open with all three types:
            //
            //      IWbemServices
            //      IWbemServicesEx
            //      IWbemClassObject
            //
            //  Initialize all the vars
	        // =================================================================
            short FatalErrors = 0;
            CSinkEx * pHandler = NULL;

            pHandler = new CSinkEx;
            if( pHandler )
            {
                // =================================================================
                //  Open the namespace with IWbemServices
	            // =================================================================
                nRc = OpenObjectAsyncAndLogErrors(pConnection, IID_IWbemServices,sNamespace.GetPtr(),pHandler,NO_ERRORS_EXPECTED);
	            if ( nRc == FATAL_ERROR )
                {
                    FatalErrors++;
                }
                else
                {
                    IWbemServices * pNamespace = NULL;

			        pHandler->WaitForSignal(INFINITE);
			        hr = pHandler->GetStatusCode();
			        if(SUCCEEDED(hr))
                    {
				        pNamespace = (IWbemServices*)pHandler->GetInterface();
			        }

                    SAFE_RELEASE_PTR(pNamespace);
                }
            }
            else
            {
                g_LogFile.LogError(__FILE__,__LINE__,FATAL_ERROR, L"Allocation of new CSinkEx Failed - Out of memory.");
            }
            SAFE_DELETE_PTR(pHandler);


	        // =================================================================
            //  Open the namespace with IWbemServicesEx
	        // =================================================================
            pHandler = new CSinkEx;
            if( pHandler )
            {
                nRc = OpenObjectAsyncAndLogErrors(pConnection, IID_IWbemServicesEx,sNamespace.GetPtr(), pHandler,NO_ERRORS_EXPECTED);
	            if ( nRc == FATAL_ERROR )
                {
                    FatalErrors++;
                }
                else
                {
                    IWbemServicesEx * pNamespace = NULL;

			        pHandler->WaitForSignal(INFINITE);
			        hr = pHandler->GetStatusCode();
			        if(SUCCEEDED(hr))
                    {
				        pNamespace = (IWbemServicesEx*)pHandler->GetInterface();
			        }

                    SAFE_RELEASE_PTR(pNamespace);
                }
            }
            else
            {
                g_LogFile.LogError(__FILE__,__LINE__,FATAL_ERROR, L"Allocation of new CSinkEx Failed - Out of memory.");
            }
            SAFE_DELETE_PTR(pHandler);

	        // =================================================================
            //  Open the class for IWbemClassObject
	        // =================================================================
            pHandler = new CSinkEx;
            if( pHandler )
            {
                nRc = OpenObjectAsyncAndLogErrors(pConnection, IID_IWbemClassObject,sClass.GetPtr(), pHandler,NO_ERRORS_EXPECTED);
	            if ( nRc == FATAL_ERROR )
                {
                    FatalErrors++;
                }
                else
                {
                    IWbemClassObject * pWbemClassObject  = NULL;
        
			        pHandler->WaitForSignal(INFINITE);
			        hr = pHandler->GetStatusCode();
			        if(SUCCEEDED(hr))
                    {
				        pWbemClassObject = (IWbemClassObject*)pHandler->GetInterface();
			        }

                    SAFE_RELEASE_PTR(pWbemClassObject);
                }
            }
            else
            {
                g_LogFile.LogError(__FILE__,__LINE__,FATAL_ERROR, L"Allocation of new CSinkEx Failed - Out of memory.");
            }
            SAFE_DELETE_PTR(pHandler);

	        // =================================================================
            //  Check to see if there are any fatal errors
	        // =================================================================
            if( !FatalErrors )
            {
                nRc = SUCCESS;
            }
        }

	    // =====================================================================
        //  Release the locator
	    // =====================================================================
        SAFE_RELEASE_PTR(pConnection);
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 4
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CreateNewTestNamespace()
{
    int nRc = SUCCESS;
    CAutoDeleteString sNamespace;
    CAutoDeleteString sInstance;
  
    if( g_Options.GetOptionsForAPITest(sNamespace, sInstance, APITEST4))
    {
        IWbemLocator * pLocator = NULL;

        nRc = CoCreateInstanceAndLogErrors(CLSID_WbemLocator,IID_IWbemLocator,(void**)&pLocator,NO_ERRORS_EXPECTED);
        if( SUCCESS == nRc )
        {
            //==========================================================================
            //  Parse the namespace name to get the parent first, and open the parent
            //  this one must be existing 
            //==========================================================================
            IWbemServices * pParentNamespace = NULL;
            IWbemServices * pChildNamespace  = NULL;

            nRc = ConnectServerAndLogErrors(pLocator,&pParentNamespace,sNamespace.GetPtr(),NO_ERRORS_EXPECTED);
            if( nRc == SUCCESS )
            {
                //==============================================================
                //  If we got here, then we know that the child namespace does 
                //  not exist, so create it.
                //==============================================================
                nRc = CreateInstances(pParentNamespace, sInstance, sNamespace.GetPtr(), APITEST4 );
                if( SUCCESS == nRc )
                {
                    //==========================================================
                    //  Open the namespace with IWbemServices as the new parent
                    //==========================================================
                    nRc = ConnectServerAndLogErrors(pLocator, &pChildNamespace, sNamespace.GetPtr(),NO_ERRORS_EXPECTED);
                }
            }
            SAFE_RELEASE_PTR(pParentNamespace);
            SAFE_RELEASE_PTR(pChildNamespace);
        }
        // =============================================================================
        //  Release the locator
	    // =============================================================================
        SAFE_RELEASE_PTR(pLocator);
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 5
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int CreateNewClassesInTestNamespace()
{
    int nRc = FATAL_ERROR;
    CAutoDeleteString sNamespace;
    IWbemServices * pNamespace = NULL;

	// =====================================================================
    //  Open the namespace and create all of the test classes, this happens
    //  a lot, so is is a utility function
	// =====================================================================
    nRc = OpenNamespaceAndCreateTestClasses( sNamespace, &pNamespace );

	// =====================================================================
    //  Release the pointers
    // =====================================================================
    SAFE_RELEASE_PTR(pNamespace);

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 6
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteAndRecreateNewClassesInTestNamespace()
{
    int nRc = FATAL_ERROR;
    CAutoDeleteString sNamespace;
    IWbemServices * pNamespace = NULL;

	// =====================================================================
    //  Open the namespace and create all of the test classes, this happens
    //  a lot, so is is a utility function
	// =====================================================================
    nRc = OpenNamespaceAndCreateTestClasses( sNamespace, &pNamespace );
    if( nRc == SUCCESS )
    {
        //=========================================
        //  Get all of the class operations for 
        //  this test:
        //     Classes to be deleted
        //     Classes to be compared
        //     Classes to be added
        //     Classes to be compared
        //     Classes to be added_deleted
        //     Classes to be compared
        //=============================================
        CAutoDeleteString sDeleteClasses;
        CAutoDeleteString sClassesAfterDelete;
        CAutoDeleteString sAddClasses; 
        CAutoDeleteString sClassesAfterAdd; 
        CAutoDeleteString sDeleteAddClassOrder; 
        CAutoDeleteString sClassesAfterDeleteAdd;

        if( g_Options.GetOptionsForAPITest( sDeleteClasses, sClassesAfterDelete,sAddClasses,
                                            sClassesAfterAdd,sDeleteAddClassOrder,
                                            sClassesAfterDeleteAdd ) )
        {
            nRc = DeleteClasses(sDeleteClasses, pNamespace, sNamespace.GetPtr());
            if( nRc == SUCCESS )
            {
                nRc = EnumerateClassesAndCompare(sClassesAfterDelete, pNamespace, sNamespace.GetPtr());
                if( nRc == SUCCESS )
                {
                    nRc = AddClasses(sAddClasses, pNamespace, sNamespace.GetPtr());
                    if( nRc == SUCCESS )
                    {
                        nRc = EnumerateClassesAndCompare(sClassesAfterAdd, pNamespace, sNamespace.GetPtr());
                        if( nRc == SUCCESS )
                        {
                            nRc = DeleteAndAddClasses(sDeleteAddClassOrder, pNamespace, sNamespace.GetPtr());
                            if( nRc == SUCCESS )
                            {
                                nRc = EnumerateClassesAndCompare(sClassesAfterDeleteAdd, pNamespace, sNamespace.GetPtr());
                            }
                        }
                    }
                }
            }
        }
    }
    // =====================================================================
    //  Release the pointers
    // =====================================================================
    SAFE_RELEASE_PTR(pNamespace);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 7
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CreateSimpleAssociations()
{
    int nRc = FATAL_ERROR;
	// =====================================================================
    //  Made into a utility function as it is used more than once
	// =====================================================================
    CAutoDeleteString sNamespace;
    IWbemServices * pNamespace = NULL;

    nRc = OpenNamespaceAndCreateTestClassesAndAssociations( sNamespace,&pNamespace);

	// =====================================================================
    //  Release the pointers
    // =====================================================================
    SAFE_RELEASE_PTR(pNamespace);

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 8
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int QueryAllClassesInTestNamespace()
{
    int nRc = FATAL_ERROR;
    CAutoDeleteString sNamespace;
    IWbemServices * pNamespace = NULL;

	// =====================================================================
    //  Made into a utility function as it is used more than once
	// =====================================================================
    nRc = OpenNamespaceAndCreateTestClassesAndAssociations( sNamespace,&pNamespace);
    if( nRc == SUCCESS )
    {
        //==================================================================
        // Query classes in test namespace
        //==================================================================
        CAutoDeleteString sQueryList;
        if( g_Options.GetOptionsForAPITest(sQueryList, APITEST8))
        {
            ClassList MasterList;
            //=======================================================
            //  Get the list of the queries
            //=======================================================
            if( InitMasterListOfClasses(sQueryList.GetPtr(),MasterList))
            {
                for( int i = 0; i < MasterList.Size(); i++ )
                {
                    ClassInfo * p = MasterList.GetAt(i);
                    CAutoDeleteString sQuery;

                    if( g_Options.GetSpecificOptionForAPITest(p->Class,sQuery,APITEST8) )
                    {
                        //==================================================================
                        // Regular query
                        //==================================================================
                        nRc = QueryAndCompareResults( pNamespace, sQuery.GetPtr(), sNamespace.GetPtr());
                        if( nRc != S_OK )
                        {
                            break;
                        }
                    }
                }
            }
        }
    }
	// =====================================================================
    //  Release the pointers
    // =====================================================================
    SAFE_RELEASE_PTR(pNamespace);

    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 9
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CreateClassInstances()
{
    int nRc = FATAL_ERROR;
    CAutoDeleteString sNamespace;
    IWbemServices * pNamespace = NULL;

	// =====================================================================
    //  Open the namespace and create all of the test classes, this happens
    //  a lot, so is is a utility function
	// =====================================================================
    nRc = OpenNamespaceAndCreateTestClasses( sNamespace, &pNamespace );
    if( nRc == SUCCESS )
    {
        // =============================================================
        //  Get the list of classes to get instances for
        // =============================================================
        CAutoDeleteString sInstanceList;
        CAutoDeleteString sInstanceCompareList;

        if( g_Options.GetOptionsForAPITest( sInstanceList, sInstanceCompareList, APITEST9 ) )
        {
            // =========================================================
            // Create the instances in the namespace
            // =========================================================
            nRc = CreateInstances(pNamespace, sInstanceList, sNamespace.GetPtr(), APITEST4 );
            if( SUCCESS == nRc )
            {
                // =====================================================
                //  Make sure those instances are in the namespace
                // =====================================================
                nRc = EnumerateInstancesAndCompare(pNamespace, sInstanceList, sInstanceCompareList,sNamespace.GetPtr());
            }
        }
    }
	// =====================================================================
    //  Release the pointers
	// =====================================================================
    SAFE_RELEASE_PTR(pNamespace);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 10
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteClassInstances()
{
    int nRc = FATAL_ERROR;
    CAutoDeleteString sNamespace;
    IWbemServices * pNamespace = NULL;

	// =====================================================================
    //  Open the namespace and create all of the test classes, this happens
    //  a lot, so is is a utility function
    //==========================================================================
    // Delete instances  
    //==========================================================================
    nRc = OpenNamespaceAndCreateTestClasses( sNamespace, &pNamespace );
    if( nRc == SUCCESS )
    {
        // =============================================================
        //  Get the list of instances to delete
        // =============================================================
        CAutoDeleteString sInstanceList;
        if( g_Options.GetOptionsForAPITest( sInstanceList, APITEST13 ) )
        {
            // =========================================================
            // Delete the instances in the namespace
            // =========================================================
            nRc = DeleteInstances(sInstanceList, pNamespace, sNamespace.GetPtr());
            if( SUCCESS == nRc )
            {
                // =====================================================
                //  Make sure those instances are not in the namespace
                // =====================================================
            }
        }
    }
	// =====================================================================
    //  Release the pointers
	// =====================================================================
    SAFE_RELEASE_PTR(pNamespace);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 11
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int EnumerateClassInstances()
{
    //==========================================================================
    // Get instance enumerator for requested classes
    //==========================================================================
    int nRc = FATAL_ERROR;
    CAutoDeleteString sNamespace;
    IWbemServices * pNamespace = NULL;

	// =====================================================================
    //  Open the namespace and create all of the test classes, this happens
    //  a lot, so is is a utility function
	// =====================================================================
    nRc = OpenNamespaceAndCreateTestClasses( sNamespace, &pNamespace );
    if( nRc == SUCCESS )
    {
        // =============================================================
        //  Get the list of classes to get instances for
        // =============================================================
        CAutoDeleteString sInstanceList;
        CAutoDeleteString sInstanceCompareList;
        
        if( g_Options.GetOptionsForAPITest( sInstanceList, sInstanceCompareList, APITEST11 ) )
        {
            // =========================================================
            // Make sure those instances are in the namespace
            // =========================================================
            nRc = EnumerateInstancesAndCompare(pNamespace, sInstanceList, sInstanceCompareList, sNamespace.GetPtr());
        }
    }
	// =====================================================================
    //  Release the pointers
	// =====================================================================
    SAFE_RELEASE_PTR(pNamespace);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 12
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CreateAssociationInstances()
{
    //==========================================================================
    // Get instance enumerator for requested classes  
    //==========================================================================
    int nRc = FATAL_ERROR;
    CAutoDeleteString sNamespace;
    IWbemServices * pNamespace = NULL;

	// =====================================================================
    //  Open the namespace and create all of the test classes, this happens
    //  a lot, so is is a utility function
	// =====================================================================
    nRc = OpenNamespaceAndCreateTestClasses( sNamespace, &pNamespace );
    if( nRc == SUCCESS )
    {
        // =============================================================
        //  Get the list of classes to get instances for
        // =============================================================
        CAutoDeleteString sInstanceList;
        CAutoDeleteString sInstanceCompareList;

        if( g_Options.GetOptionsForAPITest( sInstanceList, sInstanceCompareList, APITEST12 ) )
        {
            // =========================================================
            // Create the instances in the namespace
            // =========================================================
            nRc = CreateInstances(pNamespace, sInstanceList, sNamespace.GetPtr(), APITEST4 );
            if( SUCCESS == nRc )
            {
                // =====================================================
                //  Make sure those instances are in the namespace
                // =====================================================
                nRc = EnumerateInstancesAndCompare(pNamespace, sInstanceList, sInstanceCompareList,sNamespace.GetPtr());
            }
        }
    }
	// =====================================================================
    //  Release the pointers
	// =====================================================================
    SAFE_RELEASE_PTR(pNamespace);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 13
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteAssociationInstances()
{
    //==========================================================================
    // Delete instances  
    //==========================================================================
   int nRc = FATAL_ERROR;
    CAutoDeleteString sNamespace;
    IWbemServices * pNamespace = NULL;

	// =====================================================================
    //  Open the namespace and create all of the test classes, this happens
    //  a lot, so is is a utility function
	// =====================================================================
    nRc = OpenNamespaceAndCreateTestClasses( sNamespace, &pNamespace );
    if( nRc == SUCCESS )
    {
        // =============================================================
        //  Get the list of instances to delete
        // =============================================================
        CAutoDeleteString sInstanceList;
        if( g_Options.GetOptionsForAPITest( sInstanceList, APITEST13 ) )
        {
            // =========================================================
            // Delete the instances in the namespace
            // =========================================================
            nRc = DeleteInstances(sInstanceList, pNamespace, sNamespace.GetPtr());
            if( SUCCESS == nRc )
            {
                // =====================================================
                //  Make sure those instances are not in the namespace
                // =====================================================
            }
        }
    }
	// =====================================================================
    //  Release the pointers
	// =====================================================================
    SAFE_RELEASE_PTR(pNamespace);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 14
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int EnumerateAssociationInstances()
{
    //==========================================================================
    // Get instance enumerator for requested classes  
    //==========================================================================
    int nRc = FATAL_ERROR;
    CAutoDeleteString sNamespace;
    IWbemServices * pNamespace = NULL;

	// =====================================================================
    //  Open the namespace and create all of the test classes, this happens
    //  a lot, so is is a utility function
	// =====================================================================
    nRc = OpenNamespaceAndCreateTestClasses( sNamespace, &pNamespace );
    if( nRc == SUCCESS )
    {
        // =============================================================
        //  Get the list of classes to get instances for
        // =============================================================
        CAutoDeleteString sInstanceList;
        CAutoDeleteString sInstanceCompareList;

        if( g_Options.GetOptionsForAPITest( sInstanceList, sInstanceCompareList, APITEST14 ) )
        {
            // =========================================================
            // Make sure those instances are in the namespace
            // =========================================================
            nRc = EnumerateInstancesAndCompare(pNamespace, sInstanceList, sInstanceCompareList, sNamespace.GetPtr());
        }
    }
	// =====================================================================
    //  Release the pointers
	// =====================================================================
    SAFE_RELEASE_PTR(pNamespace);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 15
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteClassDeletesInstances()
{
    int nRc = FATAL_ERROR;
    CAutoDeleteString sNamespace;
    IWbemServices * pNamespace = NULL;

	// =====================================================================
    //  Open the namespace and create all of the test classes, this happens
    //  a lot, so is is a utility function
	// =====================================================================
    nRc = OpenNamespaceAndCreateTestClasses( sNamespace, &pNamespace );
    if( nRc == SUCCESS )
    {
    }
 	 
    // =====================================================================
    //  Release the pointers
    // =====================================================================
    SAFE_RELEASE_PTR(pNamespace);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 16
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetObjects()
{
    //==========================================================================
    // Get the various types of objects (classes/instances) using the various
    // types of paths accepted by WMI ( WMI path/ UMI path/ HTTP path)
    //==========================================================================
    int nRc = FATAL_ERROR;
    CAutoDeleteString sNamespace;
    IWbemServices * pNamespace = NULL;

	// =====================================================================
    //  Open the namespace and create all of the test classes, this happens
    //  a lot, so is is a utility function
	// =====================================================================
    nRc = OpenNamespaceAndCreateTestClasses( sNamespace, &pNamespace );
    if( nRc == SUCCESS )
    {
        // =============================================================
        //  Get the list of objexts to get
        // =============================================================
        CAutoDeleteString sObjects;
        if( g_Options.GetOptionsForAPITest( sObjects, APITEST16 ) )
        {
            // =========================================================
            // Get the requested objects
            // =========================================================
            nRc = GetSpecificObjects(sObjects, pNamespace, sNamespace.GetPtr());
        }
    }
	// =====================================================================
    //  Release the pointers
	// =====================================================================
    SAFE_RELEASE_PTR(pNamespace);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 17
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetClassMethods()
{
	// =====================================================================
    // Getting a list of Methods for a class
	// =====================================================================
    int nRc = FATAL_ERROR;
    CAutoDeleteString sNamespace;
    IWbemServices * pNamespace = NULL;

	// =====================================================================
    //  Open the namespace and create all of the test classes, this happens
    //  a lot, so is is a utility function
	// =====================================================================
    nRc = OpenNamespaceAndCreateTestClasses( sNamespace, &pNamespace );
    if( nRc == SUCCESS )
    {
    }
    SAFE_RELEASE_PTR(pNamespace);
 
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Test 18
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetInstanceMethods()
{
	// =====================================================================
    // Getting a list of Methods for an instance
	// =====================================================================
    int nRc = FATAL_ERROR;
    CAutoDeleteString sNamespace;
    IWbemServices * pNamespace = NULL;

	// =====================================================================
    //  Open the namespace and create all of the test classes, this happens
    //  a lot, so is is a utility function
	// =====================================================================
    nRc = OpenNamespaceAndCreateTestClasses( sNamespace, &pNamespace );
    if( nRc == SUCCESS )
    {
    }
    SAFE_RELEASE_PTR(pNamespace);
 
    return nRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\bvtapilib\bvt.h ===
/////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _BVT_HEADER
#define _BVT_HEADER

/////////////////////////////////////////////////////////////////////////////////////////////
//*******************************************************************************************
//
//  Common headers
//
//*******************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <stdio.h>
#include <wbemcli.h>
#include <oahelp.inl>
#include <wbemutil.h>
#include <flexarry.h>
#include <cominit.h>

/////////////////////////////////////////////////////////////////////////////////////////////
//*******************************************************************************************
//
//  Common macros and define
//
//*******************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////
#define SAFE_DELETE_PTR(pv)  \
	{ if(pv) delete pv;  \
      pv = NULL; }

#define SAFE_RELEASE_PTR(pv)  \
{   if(pv){  pv->Release(); }  \
      pv = NULL; }

#define SAFE_DELETE_ARRAY(pv)  \
	{ if(pv) delete []pv;  \
      pv = NULL; }

#define SUCCESS             0
#define WARNING             10
#define FATAL_ERROR         20
#define FAILED_AS_EXPECTED  30
#define NO_MORE_DATA        40

#define ADD_CLASS 0
#define DELETE_CLASS 1

//====================================================================================================
//  The Repository tests
//====================================================================================================
#define APITEST1   1       
#define APITEST2   2       
#define APITEST3   3        
#define APITEST4   4      
#define APITEST5   5
#define APITEST6   6
#define APITEST7   7
#define APITEST8   8
#define APITEST9   9
#define APITEST10  10
#define APITEST11  11
#define APITEST12  12
#define APITEST13  13
#define APITEST14  14
#define APITEST15  15
#define APITEST16  16
#define APITEST17  17
#define APITEST18  18
#define APITEST19  19
#define APITEST20  20
#define APITEST21  21
#define APITEST22  22
#define APITEST23  23
#define APITEST24  24
//====================================================================================================
//  The Provider CIMV2 tests
//====================================================================================================
#define APITEST200 200
#define APITEST201 201
#define APITEST202 202
#define APITEST203 203
#define APITEST204 204

//====================================================================================================
// Scripting tests
//====================================================================================================
#define SCRIPTTEST1 1001

#define NO_ERRORS_EXPECTED       FALSE,__FILE__,__LINE__
#define ERRORS_CAN_BE_EXPECTED   TRUE,__FILE__,__LINE__

/////////////////////////////////////////////////////////////////////////////////////////////
//*******************************************************************************************1
//
//  Typedefs
//
//*******************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////
typedef struct _IniInfo
{
    LPWSTR Key;
    LPWSTR Value;

} IniInfo;

typedef struct _PropertyInfo
{
    const WCHAR *   Property;
    const WCHAR *   QualifierName;
    CVARIANT        Var;
    long            Type;

    _PropertyInfo()     { QualifierName = Property = NULL; }
    ~_PropertyInfo()    {}
} PropertyInfo;
 
typedef struct _CPropertyList
{
    CFlexArray m_List;
    void Add( PropertyInfo * p)       { m_List.Add(p);}
    inline long Size()                { return m_List.Size(); }
    PropertyInfo * GetAt(int x)       { return (PropertyInfo*)m_List.GetAt(x);}

     _CPropertyList()            {}
     ~_CPropertyList();          
} CPropertyList;

typedef struct _ClassInfo
{
    const WCHAR *   Class;
    BOOL            fProcessed;
    BOOL            fAction;

    _ClassInfo()    { Class = NULL; fProcessed = 0; fAction = 0; }
    ~_ClassInfo()   {}

}ClassInfo;

typedef struct _ClassList
{
    CFlexArray m_List;
    void Add( ClassInfo * p)       { m_List.Add(p);}
    inline long Size()             { return m_List.Size(); }
    ClassInfo * GetAt(int x)       { return (ClassInfo*)m_List.GetAt(x);}

    int ClassesCompareAsExpectedAndLogErrors(WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile, const ULONG Line);
    int ClassInListAndLogErrors(WCHAR * wcsClass, WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile, const ULONG Line);

     _ClassList()            {}
     ~_ClassList();          
} ClassList;


/////////////////////////////////////////////////////////////////////////////////////////////
//*******************************************************************************************1
//
//  Prototypes 
//
//*******************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////

int BasicConnectUsingIWbemLocator(void);                    // Test 1
int BasicSyncConnectUsingIWbemConnection(void);             // Test 2
int BasicAsyncConnectUsingIWbemConnection(void);            // Test 3
int CreateNewTestNamespace(void);                           // Test 4
int CreateNewClassesInTestNamespace(void);                  // Test 5
int DeleteAndRecreateNewClassesInTestNamespace(void);       // Test 6
int CreateSimpleAssociations();                             // Test 7
int QueryAllClassesInTestNamespace(void);                   // Test 8


/////////////////////////////////////////////////////////////////////////////////////////////
//*******************************************************************************************
//
//  Class definitions
//
//*******************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////
class CVARIANTEx : public CVARIANT
{
    public:
        CVARIANTEx() {}
        CVARIANTEx(const WCHAR * pSrc) { VariantInit(&v); SetStr(pSrc); }
        ~CVARIANTEx() {}

        void   SetStr(const WCHAR * pSrc)
        {   Clear(); V_VT(&v) = pSrc ? VT_BSTR : VT_NULL; 
            V_BSTR(&v) = pSrc ? SysAllocString(pSrc) : 0; 
        }
};

class CCriticalSection 
{
    public:		
        CCriticalSection()          {  Init(); }

        ~CCriticalSection() 	    {  Delete(); }
        inline void Init()          {  InitializeCriticalSection(&m_criticalsection);   }
        inline void Delete()        {  DeleteCriticalSection(&m_criticalsection); }
        inline void Enter()         {  EnterCriticalSection(&m_criticalsection); }
        inline void Leave()         {  LeaveCriticalSection(&m_criticalsection); }

    private:

	    CRITICAL_SECTION	m_criticalsection;			// standby critical section
};  

/////////////////////////////////////////////////////////////////////////////////////////////
class CAutoBlock
{
    private:

	    CCriticalSection *m_pCriticalSection;

    public:

        CAutoBlock(CCriticalSection *pCriticalSection)
        {
	        m_pCriticalSection = NULL;
	        if(pCriticalSection)
            {
		        pCriticalSection->Enter();
            }
	        m_pCriticalSection = pCriticalSection;
        }

        ~CAutoBlock()
        {
	        if(m_pCriticalSection)
		        m_pCriticalSection->Leave();

        }
};
/////////////////////////////////////////////////////////////////////////////////////////////
#include "bvtutil.h"
#include "bvtcom.h"
#include "bvtapi.h"

/////////////////////////////////////////////////////////////////////////////////////////////
//*******************************************************************************************
//
//  Global Variables
//
//*******************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////
#ifndef DECLARE_GLOBALS

    extern CLogAndDisplayOnScreen   g_LogFile;
    extern CIniFileAndGlobalOptions g_Options;
    extern g_nDefaultTests[];
#else
    CLogAndDisplayOnScreen      g_LogFile;
    CIniFileAndGlobalOptions    g_Options;
    int g_nDefaultTests[] = {1,2,3,4,5,6,7,8,9,10};


#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\bvtapilib\bvtapi.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTUtil.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "bvt.h"
#include <time.h>
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CoCreateInstanceAndLogErrors( REFCLSID  clsid, REFIID  iid, void ** pPtr, 
                                  BOOL fExpectedFailure, const char * csFile, const ULONG Line )
{
    int nRc = SUCCESS;

 	// =================================================================
    //  Open the namespace with IWbemServices
	// =================================================================
    HRESULT hr = CoCreateInstance( clsid, NULL, CLSCTX_INPROC_SERVER, iid, (void**) pPtr );
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
             nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"CoCreateInstance failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from CoCreateInstance was: 0x%x", hr );
            LogCLSID(csFile,Line, L"REFIID ",iid);
            LogCLSID(csFile,Line, L"REFCLSID ",clsid);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ConnectServerAndLogErrors(IWbemLocator * pLocator, IWbemServices ** pNamespace, 
                              WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile, const ULONG Line )
{
    int nRc = SUCCESS;

 	// =================================================================
    //  Open the namespace with IWbemServices
	// =================================================================
    HRESULT hr = pLocator->ConnectServer( CBSTR(wcsNamespace),	// NameSpace Name
  							      NULL,			// UserName
								  NULL,			// Password
								  NULL,			// Locale
								  0L,				// Security Flags
								  NULL,			// Authority
								  NULL,			// Wbem Context
								  pNamespace	// Namespace
								);
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
             nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"ConnectServer via IWbemLocator failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from ConnectServer was: 0x%x", hr );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to open namespace: %s",wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int OpenObjectAndLogErrors( IWbemConnection * pConnection, REFIID  iid, void ** pObj, 
                            WCHAR * wcsObjectName, BOOL fExpectedFailure, const char * csFile, const ULONG Line )
{
    int nRc = SUCCESS;

 	// =================================================================
    //  Open the requested object
	// =================================================================
	HRESULT hr = pConnection->Open(	CBSTR(wcsObjectName), NULL, NULL, NULL, 0L, NULL, iid,(void**) &pObj, NULL);
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
             nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Open via IWbemConnection failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from Open was: 0x%x", hr );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Object Name: %s",wcsObjectName);
            LogCLSID(csFile,Line, L"REFIID",iid);

            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int OpenObjectAsyncAndLogErrors( IWbemConnection * pConnection, REFIID  iid, WCHAR * wcsObjectName, IWbemObjectSinkEx * pHandler,
                                 BOOL fExpectedFailure, const char * csFile, const ULONG Line )
{
    int nRc = SUCCESS;

 	// =================================================================
    //  Open the requested object
	// =================================================================
    HRESULT hr = pConnection->OpenAsync(CBSTR(wcsObjectName), NULL, NULL, NULL, 0L, NULL, iid,pHandler);
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
             nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"OpenAsync via IWbemConnection failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from OpenAsync was: 0x%x", hr );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Object Name: %s",wcsObjectName);
            LogCLSID(csFile,Line, L"REFIID",iid);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetPropertyAndLogErrors( IWbemClassObject * pClass, WCHAR * wcsProperty, VARIANT * vProperty, CIMTYPE * pType,
                             LONG * plFlavor, WCHAR * wcsClassName, WCHAR * wcsNamespace,
                             BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;

 	// =================================================================
    //  Open the namespace with IWbemServices
	// =================================================================
    HRESULT hr = pClass->Get(CBSTR(wcsProperty),0L,vProperty,pType, plFlavor);
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Get failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from Get was: 0x%x", hr );
            if( wcsClassName )
            {
                g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to get property %s from class: %s from Namespace %s",wcsProperty, wcsClassName,wcsNamespace);
            }
            else
            {
                g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to get the class name (property %s) from Namespace %s",wcsProperty, wcsNamespace);
            }
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetClassObjectAndLogErrors( IWbemServices * pNamespace, const WCHAR * wcsClassName, IWbemClassObject ** ppClass,
                                WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;

 	// =================================================================
    //  Open the namespace with IWbemServices
	// =================================================================
    WCHAR * wcsClass = (WCHAR*) wcsClassName;
  	
    HRESULT hr = pNamespace->GetObject(CBSTR(wcsClass),WBEM_FLAG_RETURN_WBEM_COMPLETE,NULL,ppClass,NULL );
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"GetObject failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from GetObject was: 0x%x", hr );
            if( wcsClassName )
            {
                g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to get class: %s from Namespace %s",wcsClassName,wcsNamespace);
            }
            else
            {
                g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting create an empty class in the Namespace %s",wcsNamespace);
            }
            nRc = FATAL_ERROR;
        }
    }
    return nRc;

}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int SpawnInstanceAndLogErrors( IWbemClassObject * pClass, const WCHAR * wcsClassName, IWbemClassObject ** ppInst,
                               WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;

 	// =================================================================
    //  Open the namespace with IWbemServices
	// =================================================================
    HRESULT hr = pClass->SpawnInstance(0, ppInst);
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"SpawnInstance failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from SpawnInstance was: 0x%x", hr );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to spawn instance of class: %s from Namespace %s",wcsClassName,wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int SpawnDerivedClassAndLogErrors( IWbemClassObject * pClass, const WCHAR * wcsClassName, IWbemClassObject ** ppInst,
                               WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;

 	// =================================================================
    //  Open the namespace with IWbemServices
	// =================================================================
    HRESULT hr = pClass->SpawnDerivedClass(0, ppInst);
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"SpawnDerivedClass failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from SpawnDerivedClass was: 0x%x", hr );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to spawn derviced class: %s from Namespace %s",wcsClassName,wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int PutPropertyAndLogErrors( IWbemClassObject * pInst, const WCHAR * wcsProperty, long lType, VARIANT * pVar, const WCHAR * wcsClass,
                             DWORD dwFlags,WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;

 	// =================================================================
    //  Open the namespace with IWbemServices
	// =================================================================
    WCHAR * wcsProp = (WCHAR*)wcsProperty;
    HRESULT hr = pInst->Put(CBSTR(wcsProp), dwFlags, pVar, lType);
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Put failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from Put was: 0x%x", hr );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to put %s in class %s in Namespace %s",wcsProperty,wcsClass,wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int PutInstanceAndLogErrors( IWbemServices * pNamespace, IWbemClassObject * pInst, const WCHAR * wcsClass,
                             WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Open the namespace with IWbemServices
	// =================================================================
    HRESULT hr = pNamespace->PutInstance(pInst,WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"PutInstance failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from PutInstance was: 0x%x", hr );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to put instance of class %s in Namespace %s",wcsClass,wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ClassInheritsFromAndLogErrors( IWbemClassObject * pClass, const WCHAR * wcsClass, const WCHAR * wcsParent, 
                                   WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Set who the class inherits from
	// =================================================================
    HRESULT hr = pClass->InheritsFrom( wcsParent );
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"InheritsFrom failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from InheritsFrom was: 0x%x", hr );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to inherit class %s from class %s in Namespace %s",wcsClass,wcsParent,wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetPropertyQualifierSetAndLogErrors( IWbemClassObject * pClass, IWbemQualifierSet ** pQualifierSet,const WCHAR * wcsProperty, 
                                 const WCHAR * wcsClass,
                                 WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Set who the class inherits from
	// =================================================================
    HRESULT hr = S_OK;
    *pQualifierSet = NULL;
    WCHAR * wcsProp = (WCHAR*) wcsProperty;

    hr = pClass->GetPropertyQualifierSet(CBSTR(wcsProp),pQualifierSet);
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"GetPropertyQualifierSet failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from GetPropertyQualifierSet was: 0x%x", hr );
            if( wcsProperty )
            {
                g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to get the qualifier set for property %s in class %s from class %s in Namespace %s",wcsProperty,wcsClass,wcsNamespace);
            }
            else
            {
                g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to get the qualifier set for class %s from class %s in Namespace %s",wcsClass,wcsNamespace);
            }
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int PutQualifierOnPropertyAndLogErrors( IWbemClassObject * pClass, const WCHAR * wcsProperty, const WCHAR * wcsQualifier, 
                                        VARIANT * Var, const WCHAR * wcsClass, DWORD dwFlags,
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Set who the class inherits from
	// =================================================================
    HRESULT hr = S_OK;
    IWbemQualifierSet * pQualifierSet = NULL;

    nRc = GetPropertyQualifierSetAndLogErrors( pClass, &pQualifierSet,wcsProperty,wcsClass,wcsNamespace,fExpectedFailure,csFile,Line );
    if( nRc == SUCCESS )
    {
        WCHAR * wcsQual = (WCHAR*)wcsQualifier;
       	hr = pQualifierSet->Put(CBSTR(wcsQual), Var, dwFlags);
        if( FAILED(hr))
        {
            nRc = FATAL_ERROR;
        }
    }
    SAFE_RELEASE_PTR(pQualifierSet);
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"QualifierSet->Put failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from Put was: 0x%x", hr );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to put qualifier %s on property %s in class %s in Namespace %s",wcsQualifier, wcsProperty,wcsClass,wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetClassQualifierSetAndLogErrors( IWbemClassObject * pClass, IWbemQualifierSet ** pQualifierSet, 
                                      const WCHAR * wcsClass,
                                      WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Set who the class inherits from
	// =================================================================
    HRESULT hr = S_OK;
    *pQualifierSet = NULL;

    hr = pClass->GetQualifierSet(pQualifierSet);
    if( FAILED(hr))
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"GetQualifierSet failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from GetQualifierSet was: 0x%x", hr );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to get the qualifier set for class %s in Namespace %s",wcsClass,wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int PutQualifierOnClassAndLogErrors( IWbemClassObject * pClass, const WCHAR * wcsQualifier, 
                                     VARIANT * Var, const WCHAR * wcsClass, DWORD dwFlags,
                                     WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Set who the class inherits from
	// =================================================================
    HRESULT hr = S_OK;
    IWbemQualifierSet * pQualifierSet = NULL;

    nRc = GetClassQualifierSetAndLogErrors( pClass, &pQualifierSet,wcsClass,wcsNamespace,fExpectedFailure,csFile,Line );
    if( nRc == SUCCESS )
    {
        WCHAR * wcsQual = (WCHAR*)wcsQualifier;
       	hr = pQualifierSet->Put(CBSTR(wcsQual), Var, dwFlags);
        if( FAILED(hr))
        {
            nRc = FATAL_ERROR;
        }
    }
    SAFE_RELEASE_PTR(pQualifierSet);
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"QualifierSet->Put failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from Put was: 0x%x", hr );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to put qualifier %s on class %s in Namespace %s",wcsQualifier, wcsClass,wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int EnumerateClassesAndLogErrors( IWbemServices * pNamespace, IEnumWbemClassObject ** pEnum, 
                                  WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Begin enumerating classes
	// =================================================================
    HRESULT hr = S_OK;

    hr = pNamespace->CreateClassEnum(NULL, WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,NULL,pEnum);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"CreateClassEnum failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from CreateClassEnum was: 0x%x", hr );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to Enumerate Classes in Namespace %s",wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int EnumerateInstancesAndLogErrors( IWbemServices * pNamespace, IEnumWbemClassObject ** pEnum, const WCHAR * wcsClassName,
                                    WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Begin enumerating classes
	// =================================================================
    HRESULT hr = S_OK;
    WCHAR * wcsClass = (WCHAR*)wcsClassName;
    
    hr = pNamespace->CreateInstanceEnum(CBSTR(wcsClass), WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,NULL,pEnum);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"CreateInstanceEnum failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from CreateInstanceEnum was: 0x%x", hr );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to Enumerate instances of class %s in Namespace %s",wcsClass, wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int NextClassAndLogErrors( IEnumWbemClassObject * pEnum, IWbemClassObject ** pClass,
                           WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Get the next class
	// =================================================================

    unsigned long u = 0;
    HRESULT hr = pEnum->Next(0,1,pClass,&u);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( hr == WBEM_S_FALSE )
    {
        nRc = NO_MORE_DATA;
    }
    if( nRc == FATAL_ERROR )
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Next failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from Next was: 0x%x", hr );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to get the next Class in Namespace %s",wcsNamespace);
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteClassAndLogErrors(IWbemServices * pNamespace, const WCHAR * wcsClassName,
                           WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Delete the class
	// =================================================================
    
    WCHAR * wcsClass = (WCHAR*)wcsClassName;

    HRESULT hr = pNamespace->DeleteClass(CBSTR(wcsClass),0,NULL,NULL);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Delete failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from Delete was: 0x%x", hr );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to delete Class %s in Namespace %s",wcsClass, wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteInstanceAndLogErrors(IWbemServices * pNamespace, const WCHAR * wcsInstanceName,
                               WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Delete the requested instance
	// =================================================================
    WCHAR * wcsInstance = (WCHAR*)wcsInstanceName;

    HRESULT hr = pNamespace->DeleteInstance(CBSTR(wcsInstance),0,NULL,NULL);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure )
        {
            nRc = FAILED_AS_EXPECTED;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"DeleteInstance failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from DeleteInstance was: 0x%x", hr );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to delete instance %s in Namespace %s",wcsInstance, wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int PutClassAndLogErrors(IWbemServices * pNamespace, IWbemClassObject * pClass, const WCHAR * wcsClass, 
                           WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    //  Set who the class inherits from
	// =================================================================
    HRESULT hr = pNamespace->PutClass(pClass,0,NULL,NULL);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure && ( hr == WBEM_E_CLASS_HAS_CHILDREN ))
        {
            nRc = SUCCESS;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"PutClass failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from PutClass was: 0x%x", hr );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to put class %s in Namespace %s",wcsClass, wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ExecQueryAndLogErrors(IWbemServices * pNamespace, IEnumWbemClassObject ** ppEnum, WCHAR * wcsQuery, DWORD dwFlags,
                           WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = SUCCESS;
 	// =================================================================
    // Execute the query
	// =================================================================
 
    HRESULT hr = pNamespace->ExecQuery(CBSTR(L"WQL"), CBSTR(wcsQuery),dwFlags,NULL,ppEnum);
    if( FAILED(hr))
    {
        nRc = FATAL_ERROR;
    }
    if( nRc != SUCCESS )
    {
        if( fExpectedFailure  )
        {
            nRc = SUCCESS;
        }
        else
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"ExecQuery failed." );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"HRESULT from ExecQuery was: 0x%x", hr );
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Attempting to query %s in Namespace %s",wcsQuery, wcsNamespace);
            nRc = FATAL_ERROR;
        }
    }
    return nRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\bvtapilib\bvtcom.h ===
/////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _BVT_COM_HEADER
#define _BVT_COM_HEADER

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Common functional units used among tests
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int OpenNamespaceAndKeepOpen      ( IWbemServices ** pNamespace, WCHAR * wcsNamespace, BOOL fCreateIfDoesntExist);
int CreateClassAndLogErrors       ( IWbemServices * pNamespace, const WCHAR * wcsClass, WCHAR * wcsClassDefinition,
                                    WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int DeleteClasses                 ( CAutoDeleteString & sDeleteClasses,IWbemServices * pNamespace, WCHAR * wcsNamespace);
int EnumerateInstancesAndCompare  ( IWbemServices * pNamespace, CAutoDeleteString & sInstanceList, 
                                    CAutoDeleteString & sInstanceCompareList, WCHAR * wcsNamespace );
int EnumerateClassesAndCompare    ( CAutoDeleteString & sClassesAfterDelete, IWbemServices * pNamespace, WCHAR * wcsNamespace);
int AddClasses                    ( CAutoDeleteString & sAddClasses, IWbemServices * pNamespace, WCHAR * wcsNamespace);
int DeleteAndAddClasses           ( CAutoDeleteString & sDeleteAddClasses, IWbemServices * pNamespace, WCHAR * wcsNamespace);
int CreateAssociationAndLogErrors ( IWbemServices * pNamespace, const WCHAR * wcsClass, WCHAR * wcsClassDefinition, WCHAR * wcsNamespace );
int CreateInstances               ( IWbemServices * pNamespace, CAutoDeleteString & sInstances, WCHAR * wcsNamespace, int nClassDefinitionSection );
int QueryAndCompareResults        ( IWbemServices * pNamespace, WCHAR * wcsQueryString, WCHAR * wcsNamespace );
int DeleteInstances               ( CAutoDeleteString & sDeleteInstances,IWbemServices * pNamespace, WCHAR * wcsNamespace);
int GetSpecificObjects            ( CAutoDeleteString & sObjects, IWbemServices * pNamespace, WCHAR * wcsNamespace);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\bvtapilib\bvtsink.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTSink.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "bvt.h"
#include <time.h>
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//
//  
//
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CSinkEx::QueryInterface( REFIID riid, LPVOID * ppvObj  )
{
    if (riid == IID_IUnknown)
    {
        *ppvObj = (IUnknown *)this;
    }
    else if (riid == IID_IWbemObjectSink)
	{
        *ppvObj = (IWbemObjectSink *)this;
	}
    else if (riid == IID_IWbemObjectSinkEx)
	{
		*ppvObj = (IWbemObjectSinkEx *)this;
	}
	else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ULONG CSinkEx::AddRef()
{
    return (ULONG)InterlockedIncrement(&m_lRefCount);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ULONG CSinkEx::Release()
{
    Lock();
    if(m_lRefCount <= 0) 
    {
        delete this;
        return 0;
    }

    if (InterlockedDecrement(&m_lRefCount))
    {
        Unlock();
        return 1;
    }

    Unlock();
    delete this;
    return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CSinkEx::Indicate(  long lObjectCount,  IWbemClassObject ** pObjArray  )
{
    if(lObjectCount == 0) 
        return WBEM_NO_ERROR;

    Lock();

    for (int i = 0; i < lObjectCount; i++)
    {
        IWbemClassObject *pObj = pObjArray[i];
        pObj->AddRef();
        m_aObjects.Add(pObj);
    }

    Unlock();
    return WBEM_NO_ERROR;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CSinkEx::Set( long lFlags,  REFIID riid,   void *pComObject)
{
	Lock();

	m_pInterfaceID=riid;
	m_pInterface=(IUnknown *)pComObject;

	Unlock();
	return WBEM_NO_ERROR;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSinkEx::SetStatus(long lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject* pObjParam)
{
    m_hres = hResult;
    if(lFlags & WBEM_STATUS_PROGRESS)
    {
        return WBEM_NO_ERROR;
    }
    m_pErrorObj = pObjParam;

    if(pObjParam)
        pObjParam->AddRef();

    SetEvent(m_hEvent);
    return WBEM_NO_ERROR;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CSinkEx::CSinkEx(LONG lStartingRefCount)
{
    InitializeCriticalSection(&m_cs);
    m_lRefCount = lStartingRefCount;
    m_hEvent = CreateEvent(0, FALSE, FALSE, 0);
    m_pErrorObj = NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CSinkEx::~CSinkEx()
{
    DeleteCriticalSection(&m_cs);
    CloseHandle(m_hEvent);

    for (int i = 0; i < m_aObjects.Size(); i++)
         ((IWbemClassObject *) m_aObjects[i])->Release();
    if(m_pErrorObj) m_pErrorObj->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\bvtapilib\bvtutil.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTUtil.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "bvt.h"
#include <time.h>
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//
//  The string class that automatically cleans up after itself
//
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CAutoDeleteString::CAutoDeleteString()
{
    m_pwcsString = NULL;
    m_fAllocated = FALSE;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CAutoDeleteString::~CAutoDeleteString()
{
    if( m_fAllocated )
    {
        SAFE_DELETE_ARRAY(m_pwcsString);
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CAutoDeleteString::SetPtr(WCHAR * wcs)
{
    if( m_pwcsString )
    {
        SAFE_DELETE_ARRAY(m_pwcsString);
    }
    m_pwcsString = wcs;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CAutoDeleteString::AddToString(const WCHAR * wcs)
{
    BOOL fRc = FALSE;

    if( m_pwcsString )
    {
        WCHAR * pNew = new WCHAR[wcslen(m_pwcsString)+2];

        if( pNew )
        {
            wcscpy( pNew,m_pwcsString);
            if( Allocate(wcslen(m_pwcsString)+wcslen(wcs)+4))
            {
                swprintf(m_pwcsString,L"%s /n:%s",wcs);
            }

            SAFE_DELETE_ARRAY(pNew);
        }
    }
    return fRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CAutoDeleteString::CopyString(const WCHAR * wcs)
{
    if( m_pwcsString )
    {
        wcsncpy( m_pwcsString, wcs, MAX_PATH);
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CAutoDeleteString::AllocAndCopy(const WCHAR * wcsSource)
{
    BOOL fRc = FALSE;

    m_fAllocated = TRUE;
    SAFE_DELETE_ARRAY(m_pwcsString);

    if( Allocate(wcslen(wcsSource)))
    {
        CopyString(wcsSource);
        fRc = TRUE;
    }
    return fRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CAutoDeleteString::Allocate(int nSize)
{
    m_fAllocated = TRUE;
    BOOL fRc = FALSE;
    //============================================
    //  Delete old info, in case of reallocation
    //============================================
    if( m_pwcsString )
    {
        SAFE_DELETE_ARRAY(m_pwcsString);
    }

    //============================================
    //  Allocate the string
    //============================================
    m_pwcsString = new WCHAR[nSize+2];
    if( m_pwcsString )
    {
        memset(m_pwcsString,NULL,nSize+2);
        fRc = TRUE;
    }
    return fRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
_CPropertyList::~_CPropertyList()
{  
    for( int i = 0; i < m_List.Size(); i++ )
    {
        PropertyInfo * pPtr = (PropertyInfo*)m_List[i];
        delete pPtr;
    }
    m_List.Empty();
 }
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
_ClassList::~_ClassList()
{  
    for( int i = 0; i < m_List.Size(); i++ )
    {
        ClassInfo * pPtr = (ClassInfo*)m_List[i];
        delete pPtr;
    }
    m_List.Empty();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int _ClassList::ClassesCompareAsExpectedAndLogErrors(WCHAR * wcsNamespace, 
                                                     BOOL fExpectedFailure, const char * csFile, const ULONG Line)
{
    int nRc = SUCCESS;

    for( int i = 0; i < m_List.Size(); i++ )
    {
        ClassInfo * pPtr = (ClassInfo*)m_List[i];
        if( !pPtr->fProcessed )
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Expected class not in namespace. Class %s in namespace %s",pPtr->Class, wcsNamespace);
            nRc = FATAL_ERROR;
            break;
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int _ClassList::ClassInListAndLogErrors(WCHAR * wcsClass, WCHAR * wcsNamespace, 
                            BOOL fExpectedFailure, const char * csFile, const ULONG Line)
{
    int nRc = FATAL_ERROR;
    BOOL fLogged = FALSE;

    for( int i = 0; i < m_List.Size(); i++ )
    {
        ClassInfo * pPtr = (ClassInfo*)m_List[i];
        if( _wcsicmp(pPtr->Class,wcsClass ) == 0 )
        {
            if( !pPtr->fProcessed )
            {
                nRc = SUCCESS;
                pPtr->fProcessed = TRUE;
            }
            else
            {
                if( !fExpectedFailure )
                {
                    g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Class showed up in the list twice.  Class %s in namespace %s", wcsClass, wcsNamespace);
                    fLogged = TRUE;
                }
            }
            break;
        }
    }

    if( nRc == FATAL_ERROR )
    {
        if( !fExpectedFailure )
        {
            if( !fLogged )
            {
                g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Did not find expected class %s in namespace %s", wcsClass, wcsNamespace);
            }
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//
//  The error logging and display class
//
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CLogAndDisplayOnScreen::CLogAndDisplayOnScreen()
{
    memset( m_wcsFileName,NULL,MAX_PATH+2);
    m_fDisplay = TRUE;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CLogAndDisplayOnScreen::~CLogAndDisplayOnScreen()
{

}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CLogAndDisplayOnScreen::WriteToFile(WCHAR * pwcsError, WCHAR * pwcsFileAndLine, const WCHAR *wcsString)
{
    BOOL fRc = FALSE;
    //===========================================
    // Get time.
    //===========================================
    WCHAR wcsTime[MAX_PATH];

    memset(wcsTime,NULL,MAX_PATH);

    time_t now = time(0);
    struct tm *local = localtime(&now);
    if(local)
    {
        wcscpy(wcsTime, _wasctime(local));
    }
    else
    {
        wcscpy(wcsTime,L"??");
    }

    //===========================================
    //  Open the file and log the error
    //===========================================
    FILE * fp = _wfopen( m_wcsFileName, L"at");
    if (fp)
    {
        fwprintf(fp, L"(%s) : %s - [%s]\n %s", wcsTime,pwcsError,pwcsFileAndLine, wcsString);
        fRc = TRUE;
        fclose(fp);
    }
    return fRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CLogAndDisplayOnScreen::LogError(const char * csFile , const ULONG Line , int nErrorType, const WCHAR *fmt, ...)
{
    BOOL fRc = FALSE;
    CAutoDeleteString Buffer;
    CAutoDeleteString FileAndLine;
    WCHAR * pwcsWarning = L"WARNING";
    WCHAR * pwcsFatal = L"FATAL";
    WCHAR * pwcsSuccess = L"SUCCESS";
    WCHAR * pwcsError = NULL;
    WCHAR * pwcsFile = NULL;

    CAutoBlock block(&m_CritSec);

    //==================================================
    //  First of all, allocate and format the strings 
    //  Get the type of error
    //==================================================
    if( nErrorType == FATAL_ERROR )
    {
        pwcsError = pwcsFatal;
    }
    else if( nErrorType == WARNING )
    {
        pwcsError = pwcsWarning;
    }
    else
    {
        pwcsError = pwcsSuccess;
    }

    if( S_OK == AllocateAndConvertAnsiToUnicode((char *)(const char*)csFile, pwcsFile))
    {
        if( FileAndLine.Allocate(wcslen(pwcsFile)+25))
        {
            WCHAR * pwcsFileAndLine = FileAndLine.GetPtr();
            //==============================================
            //  Create the filename and line number string
            //==============================================
            wsprintf(pwcsFileAndLine,L"File:%s,Line: %d",pwcsFile,Line);
            if( Buffer.Allocate(2048) )
            {
                va_list argptr;
                int cnt = 0;
                WCHAR * pwcsBuffer = Buffer.GetPtr();

                va_start(argptr, fmt);
                cnt = _vsnwprintf(pwcsBuffer, 2047, fmt, argptr);
                va_end(argptr);

                //==============================================
                //  a -1 indicates that the buffer was exceeded
                //==============================================
                if( cnt != -1 )
                {
                    //==========================================
                    //  Write it to the log file
                    //==========================================
                    fRc = WriteToFile(pwcsError, pwcsFileAndLine, pwcsBuffer);
                    //==========================================
                    //  Display it on the screen
                    //==========================================
                    wprintf(L"%s: %s\n",pwcsError,pwcsBuffer);
                }
            }
        }
    }

    if( !fRc )
    {
       wprintf(L"Major error, BVT cannot run\n");
    }

    SAFE_DELETE_ARRAY(pwcsFile);
    return fRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//
//  Misc. Functions
//
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT AllocateAndConvertAnsiToUnicode(char * pstr, WCHAR *& pszW)
{
    HRESULT hr = WBEM_E_FAILED;
    pszW = NULL;

    int nSize = strlen(pstr);
    if (nSize != 0 ){

        // Determine number of wide characters to be allocated for the
        // Unicode string.
        nSize++;
		pszW = new WCHAR[nSize * 2];
		if (NULL != pszW)
        {
            // Covert to Unicode.
			MultiByteToWideChar(CP_ACP, 0, pstr, nSize,pszW,nSize);
            hr = S_OK;
		}
    }
    return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ConvertType( CVARIANT & Var, long & lType, const WCHAR * wcsType, WCHAR * wcsValue )
{
    int nRc = SUCCESS;

    if (_wcsicmp(L"CIM_UINT8",wcsType) == 0 )
    {
        lType = CIM_UINT8;
        Var.SetByte((BYTE)_wtoi(wcsValue));  
    }
    else if (_wcsicmp(L"CIM_SINT8",wcsType) == 0 )
    {
        lType = CIM_SINT8;
        Var.SetByte((BYTE)_wtoi(wcsValue));  
    }
    else if( _wcsicmp(L"CIM_BOOLEAN",wcsType) == 0 )
    {   
        lType = CIM_BOOLEAN;
        Var.SetBool((SHORT)_wtoi(wcsValue));  
    }
    else if( _wcsicmp(L"CIM_CHAR16",wcsType) == 0 )
    {   
        lType = CIM_CHAR16;
        Var.SetShort((SHORT)_wtoi(wcsValue));  
    }
    else if( _wcsicmp(L"CIM_SINT16",wcsType) == 0 )
    {   
        lType = CIM_SINT16;
        Var.SetShort((SHORT)_wtoi(wcsValue));  
    }
    else if( _wcsicmp(L"CIM_UINT16",wcsType) == 0 )
    {   
        lType = CIM_UINT16;
        Var.SetShort((SHORT)_wtoi(wcsValue));  
    }
    else if( _wcsicmp(L"CIM_REAL32",wcsType) == 0 )
    {   
          lType = CIM_REAL32;

//        Var.SetLONG(_wtof(wcsValue));
    }
    else if( _wcsicmp(L"CIM_SINT32",wcsType) == 0 )
    {   
        lType = CIM_SINT32;
        Var.SetLONG(_wtol(wcsValue));
    }
    else if( _wcsicmp(L"CIM_UINT32",wcsType) == 0 )
    {   
        lType = CIM_UINT32;
        Var.SetLONG(_wtol(wcsValue));
    }
    else if( _wcsicmp(L"CIM_SINT64",wcsType) == 0 )
    {   
        lType = CIM_SINT64;
        Var.SetStr(wcsValue);
    }
    else if( _wcsicmp(L"CIM_UINT64",wcsType) == 0 )
    {   
        lType = CIM_UINT64;
        Var.SetStr(wcsValue);
    }
    else if( _wcsicmp(L"CIM_REAL64",wcsType) == 0 )
    {   
        lType = CIM_REAL64;
        Var.SetStr(wcsValue);
    }
    else if( _wcsicmp(L"CIM_DATETIME",wcsType) == 0 )
    {   
        lType = CIM_DATETIME;
        Var.SetStr(wcsValue);
    }
    else if( _wcsicmp(L"CIM_STRING",wcsType) == 0 )
    {   
        lType = CIM_STRING;
        Var.SetStr(wcsValue);
    }
    else if( _wcsicmp(L"CIM_REFERENCE",wcsType) == 0 )
    {   
        lType = CIM_REFERENCE;
        Var.SetStr(wcsValue);
    }
    else
    {
        nRc = FATAL_ERROR;
    }
        
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Format to crack:  
//  "Delete:TestClass2, Delete:TestClass9, Add:TestClass2, Delete: TestClass7, Delete: TestClass6"
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BOOL InitMasterListOfAddDeleteClasses(const WCHAR * wcsString,ClassList & MasterList)
{
    BOOL fRc = FALSE;
    WCHAR * wcsClassesAddDelete = (WCHAR*) wcsString;

    WCHAR * wcsToken = wcstok( wcsClassesAddDelete,L":, ");

    //==============================================================
    // Start looping through all of the classes
    //==============================================================
    while( wcsToken )
    {
        fRc = FALSE;

        ClassInfo *p = new ClassInfo;
        if( !p )
        {
            break;
        }
        //==========================================================
        //  If it is a class to be deleted
        //==========================================================
        if( _wcsicmp(L"Delete",wcsToken ) == 0 )
        {
            p->fAction = DELETE_CLASS;
        }
        else
        {
            p->fAction = ADD_CLASS;
        }
        wcsToken = wcstok( NULL, L":, ");         
        if( !wcsToken )
        {
            break;
        }
        p->Class = wcsToken;
        p->fProcessed = 0;

        MasterList.Add(p);
        fRc = TRUE;        

        wcsToken = wcstok( NULL, L",: ");         
    }

    return fRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Format to crack:  
//    { "TestClass1,TestClass3" },
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BOOL InitMasterListOfClasses(const WCHAR * wcsClassesString,ClassList & MasterList)
{
    BOOL fRc = FALSE;


    WCHAR * wcsClassesAfterDelete = (WCHAR*) wcsClassesString;
    WCHAR * wcsToken = wcstok( wcsClassesAfterDelete,L", ");

    //==============================================================
    // Start looping through all of the classes
    //==============================================================
    while( wcsToken )
    {
        fRc = FALSE;

        ClassInfo *p = new ClassInfo;
        if( !p )
        {
            break;
        }
        p->Class = wcsToken;
        p->fProcessed = 0;

        MasterList.Add(p);
        fRc = TRUE;        

        wcsToken = wcstok( NULL, L",: ");         
    }

    return fRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//   Property:FirstPoint:CIM_REFERENCE:Value, PropertyQualifier:CIMTYPE:CIM_STRING:ref:Test1, Property:EndPoint:CIM_REFERENCE:Value, PropertyQualifier:CIMTYPE:CIM_STRING:ref:Test2
//   PropertyQualifier:QualifierName:PropertyName:KeyName3:CIM_SINT32:3,      Property:PropertyName3:CIM_UINT32:3,   Property:PropertyName3B:CIM_STRING:Test" },
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CrackProperties( WCHAR * wcsToken, CPropertyList & Properties )
{
    int nRc = SUCCESS;
    WCHAR wcsSeps[] = L":, ";

    //==============================================================
    // Process all of the properties and qualifiers
    //==============================================================
    while( wcsToken )
    {
        nRc = FATAL_ERROR;

        PropertyInfo *p = new PropertyInfo;
        if( !p )
        {
            break;
        }

        //==========================================================
        //  Find out if it is a key     
        //==========================================================
        if( ( _wcsicmp(wcsToken, L"PropertyQualifier") == 0 ))
        {
            //==================================================
            //  If it is a qualifier, get the qualifier name
            //==================================================
            wcsToken = wcstok( NULL,wcsSeps);         
            if( !wcsToken )
            {
                break;
            }
            p->QualifierName = wcsToken;
        }

        wcsToken = wcstok( NULL,wcsSeps);         
        if( !wcsToken )
        {
            break;
        }
        //==========================================================
        //  Get the name of the property
        //==========================================================
        p->Property = wcsToken;
        wcsToken = wcstok( NULL,wcsSeps);         
        if( !wcsToken )
        {
            break;
        }
        //==========================================================
        //  Get the type of the property or qualifier
        //==========================================================
        WCHAR * wcsType = wcsToken;

        wcsToken = wcstok( NULL,L" ,");       //  note, now go to the next comma, as some string values may have embedded :  
        if( !wcsToken )
        {
            break;
        }

        //==========================================================
        //  Get the value
        //==========================================================
        nRc = ConvertType(p->Var, p->Type, wcsType, wcsToken );
        if( nRc == SUCCESS )
        {
            Properties.Add(p);
        }
        wcsToken = wcstok( NULL,wcsSeps);         

        if( nRc != SUCCESS )
        {
            break;
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Format to crack:  ( Note, there can be more than one key and more than one property )
//
//   "Property:FirstPoint:CIM_REFERENCE:Value, PropertyQualifier:CIMTYPE:CIM_STRING:ref:Test1, Property:EndPoint:CIM_REFERENCE:Value, PropertyQualifier:CIMTYPE:CIM_STRING:ref:Test2
//   "AssocProp1:Prop1:TestClass3, Prop2:AssocProp2:TestClass4" 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CrackAssociation( const WCHAR * wcsString, CPropertyList & Properties, BOOL fExpectedFailure, const char * csFile, const ULONG Line )
{
    int nRc = SUCCESS;
    WCHAR wcsSeps[] = L":, ";

    //=================================================================
    // Set it on the first property before looping
    //=================================================================
    WCHAR * wcsClassString = (WCHAR *)wcsString;
    WCHAR * wcsToken = wcstok( wcsClassString,wcsSeps);

    nRc = CrackProperties(wcsToken, Properties );

    if( nRc != SUCCESS )
    {
        if( !fExpectedFailure )
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Invalid ini entry, couldn't crack the association info for this string: %s", wcsClassString );
        }
    }

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Format to crack:  ( Note, there can be more than one key and more than one property )
//
// TestClass10= "Parent:TestClass9,Key:KeyName10:CIM_UINT32:10,    Property:PropertyName10:CIM_BOOLEAN:0"
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CrackClass(WCHAR * wcsInClassString, const WCHAR *& wcsParentClass, 
               CPropertyList & Properties, BOOL fExpectedFailure, const char * csFile, const ULONG Line )
{
    int nRc = FATAL_ERROR;

    WCHAR * wcsClassString = wcsInClassString;
    WCHAR * wcsSeps = L",: ";

    WCHAR * wcsToken = wcstok( wcsClassString,wcsSeps);

    if( ( _wcsicmp(wcsToken, L"Empty") == 0 ))
    {
        nRc = SUCCESS;
    }
    else
    {

        //==============================================================
        // Get the name of the Parent class, it will be the next one,
        // if we don't have a key or property next
        //==============================================================
        if( ( _wcsicmp(wcsToken, L"Parent") == 0 )) 
        {
            wcsToken = wcstok( NULL, wcsSeps);
            wcsParentClass = wcsToken;
            wcsToken = wcstok( NULL, wcsSeps);
        }

        nRc = CrackProperties(wcsToken, Properties );

    }

    if( nRc != SUCCESS )
    {
        if( !fExpectedFailure )
        {
            g_LogFile.LogError(csFile,Line,FATAL_ERROR, L"Invalid ini entry, couldn't crack class info for this string: %s", wcsClassString );
        }
    }

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void LogCLSID(const char * csFile, const ULONG Line, WCHAR * wcsID, CLSID clsid)
{
	LPOLESTR pStr = NULL;

	if (SUCCEEDED(StringFromCLSID (clsid, &pStr)))
	{
        WCHAR wcsBuffer[MAX_PATH];
        wsprintf(wcsBuffer,L"%s:%s",wcsID,pStr);
        g_LogFile.LogError(csFile,Line,FATAL_ERROR, wcsBuffer );
		CoTaskMemFree (pStr);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\bvtapilib\bvtcom.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTCOM.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "bvt.h"


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Common functional units used among tests
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int OpenNamespaceAndKeepOpen( IWbemServices ** ppNamespace, WCHAR * wcsNamespace, BOOL fCreateIfDoesntExist)
{
    //==========================================================================
    // Open CIMV2 namespace
    //==========================================================================
    int nRc = FATAL_ERROR;
    IWbemLocator    * pLocator      = NULL;

	// =====================================================================
    //  Get the locator
	// =====================================================================
    nRc = CoCreateInstanceAndLogErrors(CLSID_WbemLocator,IID_IWbemLocator,(void**)&pLocator,NO_ERRORS_EXPECTED);
    if( SUCCESS == nRc )
    {
	    // =================================================================
	    // Connect to the desired namespace
        // =================================================================
        nRc = ConnectServerAndLogErrors(pLocator,ppNamespace,wcsNamespace,NO_ERRORS_EXPECTED);
        if( (SUCCESS != nRc ) && ( fCreateIfDoesntExist ))
        {
            nRc = CreateNewTestNamespace();
            if( nRc == S_OK )
            {
                nRc = ConnectServerAndLogErrors(pLocator,ppNamespace,wcsNamespace,NO_ERRORS_EXPECTED);
            }
        }
    }
	// =====================================================================
    //  Release the pointers
	// =====================================================================
    SAFE_RELEASE_PTR(pLocator);

    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int WritePropertiesAndQualifiers( IWbemServices * pNamespace, IWbemClassObject * pClass, CPropertyList & Props, 
                                  const WCHAR * wcsClass, DWORD dwFlags,
                                  WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = FATAL_ERROR;

    if( Props.Size() == 0 )
    {
        nRc = SUCCESS;
    }

    for( int i = 0; i < Props.Size(); i++ )
    {                                
        //======================================================
        //  Get the property info
        //======================================================
        PropertyInfo *p = Props.GetAt(i); 
        if( !p )
        {
            break;
        }

        if( !p->QualifierName )
        {
            //======================================================
            //  Write out the property
            //======================================================
            nRc = PutPropertyAndLogErrors( pClass, p->Property, p->Type, p->Var, wcsClass, 0,wcsNamespace, fExpectedFailure, csFile , Line );
        }
        else
        {
            //======================================================
            //  If it is a qualifier, write the qualifier
            //======================================================
            nRc = PutQualifierOnPropertyAndLogErrors( pClass, p->Property, p->QualifierName ,p->Var, wcsClass, dwFlags, wcsNamespace, fExpectedFailure, csFile , Line );
        }
        if( nRc != SUCCESS )
        { 
            break;
        }
    }
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CreateClassAndLogErrors( IWbemServices * pNamespace, const WCHAR * wcsClass, WCHAR * wcsClassDefinition,
                             WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line )
{
    int nRc = FATAL_ERROR;
    IWbemClassObject *pClass = NULL;

    const WCHAR * wcsParentClass = NULL;  // nothing is allocated, so don't release
    CPropertyList Properties;       // destructor will release

    //===========================================================
    //  Get the class definition
    //===========================================================
    nRc = CrackClass(wcsClassDefinition,wcsParentClass, Properties, fExpectedFailure, csFile, Line );
    if( nRc == SUCCESS )
    {

        if( wcsParentClass )
        {
 	        // =================================================================
            //  Spawn a class from the parent
 	        // =================================================================
            IWbemClassObject * pParentClass = NULL;
            nRc = GetClassObjectAndLogErrors(pNamespace, wcsParentClass, &pParentClass, wcsNamespace, fExpectedFailure, csFile , Line );
            if( nRc == SUCCESS )
            {
                nRc = SpawnDerivedClassAndLogErrors(pParentClass, wcsParentClass, &pClass,wcsNamespace, fExpectedFailure, csFile , Line );
            }
        }
        else
        {
 	        // =================================================================
            //  Get an empty class object to work with
 	        // =================================================================
            nRc = GetClassObjectAndLogErrors(pNamespace, NULL, &pClass, wcsNamespace, fExpectedFailure, csFile , Line );
        }
        if( nRc == SUCCESS )
        {
            //==============================================================
            //  Now, set the properties of the class
            //  start with the name of the class
            //==============================================================
            CVARIANT var;
            var.SetStr((WCHAR*)wcsClass);

            nRc = PutPropertyAndLogErrors( pClass, L"__CLASS", CIM_STRING, var, wcsClass, 0,wcsNamespace, fExpectedFailure, csFile , Line );
            if( SUCCESS == nRc )
            {
                //==========================================================
                //  Set the rest of the properties
                //==========================================================
                DWORD dwFlags = 0;
                nRc = WritePropertiesAndQualifiers(pNamespace, pClass, Properties,wcsClass,dwFlags,wcsNamespace,NO_ERRORS_EXPECTED);
                //==============================================================
                //  Now, create the class
                //==============================================================
                if( SUCCESS == nRc )
                {
                    nRc = PutClassAndLogErrors(pNamespace, pClass,wcsClass,wcsNamespace, TRUE, csFile , Line );
                }
            }
        }
    }

    SAFE_RELEASE_PTR(pClass);
    return nRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteClasses(CAutoDeleteString & sDeleteClasses,IWbemServices * pNamespace, WCHAR * wcsNamespace)
{
    int nRc = FATAL_ERROR;

    ClassList MasterList;

    //=======================================================
    //  Get the list of the classes to be deleted
    //=======================================================
    if( InitMasterListOfClasses(sDeleteClasses.GetPtr(),MasterList))
    {

        for( int i = 0; i < MasterList.Size(); i++ )
        {
            ClassInfo * pClass = MasterList.GetAt(i);

            nRc = DeleteClassAndLogErrors(pNamespace, pClass->Class, wcsNamespace,NO_ERRORS_EXPECTED);
            if( nRc != SUCCESS )
            {
                break;
            }
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int EnumerateInstancesAndCompare( IWbemServices * pNamespace, CAutoDeleteString & sInstanceList, 
                                  CAutoDeleteString & sInstanceCompareList, WCHAR * wcsNamespace )
{
    int nRc = FATAL_ERROR;

    //=======================================================
    //  Get the list of the classes to get instances for
    //=======================================================
    ClassList InstanceList;

    if( InitMasterListOfClasses(sInstanceList.GetPtr(),InstanceList))
    {
        for( int i=0; i < InstanceList.Size(); i++ )
        {
            ClassInfo * p = InstanceList.GetAt(i);
            IEnumWbemClassObject * pEnum = NULL;
            
            //===========================================================
            //  Begin enumerating all of the requested instances
            //===========================================================
            nRc = EnumerateInstancesAndLogErrors(pNamespace,&pEnum,p->Class,wcsNamespace,NO_ERRORS_EXPECTED);
            if( nRc == S_OK )
            {
                //=======================================================
                //  Compare instances, if we were asked to do so
                //=======================================================
                if( sInstanceCompareList.GetPtr() )
                {
                    ClassList MasterList;
                    //===================================================
                    //  Get the list of the classes to compare with what 
                    //  is in the namespace
                    //===================================================
                    if( InitMasterListOfClasses(sInstanceCompareList.GetPtr(),MasterList))
                    {
                        //===================================================
                        //  while we get the instances
                        //===================================================
                        while( TRUE )
                        {
    	                    IWbemClassObject * pClass = NULL;
                            nRc = NextClassAndLogErrors(pEnum, &pClass,wcsNamespace,NO_ERRORS_EXPECTED);
                            if( nRc == NO_MORE_DATA )
                            {
                                nRc = SUCCESS;
                                break;
                            }
                            if( nRc != SUCCESS )
                            { 
                                break;
                            }
                            CVARIANT vProperty;
                            CIMTYPE pType = 0;
                            LONG    lFlavor = 0;
                            //===================================================
                            //  Get the name of the class
                            //===================================================
                            nRc = GetPropertyAndLogErrors( pClass, L"__CLASS", &vProperty, &pType, &lFlavor, NULL,wcsNamespace, NO_ERRORS_EXPECTED);
                            if( nRc == S_OK )
                            {
                                //===============================================
                                //  Compare the class name with what we expect
                                //  and make sure we haven't already compared it
                                //  before, if it isn't in the list, then error
                                //  out, we have a big problem
                                //===============================================
                                if( !MasterList.ClassInListAndLogErrors(vProperty.GetStr(),wcsNamespace,NO_ERRORS_EXPECTED))
                                {
                                    break;
                                }
                            }
                        }
                        if( nRc == SUCCESS )
                        {
                            //====================================================
                            //  Go through the master list and see if there are
                            //  any classes we expect to be there but we didn't
                            //  get during the enumeration
                            //====================================================
                            nRc = MasterList.ClassesCompareAsExpectedAndLogErrors(wcsNamespace,NO_ERRORS_EXPECTED);
                        }
                    }
                }
            }
            SAFE_RELEASE_PTR(pEnum);
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int EnumerateClassesAndCompare(CAutoDeleteString & sClassesAfterDelete, IWbemServices * pNamespace, WCHAR * wcsNamespace)
{
    IEnumWbemClassObject * pEnum = NULL;
    int nRc = FATAL_ERROR;

    //===========================================================
    //  Begin enumerating all of the classes in the namespace
    //===========================================================
    nRc = EnumerateClassesAndLogErrors(pNamespace,&pEnum, wcsNamespace,NO_ERRORS_EXPECTED);
    if( nRc == S_OK )
    {
        ClassList MasterList;

        //=======================================================
        //  Get the list of the classes to compare with what is
        //  in the namespace
        //=======================================================
        if( InitMasterListOfClasses(sClassesAfterDelete.GetPtr(),MasterList))
        {
            //===================================================
            //  while we get the classes in the namespace
            //===================================================
            while( TRUE )
            {
    	        IWbemClassObject * pClass = NULL;
                nRc = NextClassAndLogErrors(pEnum, &pClass,wcsNamespace,NO_ERRORS_EXPECTED);
                if( nRc == NO_MORE_DATA )
                {
                    nRc = SUCCESS;
                    break;
                }
                if( nRc != SUCCESS )
                { 
                    break;
                }
                CVARIANT vProperty;
                CIMTYPE pType = 0;
                LONG    lFlavor = 0;
                //===================================================
                //  Get the name of the class
                //===================================================
                nRc = GetPropertyAndLogErrors( pClass, L"__CLASS", &vProperty, &pType, &lFlavor, NULL,wcsNamespace, NO_ERRORS_EXPECTED);
                if( nRc == S_OK )
                {
                    //===============================================
                    //  filter out system classes
                    //===============================================
                    if( wcsncmp( vProperty.GetStr(), L"__", 2 ) != 0 )
                    {
                        //===============================================
                        //  Compare the class name with what we expect
                        //  and make sure we haven't already compared it
                        //  before, if it isn't in the list, then error
                        //  out, we have a big problem
                        //===============================================
                        nRc = MasterList.ClassInListAndLogErrors(vProperty.GetStr(),wcsNamespace,NO_ERRORS_EXPECTED);
                        if( nRc != SUCCESS )
                        {
                            break;
                        }
                    }
                }
            }
        }
        if( nRc == SUCCESS )
        {
            //====================================================
            //  Go through the master list and see if there are
            //  any classes we expect to be there but we didn't
            //  get during the enumeration
            //====================================================
            nRc = MasterList.ClassesCompareAsExpectedAndLogErrors(wcsNamespace,NO_ERRORS_EXPECTED);
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int AddClasses(CAutoDeleteString & sAddClasses, IWbemServices * pNamespace, WCHAR * wcsNamespace)
{
    int nRc = FATAL_ERROR;

    ClassList MasterList;

    //=======================================================
    //  Get the list of the classes to be deleted
    //=======================================================
    if( InitMasterListOfClasses(sAddClasses.GetPtr(),MasterList))
    {
        for( int i = 0; i < MasterList.Size(); i++ )
        {
            ClassInfo * pClass = MasterList.GetAt(i);
            CAutoDeleteString sClassDefinition;

            if( g_Options.GetSpecificOptionForAPITest( pClass->Class, sClassDefinition,APITEST5))
            {
                nRc = CreateClassAndLogErrors(pNamespace, pClass->Class, sClassDefinition.GetPtr(), wcsNamespace,NO_ERRORS_EXPECTED);
                if( nRc != SUCCESS )
                {
                    break;
                }
            }
        }
    }
    return nRc;

}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteAndAddClasses(CAutoDeleteString & sDeleteAddClasses, IWbemServices * pNamespace, WCHAR * wcsNamespace)
{
    int nRc = FATAL_ERROR;

    ClassList MasterList;

    //=======================================================
    //  Get the list of the classes to be added & deleted
    //=======================================================
    if( InitMasterListOfAddDeleteClasses(sDeleteAddClasses.GetPtr(),MasterList))
    {

        for( int i = 0; i < MasterList.Size(); i++ )
        {
            ClassInfo * pClass = MasterList.GetAt(i);
            if( pClass->fAction == DELETE_CLASS )
            {
                nRc = DeleteClassAndLogErrors(pNamespace, pClass->Class, wcsNamespace,NO_ERRORS_EXPECTED);
                if( nRc != SUCCESS )
                {
                    break;
                }
            }
            else
            {
                ClassInfo * pClass = MasterList.GetAt(i);
                CAutoDeleteString sClassDefinition;

                if( g_Options.GetSpecificOptionForAPITest( pClass->Class, sClassDefinition, APITEST5))
                {
                    nRc = CreateClassAndLogErrors(pNamespace, pClass->Class, sClassDefinition.GetPtr(), wcsNamespace,NO_ERRORS_EXPECTED);
                    if( nRc != SUCCESS )
                    {
                        break;
                    }
                }
            }
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetSpecificObjects(CAutoDeleteString & sObjects, IWbemServices * pNamespace, WCHAR * wcsNamespace)
{
    int nRc = FATAL_ERROR;

    ClassList MasterList;

    //=======================================================
    //  Get the list of the classes to be deleted
    //=======================================================
    if( InitMasterListOfClasses(sObjects.GetPtr(),MasterList))
    {
        for( int i = 0; i < MasterList.Size(); i++ )
        {
            ClassInfo * pClassInfo    = MasterList.GetAt(i);
            IWbemClassObject * pClass = NULL;

            nRc = GetClassObjectAndLogErrors(pNamespace, pClassInfo->Class, &pClass, wcsNamespace,NO_ERRORS_EXPECTED);
            if( nRc != SUCCESS )
            {
                break;
            }
            SAFE_RELEASE_PTR(pClass);
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CreateInstances(IWbemServices * pNamespace, CAutoDeleteString & sInstances, WCHAR * wcsNamespace, int nClassDefinitionSection )
{

    int nRc = FATAL_ERROR;

    ClassList MasterList;

    //=======================================================
    //  Get the list of the instances to be created
    //=======================================================
    if( InitMasterListOfClasses(sInstances.GetPtr(),MasterList))
    {
        IWbemClassObject * pClass = NULL;
  		IWbemClassObject *pInst   = NULL;

        for( int i = 0; i < MasterList.Size(); i++ )
        {
            CAutoDeleteString sClassInformation;

            ClassInfo * pClassInfo    = MasterList.GetAt(i);

            if( g_Options.GetSpecificOptionForAPITest(pClassInfo->Class,sClassInformation,nClassDefinitionSection) )
            {
                const WCHAR * wcsTmpParentClass = NULL;  // nothing is allocated, so don't release
                CPropertyList Properties;       // destructor will release

                //===========================================================
                //  Get the class definition
                //===========================================================
                nRc = CrackClass(sClassInformation.GetPtr(),wcsTmpParentClass, Properties, NO_ERRORS_EXPECTED);
                if( SUCCESS == nRc )
                {
                    //==============================================================
                    //  Get the class definition 
                    //==============================================================
                    nRc = GetClassObjectAndLogErrors(pNamespace,pClassInfo->Class,&pClass,wcsNamespace, NO_ERRORS_EXPECTED);
                    if( SUCCESS != nRc )
                    {
                        break;
                    }

                    //==============================================================
                    // Spawn a new instance of this class.
                    //==============================================================
                    nRc = SpawnInstanceAndLogErrors(pClass,pClassInfo->Class,&pInst,wcsNamespace,NO_ERRORS_EXPECTED);
                    if( SUCCESS != nRc )
                    {
                        break;
                    }
                    //==========================================================
		            // Set the Properties
                    //==========================================================

                    DWORD dwFlags = 0;
                    nRc = WritePropertiesAndQualifiers(pNamespace, pClass, Properties,pClassInfo->Class,dwFlags,wcsNamespace,NO_ERRORS_EXPECTED);
                    if( SUCCESS != nRc )
                    {
                        break;
                    }

                    //==========================================================
                    // Create the new instance
                    //==========================================================

                    nRc = PutInstanceAndLogErrors(pNamespace, pInst,pClassInfo->Class,wcsNamespace,NO_ERRORS_EXPECTED);
                    if( SUCCESS != nRc )
                    {
                        break;
                    }
                    SAFE_RELEASE_PTR(pInst);
                    SAFE_RELEASE_PTR(pClass);
                }
            }
        }
        SAFE_RELEASE_PTR(pInst);
        SAFE_RELEASE_PTR(pClass);

    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DeleteInstances(CAutoDeleteString & sDeleteInstances,IWbemServices * pNamespace, WCHAR * wcsNamespace)
{
    int nRc = FATAL_ERROR;

    ClassList MasterList;

    //=======================================================
    //  Get the list of the instances to be deleted
    //=======================================================
    if( InitMasterListOfClasses(sDeleteInstances.GetPtr(),MasterList))
    {
        for( int i = 0; i < MasterList.Size(); i++ )
        {
            ClassInfo * pClass = MasterList.GetAt(i);

            nRc = DeleteInstanceAndLogErrors(pNamespace, pClass->Class, wcsNamespace,NO_ERRORS_EXPECTED);
            if( nRc != SUCCESS )
            {
                break;
            }
        }
    }
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CreateAssociationAndLogErrors(  IWbemServices * pNamespace, const WCHAR * wcsClass, WCHAR * wcsClassDefinition,
                                    WCHAR * wcsNamespace )
{
    IWbemClassObject *pClass = NULL;
    const WCHAR * wcsClass1 = NULL;  // nothing is allocated, so don't release
    const WCHAR * wcsClass2 = NULL;  // nothing is allocated, so don't release

    //===========================================================
    //  Get the association definition
    //===========================================================
    CPropertyList Props;

    int nRc = CrackAssociation( wcsClassDefinition, Props, NO_ERRORS_EXPECTED);
    if( nRc == SUCCESS )
    {
 	    // =================================================================
        //  Get an empty class object to work with
 	    // =================================================================
        nRc = GetClassObjectAndLogErrors(pNamespace, NULL, &pClass, wcsNamespace, NO_ERRORS_EXPECTED);
        if( nRc == SUCCESS )
        {
            //==============================================================
            //  Write out the name of the association
            //==============================================================
            DWORD dwFlags = WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
            CVARIANT v;
            v.SetStr((WCHAR*)wcsClass);

            nRc = PutPropertyAndLogErrors( pClass, L"__CLASS",CIM_STRING, v, wcsClass, dwFlags, wcsNamespace, NO_ERRORS_EXPECTED);
            if( nRc == SUCCESS )
            { 
                //==========================================================
                //  Make the class an association
                //==========================================================
                CVARIANT Var;
                Var.SetBool(TRUE);
  
                nRc = PutQualifierOnClassAndLogErrors( pClass, L"Association",&Var, wcsClass,dwFlags, wcsNamespace, NO_ERRORS_EXPECTED);
                if( nRc == SUCCESS )
                { 
                    //======================================================
                    //  Now, create the association endpoints
                    //======================================================
                    nRc = WritePropertiesAndQualifiers(pNamespace, pClass, Props,wcsClass,dwFlags,wcsNamespace,NO_ERRORS_EXPECTED);
                    if( SUCCESS == nRc )
                    {
                        //==============================================================
                        //  Now, create the association class
                        //==============================================================
                        nRc = PutClassAndLogErrors(pNamespace, pClass,wcsClass,wcsNamespace, NO_ERRORS_EXPECTED);

                    }
                }
            }
        }
    }
    SAFE_RELEASE_PTR(pClass);
    return nRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int QueryAndCompareResults( IWbemServices * pNamespace, WCHAR * wcsQuery, WCHAR * wcsNamespace )
{
    IEnumWbemClassObject * pEnum = NULL;

    DWORD dwFlags = WBEM_FLAG_FORWARD_ONLY;
    int nRc = ExecQueryAndLogErrors( pNamespace,&pEnum, wcsQuery, dwFlags, wcsNamespace,NO_ERRORS_EXPECTED);

    SAFE_RELEASE_PTR(pEnum);
    return nRc; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\bvtapilib\bvtutil.h ===
/////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _BVT_UTIL_HEADER
#define _BVT_UTIL_HEADER



/////////////////////////////////////////////////////////////////////////////////////////////
//*******************************************************************************************
//
//  Class definitions & prototypes
//
//*******************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////
HRESULT AllocateAndConvertAnsiToUnicode(char * pstr, WCHAR *& pszW);
int ExecuteScript( int nTest);
void LogCLSID(const char * csFile, const ULONG Line, WCHAR * wcsID, CLSID clsid);

BOOL InitMasterListOfClasses          ( const WCHAR * wcsClassesAfterDelete,ClassList & MasterList);
BOOL InitMasterListOfAddDeleteClasses ( const WCHAR * wcsClassesAddDelete,ClassList & MasterList);
int CrackAssociation                  ( const WCHAR * wcsClassString, CPropertyList & Properties, BOOL fExpectedFailure, const char * csFile, const ULONG Line );
int CrackClass                        ( WCHAR * wcsClassString,const WCHAR *& wcsParentClass, 
                                        CPropertyList & Properties, BOOL fExpectedFailure, const char * csFile, const ULONG Line );

/////////////////////////////////////////////////////////////////////////////////////////////
class CAutoDeleteString
{
    private:
        WCHAR               * m_pwcsString;
        BOOL m_fAllocated;
        void CopyString(const WCHAR * wcs);
    public:
        CAutoDeleteString();
        ~CAutoDeleteString();

        BOOL Allocate(int nSize);
        void SetPtr(WCHAR * wcs);
        BOOL AllocAndCopy(const WCHAR * wcsSource);
        BOOL AddToString(const WCHAR * wcs);


        inline WCHAR * GetPtr()     { return m_pwcsString; }
};
/////////////////////////////////////////////////////////////////////////////////////////////
class CLogAndDisplayOnScreen
{
    private:
        WCHAR              m_wcsFileName[MAX_PATH+2];
        BOOL               m_fDisplay;
        CCriticalSection   m_CritSec;

        BOOL WriteToFile(WCHAR * pwcsError, WCHAR * pwcsFileAndLine, const WCHAR *wcsString);

    public:
        CLogAndDisplayOnScreen();
        ~CLogAndDisplayOnScreen();
        
        BOOL LogError(const char * csFile , const ULONG Line , int nErrorType, const WCHAR *fmt, ...);


        inline void SetDisplay(BOOL fDisplay)       { CAutoBlock Block(&m_CritSec); m_fDisplay = fDisplay;}
        inline void SetFileName(WCHAR * wcsFile  )  { CAutoBlock Block(&m_CritSec); wcsncpy( m_wcsFileName, wcsFile, MAX_PATH); }
};
/////////////////////////////////////////////////////////////////////////////////////////////
class CIniFileAndGlobalOptions
{
    private:
        WCHAR              m_wcsFileName[MAX_PATH+2];
        CCriticalSection   m_CritSec;
        CFlexArray         m_SpecificTests;
        BOOL               m_fSpecificTests;

        BOOL ReadIniFile( WCHAR * wcsSection, const WCHAR * wcsKey, WCHAR * wcsDefault, CAutoDeleteString & sBuffer, DWORD dwLen);
        void DeleteList();
        
    public:

        CIniFileAndGlobalOptions();
        ~CIniFileAndGlobalOptions();

        BOOL GetOptionsForAPITest(CAutoDeleteString & sNamespace, int nTest);
        BOOL GetOptionsForAPITest(CAutoDeleteString & sNamespace, CAutoDeleteString & sClass, int nTest);
        BOOL GetOptionsForAPITest(CAutoDeleteString * psClasses, int nHowMany, int nTest );
        BOOL GetOptionsForAPITest(CAutoDeleteString & sDeleteClasses, CAutoDeleteString & sClassesAfterDelete, 
                                  CAutoDeleteString & sAddClasses,    CAutoDeleteString & sClassesAfterAdd, 
                                  CAutoDeleteString & sDeleteAddClassOrder, CAutoDeleteString & sClassesAfterDeleteAdd );
        BOOL GetOptionsForAPITest(CAutoDeleteString & sRegularQuery, CAutoDeleteString & sAssociatorsQuery, 
                                                    CAutoDeleteString & sReferenceQuery,int nTest );
        BOOL GetSpecificOptionForAPITest(const WCHAR * wcsClass, CAutoDeleteString & sClass, int nTest);


        BOOL GetOptionsForScriptingTests(CAutoDeleteString & sScript, CAutoDeleteString & sNamespace, int nTest);

        void WriteDefaultIniFile();

        inline void AddToSpecificTestList(int nTest)        { int * p = new int; *p = nTest; m_SpecificTests.Add(p); }
        inline int  SpecificTestSize()                      { return m_SpecificTests.Size(); }
        inline int  GetSpecificTest(int n)                  { int * p = (int*) m_SpecificTests.GetAt(n); return *p;}
        inline void SpecificTests(BOOL f)                   { m_fSpecificTests = f;}
        inline BOOL RunSpecificTests()                      { return m_fSpecificTests;}

        inline void SetFileName(WCHAR * wcsFile  )          { CAutoBlock Block(&m_CritSec); wcsncpy( m_wcsFileName, wcsFile, MAX_PATH); }

};

class CSinkEx : public IWbemObjectSinkEx
{
    CFlexArray m_aObjects;
    LONG m_lRefCount;
    CRITICAL_SECTION m_cs;
    HANDLE m_hEvent;
    HRESULT m_hres;
    IWbemClassObject* m_pErrorObj;
	IID m_pInterfaceID;
	IUnknown *m_pInterface;

public:
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, HRESULT hResult, BSTR strParam,   IWbemClassObject* pObjPAram);

	STDMETHOD(Set)(long lFlags, REFIID riid, void *pComObject);

    // Private to implementation.
    // ==========================

    CSinkEx(LONG lStartingRefCount = 1);
   ~CSinkEx();

    UINT WaitForSignal(DWORD dwMSec)    { return ::WbemWaitForSingleObject(m_hEvent, dwMSec); }
    CFlexArray* GetObjectArray()        { return &m_aObjects; }
	IUnknown *GetInterface()            { return m_pInterface; }
    HRESULT GetStatusCode(IWbemClassObject** ppErrorObj = NULL)
    {
        if(ppErrorObj) 
        {
            *ppErrorObj = m_pErrorObj;
            if(m_pErrorObj) m_pErrorObj->AddRef();
        }
        return m_hres;
    }

    void Lock() { EnterCriticalSection(&m_cs); }
    void Unlock() { LeaveCriticalSection(&m_cs); }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\bvtapilib\bvtini.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTUtil.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "bvt.h"
#include <time.h>
#define BVTVALUE 1024
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//
//  The Ini file class
//
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CIniFileAndGlobalOptions::CIniFileAndGlobalOptions()
{
    memset( m_wcsFileName,NULL,MAX_PATH+2);
    m_fSpecificTests = FALSE;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CIniFileAndGlobalOptions::~CIniFileAndGlobalOptions()
{
    DeleteList();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CIniFileAndGlobalOptions::DeleteList()
{    
    CAutoBlock Block(&m_CritSec);
    for( int i = 0; i < m_SpecificTests.Size(); i++ )
    {
        int * pPtr = (int*)m_SpecificTests[i];
        delete pPtr;
    }
    m_SpecificTests.Empty();

}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CIniFileAndGlobalOptions::ReadIniFile( WCHAR * wcsSection, const WCHAR * wcsKey, WCHAR * wcsDefault, 
                                            CAutoDeleteString & sBuffer, DWORD dwLen)
{
    BOOL fRc = FALSE;

    while (sBuffer.Allocate(dwLen))
    {
        DWORD dwRc = GetPrivateProfileString(wcsSection, wcsKey, wcsDefault, sBuffer.GetPtr(), dwLen, m_wcsFileName);
        if (dwRc == 0)
        {
            fRc = FALSE;
        } 
        else if (dwRc < dwLen - sizeof(WCHAR))
        {
            fRc = TRUE;
            break;
        }
        dwLen += BVTVALUE;
    }
    return fRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//  Documentation arrays
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IniInfo g_Doc1[] = {  
    { L"Description", L"Basic connect using IWbemLocator"},
    { L"FYI",         L"NAMESPACE is the Namespace the BVT will use"} };

IniInfo g_Doc2[] = {
    { L"Description", L"Basic connect using IWbemConnection for IWbemServices, IWbemServicesEx, IWbemClassObject"},
    { L"FYI", L"NAMESPACE is the Namespace the BVT will use. CLASS is the class used to create the namespace" }};

IniInfo g_Doc3[] = {
    { L"Description", L"Basic async connect using IWbemConnection for IWbemServices, IWbemServicesEx, IWbemClassObject"},
    { L"FYI", L"NAMESPACE is the Namespace the BVT will use. CLASS is the class used to create the namespace" }};

IniInfo g_Doc4[] = {
    { L"Description", L"Creation of a test namespace"},
    { L"FYI",         L"NAMESPACE is the Namespace the BVT will create" }};

IniInfo g_Doc5[] = {
    {L"Description", L"Creates test classes in the test namespace"},
    {L"FYI",            L"Classes = the list of comma separated class names, all of these classes should exist in this section as defined in the FYI_Format entry below" },
    {L"FYI_Format",     L"Classes are defined in this format: ClassName = Parent:XClass, Key:TmpKey:CIM_SINT32:3, Property:PropertyName3:CIM_UINT32:3" },
    {L"FYI_Class",      L"Using format as defined in FYI_Format, ClassName is the actual name of the class to be created" },
    {L"FYI_InHeritance",L"Using format as defined in FYI_Format, Parent:XClass where Parent means this entity describes the inheritance of the class. XClass is the name of the ParentClass." },
    {L"FYI_Qualifier",  L"Doc this" },
    {L"FYI_Property",   L"Using format as defined in FYI_Format, Property:PropName:CIM_UINT32:5 where Property means this entity describes the Property.  PropName is the name of the Property.  CIM_UINT32 is the type and 5 is the value." },
    {L"FYI_Comments",   L"Classes may contain more than one qualifier and more than one property.  These must be comma separated and identified as described." }};

IniInfo g_Doc6[] = {
    {L"Description", L"Deletes and Creates the classes as defined in test 5 in the requested order."},
    {L"FYI_Delete_Classes",           L"First,  Classes will be deleted as specified by the ini entry DELETE_CLASSES" },
    {L"FYI_Classes_After_Delete",     L"Second, Classes will then be compared to what is expected to be left, by looking at the values in the ini entry CLASSES_AFTER_DELETE" },
    {L"FYI_Add_Classes",              L"Third,  Classes to be added are then specified by the ini entry ADD_CLASSES" },
    {L"FYI_Classes_After_Add",        L"Fourth, Classes will then be compared to what is expected to be left, by looking at the values in the ini entry CLASSES_AFTER_ADD" },
    {L"FYI_Classes_Add_Delete_Order", L"Fifth,  Classes to be deleted and added in specified order DELETE_ADD_CLASS_ORDER" },
    {L"FYI_Classes_After_Delete_Add", L"Sixth,  Classes will then be compared to what is expected to be left, by looking at the values in the ini entry CLASSES_AFTER_DELETE_ADD" },
    {L"FYI_Comments",   L"All of these entries, with the exception of DELETE_ADD_CLASS_ORDER are comma separated class names. See FYI_FORMAT for DELETE_ADD_CLASS_ORDER format" },
    {L"FYI_FORMAT",     L"DELETE_ADD_CLASS_ORDER format: 'Delete:Class1, Add:Class2, Add:Class3'  where Delete means to delete the following class, and Add to add the following class, this may be in any order." }};

IniInfo g_Doc7[] = {{L"Description",L"Creates simple associations"},
                    {L"FYI",  L"ASSOCIATION_CLASSES is a comma separated list of associations to create.  These must exist in this section.  See FYI_Format to see how to create an association" },
                    {L"FYI_Format",   L"Example: Property:FirstPoint:TestClass1:Reference:REF:TestClass1, Property:SecondPoint:TestClass2:REF:TestClass2" },
                    {L"FYI_Property", L"Using format as defined in FYI_Format, Property:FirstPoint:TestClass1:REF:TestClass1 where Property means this entity describes the Property. FirstPoint is the name of first Key, TestClass1 is that key's value, Reference creates a strongly typed reference as defined in REF:TestClass1." },
                    {L"FYI_Comments", L"REF is optional" }};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
IniInfo g_Test1[] = {L"NAMESPACE",L"ROOT\\DEFAULT" };

IniInfo g_Test2[] = { { L"NAMESPACE",L"ROOT\\DEFAULT" },
                      { L"CLASS"    ,L"__NAMESPACE" } };

IniInfo g_Test3[] = { { L"NAMESPACE",L"ROOT\\DEFAULT" },
                      { L"CLASS"    ,L"__NAMESPACE" } };

IniInfo g_Test4[] = {{L"NAMESPACE",L"ROOT\\BVTAPITEST" },
                    {L"PARENT_NAMESPACE",L"ROOT"},
                    {L"Classes", L"__NAMESPACE"},
                    {L"__NAMESPACE", L"Property:Name:CIM_STRING:BVTAPITEST" }};

IniInfo g_Test5[] = {
    { L"Classes",     L"TestClass1,TestClass2,TestClass3,TestClass4,TestClass5,TestClass6,TestClass7,TestClass8,TestClass9,TestClass10" },
    { L"TestClass1",  L"Empty" }, // an abstract class, so 4 and 5 can define additional keys
    { L"TestClass2",  L"Property:LaKey1:CIM_STRING:Key1, PropertyQualifier:KEY:LaKey1:CIM_BOOLEAN:1,    Property:LaKey2:CIM_STRING:Key2, PropertyQualifier:Key:LaKey2:CIM_BOOLEAN:1," },
    { L"TestClass3",  L"Property:KeyName1:CIM_SINT32:3,  PropertyQualifier:KEY:KeyName1:CIM_BOOLEAN:1,  Property:PropertyName3:CIM_UINT32:3,   Property:PropertyName3B:CIM_STRING:Test" },
    { L"TestClass4",  L"Parent:TestClass1,  Property:KeyName4:CIM_UINT32:4,    PropertyQualifier:KEY:KeyName4:CIM_BOOLEAN:1, Property:PropertyName4:CIM_BOOLEAN:0" },
    { L"TestClass5",  L"Parent:TestClass1,  Property:KeyName5:CIM_STRING:Temp, PropertyQualifier:KEY:KeyName5:CIM_BOOLEAN:1, Property:PropertyName5:CIM_STRING:Value5" },
    { L"TestClass6",  L"Parent:TestClass5,  Property:PropertyName6:CIM_STRING:Value6" },    // no additional key can be defined
    { L"TestClass7",  L"Parent:TestClass6,  Property:PropertyName7:CIM_BOOLEAN:1" },        // no additional key can be defined
    { L"TestClass8",  L"Parent:TestClass7,  Property:PropertyName8:CIM_SINT32:2" },        // no additional key can be defined
    { L"TestClass9",  L"Parent:TestClass8,  Property:PropertyName9:CIM_STRING:Value9" },    // no additional key can be defined
    { L"TestClass10", L"Parent:TestClass9,  Property:PropertyName10:CIM_BOOLEAN:0" } };     // no additional key can be defined

IniInfo g_Test6[] = {
    { L"DELETE_CLASSES",            L"TestClass1,TestClass3" },
    { L"CLASSES_AFTER_DELETE",      L"TestClass2" },
    { L"ADD_CLASSES",               L"TestClass1,TestClass3,TestClass4,TestClass5,TestClass6,TestClass7, TestClass8, TestClass9, TestClass10" },
    { L"CLASSES_AFTER_ADD",         L"TestClass1,TestClass2,TestClass3,TestClass4,TestClass5,TestClass6,TestClass7, TestClass8, TestClass9, TestClass10" },
    { L"DELETE_ADD_CLASS_ORDER",    L"Delete:TestClass2, Delete:TestClass9, Add:TestClass2, Delete: TestClass7, Delete: TestClass6" },
    { L"CLASSES_AFTER_DELETE_ADD",  L"TestClass1,TestClass2,TestClass3,TestClass4,TestClass5" }};


IniInfo g_Test7[] = {
    { L"ASSOCIATION_CLASSES", L"Association1, Association2" },
    { L"Association1",  L"Property:FirstPoint:CIM_REFERENCE:Value,   PropertyQualifier:KEY:FirstPoint:CIM_BOOLEAN:1, PropertyQualifier:CIMTYPE:FirstPoint:CIM_STRING:ref:Test1,Property:EndPoint:CIM_REFERENCE:Value, PropertyQualifier:CIMTYPE:EndPoint:CIM_STRING:ref:Test2, PropertyQualifier:Key:EndPoint:CIM_BOOLEAN:1" },
    { L"Association2",  L"Property:AssocProp1:CIM_STRING:TestClass3, PropertyQualifier:Key:AssocProp1:CIM_BOOLEAN:1, Property:AssocProp2:CIM_STRING:TestClass4, PropertyQualifier:Key:AssocProp2:CIM_BOOLEAN:1" }};

IniInfo g_Test8[] = {
    { L"QUERY_LIST",        L"QUERY"},
    { L"QUERY",              L"select * from meta_class" },
    { L"ASSOCIATORS_QUERY",  L"Associators of" },
    { L"REFERENCES_QUERY",   L"References of" }};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL GetDefaultMatch(IniInfo Array[], const WCHAR * wcsKey, int & nWhich , int nMax)
{
    BOOL fRc = FALSE;
  
    for( int i = 0; i < nMax; i++ )
    {
        
        if( _wcsicmp(Array[i].Key, wcsKey ) == 0 )
        {
            nWhich = i;
            fRc = TRUE;
            break;
        }
    }
    return fRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CIniFileAndGlobalOptions::GetSpecificOptionForAPITest(const WCHAR * wcsClass, CAutoDeleteString & sClass, int nTest)
{
    BOOL fRc = FALSE;
    int nNum = 0;
 int nMax = 0;
    switch( nTest )
    {
        case APITEST4:
            //============================================================================
            //  Get the specific class defintion as listed in APITEST5
            //============================================================================
            fRc = ReadIniFile(L"APITEST4",wcsClass,g_Test4[3].Value,sClass,BVTVALUE);
            break;

        case APITEST5:
            //============================================================================
            //  Get the specific class defintion as listed in APITEST5
            //============================================================================
            nMax = sizeof(g_Test5)/sizeof(IniInfo);
            if( GetDefaultMatch(g_Test5,wcsClass,nNum, nMax))
            {
                fRc = ReadIniFile(L"APITEST5",wcsClass,g_Test5[nNum].Value,sClass,BVTVALUE);
            }
            else
            {
                fRc = ReadIniFile(L"APITEST5",wcsClass,L"Empty",sClass,BVTVALUE);
            }
            break;

        case APITEST7:
            //============================================================================
            //  Get the specific association defintion as listed in APITEST7
            //============================================================================
            nMax = sizeof(g_Test7)/sizeof(IniInfo);
            if( GetDefaultMatch(g_Test7,wcsClass,nNum, nMax ))
            {
                 fRc = ReadIniFile(L"APITEST7",wcsClass,g_Test7[nNum].Value,sClass,BVTVALUE);
            }
            else
            {
                 fRc = ReadIniFile(L"APITEST7",wcsClass,L"Empty",sClass,BVTVALUE);
            }
            break;

        case APITEST8:
            //============================================================================
            //  Get the specific Query as listed in APITEST8
            //============================================================================
            nMax = sizeof(g_Test8)/sizeof(IniInfo);
            if( GetDefaultMatch(g_Test8,wcsClass,nNum, nMax))
            {
                fRc = ReadIniFile(L"APITEST8",wcsClass,g_Test8[nNum].Value,sClass,BVTVALUE);
            }
            else
            {
                fRc = ReadIniFile(L"APITEST8",wcsClass,L"Empty",sClass,BVTVALUE);
            }
            break;
    }

    return fRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CIniFileAndGlobalOptions::GetOptionsForAPITest(CAutoDeleteString & sBuffer, int nTest)
{
    BOOL fRc = FALSE;

    switch( nTest )
    {
        case APITEST1:
            //============================================================================
            //  Get namespace
            //============================================================================
            fRc = ReadIniFile(L"APITEST1",g_Test1[0].Key,g_Test1[0].Value,sBuffer,BVTVALUE);
            break;

        case APITEST4:
            //============================================================================
            //  Get namespace
            //============================================================================
            fRc = ReadIniFile(L"APITEST4",g_Test4[0].Key,g_Test4[0].Value,sBuffer,BVTVALUE);
            break;

        case APITEST5:
            //============================================================================
            //  Get list of classes
            //============================================================================
            fRc = ReadIniFile(L"APITEST5",g_Test5[0].Key,g_Test5[0].Value,sBuffer,BVTVALUE);
            break;

        case APITEST7:
            //============================================================================
            //  Get list of classes
            //============================================================================
            fRc = ReadIniFile(L"APITEST5",g_Test7[0].Key,g_Test7[0].Value,sBuffer,BVTVALUE);
            break;

        case APITEST8:
            //============================================================================
            //  Get list of classes
            //============================================================================
            fRc = ReadIniFile(L"APITEST8",g_Test8[0].Key,g_Test8[0].Value,sBuffer,BVTVALUE);
            break;

    }
    return fRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CIniFileAndGlobalOptions::GetOptionsForAPITest(CAutoDeleteString & sNamespace, 
                                                    CAutoDeleteString & sClass, 
                                                    int nTest)
{
    BOOL fRc = FALSE;

    switch( nTest)
    {
        case APITEST2:
            fRc = ReadIniFile(L"APITEST2",g_Test2[0].Key,g_Test2[0].Value,sNamespace,BVTVALUE);
            if( fRc )
            {
                fRc = ReadIniFile(L"APITEST2",g_Test2[1].Key,g_Test2[1].Value,sClass,BVTVALUE);
            }
            break;

        case APITEST3:
            fRc = ReadIniFile(L"APITEST3",g_Test3[0].Key,g_Test3[0].Value,sNamespace,BVTVALUE);
            if( fRc )
            {
                fRc = ReadIniFile(L"APITEST3",g_Test3[1].Key,g_Test3[1].Value,sClass,BVTVALUE);
            }
            break;

       case APITEST4:
            //============================================================================
            //  Get parent namespace, the list of namespaces to create 
            //============================================================================
            fRc = ReadIniFile(L"APITEST4",g_Test4[1].Key,g_Test4[1].Value,sNamespace,BVTVALUE);
            if( fRc )
            {
                fRc = ReadIniFile(L"APITEST4",g_Test4[2].Key,g_Test4[2].Value,sClass,BVTVALUE);
            }
            break;
    }
    return fRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CIniFileAndGlobalOptions::GetOptionsForAPITest(CAutoDeleteString & sDeleteClasses, 
                                                    CAutoDeleteString & sClassesAfterDelete, 
                                                    CAutoDeleteString & sAddClasses, 
                                                    CAutoDeleteString & sClassesAfterAdd, 
                                                    CAutoDeleteString & sDeleteAddClassOrder, 
                                                    CAutoDeleteString & sClassesAfterDeleteAdd )
{
    BOOL fRc = FALSE;

    fRc = ReadIniFile(L"APITEST6",g_Test6[0].Key,g_Test6[0].Value,sDeleteClasses,BVTVALUE);
    if( fRc )
    {
        fRc = ReadIniFile(L"APITEST6",g_Test6[1].Key,g_Test6[1].Value,sClassesAfterDelete,BVTVALUE);
        if( fRc )
        {
            fRc = ReadIniFile(L"APITEST6",g_Test6[2].Key,g_Test6[2].Value,sAddClasses,BVTVALUE);
            if( fRc )
            {
               fRc = ReadIniFile(L"APITEST6",g_Test6[3].Key,g_Test6[3].Value,sClassesAfterAdd,BVTVALUE);
               if( fRc )
               {
                   fRc = ReadIniFile(L"APITEST6",g_Test6[4].Key,g_Test6[4].Value,sDeleteAddClassOrder,BVTVALUE);
                   if( fRc )
                   {
                        fRc = ReadIniFile(L"APITEST6",g_Test6[5].Key,g_Test6[5].Value,sClassesAfterDeleteAdd,BVTVALUE);
                   }
               }
            }
        }
    }
    return fRc;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  The following sections are used for SCRIPTTest1
//
//	[SCRIPTTEST1]
//
//	SCRIPT=scripts\\Test1.vbs
//	NAMESPACE="ROOT\\DEFAULT"
//  DESCRIPTION=Basic Connect via SWbemLocator and SWbemLocator.ConnectServer
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
IniInfo g_TestScript1[] = { {L"SCRIPT",L"scripts\\Test1.vbs" },
                            {L"NAMESPACE",L"Root\\Default"}};

BOOL CIniFileAndGlobalOptions::GetOptionsForScriptingTests(CAutoDeleteString & sScript, CAutoDeleteString & sNamespace,
                                                           int nTest)
{
    BOOL fRc = FALSE;

    switch( nTest )
    {
        case SCRIPTTEST1:
            fRc = ReadIniFile(L"SCRIPTTEST1",g_TestScript1[0].Key,g_TestScript1[0].Value,sScript,BVTVALUE);
            if( fRc )
            {
                fRc = ReadIniFile(L"SCRIPTTEST1",g_TestScript1[0].Key,g_TestScript1[0].Value,sNamespace,BVTVALUE);
            }
            break;
    }

    return fRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CIniFileAndGlobalOptions::WriteDefaultIniFile()
{
    BOOL fRc;
   //================================================================================
   // Write out test 1
   //================================================================================
    for( int i=0; i<sizeof(g_Doc1)/sizeof(IniInfo); i++ )
    {
        fRc = WritePrivateProfileString(L"APITEST1", g_Doc1[i].Key, g_Doc1[i].Value,m_wcsFileName);
    }
    fRc = WritePrivateProfileString(L"APITEST1", g_Test1[1].Key, g_Test1[1].Value,m_wcsFileName);
    
   //================================================================================
   // Write out test 2
   //================================================================================
    for( int i=0; i<sizeof(g_Doc2)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"APITEST2", g_Doc2[i].Key, g_Doc2[i].Value,m_wcsFileName);
    }
    for( int i=0; i<sizeof(g_Test2)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"APITEST2", g_Test2[i].Key, g_Test2[i].Value,m_wcsFileName);
    }
   //================================================================================
   // Write out test 3
   //================================================================================
    for( int i=0; i<sizeof(g_Doc3)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"APITEST3", g_Doc3[i].Key, g_Doc3[i].Value,m_wcsFileName);
    }
    for( int i=0; i<sizeof(g_Test3)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"APITEST3", g_Test3[i].Key, g_Test3[i].Value,m_wcsFileName);
    }
   //================================================================================
   // Write out test 4
   //================================================================================
    for( int i=0; i<sizeof(g_Doc4)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"APITEST4", g_Doc4[i].Key, g_Doc4[i].Value,m_wcsFileName);
    }
    WritePrivateProfileString(L"APITEST4", g_Test4[0].Key, g_Test4[0].Value,m_wcsFileName);
   //================================================================================
   // Write out test 5
   //================================================================================
    for( int i=0; i<sizeof(g_Doc5)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"APITEST5", g_Doc5[i].Key, g_Doc5[i].Value,m_wcsFileName);
    }
    for( int i=0; i<sizeof(g_Test5)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"APITEST5", g_Test5[i].Key, g_Test5[i].Value,m_wcsFileName);
    }

    //================================================================================
    // Write out test 6
    //================================================================================
    for( int i=0; i<sizeof(g_Doc6)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"APITEST6", g_Doc6[i].Key, g_Doc6[i].Value,m_wcsFileName);
    }
    for( int i=0; i<sizeof(g_Test6)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"APITEST6", g_Test6[i].Key, g_Test6[i].Value,m_wcsFileName);
    }

   //================================================================================
   // Write out test 7
   //================================================================================
    for( int i=0; i<sizeof(g_Doc7)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"APITEST7", g_Doc7[i].Key, g_Doc7[i].Value,m_wcsFileName);
    }
    for( int i=0; i<sizeof(g_Test7)/sizeof(IniInfo); i++ )
    {
        WritePrivateProfileString(L"APITEST7", g_Test7[i].Key, g_Test7[i].Value,m_wcsFileName);
    }

   //================================================================================
   // Scripting: Write out test 1
   //================================================================================
    WritePrivateProfileString(L"ScriptTest1", L"Description", L"Basic Connect via SWbemLocator and SWbemLocator.ConnectServer",m_wcsFileName);
    WritePrivateProfileString(L"ScriptTest1", g_TestScript1[0].Key, g_TestScript1[0].Value,m_wcsFileName);
    WritePrivateProfileString(L"ScriptTest1", g_TestScript1[1].Key, g_TestScript1[1].Value,m_wcsFileName);
 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\bvtapilib\bvtapi.h ===
/////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _BVT_API_HEADER
#define _BVT_API_HEADER

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
//*******************************************************************************************1
//
//  Prototypes 
//
//*******************************************************************************************
/////////////////////////////////////////////////////////////////////////////////////////////
int CoCreateInstanceAndLogErrors      ( REFCLSID clsid, REFIID  iid, void ** pPtr, BOOL fExpectedFailure, 
                                        const char * csFile, const ULONG Line );
int ConnectServerAndLogErrors         ( IWbemLocator * pLocator, IWbemServices ** pNamespace, WCHAR * wcsNamespace, 
                                        BOOL fExpectedFailure, const char * csFile, const ULONG Line );
int OpenObjectAndLogErrors            ( IWbemConnection * pConnection, REFIID  iid, void ** pObj, WCHAR * wcsObjectName,
                                        BOOL fExpectedFailure, const char * csFile, const ULONG Line );
int OpenObjectAsyncAndLogErrors       ( IWbemConnection * pConnection, REFIID  iid, WCHAR * wcsObjectName, 
                                        IWbemObjectSinkEx * pHandler, BOOL fExpectedFailure, const char * csFile,
                                        const ULONG Line );
int GetClassObjectAndLogErrors        ( IWbemServices * pNamespace, const WCHAR * wcsClassName, IWbemClassObject ** ppClass,
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , 
                                        const ULONG Line );
int SpawnInstanceAndLogErrors         ( IWbemClassObject * pClass, const WCHAR * wcsClassName, IWbemClassObject ** ppInst, 
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , 
                                        const ULONG Line );
int SpawnDerivedClassAndLogErrors    ( IWbemClassObject * pClass, const WCHAR * wcsClassName, IWbemClassObject ** ppInst,
                                       WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int PutPropertyAndLogErrors           ( IWbemClassObject * pInst, const WCHAR * wcsProperty, long lType, VARIANT * pVar, 
                                        const WCHAR * wcsClass, DWORD dwFlags, WCHAR * wcsNamespace, BOOL fExpectedFailure, 
                                        const char * csFile , const ULONG Line );
int PutInstanceAndLogErrors           ( IWbemServices * pNamespace, IWbemClassObject * pInst,const WCHAR * wcsClass, 
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , 
                                        const ULONG Line );
int ClassInheritsFromAndLogErrors     ( IWbemClassObject * pClass, const WCHAR * wcsClass, const WCHAR * wcsParent, 
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , 
                                        const ULONG Line );
int GetPropertyQualifierSetAndLogErrors ( IWbemClassObject * pClass, IWbemQualifierSet ** pQualifierSet,
                                        const WCHAR * wcsProperty, const WCHAR * wcsClass, WCHAR * wcsNamespace, 
                                        BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int GetClassQualifierSetAndLogErrors  ( IWbemClassObject * pClass, IWbemQualifierSet ** pQualifierSet,
                                        const WCHAR * wcsClass, WCHAR * wcsNamespace, 
                                        BOOL fExpectedFailure, const char * csFile , const ULONG Line );

int PutQualifierOnClassAndLogErrors   ( IWbemClassObject * pClass, const WCHAR * wcsQualifier, 
                                        VARIANT * Var, const WCHAR * wcsClass, DWORD dwFlags,
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int PutQualifierOnPropertyAndLogErrors( IWbemClassObject * pClass, const WCHAR * wcsProperty,const WCHAR * wcsQualifier,
                                        VARIANT * Var, const WCHAR * wcsClass, DWORD dwFlags, WCHAR * wcsNamespace, 
                                        BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int DeleteClassAndLogErrors           ( IWbemServices * pNamespace, const WCHAR * wcsClass,
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int PutClassAndLogErrors              ( IWbemServices * pNamespace, IWbemClassObject * pClass, const WCHAR * wcsClass, 
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int NextClassAndLogErrors             ( IEnumWbemClassObject * pEnum, IWbemClassObject ** pClass,
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int EnumerateClassesAndLogErrors      ( IWbemServices * pNamespace, IEnumWbemClassObject ** pEnum, 
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int EnumerateInstancesAndLogErrors    ( IWbemServices * pNamespace, IEnumWbemClassObject ** pEnum, const WCHAR * wcsClass,
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int GetPropertyAndLogErrors           ( IWbemClassObject * pClass, WCHAR * wcsProperty, VARIANT * vProperty, CIMTYPE * pType,
                                        LONG * plFlavor, WCHAR * wcsClassName, WCHAR * wcsNamespace,
                                        BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int DeleteInstanceAndLogErrors        ( IWbemServices * pNamespace, const WCHAR * wcsInstance,
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );
int ExecQueryAndLogErrors             ( IWbemServices * pNamespace, IEnumWbemClassObject ** ppEnum,WCHAR * wcsQuery, DWORD dwFlags, 
                                        WCHAR * wcsNamespace, BOOL fExpectedFailure, const char * csFile , const ULONG Line );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\framework\classfac.cpp ===
//=============
// CLASSFAC.CPP
//=============

#include "module.h"
#include "classfac.h"
#include "cimmodule_i.c"

extern HANDLE g_hEvent;

CClassFactory::CClassFactory() 
{
	m_cRef = 0L;
}

CClassFactory::~CClassFactory()
{
}


//===============
//IUknown methods
//===============

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IClassFactory)
        *ppv=this;

    if (*ppv != NULL)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CClassFactory::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CClassFactory::Release(void)
{
    int lNewRef = InterlockedDecrement(&m_cRef);
    if(lNewRef == 0)
    {
        delete this;
    }

    return lNewRef;
}

//=====================
//IClassFactory methods
//=====================

STDMETHODIMP
CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, LPVOID *ppv)
{
	HRESULT hr;
   
    if (pUnkOuter)
        return E_FAIL;

	// This object doesnt support aggregation
	//=======================================
    if (pUnkOuter!=NULL)
        return CLASS_E_NOAGGREGATION;

    pModule = new CModule();

    if (pModule == NULL)
	{
		return E_FAIL;
	}

    if (pModule)
    {
		// Retrieve the requested interface.
        hr = pModule->QueryInterface(riid, ppv);
    }
    else
    {
        *ppv = NULL;
        return E_OUTOFMEMORY;
    }

    return NOERROR;
}

//***************************************************************************
//
// CClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the EXE.  If the
//  lock count goes to zero and there are no objects, the EXE
//  is allowed to unload.  
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************
STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        CoAddRefServerProcess();
    else 
		if (CoReleaseServerProcess()==0)
			SetEvent(g_hEvent);
	
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\framework\worker.cpp ===
#define _WIN32_DCOM	

#include "module.h"
#include "worker.h"



CMyWorker::CMyWorker(CModule *pMod):
    CWorker(pMod)
{

	m_hThread=CreateThread(0, 
						   0, 
						   CMyWorker::ModWorkThread, 
						   this, 
						   0, 
						   &m_dwTID);

	if(m_hThread)
	{
		CloseHandle(m_hThread);
	}

}


DWORD WINAPI CMyWorker::ModWorkThread(void *pVoid)
{
    HRESULT hr=CoInitializeEx(0, COINIT_MULTITHREADED);
	CMyWorker *pThis=(CMyWorker *)pVoid;

	//one way for a module to work--run until stopped by user 
    //=======================================================

	while(!pThis->IsStopped())
	{
		//execute test here
		//=================

		//check for pause condition after each test
		//=========================================

		while(pThis->IsPaused() && !pThis->IsStopped())
		{
			Sleep(1000);
		}
	}
	
	delete pThis;

	return 0;
}



CMyWorker::~CMyWorker()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\framework\module.h ===
#ifndef _MODULE_H_
#define _MODULE_H_

#include "cimmodule.h"

class CModule : public ICimModule
{
public:

	CModule();
	~CModule();

    //IUnknown methods
	//================
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	//IDispatch methods not supported
	//===============================
	STDMETHODIMP GetTypeInfoCount(UINT *)
	{return E_NOTIMPL;}
	STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **)
	{return E_NOTIMPL;}
	STDMETHODIMP GetIDsOfNames(REFIID, LPOLESTR*, UINT, LCID, DISPID*)
	{return E_NOTIMPL;}
	STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD, DISPPARAMS*, VARIANT *, EXCEPINFO*, UINT*)
	{return E_NOTIMPL;}

	//ICimModule methods
	//==================
	STDMETHODIMP Start(VARIANT* pvarInitOp, IUnknown* pIUnknown);
	STDMETHODIMP Pause(void);
	STDMETHODIMP Terminate(void);
	STDMETHODIMP BonusMethod(void);


	bool m_bShouldExit;
	bool m_bShouldPause;
	ICimNotify *m_pCimNotify;
	BSTR m_bstrParams;

protected:
	void ParseParams(VARIANT *);
	static DWORD WINAPI ModuleMain(void *pVoid);
	
	HANDLE m_hThread;
	LONG m_cRef;
};

#endif /*_MODULE_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\framework\classfac.h ===
//===============================
// CLASSFAC.H
// CClassFactory Class Definition
//===============================

#ifndef _CLASSFAC_H_
#define _CLASSFAC_H_

class CClassFactory : public IClassFactory
{
public:

	CClassFactory();
	virtual ~CClassFactory();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
	 
	// IClassFactory members
	// =====================
	STDMETHODIMP CreateInstance(IUnknown * pUnkOuter, REFIID riid, void ** ppvObject);
 	STDMETHODIMP LockServer(BOOL fLock);

private:
	LONG m_cRef;
	CModule *pModule;
	HWND hWnd;
};


#endif /* _CLASSFAC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\framework\worker.h ===
#ifndef _WORKER_H_
#define _WORKER_H_

class CWorker
{
public:
	CWorker::CWorker(CModule *pModule):
		m_pNotify(pModule->m_pCimNotify),
		m_pModule(pModule),
		m_pbStop(&pModule->m_bShouldExit),
		m_pbPause(&pModule->m_bShouldPause)
	{
		m_wsParams=_wcsdup(pModule->m_bstrParams);
		
        m_pNotify->AddRef();
		m_pNotify->AddRef();
		m_pModule->AddRef();
	}

	virtual ~CWorker()
	{
		delete []m_wsParams;
		
		m_pNotify->Release();
		m_pModule->Release();
	}

	virtual bool IsStopped()
	{
		return *m_pbStop==true;
	}

    virtual void StopModule()
    {
        *m_pbStop=true;
    }

	virtual bool IsPaused()
	{
		return *m_pbPause==true;
	}

private:
	bool *m_pbStop, *m_pbPause;
	WCHAR *m_wsParams;
	ICimNotify *m_pNotify;
	CModule *m_pModule;


};


class CMyWorker : public CWorker
{
public:
	CMyWorker(CModule *pModule);
	~CMyWorker();

private:
	static DWORD WINAPI ModWorkThread(void *pVoid);


	HANDLE m_hThread;
	DWORD m_dwTID;


};


#endif /*_WORKER_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\framework\module.cpp ===
// ================================================
// MODULE.CPP
// Module Class implementation; non-module specific
// ================================================

#define _WIN32_DCOM	

#include "module.h"
#include "comdef.h"
#include "process.h"
#include "worker.h"	


extern HANDLE g_hEvent;


CModule::CModule():
	m_pCimNotify(0),
	m_cRef(0),
	m_bstrParams(NULL),
	m_bShouldExit(false),
	m_bShouldPause(false),
	m_hThread(NULL)
{
	CoAddRefServerProcess();
}

CModule::~CModule()
{
	if (m_hThread)
	{
		CloseHandle(m_hThread);
	}

	SysFreeString(m_bstrParams);

	if (CoReleaseServerProcess()==0)
		SetEvent(g_hEvent); //shutdown server

}

STDMETHODIMP CModule::QueryInterface(REFIID riid, LPVOID *ppv)
{
	*ppv=NULL;

	if(IID_IUnknown == riid || IID_ICimModule == riid)
	{
		*ppv = (ICimModule *)this;
	}
	
	if(NULL != *ppv)
	{
		AddRef();
		return NOERROR;
	}
	else
		return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CModule::AddRef(void)
{
   return InterlockedIncrement((long *)&m_cRef);
}

STDMETHODIMP_(ULONG) CModule::Release(void)
{
	ULONG nNewCount=InterlockedDecrement((long *)&m_cRef);
    if (nNewCount != 0)
        return nNewCount;

	delete this;

	return 0;
}




STDMETHODIMP CModule::Start(VARIANT* pvarInitOp, IUnknown* pUnknown)
{

	// The module MUST return immediately from calls to Start()
	// Non-zero error code indicates catastrophic failure! Never return that!
	//=======================================================================

	HRESULT hr;
	DWORD dwTID;

	// Get the logging interface (ICimNotify)
	//=======================================

	hr = pUnknown->QueryInterface(IID_ICimNotify, (LPVOID *)&m_pCimNotify);

	if (hr == S_OK)
	{	
		//Grab a copy of the start parameters
		//===================================

		CModule::ParseParams(pvarInitOp);

		// Start the thread and return
		//============================

		m_hThread = CreateThread(0, 0, CModule::ModuleMain, this, 0, &dwTID);
	}

	return hr;
}

STDMETHODIMP CModule::Terminate()
{
	// The module MUST return immediately from calls to Terminate()
	// Failure codes indicates catastrophic failure! Never return that!
	//=======================================================================

	m_bShouldExit=true;
	return S_OK;
}

STDMETHODIMP CModule::Pause()
{
	// The module MUST return immediately from calls to Pause()
	// Failure codes indicate catastrophic failure! Never return that!
	//=======================================================================

	m_bShouldPause=!m_bShouldPause;
	return S_OK;
}

STDMETHODIMP CModule::BonusMethod(void)
{
	// The module MUST return immediately from calls to BonusMethod()
	// Module specific (i.e. do whatever you want to here)
	// Failure codes indicate catastrophic failure! Never return that!
	//=======================================================================

	return 0;
}

void CModule::ParseParams(VARIANT *pVar)
{
	//This just stores the parameter. You could choose to actually parse it here!
	//===========================================================================

	if(VT_BSTR==pVar->vt)
	{
		m_bstrParams=SysAllocString(pVar->bstrVal);
	}
}



DWORD WINAPI CModule::ModuleMain(void *pVoid)
{
	CoInitializeEx(0, COINIT_MULTITHREADED);

	CModule *pThis = (CModule *)pVoid;

	//this module could create a different worker object dependent on the parameters
	//==============================================================================

	CWorker *pWorker= new CMyWorker(pThis);

	//Worker now has control over the lifetime over ICimModule (CModule) and ICimNotify 
	//=================================================================================

	pThis->m_pCimNotify->Release();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\codecoverage\reports\makefile.inc ===
!include $(_NTDRIVE)$(_NTROOT)\ADMIN\WMI\WBEM\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\framework\main.cpp ===
// TO BUILD A MODULE FROM THE SKELETON, see README.TXT
// ===================================================
// MAIN.CPP
// Module executable entry point
// ===================================================
// Project History:
//
// Date     Name	  Change
// -------- --------- ---------
// 9/17/98  a-jaker	  Created
// 10/23/98 a-jayher  Edited
// 12/14/98 marioh	  Edited [AppWizard additions]
//====================================================

#define _WIN32_DCOM	

#include "module.h"
#include "classfac.h"

HANDLE g_hEvent;

// Used to register a COM API
void RegisterServer(char *szFileName, GUID guid, char * pDesc, char * pModel, char * pProgID);



int APIENTRY WinMain(IN HINSTANCE hInstance,
                     IN HINSTANCE hPrevInstance,
                     IN LPSTR szCmdLine,
                     IN int nCmdShow)
{
	DWORD dwObject=0;
	HRESULT hr;

	// Register CLSID here if called with /REGSERVER
	//==============================================

	if(!lstrcmpi(TEXT("REGSERVER"),szCmdLine+1))
	{
		char szBuffer[MAX_PATH];
		GetModuleFileName(NULL,szBuffer,MAX_PATH);
		
		//All modules need to have the substring "WBEM TEST MODULE" in their description
		RegisterServer(szBuffer, CLSID_CimModule, "WMI Generic Framework Module - WBEM TEST MODULE", "Both", NULL);
		exit(0);
	}

	CClassFactory *pFactory=new CClassFactory();
	g_hEvent = CreateEvent(0, FALSE, FALSE, 0);

	hr=CoInitializeEx(0, COINIT_MULTITHREADED);

	if (hr==S_OK)
	{
		// Initialize DCOM Security Here (change flags as needed)
		//=======================================================

		hr = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE, 
			RPC_C_IMP_LEVEL_IDENTIFY, NULL, EOAC_NONE, 0);

		if (hr==S_OK)
		{

			hr=CoRegisterClassObject(CLSID_CimModule,
								  (IUnknown *) pFactory,
								  CLSCTX_LOCAL_SERVER,
								  REGCLS_MULTIPLEUSE,
								  &dwObject);
		}
	}


	if (hr != S_OK)
		exit(hr);


	CoResumeClassObjects();

	//Wait here until all objects have been released
	//==============================================

	WaitForSingleObject(g_hEvent,INFINITE);

	CoRevokeClassObject(dwObject);
	CloseHandle(g_hEvent);
	CoUninitialize();
	return 0;

}

void RegisterServer(char *szFileName, GUID guid, char * pDesc, char * pModel,
			char * pProgID)
{
    char       szID[128];
    WCHAR      wcID[128];
    char       szCLSID[128];
    HKEY hKey1 = NULL, hKey2 = NULL;

    // Create the path.
    if(0 ==StringFromGUID2(guid, wcID, 128))
		return;

    wcstombs(szID, wcID, 128);
    lstrcpy(szCLSID, TEXT("CLSID\\"));
    lstrcat(szCLSID, szID);

    // Create entries under CLSID
    if(ERROR_SUCCESS != RegCreateKey(HKEY_CLASSES_ROOT, szCLSID, &hKey1))
		return;

    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pDesc, lstrlen(pDesc)+1);
    
    if (strstr(_strlwr(szFileName),".exe"))
	{
		if(ERROR_SUCCESS != RegCreateKey(hKey1,"LocalServer32",&hKey2))
			return;
	}
	else
	{
		if(ERROR_SUCCESS != RegCreateKey(hKey1,"InProcServer32",&hKey2))
			return;
	}

    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szFileName, 
                                        lstrlen(szFileName)+1);
  
    RegSetValueEx(hKey2, "ThreadingModel", 0, REG_SZ, 
                                       (BYTE *)pModel, lstrlen(pModel)+1);

    RegCloseKey(hKey1);
    RegCloseKey(hKey2);

    // If there is a progid, then add it too
    if(pProgID)
    {
        if(ERROR_SUCCESS == RegCreateKey(HKEY_CLASSES_ROOT, pProgID, &hKey1))
        {

            RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)pDesc , lstrlen(pDesc)+1);
            if(ERROR_SUCCESS == RegCreateKey(hKey1,"CLSID",&hKey2))
            {
                RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szID, 
                                        lstrlen(szID)+1);
                RegCloseKey(hKey2);
                hKey2 = NULL;
            }
            RegCloseKey(hKey1);
        }

    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\test\bvt\standalone\bvtmain.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  BVTMain.CPP
//
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define DECLARE_GLOBALS
#include <bvt.h>
#include <string.h> 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL ParseCommandLine(int argc, char *argv[])
{
    BOOL fRc = TRUE;

    //============================================================================================
    //  Set the default error log name.
    //============================================================================================

    g_LogFile.SetFileName(L"BVT.LOG");
    g_Options.SetFileName(L"BVT.INI");


    //============================================================================================
    //
    //  Loop through the command line and get all of the available arguments.  
    //
    //============================================================================================
	for(int i=1; i<argc; i++)
	{
		if(_stricmp(argv[i], "-INIFILE") == 0)
		{
            WCHAR * pszW = NULL;
            if( S_OK == AllocateAndConvertAnsiToUnicode(argv[++i], pszW))
            {
                g_Options.SetFileName(pszW);
            }
            SAFE_DELETE_ARRAY(pszW);
		}
		else if(_stricmp(argv[i], "-LOGFILE") == 0)
		{
            WCHAR * pszW = NULL;
            if( S_OK == AllocateAndConvertAnsiToUnicode(argv[++i], pszW))
            {
                g_LogFile.SetFileName(pszW);
            } 
            SAFE_DELETE_ARRAY(pszW);
		}
		else if(_stricmp(argv[i], "-TEST") == 0)
		{
            char * pSeps = "[],";
            char * pToken = strtok( argv[i++], pSeps );

            while( pToken != NULL )
            {
                g_Options.AddToSpecificTestList(atoi(pToken));
                pToken = strtok( NULL, pSeps );
            }

            g_Options.SpecificTests(TRUE);
		}
		else if(_stricmp(argv[i], "-DEFAULT") == 0)
		{
           g_Options.WriteDefaultIniFile();
        }
		else
		{
	    	printf("Usage : %s OPTIONS\n\n", argv[0]);
			printf("Valid options are: \n");
            printf("  -TEST    [1,2,10...]        Default: All tests are executed\n");
			printf("  -INIFILE inifilename        The name of the ini file.\n");
			printf("  -WRITEDEFAULTINI            Writes out the default ini file.\n");
			printf("  -LOGFILE logfilename        The name of the output log file.\n");
            printf("                              Default: BVT.LOG\n\n");
			return FALSE;
		}
	}

    return fRc;
}

void Test()
{
    IWbemLocator * pLocator = NULL;
    int nRc;

    nRc = CoCreateInstanceAndLogErrors(CLSID_WbemLocator,IID_IWbemLocator,(void**)&pLocator,NO_ERRORS_EXPECTED);
    if( SUCCESS == nRc )
    {
        //==========================================================================
        //  Parse the namespace name to get the parent first, and open the parent
        //  this one must be existing 
        //==========================================================================
        IWbemServices * pNamespace = NULL;

        nRc = ConnectServerAndLogErrors(pLocator,&pNamespace,L"ROOT",NO_ERRORS_EXPECTED);
        if( nRc == SUCCESS )
        {

            IWbemClassObject * pClass = NULL;
            HRESULT hr = pNamespace->GetObject(CBSTR(L"__NAMESPACE"),WBEM_FLAG_RETURN_WBEM_COMPLETE,NULL,&pClass,NULL );
            if( hr == S_OK )
            {
                IWbemClassObject * pInst = NULL;
                hr = pClass->SpawnInstance(0, &pInst);
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//*****************************************************************************************************************
//
//  Run the tests
//
//*****************************************************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int RunTests(int nWhichTest)
{

    int nRc = FATAL_ERROR;

    g_LogFile.LogError(__FILE__,__LINE__,SUCCESS, L"Running Test# %d ", nWhichTest );


    switch( nWhichTest )
    {
        //=================================================================
        // Basic connect using IWbemLocator 
        //=================================================================
        case APITEST1:
            nRc = BasicConnectUsingIWbemLocator();
            break;

        //=================================================================
        // Basic Sync connect using IWbemConnection
        //=================================================================
        case APITEST2:
            nRc = BasicSyncConnectUsingIWbemConnection();
            break;

        //=============================================================
        // Basic connect sync & async using IWbemConnection
        //=============================================================
        case APITEST3:
            nRc = BasicAsyncConnectUsingIWbemConnection();
            break;

        //=============================================================
        // Create a new test namespace
        //=============================================================
        case APITEST4:
            nRc = CreateNewTestNamespace();
            break;
        
        //=============================================================
        // Create 10 classes with different properties. Some of 
        // these should be in the following inheritance chain and 
        // some should not inherit from the others at all:  
        // classes = {A, B, C, D:A, E:A, F:E, G:F, H:G, I:F}.  
        // A mix of simple string & sint32 keys are fine.
        //=============================================================
        case APITEST5:
            nRc = CreateNewClassesInTestNamespace();
            break;

        //=============================================================
        // "memorize the class definitions".  In a complex loop, 
        // delete the classes and recreate them in various sequences, 
        // ending with the full set.
        //=============================================================
        case APITEST6:
            nRc = DeleteAndRecreateNewClassesInTestNamespace();
            break;

        //=============================================================
        // Create associations
        //=============================================================
        case APITEST7:
            nRc= CreateSimpleAssociations();
            break;

        //=============================================================
        // Execute queries
        //=============================================================
        case APITEST8:
            nRc = QueryAllClassesInTestNamespace();
            break;

        //=============================================================
        // Create instances of the above classes, randomly creating 
        // and deleting in a loop, finishing up with a known set.  
        // Query the instances and ensure that no instances disappeared 
        // or appeared that shouldn't be there.    
        //=============================================================

        //=============================================================
        // Verify that deletion of instances works.
        //=============================================================
        case APITEST9:
            break;

        //=============================================================
        // Verify that deletion of a class takes out all the instances.
        //=============================================================
        case APITEST10:
            break;

        //=============================================================
        // Call each of the sync & async APIs at least once.
        //=============================================================
        case APITEST11:
            break;

        //=============================================================
        // Create some simple association classes 
        //=============================================================
        case APITEST12:
            break;

        //=============================================================
        // Execute some simple refs/assocs queries over these and 
        // ensure they work.
        //=============================================================
        case APITEST13:
            break;

        //=============================================================
        //  Open an association endpoint as a collection 
        // (Whistler-specific) and enumerate, ensure that results are 
        // identical to [12].
        //=============================================================
        case APITEST14:
            break;

        //=============================================================
        // Open a scope and do sets of simple instances operations
        // (create, enum,query, update, delete)
        //=============================================================
        case APITEST15:
            break;

        //=============================================================
        //  Complex Repository Phase
        //  Rerun the above tests in parallel from several threads 
        //  in different namespaces.
        //=============================================================
        case APITEST16:
            break;

        case SCRIPTTEST1:
            ExecuteScript(nWhichTest);
            break;

        default:
            g_LogFile.LogError(__FILE__,__LINE__,WARNING, L"Requested test does not exist." );
            break;
    }
        
    g_LogFile.LogError(__FILE__,__LINE__,SUCCESS, L"Leaving Test# %d ", nWhichTest );
    return nRc;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
extern "C" int __cdecl main( int argc, char *argv[] )
{
    int nRc = FATAL_ERROR;
    //==============================================================
    //  Get the command line arguments
    //==============================================================
    if( !ParseCommandLine(argc, argv) )
    {
        g_LogFile.LogError( __FILE__,__LINE__,FATAL_ERROR, L"GetCommandLineArguments failed." );
    }
    else
    {
	    // =========================================================
      	// Initialize COM
	    // =========================================================
        HRESULT hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
	    if ( SUCCEEDED( hr ) )
        {
	        // =====================================================
        	// Setup default security parameters
	        // =====================================================
        	hr = CoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE,
			                           NULL, EOAC_NONE, NULL );
	        if ( SUCCEEDED( hr ) )
            {
                if( g_Options.RunSpecificTests())
                {
         	        // =================================================
                    //  Execute the specific tests requested
         	        // =================================================
                    for( int i = 0; i < g_Options.SpecificTestSize(); i++ )
                    {
                        int nTest = g_Options.GetSpecificTest(i);
                        nRc = RunTests(nTest);
                        if( nRc == FATAL_ERROR )
                        {
                            g_LogFile.LogError( __FILE__,__LINE__,FATAL_ERROR, L"Test # %d returned a FATAL ERROR",nTest );
                        }
                    }
                }
                else
                {
         	        // =================================================
                    //  Execute all of the BVT tests
    	            // =================================================
                        
                    int nMaxTests = sizeof(g_nDefaultTests) / sizeof(int);

                    for( int i = 0; i < nMaxTests ; i++ )
                    {
                        nRc = RunTests(g_nDefaultTests[i]);
                    }
                }
            }
            else
            {
                g_LogFile.LogError( __FILE__,__LINE__,FATAL_ERROR, L"CoInitializeSecurity failed." );
            }

          	CoUninitialize();
        }
        else
        {
            g_LogFile.LogError( __FILE__,__LINE__,FATAL_ERROR, L"CoInitializeEx failed." );
        }

    }

    return nRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\debuggerextension\wmiexts\makefile.inc ===
!include $(_NTDRIVE)$(_NTROOT)\ADMIN\WMI\WBEM\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\codecoverage\reports\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Precomp.h

Abstract:


History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>
#include <ntpsapi.h>
#include <ntexapi.h>

#define _WINNT_	// have what is needed from above

#include <ole2.h>
#include <windows.h>
#define COREPOL_HEADERFILE_IS_INCLUDED
#ifndef POLARITY
#if 1
#define POLARITY __declspec( dllimport )
#else
#define POLARITY 
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\codecoverage\reports\report.cpp ===
//  Copyright (c) 1999 Microsoft Corporation
#include <precomp.h>
#include <windows.h>
#include <objbase.h>
#include <stdio.h>

#include <Allocator.h>
#include <Array.h>
#include <Stack.h>
#include <Queue.h>
#include <Algorithms.h>
#include <PQueue.h>
#include <RedBlackTree.h>
#include <AvlTree.h>
#include <TPQueue.h>
#include <HashTable.h>
#include <Thread.h>
#include <BpTree.h>
#include <HelperFuncs.h>

#import "c:\Program Files\Common Files\System\ADO\msado15.dll" \
   no_namespace rename("EOF", "EndOfFile")

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

LRESULT CALLBACK WindowsMainProc ( HWND a_hWnd , UINT a_message , WPARAM a_wParam , LPARAM a_lParam )
{
	LRESULT t_rc = 0 ;

	switch ( a_message )
	{
		case WM_DESTROY:
		{
			PostMessage ( a_hWnd , WM_QUIT , 0 , 0 ) ;
		}
		break ;

		default:
		{		
			t_rc = DefWindowProc ( a_hWnd , a_message , a_wParam , a_lParam ) ;
		}
		break ;
	}

	return ( t_rc ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HWND WindowsInit ( HINSTANCE a_HInstance )
{
	static wchar_t *t_TemplateCode = L"TemplateCode" ;

	WNDCLASS  t_wc ;
 
	t_wc.style            = CS_HREDRAW | CS_VREDRAW ;
	t_wc.lpfnWndProc      = WindowsMainProc ;
	t_wc.cbClsExtra       = 0 ;
	t_wc.cbWndExtra       = 0 ;
	t_wc.hInstance        = a_HInstance ;
	t_wc.hIcon            = LoadIcon(NULL, IDI_HAND) ;
	t_wc.hCursor          = LoadCursor(NULL, IDC_ARROW) ;
	t_wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1) ;
	t_wc.lpszMenuName     = NULL ;
	t_wc.lpszClassName    = t_TemplateCode ;
 
	ATOM t_winClass = RegisterClass ( &t_wc ) ;

	HWND t_HWnd = CreateWindow (

		t_TemplateCode ,              // see RegisterClass() call
		t_TemplateCode ,                      // text for window title bar
		WS_OVERLAPPEDWINDOW | WS_MINIMIZE ,               // window style
		CW_USEDEFAULT ,                     // default horizontal position
		CW_USEDEFAULT ,                     // default vertical position
		CW_USEDEFAULT ,                     // default width
		CW_USEDEFAULT ,                     // default height
		NULL ,                              // overlapped windows have no parent
		NULL ,                              // use the window class menu
		a_HInstance ,
		NULL                                // pointer not needed
	) ;

	ShowWindow ( t_HWnd, SW_SHOW ) ;
	//ShowWindow ( t_HWnd, SW_HIDE ) ;

	return t_HWnd ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WindowsStop ( HWND a_HWnd )
{
	CoUninitialize () ;
	DestroyWindow ( a_HWnd ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HWND WindowsStart ( HINSTANCE a_Handle )
{
	HWND t_HWnd = NULL ;
	if ( ! ( t_HWnd = WindowsInit ( a_Handle ) ) )
	{
    }

	return t_HWnd ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT UnInitComClient ()
{
	CoUninitialize () ;

	return S_OK ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT InitComClient ( DWORD a_AuthenticationLevel , DWORD a_ImpersonationLevel )
{
	HRESULT t_Result = S_OK ;

    t_Result = CoInitializeEx (

		0, 
		COINIT_MULTITHREADED
	);

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = CoInitializeSecurity (

			NULL, 
			-1, 
			NULL, 
			NULL,
			a_AuthenticationLevel,
			a_ImpersonationLevel, 
			NULL, 
			EOAC_DYNAMIC_CLOAKING, 
			0
		);

		if ( FAILED ( t_Result ) ) 
		{
			CoUninitialize () ;
			return t_Result ;
		}

	}

	return t_Result  ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void WindowsDispatch ()
{
	BOOL t_GetMessage ;
	MSG t_lpMsg ;

	while (	( t_GetMessage = GetMessage ( & t_lpMsg , NULL , 0 , 0 ) ) == TRUE )
	{
		TranslateMessage ( & t_lpMsg ) ;
		DispatchMessage ( & t_lpMsg ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Process_GetTrace_RecordSet (

	_ConnectionPtr & a_Connection , 
	_RecordsetPtr &a_RecordSet ,
	wchar_t *a_Trace
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		if ( a_Trace )
		{
			BSTR t_Filter = NULL ;
			WmiStatusCode t_StatusCode = WmiHelper :: ConcatenateStrings (

				3 , 
				& t_Filter ,
				L"select * from tTrace where name='" ,
				a_Trace ,
				"'"
			) ;

			if ( t_StatusCode == e_StatusCode_Success )
			{
				try
				{
					a_RecordSet = a_Connection->Execute (

						t_Filter ,
						NULL ,
						0
					) ;
				}
				catch ( ... )
				{
					t_Result = E_FAIL ;
				}

				SysFreeString ( t_Filter ) ;
			}
			else
			{
				t_Result = E_FAIL ;
			}
		}
		else
		{
			a_RecordSet = a_Connection->Execute (

				"select * from tTrace" ,
				NULL ,
				0
			) ;
		}
	}
	catch ( ... )
	{
		t_Result = E_FAIL ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Process_GetJoined_RecordSet (

	_ConnectionPtr & a_Connection , 
	_RecordsetPtr &a_RecordSet
)
{
	HRESULT t_Result = S_OK ;

	try
	{
		a_RecordSet = a_Connection->Execute (

			"Select " \
			"tSourceFile.ID As tSourceFile_ID ," \
			"tSourceFile.Path As tSourceFile_Path , " \
			"tBlock.ID As tBlock_ID ," \
			"tBlock.ProcedureId As tBlock_ProcedureId ," \
			"tBlock.BlockID As tBlock_BlockID ," \
			"tBlock.Address As tBlock_Address ," \
			"tBlock.ComponentID As tBlock_ComponentID , " \
			"tProcedure.ID As tProcedure_ID , " \
			"tProcedure.ComponentID As tProcedure_ComponentID , " \
			"tProcedure.Name As tProcedure_Name , " \
			"tProcedure.ByteSize As tProcedure_ByteSize , " \
			"tProcedure.Address As tProcedure_Address , " \
			"tProcedure.BlockCount As tProcedure_BlockCount , " \
			"tProcedure.MCComplexity As tProcedure_MCComplexity , " \
			"tProcedure.LineNumber As tProcedure_LineNumber , " \
			"tProcedure.SrcFileID As tProcedure_SrcFileID , " \
			"tProcedure.ClassID As tProcedure_ClassID , " \
			"tComponent.ID As tComponent_ID , " \
			"tComponent.Name As tComponent_Name , " \
			"tComponent.GUID As tComponent_GUID , " \
			"tComponent.ProcCount As tComponent_ProcCount ," \
			"tComponent.Checksum As tComponent_Checksum , " \
			"tComponent.BinarySize As tComponent_BinarySize , " \
			"tComponent.InstTime As tComponent_InstTime " \
 			"from tSourceFile JOIN tProcedure On ( tSourceFile.ID = tProcedure.SrcFileID )	Join tBlock On ( tBlock.ProcedureId = tProcedure.ID ) Join tComponent On ( tComponent.Id = tProcedure.ComponentId )" ,
			NULL ,
			0
		) ;
	}
	catch ( ... )
	{
		t_Result = E_FAIL ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL Process_CheckBit (

	SAFEARRAY *a_BitVector ,
	ULONG a_BitIndex
)
{
	LONG t_ElementIndex = a_BitIndex >> 3 ;

	BYTE t_Element = 0 ;
	if ( SUCCEEDED ( SafeArrayGetElement ( a_BitVector , &t_ElementIndex , & t_Element ) ) )
	{
		if ( t_Element & ( 1 << ( a_BitIndex & 0x7 ) ) )
		{
			return TRUE ;
		}
		else
		{
			return FALSE ;
		}
	}

	return FALSE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

ULONG Process_PrintCoverage (

	SAFEARRAY *a_BitVector ,
	_RecordsetPtr &a_JoinedRecordSet
)
{
	ULONG t_CoveredPecentage = 0 ;

	try
	{
		if ( SafeArrayGetDim ( a_BitVector ) == 1 )
		{
			LONG t_Dimension = 1 ; 

			LONG t_Lower ;
			SafeArrayGetLBound ( a_BitVector , t_Dimension , & t_Lower ) ;

			LONG t_Upper ;
			SafeArrayGetUBound ( a_BitVector , t_Dimension , & t_Upper ) ;

			LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

			ULONG t_BlockCount = 0 ;
			ULONG t_CoveredCount = 0 ;

			a_JoinedRecordSet->MoveFirst () ;
			while ( a_JoinedRecordSet->EndOfFile == FALSE )
			{
				_variant_t t_Variant_ID ;
				t_Variant_ID = a_JoinedRecordSet->Fields->GetItem (L"tBlock_ID")->Value ;

				ULONG t_BitIndex = ( LONG ) t_Variant_ID ;
				BOOL t_Covered = Process_CheckBit (

					a_BitVector ,
					t_BitIndex
				) ;

				if ( t_Covered )
				{
					t_CoveredCount ++ ;
				}

				t_BlockCount ++ ;

				a_JoinedRecordSet->MoveNext () ;
			}

			t_CoveredPecentage = t_CoveredCount	 * 100 / t_BlockCount ;
		}
	}
	catch ( ... )
	{
	}

	return t_CoveredPecentage ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void Process_PrintTraceStatistics (

	_RecordsetPtr &a_TraceRecordSet ,
	_RecordsetPtr &a_JoinedRecordSet ,
	FieldsPtr &a_Fields
)
{
	try
	{
		_variant_t t_Variant_Name ;
		t_Variant_Name = a_Fields->GetItem (L"Name")->Value ;
		printf ( "\nTrace:[%S]" , ( wchar_t * ) ( _bstr_t ) t_Variant_Name ) ;

		_variant_t t_Variant_Date ;
		t_Variant_Date = a_Fields->GetItem (L"SaveDate")->Value ;
		printf ( "\nDate:[%S]" , ( wchar_t * ) ( _bstr_t ) t_Variant_Date ) ;

		_variant_t t_Variant_TraceGuid ;
		t_Variant_TraceGuid = a_Fields->GetItem (L"TraceGuid")->Value ;
		printf ( "\nTraceGuid:[%S]" , ( wchar_t * ) ( _bstr_t ) t_Variant_TraceGuid ) ;

		_variant_t t_Variant_ComponentGuid ;
		t_Variant_ComponentGuid = a_Fields->GetItem (L"ComponentGuid")->Value ;
		printf ( "\nComponentGuid:[%S]" , ( wchar_t * ) ( _bstr_t ) t_Variant_ComponentGuid ) ;

		_variant_t t_Variant_BitVector ;
		t_Variant_BitVector = a_Fields->GetItem (L"BitVector")->Value ;

		VARIANT t_RealVariant ;
		VariantInit ( & t_RealVariant ) ;
		t_RealVariant = t_Variant_BitVector.Detach () ;

		if ( t_RealVariant.vt == ( VT_ARRAY | VT_UI1 ) )
		{
			SAFEARRAY *t_Array = t_RealVariant.parray ;
			
			ULONG t_CoveragePercentage = Process_PrintCoverage (

				t_Array ,
				a_JoinedRecordSet
			) ;

			printf ( "\nCoverage%%:[%d]" , t_CoveragePercentage ) ;
		}

		VariantClear ( & t_RealVariant ) ;
	}
	catch ( ... )
	{
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void Process_Results (

	_RecordsetPtr &a_TraceRecordSet ,
	_RecordsetPtr &a_JoinedRecordSet
)
{
	a_TraceRecordSet->MoveFirst () ;
	while ( a_TraceRecordSet->EndOfFile == FALSE )
	{
		Process_PrintTraceStatistics (

			a_TraceRecordSet ,
			a_JoinedRecordSet ,
			a_TraceRecordSet->Fields
		) ;

		printf ( "\n" ) ;

		a_TraceRecordSet->MoveNext () ;
	}
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void Process ()
{
	_ConnectionPtr t_Connection ( "ADODB.Connection" ) ;

	try
	{
		t_Connection->Open (

			"Provider=sqloledb;Data source=stevm_12_12076;Uid=sa;pwd=;Initial catalog=sleuth;" , 
			"", 
			"", 
			adConnectUnspecified
		) ;

		try
		{
			_RecordsetPtr t_TraceRecordSet ( "ADODB.Recordset" ) ;

			HRESULT t_Result = Process_GetTrace_RecordSet ( t_Connection , t_TraceRecordSet , L"Steve" ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				_RecordsetPtr t_JoinedRecordSet ( "ADODB.Recordset" ) ;

				HRESULT t_Result = Process_GetJoined_RecordSet ( t_Connection , t_JoinedRecordSet ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					Process_Results ( 

						t_TraceRecordSet ,
						t_JoinedRecordSet
					) ;
				}

				t_TraceRecordSet->Close () ;
			}
		}
		catch ( ... ) 
		{
		}

		t_Connection->Close () ;
	}
	catch ( ... )
	{
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

EXTERN_C int __cdecl wmain (

	int argc ,
	char **argv 
)
{
	HWND t_Window = WindowsStart ( NULL ) ;
	if ( t_Window )
	{
		DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
		DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_CONNECT ;

		HRESULT t_Result = InitComClient ( t_AuthenticationLevel , t_ImpersonationLevel ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			Process () ;
			UnInitComClient () ;
		}

		WindowsStop ( t_Window ) ;
	}

	return 0 ;
}


#include <HelperFuncs.cpp>
#include <Allocator.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\debuggerextension\wmiexts\container.cpp ===
#include <precomp.h>
#include "Container.h"

#include <Exception.h>
#include <Allocator.h>
#include <BasicTree.h>
#include <TPQueue.h>
#include <Cache.h>

#include <imagehlp.h>


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void Dump_BasicTree (

	HANDLE hCurrentProcess,
	HANDLE hCurrentThread,
	DWORD dwCurrentPc, 
	PNTSD_EXTENSION_APIS lpExtensionApis,
	LPSTR lpArgumentString
)
{
	try
	{
		DWORD t_HeapLocation = 0 ;
		DWORD t_ScanValue = 0 ;

		if ( ! sscanf ( lpArgumentString , "%8lx" , & t_HeapLocation ) ) 
		{
			lpExtensionApis->lpOutputRoutine("Error in input\n");
			return 	;
		}

		lpExtensionApis->lpOutputRoutine("Dumping WmiBasicTree %lx\n", t_HeapLocation);

#if 0
		HEAP t_Heap ;
		ZeroMemory ( & t_Heap , sizeof ( t_Heap ) ) ;

		BOOL t_BoolStatus = ReadProcessMemory (

			hCurrentProcess, 
			( void * ) t_HeapLocation , 
			& t_Heap , 
			sizeof ( t_Heap ) , 
			NULL
		) ;

		if ( t_BoolStatus )
		{
			HEAP_SEGMENT t_Segment ;
			ZeroMemory ( & t_Segment , sizeof ( t_Segment ) ) ;

			t_BoolStatus = ReadProcessMemory (

				hCurrentProcess, 
				( void * ) t_Heap.Segments [ t_SegmentIndex ] , 
				& t_Segment , 
				sizeof ( t_Segment ) , 
				NULL
			) ;

			if ( t_BoolStatus )
			{
				if (lpExtensionApis->lpCheckControlCRoutine() != 0)
				{
					// CTRL-C pressed
					lpExtensionApis->lpOutputRoutine("CTRL-C pressed\n");
					break ;
				}
			}
			else
			{
				lpExtensionApis->lpOutputRoutine("Could not read segment \n");
			}
		}
		else
		{
			lpExtensionApis->lpOutputRoutine("Could not read heap \n");
		}
#endif

	}
	catch ( ... )
	{
			lpExtensionApis->lpOutputRoutine("Catch\n");
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void Dump_ThreadCallStack (

	HANDLE hCurrentProcess,
	HANDLE hCurrentThread,
	DWORD dwCurrentPc, 
	PNTSD_EXTENSION_APIS lpExtensionApis,
	LPSTR lpArgumentString
)
{
    DWORD                             MachineType = IMAGE_FILE_MACHINE_I386 ;

	BOOL t_Status = SymInitialize (

		hCurrentProcess,
		NULL,
		TRUE
	);

	if ( t_Status )
	{
		PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine = NULL ;
		PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine = NULL ;
		PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine = NULL ;
		PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress = NULL ;

		CONTEXT	ContextRecord ;
		ZeroMemory ( & ContextRecord , sizeof ( ContextRecord ) ) ;
		ContextRecord.ContextFlags = CONTEXT_FULL ;
		GetThreadContext ( hCurrentThread , & ContextRecord ) ;

		// Set up the starting stack frame.
		// ================================

		STACKFRAME StackFrame ;
		ZeroMemory ( & StackFrame , sizeof ( StackFrame ) ) ;

		StackFrame.AddrPC.Offset       = ContextRecord.Eip;
		StackFrame.AddrPC.Mode         = AddrModeFlat;
		StackFrame.AddrStack.Offset    = ContextRecord.Esp;
		StackFrame.AddrStack.Mode      = AddrModeFlat;
		StackFrame.AddrFrame.Offset    = ContextRecord.Ebp;
		StackFrame.AddrFrame.Mode      = AddrModeFlat;

		t_Status = StackWalk (

				MachineType,
				hCurrentProcess,
				hCurrentThread,
				& StackFrame,
				& ContextRecord,
				ReadMemoryRoutine,
				FunctionTableAccessRoutine,
				GetModuleBaseRoutine,
				TranslateAddress
		);

		while ( t_Status ) 
		{
			t_Status = StackWalk (

				MachineType,
				hCurrentProcess,
				hCurrentThread,
				& StackFrame,
				& ContextRecord,
				ReadMemoryRoutine,
				FunctionTableAccessRoutine,
				GetModuleBaseRoutine,
				TranslateAddress
			);

			if ( t_Status )
			{
				DWORD Displacement;

				BYTE t_Array [ 1024 ];
				IMAGEHLP_SYMBOL *SymbolInfo = ( IMAGEHLP_SYMBOL * ) t_Array ;
				ZeroMemory ( SymbolInfo , sizeof ( SymbolInfo ) ) ;

				SymbolInfo->SizeOfStruct = 1024 ;
				SymbolInfo->MaxNameLength = 128 ;

				BOOL t_SymStatus = SymGetSymFromAddr ( 

						hCurrentProcess, 
						StackFrame.AddrPC.Offset, 
						&Displacement, 
						SymbolInfo
				) ;

				char t_Buffer [ 1024 ] ;

				sprintf ( t_Buffer , "%08x %08x ", StackFrame.AddrFrame.Offset, StackFrame.AddrReturn.Offset );

				lpExtensionApis->lpOutputRoutine(t_Buffer);

				if ( t_SymStatus )
				{
					sprintf( t_Buffer , "%s\n", SymbolInfo->Name );
				}
				else
				{
					sprintf( t_Buffer , "0x%08x\n", StackFrame.AddrPC.Offset );
				}

				lpExtensionApis->lpOutputRoutine(t_Buffer);
			}
		}
	}
	else
	{
		lpExtensionApis->lpOutputRoutine("Failed to initialize");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\debuggerextension\wmiexts\utils.cpp ===
#include <precomp.h>

DWORD WaitOnProcess( TCHAR *szExe, TCHAR *szParams, bool bHidden/*=true*/, bool bWait/*=true*/)
{
	STARTUPINFO si;
    PROCESS_INFORMATION pi;
    BOOL bRet;
    DWORD dwExitCode=STILL_ACTIVE;


    ZeroMemory(&si,sizeof(si));
    si.cb=sizeof(si);

    bRet=CreateProcess(szExe,szParams,NULL,NULL,NULL,
		((bHidden)?DETACHED_PROCESS:CREATE_NEW_CONSOLE),NULL,NULL,&si,&pi);

	//wait until done
	//===============

	if (bRet && bWait)
	{
		while(dwExitCode==STILL_ACTIVE)
		{
			Sleep(100); //don't be a pig
			GetExitCodeProcess(pi.hProcess,&dwExitCode);
		}

		CloseHandle(pi.hThread);
		CloseHandle(pi.hProcess);
	}
	else
	{
		dwExitCode=(bRet)?0:1;
	}

    return dwExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\debuggerextension\wmiexts\utils.h ===
#ifndef _UTILS_H_
#define _UTILS_H_

DWORD WaitOnProcess( TCHAR *szExe, TCHAR *szParams, bool bHidden=true, bool bWait=true); 

#endif /*_UTILS_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\debuggerextension\wmiexts\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
#include <ntobapi.h>
#include <ntpsapi.h>
#include <ntexapi.h>


#define _WINNT_	// have what is needed from above
#define NOWINBASEINTERLOCK

#include <windows.h>
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <tchar.h>
#include <ntsdexts.h>

#include <heap.h>
#include <heappriv.h>

#include "wmiext.h"
#include "utils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\debuggerextension\wmiexts\wmiext.h ===
#ifndef WMIEXT_H_
#define WMIEXT_H_ 

extern "C" void wmiver(HANDLE,
							      HANDLE,
								  DWORD, 
								  PNTSD_EXTENSION_APIS,
								  LPSTR);


extern "C" void telescope(HANDLE,
								     HANDLE,
								     DWORD, 
								     PNTSD_EXTENSION_APIS,
								     LPSTR);

extern "C" void mem(HANDLE,
							   HANDLE,
							   DWORD, 
							   PNTSD_EXTENSION_APIS,
							   LPSTR);

extern "C" void hpfwd (HANDLE,
							   HANDLE,
							   DWORD, 
							   PNTSD_EXTENSION_APIS,
							   LPSTR);


extern "C" void tstack (HANDLE,
							   HANDLE,
							   DWORD, 
							   PNTSD_EXTENSION_APIS,
							   LPSTR);


extern "C" void ststack (HANDLE,
							   HANDLE,
							   DWORD, 
							   PNTSD_EXTENSION_APIS,
							   LPSTR);


extern "C" void heapentry (HANDLE,
							   HANDLE,
							   DWORD, 
							   PNTSD_EXTENSION_APIS,
							   LPSTR);

extern "C" void heapsegments (HANDLE,
							   HANDLE,
							   DWORD, 
							   PNTSD_EXTENSION_APIS,
							   LPSTR);


extern "C" void scanheapsegments (HANDLE,
							   HANDLE,
							   DWORD, 
							   PNTSD_EXTENSION_APIS,
							   LPSTR);


#endif /*WMIEXT_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\precomp.h ===
#pragma warning (disable : 4786)
// #include <windows.h>
#include <objidl.h>
extern long g_cLock;
extern long g_cObj;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\stdafx.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STDAFX.CPP

History:

--*/

// stdafx.cpp : source file that includes just the standard includes
//	WMIparse.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information
#include "precomp.h"
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\debuggerextension\wmiexts\wmiext.cpp ===
#include <precomp.h>
#include "Container.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL APIENTRY DllMain (

	HANDLE hModule, 
    DWORD  ul_reason_for_call, 
    LPVOID lpReserved
)
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }

    return TRUE;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void help(
	
	HANDLE hCurrentProcess,
	HANDLE hCurrentThread,
	DWORD dwCurrentPc, 
	PNTSD_EXTENSION_APIS lpExtensionApis,
	LPSTR lpArgumentString
)
{
	lpExtensionApis->lpOutputRoutine("Help \n");
	lpExtensionApis->lpOutputRoutine("------------ \n");
    lpExtensionApis->lpOutputRoutine("wmiver - display version of wmi\n") ;
	lpExtensionApis->lpOutputRoutine("mem - print memory consumption\n") ;
	lpExtensionApis->lpOutputRoutine("hpfwd Address(%%lx) [Count(%%d)] - dump heap memory\n") ;
	lpExtensionApis->lpOutputRoutine("tstack - dump thread stack information\n") ;
	lpExtensionApis->lpOutputRoutine("ststack Address(%%lx) - search thread stack for address\n") ;
	lpExtensionApis->lpOutputRoutine("heapentry Address(%%lx) - dump heap entry information\n") ;
	lpExtensionApis->lpOutputRoutine("heapsegments Address(%%lx) - dump heap segment \n") ;
	lpExtensionApis->lpOutputRoutine("scanheapsegments Address(%%lx),DWORD(%%lx) - scan heap segment for DWORD hex value \n") ;
	lpExtensionApis->lpOutputRoutine("------------ \n");
	lpExtensionApis->lpOutputRoutine("End Help \n");
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

//========================
// output the wbem version
//========================

void wmiver(
	
	HANDLE hCurrentProcess,
	HANDLE hCurrentThread,
	DWORD dwCurrentPc, 
	PNTSD_EXTENSION_APIS lpExtensionApis,
	LPSTR lpArgumentString
)
{
	HKEY hCimomReg;
	wchar_t szWbemVersion[100];
	DWORD dwSize = 100;

    DWORD lResult=RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\WBEM"), 
						NULL, KEY_READ, &hCimomReg);

    if (lResult==ERROR_SUCCESS) 
	{
		lResult=RegQueryValueEx(hCimomReg, _T("Build"), NULL, NULL, 
						(unsigned char *)szWbemVersion, &dwSize);

		RegCloseKey(hCimomReg);
	}

	if(lResult==ERROR_SUCCESS)
	{
		lpExtensionApis->lpOutputRoutine("\nWMI build %s is installed.\n\n",szWbemVersion);
	}
	else
	{
		lpExtensionApis->lpOutputRoutine("\nHKLM\\SOFTWARE\\Microsoft\\WBEM\\BUILD registry key not found!\n\n");
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

//====================================
//Connect to telescope\debug as smsadmin 
//====================================

void telescope(HANDLE hCurrentProcess,
					   HANDLE hCurrentThread,
					   DWORD dwCurrentPc, 
					   PNTSD_EXTENSION_APIS lpExtensionApis,
					   LPSTR lpArgumentString)
{
	lpExtensionApis->lpOutputRoutine("\nConnecting to telescope\\debug for source... ");
	
	//construct paths first
	//=====================

	TCHAR szFirst[MAX_PATH+100],szSecond[MAX_PATH+100];

	GetSystemDirectory(szFirst,MAX_PATH);

	_tcscat(szFirst,_T("\\net.exe"));
	_tcscpy(szSecond,szFirst);
	_tcscat(szSecond,_T(" use \\\\telescope\\debug /u:wmilab\\wmiadmin wbemlives!")); 

	//now net use to mermaid\debug
	//============================

	DWORD dwRes=WaitOnProcess(szFirst,szSecond,false);	

	if (0==dwRes)
	{
		lpExtensionApis->lpOutputRoutine("Succeeded!\n");
	}
	else
	{
		lpExtensionApis->lpOutputRoutine("Failed!\n");
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

//=======================
//Give memory information
//=======================

void mem(HANDLE hCurrentProcess,
					HANDLE hCurrentThread,
					DWORD dwCurrentPc, 
					PNTSD_EXTENSION_APIS lpExtensionApis,
					LPSTR lpArgumentString)
{
	MEMORYSTATUS mem;
	memset(&mem, 0, sizeof(MEMORYSTATUS));
	mem.dwLength = sizeof(MEMORYSTATUS);

	GlobalMemoryStatus(&mem);

    lpExtensionApis->lpOutputRoutine("Total memory = %d mb / "
									 "Available memory = %d mb\n",
									 (mem.dwTotalPageFile+mem.dwTotalPhys)/(1 << 20),
									 (mem.dwAvailPageFile+mem.dwAvailPhys)/(1 << 20));
}


#define SafeGetMem(addr,size) (IsBadReadPtr(addr,size) ? 0xffffff : *((DWORD *)addr))

void hpfwd (HANDLE hCurrentProcess,
					HANDLE hCurrentThread,
					DWORD dwCurrentPc, 
					PNTSD_EXTENSION_APIS lpExtensionApis,
					LPSTR lpArgumentString)
{

	DWORD membuffer[32];
	

	DWORD addr, nextaddr, tempaddr;
	DWORD startemaddr, farmemaddr, closememaddr;
	int count = -1;
	int i = 0, j= 0, k;

	BOOL success;
	bool doloop = true;
	char *cpos = lpArgumentString;
	
	// const int maxlooplen = 1000;
	const int shortloop = 10;

	// Get args

	while (cpos && (*cpos == ' '))
		cpos++;

	if ((cpos == NULL) || (strlen(cpos) == 0))
	{
		lpExtensionApis->lpOutputRoutine("Usage: hpfwd addr [count]\n");
		return;
	}

	sscanf (cpos ,"%x", &addr);

	if ((cpos = strchr(cpos,' ')) != NULL)
	{
		while (cpos && (*cpos == ' '))
			cpos++;

		count = atoi(cpos);
	}

	addr = (lpExtensionApis->lpGetExpressionRoutine)(lpArgumentString);
    if (!addr) 
	{
		(lpExtensionApis->lpOutputRoutine)( "Invalid Expression." );
		return;
	}

	lpExtensionApis->lpOutputRoutine("Dumping heaplist\nAddr  = %x\n",addr);
	if (count != -1)
		lpExtensionApis->lpOutputRoutine("count = %d\n",count);

	lpExtensionApis->lpOutputRoutine("=============================================\n");

	startemaddr = closememaddr = farmemaddr = addr;

	while (doloop)
	{
		// dump table

		lpExtensionApis->lpOutputRoutine("0 (reading from %08x)\n",addr);

		//(lpExtensionApis->lpReadProcessMemoryRoutine)((DWORD)addr,
		//											 membuffer,
		//											 4 /* sizeof(membuffer) */,
        //                                             NULL);

		success = ReadProcessMemory (hCurrentProcess,
			(void *)addr,
			membuffer,
			sizeof(membuffer),
            NULL);

		if (!success)
		{
			lpExtensionApis->lpOutputRoutine("Error reading process memory\n");
		}

		for (k=0;k<8;k++)
		{
			tempaddr = (DWORD)(membuffer + k * 4);
			
			lpExtensionApis->lpOutputRoutine("%08x  %08x %08x %08x %08x\n",
				((DWORD *)addr)+k*4,
				*(DWORD *)tempaddr, 
				*(((DWORD *)tempaddr)+1), 
				*(((DWORD *)tempaddr)+2), 
				*(((DWORD *)tempaddr)+3));
		}

		lpExtensionApis->lpOutputRoutine("---------------------------------------------\n");


		if (IsBadReadPtr(membuffer,4))
		{
			lpExtensionApis->lpOutputRoutine("Invalid fwd pointer\n");
			break;
		}

		nextaddr = *(DWORD *)membuffer;

		if (nextaddr == startemaddr)
		{
			// end detectded
			lpExtensionApis->lpOutputRoutine("End of list (pointer to first elem)\n");

			// doloop = false;
			break;
		}

		if ((nextaddr == closememaddr) || (nextaddr == farmemaddr))
		{
			// loop detectded
			lpExtensionApis->lpOutputRoutine("Loop detected !\n");

			// doloop = false;
			break;
		}
		

		if ((++j % 2) == 0)
		{
			j = 0;

			//lpExtensionApis->lpReadProcessMemoryRoutine((DWORD)farmemaddr,
			//										     (void *)tempaddr,
			//										     4,
            //                                             NULL);

			success = ReadProcessMemory (hCurrentProcess,
										(void *)farmemaddr,
										(void *)&tempaddr,
										4,
										NULL);

			farmemaddr = tempaddr;
			
		}

		if ((j % shortloop) == 0)
		{
			closememaddr = addr;
		}

		if (++i == count)
		{
			lpExtensionApis->lpOutputRoutine("Maximum count reached\n");
			doloop = false;
		}

		addr = nextaddr;

		if (lpExtensionApis->lpCheckControlCRoutine() != 0)
		{
			// CTRL-C pressed
			lpExtensionApis->lpOutputRoutine("CTRL-C pressed\n");
			doloop = false;
		}

	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void tstack (

	HANDLE hCurrentProcess,
	HANDLE hCurrentThread,
	DWORD dwCurrentPc, 
	PNTSD_EXTENSION_APIS lpExtensionApis,
	LPSTR lpArgumentString
)
{
	try
	{
		lpExtensionApis->lpOutputRoutine("Dumping thread stack\n");

		THREAD_BASIC_INFORMATION t_ThreadInformation ;
		ZeroMemory ( & t_ThreadInformation , sizeof ( t_ThreadInformation ) ) ;

		NTSTATUS t_Status = NtQueryInformationThread ( 

			hCurrentThread ,
			ThreadBasicInformation ,
			& t_ThreadInformation ,
			sizeof ( t_ThreadInformation ) ,
			NULL 			
		) ;

		if ( NT_SUCCESS ( t_Status ) )
		{
			PTEB t_Teb = t_ThreadInformation.TebBaseAddress ;
			PTEB t_TebAllocation = ( PTEB ) malloc ( sizeof ( TEB ) ) ;
			ZeroMemory ( t_TebAllocation , sizeof ( TEB ) ) ;

			DWORD t_Length = 0 ;
			BOOL t_BoolStatus = ReadProcessMemory (

				hCurrentProcess, 
				t_Teb, 
				t_TebAllocation, 
				sizeof ( TEB ) , 
				& t_Length
			) ;

			if ( t_BoolStatus )
			{
				NT_TIB t_TIBAllocation ;
				ZeroMemory ( & t_TIBAllocation , sizeof ( t_TIBAllocation ) ) ;

				t_BoolStatus = ReadProcessMemory (

					hCurrentProcess, 
					& t_Teb->NtTib, 
					& t_TIBAllocation, 
					sizeof ( t_TIBAllocation ) , 
					NULL
				) ;

				if ( t_BoolStatus )
				{
					DWORD t_StackBase = ( DWORD ) t_TIBAllocation.StackBase ;
					DWORD t_StackLimit = ( DWORD ) t_TIBAllocation.StackLimit ;

					CLIENT_ID t_ClientId ;
					ZeroMemory ( & t_ClientId, sizeof ( t_ClientId ) ) ;

					t_BoolStatus = ReadProcessMemory (

						hCurrentProcess, 
						& t_Teb->ClientId, 
						& t_ClientId, 
						sizeof ( t_ClientId ) , 
						NULL
					) ;

					if ( t_BoolStatus )
					{
						lpExtensionApis->lpOutputRoutine("\tThread [%lx.%lx]\n", t_ClientId.UniqueProcess, t_ClientId.UniqueThread ) ;
						lpExtensionApis->lpOutputRoutine("\tTeb [%lx]\n", t_Teb ) ;
						lpExtensionApis->lpOutputRoutine("\tStackBase [%lx]\n", t_StackBase ) ;
						lpExtensionApis->lpOutputRoutine("\tStackLimit[%lx]\n", t_StackLimit ) ;

						DWORD t_Columns = 0 ;

						DWORD t_StackIndex = t_StackLimit ;
						while ( t_StackIndex < t_StackBase ) 
						{
							DWORD t_StackLocation = 0 ;

							t_BoolStatus = ReadProcessMemory (

								hCurrentProcess, 
								( void * ) t_StackIndex , 
								& t_StackLocation , 
								sizeof ( t_StackLocation ) , 
								NULL
							) ;

							if ( t_BoolStatus )
							{
								if ( t_Columns % 4 == 0 )
								{							
									lpExtensionApis->lpOutputRoutine (

										"\n%08x  %08x",
										t_StackIndex,
										t_StackLocation
									);
								}
								else
								{
									lpExtensionApis->lpOutputRoutine (

										" %08x",
										t_StackLocation
									) ;
								}
							}
							else
							{
								if ( t_Columns % 4 == 0 )
								{							
									lpExtensionApis->lpOutputRoutine (

										"\n%08x  ????????",
										t_StackIndex
									);
								}
								else
								{
									lpExtensionApis->lpOutputRoutine (

										" ????????"
									) ;
								}
							}

							t_Columns ++ ;
							t_StackIndex += 4 ;
		
							if (lpExtensionApis->lpCheckControlCRoutine() != 0)
							{
								// CTRL-C pressed
								lpExtensionApis->lpOutputRoutine("CTRL-C pressed\n");
								break ;
							}
						}

						lpExtensionApis->lpOutputRoutine (

							"\n"
						) ;

					}
				}

				free ( t_TebAllocation ) ;
			}
		}

	}
	catch ( ... )
	{
			lpExtensionApis->lpOutputRoutine("Catch\n");
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void ststack (

	HANDLE hCurrentProcess,
	HANDLE hCurrentThread,
	DWORD dwCurrentPc, 
	PNTSD_EXTENSION_APIS lpExtensionApis,
	LPSTR lpArgumentString
)
{
	try
	{
		DWORD t_FindLocation = 0 ;
		if ( ! sscanf ( lpArgumentString , "%8lx" , & t_FindLocation ) )
		{
			lpExtensionApis->lpOutputRoutine("Error in input\n");
			return 	;
		}
		
		lpExtensionApis->lpOutputRoutine("Search thread stack for %lx\n", t_FindLocation);

		THREAD_BASIC_INFORMATION t_ThreadInformation ;
		ZeroMemory ( & t_ThreadInformation , sizeof ( t_ThreadInformation ) ) ;

		NTSTATUS t_Status = NtQueryInformationThread ( 

			hCurrentThread ,
			ThreadBasicInformation ,
			& t_ThreadInformation ,
			sizeof ( t_ThreadInformation ) ,
			NULL 			
		) ;

		if ( NT_SUCCESS ( t_Status ) )
		{
			PTEB t_Teb = t_ThreadInformation.TebBaseAddress ;
			PTEB t_TebAllocation = ( PTEB ) malloc ( sizeof ( TEB ) ) ;
			ZeroMemory ( t_TebAllocation , sizeof ( TEB ) ) ;

			DWORD t_Length = 0 ;
			BOOL t_BoolStatus = ReadProcessMemory (

				hCurrentProcess, 
				t_Teb, 
				t_TebAllocation, 
				sizeof ( TEB ) , 
				& t_Length
			) ;

			if ( t_BoolStatus )
			{
				NT_TIB t_TIBAllocation ;
				ZeroMemory ( & t_TIBAllocation , sizeof ( t_TIBAllocation ) ) ;

				t_BoolStatus = ReadProcessMemory (

					hCurrentProcess, 
					& t_Teb->NtTib, 
					& t_TIBAllocation, 
					sizeof ( t_TIBAllocation ) , 
					NULL
				) ;

				if ( t_BoolStatus )
				{
					DWORD t_StackBase = ( DWORD ) t_TIBAllocation.StackBase ;
					DWORD t_StackLimit = ( DWORD ) t_TIBAllocation.StackLimit ;

					CLIENT_ID t_ClientId ;
					ZeroMemory ( & t_ClientId, sizeof ( t_ClientId ) ) ;

					t_BoolStatus = ReadProcessMemory (

						hCurrentProcess, 
						& t_Teb->ClientId, 
						& t_ClientId, 
						sizeof ( t_ClientId ) , 
						NULL
					) ;

					if ( t_BoolStatus )
					{
						lpExtensionApis->lpOutputRoutine("\tThread [%8lx.%8lx]\n", t_ClientId.UniqueProcess, t_ClientId.UniqueThread ) ;
						lpExtensionApis->lpOutputRoutine("\tTeb [%8lx]\n", t_Teb ) ;
						lpExtensionApis->lpOutputRoutine("\tStackBase [%8lx]\n", t_StackBase ) ;
						lpExtensionApis->lpOutputRoutine("\tStackLimit[%8lx]\n", t_StackLimit ) ;

						DWORD t_Columns = 0 ;

						DWORD t_StackIndex = t_StackLimit ;
						while ( t_StackIndex < t_StackBase ) 
						{
							DWORD t_StackLocation = 0 ;

							t_BoolStatus = ReadProcessMemory (

								hCurrentProcess, 
								( void * ) t_StackIndex , 
								& t_StackLocation , 
								sizeof ( t_StackLocation ) , 
								NULL
							) ;

							if ( t_BoolStatus )
							{
								if ( t_StackLocation == t_FindLocation )
								{
									lpExtensionApis->lpOutputRoutine (

										"\n%08lx",
										t_StackIndex
									);
								}
							}

							t_StackIndex += 4 ;
		
							if (lpExtensionApis->lpCheckControlCRoutine() != 0)
							{
								// CTRL-C pressed
								lpExtensionApis->lpOutputRoutine("CTRL-C pressed\n");
								break ;
							}
						}

						lpExtensionApis->lpOutputRoutine (

							"\n"
						) ;

					}
				}

				free ( t_TebAllocation ) ;
			}
		}

	}
	catch ( ... )
	{
			lpExtensionApis->lpOutputRoutine("Catch\n");
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void heapentry (

	HANDLE hCurrentProcess,
	HANDLE hCurrentThread,
	DWORD dwCurrentPc, 
	PNTSD_EXTENSION_APIS lpExtensionApis,
	LPSTR lpArgumentString
)
{
	try
	{
		DWORD t_HeapEntryLocation = 0 ;
		if ( ! sscanf ( lpArgumentString , "%8lx" , & t_HeapEntryLocation ) )
		{
			lpExtensionApis->lpOutputRoutine("Error in input\n");
			return 	;
		}
		
		lpExtensionApis->lpOutputRoutine("Dumping Heap Entry %lx\n", t_HeapEntryLocation);

		HEAP_ENTRY t_Entry ;

		BOOL t_BoolStatus = ReadProcessMemory (

			hCurrentProcess, 
			( void * ) t_HeapEntryLocation , 
			& t_Entry , 
			sizeof ( t_Entry ) , 
			NULL
		) ;

		if ( t_BoolStatus )
		{
			DWORD t_Size = t_Entry.Size << HEAP_GRANULARITY_SHIFT ;
			DWORD t_PreviousSize = t_Entry.PreviousSize << HEAP_GRANULARITY_SHIFT ;
			DWORD t_SegmentIndex = t_Entry.SegmentIndex ;
			DWORD t_UnusedBytes = t_Entry.UnusedBytes ;
			DWORD t_Flags = t_Entry.Flags ;

			DWORD t_PreviousHeapEntryLocation = t_HeapEntryLocation - t_PreviousSize ;
			DWORD t_NextHeapEntryLocation = t_HeapEntryLocation + t_Size ;

			lpExtensionApis->lpOutputRoutine("Segment           [%8lx]\n", t_SegmentIndex );
			lpExtensionApis->lpOutputRoutine("Size              [%8lx]\n", t_Size );
			lpExtensionApis->lpOutputRoutine("Previous Size     [%8lx]\n", t_PreviousSize );
			lpExtensionApis->lpOutputRoutine("Unused Bytes      [%8lx]\n", t_UnusedBytes );

			if ( t_PreviousSize ) 
			{
				lpExtensionApis->lpOutputRoutine("Previous Entry    [%8lx]\n", t_PreviousHeapEntryLocation );
			}
			else
			{
				lpExtensionApis->lpOutputRoutine("First Entry\n");
			}

			if ( t_Flags & HEAP_ENTRY_LAST_ENTRY )
			{
				lpExtensionApis->lpOutputRoutine("Last Entry\n");
			}
			else
			{
				lpExtensionApis->lpOutputRoutine("Next Entry       [%8lx]\n", t_NextHeapEntryLocation );
			}

			lpExtensionApis->lpOutputRoutine("\n");

			if ( t_Flags & HEAP_ENTRY_VIRTUAL_ALLOC )
			{
				lpExtensionApis->lpOutputRoutine("Virtual Allocation \n");
			}
			else
			{
				if ( t_Flags & HEAP_ENTRY_BUSY ) 
				{
					lpExtensionApis->lpOutputRoutine("Busy\n");

					if ( t_Flags & HEAP_ENTRY_EXTRA_PRESENT )
					{
						lpExtensionApis->lpOutputRoutine("Extra Present\n");
					}
				}
				else
				{
					lpExtensionApis->lpOutputRoutine("Free\n");

					if ( t_Flags & HEAP_ENTRY_EXTRA_PRESENT )
					{
						lpExtensionApis->lpOutputRoutine("Extra Present\n");
					}
				}
			}

			if ( t_Flags & HEAP_ENTRY_FILL_PATTERN )
			{
				lpExtensionApis->lpOutputRoutine("Fill Pattern\n");
			}

			if ( t_Flags & HEAP_ENTRY_SETTABLE_FLAG1 )
			{
				lpExtensionApis->lpOutputRoutine("Settable1\n");
			}

			if ( t_Flags & HEAP_ENTRY_SETTABLE_FLAG2 )
			{
				lpExtensionApis->lpOutputRoutine("Settable2\n");
			}
		
			if ( t_Flags & HEAP_ENTRY_SETTABLE_FLAG3 )
			{
				lpExtensionApis->lpOutputRoutine("Settable3\n");
			}
		}
		else
		{
			lpExtensionApis->lpOutputRoutine("Could not read heap entry\n");
		}
	}
	catch ( ... )
	{
			lpExtensionApis->lpOutputRoutine("Catch\n");
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

BOOL getentry (

	HANDLE hCurrentProcess,
	HANDLE hCurrentThread,
	DWORD dwCurrentPc, 
	PNTSD_EXTENSION_APIS lpExtensionApis,
	LPSTR lpArgumentString ,
	HEAP_ENTRY *t_HeapEntryLocation ,
	HEAP_ENTRY &t_Entry
)
{
	BOOL t_BoolStatus = FALSE ;

	try
	{
		t_BoolStatus = ReadProcessMemory (

			hCurrentProcess, 
			( void * ) t_HeapEntryLocation , 
			& t_Entry , 
			sizeof ( t_Entry ) , 
			NULL
		) ;

		if ( t_BoolStatus )
		{
		}
		else
		{
			lpExtensionApis->lpOutputRoutine("Could not read heap entry\n");
		}
	}
	catch ( ... )
	{
			lpExtensionApis->lpOutputRoutine("Catch\n");
	}

	return t_BoolStatus ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

struct UnCommittedRanges {

	DWORD m_Size ;
	DWORD m_Address ;
} ;

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

UnCommittedRanges *getuncommitted (

	HANDLE hCurrentProcess,
	HANDLE hCurrentThread,
	DWORD dwCurrentPc, 
	PNTSD_EXTENSION_APIS lpExtensionApis,
	LPSTR lpArgumentString ,
	HEAP *a_HeapLocation ,
	HEAP &a_Heap ,	
	HEAP_SEGMENT *a_SegmentLocation ,
	HEAP_SEGMENT &a_Segment ,
	DWORD a_SegmentIndex ,
	DWORD &a_Size ,
	BOOL a_Scanning 
)
{
	UnCommittedRanges *t_Buffer = NULL ;

	a_Size = a_Segment.NumberOfUnCommittedRanges ;

	if ( ! a_Scanning )
	{
		lpExtensionApis->lpOutputRoutine("\tNumber of Un Committed Ranges - %lx\n" , a_Segment.NumberOfUnCommittedRanges );
	}

	if ( a_Segment.NumberOfUnCommittedRanges )
	{
		t_Buffer = ( UnCommittedRanges * ) malloc (

			a_Segment.NumberOfUnCommittedRanges * sizeof ( UnCommittedRanges )
		) ;

		if ( t_Buffer )
		{
			BOOL t_RangeIndex = 0 ;

			HEAP_UNCOMMMTTED_RANGE *t_RangeLocation = a_Segment.UnCommittedRanges ;

			while ( t_RangeLocation != NULL) 
			{
				HEAP_UNCOMMMTTED_RANGE t_Range ;
				ZeroMemory ( & t_Range , sizeof ( t_Range ) ) ;

				BOOL t_BoolStatus = ReadProcessMemory (

					hCurrentProcess, 
					( void * ) t_RangeLocation , 
					& t_Range , 
					sizeof ( t_Range ) , 
					NULL
				) ;

				if ( t_BoolStatus )
				{
					if ( ! a_Scanning )
					{
						lpExtensionApis->lpOutputRoutine("\tUnCommitted Range - %lx,%lx\n" , t_Range.Address , t_Range.Size );
					}

					t_Buffer [ t_RangeIndex ].m_Address = t_Range.Address ;
					t_Buffer [ t_RangeIndex ].m_Size = t_Range.Size ;
					t_RangeLocation = t_Range.Next ;
				}
				else
				{
					lpExtensionApis->lpOutputRoutine("Failure\n" ) ;
					break ;
				}

				t_RangeIndex ++ ;
			}
		}
	}

	if ( ! a_Scanning )
	{
		lpExtensionApis->lpOutputRoutine("\n" ) ;
	}

	return t_Buffer ;

}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void dumpsegment (

	HANDLE hCurrentProcess,
	HANDLE hCurrentThread,
	DWORD dwCurrentPc, 
	PNTSD_EXTENSION_APIS lpExtensionApis,
	LPSTR lpArgumentString ,
	HEAP *a_HeapLocation ,
	HEAP &a_Heap ,	
	HEAP_SEGMENT *a_SegmentLocation ,
	HEAP_SEGMENT &a_Segment ,
	DWORD a_SegmentIndex ,
	BOOL a_Scanning ,
	DWORD a_ScanValue
)
{
	if ( ! a_Scanning )
	{
		lpExtensionApis->lpOutputRoutine("\n\tSegment Info %lx , %lx , %lx\n", a_SegmentIndex , a_HeapLocation , a_SegmentLocation );
	}

	DWORD t_UnCommittedSize = 0 ;
	UnCommittedRanges *t_UnCommitted = getuncommitted (

		hCurrentProcess,
		hCurrentThread,
		dwCurrentPc, 
		lpExtensionApis,
		lpArgumentString ,
		a_HeapLocation ,
		a_Heap ,	
		a_SegmentLocation ,
		a_Segment ,
		a_SegmentIndex ,
		t_UnCommittedSize ,
		a_Scanning 
	) ;

	if ( ! a_Scanning ) 
	{
		lpExtensionApis->lpOutputRoutine("\n\t\tDumping Segment Ranges\n\n" ) ;
	}

	HEAP_ENTRY *t_CurrentEntryLocation = a_Segment.FirstEntry ;

	DWORD t_UnCommittedIndex = 0 ;

	DWORD t_StartRange = ( DWORD ) t_CurrentEntryLocation ;

	while ( t_CurrentEntryLocation && t_CurrentEntryLocation < a_Segment.LastValidEntry )
	{
		HEAP_ENTRY t_Entry ;
		ZeroMemory ( & t_Entry , sizeof ( t_Entry ) ) ;

		BOOL t_Status = getentry ( 

			hCurrentProcess,
			hCurrentThread,
			dwCurrentPc, 
			lpExtensionApis,
			lpArgumentString ,
			t_CurrentEntryLocation ,
			t_Entry
		) ;

		if ( t_Status )
		{
			DWORD t_Size = t_Entry.Size << HEAP_GRANULARITY_SHIFT ;
			DWORD t_PreviousSize = t_Entry.PreviousSize << HEAP_GRANULARITY_SHIFT ;
			DWORD t_SegmentIndex = t_Entry.SegmentIndex ;
			DWORD t_UnusedBytes = t_Entry.UnusedBytes ;
			DWORD t_Flags = t_Entry.Flags ;

			DWORD t_PreviousHeapEntryLocation = ( DWORD ) t_CurrentEntryLocation - t_PreviousSize ;
			DWORD t_NextHeapEntryLocation = ( DWORD ) t_CurrentEntryLocation + t_Size ;

/*
 *	Search for ScanAddress
 */

			if ( a_Scanning ) 
			{
				DWORD t_HeapLocation = ( DWORD ) t_CurrentEntryLocation ;
				while ( t_HeapLocation < t_NextHeapEntryLocation )
				{
					DWORD t_HeapValue = 0;

					BOOL t_BoolStatus = ReadProcessMemory (

						hCurrentProcess, 
						( void * ) t_HeapLocation , 
						& t_HeapValue , 
						sizeof ( t_HeapValue ) , 
						NULL
					) ;

					if ( t_BoolStatus )
					{
						if ( t_HeapValue == a_ScanValue )
						{
							lpExtensionApis->lpOutputRoutine (

								"\t\t\t%08lx @ Heap Entry [%8lx]\n", 
								t_HeapLocation ,
								t_CurrentEntryLocation
							);
						}
					}
					else
					{
						break ;
					}

					t_HeapLocation ++ ;

					if (lpExtensionApis->lpCheckControlCRoutine() != 0)
					{
						// CTRL-C pressed
						lpExtensionApis->lpOutputRoutine("CTRL-C pressed\n");
						break ;
					}
				}
			}

			if ( t_Flags & HEAP_ENTRY_LAST_ENTRY )
			{
				if ( ! a_Scanning ) 
				{
					lpExtensionApis->lpOutputRoutine(

						"\t\t\tValid Range %lx , %lx\n" ,
						t_StartRange ,
						t_NextHeapEntryLocation - 1
					) ;
				}

/*
 *	An uncommitted range must have an proceeding ( also preceeding HEAP_ENTRY ), otherwise it hasn't been coalaesced.
 */

				if (	t_UnCommitted && 
						( t_UnCommittedIndex < t_UnCommittedSize ) &&
						( ( DWORD ) t_UnCommitted [ t_UnCommittedIndex ].m_Address == ( DWORD ) t_NextHeapEntryLocation ) 
				)
				{
					if ( ! a_Scanning ) 
					{
						lpExtensionApis->lpOutputRoutine("\t\t\tUnCommitted %lx , %lx \n" , t_UnCommitted [ t_UnCommittedIndex ].m_Address , t_UnCommitted [ t_UnCommittedIndex ].m_Size );
					}

					t_CurrentEntryLocation = ( HEAP_ENTRY * ) ( t_UnCommitted [ t_UnCommittedIndex ].m_Address + t_UnCommitted [ t_UnCommittedIndex ].m_Size ) ; 
					t_StartRange = ( DWORD ) t_CurrentEntryLocation ;
					t_UnCommittedIndex ++ ;
				}
				else
				{
					break ;
				}
			}
			else
			{
				t_CurrentEntryLocation = ( HEAP_ENTRY * ) t_NextHeapEntryLocation ;
			}

			if (lpExtensionApis->lpCheckControlCRoutine() != 0)
			{
				// CTRL-C pressed
				lpExtensionApis->lpOutputRoutine("CTRL-C pressed\n");
				break ;
			}

		}
	}

	if ( t_UnCommitted )
	{
		free ( t_UnCommitted ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void privateheapsegments (

	HANDLE hCurrentProcess,
	HANDLE hCurrentThread,
	DWORD dwCurrentPc, 
	PNTSD_EXTENSION_APIS lpExtensionApis,
	LPSTR lpArgumentString ,
	BOOL a_Scanning 
)
{
	try
	{
		DWORD t_HeapLocation = 0 ;
		DWORD t_ScanValue = 0 ;

		if ( ! a_Scanning )
		{
			if ( ! sscanf ( lpArgumentString , "%8lx" , & t_HeapLocation ) ) 
			{
				lpExtensionApis->lpOutputRoutine("Error in input\n");
				return 	;
			}
		}
		else
		{
			if ( ! sscanf ( lpArgumentString , "%8lx %8lx" , & t_HeapLocation , & t_ScanValue ) )
			{
				lpExtensionApis->lpOutputRoutine("Error in input\n");
				return 	;
			}
		}
		
		if ( a_Scanning )
		{
			lpExtensionApis->lpOutputRoutine("Scanning Heap %lx for %lx \n", t_HeapLocation , t_ScanValue );
		}
		else
		{
			lpExtensionApis->lpOutputRoutine("Dumping Heap %lx\n", t_HeapLocation);
		}

		HEAP t_Heap ;
		ZeroMemory ( & t_Heap , sizeof ( t_Heap ) ) ;

		BOOL t_BoolStatus = ReadProcessMemory (

			hCurrentProcess, 
			( void * ) t_HeapLocation , 
			& t_Heap , 
			sizeof ( t_Heap ) , 
			NULL
		) ;

		if ( t_BoolStatus )
		{
			for ( DWORD t_SegmentIndex = 0 ; t_SegmentIndex < HEAP_MAXIMUM_SEGMENTS ; t_SegmentIndex ++ )
			{
				if ( t_Heap.Segments [ t_SegmentIndex ] )
				{
					HEAP_SEGMENT t_Segment ;
					ZeroMemory ( & t_Segment , sizeof ( t_Segment ) ) ;

					t_BoolStatus = ReadProcessMemory (

						hCurrentProcess, 
						( void * ) t_Heap.Segments [ t_SegmentIndex ] , 
						& t_Segment , 
						sizeof ( t_Segment ) , 
						NULL
					) ;

					if ( t_BoolStatus )
					{
						dumpsegment (

							hCurrentProcess,
							hCurrentThread,
							dwCurrentPc, 
							lpExtensionApis,
							lpArgumentString ,
							( HEAP * ) t_HeapLocation ,
							t_Heap ,
							t_Heap.Segments [ t_SegmentIndex ] ,
							t_Segment ,
							t_SegmentIndex ,
							a_Scanning ,
							t_ScanValue 
						) ;

						if (lpExtensionApis->lpCheckControlCRoutine() != 0)
						{
							// CTRL-C pressed
							lpExtensionApis->lpOutputRoutine("CTRL-C pressed\n");
							break ;
						}
					}
					else
					{
						lpExtensionApis->lpOutputRoutine("Could not read segment \n");
					}
				}
			}
		}
		else
		{
			lpExtensionApis->lpOutputRoutine("Could not read heap \n");
		}
	}
	catch ( ... )
	{
			lpExtensionApis->lpOutputRoutine("Catch\n");
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void heapsegments (

	HANDLE hCurrentProcess,
	HANDLE hCurrentThread,
	DWORD dwCurrentPc, 
	PNTSD_EXTENSION_APIS lpExtensionApis,
	LPSTR lpArgumentString
)
{
	try
	{
		privateheapsegments (

			hCurrentProcess,
			hCurrentThread,
			dwCurrentPc, 
			lpExtensionApis,
			lpArgumentString ,
			FALSE 
		) ;
	}
	catch ( ... )
	{
			lpExtensionApis->lpOutputRoutine("Catch\n");
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void scanheapsegments (

	HANDLE hCurrentProcess,
	HANDLE hCurrentThread,
	DWORD dwCurrentPc, 
	PNTSD_EXTENSION_APIS lpExtensionApis,
	LPSTR lpArgumentString
)
{
	try
	{
		privateheapsegments (

			hCurrentProcess,
			hCurrentThread,
			dwCurrentPc, 
			lpExtensionApis,
			lpArgumentString ,
			TRUE
		) ;
	}
	catch ( ... )
	{
			lpExtensionApis->lpOutputRoutine("Catch\n");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\stdafx.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STDAFX.H

History:

--*/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//
#ifndef _STDAFX_H_
#define _STDAFX_H_

// #define PSH_WIZARD97 PSH_WIZARD
// #define RBBS_GRIPPERALWAYS 0

#undef _WINDOWS_

#include <afxres.h>
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>			// MFX Ole stuff
#include <afxtempl.h>	    // MFC template collection classes.

#include <parser.h>

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\resource.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    RESOURCE.H

History:

--*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WMIPARSE.RC
//
#define IDS_WMI_DESC                    12700
#define IDS_WMI_NO_ERROR                12701
#define IDS_WMI_OOM                     12702
#define IDS_WMI_CANT_LOAD_SOURCE        12703
#define IDS_WMI_CANT_OPEN_TARGET        12704
#define IDS_WMI_NO_OPEN_FILE            12705
#define IDS_WMI_NOT_MOF_FILE            12706
#define IDS_WMI_CANT_WRITE_FILE         12707
#define IDS_WMI_SYNTAX                  12708
#define IDS_WMI_HANDLER_ERROR           12709
#define IDS_WMI_UNKNOWN_ERROR           12710
#define IDS_WMI_PARSER_DESC             12711
#define IDS_WMI_BAD_FILE                12712
#define IDS_WMI_NO_MEMORY               12713
#define IDS_WMI_UNICODE_ERROR           12714
#define IDS_WMI_EXCEPTION               12715
#define IDS_WMI_GENERIC_LOCATION        12716
#define IDS_WMI_FULL_CONTEXT            12717
#define IDS_WMI_LINE_ERROR              12718
#define IDS_WMI_VAL_HOTKEY              12750
#define IDS_WMI_VAL_BAD_CHARS           12751
#define IDS_OPT_DESC                    12752
#define IDS_OPT_HELP                    12753
#define IDS_DISABLE_WATERMARKING_BOOL   12754
#define IDS_DISABLE_WATERMARKING_BOOL_HELP 12755

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\wmiclass.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WMICLASS.CPP

History:

--*/

//  
//  Implementation file for the WMI MOF parser IClassFactory object.
//  
#include "precomp.h"
#include "stdafx.h"


#include "WMIparse.h"
#include "resource.h"
#include "WMIlprs.h"

#include "WMIclass.h"


CWMILocClassFactory::CWMILocClassFactory()
{
	m_uiRefCount = 0;

	AddRef();
	IncrementClassCount();
}


#ifdef _DEBUG

void
CWMILocClassFactory::AssertValid(void)
		const
{
	CLObject::AssertValid();
}



void
CWMILocClassFactory::Dump(
		CDumpContext &dc)
		const
{
	CLObject::Dump(dc);
}

#endif // _DEBUG


ULONG
CWMILocClassFactory::AddRef(void)
{
	return ++m_uiRefCount;
}



ULONG
CWMILocClassFactory::Release(void)
{
	LTASSERT(m_uiRefCount != 0);
	
	m_uiRefCount--;
	
	if (m_uiRefCount == 0)
	{
		delete this;
		return 0;
	}

	return m_uiRefCount;
}



HRESULT
CWMILocClassFactory::QueryInterface(
		REFIID iid,
		LPVOID *ppvObj)
{
	SCODE sc = E_NOINTERFACE;

	*ppvObj = NULL;
	
	if (iid == IID_IUnknown)
	{
		*ppvObj = (IUnknown *)this;
		sc = S_OK;
	}
	else if (iid == IID_IClassFactory)
	{
		*ppvObj = (IClassFactory *)this;
		sc = S_OK;
	}
	
	if (sc == S_OK)
	{
		AddRef();
	}
	return ResultFromScode(sc);
}



HRESULT
CWMILocClassFactory::CreateInstance(
		LPUNKNOWN pUnknown,
		REFIID iid,
		LPVOID *ppvObj)
{
	SCODE sc = E_UNEXPECTED;

	*ppvObj = NULL;
	
	if (pUnknown != NULL)
	{
		sc = CLASS_E_NOAGGREGATION;
	}
	else
	{
		try
		{
			CWMILocParser *pParser;

			pParser = new CWMILocParser;

			sc = pParser->QueryInterface(iid, ppvObj);

			pParser->Release();
		}
		catch (CMemoryException *pMemoryException)
		{
			sc = E_OUTOFMEMORY;
			pMemoryException->Delete();
		}
	}

	return ResultFromScode(sc);
}



HRESULT
CWMILocClassFactory::LockServer(
		BOOL)
{
	return E_NOTIMPL;
}



CWMILocClassFactory::~CWMILocClassFactory()
{
	LTASSERT(m_uiRefCount == 0);
	DEBUGONLY(AssertValid());

	DecrementClassCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\wmiclass.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WMICLASS.H

History:

--*/


#ifndef WMICLASS_H
#define WMICLASS_H

class CWMILocClassFactory : public IClassFactory, public CLObject
{
public:
	CWMILocClassFactory();

#ifdef _DEBUG
	void AssertValid(void) const;
	void Dump(CDumpContext &) const;
#endif
	
	STDMETHOD_(ULONG, AddRef)(); 
	STDMETHOD_(ULONG, Release)(); 
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);

	STDMETHOD(CreateInstance)(THIS_ LPUNKNOWN, REFIID, LPVOID *);
	STDMETHOD(LockServer)(THIS_ BOOL);

	~CWMILocClassFactory();
	
private:
	UINT m_uiRefCount;
	
};


#endif // WMICLASS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\wmilfile.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WMILFILE.CPP

Abstract:

    Implementation of CWmiLocFile, the MOF parser for Localization Studio

History:

--*/
#include "precomp.h"
#include "stdafx.h"
#include <buildnum.h>
#include <helpids.h>

#include "WMIparse.h"
#include "resource.h"
#include "WMIlprs.h"


#include "WMIlfile.h"

#include <malloc.h>

//*****************************************************************************
//
//  CWMILocFile::CWMILocFile
//
//*****************************************************************************

CWMILocFile::CWMILocFile(
		ILocParser *pParentClass)
{
	//
	// C.O.M. initialization
	//
	m_pParentClass = pParentClass;
    m_sCurrentNamespace = "";
	m_ulRefCount = 0;

	//
	//  WMI file initialization
	//
	m_uiLineNumber = 0;
	m_pOpenSourceFile = NULL;
	m_pOpenTargetFile = NULL;

	AddRef();
	IncrementClassCount();
}

//*****************************************************************************
//
//  CWMILocFile::GetFileDescriptions
//
//*****************************************************************************

void CWMILocFile::GetFileDescriptions(
		CEnumCallback &cb)
{
	EnumInfo eiFileInfo;
	CLString strDesc;
	
	eiFileInfo.szAbbreviation = NULL;

	LTVERIFY(strDesc.LoadString(g_hDll, IDS_WMI_DESC));

	eiFileInfo.szDescription = (const TCHAR *)strDesc;
	eiFileInfo.ulValue = ftWMIFileType;

	cb.ProcessEnum(eiFileInfo);
}

//*****************************************************************************
//
//  CWMILocFile::AddRef
//
//*****************************************************************************

ULONG CWMILocFile::AddRef(void)
{
	if (m_pParentClass != NULL)
	{
		m_pParentClass->AddRef();
	}
	
	return m_ulRefCount++;
}

//*****************************************************************************
//
//  CWMILocFile::Release
//
//*****************************************************************************

ULONG CWMILocFile::Release(void)
{
	LTASSERT(m_ulRefCount != 0);

	if (m_pParentClass != NULL)
	{
		
		m_pParentClass->Release();
	}

	m_ulRefCount--;
	if (m_ulRefCount == 0)
	{
		delete this;
		return 0;
	}
	
	return m_ulRefCount;
}

//*****************************************************************************
//
//  CWMILocFile::QueryInterface
//
//*****************************************************************************

HRESULT CWMILocFile::QueryInterface(
		REFIID iid,
		LPVOID *ppvObj)
{
	if (m_pParentClass != NULL)
	{
		return m_pParentClass->QueryInterface(iid, ppvObj);
	}
	else
	{
		SCODE scRetVal = E_NOINTERFACE;

		*ppvObj = NULL;
		
		if (iid == IID_IUnknown)
		{
			*ppvObj = (IUnknown *)this;
			scRetVal = S_OK;
		}
		else if (iid == IID_ILocFile)
		{
			*ppvObj = (ILocFile *)this;
			scRetVal = S_OK;
		}

		if (scRetVal == S_OK)
		{
			AddRef();
		}
		return ResultFromScode(scRetVal);
	}
}

//*****************************************************************************
//
//  CWMILocFile::AssertValidInterface
//
//*****************************************************************************

void CWMILocFile::AssertValidInterface(void)
		const
{
	AssertValid();
}

//*****************************************************************************
//
//  CWMILocFile::OpenFile
//
//*****************************************************************************

BOOL CWMILocFile::OpenFile(
		const CFileSpec &fsFile,
		CReporter &Reporter)
{
	LTTRACEPOINT("OpenFile()");
	
	BOOL fRetCode;
	
	LTASSERT(m_pOpenTargetFile == NULL);
	fRetCode = FALSE;

	m_didFileId = fsFile.GetFileId();
	m_pstrFileName = fsFile.GetFileName();
	
	if (m_pOpenSourceFile != NULL)
	{
        fclose(m_pOpenSourceFile);
		m_pOpenSourceFile = NULL;
	}

    // We are just going to open the file.
    // and save the handle.
    // ===================================
	
	try
	{

		m_pOpenSourceFile = fopen(_T(m_pstrFileName), "rb");

		if (!m_pOpenSourceFile)
		{			
			fclose(m_pOpenSourceFile);
			m_pOpenSourceFile = NULL;
		}
        else
        {           
            fRetCode = TRUE;
        }

    }
	catch (CMemoryException *pMemoryException)
	{
		CLString strContext;

		strContext.LoadString(g_hDll, IDS_WMI_GENERIC_LOCATION);
		
		Reporter.IssueMessage(esError, strContext, g_hDll, IDS_WMI_NO_MEMORY,
				g_locNull);

		pMemoryException->Delete();
	}
	return fRetCode;
}

//*****************************************************************************
//
//  CWMILocFile::GetFileType
//
//*****************************************************************************

FileType CWMILocFile::GetFileType(void)
		const
{
	//
	//  Just return some number that isn't ftUnknown...
	//
	return ftWMIFileType;
}

//*****************************************************************************
//
//  CWMILocFile::GetFileTypeDescription
//
//*****************************************************************************

void CWMILocFile::GetFileTypeDescription(
		CLString &strDesc)
		const
{
	LTVERIFY(strDesc.LoadString(g_hDll, IDS_WMI_DESC));
	
	return;
}


//*****************************************************************************
//
//  CWMILocFile::GetAssociatedFiles
//
//*****************************************************************************

BOOL CWMILocFile::GetAssociatedFiles(
		CStringList &lstFiles)
		const
{
	LTASSERT(lstFiles.GetCount() == 0);
	
	lstFiles.RemoveAll();
	return FALSE;
}

//*****************************************************************************
//
//  CWMILocFile::EnumerateFile
//
//*****************************************************************************

BOOL CWMILocFile::EnumerateFile(
		CLocItemHandler &ihItemHandler,
		const CLocLangId &lid,
		const DBID &dbidFileId)
{
    BOOL bRet = TRUE;
    DBID dbidThisId = dbidFileId;

	LTTRACEPOINT("EnumerateFile()");
	
	if (m_pOpenSourceFile == NULL)
	{
		return FALSE;
	}

    // Enumerate file will need to:
    // * Parse the MOF.
    // * Walk through all qualifiers.  For each "Amended" qualifier, 
    //   send back a CLocItem whose key is namespace, class, property and qualifier name.
    // * Fail if the language ID does not match that of LocaleID.
    // * Parent objects are namespaces, classes
    // =============================================================

	m_cpSource = lid.GetCodePage(cpAnsi);
    m_wSourceId = lid.GetLanguageId();

    ihItemHandler.SetProgressIndicator(0);	

    bRet = ReadLines(ihItemHandler, dbidFileId, FALSE);

	return bRet;
}

//*****************************************************************************
//
//  CWMILocFile::GenerateFile
//
//*****************************************************************************

BOOL CWMILocFile::GenerateFile(
		const CPascalString &pstrTargetFile,
		CLocItemHandler &ihItemHandler,
		const CLocLangId &lidSource,
		const CLocLangId &lidTarget,
		const DBID &dbidParent)
{
	LTASSERT(m_pOpenTargetFile == NULL);
	BOOL fRetVal = TRUE;

	if (m_pOpenSourceFile== NULL)
	{
		return FALSE;
	}
    // Generate File needs to:
    // * Parse the MOF.
    // * Walk through all qualifiers.  For each "Amended" qualifier,
    //   send back a CLocItem whose key is namespace, class, property and qualifier name.
    // * Replace all Amended qualifiers with localized text
    // * Replace all occurrences of the locale ID in namespaces and qualifiers
    //   with the new one.
    // =================================================================================
    
	m_cpSource = lidSource.GetCodePage(cpAnsi);
	m_cpTarget = lidTarget.GetCodePage(cpAnsi);

    m_wSourceId = lidSource.GetLanguageId();
    m_wTargetId = lidTarget.GetLanguageId();
    	
	try
	{
		CFileException excFile;
		fRetVal = FALSE;
		
		if (m_pOpenTargetFile != NULL)
		{
			fclose(m_pOpenTargetFile);
			m_pOpenTargetFile = NULL;
		}

        char FileName[255];
        strcpy(FileName, _bstr_t(_T(pstrTargetFile)));

        // This file must be in Unicode.
        HANDLE hFile = CreateFile(FileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL,
            CREATE_ALWAYS, 0, NULL);
	    if(hFile != INVALID_HANDLE_VALUE)
	    {
		    unsigned char cUnicodeHeader[2] = {0xff, 0xfe};
		    DWORD dwWrite;
            WriteFile(hFile, cUnicodeHeader, 2, &dwWrite, NULL);
            CloseHandle(hFile);
	    }      
	
		m_pOpenTargetFile = fopen(FileName, "ab");

		if (!m_pOpenTargetFile)
		{			
			fclose(m_pOpenTargetFile);
			m_pOpenTargetFile = NULL;
		}
        else
        {
            fRetVal = TRUE;
        }
	}
	catch (CMemoryException *pMemoryException)
	{
		CLString strContext;
		GetFullContext(strContext);
		
		ihItemHandler.IssueMessage(esError, strContext, g_hDll, IDS_WMI_NO_MEMORY,
				g_locNull);

		pMemoryException->Delete();
	}
	catch (CFileException *pFileException)
	{		
		fclose(m_pOpenTargetFile);
		fRetVal = FALSE;

		ReportFileError((const WCHAR *)pstrTargetFile, m_didFileId, pFileException, ihItemHandler);

		pFileException->Delete();
	}

	if (!fRetVal)
	{
		return fRetVal;
	}
			
	fRetVal = ReadLines(ihItemHandler, dbidParent, TRUE);
	
	fclose(m_pOpenTargetFile);

	if (!fRetVal)
	{
		DeleteFileW (pstrTargetFile);
	}

	return fRetVal;
}

//*****************************************************************************
//
//  CWMILocFile::GenerateItem
//
//*****************************************************************************

BOOL CWMILocFile::GenerateItem(
		CLocItemHandler &ihItemHandler,
		CLocItemSet &isItemSet,
        wchar_t **pOutBuffer,
        UINT &uiStartingPos)
{

	BOOL fRetVal = TRUE;
    UINT uiLength;

    wchar_t *pTemp = *pOutBuffer;

    _bstr_t sQualifierValue;

    // If nothing has changed, we can just
    // ignore this line.

    fRetVal = GetQualifierValue(pTemp, uiStartingPos, sQualifierValue, uiLength);
    if (fRetVal)
    {
        fRetVal = ihItemHandler.HandleItemSet(isItemSet);
		if (fRetVal)
		{
            sQualifierValue = "";
            for (int i = 0; i < isItemSet.GetSize(); i++)
            {			
				CVC::ValidationCode vcRetVal;
				CLocItem *pLocItem = isItemSet[i];
				CLString strContext;
 				CLocation loc;
				
				GetFullContext(strContext);
				loc.SetGlobalId(
						CGlobalId(pLocItem->GetMyDatabaseId(), otResource));
				loc.SetView(vTransTab);
				
				CPascalString pstrId, pstrText;
			
				pLocItem->GetUniqueId().GetResId().GetId(pstrId);
				pstrText = pLocItem->GetLocString().GetString();
                
                if (i > 0)
                    sQualifierValue += L"\",\"";

                sQualifierValue += (const wchar_t *)pstrText;
            }

            // Set it live in the buffer.  We are not going to 
            // write it to the file until the very end.

            fRetVal = SetQualifierValue(pTemp, pOutBuffer, uiStartingPos, sQualifierValue, uiLength);				
            pTemp = *pOutBuffer;

        }

    }		
    
	return fRetVal;
}
	


//*****************************************************************************
//
//  CWMILocFile::EnumerateItem
//
//*****************************************************************************

BOOL CWMILocFile::EnumerateItem(
		CLocItemHandler &ihItemHandler,
		CLocItemSet &isItemSet)
{
	BOOL fRetVal;
	
	if (isItemSet.GetSize() != 0)
	{
		fRetVal = ihItemHandler.HandleItemSet(isItemSet);
	}
	else
	{
		fRetVal = TRUE;
	}

	return fRetVal;
}



#ifdef _DEBUG

//*****************************************************************************
//
//  CWMILocFile::AssertValid
//
//*****************************************************************************

void CWMILocFile::AssertValid(void)
		const
{
	CLObject::AssertValid();
}

//*****************************************************************************
//
//  CWMILocFile::Dump
//
//*****************************************************************************

void CWMILocFile::Dump(
		CDumpContext &dc)
		const
{
	CLObject::Dump(dc);
}

#endif

//*****************************************************************************
//
//  CWMILocFile::~CWMILocFile
//
//*****************************************************************************

CWMILocFile::~CWMILocFile()
{
	DEBUGONLY(AssertValid());

	if (m_pOpenSourceFile != NULL)
	{
        fclose(m_pOpenSourceFile);
		m_pOpenSourceFile = NULL;
	}

	DecrementClassCount();
}

//*****************************************************************************
//
//  CWMILocFile::SetFlags
//
//*****************************************************************************

void CWMILocFile::SetFlags(
		CLocItem *pItem,
		CLocString &lsString)
		const
{
	ULONG ulItemType;

	pItem->SetFDevLock(FALSE);
	pItem->SetFUsrLock(FALSE);
	pItem->SetFExpandable(FALSE);
	
	LTVERIFY(pItem->GetUniqueId().GetTypeId().GetId(ulItemType));
	
	switch (ulItemType)
	{
	case wltNamespaceName:
		pItem->SetFDisplayable(TRUE);
		pItem->SetFNoResTable(TRUE);
		break;

	case wltClassName:
	case wltPropertyName:
		pItem->SetFDisplayable(FALSE);
		pItem->SetFNoResTable(FALSE);
		lsString.SetCodePageType(cpAnsi);
		lsString.SetStringType(CST::Text);
		break;

	default:
		LTASSERT(FALSE && "Unexpected item type!");
	}
}

//*****************************************************************************
//
//  CWMILocFile::ReadLines
//
//*****************************************************************************

BOOL CWMILocFile::ReadLines(
		CLocItemHandler &ihItemHandler,
		const DBID &dbidFileId,
		BOOL fGenerating)
{
	DBID dbidSectionId;
	BOOL fRetVal = TRUE;
	wchar_t *pstrNamespaceName;
    _bstr_t pstrClassName;
    UINT uiStartPos = 0;

	UINT uiCommentNum;
	UINT uiReadingOrder;

	dbidSectionId = dbidFileId;
	m_uiLineNumber = 0;
    BOOL bPendingObj = FALSE;

	
	try
	{
		UINT uiOldPercentage = 0, uiNewPercentage = 0;
        UINT uiBytesRead, uiCurrPos = 1;

        ihItemHandler.SetProgressIndicator(uiOldPercentage);
   
        fseek(m_pOpenSourceFile, 0, SEEK_END);
        long lSize = ftell(m_pOpenSourceFile) + 6;
        fseek(m_pOpenSourceFile, 0, SEEK_SET);

        // Check for UNICODE source file.
        // ==============================

        BYTE UnicodeSignature[2];
        BOOL bUnicode = FALSE;        

        if (fread(UnicodeSignature, sizeof(BYTE), 2, m_pOpenSourceFile) != 2)
        {
            fRetVal = FALSE;
            return fRetVal;
        }
        if ((UnicodeSignature[0] == 0xFF && UnicodeSignature[1] == 0xFE) ||
            (UnicodeSignature[0] == 0xFE && UnicodeSignature[1] == 0xFF))
        {
            bUnicode = TRUE;
            lSize *= 2;
        }
        if (!bUnicode)
            fseek(m_pOpenSourceFile, 0, SEEK_SET);

        wchar_t *pBuff = (wchar_t *)new wchar_t[lSize+1];        
        if (!pBuff)
        {
            fRetVal = FALSE;
            return fRetVal;
        }
        memset(pBuff,0,lSize*sizeof(wchar_t));

        // If this is not a Unicode file,
        // we need to perform a conversion.
        // =====================================

        if (bUnicode)
            uiBytesRead = fread(pBuff, sizeof(wchar_t), lSize, m_pOpenSourceFile);           
        else
        {
            char *pCharBuff = new char[lSize+1];
            if (pCharBuff)
            {
                uiBytesRead = fread(pCharBuff, sizeof(char), lSize, m_pOpenSourceFile);
                pCharBuff[lSize] = '\0';
                swprintf(pBuff, L"%S", pCharBuff);
                delete pCharBuff;
            }
        }
        pBuff[lSize] = '\0';

        if (uiBytesRead != 0)
        {
            wchar_t *pOutBuffer = NULL;
            uiCurrPos += uiBytesRead;
		    fRetVal = TRUE;
		    
		    pstrNamespaceName = NULL;
            m_sCurrentNamespace = L"";
            pstrClassName = L"";

		    uiCommentNum = 0;
		    uiReadingOrder = 1;
	
			WMIFileError wmiRet;
			CLocItemSet isItemSet;
            UINT uiTemp = 0;
            DWORD dwCount = 0;
			
            // If we are generating a file, make a copy
            // of the outbound buffer.

            if (fGenerating)
                pOutBuffer = pBuff;

            while (GetNextQualifierPos(L"amended", pBuff, uiTemp, uiTemp) && !bPendingObj)
            {			    
                // If we have found the "amended" keyword,
                // we want to find the namespace,
                // class, and property if applicable, and
                // generate the object as appropriate.
                // ======================================

                pstrNamespaceName = GetCurrentNamespace(pBuff, uiTemp);
                if (!pstrNamespaceName || !wcslen(pstrNamespaceName))
                {
                    delete pBuff;
                    return FALSE;
                }
                if (wcscmp(pstrNamespaceName, m_sCurrentNamespace))
                {
                    // We need to generate this object,
                    // and set it up as the current parent.
                    // ====================================

                    CLocItem *pNewItem = new CLocItem;
                    CPascalString sId;

                    if (pNewItem)
                    {

               			CLocUniqueId uid;
                        sId = (const WCHAR *)pstrNamespaceName;

                        uid.GetResId().SetId(sId);	
			            uid.GetTypeId().SetId(wltNamespaceName);
                        uid.SetParentId(dbidFileId);
            			pNewItem->SetUniqueId(uid);
			
			            CLocString lsString;
			
			            pNewItem->SetIconType(CIT::String);			            
                        CPascalString pstrComment, pstrText;
                       		
                        pNewItem->SetInstructions(pstrComment);
                        lsString.SetString(pstrText);

			            SetFlags(pNewItem, lsString);
			            pNewItem->SetLocString(lsString);
			            
			            isItemSet.Add(pNewItem);

					    uiReadingOrder = (uiReadingOrder + 999)/1000*1000;
				        isItemSet[0]->SetDisplayOrder(uiReadingOrder);
				        uiReadingOrder++;

                        fRetVal = EnumerateItem(ihItemHandler,
                        	isItemSet);

				        dbidSectionId.Clear();			        
				        dbidSectionId = isItemSet[0]->GetMyDatabaseId();
                        isItemSet.ClearItemSet();
                        uiTemp += 1;

                    }

                    m_sCurrentNamespace = pstrNamespaceName;
                    delete pstrNamespaceName; 


                }

                // For the class name, this is trickier.
                // If there are one or more qualifiers
                // on the class itself, we need to read ahead
                // to find the class name, and then
                // generate all the qualifier objects at once.
                // ==========================================

                wmiRet = GetNextItemSet(dwCount, pBuff, isItemSet, dbidSectionId, uiStartPos);
                while (wmiRet == WMINoError)
                {
                    // For each item, we want to set its key,
                    // and push it or write it as appropriate.
                    // ========================================

                    dwCount++;
                    ULONG ulItemType;
				    CLocUniqueId &rUid = isItemSet[0]->GetUniqueId();
				    
				    rUid.GetTypeId().GetId(ulItemType);
				    //if (ulItemType == wltClassName)
				    //{
					//   uiCommentNum = 0;
					//    uiReadingOrder = (uiReadingOrder + 999)/1000*1000;
				    //}
                    for (int i = 0; i < isItemSet.GetSize(); i++)
                    {
				        isItemSet[i]->SetDisplayOrder(uiReadingOrder);
				        uiReadingOrder++;
                    }

			        if (fGenerating)
                    {
                        fRetVal = GenerateItem(ihItemHandler,
                            isItemSet, &pOutBuffer, uiStartPos);

                        if (pBuff != pOutBuffer)
                        {
                            delete pBuff;
                            pBuff = NULL;
                            pBuff = pOutBuffer; // The old memory has already been deleted.
                        }
                        else
                        {
                            fRetVal = FALSE;
                        }
                    }
                    else
			        {
				        fRetVal = EnumerateItem(ihItemHandler,
				        	isItemSet);
			        }

                    isItemSet.ClearItemSet();
                    uiTemp += 1;

                    if (!fRetVal)
                    {
                        fRetVal = TRUE;
                        break;
                    }

                    wmiRet = GetNextItemSet(dwCount, pBuff, isItemSet, dbidSectionId, uiStartPos);
                    if (uiStartPos > uiTemp)
                        uiTemp = uiStartPos;

                    if (dwCount%20 == 0)
                    {
                        if (uiNewPercentage < 100)
                            uiNewPercentage++;
                        ihItemHandler.SetProgressIndicator(uiNewPercentage);				
                    }                             
                }

                // If we were generating the file,
                // we're done.
                // ==============================
                if (fGenerating)
                    break;

                if (uiNewPercentage < 100)
                    uiNewPercentage++;
                ihItemHandler.SetProgressIndicator(uiNewPercentage);				
               
            } 
        
            uiTemp = 0;

            // Now, we get to search and replace the locale IDs,
            // and actually write out the file.
            // =================================================

            if (fRetVal && fGenerating)
            {
                fRetVal = WriteNewFile(pOutBuffer);
            }

		}

        if (pBuff)
            delete pBuff;

        ihItemHandler.SetProgressIndicator(100);

	}
	catch (CFileException *pFileException)
	{
		fRetVal = FALSE;

		ReportFileError(m_pstrFileName, m_didFileId, pFileException, ihItemHandler);

		pFileException->Delete();
	}
	catch (CUnicodeException *pUnicodeException)
	{
		CLocation loc;

		loc.SetGlobalId(CGlobalId(m_didFileId, otFile));
		loc.SetView(vProjWindow);
		
		ReportUnicodeError(pUnicodeException, ihItemHandler, loc);

		pUnicodeException->Delete();
		fRetVal = FALSE;
	}
	catch (CMemoryException *pMemoryException)
	{
		CLString strContext;
		
		ihItemHandler.IssueMessage(esError, strContext,
				g_hDll, IDS_WMI_NO_MEMORY, g_locNull);
		
		fRetVal = FALSE;

		pMemoryException->Delete();
	}
	catch (CException *pException)
	{
		CLocation loc;

		loc.SetGlobalId(CGlobalId(m_didFileId, otFile));
		loc.SetView(vProjWindow);
		
		ReportException(pException, ihItemHandler, loc);

		pException->Delete();
		fRetVal = FALSE;
	}
	return fRetVal;
}



//*****************************************************************************
//
//  CWMILocFile::WriteWaterMark
//
//*****************************************************************************

void CWMILocFile::WriteWaterMark()
{
	LTASSERT(NULL != m_pOpenTargetFile);

	LTASSERT(NULL != m_pOpenSourceFile);

    // Do we need to support this?

}

//*****************************************************************************
//
//  CWMILocFile::GetNextQualifierPos
//
//*****************************************************************************

BOOL CWMILocFile::GetNextQualifierPos(const wchar_t *wTmp, const wchar_t *pBuff, UINT &uiNewPos, UINT uiStartingPos) 
{
    BOOL bRet = FALSE;
    UINT uiPos = uiStartingPos;
    BOOL bComment = FALSE;

    if (pBuff && wcslen(pBuff) < uiStartingPos)
        return FALSE;

    wchar_t *pTemp = (wchar_t *)pBuff;
    pTemp += uiStartingPos;

    while (TRUE)
    {
        wchar_t *pszTest2 = NULL;

        pszTest2 = wcsstr(pTemp, L":");
        if (pszTest2)
        {
            uiPos = pszTest2 - pBuff + 1;

            // Look for the "amended" keyword.
            // ==============================

			WCHAR temp = pszTest2[0];
            while(temp == L' ' || temp == L'\0' || temp == L':')
            {
                pszTest2++;
				temp = pszTest2[0];
            }

            if (temp != L'\0')
            {
                wchar_t wTmp2[8];
                wcsncpy(wTmp2, pszTest2, 7);
				wTmp2[7] = '\0';
                if (!_wcsicmp(wTmp2, wTmp))
                {
                    bRet = TRUE;
                }
            }

            // If here, we found a non-match, so try again.
            // ============================================

            if (!bRet)
                pTemp = pszTest2 + 1;
            else
                break;
        }
        else
        {
            break;
        }
    }
   
    if (bRet)
        uiNewPos = uiPos;    

    return bRet;

}

//*****************************************************************************
//
//  CWMILocFile::GetCurrentNamespace
//
//*****************************************************************************

wchar_t *CWMILocFile::GetCurrentNamespace(wchar_t *pstr, UINT uPos)
{
    wchar_t *pTemp = pstr;
    _bstr_t pstrNamespace = m_sCurrentNamespace;
    UINT uiCurrPos = 0;
    BOOL bComment = FALSE;
    
    wchar_t wTmp[] = L"#pragma namespace";
    int iHCLen = wcslen(wTmp);

    // Find the first occurrence of the namespace
    // before the current position.

    if (pstrNamespace.length() > 0)
        pTemp = wcsstr(pTemp, pstrNamespace);   // Jump directly to the existing one.

    while (uiCurrPos < uPos)
    {
        wchar_t *pszTest2 = NULL;

        pszTest2 = wcsstr(pTemp, L"#");
        if (pszTest2)
        {
            // First, go back and make sure this isn't a comment line.
            // =======================================================            
            bComment = FALSE;

            wchar_t *pComment = pszTest2;
            while (pComment > pstr)
            {
                if (pComment[0] == L'\n' || pComment[0] == L'\r')
                {
                    if (pComment[1] == L'/' && pComment[2] == L'/')
                    {
                        bComment = TRUE;
                    }
                    else
                    {
                        bComment = FALSE;
                    }
                    break;
                }
                pComment--;
            }

            if (!bComment)
            {

                wchar_t wTmp2[100];
                wcsncpy(wTmp2, pszTest2, 17);
				wTmp2[17] = '\0';
                if (!_wcsicmp(wTmp2, wTmp))
                {
                    uiCurrPos += (pszTest2 - pTemp);
                    wchar_t *pszTest3 = wcschr(pszTest2, L')');

                    int iLen = (pszTest3 - pszTest2);                    
                    wchar_t *pszTmpNS = new wchar_t[iLen*2+1];
                    if (pszTmpNS)
                    {
                        pszTest2 += iHCLen + 2; // skip quote and open parent.
                        wcsncpy(pszTmpNS, pszTest2, iLen - 2); // strip quotes.
                        pszTmpNS[iLen-iHCLen-3] = '\0';
                        pstrNamespace = pszTmpNS;

                        pTemp = pszTest2 + 1;
                        delete pszTmpNS;
                    }
                }
                else
                {
                    pTemp = pszTest2 + 1;
                }
            }
            else
            {
                pTemp = pszTest2 + 1;
            }
        }
        else
        {
            break;
        }
    }

    int iLen = wcslen(pstrNamespace) ;

    wchar_t *pNew = new wchar_t[iLen*2+1];
    if (pNew)
    {
        wcsncpy(pNew, (const wchar_t *)pstrNamespace, iLen);
        pNew[iLen] = '\0';
    }

    return pNew;

}

//*****************************************************************************
//
//  CWMILocFile::GetNextItemSet
//
//*****************************************************************************

CWMILocFile::WMIFileError CWMILocFile::GetNextItemSet(
		DWORD dwCurrPos,
        const _bstr_t &pstrCurrentLine,
		CLocItemSet &aNewItem,
		const DBID &dbidSection,
        UINT &uiStartPos)		
{

    // In this function, we know there is an
    // "amended" keyword in here somewhere.
    // We want to know to which class and/or
    // property does it belong?  If we don't
    // have enough data to figure it out,
    // we need to send back a WMIIncompleteObj
    // code.  
    // ======================================
    UINT uiCurrPos = 0;
    WMIFileError feRetCode = WMINoError;
    _bstr_t sQualifierName, sRawValue, sPropName, sClassName;
    BOOL bClass = FALSE;
    int iLen = pstrCurrentLine.length() + 1;
    iLen *= 2;

    // Get the position of the keyword
    // "amended" in this chunk of text.

    wchar_t *wTemp = new wchar_t[iLen+1];
    if (!wTemp)
    {
        feRetCode = WMIOOM;
        return feRetCode;
    }

    if (GetNextQualifierPos(L"amended", pstrCurrentLine, uiCurrPos, uiStartPos))
    {
        BOOL bArray = FALSE;

        uiStartPos = uiCurrPos;
    
        // Find the qualifier name and value.   
        // wTemp = Top of File
        // wTmp2 = "Amended" keyword
        // wQfrVal = Opening bracket
        // wBkwd = floating pointer.

        wchar_t *wTmp2 = NULL, *wBkwd = NULL, *wQfrVal = NULL;

        wcscpy(wTemp, pstrCurrentLine);
        wTemp[iLen] = '\0';

        wTmp2 = wTemp;
        wTmp2 += (uiCurrPos - 1); // the "Amended" keyword.
        
        wQfrVal = FindTop(wTmp2, wTemp, bArray);

        if (!wQfrVal) // Make sure we had an open parenth
        {
            feRetCode = WMISyntaxError;
            delete wTemp;
            return feRetCode;
        }

        // Find the beginning of the qualifier name.
        wBkwd = wQfrVal;

        while (wBkwd[0] != L',' && wBkwd[0] != L'[' && wBkwd >= wTemp)
        {
            wBkwd--;
        }

        if (wBkwd[0] != L',' && wBkwd[0] != L'[') // Make sure we had a valid qualifier name.
        {
            feRetCode = WMISyntaxError;
            delete wTemp;
            return feRetCode;
        }       

        WCHAR *token;
        UINT uiLen;

        wBkwd += 1;
        
        wchar_t wTmpBuff[256];
        wcsncpy(wTmpBuff, wBkwd, wQfrVal - wBkwd);   
        wTmpBuff[wQfrVal - wBkwd] = '\0';
        sQualifierName = wTmpBuff;

        GetQualifierValue(wTemp, uiStartPos, sRawValue, uiLen);

        // Finally, populate the CLocItem.
        // ===============================
    
	    LTASSERT(aNewItem.GetSize() == 0);
	    
	    if (feRetCode == WMINoError)
	    {
		    CLocItem *pNewItem;
		    
		    try
		    {
                // Now we have a value, but it may be an 
                // array.  If so, we need to add one CLocItem
                // for each value in the array.

                VectorString arrValues;
                if (bArray)
                    ParseArray(sRawValue, arrValues);
                else
                    arrValues.push_back(sRawValue);

                for (int i = 0; i < arrValues.size(); i++)
                {               
                    wchar_t szTmp[20];
                    swprintf(szTmp, L"%ld", dwCurrPos);

                    _bstr_t sValue = arrValues.at(i);

			        pNewItem = new CLocItem;

			        CLocUniqueId uid;

                    CPascalString sTempString;

                    sTempString = sQualifierName;
                    sTempString += szTmp;
                               
			        uid.GetResId().SetId(sTempString) ;

			        if (bClass)
			            uid.GetTypeId().SetId(wltClassName);
                    else
                        uid.GetTypeId().SetId(wltPropertyName);

                    uid.SetParentId(dbidSection);				
			        pNewItem->SetUniqueId(uid);
			        
			        CLocString lsString;
                    CPascalString pstrComment, pstrText;

                    pstrText = sValue;                
                
			        pNewItem->SetIconType(CIT::String);
                    pNewItem->SetInstructions(pstrComment);
			        
                    lsString.SetString(pstrText);
			        SetFlags(pNewItem, lsString);
			        pNewItem->SetLocString(lsString);
			        
			        aNewItem.Add(pNewItem);
                }

		    }
		    catch (CMemoryException *pMemoryException)
		    {
			    feRetCode = WMIOOM;
			    
			    pMemoryException->Delete();
		    }
	    }
	    else
	    {
		    LTTRACE("Unable to process line '%ls'",
				    (const WCHAR *)pstrCurrentLine);
	    }
       
    }
    else
    {
        feRetCode = WMINoMore;
    }
    uiStartPos = uiCurrPos;


    delete wTemp;
	return feRetCode;
}

const UINT WMI_MAX_CONTEXT = 256;

//*****************************************************************************
//
//  CWMILocFile::GetFullContext
//
//*****************************************************************************

void CWMILocFile::GetFullContext(
		CLString &strContext)
		const
{
	CLString strFormat;

	strFormat.LoadString(g_hDll, IDS_WMI_FULL_CONTEXT);

	strContext.Empty();

	_sntprintf(strContext.GetBuffer(WMI_MAX_CONTEXT), WMI_MAX_CONTEXT,
			(const TCHAR *)strFormat,
			(const WCHAR *)m_pstrFileName, (UINT)m_uiLineNumber);
	strContext.ReleaseBuffer();
	
}

//*****************************************************************************
//
//  CWMILocFile::ReportFileError
//
//*****************************************************************************

void CWMILocFile::ReportFileError(
		const _bstr_t &pstrFileName,
		const DBID &didFileId,
		CFileException *pFileException,
		CReporter &Reporter)
		const
{
	CLString strContext;
	CLString strMessage;
	const UINT MAX_MESSAGE = 256;
	TCHAR szFileErrorMessage[MAX_MESSAGE];
	CLocation loc;
	
	pFileException->GetErrorMessage(szFileErrorMessage, MAX_MESSAGE);
	
	strMessage.Format(g_hDll, IDS_WMI_BAD_FILE, (const WCHAR *)pstrFileName,
			szFileErrorMessage);

	GetFullContext(strContext);
	loc.SetGlobalId(CGlobalId(didFileId, otFile));
	loc.SetView(vProjWindow);
	
	Reporter.IssueMessage(esError, strContext, strMessage, loc);
}

//*****************************************************************************
//
//  CWMILocFile::ReportUnicodeError
//
//*****************************************************************************

void CWMILocFile::ReportUnicodeError(
		CUnicodeException *pUnicodeException,
		CReporter &Reporter,
		const CLocation &Location)
		const
{
	CLString strContext;
	CLString strMessage;
	const UINT MAX_MESSAGE = 256;
	TCHAR szUnicodeErrorMessage[MAX_MESSAGE];
	CLocation loc;
	
	pUnicodeException->GetErrorMessage(szUnicodeErrorMessage, MAX_MESSAGE);
	
	strMessage.Format(g_hDll, IDS_WMI_UNICODE_ERROR, szUnicodeErrorMessage);
	GetFullContext(strContext);
	
	Reporter.IssueMessage(esError, strContext, strMessage, Location,
			IDH_UNICODE_CONV);
}

//*****************************************************************************
//
//  CWMILocFile::ReportException
//
//*****************************************************************************

void CWMILocFile::ReportException(
		CException *pException,
		CReporter &Reporter,
		const CLocation &Location)
		const
{
	CLString strContext;
	CLString strMessage;
	const UINT MAX_MESSAGE = 256;
	TCHAR szErrorMessage[MAX_MESSAGE];
	
	pException->GetErrorMessage(szErrorMessage, MAX_MESSAGE);
	
	strMessage.Format(g_hDll, IDS_WMI_EXCEPTION, szErrorMessage);
	GetFullContext(strContext);

	Reporter.IssueMessage(esError, strContext, strMessage, Location);
}

//
//  This function estimates the size of a buffer
//  required to hold a string up to something like __"}__ or __")__
//  invalid combinations are \"} and \") (there is the escape)
//  but double \\"} or \\") are valid
//

//
//
//  we will consider \\ and \" as special
//  white spaces are \r \n \t \x20
//  array of strings { "" , "" }
//  ("")

// states of the FSA modelling the parser

#define BEFORE_PAREN  0
#define AFTER_PAREN   1
#define	OPEN_QUOTE    2
#define	CLOSE_QUOTE   3
#define COMMA         4
#define	CLOSE_PAREN   5
#define	BAD           6
#define	LAST_STATE    7

// classes of characters

#define QUOTE		0
#define PAREN_OPEN  1
#define	SPACES      2
#define	PAREN_CLOSE 3
#define	COMMA_CHAR  4
#define OTHER	    5
#define	LAST_CLASS  6


DWORD g_pTable[LAST_STATE][LAST_CLASS] =
{
	/* BEFORE_PAREN */ {BAD        , AFTER_PAREN, BEFORE_PAREN, BAD,         BAD,        BAD        },
    /* AFTER_PAREN  */ {OPEN_QUOTE , BAD,         AFTER_PAREN,  BAD,         BAD,        BAD        },
	/* OPEN_QUOTE   */ {CLOSE_QUOTE, OPEN_QUOTE,  OPEN_QUOTE,   OPEN_QUOTE,  OPEN_QUOTE, OPEN_QUOTE },
	/* CLOSE_QUOTE  */ {BAD,         BAD,         CLOSE_QUOTE,  CLOSE_PAREN, COMMA,      BAD        },
	/* COMMA        */ {OPEN_QUOTE , BAD,         COMMA,        BAD,         BAD,        BAD},
	/* CLOSE_PAREN  */ {BAD, BAD,BAD,BAD,BAD,BAD },
	/* BAD          */ {BAD, BAD,BAD,BAD,BAD,BAD },
};

ULONG_PTR
Estimate(WCHAR * pBuff,BOOL * pbOK, DWORD InitState)
{
	DWORD State = InitState; 

	ULONG_PTR i=0;

	while (pBuff[i])
	{
	    switch(pBuff[i])
		{
		case L'{':
		case L'(':
			State = g_pTable[State][PAREN_OPEN];
            break;
		case L'}':
		case L')':
			State = g_pTable[State][PAREN_CLOSE];
            break;
		case L'\t':
		case L'\r':
		case L'\n':
		case L' ':
            State = g_pTable[State][SPACES];
			break;
		case L'\"':
            State = g_pTable[State][QUOTE];
            break;
		case L',':
            State = g_pTable[State][COMMA_CHAR];
            break;
		case L'\\':
			if ((pBuff[i+1] == L'\"' ||
				pBuff[i+1] == L'\\' ||
				pBuff[i+1] == L'r'  ||
				pBuff[i+1] == L'n'  ||
				pBuff[i+1] == L't' ) &&
				(State == OPEN_QUOTE)){
				i++;
            };  
			State = g_pTable[State][OTHER];
            break;
		default:
            State = g_pTable[State][OTHER];
		};
		i++;
		if (State == CLOSE_PAREN){			
			*pbOK = TRUE;
			break;
		}
	    if (State == BAD)
		{
			*pbOK = FALSE;
			//
			// get the next ) or }, and take the most far
			//
			ULONG_PTR NextClose1 = (ULONG_PTR)wcschr(&pBuff[i],L'}');
			ULONG_PTR NextClose2 = (ULONG_PTR)wcschr(&pBuff[i],L')');
			ULONG_PTR Res = (NextClose1<NextClose2)?NextClose2:NextClose1;
			if (Res){
                i = 1+(Res-(ULONG_PTR)pBuff);
				i /= sizeof(WCHAR);
			}
			break;
		}
	}

    /*
    {
      char pBuffDbg[64];
      wsprintfA(pBuffDbg,"pBuff %p Size %d\n",pBuff,(DWORD)i);
      OutputDebugStringA(pBuffDbg);
    }
    */

	return i+4;
}


//*****************************************************************************
//
//  CWMILocFile::GetQualifierValue
//
//*****************************************************************************

BOOL CWMILocFile::GetQualifierValue(wchar_t *pBuffer, UINT &uiPos, _bstr_t &sValue, UINT &uiPhysLen)
{

    // This needs to read up the text of the qualifier,
    // strip out the quotes and carriage returns, and
    // return it and its *physical* length-in-file.

    BOOL fRetVal = FALSE;
    BOOL bArray = FALSE;

    wchar_t *pTemp = pBuffer;

    pTemp += uiPos;

    pTemp = FindTop(pTemp, pBuffer, bArray);
    if (pTemp)
    {

        BOOL bOK = FALSE;
        ULONG_PTR dwSize = Estimate(pTemp,&bOK,BEFORE_PAREN);
        wchar_t * tempBuff = new WCHAR[dwSize+1];

        if (tempBuff == NULL){
            return FALSE;
        }
        
        int iCount = 0;

        pTemp++;    // Step past this character.
        uiPhysLen = 0;

        WCHAR *token = pTemp;
        BOOL bEnd = FALSE;
        while (!bEnd)
        {
            uiPhysLen++;    // Count every character.
            WCHAR *Test;

            switch(*token)
            {
            case L'\0':
                bEnd = TRUE;
                break;
            case L'\n':
            case L'\r':
            case L'\t':
                break;
            case L'\"':
                if (!iCount)
                    break;
            case L')':
            case L'}': 
                Test = token - 1;
                while (TRUE)                    
                {
                    if (*Test == L' ' || *Test == L'\r' || *Test == L'\n' || *Test == L'\t')
                    {
                        Test--;
                        continue;
                    }
                    if (*Test == L'\"')
                    {
                        Test--;
                        if (*Test != L'\\')
                        {
                            bEnd = TRUE;
                            break;
                        }
                        else
                        {
                            Test--;
                            if (*Test == L'\\')
                            {
                                bEnd = TRUE;
                                break;
                            }
                        }
                    }
                    tempBuff[iCount] = *token;
                    iCount++;
                    break;
                }
                break;
            default:
                tempBuff[iCount] = *token;
                iCount++;
                break;

            }
            token++;
        }
        if (tempBuff[iCount-1] == L'\"')
            tempBuff[iCount-1] = '\0';
        else
            tempBuff[iCount] = '\0';
        sValue = tempBuff;

        delete [] tempBuff;
        
        fRetVal = TRUE;
    }
    uiPhysLen -= 1; // We want to keep the closing parenth.

    return fRetVal;

}

//*****************************************************************************
//
//  CWMILocFile::SetQualifierValue
//
//*****************************************************************************

BOOL CWMILocFile::SetQualifierValue(wchar_t *pIn, wchar_t **pOut, UINT &uiPos, _bstr_t &sValue, UINT &uiLen, BOOL bQuotes)
{
    // This needs to write the localized qualifier value
    // and erase *uiLen* characters.
    // uiPos will need to be updated with the *new*
    // position of this qualifier.
    
    BOOL fRetVal = FALSE;
    wchar_t *pStart = pIn + uiPos;
    BOOL bArray = FALSE;

    pStart = FindTop(pStart, pIn, bArray);
    if (pStart)
    {
        int iNewLen = wcslen(sValue);
        int iLen = wcslen(pIn) + 3;
        if (iNewLen > uiLen)                // The length of the new buffer
            iLen += (iNewLen - uiLen);      // If the new value is longer, add it.

        pStart++;                                     // jump past the '(' character.  uiLen starts now.
        int iPos = pStart-pIn;                        // The current position.

        iLen *= 2;
        wchar_t *pNew = new wchar_t[iLen+3];

        if (pNew)
        {
            int iTempPos = 0;

            wcsncpy(pNew, pIn, iPos);       // Copy the initial part of the file.
            if (bQuotes)
                pNew[iPos] = '\"';             
            pNew[iPos+1] = '\0';            // Null terminate

            wcscat(pNew, sValue);           // Add the new value.

            iPos += 1 + wcslen(sValue);     // Jump past the value
            if (bQuotes)
                pNew[iPos] = '\"';
            pNew[iPos+1] = '\0';            // Null terminate the value.

            pStart += uiLen;                // Jump past the current value.
            
            iTempPos = iPos;
            iPos = wcslen(pIn) - (pStart-pIn);  // Calculate the length of the rest of the file.
            
            wcsncat(pNew, pStart, iPos);        // Append the rest of the file to the new buffer.

            pStart = pNew + iLen;
            pStart = FindPrevious(pStart, L";", pNew);
            pStart[1] = L'\r';
            pStart[2] = L'\n';
            pStart[3] = L'\0';
                      
            *pOut = pNew;

            fRetVal = TRUE;
        }
    }

    // Adjust the position.

    int iNewLen = wcslen(sValue);
    if (iNewLen < uiLen)
        uiPos -= (uiLen - iNewLen);
    else
        uiPos += (iNewLen - uiLen);
    uiPos += 3;

    return fRetVal;
}

//*****************************************************************************
//
//  CWMILocFile::WriteNewFile
//
//*****************************************************************************

BOOL CWMILocFile::WriteNewFile(wchar_t *pBuffer)
{
    // This needs to seek and replace all instances of the 
    // original Locale with the new one.
    // ===================================================

    BOOL fRetVal = FALSE, fSuccess = TRUE;
    UINT uiPos = 0, uiStartingPos = 0;
    int uiLen = wcslen(pBuffer);

    _bstr_t sThisLocale, sTargetLocale;
    wchar_t wOldCodePage[30], wNewCodePage[30];
    swprintf(wOldCodePage, L"_%X", m_wSourceId );
    swprintf(wNewCodePage, L"_%X", m_wTargetId );

    if (m_wSourceId != m_wTargetId)
    {

        wchar_t *pLocale = wcsstr(pBuffer, wOldCodePage);
        while (pLocale != NULL)
        {
            for (int i = 0; i < wcslen(wOldCodePage); i++)
            {
                pLocale[i] = wNewCodePage[i];
            }
        
            pLocale = wcsstr(pLocale, wOldCodePage);
        }

        // Now look for the locale if 
        // it was converted to a decimal.
        // ==============================

        swprintf(wOldCodePage, L"(0x%X)", m_wSourceId );
        swprintf(wNewCodePage, L"(0x%X)", m_wTargetId );

        pLocale = wcsstr(pBuffer, wOldCodePage);
        while (pLocale != NULL)
        {
            for (int i = 0; i < wcslen(wOldCodePage); i++)
            {
                pLocale[i] = wNewCodePage[i];
            }
        
            pLocale = wcsstr(pLocale, wOldCodePage);
        }

        // Now look for the locale if 
        // it was converted to a decimal.
        // ==============================

        swprintf(wOldCodePage, L"(%ld)", m_wSourceId );
        swprintf(wNewCodePage, L"(%ld)", m_wTargetId );

        pLocale = wcsstr(pBuffer, wOldCodePage);
        while (pLocale != NULL)
        {
            for (int i = 0; i < wcslen(wOldCodePage); i++)
            {
                pLocale[i] = wNewCodePage[i];
            }
        
            pLocale = wcsstr(pLocale, wOldCodePage);
        }
    }

    if (fSuccess)
    {
        fRetVal = TRUE;

        // Finally, write out the buffer to a brand new file
        // =================================================

        while (uiLen >= 0)
        {
            if (fwrite(pBuffer, sizeof(wchar_t), (uiLen > 4096) ? 4096: uiLen, m_pOpenTargetFile) < 0)
            {
                fRetVal = FALSE;
                break;
            }
            else
            {
                fRetVal = TRUE;
                pBuffer += 4096;
                uiLen -= 4096;
            }

            fflush(m_pOpenTargetFile);
        }
    }

    return fRetVal;

}

//*****************************************************************************
//
//  CWMILocFile::FindPrevious
//
//*****************************************************************************

wchar_t *CWMILocFile::FindPrevious(wchar_t *pBuffer, const wchar_t *pFind, const wchar_t *pTop)
{

    wchar_t *pRet = NULL;
    WCHAR t1, t2;
    int iLen = wcslen(pFind);
    BOOL bFound = FALSE;

    pRet = pBuffer;
    while (pRet >= pTop)
    {
        t2 = pRet[0];
        for (int i = 0; i < iLen; i++)
        {
            t1 = pFind[i];

            if (t1 == t2)
            {
                bFound = TRUE;
                break;
            }
        }
        
        if (bFound)
            break;

        pRet--;
    }

    if (pRet <= pTop)
        pRet = NULL;

    return pRet;
}

//*****************************************************************************
//
//  CWMILocFile::FindTop
//
//*****************************************************************************

wchar_t *CWMILocFile::FindTop(wchar_t *wTmp2, wchar_t *wTop, BOOL &bArray)
{

    wchar_t *wQfrVal = FindPrevious(wTmp2, L"({", wTop);        

    while (wQfrVal)
    {
        WCHAR *pQT = wQfrVal + 1;
        BOOL bFound = FALSE;

        while (TRUE)
        {
            if (*pQT != L' ' && *pQT != L'\t' && *pQT != L'\r' && *pQT != L'\n')
            {
                if (*pQT == L'\"')
                {
                    bFound = TRUE;
                }
                break;
            }
            pQT++;
        }
        
        if (!bFound)
        {
            wQfrVal --;
            wQfrVal = FindPrevious(wQfrVal, L"({", wTop);        
        }
        else
            break;
    }

    if (wQfrVal)
    {
        if (wQfrVal[0] == L'{')
            bArray = TRUE;
    }

    return wQfrVal;

}

//*****************************************************************************
//
//  CWMILocFile::ParseArray
//
//*****************************************************************************

void CWMILocFile::ParseArray(wchar_t *pIn, VectorString &arrOut)
{
    
    wchar_t *pLast = pIn;
    if (*pLast == L'\"')
        pLast++;

    BOOL bOK = FALSE;
    BOOL bAlloc = FALSE;
    ULONG_PTR qwSize = Estimate(pLast,&bOK,OPEN_QUOTE);

    wchar_t * Buff = new WCHAR[(DWORD)qwSize]; 

    if(Buff == NULL){
        Buff = (WCHAR *)_alloca((DWORD)qwSize);
    } else {
        bAlloc = TRUE;
    }
        
    wchar_t *pFind = wcsstr(pIn, L"\",");

    arrOut.clear();

    while (pFind)
    {
        wchar_t temp = pFind[-1];
        if (temp == '\\')
        { 
            pFind++;
            pFind = wcsstr(pFind, L"\",");
            continue;
        }

        wcsncpy(Buff, pLast, pFind-pLast);
        Buff[pFind-pLast] = '\0';

        arrOut.push_back(_bstr_t(Buff));

        // Now move pFind to the next valid char.

        while (pFind[0] == L'\n' || 
            pFind[0] == L'\r' ||
            pFind[0] == L' ' ||
            pFind[0] == L',' ||
            pFind[0] == L'\"' )
            pFind++;

        pLast = pFind ;
        pFind = wcsstr(pFind, L"\",");
    }

    wcscpy(Buff, pLast);
    
    if (Buff[wcslen(Buff)-1] == L'\"')
        Buff[wcslen(Buff)-1] = L'\0';   // strip off that trailing quote.
    else
        Buff[wcslen(Buff)] = L'\0';   // strip off that trailing quote.
    arrOut.push_back(_bstr_t(Buff));

    if (bAlloc) {
        delete [] Buff;
    }
    
    return;
}

//*****************************************************************************
//
//  CVC::ValidateString
//
//*****************************************************************************

CVC::ValidationCode ValidateString(
		const CLocTypeId &,
		const CLocString &clsOutputLine,
		CReporter &repReporter,
		const CLocation &loc,
		const CLString &strContext)
{
	CVC::ValidationCode vcRetVal = CVC::NoError;
	CLString strMyContext = strContext;

	if (strMyContext.GetLength() == 0)
	{
		strMyContext.LoadString(g_hDll, IDS_WMI_GENERIC_LOCATION);
	}

    loc; repReporter; clsOutputLine;
	
/*
	if (clsOutputLine.HasHotKey())
	{
		vcRetVal = CVC::UpgradeValue(vcRetVal, CVC::Warning);
		repReporter.IssueMessage(esWarning, strMyContext, g_hDll,
				IDS_WMI_VAL_HOTKEY, loc);
	}
	
	_bstr_t pstrBadChars;
	UINT uiBadPos;

	pstrBadChars.SetString(L"\n\ra", (UINT)3);
	
	if (pstrOutput.FindOneOf(pstrBadChars, 0, uiBadPos))
	{
		vcRetVal = CVC::UpgradeValue(vcRetVal, CVC::Error);

		repReporter.IssueMessage(esError, strMyContext, g_hDll,
				IDS_WMI_VAL_BAD_CHARS, loc);
	}
    */
	return vcRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\wmilprs.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WMILPRS.H

History:

--*/

#ifndef WMIPARSE_H
#define WMIPARSE_H

#define OPT_DISABLE_WATERMARKING "DisableWatermarking"

class CWMILocParser : public CPULocParser
{
public:
	CWMILocParser();
	~CWMILocParser();

// Overrides
public:
	// ILocParser
	virtual HRESULT OnInit(IUnknown *);
	virtual HRESULT OnCreateFileInstance(ILocFile * &, FileType);
	virtual void OnGetParserInfo(ParserInfo &) const;
	virtual void OnGetFileDescriptions(CEnumCallback &) const;

	// ILocVersion
	virtual void OnGetParserVersion(DWORD &dwMajor,	DWORD &dwMinor, BOOL &fDebug) const;

	// ILocStringValidation
	virtual CVC::ValidationCode OnValidateString(const CLocTypeId &ltiType,
			const CLocTranslation &trTrans, CReporter *pReporter,
			const CContext &context);

// Implementation
protected:
	void GetDefaultExtensionList(CLocExtensionList & elExtList) const;

private:
	void RegisterOptions();
	void UnRegisterOptions();

	BOOL m_fOptionInit;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\wmiparse.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WMIPARSE.H

History:

--*/

void IncrementClassCount(void);
void DecrementClassCount(void);

extern HMODULE g_hDll;
extern PUID g_puid;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\wmilprs.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WMILPRS.CPP

History:

--*/
#include "precomp.h"
#include "stdafx.h"
#include "string.h"

#include "WMIParse.h"
#include "resource.h"
#include "WMIlfile.h"
#include "WMIlprs.h"


//*****************************************************************************
//
// CWMILocParser Construction
//
//*****************************************************************************

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Constructor for CWMILocParser.
//
//-----------------------------------------------------------------------------
CWMILocParser::CWMILocParser() : CPULocParser(g_hDll)
{
	m_fOptionInit = FALSE;
	IncrementClassCount();
}


CWMILocParser::~CWMILocParser()
{
	DEBUGONLY(AssertValid());

	DecrementClassCount();

	// Remove any options
	UnRegisterOptions();
}


//*****************************************************************************
//
// CWMILocParser Overrides
//
//*****************************************************************************

///////////////////////////////////////////////////////////////////////////////
//
// ILocVersion
//
///////////////////////////////////////////////////////////////////////////////

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Reports the parser version information.
//
//-----------------------------------------------------------------------------
void 
CWMILocParser::OnGetParserVersion(
		DWORD &dwMajor,	
		DWORD &dwMinor, 
		BOOL &fDebug) const
{
	dwMajor = dwCurrentMajorVersion;
	dwMinor = dwCurrentMinorVersion;
	fDebug = fCurrentDebugMode;
}

	
///////////////////////////////////////////////////////////////////////////////
//
// ILocParser
//
///////////////////////////////////////////////////////////////////////////////

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Initializes the parser. Registers options for the WMI parser.
//
//-----------------------------------------------------------------------------
HRESULT
CWMILocParser::OnInit(
		IUnknown * pUnk
		)
{
	UNREFERENCED_PARAMETER(pUnk);

	LTASSERT(!m_fOptionInit);

	RegisterOptions();
	return ERROR_SUCCESS;
}


HRESULT
CWMILocParser::OnCreateFileInstance(
		ILocFile *&pLocFile,
		FileType ft)
{
	SCODE sc = E_INVALIDARG;

	pLocFile = NULL;

	if (ft == ftUnknown ||
		ft == ftWMIFileType)
	{
		try
		{
			pLocFile = new CWMILocFile(NULL);
			sc = S_OK;
		}
		catch (const CMemoryException *)
		{
			sc = E_OUTOFMEMORY;
		}
	}

	return ResultFromScode(sc);
}


void
CWMILocParser::OnGetParserInfo(
		ParserInfo &pi)
		const
{
	LTASSERT(pi.elExtensions.GetCount() == 0);

	pi.aParserIds.SetSize(1);
	pi.aParserIds[0].m_pid = pidWMI;
	pi.aParserIds[0].m_pidParent = pidNone;

	try
	{
		LTVERIFY(pi.strDescription.LoadString(g_hDll, IDS_WMI_PARSER_DESC));
		LTVERIFY(pi.strHelp.LoadString(g_hDll, IDS_OPT_HELP));
		
		pi.elExtensions.AddTail("MOF");
	}
	catch (CMemoryException *pe)
	{
		pi.strDescription.Empty();
		pe->Delete();
	}
}


void
CWMILocParser::OnGetFileDescriptions(
		CEnumCallback &cb)
		const
{
	CWMILocFile::GetFileDescriptions(cb);
}


///////////////////////////////////////////////////////////////////////////////
//
// ILocStringValidation
//
///////////////////////////////////////////////////////////////////////////////

CVC::ValidationCode
CWMILocParser::OnValidateString(
		const CLocTypeId &ltiType,
		const CLocTranslation &trTrans,
		CReporter *pReporter,
		const CContext &context)
{
	CLString strContext;

	DEBUGONLY(ltiType.AssertValid());
	DEBUGONLY(trTrans.AssertValid());
	LTASSERT(pReporter != NULL);
	DEBUGONLY(pReporter->AssertValid());
	
	return ::ValidateString(ltiType, trTrans.GetTargetString(), *pReporter, 
			context.GetLocation(), context.GetContext());
}


//*****************************************************************************
//
// Parser options.
//
//*****************************************************************************

// Reference count the registering of options since these are global to the
// parser.

static INT g_nOptionRegisterCount = 0;

BEGIN_LOC_UI_OPTIONS_BOOL(optsParserBools)
		LOC_UI_OPTIONS_BOOL_ENTRY(OPT_DISABLE_WATERMARKING,
				FALSE, CLocUIOption::etCheckBox,
				IDS_DISABLE_WATERMARKING_BOOL,
				IDS_DISABLE_WATERMARKING_BOOL_HELP,
				NULL, CLocUIOption::stUser | CLocUIOption::stOverride),

	END_LOC_UI_OPTIONS_BOOL();

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Register any options for the parser.
//
//-----------------------------------------------------------------------------
void
CWMILocParser::RegisterOptions()
{

	LTASSERT(g_nOptionRegisterCount >= 0);

	if (g_nOptionRegisterCount++ > 0)
	{
		// Already registered
		return;
	}

	SmartRef<CLocUIOptionSet> spOptSet;
	CLocUIOptionImpHelper OptHelp(g_hDll);
	
	spOptSet = new CLocUIOptionSetDef;
	spOptSet->SetGroupName(g_puid.GetName());
	
	OptHelp.SetBools(optsParserBools, COUNTOF(optsParserBools));

	OptHelp.GetOptions(spOptSet.GetInterface(), IDS_OPT_DESC, 
		IDS_OPT_HELP);

	//m_fOptionInit = RegisterParserOptions(spOptSet.GetInterface());

	if (m_fOptionInit)
	{
		spOptSet.Extract();
	}
}

void
CWMILocParser::UnRegisterOptions()
{
	if (m_fOptionInit)
	{
		if (--g_nOptionRegisterCount == 0)
		{
			// UnRegisterParserOptions(g_puid);		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\wmiparse.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WMIPARSE.CPP

History:

--*/
#include "precomp.h"
#include "stdafx.h"

#include "WMIclass.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

LONG g_lActiveClasses = 0;
HMODULE g_hDll;
PUID g_puid(pidWMI, pidNone);

static AFX_EXTENSION_MODULE WMIparseDLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	UNREFERENCED_PARAMETER(lpReserved);
	
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("WMIPARSE.DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(WMIparseDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(WMIparseDLL);
		g_hDll = hInstance;
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("WMIPARSE.DLL Terminating!\n");

		//
		//  If there are active classes, they WILL explode badly once the
		//  DLL is unloaded...
		//
		LTASSERT(DllCanUnloadNow() == S_OK);
		AfxTermExtensionModule(WMIparseDLL);
	}
	return 1;   // ok
}





// {74FCE960-7F7F-11ce-8311-00AA00383930}
static const CLSID ciWMIParserCLSID =
{ 0x74fce960, 0x7f7f, 0x11ce, { 0x83, 0x11, 0x0, 0xaa, 0x0, 0x38, 0x39, 0x30 } };


STDAPI_(void)
DllGetParserCLSID(
		CLSID &ciParserCLSID)
{
	ciParserCLSID = ciWMIParserCLSID;
}



STDAPI
DllRegisterParser(void)
{
	return S_OK;//RegisterParser(g_hDll);
}



STDAPI
DllUnregisterParser(void)
{
	return S_OK; //UnregisterParser(pidWMI, pidNone);
}


	
STDAPI
DllGetClassObject(
		REFCLSID cidRequestedClass,
		REFIID iid,
		LPVOID *ppClassFactory)
{
	SCODE sc = E_UNEXPECTED;

	*ppClassFactory = NULL;

	if (cidRequestedClass != ciWMIParserCLSID)
	{
		sc = CLASS_E_CLASSNOTAVAILABLE;
	}
	else
	{
		try
		{
			CWMILocClassFactory *pClassFactory;

			pClassFactory = new CWMILocClassFactory;

			sc = pClassFactory->QueryInterface(iid, ppClassFactory);

			pClassFactory->Release();
		}
		catch (CMemoryException *pMemoryException)
		{
			sc = E_OUTOFMEMORY;
			pMemoryException->Delete();
		}
	}
	
	return ResultFromScode(sc);
}

void
IncrementClassCount(void)
{
	InterlockedIncrement(&g_lActiveClasses);
}



void
DecrementClassCount(void)
{
	LTASSERT(g_lActiveClasses != 0);
	
	InterlockedDecrement(&g_lActiveClasses);
}

	   

STDAPI
DllCanUnloadNow(void)
{
	SCODE sc;
	
	sc = (g_lActiveClasses == 0) ? S_OK : S_FALSE;

	return ResultFromScode(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\buildnum.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    BUILDNUM.H

History:

--*/

//  Build number file.  This converts the SLM build numbers in PRODVER.H
//  to something a little more useful.
//  
//  This is mostly used by version stamp resoruces.  If you want the build
//  numbers, you should PROBABLY use the ones exported in PBASE (if you are
//  a parser), or function GetVersionInfo() in ESPUTIL.
//

#pragma once

#include "prodver\prodver.h"

#define stringize2(x) #x
#define stringize(x) stringize2(x)
#define frmj rmj
#define frmm rmm
#define frup rup
#define prmj rmj
#define prmm rmm
#define prup rup

#define RELEASE 

#if defined(_DEBUG)
#define ProdVerString stringize(prmj.prmm.prup (Debug) RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup (Debug) RELEASE\0)
#else
#define ProdVerString stringize(prmj.prmm.prup RELEASE\0)
#define FileVerString stringize(frmj.frmm.frup RELEASE\0)
#endif

//
//  Common version information
//
#define CompanyNameString "Microsoft Corporation\0"
#define CopyrightString "Copyright \251 1994-1998 Microsoft Corp.\0"
// copyright for command line tools
#define CopyrightStringCMD "Copyright (C) 1994-1998 Microsoft Corp. All rights reserved.\0"
#define ProductNameString "Microsoft Localization Studio\0"
#define TrademarkString  \
"Microsoft is a registered trademark of Microsoft Corporation. \
Windows(TM) is a trademark of Microsoft Corporation.\0"

#define TIMESTAMP stringize(__TIME__\0)
#define DATESTAMP stringize(__DATE__\0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\wmilfile.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WMILFILE.H

Abstract:

    Header file for CWmiLocFile, the MOF parser for Localization Studio

History:

--*/

#ifndef WMILOCFIL_H
#define WMILOCFIL_H

#include <vector>

const FileType ftWMIFileType = ftUnknown+1;

class CWMILocFile : public ILocFile, public CLObject
{
public:

	CWMILocFile(ILocParser *);

	static void GetFileDescriptions(CEnumCallback &);
	
    typedef std::vector<_bstr_t> VectorString;
protected:
	//
	//  Standard IUnknown methods
	//
	STDMETHOD_(ULONG, AddRef)(); 
	STDMETHOD_(ULONG, Release)(); 
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);

	//
	//  Standard Debugging interfaces
	//
	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD;

	//
	//  ILocFile methods.
	//
	STDMETHOD_(BOOL, OpenFile)(const CFileSpec REFERENCE,
			CReporter REFERENCE);
	STDMETHOD_(FileType, GetFileType)(void) const;
	STDMETHOD_(void, GetFileTypeDescription)(CLString REFERENCE) const;
	STDMETHOD_(BOOL, GetAssociatedFiles)(CStringList REFERENCE) const;

	STDMETHOD_(BOOL, EnumerateFile)(CLocItemHandler REFERENCE,
			const CLocLangId &, const DBID REFERENCE);
	STDMETHOD_(BOOL, GenerateFile)(const CPascalString REFERENCE,
			CLocItemHandler REFERENCE, const CLocLangId REFERENCE,
			const CLocLangId REFERENCE, const DBID REFERENCE);

	//
	//  CLObect implementation
	//
#ifdef _DEBUG
	void AssertValid(void) const;
	void Dump(CDumpContext &) const;
#endif

private:
	//
	//  Private methods to prevent callers access.
	//
	~CWMILocFile();
	CWMILocFile();
	const CWMILocFile &operator=(const CWMILocFile &);

	//
	//  Private data for C.O.M. implementation
	ILocParser *m_pParentClass;
	ULONG m_ulRefCount;

	//
	//  WMI specific private data.
	//
	enum WMIFileError
	{
		WMINoError,
		WMIOOM,
		WMICantOpenSourceFile,
		WMICantOpenTargetFile,
		WMINoOpenFile,
		WMINotWMIFile,
		WMICantWriteFile,
		WMISyntaxError,
		WMIFileError2,
		WMIHandlerError,
		WMIUnknownError,
        WMIIncompleteObj,
        WMINoMore
	};
	enum WMILineTypes
	{
		wltUnknown,
		wltNamespaceName,
		wltClassName,
		wltPropertyName
	};

	UINT m_uiLineNumber;
	DBID m_didFileId;
	_bstr_t m_pstrFileName;
	_bstr_t m_pstrTargetFile;
    
	FILE *m_pOpenSourceFile;
    FILE *m_pOpenTargetFile;
	
	CodePage m_cpSource;
	CodePage m_cpTarget;

    WORD m_wSourceId;
    WORD m_wTargetId;

    _bstr_t m_sCurrentNamespace;

    BOOL ReadLines(CLocItemHandler &, const DBID &, BOOL);
    WMIFileError GetNextItemSet(DWORD dwCurrPos,const _bstr_t &, CLocItemSet &,
		const DBID &, UINT &uiStartPos) ;
    BOOL GetNextQualifierPos(const wchar_t *, const wchar_t *, UINT &uiPos, UINT uiStartingPos = 0);
    BOOL EnumerateItem(CLocItemHandler &, CLocItemSet &);
	BOOL GenerateItem(CLocItemHandler &, CLocItemSet &, wchar_t **, UINT &uiStartingPos);
    void SetFlags(CLocItem *, CLocString &) const;
	void GetFullContext(CLString &) const;
	void ReportFileError(const _bstr_t &pstrFileName,
			const DBID &didFileId, CFileException *pFileException,
			CReporter &Reporter) const;
	void ReportUnicodeError(CUnicodeException *pUnicodeException,
			CReporter &Reporter, const CLocation &Location) const;
	void ReportException(CException *pException,
			CReporter &Reporter, const CLocation &) const;
    BOOL GetQualifierValue(wchar_t *, UINT &, _bstr_t &, UINT &);
    BOOL SetQualifierValue(wchar_t *, wchar_t **, UINT &, _bstr_t &, UINT &, BOOL bQuotes = TRUE);
    BOOL WriteNewFile(wchar_t *);
    wchar_t *FindPrevious(wchar_t *, const wchar_t *pTop, const wchar_t *);
    wchar_t *GetCurrentNamespace(wchar_t *, UINT uPos);
    wchar_t *FindTop(wchar_t *, wchar_t *, BOOL &);
    void ParseArray(wchar_t *, VectorString &);

    void WriteWaterMark();
	
};

CVC::ValidationCode ValidateString(const CLocTypeId &, const CLocString &clsOutputLine,
		CReporter &repReporter, const CLocation &loc, const CLString &strContext);

#endif // WMILOCFIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ESPTUIL.H

History:

--*/

//  
//  Common classes for Espresso
//  
//  

#pragma once

#pragma comment(lib, "esputil.lib")

#ifdef __cplusplus
#include <mitutil.h>
#include <locutil.h>

//
//  Not everybody gets this by default.

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <ltapi.h>
#include <loctypes.h>					//  Generic types.
#include ".\esputil\puid.h"			//  Parser Unique ID
#include ".\esputil\espreg.h"
#include ".\esputil\espenum.h"			//  Various enumeration like objects
#include ".\esputil\dbid.h"			//  Database IDs
#include ".\esputil\globalid.h"
#include ".\esputil\location.h"		//  location for Got To functionality
#include ".\esputil\goto.h"
#include ".\esputil\filespec.h"
#include ".\esputil\context.h"			//  Context for messages - string and location

#include ".\esputil\reporter.h"		//  Message reporting mechanism
#include ".\esputil\espopts.h"


#include ".\esputil\clfile.h"			//  Wrapper for CFile
#include ".\esputil\_wtrmark.h"

#include ".\esputil\resid.h"			//  Resource ID class
#include ".\esputil\typeid.h"			//  Type ID class
#include ".\esputil\uniqid.h"			//  Loc item ID
#include ".\esputil\binary.h"			//  LocItem binary data object
#include ".\esputil\interface.h"
#include ".\esputil\locitem.h"			//  Contents of a single loc item.
#include ".\esputil\itemhand.h"		//  Item handler call-back class


#include ".\esputil\LUnknown.h"		//	CLUnknown child IUnknown helper class.

//
//  These pieces are for the Espresso core components only.
//
#ifndef ESPRESSO_AUX_COMPONENT

#pragma message("Including ESPUTIL private components")

//
//  These files are semi-private - Parsers should not see them.
//
#include ".\esputil\SoftInfo.h"		//	Information about Software projects.
#include ".\esputil\_var.h"
#include ".\esputil\_importo.h"			//  Import options object
#include ".\esputil\_globalid.h"
#include ".\esputil\_goto.h"
#include ".\espUtil\_reporter.h"
#include ".\esputil\_errorrep.h"
#include ".\esputil\_espopts.h"
#include ".\esputil\_interface.h"
#endif


#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\extension.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    EXTENSION.H

History:

--*/

#pragma once


#include <esputil.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locking.h ===
/***
*sys/locking.h - flags for locking() function
*
*	Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	This file defines the flags for the locking() function.
*	[System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LOCKING
#define _INC_LOCKING

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#define _LK_UNLCK	0	/* unlock the file region */
#ifdef _WIN32
#define _LK_LOCK	1	/* lock the file region */
#endif
#define _LK_NBLCK	2	/* non-blocking lock */
#ifdef _WIN32
#define _LK_RLCK	3	/* lock for writing */
#endif
#define _LK_NBRLCK	4	/* non-blocking lock for writing */

#if !__STDC__
/* Non-ANSI names for compatibility */
#define LK_UNLCK	_LK_UNLCK
#ifdef _WIN32
#define LK_LOCK 	_LK_LOCK
#endif
#define LK_NBLCK	_LK_NBLCK
#ifdef _WIN32
#define LK_RLCK 	_LK_RLCK
#endif
#define LK_NBRLCK	_LK_NBRLCK
#endif

#endif	/* _INC_LOCKING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\ltapi.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LTAPI.H

History:

--*/

#ifdef LTAPIENTRY
#undef LTAPIENTRY
#endif

#ifdef IMPLEMENT
#define LTAPIENTRY __declspec(dllexport)

#else  // IMPLEMENT
#define LTAPIENTRY __declspec(dllimport)

#endif // IMPLEMENT


#ifndef LTAPI_H
#define LTAPI_H
//
//  Allow the use of C++ reference types and const methods, without
//  breaking the 'C' world.
//
#ifdef __cplusplus
#define REFERENCE &
#define CONST_METHOD const
#else
#define REFERENCE *
#define CONST_METHOD
#endif

#include <MitThrow.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mitthrow.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITTHROW.H

History:

--*/

#include ".\Mit\inc\MitThrow.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\helpids.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    HELPIDS.H

History:

--*/

#pragma once

//
//  We based off 12000 since that is the start of our resource ID range.
//
//  These have to be unique.  ESPPRJ and RESTBL use up the range 12000-12400
//  for their system wide unique resource ID's, so start at 12400.
//
#define IDH_SPELLDIALOG				12400
#define IDH_UNICODE_CONV			12401   
#define IDH_ENUMERATION_UNSUCCESS		12402
#define IDH_DLGLNIT_RESOURCE			12404
//#define IDH_ACME_PAGEFAULT			12406
#define IDH_NO_PARSER_UPDATE			12408
#define IDH_NO_PARSER_UPLOAD			12410
#define IDH_GENERATE_TERMINATED		12412
#define IDH_OSTRMANX_CLEAR			12414
#define IDH_ITEMS_UNMATCHED			12416
#define IDH_MESSAGE_TABLE			12418
//#define IDH_LINKER_OLD			12426
#define IDH_GETROW_ERROR			12428
#define IDH_SDM_DIALOG				12430
#define IDH_ESPGCOMP				12432
#define IDH_ESPGCOMP_OPTIONS			12434
#define IDH_Eraser_Message			12436
#define IDH_SOURCE_SAME_GEN			12438
#define IDH_SOURCE_SAME_UP			12440	



//The following are for the Project Settings and User Settings Tabs
#define IDH_RESOPT_VALIDATION			12442
#define IDH_RESOPT_SPELLING			12444
#define IDH_RESOPT_TRANSLATION		12446
#define IDH_ESPOPT_FILE				12448
#define IDH_ESPOPT_COPY_ACROSS		12450
#define IDH_ESPOPT_ADMIN			12452
#define IDH_ESPOPT_SET_FONT			12454
#define IDH_ESPOPT_RES_ANLY			12456
#define IDH_ESPOPT_CUSTOM			12003
#define IDH_ESPOPT_LOOKUP			12453
#define IDH_ESPOPT_CUSTFIELD_GLO		30536
#define IDH_ESPOPT_CUSTFIELD_PRO		12003
#define IDH_ESPOPT_COLUMNS			12513
#define IDH_ESPOPT_SUGGESTIONS		37692
#define IDH_ESPOPT_PSEUDO			12478

//The following are for the Parser Properties dialog, General and <parser name> tabs
#define IDH_ESPOPT_PARSER_PROP_GEN		12458
#define	IDH_ESPOPT_PARSER_PROP_SPEC	12460

//This provides help @ the output/translation window when the user presses F1 with the focus there...
#define IDH_PROJECT_WINDOW_F_ONE			12462
#define IDH_TRANS_WINDOW_F_ONE				12464
#define IDH_OUTPUT_PLACEHOLDER				12466

//This is for F1-on-error-message-in-output-window-help
#define IDH_UNEXPECTED_NULL_MACSDM		12468

#define IDH_WORKSPACE_WINDOW_GLOSSARY_F_ONE	12470
#define IDH_WORKSPACE_WINDOW_FILTER_F_ONE 	12472
#define IDH_GLOSSARY_TABLE_F_ONE			12474
#define IDH_SUGGESTIONS_F_ONE				12476

#define IDH_ESPOPT_EXTENSIONS				12480
#define IDH_ESPOPT_ACCELERATORS			12482

//File|Open glossary
#define IDH_FILE_OPEN_GLOSSARY	28676
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\locutil.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCUTIL.H

History:

--*/

#ifndef LOCUTIL_H
#define LOCUTIL_H
#pragma once

#pragma comment(lib, "locutil.lib")

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <MitWarning.h>				// MIT Template Library warnings
#pragma warning(ZCOM_WARNING_DISABLE)
#include <ComDef.h>
#pragma warning(ZCOM_WARNING_DEFAULT)

#ifndef __AFXOLE_H__
#include <afxole.h>
#pragma message("Warning: <afxole.h> not in pre-compiled header file, including")
#endif

#include <ltapi.h>
#include ".\LocUtil\FieldVal.h"
#include ".\LocUtil\Operator.h"
#include ".\LocUtil\FieldDef.h"
#include ".\LocUtil\FldDefList.h"
#include ".\LocUtil\Schema.h"
#include ".\LocUtil\FldDefHelp.h"

#include ".\LocUtil\locobj.h"
#include ".\LocUtil\locenum.h"
#include ".\LocUtil\espreg.h"			//  Registry and version info

#include ".\LocUtil\goto.h"
#include ".\LocUtil\gotohelp.h"

#include ".\locutil\report.h"
#include ".\LocUtil\progress.h"		//  'Progressive' objects base class
#include ".\LocUtil\cancel.h"			//  Base class for 'Cancelable" objects
#include ".\locutil\logfile.h"
#include ".\LocUtil\locpct.h"			//  Percent helper classes


#include ".\LocUtil\espopts.h"
#include ".\LocUtil\espstate.h"

#include ".\LocUtil\interface.h"
#include ".\LocUtil\product.h"			//	General functions about the Espresso product installed
#include ".\LocUtil\locstr.h"
#include ".\LocUtil\StringHelp.h"		//	String UI helpers
#include ".\LocUtil\ExtList.h"			//	File Extension list
#include ".\LocUtil\lstime.h"

#ifndef ESPRESSO_AUX_COMPONENT

#pragma message("Including LOCUTIL private components")


//  These files are semi-private - Parsers should not see them.
//
#include ".\LocUtil\FileDlg.h"			//  Wrapper for file dialog
#include ".\LocUtil\FileExclDlg.h"			//  Wrapper for file dialog
#include ".\LocUtil\DcsGrid.h"			// Function for DisplayColumn and MIT Grid
#include ".\LocUtil\PasStrMerge.h"

#include ".\LocUtil\_errorrep.h"		//  Error reporting mechanism
#include ".\LocUtil\_pumpidle.h"		//  Mechanism for idle time
#include ".\LocUtil\_username.h"
#include ".\LocUtil\_progress.h"
#include ".\LocUtil\_cancel.h"
#include ".\LocUtil\_locstr.h"
#include ".\LocUtil\_optvalstore.h"
#include ".\LocUtil\_espopts.h"
#include ".\LocUtil\_extension.h"
#include ".\LocUtil\_interface.h"
#include ".\LocUtil\_locenum.h"
#include ".\LocUtil\_report.h"

#include ".\LocUtil\ShowWarnings.h"
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\loctypes.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCTYPES.H

History:

--*/

//  This file contains defintions for simple types that have no
//  implementation.  If you have a 'universal' type that requires
//  implementation, put it in the 'esputil' directory.
//  
 

#pragma once

typedef ULONG SequenceNum;
//typedef int CodePage;
typedef ULONG FileId;
typedef ULONG BinaryId;

const BinaryId bidInvalid = 0;

typedef WORD ParserId;
const ParserId pidNone = 0;

typedef CWordArray CLocParserIdArray;

typedef WORD FileType;

//const CodePage cpInvalidCodePage = 0xDEADBEEF;

const FileType ftUnknown = 0; //Global filetype for an unknown type

// maximum number of bytes for strings corresponding to text fields
const size_t MAX_TXT = 255;

//Maximum number of nodes for Espresso szParents fields
const int MAX_PARENT_NODES = 31;
//
//  These values given to us by the VC guys, and are also in shell\ids.h
//
#ifndef MIN_ESPRESSO_RESOURCE_ID
const DWORD MIN_ESPRESSO_RESOURCE_ID  = 12000;
#endif
#ifndef MAX_ESPRESSO_RESOURCE_ID
const DWORD MAX_ESPRESSO_RESOURCE_ID  = 13999;
#endif

//
//  Now partion our range up for UI and non-UI (shared) components.
//
const DWORD MIN_ESP_UI_RESOURCE_ID    = MIN_ESPRESSO_RESOURCE_ID;
const DWORD MAX_ESP_UI_RESOURCE_ID    = MIN_ESPRESSO_RESOURCE_ID + 699;
const DWORD MIN_ESP_NONUI_RESOURCE_ID = MAX_ESP_UI_RESOURCE_ID + 1;
const DWORD MAX_ESP_NONUI_RESOURCE_ID = MAX_ESPRESSO_RESOURCE_ID;


enum VisualEditor
{
	veNone,
	veApstudio,
	veApstudioSubRes,
	veExternalEditor

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mitwarning.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITWARNING.H

History:

--*/

#if !defined(MIT_MitWarning)
#define MIT_MitWarning

#define ZCOM_WARNING_DISABLE disable: 473 454 4100 4244 4310 4505 4510 4610
#define ZCOM_WARNING_DEFAULT default: 473 454 4100 4244 4310 4505 4510 4610

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\mitutil.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    MITUTIL.H

History:

--*/

#include ".\mit\inc\mitutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\parseman.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PARSEMAN.H

History:

--*/
 
#pragma once
#pragma comment(lib, "parseman.lib")

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <ltapi.h>

#include ".\parseman\pinfo.h"
#include ".\parseman\pmanager.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\parsutil.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PARSUTIL.H

History:

--*/

#pragma once

#pragma comment(lib, "parsutil.lib")

#ifdef IMPLEMENT
#error Illegal use of IMPLEMENT macro
#endif

#include <ltapi.h>						// Provide interface definitions 

#include ".\parsers\ParsUtil\LocParser.h"
#include ".\parsers\ParsUtil\LocChild.h"
#include ".\parsers\ParsUtil\LocBinary.h"
#include ".\parsers\ParsUtil\LocVersion.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\parser.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PARSER.H

History:

--*/

//  
//  Mother of all include files for parsers.  This should be everything that
//  a parser needs.
//  

#pragma once

#define ESPRESSO_AUX_COMPONENT

#include <esputil.h>
#include <pbase.h>
#include <parsutil.h>
#include <parserid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\pbase.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PBASE.H

History:

--*/
 
#pragma once

#pragma comment(lib, "pbase.lib")

#include ".\pbase\locfile.h"
#include ".\pbase\parseapi.h"
#include ".\pbase\pversion.h"
#include ".\pbase\subparse.h"
#include ".\pbase\binary.h"
#include ".\pbase\imgres32.h"
#include ".\pbase\mnemonic.h"
#include ".\pbase\idupdate.h"
#include ".\pbase\updatelog.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\precenum.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PRECENUM.H

History:

--*/

#include ".\mit\inc\PreCEnum.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\puser.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PUSER.H

History:

--*/

//  
//  Master include file for components that need to use parsers, but not
//  implement a parser.
//
//  If you are implementing a parser, use PARSER.H instead.
//  
 
#pragma once

#include <esputil.h>
#include <pbase.h>
#include <parserid.h>
#include <parseman.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\parserid.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PARSERID.H

History:

--*/
 
#pragma once

const ParserId pidMac   = 1;
const ParserId pidText  = 2;
const ParserId pidWin32 = 3;
const ParserId pidIni   = 4;
const ParserId pidWin16 = 5;
const ParserId pidTok   = 6;
const ParserId pidInf   = 7;
const ParserId pidRiff  = 8;
const ParserId pidFox   = 9;
const ParserId pidDos7  = 10;
const ParserId pidNet	= 11;
const ParserId pidVxd	= 12;
const ParserId pidScan	= 13;
const ParserId pidMsg   = 14;
const ParserId pidWinboot = 15;
const ParserId pidRPLBoot = 16;
const ParserId pidMacTok = 17;
const ParserId pidPpd   = 18;
const ParserId pidBmpIcon = 19;
const ParserId pidProject = 20;
const ParserId pidSrg = 21;
const ParserId pidHEAT = 22;

const ParserId pidNashville_BEGIN = 23;	
const ParserId pidNashville_END = 32;   

const ParserId pidPegasus_BEGIN = 33;
const ParserId pidPegasus_STR = 33;
const ParserId pidPegasus_END = 47;   

const ParserId pidOPC = 48;
const ParserId pidDAT = 49;

const ParserId pidPublisher_BEGIN = 50;	
const ParserId pidPublisher_DES = 50;
const ParserId pidPublisher_POC = 51;
const ParserId pidPublisher_CAT = 52;
const ParserId pidPublisher_END = 59;

const ParserId pidJavaRB = 60;

const ParserId pidOffice_BEGIN = 61;
const ParserId pidOffice_END = 80;

const ParserId pidAccWiz = 81;
const ParserId pidINX = 82;

const ParserId pidMsi = 83;
const ParserId pidForms3 = 84;
const ParserId pidVbForms = 85;
const ParserId pidMmc = 86;
const ParserId pidMAPIcfg = 87;

const ParserId pidServerApps_BEGIN = 88;
const ParserId pidServerApps_SysMessages = 88;
const ParserId pidServerApps_END = 92;

const ParserId pidProjectLCP = 93;
const ParserId pidExchangeMNC = 94;

const ParserId pidFsfParse = 95;

const ParserId pidCBTParse = 96;
const ParserId pidWMI = 97;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\types.h ===
/***
*sys/types.h - types returned by system level calls for file and time info
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines types used in defining values returned by system
*       level calls for file status and time information.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TYPES
#define _INC_TYPES

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif


#ifndef _INO_T_DEFINED

typedef unsigned short _ino_t;          /* i-node number (not used on DOS) */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif

#define _INO_T_DEFINED
#endif


#ifndef _DEV_T_DEFINED

typedef unsigned int _dev_t;            /* device code */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned int dev_t;
#endif

#define _DEV_T_DEFINED
#endif


#ifndef _OFF_T_DEFINED

typedef long _off_t;                    /* file offset value */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif

#define _OFF_T_DEFINED
#endif

#endif  /* _INC_TYPES */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\timeb.h ===
/***
*sys/timeb.h - definition/declarations for _ftime()
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file define the _ftime() function and the types it uses.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TIMEB
#define _INC_TIMEB

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif


/* Structure returned by _ftime system call */

#ifndef _TIMEB_DEFINED
struct _timeb {
        time_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#if     !__STDC__

/* Non-ANSI name for compatibility */

struct timeb {
        time_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#endif

#define _TIMEB_DEFINED
#endif


/* Function prototypes */

_CRTIMP void __cdecl _ftime(struct _timeb *);

#if     !__STDC__

/* Non-ANSI name for compatibility */

_CRTIMP void __cdecl ftime(struct timeb *);

#endif


#ifdef __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_TIMEB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\utime.h ===
/***
*sys/utime.h - definitions/declarations for utime()
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the utime routine to set
*       new file access and modification times.  NOTE - MS-DOS
*       does not recognize access time, so this field will
*       always be ignored and the modification time field will be
*       used to set the new time.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_UTIME
#define _INC_UTIME

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif

#ifdef  _WIN32
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#endif  /* _WIN32 */

#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif

/* define struct used by _utime() function */

#ifndef _UTIMBUF_DEFINED

struct _utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };

#if     !__STDC__
/* Non-ANSI name for compatibility */
struct utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };
#endif

#define _UTIMBUF_DEFINED
#endif


/* Function Prototypes */

_CRTIMP int __cdecl _utime(const char *, struct _utimbuf *);
#ifdef _WIN32
_CRTIMP int __cdecl _futime(int, struct _utimbuf *);

/* Wide Function Prototypes */
_CRTIMP int __cdecl _wutime(const wchar_t *, struct _utimbuf *);
#endif /* _WIN32 */

#if     !__STDC__
/* Non-ANSI name for compatibility */
_CRTIMP int __cdecl utime(const char *, struct utimbuf *);
#endif

#ifdef __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_UTIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\stat.h ===
/***
*sys/stat.h - defines structure used by stat() and fstat()
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the _stat() and _fstat()
*       routines.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STAT
#define _INC_STAT

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


#include <sys/types.h>


#ifndef _TIME_T_DEFINED
typedef long time_t;
#define _TIME_T_DEFINED
#endif


#ifdef _WIN32
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#endif /* _WIN32 */


/* define structure for returning status information */

#ifndef _STAT_DEFINED

struct _stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#if     !__STDC__

/* Non-ANSI names for compatibility */

struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#endif  /* __STDC__ */

#if     _INTEGRAL_MAX_BITS >= 64
struct _stati64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };
#endif

#define _STAT_DEFINED
#endif


#define _S_IFMT         0170000         /* file type mask */
#define _S_IFDIR        0040000         /* directory */
#define _S_IFCHR        0020000         /* character special */
#define _S_IFIFO        0010000         /* pipe */
#define _S_IFREG        0100000         /* regular */
#define _S_IREAD        0000400         /* read permission, owner */
#define _S_IWRITE       0000200         /* write permission, owner */
#define _S_IEXEC        0000100         /* execute/search permission, owner */


/* Function prototypes */

_CRTIMP int __cdecl _fstat(int, struct _stat *);
_CRTIMP int __cdecl _stat(const char *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _fstati64(int, struct _stati64 *);
_CRTIMP int __cdecl _stati64(const char *, struct _stati64 *);
#endif

#ifdef _WIN32
#ifndef _WSTAT_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_CRTIMP int __cdecl _wstat(const wchar_t *, struct _stat *);

#if     _INTEGRAL_MAX_BITS >= 64
_CRTIMP int __cdecl _wstati64(const wchar_t *, struct _stati64 *);
#endif

#define _WSTAT_DEFINED
#endif
#endif /* _WIN32 */


#if     !__STDC__

/* Non-ANSI names for compatibility */

#define S_IFMT   _S_IFMT
#define S_IFDIR  _S_IFDIR
#define S_IFCHR  _S_IFCHR
#define S_IFREG  _S_IFREG
#define S_IREAD  _S_IREAD
#define S_IWRITE _S_IWRITE
#define S_IEXEC  _S_IEXEC

_CRTIMP int __cdecl fstat(int, struct stat *);
_CRTIMP int __cdecl stat(const char *, struct stat *);

#endif  /* __STDC__ */


#ifdef __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STAT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\binary.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    BINARY.INL

History:

--*/
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocBinary::GetFBinaryDirty(void)
		const
{
	return m_Flags.m_fBinaryDirty;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - comment this function!
//  
//-----------------------------------------------------------------------------
inline
void
CLocBinary::SetFBinaryDirty(
		BOOL f)
{
	m_Flags.m_fBinaryDirty = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - Comment this function.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocBinary::GetFPartialUpdateBinary(void)
		const
{
	return m_Flags.m_fPartialUpdateBinary;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO - Comment this function!
//  
//-----------------------------------------------------------------------------
inline
void
CLocBinary::SetFPartialUpdateBinary(
		BOOL f)
{
	m_Flags.m_fPartialUpdateBinary = f;
}



//-----------------------------------------------------------------------------
//
//  Default conversion of one Binary to another format - it fails
//
//-----------------------------------------------------------------------------
inline
BOOL
CLocBinary::Convert(CLocItem *)
{
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\binary.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    BINARY.H

History:

--*/


#ifndef ESPUTIL_BINARY_H
#define ESPUTIL_BINARY_H


//
//  Base class for binary classes.  This allows serialization
//  of arbitrary data.
//

class CLocVariant;
class CLocItem;

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocBinary : public CObject
{
public:
	CLocBinary();

	virtual void AssertValid(void) const;

	//
	//  Serialization routines. Supports serialization withour dynamic creation
	//
	virtual void Serialize(CArchive &archive);  //Afx serialize function

	//
	//  Result code for comparing one binary class from another.
	//
	enum CompareCode
	{
		noChange,		
		partialChange,    //Only non-localizable data changed
		fullChange        //Localizable data changed
	};
	virtual CompareCode Compare (const CLocBinary *) = 0;

	// Called to update the non-localizable data - Used when compare returns
	// partialChange

	virtual void PartialUpdate(const CLocBinary * binSource) = 0;

	enum Alignment
	{
		a_Default,
		a_Left,
		a_Center,
		a_Right,
		a_Top,
		a_VCenter,
		a_Bottom
	};

	//
	//  The universe of possible binary properties that may be queried for.
	//  This order must NOT change, or you may break old parsers!  Put new
	//  properties at the end.
	//
	enum Property
	{
		//
		//  Native formats..
		//
		p_dwXPosition,
		p_dwYPosition,
		p_dwXDimension,
		p_dwYDimension,
		p_dwAlignment,
		p_blbNativeImage,

		p_dwFontSize,
		p_pasFontName,
		p_dwFontWeight,
		p_dwFontStyle,

		//
		//  Interchange formats..
		//
		p_dwWin32XPosition,
		p_dwWin32YPosition,
		p_dwWin32XDimension,
		p_dwWin32YDimension,
		p_dwWin32Alignment,				// Use Alignment enum
		p_dwWin32ExtAlignment,			// Extended - Use Alignment enum
		p_blbWin32Bitmap,
		p_blbWin32DialogInit,
		
		//
		//  Generic - usable both for Native and Interchange
		//
		p_bVisible,						// Is the item visable?
		p_bDisabled,					// Is the item disabled?
		p_bLTRReadingOrder,				// Is the reading order L to R?
		p_bLeftScrollBar,				// Scroll bar on left?

		//
		//	"Styles" tab for dialog controls.
		//
		p_bLeftText,					// Display text to left of control?

	
		p_bWin32LTRLayout,              // WS_EX_LAYOUT_RTL
		p_bWin32NoInheritLayout,        // WS_EX_NOINHERIT_LAYOUT

		p_dwWin32VAlignment,				// Use Alignment enum

		// Insert new entries here
	};

	virtual BOOL GetProp(const Property, CLocVariant &) const;
	virtual BOOL SetProp(const Property, const CLocVariant &);
	
	//
	// Attempts to convert CBinary in CLocItem to same type as this 
	//
	virtual BOOL Convert(CLocItem *);
	virtual BinaryId GetBinaryId(void) const = 0;
	
	virtual ~CLocBinary();

	BOOL NOTHROW GetFBinaryDirty(void) const;
	BOOL NOTHROW GetFPartialUpdateBinary(void) const;
	void NOTHROW SetFBinaryDirty(BOOL);
	void NOTHROW SetFPartialUpdateBinary(BOOL);

protected:
	
private:
	//
	//  Copy constructor and assignment are hidden, since we
	//  shouldn't be copying these things around.
	//
	CLocBinary(const CLocBinary &);
	const CLocBinary& operator=(const CLocBinary &);
	//
	//  These allow a user to determine what parts of the item have been
	//  changed.
	//
	struct Flags
	{
		BOOL m_fBinaryDirty         :1;
		BOOL m_fPartialUpdateBinary :1;
	};

	Flags m_Flags;
};

#pragma warning(default: 4275)

#include "binary.inl"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\clfile.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    CLFILE.H

History:

--*/

//  
//  Wrapper class for CFile.  It allows us to use CPascalString for
//  file names, and does some 'text mode' read/write operations.
//  This class contains a pointer to a CFile but contains most of
//  the CFile methods thus it can be used as a CFile.  CLFile will either
//  use an existing CFile provided at construction time or it will create its
//  own CFile as needed.  In either case, the enbeded CFile is destroyed when
//  the CLFile is destroyed.
//  
 
#ifndef CLFILE_H
#define CLFILE_H


#pragma warning(disable : 4275)

class LTAPIENTRY CLFile : public CObject
{
public:
	CLFile();
	CLFile(CFile *);
	~CLFile();

	void AssertValid(void) const;

//-----------------------------------------------------------------------------
// The following are the CFile methods that are reimplemented 
//-----------------------------------------------------------------------------
	DWORD GetPosition() const;

	DWORD SeekToEnd();
	void SeekToBegin();

	LONG Seek(LONG lOff, UINT nFrom);
	void SetLength(DWORD dwNewLen);
	DWORD GetLength() const;

	UINT Read(void* lpBuf, UINT nCount);
	void Write(const void* lpBuf, UINT nCount);

	void LockRange(DWORD dwPos, DWORD dwCount);
	void UnlockRange(DWORD dwPos, DWORD dwCount);

	void Abort();
	void Flush();
	void Close();

	CLString GetFileName(void) const;

//-----------------------------------------------------------------------------
// The following are all the CLFile methods
//-----------------------------------------------------------------------------


	BOOL Open(const CPascalString &pstrFileName, UINT nOpenFlags,
			CFileException *pError = NULL);

	static void Rename(const CPascalString &pstrFileName,
			const CPascalString &pstrNewName);
	static void Remove(const CPascalString &pstrFileName);

	static void CopyFile(
			const CPascalString &pasSource,
			const CPascalString &pasTarget,
			BOOL fFailIfExist = TRUE,
			CProgressiveObject *pProgress = NULL);
	
	static BOOL GetStatus(const CPascalString &pstrFileName,
			CFileStatus &rStatus);
	static void SetStatus(const CPascalString &pstrFileName,
			const CFileStatus &status);

	UINT ReadLine(CPascalString &pstrLine, CodePage cp);
	UINT ReadLine(CPascalString &pstrLine);

	UINT ReadString(CPascalString &pstrLine, CodePage cp);
	UINT ReadString(CPascalString &pstrLine);

	UINT ReadByte(BYTE &);
	UINT ReadWord(WORD &, BOOL BigEnded = FALSE);
	UINT ReadDWord(DWORD &, BOOL BigEnded = FALSE);

	UINT ReadPascalB(CPascalString &);
	UINT ReadPascalW(CPascalString &);
	UINT ReadPascalD(CPascalString &);

	UINT ReadPascalB(CPascalString &, CodePage);
	UINT ReadPascalW(CPascalString &, CodePage);
	UINT ReadPascalD(CPascalString &, CodePage);

	UINT Read(CPascalString &pstr, UINT nCount, CodePage cp);
	UINT Read(CPascalString &pstr, UINT nCount);

	UINT WriteLine(const CPascalString &pstrLine, CodePage cp);
	UINT WriteLine(const CPascalString &pstrLine);

	UINT WriteString(const CPascalString &pstrString, CodePage cp);
	UINT WriteString(const CPascalString &pstrString);

	UINT WriteByte(const BYTE &);
	UINT WriteWord(const WORD &, BOOL BigEnded = FALSE);
	UINT WriteDWord(const DWORD &, BOOL BigEnded = FALSE);

	UINT WritePascalB(const CPascalString &);
	UINT WritePascalW(const CPascalString &);
	UINT WritePascalD(const CPascalString &);

	UINT WritePascalB(const CPascalString &, CodePage);
	UINT WritePascalW(const CPascalString &, CodePage);
	UINT WritePascalD(const CPascalString &, CodePage);

	UINT Write(const CPascalString &pstrString);
	UINT Write(const CPascalString &pstrString, CodePage cp);

	UINT SkipToBoundary(UINT nBoundary);
	UINT PadToBoundary(UINT nBoundary, BYTE ucPad = 0);
	void Pad(UINT nCount, BYTE ucPad = 0);

	UINT CopyRange(CLFile &Target, UINT uiNumBytes,
			CProgressiveObject *pProgress = NULL);
	
protected:
	CFile *m_pFile;
	BOOL m_bDeleteFile;	//Should we delete m_pFile in our destructor?
};


enum FileStat
{
	fsNoStatus = 0x00,
	fsNotFound = 0x01,
	fsUpToDate = 0x02,
	fsFileNewer = 0x04,
	fsFileOlder = 0x08,
	fsNotReadable = 0x10,
	fsNotWritable = 0x20
};



WORD
LTAPIENTRY LocateFile(
		const CLString &strFileName,
		const COleDateTime &tGmtFileTime);



#pragma warning(default : 4275)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "clfile.inl"
#endif

#endif // CLFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\clfile.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    CLFILE.INL

History:

--*/

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the CLFile object - we create the CFile
//  
//-----------------------------------------------------------------------------
inline
CLFile::CLFile()
{
	m_pFile = new CFile();
	m_bDeleteFile = TRUE;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Constructor for the CLFile object - user provides a CFile.  User is
//  responsible for the CFile object!
//  
//-----------------------------------------------------------------------------

inline
CLFile::CLFile(
		CFile *pFile)
{
	LTASSERT(pFile != NULL);
	m_pFile = pFile;
	m_bDeleteFile = FALSE;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Destructor - also delete contained CFile if not user supplied.
//
//-----------------------------------------------------------------------------

inline
CLFile::~CLFile()
{
	DEBUGONLY(AssertValid());
	if (m_bDeleteFile)
	{
		delete m_pFile;
	}
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Read a byte at the current file position
//
//-----------------------------------------------------------------------------

inline
UINT							//Byte count read 
CLFile::ReadByte(
	BYTE & byte)				//where to place the byte
{
	if (Read(&byte, sizeof(BYTE)) != sizeof(BYTE))
	{
		AfxThrowFileException(CFileException::endOfFile);
	}
	return sizeof(BYTE);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Write a byte at the current file position
//
//-----------------------------------------------------------------------------

inline
UINT							//Byte count written
CLFile::WriteByte(
		const BYTE & byte)
{
	Write(&byte, sizeof(BYTE));
	return sizeof(BYTE);
}


//-----------------------------------------------------------------------------
// The following are the CFile methods that are reimplemented 
//-----------------------------------------------------------------------------
inline
DWORD
CLFile::GetPosition()
		const
{
	return m_pFile->GetPosition();
}

inline
DWORD
CLFile::SeekToEnd()
{
	return m_pFile->SeekToEnd();
}

inline
void
CLFile::SeekToBegin()
{
	m_pFile->SeekToBegin();
}

inline
LONG
CLFile::Seek(
		LONG lOff,
		UINT nFrom)
{
	return m_pFile->Seek(lOff, nFrom);
}

inline
void
CLFile::SetLength(
		DWORD dwNewLen)
{
	m_pFile->SetLength(dwNewLen);
}

inline
DWORD
CLFile::GetLength()
		const
{
	return m_pFile->GetLength();
}

inline
UINT
CLFile::Read(
		void* lpBuf,
		UINT nCount)
{
	return m_pFile->Read(lpBuf, nCount);
}

inline
void
CLFile::Write(
		const void* lpBuf,
		UINT nCount)
{
	m_pFile->Write(lpBuf, nCount);
}

inline
void
CLFile::Flush()
{
	m_pFile->Flush();
}

inline
void
CLFile::Close()
{
 	m_pFile->Close();
}


inline
void
CLFile::Abort()
{
	m_pFile->Abort();
}



inline
CLString
CLFile::GetFileName(void)
		const
{
	return m_pFile->GetFileName();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\context.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    CONTEXT.H

History:

--*/

#ifndef ESPUTIL_CONTEXT_H
#define ESPUTIL_CONTEXT_H



//
//  This class should NOT be used as a base class.
//
class LTAPIENTRY CContext
{
public:
	CContext();
	CContext(const CContext &);
	CContext(const CLString &);
	CContext(HINSTANCE, UINT uiStringId); 
	CContext(const CLString &, const CLocation &);
	CContext(HINSTANCE, UINT uiStringId, const CLocation &);
	CContext(const CLString &, const DBID &, ObjectType, View,
			TabId = NullTabId, Component = cmpNone);
	CContext(HINSTANCE, UINT uiStringID, const DBID &, ObjectType, View, 
			TabId = NullTabId, Component = cmpNone);
	
	void AssertValid(void) const;

	const CContext &operator=(const CContext &);

	const CLString &GetContext(void) const;
	const CLocation &GetLocation(void) const;

	BOOL operator==(const CContext &);
			
private:

	CLString m_strContext;
	CLocation m_loc;
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "context.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\dbid.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    DBID.INL

History:

--*/
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// every new DBID is null
//
//-----------------------------------------------------------------------------
inline
DBID::DBID()
{
	m_l = 0;

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// a DBID can be created from a valid LONG
//
//-----------------------------------------------------------------------------
inline
DBID::DBID(
		LONG l)
{
	LTASSERT(l > 0);

	m_l = l;

	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// a DBID can be created from a valid other dbid
//
//-----------------------------------------------------------------------------
inline
DBID::DBID(
		const DBID& id)
{
	ASSERT_VALID(&id);

	m_l = id.m_l;

	DEBUGONLY(++m_UsageCounter);
}



inline
DBID::~DBID()
{
	DEBUGONLY(--m_UsageCounter);
}


	
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// sets the DBID to a valid value
// only a null DBID can be set
// any attempt to change a valid DBID will cause an assertion failure
//
//-----------------------------------------------------------------------------
inline
void
DBID::Set(
		LONG l)
{
	ASSERT_VALID(this);
	LTASSERT(l > 0);
	LTASSERT(m_l == 0);

	m_l = l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// sets the DBID to a valid value
// only a null DBID can be set
// any attempt to change a valid DBID will cause an assertion failure
//
//-----------------------------------------------------------------------------
inline
void
DBID::operator=(
		const DBID& id)
{
	ASSERT_VALID(this);
	LTASSERT(m_l == 0);
	ASSERT_VALID(&id);

	m_l = id.m_l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// LONG operator, the only way to get the value of a DBID, any attempt to get
// the value of a null DBID will cause an assertion failure
//
//-----------------------------------------------------------------------------
inline
DBID::operator LONG ()
		const
{
	ASSERT_VALID(this);
	LTASSERT(m_l > 0);

	return m_l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// the only way to clear (make it null) the dbid must be explicit
//
//-----------------------------------------------------------------------------
inline
void
DBID::Clear()
{
	ASSERT_VALID(this);

	m_l = 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// the only way to know if a dbid is null
//
//-----------------------------------------------------------------------------
inline
BOOL
DBID::IsNull()
		const
{
	ASSERT_VALID(this);

	return (m_l == 0);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// == operator
//
//-----------------------------------------------------------------------------
inline
int
DBID::operator==(
		const DBID &dbid)
		const
{
	ASSERT_VALID(this);

	return m_l == dbid.m_l;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// != operator
//
//-----------------------------------------------------------------------------
inline
int
DBID::operator!=(
		const DBID &dbid)
		const
{
	ASSERT_VALID(this);

	return m_l != dbid.m_l;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\espenum.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ESPENUM.H

History:

--*/


#ifndef ESPENUM_H
#define ESPENUM_H



extern const LTAPIENTRY CString ftDescUnknown; //Description for unknown file types


class LTAPIENTRY CIconType
{
public:
	// Special note: these enum value sequence is of vital importance to
	// the GUI components.  Please preserve them.
	enum IconType
	{
		None = 0,
		Project,		// project root icon
		Directory,		// Part of project structure
		File,			// File object in the project
		Expandable,		// Generic Expandable node in a file.
						// Special note: Any value up to Expandable is
						// currently display as a folder in prj window
		Bitmap,			// Bitmap
		Dialog,			// Dialog like items
		Icon,			// Icon resource
		Version,		// Version stamping resources
		String,			// String resources
		Accel,			// Accelerator
		Cursor,			// Cursor resource
		Menu,			// Menu resources
		Custom,			// Custom resources
		Reference		// icon for reference glossary
	};

	NOTHROW static const TCHAR * GetIconName(CIconType::IconType);
	NOTHROW static HBITMAP GetIconBitmap(CIconType::IconType);
	static void Enumerate(CEnumCallback &);
	
private:
	static const TCHAR *const m_szIconNames[];
	CIconType();
};

typedef CIconType CIT;



class LTAPIENTRY CLocStatus
{
public:
	enum LocStatus
	{
		InvalidLocStatus = 0,
		NotLocalized,
		Updated,
		Obsolete_AutoTranslated,  //  Don't use this!  Obsolete!
		Localized = 4,
		NotApplicable,
		InvalidLocStatus2  // used by edbval to determine a invalid status
		                   // a new "valid" status must be entered before this.
	};

	NOTHROW static const TCHAR * GetStatusText(CLocStatus::LocStatus);
	NOTHROW static const TCHAR * GetStatusShortText(CLocStatus::LocStatus);
	NOTHROW static CLocStatus::LocStatus MapShortTextToEnum(const TCHAR *);
	NOTHROW static CLocStatus::LocStatus MapCharToEnum(const TCHAR);
	NOTHROW static CLocStatus::LocStatus MapLongTextToEnum(const TCHAR *szLongName);
	
	static void Enumerate(CEnumCallback &);
	
private:
	struct StatusInfo
	{
		const TCHAR *szStatusShortText;
		const TCHAR *szStatusText;
	};

	static const StatusInfo m_Info[];

	CLocStatus();
};

typedef CLocStatus CLS;




#endif // ESPENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\dbid.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    DBID.H

History:

--*/

#ifndef DBID_H
#define DBID_H


//
// represents a database id
//

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY DBID : public CObject
{
public:
	//
	// ctors
	//
	DBID();
	DBID(const DBID& id);
	DBID(long l);
	~DBID();

	//
	// debug methods
	//
	void AssertValid() const;
	//
	// 'get like' methods
	//
	BOOL NOTHROW IsNull() const;
	NOTHROW operator long () const;
	int NOTHROW operator==(const DBID &) const;
	int NOTHROW operator!=(const DBID &) const;

	//
	// 'put like' methods
	//
	void NOTHROW operator=(const DBID&);
	void NOTHROW Set(long);
	void NOTHROW Clear();

protected:
	long m_l;

private:
	DEBUGONLY(static CCounter m_UsageCounter);
};

#pragma warning(default: 4275)

typedef CArray<DBID, DBID &> CDBIDArray;

	
#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "dbid.inl"
#endif

const extern LTAPIENTRY DBID g_NullDBID;
  
#endif // DBID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\espopts.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ESPOPTS.H

History:

--*/

LTAPIENTRY BOOL RegisterParserOptions(CLocUIOptionSet*);
LTAPIENTRY void UnRegisterParserOptions(const PUID&);

LTAPIENTRY BOOL GetParserOptionValue(const PUID &, LPCTSTR szName, CLocOptionVal *&);
LTAPIENTRY BOOL GetParserOptionBool(const PUID&, LPCTSTR pszName);
LTAPIENTRY const CPascalString GetParserOptionString(const PUID&, LPCTSTR pszName);
LTAPIENTRY DWORD GetParserOptionNumber(const PUID&, LPCTSTR pszName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\espreg.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ESPREG.H

History:

--*/
//  
//  Registry and version information for Espresso 2.x
//  
 



//
//  Provided so parsers can register themselves.
//
LTAPIENTRY HRESULT RegisterParser(HMODULE);
LTAPIENTRY HRESULT UnregisterParser(ParserId pid, ParserId pidParent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\context.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    CONTEXT.INL

History:

--*/



inline
CContext::CContext()
{}


inline
CContext::CContext(
		const CContext & context)
	: m_strContext(context.m_strContext), m_loc(context.m_loc)
{}


inline
CContext::CContext(
		const CLString &strContext)
	: m_strContext(strContext)
{}



inline
CContext::CContext(
		HINSTANCE hDll,
		UINT uiStringID)
	: m_strContext(hDll, uiStringID)
{}



inline
CContext::CContext(
		const CLString &strContext,
		const CLocation &loc)
	: m_strContext(strContext), m_loc(loc)
{}

	

inline
CContext::CContext(
		const CLString &strContext,
		const DBID &dbid,
		ObjectType ot,
		View view,
		TabId tabid,
		Component component)
	: m_strContext(strContext), m_loc(dbid, ot, view, tabid, component)
{}



inline
CContext::CContext(
		HINSTANCE hDll,
		UINT uiStringID,
		const CLocation &loc)
	: m_strContext(hDll, uiStringID), m_loc(loc)
{}


inline
CContext::CContext(
		HINSTANCE hDll, 
		UINT uiStringID, 
		const DBID & dbid, 
		ObjectType ot, 
		View view, 
		TabId tabid, 
		Component component)
	: m_strContext(hDll, uiStringID), 
	  m_loc(dbid, ot, view, tabid, component)
{}


inline
const CLString &
CContext::GetContext(void) const
{
	return m_strContext;
}



inline
const CLocation &
CContext::GetLocation(void)
		const
{
	return m_loc;
}



inline
const 
CContext &
CContext::operator=(const CContext & context)
{
	m_strContext	= context.m_strContext;
	m_loc			= context.m_loc;

	return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\filespec.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    FILESPEC.H

History:

--*/

#ifndef ESPUTIL_FILESPEC_H
#define ESPUTIL_FILESPEC_H

#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CFileSpec : public CObject
{
public:
	NOTHROW CFileSpec();
	NOTHROW CFileSpec(const CFileSpec &);
	NOTHROW CFileSpec(const CPascalString &, const DBID &);

	void AssertValid(void) const;

	NOTHROW void SetFileName(const CPascalString &);
	NOTHROW void SetFileId(const DBID &);

	NOTHROW const CPascalString & GetFileName(void) const;
	NOTHROW const DBID & GetFileId(void) const;

	NOTHROW const CFileSpec & operator=(const CFileSpec &);
	
	~CFileSpec();
	
private:
	
	CPascalString m_pasFileName;
	DBID m_didFileId;
};

#pragma warning(default: 4275)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\globalid.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    GLOBALID.H

History:

--*/

#ifndef ESPUTIL_GLOBALID_H
#define ESPUTIL_GLOBALID_H

enum ObjectType
{
	otNone,
	otFile,
	otResource,
};



///////////////////////////////////////////////////////////////////////////////
//
// global id object, represents what fully qualifies any database item
//
///////////////////////////////////////////////////////////////////////////////
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 
class LTAPIENTRY CGlobalId: public CObject
{
public:
	//
	// ctor/dtor
	//
	NOTHROW CGlobalId();
	NOTHROW CGlobalId(const DBID &dbid, ObjectType otType);
	NOTHROW CGlobalId(const CGlobalId &id);
	NOTHROW ~CGlobalId();
	
	//
	// operators
	//
	NOTHROW int operator==(const CGlobalId &) const;
	NOTHROW int operator!=(const CGlobalId &) const;

	NOTHROW const CGlobalId & operator=(const CGlobalId &);
	
	NOTHROW const DBID & GetDBID() const;
	NOTHROW ObjectType GetObjType(void) const;
	
protected:
	//
	// debug routines
	//
	virtual void AssertValid() const;

	//
	// data members
	//
	DBID  m_dbid;
	ObjectType  m_otObjType;

	DEBUGONLY(static CCounter m_UsageCounter);
};

#pragma warning(default: 4275)


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "globalid.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\goto.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    GOTO.H

History:

--*/

#pragma once


LTAPIENTRY CGoto *CreateEspGoto(const CLocation &);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\globals.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    GLOBALS.H

History:

--*/
void GlobalInit(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\itemhand.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ITEMHAND.H

History:

--*/

//  
//  Declaration for the item handler class.  This encapsulates the call-back
//  functionality for the Parsers during an enumeration.
//  
 

#ifndef ITEMHAND_H
#define ITEMHAND_H


class LTAPIENTRY CLocItemHandler : public CReporter, public CCancelableObject
{
public:
	CLocItemHandler();

	void AssertValid(void) const;
	
	virtual BOOL HandleItemSet(CLocItemSet &) = 0;

	virtual ~CLocItemHandler();
			
private:
};

#endif //  ITEMHAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\interface.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    INTERFACE.H

History:

--*/

//  
//  Various public interfaces in Espresso.
//  
 
#pragma once


extern const LTAPIENTRY IID IID_ILocStringValidation;

class CLocTranslation;

DECLARE_INTERFACE_(ILocStringValidation, IUnknown)
{
	//
	//  IUnknown standard Interface
	//
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	//
	//  Standard Debugging interfaces
	//
 	STDMETHOD_(void, AssertValidInterface)(THIS) CONST_METHOD PURE;

	STDMETHOD_(CVC::ValidationCode, ValidateString)
		(THIS_ const CLocTypeId REFERENCE, const CLocTranslation REFERENCE,
				CReporter *, const CContext &) PURE;
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\itemhand.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ITEMHAND.INL

History:

--*/
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Retail versions do nothing.  Debug code is in reporter.cpp
//  
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\globalid.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    GLOBALID.INL

History:

--*/

inline
CGlobalId::CGlobalId()
{
	m_otObjType = otNone;
	
	DEBUGONLY(++m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// ctor
//
//-----------------------------------------------------------------------------
inline
CGlobalId::CGlobalId(
		const DBID &dbid,
		ObjectType ot)
{
	m_dbid = dbid;
	m_otObjType = ot;

	DEBUGONLY(++m_UsageCounter);
}

inline
CGlobalId::CGlobalId(
		const CGlobalId &id)
{
	m_dbid = id.m_dbid;
	m_otObjType = id.m_otObjType;

	DEBUGONLY(++m_UsageCounter);
}



inline
CGlobalId::~CGlobalId()
{
	DEBUGONLY(--m_UsageCounter);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// == operator
//
//-----------------------------------------------------------------------------
inline
int
CGlobalId::operator==(
		const CGlobalId& id)
		const
{
	return (m_dbid == id.m_dbid && m_otObjType == id.m_otObjType);
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// != operator
//
//-----------------------------------------------------------------------------
inline
int
CGlobalId::operator!=(
		const CGlobalId& id)
		const
{
	return !(m_dbid == id.m_dbid && m_otObjType == id.m_otObjType);
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Get the dbid
//
//-----------------------------------------------------------------------------

inline
const DBID &
CGlobalId::GetDBID()
		const
{
	return m_dbid;
}


inline
ObjectType
CGlobalId::GetObjType(void)
		const
{
	return m_otObjType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\location.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCATION.INL

History:

--*/

inline
void
CLocation::AssignFrom(
		const CLocation &other)
{
	m_giId = other.m_giId;
	m_TabId = other.m_TabId;
	m_View = other.m_View;
	m_Component = other.m_Component;
}



inline
BOOL
CLocation::Compare(
		const CLocation &other)
		const
{
	return m_giId == other.m_giId &&
		m_TabId == other.m_TabId &&
		m_View == other.m_View &&
		m_Component == other. m_Component;
}



inline
CLocation::CLocation()
{
	m_TabId = NullTabId;
	m_View = vNone;
	m_Component = cmpNone;
}



inline
CLocation::CLocation(
		const CLocation &Other)
{
	AssignFrom(Other);
}



inline
CLocation::CLocation(
		const CGlobalId &giId,
		View view,
		TabId tabId,
		Component component)
	: m_giId(giId), m_TabId(tabId), m_View(view), m_Component(component)
{}



inline
CLocation::CLocation(
		const DBID &dbid,
		ObjectType ot,
		View view,
		TabId tabId,
		Component component)
	: m_giId(dbid, ot), m_TabId(tabId), m_View(view), m_Component(component)
{}



inline
const CLocation &
CLocation::operator=(
		const CLocation &Other)
{
	AssignFrom(Other);

	return *this;
}



inline
int
CLocation::operator==(
		const CLocation &Other) const
{
	return Compare(Other);
}



inline
int
CLocation::operator!=(
		const CLocation &Other) const
{
	return !Compare(Other);
}



inline
const CGlobalId &
CLocation::GetGlobalId(void)
		const
{
	return m_giId;
}



inline
TabId
CLocation::GetTabId(void)
		const
{
	return m_TabId;
}



inline
View
CLocation::GetView(void)
		const
{
	return m_View;
}



inline
Component
CLocation::GetComponent(void)
		const
{
	return m_Component;
}



inline
BOOL
CLocation::IsVisual(void)
		const
{
	return (m_View == vVisualEditor);
}



inline
void
CLocation::SetGlobalId(
		const CGlobalId &gid)
{
	m_giId = gid;
}



inline
void
CLocation::SetTabId(
		const TabId TabId)
{
	m_TabId = TabId;
}



inline
void
CLocation::SetView(
		View vView)
{
	m_View = vView;
}



inline
void
CLocation::SetComponent(
		Component comp)
{
	m_Component = comp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\location.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCATION.H

History:

--*/

#ifndef ESPUTIL_LOCATION_H
#define ESPUTIL_LOCATION_H



typedef CWnd *TabId;
const TabId NullTabId = 0;

enum View
{
	vNone,
	vTransTab,
	vVisualEditor,
	vProjWindow
};

enum Component
{
	cmpNone,
	cmpSource,
	cmpTarget,
	cmpSourceAndTarget
};
	
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CLocation : public CObject
{
public:
	NOTHROW CLocation();
	NOTHROW CLocation(const CLocation &);
	NOTHROW CLocation(const CGlobalId &, View, TabId = NullTabId, Component = cmpNone);
	NOTHROW CLocation(const DBID &, ObjectType, View, TabId = NullTabId, Component = cmpNone);
	
#ifdef _DEBUG
	virtual void AssertValid(void) const;
#endif
	
	NOTHROW const CLocation & operator=(const CLocation &);
	NOTHROW int operator==(const CLocation &) const;
	NOTHROW int operator!=(const CLocation &) const;

	NOTHROW const CGlobalId & GetGlobalId(void) const;
	NOTHROW TabId GetTabId(void) const;
	NOTHROW View GetView(void) const;
	NOTHROW Component GetComponent(void) const;
	NOTHROW BOOL IsVisual(void) const;

	NOTHROW void SetGlobalId(const CGlobalId &);
	NOTHROW void SetTabId(const TabId);
	NOTHROW void SetView(View);
	NOTHROW void SetComponent(Component);

	NOTHROW ~CLocation() {};

private:
	NOTHROW void AssignFrom(const CLocation &);
	NOTHROW BOOL Compare(const CLocation &) const;
	
	CGlobalId m_giId;
	TabId m_TabId;
	View m_View;
	Component m_Component;
};

#pragma warning(default: 4275)

const extern LTAPIENTRY CLocation g_locNull;

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "location.inl"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\puid.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PUID.H

History:

--*/

#pragma once

struct LTAPIENTRY PUID
{
	PUID();
	PUID(ParserId pid, ParserId pidParent);
	CLString GetName(void) const;
	
	ParserId m_pid;
	ParserId m_pidParent;
};


#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "puid.inl"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\lunknown.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LUNKNOWN.H

History:

--*/
#if !defined (EspUtil_LUnknown_h)
#define EspUtil_LUnknown_h


////////////////////////////////////////////////////////////////////////////////
// CLUnknown
//
//	A abstract base class that is designed to help when creating child classes
//	that depend on a parent class.  These classes can not exist by themselves,
//	but instead mearly export different interfaces to the parent class.
//
// Rules:
//	1.	All classes must have a valid, non-NULL parent pointer.
//	2.	The parent class is responsible for AddRef()'ing itself during
//		QueryInterface().
//
////////////////////////////////////////////////////////////////////////////////

class LTAPIENTRY CLUnknown
{
// Construction
public:
	CLUnknown(IUnknown * pParent);
protected:  // Don't allow stack objects
	virtual ~CLUnknown() = 0;

// Data
protected:
	ULONG		m_ulRef;	// Reference count
	IUnknown *	m_pParent;	// Parent of object

// Operations
public:
	ULONG AddRef();
	ULONG Release();
	HRESULT QueryInterface(REFIID iid, LPVOID * ppvObject);
};
////////////////////////////////////////////////////////////////////////////////

#include "LUnknown.inl"

#if !defined(DECLARE_CLUNKNOWN)

#define DECLARE_CLUNKNOWN() \
public: \
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR*ppvObj); \
	STDMETHOD_(ULONG, AddRef)(THIS); \
	STDMETHOD_(ULONG, Release)(THIS);

#endif

#if !defined(IMPLEMENT_CLUNKNOWN)

#define IMPLEMENT_CLUNKNOWN_ADDREF(ObjectClass) \
	STDMETHODIMP_(ULONG) ObjectClass::AddRef(void) \
	{ \
		return CLUnknown::AddRef(); \
	}

#define IMPLEMENT_CLUNKNOWN_RELEASE(ObjectClass) \
	STDMETHODIMP_(ULONG) ObjectClass::Release(void) \
	{ \
		return CLUnknown::Release(); \
	}

#define IMPLEMENT_CLUNKNOWN_QUERYINTERFACE(ObjectClass) \
	STDMETHODIMP ObjectClass::QueryInterface(REFIID riid, LPVOID *ppVoid) \
	{ \
		return (HRESULT) CLUnknown::QueryInterface(riid, ppVoid); \
	}

#define IMPLEMENT_CLUNKNOWN(ObjectClass) \
	IMPLEMENT_CLUNKNOWN_ADDREF(ObjectClass) \
	IMPLEMENT_CLUNKNOWN_RELEASE(ObjectClass) \
	IMPLEMENT_CLUNKNOWN_QUERYINTERFACE(ObjectClass)

#endif




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\locitem.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCITEM.INL

History:

--*/

//  
//  Inline functions for the CLocItem class.  This is included by locitem.h.
//  
 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns whether or not the item has a localizable string.
//  
//-----------------------------------------------------------------------------
inline                                                                  
BOOL									// TRUE if there's a localizable string
CLocItem::HasLocString(void)
		const
{
	return !GetLocString().GetString().IsNull();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns whether or not the item has binary info.
//  
//-----------------------------------------------------------------------------
inline                                                                  
BOOL									// TRUE if the item has bin. content
CLocItem::HasBinary(void)
		const
{
	return m_pBinary!= NULL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the database id for the item.  This is internal to the DB, and
//  should not be used except to indicate parent child relationships and for
//  database operations.
//  
//-----------------------------------------------------------------------------
inline
const DBID&								// The database id for the item.
CLocItem::GetMyDatabaseId(void)
		const
{
	return m_dbid;
}





inline
const DBID &
CLocItem::GetPseudoParentId(void)
		const
{
	return m_PseudoParent;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the ID for the item.
//  
//-----------------------------------------------------------------------------
inline
const CLocUniqueId &
CLocItem::GetUniqueId(void)
	const
{
	return m_uid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the ID for the item.
//  
//-----------------------------------------------------------------------------
inline
CLocUniqueId &
CLocItem::GetUniqueId(void)
{
	return m_uid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current localization status for the translation of the item.
//  
//-----------------------------------------------------------------------------
inline
CLS::LocStatus							// Status for the item.
CLocItem::GetTranslationStatus(void)
		const
{
	return m_lsTranslationStatus;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current localization status for the binary part of the item.
//  
//-----------------------------------------------------------------------------
inline
CLS::LocStatus							// Status for the item.
CLocItem::GetBinaryStatus(void)
		const
{
	return m_lsBinaryStatus;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current translation origin for the item.
//  
//-----------------------------------------------------------------------------
inline
CTO::TranslationOrigin							// origin for the item.
CLocItem::GetTranslationOrigin(void)
		const
{
	return m_toTranslationOrigin;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current approval status for the item.
//  
//-----------------------------------------------------------------------------
inline
CAS::ApprovalState							// Status for the item.
CLocItem::GetApprovalStatus(void)
		const
{
	return m_asApprovalStatus;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current auto approval status for the item.
//  
//-----------------------------------------------------------------------------
inline
CAA::AutoApproved 						// Status for the item.
CLocItem::GetAutoApproved(void)
		const
{
	return m_auto_approved;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current confidence level for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetConfidenceLevel(void)
		const
{
	return m_confidence_level;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom1 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom1(void)
		const
{
	return m_custom1;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom2 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom2(void)
		const
{
	return m_custom2;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom3 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom3(void)
		const
{
	return m_custom3;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom4 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom4(void)
		const
{
	return m_custom4;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom5 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom5(void)
		const
{
	return m_custom5;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the current custom6 for the item.
//  
//-----------------------------------------------------------------------------
inline
long						
CLocItem::GetCustom6(void)
		const
{
	return m_custom6;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets the display order for the item. This is used to provide a default
//  ordering of items in the resource table.  Lower values are displayed first.
//  
//-----------------------------------------------------------------------------
inline
UINT									// Display order for the item.
CLocItem::GetDisplayOrder(void)
		const
{
	return m_uiDisplayOrder;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the CLocString for the item.  To determine if it is valid, use
//  HasLocString().  A valid string can be blank!
//  
//-----------------------------------------------------------------------------
inline
const CLocString &						// Current string for the item.
CLocItem::GetLocString(void)
	const
{
	return m_lsString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the 'intructions' (developer provided comments) for an item.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Developer intructions.
CLocItem::GetInstructions(void)
		const
{
	return m_pstrInstructions;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the 'term notes' (glossary note) for an item.
//  
//-----------------------------------------------------------------------------
inline
const CPascalString &					// Glossary Notes.
CLocItem::GetTermNotes(void)
		const
{
	return m_pstrTermNotes;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get the 'InstrAtt'  for an item.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFInstrAtt(void)
		const
{
	return m_Flags.m_fInstrAtt;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Gets the binary content for an item.  If this function returns FALSE, the
//  return pointer is set to NULL.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if the content is valid.
CLocItem::GetBinary(
		const CLocBinary *&pBinary) // RETURN pointer
		const
{
	pBinary = m_pBinary;
	
	return pBinary != NULL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//	Similar to GetBinary() but after this call
//	the item will no longer have a CLocBinary.
//	By calling this member, the caller gets
//	ownership of the CLocBinary, so he is responsible
//	of either deleting the CLocBinary or assigning
//	it to another CLocItem via the SetBinary() member.
//  
//-----------------------------------------------------------------------------
inline
BOOL									// TRUE if a CLocBinary was extracted.
CLocItem::ExtractBinary(
		CLocBinary *&pBinary) // RETURN pointer
{
	pBinary = m_pBinary;
	m_pBinary = NULL;
	
	return pBinary != NULL;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the icon type fro the item.
//  
//-----------------------------------------------------------------------------
inline
CIT::IconType
CLocItem::GetIconType(void)
		const
{
	return m_icIconType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Returns the editor for this item (and all it's children!).
//  
//-----------------------------------------------------------------------------
inline
VisualEditor
CLocItem::GetVisualEditor(void)
		const
{
	return m_veEditor;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the database id for the item.  ONLY the database code should use
//  this method.  This may become protected/private in the future!
//
//  The Database id will not allow itself be set twice!
//
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetMyDatabaseId(
		const DBID& dbid)				// New datbase id for this item.
{
	m_dbid = dbid;
}



inline void
CLocItem::SetPseudoParent(
		const DBID &dbid)
{
	m_PseudoParent.Clear();
	
	m_PseudoParent = dbid;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the localization status for the translation part of the item.  
//  This is of interest to the Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetTranslationStatus(
		CLS::LocStatus lsNewStatus)		// New status for the item.
{
	m_lsTranslationStatus = lsNewStatus;

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the localization status for the binary part of the item.  
//  This is of interest to the Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetBinaryStatus(
		CLS::LocStatus lsNewStatus)		// New status for the item.
{
	m_lsBinaryStatus = lsNewStatus;

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the translation origin for the item.  This is of interest to the
//  Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetTranslationOrigin(
		CTO::TranslationOrigin toNewOrigin)		// New origin for the item.
{
	m_toTranslationOrigin = toNewOrigin;

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the approval status for the item.  
//  This is of interest to the Updater code, for example.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetApprovalStatus(
		CAS::ApprovalState asNewStatus)		// New status for the item.
{
	m_asApprovalStatus = asNewStatus;

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the auto approval status for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetAutoApproved(
		CAA::AutoApproved aaNewStatus)		// New status for the item.
{
	m_auto_approved = aaNewStatus;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the confidence level for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetConfidenceLevel(
		long lConfLevel)		// New confidence level for the item.
{
	m_confidence_level = lConfLevel;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom1 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom1(
		long lCustom1)		
{
	m_custom1 = lCustom1;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom2 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom2(
		long lCustom2)		
{
	m_custom2 = lCustom2;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom3 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom3(
		long lCustom3)		
{
	m_custom3 = lCustom3;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom4 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom4(
		long lCustom4)		
{
	m_custom4 = lCustom4;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom5 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom5(
		long lCustom5)		
{
	m_custom5 = lCustom5;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the custom6 for the item.  
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetCustom6(
		long lCustom6)		
{
	m_custom6 = lCustom6;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the display order for an item.  This is used to provide a default
//  ordering of items in the resource table.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetDisplayOrder(
		UINT uiNewDisplayOrder)			// New display order for the item.
{
	m_uiDisplayOrder = uiNewDisplayOrder;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the visual editor for the item.  The parser sets this.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetVisualEditor(
		VisualEditor veNewEditor)
{
	m_veEditor = veNewEditor;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Set the icon type.  This is displayed bside the item in the Translation
//  table.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetIconType(
		CIT::IconType itNewIconType)
{
	m_icIconType = itNewIconType;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the intstructions for the item.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetInstructions(
		const CPascalString &pstrNewInstructions) // New instructions.
{
	if (pstrNewInstructions != m_pstrInstructions)
	{
		m_pstrInstructions = pstrNewInstructions;
		SetFInstructionsDirty(TRUE);
	}
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the term notes for the item.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetTermNotes(
		const CPascalString &pstrNewTermNotes) // New Term Notes.
{
	if (pstrNewTermNotes != m_pstrTermNotes)
	{
		m_pstrTermNotes = pstrNewTermNotes;
	}
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the InstrAtt for the item.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetFInstrAtt(
		BOOL f)
{
	m_Flags.m_fInstrAtt = f;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clears all the dirty flags for the item and its sub-components.
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::ClearDirtyFlags(void)
{
	m_Flags.m_fTargetStringDirty = m_Flags.m_fStringDirty = 
			m_Flags.m_fItemDirty = m_Flags.m_fInstructionsDirty = 0;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clear/Set various internal state flags
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFEqualSrcTgtString(void) const
{
	return m_Flags.m_fEqualSrcTgtString;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO (eduardof) - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetFEqualSrcTgtString(BOOL f)
{
	m_Flags.m_fEqualSrcTgtString = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO (eduardof) - comment this function
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFEqualSrcTgtBinary(void) const
{
	return m_Flags.m_fEqualSrcTgtBinary;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  TODO (eduardof) - comment this function
//  
//-----------------------------------------------------------------------------
inline
void
CLocItem::SetFEqualSrcTgtBinary(BOOL f)
{
	m_Flags.m_fEqualSrcTgtBinary = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Get and set methods for all the Dirty flags.  Used by the update code.
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFStringDirty(void) const
{
	return m_Flags.m_fStringDirty;
}

inline
void
CLocItem::SetFStringDirty(BOOL f)
{
	m_Flags.m_fStringDirty = f;
}

inline
BOOL
CLocItem::GetFTargetStringDirty(void) const
{
	return m_Flags.m_fTargetStringDirty;
}

inline
void
CLocItem::SetFTargetStringDirty(BOOL f)
{
	m_Flags.m_fTargetStringDirty = f;
}

inline
BOOL
CLocItem::GetFItemDirty(void) const
{
	return m_Flags.m_fItemDirty;
}

inline
void
CLocItem::SetFItemDirty(BOOL f)
{
	m_Flags.m_fItemDirty = f;
}

inline
BOOL
CLocItem::GetFInstructionsDirty(void)
		const
{
	return m_Flags.m_fInstructionsDirty;
}

inline
void
CLocItem::SetFInstructionsDirty(
		BOOL f)
{
	m_Flags.m_fInstructionsDirty = f;
}

inline
BOOL
CLocItem::GetFValidTranslation(void) const
{
	return m_Flags.m_fValidTranslation;
}

inline
void
CLocItem::SetFValidTranslation(BOOL f)
{
	m_Flags.m_fValidTranslation = f;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Global is anything in this CBinary dirty
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::IsAnyDirty()
{
	return m_Flags.m_fItemDirty ||
		m_Flags.m_fStringDirty || 
		m_Flags.m_fTargetStringDirty ||
		m_Flags.m_fInstructionsDirty ||
		(m_pBinary==NULL ? FALSE : m_pBinary->GetFBinaryDirty());
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Clear/Set various parser flags
//  
//-----------------------------------------------------------------------------
inline
BOOL
CLocItem::GetFDevLock(void) const
{
	return m_Flags.m_fDevLock;
}

inline
void
CLocItem::SetFDevLock(BOOL f)
{
	m_Flags.m_fDevLock = f;
}

inline
BOOL
CLocItem::GetFUsrLock(void) const
{
	return m_Flags.m_fUsrLock;
}
inline
void
CLocItem::SetFUsrLock(BOOL f)
{
	m_Flags.m_fUsrLock = f;
}

inline
BOOL
CLocItem::GetFTransLock(void) const
{
	return m_Flags.m_fTransLock;
}
inline
void
CLocItem::SetFTransLock(BOOL f)
{
	m_Flags.m_fTransLock = f;
}


inline
BOOL
CLocItem::GetFExpandable(void) const
{
	return m_Flags.m_fExpandable;
}

inline
void
CLocItem::SetFExpandable(BOOL f)
{
	m_Flags.m_fExpandable = f;
}

inline
BOOL
CLocItem::GetFDisplayable(void) const
{
	return m_Flags.m_fDisplayable;
}

inline
void
CLocItem::SetFDisplayable(BOOL f)
{
	m_Flags.m_fDisplayable = f;
}

inline
BOOL
CLocItem::GetFNoResTable(void) const
{
	return m_Flags.m_fNoResTable;
}

inline
void
CLocItem::SetFNoResTable(BOOL f)
{
	m_Flags.m_fNoResTable = f;
}



inline
void
CLocItem::SetLocString(
		const CLocString &lsNewString)
{
	m_lsString = lsNewString;
}



inline
void
CLocItem::SetUniqueId(
		const CLocUniqueId &uid)
{
	m_uid = uid;
}



inline
void
CLocItem::ClearUniqueId(void)
{
	m_uid.ClearId();
}


	
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Sets the binary content for the item.  If there was a previous binary
//  content, it is deleted.
//  
//-----------------------------------------------------------------------------
inline 
void
CLocItem::SetBinary(
		CLocBinary *pNewBinary)
{
	if (m_pBinary != NULL)
	{
		delete m_pBinary;
	}
	m_pBinary = pNewBinary;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the item editable?
//  
//-----------------------------------------------------------------------------
inline
BOOL 
CLocItem::IsLocked(void) const
{
	return (GetFDevLock() || GetFUsrLock());
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Is the item ignored by the visual editor
//  
//-----------------------------------------------------------------------------
inline
BOOL CLocItem::GetFVisEditorIgnore(void) const
{
	return m_Flags.m_fVisEditorIgnore;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Set if the item is ignored by the visual editor
//  
//-----------------------------------------------------------------------------
inline
void 
CLocItem::SetFVisEditorIgnore(BOOL f)
{
	m_Flags.m_fVisEditorIgnore = f; 
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  Needed so that the CMnemonic class can be used as the key of a CMap
//  
//-----------------------------------------------------------------------------
inline
CMnemonic::operator unsigned long() const
{
	return MAKELONG(m_cHotkeyChar, m_nHotkeyScope);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\locitem.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    LOCITEM.H

History:

--*/
#ifndef LOCITEM_H
#define LOCITEM_H



#pragma warning(disable : 4251)  // Shut up already about _declspec(import)
#pragma warning(disable : 4275)  // Shut up already about _declspec(export)

class CLocItem;


//
//  Class to hold an array of pointers to items.
//
class LTAPIENTRY CLocItemPtrArray : public CTypedPtrArray<CPtrArray, CLocItem *>
{
public:
	NOTHROW CLocItemPtrArray(BOOL fDelete=TRUE);

	void AssertValid(void) const;

	void NOTHROW ClearItemPtrArray(void);
	int NOTHROW Find(DBID, const CLocItem * &, BOOL bLocalizableOnly = FALSE) const;

	virtual ~CLocItemPtrArray();

private:
	CLocItemPtrArray(const CLocItemPtrArray &);
	void operator=(const CLocItemPtrArray &);

	BOOL m_fDelete;
};


//
//  Class to hold an item set.  This is an array of items that all have the
//  same identifier.
//
class LTAPIENTRY CLocItemSet : public CLocItemPtrArray
{
public:
	NOTHROW CLocItemSet(BOOL fDelete=TRUE);

	void AssertValid(void) const;
	
	NOTHROW const CLocUniqueId & GetUniqueId(void) const;
	NOTHROW const DBID & GetPseudoParentId(void) const;

	NOTHROW void ClearItemSet(void);

	NOTHROW void Match(const CLocItemSet &, CMap<int, int, int, int> &);

	NOTHROW int Find(CLocItem * pItem, int nStartAt = 0);
	
	NOTHROW ~CLocItemSet();
	
private:
	static const CLocUniqueId m_luid;     //This is a default last ditch 
	DEBUGONLY(static CCounter m_UsageCounter);
};

//
//  A localizable item. 
//  It represents either source or target data, depending on the context, but not both.
//
class LTAPIENTRY CLocItem : public CObject
{
public:
	NOTHROW CLocItem();

	void AssertValid(void) const;
	
	//
	//  Read-only access members
	//
	NOTHROW BOOL HasLocString(void) const;
	NOTHROW BOOL HasBinary(void) const;
	
	NOTHROW const DBID & GetMyDatabaseId(void) const;
	NOTHROW const CLocUniqueId & GetUniqueId(void) const;
	const DBID &GetPseudoParentId(void) const;
	NOTHROW CLocUniqueId & GetUniqueId(void);
	
	NOTHROW CLS::LocStatus GetTranslationStatus(void) const;
	NOTHROW CLS::LocStatus GetBinaryStatus(void) const;
	NOTHROW CTO::TranslationOrigin GetTranslationOrigin(void) const;
	NOTHROW CAS::ApprovalState GetApprovalStatus(void) const;
	NOTHROW CAA::AutoApproved GetAutoApproved(void) const;
	NOTHROW long GetConfidenceLevel(void) const;
	NOTHROW long GetCustom1(void) const;
	NOTHROW long GetCustom2(void) const;
	NOTHROW long GetCustom3(void) const;
	NOTHROW long GetCustom4(void) const;
	NOTHROW long GetCustom5(void) const;
	NOTHROW long GetCustom6(void) const;

	NOTHROW const CLocString & GetLocString(void) const;
	
	NOTHROW BOOL GetBinary(const CLocBinary *&) const;

	NOTHROW CIT::IconType GetIconType(void) const;
	NOTHROW const CPascalString & GetInstructions(void) const;
	NOTHROW const CPascalString GetInstructions(BOOL) const;
	NOTHROW const CPascalString & GetTermNotes(void) const;
	NOTHROW UINT GetDisplayOrder(void) const;
	NOTHROW VisualEditor GetVisualEditor(void) const;

	NOTHROW BOOL GetFEqualSrcTgtString(void) const;
	NOTHROW void SetFEqualSrcTgtString(BOOL);
	NOTHROW BOOL GetFEqualSrcTgtBinary(void) const;
	NOTHROW void SetFEqualSrcTgtBinary(BOOL);
	NOTHROW BOOL GetFStringDirty(void) const;
	NOTHROW void SetFStringDirty(BOOL);
	NOTHROW BOOL GetFTargetStringDirty(void) const;
	NOTHROW void SetFTargetStringDirty(BOOL);
	NOTHROW BOOL GetFItemDirty(void) const;
	NOTHROW void SetFItemDirty(BOOL);
	NOTHROW BOOL IsAnyDirty(void);
	NOTHROW BOOL IsLocked(void) const;

	NOTHROW BOOL GetFDevLock(void) const;
	NOTHROW void SetFDevLock(BOOL);
	NOTHROW BOOL GetFTransLock(void) const;
	NOTHROW void SetFTransLock(BOOL);
	NOTHROW BOOL GetFUsrLock(void) const;
	NOTHROW void SetFUsrLock(BOOL);
	NOTHROW BOOL GetFExpandable(void) const;
	NOTHROW void SetFExpandable(BOOL);
	NOTHROW BOOL GetFDisplayable(void) const;
	NOTHROW void SetFDisplayable(BOOL);
	NOTHROW BOOL GetFNoResTable(void) const;
	NOTHROW void SetFNoResTable(BOOL);
	NOTHROW BOOL GetFValidTranslation(void) const;
	NOTHROW void SetFValidTranslation(BOOL);
	NOTHROW BOOL GetFVisEditorIgnore(void) const;
	NOTHROW void SetFVisEditorIgnore(BOOL);

	NOTHROW void SetFInstructionsDirty(BOOL);
	NOTHROW BOOL GetFInstructionsDirty(void) const;
	
	NOTHROW void SetFInstrAtt(BOOL);
	NOTHROW BOOL GetFInstrAtt(void) const;

	//
	//  Assignment members.  These set the appropriate dirty flags in the
	//  item.
	//

	NOTHROW void SetMyDatabaseId(const DBID&);
	NOTHROW void SetUniqueId(const CLocUniqueId &);
	NOTHROW void SetPseudoParent(const DBID &);
	NOTHROW void SetLocString(const CLocString &);
	NOTHROW void ClearUniqueId(void);
	NOTHROW void SetTranslationStatus(CLS::LocStatus);
	NOTHROW void SetBinaryStatus(CLS::LocStatus);
	NOTHROW void SetTranslationOrigin(CTO::TranslationOrigin);
	NOTHROW void SetApprovalStatus(CAS::ApprovalState);
	NOTHROW void SetAutoApproved(CAA::AutoApproved);
	NOTHROW void SetConfidenceLevel(long);
	NOTHROW void SetCustom1(long);
	NOTHROW void SetCustom2(long);
	NOTHROW void SetCustom3(long);
	NOTHROW void SetCustom4(long);	
	NOTHROW void SetCustom5(long);
	NOTHROW void SetCustom6(long);
	NOTHROW void SetIconType(CIT::IconType);
	NOTHROW void SetInstructions(const CPascalString &);
	NOTHROW void SetTermNotes(const CPascalString &);
	NOTHROW void SetDisplayOrder(UINT);
	NOTHROW void SetVisualEditor(VisualEditor);


	//
	//  Setting the binary part will delete the
	//  previous one!
	//
	NOTHROW void SetBinary(CLocBinary *);

	NOTHROW BOOL ExtractBinary(CLocBinary *&);

	NOTHROW void TransferBinary(CLocItem *);

	//
	//  Clear ALL the dirty flags for the item.
	//
	NOTHROW void ClearDirtyFlags(void);

	//	Kind of smart assignment
	BOOL UpdateFrom(CLocItem &);

	enum eLocContent
	{
		Source,
		Target
	};

	enum eDataFlow
	{
		FromFileToDb,
		FromDbToFile
	};
	//	Kind of assignment for localizable content only.
	BOOL UpdateLocContentFrom(
		CLocItem & itemInput, 
		eDataFlow nDataFlow, 
		eLocContent nFrom, 
		eLocContent nTo);
	//Used to know how similar is the localizable content between 2 items
	enum eMatchType
	{
		matchEmpty,
		matchBinary,
		matchString,
		matchFull
	};
	int MatchLocContent(const CLocItem &);
	//
	//  Comparisons between localizable items.
	//
	NOTHROW int operator==(const CLocItem &) const;
	NOTHROW int operator!=(const CLocItem &) const;

	NOTHROW BOOL BobsConsistencyChecker(void) const;
	
	virtual ~CLocItem();

protected:
	
	//
	//  Private helper functions.
	//
	NOTHROW BOOL CompareItems(const CLocItem &);
	
private:

	//
	//  Flags that apply to the entire item.  These control the display and
	//  editablity and internal status of an item.
	//
	struct Flags
	{
		BOOL m_fDevLock           :1; // Resource locked (in source file) from parser data
		BOOL m_fUsrLock           :1; // Resource locked (by user) from parser data
		BOOL m_fTransLock         :1; // Resource locked (for the user) from parser data
		BOOL m_fExpandable        :1; // Expandable in project window
		BOOL m_fDisplayable       :1; // Display in project window
		BOOL m_fNoResTable        :1; // Don't display in res table
		BOOL m_fStringDirty       :1; // has the source locstring changed?
		BOOL m_fTargetStringDirty :1; // has the target locstring changed?
		BOOL m_fItemDirty         :1; // has any other part of the item changed?
		BOOL m_fEqualSrcTgtString :1; // are the src&tgt strings equal?
		BOOL m_fEqualSrcTgtBinary :1; // are the src&tgt binaries equal?
		BOOL m_fValidTranslation  :1; // is the target string (the translation) good 
									  // for an autotranslate ?
		BOOL m_fVisEditorIgnore   :1; // is the item ignored in the visual editor?
									  // in memory state only.
		BOOL m_fInstructionsDirty :1;
		BOOL m_fInstrAtt		  :1; // has the instruction changed by Update command?
	};

	//
	//  Prevents the default copy constructor from being called.
	//
	CLocItem(const CLocItem &);
	virtual void Serialize(CArchive &) {}
	const CLocItem &operator=(const CLocItem &);
	
	//
	//  Item data.
	//

	//Language-independent members
	DBID           m_dbid;             //Id of item within the db
	DBID           m_PseudoParent;
	CLocUniqueId   m_uid;
	CLocString     m_lsString;
	CIT::IconType  m_icIconType;       //UI Icon that visually indicates item type
	CPascalString  m_pstrInstructions; //Instructions on how to localize the item
	CPascalString  m_pstrTermNotes;    // glossary notes 
	CLS::LocStatus m_lsTranslationStatus;		// Translation Loc status
	CLS::LocStatus m_lsBinaryStatus;			// Binary Loc status
	CTO::TranslationOrigin m_toTranslationOrigin;	// translation origin
	CAS::ApprovalState	m_asApprovalStatus;
	CAA::AutoApproved m_auto_approved;		// AUTO APPROVED
	long m_confidence_level;				// confidence level
	long m_custom1;							// CUSTOM1
	long m_custom2;							// CUSTOM2
	long m_custom3;							// CUSTOM3
	long m_custom4;							// CUSTOM4
	long m_custom5;							// CUSTOM5
	long m_custom6;							// CUSTOM6
	VisualEditor   m_veEditor;         //Graphical editor used for the item
	Flags          m_Flags;            //Various flags

	//Language-dependent members
	UINT           m_uiDisplayOrder;   //Physical order of item in the file
	CLocBinary    *m_pBinary;        //Parser-specific properties

	DEBUGONLY(static CCounter m_UsageCounter);
};

//
//  Callback class used to provide information about
//  items to the item log.
//
class LTAPIENTRY CItemInfo
{
public:
	CItemInfo() {};
	
	virtual ~CItemInfo() {};

	virtual CLString GetFileName(const CLocItem *) = 0;
	virtual CLString GetItemName(const CLocItem *) = 0;
	
private:
	CItemInfo(const CItemInfo &);
	const CItemInfo & operator=(const CItemInfo &);
};



//Classes used to retrieve mnemonics (aka hotkeys) from parsers
class LTAPIENTRY CMnemonic
{
public:
	NOTHROW operator unsigned long() const;
	WCHAR m_cHotkeyChar;
	WORD m_nHotkeyScope;

};

class LTAPIENTRY CMnemonicsMap : public CMap<CMnemonic, CMnemonic &,
					  CLocItemPtrArray *, CLocItemPtrArray * &>
{
public:
	CMnemonicsMap() 
	{};

	~CMnemonicsMap();

private:
	CMnemonicsMap(const CMnemonicsMap &);
	void operator=(int);
};


#pragma warning(default : 4251)

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "locitem.inl"
#endif

#endif // LOCITEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\puid.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    PUID.INL

History:

--*/

inline
PUID::PUID()
{
	m_pid = pidNone;
	m_pidParent = pidNone;
}



inline
PUID::PUID(
		ParserId pid,
		ParserId pidParent)
{
	m_pid = pid;
	m_pidParent = pidParent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\reporter.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    REPORTER.INL

History:

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\lunknown.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    IUNKNOWN.INL

History:

--*/

//*****************************************************************************
//
// CLUnknown Constructions / Destruction
//
//*****************************************************************************

///////////////////////////////////////////////////////////////////////////////
inline 
CLUnknown::CLUnknown(
		IUnknown * pParent
		)
{
	LTASSERT(pParent != NULL);

	m_ulRef = 0;
	m_pParent = pParent;
	m_pParent->AddRef();
//	AddRef();  // Don't AddRef() itself.  The caller is expected to do this
}


///////////////////////////////////////////////////////////////////////////////
inline 
CLUnknown::~CLUnknown()
{
	LTASSERT(m_ulRef == 0);

	LTASSERT(m_pParent != NULL);
	m_pParent->Release();	
}


//*****************************************************************************
//
// CLUnknown Operations
//
//*****************************************************************************

///////////////////////////////////////////////////////////////////////////////
inline 
ULONG
CLUnknown::AddRef()
{
	return ++m_ulRef;
}


///////////////////////////////////////////////////////////////////////////////
inline 
ULONG
CLUnknown::Release()
{
	LTASSERT(m_ulRef > 0);

	if (--m_ulRef == 0)
	{
		delete this;
		return 0;
	}

	return m_ulRef;
}


///////////////////////////////////////////////////////////////////////////////
inline 
HRESULT
CLUnknown::QueryInterface(REFIID iid, LPVOID * ppvObject)
{
	LTASSERT(ppvObject != NULL);

	return m_pParent->QueryInterface(iid, ppvObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\reporter.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    REPORTER.H

History:

--*/

//  
//  Mechanism for reporting messages and such to people.
//  
 
#ifndef ESPUTIL_REPORTER_H
#define ESPUTIL_REPORTER_H



//
//  Basic output mechanism for Espresso 2.x.  Allows the caller to uniformly
//  report messages of various severities to the user without worrying about
//  the exact implementation or destination.
//
//  We provide ways of outputting strings, or for loading messages from string
//  tables and outputting those.
//
//  The confidence level allow the caller to tell the Reporter that messages
//  will actually provide meaningful information.  This is used (in particular)
//  in the parsers when a file has not yet ever been parsed.
//
#pragma warning(disable: 4275)			// non dll-interface class 'foo' used
										// as base for dll-interface class 'bar' 

class LTAPIENTRY CReporter : public CReport
{
public:
	CReporter() {};

	void AssertValid(void) const;


 	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, CGoto *pGoto = NULL,
			CGotoHelp *pGotoHelp = NULL) = 0;
	//
	//  The usage of these versions of IssueMessage is discouraged.  Use the
	//  versions with the CGoto objects instead.
	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			const CLString &strMessage, const CLocation &,
			UINT uiHelpContext = 0);

	virtual void IssueMessage(MessageSeverity,
			const CPascalString &strContext, const CLString &strMessage,
			const CLocation &, UINT uiHelpContext = 0);

	virtual void IssueMessage(MessageSeverity, const CLString &strContext,
			HMODULE hResourceModule, UINT uiStringId, const CLocation &,
			UINT uiHelpContext = 0);

	virtual void IssueMessage(MessageSeverity, HMODULE hResourceModule,
			UINT uiContext, const CLString &strMessage ,
			const CLocation &, UINT uiHelpContext = 0);
	
	virtual void IssueMessage(MessageSeverity, HMODULE hResourceModule,
			UINT uiContext, UINT uiStringId, const CLocation &,
			UINT uiHelpContext = 0);


	virtual void IssueMessage(MessageSeverity, const CContext &context,
			const CLString &strMessage, UINT uiHelpId = 0);
	virtual void IssueMessage(MessageSeverity, const CContext &context,
			HMODULE hResourceModule, UINT uiStringId, UINT uiHelpId = 0);
	
	virtual ~CReporter();

private:
	//
	//  Prevent usage of copy constructor or assignment operator.
	//
	CReporter(const CReporter &);
	const CReporter &operator=(const CReporter &);

};

#pragma warning(default: 4275)


#endif // ESPUTIL_REPORTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\resid.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    RESID.H

History:

--*/

#ifndef RESID_H
#define RESID_H


class LTAPIENTRY CLocResId : public CLocId
{
public:
	NOTHROW CLocResId();

	void AssertValid(void) const;

	const CLocResId &operator=(const CLocResId &);

	int NOTHROW operator==(const CLocResId &) const;
	int NOTHROW operator!=(const CLocResId &) const;

	void Serialize(CArchive &ar);

protected:

private:
};

#if !defined(_DEBUG) || defined(IMPLEMENT)
#include "resid.inl"
#endif

#endif  // RESID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\resid.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    RESID.INL

History:

--*/

//  
//  Inline funxtions for the Resource ID.  This file should ONLY be included
//  by resid.h.
//  
 
//-----------------------------------------------------------------------------
//  
//  File: resid.inl
//
//-----------------------------------------------------------------------------
 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  
//  All methods directed to base class
//  
//-----------------------------------------------------------------------------

inline
CLocResId::CLocResId()
{}



inline
const CLocResId &
CLocResId::operator=(
		const CLocResId & locId)
{
	CLocId::operator=(locId);
	return *this;
}


inline
int
CLocResId::operator==(
		const CLocResId & locId)
		const
{
	return CLocId::operator==(locId);
}


inline
int
CLocResId::operator!=(
		const CLocResId & locId)
		const
{
	return CLocId::operator!=(locId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\stdafx.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    STDAFX.H

History:

--*/

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#pragma warning(disable : 4663 )
#pragma warning(disable : 4665 )

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#pragma warning(disable : 4664 )
#include <afxtempl.h>

#include <mitutil.h>
#include <locutil.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\tools\locstudioparser\inc\esputil\resource.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    RESOURCE.H

History:

--*/
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Espresso.rc
//
#define IDS_NOTE                        12746
#define IDS_WARNING                     12747
#define IDS_ERROR                       12748
#define IDS_ABORT                       12749
#define IDS_SHUTDOWN                    12750
#define IDS_OUTTAB_FILE                 12751
#define IDS_OUTTAB_TEST                 12752
#define IDS_OUTTAB_GBOX                 12753
#define IDS_OUTTAB_LOCK                 12754
#define IDS_OUTTAB_UPDATE               12755
#define IDS_OUTTAB_MESSAGES             12756
#define IDS_SETTINGS_CTX                12766
#define IDS_SETTINGS_INDENT             12767
#define IDS_SETTINGS_SEP                12768
#define IDS_SETTINGS_DEFAULT            12769
#define IDS_SETTINGS_USER               12770
#define IDS_SETTINGS_OVERRIDE           12771
#define IDS_DISP_ICON                   12772
#define IDS_DISP_SOURCE                 12773
#define IDS_DISP_TRANSLATION            12774
#define IDS_DISP_PREVIOUS               12775
#define IDS_DISP_INSTRUCTIONS           12776
#define IDS_DISP_TERM_NOTE              12777
#define IDS_DISP_RESOURCE_ID            12778
#define IDS_DISP_TRANSLATION_STATUS     12779
#define IDS_DISP_BINARY_STATUS          12780
#define IDS_DISP_TRANSLATION_ORIGIN     12781
#define IDS_DISP_STRING_CATEGORY        12782
#define IDS_DISP_APPROVAL               12783
#define IDS_DISP_LOCK                   12784
#define IDS_DISP_SRC_LOCK               12785
#define IDS_DISP_PARSER_ID              12786
#defi