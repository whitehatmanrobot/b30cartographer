                          DirInfo->Name.Length
                                 );
                    lpTargetPath += ucchName;
                    *lpTargetPath++ = UNICODE_NULL;
                    ucchReturned += ucchName + 1;
                    nElements++;
                }

                RestartScan = FALSE;
            }

            if ( (BaseStaticServerData->LUIDDeviceMapsEnabled == TRUE) &&
                 (NT_SUCCESS( Status )) &&
                 ScanGlobalDeviceMap == TRUE) {
                //
                // need to perform a second scan for the
                // global device map because the first scan only
                // searches the LUID device map
                //

                //
                // close DirectoryHandle, set to NULL
                //
                if( DirectoryHandle != NULL ) {
                    NtClose( DirectoryHandle );
                    DirectoryHandle = NULL;
                }

                //
                // open the global device map
                //
                RtlInitUnicodeString( &UnicodeString, L"\\GLOBAL??" );

                InitializeObjectAttributes( &Attributes,
                                            &UnicodeString,
                                            OBJ_CASE_INSENSITIVE,
                                            NULL,
                                            NULL
                                          );
                Status = NtOpenDirectoryObject( &DirectoryHandle,
                                                DIRECTORY_QUERY,
                                                &Attributes
                                              );

                if (!NT_SUCCESS( Status )) {
                    DirectoryHandle = NULL;
                    leave;
                }

                //
                // perform the second scan
                // scan the global device map
                //
                RestartScan = TRUE;
                while (TRUE) {
                    Status = NtQueryDirectoryObject( DirectoryHandle,
                                                     (PVOID)DirInfo,
                                                     sizeof( DirInfoBuffer ),
                                                     TRUE,
                                                     RestartScan,
                                                     &Context,
                                                     &ReturnedLength
                                                   );

                    //
                    //  Check the status of the operation.
                    //

                    if (!NT_SUCCESS( Status )) {
                        if (Status == STATUS_NO_MORE_ENTRIES) {
                            Status = STATUS_SUCCESS;
                        }

                        break;
                    }

                    if (!wcscmp( DirInfo->TypeName.Buffer, L"SymbolicLink" )) {
                        Result = FindSymbolicLinkEntry(
                                                DirInfo->Name.Buffer,
                                                lpBuffer,
                                                nElements,
                                                &DuplicateEntry);

                        if ((Result == NO_ERROR) && (DuplicateEntry == FALSE)) {
                            ucchName = DirInfo->Name.Length / sizeof( WCHAR );
                            if ((ucchReturned + ucchName + 1 + 1) > ucchMax) {
                                ucchReturned = 0;
                                Status = STATUS_BUFFER_TOO_SMALL;
                                break;
                            }
                            RtlCopyMemory( lpTargetPath,
                                           DirInfo->Name.Buffer,
                                           DirInfo->Name.Length
                                         );
                            lpTargetPath += ucchName;
                            *lpTargetPath++ = UNICODE_NULL;
                            ucchReturned += ucchName + 1;
                        }
                    }

                    RestartScan = FALSE;
                }

            }

            if (NT_SUCCESS( Status )) {
                *lpTargetPath++ = UNICODE_NULL;
                ucchReturned++;
            }
        }
    } finally {
        if( DirectoryHandle != NULL ) {
            NtClose( DirectoryHandle );
        }
    }

    if (!NT_SUCCESS( Status )) {
        ucchReturned = 0;
        BaseSetLastNTError( Status );
    }

    return ucchReturned;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\filehops.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    filehops.c

Abstract:

    This module implements Win32 file handle APIs

Author:

    Mark Lucovsky (markl) 25-Sep-1990

Revision History:

--*/

#include "basedll.h"
#include "winioctl.h"

HANDLE
WINAPI
GetStdHandle(
    DWORD nStdHandle
    )
{
    PPEB Peb;
    HANDLE rv;


    Peb = NtCurrentPeb();
    switch( nStdHandle ) {
        case STD_INPUT_HANDLE:
            rv = Peb->ProcessParameters->StandardInput;
            break;

        case STD_OUTPUT_HANDLE:
            rv = Peb->ProcessParameters->StandardOutput;
            break;

        case STD_ERROR_HANDLE:
            rv = Peb->ProcessParameters->StandardError;
            break;
        default:
            rv = INVALID_HANDLE_VALUE;
            break;
    }
    if ( rv == INVALID_HANDLE_VALUE ) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        }
    return rv;
}

BOOL
WINAPI
SetStdHandle(
    DWORD nStdHandle,
    HANDLE hHandle
    )
{
    PPEB Peb;

    Peb = NtCurrentPeb();
    switch( nStdHandle ) {
        case STD_INPUT_HANDLE:
            Peb->ProcessParameters->StandardInput = hHandle;
            break;

        case STD_OUTPUT_HANDLE:
            Peb->ProcessParameters->StandardOutput = hHandle;
            break;

        case STD_ERROR_HANDLE:
            Peb->ProcessParameters->StandardError = hHandle;
            break;

        default:
            BaseSetLastNTError(STATUS_INVALID_HANDLE);
            return FALSE;
    }

    return( TRUE );
}

DWORD
WINAPI
GetFileType(
    HANDLE hFile
    )

/*++

Routine Description:

    GetFileType is used to determine the file type of the specified file.

Arguments:

    hFile - Supplies an open handle to a file whose type is to be
        determined

Return Value:

    FILE_TYPE_UNKNOWN - The type of the specified file is unknown.

    FILE_TYPE_DISK - The specified file is a disk file.

    FILE_TYPE_CHAR - The specified file is a character file (LPT,
        console...)

    FILE_TYPE_PIPE - The specified file is a pipe (either a named pipe or
        a pipe created by CreatePipe).

--*/

{
    NTSTATUS Status;
    FILE_FS_DEVICE_INFORMATION DeviceInformation;
    IO_STATUS_BLOCK IoStatusBlock;
    PPEB Peb;

    Peb = NtCurrentPeb();

    switch( HandleToUlong(hFile) ) {
        case STD_INPUT_HANDLE:
            hFile = Peb->ProcessParameters->StandardInput;
            break;
        case STD_OUTPUT_HANDLE:
            hFile = Peb->ProcessParameters->StandardOutput;
            break;
        case STD_ERROR_HANDLE:
            hFile = Peb->ProcessParameters->StandardError;
            break;
    }

    if (CONSOLE_HANDLE(hFile) && VerifyConsoleIoHandle(hFile)) {
        return( FILE_TYPE_CHAR );
    }

    if (hFile == NULL) {
        BaseSetLastNTError( STATUS_INVALID_HANDLE );
        return( FILE_TYPE_UNKNOWN );    
    }

    //
    // If handle cannot be a real kernel handle we will fail
    // the call instead of calling with a bogus value NtQuery.
    //

    if (((ULONG_PTR)hFile & 0x01)) {

        BaseSetLastNTError( STATUS_INVALID_HANDLE );
        return( FILE_TYPE_UNKNOWN );
    }

    Status = NtQueryVolumeInformationFile( hFile,
                                           &IoStatusBlock,
                                           &DeviceInformation,
                                           sizeof( DeviceInformation ),
                                           FileFsDeviceInformation
                                         );

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FILE_TYPE_UNKNOWN );
    }

    switch( DeviceInformation.DeviceType ) {

    case FILE_DEVICE_SCREEN:
    case FILE_DEVICE_KEYBOARD:
    case FILE_DEVICE_MOUSE:
    case FILE_DEVICE_PARALLEL_PORT:
    case FILE_DEVICE_PRINTER:
    case FILE_DEVICE_SERIAL_PORT:
    case FILE_DEVICE_MODEM:
    case FILE_DEVICE_SOUND:
    case FILE_DEVICE_NULL:
        return( FILE_TYPE_CHAR );

    case FILE_DEVICE_CD_ROM:
    case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
    case FILE_DEVICE_CONTROLLER:
    case FILE_DEVICE_DATALINK:
    case FILE_DEVICE_DFS:
    case FILE_DEVICE_DISK:
    case FILE_DEVICE_DISK_FILE_SYSTEM:
    case FILE_DEVICE_VIRTUAL_DISK:
        return( FILE_TYPE_DISK );

    case FILE_DEVICE_NAMED_PIPE:
        return( FILE_TYPE_PIPE );

    case FILE_DEVICE_NETWORK:
    case FILE_DEVICE_NETWORK_FILE_SYSTEM:
    case FILE_DEVICE_PHYSICAL_NETCARD:
    case FILE_DEVICE_TAPE:
    case FILE_DEVICE_TAPE_FILE_SYSTEM:
    case FILE_DEVICE_TRANSPORT:
        // NTRAID#589623-2002/03/28-earhart - changed to NTRAID marker
        // how should we handle tapes, network devices, etc...?

    case FILE_DEVICE_UNKNOWN:
    default:
        SetLastError( NO_ERROR );
        return( FILE_TYPE_UNKNOWN );
    }
}

BOOL
WINAPI
ReadFile(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    Data can be read from a file using ReadFile.

    This API is used to read data from a file.  Data is read from the
    file from the position indicated by the file pointer.  After the
    read completes, the file pointer is adjusted by the number of bytes
    actually read.  A return value of TRUE coupled with a bytes read of
    0 indicates that the file pointer was beyond the current end of the
    file at the time of the read.

Arguments:

    hFile - Supplies an open handle to a file that is to be read.  The
        file handle must have been created with GENERIC_READ access to
        the file.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the file.

    nNumberOfBytesToRead - Supplies the number of bytes to read from the
        file.

    lpNumberOfBytesRead - Returns the number of bytes read by this call.
        This parameter is always set to 0 before doing any IO or error
        checking.

    lpOverlapped - Optionally points to an OVERLAPPED structure to be used with the
    request. If NULL then the transfer starts at the current file position
    and ReadFile will not return until the operation completes.

    If the handle hFile was created without specifying FILE_FLAG_OVERLAPPED
    the file pointer is moved to the specified offset plus
    lpNumberOfBytesRead before ReadFile returns. ReadFile will wait for the
    request to complete before returning (it will not return
    ERROR_IO_PENDING).

    When FILE_FLAG_OVERLAPPED is specified, ReadFile may return
    ERROR_IO_PENDING to allow the calling function to continue processing
    while the operation completes. The event (or hFile if hEvent is NULL) will
    be set to the signalled state upon completion of the request.

    When the handle is created with FILE_FLAG_OVERLAPPED and lpOverlapped
    is set to NULL, ReadFile will return ERROR_INVALID_PARAMTER because
    the file offset is required.


Return Value:

    TRUE - The operation was successul.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PPEB Peb;
    DWORD InputMode;

    if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
        *lpNumberOfBytesRead = 0;
        }

    Peb = NtCurrentPeb();

    switch( HandleToUlong(hFile) ) {
        case STD_INPUT_HANDLE:  hFile = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hFile = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hFile = Peb->ProcessParameters->StandardError;
                                break;
        }

    if (CONSOLE_HANDLE(hFile)) {
        if (ReadConsoleA(hFile,
                        lpBuffer,
                        nNumberOfBytesToRead,
                        lpNumberOfBytesRead,
                        lpOverlapped
                       )
           ) {
            Status = STATUS_SUCCESS;
            if (!GetConsoleMode( hFile, &InputMode )) {
                InputMode = 0;
                }

            if (InputMode & ENABLE_PROCESSED_INPUT) {
                try {
                    if (*(PCHAR)lpBuffer == 0x1A) {
                        *lpNumberOfBytesRead = 0;
                        }
                    }
                except( EXCEPTION_EXECUTE_HANDLER ) {
                    Status = GetExceptionCode();
                    }
                }

            if (NT_SUCCESS(Status)) {
                return TRUE;
                }
            else {
                BaseSetLastNTError(Status);
                return FALSE;
                }
            }
        else {
            return FALSE;
            }
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtReadFile(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                lpBuffer,
                nNumberOfBytesToRead,
                &Li,
                NULL
                );


        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                try {
                    *lpNumberOfBytesRead = (DWORD)lpOverlapped->InternalHigh;
                    }
                except(EXCEPTION_EXECUTE_HANDLER) {
                    *lpNumberOfBytesRead = 0;
                    }
                }
            return TRUE;
            }
        else
        if (Status == STATUS_END_OF_FILE) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                *lpNumberOfBytesRead = 0;
                }
            BaseSetLastNTError(Status);
            return FALSE;
            }
        else {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else
        {
        Status = NtReadFile(
                hFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                lpBuffer,
                nNumberOfBytesToRead,
                NULL,
                NULL
                );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
                }
            }

        if ( NT_SUCCESS(Status) ) {
            *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
            return TRUE;
            }
        else
        if (Status == STATUS_END_OF_FILE) {
            *lpNumberOfBytesRead = 0;
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
                }
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
}


BOOL
WINAPI
WriteFile(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    Data can be written to a file using WriteFile.

    This API is used to write data to a file.  Data is written to the
    file from the position indicated by the file pointer.  After the
    write completes, the file pointer is adjusted by the number of bytes
    actually written.

    Unlike DOS, a NumberOfBytesToWrite value of zero does not truncate
    or extend the file.  If this function is required, SetEndOfFile
    should be used.

Arguments:

    hFile - Supplies an open handle to a file that is to be written.  The
        file handle must have been created with GENERIC_WRITE access to
        the file.

    lpBuffer - Supplies the address of the data that is to be written to
        the file.

    nNumberOfBytesToWrite - Supplies the number of bytes to write to the
        file. Unlike DOS, a value of zero is interpreted a null write.

    lpNumberOfBytesWritten - Returns the number of bytes written by this
        call. Before doing any work or error processing, the API sets this
        to zero.


    lpOverlapped - Optionally points to an OVERLAPPED structure to be
        used with the request. If NULL then the transfer starts at the
        current file position and WriteFile will not return until the
        operation completes.

        If the handle <hFile> was created without specifying
        FILE_FLAG_OVERLAPPED the file pointer is moved to the specified
        offset plus lpNumberOfBytesWritten before WriteFile returns.
        WriteFile will wait for the request to complete before returning
        (it will not set ERROR_IO_PENDING).

        When FILE_FLAG_OVERLAPPED is specified, WriteFile may return
        ERROR_IO_PENDING to allow the calling function to continue processing
        while the operation completes. The event (or hFile if hEvent is NULL) will
        be set to the signalled state upon completion of the request.

        When the handle is created with FILE_FLAG_OVERLAPPED and lpOverlapped
        is set to NULL, WriteFile will return ERROR_INVALID_PARAMTER because
        the file offset is required.

Return Value:

    TRUE - The operation was a success.

    FALSE - The operation failed.  Extended error status is
        available using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PPEB Peb;

    if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) ) {
        *lpNumberOfBytesWritten = 0;
        }

    Peb = NtCurrentPeb();
    switch( HandleToUlong(hFile) ) {
        case STD_INPUT_HANDLE:  hFile = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hFile = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hFile = Peb->ProcessParameters->StandardError;
                                break;
        }

    if (CONSOLE_HANDLE(hFile)) {
        return WriteConsoleA(hFile,
                            (LPVOID)lpBuffer,
                            nNumberOfBytesToWrite,
                            lpNumberOfBytesWritten,
                            lpOverlapped
                           );
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtWriteFile(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                (PVOID)lpBuffer,
                nNumberOfBytesToWrite,
                &Li,
                NULL
                );

        if ( !NT_ERROR(Status) && Status != STATUS_PENDING) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) ) {
                try {
                    *lpNumberOfBytesWritten = (DWORD)lpOverlapped->InternalHigh;
                    }
                except(EXCEPTION_EXECUTE_HANDLER) {
                    *lpNumberOfBytesWritten = 0;
                    }
                }
            return TRUE;
            }
        else  {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else {
        Status = NtWriteFile(
                hFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                (PVOID)lpBuffer,
                nNumberOfBytesToWrite,
                NULL,
                NULL
                );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
                }
            }

        if ( NT_SUCCESS(Status)) {
            *lpNumberOfBytesWritten = (DWORD)IoStatusBlock.Information;
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                *lpNumberOfBytesWritten = (DWORD)IoStatusBlock.Information;
                }
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
}

BOOL
WINAPI
SetEndOfFile(
    HANDLE hFile
    )

/*++

Routine Description:

    The end of file position of an open file can be set to the current
    file pointer using SetEndOfFile.

    This API is used to set the end of file position of a file to the
    same value as the current file pointer.  This has the effect of
    truncating or extending a file.  This functionality is similar to
    DOS (int 21h, function 40H with CX=0).

Arguments:

    hFile - Supplies an open handle to a file that is to be extended or
        truncated.  The file handle must have been created with
        GENERIC_WRITE access to the file.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_POSITION_INFORMATION CurrentPosition;
    FILE_END_OF_FILE_INFORMATION EndOfFile;
    FILE_ALLOCATION_INFORMATION Allocation;

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
        }

    //
    // Get the current position of the file pointer
    //

    Status = NtQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &CurrentPosition,
                sizeof(CurrentPosition),
                FilePositionInformation
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    //
    // Set the end of file based on the current file position
    //

    EndOfFile.EndOfFile = CurrentPosition.CurrentByteOffset;

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &EndOfFile,
                sizeof(EndOfFile),
                FileEndOfFileInformation
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    //
    // Set the allocation based on the current file size
    //

    Allocation.AllocationSize = CurrentPosition.CurrentByteOffset;

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &Allocation,
                sizeof(Allocation),
                FileAllocationInformation
                );
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

DWORD
WINAPI
SetFilePointer(
    HANDLE hFile,
    LONG lDistanceToMove,
    PLONG lpDistanceToMoveHigh,
    DWORD dwMoveMethod
    )

/*++

Routine Description:

    An open file's file pointer can be set using SetFilePointer.

    The purpose of this function is to update the current value of a
    file's file pointer.  Care should be taken in multi-threaded
    applications that have multiple threads sharing a file handle with
    each thread updating the file pointer and then doing a read.  This
    sequence should be treated as a critical section of code and should
    be protected using either a critical section object or a mutex
    object.

    This API provides the same functionality as DOS (int 21h, function
    42h) and OS/2's DosSetFilePtr.

Arguments:

    hFile - Supplies an open handle to a file whose file pointer is to be
        moved.  The file handle must have been created with
        GENERIC_READ or GENERIC_WRITE access to the file.

    lDistanceToMove - Supplies the number of bytes to move the file
        pointer.  A positive value moves the pointer forward in the file
        and a negative value moves backwards in the file.

    lpDistanceToMoveHigh - An optional parameter that if specified
        supplies the high order 32-bits of the 64-bit distance to move.
        If the value of this parameter is NULL, this API can only
        operate on files whose maximum size is (2**32)-2.  If this
        parameter is specified, than the maximum file size is (2**64)-2.
        This value also returns the high order 32-bits of the new value
        of the file pointer.  If this value, and the return value
        are 0xffffffff, then an error is indicated.

    dwMoveMethod - Supplies a value that specifies the starting point
        for the file pointer move.

        FILE_BEGIN - The starting point is zero or the beginning of the
            file.  If FILE_BEGIN is specified, then DistanceToMove is
            interpreted as an unsigned location for the new
            file pointer.

        FILE_CURRENT - The current value of the file pointer is used as
            the starting point.

        FILE_END - The current end of file position is used as the
            starting point.


Return Value:

    Not -1 - Returns the low order 32-bits of the new value of the file
        pointer.

    0xffffffff - If the value of lpDistanceToMoveHigh was NULL, then The
        operation failed.  Extended error status is available using
        GetLastError.  Otherwise, this is the low order 32-bits of the
        new value of the file pointer.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_POSITION_INFORMATION CurrentPosition;
    FILE_STANDARD_INFORMATION StandardInfo;
    LARGE_INTEGER Large;

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return (DWORD)-1;
        }

    if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)) {
        Large.HighPart = *lpDistanceToMoveHigh;
        Large.LowPart = lDistanceToMove;
        }
    else {
        Large.QuadPart = lDistanceToMove;
        }
    switch (dwMoveMethod) {
        case FILE_BEGIN :
            CurrentPosition.CurrentByteOffset = Large;
                break;

        case FILE_CURRENT :

            //
            // Get the current position of the file pointer
            //

            Status = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &CurrentPosition,
                        sizeof(CurrentPosition),
                        FilePositionInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                return (DWORD)-1;
                }
            CurrentPosition.CurrentByteOffset.QuadPart += Large.QuadPart;
            break;

        case FILE_END :
            Status = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &StandardInfo,
                        sizeof(StandardInfo),
                        FileStandardInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                return (DWORD)-1;
                }
            CurrentPosition.CurrentByteOffset.QuadPart =
                                StandardInfo.EndOfFile.QuadPart + Large.QuadPart;
            break;

        default:
            SetLastError(ERROR_INVALID_PARAMETER);
            return (DWORD)-1;
            break;
        }

    //
    // If the resulting file position is negative, or if the app is not
    // prepared for greater than
    // then 32 bits than fail
    //

    if ( CurrentPosition.CurrentByteOffset.QuadPart < 0 ) {
        SetLastError(ERROR_NEGATIVE_SEEK);
        return (DWORD)-1;
        }
    if ( !ARGUMENT_PRESENT(lpDistanceToMoveHigh) &&
        (CurrentPosition.CurrentByteOffset.HighPart & MAXLONG) ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (DWORD)-1;
        }


    //
    // Set the current file position
    //

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &CurrentPosition,
                sizeof(CurrentPosition),
                FilePositionInformation
                );
    if ( NT_SUCCESS(Status) ) {
        if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)){
            *lpDistanceToMoveHigh = CurrentPosition.CurrentByteOffset.HighPart;
            }
        if ( CurrentPosition.CurrentByteOffset.LowPart == -1 ) {
            SetLastError(0);
            }
        return CurrentPosition.CurrentByteOffset.LowPart;
        }
    else {
        BaseSetLastNTError(Status);
        if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)){
            *lpDistanceToMoveHigh = -1;
            }
        return (DWORD)-1;
        }
}


BOOL
WINAPI
SetFilePointerEx(
    HANDLE hFile,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER lpNewFilePointer,
    DWORD dwMoveMethod
    )

/*++

Routine Description:

    An open file's file pointer can be set using SetFilePointer.

    The purpose of this function is to update the current value of a
    file's file pointer.  Care should be taken in multi-threaded
    applications that have multiple threads sharing a file handle with
    each thread updating the file pointer and then doing a read.  This
    sequence should be treated as a critical section of code and should
    be protected using either a critical section object or a mutex
    object.

    This API provides the same functionality as DOS (int 21h, function
    42h) and OS/2's DosSetFilePtr.

Arguments:

    hFile - Supplies an open handle to a file whose file pointer is to be
        moved.  The file handle must have been created with
        GENERIC_READ or GENERIC_WRITE access to the file.

    liDistanceToMove - Supplies the number of bytes to move the file
        pointer.  A positive value moves the pointer forward in the file
        and a negative value moves backwards in the file.

    lpNewFilePointer - An optional parameter that if specified returns
        the new file pointer

    dwMoveMethod - Supplies a value that specifies the starting point
        for the file pointer move.

        FILE_BEGIN - The starting point is zero or the beginning of the
            file.  If FILE_BEGIN is specified, then DistanceToMove is
            interpreted as an unsigned location for the new
            file pointer.

        FILE_CURRENT - The current value of the file pointer is used as
            the starting point.

        FILE_END - The current end of file position is used as the
            starting point.


Return Value:

    TRUE - The operation was successful

    FALSE - The operation failed. Extended error status is available using
        GetLastError.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_POSITION_INFORMATION CurrentPosition;
    FILE_STANDARD_INFORMATION StandardInfo;
    LARGE_INTEGER Large;

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
        }
    Large = liDistanceToMove;

    switch (dwMoveMethod) {
        case FILE_BEGIN :
            CurrentPosition.CurrentByteOffset = Large;
                break;

        case FILE_CURRENT :

            //
            // Get the current position of the file pointer
            //

            Status = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &CurrentPosition,
                        sizeof(CurrentPosition),
                        FilePositionInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                return FALSE;
                }
            CurrentPosition.CurrentByteOffset.QuadPart += Large.QuadPart;
            break;

        case FILE_END :
            Status = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &StandardInfo,
                        sizeof(StandardInfo),
                        FileStandardInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                return FALSE;
                }
            CurrentPosition.CurrentByteOffset.QuadPart =
                                StandardInfo.EndOfFile.QuadPart + Large.QuadPart;
            break;

        default:
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
            break;
        }

    //
    // If the resulting file position is negative fail
    //

    if ( CurrentPosition.CurrentByteOffset.QuadPart < 0 ) {
        SetLastError(ERROR_NEGATIVE_SEEK);
        return FALSE;
        }


    //
    // Set the current file position
    //

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &CurrentPosition,
                sizeof(CurrentPosition),
                FilePositionInformation
                );
    if ( NT_SUCCESS(Status) ) {
        if (ARGUMENT_PRESENT(lpNewFilePointer)){
            *lpNewFilePointer = CurrentPosition.CurrentByteOffset;
            }
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}



BOOL
WINAPI
GetFileInformationByHandle(
    HANDLE hFile,
    LPBY_HANDLE_FILE_INFORMATION lpFileInformation
    )

/*++

Routine Description:


Arguments:

    hFile - Supplies an open handle to a file whose modification date and
        times are to be read.  The file handle must have been created with
        GENERIC_READ access to the file.

    lpCreationTime - An optional parameter that if specified points to
        the location to return the date and time the file was created.
        A returned time of all zero indicates that the file system
        containing the file does not support this time value.


Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    BY_HANDLE_FILE_INFORMATION LocalFileInformation;
    FILE_ALL_INFORMATION FileInformation;
    FILE_FS_VOLUME_INFORMATION VolumeInfo;

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
        }

    Status = NtQueryVolumeInformationFile(
                hFile,
                &IoStatusBlock,
                &VolumeInfo,
                sizeof(VolumeInfo),
                FileFsVolumeInformation
                );
    if ( !NT_ERROR(Status) ) {
        LocalFileInformation.dwVolumeSerialNumber = VolumeInfo.VolumeSerialNumber;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }


    Status = NtQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &FileInformation,
                sizeof(FileInformation),
                FileAllInformation
                );

    //
    // we really plan for buffer overflow
    //

    if ( !NT_ERROR(Status) ) {
        LocalFileInformation.dwFileAttributes = FileInformation.BasicInformation.FileAttributes;
        LocalFileInformation.ftCreationTime = *(LPFILETIME)&FileInformation.BasicInformation.CreationTime;
        LocalFileInformation.ftLastAccessTime = *(LPFILETIME)&FileInformation.BasicInformation.LastAccessTime;
        LocalFileInformation.ftLastWriteTime = *(LPFILETIME)&FileInformation.BasicInformation.LastWriteTime;
        LocalFileInformation.nFileSizeHigh = FileInformation.StandardInformation.EndOfFile.HighPart;
        LocalFileInformation.nFileSizeLow = FileInformation.StandardInformation.EndOfFile.LowPart;
        LocalFileInformation.nNumberOfLinks = FileInformation.StandardInformation.NumberOfLinks;
        LocalFileInformation.nFileIndexHigh = FileInformation.InternalInformation.IndexNumber.HighPart;
        LocalFileInformation.nFileIndexLow = FileInformation.InternalInformation.IndexNumber.LowPart;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    *lpFileInformation = LocalFileInformation;
    return TRUE;
}

BOOL
APIENTRY
GetFileTime(
    HANDLE hFile,
    LPFILETIME lpCreationTime,
    LPFILETIME lpLastAccessTime,
    LPFILETIME lpLastWriteTime
    )

/*++

Routine Description:

    The date and time that a file was created, last accessed or last
    modified can be read using GetFileTime.  File time stamps are
    returned as 64-bit values, that represent the number of 100
    nanoseconds since January 1st, 1601.  This date was chosen because
    it is the start of a new quadricentury.  At 100ns resolution 32 bits
    is good for about 429 seconds (or 7 minutes) and a 63-bit integer is
    good for about 29,247 years, or around 10,682,247 days.

    This API provides the same functionality as DOS (int 21h, function
    47H with AL=0), and provides a subset of OS/2's DosQueryFileInfo.

Arguments:

    hFile - Supplies an open handle to a file whose modification date and
        times are to be read.  The file handle must have been created with
        GENERIC_READ access to the file.

    lpCreationTime - An optional parameter that if specified points to
        the location to return the date and time the file was created.
        A returned time of all zero indicates that the file system
        containing the file does not support this time value.

    lpLastAccessTime - An optional parameter that if specified points to
        the location to return the date and time the file was last accessed.
        A returned time of all zero indicates that the file system
        containing the file does not support this time value.

    lpLastWriteTime - An optional parameter that if specified points to
        the location to return the date and time the file was last written.
        A file system must support this time and thus a valid value will
        always be returned for this time value.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo;

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
        }

    //
    // Get the attributes
    //

    Status = NtQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &BasicInfo,
                sizeof(BasicInfo),
                FileBasicInformation
                );

    if ( NT_SUCCESS(Status) ) {
        if (ARGUMENT_PRESENT( lpCreationTime )) {
            *lpCreationTime = *(LPFILETIME)&BasicInfo.CreationTime;
            }

        if (ARGUMENT_PRESENT( lpLastAccessTime )) {
            *lpLastAccessTime = *(LPFILETIME)&BasicInfo.LastAccessTime;
            }

        if (ARGUMENT_PRESENT( lpLastWriteTime )) {
            *lpLastWriteTime = *(LPFILETIME)&BasicInfo.LastWriteTime;
            }
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
WINAPI
SetFileTime(
    HANDLE hFile,
    CONST FILETIME *lpCreationTime,
    CONST FILETIME *lpLastAccessTime,
    CONST FILETIME *lpLastWriteTime
    )

/*++

Routine Description:

    The date and time that a file was created, last accessed or last
    modified can be modified using SetFileTime.  File time stamps are
    returned as 64-bit values, that represent the number of 100
    nanoseconds since January 1st, 1601.  This date was chosen because
    it is the start of a new quadricentury.  At 100ns resolution 32 bits
    is good for about 429 seconds (or 7 minutes) and a 63-bit integer is
    good for about 29,247 years, or around 10,682,247 days.

    This API provides the same functionality as DOS (int 21h, function
    47H with AL=1), and provides a subset of OS/2's DosSetFileInfo.

Arguments:

    hFile - Supplies an open handle to a file whose modification date and
        times are to be written.  The file handle must have been created
        with GENERIC_WRITE access to the file.

    lpCreationTime - An optional parameter, that if specified supplies
        the new creation time for the file.  Some file system's do not
        support this time value, so this parameter may be ignored.

    lpLastAccessTime - An optional parameter, that if specified supplies
        the new last access time for the file.  Some file system's do
        not support this time value, so this parameter may be ignored.

    lpLastWriteTime - An optional parameter, that if specified supplies
        the new last write time for the file.  A file system must support
        this time value.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo;

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
        }

    //
    // Zero all the time values we can set.
    //

    RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));

    //
    // For each time value that is specified, copy it to the I/O system
    // record.
    //
    if (ARGUMENT_PRESENT( lpCreationTime )) {
        BasicInfo.CreationTime.LowPart = lpCreationTime->dwLowDateTime;
        BasicInfo.CreationTime.HighPart = lpCreationTime->dwHighDateTime;
        }

    if (ARGUMENT_PRESENT( lpLastAccessTime )) {
        BasicInfo.LastAccessTime.LowPart = lpLastAccessTime->dwLowDateTime;
        BasicInfo.LastAccessTime.HighPart = lpLastAccessTime->dwHighDateTime;
        }

    if (ARGUMENT_PRESENT( lpLastWriteTime )) {
        BasicInfo.LastWriteTime.LowPart = lpLastWriteTime->dwLowDateTime;
        BasicInfo.LastWriteTime.HighPart = lpLastWriteTime->dwHighDateTime;
        }

    //
    // Set the requested times.
    //

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &BasicInfo,
                sizeof(BasicInfo),
                FileBasicInformation
                );

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
WINAPI
FlushFileBuffers(
    HANDLE hFile
    )

/*++

Routine Description:

    Buffered data may be flushed out to the file using the
    FlushFileBuffers service.

    The FlushFileBuffers service causes all buffered data to be written
    to the specified file.

Arguments:

    hFile - Supplies an open handle to a file whose buffers are to be
        flushed.  The file handle must have been created with
        GENERIC_WRITE access to the file.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PPEB Peb;

    Peb = NtCurrentPeb();

    switch( HandleToUlong(hFile) ) {
        case STD_INPUT_HANDLE:  hFile = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hFile = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hFile = Peb->ProcessParameters->StandardError;
                                break;
        }

    if (CONSOLE_HANDLE(hFile)) {
        return( FlushConsoleInputBuffer( hFile ) );
        }

    Status = NtFlushBuffersFile(hFile,&IoStatusBlock);

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
WINAPI
LockFile(
    HANDLE hFile,
    DWORD dwFileOffsetLow,
    DWORD dwFileOffsetHigh,
    DWORD nNumberOfBytesToLockLow,
    DWORD nNumberOfBytesToLockHigh
    )

/*++

Routine Description:

    A byte range within an open file may be locked for exclusive access
    using LockFile.

    Locking a region of a file is used to aquire exclusive access to the
    specified region of the file.  File locks are not inherited by the
    new process during process creation.

    Locking a portion of a file denies all other processes both read and
    write access to the specified region of the file.  Locking a region
    that goes beyond the current end-of-file position is not an error.

    Locks may not overlap an existing locked region of the file.

    For DOS based systems running share.exe the lock semantics work as
    described above.  Without share.exe, all attempts to lock or unlock
    a file will fail.

Arguments:

    hFile - Supplies an open handle to a file that is to have a range of
        bytes locked for exclusive access.  The handle must have been
        created with either GENERIC_READ or GENERIC_WRITE access to the
        file.

    dwFileOffsetLow - Supplies the low order 32-bits of the starting
        byte offset of the file where the lock should begin.

    dwFileOffsetHigh - Supplies the high order 32-bits of the starting
        byte offset of the file where the lock should begin.

    nNumberOfBytesToLockLow - Supplies the low order 32-bits of the length
        of the byte range to be locked.

    nNumberOfBytesToLockHigh - Supplies the high order 32-bits of the length
        of the byte range to be locked.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    LARGE_INTEGER ByteOffset;
    LARGE_INTEGER Length;
    IO_STATUS_BLOCK IoStatusBlock;

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
        }

    ByteOffset.LowPart = dwFileOffsetLow;
    ByteOffset.HighPart = dwFileOffsetHigh;

    Length.LowPart = nNumberOfBytesToLockLow;
    Length.HighPart = nNumberOfBytesToLockHigh;

    Status = NtLockFile( hFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         &ByteOffset,
                         &Length,
                         0,
                         TRUE,
                         TRUE
                       );

    if (Status == STATUS_PENDING) {

        Status = NtWaitForSingleObject( hFile, FALSE, NULL );
        if (NT_SUCCESS( Status )) {
            Status = IoStatusBlock.Status;
            }
        }

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}


BOOL
WINAPI
LockFileEx(
    HANDLE hFile,
    DWORD dwFlags,
    DWORD dwReserved,
    DWORD nNumberOfBytesToLockLow,
    DWORD nNumberOfBytesToLockHigh,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    A byte range within an open file may be locked for shared or
    exclusive access using LockFileEx.

    Locking a region of a file is used to aquire shared or exclusive
    access to the specified region of the file.  File locks are not
    inherited by the new process during process creation.

    Locking a portion of a file for exclusive access denies all other
    processes both read and write access to the specified region of the
    file.  Locking a region that goes beyond the current end-of-file
    position is not an error.

    Locking a portion of a file for shared access denies all other
    processes write access to the specified region of the file, but
    allows other processes to read the locked region.

    If requesting an exclusive lock for a file that is already locked
    shared or exclusively by other threads, then this call will wait
    until the lock is granted unless the LOCKFILE_FAIL_IMMEDIATELY
    flag is specified.

    Locks may not overlap an existing locked region of the file.

Arguments:

    hFile - Supplies an open handle to a file that is to have a range of
        bytes locked for exclusive access.  The handle must have been
        created with either GENERIC_READ or GENERIC_WRITE access to the
        file.

    dwFlags - Supplies flag bits that modify the behavior of this function.

        LOCKFILE_FAIL_IMMEDIATELY - if set, then this function will return
            immediately if it is unable to acquire the requested lock.
            Otherwise it will wait.

        LOCKFILE_EXCLUSIVE_LOCK - if set, then this function requests an
            exclusive lock, otherwise it requested a shared lock.

    dwReserved - Reserved parameter that must be zero.

    nNumberOfBytesToLockLow - Supplies the low order 32-bits of the length
        of the byte range to be locked.

    nNumberOfBytesToLockHigh - Supplies the high order 32-bits of the length
        of the byte range to be locked.

    lpOverlapped - Required pointer to an OVERLAPPED structure to be
        used with the request.  It contains the file offset of the
        beginning of the lock range.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/


{
    NTSTATUS Status;
    LARGE_INTEGER ByteOffset;
    LARGE_INTEGER Length;

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
        }

    if (dwReserved != 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }

    ByteOffset.LowPart = lpOverlapped->Offset;
    ByteOffset.HighPart = lpOverlapped->OffsetHigh;

    Length.LowPart = nNumberOfBytesToLockLow;
    Length.HighPart = nNumberOfBytesToLockHigh;
    lpOverlapped->Internal = (DWORD)STATUS_PENDING;

    Status = NtLockFile( hFile,
                         lpOverlapped->hEvent,
                         NULL,
                         (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                         (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                         &ByteOffset,
                         &Length,
                         0,
                         (BOOLEAN)((dwFlags & LOCKFILE_FAIL_IMMEDIATELY) ? TRUE : FALSE),
                         (BOOLEAN)((dwFlags & LOCKFILE_EXCLUSIVE_LOCK) ? TRUE : FALSE)
                       );

    if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}


BOOL
WINAPI
UnlockFile(
    HANDLE hFile,
    DWORD dwFileOffsetLow,
    DWORD dwFileOffsetHigh,
    DWORD nNumberOfBytesToUnlockLow,
    DWORD nNumberOfBytesToUnlockHigh
    )

/*++

Routine Description:

    A previously locked byte range within an open file may be Unlocked
    using UnlockFile.

    Unlocking a region of a file is used release a previously aquired
    lock on a file.  The region to unlock must exactly correspond to an
    existing locked region.  Two adjacent regions of a file can not be
    locked seperately and then be unlocked using a single region that
    spans both locked regions.

    If a process terminates with a portion of a file locked, or closes a
    file that has outstanding locks, the behavior is not specified.

    For DOS based systems running share.exe the lock semantics work as
    described above.  Without share.exe, all attempts to lock or unlock
    a file will fail.

Arguments:

    hFile - Supplies an open handle to a file that is to have an
        existing locked region unlocked.  The handle must have been
        created with either GENERIC_READ or GENERIC_WRITE access to the
        file.

    dwFileOffsetLow - Supplies the low order 32-bits of an existing
        locked region to be unlocked.

    dwFileOffsetHigh - Supplies the high order 32-bits of an existing
        locked region to be unlocked.

    nNumberOfBytesToUnlockLow - Supplies the low order 32-bits of the
        length of the byte range to be unlocked.

    nNumberOfBytesToUnlockHigh - Supplies the high order 32-bits of the
        length of the byte range to be unlocked.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    BOOL bResult;
    OVERLAPPED Overlapped;
    NTSTATUS Status;

    Overlapped.Offset = dwFileOffsetLow;
    Overlapped.OffsetHigh = dwFileOffsetHigh;
    bResult = UnlockFileEx( hFile,
                            0,
                            nNumberOfBytesToUnlockLow,
                            nNumberOfBytesToUnlockHigh,
                            &Overlapped
                          );
    if (!bResult && GetLastError() == ERROR_IO_PENDING) {
        Status = NtWaitForSingleObject( hFile, FALSE, NULL );
        if (NT_SUCCESS( Status )) {
            Status = (NTSTATUS)Overlapped.Internal;
            }

        if ( NT_SUCCESS(Status) ) {
            return TRUE;
            }
        else {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else {
        return bResult;
        }
}



BOOL
WINAPI
UnlockFileEx(
    HANDLE hFile,
    DWORD dwReserved,
    DWORD nNumberOfBytesToUnlockLow,
    DWORD nNumberOfBytesToUnlockHigh,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    A previously locked byte range within an open file may be Unlocked
    using UnlockFile.

    Unlocking a region of a file is used release a previously aquired
    lock on a file.  The region to unlock must exactly correspond to an
    existing locked region.  Two adjacent regions of a file can not be
    locked seperately and then be unlocked using a single region that
    spans both locked regions.

    If a process terminates with a portion of a file locked, or closes a
    file that has outstanding locks, the behavior is not specified.

Arguments:

    hFile - Supplies an open handle to a file that is to have an
        existing locked region unlocked.  The handle must have been
        created with either GENERIC_READ or GENERIC_WRITE access to the
        file.

    dwReserved - Reserved parameter that must be zero.

    nNumberOfBytesToUnlockLow - Supplies the low order 32-bits of the
        length of the byte range to be unlocked.

    nNumberOfBytesToUnlockHigh - Supplies the high order 32-bits of the
        length of the byte range to be unlocked.

    lpOverlapped - Required pointer to an OVERLAPPED structure to be
        used with the request.  It contains the file offset of the
        beginning of the lock range.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/


{
    NTSTATUS Status;
    LARGE_INTEGER ByteOffset;
    LARGE_INTEGER Length;

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
        }

    if (dwReserved != 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }

    ByteOffset.LowPart = lpOverlapped->Offset;
    ByteOffset.HighPart = lpOverlapped->OffsetHigh;

    Length.LowPart = nNumberOfBytesToUnlockLow;
    Length.HighPart = nNumberOfBytesToUnlockHigh;

    Status = NtUnlockFile(
                hFile,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                &ByteOffset,
                &Length,
                0
                );

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

UINT
WINAPI
SetHandleCount(
    UINT uNumber
    )

/*++

Routine Description:

    This function changes the number of file handles available to a
    process.  For DOS based Win32, the default maximum number of file
    handles available to a process is 20.  For NT/Win32 systems, this
    API has no effect.

Arguments:

    uNumber - Specifies the number of file handles needed by the
        application.  The maximum is 255.

Return Value:

    The return value specifies the number of file handles actually
    available to the application.  It may be less than the number
    specified by the wNumber parameter.

--*/

{
    return uNumber;
}

DWORD
WINAPI
GetFileSize(
    HANDLE hFile,
    LPDWORD lpFileSizeHigh
    )

/*++

Routine Description:

    This function returns the size of the file specified by
    hFile. It is capable of returning 64-bits worth of file size.

    The return value contains the low order 32-bits of the file's size.
    The optional lpFileSizeHigh returns the high order 32-bits of the
    file's size.

Arguments:

    hFile - Supplies an open handle to a file whose size is to be
        returned.  The handle must have been created with either
        GENERIC_READ or GENERIC_WRITE access to the file.

    lpFileSizeHigh - An optional parameter, that if specified, returns
        the high order 64-bits of the file's size.


Return Value:

    Not -1 - Returns the low order 32-bits of the specified file's size.


    0xffffffff - If the value of size of the file cannot be determined,
        or an invalid handle or handle with inappropriate access, or a
        handle to a non-file is specified, this error is returned.  If
        the file's size (low 32-bits) is -1, then this value is
        returned, and GetLastError() will return 0.  Extended error
        status is available using GetLastError.


--*/

{
    BOOL b;
    LARGE_INTEGER Li;

    b = GetFileSizeEx(hFile,&Li);

    if ( b ) {

        if ( ARGUMENT_PRESENT(lpFileSizeHigh) ) {
            *lpFileSizeHigh = (DWORD)Li.HighPart;
            }
        if (Li.LowPart == -1 ) {
            SetLastError(0);
            }
        }
    else {
        Li.LowPart = -1;
        }

    return Li.LowPart;
}

BOOL
WINAPI
GetFileSizeEx(
    HANDLE hFile,
    PLARGE_INTEGER lpFileSize
    )

/*++

Routine Description:

    This function returns the size of the file specified by
    hFile. It is capable of returning 64-bits worth of file size.

Arguments:

    hFile - Supplies an open handle to a file whose size is to be
        returned.  The handle must have been created with either
        GENERIC_READ or GENERIC_WRITE access to the file.

    lpFileSize - Returns the files size


Return Value:

    TRUE - The operation was successful


    FALSE - The operation failed. Extended error
        status is available using GetLastError.


--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_STANDARD_INFORMATION StandardInfo;

    Status = NtQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &StandardInfo,
                sizeof(StandardInfo),
                FileStandardInformation
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    else {
        *lpFileSize = StandardInfo.EndOfFile;
        return TRUE;
        }
}

VOID
WINAPI
BasepIoCompletion(
    PVOID ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock,
    DWORD Reserved
    )


/*++

Routine Description:

    This procedure is called to complete ReadFileEx and WriteFileEx
    asynchronous I/O. Its primary function is to extract the
    appropriate information from the passed IoStatusBlock and call the
    users completion routine.

    The users completion routine is called as:

        Routine Description:

            When an outstanding I/O completes with a callback, this
            function is called.  This function is only called while the
            thread is in an alertable wait (SleepEx,
            WaitForSingleObjectEx, or WaitForMultipleObjectsEx with the
            bAlertable flag set to TRUE).  Returning from this function
            allows another pendiong I/O completion callback to be
            processed.  If this is the case, this callback is entered
            before the termination of the thread's wait with a return
            code of WAIT_IO_COMPLETION.

            Note that each time your completion routine is called, the
            system uses some of your stack.  If you code your completion
            logic to do additional ReadFileEx's and WriteFileEx's within
            your completion routine, AND you do alertable waits in your
            completion routine, you may grow your stack without ever
            trimming it back.

        Arguments:

            dwErrorCode - Supplies the I/O completion status for the
                related I/O.  A value of 0 indicates that the I/O was
                successful.  Note that end of file is indicated by a
                non-zero dwErrorCode value of ERROR_HANDLE_EOF.

            dwNumberOfBytesTransfered - Supplies the number of bytes
                transfered during the associated I/O.  If an error
                occured, a value of 0 is supplied.

            lpOverlapped - Supplies the address of the OVERLAPPED
                structure used to initiate the associated I/O.  The
                hEvent field of this structure is not used by the system
                and may be used by the application to provide additional
                I/O context.  Once a completion routine is called, the
                system will not use the OVERLAPPED structure.  The
                completion routine is free to deallocate the overlapped
                structure.

Arguments:

    ApcContext - Supplies the users completion routine. The format of
        this routine is an LPOVERLAPPED_COMPLETION_ROUTINE.

    IoStatusBlock - Supplies the address of the IoStatusBlock that
        contains the I/O completion status. The IoStatusBlock is
        contained within the OVERLAPPED structure.

    Reserved - Not used; reserved for future use.

Return Value:

    None.

--*/

{
    PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK ActivationBlock;
    LPOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine;
    DWORD dwErrorCode;
    DWORD dwNumberOfBytesTransfered;
    LPOVERLAPPED lpOverlapped;
    NTSTATUS Status;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME ActivationFrame = { sizeof(ActivationFrame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };
    PACTIVATION_CONTEXT ActivationContext = NULL;

    if ( NT_ERROR(IoStatusBlock->Status) ) {
        dwErrorCode = RtlNtStatusToDosError(IoStatusBlock->Status);
        dwNumberOfBytesTransfered = 0;
    } else {
        dwErrorCode = 0;
        dwNumberOfBytesTransfered = (DWORD)IoStatusBlock->Information;
    }

    ActivationBlock = (PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK) ApcContext;
    ActivationContext = ActivationBlock->ActivationContext;
    CompletionRoutine = (LPOVERLAPPED_COMPLETION_ROUTINE) ActivationBlock->CallbackFunction;
    lpOverlapped = (LPOVERLAPPED) CONTAINING_RECORD(IoStatusBlock, OVERLAPPED, Internal);

    if (!(ActivationBlock->Flags & BASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_FREE_AFTER_CALLBACK))
        BasepFreeActivationContextActivationBlock(ActivationBlock);

    RtlActivateActivationContextUnsafeFast(&ActivationFrame, ActivationContext);
    __try {
        (*CompletionRoutine)(dwErrorCode, dwNumberOfBytesTransfered, lpOverlapped);
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&ActivationFrame);
    }

    Reserved;
}

VOID
WINAPI
BasepIoCompletionSimple(
    PVOID ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock,
    DWORD Reserved
    )


/*++

Routine Description:

    This procedure is called to complete ReadFileEx and WriteFileEx
    asynchronous I/O. Its primary function is to extract the
    appropriate information from the passed IoStatusBlock and call the
    users completion routine.

    The users completion routine is called as:

        Routine Description:

            When an outstanding I/O completes with a callback, this
            function is called.  This function is only called while the
            thread is in an alertable wait (SleepEx,
            WaitForSingleObjectEx, or WaitForMultipleObjectsEx with the
            bAlertable flag set to TRUE).  Returning from this function
            allows another pendiong I/O completion callback to be
            processed.  If this is the case, this callback is entered
            before the termination of the thread's wait with a return
            code of WAIT_IO_COMPLETION.

            Note that each time your completion routine is called, the
            system uses some of your stack.  If you code your completion
            logic to do additional ReadFileEx's and WriteFileEx's within
            your completion routine, AND you do alertable waits in your
            completion routine, you may grow your stack without ever
            trimming it back.

        Arguments:

            dwErrorCode - Supplies the I/O completion status for the
                related I/O.  A value of 0 indicates that the I/O was
                successful.  Note that end of file is indicated by a
                non-zero dwErrorCode value of ERROR_HANDLE_EOF.

            dwNumberOfBytesTransfered - Supplies the number of bytes
                transfered during the associated I/O.  If an error
                occured, a value of 0 is supplied.

            lpOverlapped - Supplies the address of the OVERLAPPED
                structure used to initiate the associated I/O.  The
                hEvent field of this structure is not used by the system
                and may be used by the application to provide additional
                I/O context.  Once a completion routine is called, the
                system will not use the OVERLAPPED structure.  The
                completion routine is free to deallocate the overlapped
                structure.

Arguments:

    ApcContext - Supplies the users completion routine. The format of
        this routine is an LPOVERLAPPED_COMPLETION_ROUTINE.

    IoStatusBlock - Supplies the address of the IoStatusBlock that
        contains the I/O completion status. The IoStatusBlock is
        contained within the OVERLAPPED structure.

    Reserved - Not used; reserved for future use.

Return Value:

    None.

--*/

{
    LPOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine;
    DWORD dwErrorCode;
    DWORD dwNumberOfBytesTransfered;
    LPOVERLAPPED lpOverlapped;

    dwErrorCode = 0;

    if ( NT_ERROR(IoStatusBlock->Status) ) {
        dwErrorCode = RtlNtStatusToDosError(IoStatusBlock->Status);
        dwNumberOfBytesTransfered = 0;
        }
    else {
        dwErrorCode = 0;
        dwNumberOfBytesTransfered = (DWORD)IoStatusBlock->Information;
        }

    CompletionRoutine = (LPOVERLAPPED_COMPLETION_ROUTINE)ApcContext;
    lpOverlapped = (LPOVERLAPPED)CONTAINING_RECORD(IoStatusBlock,OVERLAPPED,Internal);

    (CompletionRoutine)(dwErrorCode,dwNumberOfBytesTransfered,lpOverlapped);

    Reserved;
}

BOOL
WINAPI
ReadFileEx(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )

/*++

Routine Description:

    Data can be read from a file using ReadFileEx.

    This API reports its completion status asynchronously by calling the
    specified lpCompletionRoutine.

    The caller of this routine uses the lpOverlappedStructure to specify
    the byte offset within the file where the read is to begin from.
    For files that do not support this concept (pipes...), the starting
    file offset is ignored.

    Upon successful completion of this API (return value of TRUE), the
    calling thread has an I/O outstanding.  When the I/O completes, and
    the thread is blocked in an alertable wait, the lpCompletionRoutine
    will be called and the wait will return with a return code of
    WAIT_IO_COMPLETION.  If the I/O completes, but the thread issuing
    the I/O is not in an alertable wait, the call to the completion
    routine is queued until the thread executes an alertable wait.

    If this API fails (by returning FALSE), GetLastError can be used to
    get additional error information.  If this call fails because the
    thread issued a read beyond the end of file, GetLastError will
    return a value of ERROR_HANDLE_EOF.

Arguments:

    hFile - Supplies an open handle to a file that is to be read.  The
        file handle must have been created with GENERIC_READ access to
        the file.  The file must have been created with the
        FILE_FLAG_OVERLAPPED flag.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the file.

    nNumberOfBytesToRead - Supplies the number of bytes to read from the
        file.

    lpOverlapped - Supplies the address of an OVERLAPPED structure to be
        used with the request.  The caller of this function must specify
        a starting byte offset within the file to start the read from.
        It does this using the Offset and OffsetHigh fields of the
        overlapped structure.  This call does not use or modify the
        hEvent field of the overlapped structure.  The caller may use
        this field for any purpose.  This API does use the Internal and
        InternalHigh fields of the overlapped structure, the thread
        should not manipulate this.  The lpOverlapped structure must
        remain valid for the duration of the I/O.  It is not a good idea
        to make it a local variable and then possibly returning from the
        routine with the I/O that is using this structure still pending.

Return Value:

    TRUE - The operation was successul.  Completion status will be
        propagated to the caller using the completion callback
        mechanism.  Note that this information is only made available to
        the thread that issued the I/O, and only when the I/O completes,
        and the thread is executing in an alertable wait.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError. Note that end of file is treated as a failure
        with an error code of ERROR_HANDLE_EOF.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER Li;
    PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK ActivationBlock = NULL;
    PIO_APC_ROUTINE IoApcRoutine = &BasepIoCompletionSimple;
    PVOID ApcContext = lpCompletionRoutine;

    Li.LowPart = lpOverlapped->Offset;
    Li.HighPart = lpOverlapped->OffsetHigh;

    // If there's an APC routine to call we need to allocate a little chunk of heap
    // to pass the activation context to the APC callback.
    if (lpCompletionRoutine != NULL) {
        Status = BasepAllocateActivationContextActivationBlock(
            BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_ALLOCATE_IF_PROCESS_DEFAULT,
            lpCompletionRoutine,
            lpOverlapped,
            &ActivationBlock);
        if (!NT_SUCCESS(Status)) {
            BaseSetLastNTError(Status);
            return FALSE;
        }

        // If there's nothing to do, call the simpler one that doesn't try to do activation context stuff
        if (ActivationBlock != NULL) {
            IoApcRoutine = &BasepIoCompletion;
            ApcContext = ActivationBlock;
        }
    }

    Status = NtReadFile(
                hFile,
                NULL,
                IoApcRoutine,
                ApcContext,
                (PIO_STATUS_BLOCK) &lpOverlapped->Internal,
                lpBuffer,
                nNumberOfBytesToRead,
                &Li,
                NULL
                );
    if ( NT_ERROR(Status) ) {
        if (ActivationBlock != NULL)
            BasepFreeActivationContextActivationBlock(ActivationBlock);
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
WriteFileEx(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )

/*++

Routine Description:

    Data can be written to a file using WriteFileEx.

    This API reports its completion status asynchronously by calling the
    specified lpCompletionRoutine.

    The caller of this routine uses the lpOverlappedStructure to specify
    the byte offset within the file where the write is to begin.
    For files that do not support this concept (pipes...), the starting
    file offset is ignored.

    Upon successful completion of this API (return value of TRUE), the
    calling thread has an I/O outstanding.  When the I/O completes, and
    the thread is blocked in an alertable wait, the lpCompletionRoutine
    will be called and the wait will return with a return code of
    WAIT_IO_COMPLETION.  If the I/O completes, but the thread issuing
    the I/O is not in an alertable wait, the call to the completion
    routine is queued until the thread executes an alertable wait.

    If this API fails (by returning FALSE), GetLastError can be used to
    get additional error information.

    Unlike DOS, a NumberOfBytesToWrite value of zero does not truncate
    or extend the file.  If this function is required, SetEndOfFile
    should be used.

Arguments:

    hFile - Supplies an open handle to a file that is to be written.  The
        file handle must have been created with GENERIC_WRITE access to
        the file.

    lpBuffer - Supplies the address of the data that is to be written to
        the file.

    nNumberOfBytesToWrite - Supplies the number of bytes to write to the
        file. Unlike DOS, a value of zero is interpreted a null write.

    lpOverlapped - Supplies the address of an OVERLAPPED structure to be
        used with the request.  The caller of this function must specify
        a starting byte offset within the file to start the write to.
        It does this using the Offset and OffsetHigh fields of the
        overlapped structure.  This call does not use or modify the
        hEvent field of the overlapped structure.  The caller may use
        this field for any purpose.  This API does use the Internal and
        InternalHigh fields of the overlapped structure, the thread
        should not manipulate this.  The lpOverlapped structure must
        remain valid for the duration of the I/O.  It is not a good idea
        to make it a local variable and then possibly returning from the
        routine with the I/O that is using this structure still pending.

Return Value:

    TRUE - The operation was successul.  Completion status will be
        propagated to the caller using the completion callback
        mechanism.  Note that this information is only made available to
        the thread that issued the I/O, and only when the I/O completes,
        and the thread is executing in an alertable wait.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError. Note that end of file is treated as a failure
        with an error code of ERROR_HANDLE_EOF.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER Li;
    PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK ActivationBlock = NULL;
    PIO_APC_ROUTINE IoApcRoutine = &BasepIoCompletionSimple;
    PVOID ApcContext = lpCompletionRoutine;

    Li.LowPart = lpOverlapped->Offset;
    Li.HighPart = lpOverlapped->OffsetHigh;

    // If there's an APC routine to call we may need to allocate a little chunk of heap
    // to pass to the APC callback.
    //
    // we'll replace the parameters to the common NtWriteFile call below so that
    // the control flow is obvious.
    //
    if (lpCompletionRoutine != NULL) {
        Status = BasepAllocateActivationContextActivationBlock(
            BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_ALLOCATE_IF_PROCESS_DEFAULT,
            lpCompletionRoutine,
            lpOverlapped,
            &ActivationBlock);
        if (!NT_SUCCESS(Status)) {
            BaseSetLastNTError(Status);
            return FALSE;
        }

        // If there's nothing to do, call the simpler one that doesn't try to do activation context stuff
        if (ActivationBlock != NULL) {
            IoApcRoutine = &BasepIoCompletion;
            ApcContext = ActivationBlock;
        }
    }

    Status = NtWriteFile(
                hFile,
                NULL,
                IoApcRoutine,
                ApcContext,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                (LPVOID)lpBuffer,
                nNumberOfBytesToWrite,
                &Li,
                NULL
                );
    if ( NT_ERROR(Status) ) {
        if (ActivationBlock != NULL) {
            BasepFreeActivationContextActivationBlock(ActivationBlock);
        }
        BaseSetLastNTError(Status);
        return FALSE;
        }

    return TRUE;
}

BOOL
WINAPI
DeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    An operation on a device may be performed by calling the device driver
    directly using the DeviceIoContrl function.

    The device driver must first be opened to get a valid handle.

Arguments:

    hDevice - Supplies an open handle a device on which the operation is to
        be performed.

    dwIoControlCode - Supplies the control code for the operation. This
        control code determines on which type of device the operation must
        be performed and determines exactly what operation is to be
        performed.

    lpInBuffer - Suplies an optional pointer to an input buffer that contains
        the data required to perform the operation.  Whether or not the
        buffer is actually optional is dependent on the IoControlCode.

    nInBufferSize - Supplies the length of the input buffer in bytes.

    lpOutBuffer - Suplies an optional pointer to an output buffer into which
        the output data will be copied. Whether or not the buffer is actually
        optional is dependent on the IoControlCode.

    nOutBufferSize - Supplies the length of the output buffer in bytes.

    lpBytesReturned - Supplies a pointer to a dword which will receive the
        actual length of the data returned in the output buffer.

    lpOverlapped - An optional parameter that supplies an overlap structure to
        be used with the request. If NULL or the handle was created without
        FILE_FLAG_OVERLAPPED then the DeviceIoControl will not return until
        the operation completes.

        When lpOverlapped is supplied and FILE_FLAG_OVERLAPPED was specified
        when the handle was created, DeviceIoControl may return
        ERROR_IO_PENDING to allow the caller to continue processing while the
        operation completes. The event (or File handle if hEvent == NULL) will
        be set to the not signalled state before ERROR_IO_PENDING is
        returned. The event will be set to the signalled state upon completion
        of the request. GetOverlappedResult is used to determine the result
        when ERROR_IO_PENDING is returned.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{
    NTSTATUS Status;
    BOOLEAN DevIoCtl;

    // On terminal Services TS-app-server, only allow admins to eject media while connected remotely
    if ( ( dwIoControlCode == IOCTL_STORAGE_EJECT_MEDIA )  ||
       ( dwIoControlCode == IOCTL_DISK_EJECT_MEDIA ) ||
       ( dwIoControlCode == FSCTL_DISMOUNT_VOLUME ) )
    {
        if ( (NtCurrentPeb()->SessionId != USER_SHARED_DATA->ActiveConsoleId))
        {
            BOOL    TSAppCompatEnabled;
            NTSTATUS Status;

            Status = IsTSAppCompatEnabled(&TSAppCompatEnabled);
            if (!NT_SUCCESS(Status)) {
                BaseSetLastNTError(Status);
                return FALSE;
            }
            if (TSAppCompatEnabled && !IsCallerAdminOrSystem()) {
                BaseSetLastNTError(STATUS_ACCESS_DENIED);
                return FALSE;
            }
        }
   }


    if ( dwIoControlCode >> 16 == FILE_DEVICE_FILE_SYSTEM ) {
        DevIoCtl = FALSE;
        }
    else {
        DevIoCtl = TRUE;
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        lpOverlapped->Internal = (DWORD)STATUS_PENDING;

        if ( DevIoCtl ) {

            Status = NtDeviceIoControlFile(
                        hDevice,
                        lpOverlapped->hEvent,
                        NULL,             // APC routine
                        (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                        (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }
        else {

            Status = NtFsControlFile(
                        hDevice,
                        lpOverlapped->hEvent,
                        NULL,             // APC routine
                        (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                        (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );

            }

        // handle warning value STATUS_BUFFER_OVERFLOW somewhat correctly
        if ( !NT_ERROR(Status) && ARGUMENT_PRESENT(lpBytesReturned) ) {
            try {
                *lpBytesReturned = (DWORD)lpOverlapped->InternalHigh;
                }
            except(EXCEPTION_EXECUTE_HANDLER) {
                *lpBytesReturned = 0;
                }
            }
        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
            return TRUE;
            }
        else {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else
        {
        IO_STATUS_BLOCK Iosb;

        if ( DevIoCtl ) {
            Status = NtDeviceIoControlFile(
                        hDevice,
                        NULL,
                        NULL,             // APC routine
                        NULL,             // APC Context
                        &Iosb,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }
        else {
            Status = NtFsControlFile(
                        hDevice,
                        NULL,
                        NULL,             // APC routine
                        NULL,             // APC Context
                        &Iosb,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & Iosb destroyed
            Status = NtWaitForSingleObject( hDevice, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = Iosb.Status;
                }
            }

        if ( NT_SUCCESS(Status) ) {
            *lpBytesReturned = (DWORD)Iosb.Information;
            return TRUE;
            }
        else {
            // handle warning value STATUS_BUFFER_OVERFLOW somewhat correctly
            if ( !NT_ERROR(Status) ) {
                *lpBytesReturned = (DWORD)Iosb.Information;
            }
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
}

BOOL
WINAPI
CancelIo(
    HANDLE hFile
    )

/*++

Routine Description:

    This routine cancels all of the outstanding I/O for the specified handle
    for the specified file.

Arguments:

    hFile - Supplies the handle to the file whose pending I/O is to be
        canceled.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed.  Extended error status is available using
        GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Simply cancel the I/O for the specified file.
    //

    Status = NtCancelIoFile(hFile, &IoStatusBlock);

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }

}

BOOL
WINAPI
ReadFileScatter(
    HANDLE hFile,
    FILE_SEGMENT_ELEMENT aSegementArray[],
    DWORD nNumberOfBytesToRead,
    LPDWORD lpReserved,
    LPOVERLAPPED lpOverlapped
    )
/*++

Routine Description:

    Data can be read from a file using ReadFileScatter.  The data
    is then scatter to specified buffer segements.

    This API is used to read data from a file.  Data is read from the
    file from the position indicated by the file pointer.  After the
    read completes, the file pointer is adjusted by the number of bytes
    actually read.  A return value of TRUE coupled with a bytes read of
    0 indicates that the file pointer was beyond the current end of the
    file at the time of the read.

Arguments:

    hFile - Supplies an open handle to a file that is to be read.  The
        file handle must have been created with GENERIC_READ access to
        the file.

    aSegementArray - Supplies a pointer an array of virtual segments.
        A virtual segment is a memory buffer where part of the transferred data
        should be placed.  Segments are have a fix size of PAGE_SIZE
        and must be aligned on a PAGE_SIZE boundary.

    nNumberOfBytesToRead - Supplies the number of bytes to read from the file.

    lpReserved - Reserved for now.

    lpOverlapped - Optionally points to an OVERLAPPED structure to be used with the
    request. If NULL then the transfer starts at the current file position
    and ReadFile will not return until the operation completes.

    If the handle hFile was created without specifying FILE_FLAG_OVERLAPPED
    the file pointer is moved to the specified offset plus
    lpNumberOfBytesRead before ReadFile returns. ReadFile will wait for the
    request to complete before returning (it will not return
    ERROR_IO_PENDING).

    When FILE_FLAG_OVERLAPPED is specified, ReadFile may return
    ERROR_IO_PENDING to allow the calling function to continue processing
    while the operation completes. The event (or hFile if hEvent is NULL) will
    be set to the signalled state upon completion of the request.

    When the handle is created with FILE_FLAG_OVERLAPPED and lpOverlapped
    is set to NULL, ReadFile will return ERROR_INVALID_PARAMTER because
    the file offset is required.


Return Value:

    TRUE - The operation was successul.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    LPDWORD lpNumberOfBytesRead = NULL;

    if ( ARGUMENT_PRESENT(lpReserved) ||
         !ARGUMENT_PRESENT( lpOverlapped )) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;

        }

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
        }

    if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
        *lpNumberOfBytesRead = 0;
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtReadFileScatter(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                aSegementArray,
                nNumberOfBytesToRead,
                &Li,
                NULL
                );


        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                try {
                    *lpNumberOfBytesRead = (DWORD)lpOverlapped->InternalHigh;
                    }
                except(EXCEPTION_EXECUTE_HANDLER) {
                    *lpNumberOfBytesRead = 0;
                    }
                }
            return TRUE;
            }
        else
        if (Status == STATUS_END_OF_FILE) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                *lpNumberOfBytesRead = 0;
                }
            BaseSetLastNTError(Status);
            return FALSE;
            }
        else {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else
        {
        Status = NtReadFileScatter(
                hFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                aSegementArray,
                nNumberOfBytesToRead,
                NULL,
                NULL
                );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
                }
            }

        if ( NT_SUCCESS(Status) ) {
            *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
            return TRUE;
            }
        else
        if (Status == STATUS_END_OF_FILE) {
            *lpNumberOfBytesRead = 0;
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
                }
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
}


BOOL
WINAPI
WriteFileGather(
    HANDLE hFile,
    FILE_SEGMENT_ELEMENT aSegementArray[],
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpReserved,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    Data can be written to a file using WriteFileGather.  The data can
    be in multple file segement buffers.

    This API is used to write data to a file.  Data is written to the
    file from the position indicated by the file pointer.  After the
    write completes, the file pointer is adjusted by the number of bytes
    actually written.

    Unlike DOS, a NumberOfBytesToWrite value of zero does not truncate
    or extend the file.  If this function is required, SetEndOfFile
    should be used.

Arguments:

    hFile - Supplies an open handle to a file that is to be written.  The
        file handle must have been created with GENERIC_WRITE access to
        the file.

    aSegementArray - Supplies a pointer an array of virtual segments.
        A virtual segment is a memory buffer where part of the transferred data
        should be placed.  Segments are have a fix size of PAGE_SIZE
        and must be aligned on a PAGE_SIZE boundary. The number of
        entries in the array must be equal to nNumberOfBytesToRead /
        PAGE_SIZE.

    nNumberOfBytesToWrite - Supplies the number of bytes to write to the
        file. Unlike DOS, a value of zero is interpreted a null write.

    lpReserved - Unused for now.

    lpOverlapped - Optionally points to an OVERLAPPED structure to be
        used with the request. If NULL then the transfer starts at the
        current file position and WriteFileGather will not return until the
        operation completes.

        If the handle <hFile> was created without specifying
        FILE_FLAG_OVERLAPPED the file pointer is moved to the specified
        offset plus lpNumberOfBytesWritten before WriteFile returns.
        WriteFile will wait for the request to complete before returning
        (it will not set ERROR_IO_PENDING).

        When FILE_FLAG_OVERLAPPED is specified, WriteFile may return
        ERROR_IO_PENDING to allow the calling function to continue processing
        while the operation completes. The event (or hFile if hEvent is NULL) will
        be set to the signalled state upon completion of the request.

        When the handle is created with FILE_FLAG_OVERLAPPED and lpOverlapped
        is set to NULL, WriteFile will return ERROR_INVALID_PARAMTER because
        the file offset is required.

Return Value:

    TRUE - The operation was a success.

    FALSE - The operation failed.  Extended error status is
        available using GetLastError.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    LPDWORD lpNumberOfBytesWritten = NULL;

    if ( ARGUMENT_PRESENT(lpReserved) ||
         !ARGUMENT_PRESENT( lpOverlapped )) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;

        }

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
        }

    if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) ) {
        *lpNumberOfBytesWritten = 0;
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtWriteFileGather(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                aSegementArray,
                nNumberOfBytesToWrite,
                &Li,
                NULL
                );

        if ( !NT_ERROR(Status) && Status != STATUS_PENDING) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) ) {
                try {
                    *lpNumberOfBytesWritten = (DWORD)lpOverlapped->InternalHigh;
                    }
                except(EXCEPTION_EXECUTE_HANDLER) {
                    *lpNumberOfBytesWritten = 0;
                    }
                }
            return TRUE;
            }
        else  {
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else {
        Status = NtWriteFileGather(
                hFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                aSegementArray,
                nNumberOfBytesToWrite,
                NULL,
                NULL
                );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
                }
            }

        if ( NT_SUCCESS(Status)) {
            *lpNumberOfBytesWritten = (DWORD)IoStatusBlock.Information;
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                *lpNumberOfBytesWritten = (DWORD)IoStatusBlock.Information;
                }
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
}


BOOL
APIENTRY
SetFileValidData(
    IN HANDLE hFile,
    IN LONGLONG ValidDataLength
    )

/*++

Routine Description:

    SetFileValidData is used to set the valid data length for the given file.

Arguments:

    hFile - Supplies an open handle to a file whose type valid data
        length is to be set

    ValidDataLength - Supplies the desired valid data length

Return Value:

    TRUE - The operation was a success.

    FALSE - The operation failed.  Extended error status is
        available using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_VALID_DATA_LENGTH_INFORMATION ValidDataInfo;

    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
    }

    ValidDataInfo.ValidDataLength.QuadPart = ValidDataLength;

    Status = NtSetInformationFile(
        hFile,
        &IoStatusBlock,
        &ValidDataInfo,
        sizeof(FILE_VALID_DATA_LENGTH_INFORMATION),
        FileValidDataLengthInformation
        );
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}


BOOL
APIENTRY
SetFileShortNameW(
    IN HANDLE hFile,
    IN LPCWSTR lpShortName
    )

/*++

Routine Description:

    SetFileShortNameW is used to set the short name for the given file.

Arguments:

    hFile - Supplies an open handle to a file whose short name is to be changed

    lpShortName - Supplies the desired short name

Return Value:

    TRUE - The operation was a success.

    FALSE - The operation failed.  Extended error status is
        available using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_NAME_INFORMATION FileNameInfo;
    DWORD FileNameInfoSize;
    DWORD FileInformationClass;


    if (CONSOLE_HANDLE(hFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return FALSE;
    }

    if (!ARGUMENT_PRESENT(lpShortName)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    FileNameInfoSize = FIELD_OFFSET(FILE_NAME_INFORMATION, FileName) + ((wcslen(lpShortName)+1)*sizeof(WCHAR));
    FileNameInfo = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG(TMP_TAG), FileNameInfoSize );
    if (!FileNameInfo) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    FileNameInfo->FileNameLength = wcslen(lpShortName) * sizeof(WCHAR);
    wcscpy( FileNameInfo->FileName, lpShortName );

    Status = NtSetInformationFile(
        hFile,
        &IoStatusBlock,
        FileNameInfo,
        FileNameInfoSize,
        FileShortNameInformation
        );

    RtlFreeHeap( RtlProcessHeap(), 0, FileNameInfo );

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    FileInformationClass = FileShortNameInformation;

    if ((FileInformationClass == FileEndOfFileInformation) ||
         (FileInformationClass == FileAllocationInformation) ||
         (FileInformationClass == FilePositionInformation))
    {
        return FALSE;
    }



    return TRUE;
}


BOOL
APIENTRY
SetFileShortNameA(
    IN HANDLE hFile,
    IN LPCSTR lpShortName
    )

/*++

Routine Description:

    SetFileShortNameW is used to set the short name for the given file.

Arguments:

    hFile - Supplies an open handle to a file whose short name is to be changed

    lpShortName - Supplies the desired short name

Return Value:

    TRUE - The operation was a success.

    FALSE - The operation failed.  Extended error status is
        available using GetLastError.

--*/

{
    PUNICODE_STRING Unicode;

    Unicode = Basep8BitStringToStaticUnicodeString( lpShortName );
    if (Unicode == NULL) {
        return FALSE;
    }

    return ( SetFileShortNameW(
                hFile,
                (LPCWSTR)Unicode->Buffer
                )
            );
}


BOOLEAN
Wow64EnableWow64FsRedirection (
    IN BOOLEAN Wow64FsEnableRedirection
    )

/*++

Routine Description:

    This function enables/disables Wow64 file system redirection.
    
    Wow64 redirects all accesses to %windir%\system32 to %windir%\syswow64.
    This API is useful  for 32-bit applications which want to gain access to the
    native system32 directory. By default, Wow64 file system redirection is enabled.
    
    File redirection is only affected for the thread calling this API.
    
    Note : You must enable file system redirection after disabling it. Once you have
           a file handle, you must enable file system redirection back. 
    
    Example:
    
    BOOL bRet = Wow64EnableWow64FsRedirection (FALSE);
    if (bRet == TRUE) {
        
        //
        // Open the file handle
        //
        
        CreateFile (..."c:\\windows\\system32\\notepad.exe"...)
        
        //
        // Enable Wow64 file system redirection.
        //
        
        Wow64EnableWow64FsRedirection (TRUE);
    }
    
    //
    // Use the file handle
    //
    

Arguments:

    Wow64FsEnableRedirection - Boolean to indicate whether to enable Wow64 file system
        redirection. Specify FALSE if you want to disable Wow64 file system redirection,
        otherwise TRUE to enable it.
        

Return Value:

    TRUE - The operation was successul.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.    
--*/

{
    NTSTATUS NtStatus;

    NtStatus = RtlWow64EnableFsRedirection (Wow64FsEnableRedirection);

    if (!NT_SUCCESS (NtStatus)) {
        
        BaseSetLastNTError (NtStatus);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\filemap.c ===
/*++

Copyright (c) 1990,1991 Microsoft Corporation

Module Name:

    filemap.c

Abstract:

    This module implements Win32 mapped file APIs

Author:

    Mark Lucovsky (markl) 15-Feb-1991

Revision History:

--*/

#include "basedll.h"
HANDLE
APIENTRY
CreateFileMappingA(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to CreateFileMappingW

--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    LPCWSTR NameBuffer;

    NameBuffer = NULL;
    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        NameBuffer = (LPCWSTR)Unicode->Buffer;
        }

    return CreateFileMappingW(
                hFile,
                lpFileMappingAttributes,
                flProtect,
                dwMaximumSizeHigh,
                dwMaximumSizeLow,
                NameBuffer
                );
}

HANDLE
APIENTRY
CreateFileMappingW(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    )
/*++

Routine Description:

    A file mapping object can be created using CreateFileMapping

    Creating a file mapping object creates the potential for mapping a
    view of the file into an address space.  File mapping objects may be
    shared either through process creation or handle duplication.
    Having a handle to a file mapping object allows for mapping of the
    file.  It does not mean that the file is actually mapped.

    A file mapping object has a maximum size.  This is used to size the
    file.  A file may not grow beyond the size specified in the mapping
    object.  While not required, it is recommended that when opening a
    file that you intend to map, the file should be opened for exclusive
    access.  Win32 does not require that a mapped file and a file
    accessed via the IO primitives (ReadFile/WriteFile) are coherent.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the
    following object type specific access flags are valid for file
    mapping objects:

      - FILE_MAP_WRITE - Write map access to the file mapping object is
            desired.  This allows a writable view of the file to be
            mapped.  Note that if flProtect does not include
            PAGE_READWRITE, this access type does not allow writing the
            mapped file.

      - FILE_MAP_READ - Read map access to the file mapping object is
            desired.  This allows a readablee view of the file to be
            mapped.

      - FILE_MAP_ALL_ACCESS - This set of access flags specifies all of
            the possible access flags for a file mapping object.

Arguments:

    hFile - Supplies an open handle to a file that a mapping object is
        to be created for.  The file must be opened with an access mode
        that is compatible with the specified pretection flags. A value
        of INVALID_HANDLE_VALUE specifies that the mapping object is
        backed by the system paging file.  If this is the case, a size
        must be specified.

    lpFileMappingAttributes - An optional parameter that may be used to
        specify the attributes of the new file mapping object.  If the
        parameter is not specified, then the file mapping object is
        created without a security descriptor, and the resulting handle
        is not inherited on process creation:

    flProtect - The protection desired for mapping object when the file
        is mapped.

        flProtect Values

        PAGE_READONLY - Read access to the committed region of pages is
            allowed.  An attempt to write or execute the committed
            region results in an access violation.  The specified hFile
            must have been created with GENERIC_READ access.

        PAGE_READWRITE - Read and write access to the committed region
            of pages is allowed.  The specified hFile must have been
            created with GENERIC_READ and GENERIC_WRITE access.

        PAGE_WRITECOPY - Read and copy on write access to the committed
            region of pages is allowed.  The specified hFile must have been
            created with GENERIC_READ access.

    dwMaximumSizeHigh - Supplies the high order 32-bits of the maximum
        size of the file mapping object.

    dwMaximumSizeLow - Supplies the low order 32-bits of the maximum
        size of the file mapping object.  A value of zero along with a
        value of zero in dwMaximumSizeHigh indicates that the size of
        the file mapping object is equal to the current size of the file
        specified by hFile.

    lpName - Supplies the name ofthe file mapping object.

Return Value:

    NON-NULL - Returns a handle to the new file mapping object.  The
        handle has full access to the new file mapping object and may be
        used in any API that requires a handle to a file mapping object.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    HANDLE Section;
    NTSTATUS Status;
    LARGE_INTEGER SectionSizeData;
    PLARGE_INTEGER SectionSize;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    ACCESS_MASK DesiredAccess;
    UNICODE_STRING ObjectName;
    ULONG AllocationAttributes;

    DesiredAccess = STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ;
    AllocationAttributes = flProtect & (SEC_FILE | SEC_IMAGE | SEC_RESERVE | SEC_COMMIT | SEC_NOCACHE);
    flProtect ^= AllocationAttributes;
    if (AllocationAttributes == 0) {
        AllocationAttributes = SEC_COMMIT;
        }

    if ( flProtect == PAGE_READWRITE ) {
        DesiredAccess |= (SECTION_MAP_READ | SECTION_MAP_WRITE);
        }
    else
    if ( flProtect != PAGE_READONLY && flProtect != PAGE_WRITECOPY ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
        }

    if ( ARGUMENT_PRESENT(lpName) ) {
        RtlInitUnicodeString(&ObjectName,lpName);
        pObja = BaseFormatObjectAttributes(&Obja,lpFileMappingAttributes,&ObjectName);
        }
    else {
        pObja = BaseFormatObjectAttributes(&Obja,lpFileMappingAttributes,NULL);
        }

    if ( dwMaximumSizeLow || dwMaximumSizeHigh ) {
        SectionSize = &SectionSizeData;
        SectionSize->LowPart = dwMaximumSizeLow;
        SectionSize->HighPart = dwMaximumSizeHigh;
        }
    else {
        SectionSize = NULL;
        }

    if (hFile == INVALID_HANDLE_VALUE) {
        hFile = NULL;
        if ( !SectionSize ) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return NULL;
            }
        }

    Status = NtCreateSection(
                &Section,
                DesiredAccess,
                pObja,
                SectionSize,
                flProtect,
                AllocationAttributes,
                hFile
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return Section = NULL;
        }
    else {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        }
    return Section;
}

HANDLE
APIENTRY
OpenFileMappingA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to OpenFileMappingW

--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        }
    else {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    return OpenFileMappingW(
                dwDesiredAccess,
                bInheritHandle,
                (LPCWSTR)Unicode->Buffer
                );
}

HANDLE
APIENTRY
OpenFileMappingW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING ObjectName;
    NTSTATUS Status;
    HANDLE Object;

    if ( !lpName ) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    RtlInitUnicodeString(&ObjectName,lpName);

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        (bInheritHandle ? OBJ_INHERIT : 0),
        BaseGetNamedObjectDirectory(),
        NULL
        );

    if ( dwDesiredAccess == FILE_MAP_COPY ) {
        dwDesiredAccess = FILE_MAP_READ;
        }

    Status = NtOpenSection(
                &Object,
                dwDesiredAccess,
                &Obja
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
        }
    return Object;
}


LPVOID
APIENTRY
MapViewOfFile(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    SIZE_T dwNumberOfBytesToMap
    )

/*++

Routine Description:

    A view of a file may be mapped into the address space of the calling
    process using MapViewOfFile.

    Mapping a file object makes the specified portion of the file
    visible in the address space of the calling process.  The return
    address is a pointer to memory that when addressed causes data
    within the file to be accessed.

    Mapping a view of a file has some simple coherency rules:

      - Multiple views on a file are coherent if they are derived from
        the same file mapping object.  If a process opens a file,
        creates a mapping object, duplicates the object to another
        process...  If both processes map a view of the file, they will
        both see a coherent view of the file's data...  they will
        effectively be viewing shared memory backed by the file.

      - If multiple mapping objects exist for the same file, then views
        derived from the different mapping objects are not garunteed to
        be coherent.

      - A mapped view on a file is not garunteed to be coherent with a
        file being accessed via ReadFile or WriteFile.

Arguments:

    hFileMappingObject - Supplies an open handle to a file mapping object
        that is to be mapped into the callers address space.

    dwDesiredAccess - Specifies the access that is requested to the file
        mapping object. This determines the page protection of the pages
        mapped by the file.

        dwDesiredAccess Values:

        FILE_MAP_WRITE - Read/write access is desired.  The mapping
            object must have been created with PAGE_READWRITE
            protection.  The hFileMappingObject must have been created
            with FILE_MAP_WRITE access. A read/write view of the file will
            be mapped.

        FILE_MAP_READ - Read access is desired.  The mapping object must
            have been created with PAGE_READWRITE or PAGE_READ
            protection.  The hFileMappingObject must have been created
            with FILE_MAP_READ access.  A read only view of the file
            will be mapped.

    dwFileOffsetHigh - Supplies the high order 32-bits of the file
        offset where mapping is to begin.

    dwFileOffsetLow - Supplies the low order 32-bits of the file offset
        where mapping is to begin. The combination of the high and low
        offsets must specify a 64Kb aligned offset within the file. It
        is an error if this is not the case.

    dwNumberOfBytesToMap - Supplies the number of bytes of the file to map.
        A value of zero specifies that the entire file is to be mapped.

Return Value:

    NON-NULL - Returns the address of where the file is mapped.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return MapViewOfFileEx(
            hFileMappingObject,
            dwDesiredAccess,
            dwFileOffsetHigh,
            dwFileOffsetLow,
            dwNumberOfBytesToMap,
            NULL
            );
}

LPVOID
APIENTRY
MapViewOfFileEx(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    SIZE_T dwNumberOfBytesToMap,
    LPVOID lpBaseAddress
    )

/*++

Routine Description:

    A view of a file may be mapped into the address space of the calling
    process using MapViewOfFileEx.

    Mapping a file object makes the specified portion of the file
    visible in the address space of the calling process.  The return
    address is a pointer to memory that when addressed causes data
    within the file to be accessed. This API allows the caller to
    supply the system with a suggested mapping address. The system
    will round this address down to the nearest 64k boundry and attempt
    to map the file at thet address. If there is not enough address space
    at that address, this call will fail.

    Mapping a view of a file has some simple coherency rules:

      - Multiple views on a file are coherent if they are derived from
        the same file mapping object.  If a process opens a file,
        creates a mapping object, duplicates the object to another
        process...  If both processes map a view of the file, they will
        both see a coherent view of the file's data...  they will
        effectively be viewing shared memory backed by the file.

      - If multiple mapping objects exist for the same file, then views
        derived from the different mapping objects are not garunteed to
        be coherent.

      - A mapped view on a file is not garunteed to be coherent with a
        file being accessed via ReadFile or WriteFile.

Arguments:

    hFileMappingObject - Supplies an open handle to a file mapping object
        that is to be mapped into the callers address space.

    dwDesiredAccess - Specifies the access that is requested to the file
        mapping object. This determines the page protection of the pages
        mapped by the file.

        dwDesiredAccess Values:

        FILE_MAP_WRITE - Read/write access is desired.  The mapping
            object must have been created with PAGE_READWRITE
            protection.  The hFileMappingObject must have been created
            with FILE_MAP_WRITE access. A read/write view of the file will
            be mapped.

        FILE_MAP_READ - Read access is desired.  The mapping object must
            have been created with PAGE_READWRITE or PAGE_READ
            protection.  The hFileMappingObject must have been created
            with FILE_MAP_READ access.  A read only view of the file
            will be mapped.

    dwFileOffsetHigh - Supplies the high order 32-bits of the file
        offset where mapping is to begin.

    dwFileOffsetLow - Supplies the low order 32-bits of the file offset
        where mapping is to begin. The combination of the high and low
        offsets must specify a 64Kb aligned offset within the file. It
        is an error if this is not the case.

    dwNumberOfBytesToMap - Supplies the number of bytes of the file to map.
        A value of zero specifies that the entire file is to be mapped.

    lpBaseAddress - Supplies the base address of where in the processes
        address space the mapping is to begin at.  The address is
        rounded down to the nearest 64k boundry by the system.  A value
        of NULL for this parameter operates exactly the same as
        MapViewOfFile...  The system picks the mapping base address
        without any hint from the caller.

Return Value:

    NON-NULL - Returns the address of where the file is mapped.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    PVOID ViewBase;
    ULONG Protect;

    SectionOffset.LowPart = dwFileOffsetLow;
    SectionOffset.HighPart = dwFileOffsetHigh;
    ViewSize = dwNumberOfBytesToMap;
    ViewBase = lpBaseAddress;

    if ( dwDesiredAccess == FILE_MAP_COPY ) {
        Protect = PAGE_WRITECOPY;
        }
    else
    if ( dwDesiredAccess & FILE_MAP_WRITE ) {
        Protect = PAGE_READWRITE;
        }
    else if ( dwDesiredAccess & FILE_MAP_READ ) {
        Protect = PAGE_READONLY;
        }
    else {
        Protect = PAGE_NOACCESS;
        }

    Status = NtMapViewOfSection(
                hFileMappingObject,
                NtCurrentProcess(),
                &ViewBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                Protect
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
        }
    return ViewBase;
}


BOOL
APIENTRY
FlushViewOfFile(
    LPCVOID lpBaseAddress,
    SIZE_T dwNumberOfBytesToFlush
    )

/*++

Routine Description:

    A byte range within a mapped view of a file can be flushed to disk
    using FlushViewOfFile.

    A byte range within a mapped view of a file can be flushed to disk
    using FlushViewOfFile.

    Flushing a range of a mapped view causes any dirty pages within that
    range to be written to disk.  This operation automatically happens
    whenever a view is unmapped (either explicitly or as a result of
    process termination).


Arguments:

    lpBaseAddress - Supplies the base address of a set of bytes that are
        to be flushed to the on disk representation of the mapped file.

    dwNumberOfBytesToFlush - Supplies the number of bytes to flush.

Return Value:

    TRUE - The operation was successful.  All dirty pages within the
        specified range are stored in the on-disk representation of the
        mapped file.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    PVOID BaseAddress;
    SIZE_T RegionSize;
    IO_STATUS_BLOCK IoStatus;

    BaseAddress = (PVOID)lpBaseAddress;
    RegionSize = dwNumberOfBytesToFlush;

    Status = NtFlushVirtualMemory(
                NtCurrentProcess(),
                &BaseAddress,
                &RegionSize,
                &IoStatus
                );
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_NOT_MAPPED_DATA ) {
            return TRUE;
            }
        BaseSetLastNTError(Status);
        return FALSE;
        }

    return TRUE;
}

BOOL
APIENTRY
UnmapViewOfFile(
    LPCVOID lpBaseAddress
    )

/*++

Routine Description:

    A previously mapped view of a file may be unmapped from the callers
    address space using UnmapViewOfFile.

Arguments:

    lpBaseAddress - Supplies the base address of a previously mapped
        view of a file that is to be unmapped.  This value must be
        identical to the value returned by a previous call to
        MapViewOfFile.

Return Value:

    TRUE - The operation was successful.  All dirty pages within the
        specified range are stored in the on-disk representation of the
        mapped file.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtUnmapViewOfSection(NtCurrentProcess(),(PVOID)lpBaseAddress);

    if ( !NT_SUCCESS(Status) ) {
        if (Status == STATUS_INVALID_PAGE_PROTECTION) {

            //
            // Unlock any pages that were locked with MmSecureVirtualMemory.
            // This is useful for SANs.
            //

            if (RtlFlushSecureMemoryCache((PVOID)lpBaseAddress, 0)) {
                Status = NtUnmapViewOfSection(NtCurrentProcess(),
                                              (PVOID)lpBaseAddress
                                            );

                if (NT_SUCCESS( Status )) {
                    return( TRUE );
                    }
                }
            }
        BaseSetLastNTError(Status);
        return FALSE;
        }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\filemisc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    filemisc.c

Abstract:

    Misc file operations for Win32

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include <basedll.h>


DWORD
BasepGetComputerNameFromNtPath (
    PUNICODE_STRING NtPathName,
    HANDLE hFile,
    LPWSTR lpBuffer,
    LPDWORD nSize
    );

NTSTATUS
BasepMoveFileDelayed(
    IN PUNICODE_STRING OldFileName,
    IN PUNICODE_STRING NewFileName,
    IN ULONG Index,
    IN BOOL OkayToCreateNewValue
    );

BOOL
APIENTRY
SetFileAttributesA(
    LPCSTR lpFileName,
    DWORD dwFileAttributes
    )

/*++

Routine Description:

    ANSI thunk to SetFileAttributesW

--*/

{
    PUNICODE_STRING Unicode;

    Unicode = Basep8BitStringToStaticUnicodeString( lpFileName );
    if (Unicode == NULL) {
        return FALSE;
    }

    return ( SetFileAttributesW(
                (LPCWSTR)Unicode->Buffer,
                dwFileAttributes
                )
            );
}


BOOL
APIENTRY
SetFileAttributesW(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    )

/*++

Routine Description:

    The attributes of a file can be set using SetFileAttributes.

    This API provides the same functionality as DOS (int 21h, function
    43H with AL=1), and provides a subset of OS/2's DosSetFileInfo.

Arguments:

    lpFileName - Supplies the file name of the file whose attributes are to
        be set.

    dwFileAttributes - Specifies the file attributes to be set for the
        file.  Any combination of flags is acceptable except that all
        other flags override the normal file attribute,
        FILE_ATTRIBUTE_NORMAL.

        FileAttributes Flags:

        FILE_ATTRIBUTE_NORMAL - A normal file should be created.

        FILE_ATTRIBUTE_READONLY - A read-only file should be created.

        FILE_ATTRIBUTE_HIDDEN - A hidden file should be created.

        FILE_ATTRIBUTE_SYSTEM - A system file should be created.

        FILE_ATTRIBUTE_ARCHIVE - The file should be marked so that it
            will be archived.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Open the file inhibiting the reparse behavior.
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                );

    if ( !NT_SUCCESS(Status) ) {
        //
        // Back level file systems may not support reparse points.
        // We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
        //

        if ( Status == STATUS_INVALID_PARAMETER ) {
            //
            // Open the file without inhibiting the reparse behavior.
            //

            Status = NtOpenFile(
                        &Handle,
                        (ACCESS_MASK)FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                        );

            if ( !NT_SUCCESS(Status) ) {
                RtlReleaseRelativeName(&RelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                BaseSetLastNTError(Status);
                return FALSE;
                }
            }
        else {
            RtlReleaseRelativeName(&RelativeName);
            RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }

    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    //
    // Set the attributes
    //

    RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));
    BasicInfo.FileAttributes = (dwFileAttributes & FILE_ATTRIBUTE_VALID_SET_FLAGS) | FILE_ATTRIBUTE_NORMAL;

    Status = NtSetInformationFile(
                Handle,
                &IoStatusBlock,
                &BasicInfo,
                sizeof(BasicInfo),
                FileBasicInformation
                );

    NtClose(Handle);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}



DWORD
APIENTRY
GetFileAttributesA(
    LPCSTR lpFileName
    )

/*++

Routine Description:

    ANSI thunk to GetFileAttributesW

--*/

{

    PUNICODE_STRING Unicode;

    Unicode = Basep8BitStringToStaticUnicodeString( lpFileName );
    if (Unicode == NULL) {
        return (DWORD)-1;
    }

    return ( GetFileAttributesW((LPCWSTR)Unicode->Buffer) );
}

DWORD
APIENTRY
GetFileAttributesW(
    LPCWSTR lpFileName
    )

/*++

Routine Description:

    The attributes of a file can be obtained using GetFileAttributes.

    This API provides the same functionality as DOS (int 21h, function
    43H with AL=0), and provides a subset of OS/2's DosQueryFileInfo.

Arguments:

    lpFileName - Supplies the file name of the file whose attributes are to
        be set.

Return Value:

    Not -1 - Returns the attributes of the specified file.  Valid
        returned attributes are:

        FILE_ATTRIBUTE_NORMAL - The file is a normal file.

        FILE_ATTRIBUTE_READONLY - The file is marked read-only.

        FILE_ATTRIBUTE_HIDDEN - The file is marked as hidden.

        FILE_ATTRIBUTE_SYSTEM - The file is marked as a system file.

        FILE_ATTRIBUTE_ARCHIVE - The file is marked for archive.

        FILE_ATTRIBUTE_DIRECTORY - The file is marked as a directory.

        FILE_ATTRIBUTE_REPARSE_POINT - The file is marked as a reparse point.

        FILE_ATTRIBUTE_VOLUME_LABEL - The file is marked as a volume lable.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    FILE_BASIC_INFORMATION BasicInfo;
    BOOLEAN TranslationStatus;
    PVOID FreeBuffer;

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            NULL
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return (DWORD)-1;
        }

    FreeBuffer = FileName.Buffer;

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the file
    //

    Status = NtQueryAttributesFile(
                 &Obja,
                 &BasicInfo
                 );
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    if ( NT_SUCCESS(Status) ) {
        return BasicInfo.FileAttributes;
        }
    else {

        //
        // Check for a device name.
        //

        if ( RtlIsDosDeviceName_U((PWSTR)lpFileName) ) {
            return FILE_ATTRIBUTE_ARCHIVE;
            }
        BaseSetLastNTError(Status);
        return (DWORD)-1;
        }
}

BOOL
APIENTRY
GetFileAttributesExA(
    LPCSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
    )

/*++

Routine Description:

    ANSI thunk to GetFileAttributesExW

--*/

{

    PUNICODE_STRING Unicode;

    Unicode = Basep8BitStringToStaticUnicodeString( lpFileName );
    if (Unicode == NULL) {
        return FALSE;
    }

    return ( GetFileAttributesExW((LPCWSTR)Unicode->Buffer,fInfoLevelId,lpFileInformation) );
}

BOOL
APIENTRY
GetFileAttributesExW(
    LPCWSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
    )

/*++

Routine Description:

    The main attributes of a file can be obtained using GetFileAttributesEx.

Arguments:

    lpFileName - Supplies the file name of the file whose attributes are to
        be set.

    fInfoLevelId - Supplies the info level indicating the information to be
        returned about the file.

    lpFileInformation - Supplies a buffer to receive the specified information
        about the file.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;
    LPWIN32_FILE_ATTRIBUTE_DATA AttributeData;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;

    //
    // Check the parameters.  Note that for now there is only one info level,
    // so there's no special code here to determine what to do.
    //

    if ( fInfoLevelId >= GetFileExMaxInfoLevel || fInfoLevelId < GetFileExInfoStandard ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Query the information about the file using the path-based NT service.
    //

    Status = NtQueryFullAttributesFile( &Obja, &NetworkInfo );
    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    if ( NT_SUCCESS(Status) ) {
        AttributeData = (LPWIN32_FILE_ATTRIBUTE_DATA)lpFileInformation;
        AttributeData->dwFileAttributes = NetworkInfo.FileAttributes;
        AttributeData->ftCreationTime = *(PFILETIME)&NetworkInfo.CreationTime;
        AttributeData->ftLastAccessTime = *(PFILETIME)&NetworkInfo.LastAccessTime;
        AttributeData->ftLastWriteTime = *(PFILETIME)&NetworkInfo.LastWriteTime;
        AttributeData->nFileSizeHigh = NetworkInfo.EndOfFile.HighPart;
        AttributeData->nFileSizeLow = (DWORD)NetworkInfo.EndOfFile.LowPart;
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
APIENTRY
DeleteFileA(
    LPCSTR lpFileName
    )

/*++

Routine Description:

    ANSI thunk to DeleteFileW

--*/

{
    PUNICODE_STRING Unicode;

    Unicode = Basep8BitStringToStaticUnicodeString( lpFileName );
    if (Unicode == NULL) {
        return FALSE;
    }

    return ( DeleteFileW((LPCWSTR)Unicode->Buffer) );
}

BOOL
APIENTRY
DeleteFileW(
    LPCWSTR lpFileName
    )

/*++

    Routine Description:

    An existing file can be deleted using DeleteFile.

    This API provides the same functionality as DOS (int 21h, function 41H)
    and OS/2's DosDelete.

Arguments:

    lpFileName - Supplies the file name of the file to be deleted.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_DISPOSITION_INFORMATION Disposition;
    FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;
    BOOLEAN fIsSymbolicLink = FALSE;

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Open the file for delete access.
    // Inhibit the reparse behavior using FILE_OPEN_REPARSE_POINT.
    //

    Status = NtOpenFile(
                 &Handle,
                 (ACCESS_MASK)DELETE | FILE_READ_ATTRIBUTES,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                 );
    if ( !NT_SUCCESS(Status) ) {
        //
        // Back level file systems may not support reparse points and thus not
        // support symbolic links.
        // We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
        //

        if ( Status == STATUS_INVALID_PARAMETER ) {
            //
            // Open without inhibiting the reparse behavior and not needing to
            // read the attributes.
            //

            Status = NtOpenFile(
                         &Handle,
                         (ACCESS_MASK)DELETE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                         );
            if ( !NT_SUCCESS(Status) ) {
                RtlReleaseRelativeName(&RelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                BaseSetLastNTError(Status);
                return FALSE;
                }
            }
        else {
            //
            // A second case of interest is when the caller does not have rights 
            // to read attributes yet it does have rights to delete the file.
            // In this case Status is to be STATUS_ACCESS_DENIED.
            //
            
            if ( Status != STATUS_ACCESS_DENIED ) {
                RtlReleaseRelativeName(&RelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                BaseSetLastNTError(Status);
                return FALSE;
                }
            
            // 
            // Re-open inhibiting reparse point and not requiring read attributes.
            //

            Status = NtOpenFile(
                         &Handle,
                         (ACCESS_MASK)DELETE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                         );
            if ( !NT_SUCCESS(Status) ) {
                RtlReleaseRelativeName(&RelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                BaseSetLastNTError(Status);
                return FALSE;
                }

            //
            // If we are here, Handle is valid.
            //
            // Moreover, Handle is to a file for which the caller has DELETE right yet
            // does not have FILE_READ_ATTRIBUTES rights. 
            //
            // The underlying file may or not be a reparse point. 
            // As the caller does not have rights to read the attributes this code
            // will delete this file without giving the opportunity to the 
            // appropriate manager of these reparse points to clean-up its internal 
            // state at this time.
            //
            }
        }
    else {
        //
        // If we found a reparse point that is not a symbolic link, we re-open
        // without inhibiting the reparse behavior.
        //

        Status = NtQueryInformationFile(
                     Handle,
                     &IoStatusBlock,
                     (PVOID) &FileTagInformation,
                     sizeof(FileTagInformation),
                     FileAttributeTagInformation
                     );
        if ( !NT_SUCCESS(Status) ) {
            //
            // Not all File Systems implement all information classes.
            // The value STATUS_INVALID_PARAMETER is returned when a non-supported
            // information class is requested to a back-level File System. As all the
            // parameters to NtQueryInformationFile are correct, we can infer that
            // we found a back-level system.
            //
            // If FileAttributeTagInformation is not implemented, we assume that
            // the file at hand is not a reparse point.
            //

            if ( (Status != STATUS_NOT_IMPLEMENTED) &&
                 (Status != STATUS_INVALID_PARAMETER) ) {
                RtlReleaseRelativeName(&RelativeName);
                RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                NtClose(Handle);
                BaseSetLastNTError(Status);
                return FALSE;
                }
            }

        if ( NT_SUCCESS(Status) &&
             (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) ) {
            if ( FileTagInformation.ReparseTag == IO_REPARSE_TAG_MOUNT_POINT ) {
                fIsSymbolicLink = TRUE;
                }
            }

        if ( NT_SUCCESS(Status) &&
             (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) &&
             !fIsSymbolicLink) {
            //
            // Re-open without inhibiting the reparse behavior and not needing to
            // read the attributes.
            //

            NtClose(Handle);
            Status = NtOpenFile(
                         &Handle,
                         (ACCESS_MASK)DELETE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                         );

            if ( !NT_SUCCESS(Status) ) {
                //
                // When the FS Filter is absent, delete it any way.
                //

                if ( Status == STATUS_IO_REPARSE_TAG_NOT_HANDLED ) {
                    //
                    // We re-open (possible 3rd open) for delete access inhibiting the reparse behavior.
                    //

                    Status = NtOpenFile(
                                 &Handle,
                                 (ACCESS_MASK)DELETE,
                                 &Obja,
                                 &IoStatusBlock,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                 FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
                                 );
                    }

                if ( !NT_SUCCESS(Status) ) {
                    RtlReleaseRelativeName(&RelativeName);
                    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                    BaseSetLastNTError(Status);
                    return FALSE;
                    }
                }
            }
        }

    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    //
    // Delete the file
    //
#undef DeleteFile
    Disposition.DeleteFile = TRUE;

    Status = NtSetInformationFile(
                 Handle,
                 &IoStatusBlock,
                 &Disposition,
                 sizeof(Disposition),
                 FileDispositionInformation
                 );

    NtClose(Handle);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}


//
//  Ascii versions that thunk to the common code
//

BOOL
APIENTRY
MoveFileA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName
    )
{
    return MoveFileWithProgressA( lpExistingFileName,
                                  lpNewFileName,
                                  (LPPROGRESS_ROUTINE)NULL,
                                  NULL,
                                  MOVEFILE_COPY_ALLOWED );
}

BOOL
APIENTRY
MoveFileExA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    DWORD dwFlags
    )

{
    return MoveFileWithProgressA( lpExistingFileName,
                                  lpNewFileName,
                                  (LPPROGRESS_ROUTINE)NULL,
                                  NULL,
                                  dwFlags );
}


BOOL
APIENTRY
MoveFileWithProgressA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData OPTIONAL,
    DWORD dwFlags
    )

/*++

Routine Description:

    ANSI thunk to MoveFileWithProgressW

--*/

{

    UNICODE_STRING UnicodeOldFileName;
    UNICODE_STRING UnicodeNewFileName;
    BOOL ReturnValue;

    if ( !Basep8BitStringToDynamicUnicodeString(&UnicodeOldFileName, lpExistingFileName) ) {
        return FALSE;
        }

    if ( ARGUMENT_PRESENT(lpNewFileName) ) {
        if ( !Basep8BitStringToDynamicUnicodeString(&UnicodeNewFileName, lpNewFileName) ) {
            RtlFreeUnicodeString(&UnicodeOldFileName);
            return FALSE;
            }
        }
    else {
        UnicodeNewFileName.Buffer = NULL;
        }

    ReturnValue =
        MoveFileWithProgressW( (LPCWSTR)UnicodeOldFileName.Buffer,
                               (LPCWSTR)UnicodeNewFileName.Buffer,
                               lpProgressRoutine,
                               lpData,
                               dwFlags
                               );

    RtlFreeUnicodeString(&UnicodeOldFileName);
    RtlFreeUnicodeString(&UnicodeNewFileName);

    return ReturnValue;
}

typedef struct _HELPER_CONTEXT {
    DWORD dwFlags;
    LPPROGRESS_ROUTINE lpProgressRoutine;
    LPVOID lpData;
} HELPER_CONTEXT, *PHELPER_CONTEXT;

DWORD
APIENTRY
BasepMoveFileCopyProgress(
    LARGE_INTEGER TotalFileSize,
    LARGE_INTEGER TotalBytesTransferred,
    LARGE_INTEGER StreamSize,
    LARGE_INTEGER StreamBytesTransferred,
    DWORD dwStreamNumber,
    DWORD dwCallbackReason,
    HANDLE SourceFile,
    HANDLE DestinationFile,
    LPVOID lpData OPTIONAL
    )
/*++

Routine Description:

    Perform special actions when doing move-by-copy.

Arguments:

    TotalFileSize - total number of bytes being transferred

    TotalBytesTransferred - current progress through the file

    StreamSize - total number of bytes being transferred in this stream

    StreamBytesTransferred - current progress through this stream

    dwStreamNumber - ordinal number of stream

    dwCallbackReason - CopyFile's reason for calling us

    SourceFile - source handle of transfer

    DestinationFile - destination handle of transfer

    lpData - pointer to HELPER_CONTEXT constructed by MoveFileWithProgressW.


Return Value:

    PROGRESS_CONTINUE if no progress routine was specified, otherwise
        the return value from the progress routine specified to
        MoveFileWithProgress

--*/

{
    PHELPER_CONTEXT Context = (PHELPER_CONTEXT)lpData;

    //
    //  If we are finished with a stream and the caller
    //  specified WRITE_THROUGH then we make sure the file buffers
    //  actually made it out to disk.
    //

    if ((Context->dwFlags & MOVEFILE_WRITE_THROUGH) != 0
        && dwCallbackReason == CALLBACK_CHUNK_FINISHED
        && StreamBytesTransferred.QuadPart == StreamSize.QuadPart ) {

        FlushFileBuffers(DestinationFile);

    }


    //
    //  If a callback routine was specified, call through him
    //

    if (Context->lpProgressRoutine == NULL) {
        return PROGRESS_CONTINUE;
    }

    return (Context->lpProgressRoutine) (
                TotalFileSize,
                TotalBytesTransferred,
                StreamSize,
                StreamBytesTransferred,
                dwStreamNumber,
                dwCallbackReason,
                SourceFile,
                DestinationFile,
                Context->lpData );
}



NTSTATUS
BasepNotifyTrackingService( PHANDLE SourceFile,
                            POBJECT_ATTRIBUTES SourceFileObjAttributes,
                            HANDLE DestFile,
                            PUNICODE_STRING NewFileName
                            )
{
    NTSTATUS Status = STATUS_SUCCESS;
    FILE_BASIC_INFORMATION BasicInformation;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG FileAttributes;
    ULONG cchComputerName;
    WCHAR ComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD dwError;

    BYTE FTIBuffer[ sizeof(FILE_TRACKING_INFORMATION) + MAX_COMPUTERNAME_LENGTH + 1 ];
    PFILE_TRACKING_INFORMATION pfti = (PFILE_TRACKING_INFORMATION) &FTIBuffer[0];

    try
    {
        cchComputerName = MAX_COMPUTERNAME_LENGTH + 1;
        dwError = BasepGetComputerNameFromNtPath( NewFileName,
                                                  DestFile,
                                                  ComputerName,
                                                  &cchComputerName );

        if (ERROR_SUCCESS != dwError) {
            pfti->ObjectInformationLength = 0;
        } else {
            
            CHAR ComputerNameOemBuffer[ MAX_PATH ];
            OEM_STRING ComputerNameOemString = { 0,
                                                 sizeof(ComputerNameOemBuffer),
                                                 ComputerNameOemBuffer };
            UNICODE_STRING ComputerNameUnicodeString;

            RtlInitUnicodeString( &ComputerNameUnicodeString,
                                  ComputerName );


            Status = RtlUnicodeStringToOemString( &ComputerNameOemString,
                                                  &ComputerNameUnicodeString,
                                                  FALSE );  // Don't allocate
            if( !NT_SUCCESS(Status) ) {
                leave;
            }

            memcpy( pfti->ObjectInformation,
                    ComputerNameOemString.Buffer,
                    ComputerNameOemString.Length );
            pfti->ObjectInformation[ ComputerNameOemString.Length ] = '\0';
                
            // Fill in the rest of the fti buffer, and set the file information

            pfti->ObjectInformationLength = ComputerNameOemString.Length + 1;
        }

        pfti->DestinationFile = DestFile;

        Status = NtSetInformationFile(
                                     *SourceFile,
                                     &IoStatusBlock,
                                     pfti,
                                     sizeof( FTIBuffer ),
                                     FileTrackingInformation );

        //
        // Check to see if tracking failed because
        // the source has a read-only attribute set.
        //

        if (Status != STATUS_ACCESS_DENIED) {
            leave;
        }

        //
        // reopen the source file and reset the read-only attribute
        // so that we'll be able to open for write access.
        //

        CloseHandle(*SourceFile);

        Status = NtOpenFile(
                           SourceFile,
                           SYNCHRONIZE | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                           SourceFileObjAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                           FILE_SYNCHRONOUS_IO_NONALERT
                           );

        if (!NT_SUCCESS(Status)) {
            *SourceFile = INVALID_HANDLE_VALUE;
            leave;
        }


        Status = NtQueryInformationFile(
                                       *SourceFile,
                                       &IoStatusBlock,
                                       &BasicInformation,
                                       sizeof(BasicInformation),
                                       FileBasicInformation );

        if (!NT_SUCCESS(Status)) {
            leave;
        }

        //
        // Reset the r/o bit and write the attributes back.
        //

        FileAttributes = BasicInformation.FileAttributes;
        RtlZeroMemory(&BasicInformation, sizeof(BasicInformation));
        BasicInformation.FileAttributes = FileAttributes & ~FILE_ATTRIBUTE_READONLY;

        Status = NtSetInformationFile(
                                     *SourceFile,
                                     &IoStatusBlock,
                                     &BasicInformation,
                                     sizeof(BasicInformation),
                                     FileBasicInformation);

        if (!NT_SUCCESS(Status)) {

            //
            // If this fails, we can't track the file.
            //

            leave;
        }

        //
        // Now that the r/o bit is reset, reopen for write access and
        // retry the tracking notification.
        //

        else {
            HANDLE hSourceRw;

            Status = NtOpenFile(
                               &hSourceRw,
                               SYNCHRONIZE | GENERIC_WRITE,
                               SourceFileObjAttributes,
                               &IoStatusBlock,
                               FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                               FILE_SYNCHRONOUS_IO_NONALERT
                               );

            if (NT_SUCCESS(Status)) {
                NtClose(*SourceFile);
                *SourceFile = hSourceRw;

                //
                // Send the source machine a tracking notification.
                //

                Status = NtSetInformationFile( *SourceFile,
                                               &IoStatusBlock,
                                               pfti,
                                               sizeof( FTIBuffer ),
                                               FileTrackingInformation );
            }
        }


        if (!NT_SUCCESS(Status)) {

            //
            // Try to put back the r/o bit -- don't assign Status here
            // because we want to fail. If we crash here, we may leave
            // the r/o attribute clear when it should be set, but there's
            // not much we can do about it without a transaction.
            //

            BasicInformation.FileAttributes |= FILE_ATTRIBUTE_READONLY;
            NtSetInformationFile(
                                *SourceFile,
                                &IoStatusBlock,
                                &BasicInformation,
                                sizeof(BasicInformation),
                                FileBasicInformation);
        }
    }
    finally
    {
    }


    return( Status );

}





BOOL
APIENTRY
MoveFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName
    )
{
    return MoveFileWithProgressW( lpExistingFileName,
                                  lpNewFileName,
                                  (LPPROGRESS_ROUTINE)NULL,
                                  NULL,
                                  MOVEFILE_COPY_ALLOWED );
}

BOOL
APIENTRY
MoveFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags
    )

{
    return MoveFileWithProgressW( lpExistingFileName,
                                  lpNewFileName,
                                  (LPPROGRESS_ROUTINE)NULL,
                                  NULL,
                                  dwFlags );
}

BOOL
APIENTRY
MoveFileWithProgressW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    DWORD dwFlags
    )

/*++

Routine Description:

    An existing file can be renamed using MoveFileWithProgressW.

Arguments:

    lpExistingFileName - Supplies the name of an existing file that is to be
        renamed.

    lpNewFileName - Supplies the new name for the existing file.  The new
        name must reside in the same file system/drive as the existing
        file and must not already exist.

    lpProgressRoutine - Supplies a callback routine that is notified.

    lpData - Supplies context data passed to the progress routine.

    dwFlags - Supplies optional flag bits to control the behavior of the
        rename.  The following bits are currently defined:

        MOVEFILE_REPLACE_EXISTING - if the new file name exists, replace
            it by renaming the old file name on top of the new file name.

        MOVEFILE_COPY_ALLOWED - if the new file name is on a different
            volume than the old file name, and causes the rename operation
            to fail, then setting this flag allows the MoveFileEx API
            call to simulate the rename with a call to CopyFile followed
            by a call to DeleteFile to the delete the old file if the
            CopyFile was successful.

        MOVEFILE_DELAY_UNTIL_REBOOT - dont actually do the rename now, but
            instead queue the rename so that it will happen the next time
            the system boots.  If this flag is set, then the lpNewFileName
            parameter may be NULL, in which case a delay DeleteFile of
            the old file name will occur the next time the system is
            booted.

            The delay rename/delete operations occur immediately after
            AUTOCHK is run, but prior to creating any paging files, so
            it can be used to delete paging files from previous boots
            before they are reused.

        MOVEFILE_WRITE_THROUGH - perform the rename operation in such a
            way that the file has actually been moved on the disk before
            the API returns to the caller.  Note that this flag causes a
            flush at the end of a copy operation (if one were allowed and
            necessary), and has no effect if the rename operation is
            delayed until the next reboot.

        MOVEFILE_CREATE_HARDLINK - create a hard link from the new file name to
            the existing file name.  May not be specified with
            MOVEFILE_DELAY_UNTIL_REBOOT

        MOVEFILE_FAIL_IF_NOT_TRACKABLE - fail the move request if the file cannot
            be tracked.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    BOOLEAN ReplaceIfExists;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle = INVALID_HANDLE_VALUE;
    UNICODE_STRING OldFileName;
    UNICODE_STRING NewFileName;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_RENAME_INFORMATION NewName;
    FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;
    BOOLEAN TranslationStatus;
    ULONG OpenFlags;
    BOOLEAN b = FALSE;
    HELPER_CONTEXT Context;

    NewFileName.Buffer = NULL;
    OldFileName.Buffer = NULL;

    try {

        //
        // if the target is a device, do not allow the rename !
        //

        if ( lpNewFileName ) {
            if ( RtlIsDosDeviceName_U((PWSTR)lpNewFileName) ) {
                BaseSetLastNTError( STATUS_OBJECT_NAME_COLLISION );
                leave;
            }
        }

        ReplaceIfExists = (dwFlags & MOVEFILE_REPLACE_EXISTING) != 0;

        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                lpExistingFileName,
                                &OldFileName,
                                NULL,
                                NULL
                                );

        if ( !TranslationStatus ) {
            BaseSetLastNTError( STATUS_OBJECT_PATH_NOT_FOUND );
            leave;
        }

        //
        //  Cannot perform delayed-move-by-creating-hardlink
        //

        if ((dwFlags & MOVEFILE_DELAY_UNTIL_REBOOT) != 0 &&
            (dwFlags & MOVEFILE_CREATE_HARDLINK) != 0) {
            BaseSetLastNTError( STATUS_INVALID_PARAMETER );
            leave;
        }

        //
        //  Get a handle to the source of the move.  We do this even for
        //  the delayed move in order to validate that we have delete
        //  access to the file.
        //

        InitializeObjectAttributes(
                                  &Obja,
                                  &OldFileName,
                                  OBJ_CASE_INSENSITIVE,
                                  NULL,
                                  NULL
                                  );

        //
        //  Establish whether we are renaming a symbolic link or not by:
        //      (1) obtaining a handle to the local entity, and
        //      (2) finding whether a symbolic link was found.
        //
        //  Open the file for delete access inhibiting the reparse
        //  point behavior.
        //

        OpenFlags = FILE_SYNCHRONOUS_IO_NONALERT |
                    FILE_OPEN_FOR_BACKUP_INTENT  |
                    ((dwFlags & MOVEFILE_WRITE_THROUGH) ? FILE_WRITE_THROUGH : 0);

        Status = NtOpenFile( &Handle,
                             FILE_READ_ATTRIBUTES | DELETE | SYNCHRONIZE,
                             &Obja,
                             &IoStatusBlock,
                             FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                             FILE_OPEN_REPARSE_POINT | OpenFlags
                             );


        if (!NT_SUCCESS( Status )) {

            //
            //  The Open may fail for a number of reasons.  If we're
            //  delaying the operation until reboot, it doesn't matter
            //  if we get a sharing violation or a non-existent file
            //  or a non-existent path.
            //

            if (((dwFlags & MOVEFILE_DELAY_UNTIL_REBOOT) != 0)
                && (Status == STATUS_SHARING_VIOLATION
                    || Status == STATUS_OBJECT_NAME_NOT_FOUND
                    || Status == STATUS_OBJECT_PATH_NOT_FOUND)) {

                Handle = INVALID_HANDLE_VALUE;

            } else {

                //
                //  Back level file systems may not support reparse points and thus not
                //  support symbolic links.
                //
                //  We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
                //

                if ( Status == STATUS_INVALID_PARAMETER ) {

                    //
                    //  Retry the open without reparse behaviour.  This should be compatible
                    //  with older file systems.
                    //

                    Status = NtOpenFile(
                                       &Handle,
                                       DELETE | SYNCHRONIZE,
                                       &Obja,
                                       &IoStatusBlock,
                                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                                       OpenFlags
                                       );
                }

                if ( !NT_SUCCESS( Status ) ) {
                    BaseSetLastNTError( Status );
                    leave;
                }
            }
        } else {

            //
            //  The open succeeded. If we do not find a symbolic link or a mount point,
            //  re-open without inhibiting the reparse behavior.
            //

            Status = NtQueryInformationFile(
                                           Handle,
                                           &IoStatusBlock,
                                           (PVOID) &FileTagInformation,
                                           sizeof(FileTagInformation),
                                           FileAttributeTagInformation
                                           );

            if ( !NT_SUCCESS( Status ) ) {

                //
                //  Not all File Systems implement all information classes.
                //  The value STATUS_INVALID_PARAMETER is returned when a non-supported
                //  information class is requested to a back-level File System. As all the
                //  parameters to NtQueryInformationFile are correct, we can infer that
                //  we found a back-level system.
                //
                //  If FileAttributeTagInformation is not implemented, we assume that
                //  the file at hand is not a reparse point.
                //

                if ( (Status != STATUS_NOT_IMPLEMENTED) &&
                     (Status != STATUS_INVALID_PARAMETER) ) {
                    BaseSetLastNTError( Status );
                    leave;
                }
            }

            if ( NT_SUCCESS(Status) &&
                 (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) &&
                 FileTagInformation.ReparseTag != IO_REPARSE_TAG_MOUNT_POINT ) {

                //
                //  Open without inhibiting the reparse behavior and not needing to
                //  read the attributes.
                //

                NtClose( Handle );
                Handle = INVALID_HANDLE_VALUE;

                Status = NtOpenFile(
                                   &Handle,
                                   DELETE | SYNCHRONIZE,
                                   &Obja,
                                   &IoStatusBlock,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   OpenFlags
                                   );

                if ( !NT_SUCCESS( Status ) ) {
                    BaseSetLastNTError( Status );
                    leave;
                }
            }
        }

        if (!(dwFlags & MOVEFILE_DELAY_UNTIL_REBOOT) ||
            (lpNewFileName != NULL)) {
            TranslationStatus = RtlDosPathNameToNtPathName_U(
                                                            lpNewFileName,
                                                            &NewFileName,
                                                            NULL,
                                                            NULL
                                                            );

            if ( !TranslationStatus ) {
                BaseSetLastNTError( STATUS_OBJECT_PATH_NOT_FOUND );
                leave;
            }

        } else {
            RtlInitUnicodeString( &NewFileName, NULL );
        }

        if (dwFlags & MOVEFILE_DELAY_UNTIL_REBOOT) {

            //
            // (typical stevewo hack, preserved for sentimental value)
            //
            // If ReplaceIfExists is TRUE, prepend an exclamation point
            // to the new filename in order to pass this bit of data
            // along to the session manager.
            //

            if (ReplaceIfExists && NewFileName.Length != 0) {
                PWSTR NewBuffer;

                NewBuffer = RtlAllocateHeap( RtlProcessHeap(),
                                             MAKE_TAG( TMP_TAG ),
                                             NewFileName.Length + sizeof(WCHAR) );
                if (NewBuffer == NULL) {
                    BaseSetLastNTError( STATUS_NO_MEMORY );
                    leave;
                }

                NewBuffer[0] = L'!';
                CopyMemory(&NewBuffer[1], NewFileName.Buffer, NewFileName.Length);
                NewFileName.Length += sizeof(WCHAR);
                NewFileName.MaximumLength += sizeof(WCHAR);
                RtlFreeHeap(RtlProcessHeap(), 0, NewFileName.Buffer);
                NewFileName.Buffer = NewBuffer;
            }

            //
            // Check to see if the existing file is on a remote share. If it
            // is, flag the error rather than let the operation silently fail
            // because the delayed operations are done before the net is
            // available. Rather than open the file and do a hard core file type,
            // we just check for UNC in the file name. This isn't perfect, but it is
            // pretty good. Chances are we can not open and manipulate the file. That is
            // why the caller is using the delay until reboot option !
            //

            if ( RtlDetermineDosPathNameType_U(lpExistingFileName) == RtlPathTypeUncAbsolute ) {
                Status = STATUS_INVALID_PARAMETER;
            }

            //
            // copy allowed is not permitted on delayed renames
            //

            else if ( dwFlags & MOVEFILE_COPY_ALLOWED ) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
	        Status = BasepMoveFileDelayed( &OldFileName,
					       &NewFileName,
					       2,
					       FALSE );
		if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
		    Status = BasepMoveFileDelayed( &OldFileName,
						   &NewFileName,
						   1,
						   TRUE );
		    if (Status == STATUS_INSUFFICIENT_RESOURCES) {
                        Status = BasepMoveFileDelayed( &OldFileName,
						       &NewFileName,
						       2,
						       TRUE );
		    }
		}
            }

            if (!NT_SUCCESS( Status )) {
                BaseSetLastNTError( Status );
                leave;
            }

            b = TRUE;
            leave;
        }

        //
        //  We must to the real move now.
        //

        NewName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), NewFileName.Length+sizeof(*NewName));

        if (NewName == NULL) {
            BaseSetLastNTError( STATUS_NO_MEMORY );
            leave;
        }

        RtlCopyMemory( NewName->FileName, NewFileName.Buffer, NewFileName.Length );

        NewName->ReplaceIfExists = ReplaceIfExists;
        NewName->RootDirectory = NULL;
        NewName->FileNameLength = NewFileName.Length;

        Status = NtSetInformationFile(
                    Handle,
                    &IoStatusBlock,
                    NewName,
                    NewFileName.Length+sizeof(*NewName),
                    (dwFlags & MOVEFILE_CREATE_HARDLINK) ?
                        FileLinkInformation :
                        FileRenameInformation
                    );

        RtlFreeHeap(RtlProcessHeap(), 0, NewName);

        if (NT_SUCCESS( Status )) {
            b = TRUE;
            leave;
        }

        if (Status != STATUS_NOT_SAME_DEVICE || (dwFlags & MOVEFILE_COPY_ALLOWED) == 0) {
            BaseSetLastNTError( Status );
            leave;
        }

        NtClose( Handle );
        Handle = INVALID_HANDLE_VALUE;

        //
        //  Perform a copy/delete.  Handle link tracking.
        //

        {
            HANDLE hSource = INVALID_HANDLE_VALUE;
            HANDLE hDest = INVALID_HANDLE_VALUE;

            Context.dwFlags = dwFlags;
            Context.lpProgressRoutine = lpProgressRoutine;
            Context.lpData = lpData;

            b = (BOOLEAN)BasepCopyFileExW(
                            lpExistingFileName,
                            lpNewFileName,
                            BasepMoveFileCopyProgress,
                            &Context,
                            NULL,
                            (ReplaceIfExists ? 0 : COPY_FILE_FAIL_IF_EXISTS) | COPY_FILE_OPEN_SOURCE_FOR_WRITE,
                            0, // PrivCopyFile flags
                            &hSource,
                            &hDest
                            );

            if ( b && hSource != INVALID_HANDLE_VALUE && hDest != INVALID_HANDLE_VALUE) {

                //
                // attempt to do tracking
                //

                Status = BasepNotifyTrackingService( &hSource,
                                                     &Obja,
                                                     hDest,
                                                     &NewFileName );


                if ( !NT_SUCCESS(Status) &&
                    (dwFlags & MOVEFILE_FAIL_IF_NOT_TRACKABLE)) {

                    if (hDest != INVALID_HANDLE_VALUE)
                        CloseHandle( hDest );

                    hDest = INVALID_HANDLE_VALUE;
                    DeleteFileW( lpNewFileName );
                    b = FALSE;

                    BaseSetLastNTError( Status );

                }
            }

            if (hSource != INVALID_HANDLE_VALUE) {
                CloseHandle(hSource);
                hSource = INVALID_HANDLE_VALUE;
            }

            if (hDest != INVALID_HANDLE_VALUE) {
                CloseHandle(hDest);
                hDest = INVALID_HANDLE_VALUE;
            }

            //
            // the copy worked... Delete the source of the rename
            // if it fails, try a set attributes and then a delete
            //

            if (b && !DeleteFileW( lpExistingFileName ) ) {

                //
                // If the delete fails, we will return true, but possibly
                // leave the source dangling
                //

                SetFileAttributesW(lpExistingFileName,FILE_ATTRIBUTE_NORMAL);
                DeleteFileW( lpExistingFileName );
            }
        }

    } finally {
        if (Handle != INVALID_HANDLE_VALUE) {
            NtClose( Handle );
        }
        RtlFreeHeap( RtlProcessHeap(), 0, OldFileName.Buffer );
        RtlFreeHeap( RtlProcessHeap(), 0, NewFileName.Buffer );
    }

    return b;
}


NTSTATUS
BasepMoveFileDelayed(
    IN PUNICODE_STRING OldFileName,
    IN PUNICODE_STRING NewFileName,
    IN ULONG Index,
    IN BOOL OkayToCreateNewValue
    )

/*++

Routine Description:

    Appends the given delayed move file operation to the registry
    value that contains the list of move file operations to be
    performed on the next boot.

Arguments:

    OldFileName - Supplies the old file name

    NewFileName - Supplies the new file name

Return Value:

    NTSTATUS

--*/

{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    HANDLE KeyHandle;
    PWSTR ValueData, s;
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo;
    ULONG ValueLength = 1024;
    ULONG ReturnedLength;
    WCHAR ValueNameBuf[64];
    NTSTATUS Status;


    RtlInitUnicodeString( &KeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager" );

    if (Index == 1) {
        RtlInitUnicodeString( &ValueName, L"PendingFileRenameOperations" );
    } else {
        swprintf(ValueNameBuf,L"PendingFileRenameOperations%d",Index);
        RtlInitUnicodeString( &ValueName, ValueNameBuf );
    }

    InitializeObjectAttributes(
        &Obja,
        &KeyName,
        OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtCreateKey( &KeyHandle,
                          GENERIC_READ | GENERIC_WRITE,
                          &Obja,
                          0,
                          NULL,
                          0,
                          NULL
                        );
    if ( Status == STATUS_ACCESS_DENIED ) {
        Status = NtCreateKey( &KeyHandle,
                              GENERIC_READ | GENERIC_WRITE,
                              &Obja,
                              0,
                              NULL,
                              REG_OPTION_BACKUP_RESTORE,
                              NULL
                            );
    }

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    while (TRUE) {
        ValueInfo = RtlAllocateHeap(RtlProcessHeap(),
                                    MAKE_TAG(TMP_TAG),
                                    ValueLength + OldFileName->Length + sizeof(WCHAR) +
                                                  NewFileName->Length + 2*sizeof(WCHAR));

        if (ValueInfo == NULL) {
            NtClose(KeyHandle);
            return(STATUS_NO_MEMORY);
        }

        //
        // File rename operations are stored in the registry in a
        // single MULTI_SZ value. This allows the renames to be
        // performed in the same order that they were originally
        // requested. Each rename operation consists of a pair of
        // NULL-terminated strings.
        //

        Status = NtQueryValueKey(KeyHandle,
                                 &ValueName,
                                 KeyValuePartialInformation,
                                 ValueInfo,
                                 ValueLength,
                                 &ReturnedLength);

        if (Status != STATUS_BUFFER_OVERFLOW) {
            break;
        }

        //
        // The existing value is too large for our buffer.
        // Retry with a larger buffer.
        //
        ValueLength = ReturnedLength;
        RtlFreeHeap(RtlProcessHeap(), 0, ValueInfo);
    }

    if ((Status == STATUS_OBJECT_NAME_NOT_FOUND)
	&& OkayToCreateNewValue) {
        //
        // The value does not currently exist. Create the
        // value with our data.
        //
        s = ValueData = (PWSTR)ValueInfo;
    } else if (NT_SUCCESS(Status)) {
        //
        // A value already exists, append our two strings to the
        // MULTI_SZ.
        //
        ValueData = (PWSTR)(&ValueInfo->Data);
        s = (PWSTR)((PCHAR)ValueData + ValueInfo->DataLength) - 1;
    } else {
        NtClose(KeyHandle);
        RtlFreeHeap(RtlProcessHeap(), 0, ValueInfo);
        return(Status);
    }

    CopyMemory(s, OldFileName->Buffer, OldFileName->Length);
    s += (OldFileName->Length/sizeof(WCHAR));
    *s++ = L'\0';

    CopyMemory(s, NewFileName->Buffer, NewFileName->Length);
    s += (NewFileName->Length/sizeof(WCHAR));
    *s++ = L'\0';
    *s++ = L'\0';

    Status = NtSetValueKey(KeyHandle,
                           &ValueName,
                           0,
                           REG_MULTI_SZ,
                           ValueData,
                           (ULONG)((s-ValueData)*sizeof(WCHAR)));
    NtClose(KeyHandle);
    RtlFreeHeap(RtlProcessHeap(), 0, ValueInfo);

    return(Status);
}




NTSTATUS
BasepOpenFileForMove( IN     LPCWSTR lpFileName,
                      OUT    PUNICODE_STRING FileName,
                      OUT    PVOID *FileNameFreeBuffer,
                      OUT    PHANDLE Handle,
                      OUT    POBJECT_ATTRIBUTES Obja,
                      IN     ULONG DesiredAccess,
                      IN     ULONG ShareAccess,
                      IN     ULONG OpenOptions )
/*++

Routine Description:

    Opens a file such that it may be used in MoveFile or MoveFileIdentity.

Arguments:

    lpFileName - the file to open

    FileName - lpFileName translated to an NT path

    FileNameFreeBuffer - a buffer which needs to be freed when FileName
        is no longer in use

    Handle - Location in which to put the handle for the opened file.

    Obja - Object attributes used to open the file

    DesiredAccess - Access flags which must be set, in addition to
        FILE_READ_ATTRIBUTES and SYNCHRONIZE which may also be set.

    ShareAccess - Sharing flags which must be set, though additional
        flags may also be set.

    OpenOptions - FILE_OPEN_ flags which must be set, though
        FILE_OPEN_REPARSE_POINT, FILE_SYNCHRONOUS_IO_NONALERT, and
        FILE_OPEN_FOR_BACKUP_INTENT may also be set.


Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOL ReleaseRelativeName = FALSE;

    try
    {

        FileName->Length = FileName->MaximumLength = 0;
        FileName->Buffer = NULL;
        *FileNameFreeBuffer = NULL;

        //
        //  Initialize the object attributes
        //

        TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                                lpFileName,
                                FileName,
                                NULL,
                                &RelativeName
                                );

        if ( !TranslationStatus ) {
            Status = STATUS_OBJECT_PATH_NOT_FOUND;
            leave;
        }
        ReleaseRelativeName = TRUE;
        *FileNameFreeBuffer = FileName->Buffer;


        if ( RelativeName.RelativeName.Length ) {
            *FileName = RelativeName.RelativeName;
        } else {
            RelativeName.ContainingDirectory = NULL;
        }

        InitializeObjectAttributes(
                                  Obja,
                                  FileName,
                                  OBJ_CASE_INSENSITIVE,
                                  RelativeName.ContainingDirectory,
                                  NULL
                                  );

        //
        //  Establish whether we are handling a symbolic link or not by:
        //      (1) obtaining a handle to the local entity, and
        //      (2) finding whether a symbolic link was found.
        //
        //  Open the file for delete access inhibiting the reparse
        //  point behavior.
        //

        OpenOptions |= (FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT);

        Status = NtOpenFile( Handle,
                             FILE_READ_ATTRIBUTES | SYNCHRONIZE | DesiredAccess,
                             Obja,
                             &IoStatusBlock,
                             FILE_SHARE_READ | FILE_SHARE_WRITE | ShareAccess,
                             FILE_OPEN_REPARSE_POINT | OpenOptions
                             );

        if (!NT_SUCCESS( Status )) {

            //
            //  Back level file systems may not support reparse points and thus not
            //  support symbolic links.
            //
            //  We infer this is the case when the Status is STATUS_INVALID_PARAMETER.
            //

            if ( Status == STATUS_INVALID_PARAMETER ) {

                //
                //  Retry the open without reparse behaviour.  This should be compatible
                //  with older file systems.
                //

                Status = NtOpenFile(
                                   Handle,
                                   SYNCHRONIZE | DesiredAccess,
                                   Obja,
                                   &IoStatusBlock,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE | ShareAccess,
                                   OpenOptions
                                   );
            }

            if ( !NT_SUCCESS( Status ) ) {

                leave;
            }

        } else {

            FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;

            //
            //  The open succeeded. If we do not find a symbolic link or a mount point,
            //  re-open without inhibiting the reparse behavior.
            //

            Status = NtQueryInformationFile(
                                           *Handle,
                                           &IoStatusBlock,
                                           (PVOID) &FileTagInformation,
                                           sizeof(FileTagInformation),
                                           FileAttributeTagInformation
                                           );

            if ( !NT_SUCCESS( Status ) ) {

                //
                //  Not all File Systems implement all information classes.
                //  The value STATUS_INVALID_PARAMETER is returned when a non-supported
                //  information class is requested to a back-level File System. As all the
                //  parameters to NtQueryInformationFile are correct, we can infer that
                //  we found a back-level system.
                //
                //  If FileAttributeTagInformation is not implemented, we assume that
                //  the file at hand is not a reparse point.
                //

                if ( (Status != STATUS_NOT_IMPLEMENTED) &&
                     (Status != STATUS_INVALID_PARAMETER) ) {

                    leave;
                }
            }

            if ( NT_SUCCESS(Status) &&
                 (FileTagInformation.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) &&
                 FileTagInformation.ReparseTag != IO_REPARSE_TAG_MOUNT_POINT ) {

                //
                //  Open without inhibiting the reparse behavior and not needing to
                //  read the attributes.
                //

                NtClose( *Handle );
                *Handle = INVALID_HANDLE_VALUE;

                Status = NtOpenFile(
                                   Handle,
                                   SYNCHRONIZE | DesiredAccess,
                                   Obja,
                                   &IoStatusBlock,
                                   FILE_SHARE_DELETE | FILE_SHARE_READ | ShareAccess,
                                   OpenOptions
                                   );

                if ( !NT_SUCCESS( Status ) ) {

                    leave;
                }
            }
        }
    }
    finally
    {
        if (ReleaseRelativeName) {
            RtlReleaseRelativeName(&RelativeName);
        }
    }

    return( Status );

}



BOOL
APIENTRY
PrivMoveFileIdentityW(
    LPCWSTR lpOldFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags
    )

/*++

Routine Description:

    Moves an identity from one file to another.  The identity is composed
    of the file's create date, and its object ID.  The Object ID isn't
    necessarily copied straight across; it's handled as if the actual
    file were being moved by MoveFileWithProgressW.

Arguments:

    lpOldFileName - Supplies the old file name

    lpNewFileName - Supplies the new file name

Return Value:

    TRUE if successful.  Otherwise the error can be found by calling GetLastError().

--*/

{   // MOVE_FILEIDentityW

    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS StatusIgnored = STATUS_SUCCESS;
    HANDLE SourceFile = INVALID_HANDLE_VALUE;
    HANDLE DestFile = INVALID_HANDLE_VALUE;
    UNICODE_STRING SourceFileName = { 0, 0, NULL };
    PVOID SourceFileNameFreeBuffer = NULL;
    UNICODE_STRING DestFileName = { 0, 0, NULL };
    PVOID DestFileNameFreeBuffer = NULL;
    BOOL TranslationStatus;
    OBJECT_ATTRIBUTES SourceObja;
    OBJECT_ATTRIBUTES DestObja;
    ULONG OpenFlags;
    FILE_DISPOSITION_INFORMATION DispositionInformation = { TRUE };
    IO_STATUS_BLOCK IoStatus;
    FILE_BASIC_INFORMATION SourceBasicInfo;
    FILE_BASIC_INFORMATION DestBasicInfo;
    DWORD SourceFileAccess;
    DWORD DestFileAccess;

    try {

        // Open the source file.  It must be opened for write or the
        // FileTrackingInformation call will fail.

        SourceFileAccess = FILE_WRITE_DATA | FILE_READ_ATTRIBUTES;
        if( dwFlags & PRIVMOVE_FILEID_DELETE_OLD_FILE ) {
            SourceFileAccess |= DELETE;
        }

        while( TRUE ) {

            Status = BasepOpenFileForMove( lpOldFileName,
                                           &SourceFileName,
                                           &SourceFileNameFreeBuffer,
                                           &SourceFile,
                                           &SourceObja,
                                           SourceFileAccess,
                                           FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                                           FILE_OPEN_NO_RECALL );
            if( NT_SUCCESS(Status) ) {
                break;
            } else {

                // We might be able to try again without requesting write access
                if( (SourceFileAccess & FILE_WRITE_DATA) &&
                    (dwFlags & PRIVMOVE_FILEID_IGNORE_ID_ERRORS) ) {

                    //
                    // BasepOpenFileForMove may return a buffer or handle even
                    // in a failure case
                    //
                    if( SourceFileNameFreeBuffer != NULL ) {
                        RtlFreeHeap( RtlProcessHeap(), 0, SourceFileNameFreeBuffer );
                        SourceFileNameFreeBuffer = NULL;
                    }

                    if( SourceFile != INVALID_HANDLE_VALUE ) {
                        NtClose( SourceFile );
                        SourceFile = INVALID_HANDLE_VALUE;
                    }

                    // Try again without write access
                    SourceFileAccess &= ~FILE_WRITE_DATA;

                    if( NT_SUCCESS(StatusIgnored) ) {
                        StatusIgnored = Status;
                    }
                    Status = STATUS_SUCCESS;
                } else {
                    // Nothing we can do.
                    break;
                }
            }
        }

        if( !NT_SUCCESS(Status) ) {
            leave;
        }

        // Open the destination file

        DestFileAccess = FILE_WRITE_ATTRIBUTES;
        if( SourceFileAccess & FILE_WRITE_DATA )
            DestFileAccess |= FILE_WRITE_DATA;

        while( TRUE ) {

            Status = BasepOpenFileForMove( lpNewFileName,
                                           &DestFileName,
                                           &DestFileNameFreeBuffer,
                                           &DestFile,
                                           &DestObja,
                                           (SourceFileAccess & FILE_WRITE_DATA)
                                                ? FILE_WRITE_ATTRIBUTES | FILE_WRITE_DATA
                                                : FILE_WRITE_ATTRIBUTES,
                                           FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ,
                                           FILE_OPEN_NO_RECALL );

            if( NT_SUCCESS(Status) ) {
                break;
            } else {

                // We might be able to try again without requesting write access
                if( (DestFileAccess & FILE_WRITE_DATA) &&
                    (dwFlags & PRIVMOVE_FILEID_IGNORE_ID_ERRORS) ) {

                    //
                    // BasepOpenFileForMove may return a buffer or handle even
                    // in a failure case
                    //
                    if( DestFileNameFreeBuffer != NULL ) {
                        RtlFreeHeap( RtlProcessHeap(), 0, DestFileNameFreeBuffer );
                        DestFileNameFreeBuffer = NULL;
                    }

                    if( DestFile != INVALID_HANDLE_VALUE ) {
                        NtClose( DestFile );
                        DestFile = INVALID_HANDLE_VALUE;
                    }

                    // Try again
                    DestFileAccess &= ~FILE_WRITE_DATA;

                    if( NT_SUCCESS(StatusIgnored) ) {
                        StatusIgnored = Status;
                    }
                    Status = STATUS_SUCCESS;

                } else {
                    // Nothing we can do.
                    break;
                }
            }
        }

        if( !NT_SUCCESS(Status) ) {
            leave;
        }

        // Copy the create date to the dest file

        Status = NtQueryInformationFile( SourceFile,
                                         &IoStatus,
                                         &SourceBasicInfo,
                                         sizeof(SourceBasicInfo),
                                         FileBasicInformation );
        if( NT_SUCCESS(Status) ) {

            RtlZeroMemory( &DestBasicInfo, sizeof(DestBasicInfo) );
            DestBasicInfo.CreationTime = SourceBasicInfo.CreationTime;

            Status = NtSetInformationFile( DestFile,
                                           &IoStatus,
                                           &DestBasicInfo,
                                           sizeof(DestBasicInfo),
                                           FileBasicInformation );
        }

        // If we had an error and can't ignore it, abort.
        if( !NT_SUCCESS(Status) ) {

            if( dwFlags & PRIVMOVE_FILEID_IGNORE_ID_ERRORS ) {
                if( NT_SUCCESS(StatusIgnored) ) {
                    StatusIgnored = Status;
                }
                Status = STATUS_SUCCESS;
            }
            else {
                leave;
            }
        }

        // Transfer the tracking information to the dest file, but only if we
        // were able to get write access to both files.

        if( (DestFileAccess & FILE_WRITE_DATA) &&
            (SourceFileAccess & FILE_WRITE_DATA) ) {

            Status = BasepNotifyTrackingService( &SourceFile,
                                                 &SourceObja,
                                                 DestFile,
                                                 &DestFileName );
            if( !NT_SUCCESS(Status) ) {
                if( dwFlags & PRIVMOVE_FILEID_IGNORE_ID_ERRORS ) {
                    if( NT_SUCCESS(StatusIgnored) ) {
                        StatusIgnored = Status;
                    }
                    Status = STATUS_SUCCESS;
                }
                else {
                    leave;
                }
            }
        }

    }
    finally
    {
        if( SourceFileNameFreeBuffer != NULL )
            RtlFreeHeap( RtlProcessHeap(), 0, SourceFileNameFreeBuffer );

        if( DestFileNameFreeBuffer != NULL )
            RtlFreeHeap( RtlProcessHeap(), 0, DestFileNameFreeBuffer );

    }

    // If requested, delete the source file.  DispositionInformation.DeleteFile
    // has already been initialized to TRUE.

    if( NT_SUCCESS(Status) && (dwFlags & PRIVMOVE_FILEID_DELETE_OLD_FILE) ) {

        Status = NtSetInformationFile(
            SourceFile,
            &IoStatus,
            &DispositionInformation,
            sizeof(DispositionInformation),
            FileDispositionInformation
            );
    }

    if( DestFile != INVALID_HANDLE_VALUE )
        NtClose( DestFile );

    if( SourceFile != INVALID_HANDLE_VALUE )
        NtClose( SourceFile );

    if( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
    }
    else if( !NT_SUCCESS(StatusIgnored) ) {
        BaseSetLastNTError(StatusIgnored);
    }

    return( NT_SUCCESS(Status) );

}





DWORD
WINAPI
GetCompressedFileSizeA(
    LPCSTR lpFileName,
    LPDWORD lpFileSizeHigh
    )
{

    PUNICODE_STRING Unicode;

    Unicode = Basep8BitStringToStaticUnicodeString( lpFileName );
    if (Unicode == NULL) {
        return (DWORD)-1;
    }

    return ( GetCompressedFileSizeW((LPCWSTR)Unicode->Buffer,lpFileSizeHigh) );
}

DWORD
WINAPI
GetCompressedFileSizeW(
    LPCWSTR lpFileName,
    LPDWORD lpFileSizeHigh
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_COMPRESSION_INFORMATION CompressionInfo;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;
    DWORD FileSizeLow;

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return (DWORD)-1;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_OPEN_FOR_BACKUP_INTENT
                );
    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return (DWORD)-1;
        }

    //
    // Get the compressed file size.
    //

    Status = NtQueryInformationFile(
                Handle,
                &IoStatusBlock,
                &CompressionInfo,
                sizeof(CompressionInfo),
                FileCompressionInformation
                );

    if ( !NT_SUCCESS(Status) ) {
        FileSizeLow = GetFileSize(Handle,lpFileSizeHigh);
        NtClose(Handle);
        return FileSizeLow;
        }


    NtClose(Handle);
    if ( ARGUMENT_PRESENT(lpFileSizeHigh) ) {
        *lpFileSizeHigh = (DWORD)CompressionInfo.CompressedFileSize.HighPart;
        }
    if (CompressionInfo.CompressedFileSize.LowPart == -1 ) {
        SetLastError(0);
        }
    return CompressionInfo.CompressedFileSize.LowPart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\globcs.c ===
#include <stdio.h>
#include <windows.h>


//
// Global Critical Sections have two components. One piece is shared between all
// applications using the global lock. This portion will typically reside in some
// sort of shared memory
//
// The second piece is per-process. This contains a per-process handle to the shared
// critical section lock semaphore. The semaphore is itself shared, but each process
// may have a different handle value to the semaphore.
//
// Global critical sections are attached to by name. The application wishing to
// attach must know the name of the critical section (actually the name of the shared
// lock semaphore, and must know the address of the global portion of the critical
// section
//

typedef struct _GLOBAL_SHARED_CRITICAL_SECTION {
    LONG LockCount;
    LONG RecursionCount;
    DWORD OwningThread;
    DWORD Reserved;
} GLOBAL_SHARED_CRITICAL_SECTION, *PGLOBAL_SHARED_CRITICAL_SECTION;

typedef struct _GLOBAL_LOCAL_CRITICAL_SECTION {
    PGLOBAL_SHARED_CRITICAL_SECTION GlobalPortion;
    HANDLE LockSemaphore;
    DWORD Reserved1;
    DWORD Reserved2;
} GLOBAL_LOCAL_CRITICAL_SECTION, *PGLOBAL_LOCAL_CRITICAL_SECTION;


BOOL
WINAPI
AttachToGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion,
    PGLOBAL_SHARED_CRITICAL_SECTION lpGlobalPortion,
    LPCSTR lpName
    )

/*++

Routine Description:

    This routine attaches to an existing global critical section, or creates and
    initializes the global critical section if it does not already exist.

Arguments:

    lpLocalPortion - Supplies the address of a per-app local portion of the global
        critical section.

    lpGlobalPortion - Supplies the address of the global shared portion of the
        critical section. If the critical section is new, the caller will initialize it.

    lpName - Supplies the name of the critical section.  If an existing
        critical section with this name already exists, then it is not
        reinitialized.  In this case, the caller simply attaches to it.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.

--*/

{

    HANDLE GlobalMutex;
    HANDLE LockSemaphore;
    BOOL rv;
    DWORD WaitResult;

    //
    // Serialize all global critical section initialization
    //

    GlobalMutex = CreateMutex(NULL,TRUE,"GlobalCsMutex");

    //
    // If the mutex create/open failed, then bail
    //

    if ( !GlobalMutex ) {
        return FALSE;
        }

    if ( GetLastError() == ERROR_ALREADY_EXISTS ) {

        //
        // Since the mutex already existed, the request for ownership has no effect.
        // wait for the mutex
        //

        WaitResult = WaitForSingleObject(GlobalMutex,INFINITE);
        if ( WaitResult == WAIT_FAILED ) {
            CloseHandle(GlobalMutex);
            return FALSE;
            }
        }

    //
    // We now own the global critical section creation mutex. Create/Open the
    // named semaphore. If we are the creator, then initialize the critical
    // section. Otherwise just point to it. The global critical section creation
    // allows us to do this safely.
    //

    rv = FALSE;
    LockSemaphore = NULL;
    try {
        LockSemaphore = CreateSemaphore(NULL,0,MAXLONG-1,lpName);

        //
        // If the semaphore create/open failed, then bail
        //

        if ( !GlobalMutex ) {
            rv = FALSE;
            goto finallyexit;
            }

        //
        // See if we attached to the semaphore, or if we created it. If we created it,
        // then we need to init the global structure.
        //

        if ( GetLastError() != ERROR_ALREADY_EXISTS ) {

            //
            // We Created the semaphore, so init the global portion.
            //

            lpGlobalPortion->LockCount = -1;
            lpGlobalPortion->RecursionCount = 0;
            lpGlobalPortion->OwningThread = 0;
            lpGlobalPortion->Reserved = 0;
            }

        lpLocalPortion->LockSemaphore = LockSemaphore;
        LockSemaphore = NULL;
        lpLocalPortion->GlobalPortion = lpGlobalPortion;
        lpLocalPortion->Reserved1 = 0;
        lpLocalPortion->Reserved2 = 0;
        rv = TRUE;
finallyexit:;
        }
    finally {
        ReleaseMutex(GlobalMutex);
        CloseHandle(GlobalMutex);
        if ( LockSemaphore ) {
            CloseHandle(LockSemaphore);
            }
        }

    return rv;
}

BOOL
WINAPI
DetachFromGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion
    )

/*++

Routine Description:

    This routine detaches from an existing global critical section.

Arguments:

    lpLocalPortion - Supplies the address of a per-app local portion of the global
        critical section.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.

--*/

{

    HANDLE LockSemaphore;
    HANDLE GlobalMutex;
    DWORD WaitResult;
    BOOL rv;


    //
    // Serialize all global critical section initialization
    //

    GlobalMutex = CreateMutex(NULL,TRUE,"GlobalCsMutex");

    //
    // If the mutex create/open failed, then bail
    //

    if ( !GlobalMutex ) {
        return FALSE;
        }

    if ( GetLastError() == ERROR_ALREADY_EXISTS ) {

        //
        // Since the mutex already existed, the request for ownership has no effect.
        // wait for the mutex
        //

        WaitResult = WaitForSingleObject(GlobalMutex,INFINITE);
        if ( WaitResult == WAIT_FAILED ) {
            CloseHandle(GlobalMutex);
            return FALSE;
            }
        }
    LockSemaphore = NULL;
    rv = FALSE;
    try {
        LockSemaphore = lpLocalPortion->LockSemaphore;
        ZeroMemory(lpLocalPortion,sizeof(*lpLocalPortion));
        rv = TRUE;
        }
    finally {
        if ( LockSemaphore ) {
            CloseHandle(LockSemaphore);
            }
        ReleaseMutex(GlobalMutex);
        CloseHandle(GlobalMutex);
        }
    return rv;
}

VOID
WINAPI
EnterGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion
    )
{
    PGLOBAL_SHARED_CRITICAL_SECTION GlobalPortion;
    DWORD ThreadId;
    LONG IncResult;
    DWORD WaitResult;

    ThreadId = GetCurrentThreadId();
    GlobalPortion = lpLocalPortion->GlobalPortion;

    //
    // Increment the lock variable. On the transition to 0, the caller
    // becomes the absolute owner of the lock. Otherwise, the caller is
    // either recursing, or is going to have to wait
    //

    IncResult = InterlockedIncrement(&GlobalPortion->LockCount);
    if ( !IncResult ) {

        //
        // lock count went from 0 to 1, so the caller
        // is the owner of the lock
        //

        GlobalPortion->RecursionCount = 1;
        GlobalPortion->OwningThread = ThreadId;
        }
    else {

        //
        // If the caller is recursing, then increment the recursion count
        //

        if ( GlobalPortion->OwningThread == ThreadId ) {
            GlobalPortion->RecursionCount++;
            }
        else {
            WaitResult = WaitForSingleObject(lpLocalPortion->LockSemaphore,INFINITE);
            if ( WaitResult == WAIT_FAILED ) {
                RaiseException(GetLastError(),0,0,NULL);
                }
            GlobalPortion->RecursionCount = 1;
            GlobalPortion->OwningThread = ThreadId;
            }
        }
}

VOID
WINAPI
LeaveGlobalCriticalSection(
    PGLOBAL_LOCAL_CRITICAL_SECTION lpLocalPortion
    )
{
    PGLOBAL_SHARED_CRITICAL_SECTION GlobalPortion;
    LONG DecResult;

    GlobalPortion = lpLocalPortion->GlobalPortion;


    //
    // decrement the recursion count. If it is still non-zero, then
    // we are still the owner so don't do anything other than dec the lock
    // count
    //

    if (--GlobalPortion->RecursionCount) {
        InterlockedDecrement(&GlobalPortion->LockCount);
        }
    else {

        //
        // We are really leaving, so give up ownership and decrement the
        // lock count
        //

        GlobalPortion->OwningThread = 0;
        DecResult = InterlockedDecrement(&GlobalPortion->LockCount);

        //
        // Check to see if there are other waiters. If so, then wake up a waiter
        //

        if ( DecResult >= 0 ) {
            ReleaseSemaphore(lpLocalPortion->LockSemaphore,1,NULL);
            }

        }
}

GLOBAL_LOCAL_CRITICAL_SECTION LocalPortion;

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    HANDLE hFileMap;
    LPVOID SharedMem;
    BOOL b;
    int i;
    DWORD Start,End;
    HANDLE Mutex1;

    //
    // open or create a shared file mapping object
    //

    hFileMap = CreateFileMapping(INVALID_HANDLE_VALUE,NULL,PAGE_READWRITE,0,1024,"MyMem");

    if ( !hFileMap ) {
        printf("create file map failed\n");
        ExitProcess(1);
        }

    SharedMem = MapViewOfFile(hFileMap,FILE_MAP_WRITE,0,0,0);

    if ( !SharedMem ) {
        printf("map view failed\n");
        ExitProcess(1);
        }

    b = AttachToGlobalCriticalSection(&LocalPortion,SharedMem,"MyGlobalCs");

    if ( !b ) {
        printf("attach failed\n");
        ExitProcess(1);
        }

    if ( argc > 1 ) {

        for(i=0;i<30;i++){
            EnterGlobalCriticalSection(&LocalPortion);
            printf("Thread %x is in\n",GetCurrentThreadId());
            Sleep(500);
            LeaveGlobalCriticalSection(&LocalPortion);
            }
        }

    Start = GetTickCount();
    for(i=0;i<1000000;i++){
        EnterGlobalCriticalSection(&LocalPortion);
        LeaveGlobalCriticalSection(&LocalPortion);
        }
    End = GetTickCount();
    printf("Global CS Time %dms\n",End-Start);

    Mutex1 = CreateMutex(NULL,FALSE,NULL);
    Start = GetTickCount();
    for(i=0;i<100000;i++){
        WaitForSingleObject(Mutex1,INFINITE);
        ReleaseMutex(Mutex1);
        }
    End = GetTickCount();
    printf("Mutex Time     %dms\n",(End-Start)*10);

    DetachFromGlobalCriticalSection(&LocalPortion);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\firmware.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    firmware.c

Abstract:

    This module implements Win32 firmware access APIs

Author:

    Andrew Ritz (andrewr) 3-April-2001

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop


DWORD
WINAPI
GetFirmwareEnvironmentVariableA(
    IN LPCSTR lpName,
    IN LPCSTR lpGuid,
    OUT PVOID  pBuffer,
    IN DWORD nSize
    )

/*++

Routine Description:

    The value of a firmware environment variable may be retrieved by using
    this API.
    
    This API is just a wrapper for NtQuerySystemEnvironmentValueEx.  It's 
    purpose is to provide a backwards compatible, documented interface into
    the Nt inteface.  By having this wrapper, we do not have to document the
    Nt interface, and we have the freedom to change the NT interface in the 
    future.

Arguments:

    lpName - Pointer to a null terminate string that is the name of the
        firmware environment variable whose value is being requested.
        
    lpGuid - Pointer to a null terminate string that is the GUID namespace of
       the firmware environment variable whose value is being requested.  On
       platforms that do not have a GUID based namespace, this value will be
       ignored.

    pBuffer - Pointer to a buffer that is to receive the value of the
        specified variable name.

    nSize - Specifies the maximum number of bytes that can be stored in
        the buffer pointed to by pBuffer.

Return Value:

    The actual number of bytes stored in the memory pointed to by the
    pBuffer parameter.  The return value is zero if the variable name was not
    found in the firmware or if another failure occurred (Call GetLastError() 
    to get extended error information.)
    
--*/

{
    NTSTATUS Status;
    STRING Name,Guid;
    UNICODE_STRING UnicodeName,UnicodeGuid;
    DWORD RetVal;
    

    RtlInitString( &Name, lpName );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &Name, TRUE );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return ( 0 );
    }

    RtlInitString( &Guid, lpGuid );
    Status = RtlAnsiStringToUnicodeString( &UnicodeGuid, &Guid, TRUE );
    if (!NT_SUCCESS( Status )) {
        RtlFreeUnicodeString(&UnicodeName);
        BaseSetLastNTError( Status );
        return ( 0 );
    }

    RetVal = GetFirmwareEnvironmentVariableW( 
                                    UnicodeName.Buffer,
                                    UnicodeGuid.Buffer,
                                    pBuffer,
                                    nSize );
        
    RtlFreeUnicodeString(&UnicodeName);
    RtlFreeUnicodeString(&UnicodeGuid);

    return( RetVal );
    
}


DWORD
WINAPI
GetFirmwareEnvironmentVariableW(
    IN LPCWSTR lpName,
    IN LPCWSTR lpGuid,
    OUT PVOID  pBuffer,
    IN DWORD nSize
    )
/*++

Routine Description:

    The value of a firmware environment variable may be retrieved by using
    this API.
    
    This API is just a wrapper for NtQuerySystemEnvironmentValueEx.  It's 
    purpose is to provide a backwards compatible, documented interface into
    the Nt inteface.  By having this wrapper, we do not have to document the
    Nt interface, and we have the freedom to change the NT interface in the 
    future.

Arguments:

    lpName - Pointer to a null terminate string that is the name of the
        firmware environment variable whose value is being requested.
        
    lpGuid - Pointer to a null terminate string that is the GUID namespace of
       the firmware environment variable whose value is being requested.  On
       platforms that do not have a GUID based namespace, this value will be
       ignored.

    pBuffer - Pointer to a buffer that is to receive the value of the
        specified variable name.

    nSize - Specifies the maximum number of bytes that can be stored in
        the buffer pointed to by pBuffer.

Return Value:

    The actual number of bytes stored in the memory pointed to by the
    pBuffer parameter.  The return value is zero if the variable name was not
    found in the firmware or if another failure occurred (Call GetLastError() 
    to get extended error information.)
    
--*/
{
    UNICODE_STRING uStringName,GuidString;
    GUID  Guid;
    NTSTATUS Status;
    DWORD scratchSize;

    if (!lpName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    RtlInitUnicodeString(&uStringName, lpName);
    RtlInitUnicodeString(&GuidString, lpGuid);

    Status = RtlGUIDFromString(&GuidString, &Guid);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return 0;
    }
    
    scratchSize = nSize;
    Status = NtQuerySystemEnvironmentValueEx(
                                &uStringName,
                                &Guid,
                                pBuffer,
                                &scratchSize,
                                NULL); //bugbug need to give caller the attributes?

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return 0;
    }

    return scratchSize;

}


BOOL
WINAPI
SetFirmwareEnvironmentVariableA(
    IN LPCSTR lpName,
    IN LPCSTR lpGuid,
    IN PVOID  pBuffer,
    IN DWORD nSize
    )

/*++

Routine Description:

    The value of a firmware environment variable may be set by using
    this API.
    
    This API is just a wrapper for NtSetSystemEnvironmentValueEx.  It's 
    purpose is to provide a backwards compatible, documented interface into
    the Nt inteface.  By having this wrapper, we do not have to document the
    Nt interface, and we have the freedom to change the NT interface in the 
    future.

Arguments:

    lpName - Pointer to a null terminate string that is the name of the
        firmware environment variable whose value is being requested.
        
    lpGuid - Pointer to a null terminate string that is the GUID namespace of
       the firmware environment variable whose value is being requested.  On
       platforms that do not have a GUID based namespace, this value will be
       ignored.

    pBuffer - Pointer to a buffer that contains the data for the specified
       variable name.

    nSize - Specifies the number of bytes that are stored in
        the buffer pointed to by pBuffer.  Specifying 0 indicates that the 
        caller wants the deleted.

Return Value:

    TRUE indicates that the value was successfully set.  The return value is 
    FALSE if the variable name was not set. (Call GetLastError() to get 
    extended error information.)
    
--*/
{
    NTSTATUS Status;
    STRING Name,Guid;
    UNICODE_STRING UnicodeName,UnicodeGuid;
    BOOL RetVal;
    

    RtlInitString( &Name, lpName );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &Name, TRUE );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return(FALSE);
    }

    RtlInitString( &Guid, lpGuid );
    Status = RtlAnsiStringToUnicodeString( &UnicodeGuid, &Guid, TRUE );
    if (!NT_SUCCESS( Status )) {
        RtlFreeUnicodeString(&UnicodeName);
        BaseSetLastNTError( Status );
        return(FALSE);
    }

    RetVal = SetFirmwareEnvironmentVariableW( 
                                    UnicodeName.Buffer,
                                    UnicodeGuid.Buffer,
                                    pBuffer,
                                    nSize );
        
    RtlFreeUnicodeString(&UnicodeName);
    RtlFreeUnicodeString(&UnicodeGuid);

    return( RetVal );
    
}



BOOL
WINAPI
SetFirmwareEnvironmentVariableW(
    IN LPCWSTR lpName,
    IN LPCWSTR lpGuid,
    IN PVOID  pBuffer,
    IN DWORD nSize
    )
/*++

Routine Description:

    The value of a firmware environment variable may be set by using
    this API.
    
    This API is just a wrapper for NtSetSystemEnvironmentValueEx.  It's 
    purpose is to provide a backwards compatible, documented interface into
    the Nt inteface.  By having this wrapper, we do not have to document the
    Nt interface, and we have the freedom to change the NT interface in the 
    future.

Arguments:

    lpName - Pointer to a null terminate string that is the name of the
        firmware environment variable whose value is being requested.
        
    lpGuid - Pointer to a null terminate string that is the GUID namespace of
       the firmware environment variable whose value is being requested.  On
       platforms that do not have a GUID based namespace, this value will be
       ignored.

    pBuffer - Pointer to a buffer that contains the data for the specified
       variable name.

    nSize - Specifies the number of bytes that are stored in
        the buffer pointed to by pBuffer.  Specifying 0 indicates that the 
        caller wants the deleted.

Return Value:

    TRUE indicates that the value was successfully set.  The return value is 
    FALSE if the variable name was not set. (Call GetLastError() to get 
    extended error information.)
    
--*/
{
    UNICODE_STRING uStringName,GuidString;
    GUID  Guid;
    NTSTATUS Status;

    if (!lpName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    RtlInitUnicodeString(&uStringName, lpName);
    RtlInitUnicodeString(&GuidString, lpGuid);

    Status = RtlGUIDFromString(&GuidString, &Guid);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return(FALSE);
    }
    
    Status = NtSetSystemEnvironmentValueEx(
                                &uStringName,
                                &Guid,
                                pBuffer,
                                nSize,
                                VARIABLE_ATTRIBUTE_NON_VOLATILE); //bugbug need to give caller the ability to set attributes?

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return(FALSE);
    }

    return( TRUE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\gmem.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    gmem.c

Abstract:

    This module contains the Win32 Global Memory Management APIs

Author:

    Steve Wood (stevewo) 24-Sep-1990

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop

#include "winuserp.h"
#include "wowuserp.h"
#include <wow64t.h>

PFNWOWGLOBALFREEHOOK pfnWowGlobalFreeHook = NULL;

VOID
WINAPI
RegisterWowBaseHandlers(
    PFNWOWGLOBALFREEHOOK pfn
    )
{
    pfnWowGlobalFreeHook = pfn;
}


#if i386
#pragma optimize("y",off)
#endif

HGLOBAL
WINAPI
GlobalAlloc(
    UINT uFlags,
    SIZE_T dwBytes
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    HANDLE hMem;
    LPSTR p;
    ULONG Flags;

    if (uFlags & ~GMEM_VALID_FLAGS) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
        }

    Flags = 0;
    if (uFlags & GMEM_ZEROINIT) {
        Flags |= HEAP_ZERO_MEMORY;
        }

    if (!(uFlags & GMEM_MOVEABLE)) {
        if (uFlags & GMEM_DDESHARE) {
            Flags |= BASE_HEAP_FLAG_DDESHARE;
            }

        p = RtlAllocateHeap( BaseHeap,
                             MAKE_TAG( GMEM_TAG ) | Flags,
                             dwBytes ? dwBytes : 1
                           );

        if (p == NULL) {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            }

        return p;
        }

    p = NULL;
    RtlLockHeap( BaseHeap );
    Flags |= HEAP_NO_SERIALIZE | HEAP_SETTABLE_USER_VALUE | BASE_HEAP_FLAG_MOVEABLE;
    try {
        HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)RtlAllocateHandle( &BaseHeapHandleTable, NULL );
        if (HandleEntry == NULL) {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            goto Fail;
            }

        hMem = (HANDLE)&HandleEntry->Object;
        if (dwBytes != 0) {
            p = (LPSTR)RtlAllocateHeap( BaseHeap, MAKE_TAG( GMEM_TAG ) | Flags, dwBytes );
            if (p == NULL) {
                HandleEntry->Flags = RTL_HANDLE_ALLOCATED;
                RtlFreeHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry );
                HandleEntry = NULL;
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                }
            else {
                RtlSetUserValueHeap( BaseHeap, HEAP_NO_SERIALIZE, p, hMem );
                }
            }
Fail:   ;
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    if (HandleEntry != NULL) {
        HandleEntry->Object = p;
        if (p != NULL) {
            HandleEntry->Flags = RTL_HANDLE_ALLOCATED;
            }
        else {
            HandleEntry->Flags = RTL_HANDLE_ALLOCATED | BASE_HANDLE_DISCARDED;
            }

        if (uFlags & GMEM_DISCARDABLE) {
            HandleEntry->Flags |= BASE_HANDLE_DISCARDABLE;
            }

        if (uFlags & GMEM_MOVEABLE) {
            HandleEntry->Flags |= BASE_HANDLE_MOVEABLE;
            }

        if (uFlags & GMEM_DDESHARE) {
            HandleEntry->Flags |= BASE_HANDLE_SHARED;
            }

        p = (LPSTR)hMem;
        }

    return( (HANDLE)p );
}


HGLOBAL
WINAPI
GlobalReAlloc(
    HANDLE hMem,
    SIZE_T dwBytes,
    UINT uFlags
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    HANDLE Handle;
    LPSTR p;
    ULONG Flags;

    if ((uFlags & ~(GMEM_VALID_FLAGS | GMEM_MODIFY)) ||
        ((uFlags & GMEM_DISCARDABLE) && !(uFlags & GMEM_MODIFY))
       ) {
#if DBG
        DbgPrint( "*** GlobalReAlloc( %lx ) - invalid flags\n", uFlags );
        BaseHeapBreakPoint();
#endif
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
        }

    Flags = 0;
    if (uFlags & GMEM_ZEROINIT) {
        Flags |= HEAP_ZERO_MEMORY;
        }
    if (!(uFlags & GMEM_MOVEABLE)) {
        Flags |= HEAP_REALLOC_IN_PLACE_ONLY;
        }

    RtlLockHeap( BaseHeap );
    Flags |= HEAP_NO_SERIALIZE;
    try {
        if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (!RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
#if DBG
                DbgPrint( "*** GlobalReAlloc( %lx ) - invalid handle\n", hMem );
                BaseHeapBreakPoint();
#endif
                SetLastError( ERROR_INVALID_HANDLE );
                hMem = NULL;
                }
            else
            if (uFlags & GMEM_MODIFY) {
                if (uFlags & GMEM_DISCARDABLE) {
                    HandleEntry->Flags |= BASE_HANDLE_DISCARDABLE;
                    }
                else {
                    HandleEntry->Flags &= ~BASE_HANDLE_DISCARDABLE;
                    }
                }
            else {
                p = HandleEntry->Object;
                if (dwBytes == 0) {
                    hMem = NULL;
                    if (p != NULL) {
                        if ((uFlags & GMEM_MOVEABLE) && HandleEntry->LockCount == 0) {
                            if (RtlFreeHeap( BaseHeap, Flags, p )) {
                                HandleEntry->Object = NULL;
                                HandleEntry->Flags |= BASE_HANDLE_DISCARDED;
                                hMem = (HANDLE)&HandleEntry->Object;
                                }
                            }
                        else {
#if DBG
                            DbgPrint( "*** GlobalReAlloc( %lx ) - failing with locked handle\n", &HandleEntry->Object );
                            BaseHeapBreakPoint();
#endif
                            }
                        }
                    else {
                        hMem = (HANDLE)&HandleEntry->Object;
                        }
                    }
                else {
                    Flags |= HEAP_SETTABLE_USER_VALUE | BASE_HEAP_FLAG_MOVEABLE;
                    if (p == NULL) {
                        p = RtlAllocateHeap( BaseHeap, MAKE_TAG( GMEM_TAG ) | Flags, dwBytes );
                        if (p != NULL) {
                            RtlSetUserValueHeap( BaseHeap, HEAP_NO_SERIALIZE, p, hMem );
                            }
                        }
                    else {
                        if (!(uFlags & GMEM_MOVEABLE) &&
                            HandleEntry->LockCount != 0
                           ) {
                            Flags |= HEAP_REALLOC_IN_PLACE_ONLY;
                            }
                        else {
                            Flags &= ~HEAP_REALLOC_IN_PLACE_ONLY;
                            }

#pragma prefast(suppress: 308, "Realloc is allowed to lose this pointer")
                        p = RtlReAllocateHeap( BaseHeap, MAKE_TAG( GMEM_TAG ) | Flags, p, dwBytes );
                        }

                    if (p != NULL) {
                        HandleEntry->Object = p;
                        HandleEntry->Flags &= ~BASE_HANDLE_DISCARDED;
                        }
                    else {
                        hMem = NULL;
                        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                        }
                    }
                }
            }
        else
        if (uFlags & GMEM_MODIFY) {
            if (uFlags & GMEM_MOVEABLE) {
                Handle = hMem;
                if (RtlGetUserInfoHeap( BaseHeap, HEAP_NO_SERIALIZE, (PVOID)hMem, &Handle, NULL )) {
                    if (Handle == hMem || !(Flags & BASE_HEAP_FLAG_MOVEABLE)) {
                        HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)RtlAllocateHandle( &BaseHeapHandleTable,
                                                                                   NULL
                                                                                 );
                        if (HandleEntry == NULL) {
                            hMem = NULL;
                            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                            }
                        else {
                            dwBytes = RtlSizeHeap( BaseHeap, HEAP_NO_SERIALIZE, hMem );
                            Flags |= HEAP_SETTABLE_USER_VALUE | BASE_HEAP_FLAG_MOVEABLE;
                            HandleEntry->Object = (PVOID)RtlAllocateHeap( BaseHeap,
                                                                            MAKE_TAG( GMEM_TAG ) | Flags,
                                                                            dwBytes
                                                                          );
                            if (HandleEntry->Object == NULL) {
                                HandleEntry->Flags = RTL_HANDLE_ALLOCATED;
                                RtlFreeHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry );
                                hMem = NULL;
                                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                                }
                            else {
                                RtlMoveMemory( HandleEntry->Object, hMem, dwBytes );
                                RtlFreeHeap( BaseHeap, HEAP_NO_SERIALIZE, hMem );
                                hMem = (HANDLE)&HandleEntry->Object;
                                HandleEntry->LockCount = 0;
                                HandleEntry->Flags = RTL_HANDLE_ALLOCATED | BASE_HANDLE_MOVEABLE;
                                if (uFlags & GMEM_DISCARDABLE) {
                                    HandleEntry->Flags |= BASE_HANDLE_DISCARDABLE;
                                    }

                                if ((ULONG_PTR)Handle & GMEM_DDESHARE) {
                                    HandleEntry->Flags |= BASE_HANDLE_SHARED;
                                    }

                                RtlSetUserValueHeap( BaseHeap,
                                                     HEAP_NO_SERIALIZE,
                                                     HandleEntry->Object,
                                                     hMem
                                                   );
                                }
                            }
                        }
                    }
                }
            }
        else {
#pragma prefast(suppress: 308, "Realloc is allowed to lose this pointer")
            hMem = RtlReAllocateHeap( BaseHeap,
                                      MAKE_TAG( GMEM_TAG ) | Flags | HEAP_NO_SERIALIZE,
                                      (PVOID)hMem,
                                      dwBytes
                                    );
            if (hMem == NULL) {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        hMem = NULL;
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    return( (LPSTR)hMem );
}

LPVOID
WINAPI
GlobalLock(
    HGLOBAL hMem
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    LPSTR p;

    if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
        RtlLockHeap( BaseHeap );
        try {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (!RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
#if DBG
                DbgPrint( "*** GlobalLock( %lx ) - invalid handle\n", hMem );
                BaseHeapBreakPoint();
#endif
                SetLastError( ERROR_INVALID_HANDLE );
                p = NULL;
                }
            else {
                p = HandleEntry->Object;
                if (p != NULL) {
                    if (HandleEntry->LockCount++ == GMEM_LOCKCOUNT) {
                        HandleEntry->LockCount--;
                        }
                    }
                else {
                    SetLastError( ERROR_DISCARDED );
                    }
                }

            }
        except (EXCEPTION_EXECUTE_HANDLER) {
            p = NULL;
            BaseSetLastNTError( GetExceptionCode() );
            }

        RtlUnlockHeap( BaseHeap );

        return( p );
        }
    else {
        if ( (ULONG_PTR)hMem >= SystemRangeStart ) {
            SetLastError( ERROR_INVALID_HANDLE );
            return NULL;
            }
        if (IsBadReadPtr( hMem, 1 )) {
            SetLastError( ERROR_INVALID_HANDLE );
            return NULL;
            }

        return( (LPSTR)hMem );
        }
}


HANDLE
WINAPI
GlobalHandle(
    LPCVOID pMem
    )
{
    HANDLE Handle;
    ULONG Flags;

    RtlLockHeap( BaseHeap );
    try {
        Handle = NULL;
        if (!RtlGetUserInfoHeap( BaseHeap, HEAP_NO_SERIALIZE, (LPVOID)pMem, &Handle, &Flags )) {
            SetLastError( ERROR_INVALID_HANDLE );
            }
        else
        if (Handle == NULL || !(Flags & BASE_HEAP_FLAG_MOVEABLE)) {
            Handle = (HANDLE)pMem;
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    return( Handle );
}


BOOL
WINAPI
GlobalUnlock(
    HANDLE hMem
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    BOOL Result;

    Result = TRUE;
    if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
        RtlLockHeap( BaseHeap );
        try {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (!RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
#if DBG
                PVOID ImageBase;

                //
                // If passed address is NOT part of an image file, then display
                // a debug message.  This prevents apps that call GlobalUnlock
                // with the return value of LockResource from displaying the
                // message.
                //

                if (!RtlPcToFileHeader( (PVOID)hMem, &ImageBase)) {
                    DbgPrint( "*** GlobalUnlock( %lx ) - invalid handle\n", hMem );
                    BaseHeapBreakPoint();
                    }
#endif

                SetLastError( ERROR_INVALID_HANDLE );
                }
            else
            if (HandleEntry->LockCount-- == 0) {
                HandleEntry->LockCount++;
                SetLastError( ERROR_NOT_LOCKED );
                Result = FALSE;
                }
            else
            if (HandleEntry->LockCount == 0) {
                SetLastError( NO_ERROR );
                Result = FALSE;
                }
            }
        except (EXCEPTION_EXECUTE_HANDLER) {
            BaseSetLastNTError( GetExceptionCode() );
            }

        RtlUnlockHeap( BaseHeap );
        }

    return( Result );
}


SIZE_T
WINAPI
GlobalSize(
    HANDLE hMem
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    PVOID Handle;
    ULONG Flags;
    SIZE_T dwSize;

    dwSize = MAXULONG_PTR;
    Flags = 0;
    RtlLockHeap( BaseHeap );
    try {
        if (!((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT)) {
            Handle = NULL;
            if (!RtlGetUserInfoHeap( BaseHeap, Flags, hMem, &Handle, &Flags )) {
                }
            else
            if (Handle == NULL || !(Flags & BASE_HEAP_FLAG_MOVEABLE)) {
                dwSize = RtlSizeHeap( BaseHeap, HEAP_NO_SERIALIZE, (PVOID)hMem );
                }
            else {
                hMem = Handle;
                }
            }

        if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (!RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
#if DBG
                DbgPrint( "*** GlobalSize( %lx ) - invalid handle\n", hMem );
                BaseHeapBreakPoint();
#endif
                SetLastError( ERROR_INVALID_HANDLE );
                }
            else
            if (HandleEntry->Flags & BASE_HANDLE_DISCARDED) {
                dwSize = HandleEntry->Size;
                }
            else {
                dwSize = RtlSizeHeap( BaseHeap, HEAP_NO_SERIALIZE, HandleEntry->Object );
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    if (dwSize == MAXULONG_PTR) {
        SetLastError( ERROR_INVALID_HANDLE );
        return 0;
        }
    else {
        return dwSize;
        }
}

UINT
WINAPI
GlobalFlags(
    HANDLE hMem
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    HANDLE Handle;
    ULONG Flags;
    UINT uFlags;

    uFlags = GMEM_INVALID_HANDLE;
    RtlLockHeap( BaseHeap );
    try {
        if (!((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT)) {
            Handle = NULL;
            Flags = 0;
            if (!RtlGetUserInfoHeap( BaseHeap, Flags, hMem, &Handle, &Flags )) {
                }
            else
            if (Handle == NULL || !(Flags & BASE_HEAP_FLAG_MOVEABLE)) {
                uFlags = 0;
                }
            else {
                hMem = Handle;
                }
            }

        if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
                uFlags = HandleEntry->LockCount & GMEM_LOCKCOUNT;
                if (HandleEntry->Flags & BASE_HANDLE_DISCARDED) {
                    uFlags |= GMEM_DISCARDED;
                    }

                if (HandleEntry->Flags & BASE_HANDLE_DISCARDABLE) {
                    uFlags |= GMEM_DISCARDABLE;
                    }

                if (HandleEntry->Flags & BASE_HANDLE_SHARED) {
                    uFlags |= GMEM_DDESHARE;
                    }
                }
            }

        if (uFlags == GMEM_INVALID_HANDLE) {
#if DBG
            DbgPrint( "*** GlobalFlags( %lx ) - invalid handle\n", hMem );
            BaseHeapBreakPoint();
#endif
            SetLastError( ERROR_INVALID_HANDLE );
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    return( uFlags );
}


HGLOBAL
WINAPI
GlobalFree(
    HGLOBAL hMem
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    LPSTR p;

    try {
        if (pfnWowGlobalFreeHook != NULL) {
            if (!(*pfnWowGlobalFreeHook)(hMem)) {
                return NULL;
                }
            }

        if (!((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT)) {
            if (RtlFreeHeap( BaseHeap, 0, (PVOID)hMem )) {
                return NULL;
                }
            else {
                SetLastError( ERROR_INVALID_HANDLE );
                return hMem;
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        return hMem;
        }

    RtlLockHeap( BaseHeap );
    try {
        if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (!RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
#if DBG
                DbgPrint( "*** GlobalFree( %lx ) - invalid handle\n", hMem );
                BaseHeapBreakPoint();
#endif
                SetLastError( ERROR_INVALID_HANDLE );
                p = NULL;
                }
            else {
#if DBG
                if (HandleEntry->LockCount != 0) {
                    DbgPrint( "BASE: GlobalFree called with a locked object.\n" );
                    BaseHeapBreakPoint();
                    }
#endif
                p = HandleEntry->Object;
                RtlFreeHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry );
                if (p == NULL) {
                    hMem = NULL;
                    }
                }
            }
        else {
            p = (LPSTR)hMem;
            }

        if (p != NULL) {
            if (RtlFreeHeap( BaseHeap, HEAP_NO_SERIALIZE, p )) {
                hMem = NULL;
                }
            else {
                SetLastError( ERROR_INVALID_HANDLE );
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    return( hMem );
}


SIZE_T
WINAPI
GlobalCompact(
    DWORD dwMinFree
    )
{
    return RtlCompactHeap( BaseHeap, 0 );
}

VOID
WINAPI
GlobalFix(
    HGLOBAL hMem
    )
{
    if (hMem != (HGLOBAL)-1) {
        GlobalLock( hMem );
        }
    return;
}


VOID
WINAPI
GlobalUnfix(
    HGLOBAL hMem
    )
{
    if (hMem != (HGLOBAL)-1) {
        GlobalUnlock( hMem );
        }
    return;
}

LPVOID
WINAPI
GlobalWire(
    HGLOBAL hMem
    )
{
    return GlobalLock( hMem );
}

BOOL
WINAPI
GlobalUnWire(
    HGLOBAL hMem
    )
{
    return GlobalUnlock( hMem );
}

VOID
WINAPI
GlobalMemoryStatus(
    LPMEMORYSTATUS lpBuffer
    )
{
    DWORD NumberOfPhysicalPages;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    VM_COUNTERS VmCounters;
    QUOTA_LIMITS QuotaLimits;
    NTSTATUS Status;
    PPEB Peb;
    PIMAGE_NT_HEADERS NtHeaders;
    DWORDLONG Memory64;

    Status = NtQuerySystemInformation(
                SystemPerformanceInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL);

    ASSERT(NT_SUCCESS(Status));


    lpBuffer->dwLength = sizeof( *lpBuffer );

    //
    // Capture the number of physical pages as it can change dynamically.
    // If it goes up or down in the middle of this routine, the results may
    // look strange (ie: available > total, etc), but it will quickly
    // right itself.
    //

    NumberOfPhysicalPages = USER_SHARED_DATA->NumberOfPhysicalPages;

#if defined(BUILD_WOW6432)

    //
    // Convert the number of physical pages from the native system to
    // the emulation system.
    //
    
    NumberOfPhysicalPages = NumberOfPhysicalPages * (Wow64GetSystemNativePageSize() / BASE_SYSINFO.PageSize);

#endif

    //
    // Determine the memory load.  < 100 available pages is 100
    // Otherwise load is ((TotalPhys - AvailPhys) * 100) / TotalPhys
    //

    if (PerfInfo.AvailablePages < 100) {
        lpBuffer->dwMemoryLoad = 100;
    } else {
        lpBuffer->dwMemoryLoad =
            ((DWORD)(NumberOfPhysicalPages - PerfInfo.AvailablePages) * 100) /
                NumberOfPhysicalPages;
    }

    //
    // Determine the physical memory sizes. 
    //

    Memory64 =  (DWORDLONG)NumberOfPhysicalPages * BASE_SYSINFO.PageSize;

    lpBuffer->dwTotalPhys = (SIZE_T) __min(Memory64, MAXULONG_PTR);

    Memory64 = ((DWORDLONG)PerfInfo.AvailablePages * (DWORDLONG)BASE_SYSINFO.PageSize);

    lpBuffer->dwAvailPhys = (SIZE_T) __min(Memory64, MAXULONG_PTR);

    if (gpTermsrvAdjustPhyMemLimits) {
        gpTermsrvAdjustPhyMemLimits(&(lpBuffer->dwTotalPhys),
                                    &(lpBuffer->dwAvailPhys),
                                    BASE_SYSINFO.PageSize);
    }
    
    //
    // Zero returned values in case the query process fails.
    //

    RtlZeroMemory (&QuotaLimits, sizeof (QUOTA_LIMITS));
    RtlZeroMemory (&VmCounters, sizeof (VM_COUNTERS));

    Status = NtQueryInformationProcess (NtCurrentProcess(),
                                        ProcessQuotaLimits,
                                        &QuotaLimits,
                                        sizeof(QUOTA_LIMITS),
                                        NULL);

    ASSERT(NT_SUCCESS(Status));



    Status = NtQueryInformationProcess (NtCurrentProcess(),
                                        ProcessVmCounters,
                                        &VmCounters,
                                        sizeof(VM_COUNTERS),
                                        NULL);
    ASSERT(NT_SUCCESS(Status));


    //
    // Determine the total page file space with respect to this process.
    //

    Memory64 = __min(PerfInfo.CommitLimit, QuotaLimits.PagefileLimit);

    Memory64 *= BASE_SYSINFO.PageSize;

    lpBuffer->dwTotalPageFile = (SIZE_T)__min(Memory64, MAXULONG_PTR);

    //
    // Determine remaining page file space with respect to this process.
    //

    Memory64 = __min(PerfInfo.CommitLimit - PerfInfo.CommittedPages,
                     QuotaLimits.PagefileLimit - VmCounters.PagefileUsage);

    Memory64 *= BASE_SYSINFO.PageSize;

    lpBuffer->dwAvailPageFile = (SIZE_T) __min(Memory64, MAXULONG_PTR);

    lpBuffer->dwTotalVirtual = (BASE_SYSINFO.MaximumUserModeAddress -
                                BASE_SYSINFO.MinimumUserModeAddress) + 1;

    lpBuffer->dwAvailVirtual = lpBuffer->dwTotalVirtual - VmCounters.VirtualSize;

#if !defined(_WIN64)

    //
    // Lie about available memory if application can't handle large (>2GB) addresses
    //

    Peb = NtCurrentPeb();
    NtHeaders = RtlImageNtHeader( Peb->ImageBaseAddress );

    if (NtHeaders && !(NtHeaders->FileHeader.Characteristics & IMAGE_FILE_LARGE_ADDRESS_AWARE)) {

        if (BASE_SYSINFO.MaximumUserModeAddress > 0x7FFEFFFF) {

            //
            // Booted /3GB, but the application can't handle large virtual
            // addresses so remove the portion above 2GB.  Note this portion
            // is variable from zero up to 1GB (depending on the /USERVA value).
            //

            lpBuffer->dwAvailVirtual -= (BASE_SYSINFO.MaximumUserModeAddress - 0x7FFEFFFF);
        }

        if (lpBuffer->dwTotalPhys > 0x7FFFFFFF) {
            lpBuffer->dwTotalPhys = 0x7FFFFFFF;
        }
        if (lpBuffer->dwAvailPhys > 0x7FFFFFFF) {
            lpBuffer->dwAvailPhys = 0x7FFFFFFF;
        }
        if (lpBuffer->dwTotalVirtual > 0x7FFFFFFF) {
            lpBuffer->dwTotalVirtual = 0x7FFFFFFF;
        }
        if (lpBuffer->dwAvailVirtual > 0x7FFFFFFF) {
            lpBuffer->dwAvailVirtual = 0x7FFFFFFF;
        }
    }
#endif

    return;
}


PVOID
WINAPI
VirtualAlloc(
    PVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    )
{

    return VirtualAllocEx(
                NtCurrentProcess(),
                lpAddress,
                dwSize,
                flAllocationType,
                flProtect
                );

}

BOOL
WINAPI
VirtualFree(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD dwFreeType
    )
{
    return VirtualFreeEx(NtCurrentProcess(),lpAddress,dwSize,dwFreeType);
}

PVOID
WINAPI
VirtualAllocEx(
    HANDLE hProcess,
    PVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    )
{
    NTSTATUS Status;

    if (lpAddress != NULL && (ULONG_PTR)lpAddress < BASE_SYSINFO.AllocationGranularity) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
    }

    try {
        Status = NtAllocateVirtualMemory( hProcess,
                                          &lpAddress,
                                          0,
                                          &dwSize,
                                          flAllocationType,
                                          flProtect
                                        );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Status = GetExceptionCode();
    }

    if (NT_SUCCESS( Status )) {
        return( lpAddress );
    } else {
        BaseSetLastNTError( Status );
        return( NULL );
    }
}

BOOL
WINAPI
VirtualFreeEx(
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD dwFreeType
    )
{
    NTSTATUS Status;


    if ( (dwFreeType & MEM_RELEASE ) && dwSize != 0 ) {
        BaseSetLastNTError( STATUS_INVALID_PARAMETER );
        return FALSE;
        }

    Status = NtFreeVirtualMemory( hProcess,
                                  &lpAddress,
                                  &dwSize,
                                  dwFreeType
                                );

    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        if (Status == STATUS_INVALID_PAGE_PROTECTION) {
            if (hProcess == NtCurrentProcess()) {

                //
                // Unlock any pages that were locked with MmSecureVirtualMemory.
                // This is useful for SANs.
                //

                if (RtlFlushSecureMemoryCache(lpAddress, dwSize)) {
                    Status = NtFreeVirtualMemory( hProcess,
                                                  &lpAddress,
                                                  &dwSize,
                                                  dwFreeType
                                                );

                    if (NT_SUCCESS( Status )) {
                        return( TRUE );
                        }
                    }
                }
            }

        BaseSetLastNTError( Status );
        return( FALSE );
        }
}


BOOL
WINAPI
VirtualProtect(
    PVOID lpAddress,
    SIZE_T dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
    )
{

    return VirtualProtectEx( NtCurrentProcess(),
                             lpAddress,
                             dwSize,
                             flNewProtect,
                             lpflOldProtect
                           );
}

BOOL
WINAPI
VirtualProtectEx(
    HANDLE hProcess,
    PVOID lpAddress,
    SIZE_T dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
    )
{
    NTSTATUS Status;

    Status = NtProtectVirtualMemory( hProcess,
                                     &lpAddress,
                                     &dwSize,
                                     flNewProtect,
                                     lpflOldProtect
                                   );

    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        if (Status == STATUS_INVALID_PAGE_PROTECTION) {
            if (hProcess == NtCurrentProcess()) {

                //
                // Unlock any pages that were locked with MmSecureVirtualMemory.
                // This is useful for SANs.
                //

                if (RtlFlushSecureMemoryCache(lpAddress, dwSize)) {
                    Status = NtProtectVirtualMemory( hProcess,
                                                  &lpAddress,
                                                  &dwSize,
                                                  flNewProtect,
                                                  lpflOldProtect
                                                );

                    if (NT_SUCCESS( Status )) {
                        return( TRUE );
                        }
                    }
                }
            }
        BaseSetLastNTError( Status );
        return( FALSE );
        }
}

SIZE_T
WINAPI
VirtualQuery(
    LPCVOID lpAddress,
    PMEMORY_BASIC_INFORMATION lpBuffer,
    SIZE_T dwLength
    )
{

    return VirtualQueryEx( NtCurrentProcess(),
                           lpAddress,
                           (PMEMORY_BASIC_INFORMATION)lpBuffer,
                           dwLength
                         );
}

SIZE_T
WINAPI
VirtualQueryEx(
    HANDLE hProcess,
    LPCVOID lpAddress,
    PMEMORY_BASIC_INFORMATION lpBuffer,
    SIZE_T dwLength
    )
{
    NTSTATUS Status;
    SIZE_T ReturnLength;

    Status = NtQueryVirtualMemory( hProcess,
                                   (LPVOID)lpAddress,
                                   MemoryBasicInformation,
                                   (PMEMORY_BASIC_INFORMATION)lpBuffer,
                                   dwLength,
                                   &ReturnLength
                                 );
    if (NT_SUCCESS( Status )) {
        return( ReturnLength );
        }
    else {
        BaseSetLastNTError( Status );
        return( 0 );
        }
}

BOOL
WINAPI
VirtualLock(
    LPVOID lpAddress,
    SIZE_T dwSize
    )

/*++

Routine Description:

    This API may be used to lock the specified range of the processes
    address space into memory.  This range is present whenever the
    application is running.  All pages covered by the range must be
    commited.  VirtialLock is in now way related to LocalLock or
    GlobalLock.  It does not perform a handle translation.  Its function
    is to lock memory in the "working set" of the calling process.

    Note that the specified range is used to compute the range of pages
    covered by the lock. A 2 byte lock that straddles a page boundry
    ends up locking both of the pages covered by the range. Also note
    that calls to VirtualLock do not nest.


Arguments:

    lpAddress - Supplies the base address of the region being locked.

    dwSize - Supplies the number of bytes being locked.

Return Value:

    TRUE - The operation was was successful.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;
    PVOID BaseAddress;
    SIZE_T RegionSize;
    BOOL ReturnValue;

    ReturnValue = TRUE;
    BaseAddress = lpAddress;
    RegionSize = dwSize;

    Status = NtLockVirtualMemory(
                NtCurrentProcess(),
                &lpAddress,
                &RegionSize,
                MAP_PROCESS
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
        }

    return ReturnValue;
}

BOOL
WINAPI
VirtualUnlock(
    LPVOID lpAddress,
    SIZE_T dwSize
    )

/*++

Routine Description:

    This API may be used to unlock the specified range of the processes
    address space from memory. This call is used to reveres the effects of
    a previous call to VirtualLock. The range specified need not match
    a range passed to a previous VirtualLock call, but it must specify
    a locked range" for this API to be successful.

    Note that the specified range is used to compute the range of pages
    covered by the unlock. A 2 byte unlock that straddles a page boundry
    ends up unlocking both of the pages covered by the range.

Arguments:

    lpAddress - Supplies the base address of the region being unlocked.

    dwSize - Supplies the number of bytes being unlocked.

Return Value:

    TRUE - The operation was was successful.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;
    PVOID BaseAddress;
    SIZE_T RegionSize;
    BOOL ReturnValue;

    ReturnValue = TRUE;
    BaseAddress = lpAddress;
    RegionSize = dwSize;

    Status = NtUnlockVirtualMemory(
                NtCurrentProcess(),
                &lpAddress,
                &RegionSize,
                MAP_PROCESS
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
        }

    return ReturnValue;
}

BOOL
WINAPI
FlushInstructionCache(
    HANDLE hProcess,
    LPCVOID lpBaseAddress,
    SIZE_T dwSize
    )

/*++

Routine Description:

    This function flushes the instruction cache for the specified process.

Arguments:

    hProcess - Supplies a handle to the process in which the instruction
        cache is to be flushed.

    lpBaseAddress - Supplies an optional pointer to base of the region that
        is flushed.

    dwSize - Supplies the length of the region that is flushed if the base
        address is specified.

Return Value:

    TRUE - The operation was was successful.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.


--*/

{
    NTSTATUS Status;
    BOOL ReturnValue = TRUE;

    Status = NtFlushInstructionCache(
                hProcess,
                (LPVOID)lpBaseAddress,
                dwSize
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
        }

    return ReturnValue;
}

BOOL
WINAPI
AllocateUserPhysicalPages(
    HANDLE hProcess,
    PULONG_PTR NumberOfPages,
    PULONG_PTR PageArray
    )
{
    NTSTATUS Status;

    Status = NtAllocateUserPhysicalPages( hProcess,
                                          NumberOfPages,
                                          PageArray);

    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        BaseSetLastNTError( Status );
        return( FALSE );
        }
}

BOOL
WINAPI
FreeUserPhysicalPages(
    HANDLE hProcess,
    PULONG_PTR NumberOfPages,
    PULONG_PTR PageArray
    )
{
    NTSTATUS Status;

    Status = NtFreeUserPhysicalPages( hProcess,
                                      NumberOfPages,
                                      PageArray);

    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        BaseSetLastNTError( Status );
        return( FALSE );
        }
}

BOOL
WINAPI
MapUserPhysicalPages(
    PVOID VirtualAddress,
    ULONG_PTR NumberOfPages,
    PULONG_PTR PageArray
    )
{
    NTSTATUS Status;

    Status = NtMapUserPhysicalPages( VirtualAddress,
                                     NumberOfPages,
                                     PageArray);

    if (NT_SUCCESS( Status )) {
        return( TRUE );
    } else {
        BaseSetLastNTError( Status );
        return( FALSE );
    }
}

BOOL
WINAPI
MapUserPhysicalPagesScatter(
    PVOID *VirtualAddresses,
    ULONG_PTR NumberOfPages,
    PULONG_PTR PageArray
    )
{
    NTSTATUS Status;

    Status = NtMapUserPhysicalPagesScatter( VirtualAddresses,
                                            NumberOfPages,
                                            PageArray);

    if (NT_SUCCESS( Status )) {
        return( TRUE );
    } else {
        BaseSetLastNTError( Status );
        return( FALSE );
    }
}

BOOL
WINAPI
GlobalMemoryStatusEx(
    LPMEMORYSTATUSEX lpBuffer
    )
{
    DWORD NumberOfPhysicalPages;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    VM_COUNTERS VmCounters;
    QUOTA_LIMITS QuotaLimits;
    DWORDLONG AvailPageFile;
    DWORDLONG PhysicalMemory;
    NTSTATUS Status;
    DWORD Success;
    DWORDLONG address64;

    if (lpBuffer->dwLength != sizeof(*lpBuffer)) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    Status = NtQuerySystemInformation (SystemPerformanceInformation,
                                       &PerfInfo,
                                       sizeof(PerfInfo),
                                       NULL);
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return FALSE;
    }

    //
    // Capture the number of physical pages as it can change dynamically.
    // If it goes up or down in the middle of this routine, the results may
    // look strange (ie: available > total, etc), but it will quickly
    // right itself.
    //

    NumberOfPhysicalPages = USER_SHARED_DATA->NumberOfPhysicalPages;

#if defined(BUILD_WOW6432)

    //
    // Convert the number of physical pages from the native system to
    // the emulation system.
    //
    
    NumberOfPhysicalPages = NumberOfPhysicalPages * (Wow64GetSystemNativePageSize() / BASE_SYSINFO.PageSize);

#endif

    PhysicalMemory = (DWORDLONG)NumberOfPhysicalPages * BASE_SYSINFO.PageSize;

    //
    // Determine the memory load.  < 100 available pages is 100
    // Otherwise load is ((TotalPhys - AvailPhys) * 100) / TotalPhys
    //

    if (PerfInfo.AvailablePages < 100) {
        lpBuffer->dwMemoryLoad = 100;
    } else {
        lpBuffer->dwMemoryLoad =
            ((DWORD)(NumberOfPhysicalPages - PerfInfo.AvailablePages) * 100) /
                NumberOfPhysicalPages;
    }

    lpBuffer->ullTotalPhys = PhysicalMemory;

    PhysicalMemory = PerfInfo.AvailablePages;

    PhysicalMemory *= BASE_SYSINFO.PageSize;

    lpBuffer->ullAvailPhys = PhysicalMemory;

    //
    // Zero returned values in case the query process fails.
    //

    RtlZeroMemory (&QuotaLimits, sizeof (QUOTA_LIMITS));
    RtlZeroMemory (&VmCounters, sizeof (VM_COUNTERS));

    Status = NtQueryInformationProcess (NtCurrentProcess(),
                                        ProcessQuotaLimits,
                                        &QuotaLimits,
                                        sizeof(QUOTA_LIMITS),
                                        NULL );

    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return FALSE;
    }

    Status = NtQueryInformationProcess (NtCurrentProcess(),
                                        ProcessVmCounters,
                                        &VmCounters,
                                        sizeof(VM_COUNTERS),
                                        NULL );
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return FALSE;
    }

    //
    // Determine the total page file space with respect to this process.
    //

    lpBuffer->ullTotalPageFile = PerfInfo.CommitLimit;
    if (QuotaLimits.PagefileLimit < PerfInfo.CommitLimit) {
        lpBuffer->ullTotalPageFile = QuotaLimits.PagefileLimit;
    }

    lpBuffer->ullTotalPageFile *= BASE_SYSINFO.PageSize;

    //
    // Determine remaining page file space with respect to this process.
    //

    AvailPageFile = PerfInfo.CommitLimit - PerfInfo.CommittedPages;

    lpBuffer->ullAvailPageFile =
                    QuotaLimits.PagefileLimit - VmCounters.PagefileUsage;

    if ((ULONG)lpBuffer->ullAvailPageFile > (ULONG)AvailPageFile) {
        lpBuffer->ullAvailPageFile = AvailPageFile;
    }

    lpBuffer->ullAvailPageFile *= BASE_SYSINFO.PageSize;

    lpBuffer->ullTotalVirtual = (BASE_SYSINFO.MaximumUserModeAddress -
                               BASE_SYSINFO.MinimumUserModeAddress) + 1;

    lpBuffer->ullAvailVirtual = lpBuffer->ullTotalVirtual - VmCounters.VirtualSize;

    lpBuffer->ullAvailExtendedVirtual = 0;

    return TRUE;
}

WINBASEAPI
UINT
WINAPI
GetWriteWatch(
    DWORD dwFlags,	
    PVOID lpBaseAddress,
    SIZE_T dwRegionSize,
    PVOID *addresses,
    ULONG_PTR *count,
    LPDWORD granularity
    )
{
    NTSTATUS Status;

    Status = NtGetWriteWatch ( NtCurrentProcess(),
                               dwFlags,
                               lpBaseAddress,
                               dwRegionSize,
                               addresses,
                               count,
                               granularity
                               );

    //
    // Note these return codes are taken straight from Win9x.
    //

    if (NT_SUCCESS( Status )) {
        return( 0 );
        }
    else {
        BaseSetLastNTError( Status );
        return (UINT)-1;
        }
}

WINBASEAPI
UINT
WINAPI
ResetWriteWatch(
    LPVOID lpBaseAddress,
    SIZE_T dwRegionSize
    )
{
    NTSTATUS Status;

    Status = NtResetWriteWatch ( NtCurrentProcess(),
                                 lpBaseAddress,
                                 dwRegionSize
                                 );

    //
    // Note these return codes are taken straight from Win9x.
    //

    if (NT_SUCCESS( Status )) {
        return( 0 );
        }
    else {
        BaseSetLastNTError( Status );
        return (UINT)-1;
        }
}

SIZE_T
WINAPI
GetLargePageMinimum (
    VOID
    )

/*++

Routine Description:

    This function returns the size in bytes of the minimum large
    page size and address alignment that can be used with the
    VirtualAlloc MEM_LARGE_PAGES flag.

Arguments:

    None.

Return Value:

    The size in bytes of the minimum large page or zero if no large page
    is supported by the underlying hardware.

--*/

{
    return (SIZE_T) USER_SHARED_DATA->LargePageMinimum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\handle.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    handle.c

Abstract:

    This module implements the Win32 handle management services.

Author:

    Mark Lucovsky (markl) 21-Sep-1990

Revision History:

--*/

#include "basedll.h"

BOOL
CloseHandle(
    HANDLE hObject
    )

/*++

Routine Description:

    An open handle to any object can be closed using CloseHandle.

    This is a generic function and operates on the following object
    types:

        - Process Object

        - Thread Object

        - Mutex Object

        - Event Object

        - Semaphore Object

        - File Object

    Please note that Module Objects are not in this list.

    Closing an open handle to an object causes the handle to become
    invalid and the HandleCount of the associated object to be
    decremented and object retention checks to be performed.  Once the
    last open handle to an object is closed, the object is removed from
    the system.

Arguments:

    hObject - An open handle to an object.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    PPEB Peb;

    Peb = NtCurrentPeb();

    //
    // Perhaps we ought to use a full-fledged lock here, however, it
    // doesn't seem absolutely necessary, and it's reasonable to
    // assume that callers are aware of the various race conditions
    // which may be involved with using and closing the standard
    // handles.
    //
    // In any event, a proper fix would use a lock in kernel mode, and
    // do the mapping there, as the lock would really need to be held
    // across the translation from handle to kernel object.
    //
    // Replacing handles with NULL will cause StuffStdHandle() to
    // ignore them when duplicating handles to child processes.
    //

    switch( HandleToUlong(hObject) ) {
        case STD_INPUT_HANDLE:
            hObject = InterlockedExchangePointer(
                &Peb->ProcessParameters->StandardInput,
                NULL);
            break;
        case STD_OUTPUT_HANDLE:
            hObject = InterlockedExchangePointer(
                &Peb->ProcessParameters->StandardOutput,
                NULL);
            break;
        case STD_ERROR_HANDLE: 
            hObject = InterlockedExchangePointer(
                &Peb->ProcessParameters->StandardError,
                NULL);
            break;
        }
    if (CONSOLE_HANDLE(hObject)) {
        return CloseConsoleHandle(hObject);
        }

    Status = NtClose(hObject);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}


BOOL
DuplicateHandle(
    HANDLE hSourceProcessHandle,
    HANDLE hSourceHandle,
    HANDLE hTargetProcessHandle,
    LPHANDLE lpTargetHandle,
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwOptions
    )

/*++

Routine Description:

    A duplicate handle can be created with the DuplicateHandle function.

    This is a generic function and operates on the following object
    types:

        - Process Object

        - Thread Object

        - Mutex Object

        - Event Object

        - Semaphore Object

        - File Object

    Please note that Module Objects are not in this list.

    This function requires PROCESS_DUP_ACCESS to both the
    SourceProcessHandle and the TargetProcessHandle.  This function is
    used to pass an object handle from one process to another.  Once
    this call is complete, the target process needs to be informed of
    the value of the target handle.  The target process can then operate
    on the object using this handle value.

Arguments:

    hSourceProcessHandle - An open handle to the process that contains the
        handle to be duplicated. The handle must have been created with
        PROCESS_DUP_HANDLE access to the process.

    hSourceHandle - An open handle to any object that is valid in the
        context of the source process.

    hTargetProcessHandle - An open handle to the process that is to
        receive the duplicated handle.  The handle must have been
        created with PROCESS_DUP_HANDLE access to the process.

    lpTargetHandle - A pointer to a variable which receives the new handle
        that points to the same object as SourceHandle does.  This
        handle value is valid in the context of the target process.

    dwDesiredAccess - The access requested to for the new handle.  This
        parameter is ignored if the DUPLICATE_SAME_ACCESS option is
        specified.

    bInheritHandle - Supplies a flag that if TRUE, marks the target
        handle as inheritable.  If this is the case, then the target
        handle will be inherited to new processes each time the target
        process creates a new process using CreateProcess.

    dwOptions - Specifies optional behaviors for the caller.

        Options Flags:

        DUPLICATE_CLOSE_SOURCE - The SourceHandle will be closed by
            this service prior to returning to the caller.  This occurs
            regardless of any error status returned.

        DUPLICATE_SAME_ACCESS - The DesiredAccess parameter is ignored
            and instead the GrantedAccess associated with SourceHandle
            is used as the DesiredAccess when creating the TargetHandle.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    PPEB Peb;

    Peb = NtCurrentPeb();
    switch( HandleToUlong(hSourceHandle) ) {
        case STD_INPUT_HANDLE:  hSourceHandle = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hSourceHandle = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hSourceHandle = Peb->ProcessParameters->StandardError;
                                break;
        }

    if (CONSOLE_HANDLE(hSourceHandle) &&
	(hSourceHandle != NtCurrentProcess() &&
	 hSourceHandle != NtCurrentThread()) ) {
        HANDLE Target;

        if (hSourceProcessHandle != NtCurrentProcess() ||
            hTargetProcessHandle != NtCurrentProcess()) {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;
            }
        Target = DuplicateConsoleHandle(hSourceHandle,
                                        dwDesiredAccess,
                                        bInheritHandle,
                                        dwOptions
                                       );
        if (Target == INVALID_HANDLE_VALUE) {
            return FALSE;
            }
        else {
            try {
                if ( ARGUMENT_PRESENT(lpTargetHandle) ) {
                    *lpTargetHandle = Target;
                    }
                }
            except (EXCEPTION_EXECUTE_HANDLER) {
                return TRUE;
                }
            return TRUE;
            }
        }

    Status = NtDuplicateObject(
                hSourceProcessHandle,
                hSourceHandle,
                hTargetProcessHandle,
                lpTargetHandle,
                (ACCESS_MASK)dwDesiredAccess,
                bInheritHandle ? OBJ_INHERIT : 0,
                dwOptions
                );
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    return FALSE;
}


BOOL
GetHandleInformation(
    HANDLE hObject,
    LPDWORD lpdwFlags
    )
{
    NTSTATUS Status;
    OBJECT_HANDLE_FLAG_INFORMATION HandleInfo;
    DWORD Result;
    PPEB Peb;

    Peb = NtCurrentPeb();
    switch( HandleToUlong(hObject) ) {
        case STD_INPUT_HANDLE:  hObject = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hObject = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hObject = Peb->ProcessParameters->StandardError;
                                break;
        }

    if (CONSOLE_HANDLE(hObject)) {
        return GetConsoleHandleInformation(hObject,
                                           lpdwFlags
                                          );
        }

    Status = NtQueryObject( hObject,
                            ObjectHandleFlagInformation,
                            &HandleInfo,
                            sizeof( HandleInfo ),
                            NULL
                          );
    if (NT_SUCCESS( Status )) {
        Result = 0;
        if (HandleInfo.Inherit) {
            Result |= HANDLE_FLAG_INHERIT;
            }

        if (HandleInfo.ProtectFromClose) {
            Result |= HANDLE_FLAG_PROTECT_FROM_CLOSE;
            }

        *lpdwFlags = Result;
        return TRUE;
        }
    else {
        BaseSetLastNTError( Status );
        return FALSE;
        }
}


BOOL
SetHandleInformation(
    HANDLE hObject,
    DWORD dwMask,
    DWORD dwFlags
    )
{
    NTSTATUS Status;
    OBJECT_HANDLE_FLAG_INFORMATION HandleInfo;
    PPEB Peb;

    Peb = NtCurrentPeb();
    switch( HandleToUlong(hObject) ) {
        case STD_INPUT_HANDLE:  hObject = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hObject = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hObject = Peb->ProcessParameters->StandardError;
                                break;
        }

    if (CONSOLE_HANDLE(hObject)) {
        return SetConsoleHandleInformation(hObject,
                                           dwMask,
                                           dwFlags
                                          );
        }

    Status = NtQueryObject( hObject,
                            ObjectHandleFlagInformation,
                            &HandleInfo,
                            sizeof( HandleInfo ),
                            NULL
                          );
    if (NT_SUCCESS( Status )) {
        if (dwMask & HANDLE_FLAG_INHERIT) {
            HandleInfo.Inherit = (dwFlags & HANDLE_FLAG_INHERIT) ? TRUE : FALSE;
            }

        if (dwMask & HANDLE_FLAG_PROTECT_FROM_CLOSE) {
            HandleInfo.ProtectFromClose = (dwFlags & HANDLE_FLAG_PROTECT_FROM_CLOSE) ? TRUE : FALSE;
            }

        Status = NtSetInformationObject( hObject,
                                         ObjectHandleFlagInformation,
                                         &HandleInfo,
                                         sizeof( HandleInfo )
                                       );
        if (NT_SUCCESS( Status )) {
            return TRUE;
            }
        }

    BaseSetLastNTError( Status );
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\job.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    job.c

Abstract:

    Support for the Job Object

Author:

    Mark Lucovsky (markl) 12-Jun-1997

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop

HANDLE
WINAPI
CreateJobObjectA(
    LPSECURITY_ATTRIBUTES lpJobAttributes,
    LPCSTR lpName
    )
{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    LPCWSTR NameBuffer;

    NameBuffer = NULL;
    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        NameBuffer = (LPCWSTR)Unicode->Buffer;
        }

    return CreateJobObjectW(
                lpJobAttributes,
                NameBuffer
                );
}

HANDLE
WINAPI
CreateJobObjectW(
    LPSECURITY_ATTRIBUTES lpJobAttributes,
    LPCWSTR lpName
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    UNICODE_STRING ObjectName;

    if ( ARGUMENT_PRESENT(lpName) ) {
        RtlInitUnicodeString(&ObjectName,lpName);
        pObja = BaseFormatObjectAttributes(&Obja,lpJobAttributes,&ObjectName);
        }
    else {
        pObja = BaseFormatObjectAttributes(&Obja,lpJobAttributes,NULL);
        }

    Status = NtCreateJobObject(
                &Handle,
                JOB_OBJECT_ALL_ACCESS,
                pObja
                );
    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        return Handle;
        }
    else {
        BaseSetLastNTError(Status);
        return NULL;
        }
}

HANDLE
WINAPI
OpenJobObjectA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    )
{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        }
    else {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    return OpenJobObjectW(
                dwDesiredAccess,
                bInheritHandle,
                (LPCWSTR)Unicode->Buffer
                );
}

HANDLE
WINAPI
OpenJobObjectW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING ObjectName;
    NTSTATUS Status;
    HANDLE Object;

    if ( !lpName ) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }
    RtlInitUnicodeString(&ObjectName,lpName);

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        (bInheritHandle ? OBJ_INHERIT : 0),
        BaseGetNamedObjectDirectory(),
        NULL
        );

    Status = NtOpenJobObject(
                &Object,
                dwDesiredAccess,
                &Obja
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
        }
    return Object;
}

BOOL
WINAPI
AssignProcessToJobObject(
    HANDLE hJob,
    HANDLE hProcess
    )
{
    NTSTATUS Status;
    BOOL rv;

    rv = TRUE;
    Status = NtAssignProcessToJobObject(hJob,hProcess);
    if ( !NT_SUCCESS(Status) ) {
        rv = FALSE;
        BaseSetLastNTError(Status);
        }
    return rv;
}

BOOL
WINAPI
TerminateJobObject(
    HANDLE hJob,
    UINT uExitCode
    )
{
    NTSTATUS Status;
    BOOL rv;

    rv = TRUE;
    Status = NtTerminateJobObject(hJob,uExitCode);
    if ( !NT_SUCCESS(Status) ) {
        rv = FALSE;
        BaseSetLastNTError(Status);
        }
    return rv;
}

BOOL
WINAPI
QueryInformationJobObject(
    HANDLE hJob,
    JOBOBJECTINFOCLASS JobObjectInformationClass,
    LPVOID lpJobObjectInformation,
    DWORD cbJobObjectInformationLength,
    LPDWORD lpReturnLength
    )
{
    NTSTATUS Status;
    BOOL rv;
    JOBOBJECT_EXTENDED_LIMIT_INFORMATION ExtendedLimitInfo;
    PVOID LimitInfo;

    if ( JobObjectInformationClass == JobObjectBasicLimitInformation ) {
        LimitInfo = &ExtendedLimitInfo;
        if ( cbJobObjectInformationLength != sizeof(JOBOBJECT_BASIC_LIMIT_INFORMATION) ) {
            BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
            return FALSE;
            }
        }
    else if ( JobObjectInformationClass == JobObjectExtendedLimitInformation ) {
        LimitInfo = &ExtendedLimitInfo;
        if ( cbJobObjectInformationLength != sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION) ) {
            BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
            return FALSE;
            }
        }
    else {
        LimitInfo = lpJobObjectInformation;
        }

    rv = TRUE;
    Status = NtQueryInformationJobObject(
                hJob,
                JobObjectInformationClass,
                LimitInfo,
                cbJobObjectInformationLength,
                lpReturnLength
                );
    if ( !NT_SUCCESS(Status) ) {
        rv = FALSE;
        BaseSetLastNTError(Status);
        }
    else {
        if (LimitInfo == &ExtendedLimitInfo ) {
            switch (ExtendedLimitInfo.BasicLimitInformation.PriorityClass) {
                case PROCESS_PRIORITY_CLASS_IDLE :
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = IDLE_PRIORITY_CLASS;
                    break;
                case PROCESS_PRIORITY_CLASS_BELOW_NORMAL:
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = BELOW_NORMAL_PRIORITY_CLASS;
                    break;
                case PROCESS_PRIORITY_CLASS_NORMAL :
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = NORMAL_PRIORITY_CLASS;
                    break;
                case PROCESS_PRIORITY_CLASS_ABOVE_NORMAL:
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = ABOVE_NORMAL_PRIORITY_CLASS;
                    break;
                case PROCESS_PRIORITY_CLASS_HIGH :
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = HIGH_PRIORITY_CLASS;
                    break;
                case PROCESS_PRIORITY_CLASS_REALTIME :
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = REALTIME_PRIORITY_CLASS;
                    break;
                default:
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = NORMAL_PRIORITY_CLASS;

                }
            CopyMemory(lpJobObjectInformation,&ExtendedLimitInfo,cbJobObjectInformationLength);
            }
        }
    return rv;
}

BOOL
WINAPI
SetInformationJobObject(
    HANDLE hJob,
    JOBOBJECTINFOCLASS JobObjectInformationClass,
    LPVOID lpJobObjectInformation,
    DWORD cbJobObjectInformationLength
    )
{
    NTSTATUS Status;
    BOOL rv;
    JOBOBJECT_EXTENDED_LIMIT_INFORMATION ExtendedLimitInfo;
    PVOID LimitInfo;
    NTSTATUS PrivStatus = STATUS_UNSUCCESSFUL;
    PVOID State;

    rv = TRUE;
    if (JobObjectInformationClass == JobObjectBasicLimitInformation ||
        JobObjectInformationClass == JobObjectExtendedLimitInformation ) {

        if ( JobObjectInformationClass == JobObjectBasicLimitInformation ) {
            if ( cbJobObjectInformationLength != sizeof(JOBOBJECT_BASIC_LIMIT_INFORMATION) ) {
                BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
                return FALSE;
            }
        } else {
            if ( cbJobObjectInformationLength != sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION) ) {
                BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
                return FALSE;
            }
        }

        LimitInfo = &ExtendedLimitInfo;

        CopyMemory(&ExtendedLimitInfo,lpJobObjectInformation,cbJobObjectInformationLength);

        if ( ExtendedLimitInfo.BasicLimitInformation.LimitFlags & JOB_OBJECT_LIMIT_PRIORITY_CLASS ) {
            switch (ExtendedLimitInfo.BasicLimitInformation.PriorityClass) {

                case IDLE_PRIORITY_CLASS :
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = PROCESS_PRIORITY_CLASS_IDLE;
                    break;
                case BELOW_NORMAL_PRIORITY_CLASS :
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = PROCESS_PRIORITY_CLASS_BELOW_NORMAL;
                    break;
                case NORMAL_PRIORITY_CLASS :
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = PROCESS_PRIORITY_CLASS_NORMAL;
                    break;
                case ABOVE_NORMAL_PRIORITY_CLASS :
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = PROCESS_PRIORITY_CLASS_ABOVE_NORMAL;
                    break;
                case HIGH_PRIORITY_CLASS :
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = PROCESS_PRIORITY_CLASS_HIGH;
                    break;
                case REALTIME_PRIORITY_CLASS :
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = PROCESS_PRIORITY_CLASS_REALTIME;
                    break;
                default:
                    ExtendedLimitInfo.BasicLimitInformation.PriorityClass = PROCESS_PRIORITY_CLASS_NORMAL;

            }
        }
        if (ExtendedLimitInfo.BasicLimitInformation.LimitFlags & JOB_OBJECT_LIMIT_WORKINGSET) {
            //
            // Attempt to acquire the appropriate privilege.  If this
            // fails, it's no big deal -- we'll attempt to make the
            // NtSetInformationProcess call anyway, in case it turns out
            // to be a decrease operation (which will succeed anyway).
            //

            PrivStatus = BasepAcquirePrivilegeEx( SE_INC_BASE_PRIORITY_PRIVILEGE, &State );
        }
    } else {
        LimitInfo = lpJobObjectInformation;
    }

    Status = NtSetInformationJobObject(
                hJob,
                JobObjectInformationClass,
                LimitInfo,
                cbJobObjectInformationLength
                );

    if (NT_SUCCESS(PrivStatus)) {
        //
        // We successfully acquired the privilege above; we need to relinquish it.
        //
        ASSERT (State != NULL);
        BasepReleasePrivilege (State);
        State = NULL;
    }

    if ( !NT_SUCCESS(Status) ) {
        rv = FALSE;
        BaseSetLastNTError(Status);
    }
    return rv;
}

BOOL
WINAPI
IsProcessInJob (
    IN HANDLE ProcessHandle,
    IN HANDLE JobHandle,
    OUT PBOOL Result
    )
/*++

Routine Description:

    This routine finds out if a process is in a specific or any job

Arguments:

    ProcessHandle - Handle to process to be checked
    JobHandle     - Handle of job to check process against, May be NULL to do general query.
    Result        - TRUE if the process is part of the job FALSE otherwise.

Return Value:

    BOOL - TRUE the call was successfull, FALSE the call failed

--*/
{
    NTSTATUS Status;

    Status = NtIsProcessInJob (ProcessHandle,
                               JobHandle);
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return FALSE;
    }
    if (Status == STATUS_PROCESS_NOT_IN_JOB) {
        *Result = FALSE;
    } else {
        *Result = TRUE;
    }
    return TRUE;
}

BOOL
WINAPI
CreateJobSet (
    IN ULONG NumJob,
    IN PJOB_SET_ARRAY UserJobSet,
    IN ULONG Flags)
/*++

Routine Description:

    This function creates a job set from multiple job objects.
    
Arguments:

    NumJob     - Number of jobs in JobSet
    UserJobSet - Pointer to array of jobs to combine
    Flags      - Flags mask for future expansion

Return Value:

    BOOL - TRUE the call was successfull, FALSE the call failed

--*/
{
    NTSTATUS Status;

    Status = NtCreateJobSet (NumJob,
                             UserJobSet,
                             Flags);
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\fileopcr.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    fileopcr.c

Abstract:

    This module implements File open and Create APIs for Win32

Author:

    Mark Lucovsky (markl) 25-Sep-1990

Revision History:

--*/


#include "basedll.h"
#include "mountmgr.h"
#include "aclapi.h"
#include "winefs.h"

WCHAR BasepDataAttributeType[] = DATA_ATTRIBUTE_NAME;

typedef BOOL (WINAPI *ENCRYPTFILEWPTR)(LPCWSTR);
typedef BOOL (WINAPI *DECRYPTFILEWPTR)(LPCWSTR, DWORD);

extern const WCHAR AdvapiDllString[] = L"advapi32.dll";

#define BASE_OF_SHARE_MASK 0x00000070
#define TWO56K ( 256 * 1024 )
ULONG
BasepOfShareToWin32Share(
    IN ULONG OfShare
    )
{
    DWORD ShareMode;

    if ( (OfShare & BASE_OF_SHARE_MASK) == OF_SHARE_DENY_READ ) {
        ShareMode = FILE_SHARE_WRITE;
        }
    else if ( (OfShare & BASE_OF_SHARE_MASK) == OF_SHARE_DENY_WRITE ) {
        ShareMode = FILE_SHARE_READ;
        }
    else if ( (OfShare & BASE_OF_SHARE_MASK) == OF_SHARE_DENY_NONE ) {
        ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
        }
    else if ( (OfShare & BASE_OF_SHARE_MASK) == OF_SHARE_EXCLUSIVE ) {
        ShareMode = 0;
        }
    else {
        ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;;
        }
    return ShareMode;
}


typedef DWORD (WINAPI DUPLICATEENCRYPTIONINFOFILE)(
     IN LPCWSTR SrcFileName,
     IN LPCWSTR DstFileName,
     IN DWORD dwCreationDistribution,
     IN DWORD dwAttributes,
     IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
     );

DUPLICATEENCRYPTIONINFOFILE LoadDuplicateEncryptionInfoFile;
DUPLICATEENCRYPTIONINFOFILE *pfnDuplicateEncryptionInfoFile = LoadDuplicateEncryptionInfoFile;

DWORD
WINAPI
LoadDuplicateEncryptionInfoFile(
     IN LPCWSTR SrcFileName,
     IN LPCWSTR DstFileName,
     IN DWORD dwCreationDistribution,
     IN DWORD dwAttributes,
     IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
     )
{
    DUPLICATEENCRYPTIONINFOFILE *pfnTemp;
    HANDLE Advapi32 = NULL;
    BOOL ReturnSuccess = FALSE;
    DWORD ErrorReturn = 0;

    Advapi32 = LoadLibraryW( AdvapiDllString );
    if( Advapi32 == NULL ) {
        return GetLastError();
    }

    pfnTemp = (DUPLICATEENCRYPTIONINFOFILE*)
              GetProcAddress( Advapi32, "DuplicateEncryptionInfoFile" );
    if( pfnTemp == NULL ) {
        return GetLastError();
    }

    pfnDuplicateEncryptionInfoFile = pfnTemp;
    return pfnDuplicateEncryptionInfoFile( SrcFileName,
                                           DstFileName, 
                                           dwCreationDistribution, 
                                           dwAttributes, 
                                           lpSecurityAttributes );

}




PCUNICODE_STRING
BaseIsThisAConsoleName(
    PCUNICODE_STRING FileNameString,
    DWORD dwDesiredAccess
    )
{
    PCUNICODE_STRING FoundConsoleName;
    ULONG DeviceNameLength;
    ULONG DeviceNameOffset;
    UNICODE_STRING ConString;
    WCHAR sch,ech;

    FoundConsoleName = NULL;
    if ( FileNameString->Length ) {
        sch = FileNameString->Buffer[0];
        ech = FileNameString->Buffer[(FileNameString->Length-1)>>1];

        //
        // if CON, CONOUT$, CONIN$, \\.\CON...
        //
        //

        if ( sch == (WCHAR)'c' || sch == (WCHAR)'C' || sch == (WCHAR)'\\' ||
             ech == (WCHAR)'n' || ech == (WCHAR)'N' || ech == (WCHAR)':' || ech == (WCHAR)'$' ) {


            ConString = *FileNameString;

            DeviceNameLength = RtlIsDosDeviceName_U(ConString.Buffer);
            if ( DeviceNameLength ) {
                DeviceNameOffset = DeviceNameLength >> 16;
                DeviceNameLength &= 0x0000ffff;

                ConString.Buffer = (PWSTR)((PSZ)ConString.Buffer + DeviceNameOffset);
                ConString.Length = (USHORT)DeviceNameLength;
                ConString.MaximumLength = (USHORT)(DeviceNameLength + sizeof(UNICODE_NULL));
                }

            FoundConsoleName = NULL;
            try {

                if (RtlEqualUnicodeString(&ConString,&BaseConsoleInput,TRUE) ) {
                    FoundConsoleName = &BaseConsoleInput;
                    }
                else if (RtlEqualUnicodeString(&ConString,&BaseConsoleOutput,TRUE) ) {
                    FoundConsoleName = &BaseConsoleOutput;
                    }
                else if (RtlEqualUnicodeString(&ConString,&BaseConsoleGeneric,TRUE) ) {
                    if ((dwDesiredAccess & (GENERIC_READ|GENERIC_WRITE)) == GENERIC_READ) {
                        FoundConsoleName = &BaseConsoleInput;
                        }
                    else if ((dwDesiredAccess & (GENERIC_READ|GENERIC_WRITE)) == GENERIC_WRITE){
                        FoundConsoleName = &BaseConsoleOutput;
                        }
                    }
                }
            except (EXCEPTION_EXECUTE_HANDLER) {
                return NULL;
                }
            }
        }
    return FoundConsoleName;
}


DWORD
WINAPI
CopyReparsePoint(
    HANDLE hSourceFile,
    HANDLE hDestinationFile
    )

/*++

Routine Description:

    This is an internal routine that copies a reparse point.

Arguments:

    hSourceFile - Provides a handle to the source file.

    hDestinationFile - Provides a handle to the destination file.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
   NTSTATUS Status;
   IO_STATUS_BLOCK IoStatusBlock;
   PUCHAR ReparseBuffer;
   PREPARSE_DATA_BUFFER ReparseBufferHeader;

   //
   //  Allocate the buffer to set the reparse point.
   //

   ReparseBuffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
   if ( ReparseBuffer == NULL ) {
       BaseSetLastNTError(STATUS_NO_MEMORY);
       return FALSE;
   }

   //
   // Get the reparse point.
   //

   Status = NtFsControlFile(
                hSourceFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                FSCTL_GET_REPARSE_POINT,
                NULL,                                //  Input buffer
                0,                                   //  Input buffer length
                ReparseBuffer,                       //  Output buffer
                MAXIMUM_REPARSE_DATA_BUFFER_SIZE     //  Output buffer length
                );

   if ( !NT_SUCCESS( Status ) ) {
       RtlFreeHeap(RtlProcessHeap(), 0, ReparseBuffer);
       BaseSetLastNTError(Status);
       return FALSE;
       }

   //
   // Decode the reparse point buffer.
   //

   ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;

   //
   // Set the reparse point.
   //

   Status = NtFsControlFile(
                hDestinationFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                FSCTL_SET_REPARSE_POINT,
                ReparseBuffer,
                FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) + ReparseBufferHeader->ReparseDataLength,
                NULL,
                0
                );

   RtlFreeHeap(RtlProcessHeap(), 0, ReparseBuffer);

   if ( !NT_SUCCESS( Status ) ) {
       BaseSetLastNTError(Status);
       return FALSE;
       }

   return TRUE;
}


DWORD
WINAPI
CopyNameGraftNow(
    HANDLE hSourceFile,
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    ULONG CreateOptions,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    LPBOOL pbCancel OPTIONAL,
    LPDWORD lpCopyFlags
    )

/*++

Routine Description:

    This is an internal routine that copies a name grafting file/directory preserving
    its characteristics.

Arguments:

    hSourceFile - Provides a handle to the source file.
    
    lpExistingFileName - Provides the name of the existing, source file.

    lpNewFileName - Provides a name for the target file/stream. This must not
        be a UNC path name.

    lpProgressRoutine - Optionally supplies the address of a callback routine
        to be called as the copy operation progresses.

    lpData - Optionally supplies a context to be passed to the progress callback
        routine.

    pbCancel - Optionally supplies the address of a boolean to be set to TRUE
        if the caller would like the copy to abort.

    lpCopyFlags - Provides flags that modify how the copy is to proceed.  See
        CopyFileEx for details.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{   // CopyNameGraftNow

    NTSTATUS Status;
    DWORD ReturnValue = FALSE;
    HANDLE DestFile = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK IoStatusBlock;
    PREPARSE_DATA_BUFFER ReparseBufferHeader;
    PUCHAR ReparseBuffer = NULL;
    FILE_BASIC_INFORMATION BasicInformation;
    FILE_STANDARD_INFORMATION StandardInformation;
    COPYFILE_CONTEXT CfContext;
    UNICODE_STRING      SourceFileName;
    UNICODE_STRING      DestFileName;
    PVOID               SourceFileNameBuffer = NULL;
    PVOID               DestFileNameBuffer = NULL;
    BOOL TranslationStatus;
    BOOL b;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatus;

    //
    // Set up the context if appropriate.
    //

    RtlZeroMemory(&StandardInformation, sizeof(StandardInformation));
    if ( ARGUMENT_PRESENT(lpProgressRoutine) || ARGUMENT_PRESENT(pbCancel) ) {

        CfContext.TotalFileSize = StandardInformation.EndOfFile;
        CfContext.TotalBytesTransferred.QuadPart = 0;
        CfContext.dwStreamNumber = 0;
        CfContext.lpCancel = pbCancel;
        CfContext.lpData = lpData;
        CfContext.lpProgressRoutine = lpProgressRoutine;
    }

    //
    // Allocate the buffer to set the reparse point.
    //

    ReparseBuffer = RtlAllocateHeap( 
                        RtlProcessHeap(), 
                        MAKE_TAG( TMP_TAG ), 
                        MAXIMUM_REPARSE_DATA_BUFFER_SIZE
                        );
    if ( ReparseBuffer == NULL) {
        BaseSetLastNTError(STATUS_NO_MEMORY);
        return FALSE;
        }

    try {
        //
        // Translate both names.
        //

        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                lpExistingFileName,
                                &SourceFileName,
                                NULL,
                                NULL
                                );

        if ( !TranslationStatus ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            DestFile = INVALID_HANDLE_VALUE;
            leave;
        }
        SourceFileNameBuffer = SourceFileName.Buffer;

        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                lpNewFileName,
                                &DestFileName,
                                NULL,
                                NULL
                                );

        if ( !TranslationStatus ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            DestFile = INVALID_HANDLE_VALUE;
            leave;
        }
        DestFileNameBuffer = DestFileName.Buffer;
     
        //
        // Verify that the source and target are different.
        //
   
        if ( RtlEqualUnicodeString(&SourceFileName, &DestFileName, TRUE) ) {
            //
            // Do nothing. Source and target are the same.
            //
   
            DestFile = INVALID_HANDLE_VALUE;
            leave;
        }
   
        //
        // Open the destination.
        //

        InitializeObjectAttributes(
            &Obja,
            &DestFileName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status = NtCreateFile( &DestFile,
                               GENERIC_READ | GENERIC_WRITE,
                               &Obja,
                               &IoStatus,
                               NULL,
                               0,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               (*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS) ? FILE_CREATE : FILE_OPEN_IF,
                               FILE_OPEN_REPARSE_POINT | CreateOptions,
                               NULL,
                               0 );
        if( !NT_SUCCESS(Status) ) {
            DestFile = INVALID_HANDLE_VALUE;
            BaseSetLastNTError(Status);
            leave;
        }
                        
        //
        // We now have the handle to the destination.
        // We get and set the corresponding reparse point.
        //

        Status = NtFsControlFile(
                     hSourceFile,
                     NULL,
                     NULL,
                     NULL,
                     &IoStatusBlock,
                     FSCTL_GET_REPARSE_POINT,
                     NULL,                                //  Input buffer
                     0,                                   //  Input buffer length
                     ReparseBuffer,                       //  Output buffer
                     MAXIMUM_REPARSE_DATA_BUFFER_SIZE     //  Output buffer length
                     );

        if ( !NT_SUCCESS( Status ) ) {
            BaseSetLastNTError(Status);
            leave;
        }

        //
        // Defensive sanity check. The reparse buffer should be name grafting.
        //

        ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;
        if ( ReparseBufferHeader->ReparseTag != IO_REPARSE_TAG_MOUNT_POINT ) {
            BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
            leave;
        }

        //
        // Determine whether the sourse is a volume mount point.
        //

        if ( MOUNTMGR_IS_VOLUME_NAME(&SourceFileName) ) {
            //
            // Set the volume mount point and be done.
            //

            b = SetVolumeMountPointW(
                    lpNewFileName, 
                    ReparseBufferHeader->MountPointReparseBuffer.PathBuffer
                    );
            if ( !b ) {
                leave;
                }
            }
        else {
            //
            // Set the reparse point of type name junction.
            //
   
            Status = NtFsControlFile(
                         DestFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         FSCTL_SET_REPARSE_POINT,
                         ReparseBuffer,
                         FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) + ReparseBufferHeader->ReparseDataLength,
                         NULL,
                         0
                         );
            }

        if ( !(*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS) &&
             ((Status == STATUS_EAS_NOT_SUPPORTED) ||
              (Status == STATUS_IO_REPARSE_TAG_MISMATCH)) ) {
            //
            // In either of these error conditions, the correct behavior is to
            // first delete the destination file and then copy the name graft.
            //
            // Re-open the destination for the deletion without inhibiting the
            // reparse behavior.
            //

            BOOL DeleteStatus = FALSE;

            CloseHandle(DestFile);
            DestFile = INVALID_HANDLE_VALUE;

            DeleteStatus = DeleteFileW(
                               lpNewFileName
                               );

            if ( !DeleteStatus ) {
                leave;
                }

            //
            // Create the destination name graft. 
            // Notice that either a file or a directory may be created.
            //

            Status = NtCreateFile( &DestFile,
                                   GENERIC_READ | GENERIC_WRITE,
                                   &Obja,
                                   &IoStatus,
                                   NULL,
                                   0,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   FILE_CREATE,
                                   FILE_OPEN_REPARSE_POINT | CreateOptions,
                                   NULL,
                                   0 );
            if( !NT_SUCCESS( Status )) {
                BaseSetLastNTError( Status );
                leave;
            }

            //
            // Set the reparse point.
            //

            Status = NtFsControlFile(
                         DestFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         FSCTL_SET_REPARSE_POINT,
                         ReparseBuffer,
                         FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) + ReparseBufferHeader->ReparseDataLength,
                         NULL,
                         0
                         );
        }   // if ( !(*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS) ...

        //
        // Close the destination file and return appropriatelly.
        //

        if ( !NT_SUCCESS( Status ) ) {
            BaseSetLastNTError(Status);
            leave;
            }

        //
        // The name graft was copied. Set the last write time for the file
        // so that it matches the input file.
        //

        Status = NtQueryInformationFile(
                     hSourceFile,
                     &IoStatusBlock,
                     (PVOID) &BasicInformation,
                     sizeof(BasicInformation),
                     FileBasicInformation
                     );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            leave;
        }

        BasicInformation.CreationTime.QuadPart = 0;
        BasicInformation.LastAccessTime.QuadPart = 0;
        BasicInformation.FileAttributes = 0;

        //
        // If the time cannot be set for whatever reason, we still return
        // TRUE.
        //

        Status = NtSetInformationFile(
                     DestFile,
                     &IoStatusBlock,
                     &BasicInformation,
                     sizeof(BasicInformation),
                     FileBasicInformation
                     );

        if ( Status == STATUS_SHARING_VIOLATION ) {

            //
            // IBM PC Lan Program (and other MS-NET servers) return
            // STATUS_SHARING_VIOLATION if an application attempts to perform
            // an NtSetInformationFile on a file handle opened for GENERIC_READ
            // or GENERIC_WRITE.
            //
            // If we get a STATUS_SHARING_VIOLATION on this API we want to:
            //
            //   1) Close the handle to the destination
            //   2) Re-open the file for FILE_WRITE_ATTRIBUTES
            //   3) Re-try the operation.
            //

            CloseHandle(DestFile);

            //
            // Re-Open the destination file inhibiting the reparse behavior as
            // we know that it is a symbolic link.  Please note that we do this
            // using the CreateFileW API.  The CreateFileW API allows you to
            // pass NT native desired access flags, even though it is not
            // documented to work in this manner.
            //

            Status = NtCreateFile( &DestFile,
                                   FILE_WRITE_ATTRIBUTES,
                                   &Obja,
                                   &IoStatus,
                                   NULL,
                                   0,
                                   0,
                                   FILE_OPEN,
                                   FILE_OPEN_REPARSE_POINT | CreateOptions,
                                   NULL,
                                   0 );

            if ( NT_SUCCESS( Status )) {

                //
                // If the open succeeded, we update the file information on
                // the new file.
                //
                // Note that we ignore any errors from this point on.
                //

                Status = NtSetInformationFile(
                             DestFile,
                             &IoStatusBlock,
                             &BasicInformation,
                             sizeof(BasicInformation),
                             FileBasicInformation
                             );

            }
        }

        ReturnValue = TRUE;

    } finally {
        if( INVALID_HANDLE_VALUE != DestFile )
            CloseHandle( DestFile );
        RtlFreeHeap( RtlProcessHeap(), 0, SourceFileNameBuffer );
        RtlFreeHeap( RtlProcessHeap(), 0, DestFileNameBuffer );
        RtlFreeHeap(RtlProcessHeap(), 0, ReparseBuffer);
    }

    return ReturnValue;
}


BOOL
WINAPI
CopyFileA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    BOOL bFailIfExists
    )

/*++

Routine Description:

    ANSI thunk to CopyFileW

--*/

{
    PUNICODE_STRING StaticUnicode;
    UNICODE_STRING DynamicUnicode;
    BOOL b;

    StaticUnicode = Basep8BitStringToStaticUnicodeString( lpExistingFileName );
    if (StaticUnicode == NULL) {
        return FALSE;
    }

    if (!Basep8BitStringToDynamicUnicodeString( &DynamicUnicode, lpNewFileName )) {
        return FALSE;
    }

    b = CopyFileExW(
            (LPCWSTR)StaticUnicode->Buffer,
            (LPCWSTR)DynamicUnicode.Buffer,
            (LPPROGRESS_ROUTINE)NULL,
            (LPVOID)NULL,
            (LPBOOL)NULL,
            bFailIfExists ? COPY_FILE_FAIL_IF_EXISTS : 0
            );

    RtlFreeUnicodeString(&DynamicUnicode);

    return b;
}

BOOL
WINAPI
CopyFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    BOOL bFailIfExists
    )

/*++

Routine Description:

    A file, its extended attributes, alternate data streams, and any other
    attributes can be copied using CopyFile.

Arguments:

    lpExistingFileName - Supplies the name of an existing file that is to be
        copied.

    lpNewFileName - Supplies the name where a copy of the existing
        files data and attributes are to be stored.

    bFailIfExists - Supplies a flag that indicates how this operation is
        to proceed if the specified new file already exists.  A value of
        TRUE specifies that this call is to fail.  A value of FALSE
        causes the call to the function to succeed whether or not the
        specified new file exists.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    BOOL b;

    b = CopyFileExW(
            lpExistingFileName,
            lpNewFileName,
            (LPPROGRESS_ROUTINE)NULL,
            (LPVOID)NULL,
            (LPBOOL)NULL,
            bFailIfExists ? COPY_FILE_FAIL_IF_EXISTS : 0
            );

    return b;
}

BOOL
WINAPI
CopyFileExA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    LPBOOL pbCancel OPTIONAL,
    DWORD dwCopyFlags
    )

/*++

Routine Description:

    ANSI thunk to CopyFileExW

--*/

{
    PUNICODE_STRING StaticUnicode;
    UNICODE_STRING DynamicUnicode;
    BOOL b;

    StaticUnicode = Basep8BitStringToStaticUnicodeString( lpExistingFileName );
    if (StaticUnicode == NULL) {
        return FALSE;
    }

    if (!Basep8BitStringToDynamicUnicodeString( &DynamicUnicode, lpNewFileName )) {
        return FALSE;
    }

    b = CopyFileExW(
            (LPCWSTR)StaticUnicode->Buffer,
            (LPCWSTR)DynamicUnicode.Buffer,
            lpProgressRoutine,
            lpData,
            pbCancel,
            dwCopyFlags
            );

    RtlFreeUnicodeString(&DynamicUnicode);

    return b;
}





#define COPY_FILE_VALID_FLAGS (COPY_FILE_FAIL_IF_EXISTS | \
                               COPY_FILE_RESTARTABLE    | \
                               COPY_FILE_OPEN_SOURCE_FOR_WRITE | \
                               COPY_FILE_ALLOW_DECRYPTED_DESTINATION)




NTSTATUS
BasepProcessNameGrafting( HANDLE SourceFile,
                          PBOOL IsNameGrafting,
                          PBOOL bCopyRawSourceFile,
                          PBOOL bOpenFilesAsReparsePoint,
                          PFILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation )
/*++

Routine Description:

    During CopyFile, check to see if the source is a symlink which
    requires special processing during copy.

Arguments:

    SourceFile - Handle for the source of the copy.

    IsNameGrafting - If true on return, the source file is grafted.

    bCopyRawSourceFile - If true on return, the source file needn't be
        reopened.  If false, the file should be reopened without the
        FILE_OPEN_REPARSE_POINT flag.

    bOpenFilesAsReparsePoint - If true on return, source/dest named
        streams should be opened/created with FILE_OPEN_REPARSE_POINT
        specified.

    FileTagInformation - Pointer to location to hold the results of
        NtQueryInformationFile(FileAttributeTagInformation).

Return Value:

    NTSTATUS

--*/


{
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS Status = STATUS_SUCCESS;

    Status = NtQueryInformationFile(
                SourceFile,
                &IoStatus,
                (PVOID) FileTagInformation,
                sizeof(*FileTagInformation),
                FileAttributeTagInformation
                );

    if ( !NT_SUCCESS(Status) ) {
        //
        //  Not all File Systems implement all information classes.
        //  The value STATUS_INVALID_PARAMETER is returned when a non-supported
        //  information class is requested to a back-level File System. As all
        //  the parameters to NtQueryInformationFile are correct, we can infer
        //  in this case that we found a back-level system.
        //

        if ( (Status != STATUS_INVALID_PARAMETER) &&
             (Status != STATUS_NOT_IMPLEMENTED) ) {
            return( Status );
        }
        Status = STATUS_SUCCESS;

        //
        //  If FileAttributeTagInformation is not supported, we assume that
        //  the file at hand is not a reparse point nor a symbolic link.
        //  The copy of these files is the same as the raw copy of a file.
        //  The target file is opened without inhibiting the reparse point
        //  behavior.
        //

        *bCopyRawSourceFile = TRUE;
    } else {
       //
       //  The source file is opened and the file system supports the
       //  FileAttributeTagInformation information class.
       //

       if ( FileTagInformation->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) {
           //
           //  We have a reparse point at hand.
           //

           if ( FileTagInformation->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT ) {
               //
               //  We found a name grafting operation.
               //

               *IsNameGrafting = TRUE;
           }

       } else {
           //
           //  We have a valid handle.
           //  The underlying file system supports reparse points.
           //  The source file is not a reparse point.
           //  This is the case of a normal file in NT 5.0.
           //  The SourceFile handle can be used for the copy. The copy of
           //  these files is the same as the raw copy of a reparse point.
           //  The target file is opened without inhibiting the reparse
           //  point behavior.
           //

           *bCopyRawSourceFile = TRUE;
       }
    }

    return( Status );
}



BOOL
BasepCopySecurityInformation( LPCWSTR lpExistingFileName,
                              HANDLE SourceFile,
                              ACCESS_MASK SourceFileAccess,
                              LPCWSTR lpNewFileName,
                              HANDLE DestFile,
                              ACCESS_MASK DestFileAccess,
                              SECURITY_INFORMATION SecurityInformation,
                              LPCOPYFILE_CONTEXT Context,
                              DWORD DestFileFsAttributes,
                              PBOOL Canceled,
                              BOOL  CopyCreatorOwnerAce );

BOOL
BasepCopyFileCallback( BOOL ContinueByDefault,
                       DWORD Win32ErrorOnStopOrCancel,
                       LPCOPYFILE_CONTEXT Context,
                       PLARGE_INTEGER StreamBytesCopied OPTIONAL,
                       DWORD CallbackReason,
                       HANDLE SourceFile,
                       HANDLE DestFile,
                       OPTIONAL PBOOL Canceled );



BOOL
BasepCopyFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    LPBOOL pbCancel OPTIONAL,
    DWORD dwCopyFlags,
    DWORD dwPrivCopyFlags,  // From PrivCopyFileExW
    LPHANDLE phSource,
    LPHANDLE phDest
    )
{
    HANDLE SourceFile = INVALID_HANDLE_VALUE;
    HANDLE DestFile = INVALID_HANDLE_VALUE;
    DWORD b = FALSE;
    BOOL IsNameGrafting = FALSE;
    BOOL bCopyRawSourceFile = FALSE;
    BOOL bOpenFilesAsReparsePoint = FALSE;
    ULONG CopySize;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    FILE_STANDARD_INFORMATION FileInformation;
    FILE_BASIC_INFORMATION BasicInformation;
    PFILE_STREAM_INFORMATION StreamInfo;
    PFILE_STREAM_INFORMATION StreamInfoBase = NULL;
    UNICODE_STRING StreamName;
    HANDLE OutputStream;
    HANDLE StreamHandle;
    ULONG StreamInfoSize;
    COPYFILE_CONTEXT CfContext;
    LPCOPYFILE_CONTEXT CopyFileContext = NULL;
    RESTART_STATE RestartState;
    DWORD SourceFileAttributes = 0;
    DWORD FlagsAndAttributes = 0;
    DWORD FileFlagBackupSemantics = 0;
    DWORD DestFileFsAttributes = 0;
    DWORD SourceFileAccessDefault;
    DWORD SourceFileAccess = 0;
    DWORD SourceFileFlagsAndAttributes = 0;
    DWORD SourceFileSharing = 0;
    DWORD SourceFileSharingDefault = 0;
    BOOL  CheckedForNameGrafting = FALSE;
    FILE_ATTRIBUTE_TAG_INFORMATION FileTagInformation;

    //
    // Ensure that only valid flags were passed.
    //

    if ( dwCopyFlags & ~COPY_FILE_VALID_FLAGS ) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return FALSE;
    }

    if ( dwPrivCopyFlags & ~PRIVCOPY_FILE_VALID_FLAGS ) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return FALSE;
    }

    // Make sure the copy_file and privcopy_file flags don't overlap
    // in winbase.w.
    ASSERT( (PRIVCOPY_FILE_VALID_FLAGS & COPY_FILE_VALID_FLAGS) == 0 );
    dwCopyFlags |= dwPrivCopyFlags;

    try {

        //
        //  We first establish whether we are copying a reparse point:
        //  (1) obtain a handle inhibiting the reparse point behavior
        //  (2) establish whether a symbolic link was found
        //  (3) establish whether a reparse point that is not a symbolic link
        //      is to be copied in raw format or re-enabling the reparse point
        //      behavior
        //

        // Determine if backup-intent should be set.
        if( (PRIVCOPY_FILE_DIRECTORY|PRIVCOPY_FILE_BACKUP_SEMANTICS) & dwCopyFlags ) {
            FileFlagBackupSemantics = FILE_FLAG_BACKUP_SEMANTICS;
        }

        SourceFileAccessDefault = GENERIC_READ;
        SourceFileAccessDefault |= (dwCopyFlags & COPY_FILE_OPEN_SOURCE_FOR_WRITE) ? GENERIC_WRITE : 0;
        SourceFileAccessDefault |= (dwCopyFlags & PRIVCOPY_FILE_SACL) ? ACCESS_SYSTEM_SECURITY : 0;

        SourceFileFlagsAndAttributes = FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_SEQUENTIAL_SCAN | FileFlagBackupSemantics;
        CheckedForNameGrafting = FALSE;
        SourceFileSharingDefault = FILE_SHARE_READ;

retry_open_SourceFile:

        SourceFileAccess = SourceFileAccessDefault;
        SourceFileSharing = SourceFileSharingDefault;

        while( TRUE ) {

            SourceFile = CreateFileW(
                            lpExistingFileName,
                            SourceFileAccess,
                            SourceFileSharing,
                            NULL,
                            OPEN_EXISTING,
                            SourceFileFlagsAndAttributes,
                            NULL
                            );

            if ( SourceFile == INVALID_HANDLE_VALUE ) {

                // If we tried to get ACCESS_SYSTEM_SECURITY access, that
                // might cause an access or privilege error.
                if( ( GetLastError() == ERROR_PRIVILEGE_NOT_HELD
                      ||
                      GetLastError() == ERROR_ACCESS_DENIED
                    )
                    &&
                    (SourceFileAccess & ACCESS_SYSTEM_SECURITY) ) {

                    // Turn it off
                    SourceFileAccess &= ~ACCESS_SYSTEM_SECURITY;
                }


                // Maybe we should stop requesting write access (done for
                // COPYFILE_OPEN_SOURCE_FOR_WRITE
                else if( ( GetLastError() == ERROR_ACCESS_DENIED ||
                           GetLastError() == ERROR_SHARING_VIOLATION ) &&
                         (GENERIC_WRITE & SourceFileAccess) ) {

                    // Turn it off, but if originally requested,
                    // turn access_system_security back on.
                    SourceFileAccess &= ~GENERIC_WRITE;

                    if( SourceFileAccessDefault & ACCESS_SYSTEM_SECURITY ) {
                        SourceFileAccess |= ACCESS_SYSTEM_SECURITY;
                    }
                }

                // Try sharing for writing.
                else if( !(FILE_SHARE_WRITE & SourceFileSharing) ) {
                    // Add write-sharing
                    SourceFileSharing |= FILE_SHARE_WRITE;

                    // Start back over wrt the access flags
                    SourceFileAccess = SourceFileAccessDefault;
                }

                //
                //  There is the case when we still do not get the file opened and we
                //  do want to proceed with the copy. Pre NT 5.0 systems do not support
                //  FILE_FLAG_OPEN_REPARSE_POINT. If this happens, by initialization we
                //  have that:
                //        IsNameGrafting            is FALSE  and
                //        bCopyRawSourceFile        is FALSE  and
                //        bOpenFilesAsReparsePoint  is FALSE
                //

                else if( FILE_FLAG_OPEN_REPARSE_POINT & SourceFileFlagsAndAttributes ) {
                    // Turn off open-reparse
                    SourceFileFlagsAndAttributes &= ~FILE_FLAG_OPEN_REPARSE_POINT;

                    // Reset the access & sharing back to default
                    SourceFileAccess = SourceFileAccessDefault;
                    SourceFileSharing = SourceFileSharingDefault;
                }


                // Otherwise there's nothing more we can try.
                else {
                    leave;
                }


            }   // if ( SourceFile == INVALID_HANDLE_VALUE )

            // We've opened the source file.  If we haven't yet checked for
            // name grafting (symbolic links), do so now.

            else if( !CheckedForNameGrafting ) {

                CheckedForNameGrafting = TRUE;

                //
                //  Find out whether the file is a symbolic link and whether a reparse
                //  point can be copied with the reparse behavior inhibited.
                //

                Status = BasepProcessNameGrafting( SourceFile,
                                                   &IsNameGrafting,
                                                   &bCopyRawSourceFile,
                                                   &bOpenFilesAsReparsePoint,
                                                   &FileTagInformation );
                if( !NT_SUCCESS(Status) ) {
                    CloseHandle( SourceFile );
                    SourceFile = INVALID_HANDLE_VALUE;
                    BaseSetLastNTError(Status);
                    leave;
                }

                if ( IsNameGrafting ) {
                    //
                    //  Do now the copy of a name grafting file/directory.
                    //

                    Status = CopyNameGraftNow(
                                 SourceFile,
                                 lpExistingFileName,
                                 lpNewFileName,
                                 (PRIVCOPY_FILE_DIRECTORY & dwPrivCopyFlags)
                                     ? (FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT)
                                     : 0,
                                 lpProgressRoutine,
                                 lpData,
                                 pbCancel,
                                 &dwCopyFlags
                                 );

                    CloseHandle(SourceFile);
                    SourceFile = INVALID_HANDLE_VALUE;

                    if( !Status ) {
                        b = FALSE;
                        leave;
                    }

                    b = TRUE;
                    leave;
                }

                // If we're doing a raw copy, we can start doing the copy with this
                // SourceFile handle.

                if ( bCopyRawSourceFile ) {
                    break; // while( TRUE )
                }

                // Otherwise, we need to reopen without FILE_FLAG_OPEN_REPARSE_POINT;
                else {
                    // Turn off open-as-reparse
                    SourceFileFlagsAndAttributes &= ~FILE_FLAG_OPEN_REPARSE_POINT;

                    CloseHandle( SourceFile );
                    SourceFile = INVALID_HANDLE_VALUE;

                    // Since SourceFileAccess & SourceFileSharing are already set,
                    // the next CreateFile attempt should succeed.
                }

            }   // else if( !CheckedForNameGrafting )

            // Otherwise, we have the file open, and we're done checking for grafting
            else {
                break;
            }

        }   // while( TRUE )


        //
        //  Size the source file to determine how much data is to be copied
        //

        Status = NtQueryInformationFile(
                    SourceFile,
                    &IoStatus,
                    (PVOID) &FileInformation,
                    sizeof(FileInformation),
                    FileStandardInformation
                    );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            leave;
        }

        //
        //  Get the timestamp info as well.
        //

        Status = NtQueryInformationFile(
                    SourceFile,
                    &IoStatus,
                    (PVOID) &BasicInformation,
                    sizeof(BasicInformation),
                    FileBasicInformation
                    );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            leave;
        }

        SourceFileAttributes = BasicInformation.FileAttributes; // Cache for later use

        //
        // Set up the context if appropriate.
        //

        if ( ARGUMENT_PRESENT(lpProgressRoutine) || ARGUMENT_PRESENT(pbCancel) ) {

            CfContext.TotalFileSize = FileInformation.EndOfFile;
            CfContext.TotalBytesTransferred.QuadPart = 0;
            CfContext.dwStreamNumber = 0;
            CfContext.lpCancel = pbCancel;
            CfContext.lpData = lpData;
            CfContext.lpProgressRoutine = lpProgressRoutine;
            CopyFileContext = &CfContext;
        }

        //
        //  Obtain the full set of streams we have to copy.  Since the Io subsystem does
        //  not provide us a way to find out how much space this information will take,
        //  we must iterate the call, doubling the buffer size upon each failure.
        //
        //  If the underlying file system does not support stream enumeration, we end up
        //  with a NULL buffer.  This is acceptable since we have at least a default
        //  data stream.
        //
        //  We also allocate one more character than necessary since we use the returned
        //  stream names in place when calling BaseCopyStream and we must NUL-terminate
        //  the names
        //

        StreamInfoSize = 4096;
        do {
            StreamInfoBase = RtlAllocateHeap( RtlProcessHeap(),
                                              MAKE_TAG( TMP_TAG ),
                                              StreamInfoSize );

            if ( !StreamInfoBase ) {
                BaseSetLastNTError( STATUS_NO_MEMORY );
                leave;
            }

            Status = NtQueryInformationFile(
                        SourceFile,
                        &IoStatus,
                        (PVOID) StreamInfoBase,
                        StreamInfoSize - sizeof( WCHAR ),
                        FileStreamInformation
                        );

            if ( !NT_SUCCESS(Status) ) {
                //
                //  We failed the call.  Free up the previous buffer and set up
                //  for another pass with a buffer twice as large
                //

                RtlFreeHeap(RtlProcessHeap(), 0, StreamInfoBase);
                StreamInfoBase = NULL;
                StreamInfoSize *= 2;
            }
            else if( IoStatus.Information == 0 ) {
                //
                // There are no streams (SourceFile must be a directory).
                //
                RtlFreeHeap(RtlProcessHeap(), 0, StreamInfoBase);
                StreamInfoBase = NULL;
            }

        } while ( Status == STATUS_BUFFER_OVERFLOW || Status == STATUS_BUFFER_TOO_SMALL );

        //
        //  If a progress routine or a restartable copy was requested, obtain the
        //  full size of the entire file, including its alternate data streams, etc.
        //

        if ( ARGUMENT_PRESENT(lpProgressRoutine) ||
             (dwCopyFlags & COPY_FILE_RESTARTABLE) ) {

            if ( dwCopyFlags & COPY_FILE_RESTARTABLE ) {

                RestartState.Type = 0x7a9b;
                RestartState.Size = sizeof( RESTART_STATE );
                RestartState.CreationTime = BasicInformation.CreationTime;
                RestartState.WriteTime = BasicInformation.LastWriteTime;
                RestartState.EndOfFile = FileInformation.EndOfFile;
                RestartState.FileSize = FileInformation.EndOfFile;
                RestartState.NumberOfStreams = 0;
                RestartState.CurrentStream = 0;
                RestartState.LastKnownGoodOffset.QuadPart = 0;
            }

            if ( StreamInfoBase != NULL ) {

                ULONGLONG TotalSize = 0;

                StreamInfo = StreamInfoBase;
                while (TRUE) {
                    //
                    // Account for the size of this stream in the overall size of
                    // the file.
                    //

                    TotalSize += StreamInfo->StreamSize.QuadPart;
                    RestartState.NumberOfStreams++;

                    if (StreamInfo->NextEntryOffset == 0) {
                        break;
                    }
                    StreamInfo = (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfo + StreamInfo->NextEntryOffset);
                }

                RestartState.FileSize.QuadPart =
                    CfContext.TotalFileSize.QuadPart = TotalSize;
                RestartState.NumberOfStreams--;
            }
        }

        //
        //  Set the Basic Info to change only the WriteTime
        //
        BasicInformation.CreationTime.QuadPart = 0;
        BasicInformation.LastAccessTime.QuadPart = 0;
        BasicInformation.FileAttributes = 0;

        //
        // Determine whether or not the copy operation should really be restartable
        // based on the actual, total file size.
        //

        if ( (dwCopyFlags & COPY_FILE_RESTARTABLE) &&
            ( RestartState.FileSize.QuadPart < (512 * 1024) ||
              (SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )) {
            dwCopyFlags &= ~COPY_FILE_RESTARTABLE;
        }

        //
        // Copy the default data stream, EAs, etc. to the output file
        //

        b = BaseCopyStream(
                lpExistingFileName,
                SourceFile,
                SourceFileAccess,
                lpNewFileName,
                NULL,
                &FileInformation.EndOfFile,
                &dwCopyFlags,
                &DestFile,
                &CopySize,
                &CopyFileContext,
                &RestartState,
                bOpenFilesAsReparsePoint,
                FileTagInformation.ReparseTag,
                &DestFileFsAttributes   // In: 0, Out: Correct value
                );

        if ( bOpenFilesAsReparsePoint &&
             !b &&
             !((GetLastError() == ERROR_FILE_EXISTS) && (dwCopyFlags & COPY_FILE_FAIL_IF_EXISTS)) ) {

            //
            //  Clean up.
            //

            if (!(SourceFileAttributes & FILE_ATTRIBUTE_READONLY)) {
                BaseMarkFileForDelete(DestFile, FILE_ATTRIBUTE_NORMAL);
            }

            if (DestFile != INVALID_HANDLE_VALUE) {
                CloseHandle( DestFile );
                DestFile = INVALID_HANDLE_VALUE;
            }

            if (SourceFileAttributes & FILE_ATTRIBUTE_READONLY) {

                //  Delete the destination file before retry
                //  Some servers (like Win9x) won't let us set file attributes
                //  on the handle we already have opened.  SetFileAttributesW
                //  can do the job nicely, so we'll call that to make sure that
                //  the read-only bit isn't set.
                //  We had to close DestFile before doing this because it was
                //  possibly opened share-exclusive.
                SetFileAttributesW(lpNewFileName, FILE_ATTRIBUTE_NORMAL);
                (void) DeleteFileW(lpNewFileName);
            }

            if (SourceFile != INVALID_HANDLE_VALUE) {
                CloseHandle( SourceFile );
                SourceFile = INVALID_HANDLE_VALUE;
            }

            RtlFreeHeap( RtlProcessHeap(), 0, StreamInfoBase );
            StreamInfoBase = NULL ;

            //
            //  Try again the copy operation without inhibiting the reparse
            //  behavior for the source.
            //

            SourceFileFlagsAndAttributes &= ~FILE_FLAG_OPEN_REPARSE_POINT;
            bOpenFilesAsReparsePoint = FALSE;

            //
            //  Go to re-open the source file without inhibiting the reparse
            //  point behavior and try the copy again.
            //

            goto retry_open_SourceFile;
        }

        if ( b ) {

            //
            // Attempt to determine whether or not this file has any alternate
            // data streams associated with it.  If it does, attempt to copy each
            // to the output file.  Note that the stream information may have
            // already been obtained if a progress routine was requested.
            //

            if ( StreamInfoBase != NULL ) {
                DWORD StreamCount = 0;
                BOOLEAN CheckedForStreamCapable = FALSE;
                BOOLEAN IsStreamCapable = FALSE;
                StreamInfo = StreamInfoBase;

                while (TRUE) {

                    FILE_STREAM_INFORMATION DestStreamInformation;
                    Status = STATUS_SUCCESS;

                    //
                    //  Skip the default data stream since we've already copied
                    //  it.  Alas, this code is NTFS specific and documented
                    //  nowhere in the Io spec.
                    //

                    if (StreamInfo->StreamNameLength <= sizeof(WCHAR) ||
                        StreamInfo->StreamName[1] == ':') {
                        if (StreamInfo->NextEntryOffset == 0)
                            break;      // Done with streams
                        StreamInfo = (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfo +
                                                                StreamInfo->NextEntryOffset);
                        continue;   // Move on to the next stream
                    }

                    StreamCount++;

                    if ( b == SUCCESS_RETURNED_STATE && CopyFileContext ) {
                        if ( StreamCount < RestartState.CurrentStream ) {
                            CopyFileContext->TotalBytesTransferred.QuadPart += StreamInfo->StreamSize.QuadPart;
                            }
                        else {
                            CopyFileContext->TotalBytesTransferred.QuadPart += RestartState.LastKnownGoodOffset.QuadPart;
                            }
                        }

                    //
                    // If we haven't already, verify that both the source and destination
                    // are really stream capable.
                    //

                    if( !CheckedForStreamCapable ) {

                        struct {
                            FILE_FS_ATTRIBUTE_INFORMATION Info;
                            WCHAR Buffer[ MAX_PATH ];
                        } FileFsAttrInfoBuffer;

                        CheckedForStreamCapable = TRUE;

                        // Check for the supports-streams bit in the dest filesystem.

                        Status = NtQueryVolumeInformationFile( DestFile,
                                                               &IoStatus,
                                                               &FileFsAttrInfoBuffer.Info,
                                                               sizeof(FileFsAttrInfoBuffer),
                                                               FileFsAttributeInformation );
                        if( NT_SUCCESS(Status) &&
                            (FileFsAttrInfoBuffer.Info.FileSystemAttributes & FILE_NAMED_STREAMS) ) {

                            // It seems redundant to check to see if the source is stream capable,
                            // since we already got back a successful stream enumeration, but some
                            // SMB servers (SCO VisionFS) return success but don't really support
                            // streams.
                        
                            Status = NtQueryVolumeInformationFile( SourceFile,
                                                                   &IoStatus,
                                                                   &FileFsAttrInfoBuffer.Info,
                                                                   sizeof(FileFsAttrInfoBuffer),
                                                                   FileFsAttributeInformation );
                        }


                        if( !NT_SUCCESS(Status) ||
                            !(FileFsAttrInfoBuffer.Info.FileSystemAttributes & FILE_NAMED_STREAMS) ) {

                            if( NT_SUCCESS(Status) ) {
                                Status = STATUS_NOT_SUPPORTED;
                            }

                            if( dwCopyFlags & PRIVCOPY_FILE_VALID_FLAGS ) {
                                if( !BasepCopyFileCallback( TRUE,    // Continue by default
                                                            RtlNtStatusToDosError(Status),
                                                            CopyFileContext,
                                                            NULL,
                                                            PRIVCALLBACK_STREAMS_NOT_SUPPORTED,
                                                            SourceFile,
                                                            DestFile,
                                                            NULL )) {

                                    // LastError has been set, but we need it in Status
                                    // for compatibility with the rest of this routine.
                                    PTEB Teb = NtCurrentTeb();
                                    if ( Teb ) {
                                        Status = Teb->LastStatusValue;
                                    } else {
                                        Status = STATUS_INVALID_PARAMETER;
                                    }

                                    b = FALSE;
                                } else {
                                    // Ignore the named stream loss
                                    Status = STATUS_SUCCESS;
                                }
                            } else {
                                // Ignore the named stream loss.  We'll still try to copy the 
                                // streams, though, since the target might be NT4 which didn't support
                                // the FILE_NAMED_STREAMS bit.  But since IsStreamCapable is FALSE,
                                // if there's an error, we'll ignore it.

                                Status = STATUS_SUCCESS;
                            }
                        }
                        else {
                            Status = STATUS_SUCCESS;
                            IsStreamCapable = TRUE;
                        }
                    }   // if( !CheckedForStreamCapable )


                    if ( b == TRUE ||
                        (b == SUCCESS_RETURNED_STATE &&
                         RestartState.CurrentStream == StreamCount) ) {

                        if ( b != SUCCESS_RETURNED_STATE ) {
                            RestartState.CurrentStream = StreamCount;
                            RestartState.LastKnownGoodOffset.QuadPart = 0;
                            }

                        //
                        // Build a string descriptor for the name of the stream.
                        //

                        StreamName.Buffer = &StreamInfo->StreamName[0];
                        StreamName.Length = (USHORT) StreamInfo->StreamNameLength;
                        StreamName.MaximumLength = StreamName.Length;

                        //
                        // Open the source stream.
                        //

                        InitializeObjectAttributes(
                            &ObjectAttributes,
                            &StreamName,
                            0,
                            SourceFile,
                            NULL
                            );

                        //
                        // Inhibit reparse behavior when appropriate.
                        //

                        FlagsAndAttributes = FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY;
                        if ( bOpenFilesAsReparsePoint ) {
                            FlagsAndAttributes |= FILE_OPEN_REPARSE_POINT;
                        }

                        Status = NtCreateFile(
                                    &StreamHandle,
                                    GENERIC_READ | SYNCHRONIZE,
                                    &ObjectAttributes,
                                    &IoStatus,
                                    NULL,
                                    0,
                                    FILE_SHARE_READ,
                                    FILE_OPEN,
                                    FlagsAndAttributes,
                                    NULL,
                                    0
                                    );

                        //If we got a share violation, try again with
                        // FILE_SHARE_WRITE.
                        if ( Status == STATUS_SHARING_VIOLATION ) {
                            DWORD dwShare = FILE_SHARE_READ | FILE_SHARE_WRITE;

                            Status = NtCreateFile(
                                        &StreamHandle,
                                        GENERIC_READ | SYNCHRONIZE,
                                        &ObjectAttributes,
                                        &IoStatus,
                                        NULL,
                                        0,
                                        dwShare,
                                        FILE_OPEN,
                                        FlagsAndAttributes,
                                        NULL,
                                        0
                                        );
                        }


                        if ( NT_SUCCESS(Status) ) {
                            DWORD dwCopyFlagsNamedStreams;
                            WCHAR LastChar = StreamName.Buffer[StreamName.Length / sizeof( WCHAR )];

                            StreamName.Buffer[StreamName.Length / sizeof( WCHAR )] = L'\0';

                            OutputStream = (HANDLE)NULL;

                            //
                            // For named streams, ignore the fail-if-exists flag.  If the dest
                            // file already existed at the time the copy started, then
                            // we would have failed on the copy of the unnamed stream.  So if
                            // a named stream exists, that means that it was created by some
                            // other process while we were copying the unnamed stream.  The
                            // assumption is that such a stream should be overwritten (this 
                            // scenario can occur with SFM).
                            //

                            dwCopyFlagsNamedStreams = dwCopyFlags & ~COPY_FILE_FAIL_IF_EXISTS;

                            b = BaseCopyStream(
                                    lpExistingFileName,
                                    StreamHandle,
                                    SourceFileAccess,
                                    StreamName.Buffer,
                                    DestFile,
                                    &StreamInfo->StreamSize,
                                    &dwCopyFlagsNamedStreams,
                                    &OutputStream,
                                    &CopySize,
                                    &CopyFileContext,
                                    &RestartState,
                                    bOpenFilesAsReparsePoint,
                                    FileTagInformation.ReparseTag,
                                    &DestFileFsAttributes   // Set by first call to BaseCopyStream
                                    );
                            
                            StreamName.Buffer[StreamName.Length / sizeof( WCHAR )] = LastChar;
                            
                            NtClose(StreamHandle);
                            if ( OutputStream ) {

                                //
                                //  We set the last write time on all streams
                                //  since there is a problem with RDR caching
                                //  open handles and closing them out of order.
                                //

                                if ( b ) {
                                    Status = NtSetInformationFile(
                                                OutputStream,
                                                &IoStatus,
                                                &BasicInformation,
                                                sizeof(BasicInformation),
                                                FileBasicInformation
                                                );
                                }
                                NtClose(OutputStream);
                            }

                        }   // Status = NtCreateFile; if( NT_SUCCESS(Status) )
                    }   // if ( b == TRUE || ...

                    if ( !NT_SUCCESS(Status) ) {
                        b = FALSE;
                        BaseSetLastNTError(Status);
                    }

                    if ( !b ) {

                        // If the target is known to be capable of multi-stream files,
                        // then this is a fatal error.  Otherwise we'll ignore it.

                        if( IsStreamCapable ) {
                            BaseMarkFileForDelete(DestFile,0);
                            break;  // while( TRUE )
                        } else {
                            Status = STATUS_SUCCESS;
                            b = TRUE;
                        }
                    }

                    if (StreamInfo->NextEntryOffset == 0) {
                        break;
                    }

                    StreamInfo =
                        (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfo +
                                                   StreamInfo->NextEntryOffset);
                }   // while (TRUE)
            }   // if ( StreamInfoBase != NULL )
        }   // b = BaseCopyStream; if ( b ) ...


        //
        //  If the copy operation was successful, and it was restartable, and the
        //  output file was large enough that it was actually copied in a
        //  restartable manner, then copy the initial part of the file to its
        //  output.
        //
        //  Restartability is accomplished by placing a restart header at the
        //  head of the default data stream.  When the copy is complete, we
        //  overwite this header with the real user data.
        //

        if ( b && (dwCopyFlags & COPY_FILE_RESTARTABLE) ) {

            DWORD BytesToRead, BytesRead;
            DWORD BytesWritten;
            FILE_END_OF_FILE_INFORMATION EofInformation;

            SetFilePointer( SourceFile, 0, NULL, FILE_BEGIN );
            SetFilePointer( DestFile, 0, NULL, FILE_BEGIN );

            BytesToRead = sizeof(RESTART_STATE);
            if ( FileInformation.EndOfFile.QuadPart < sizeof(RESTART_STATE) ) {
                BytesToRead = FileInformation.EndOfFile.LowPart;
            }

            //
            //  Grab true data from the source stream
            //

            b = ReadFile(
                    SourceFile,
                    &RestartState,
                    BytesToRead,
                    &BytesRead,
                    NULL
                    );

            if ( b && (BytesRead == BytesToRead) ) {

                //
                //  Overwrite the restart header in the destination.
                //  After this point, the copy is no longer restartable
                //

                b = WriteFile(
                        DestFile,
                        &RestartState,
                        BytesRead,
                        &BytesWritten,
                        NULL
                        );

                if ( b && (BytesRead == BytesWritten) ) {
                    if ( BytesRead < sizeof(RESTART_STATE) ) {
                        EofInformation.EndOfFile.QuadPart = BytesWritten;
                        Status = NtSetInformationFile(
                                    DestFile,
                                    &IoStatus,
                                    &EofInformation,
                                    sizeof(EofInformation),
                                    FileEndOfFileInformation
                                    );
                        if ( !NT_SUCCESS(Status) ) {
                            BaseMarkFileForDelete(DestFile,0);
                            b = FALSE;
                        }
                    }
                } else {
                    BaseMarkFileForDelete(DestFile,0);
                    b = FALSE;
                }
            } else {
                BaseMarkFileForDelete(DestFile,0);
                b = FALSE;
            }
        }

        //
        // If the copy operation was successful, set the last write time for the
        // default steam so that it matches the input file.
        //

        if ( b ) {
            Status = NtSetInformationFile(
                DestFile,
                &IoStatus,
                &BasicInformation,
                sizeof(BasicInformation),
                FileBasicInformation
                );

            if ( Status == STATUS_SHARING_VIOLATION ) {

                //
                // IBM PC Lan Program (and other MS-NET servers) return
                // STATUS_SHARING_VIOLATION if an application attempts to perform
                // an NtSetInformationFile on a file handle opened for GENERIC_READ
                // or GENERIC_WRITE.
                //
                // If we get a STATUS_SHARING_VIOLATION on this API we want to:
                //
                //   1) Close the handle to the destination
                //   2) Re-open the file for FILE_WRITE_ATTRIBUTES
                //   3) Re-try the operation.
                //

                CloseHandle(DestFile);
                DestFile = INVALID_HANDLE_VALUE;

                //
                //  Re-Open the destination file.  Please note that we do this
                //  using the CreateFileW API.  The CreateFileW API allows you to
                //  pass NT native desired access flags, even though it is not
                //  documented to work in this manner.
                //
                //  Inhibit reparse behavior when appropriate.
                //

                FlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;
                if ( bOpenFilesAsReparsePoint ) {
                    FlagsAndAttributes |= FILE_FLAG_OPEN_REPARSE_POINT;
                }

                DestFile = CreateFileW(
                            lpNewFileName,
                            FILE_WRITE_ATTRIBUTES,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FlagsAndAttributes | FileFlagBackupSemantics,
                            NULL
                            );

                if ( DestFile != INVALID_HANDLE_VALUE ) {

                    //
                    //  If the open succeeded, we update the file information on
                    //  the new file.
                    //
                    //  Note that we ignore any errors from this point on.
                    //

                    NtSetInformationFile(
                        DestFile,
                        &IoStatus,
                        &BasicInformation,
                        sizeof(BasicInformation),
                        FileBasicInformation
                        );

                }
            }
        }

    } finally {

        *phSource = SourceFile;
        *phDest = DestFile;

        RtlFreeHeap( RtlProcessHeap(), 0, StreamInfoBase );
    }

    return b;
}

BOOL
CopyFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    LPBOOL pbCancel OPTIONAL,
    DWORD dwCopyFlags
    )

/*

Routine Description:

    A file, its extended attributes, alternate data streams, and any other
    attributes can be copied using CopyFileEx.  CopyFileEx also provides
    callbacks and cancellability.

Arguments:

    lpExistingFileName - Supplies the name of an existing file that is to be
        copied.

    lpNewFileName - Supplies the name where a copy of the existing
        files data and attributes are to be stored.

    lpProgressRoutine - Optionally supplies the address of a callback routine
        to be called as the copy operation progresses.

    lpData - Optionally supplies a context to be passed to the progress callback
        routine.

    lpCancel - Optionally supplies the address of a boolean to be set to TRUE
        if the caller would like the copy to abort.

    dwCopyFlags - Specifies flags that modify how the file is to be copied:

        COPY_FILE_FAIL_IF_EXISTS - Indicates that the copy operation should
            fail immediately if the target file already exists.

        COPY_FILE_RESTARTABLE - Indicates that the file should be copied in
            restartable mode; i.e., progress of the copy should be tracked in
            the target file in case the copy fails for some reason.  It can
            then be restarted at a later date.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

*/

{
    HANDLE DestFile = INVALID_HANDLE_VALUE;
    HANDLE SourceFile = INVALID_HANDLE_VALUE;
    BOOL b;

    try
    {
        b = BasepCopyFileExW(
                lpExistingFileName,
                lpNewFileName,
                lpProgressRoutine OPTIONAL,
                lpData OPTIONAL,
                pbCancel OPTIONAL,
                dwCopyFlags,
                0,  // PrivCopyFile flags
                &DestFile,
                &SourceFile
                );

    }
    finally
    {
        if (DestFile != INVALID_HANDLE_VALUE) {
            CloseHandle( DestFile );
        }

        if (SourceFile != INVALID_HANDLE_VALUE) {
            CloseHandle( SourceFile );
        }
    }

    return(b);
}



BOOL
PrivCopyFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    LPBOOL pbCancel OPTIONAL,
    DWORD dwCopyFlags
    )

/*

Routine Description:

    A file, its extended attributes, alternate data streams, and any other
    attributes can be copied using CopyFileEx.  CopyFileEx also provides
    callbacks and cancellability.

Arguments:

    lpExistingFileName - Supplies the name of an existing file that is to be
        copied.

    lpNewFileName - Supplies the name where a copy of the existing
        files data and attributes are to be stored.

    lpProgressRoutine - Optionally supplies the address of a callback routine
        to be called as the copy operation progresses.

    lpData - Optionally supplies a context to be passed to the progress callback
        routine.

    lpCancel - Optionally supplies the address of a boolean to be set to TRUE
        if the caller would like the copy to abort.

    dwCopyFlags - Specifies flags that modify how the file is to be copied:

        COPY_FILE_FAIL_IF_EXISTS - Indicates that the copy operation should
            fail immediately if the target file already exists.

        COPY_FILE_RESTARTABLE - Indicates that the file should be copied in
            restartable mode; i.e., progress of the copy should be tracked in
            the target file in case the copy fails for some reason.  It can
            then be restarted at a later date.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

*/

{
    HANDLE DestFile = INVALID_HANDLE_VALUE;
    HANDLE SourceFile = INVALID_HANDLE_VALUE;
    BOOL b;

    if( (dwCopyFlags & COPY_FILE_FAIL_IF_EXISTS) &&
        (dwCopyFlags & PRIVCOPY_FILE_SUPERSEDE) ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );
    }

    try
    {
        b = BasepCopyFileExW(
                lpExistingFileName,
                lpNewFileName,
                lpProgressRoutine OPTIONAL,
                lpData OPTIONAL,
                pbCancel OPTIONAL,
                dwCopyFlags & COPY_FILE_VALID_FLAGS,    // Copy flags
                dwCopyFlags & ~COPY_FILE_VALID_FLAGS,   // Priv copy flags
                &DestFile,
                &SourceFile
                );

    }
    finally
    {
        if (DestFile != INVALID_HANDLE_VALUE) {
            CloseHandle( DestFile );
        }

        if (SourceFile != INVALID_HANDLE_VALUE) {
            CloseHandle( SourceFile );
        }
    }

    return(b);
}







DWORD
BasepChecksum(
    PUSHORT Source,
    ULONG Length
    )

/*++

Routine Description:

    Compute a partial checksum on a structure.

Arguments:

    Source - Supplies a pointer to the array of words for which the
        checksum is computed.

    Length - Supplies the length of the array in words.

Return Value:

    The computed checksum value is returned as the function value.

--*/

{

    ULONG PartialSum = 0;

    //
    // Compute the word wise checksum allowing carries to occur into the
    // high order half of the checksum longword.
    //

    while (Length--) {
        PartialSum += *Source++;
        PartialSum = (PartialSum >> 16) + (PartialSum & 0xffff);
    }

    //
    // Fold final carry into a single word result and return the resultant
    // value.
    //

    return (((PartialSum >> 16) + PartialSum) & 0xffff);
}

BOOL
BasepRemoteFile(
    HANDLE SourceFile,
    HANDLE DestinationFile
    )

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    FILE_FS_DEVICE_INFORMATION DeviceInformation;

    DeviceInformation.Characteristics = 0;
    Status = NtQueryVolumeInformationFile(
                SourceFile,
                &IoStatus,
                &DeviceInformation,
                sizeof(DeviceInformation),
                FileFsDeviceInformation
                );

    if ( NT_SUCCESS(Status) &&
         (DeviceInformation.Characteristics & FILE_REMOTE_DEVICE) ) {

        return TRUE;

    }

    Status = NtQueryVolumeInformationFile(
                    DestinationFile,
                    &IoStatus,
                    &DeviceInformation,
                    sizeof(DeviceInformation),
                    FileFsDeviceInformation
                    );
    if ( NT_SUCCESS(Status) &&
         DeviceInformation.Characteristics & FILE_REMOTE_DEVICE ) {

        return TRUE;
    }

    return FALSE;
}



DWORD
WINAPI
BasepOpenRestartableFile(
            HANDLE hSourceFile,
            LPCWSTR lpNewFileName,
            PHANDLE DestFile,
            DWORD CopyFlags,
            LPRESTART_STATE lpRestartState,
            LARGE_INTEGER *lpFileSize,
            LPCOPYFILE_CONTEXT *lpCopyFileContext,
            DWORD FlagsAndAttributes,
            BOOL OpenAsReparsePoint )

{   // BasepRestartCopyFile

    LPCOPYFILE_CONTEXT Context = *lpCopyFileContext;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    HANDLE OverwriteHandle;
    IO_STATUS_BLOCK IoStatus;
    RESTART_STATE RestartState;
    DWORD b = TRUE;
    ULONG BytesRead = 0;


    try {

        //
        // Note that setting the sequential scan flag is an optimization
        // here that works because of the way that the Cache Manager on
        // the target works vis-a-vis unmapping segments of the file
        // behind write operations.  This eventually allows the restart
        // section and the end of the file to both be mapped, which is
        // the desired result.
        //
        // Inhibit reparse behavior when appropriate.
        //

        FlagsAndAttributes |= FILE_FLAG_SEQUENTIAL_SCAN;

        if ( OpenAsReparsePoint ) {
            //
            // The target has to be opened as reparse point. If
            // this fails the source is to be closed and re-opened
            // without inhibiting the reparse point behavior.
            //

            FlagsAndAttributes |= FILE_FLAG_OPEN_REPARSE_POINT;
        }

        *DestFile = CreateFileW(
                       lpNewFileName,
                       GENERIC_READ | GENERIC_WRITE | DELETE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FlagsAndAttributes,
                       hSourceFile
                       );

        if( *DestFile == INVALID_HANDLE_VALUE ) {

            // Caller should attempt to create/overwrite the dest file
            b = TRUE;
            leave;
        }

        //
        //  The target file already exists, so determine whether
        //  a restartable copy was already proceeding.  If so,
        //  then continue;  else, check to see whether or not
        //  the target file can be replaced.  If not, bail with
        //  an error, otherwise simply overwrite the output file.
        //

        b = ReadFile(
                *DestFile,
                &RestartState,
                sizeof(RESTART_STATE),
                &BytesRead,
                NULL
                );
        if ( !b || BytesRead != sizeof(RESTART_STATE) ) {

            //
            // The file could not be read, or there were not
            // enough bytes to contain a restart record.  In
            // either case, if the output file cannot be
            // replaced, simply return an error now.
            //

            if ( CopyFlags & COPY_FILE_FAIL_IF_EXISTS ) {
                SetLastError( ERROR_ALREADY_EXISTS );
                b = FALSE;  // Fatal error
                leave;
            }

            // The caller should create/overwrite the dest file.
            b = TRUE;
            CloseHandle( *DestFile );
            *DestFile = INVALID_HANDLE_VALUE;
            leave;

        }

        //
        // Check the contents of the restart state just
        // read against the known contents of what would
        // be there if this were the same copy operation.
        //

        if ( RestartState.Type != 0x7a9b ||
             RestartState.Size != sizeof(RESTART_STATE) ||
             RestartState.FileSize.QuadPart != lpRestartState->FileSize.QuadPart ||
             RestartState.EndOfFile.QuadPart != lpRestartState->EndOfFile.QuadPart ||
             RestartState.NumberOfStreams != lpRestartState->NumberOfStreams ||
             RestartState.CreationTime.QuadPart != lpRestartState->CreationTime.QuadPart ||
             RestartState.WriteTime.QuadPart != lpRestartState->WriteTime.QuadPart ||
             RestartState.Checksum != BasepChecksum((PUSHORT)&RestartState,FIELD_OFFSET(RESTART_STATE,Checksum) >> 1) ) {

            if ( CopyFlags & COPY_FILE_FAIL_IF_EXISTS ) {
                b = FALSE;  // Fatal error
                SetLastError( ERROR_ALREADY_EXISTS );
                leave;
            }

            // The caller should create/overwrite the dest file.
            b = TRUE;
            CloseHandle( *DestFile );
            *DestFile = INVALID_HANDLE_VALUE;
            leave;

        }

        //
        // A valid restart state has been found.  Copy
        // the appropriate values into the internal
        // restart state so the operation can continue
        // from there.
        //

        lpRestartState->CurrentStream = RestartState.CurrentStream;
        lpRestartState->LastKnownGoodOffset.QuadPart = RestartState.LastKnownGoodOffset.QuadPart;
        if ( !RestartState.CurrentStream ) {

            // We were in the middle of copying the unnamed data stream.

            if ( Context ) {
                Context->TotalBytesTransferred.QuadPart = RestartState.LastKnownGoodOffset.QuadPart;
            }

            // We'll leave the handle in *DestFile, and the caller and pick up the
            // copy of this stream.

            b = TRUE;

        } else {

            // We were in the middle of copying a named data stream.

            if ( Context ) {
                ULONG ReturnCode;

                Context->TotalBytesTransferred.QuadPart = lpFileSize->QuadPart;
                Context->dwStreamNumber = RestartState.CurrentStream;

                if ( Context->lpProgressRoutine ) {
                    ReturnCode = Context->lpProgressRoutine(
                                    Context->TotalFileSize,
                                    Context->TotalBytesTransferred,
                                    *lpFileSize,
                                    Context->TotalBytesTransferred,
                                    1,
                                    CALLBACK_STREAM_SWITCH,
                                    hSourceFile,
                                    *DestFile,
                                    Context->lpData
                                    );
                } else {
                    ReturnCode = PROGRESS_CONTINUE;
                }

                if ( ReturnCode == PROGRESS_CANCEL ||
                    (Context->lpCancel && *Context->lpCancel) ) {
                    BaseMarkFileForDelete(
                        *DestFile,
                        0
                        );
                    BaseSetLastNTError(STATUS_REQUEST_ABORTED);
                    b = FALSE;
                    leave;
                }

                if ( ReturnCode == PROGRESS_STOP ) {
                    BaseSetLastNTError(STATUS_REQUEST_ABORTED);
                    b = FALSE;
                    leave;
                }

                if ( ReturnCode == PROGRESS_QUIET ) {
                    Context = NULL;
                    *lpCopyFileContext = NULL;
                }
            }

            b = SUCCESS_RETURNED_STATE;

        }   // if ( !RestartState.CurrentStream ) ... else
    }
    finally {

        if( b == FALSE &&
            *DestFile != INVALID_HANDLE_VALUE ) {
            CloseHandle( *DestFile );
            *DestFile = INVALID_HANDLE_VALUE;
        }


    }

    return( b );

}





BOOL
WINAPI
BasepCopyCompression( HANDLE hSourceFile,
                      HANDLE DestFile,
                      DWORD SourceFileAttributes,
                      DWORD DestFileAttributes,
                      DWORD DestFileFsAttributes,
                      DWORD CopyFlags,
                      LPCOPYFILE_CONTEXT *lpCopyFileContext )
/*++

Routine Description:

    This is an internal routine that copies the compression state during
    a copyfile.  If the source is compressed, that same compression
    algorithm is copied to the dest.  If that fails, an attempt is made
    to set the default compression.  Depending on the copy flags, it
    may alternatively be necessary to decompress the destination.


Arguments:

    hSourceFile - Provides a handle to the source file.

    DestFile - Provides a handle to the destination file.

    SourceFileAttributes - FileBasicInformation attributes queried from the
        source file.

    DestFileAttributes - FileBasicInformation attributes for the current
        state of the destination file.

    DestFileFsAttributes - FileFsAttributeInformation.FileSystemAttributes
        for the file system of the dest file.

    CopyFlags - Provides flags that modify how the copy is to proceed.  See
        CopyFileEx for details.

    lpCopyFileContext - Provides a pointer to a pointer to the context
        information to track callbacks, file sizes, etc. across streams during
        the copy operation.


Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.  The DestFile has already been marked
        for delete.

--*/

{   // BasepCopyCompression

    IO_STATUS_BLOCK IoStatus;
    NTSTATUS Status = STATUS_SUCCESS;
    LPCOPYFILE_CONTEXT Context = *lpCopyFileContext;
    BOOL SuccessReturn = FALSE;
    BOOL Canceled = FALSE;

    try
    {
        if( !(SourceFileAttributes & FILE_ATTRIBUTE_COMPRESSED) ) {

            // The source file is not compressed.  If necessary, decompress
            // the target.

            if( (DestFileAttributes & FILE_ATTRIBUTE_COMPRESSED) &&
                (CopyFlags & PRIVCOPY_FILE_SUPERSEDE) ) {

                // The source isn't compressed, but the dest is, and we don't
                // want to acquire attributes from the dest.  So we need to manually
                // decompress it.

                ULONG CompressionType = COMPRESSION_FORMAT_NONE;

                Status = NtFsControlFile(
                             DestFile,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatus,
                             FSCTL_SET_COMPRESSION,
                             &CompressionType,                    //  Input buffer
                             sizeof(CompressionType),             //  Input buffer length
                             NULL,                                //  Output buffer
                             0                                    //  Output buffer length
                             );
                if( !NT_SUCCESS(Status) ) {
                    // See if it's OK to ignore the error
                    if( !BasepCopyFileCallback( TRUE,    // Continue by default
                                                RtlNtStatusToDosError(Status),
                                                Context,
                                                NULL,
                                                PRIVCALLBACK_COMPRESSION_NOT_SUPPORTED,
                                                hSourceFile,
                                                DestFile,
                                                &Canceled )) {


                        BaseMarkFileForDelete( DestFile, 0 );
                        BaseSetLastNTError( Status );
                        leave;
                    } else {
                        Status = STATUS_SUCCESS;
                    }
                }

            }

        }   // if( !(SourceFileAttributes & FILE_ATTRIBUTE_COMPRESSED) )

        else {

            // The source file is compressed.  Does the target filesystem
            // even support compression?

            if( !(FILE_FILE_COMPRESSION & DestFileFsAttributes) ) {

                // No, it won't be compressable.  See if it's OK to continue.

                if( !BasepCopyFileCallback( TRUE,    // Continue by default
                                            ERROR_NOT_SUPPORTED,
                                            Context,
                                            NULL,
                                            PRIVCALLBACK_COMPRESSION_NOT_SUPPORTED,
                                            hSourceFile,
                                            DestFile,
                                            &Canceled )) {

                    if( Canceled ) {
                        BaseMarkFileForDelete(
                            DestFile,
                            0 );
                    }
                    leave;
                }
            }   // if( !(FILE_FILE_COMPRESSION & *DestFileFsAttributes) )

            else {

                // Target volume supports compression.  Compress the target file if
                // it's not already.

                if( !(DestFileAttributes & FILE_ATTRIBUTE_COMPRESSED) ) {

                    USHORT CompressionType;

                    // Get the source file's compression type

                    Status = NtFsControlFile(
                                 hSourceFile,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &IoStatus,
                                 FSCTL_GET_COMPRESSION,
                                 NULL,                                //  Input buffer
                                 0,                                   //  Input buffer length
                                 &CompressionType,                    //  Output buffer
                                 sizeof(CompressionType)              //  Output buffer length
                                 );
                    if( NT_SUCCESS(Status) ) {

                        // Set the compression type on the target

                        Status = NtFsControlFile(
                                     DestFile,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &IoStatus,
                                     FSCTL_SET_COMPRESSION,
                                     &CompressionType,                    //  Input buffer
                                     sizeof(CompressionType),             //  Input buffer length
                                     NULL,                                //  Output buffer
                                     0                                    //  Output buffer length
                                     );

                        // If that didn't work, try the default compression
                        // format (maybe we're copying from uplevel to downlevel).

                        if( !NT_SUCCESS(Status) &&
                            COMPRESSION_FORMAT_DEFAULT != CompressionType ) {

                            CompressionType = COMPRESSION_FORMAT_DEFAULT;
                            Status = NtFsControlFile(
                                         DestFile,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &IoStatus,
                                         FSCTL_SET_COMPRESSION,
                                         &CompressionType,                    //  Input buffer
                                         sizeof(CompressionType),             //  Input buffer length
                                         NULL,                                //  Output buffer
                                         0                                    //  Output buffer length
                                         );
                        }
                    }   // FSCTL_GET_COMPRESSION ... if( NT_SUCCESS(Status) )

                    // If something went wrong and we couldn't compress it, there's a good
                    // chance that the caller doesn't want this to be fatal.  Ask and find
                    // out.

                    if( !NT_SUCCESS(Status) ) {
                        BOOL Canceled = FALSE;

                        if( !BasepCopyFileCallback( TRUE,    // Continue by default
                                                    RtlNtStatusToDosError(Status),
                                                    Context,
                                                    NULL,
                                                    PRIVCALLBACK_COMPRESSION_FAILED,
                                                    hSourceFile,
                                                    DestFile,
                                                    &Canceled )) {
                            if( Canceled ) {
                                BaseMarkFileForDelete(
                                    DestFile,
                                    0 );
                            }
                            leave;
                        }
                    }
                }   // if( !(DestFileAttributes & FILE_FILE_COMPRESSION) )
            }   // if( !(FILE_FILE_COMPRESSION & *DestFileFsAttributes) )
        }   // if( !(SourceFileAttributes & FILE_ATTRIBUTE_COMPRESSED) ) ... else

        SuccessReturn = TRUE;
    }
    finally
    {
    }

    return( SuccessReturn );
}



NTSTATUS
BasepCreateDispositionToWin32( DWORD CreateDisposition, DWORD *Win32CreateDisposition )

/*++
Routine Description:

    This is an internal routine used by BaseCopyStream.  It is used to translate
    from NT API CreateDisposition flags to Win32 CreateDisposition flags (this was 
    added in order to use the NT CreateDisposition in a call to DuplicateEncryptionInformation).

    This routine does the inverse of the Win32->NT mapping in CreateFile, except that there is
    no way to obtain TRUNCATE_EXISTING from an NT flag.  The FILE_SUPERSEDE and FILE_OVERWRITE
    flags are not supported by this routine.

Arguments:

    CreateDisposition - The NT CreateDisposition flags.

Returns:

    STATUS_INVALID_PARAMETER if an unsupported NT flag is passed in.
    STATUS_SUCCESS otherwise.

++*/


{
    switch ( CreateDisposition ) {

    case FILE_CREATE :
        *Win32CreateDisposition = CREATE_NEW;
        break;
    case FILE_OVERWRITE_IF:
        *Win32CreateDisposition = CREATE_ALWAYS;
        break;
    case FILE_OPEN:
        *Win32CreateDisposition = OPEN_EXISTING;
        break;
    case FILE_OPEN_IF:
        *Win32CreateDisposition = OPEN_ALWAYS;
        break;
    default :
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;

}




BOOL
CheckAllowDecryptedRemoteDestinationPolicy()

/*++

Routine Description:

    This routine is used by BasepCopyEncryption (part of CopyFile), when
    an attempt has been made to copy an encrypted file to a destination that
    for some reason can't support encryption (e.g. it's FAT, not trusted for
    delegation, NT4, etc).  By default, copyfile fails for this scenario.  The
    way to override that default is to pass the COPY_FILE_ALLOW_DECRYPTED_DESTINATION
    flag to CopyFile.  The other way to override that default (if you can't update
    your copy utilities to use the new flag), is to set the
    CopyFileAllowDecryptedRemoteDestination system policy.  This routine checks that policy.

    This routine caches the result of the registry check per process.  So an update
    to the policy may require a reboot to take effect in existing processes.

Arguments:

    None

Return Value:

    TRUE  - The decrypted destination is allowed

    FALSE - The destination may not be left decrypted

--*/


{
    // Static flags indicating if we've already been called once, and if
    // so what the answer was.  These are static so that we need to do the registry
    // call only once per process.

    static BOOL Allowed = FALSE;
    static BOOL AlreadyChecked = FALSE;

    NTSTATUS Status;
    HANDLE Key;

    BYTE QueryBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD)];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo =
        (PKEY_VALUE_PARTIAL_INFORMATION) QueryBuffer;

    ULONG ActualSize;

    const static UNICODE_STRING KeyName =
        RTL_CONSTANT_STRING( L"\\Registry\\Machine\\Software\\Policies\\Microsoft\\Windows\\System" );

    const static OBJECT_ATTRIBUTES ObjectAttributes =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&KeyName, OBJ_CASE_INSENSITIVE);

    const static UNICODE_STRING ValueName =
        RTL_CONSTANT_STRING( L"CopyFileAllowDecryptedRemoteDestination" );


    // Check to see if we've already been called once in this process.  If so, 
    // return the value that was calculated then (thus this process needs a reboot
    // to reflect a change to this policy).  Technically there's a race condition here, 
    // but assuming the registry isn't being updated during the call, each call to this
    // routine will get the same answer anyway.

    if( AlreadyChecked )
        return Allowed;

    // We need to do the check.

    // Try to open the system policy key.
    // If it doesn't exist, then we'll just fall through and return false.

    Status = NtOpenKey( &Key,
                        KEY_QUERY_VALUE,
                        (POBJECT_ATTRIBUTES) &ObjectAttributes);

    if (NT_SUCCESS(Status)) {

        // We have the system policy key.  Now try to open the value.  If it
        // doesn't exist, we'll just fall through, and return false.

        Status = NtQueryValueKey(
                    Key,
                    (PUNICODE_STRING) &ValueName,
                    KeyValuePartialInformation,
                    KeyValueInfo,
                    sizeof(QueryBuffer),
                    &ActualSize);

        if (NT_SUCCESS(Status)) {

            // The value exists.  If it's the right shape and value, then 
            // we'll allow the decrypted destination.

            if( KeyValueInfo->Type == REG_DWORD &&
                KeyValueInfo->DataLength == sizeof(DWORD) &&
                *((PDWORD) KeyValueInfo->Data) == 1) {

                Allowed = TRUE;
            }
        }

        NtClose( Key );
    }

    // Update the static so that we don't execute this code again.
    AlreadyChecked = TRUE;

    return Allowed;
}


typedef BOOL (WINAPI *ENCRYPTFILEWPTR)(LPCWSTR);
typedef BOOL (WINAPI *DECRYPTFILEWPTR)(LPCWSTR, DWORD);

BOOL
WINAPI
BasepCopyEncryption( HANDLE hSourceFile,
                     LPCWSTR lpNewFileName,
                     PHANDLE DestFile,
                     POBJECT_ATTRIBUTES Obja,
                     DWORD DestFileAccess,
                     DWORD DestFileSharing,
                     DWORD CreateDisposition,
                     DWORD CreateOptions,
                     DWORD SourceFileAttributes,
                     DWORD SourceFileAttributesMask,
                     PDWORD DestFileAttributes,
                     DWORD DestFileFsAttributes,
                     DWORD CopyFlags,
                     LPCOPYFILE_CONTEXT *lpCopyFileContext )
/*++

Routine Description:

    This is an internal routine that copies the encryption state during
    a copyfile.  Depending on the copy flags, it may be necessary to
    decompress the destination.  To encrypt/decrypt a file it is necessary
    to close the current handle, encrypt/decrypt, and reopen.

Arguments:

    hSourceFile - Provides a handle to the source file.

    lpNewFileName - Provides a name for the target file/stream.

    Obja - ObjectAttributes structure for the destination file.

    DestFileAccess - ACCESS_MASK to use when opening the dest.

    DestFileSharing - Sharing options to use when openting the dest.

    CreateDisposition - Creation/disposition options for opening the dest.

    SourceFileAttributes - FileBasicInformation attributes queried from the
        source file.

    SourceFileAttributesMask - the attributes from the source that are intended
        to be set on the dest.

    DestFileAttributes - FileBasicInformation attributes for the current
        state of the destination file.  This value is updated to reflect
        changes to the encryption state of the dest file.

    DestFileFsAttributes - FileFsAttributeInformation.FileSystemAttributes
        for the file system of the dest file.

    CopyFlags - Provides flags that modify how the copy is to proceed.  See
        CopyFileEx for details.

    lpCopyFileContext - Provides a pointer to a pointer to the context
        information to track callbacks, file sizes, etc. across streams during
        the copy operation.


Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.  The DestFile has already been marked
        for delete.

--*/

{   // BasepCopyEncryption

    NTSTATUS Status = 0;
    BOOL SuccessReturn = FALSE;
    BOOL EncryptFile = FALSE;
    BOOL DecryptFile = FALSE;
    HANDLE Advapi32 = NULL;
    BOOL RestoreReadOnly = FALSE;
    ENCRYPTFILEWPTR EncryptFileWPtr = NULL;
    DECRYPTFILEWPTR DecryptFileWPtr = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    LPCOPYFILE_CONTEXT Context = *lpCopyFileContext;
    FILE_BASIC_INFORMATION FileBasicInformationData;

    try
    {
        // Check to see if we need to do some encryption or decryption,
        // and set EncryptFile/DescryptFile bools if set.

        if( (SourceFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) &&
            (SourceFileAttributesMask & FILE_ATTRIBUTE_ENCRYPTED) &&
            !(*DestFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) ) {

            // We tried to copy over encryption, but it didn't stick:
            // *  This may be a system file, encryption is not supported on
            //    system files.
            // *  If this is a non-directory file, then encryption is not
            //    supported on the target file system.
            // *  If this is a directory file, then we must try to encrypt
            //    it manually (since we opened it, rather than creating it).
            //    It still may not be possible but we'll have to try to
            //    find out.

            if( (SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                &&
                !(*DestFileAttributes & FILE_ATTRIBUTE_SYSTEM) ) {
                EncryptFile = TRUE;
            }

        } else if( !(SourceFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) &&
                   (*DestFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) &&
                   (CopyFlags & PRIVCOPY_FILE_SUPERSEDE) ) {

            // The source is decrypted, the destination was encrypted, and the
            // caller specified that the source should be copied as-is.  So
            // we must manually decrypt the destination.  This can happen if
            // the dest file already existed and was encrypted.

            DecryptFile = TRUE;
        }


        // If we decided above to either encrypt or decrypt, then we have
        // more work to do.

        if( DecryptFile || EncryptFile ) {

            // If the destination file is read-only, we have to take it off
            // until we do the encrypt/decrypt (and restore it later).

            if( *DestFileAttributes & FILE_ATTRIBUTE_READONLY ) {

                RestoreReadOnly = TRUE;
                RtlZeroMemory(&FileBasicInformationData, sizeof(FileBasicInformationData));                
                FileBasicInformationData.FileAttributes = (*DestFileAttributes) & ~FILE_ATTRIBUTE_READONLY;

                Status = NtSetInformationFile(
                          *DestFile,
                          &IoStatusBlock,
                          &FileBasicInformationData,
                          sizeof(FileBasicInformationData),
                          FileBasicInformation
                          );
                if( !NT_SUCCESS(Status) ) {
                    BaseMarkFileForDelete( *DestFile, 0 );
                    BaseSetLastNTError(Status);
                    leave;
                }
            }

            // Close the file so that we can call EncryptFile/DecryptFile

            NtClose( *DestFile );
            *DestFile = INVALID_HANDLE_VALUE;

            // Load the EncryptFile/DecryptFile API, and make the call

            Advapi32 = LoadLibraryW(AdvapiDllString);
            if( Advapi32 == NULL ) {
                leave;
            }

            if( EncryptFile ) {
                EncryptFileWPtr = (ENCRYPTFILEWPTR)GetProcAddress(Advapi32, "EncryptFileW");
                if( EncryptFileWPtr == NULL ) {
                    leave;
                }

                if( EncryptFileWPtr(lpNewFileName) )
                    *DestFileAttributes |= FILE_ATTRIBUTE_ENCRYPTED;
            } else {
                DecryptFileWPtr = (DECRYPTFILEWPTR)GetProcAddress(Advapi32, "DecryptFileW");
                if( DecryptFileWPtr == NULL ) {
                    leave;
                }

                if( DecryptFileWPtr(lpNewFileName, 0) )
                    *DestFileAttributes &= ~FILE_ATTRIBUTE_ENCRYPTED;
            }

            // The encrypt/decrypt call was successful, so we can reopen the file.

            Status = NtCreateFile(
                        DestFile,
                        DestFileAccess,
                        Obja,
                        &IoStatusBlock,
                        NULL,
                        SourceFileAttributes & FILE_ATTRIBUTE_VALID_FLAGS & SourceFileAttributesMask,
                        DestFileSharing,
                        CreateDisposition,
                        CreateOptions,
                        NULL,
                        0
                        );
            if( !NT_SUCCESS(Status) ) {
                *DestFile = INVALID_HANDLE_VALUE;
                BaseSetLastNTError(Status);
                leave;
            }

            // If we took off the read-only bit above, put it back on now.

            if( RestoreReadOnly ) {

                FileBasicInformationData.FileAttributes |= FILE_ATTRIBUTE_READONLY;

                Status = NtSetInformationFile(
                          *DestFile,
                          &IoStatusBlock,
                          &FileBasicInformationData,
                          sizeof(FileBasicInformationData),
                          FileBasicInformation
                          );

                if( !NT_SUCCESS(Status) ) {
                    BaseMarkFileForDelete( *DestFile, 0 );
                    BaseSetLastNTError(Status);
                    leave;
                }
            }
        }   // if( DecryptFile || EncryptFile )

        // If it's still not encrypted, see if it's OK to leave it that way.

        if( (SourceFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)
            && !(*DestFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) ) {

            // Either there was an encryption problem (e.g. no keys available)
            // or the target just doesn't support encryption.  See if it's OK
            // to continue with the copy by checking the CopyFlags, by making
            // a callback, or by checking policy.

            BOOL Canceled = FALSE;
            DWORD dwCallbackReason = 0;
            LONG lError = ERROR_ENCRYPTION_FAILED;

            // If the COPY_FILE_ALLOW_DECRYPTED_DESTINATION flag is set, then
            // we can fall through and return success.  Otherwise, we need to do some
            // more checking.

            if( !(CopyFlags & COPY_FILE_ALLOW_DECRYPTED_DESTINATION) ) {

                // There's a policy in the registry which may be set indicating
                // that we can ignore loss of encryption on network targets.
                // If that's set, and this is a remote destination, then the
                // copy can continue.  We check the policy first, because it
                // caches its result.  Consequently, in the typical case, we only
                // check the registry once, and we never make the NtQueryVolInfoFile
                // call.

                if( CheckAllowDecryptedRemoteDestinationPolicy() ) {

                    IO_STATUS_BLOCK IoStatus;
                    FILE_FS_DEVICE_INFORMATION DeviceInformation;

                    // See if the destination is remote

                    DeviceInformation.Characteristics = 0;
                    Status = NtQueryVolumeInformationFile(
                                *DestFile,
                                &IoStatus,
                                &DeviceInformation,
                                sizeof(DeviceInformation),
                                FileFsDeviceInformation
                                );
                    if( NT_SUCCESS(Status) &&
                        (DeviceInformation.Characteristics & FILE_REMOTE_DEVICE) )
                    {
                        // Yes, it's remote, and the policy is set, so 
                        // it's OK to continue.

                        SuccessReturn = TRUE;
                    }
                } // if( CheckAllowDecryptedRemoteDestinationPolicy() )

                // If that didn't work, do we have a callback on which we can
                // check for permission to drop?  We checked the policy first, 
                // because if it allows the copy, we needn't even call the
                // callback.

                if( !SuccessReturn
                    && Context != NULL 
                    && Context->lpProgressRoutine != NULL
                    && (CopyFlags & PRIVCOPY_FILE_METADATA) ) {

                    // Yes, we have an applicable callback.

                    // Figure out what the explanation (dwCallbackReason)
                    // is for the problem.

                    if( DestFileFsAttributes & FILE_SUPPORTS_ENCRYPTION ) {

                        if( !(SourceFileAttributesMask & FILE_ATTRIBUTE_ENCRYPTED) ) {
                            // We opened the file with encryption turned off, so we must
                            // have gotten an access-denied on the first try.

                            dwCallbackReason = PRIVCALLBACK_ENCRYPTION_FAILED;
                        }

                        else if( *DestFileAttributes & FILE_ATTRIBUTE_SYSTEM )
                            dwCallbackReason = PRIVCALLBACK_CANT_ENCRYPT_SYSTEM_FILE;
                        else
                            dwCallbackReason = PRIVCALLBACK_ENCRYPTION_FAILED;
                    }
                    else
                        dwCallbackReason = PRIVCALLBACK_ENCRYPTION_NOT_SUPPORTED;

                    // Make the callback.

                    if( BasepCopyFileCallback( FALSE, // Fail by default
                                               lError,
                                               Context,
                                               NULL,
                                               dwCallbackReason,
                                               hSourceFile,
                                               *DestFile,
                                               &Canceled )) {
                        // We've been given permission to drop the encryption
                        SuccessReturn = TRUE;
                    }
                }   // if( Context != NULL 


                // We checked everything, and nothing allows us to contine,
                // so fail the call.

                if( !SuccessReturn ) {
	            BaseMarkFileForDelete(
		            *DestFile,
		            0 );
	            SetLastError( lError );
	            leave;
                }

            }   // if( !(CopyFlags & COPY_FILE_ALLOW_DECRYPTED_DESTINATION) )
        }   // if( (SourceFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)

        SuccessReturn = TRUE;

    }
    finally
    {
        if (Advapi32 != NULL) {
            FreeLibrary( Advapi32 );
        }
    }

    return( SuccessReturn );
}


DWORD
WINAPI
BaseCopyStream(
    OPTIONAL LPCWSTR lpExistingFileName,
    HANDLE hSourceFile,
    ACCESS_MASK SourceFileAccess OPTIONAL,
    LPCWSTR lpNewFileName,
    HANDLE hTargetFile OPTIONAL,
    LARGE_INTEGER *lpFileSize,
    LPDWORD lpCopyFlags,
    LPHANDLE lpDestFile,
    LPDWORD lpCopySize,
    LPCOPYFILE_CONTEXT *lpCopyFileContext,
    LPRESTART_STATE lpRestartState OPTIONAL,
    BOOL OpenFileAsReparsePoint,
    DWORD dwReparseTag,
    PDWORD DestFileFsAttributes
    )

/*++

Routine Description:

    This is an internal routine that copies an entire file (default data stream
    only), or a single stream of a file.  If the hTargetFile parameter is
    present, then only a single stream of the output file is copied.  Otherwise,
    the entire file is copied.

Arguments:

    hSourceFile - Provides a handle to the source file.

    SourceFileAccess - The ACCESS_MASK bits used to open the source file handle.
        This variable is only used with the PRIVCOPY_FILE_* flags.

    lpNewFileName - Provides a name for the target file/stream.

    hTargetFile - Optionally provides a handle to the target file.  If the
        stream being copied is an alternate data stream, then this handle must
        be provided.

    lpFileSize - Provides the size of the input stream.

    lpCopyFlags - Provides flags that modify how the copy is to proceed.  See
        CopyFileEx for details.

    lpDestFile - Provides a variable to store the handle to the target file.

    lpCopySize - Provides variable to store size of copy chunks to be used in
        copying the streams.  This is set for the file, and then reused on
        alternate streams.

    lpCopyFileContext - Provides a pointer to a pointer to the context
        information to track callbacks, file sizes, etc. across streams during
        the copy operation.

    lpRestartState - Optionally provides storage to maintain restart state
        during the copy operation.  This pointer is only valid if the caller
        has specified the COPY_FILE_RESTARTABLE flag in the lpCopyFlags word.

    OpenFileAsReparsePoint - Flag to indicate whether the target file is to
        be opened as a reparse point or not.

    DestFileFsAttributes - If hTargetFile is present, provides a location to
        store the destination file's filesystem attributes.  If hTargetFile
        is not present, provides those attributes to this routine.

Return Value:

    TRUE - The operation was successful.

    SUCCESS_RETURNED_STATE - The operation was successful, but extended
        information was returned in the restart state structure.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{   // BaseCopyStream

    HANDLE DestFile = INVALID_HANDLE_VALUE;
    HANDLE Section;
    NTSTATUS Status;
    PVOID SourceBase, IoDestBase;
    PCHAR SourceBuffer;
    LARGE_INTEGER SectionOffset;
    LARGE_INTEGER BytesWritten;
    SIZE_T BigViewSize;
    ULONG ViewSize;
    ULONG BytesToWrite;
    ULONG BytesRead;
    FILE_BASIC_INFORMATION FileBasicInformationData;
    FILE_END_OF_FILE_INFORMATION EndOfFileInformation;
    IO_STATUS_BLOCK IoStatus;
    LPCOPYFILE_CONTEXT Context = *lpCopyFileContext;
    DWORD ReturnCode;
    DWORD b;
    BOOL Restartable;
    DWORD ReturnValue = FALSE;
    DWORD WriteCount = 0;
    DWORD FlagsAndAttributes;
    DWORD DesiredAccess;
    DWORD DestFileAccess;
    DWORD DestFileSharing;
    DWORD DesiredCreateDisposition;
    DWORD CreateDisposition;
    BOOL Canceled = FALSE;
    DWORD SourceFileAttributes;
    DWORD SourceFileAttributesMask;
    DWORD BlockSize;
    BOOL fSkipBlock;
    UNICODE_STRING DestFileName;
    PVOID DestFileNameBuffer = NULL;
    OBJECT_ATTRIBUTES Obja;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    FILE_EA_INFORMATION EaInfo;
    PFILE_FULL_EA_INFORMATION EaBuffer = NULL;
    ULONG EaSize = 0;
    BOOL EasDropped = FALSE;
    IO_STATUS_BLOCK IoStatusBlock;
    WCHAR SaveStaticUnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];


    // Default the size of copy chunks
    *lpCopySize = BASE_COPY_FILE_CHUNK;

    // The lpExistingFileName sits in the TEB buffer, which has a tendency
    // to get trashed (e.g. LoadLibaryW).  So use a local buffer.

    if( lpExistingFileName == NtCurrentTeb()->StaticUnicodeBuffer ) {

        memcpy( SaveStaticUnicodeBuffer,
                NtCurrentTeb()->StaticUnicodeBuffer,
                STATIC_UNICODE_BUFFER_LENGTH );
        lpExistingFileName = SaveStaticUnicodeBuffer;
    }

    //
    //  Get times and attributes for the file if the entire file is being
    //  copied
    //

    Status = NtQueryInformationFile(
                hSourceFile,
                &IoStatus,
                (PVOID) &FileBasicInformationData,
                sizeof(FileBasicInformationData),
                FileBasicInformation
                );

    SourceFileAttributes = NT_SUCCESS(Status) ?
                             FileBasicInformationData.FileAttributes :
                             0;

    if ( !ARGUMENT_PRESENT(hTargetFile) ) {

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
        }
    } else {

        //
        //  A zero in the file's attributes informs latter DeleteFile that
        //  this code does not know what the actual file attributes are so
        //  that this code does not actually have to retrieve them for each
        //  stream, nor does it have to remember them across streams.  The
        //  error path will simply get them if needed.
        //

        FileBasicInformationData.FileAttributes = 0;
    }

    //
    // We don't allow restartable copies of directory files, because the
    // unnamed data stream is used to store restart context, and directory files
    // don't have an unnamed data stream.
    //

    Restartable = (*lpCopyFlags & COPY_FILE_RESTARTABLE) != 0;
    if( Restartable && SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
        Restartable = FALSE;
        *lpCopyFlags &= ~COPY_FILE_RESTARTABLE;
    }


    try {

        //
        // Create the destination file or alternate data stream
        //

        SourceBase = NULL;
        IoDestBase = NULL;
        Section = NULL;

        if ( !ARGUMENT_PRESENT(hTargetFile) ) {

            ULONG CreateOptions = 0, DesiredCreateOptions = 0;
            BOOL TranslationStatus = FALSE;
            PFILE_FULL_EA_INFORMATION EaBufferToUse = NULL;
            DWORD SourceFileFsAttributes = 0;
            ULONG EaSizeToUse = 0;

            // We're being called to copy the unnamed stream of the file, and
            // we need to create the file itself.

            DWORD DestFileAttributes = 0;
            struct {
                FILE_FS_ATTRIBUTE_INFORMATION Info;
                WCHAR Buffer[ MAX_PATH ];
            } FileFsAttrInfoBuffer;

            //
            // Begin by determining how the target file is to be opened based
            // on whether or not the copy operation is to be restartable.
            //

            if ( Restartable ) {

                b = BasepOpenRestartableFile( hSourceFile,
                                              lpNewFileName,
                                              &DestFile,
                                              *lpCopyFlags,
                                              lpRestartState,
                                              lpFileSize,
                                              lpCopyFileContext,
                                              FileBasicInformationData.FileAttributes,
                                              OpenFileAsReparsePoint );

                if( b == SUCCESS_RETURNED_STATE ) {
                    // We've picked up in the middle of a restartable copy.
                    // The destination file handle is in DestFile, which will
                    // be given back to our caller below in the finally.

                    if ( BasepRemoteFile(hSourceFile,DestFile) ) {
                        *lpCopySize = BASE_COPY_FILE_CHUNK - 4096;
                    }
                    ReturnValue = b;
                    leave;
                } else if( b == FALSE ) {
                    // There was a fatal error.
                    leave;
                }

                // Otherwise we should copy the first stream.  If we are to restart copying
                // in that stream, DestFile will be valid.

            }

            //
            // If the dest file is not already opened (the restart case), open it now.
            //

            if( DestFile == INVALID_HANDLE_VALUE ) {

                BOOL EndsInSlash = FALSE;
                UNICODE_STRING Win32NewFileName;
                PCUNICODE_STRING lpConsoleName = NULL;
                FILE_BASIC_INFORMATION DestBasicInformation;

                //
                // Determine the create options
                //

                CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT;

                if( SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
                    CreateOptions |= FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT;
                else
                    CreateOptions |= FILE_NON_DIRECTORY_FILE  | FILE_SEQUENTIAL_ONLY;

                if( *lpCopyFlags & (PRIVCOPY_FILE_BACKUP_SEMANTICS|PRIVCOPY_FILE_OWNER_GROUP) )
                    CreateOptions |= FILE_OPEN_FOR_BACKUP_INTENT;


                //
                // Determine the create disposition
                //
                // Directory files are copied with merge semantics.  The rationale
                // is that copying of a directory tree has merge semantics wrt the
                // contained files, so copying of a directory file should also have
                // merge semantics.
                //

                if( SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
                    CreateDisposition = (*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS) ? FILE_CREATE : FILE_OPEN_IF;
                else
                    CreateDisposition = (*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS) ? FILE_CREATE : FILE_OVERWRITE_IF;


                //
                // Determine what access is necessary based on what is being copied
                //

                DesiredAccess = SYNCHRONIZE | FILE_READ_ATTRIBUTES | GENERIC_WRITE | DELETE;

                if( SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
                    // We may or may not be able to get FILE_WRITE_DATA access, necessary for
                    // setting compression.
                    DesiredAccess &= ~GENERIC_WRITE;
                    DesiredAccess |= FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA | FILE_LIST_DIRECTORY;
                }


                if( *lpCopyFlags & PRIVCOPY_FILE_METADATA ) {
                    // We need read access for compression, write_dac for the DACL
                    DesiredAccess |= GENERIC_READ | WRITE_DAC;
                }

                if( *lpCopyFlags & PRIVCOPY_FILE_OWNER_GROUP ) {
                    DesiredAccess |= WRITE_OWNER;
                }

                if( (*lpCopyFlags & PRIVCOPY_FILE_SACL)
                    &&
                    (SourceFileAccess & ACCESS_SYSTEM_SECURITY) ) {
                    // Don't bother trying to get access_system_security unless it was
                    // successfully obtained on the source (requires SeSecurityPrivilege)
                    DesiredAccess |= ACCESS_SYSTEM_SECURITY;
                }

                SourceFileAttributesMask = ~0;

                if ( OpenFileAsReparsePoint ) {
                    //
                    // The target has to be opened as reparse point. If the open
                    // below fails, the source is to be closed and re-opened
                    // without inhibiting the reparse point behavior.
                    //

                    CreateOptions |= FILE_OPEN_REPARSE_POINT;
                    DesiredAccess = (DesiredAccess & ~DELETE) | GENERIC_READ;
                    CreateDisposition = (*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS) ? FILE_CREATE : FILE_OPEN_IF;
                }

                DesiredCreateOptions = CreateOptions;
                DesiredCreateDisposition = CreateDisposition;
		
                //
                // Get the Win32 path in a unicode_string, and get the NT path
                //

                RtlInitUnicodeString( &Win32NewFileName, lpNewFileName );

                if ( lpNewFileName[(Win32NewFileName.Length >> 1)-1] == (WCHAR)'\\' ) {
                    EndsInSlash = TRUE;
                }
                else {
                    EndsInSlash = FALSE;
                }

                TranslationStatus = RtlDosPathNameToNtPathName_U(
                                        lpNewFileName,
                                        &DestFileName,
                                        NULL,
                                        NULL
                                        );

                if ( !TranslationStatus ) {
                    SetLastError(ERROR_PATH_NOT_FOUND);
                    DestFile = INVALID_HANDLE_VALUE;
                    leave;
                    }
                DestFileNameBuffer = DestFileName.Buffer;

                InitializeObjectAttributes(
                    &Obja,
                    &DestFileName,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL
                    );

                SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
                SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
                SecurityQualityOfService.EffectiveOnly = TRUE;
                SecurityQualityOfService.Length = sizeof( SECURITY_QUALITY_OF_SERVICE );

                Obja.SecurityQualityOfService = &SecurityQualityOfService;

                //
                //  Get the EAs
                //

                EaBuffer = NULL;
                EaSize = 0;

                Status = NtQueryInformationFile(
                            hSourceFile,
                            &IoStatusBlock,
                            &EaInfo,
                            sizeof(EaInfo),
                            FileEaInformation
                            );
                if ( NT_SUCCESS(Status) && EaInfo.EaSize ) {

                    EaSize = EaInfo.EaSize;

                    do {

                        EaSize *= 2;
                        EaBuffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), EaSize);
                        if ( !EaBuffer ) {
                            BaseSetLastNTError(STATUS_NO_MEMORY);
                            leave;
                        }

                        Status = NtQueryEaFile(
                                    hSourceFile,
                                    &IoStatusBlock,
                                    EaBuffer,
                                    EaSize,
                                    FALSE,
                                    (PVOID)NULL,
                                    0,
                                    (PULONG)NULL,
                                    TRUE
                                    );

                        if ( !NT_SUCCESS(Status) ) {
                            RtlFreeHeap(RtlProcessHeap(), 0,EaBuffer);
                            EaBuffer = NULL;
                            IoStatusBlock.Information = 0;
                        }

                    } while ( Status == STATUS_BUFFER_OVERFLOW ||
                              Status == STATUS_BUFFER_TOO_SMALL );


                    EaSize = (ULONG)IoStatusBlock.Information;

                }   // if ( NT_SUCCESS(Status) && EaInfo.EaSize )


                //
                // Open the destination file.  If the destination is a console name,
                // open as such, otherwise loop until we find a way to open it with
                // NtCreateFile.
                //

                DestFileAccess = DesiredAccess;
                DestFileSharing = 0;
                EaBufferToUse = EaBuffer;
                EaSizeToUse = EaSize;

                if( (lpConsoleName = BaseIsThisAConsoleName( &Win32NewFileName, GENERIC_WRITE )) ) {

                    DestFileAccess = DesiredAccess = GENERIC_WRITE;
                    DestFileSharing = FILE_SHARE_READ | FILE_SHARE_WRITE;

                    if( EaBuffer != NULL )
                        EasDropped = TRUE;  // We're not copying the EAs

                    DestFile= OpenConsoleW( lpConsoleName->Buffer,
                                            DestFileAccess,
                                            FALSE,  // Not inheritable
                                            DestFileSharing
                                           );

                    if ( DestFile == INVALID_HANDLE_VALUE ) {
                        BaseSetLastNTError(STATUS_ACCESS_DENIED);
                        NtClose( DestFile );
                        DestFile = INVALID_HANDLE_VALUE;
                        leave;
                    }

                }

                //
                // Even if the source is offline, the destination should
                // not be (at least not as part of the copy).
                //
                SourceFileAttributes &= ~FILE_ATTRIBUTE_OFFLINE;


                //
                //  If the source file was encrypted and if we are intending
                //  to create/overwrite/supersede the destination, attempt
                //  to establish the encryption state first by calling 
                //  DuplicateEncryptionInfoFile.  This API not only makes
                //  the target file encrypted, it also copies over the source's
                //  $efs stream (i.e. everyone who had access to the source file
                //  will have access to the dest file).
                //
                //

                if (!(SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    && (SourceFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)
                    && (SourceFileAttributesMask & FILE_ATTRIBUTE_ENCRYPTED)
                    && (CreateDisposition == FILE_CREATE
                        || CreateDisposition == FILE_OVERWRITE_IF)) {

                    // We'll attempt the DuplicateEncryptionInfoCall.

                    DWORD Win32CreateDisposition;
                    DWORD LastError;

                    // Convert the NT create-disposition flags into a Win32 version.

                    Status = BasepCreateDispositionToWin32( CreateDisposition,
                                                            &Win32CreateDisposition );
                    if( !NT_SUCCESS(Status) ) {
                        BaseSetLastNTError( Status );

                    } else {

                        // Mask out the read-only bit for now, so that we can
                        // do an NtCreateFile after this DuplicateEncryptionInfoFile
                        
                        SourceFileAttributesMask &= ~FILE_ATTRIBUTE_READONLY;
                        
                        // DuplicateEncryptionInfoFile returns the error code.
                        // The "pfn" version of this API is a lazy-loader, so we
                        // don't have to implicitely link against advapi32.

                        LastError = pfnDuplicateEncryptionInfoFile(
                                                      lpExistingFileName, 
                                                      lpNewFileName, 
                                                      Win32CreateDisposition, 
                                                      SourceFileAttributes
                                                        & FILE_ATTRIBUTE_VALID_FLAGS
                                                        & SourceFileAttributesMask,
                                                      NULL );
                        if( LastError != 0 ) {
                            
                            // 
                            // We'll fall through and try using NtCreateFile.  That,
                            // at least, will try to encrypt the target via the
                            // FILE_ATTRIBUTE_ENCRYPTED bit.  Not as good as
                            // DupEncInfo, but better than leaving plain text.
                            //
                            SetLastError( LastError );
                        } else {
                        
                            //
                            //  Destination was created.  Now make it open
                            //
                        
                            CreateDisposition = FILE_OPEN;
                        }
                    }
                }   // if (!(SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                
                
                //
                // Open the destination file. This can take some effort & retries,
                // because there are so many scenarios for the target file
                // (e.g. different destination servers have different capabilities).
                //

                while( DestFile == NULL || DestFile == INVALID_HANDLE_VALUE ) {

                    // Attempt to create the destination

                    Status = NtCreateFile(
                                &DestFile,
                                DestFileAccess,
                                &Obja,
                                &IoStatusBlock,
                                NULL,
                                SourceFileAttributes
                                    & FILE_ATTRIBUTE_VALID_FLAGS
                                    & SourceFileAttributesMask,
                                DestFileSharing,
                                CreateDisposition,
                                CreateOptions,
                                EaBufferToUse,
                                EaSizeToUse
                                );

                    if( !NT_SUCCESS(Status) ) {

                        // Set the last error and fall through.  We will attempt below to
                        // resolve the problem and try again.

                        BaseSetLastNTError( Status );


                    } else {

                        //
                        // We successfully created the file.  For some special cases,
                        // we must post-process this create before continuing with the copy.
                        //

                        if( (SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                                 CreateDisposition == FILE_OPEN &&
                                 (DestFileAccess & FILE_WRITE_DATA) == FILE_WRITE_DATA &&
                                 (CreateOptions & FILE_DIRECTORY_FILE) == FILE_DIRECTORY_FILE ) {

                            //
                            // If we're copying to NT4, a previous iteration through this
                            // large while loop switched the CreateDisposition from
                            // FILE_OPENIF to FILE_OPEN; otherwise, NT4 fails the open
                            // (when passing FILE_OPENIF and FILE_WRITE_DATA to a directory
                            // file that already exists).  The open worked, but the problem
                            // is that now if we need to set compression on the target, we'll
                            // get status_invalid_parameter because the FILE_DIRECTORY_FILE
                            // CreateOption was set.  So, to allow compression to work, and
                            // since at this point we already know the target is a directory
                            // file, we can re-open it without that create option.
                            //

                            CreateOptions &= ~FILE_DIRECTORY_FILE;

                            NtClose( DestFile );
                            Status = NtCreateFile(
                                        &DestFile,
                                        DestFileAccess,
                                        &Obja,
                                        &IoStatusBlock,
                                        NULL,
                                        SourceFileAttributes & FILE_ATTRIBUTE_VALID_FLAGS & SourceFileAttributesMask,
                                        DestFileSharing,
                                        CreateDisposition,
                                        CreateOptions,
                                        EaBufferToUse,
                                        EaSizeToUse
                                        );
                            if( !NT_SUCCESS(Status) ) {

                                // But if that didn't work, go back to the combination that
                                // did (this happens on Samba servers).

                                CreateOptions |= FILE_DIRECTORY_FILE;
                                Status = NtCreateFile(
                                            &DestFile,
                                            DestFileAccess,
                                            &Obja,
                                            &IoStatusBlock,
                                            NULL,
                                            SourceFileAttributes & FILE_ATTRIBUTE_VALID_FLAGS & SourceFileAttributesMask,
                                            DestFileSharing,
                                            CreateDisposition,
                                            CreateOptions,
                                            EaBufferToUse,
                                            EaSizeToUse
                                            );

                                if( !NT_SUCCESS(Status) ) {
                                    DestFile = INVALID_HANDLE_VALUE;
                                    BaseSetLastNTError( Status );
                                    leave;
                                }
                            }
                        }
                        else if( (SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                                 CreateDisposition == FILE_OPEN_IF &&
                                 lpConsoleName == NULL ) {
                        
                            //
                            // Compatibility hack:  We successfully created the target, but 
                            // some servers (SCO VisionFS) get confused by the FILE_OPEN_IF
                            // flag and create a non-directory file instead.  Check to see if
                            // this hapenned, and if so deleted it and re-create with FILE_CREATE
                            // instead.  This is a perf hit that we have to query the file attributes,
                            // but at least it is not a net round-trip because the rdr caches the
                            // file attributes in Create&X.
                            //


                            FILE_BASIC_INFORMATION NewDestInfo;

                            Status = NtQueryInformationFile( DestFile,
                                                             &IoStatus,
                                                             &NewDestInfo,
                                                             sizeof(NewDestInfo),
                                                             FileBasicInformation );
                            if( !NT_SUCCESS(Status) ) {
                                BaseMarkFileForDelete( DestFile, 0 );
                                BaseSetLastNTError(Status);
                                leave;
                            }

                            if( !(NewDestInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {

                                // Yes, a non-directory file got created.  Delete it, then
                                // try again without FILE_OPEN_IF.

                                BaseMarkFileForDelete( DestFile,
                                                       NewDestInfo.FileAttributes );
                                NtClose( DestFile );
                                DestFile = INVALID_HANDLE_VALUE;

                                CreateDisposition = FILE_CREATE;

                                // Also, if we request FILE_WRITE_DATA access, the 
                                // directory gets created but the NtCreateFile call
                                // returns status_object_name_collision.  Since this
                                // is a very VisionFS-specific workaround, we'll just
                                // turn off that bit

                                DestFileAccess &= ~FILE_WRITE_DATA;

                                continue;
                            }
                        }

                        if( (FileBasicInformationData.FileAttributes & FILE_ATTRIBUTE_READONLY)
                            &&
                            !(SourceFileAttributesMask & FILE_ATTRIBUTE_READONLY) ) {

                            // The read-only bit was turned off, and must now be
                            // reset (it gets turned off when we call DuplicateEncryptionInfo,
                            // since that API does not return a handle).

                            Status = NtSetInformationFile(
                                      DestFile,
                                      &IoStatus,
                                      &FileBasicInformationData,
                                      sizeof(FileBasicInformationData),
                                      FileBasicInformation
                                      );
                            if( !NT_SUCCESS(Status) ) {
                                BaseMarkFileForDelete( DestFile, 0 );
                                BaseSetLastNTError(Status);
                                leave;
                            }
                        }

                        break;  // while( TRUE )

                    }   // NtCreateFile ... if( !NT_SUCCESS(Status) ) ... else

                    // If we reach this point, some error has occurred in the attempt to 
                    // create the file.


                    //
                    // If a file/directory already exists and we can't overwrite it,
                    // abort now.
                    //

                    if ( (*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS) &&
                         (STATUS_OBJECT_NAME_COLLISION == Status) ) {

                        // Not allowed to overwrite an existing file.
                        SetLastError( ERROR_FILE_EXISTS );
                        DestFile = INVALID_HANDLE_VALUE;
                        leave;

                    } else if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {

                        // Not allowed to overwrite a directory with a file.
                        if ( EndsInSlash ) {
                            SetLastError(ERROR_PATH_NOT_FOUND);
                        }
                        else {
                            SetLastError(ERROR_ACCESS_DENIED);
                        }
                        DestFile = INVALID_HANDLE_VALUE;
                        leave;
                    }

                    //
                    // If we're trying to create a directory, and a non-directory
                    // file already exists by that name, we need to manually delete
                    // it (FILE_OVERWRITE isn't valid for a directory file).
                    //

                    if( (*lpCopyFlags & PRIVCOPY_FILE_DIRECTORY) &&
                        Status == STATUS_NOT_A_DIRECTORY &&
                        !(*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS) ) {

                        Status = NtCreateFile(
                                    &DestFile,
                                    DELETE|SYNCHRONIZE,
                                    &Obja,
                                    &IoStatusBlock,
                                    NULL,
                                    FILE_ATTRIBUTE_NORMAL,
                                    0,
                                    FILE_OPEN,
                                    FILE_DELETE_ON_CLOSE | FILE_SYNCHRONOUS_IO_NONALERT,
                                    NULL,
                                    0
                                    );
                        if( !NT_SUCCESS(Status) ) {
                            BaseSetLastNTError(Status);
                            DestFile = INVALID_HANDLE_VALUE;
                            leave;
                        }

                        NtClose( DestFile );
                        DestFile = INVALID_HANDLE_VALUE;

                        continue;
                    }


                    //
                    // Some sharing and access errors can be handled
                    // by reducing the access we request on the target
                    // file.
                    //

                    if( GetLastError() == ERROR_SHARING_VIOLATION ||
                        GetLastError() == ERROR_ACCESS_DENIED ) {

                        //
                        // If the create failed because of a sharing violation or because access
                        // was denied, attempt to open the file and allow other readers and
                        // writers.
                        //

                        if( (DestFileSharing & (FILE_SHARE_READ|FILE_SHARE_WRITE))
                            != (FILE_SHARE_READ|FILE_SHARE_WRITE) ) {

                            DestFileSharing = FILE_SHARE_READ | FILE_SHARE_WRITE;
                            continue;
                        }

                        //
                        // If this failed as well, then attempt to open w/o specifying
                        // delete access.  It is probably not necessary to have delete
                        // access to the file anyway, since it will not be able to clean
                        // it up because it's probably open.  However, this is not
                        // necessarily the case.
                        //

                        else if ( (DestFileAccess & DELETE) ) {

                            DestFileAccess &= ~DELETE;
                            continue;
                        }

                    }



                    //
                    // If the destination has not been successfully created/opened, see
                    // if it's because EAs aren't supported
                    //

                    if( EaBufferToUse != NULL
                        &&
                        GetLastError() == ERROR_EAS_NOT_SUPPORTED ) {

                        // Attempt the create again, but don't use the EAs

                        EasDropped = TRUE;
                        EaBufferToUse = NULL;
                        EaSizeToUse = 0;
                        DestFileAccess = DesiredAccess;
                        DestFileSharing = 0;
                        continue;

                    }   // if( EaBufferToUse != NULL ...

                    // If we still have an access-denied problem, try dropping
                    // the WRITE_DAC or WRITE_OWNER access

                    if(( GetLastError() == ERROR_ACCESS_DENIED  ) 
                       && (DestFileAccess & (WRITE_DAC | WRITE_OWNER)) ) {

                        // If WRITE_DAC is set, try turning it off.

                        if( DestFileAccess & WRITE_DAC ) {
                            DestFileAccess &= ~WRITE_DAC;
                        }

                        // Or, if WRITE_OWNER is set, try turning it off.  We'll
                        // turn WRITE_DAC back on if it was previously turned off.  Then,
                        // if this still doesn't work, then the next iteration will turn
                        // WRITE_DAC back off, thus covering both scenarios.

                        else if( DestFileAccess & WRITE_OWNER ) {
                            DestFileAccess &= ~WRITE_OWNER;
                            DestFileAccess |= (DesiredAccess & WRITE_DAC);
                        }

                        DestFileSharing = 0;
                        continue;
                    } 


                    //
                    // 
                    // We might be having a problem copying encryption.  E.g.
                    // we might get an access-denied because the remote target machine
                    // isn't trusted for delegation.
                    // We'll try copying without encryption.  If that works, then later, in
                    // BasepCopyEncryption, we'll see if it's OK that we lost
                    // encryption.
                    //

                    if ( (SourceFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) 
                         && (SourceFileAttributesMask & FILE_ATTRIBUTE_ENCRYPTED) )
                    {

                        // Try taking the encryption bit out of the
                        // attributes we pass to NtCreateFile.

                        SourceFileAttributesMask &= ~FILE_ATTRIBUTE_ENCRYPTED;
                        CreateOptions = DesiredCreateOptions;
                        DestFileAccess = DesiredAccess;
                        DestFileSharing = 0;

                        continue;
                    }


                    //
                    // NT4 returns invalid-parameter error on an attempt to open 
                    // a directory file with both FILE_WRITE_DATA and FILE_OPEN_IF.
                    // Samba 2.x returns ERROR_ALREADY_EXISTS, even though
                    // the semantics of FILE_OPEN_IF says that it should open the
                    // existing directory.
                    // For both cases, we'll try it with FILE_OPEN.
                    //

                    if( ( GetLastError() == ERROR_INVALID_PARAMETER  ||
                          GetLastError() == ERROR_ALREADY_EXISTS ) &&
                        (SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                        CreateDisposition == FILE_OPEN_IF )  {
                        
                        CreateDisposition = FILE_OPEN;

                        SourceFileAttributesMask = ~0;
                        CreateOptions = DesiredCreateOptions;
                        DestFileAccess = DesiredAccess;
                        DestFileSharing = 0;
                        continue;
                    }

                    //
                    // Some downlevel servers don't allow a directory to be opened for write_data
                    // access.  We need write_data in order to set compression, but the
                    // downlevel server likely won't support that anyway.  (This happens on
                    // NTFS4 if the target directory file doesn't already exist.  In this
                    // case the compression will get copied over anyway as part of the create.)
                    //

                    if( (SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                        (DestFileAccess & FILE_WRITE_DATA) ) {

                        DestFileAccess = DesiredAccess & ~FILE_WRITE_DATA;

                        CreateDisposition = DesiredCreateDisposition;
                        CreateOptions = DesiredCreateOptions;
                        DestFileSharing = 0;
                        continue;
                    }

                    // If we reach this point, we've run out of options and must give up.
                    DestFile = INVALID_HANDLE_VALUE;
                    leave;

                }   // while( DestFile == INVALID_HANDLE_VALUE )
                // If we reach this point, we've successfully opened the dest file.

                //
                // If we lost the EAs, check to see if that's OK before carrying on.
                //

                if( EasDropped && (*lpCopyFlags & PRIVCOPY_FILE_METADATA) ) {

                    // Check to see if it's OK that we skip the EAs.

                    if( !BasepCopyFileCallback( TRUE,    // Continue by default
                                                ERROR_EAS_NOT_SUPPORTED,
                                                Context,
                                                NULL,
                                                PRIVCALLBACK_EAS_NOT_SUPPORTED,
                                                hSourceFile,
                                                INVALID_HANDLE_VALUE,
                                                &Canceled
                                                ) ) {
                        // Not OK.  The last error has already been set.
                        if( Canceled ) {
                            BaseMarkFileForDelete(
                                DestFile,
                                0
                                );
                        }
                        NtClose( DestFile );
                        DestFile = INVALID_HANDLE_VALUE;
                        leave;
                    }
                }
		
                //
                // When appropriate, copy the reparse point.
                //

                if ( OpenFileAsReparsePoint &&
                     (DestFile != INVALID_HANDLE_VALUE)) {
                    DWORD CopyResult = FALSE;

                    CopyResult = CopyReparsePoint(
                                     hSourceFile,
                                     DestFile
                                     );

                    if ( !CopyResult ) {
                        //
                        // Note that when OpenFileAsReparsePoint is TRUE, by
                        // exiting at this point the effect is that the caller
                        // will re-start the copy without inhibiting the reparse
                        // behavior.
                        //

                        //If we fail here, we may be leaving a newly created
                        // file around at the destination.  If
                        // COPY_FILE_FAIL_IF_EXISTS has been specified,
                        // further retries will fail.  Therefore we need to
                        // try to delete the new file here.
                        if (*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS)
                        {
                            FILE_DISPOSITION_INFORMATION Disposition = {TRUE};

                            Status = NtSetInformationFile(
                                DestFile,
                                &IoStatus,
                                &Disposition,
                                sizeof(Disposition),
                                FileDispositionInformation
                                );
                            //Ignore an error if there is one.

                        }
                        *lpDestFile = DestFile;
                        leave;
                    }
                }   // if ( OpenFileAsReparsePoint &&(DestFile != INVALID_HANDLE_VALUE))


                //
                // Get the File & FileSys attributes for the target volume, plus
                // the FileSys attributes for the source volume.  Ignore errors in
                // the target, e.g. it might be a printer and not support these calls
                // (just assume the attrs in this case are zero).
                //

                *DestFileFsAttributes = 0;
                SourceFileFsAttributes = 0;
                DestFileAttributes = 0;

                Status = NtQueryVolumeInformationFile( DestFile,
                                                       &IoStatus,
                                                       &FileFsAttrInfoBuffer.Info,
                                                       sizeof(FileFsAttrInfoBuffer),
                                                       FileFsAttributeInformation );

                if( NT_SUCCESS(Status) ) {
                    *DestFileFsAttributes = FileFsAttrInfoBuffer.Info.FileSystemAttributes;
                }

                if( lpConsoleName == NULL ) {
                    Status = NtQueryInformationFile( DestFile,
                                                     &IoStatus,
                                                     &DestBasicInformation,
                                                     sizeof(DestBasicInformation),
                                                     FileBasicInformation );
                    if( NT_SUCCESS(Status) ) {
                        DestFileAttributes = DestBasicInformation.FileAttributes;
                    }
                }

                Status = NtQueryVolumeInformationFile( hSourceFile,
                                                       &IoStatus,
                                                       &FileFsAttrInfoBuffer.Info,
                                                       sizeof(FileFsAttrInfoBuffer),
                                                       FileFsAttributeInformation );
                if( NT_SUCCESS(Status) ) {
                    SourceFileFsAttributes = FileFsAttrInfoBuffer.Info.FileSystemAttributes;
                } else {
                    BaseMarkFileForDelete( DestFile, 0 );
                    BaseSetLastNTError(Status);
                    leave;
                }

                //
                // If requested and applicable, copy one or more of the the DACL, SACL, owner, and group.
                // If the source doesn't support persistent ACLs, assume that that means that
                // it doesn't support any of DACL, SACL, and owner/group.
                //

                if( (SourceFileFsAttributes & FILE_PERSISTENT_ACLS)
                    &&
                    (*lpCopyFlags & (PRIVCOPY_FILE_METADATA | PRIVCOPY_FILE_SACL | PRIVCOPY_FILE_OWNER_GROUP)) ) {

                    SECURITY_INFORMATION SecurityInformation = 0;

                    if( *lpCopyFlags & PRIVCOPY_FILE_METADATA
                        && !(*lpCopyFlags & PRIVCOPY_FILE_SKIP_DACL) ) {

                        // Copy the DACL if metadata flag is set, but skip_dacl is not.
                        // The skip_dacl flag is a temporary workaround for a problem
                        // in CSC & roaming profiles.

                        SecurityInformation |= DACL_SECURITY_INFORMATION;
                    }

                    if( *lpCopyFlags & PRIVCOPY_FILE_SACL )
                        SecurityInformation |= SACL_SECURITY_INFORMATION;

                    if( *lpCopyFlags & PRIVCOPY_FILE_OWNER_GROUP )
                        SecurityInformation |= OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION;

                    if( SecurityInformation != 0 ) {

                        if( !BasepCopySecurityInformation( lpExistingFileName,
                                                           hSourceFile,
                                                           SourceFileAccess,
                                                           lpNewFileName,
                                                           DestFile,
                                                           DestFileAccess,
                                                           SecurityInformation,
                                                           Context,
                                                           *DestFileFsAttributes,
                                                           &Canceled,
                                                           FALSE )) {

                            if( Canceled ) {
                                BaseMarkFileForDelete(
                                    DestFile,
                                    0
                                    );
                            }
                            leave;
                        }
                    }
                }

                //
                // Copy compression and encryption
                //

                if( (*lpCopyFlags & PRIVCOPY_FILE_METADATA) ) {

                    BOOL DoCompression = FALSE;
                    int i = 0;

                    // Compression and encryption must be handled in the proper
                    // order, since a file can't be both at once.  For example,
                    // if copying (with supersede) a compressed/unencrypted file over an
                    // uncompressed/encrypted file, we must decrypt the dest
                    // before attempting to compress it.

                    if( DestFileAttributes & FILE_ATTRIBUTE_COMPRESSED ) {
                        // Handle compression first
                        DoCompression = TRUE;
                    }

                    for( i = 0; i < 2; i++ ) {

                        if( DoCompression ) {

                            DoCompression = FALSE;
                            b = BasepCopyCompression( hSourceFile,
                                                      DestFile,
                                                      SourceFileAttributes,
                                                      DestFileAttributes,
                                                      *DestFileFsAttributes,
                                                      *lpCopyFlags,
                                                      &Context );

                        } else {

                            DoCompression = TRUE;
                            b = BasepCopyEncryption( hSourceFile,
                                                     lpNewFileName,
                                                     &DestFile,
                                                     &Obja,
                                                     DestFileAccess,
                                                     DestFileSharing,
                                                     CreateDisposition,
                                                     CreateOptions,
                                                     SourceFileAttributes,
                                                     SourceFileAttributesMask,
                                                     &DestFileAttributes,
                                                     *DestFileFsAttributes,
                                                     *lpCopyFlags,
                                                     &Context );
                        }

                        if( !b ) {
                            // The dest file is already marked for delete and
                            // last error has been set.
                            leave;
                        }
                    }   // for( i = 0; i < 2; i++ )

                }   // if( (*lpCopyFlags & PRIVCOPY_FILE_METADATA) )
                else {

                    // 
                    // For the public copyfile, we still need to handle encryption.
                    //

                    b = BasepCopyEncryption( hSourceFile,
                                             lpNewFileName,
                                             &DestFile,
                                             &Obja,
                                             DestFileAccess,
                                             DestFileSharing,
                                             CreateDisposition,
                                             CreateOptions,
                                             SourceFileAttributes,
                                             SourceFileAttributesMask,
                                             &DestFileAttributes,
                                             *DestFileFsAttributes,
                                             *lpCopyFlags,
                                             &Context );

                    if( !b ) {
                        // The dest file is already marked for delete and
                        // last error has been set.
                        leave;
                    }
                }   // if( (*lpCopyFlags & PRIVCOPY_FILE_METADATA) ) ... else


                //
                // If copying a directory file, see if any attributes need to be
                // added.  For non-directory files, this is handled in the NtCreateFile since
                // either FILE_CREATE or FILE_OVERWRITE_IF is specified.
                //

                if( SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

                    //
                    // But before copying attributes, in the supersede case, the target's
                    // named streams should be removed.  We need to do this first,
                    // in case copying the attributes sets the read-only bit.
                    //

                    if( *lpCopyFlags & PRIVCOPY_FILE_SUPERSEDE ) {

                        ULONG StreamInfoSize;
                        PFILE_STREAM_INFORMATION StreamInfo;
                        PFILE_STREAM_INFORMATION StreamInfoBase = NULL;

                        // Get the dest file's streams

                        StreamInfoSize = 4096;
                        do {
                            StreamInfoBase = RtlAllocateHeap( RtlProcessHeap(),
                                                              MAKE_TAG( TMP_TAG ),
                                                              StreamInfoSize );

                            if ( !StreamInfoBase ) {
                                BaseSetLastNTError( STATUS_NO_MEMORY );
                                leave;
                            }

                            Status = NtQueryInformationFile(
                                        DestFile,
                                        &IoStatus,
                                        (PVOID) StreamInfoBase,
                                        StreamInfoSize,
                                        FileStreamInformation
                                        );

                            if ( !NT_SUCCESS(Status) ) {
                                //
                                //  We failed the call.  Free up the previous buffer and set up
                                //  for another pass with a buffer twice as large
                                //

                                RtlFreeHeap(RtlProcessHeap(), 0, StreamInfoBase);
                                StreamInfoBase = NULL;
                                StreamInfoSize *= 2;
                            }
                            else if( IoStatus.Information == 0 ) {
                                // There are no streams
                                RtlFreeHeap(RtlProcessHeap(), 0, StreamInfoBase);
                                StreamInfoBase = NULL;
                            }

                        } while ( Status == STATUS_BUFFER_OVERFLOW || Status == STATUS_BUFFER_TOO_SMALL );

                        // If there were any streams, delete them.

                        if( StreamInfoBase != NULL ) {
                            StreamInfo = StreamInfoBase;
                            while (TRUE) {

                                OBJECT_ATTRIBUTES Obja;
                                UNICODE_STRING StreamName;
                                HANDLE DestStream;

                                StreamName.Length = (USHORT) StreamInfo->StreamNameLength;
                                StreamName.MaximumLength = (USHORT) StreamName.Length;
                                StreamName.Buffer = StreamInfo->StreamName;

                                InitializeObjectAttributes(
                                    &Obja,
                                    &StreamName,
                                    OBJ_CASE_INSENSITIVE,
                                    DestFile,
                                    NULL
                                    );

                                // Relative-open the stream to be deleted.

                                Status = NtCreateFile(
                                            &DestStream,
                                            DELETE|SYNCHRONIZE,
                                            &Obja,
                                            &IoStatusBlock,
                                            NULL,
                                            0,
                                            FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                                            FILE_OPEN,
                                            FILE_DELETE_ON_CLOSE | FILE_SYNCHRONOUS_IO_NONALERT,
                                            NULL,
                                            0
                                            );
                                if( !NT_SUCCESS(Status) ) {
                                    RtlFreeHeap(RtlProcessHeap(), 0, StreamInfoBase);
                                    BaseMarkFileForDelete( DestFile, 0 );
                                    BaseSetLastNTError( Status );
                                    leave;
                                }

                                // Delete the stream
                                NtClose( DestStream );

                                if (StreamInfo->NextEntryOffset == 0) {
                                    break;
                                }
                                StreamInfo = (PFILE_STREAM_INFORMATION)((PCHAR) StreamInfo + StreamInfo->NextEntryOffset);
                            }   // while (TRUE)

                            RtlFreeHeap(RtlProcessHeap(), 0, StreamInfoBase);
                        }   // if( StreamInfoBase != NULL )
                    }   // if( *lpCopyFlags & PRIVCOPY_FILE_SUPERSEDE )

                    // Now, if necessary, copy over attributes.

                    if( SourceFileAttributes != DestFileAttributes ) {

                        DestFileAttributes |= SourceFileAttributes;

                        RtlZeroMemory( &DestBasicInformation, sizeof(DestBasicInformation) );
                        DestBasicInformation.FileAttributes = DestFileAttributes;
                        Status = NtSetInformationFile( DestFile,
                                                       &IoStatus,
                                                       &DestBasicInformation,
                                                       sizeof(DestBasicInformation),
                                                       FileBasicInformation );
                        if( !NT_SUCCESS(Status) ) {
                            BaseMarkFileForDelete( DestFile, 0 );
                            BaseSetLastNTError(Status);
                            leave;
                        }

                        DestFileAttributes = 0;
                        Status = NtQueryInformationFile( DestFile,
                                                         &IoStatus,
                                                         &DestBasicInformation,
                                                         sizeof(DestBasicInformation),
                                                         FileBasicInformation );
                        if( NT_SUCCESS(Status) ) {
                            DestFileAttributes = DestBasicInformation.FileAttributes;
                        } else {
                            BaseMarkFileForDelete( DestFile, 0 );
                            BaseSetLastNTError(Status);
                            leave;
                        }
                    }

                }   // if( SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY )


            }   // if( DestFile != INVALID_HANDLE_VALUE )

            //
            // If this is a directory file, there is nothing left to copy
            //

            if( SourceFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
                BOOL Canceled = FALSE;

                if( !BasepCopyFileCallback( TRUE,   // ContinueByDefault
                                            RtlNtStatusToDosError(STATUS_REQUEST_ABORTED),
                                            Context,
                                            NULL,
                                            CALLBACK_STREAM_SWITCH,
                                            hSourceFile,
                                            DestFile,
                                            &Canceled ) ) {
                    ReturnValue = FALSE;
                    if( Canceled ) {
                        BaseMarkFileForDelete(
                            DestFile,
                            0
                            );
                    }
                } else {
                    ReturnValue = TRUE;
                }
                leave;

            }


        } else {    // if ( !ARGUMENT_PRESENT(hTargetFile) )

            // We're copying a named stream.

            OBJECT_ATTRIBUTES ObjectAttributes;
            UNICODE_STRING StreamName;
            IO_STATUS_BLOCK IoStatus;
            ULONG Disposition;

            //
            // Create the output stream relative to the file specified by the
            // hTargetFile file handle.
            //

            RtlInitUnicodeString(&StreamName, lpNewFileName);
            InitializeObjectAttributes(
                &ObjectAttributes,
                &StreamName,
                0,
                hTargetFile,
                (PSECURITY_DESCRIPTOR)NULL
                );

            //
            // Determine the disposition type.
            //

            if ( *lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS ) {
                Disposition = FILE_CREATE;
            } else {
                Disposition = FILE_OVERWRITE_IF;
            }

            if ( Restartable ) {
                if ( lpRestartState->LastKnownGoodOffset.QuadPart ) {
                    Disposition = FILE_OPEN;
                } else {
                    Disposition = FILE_OVERWRITE_IF;
                }
            }

            //
            // Inhibit reparse behavior when appropriate.
            //

            FlagsAndAttributes = FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY;
            DesiredAccess = GENERIC_WRITE | SYNCHRONIZE;
            if ( OpenFileAsReparsePoint ) {
                //
                // The target has to be opened as reparse point. If
                // this fails the source is to be closed and re-opened
                // without inhibiting the reparse point behavior.
                //

                FlagsAndAttributes |= FILE_OPEN_REPARSE_POINT;
                DesiredAccess |= GENERIC_READ;
                if ( !(*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS) ||
                     !(Restartable && (lpRestartState->LastKnownGoodOffset.QuadPart)) ) {
                    Disposition = FILE_OPEN_IF;
                }
            }

            Status = NtCreateFile(
                        &DestFile,
                        DesiredAccess,
                        &ObjectAttributes,
                        &IoStatus,
                        lpFileSize,
                        0,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        Disposition,
                        FlagsAndAttributes,
                        (PVOID)NULL,
                        0);

            if ( !NT_SUCCESS(Status) ) {

                BaseSetLastNTError(Status);

                // If we failed the create with an invalid name error, it might be becuase
                // we tried to copy an NTFS5 property set to pre-NTFS5 (and pre-NTFS4/SP4)
                // To detect this, we first check the error, and that the prefix character
                // of the stream name is a reserved ole character.

                if( Status == STATUS_OBJECT_NAME_INVALID
                    &&
                    StreamName.Buffer[1] <= 0x1f
                    &&
                    StreamName.Buffer[1] >= 1 ) {

                    // Now we check to see if we're copying to pre-NTFS5.
                    // If so, we'll assume that the leading ole character is
                    // the cause of the problem, and will silently fail the
                    // copy of this stream just as NT4 did.

                    NTSTATUS StatusT = STATUS_SUCCESS;
                    IO_STATUS_BLOCK Iosb;
                    FILE_FS_ATTRIBUTE_INFORMATION FsAttrInfo;

                    StatusT = NtQueryVolumeInformationFile( hTargetFile, &Iosb,
                                                            &FsAttrInfo,
                                                            sizeof(FsAttrInfo),
                                                            FileFsAttributeInformation );


                    // We should always get a buffer-overflow error here, because we don't
                    // provide enough buffer for the file system name, but that's OK because
                    // we don't need it (status_buffer_overflow is just a warning, so the rest
                    // of the data is good).

                    if( !NT_SUCCESS(StatusT) && STATUS_BUFFER_OVERFLOW != StatusT) {
                        Status = StatusT;
                        BaseSetLastNTError(Status);
                        leave;
                    }

                    // If this is pre-NTFS5, then silently ignore the error.
                    if( !(FILE_SUPPORTS_OBJECT_IDS & FsAttrInfo.FileSystemAttributes) ) {

                        Status = STATUS_SUCCESS;
                        ReturnValue = TRUE;
                        leave;
                    }
                }


                if ( Status != STATUS_ACCESS_DENIED ) {
                    BaseSetLastNTError(Status);
                    leave;
                }

                //
                // Determine whether or not this failed because the file
                // is a readonly file.  If so, change it to read/write,
                // re-attempt the open, and set it back to readonly again.
                //

                Status = NtQueryInformationFile(
                            hTargetFile,
                            &IoStatus,
                            (PVOID) &FileBasicInformationData,
                            sizeof(FileBasicInformationData),
                            FileBasicInformation
                            );

                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(Status);
                    leave;
                }

                if ( FileBasicInformationData.FileAttributes & FILE_ATTRIBUTE_READONLY ) {
                    ULONG attributes = FileBasicInformationData.FileAttributes;

                    RtlZeroMemory( &FileBasicInformationData,
                                   sizeof(FileBasicInformationData)
                                );
                    FileBasicInformationData.FileAttributes = FILE_ATTRIBUTE_NORMAL;
                    (VOID) NtSetInformationFile(
                              hTargetFile,
                              &IoStatus,
                              &FileBasicInformationData,
                              sizeof(FileBasicInformationData),
                              FileBasicInformation
                              );
                    Status = NtCreateFile(
                                &DestFile,
                                DesiredAccess,
                                &ObjectAttributes,
                                &IoStatus,
                                lpFileSize,
                                0,
                                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                Disposition,
                                FlagsAndAttributes,
                                (PVOID)NULL,
                                0);
                    FileBasicInformationData.FileAttributes = attributes;
                    (VOID) NtSetInformationFile(
                                hTargetFile,
                                &IoStatus,
                                &FileBasicInformationData,
                                sizeof(FileBasicInformationData),
                                FileBasicInformation
                                );
                    if ( !NT_SUCCESS(Status) ) {
                        BaseSetLastNTError(Status);
                        leave;
                    }
                } else {
                    leave;
                }
            }

            //
            // Adjust the file length in the case of a destination open with the
            // reparse behavior inhibited. This is needed because of the incompatibility
            // between FILE_OPEN_REPARSE_POINT and FILE_OVERWRITE_IF.
            //

            if ( OpenFileAsReparsePoint ) {
               if ( !(*lpCopyFlags & COPY_FILE_FAIL_IF_EXISTS) ||
                    !(Restartable && (lpRestartState->LastKnownGoodOffset.QuadPart)) ) {
                   SetFilePointer(DestFile,0,NULL,FILE_BEGIN);
               }
            }

        }   // if ( !ARGUMENT_PRESENT(hTargetFile) ) ... else

        //
        // Adjust the notion of restartability and chunk size based on whether
        // or not one of the files is remote.
        //

        if ( Restartable || lpFileSize->QuadPart >= BASE_COPY_FILE_CHUNK ) {
            if ( BasepRemoteFile(hSourceFile,DestFile) ) {
                *lpCopySize = BASE_COPY_FILE_CHUNK - 4096;
            } else if ( Restartable ) {
                *lpCopyFlags &= ~COPY_FILE_RESTARTABLE;
                Restartable = FALSE;
            }
        }

        //
        // Preallocate the size of this file/stream so that extends do not
        // occur.
        //

        if ( !(Restartable && lpRestartState->LastKnownGoodOffset.QuadPart) &&
            lpFileSize->QuadPart) {

            EndOfFileInformation.EndOfFile = *lpFileSize;
            Status = NtSetInformationFile(
                        DestFile,
                        &IoStatus,
                        &EndOfFileInformation,
                        sizeof(EndOfFileInformation),
                        FileEndOfFileInformation
                        );
            if ( Status == STATUS_DISK_FULL ) {
                BaseSetLastNTError(Status);
                BaseMarkFileForDelete(
                    DestFile,
                    FileBasicInformationData.FileAttributes
                    );
                CloseHandle(DestFile);
                DestFile = INVALID_HANDLE_VALUE;
                leave;
            }
        }

        //
        // If the caller has a progress routine, invoke it and indicate that the
        // output file or alternate data stream has been created.  Note that a
        // stream number of 1 means that the file itself has been created.
        //

        BytesWritten.QuadPart = 0;
        if ( Context ) {
            if ( Context->lpProgressRoutine ) {
                Context->dwStreamNumber += 1;
                ReturnCode = Context->lpProgressRoutine(
                                Context->TotalFileSize,
                                Context->TotalBytesTransferred,
                                *lpFileSize,
                                BytesWritten,
                                Context->dwStreamNumber,
                                CALLBACK_STREAM_SWITCH,
                                hSourceFile,
                                DestFile,
                                Context->lpData
                                );
            } else {
                ReturnCode = PROGRESS_CONTINUE;
            }

            if ( ReturnCode == PROGRESS_CANCEL ||
                (Context->lpCancel && *Context->lpCancel) ) {
                BaseMarkFileForDelete(
                    hTargetFile ? hTargetFile : DestFile,
                    FileBasicInformationData.FileAttributes
                    );
                BaseSetLastNTError(STATUS_REQUEST_ABORTED);
                leave;
            }

            if ( ReturnCode == PROGRESS_STOP ) {
                BaseSetLastNTError(STATUS_REQUEST_ABORTED);
                leave;
            }

            if ( ReturnCode == PROGRESS_QUIET ) {
                Context = NULL;
                *lpCopyFileContext = NULL;
            }
        }


        if (!Restartable) {

            while (!lpFileSize->HighPart && (lpFileSize->LowPart < TWO56K)) {

                // If there's nothing to copy, then we're done (this happens when
                // copying directory files, as there's no unnamed data stream).

                if( lpFileSize->LowPart == 0 ) {
                    ReturnValue = TRUE;
                    leave;
                }

                //
                // Create a section and map the source file.  If anything fails,
                // then drop into an I/O system copy mode.
                //

                Status = NtCreateSection(
                    &Section,
                        SECTION_ALL_ACCESS,
                        NULL,
                        NULL,
                        PAGE_READONLY,
                        SEC_COMMIT,
                        hSourceFile
                    );
                if ( !NT_SUCCESS(Status) ) {
                    break;
                }

                SectionOffset.LowPart = 0;
                SectionOffset.HighPart = 0;
                ViewSize = 0;
                BigViewSize = 0;

                Status = NtMapViewOfSection(
                    Section,
                    NtCurrentProcess(),
                    &SourceBase,
                    0L,
                    0L,
                    &SectionOffset,
                    &BigViewSize,
                    ViewShare,
                    0L,
                    PAGE_READONLY
                    );
                NtClose(Section);
                Section = NULL;
                if ( !NT_SUCCESS(Status) ) {
                    break;
                }

                //
                // note that this is OK since ViewSize will never be > 256k in this path
                //

                ViewSize = (ULONG)BigViewSize;

                //
                // Everything is mapped, so copy the stream
                //

                SourceBuffer = SourceBase;
                BytesToWrite = lpFileSize->LowPart;

                //
                //  Since we are playing with user memory here, the user
                //  may decommit or unmap it on us.  We wrap the access
                //  in try/except to clean up if anything goes wrong
                //
                //  We set ReturnCode inside the try/except so that we
                //  can detect failure and leave from the enclosing try/finally.
                //

                ReturnCode = TRUE;

                try {

                    while (BytesToWrite) {
                        if (BytesToWrite > *lpCopySize) {
                            ViewSize = *lpCopySize;
                        } else {
                            ViewSize = BytesToWrite;
                        }

                        if ( !WriteFile(DestFile,SourceBuffer,ViewSize, &ViewSize, NULL) ) {
                            if ( !ARGUMENT_PRESENT(hTargetFile) &&
                                GetLastError() != ERROR_NO_MEDIA_IN_DRIVE ) {

                                BaseMarkFileForDelete(
                                    DestFile,
                                    FileBasicInformationData.FileAttributes
                                    );
                            }
                            ReturnCode = PROGRESS_STOP;
                            leave;
                        }

                        BytesToWrite -= ViewSize;
                        SourceBuffer += ViewSize;

                        //
                        // If the caller has a progress routine, invoke it for this
                        // chunk's completion.
                        //

                        if ( Context ) {
                            if ( Context->lpProgressRoutine ) {
                                BytesWritten.QuadPart += ViewSize;
                                Context->TotalBytesTransferred.QuadPart += ViewSize;
                                ReturnCode = Context->lpProgressRoutine(
                                    Context->TotalFileSize,
                                    Context->TotalBytesTransferred,
                                    *lpFileSize,
                                    BytesWritten,
                                    Context->dwStreamNumber,
                                    CALLBACK_CHUNK_FINISHED,
                                    hSourceFile,
                                    DestFile,
                                    Context->lpData
                                    );
                            } else {
                                ReturnCode = PROGRESS_CONTINUE;
                            }

                            if ( ReturnCode == PROGRESS_CANCEL ||
                                 (Context->lpCancel && *Context->lpCancel) ) {
                                if ( !ARGUMENT_PRESENT(hTargetFile) ) {
                                    BaseMarkFileForDelete(
                                        hTargetFile ? hTargetFile : DestFile,
                                        FileBasicInformationData.FileAttributes
                                        );
                                    BaseSetLastNTError(STATUS_REQUEST_ABORTED);
                                }
                                ReturnCode = PROGRESS_STOP;
                                leave;
                            }

                            if ( ReturnCode == PROGRESS_STOP ) {
                                BaseSetLastNTError(STATUS_REQUEST_ABORTED);
                                ReturnCode = PROGRESS_STOP;
                                leave;
                            }

                            if ( ReturnCode == PROGRESS_QUIET ) {
                                Context = NULL;
                                *lpCopyFileContext = NULL;
                            }
                        }
                    }   // while (BytesToWrite)

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    if ( !ARGUMENT_PRESENT(hTargetFile) ) {
                        BaseMarkFileForDelete(
                            DestFile,
                            FileBasicInformationData.FileAttributes
                            );
                    }
                    BaseSetLastNTError(GetExceptionCode());
                    ReturnCode = PROGRESS_STOP;
                }

                if (ReturnCode != PROGRESS_STOP) {
                    ReturnValue = TRUE;
                }

                leave;

            }   // while (!lpFileSize->HighPart && (lpFileSize->LowPart < TWO56K)
        }   // if (!Restartable)

        if ( Restartable ) {

            //
            // A restartable operation is being performed.  Reset the state
            // of the copy to the last known good offset that was written
            // to the output file to continue the operation.
            //

            SetFilePointer(
                hSourceFile,
                lpRestartState->LastKnownGoodOffset.LowPart,
                &lpRestartState->LastKnownGoodOffset.HighPart,
                FILE_BEGIN
                );
            SetFilePointer(
                DestFile,
                lpRestartState->LastKnownGoodOffset.LowPart,
                &lpRestartState->LastKnownGoodOffset.HighPart,
                FILE_BEGIN
                );
            BytesWritten.QuadPart = lpRestartState->LastKnownGoodOffset.QuadPart;
        }

        IoDestBase = RtlAllocateHeap(
                        RtlProcessHeap(),
                        MAKE_TAG( TMP_TAG ),
                        *lpCopySize
                        );
        if ( !IoDestBase ) {
            if ( !ARGUMENT_PRESENT(hTargetFile) && !Restartable ) {
                BaseMarkFileForDelete(
                    DestFile,
                    FileBasicInformationData.FileAttributes
                    );
            }
            BaseSetLastNTError(STATUS_NO_MEMORY);
            leave;
        }



        do {

            BlockSize = *lpCopySize;
            fSkipBlock = FALSE;


            if (!fSkipBlock) {
                b = ReadFile(hSourceFile,IoDestBase,BlockSize, &ViewSize, NULL);
            } else {
                LARGE_INTEGER BytesRead;
                BytesRead = BytesWritten;

                if (BytesRead.QuadPart > lpFileSize->QuadPart) {
                    BlockSize = 0;
                } else if (BytesRead.QuadPart + BlockSize >= lpFileSize->QuadPart) {
                    BlockSize = (ULONG)(lpFileSize->QuadPart - BytesRead.QuadPart);
                }

                BytesRead.QuadPart += BlockSize;
                if ( SetFilePointer(hSourceFile,
                                    BytesRead.LowPart,
                                    &BytesRead.HighPart,
                                    FILE_BEGIN) != 0xffffffff ) {
                } else {
                    if (GetLastError() != NO_ERROR)
                        b = FALSE;
                }
                ViewSize = BlockSize;
            }

            if (!b || !ViewSize)
                break;

            if (!fSkipBlock) {
                if ( !WriteFile(DestFile,IoDestBase,ViewSize, &ViewSize, NULL) ) {
                    if ( !ARGUMENT_PRESENT(hTargetFile) &&
                         GetLastError() != ERROR_NO_MEDIA_IN_DRIVE &&
                         !Restartable ) {

                        BaseMarkFileForDelete(
                                             DestFile,
                                             FileBasicInformationData.FileAttributes
                                             );
                    }

                    leave;
                }
                BytesWritten.QuadPart += ViewSize;
            } else {
                BytesWritten.QuadPart += ViewSize;
                if (( SetFilePointer(DestFile,
                                     BytesWritten.LowPart,
                                     &BytesWritten.HighPart,
                                     FILE_BEGIN) == 0xffffffff ) &&
                    ( GetLastError() != NO_ERROR )) {
                    b = FALSE;
                    break;
                }
            }

            WriteCount++;

            if ( Restartable &&
                 (((WriteCount & 3) == 0 &&
                   BytesWritten.QuadPart ) ||
                  BytesWritten.QuadPart == lpFileSize->QuadPart) ) {

                LARGE_INTEGER SavedOffset;
                DWORD Bytes;
                HANDLE DestinationFile = hTargetFile ? hTargetFile : DestFile;

                //
                // Another 256kb has been written to the target file, or
                // this stream of the file has been completely copied, so
                // update the restart state in the output file accordingly.
                //

                NtFlushBuffersFile(DestinationFile,&IoStatus);
                SavedOffset.QuadPart = BytesWritten.QuadPart;
                SetFilePointer(DestinationFile,0,NULL,FILE_BEGIN);
                lpRestartState->LastKnownGoodOffset.QuadPart = BytesWritten.QuadPart;
                lpRestartState->Checksum = BasepChecksum((PUSHORT)lpRestartState,FIELD_OFFSET(RESTART_STATE,Checksum) >> 1);
                b = WriteFile(
                             DestinationFile,
                             lpRestartState,
                             sizeof(RESTART_STATE),
                             &Bytes,
                             NULL
                             );
                if ( !b || Bytes != sizeof(RESTART_STATE) ) {
                    leave;
                }
                NtFlushBuffersFile(DestinationFile,&IoStatus);
                SetFilePointer(
                              DestinationFile,
                              SavedOffset.LowPart,
                              &SavedOffset.HighPart,
                              FILE_BEGIN
                              );
            }

            //
            // If the caller has a progress routine, invoke it for this
            // chunk's completion.
            //

            if ( Context ) {
                if ( Context->lpProgressRoutine ) {
                    Context->TotalBytesTransferred.QuadPart += ViewSize;
                    ReturnCode = Context->lpProgressRoutine(
                                                           Context->TotalFileSize,
                                                           Context->TotalBytesTransferred,
                                                           *lpFileSize,
                                                           BytesWritten,
                                                           Context->dwStreamNumber,
                                                           CALLBACK_CHUNK_FINISHED,
                                                           hSourceFile,
                                                           DestFile,
                                                           Context->lpData
                                                           );
                } else {
                    ReturnCode = PROGRESS_CONTINUE;
                }
                if ( ReturnCode == PROGRESS_CANCEL ||
                     (Context->lpCancel && *Context->lpCancel) ) {
                    if ( !ARGUMENT_PRESENT(hTargetFile) ) {
                        BaseMarkFileForDelete(
                                             hTargetFile ? hTargetFile : DestFile,
                                             FileBasicInformationData.FileAttributes
                                             );
                        BaseSetLastNTError(STATUS_REQUEST_ABORTED);
                        leave;
                    }
                }

                if ( ReturnCode == PROGRESS_STOP ) {
                    BaseSetLastNTError(STATUS_REQUEST_ABORTED);
                    leave;
                }

                if ( ReturnCode == PROGRESS_QUIET ) {
                    Context = NULL;
                    *lpCopyFileContext = NULL;
                }
            }
        } while (TRUE);

        if ( !b && !ARGUMENT_PRESENT(hTargetFile) ) {
            if ( !Restartable ) {
                BaseMarkFileForDelete(
                    DestFile,
                    FileBasicInformationData.FileAttributes
                    );
            }
            leave;
        }

        ReturnValue = TRUE;
    } finally {
        if ( DestFile != INVALID_HANDLE_VALUE ) {
            *lpDestFile = DestFile;
        }
        if ( Section ) {
            NtClose(Section);
        }
        if ( SourceBase ) {
            NtUnmapViewOfSection(NtCurrentProcess(),SourceBase);
        }
        RtlFreeHeap(RtlProcessHeap(), 0,IoDestBase);
        RtlFreeHeap(RtlProcessHeap(), 0, DestFileNameBuffer );
        RtlFreeHeap(RtlProcessHeap(), 0, EaBuffer );

        // If the TEB buffer was saved, restore it now.
        if( lpExistingFileName == SaveStaticUnicodeBuffer ) {

            memcpy( NtCurrentTeb()->StaticUnicodeBuffer,
                    SaveStaticUnicodeBuffer,
                    STATIC_UNICODE_BUFFER_LENGTH );
        }

    }

    return ReturnValue;
}

HANDLE
WINAPI
ReOpenFile(
    HANDLE  hOriginalFile,
    DWORD   dwDesiredAccess,
    DWORD   dwShareMode,
    DWORD   dwFlags
    )
/*++

Routine Description:

    This API allows an application to reopen a file with different access, share modes
    and flags given an already open handle. This API should be used if the application wants
    to ensure that the original file does not go away but wants to reopen it with 

Arguments:

    hOriginalFile - Supplies the handle to the original file relative to which 
        we open a new handle.

    dwDesiredAccess - Supplies the caller's desired access to the file. Any combination of 
        flags can be passed in (like FILE_READ_ATTRIBUTES)

        Possible DesiredAccess Flags:

        GENERIC_READ - Read access to the file is requested.  This
            allows data to be read from the file and the file pointer to
            be modified.

        GENERIC_WRITE - Write access to the file is requested.  This
            allows data to be written to the file and the file pointer to
            be modified.


    dwShareMode - Supplies a set of flags that indicates how this file is
        to be shared with other openers of the file.  A value of zero
        for this parameter indicates no sharing of the file, or
        exclusive access to the file is to occur.

        ShareMode Flags:

        FILE_SHARE_READ - Other open operations may be performed on the
            file for read access.

        FILE_SHARE_WRITE - Other open operations may be performed on the
            file for write access.

        FILE_SHARE_DELETE - Other open operations may be performed on the
            file for delete access.

    dwFlags - Specifies flags and attributes for the file.

        The attributes are not accepted by this API as they are used only for Creating a file
        This API reopens an existing file. All FILE_ATTRIBUTE_* flags are not allowed.
        
        dwFlagsAndAttributes Flags:


        FILE_FLAG_WRITE_THROUGH - Indicates that the system should
            always write through any intermediate cache and go directly
            to the file.  The system may still cache writes, but may not
            lazily flush the writes.

        FILE_FLAG_OVERLAPPED - Indicates that the system should initialize
            the file so that ReadFile and WriteFile operations that may
            take a significant time to complete will return ERROR_IO_PENDING.
            An event will be set to the signalled state when the operation
            completes. When FILE_FLAG_OVERLAPPED is specified the system will
            not maintain the file pointer. The position to read/write from
            is passed to the system as part of the OVERLAPPED structure
            which is an optional parameter to ReadFile and WriteFile.

        FILE_FLAG_NO_BUFFERING - Indicates that the file is to be opened
            with no intermediate buffering or caching done by the
            system.  Reads and writes to the file must be done on sector
            boundries.  Buffer addresses for reads and writes must be
            aligned on at least disk sector boundries in memory.

        FILE_FLAG_RANDOM_ACCESS - Indicates that access to the file may
            be random. The system cache manager may use this to influence
            its caching strategy for this file.

        FILE_FLAG_SEQUENTIAL_SCAN - Indicates that access to the file
            may be sequential.  The system cache manager may use this to
            influence its caching strategy for this file.  The file may
            in fact be accessed randomly, but the cache manager may
            optimize its cacheing policy for sequential access.

        FILE_FLAG_DELETE_ON_CLOSE - Indicates that the file is to be
            automatically deleted when the last handle to it is closed.

        FILE_FLAG_BACKUP_SEMANTICS - Indicates that the file is being opened
            or created for the purposes of either a backup or a restore
            operation.  Thus, the system should make whatever checks are
            appropriate to ensure that the caller is able to override
            whatever security checks have been placed on the file to allow
            this to happen.

        FILE_FLAG_POSIX_SEMANTICS - Indicates that the file being opened
            should be accessed in a manner compatible with the rules used
            by POSIX.  This includes allowing multiple files with the same
            name, differing only in case.  WARNING:  Use of this flag may
            render it impossible for a DOS, WIN-16, or WIN-32 application
            to access the file.

        FILE_FLAG_OPEN_REPARSE_POINT - Indicates that the file being opened
            should be accessed as if it were a reparse point.  WARNING:  Use
            of this flag may inhibit the operation of file system filter drivers
            present in the I/O subsystem.

        FILE_FLAG_OPEN_NO_RECALL - Indicates that all the state of the file
            should be acessed without changing its storage location.  Thus,
            in the case of files that have parts of its state stored at a
            remote servicer, no permanent recall of data is to happen.

    Security Quality of Service information may also be specified in
        the dwFlagsAndAttributes parameter.  These bits are meaningful
        only if the file being opened is the client side of a Named
        Pipe.  Otherwise they are ignored.

        SECURITY_SQOS_PRESENT - Indicates that the Security Quality of
            Service bits contain valid values.

    Impersonation Levels:

        SECURITY_ANONYMOUS - Specifies that the client should be impersonated
            at Anonymous impersonation level.

        SECURITY_IDENTIFICAION - Specifies that the client should be impersonated
            at Identification impersonation level.

        SECURITY_IMPERSONATION - Specifies that the client should be impersonated
            at Impersonation impersonation level.

        SECURITY_DELEGATION - Specifies that the client should be impersonated
            at Delegation impersonation level.

    Context Tracking:

        SECURITY_CONTEXT_TRACKING - A boolean flag that when set,
            specifies that the Security Tracking Mode should be
            Dynamic, otherwise Static.

        SECURITY_EFFECTIVE_ONLY - A boolean flag indicating whether
            the entire security context of the client is to be made
            available to the server or only the effective aspects of
            the context.

Return Value:

    Not -1 - Returns an open handle to the specified file.  Subsequent
        access to the file is controlled by the DesiredAccess parameter.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    ULONG CreateFlags = 0;
    ULONG CreateDisposition;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    DWORD SQOSFlags;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel = 0;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    UNICODE_STRING  FileName;

    //
    // Don't support console handles.
    //

    if (CONSOLE_HANDLE(hOriginalFile)) {
        BaseSetLastNTError(STATUS_INVALID_HANDLE);
        return INVALID_HANDLE_VALUE;
    }

    //
    // The attributes are useless as this reopen of an existing file.
    //

    if (dwFlags &  FILE_ATTRIBUTE_VALID_FLAGS) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    //
    // Initialize all the create flags from the Attribute flags.
    //

    CreateFlags |= (dwFlags & FILE_FLAG_NO_BUFFERING ? FILE_NO_INTERMEDIATE_BUFFERING : 0 );
    CreateFlags |= (dwFlags & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwFlags & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT );
    CreateFlags |= (dwFlags & FILE_FLAG_SEQUENTIAL_SCAN ? FILE_SEQUENTIAL_ONLY : 0 );
    CreateFlags |= (dwFlags & FILE_FLAG_RANDOM_ACCESS ? FILE_RANDOM_ACCESS : 0 );
    CreateFlags |= (dwFlags & FILE_FLAG_BACKUP_SEMANTICS ? FILE_OPEN_FOR_BACKUP_INTENT : 0 );
    CreateFlags |= (dwFlags & FILE_FLAG_OPEN_REPARSE_POINT ? FILE_OPEN_REPARSE_POINT : 0 );
    CreateFlags |= (dwFlags & FILE_FLAG_OPEN_NO_RECALL ? FILE_OPEN_NO_RECALL : 0 );

    if ( dwFlags & FILE_FLAG_DELETE_ON_CLOSE ) {
        CreateFlags |= FILE_DELETE_ON_CLOSE;
        dwDesiredAccess |= DELETE;
        }

    CreateFlags |= FILE_NON_DIRECTORY_FILE;
    CreateDisposition = FILE_OPEN;

    RtlInitUnicodeString( &FileName, L"");
    
    //
    // Pass a NULL name relative to the original handle.
    //

    InitializeObjectAttributes(
        &Obja,
        &FileName,  
        dwFlags & FILE_FLAG_POSIX_SEMANTICS ? 0 : OBJ_CASE_INSENSITIVE,
        hOriginalFile,  // Related handle
        NULL
        );

    SQOSFlags = dwFlags & SECURITY_VALID_SQOS_FLAGS;

    if ( SQOSFlags & SECURITY_SQOS_PRESENT ) {

        SQOSFlags &= ~SECURITY_SQOS_PRESENT;

        if (SQOSFlags & SECURITY_CONTEXT_TRACKING) {

            SecurityQualityOfService.ContextTrackingMode = (SECURITY_CONTEXT_TRACKING_MODE) TRUE;
            SQOSFlags &= ~SECURITY_CONTEXT_TRACKING;

        } else {

            SecurityQualityOfService.ContextTrackingMode = (SECURITY_CONTEXT_TRACKING_MODE) FALSE;
        }

        if (SQOSFlags & SECURITY_EFFECTIVE_ONLY) {

            SecurityQualityOfService.EffectiveOnly = TRUE;
            SQOSFlags &= ~SECURITY_EFFECTIVE_ONLY;

        } else {

            SecurityQualityOfService.EffectiveOnly = FALSE;
        }

        SecurityQualityOfService.ImpersonationLevel = SQOSFlags >> 16;


    } else {

        SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
        SecurityQualityOfService.EffectiveOnly = TRUE;
    }

    SecurityQualityOfService.Length = sizeof( SECURITY_QUALITY_OF_SERVICE );
    Obja.SecurityQualityOfService = &SecurityQualityOfService;

    Status = NtCreateFile(
                &Handle,
                (ACCESS_MASK)dwDesiredAccess | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                NULL,
                0,
                dwShareMode,
                CreateDisposition,
                CreateFlags,
                NULL,
                0
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
    }

    SetLastError(0);

    return Handle;
}

HANDLE
WINAPI
CreateFileA(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )

/*++

Routine Description:

    ANSI thunk to CreateFileW

--*/

{

    PUNICODE_STRING Unicode;

    Unicode = Basep8BitStringToStaticUnicodeString( lpFileName );
    if (Unicode == NULL) {
        return INVALID_HANDLE_VALUE;
    }

    return ( CreateFileW( Unicode->Buffer,
                          dwDesiredAccess,
                          dwShareMode,
                          lpSecurityAttributes,
                          dwCreationDisposition,
                          dwFlagsAndAttributes,
                          hTemplateFile
                        )
           );
}

HANDLE
WINAPI
CreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )

/*++

Routine Description:

    A file can be created, opened, or truncated, and a handle opened to
    access the new file using CreateFile.

    This API is used to create or open a file and obtain a handle to it
    that allows reading data, writing data, and moving the file pointer.

    This API allows the caller to specify the following creation
    dispositions:

      - Create a new file and fail if the file exists ( CREATE_NEW )

      - Create a new file and succeed if it exists ( CREATE_ALWAYS )

      - Open an existing file ( OPEN_EXISTING )

      - Open and existing file or create it if it does not exist (
        OPEN_ALWAYS )

      - Truncate and existing file ( TRUNCATE_EXISTING )

    If this call is successful, a handle is returned that has
    appropriate access to the specified file.

    If as a result of this call, a file is created,

      - The attributes of the file are determined by the value of the
        FileAttributes parameter or'd with the FILE_ATTRIBUTE_ARCHIVE bit.

      - The length of the file will be set to zero.

      - If the hTemplateFile parameter is specified, any extended
        attributes associated with the file are assigned to the new file.

    If a new file is not created, then the hTemplateFile is ignored as
    are any extended attributes.

    For DOS based systems running share.exe the file sharing semantics
    work as described above.  Without share.exe no share level
    protection exists.

    This call is logically equivalent to DOS (int 21h, function 5Bh), or
    DOS (int 21h, function 3Ch) depending on the value of the
    FailIfExists parameter.

Arguments:

    lpFileName - Supplies the file name of the file to open.  Depending on
        the value of the FailIfExists parameter, this name may or may
        not already exist.

    dwDesiredAccess - Supplies the caller's desired access to the file.

        DesiredAccess Flags:

        GENERIC_READ - Read access to the file is requested.  This
            allows data to be read from the file and the file pointer to
            be modified.

        GENERIC_WRITE - Write access to the file is requested.  This
            allows data to be written to the file and the file pointer to
            be modified.

    dwShareMode - Supplies a set of flags that indicates how this file is
        to be shared with other openers of the file.  A value of zero
        for this parameter indicates no sharing of the file, or
        exclusive access to the file is to occur.

        ShareMode Flags:

        FILE_SHARE_READ - Other open operations may be performed on the
            file for read access.

        FILE_SHARE_WRITE - Other open operations may be performed on the
            file for write access.

    lpSecurityAttributes - An optional parameter that, if present, and
        supported on the target file system supplies a security
        descriptor for the new file.

    dwCreationDisposition - Supplies a creation disposition that
        specifies how this call is to operate.  This parameter must be
        one of the following values.

        dwCreationDisposition Value:

        CREATE_NEW - Create a new file.  If the specified file already
            exists, then fail.  The attributes for the new file are what
            is specified in the dwFlagsAndAttributes parameter or'd with
            FILE_ATTRIBUTE_ARCHIVE.  If the hTemplateFile is specified,
            then any extended attributes associated with that file are
            propogated to the new file.

        CREATE_ALWAYS - Always create the file.  If the file already
            exists, then it is overwritten.  The attributes for the new
            file are what is specified in the dwFlagsAndAttributes
            parameter or'd with FILE_ATTRIBUTE_ARCHIVE.  If the
            hTemplateFile is specified, then any extended attributes
            associated with that file are propogated to the new file.

        OPEN_EXISTING - Open the file, but if it does not exist, then
            fail the call.

        OPEN_ALWAYS - Open the file if it exists.  If it does not exist,
            then create the file using the same rules as if the
            disposition were CREATE_NEW.

        TRUNCATE_EXISTING - Open the file, but if it does not exist,
            then fail the call.  Once opened, the file is truncated such
            that its size is zero bytes.  This disposition requires that
            the caller open the file with at least GENERIC_WRITE access.

    dwFlagsAndAttributes - Specifies flags and attributes for the file.
        The attributes are only used when the file is created (as
        opposed to opened or truncated).  Any combination of attribute
        flags is acceptable except that all other attribute flags
        override the normal file attribute, FILE_ATTRIBUTE_NORMAL.  The
        FILE_ATTRIBUTE_ARCHIVE flag is always implied.

        dwFlagsAndAttributes Flags:

        FILE_ATTRIBUTE_NORMAL - A normal file should be created.

        FILE_ATTRIBUTE_READONLY - A read-only file should be created.

        FILE_ATTRIBUTE_HIDDEN - A hidden file should be created.

        FILE_ATTRIBUTE_SYSTEM - A system file should be created.

        FILE_FLAG_WRITE_THROUGH - Indicates that the system should
            always write through any intermediate cache and go directly
            to the file.  The system may still cache writes, but may not
            lazily flush the writes.

        FILE_FLAG_OVERLAPPED - Indicates that the system should initialize
            the file so that ReadFile and WriteFile operations that may
            take a significant time to complete will return ERROR_IO_PENDING.
            An event will be set to the signalled state when the operation
            completes. When FILE_FLAG_OVERLAPPED is specified the system will
            not maintain the file pointer. The position to read/write from
            is passed to the system as part of the OVERLAPPED structure
            which is an optional parameter to ReadFile and WriteFile.

        FILE_FLAG_NO_BUFFERING - Indicates that the file is to be opened
            with no intermediate buffering or caching done by the
            system.  Reads and writes to the file must be done on sector
            boundries.  Buffer addresses for reads and writes must be
            aligned on at least disk sector boundries in memory.

        FILE_FLAG_RANDOM_ACCESS - Indicates that access to the file may
            be random. The system cache manager may use this to influence
            its caching strategy for this file.

        FILE_FLAG_SEQUENTIAL_SCAN - Indicates that access to the file
            may be sequential.  The system cache manager may use this to
            influence its caching strategy for this file.  The file may
            in fact be accessed randomly, but the cache manager may
            optimize its cacheing policy for sequential access.

        FILE_FLAG_DELETE_ON_CLOSE - Indicates that the file is to be
            automatically deleted when the last handle to it is closed.

        FILE_FLAG_BACKUP_SEMANTICS - Indicates that the file is being opened
            or created for the purposes of either a backup or a restore
            operation.  Thus, the system should make whatever checks are
            appropriate to ensure that the caller is able to override
            whatever security checks have been placed on the file to allow
            this to happen.

        FILE_FLAG_POSIX_SEMANTICS - Indicates that the file being opened
            should be accessed in a manner compatible with the rules used
            by POSIX.  This includes allowing multiple files with the same
            name, differing only in case.  WARNING:  Use of this flag may
            render it impossible for a DOS, WIN-16, or WIN-32 application
            to access the file.

        FILE_FLAG_OPEN_REPARSE_POINT - Indicates that the file being opened
            should be accessed as if it were a reparse point.  WARNING:  Use
            of this flag may inhibit the operation of file system filter drivers
            present in the I/O subsystem.

        FILE_FLAG_OPEN_NO_RECALL - Indicates that all the state of the file
            should be acessed without changing its storage location.  Thus,
            in the case of files that have parts of its state stored at a
            remote servicer, no permanent recall of data is to happen.

    Security Quality of Service information may also be specified in
        the dwFlagsAndAttributes parameter.  These bits are meaningful
        only if the file being opened is the client side of a Named
        Pipe.  Otherwise they are ignored.

        SECURITY_SQOS_PRESENT - Indicates that the Security Quality of
            Service bits contain valid values.

    Impersonation Levels:

        SECURITY_ANONYMOUS - Specifies that the client should be impersonated
            at Anonymous impersonation level.

        SECURITY_IDENTIFICAION - Specifies that the client should be impersonated
            at Identification impersonation level.

        SECURITY_IMPERSONATION - Specifies that the client should be impersonated
            at Impersonation impersonation level.

        SECURITY_DELEGATION - Specifies that the client should be impersonated
            at Delegation impersonation level.

    Context Tracking:

        SECURITY_CONTEXT_TRACKING - A boolean flag that when set,
            specifies that the Security Tracking Mode should be
            Dynamic, otherwise Static.

        SECURITY_EFFECTIVE_ONLY - A boolean flag indicating whether
            the entire security context of the client is to be made
            available to the server or only the effective aspects of
            the context.

    hTemplateFile - An optional parameter, then if specified, supplies a
        handle with GENERIC_READ access to a template file.  The
        template file is used to supply extended attributes for the file
        being created.  When the new file is created, the relevant attributes
        from the template file are used in creating the new file.

Return Value:

    Not -1 - Returns an open handle to the specified file.  Subsequent
        access to the file is controlled by the DesiredAccess parameter.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;
    ULONG CreateDisposition;
    ULONG CreateFlags;
    FILE_ALLOCATION_INFORMATION AllocationInfo;
    FILE_EA_INFORMATION EaInfo;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    ULONG EaSize;
    PCUNICODE_STRING lpConsoleName;
    BOOL bInheritHandle;
    BOOL EndsInSlash;
    DWORD SQOSFlags;
    BOOLEAN ContextTrackingMode = FALSE;
    BOOLEAN EffectiveOnly = FALSE;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel = 0;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

    switch ( dwCreationDisposition ) {
        case CREATE_NEW        :
            CreateDisposition = FILE_CREATE;
            break;
        case CREATE_ALWAYS     :
            CreateDisposition = FILE_OVERWRITE_IF;
            break;
        case OPEN_EXISTING     :
            CreateDisposition = FILE_OPEN;
            break;
        case OPEN_ALWAYS       :
            CreateDisposition = FILE_OPEN_IF;
            break;
        case TRUNCATE_EXISTING :
            CreateDisposition = FILE_OPEN;
            if ( !(dwDesiredAccess & GENERIC_WRITE) ) {
                BaseSetLastNTError(STATUS_INVALID_PARAMETER);
                return INVALID_HANDLE_VALUE;
                }
            break;
        default :
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
        }

    // temporary routing code

    RtlInitUnicodeString(&FileName,lpFileName);

    if ( FileName.Length > 1 && lpFileName[(FileName.Length >> 1)-1] == (WCHAR)'\\' ) {
        EndsInSlash = TRUE;
        }
    else {
        EndsInSlash = FALSE;
        }

    if ((lpConsoleName = BaseIsThisAConsoleName(&FileName,dwDesiredAccess)) ) {

        Handle = INVALID_HANDLE_VALUE;

        bInheritHandle = FALSE;
        if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
                bInheritHandle = lpSecurityAttributes->bInheritHandle;
            }

        Handle = OpenConsoleW(lpConsoleName->Buffer,
                           dwDesiredAccess,
                           bInheritHandle,
                           FILE_SHARE_READ | FILE_SHARE_WRITE //dwShareMode
                          );

        if ( Handle == INVALID_HANDLE_VALUE ) {
            BaseSetLastNTError(STATUS_ACCESS_DENIED);
            return INVALID_HANDLE_VALUE;
            }
        else {
            SetLastError(0);
             return Handle;
            }
        }
    // end temporary code

    CreateFlags = 0;

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS ? 0 : OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    SQOSFlags = dwFlagsAndAttributes & SECURITY_VALID_SQOS_FLAGS;

    if ( SQOSFlags & SECURITY_SQOS_PRESENT ) {

        SQOSFlags &= ~SECURITY_SQOS_PRESENT;

        if (SQOSFlags & SECURITY_CONTEXT_TRACKING) {

            SecurityQualityOfService.ContextTrackingMode = (SECURITY_CONTEXT_TRACKING_MODE) TRUE;
            SQOSFlags &= ~SECURITY_CONTEXT_TRACKING;

        } else {

            SecurityQualityOfService.ContextTrackingMode = (SECURITY_CONTEXT_TRACKING_MODE) FALSE;
        }

        if (SQOSFlags & SECURITY_EFFECTIVE_ONLY) {

            SecurityQualityOfService.EffectiveOnly = TRUE;
            SQOSFlags &= ~SECURITY_EFFECTIVE_ONLY;

        } else {

            SecurityQualityOfService.EffectiveOnly = FALSE;
        }

        SecurityQualityOfService.ImpersonationLevel = SQOSFlags >> 16;


    } else {

        SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
        SecurityQualityOfService.EffectiveOnly = TRUE;
    }

    SecurityQualityOfService.Length = sizeof( SECURITY_QUALITY_OF_SERVICE );
    Obja.SecurityQualityOfService = &SecurityQualityOfService;

    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle ) {
            Obja.Attributes |= OBJ_INHERIT;
            }
        }

    EaBuffer = NULL;
    EaSize = 0;

    if ( ARGUMENT_PRESENT(hTemplateFile) ) {
        Status = NtQueryInformationFile(
                    hTemplateFile,
                    &IoStatusBlock,
                    &EaInfo,
                    sizeof(EaInfo),
                    FileEaInformation
                    );
        if ( NT_SUCCESS(Status) && EaInfo.EaSize ) {
            EaSize = EaInfo.EaSize;
            do {
                EaSize *= 2;
                EaBuffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), EaSize);
                if ( !EaBuffer ) {
                    RtlReleaseRelativeName(&RelativeName);
                    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
                    BaseSetLastNTError(STATUS_NO_MEMORY);
                    return INVALID_HANDLE_VALUE;
                    }
                Status = NtQueryEaFile(
                            hTemplateFile,
                            &IoStatusBlock,
                            EaBuffer,
                            EaSize,
                            FALSE,
                            (PVOID)NULL,
                            0,
                            (PULONG)NULL,
                            TRUE
                            );
                if ( !NT_SUCCESS(Status) ) {
                    RtlFreeHeap(RtlProcessHeap(), 0,EaBuffer);
                    EaBuffer = NULL;
                    IoStatusBlock.Information = 0;
                    }
                } while ( Status == STATUS_BUFFER_OVERFLOW ||
                          Status == STATUS_BUFFER_TOO_SMALL );
            EaSize = (ULONG)IoStatusBlock.Information;
            }
        }

    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING ? FILE_NO_INTERMEDIATE_BUFFERING : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_SEQUENTIAL_SCAN ? FILE_SEQUENTIAL_ONLY : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_RANDOM_ACCESS ? FILE_RANDOM_ACCESS : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS ? FILE_OPEN_FOR_BACKUP_INTENT : 0 );

    if ( dwFlagsAndAttributes & FILE_FLAG_DELETE_ON_CLOSE ) {
        CreateFlags |= FILE_DELETE_ON_CLOSE;
        dwDesiredAccess |= DELETE;
        }

    if ( dwFlagsAndAttributes & FILE_FLAG_OPEN_REPARSE_POINT ) {
        CreateFlags |= FILE_OPEN_REPARSE_POINT;
        }

    if ( dwFlagsAndAttributes & FILE_FLAG_OPEN_NO_RECALL ) {
        CreateFlags |= FILE_OPEN_NO_RECALL;
        }

    //
    // Backup semantics allow directories to be opened
    //

    if ( !(dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS) ) {
        CreateFlags |= FILE_NON_DIRECTORY_FILE;
        }
    else {

        //
        // Backup intent was specified... Now look to see if we are to allow
        // directory creation
        //

        if ( (dwFlagsAndAttributes & FILE_ATTRIBUTE_DIRECTORY  ) &&
             (dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS ) &&
             (CreateDisposition == FILE_CREATE) ) {
             CreateFlags |= FILE_DIRECTORY_FILE;
             }
        }

    Status = NtCreateFile(
                &Handle,
                (ACCESS_MASK)dwDesiredAccess | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                NULL,
                dwFlagsAndAttributes & (FILE_ATTRIBUTE_VALID_FLAGS & ~FILE_ATTRIBUTE_DIRECTORY),
                dwShareMode,
                CreateDisposition,
                CreateFlags,
                EaBuffer,
                EaSize
                );

    RtlReleaseRelativeName(&RelativeName);

    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    RtlFreeHeap(RtlProcessHeap(), 0, EaBuffer);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        if ( Status == STATUS_OBJECT_NAME_COLLISION ) {
            SetLastError(ERROR_FILE_EXISTS);
            }
        else if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {
            if ( EndsInSlash ) {
                SetLastError(ERROR_PATH_NOT_FOUND);
                }
            else {
                SetLastError(ERROR_ACCESS_DENIED);
                }
            }
        return INVALID_HANDLE_VALUE;
        }

    //
    // if NT returns supersede/overwritten, it means that a create_always, openalways
    // found an existing copy of the file. In this case ERROR_ALREADY_EXISTS is returned
    //

    if ( (dwCreationDisposition == CREATE_ALWAYS && IoStatusBlock.Information == FILE_OVERWRITTEN) ||
         (dwCreationDisposition == OPEN_ALWAYS && IoStatusBlock.Information == FILE_OPENED) ){
        SetLastError(ERROR_ALREADY_EXISTS);
        }
    else {
        SetLastError(0);
        }

    //
    // Truncate the file if required
    //

    if ( dwCreationDisposition == TRUNCATE_EXISTING) {

        AllocationInfo.AllocationSize.QuadPart = 0;
        Status = NtSetInformationFile(
                    Handle,
                    &IoStatusBlock,
                    &AllocationInfo,
                    sizeof(AllocationInfo),
                    FileAllocationInformation
                    );
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            NtClose(Handle);
            Handle = INVALID_HANDLE_VALUE;
            }
        }

    //
    // Deal with hTemplateFile
    //

    return Handle;
}

HFILE
WINAPI
OpenFile(
    LPCSTR lpFileName,
    LPOFSTRUCT lpReOpenBuff,
    UINT uStyle
    )
{

    BOOL b;
    FILETIME LastWriteTime;
    HANDLE hFile;
    DWORD DesiredAccess;
    DWORD ShareMode;
    DWORD CreateDisposition;
    DWORD PathLength;
    LPSTR FilePart;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;
    NTSTATUS Status;
    OFSTRUCT OriginalReOpenBuff;
    BOOL SearchFailed;

    SearchFailed = FALSE;
    OriginalReOpenBuff = *lpReOpenBuff;
    hFile = (HANDLE)-1;
    try {
        SetLastError(0);

        if ( uStyle & OF_PARSE ) {
            PathLength = GetFullPathName(lpFileName,(OFS_MAXPATHNAME - 1),lpReOpenBuff->szPathName,&FilePart);
            if ( PathLength > (OFS_MAXPATHNAME - 1) ) {
                SetLastError(ERROR_INVALID_DATA);
                hFile = (HANDLE)-1;
                goto finally_exit;
                }
            lpReOpenBuff->cBytes = sizeof(*lpReOpenBuff);
            lpReOpenBuff->fFixedDisk = 1;
            lpReOpenBuff->nErrCode = 0;
            lpReOpenBuff->Reserved1 = 0;
            lpReOpenBuff->Reserved2 = 0;
            hFile = (HANDLE)0;
            goto finally_exit;
            }
        //
        // Compute Desired Access
        //

        if ( uStyle & OF_WRITE ) {
            DesiredAccess = GENERIC_WRITE;
            }
        else {
            DesiredAccess = GENERIC_READ;
            }
        if ( uStyle & OF_READWRITE ) {
            DesiredAccess |= (GENERIC_READ | GENERIC_WRITE);
            }

        //
        // Compute ShareMode
        //

        ShareMode = BasepOfShareToWin32Share(uStyle);

        //
        // Compute Create Disposition
        //

        CreateDisposition = OPEN_EXISTING;
        if ( uStyle & OF_CREATE ) {
            CreateDisposition = CREATE_ALWAYS;
            DesiredAccess = (GENERIC_READ | GENERIC_WRITE);
            }

        //
        // if this is anything other than a re-open, fill the re-open buffer
        // with the full pathname for the file
        //

        if ( !(uStyle & OF_REOPEN) ) {
            PathLength = SearchPath(NULL,lpFileName,NULL,OFS_MAXPATHNAME-1,lpReOpenBuff->szPathName,&FilePart);
            if ( PathLength > (OFS_MAXPATHNAME - 1) ) {
                SetLastError(ERROR_INVALID_DATA);
                hFile = (HANDLE)-1;
                goto finally_exit;
                }
            if ( PathLength == 0 ) {
                SearchFailed = TRUE;
                PathLength = GetFullPathName(lpFileName,(OFS_MAXPATHNAME - 1),lpReOpenBuff->szPathName,&FilePart);
                if ( !PathLength || PathLength > (OFS_MAXPATHNAME - 1) ) {
                    SetLastError(ERROR_INVALID_DATA);
                    hFile = (HANDLE)-1;
                    goto finally_exit;
                    }
                }
            }

        //
        // Special case, Delete, Exist, and Parse
        //

        if ( uStyle & OF_EXIST ) {
            if ( !(uStyle & OF_CREATE) ) {
                DWORD FileAttributes;

                if (SearchFailed) {
                    SetLastError(ERROR_FILE_NOT_FOUND);
                    hFile = (HANDLE)-1;
                    goto finally_exit;
                    }

                FileAttributes = GetFileAttributesA(lpReOpenBuff->szPathName);
                if ( FileAttributes == 0xffffffff ) {
                    SetLastError(ERROR_FILE_NOT_FOUND);
                    hFile = (HANDLE)-1;
                    goto finally_exit;
                    }
                if ( FileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
                    SetLastError(ERROR_ACCESS_DENIED);
                    hFile = (HANDLE)-1;
                    goto finally_exit;
                    }
                else {
                    hFile = (HANDLE)1;
                    lpReOpenBuff->cBytes = sizeof(*lpReOpenBuff);
                    goto finally_exit;
                    }
                }
            }

        if ( uStyle & OF_DELETE ) {
            if ( DeleteFile(lpReOpenBuff->szPathName) ) {
                lpReOpenBuff->nErrCode = 0;
                lpReOpenBuff->cBytes = sizeof(*lpReOpenBuff);
                hFile = (HANDLE)1;
                goto finally_exit;
                }
            else {
                lpReOpenBuff->nErrCode = ERROR_FILE_NOT_FOUND;
                hFile = (HANDLE)-1;
                goto finally_exit;
                }
            }


        //
        // Open the file
        //

retry_open:
        hFile = CreateFile(
                    lpReOpenBuff->szPathName,
                    DesiredAccess,
                    ShareMode,
                    NULL,
                    CreateDisposition,
                    0,
                    NULL
                    );

        if ( hFile == INVALID_HANDLE_VALUE ) {

            if ( uStyle & OF_PROMPT
                 && !(GetErrorMode() & SEM_NOOPENFILEERRORBOX)
                 && !(RtlGetThreadErrorMode() & RTL_ERRORMODE_NOOPENFILEERRORBOX)) {
                {
                    DWORD WinErrorStatus;
                    NTSTATUS st,HardErrorStatus;
                    ULONG_PTR ErrorParameter;
                    ULONG ErrorResponse;
                    ANSI_STRING AnsiString;
                    UNICODE_STRING UnicodeString;

                    WinErrorStatus = GetLastError();
                    if ( WinErrorStatus == ERROR_FILE_NOT_FOUND ) {
                        HardErrorStatus = STATUS_NO_SUCH_FILE;
                        }
                    else if ( WinErrorStatus == ERROR_PATH_NOT_FOUND ) {
                        HardErrorStatus = STATUS_OBJECT_PATH_NOT_FOUND;
                        }
                    else {
                        goto finally_exit;
                        }

                    //
                    // Hard error time
                    //

                    RtlInitAnsiString(&AnsiString,lpReOpenBuff->szPathName);
                    st = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
                    if ( !NT_SUCCESS(st) ) {
                        goto finally_exit;
                        }
                    ErrorParameter = (ULONG_PTR)&UnicodeString;

                    HardErrorStatus = NtRaiseHardError(
                                        HardErrorStatus | HARDERROR_OVERRIDE_ERRORMODE,
                                        1,
                                        1,
                                        &ErrorParameter,
                                        OptionRetryCancel,
                                        &ErrorResponse
                                        );
                    RtlFreeUnicodeString(&UnicodeString);
                    if ( NT_SUCCESS(HardErrorStatus) && ErrorResponse == ResponseRetry ) {
                        goto retry_open;
                        }
                    }
                }
            goto finally_exit;
            }

        if ( uStyle & OF_EXIST ) {
            CloseHandle(hFile);
            hFile = (HANDLE)1;
            lpReOpenBuff->cBytes = sizeof(*lpReOpenBuff);
            goto finally_exit;
            }

        //
        // Determine if this is a hard disk.
        //

        Status = NtQueryVolumeInformationFile(
                    hFile,
                    &IoStatusBlock,
                    &DeviceInfo,
                    sizeof(DeviceInfo),
                    FileFsDeviceInformation
                    );
        if ( !NT_SUCCESS(Status) ) {
            CloseHandle(hFile);
            BaseSetLastNTError(Status);
            hFile = (HANDLE)-1;
            goto finally_exit;
            }
        switch ( DeviceInfo.DeviceType ) {

            case FILE_DEVICE_DISK:
            case FILE_DEVICE_DISK_FILE_SYSTEM:
                if ( DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA ) {
                    lpReOpenBuff->fFixedDisk = 0;
                    }
                else {
                    lpReOpenBuff->fFixedDisk = 1;
                    }
                break;

            default:
                lpReOpenBuff->fFixedDisk = 0;
                break;
            }

        //
        // Capture the last write time and save in the open struct.
        //

        b = GetFileTime(hFile,NULL,NULL,&LastWriteTime);

        if ( !b ) {
            lpReOpenBuff->Reserved1 = 0;
            lpReOpenBuff->Reserved2 = 0;
            }
        else {
            b = FileTimeToDosDateTime(
                    &LastWriteTime,
                    &lpReOpenBuff->Reserved1,
                    &lpReOpenBuff->Reserved2
                    );
            if ( !b ) {
                lpReOpenBuff->Reserved1 = 0;
                lpReOpenBuff->Reserved2 = 0;
                }
            }

        lpReOpenBuff->cBytes = sizeof(*lpReOpenBuff);

        //
        // The re-open buffer is completely filled in. Now
        // see if we are quitting (parsing), verifying, or
        // just returning with the file opened.
        //

        if ( uStyle & OF_VERIFY ) {
            if ( OriginalReOpenBuff.Reserved1 == lpReOpenBuff->Reserved1 &&
                 OriginalReOpenBuff.Reserved2 == lpReOpenBuff->Reserved2 &&
                 !strcmp(OriginalReOpenBuff.szPathName,lpReOpenBuff->szPathName) ) {
                goto finally_exit;
                }
            else {
                *lpReOpenBuff = OriginalReOpenBuff;
                CloseHandle(hFile);
                hFile = (HANDLE)-1;
                goto finally_exit;
                }
            }
finally_exit:;
        }
    finally {
        lpReOpenBuff->nErrCode = (WORD)GetLastError();
        }
    return (HFILE)HandleToUlong(hFile);
}

/*++

Routine Description:

    This is an internal routine that modifies the DACL so that 
    BasepCopySecurityInfo will copy over the CreatorOwner inherited ACE.
    This is accomplished by finding the CreatorOwner ACE and marking
    it as "not inherited".

    ReplaceFile does not have enough privileges in a typical app to transfer
    the owner from the previous file to the new copy.  Consequently, the owner
    can change after calling ReplaceFile, which can result in the previous
    owner losing access to the new file, since inherited ACEs are not copied to
    the new file, but are re-inherited from the parent directory.
    If the previous owner had access to the file by the inherited ACE
    CreatorOwner:F -> PreviousOwner:F, changing owners will result in
    CreatorOwner:F -> NewOwner:F, and the previous owner's ACE is dropped.
    By stripping the inherit flag off the previous owner's ACE, it will
    be copied to the new file, and the previous owner will still have access.

Arguments:

    Dacl - DACL to be modified

    PreviousOwner - The current owner of the resource

    NewOwner - The new to-be owner of the resource

Return Value:

    NTSTATUS -- returns STATUS_SUCCESS if previous owner is the same as the new owner, or the previous owner's ACE was marked as "not inherited".


--*/

NTSTATUS BasepCopyCreatorOwnerACE (PACL Dacl,
                                   PSID PreviousOwner,
                                   PSID NewOwner)
{
    NTSTATUS nts = STATUS_SUCCESS;
    ACL_SIZE_INFORMATION aclSize;
    PACCESS_ALLOWED_ACE pACE = NULL;
    WORD wCount;

    if (NULL == PreviousOwner || NULL == Dacl) {
        nts = STATUS_INVALID_PARAMETER;
        goto Err;
    }

    // If the new owner and the previous owner are the same
    // There's no need to change the ACL, so return STATUS_SUCCESS
    if (NewOwner != NULL && RtlEqualSid (NewOwner, PreviousOwner)) {
        nts = STATUS_SUCCESS;
        goto Err;
    }

    if (!NT_SUCCESS(nts = RtlQueryInformationAcl (Dacl, &aclSize,
                                                  sizeof(aclSize),
                                                  AclSizeInformation))) {
        goto Err;
    }

    for (wCount = 0; wCount < aclSize.AceCount; wCount++) {

        if (!NT_SUCCESS(nts = RtlGetAce (Dacl, wCount, (PVOID*) &pACE))) {
            goto Err;
        }

        if (pACE->Header.AceType != ACCESS_ALLOWED_ACE_TYPE)
            continue;

        // Find the previous owner's ACE
        // The previous owner must have full access to the file
        if (RtlEqualSid (PreviousOwner, (PSID) &pACE->SidStart) &&
            pACE->Mask == FILE_ALL_ACCESS) {

            if (pACE->Header.AceFlags & INHERITED_ACE)  // disable the flag
                pACE->Header.AceFlags &= ~INHERITED_ACE;

            break;  // else if flag is not set, previous owner has full access
        }
    }
    
Err:

    return nts;
}


typedef DWORD (WINAPI *GETSECURITYINFOPTR)(
    IN  LPCWSTR                pObjectName,
    IN  SE_OBJECT_TYPE         ObjectType,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSID                 * ppsidOwner,
    OUT PSID                 * ppsidGroup,
    OUT PACL                 * ppDacl,
    OUT PACL                 * ppSacl,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

typedef DWORD (WINAPI *SETSECURITYINFOPTR)(
    IN LPCWSTR               pObjectName,
    IN SE_OBJECT_TYPE        ObjectType,
    IN SECURITY_INFORMATION  SecurityInfo,
    IN PSID                  psidOwner,
    IN PSID                  psidGroup,
    IN PACL                  pDacl,
    IN PACL                  pSacl
    );

typedef BOOL (WINAPI *GETSECURITYDESCRIPTORCONTROLPTR)(
    IN  PSECURITY_DESCRIPTOR           pSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR_CONTROL   pControl,
    OUT LPDWORD                        lpdwRevision
    );

BOOL
BasepCopySecurityInformation( LPCWSTR lpExistingFileName,
                              HANDLE SourceFile,
                              ACCESS_MASK SourceFileAccess,
                              LPCWSTR lpNewFileName,
                              HANDLE DestFile,
                              ACCESS_MASK DestFileAccess,
                              SECURITY_INFORMATION SecurityInformation,
                              LPCOPYFILE_CONTEXT Context,
                              DWORD DestFileFsAttributes,
                              PBOOL DeleteDest,
                              BOOL  CopyCreatorOwnerAce )

/*++

Routine Description:

    This is an internal routine that copies one or more of the DACL,
    SACL, owner, and group from the source to the dest file.

Arguments:

    lpExistingFileName - Provides the name of the source file.

    SourceFile - Provides a handle to that source file.

    SourceFileAccess - The access flags that were used to open SourceFile.

    lpNewFileName - Provides the name of the destination file.

    DestFile - Provides a handle to that destination file.

    DestFileAccess - The access flags that were used to open DestFile.

    SecurityInformation - Specifies what security should be copied (bit
        flag of the *_SECURITY_INFORMATION defines).

    Context - All the information necessary to call the CopyFile callback routine.

    DestFileFsAttributes - Provides the FILE_FS_ATTRIBUTE_INFORMATION.FileSystemAttributes
        for the dest file's volume.

    DeleteDest - Contains a pointer to a value that will be set to TRUE if this the dest
        file should be deleted.  This is the case if there is an error or the user
        cancels the operation.  If the user stops the operation, this routine still
        returns an error, but the dest file is not deleted.

    CopyCreatorOwnerAce - if TRUE, the ACE inherited from CREATOR_OWNER will be copied to the destination.  Normally, inherited ACEs are not copied but are re-inherited when the ACL is applied to the destination.

Return Value:

    TRUE - The operation was successful.

    FALSE- The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    BOOLEAN Succeeded = FALSE;

    PACL Dacl = NULL;
    PACL Sacl = NULL;
    PSID Owner = NULL;
    PSID Group = NULL;
    PSID NewOwner = NULL;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    PSECURITY_DESCRIPTOR NewSecurityDescriptor = NULL;
    DWORD dwError = 0;

    HANDLE Advapi32 = NULL;
    GETSECURITYINFOPTR GetSecurityInfoPtr = NULL;
    SETSECURITYINFOPTR SetSecurityInfoPtr = NULL;
    GETSECURITYDESCRIPTORCONTROLPTR GetSecurityDescriptorControlPtr = NULL;

    SECURITY_DESCRIPTOR_CONTROL Control = 0;
    DWORD dwRevision = 0;
    SECURITY_INFORMATION SecInfoCreatorOwner = 0;

    // If the source file isn't identified, there's nothing we can do.

    if( lpExistingFileName == NULL || lpNewFileName == NULL ) {
        Succeeded = TRUE;
        goto Exit;
    }

    // If the destination doesn't support ACLs, assume it doesn't
    // support any such security information (i.e. owner/group).

    if( !(FILE_PERSISTENT_ACLS & DestFileFsAttributes ) ) {

        if( BasepCopyFileCallback( TRUE,   // Continue (ignore the problem) by default
                                   ERROR_NOT_SUPPORTED,
                                   Context,
                                   NULL,
                                   PRIVCALLBACK_SECURITY_INFORMATION_NOT_SUPPORTED,
                                   SourceFile,
                                   DestFile,
                                   DeleteDest )) {
            // The caller wants to coninue on despite this.
            Succeeded = TRUE;
        }

        goto Exit;
    }

    // Check that DACL is copy-able if necessary

    if( SecurityInformation & DACL_SECURITY_INFORMATION ) {

        // We're supposed to copy the DACL.  Do we have enough access?
        if( !( SourceFileAccess & GENERIC_READ ) ||
            !( DestFileAccess & WRITE_DAC ) ) {

            SecurityInformation &= ~DACL_SECURITY_INFORMATION;

            if( !BasepCopyFileCallback( TRUE,   // Continue (ignore the problem) by default
                                        ERROR_ACCESS_DENIED,
                                        Context,
                                        NULL,
                                        PRIVCALLBACK_DACL_ACCESS_DENIED,
                                        SourceFile,
                                        DestFile,
                                        DeleteDest )) {
                goto Exit;
            }


        }
    }

    // Check that owner & group is copy-able if necessary

    if( (SecurityInformation & OWNER_SECURITY_INFORMATION) ||
        (SecurityInformation & GROUP_SECURITY_INFORMATION) ) {

        // We're supposed to copy owner & group.  Do we have enough access?

        if( !( SourceFileAccess & GENERIC_READ ) ||
            !( DestFileAccess & WRITE_OWNER ) ) {

            SecurityInformation &= ~(OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION);

            if( !BasepCopyFileCallback( TRUE,   // Continue (ignore the problem) by default
                                        ERROR_ACCESS_DENIED,
                                        Context,
                                        NULL,
                                        PRIVCALLBACK_OWNER_GROUP_ACCESS_DENIED,
                                        SourceFile,
                                        DestFile,
                                        DeleteDest )) {
                goto Exit;
            }


        }
    }

    // Check that SACL is copy-able if necessary

    if( SecurityInformation & SACL_SECURITY_INFORMATION ) {

        // We're supposed to copy the SACL.  Do we have enough rights?

        if( !(SourceFileAccess & ACCESS_SYSTEM_SECURITY) ||
            !(DestFileAccess & ACCESS_SYSTEM_SECURITY) ) {

            SecurityInformation &= ~SACL_SECURITY_INFORMATION;

            if( !BasepCopyFileCallback( TRUE,   // Continue (ignore the problem) by default
                                        ERROR_PRIVILEGE_NOT_HELD,
                                        Context,
                                        NULL,
                                        PRIVCALLBACK_SACL_ACCESS_DENIED,
                                        SourceFile,
                                        DestFile,
                                        DeleteDest )) {
                goto Exit;
            }

        }
    }

    // If nothing was copyable (and all was ignorable), then we're done.

    if( SecurityInformation == 0 ) {
        Succeeded = TRUE;
        goto Exit;
    }

    if (CopyCreatorOwnerAce)   // need the previous owner
        SecInfoCreatorOwner |= OWNER_SECURITY_INFORMATION;

    // Get the advapi32 APIs.

    Advapi32 = LoadLibraryW(AdvapiDllString);
    if( NULL == Advapi32 ) {
        *DeleteDest = TRUE;
        goto Exit;
    }

    
    GetSecurityInfoPtr     = (GETSECURITYINFOPTR) GetProcAddress( Advapi32,
                                                                  "GetSecurityInfo" );
    SetSecurityInfoPtr     = (SETSECURITYINFOPTR) GetProcAddress( Advapi32,
                                                                  "SetSecurityInfo" );

    GetSecurityDescriptorControlPtr = (GETSECURITYDESCRIPTORCONTROLPTR) GetProcAddress( Advapi32,
        "GetSecurityDescriptorControl" );

    if( GetSecurityInfoPtr == NULL ||
        GetSecurityDescriptorControlPtr == NULL ||
        SetSecurityInfoPtr == NULL ) {

        SetLastError( ERROR_INVALID_DLL );
        *DeleteDest = TRUE;
        goto Exit;
    }

    // Read in the security information from the source files

    dwError = GetSecurityInfoPtr( SourceFile,
                                  SE_FILE_OBJECT,
                                  SecurityInformation|SecInfoCreatorOwner,
                                  &Owner,
                                  &Group,
                                  &Dacl,
                                  &Sacl,
                                  &SecurityDescriptor );

    if( dwError != ERROR_SUCCESS ) {
        SetLastError( dwError );
        *DeleteDest = TRUE;
        goto Exit;
    }


    // We may have requested a DACL or SACL from a file that didn't have one.  If so,
    // don't try to set it (because it will cause a parameter error).

    if( Dacl == NULL ) {
        SecurityInformation &= ~DACL_SECURITY_INFORMATION;
    }
    if( Sacl == NULL ) {
        SecurityInformation &= ~SACL_SECURITY_INFORMATION;
    }

    if (SecurityInformation & (DACL_SECURITY_INFORMATION |
                               SACL_SECURITY_INFORMATION)) {
    
        if ( !GetSecurityDescriptorControlPtr( SecurityDescriptor, &Control, &dwRevision )) {
            // GetSecurityDescriptorControl calls BaseSetLastNTError on error
            *DeleteDest = TRUE;
            goto Exit;
        }
    }

    if (SecurityInformation & DACL_SECURITY_INFORMATION) {
        if (Control & SE_DACL_PROTECTED) {
            SecurityInformation |= PROTECTED_DACL_SECURITY_INFORMATION;
        } else {
            SecurityInformation |= UNPROTECTED_DACL_SECURITY_INFORMATION;
        }
        if (CopyCreatorOwnerAce) {
            if (ERROR_SUCCESS != GetSecurityInfoPtr( DestFile, 
                                        SE_FILE_OBJECT,
                                        OWNER_SECURITY_INFORMATION,
                                        &NewOwner,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &NewSecurityDescriptor ))
                NewOwner = NULL;

            BasepCopyCreatorOwnerACE (Dacl, Owner, NewOwner);
            // continue even if CreatorOwner ACE cannot be transferred
        }
    }
    if (SecurityInformation & SACL_SECURITY_INFORMATION) {
        if (Control & SE_SACL_PROTECTED) {
            SecurityInformation |= PROTECTED_SACL_SECURITY_INFORMATION;
        } else {
            SecurityInformation |= UNPROTECTED_SACL_SECURITY_INFORMATION;
        }
    }

    // Set the security on the dest file.  This loops because it may
    // have to back off on what it requests.

    while( TRUE && SecurityInformation != 0 ) {


        dwError = SetSecurityInfoPtr( DestFile,
                                      SE_FILE_OBJECT,
                                      SecurityInformation,
                                      Owner,
                                      Group,
                                      Dacl,
                                      Sacl );

        // Even if we have WRITE_OWNER access, the SID we're setting might not
        // be valid.  If so, see if we can retry without them.

        if( dwError == ERROR_SUCCESS ) {
            break;
        } else {

            if( SecurityInformation & (OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION) ) {

                if( !BasepCopyFileCallback( TRUE,   // Continue by default
                                            dwError,
                                            Context,
                                            NULL,
                                            PRIVCALLBACK_OWNER_GROUP_FAILED,
                                            SourceFile,
                                            DestFile,
                                            DeleteDest )) {
                    goto Exit;
                }

                // It's OK to ignore the owner/group.  Try again with them turned off.
                SecurityInformation &= ~(OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION);

            } else {

                // Samba 2.x says that it supports ACLs, but returns not-supported.
                if( !BasepCopyFileCallback( TRUE,   // Continue by default
                                            dwError,
                                            Context,
                                            NULL,
                                            PRIVCALLBACK_SECURITY_INFORMATION_NOT_SUPPORTED,
                                            SourceFile,
                                            DestFile,
                                            DeleteDest )) {
                    goto Exit;
                }

                SecurityInformation = 0;
            }

        }
    }   // while( TRUE && SecurityInformation != 0 )

    Succeeded = TRUE;

Exit:

    if( SecurityDescriptor != NULL ) {
        LocalFree( SecurityDescriptor );
    }

    if( NewSecurityDescriptor != NULL ) {
        LocalFree( NewSecurityDescriptor );
    }

    if( Advapi32 != NULL ) {
        FreeLibrary( Advapi32 );
    }

    return( Succeeded );
}



BOOL
BasepCopyFileCallback( BOOL ContinueByDefault,
                       DWORD Win32ErrorOnStopOrCancel,
                       LPCOPYFILE_CONTEXT Context,
                       PLARGE_INTEGER StreamBytesCopied OPTIONAL,
                       DWORD CallbackReason,
                       HANDLE SourceFile,
                       HANDLE DestFile,
                       OPTIONAL PBOOL Canceled )
/*++

Routine Description:

    During CopyFile, call the CopyFileProgressCallback routine.

Arguments:

    ContinueByDefault - Value to use as the return code of this
        function if there is no callback function or the callback
        returns PROGRESS_REASON_NOT_HANDLED.

    Win32ErrorOnStopOrCancel - If the callback returns PROGRESS_STOP
        or PROGRESS_CANCEL set this as the last error.

    Context - Structure with the information necessary to call
        the callback.

    StreamBytesCopied - If provided, passed to the callback.  If not
        provided, zero is passed.

    CallbackReason - Passed to the callback as the dwReasonCode.

    SourceFile - The source of the CopyFile.

    DestFile - The destination of the CopyFile.

    Canceled - Pointer to a bool that on return indicates that the copy operation
                has been canceled by the user.

Return Value:

    TRUE - The CopyFile should continue.

    FALSE - The CopyFile should be aborted.  The last error will be set
        before this routine returns.

--*/

{ // BasepCopyFileCallback

    PLARGE_INTEGER StreamBytes;
    LARGE_INTEGER Zero;
    DWORD ReturnCode;
    BOOL Continue = ContinueByDefault;

    // If there's no callback context or it's been quieted, then
    // there's nothing to do.

    if( Context == NULL || Context->lpProgressRoutine == NULL )
        return( Continue );

    // If the caller didn't provide a StreamBytesCopied, use zero.

    if( StreamBytesCopied == NULL ) {
        StreamBytes = &Zero;
        StreamBytes->QuadPart = 0;
    } else {
        StreamBytes = StreamBytesCopied;
    }

    // Call the callback

    ReturnCode = Context->lpProgressRoutine(
                    Context->TotalFileSize,
                    Context->TotalBytesTransferred,
                    Context->TotalFileSize,
                    *StreamBytes,
                    Context->dwStreamNumber,
                    CallbackReason,
                    SourceFile,
                    DestFile,
                    Context->lpData
                    );

    if( Canceled ) {
        *Canceled = FALSE;
    }

    switch( ReturnCode )
    {
    case PROGRESS_QUIET:
        Context->lpProgressRoutine = NULL;
        Continue = TRUE;
        break;

    case PROGRESS_CANCEL:
        if( Canceled ) {
            *Canceled = TRUE;
        }
        // Fall through

    case PROGRESS_STOP:
        SetLastError( Win32ErrorOnStopOrCancel );
        Continue = FALSE;
        break;

    case PROGRESS_CONTINUE:
        Continue = TRUE;
        break;

    case PRIVPROGRESS_REASON_NOT_HANDLED:
    default:

        if( !Continue ) {
            SetLastError( Win32ErrorOnStopOrCancel );
        }
        break;
    }

    return( Continue );

}





BOOL
WINAPI
ReplaceFileA(
    LPCSTR  lpReplacedFileName,
    LPCSTR  lpReplacementFileName,
    LPCSTR  lpBackupFileName OPTIONAL,
    DWORD   dwReplaceFlags,
    LPVOID  lpExclude,
    LPVOID  lpReserved
    )

/*++

Routine Description:

    ANSI thunk to ReplaceFileW

--*/

{
    UNICODE_STRING DynamicUnicodeReplaced;
    UNICODE_STRING DynamicUnicodeReplacement;
    UNICODE_STRING DynamicUnicodeBackup;
    BOOL b = FALSE;

    //
    // Parameter validation.
    //

    if(NULL == lpReplacedFileName || NULL == lpReplacementFileName ||
       NULL != lpExclude || NULL != lpReserved ||
       dwReplaceFlags & ~(REPLACEFILE_WRITE_THROUGH | REPLACEFILE_IGNORE_MERGE_ERRORS)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!Basep8BitStringToDynamicUnicodeString( &DynamicUnicodeReplaced, lpReplacedFileName )) {
        return FALSE;
    }

    if (!Basep8BitStringToDynamicUnicodeString( &DynamicUnicodeReplacement, lpReplacementFileName )) {
        goto end1;
    }

    if (lpBackupFileName) {
        if (!Basep8BitStringToDynamicUnicodeString( &DynamicUnicodeBackup, lpBackupFileName )) {
            goto end2;
        }
    } else {
        DynamicUnicodeBackup.Buffer = NULL;
    }

    b = ReplaceFileW(DynamicUnicodeReplaced.Buffer,
                     DynamicUnicodeReplacement.Buffer,
                     DynamicUnicodeBackup.Buffer,
                     dwReplaceFlags,
                     lpExclude,
                     lpReserved);

    if(lpBackupFileName) {
        RtlFreeUnicodeString(&DynamicUnicodeBackup);
    }

end2:
    RtlFreeUnicodeString(&DynamicUnicodeReplacement);
end1:
    RtlFreeUnicodeString(&DynamicUnicodeReplaced);

    return b;
}

BOOL
WINAPI
ReplaceFileW(
    LPCWSTR lpReplacedFileName,
    LPCWSTR lpReplacementFileName,
    LPCWSTR lpBackupFileName OPTIONAL,
    DWORD   dwReplaceFlags,
    LPVOID  lpExclude,
    LPVOID  lpReserved
    )

/*++

Routine Description:

    Replace a file with a new file. The original file's attributes, alternate
    data streams, oid, acl, compression/encryption are transfered to the new
    file. If a backup file name is supplied, the original file is left at the
    backup file specified. Object ID, Create time/date, and file shortnames are
    tunneled by the system.

Arguments:

    lpReplacementFileName - name of the new file.

    lpReplacedFileName - name of the file to be replaced.

    lpBackupFileName - optional. If not NULL, the original file can be found
        under this name.

    dwReplaceFlags - specifies how the file is to be replaced. Currently, the
        possible values are:
        REPLACEFILE_WRITE_THROUGH   Setting this flag guarantees that any
                                    tunneled information is flushed to disk
                                    before the function returns.
        REPLACEFILE_IGNORE_MERGE_ERRORS Setting this flag lets the routine
                                        continue on with the operation even
                                        when merge error occurs. If this flag
                                        is set, GetLastError will not return
                                        ERROR_UNABLE_TO_MERGE_DATA.

    lpExclude - Reserved for future use. Must be set to NULL.

    lpReserved - for future use. Must be set to NULL.

Return Value:

    TRUE - The operation was successful.
    FALSE - The operation failed. Extended error status is available
        using GetLastError.

Error Code:

    ERROR_UNABLE_TO_REMOVE_REPLACED     The replacement file has inherited the
                                        replaced file's attributes and streams.
                                        the replaced file is unchanged. Both
                                        files still exist under their original
                                        names. No backup file exists.

    ERROR_UNABLE_TO_MOVE_REPLACEMENT    Same as above. Except that backup file
                                        exists if requested.

    ERROR_UNABLE_TO_MOVE_REPLACEMENT_2  The replacement file has inherited the
                                        replaced file's attributes and streams.
                                        It's still under its original name.
                                        Replaced file exists under the name of
                                        the backup file.

    All other error codes               Both replacement file and replaced file
                                        exist under their original names. The
                                        replacement file may have inherited
                                        none of, or part of, or all of the
                                        replaced file's attributes and streams.
                                        No backup file exists.

--*/

{
    HANDLE                          advapi32LibHandle = INVALID_HANDLE_VALUE;
    ENCRYPTFILEWPTR                 EncryptFileWPtr = NULL;
    DECRYPTFILEWPTR                 DecryptFileWPtr = NULL;
    HANDLE                          ReplacedFile = INVALID_HANDLE_VALUE;
    HANDLE                          ReplacementFile = INVALID_HANDLE_VALUE;
    HANDLE                          StreamHandle = INVALID_HANDLE_VALUE;
    HANDLE                          OutputStreamHandle = INVALID_HANDLE_VALUE;
    UNICODE_STRING                  ReplacedFileNTName;
    UNICODE_STRING                  ReplacementFileNTName;
    UNICODE_STRING                  StreamNTName;
    UNICODE_STRING                  BackupNTFileName;
    OBJECT_ATTRIBUTES               ReplacedObjAttr;
    OBJECT_ATTRIBUTES               ReplacementObjAttr;
    OBJECT_ATTRIBUTES               StreamObjAttr;
    IO_STATUS_BLOCK                 IoStatusBlock;
    NTSTATUS                        status;
    BOOL                            fSuccess = FALSE;
    BOOL                            fDoCopy;
    PVOID                           ReplacedFreeBuffer = NULL;
    PVOID                           ReplacementFreeBuffer = NULL;
    FILE_BASIC_INFORMATION          ReplacedBasicInfo;
    FILE_BASIC_INFORMATION          ReplacementBasicInfo;
    DWORD                           ReplacementFileAccess;
    DWORD                           ReplacedFileAccess;
    FILE_COMPRESSION_INFORMATION    ReplacedCompressionInfo;
    PSECURITY_DESCRIPTOR            ReplacedSecDescPtr = NULL;
    DWORD                           dwSizeNeeded;
    ULONG                           cInfo;
    PFILE_STREAM_INFORMATION        ReplacedStreamInfo = NULL;
    PFILE_STREAM_INFORMATION        ReplacementStreamInfo = NULL;
    PFILE_STREAM_INFORMATION        ScannerStreamInfoReplaced = NULL;
    PFILE_STREAM_INFORMATION        ScannerStreamInfoReplacement = NULL;
    DWORD                           dwCopyFlags = COPY_FILE_FAIL_IF_EXISTS;
    DWORD                           dwCopySize = 0;
    PFILE_RENAME_INFORMATION        BackupReplaceRenameInfo = NULL;
    PFILE_RENAME_INFORMATION        ReplaceRenameInfo = NULL;
    LPCOPYFILE_CONTEXT              context = NULL;
    BOOL                            fQueryReplacedFileFail = FALSE;
    BOOL                            fQueryReplacementFileFail = FALSE;
    BOOL                            fReplacedFileIsEncrypted = FALSE;
    BOOL                            fReplacedFileIsCompressed = FALSE;
    BOOL                            fReplacementFileIsEncrypted = FALSE;
    BOOL                            fReplacementFileIsCompressed = FALSE;
    WCHAR *                         pwszTempBackupFile = NULL;
    DWORD                           DestFileFsAttributes = 0;
    WCHAR                           SavedLastChar;

    struct {
        FILE_FS_ATTRIBUTE_INFORMATION   Info;
        WCHAR                           Buffer[MAX_PATH];
    } ReplacementFsAttrInfoBuffer;

    //
    // Initialization
    //

    RtlInitUnicodeString(&BackupNTFileName, NULL);

    //
    // Parameter validation.
    //

    if(NULL == lpReplacedFileName || NULL == lpReplacementFileName ||
       NULL != lpExclude || NULL != lpReserved ||
       dwReplaceFlags & ~(REPLACEFILE_WRITE_THROUGH | REPLACEFILE_IGNORE_MERGE_ERRORS)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    try {

        //
        // Open the to-be-replaced file
        //

        RtlInitUnicodeString(&ReplacedFileNTName, NULL);
        if(!RtlDosPathNameToNtPathName_U(lpReplacedFileName,
                                         &ReplacedFileNTName,
                                         NULL,
                                         NULL)) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            leave;
        }
        ReplacedFreeBuffer = ReplacedFileNTName.Buffer;
        InitializeObjectAttributes(&ReplacedObjAttr,
                                   &ReplacedFileNTName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        ReplacedFileAccess = GENERIC_READ | DELETE | SYNCHRONIZE | ACCESS_SYSTEM_SECURITY;

        status = NtOpenFile(&ReplacedFile,
                            ReplacedFileAccess,
                            &ReplacedObjAttr,
                            &IoStatusBlock,
                            FILE_SHARE_READ |
                            FILE_SHARE_WRITE |
                            FILE_SHARE_DELETE,
                            FILE_NON_DIRECTORY_FILE |
                            FILE_SYNCHRONOUS_IO_NONALERT);

        if (!NT_SUCCESS(status)) {
            ReplacedFileAccess &= ~ACCESS_SYSTEM_SECURITY;

            status = NtOpenFile(&ReplacedFile,
                            ReplacedFileAccess,
                            &ReplacedObjAttr,
                            &IoStatusBlock,
                            FILE_SHARE_READ |
                            FILE_SHARE_WRITE |
                            FILE_SHARE_DELETE,
                            FILE_NON_DIRECTORY_FILE |
                            FILE_SYNCHRONOUS_IO_NONALERT);
        }
        
        if(!NT_SUCCESS(status))
        {
            BaseSetLastNTError(status);
            leave;
        }

        //
        // Open the replacement file
        //

        if(!RtlDosPathNameToNtPathName_U(lpReplacementFileName,
                                         &ReplacementFileNTName,
                                         NULL,
                                         NULL)) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            leave;
        }
        ReplacementFreeBuffer = ReplacementFileNTName.Buffer;
        InitializeObjectAttributes(&ReplacementObjAttr,
                                   &ReplacementFileNTName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        if ((ReplacedFileAccess & ACCESS_SYSTEM_SECURITY)) {
            ReplacementFileAccess = SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | DELETE | WRITE_DAC | ACCESS_SYSTEM_SECURITY;

            status = NtOpenFile(&ReplacementFile,
                            ReplacementFileAccess,
                            &ReplacementObjAttr,
                            &IoStatusBlock,
                            0,
                            FILE_NON_DIRECTORY_FILE |
                            FILE_SYNCHRONOUS_IO_NONALERT);
        }
        else status = STATUS_ACCESS_DENIED;  // force the open

        if (!NT_SUCCESS(status)) {
            ReplacementFileAccess = SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | DELETE | WRITE_DAC;
            status = NtOpenFile(&ReplacementFile,
                            ReplacementFileAccess,
                            &ReplacementObjAttr,
                            &IoStatusBlock,
                            0,
                            FILE_NON_DIRECTORY_FILE |
                            FILE_SYNCHRONOUS_IO_NONALERT);
        }

        if (STATUS_ACCESS_DENIED == status &&


           dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS) {
            ReplacementFileAccess = SYNCHRONIZE | GENERIC_READ | DELETE | WRITE_DAC;
            status = NtOpenFile(&ReplacementFile,
                                ReplacementFileAccess,
                                &ReplacementObjAttr,
                                &IoStatusBlock,
                                0,
                                FILE_NON_DIRECTORY_FILE |
                                FILE_SYNCHRONOUS_IO_NONALERT);
        }

        if(STATUS_ACCESS_DENIED == status &&
           dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)
        {   // try again without WRITE_DAC access
            ReplacementFileAccess = SYNCHRONIZE | GENERIC_READ | DELETE;
            status = NtOpenFile(&ReplacementFile,
                                ReplacementFileAccess,
                                &ReplacementObjAttr,
                                &IoStatusBlock,
                                0,
                                FILE_NON_DIRECTORY_FILE |
                                FILE_SYNCHRONOUS_IO_NONALERT);
        }

        if(!NT_SUCCESS(status))
        {
            BaseSetLastNTError(status);
            leave;
        }

        //
        // Get the attributes of the to-be-replaced file and set them on the
        // replacement file. FILE_ATTRIBUTE_COMPRESSED and
        // FILE_ATTRIBUTE_ENCRYPTED can be obtained by NtQueryInformationFile,
        // but can't be set by NtSetInformationFile. Compression and
        // encryption will be handled later.
        //

        status = NtQueryInformationFile(ReplacedFile,
                                        &IoStatusBlock,
                                        &ReplacedBasicInfo,
                                        sizeof(ReplacedBasicInfo),
                                        FileBasicInformation);
        if(!NT_SUCCESS(status)) {
            if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                BaseSetLastNTError(status);
                leave;
            }
            fQueryReplacedFileFail = TRUE;
        }
        else {
            // don't replace read-only files. See bug 38426
            if ((ReplacedBasicInfo.FileAttributes & FILE_ATTRIBUTE_READONLY)) {
                status = STATUS_ACCESS_DENIED;
                BaseSetLastNTError(status);  // ERROR_ACCESS_DENIED
                leave;
            }

            status = NtQueryInformationFile(ReplacementFile,
                                            &IoStatusBlock,
                                            &ReplacementBasicInfo,
                                            sizeof(ReplacementBasicInfo),
                                            FileBasicInformation);
            if(!NT_SUCCESS(status)) {
                if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                    BaseSetLastNTError(status);
                    leave;
                }
                fQueryReplacementFileFail = TRUE;
            }

            //
            // Creation time is the only time we want to preserve. So zero out
            // all the other times.
            //
            ReplacedBasicInfo.LastAccessTime.QuadPart = 0;
            ReplacedBasicInfo.LastWriteTime.QuadPart = 0;
            ReplacedBasicInfo.ChangeTime.QuadPart = 0;
            status = NtSetInformationFile(ReplacementFile,
                                          &IoStatusBlock,
                                          &ReplacedBasicInfo,
                                          sizeof(ReplacedBasicInfo),
                                          FileBasicInformation);
            if(!NT_SUCCESS(status) &&
               !(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                BaseSetLastNTError(status);
                leave;
            }
        }

        //
        // Transfer ACLs from the to-be-replaced file to the replacement file.
        //

        status = NtQueryVolumeInformationFile(ReplacementFile,
                                              &IoStatusBlock,
                                              &ReplacementFsAttrInfoBuffer.Info,
                                              sizeof(ReplacementFsAttrInfoBuffer),
                                              FileFsAttributeInformation);
        if(!NT_SUCCESS(status)) {
            if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                BaseSetLastNTError(status);
                leave;
            }
        }
        else
        {
            BOOL Delete = FALSE;
            if( !BasepCopySecurityInformation( lpReplacedFileName,
                                               ReplacedFile,
                                               ReplacedFileAccess,
                                               lpReplacementFileName,
                                               ReplacementFile,
                                               ReplacementFileAccess,
                                               DACL_SECURITY_INFORMATION |
                                               SACL_SECURITY_INFORMATION,
                                               NULL,
                                               ReplacementFsAttrInfoBuffer.Info.FileSystemAttributes,
                                               &Delete,
                                               TRUE )) {
                leave;
    
            }
        }


        //
        // If the to-be-replaced file has alternate data streams, and they do
        // not exist in the replacement file, copy them into the replacement
        // file.
        //

        cInfo = 4096;
        do {
            ReplacedStreamInfo = RtlAllocateHeap(RtlProcessHeap(),
                                                  MAKE_TAG(TMP_TAG),
                                                  cInfo);
            if (!ReplacedStreamInfo) {
                break;
            }
            status = NtQueryInformationFile(ReplacedFile,
                                            &IoStatusBlock,
                                            ReplacedStreamInfo,
                                            cInfo,
                                            FileStreamInformation);
            if (!NT_SUCCESS(status)) {
                RtlFreeHeap(RtlProcessHeap(), 0, ReplacedStreamInfo);
                ReplacedStreamInfo = NULL;
                cInfo *= 2;
            }
        } while(status == STATUS_BUFFER_OVERFLOW || status == STATUS_BUFFER_TOO_SMALL);
        if(NULL == ReplacedStreamInfo) {
            if(status != STATUS_INVALID_PARAMETER &&
               status != STATUS_NOT_IMPLEMENTED) {
                if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                    BaseSetLastNTError(status);
                    leave;
                }
            }
        }
        else {
            if(!NT_SUCCESS(status)) {
                if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                    BaseSetLastNTError(status);
                    leave;
                }
            }
            else {
                // The outer loop enumerates streams in the to-be-replaced file.
                ScannerStreamInfoReplaced = ReplacedStreamInfo;
                while(TRUE) {
                    // Skip the default stream.
                    if(ScannerStreamInfoReplaced->StreamNameLength <= sizeof(WCHAR) ||
                        ScannerStreamInfoReplaced->StreamName[1] == ':') {
                        if(0 == ScannerStreamInfoReplaced->NextEntryOffset) {
                            break;
                        }
                        ScannerStreamInfoReplaced = (PFILE_STREAM_INFORMATION)((PCHAR)ScannerStreamInfoReplaced + ScannerStreamInfoReplaced->NextEntryOffset);
                        continue;
                    }

                    // Query replacement file stream information if we haven't done so.
                    // We wait until now to do this query because we don't want to do
                    // it unless it's absolutely necessary.
                    if(NULL == ReplacementStreamInfo) {
                        cInfo = 4096;
                        do {
                            ReplacementStreamInfo = RtlAllocateHeap(RtlProcessHeap(),
                                                                     MAKE_TAG(TMP_TAG),
                                                             cInfo);
                            if (!ReplacementStreamInfo) {
                                break;
                            }
                            status = NtQueryInformationFile(ReplacementFile,
                                                            &IoStatusBlock,
                                                            ReplacementStreamInfo,
                                                            cInfo - sizeof( WCHAR ),
                                                            FileStreamInformation);
                            if (!NT_SUCCESS(status)) {
                                RtlFreeHeap(RtlProcessHeap(), 0, ReplacementStreamInfo);
                                ReplacementStreamInfo = NULL;
                                cInfo *= 2;
                            }
                        } while(status == STATUS_BUFFER_OVERFLOW || status == STATUS_BUFFER_TOO_SMALL);
                        if(NULL == ReplacementStreamInfo ||
                           !NT_SUCCESS(status)) {
                            if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                                BaseSetLastNTError(status);
                                leave;
                            }
                            break;
                        }
                    }

                    // The inner loop enumerates the replacement file streams.
                    ScannerStreamInfoReplacement = ReplacementStreamInfo;
                    fDoCopy = TRUE;
                    while(TRUE) {
                        if(ScannerStreamInfoReplaced->StreamNameLength == ScannerStreamInfoReplacement->StreamNameLength &&
                           _wcsnicmp(ScannerStreamInfoReplaced->StreamName, ScannerStreamInfoReplacement->StreamName, ScannerStreamInfoReplacement->StreamNameLength / sizeof(WCHAR)) == 0) {
                            // The stream already exists in the replacement file.
                            fDoCopy = FALSE;
                            break;
                        }
                        if(0 == ScannerStreamInfoReplacement->NextEntryOffset) {
                            // end of the stream information
                            break;
                        }
                        ScannerStreamInfoReplacement = (PFILE_STREAM_INFORMATION)((PCHAR)ScannerStreamInfoReplacement + ScannerStreamInfoReplacement->NextEntryOffset);
                    }

                    // We copy the stream if it doesn't exist in the replacement file.
                    if(TRUE == fDoCopy) {
                        StreamNTName.Buffer = &ScannerStreamInfoReplaced->StreamName[0];
                        StreamNTName.Length = (USHORT)ScannerStreamInfoReplaced->StreamNameLength;
                        StreamNTName.MaximumLength = StreamNTName.Length;

                        // Open the stream in the to-be-replaced file.
                        InitializeObjectAttributes(&StreamObjAttr,
                                                   &StreamNTName,
                                                   0,
                                                   ReplacedFile,
                                                   NULL);
                        status = NtOpenFile(&StreamHandle,
                                            SYNCHRONIZE |
                                            GENERIC_READ,
                                            &StreamObjAttr,
                                            &IoStatusBlock,
                                            FILE_SHARE_READ |
                                            FILE_SHARE_WRITE |
                                            FILE_SHARE_DELETE,
                                            FILE_SYNCHRONOUS_IO_NONALERT |
                                            FILE_SEQUENTIAL_ONLY);
                        if(!NT_SUCCESS(status)) {
                            if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                                BaseSetLastNTError(status);
                                leave;
                            }

                            if(0 == ScannerStreamInfoReplaced->NextEntryOffset) {
                                break;
                            }

                            ScannerStreamInfoReplaced = (PFILE_STREAM_INFORMATION)((PCHAR)ScannerStreamInfoReplaced + ScannerStreamInfoReplaced->NextEntryOffset);
                            continue;
                        }

                        // Copy the stream;
                        SavedLastChar = StreamNTName.Buffer[StreamNTName.Length / sizeof( WCHAR )];
                        StreamNTName.Buffer[StreamNTName.Length / sizeof( WCHAR )] = L'\0';
                        OutputStreamHandle = INVALID_HANDLE_VALUE;
                        if(!BaseCopyStream(NULL,
                                           StreamHandle,
                                           SYNCHRONIZE | GENERIC_READ,
                                           StreamNTName.Buffer,
                                           ReplacementFile,
                                           &ScannerStreamInfoReplaced->StreamSize,
                                           &dwCopyFlags,
                                           &OutputStreamHandle,
                                           &dwCopySize,
                                           &context,
                                           NULL,
                                           FALSE,
                                           0,
                                           &DestFileFsAttributes )) {
                            
                            StreamNTName.Buffer[StreamNTName.Length / sizeof( WCHAR )] = SavedLastChar;
                            
                            if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                                leave;
                            }
                        }
                        
                        StreamNTName.Buffer[StreamNTName.Length / sizeof( WCHAR )] = SavedLastChar;
                        
                        NtClose(StreamHandle);
                        StreamHandle = INVALID_HANDLE_VALUE;
                        if (INVALID_HANDLE_VALUE != OutputStreamHandle) {
                            NtClose(OutputStreamHandle);
                            OutputStreamHandle = INVALID_HANDLE_VALUE;
                        }
                    } // copy stream

                    if(0 == ScannerStreamInfoReplaced->NextEntryOffset) {
                        break;
                    }

                    ScannerStreamInfoReplaced = (PFILE_STREAM_INFORMATION)((PCHAR)ScannerStreamInfoReplaced + ScannerStreamInfoReplaced->NextEntryOffset);
                } // outer loop
            }
        }

        //
        // Compression/Encryption.
        //

        // If we successfully read the to-be-replaced file's attributes, we
        // do the necessary compression/encryption. Otherwise we do nothing.
        // If we don't know the replacement files attributes
        // (fQueryReplacementFileFail is TRUE), to be on the safe side, we will
        // try to (un)compress/(un)encrypt it if the to-be-replaced file is
        // (un)compressed/(un)encrypted.
        if(!fQueryReplacedFileFail) {

            fReplacedFileIsEncrypted = ReplacedBasicInfo.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED;
            fReplacedFileIsCompressed = ReplacedBasicInfo.FileAttributes & FILE_ATTRIBUTE_COMPRESSED;
            if(!fQueryReplacementFileFail) {
                fReplacementFileIsEncrypted = ReplacementBasicInfo.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED;
                fReplacementFileIsCompressed = ReplacementBasicInfo.FileAttributes & FILE_ATTRIBUTE_COMPRESSED;
            }
            else {
                // If we don't know the file attributes of the replacement
                // file, we'll assume the replacement file has opposite
                // encryption/compression attributes as the replaced file
                // so that encryption/compression operations will be forced
                // on the replacement file.
                fReplacementFileIsEncrypted = !fReplacedFileIsEncrypted;
                fReplacementFileIsCompressed = !fReplacedFileIsCompressed;
            }

            //
            // Encryption.
            //

            // If the to-be-replaced file is encrypted and either the
            // replacement file is encrypted or we don't know it's encryption
            // status, we try to encrypt the replacement file.
            if(fReplacedFileIsEncrypted && !fReplacementFileIsEncrypted) {
                NtClose(ReplacementFile);
                ReplacementFile = INVALID_HANDLE_VALUE;
                // There's no way to encrypt a file based on its handle.  We
                // must use the Win32 API (which calls over to the EFS service).
                advapi32LibHandle = LoadLibraryW(AdvapiDllString);
                if(NULL == advapi32LibHandle) {
                    if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                        leave;
                    }
                }
                else {
                    EncryptFileWPtr = (ENCRYPTFILEWPTR)GetProcAddress(advapi32LibHandle, "EncryptFileW");
                    if(NULL == EncryptFileWPtr) {
                        if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                            leave;
                        }
                    }
                    else {
                        if((EncryptFileWPtr)(lpReplacementFileName)) {
                            // Encryption operation automatically decompresses
                            // compressed files. We need this flag for the
                            // case when the replaced file is encrypted and
                            // the replacement file is compressed. At this
                            // point, the replacement file is encrypted.
                            // Because a file is automatically decompressed
                            // when it's encrypted, we don't want to
                            // decompress it again, otherwise we'll get an
                            // error.
                            fReplacementFileIsCompressed = FALSE;
                        } else if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                            leave;
                        }
                    }
                }
                status = NtOpenFile(&ReplacementFile,
                                    SYNCHRONIZE |
                                    GENERIC_READ |
                                    GENERIC_WRITE |
                                    WRITE_DAC |
                                    DELETE,
                                    &ReplacementObjAttr,
                                    &IoStatusBlock,
                                    0,
                                    FILE_NON_DIRECTORY_FILE |
                                    FILE_SYNCHRONOUS_IO_NONALERT);

                if (STATUS_ACCESS_DENIED == status &&

                   dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS) {
                    status = NtOpenFile(&ReplacementFile,
                                        SYNCHRONIZE |
                                        GENERIC_READ |
                                        DELETE |
                                        WRITE_DAC,
                                        &ReplacementObjAttr,
                                        &IoStatusBlock,
                                        0,
                                        FILE_NON_DIRECTORY_FILE |
                                        FILE_SYNCHRONOUS_IO_NONALERT);
                }
                if(STATUS_ACCESS_DENIED == status &&
                   dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS) {
                    status = NtOpenFile(&ReplacementFile,
                                        SYNCHRONIZE |
                                        GENERIC_READ |
                                        DELETE,
                                        &ReplacementObjAttr,
                                        &IoStatusBlock,
                                        0,
                                        FILE_NON_DIRECTORY_FILE |
                                        FILE_SYNCHRONOUS_IO_NONALERT);
                }

                // We leave without attempt to rename the files because we know
                // we can't rename the replacement file without it being opened
                // first.
                if(!NT_SUCCESS(status)) {
                    BaseSetLastNTError(status);
                    leave;
                }
            }
            else if(!fReplacedFileIsEncrypted && fReplacementFileIsEncrypted) {
                // If the to-be-replaced file is not encrypted and the
                // replacement file is encrypted, decrypt the replacement file.
                NtClose(ReplacementFile);
                ReplacementFile = INVALID_HANDLE_VALUE;
                advapi32LibHandle = LoadLibraryW(AdvapiDllString);
                if(NULL == advapi32LibHandle) {
                    if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                        leave;
                    }
                }
                else {
                    DecryptFileWPtr = (DECRYPTFILEWPTR)GetProcAddress(advapi32LibHandle, "DecryptFileW");
                    if(NULL == DecryptFileWPtr) {
                        if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                            leave;
                        }
                    }
                    else {
                        if((DecryptFileWPtr)(lpReplacementFileName, 0)) {
                            fReplacementFileIsEncrypted = FALSE;
                        } else if(!(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                            leave;
                        }
                    }
                }
                status = NtOpenFile(&ReplacementFile,
                                    SYNCHRONIZE |
                                    GENERIC_READ |
                                    GENERIC_WRITE |
                                    WRITE_DAC |
                                    DELETE,
                                    &ReplacementObjAttr,
                                    &IoStatusBlock,
                                    0,
                                    FILE_NON_DIRECTORY_FILE |
                                    FILE_SYNCHRONOUS_IO_NONALERT);

                if(STATUS_ACCESS_DENIED == status &&
                   dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS) {
                    status = NtOpenFile(&ReplacementFile,
                                        SYNCHRONIZE |
                                        GENERIC_READ |
                                        DELETE |
                                        WRITE_DAC,
                                        &ReplacementObjAttr,
                                        &IoStatusBlock,
                                        0,
                                        FILE_NON_DIRECTORY_FILE |
                                        FILE_SYNCHRONOUS_IO_NONALERT);
                }

                if(STATUS_ACCESS_DENIED == status &&
                   dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS) {
                    status = NtOpenFile(&ReplacementFile,
                                        SYNCHRONIZE |
                                        GENERIC_READ |
                                        DELETE,
                                        &ReplacementObjAttr,
                                        &IoStatusBlock,
                                        0,
                                        FILE_NON_DIRECTORY_FILE |
                                        FILE_SYNCHRONOUS_IO_NONALERT);
                }

                // We leave without attempt to rename the files because we know
                // we can't rename the replacement file without it being opened
                // first.
                if(!NT_SUCCESS(status)) {
                    BaseSetLastNTError(status);
                    leave;
                }
            }

            //
            // Compression.
            //

            // If the to-be-replaced file is compressed, and the replacement
            // file is not, we compress the replacement file. In the case that
            // we don't know if the replacement file is compressed or not
            // (fQueryReplacementFileFail is TRUE), we will
            // try to compress it anyway and ignore the error if it's already
            // compressed.
            if(fReplacedFileIsCompressed && !fReplacementFileIsCompressed) {
                // Get the compression method mode.
                status = NtQueryInformationFile(ReplacedFile,
                                                &IoStatusBlock,
                                                &ReplacedCompressionInfo,
                                                sizeof(FILE_COMPRESSION_INFORMATION),
                                                FileCompressionInformation);
                if(!NT_SUCCESS(status)) {
                    // We couldn't get the compression method code. if the
                    // ignore merge error flag is on, we continue on to
                    // encryption. Otherwise, we set last error and leave.
                    if(!fQueryReplacementFileFail &&
                       !(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                        BaseSetLastNTError(status);
                        leave;
                    }
                }
                else {
                    // Do the compression. If we fail and ignore failure flag
                    // is not on, set error and leave. Otherwise continue on
                    // to encryption.
                    status = NtFsControlFile(ReplacementFile,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &IoStatusBlock,
                                             FSCTL_SET_COMPRESSION,
                                             &ReplacedCompressionInfo.CompressionFormat,
                                             sizeof(ReplacedCompressionInfo.CompressionFormat),
                                             NULL,
                                             0);
                    if(!fQueryReplacementFileFail && !NT_SUCCESS(status) &&
                       !(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                            BaseSetLastNTError(status);
                            leave;
                    }
                }
            }
            else if(!fReplacedFileIsCompressed && fReplacementFileIsCompressed && !fReplacementFileIsEncrypted) {
                // The replaced file is not compressed, the replacement file
                // is compressed (or that the query information for replacement
                // file failed and we don't know if it's compressed or not),
                // decompress the replacement file.
                USHORT      CompressionFormat = 0;
                status = NtFsControlFile(ReplacementFile,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &IoStatusBlock,
                                         FSCTL_SET_COMPRESSION,
                                         &CompressionFormat,
                                         sizeof(CompressionFormat),
                                         NULL,
                                         0);
                if(!fQueryReplacementFileFail && !NT_SUCCESS(status) &&
                   !(dwReplaceFlags & REPLACEFILE_IGNORE_MERGE_ERRORS)) {
                        BaseSetLastNTError(status);
                        leave;
                }
            }
        } // if querying replaced file attribute failed.

        //
        // Do the renames.
        //

        if (NULL == lpBackupFileName) {
            HANDLE hFile = INVALID_HANDLE_VALUE;
            DWORD  dwCounter = 0;
            DWORD  dwReplacedFileLength = lstrlenW(lpReplacedFileName) * 
                                          sizeof(WCHAR);
            WCHAR  wcsSuffix [16];

            pwszTempBackupFile = RtlAllocateHeap(RtlProcessHeap(),
                                    MAKE_TAG(TMP_TAG),
                                    dwReplacedFileLength + sizeof(wcsSuffix));

            if(NULL == pwszTempBackupFile) {
                SetLastError(ERROR_UNABLE_TO_REMOVE_REPLACED);
                leave;
            }

            while (hFile == INVALID_HANDLE_VALUE && dwCounter < 16) {
                swprintf (wcsSuffix, L"~RF%4x.TMP", dwCounter + GetTickCount());
                lstrcpyW (pwszTempBackupFile, lpReplacedFileName);
                lstrcatW (pwszTempBackupFile, wcsSuffix);

                hFile = CreateFileW ( pwszTempBackupFile,
                          GENERIC_WRITE | DELETE, // file access
                          0,             // share mode
                          NULL,          // SD
                          CREATE_NEW,    // how to create
                          FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_TEMPORARY,
                          NULL);         // handle to template file

                dwCounter++;
            }

            if (hFile != INVALID_HANDLE_VALUE) {
                CloseHandle (hFile);         // immediately close temp file
            } else {
                SetLastError(ERROR_UNABLE_TO_REMOVE_REPLACED);
                leave;
            }

        }
        else {
            pwszTempBackupFile = (WCHAR *) lpBackupFileName;
        }

        // If backup file requested, rename the to-be-replaced file to backup.
        // Otherwise delete it.

        if(!RtlDosPathNameToNtPathName_U(pwszTempBackupFile,
                                             &BackupNTFileName,
                                             NULL,
                                             NULL)) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            leave;
        }

        BackupReplaceRenameInfo = RtlAllocateHeap(RtlProcessHeap(),
                                              MAKE_TAG(TMP_TAG),
                                              BackupNTFileName.Length +
                                              sizeof(*BackupReplaceRenameInfo));
        if(NULL == BackupReplaceRenameInfo)
        {
            SetLastError(ERROR_UNABLE_TO_REMOVE_REPLACED);
            leave;
        }
        BackupReplaceRenameInfo->ReplaceIfExists = TRUE;
        BackupReplaceRenameInfo->RootDirectory = NULL;
        BackupReplaceRenameInfo->FileNameLength = BackupNTFileName.Length;
        RtlCopyMemory(BackupReplaceRenameInfo->FileName, BackupNTFileName.Buffer, BackupNTFileName.Length);
        status = NtSetInformationFile(ReplacedFile,
                                          &IoStatusBlock,
                                          BackupReplaceRenameInfo,
                                          BackupNTFileName.Length +
                                          sizeof(*BackupReplaceRenameInfo),
                                          FileRenameInformation);
        if(!NT_SUCCESS(status)) {
            SetLastError(ERROR_UNABLE_TO_REMOVE_REPLACED);
            leave;
        }

        // Rename the replacement file to the replaced file.
        ReplaceRenameInfo = RtlAllocateHeap(RtlProcessHeap(),
                                      MAKE_TAG(TMP_TAG),
                                      ReplacedFileNTName.Length +
                                      sizeof(*ReplaceRenameInfo));
        if(NULL == ReplaceRenameInfo)
        {
            SetLastError(ERROR_UNABLE_TO_MOVE_REPLACEMENT);
            leave;
        }
        ReplaceRenameInfo->ReplaceIfExists = TRUE;
        ReplaceRenameInfo->RootDirectory = NULL;
        ReplaceRenameInfo->FileNameLength = ReplacedFileNTName.Length;
        RtlCopyMemory(ReplaceRenameInfo->FileName, ReplacedFileNTName.Buffer, ReplacedFileNTName.Length);
        status = NtSetInformationFile(ReplacementFile,
                                      &IoStatusBlock,
                                      ReplaceRenameInfo,
                                      ReplacedFileNTName.Length +
                                      sizeof(*ReplaceRenameInfo),
                                      FileRenameInformation);
        if(!NT_SUCCESS(status)) {
            // If we failed to rename the replacement file, and a backup file
            // for the original file exists, we try to restore the original
            // file from the backup file.
            if(lpBackupFileName) {
                status = NtSetInformationFile(ReplacedFile,
                                              &IoStatusBlock,
                                              ReplaceRenameInfo,
                                              ReplacedFileNTName.Length +
                                              sizeof(*ReplaceRenameInfo),
                                              FileRenameInformation);
                if(!NT_SUCCESS(status)) {
                    SetLastError(ERROR_UNABLE_TO_MOVE_REPLACEMENT_2);
                }
                else {
                    SetLastError(ERROR_UNABLE_TO_MOVE_REPLACEMENT);
                }
                leave;
            }
            else {
                SetLastError(ERROR_UNABLE_TO_MOVE_REPLACEMENT);
                leave;
            }
        }

        //
        // All is well. We set the return code to TRUE. And flush the files if
        // necessary.
        //

        if(dwReplaceFlags & REPLACEFILE_WRITE_THROUGH) {
            NtFlushBuffersFile(ReplacedFile, &IoStatusBlock);
        }

        fSuccess = TRUE;

    } finally {

        if(INVALID_HANDLE_VALUE != advapi32LibHandle && NULL != advapi32LibHandle) {
            FreeLibrary(advapi32LibHandle);
        }

        if(INVALID_HANDLE_VALUE != ReplacedFile) {
            NtClose(ReplacedFile);
        }
        if(INVALID_HANDLE_VALUE != ReplacementFile) {
            NtClose(ReplacementFile);
        }
        if(INVALID_HANDLE_VALUE != StreamHandle) {
            NtClose(StreamHandle);
        }
        if(INVALID_HANDLE_VALUE != OutputStreamHandle) {
            NtClose(OutputStreamHandle);
        }

        RtlFreeHeap(RtlProcessHeap(), 0, ReplacedFreeBuffer);
        RtlFreeHeap(RtlProcessHeap(), 0, ReplacementFreeBuffer);
        RtlFreeHeap(RtlProcessHeap(), 0, BackupNTFileName.Buffer);

        RtlFreeHeap(RtlProcessHeap(), 0, ReplacedStreamInfo);
        RtlFreeHeap(RtlProcessHeap(), 0, ReplacementStreamInfo);
        RtlFreeHeap(RtlProcessHeap(), 0, ReplaceRenameInfo);
        RtlFreeHeap(RtlProcessHeap(), 0, BackupReplaceRenameInfo);

        if (pwszTempBackupFile != NULL && 
            pwszTempBackupFile != lpBackupFileName) {
            DeleteFileW (pwszTempBackupFile);
            RtlFreeHeap(RtlProcessHeap(), 0, pwszTempBackupFile);
        }

    }

Exit:

    return fSuccess;
}


VOID
BaseMarkFileForDelete(
    HANDLE File,
    DWORD FileAttributes
    )

/*++

Routine Description:

    This routine marks a file for delete, so that when the supplied handle
    is closed, the file will actually be deleted.

Arguments:

    File - Supplies a handle to the file that is to be marked for delete.

    FileAttributes - Attributes for the file, if known.  Zero indicates they
        are unknown.

Return Value:

    None.

--*/

{
    #undef DeleteFile

    FILE_DISPOSITION_INFORMATION DispositionInformation;
    IO_STATUS_BLOCK IoStatus;
    FILE_BASIC_INFORMATION BasicInformation;

    if (!FileAttributes) {
        BasicInformation.FileAttributes = 0;
        NtQueryInformationFile(
            File,
            &IoStatus,
            &BasicInformation,
            sizeof(BasicInformation),
            FileBasicInformation
            );
        FileAttributes = BasicInformation.FileAttributes;
        }

    if (FileAttributes & FILE_ATTRIBUTE_READONLY) {
        RtlZeroMemory(&BasicInformation, sizeof(BasicInformation));
        BasicInformation.FileAttributes = FILE_ATTRIBUTE_NORMAL;
        NtSetInformationFile(
            File,
            &IoStatus,
            &BasicInformation,
            sizeof(BasicInformation),
            FileBasicInformation
            );
        }

    DispositionInformation.DeleteFile = TRUE;
    NtSetInformationFile(
        File,
        &IoStatus,
        &DispositionInformation,
        sizeof(DispositionInformation),
        FileDispositionInformation
        );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\killer.c ===
#include <stdio.h>
#include <windows.h>


Spin()
{
    int i;
    for (i=0;1;i++) {
        Sleep(i*7500);
        }
}

void
main(void)
{
    DWORD ThreadId;
    HANDLE Thread;
    int i;
    int failcount;

    failcount = 0;
    for (i = 0;; i++) {
        Thread = CreateThread(NULL,
                    0,
                    (LPTHREAD_START_ROUTINE)Spin,
                    NULL,
                    0,
                    &ThreadId
                    );
        if ( (i/50)*50 == i ) {
            printf("%d threads created\n", i);
            }

        if (!Thread) {
            failcount++;
            printf("%d threads created before %d failure\n", i,failcount);
            Sleep(5000);
            if ( failcount < 10 ) {
                i--;
                goto again;
                }
            break;
            }
        else {
            CloseHandle(Thread);
            }
again:;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\lzapi.h ===
/*
** lzapi.h - Private interface to LZEXPand.LIB.
*/

#ifndef _LZPRIVAPI_
#define _LZPRIVAPI_

#ifdef __cplusplus
extern "C" {
#endif

/*
** Prototypes
*/

// For the time being, private APIS exported
INT
LZCreateFileW(
    LPWSTR,
    DWORD,
    DWORD,
    DWORD,
    LPWSTR);

VOID
LZCloseFile(
    INT);


#ifdef __cplusplus
}
#endif


#endif // _LZEXPAND_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\lzpriv.h ===
/*
** lzpriv.h - Private information for LZEXPAND.DLL.
**
** Author:  DavidDi
*/


// Constants
/////////////

#define IN_BUF_LEN         (1 + 1024)  // size of input buffer
#define EXP_BUF_LEN        1024     // size of expanded data buffer
#define RING_BUF_LEN       4096     // size of ring buffer data area
#define MAX_RING_BUF_LEN   4224     // total size of ring buffer
#define MAX_CHAR_CODES     400      // maximum number of character codes

#define MAX_LZFILES        16       // maximum number of LZFile structs

#define LZ_TABLE_BIAS      1024     // offset of first LZFile entry in table of
                                    // handles, should be > 255
                                    //  (255 == largest possible DOS file handle)

#define STYLE_MASK         0xff0f   // wStyle mask used to determine whether
                                    // or not to set up an LZFile information
                                    // struct in LZOpenFile()
                                    // (used to ignore SHARE bits)

#define LZAPI  PASCAL


// Decoding bit flags used in LZFile.DecodeState.wFlags:

#define LZF_INITIALIZED     0x00000001 // 1 ==> buffers have been initialized
                                       // 0 ==> not initialized yet

// DOS Extended Error Codes

#define DEE_FILENOTFOUND   0x02     // File not found.  Awww...


// Types
/////////

typedef struct tagLZFile
{
   int dosh;                        /* DOS file handle of compressed file */

   BYTE byteAlgorithm;              /* compression algorithm */

   WORD wFlags;                     /* bit flags */

   unsigned long cbulUncompSize;    /* uncompressed file size */
   unsigned long cbulCompSize;      /* compressed file size */

   RTL_CRITICAL_SECTION semFile;    /* protect against >1 threads LZReading the same file all at once */

   long lCurSeekPos;                /* expanded file pointer position */

   PLZINFO pLZI;

} LZFile;


// Globals
///////////

extern HANDLE      rghLZFileTable[MAX_LZFILES];

// Prototypes
//////////////

// state.c
VOID SetGlobalBuffers(LZFile FAR *pLZFile);
VOID SaveDecodingState(LZFile FAR *pLZFile);
VOID RestoreDecodingState(LZFile FAR *pLZFile);
INT ConvertWin32FHToDos(HFILE DoshSource);
HFILE ConvertDosFHToWin32(INT DoshSource);


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\mailslot.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mailslot.c

Abstract:

    This module contains the Win32 Mailslot API

Author:

    Manny Weiser (mannyw) 4-Mar-1991

Revision History:

--*/

#include "basedll.h"

HANDLE
APIENTRY
CreateMailslotW(
    IN LPCWSTR lpName,
    IN DWORD nMaxMessageSize,
    IN DWORD lReadTimeout,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes OPTIONAL
    )

/*++

Routine Description:

    The create mailslot API creates a local mailslot and return a
    server-side handle to the mailslot.

Arguments:

    lpName - The name of the mailslot.  This must be a local mailslot
        name.

    nMaxMessageSize - The size (in bytes) of the largest message that
        can be written to the mailslot.

    lReadTimeout - The initial read timeout, in milliseconds.  This
        is the amount of time a read operation will block waiting for
        a message to be written to the mailslot.  This value can be
        changed with the SetMailslotInfo API.

    lpSecurityAttributes - An optional pointer to security information
        for this mailslot.

Return Value:

    Returns one of the following:

    0xFFFFFFFF --An error occurred.  Call GetLastError for more
    information.

    Anything else --Returns a handle for use in the server side of
    subsequent mailslot operations.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING fileName;
    LPWSTR filePart;
    IO_STATUS_BLOCK ioStatusBlock;
    LARGE_INTEGER readTimeout;
    HANDLE handle;
    NTSTATUS status;
    PVOID freeBuffer;
    BOOLEAN TranslationStatus;

    RtlInitUnicodeString( &fileName, lpName );

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpName,
                            &fileName,
                            &filePart,
                            NULL
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
    }

    freeBuffer = fileName.Buffer;

    InitializeObjectAttributes(
        &objectAttributes,
        &fileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        objectAttributes.SecurityDescriptor =
            lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle ) {
            objectAttributes.Attributes |= OBJ_INHERIT;
        }
    }

    if (lReadTimeout == MAILSLOT_WAIT_FOREVER) {
        readTimeout.HighPart = 0xFFFFFFFF;
        readTimeout.LowPart = 0xFFFFFFFF;
    } else {
        readTimeout.QuadPart = - (LONGLONG)UInt32x32To64( lReadTimeout, 10 * 1000 );
    }

    status = NtCreateMailslotFile (
                &handle,
                GENERIC_READ | SYNCHRONIZE | WRITE_DAC,
                &objectAttributes,
                &ioStatusBlock,
                FILE_CREATE,
                0,
                nMaxMessageSize,
                (PLARGE_INTEGER)&readTimeout
                );

    if ( status == STATUS_NOT_SUPPORTED ||
         status == STATUS_INVALID_DEVICE_REQUEST ) {

        //
        // The request must have been processed by some other device driver
        // (other than MSFS).  Map the error to something reasonable.
        //

        status = STATUS_OBJECT_NAME_INVALID;
    }

    RtlFreeHeap( RtlProcessHeap(), 0, freeBuffer );

    if (!NT_SUCCESS(status)) {
        BaseSetLastNTError( status );
        return INVALID_HANDLE_VALUE;
    }

    return handle;
}


HANDLE
APIENTRY
CreateMailslotA(
    IN LPCSTR lpName,
    IN DWORD nMaxMessageSize,
    IN DWORD lReadTimeout,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes OPTIONAL
    )
{
    PUNICODE_STRING unicode;
    ANSI_STRING ansiString;
    NTSTATUS status;

    unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString( &ansiString, lpName );
    status = RtlAnsiStringToUnicodeString( unicode, &ansiString, FALSE );

    if ( !NT_SUCCESS( status ) ) {
        if ( status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
        } else {
            BaseSetLastNTError(status);
        }
        return INVALID_HANDLE_VALUE;
    }

    return ( CreateMailslotW( unicode->Buffer,
                              nMaxMessageSize,
                              lReadTimeout,
                              lpSecurityAttributes
                              ) );

}

BOOL
APIENTRY
GetMailslotInfo(
    IN HANDLE hMailslot,
    OUT LPDWORD lpMaxMessageSize OPTIONAL,
    OUT LPDWORD lpNextSize OPTIONAL,
    OUT LPDWORD lpMessageCount OPTIONAL,
    OUT LPDWORD lpReadTimeout OPTIONAL
    )

/*++

Routine Description:

    This function will return the requested information about the
    specified mailslot.

Arguments:

    hMailslot - A handle to the mailslot.

    lpMaxMessageSize - If specified returns the size of the largest
        message that can be written to the mailslot.

    lpNextSize - If specified returns the size of the next message in
        the mailslot buffer.  It will return MAILSLOT_NO_MESSAGE if
        there are no messages in the mailslot.

    lpMessageCount - If specified returns the number of unread message
        currently in the mailslot.

    lpReadTimeout - If specified returns the read timeout, in
        milliseconds.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    FILE_MAILSLOT_QUERY_INFORMATION mailslotInfo;
    LARGE_INTEGER millisecondTimeout, tmp;

    status = NtQueryInformationFile( hMailslot,
                                     &ioStatusBlock,
                                     &mailslotInfo,
                                     sizeof( mailslotInfo ),
                                     FileMailslotQueryInformation );

    if ( !NT_SUCCESS( status ) ) {
        BaseSetLastNTError( status );
        return ( FALSE );
    }

    if ( ARGUMENT_PRESENT( lpMaxMessageSize ) ) {
        *lpMaxMessageSize = mailslotInfo.MaximumMessageSize;
    }

    if ( ARGUMENT_PRESENT( lpNextSize ) ) {
        *lpNextSize = mailslotInfo.NextMessageSize;
    }

    if ( ARGUMENT_PRESENT( lpMessageCount ) ) {
        *lpMessageCount = mailslotInfo.MessagesAvailable;
    }

    if ( ARGUMENT_PRESENT( lpReadTimeout ) ) {

        //
        // Convert read timeout from 100 ns intervals to milliseconds.
        // The readtime is currently negative, since it is a relative time.
        //

        if ( mailslotInfo.ReadTimeout.HighPart != 0xFFFFFFFF
             || mailslotInfo.ReadTimeout.LowPart != 0xFFFFFFFF ) {

            tmp.QuadPart = - mailslotInfo.ReadTimeout.QuadPart;
            millisecondTimeout = RtlExtendedLargeIntegerDivide(
                                     tmp,
                                     10 * 1000,
                                     NULL );

            if ( millisecondTimeout.HighPart == 0 ) {
                *lpReadTimeout = millisecondTimeout.LowPart;
            } else {

                //
                // The millisecond calculation would overflow the dword.
                // Approximate a large number as best we can.
                //

                *lpReadTimeout = 0xFFFFFFFE;

            }

        } else {

            //
            // The mailslot timeout is infinite.
            //

            *lpReadTimeout = MAILSLOT_WAIT_FOREVER;

        }
    }

    return( TRUE );
}

BOOL
APIENTRY
SetMailslotInfo(
    IN HANDLE hMailslot,
    IN DWORD lReadTimeout
    )

/*++

Routine Description:

    This function will set the read timeout for the specified mailslot.

Arguments:

    hMailslot - A handle to the mailslot.

    lReadTimeout - The new read timeout, in milliseconds.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    FILE_MAILSLOT_SET_INFORMATION mailslotInfo;
    LARGE_INTEGER timeout;

    if ( lReadTimeout == MAILSLOT_WAIT_FOREVER ) {
        timeout.HighPart = 0xFFFFFFFF;
        timeout.LowPart = 0xFFFFFFFF;
    } else {
        timeout.QuadPart = - (LONGLONG)UInt32x32To64( lReadTimeout, 10 * 1000 );
    }

    mailslotInfo.ReadTimeout = &timeout;
    status = NtSetInformationFile( hMailslot,
                                   &ioStatusBlock,
                                   &mailslotInfo,
                                   sizeof( mailslotInfo ),
                                   FileMailslotSetInformation );

    if ( !NT_SUCCESS( status ) ) {
        BaseSetLastNTError( status );
        return ( FALSE );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\lcompat.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    lcompat.c

Abstract:

    This module implements the _l and l compatability functions
    like _lread, lstrlen...

Author:

    Mark Lucovsky (markl) 13-Mar-1991

Revision History:

--*/

#include "basedll.h"

int
WINAPI
_lopen(
    LPCSTR lpPathName,
    int iReadWrite
    )
{

    HANDLE hFile;
    DWORD DesiredAccess;
    DWORD ShareMode;
    DWORD CreateDisposition;

    SetLastError(0);
    //
    // Compute Desired Access
    //

    if ( iReadWrite & OF_WRITE ) {
        DesiredAccess = GENERIC_WRITE;
    } else {
        DesiredAccess = GENERIC_READ;
    }

    if ( iReadWrite & OF_READWRITE ) {
        DesiredAccess |= (GENERIC_READ | GENERIC_WRITE);
    }

    //
    // Compute ShareMode
    //

    ShareMode = BasepOfShareToWin32Share ((DWORD)iReadWrite);

    CreateDisposition = OPEN_EXISTING;

    //
    // Open the file
    //

    hFile = CreateFile (lpPathName,
                        DesiredAccess,
                        ShareMode,
                        NULL,
                        CreateDisposition,
                        0,
                        NULL);

    return (HFILE)HandleToUlong (hFile);
}

HFILE
WINAPI
_lcreat(
    LPCSTR lpPathName,
    int  iAttribute
    )
{
    HANDLE hFile;
    DWORD DesiredAccess;
    DWORD ShareMode;
    DWORD CreateDisposition;

    SetLastError(0);

    //
    // Compute Desired Access
    //

    DesiredAccess = (GENERIC_READ | GENERIC_WRITE);

    ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;;

    //
    // Compute Create Disposition
    //

    CreateDisposition = CREATE_ALWAYS;

    //
    // Open the file
    //

    hFile = CreateFile (lpPathName,
                        DesiredAccess,
                        ShareMode,
                        NULL,
                        CreateDisposition,
                        iAttribute & FILE_ATTRIBUTE_VALID_FLAGS,
                        NULL);

    return (HFILE)HandleToUlong (hFile);
}

UINT
WINAPI
_lread(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT uBytes
    )
{
    DWORD BytesRead;
    BOOL b;

    b = ReadFile ((HANDLE)IntToPtr (hFile),
                  lpBuffer,
                  (DWORD)uBytes,
                  &BytesRead,
                  NULL);
    if (b) {
        return BytesRead;
    } else {
        return (DWORD)0xffffffff;
    }
}


UINT
WINAPI
_lwrite(
    HFILE hFile,
    LPCSTR lpBuffer,
    UINT uBytes
    )
{
    DWORD BytesWritten;
    BOOL b;

    if (uBytes) {
        b = WriteFile ((HANDLE)IntToPtr(hFile),
                       (CONST VOID *)lpBuffer,
                       (DWORD)uBytes,
                       &BytesWritten,
                       NULL);
    } else {
        BytesWritten = 0;
        b = SetEndOfFile((HANDLE)IntToPtr(hFile));
    }

    if (b) {
        return BytesWritten;
    } else {
        return (DWORD)0xffffffff;
    }
}

HFILE
WINAPI
_lclose(
    HFILE hFile
    )
{
    BOOL b;

    b = CloseHandle ((HANDLE)IntToPtr (hFile));
    if (b) {
        return (HFILE)0;
    } else {
        return (HFILE)-1;
    }
}

LONG
WINAPI
_llseek(
    HFILE hFile,
    LONG lOffset,
    int iOrigin
    )
{
    DWORD SeekType;

    switch (iOrigin) {
        case 0:
            SeekType = FILE_BEGIN;
            break;
        case 1:
            SeekType = FILE_CURRENT;
            break;
        case 2:
            SeekType = FILE_END;
            break;
        default:
            return -1;
    }

    return (int)SetFilePointer ((HANDLE)IntToPtr (hFile), lOffset, NULL, SeekType);
}

#if defined(_AMD64_) || defined(_IA64_)

int
WINAPI
MulDiv (
    int nNumber,
    int nNumerator,
    int nDenominator
    )

{

    LONG Negate;
    union {
        LARGE_INTEGER Product;
        struct {
            ULONG Quotient;
            ULONG Remainder;
        };
    } u;

    //
    // Compute the size of the result.
    //

    Negate = nNumber ^ nNumerator ^ nDenominator;

    //
    // Get the absolute value of the operand values.
    //

    if (nNumber < 0) {
        nNumber = - nNumber;
    }

    if (nNumerator < 0) {
        nNumerator = - nNumerator;
    }

    if (nDenominator < 0) {
        nDenominator = - nDenominator;
    }

    //
    // Compute the 64-bit product of the multiplier and multiplicand
    // values and round.
    //

    u.Product.QuadPart =
        Int32x32To64(nNumber, nNumerator) + ((ULONG)nDenominator / 2);

    //
    // If there are any high order product bits, then the quotient has
    // overflowed.
    //

    if ((ULONG)nDenominator > u.Remainder) {

        //
        // Divide the 64-bit product by the 32-bit divisor forming a 32-bit
        // quotient and a 32-bit remainder.
        //

        u.Quotient = RtlEnlargedUnsignedDivide(*(PULARGE_INTEGER)&u.Product,
                                               (ULONG)nDenominator,
                                               &u.Remainder);

        //
        // Compute the final signed result.
        //

        if ((LONG)u.Quotient >= 0) {
            if (Negate >= 0) {
                return (LONG)u.Quotient;

            } else {
                return - (LONG)u.Quotient;
            }
        }
    }

    return - 1;
}

#endif

int
APIENTRY
lstrcmpA(
    LPCSTR lpString1,
    LPCSTR lpString2
    )
{
    int retval;

    retval = CompareStringA( GetThreadLocale(),
                             LOCALE_USE_CP_ACP,
                             lpString1,
                             -1,
                             lpString2,
                             -1 );
    if (retval == 0) {
        //
        // The caller is not expecting failure.  Try the system
        // default locale id.
        //
        retval = CompareStringA( GetSystemDefaultLCID(),
                                 LOCALE_USE_CP_ACP,
                                 lpString1,
                                 -1,
                                 lpString2,
                                 -1 );
    }

    if (retval == 0) {
        if (lpString1 && lpString2) {
            //
            // The caller is not expecting failure.  We've never had a
            // failure indicator before.  We'll do a best guess by calling
            // the C runtimes to do a non-locale sensitive compare.
            //
            return strcmp(lpString1, lpString2);
        } else if (lpString1) {
            return (1);
        } else if (lpString2) {
            return (-1);
        } else {
            return (0);
        }
    }

    return (retval - 2);
}

int
APIENTRY
lstrcmpiA(
    LPCSTR lpString1,
    LPCSTR lpString2
    )
{
    int retval;

    retval = CompareStringA( GetThreadLocale(),
                             LOCALE_USE_CP_ACP | NORM_IGNORECASE,
                             lpString1,
                             -1,
                             lpString2,
                             -1 );
    if (retval == 0) {
        //
        // The caller is not expecting failure.  Try the system
        // default locale id.
        //
        retval = CompareStringA( GetSystemDefaultLCID(),
                                 LOCALE_USE_CP_ACP | NORM_IGNORECASE,
                                 lpString1,
                                 -1,
                                 lpString2,
                                 -1 );
    }
    if (retval == 0) {
        if (lpString1 && lpString2) {
            //
            // The caller is not expecting failure.  We've never had a
            // failure indicator before.  We'll do a best guess by calling
            // the C runtimes to do a non-locale sensitive compare.
            //
            return ( _stricmp(lpString1, lpString2) );
        } else if (lpString1) {
            return (1);
        } else if (lpString2) {
            return (-1);
        } else {
            return (0);
        }
    }

    return (retval - 2);
}

LPSTR
APIENTRY
lstrcpyA(
    LPSTR lpString1,
    LPCSTR lpString2
    )
{
    try {
        return strcpy (lpString1, lpString2);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }
}


LPSTR
APIENTRY
lstrcpynA(
    LPSTR lpString1,
    LPCSTR lpString2,
    int iMaxLength
    )
{
    LPSTR src,dst;

    try {
        src = (LPSTR)lpString2;
        dst = lpString1;

        if ( iMaxLength ) {
            while(iMaxLength && *src){
                *dst++ = *src++;
                iMaxLength--;
            }
            if ( iMaxLength ) {
                *dst = '\0';
            } else {
                dst--;
                *dst = '\0';
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }

   return lpString1;
}

LPSTR
APIENTRY
lstrcatA(
    LPSTR lpString1,
    LPCSTR lpString2
    )
{
    try {
        return strcat (lpString1, lpString2);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }
}

int
APIENTRY
lstrlenA(
    LPCSTR lpString
    )
{
    if (!lpString) {
        return 0;
    }

    try {
        return strlen(lpString);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return 0;
    }
}

int
APIENTRY
lstrcmpW(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    int retval;

    retval = CompareStringW( GetThreadLocale(),
                             0,
                             lpString1,
                             -1,
                             lpString2,
                             -1 );
    if (retval == 0) {
        //
        // The caller is not expecting failure.  Try the system
        // default locale id.
        //
        retval = CompareStringW( GetSystemDefaultLCID(),
                                 0,
                                 lpString1,
                                 -1,
                                 lpString2,
                                 -1 );
    }

    if (retval == 0) {
        if (lpString1 && lpString2) {
            //
            // The caller is not expecting failure.  We've never had a
            // failure indicator before.  We'll do a best guess by calling
            // the C runtimes to do a non-locale sensitive compare.
            //
            return ( wcscmp(lpString1, lpString2) );
        } else if (lpString1) {
            return (1);
        } else if (lpString2) {
            return (-1);
        } else {
            return (0);
        }
    }

    return (retval - 2);
}

int
APIENTRY
lstrcmpiW(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    int retval;

    retval = CompareStringW( GetThreadLocale(),
                             NORM_IGNORECASE,
                             lpString1,
                             -1,
                             lpString2,
                             -1 );
    if (retval == 0) {
        //
        // The caller is not expecting failure.  Try the system
        // default locale id.
        //
        retval = CompareStringW( GetSystemDefaultLCID(),
                                 NORM_IGNORECASE,
                                 lpString1,
                                 -1,
                                 lpString2,
                                 -1 );
    }
    if (retval == 0) {
        if (lpString1 && lpString2) {
            //
            // The caller is not expecting failure.  We've never had a
            // failure indicator before.  We'll do a best guess by calling
            // the C runtimes to do a non-locale sensitive compare.
            //
            return ( _wcsicmp(lpString1, lpString2) );
        } else if (lpString1) {
            return (1);
        } else if (lpString2) {
            return (-1);
        } else {
            return (0);
        }
    }

    return (retval - 2);
}

LPWSTR
APIENTRY
lstrcpyW(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
{
    try {
        return wcscpy (lpString1, lpString2);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }
}

LPWSTR
APIENTRY
lstrcpynW(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int iMaxLength
    )
{
    LPWSTR src,dst;

    try {
        src = (LPWSTR)lpString2;
        dst = lpString1;

        if ( iMaxLength ) {
            while(iMaxLength && *src){
                *dst++ = *src++;
                iMaxLength--;
            }
            if ( iMaxLength ) {
                *dst = '\0';
            } else {
                dst--;
                *dst = '\0';
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }

    return lpString1;
}

LPWSTR
APIENTRY
lstrcatW(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
{
    try {
        return wcscat (lpString1, lpString2);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }
}

int
APIENTRY
lstrlenW(
    LPCWSTR lpString
    )
{
    if (!lpString) {
        return 0;
    }
    try {
        return wcslen (lpString);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\message.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    message.c

Abstract:

    This module contains the Win32 Message Management APIs

Author:

    Steve Wood (stevewo) 24-Jan-1991

Revision History:

                  02-May-94 BruceMa Fix FormatMessage to accept Win32 status
                                    codes wrapped as HRESULTS

--*/

#include "basedll.h"

DWORD
APIENTRY
BaseDllFormatMessage(
                    BOOLEAN ArgumentsAreAnsi,
                    DWORD dwFlags,
                    LPVOID lpSource,
                    DWORD dwMessageId,
                    DWORD dwLanguageId,
                    PWSTR lpBuffer,
                    DWORD nSize,
                    va_list *arglist
                    );

DWORD
APIENTRY
FormatMessageA(
              DWORD dwFlags,
              LPCVOID lpSource,
              DWORD dwMessageId,
              DWORD dwLanguageId,
              LPSTR lpBuffer,
              DWORD nSize,
              va_list *lpArguments
              )
{
    NTSTATUS Status;
    DWORD Result;
    PWSTR UnicodeSource;
    PWSTR UnicodeBuffer;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;

    if (dwFlags & FORMAT_MESSAGE_FROM_STRING) {
        if (strlen (lpSource) >= MAXSHORT) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            RtlInitAnsiString( &AnsiString, lpSource );
            Status = RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, TRUE );
        }
        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            return 0;
        }

        UnicodeSource = UnicodeString.Buffer;
    } else {
        UnicodeSource = (PWSTR)lpSource;
    }

    if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER) {
        UnicodeBuffer = (PWSTR)lpBuffer;
    } else {
        UnicodeBuffer = RtlAllocateHeap( RtlProcessHeap(),
                                         MAKE_TAG( TMP_TAG ),
                                         nSize * sizeof( WCHAR )
                                       );
    }
    if (UnicodeBuffer != NULL) {
        Result = BaseDllFormatMessage( TRUE,
                                       dwFlags,
                                       (LPVOID)UnicodeSource,
                                       dwMessageId,
                                       dwLanguageId,
                                       UnicodeBuffer,
                                       nSize,
                                       lpArguments
                                     );
    } else {
        BaseSetLastNTError( STATUS_NO_MEMORY );
        Result = 0;
    }

    if (UnicodeSource != (PWSTR)lpSource) {
        RtlFreeUnicodeString( &UnicodeString );
    }

    if (Result != 0) {
        UnicodeString.Length = (USHORT)(Result * sizeof( WCHAR ));
        UnicodeString.MaximumLength = (USHORT)(UnicodeString.Length + sizeof( UNICODE_NULL ));
        if (Result >= MAXSHORT) {
            Status = STATUS_INVALID_PARAMETER;
            if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER) {
                UnicodeBuffer = *(PWSTR *)lpBuffer;
                *(LPSTR *)lpBuffer = NULL;
            }
        } else {
            if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER) {
                UnicodeString.Buffer = *(PWSTR *)lpBuffer;
                UnicodeBuffer = UnicodeString.Buffer;
                Status = RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeString, TRUE );
                if (NT_SUCCESS( Status )) {
                    *(LPSTR *)lpBuffer = AnsiString.Buffer;
                } else {
                    *(LPSTR *)lpBuffer = NULL;
                }
            } else {
                UnicodeString.Buffer = UnicodeBuffer;
                AnsiString.Buffer = lpBuffer;
                AnsiString.Length = 0;
                AnsiString.MaximumLength = (USHORT)nSize;
                Status = RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeString, FALSE );
                //
                // Convert the error to be concistent.
                //
                if (Status == STATUS_BUFFER_OVERFLOW) {
                    Status = STATUS_BUFFER_TOO_SMALL;
                }
            }
        }

        if (!NT_SUCCESS( Status )) {
            BaseSetLastNTError( Status );
            Result = 0;
        } else {
            //
            // Ajust return value, since Result contains Unicode char counts,
            // we have to adjust it to ANSI char counts
            //
            Result = AnsiString.Length;
        }
    } else {
        if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER) {
            UnicodeBuffer = NULL;
        }
    }

    if (UnicodeBuffer != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeBuffer );
    }

    return Result;
}


DWORD
APIENTRY
FormatMessageW(
              DWORD dwFlags,
              LPCVOID lpSource,
              DWORD dwMessageId,
              DWORD dwLanguageId,
              PWSTR lpBuffer,
              DWORD nSize,
              va_list *lpArguments
              )
{
    return BaseDllFormatMessage( FALSE,
                                 dwFlags,
                                 (LPVOID)lpSource,
                                 dwMessageId,
                                 dwLanguageId,
                                 lpBuffer,
                                 nSize,
                                 lpArguments
                               );
}


BOOLEAN
CreateVirtualBuffer(
                   OUT PVIRTUAL_BUFFER Buffer,
                   IN ULONG CommitSize OPTIONAL,
                   IN ULONG ReserveSize OPTIONAL
                   )
{
    MEMORY_BASIC_INFORMATION MemoryInformation;
    SIZE_T MemoryInformationLength;

    if (!ARGUMENT_PRESENT( LongToPtr(CommitSize) )) {
        CommitSize = 1;
    }

    if (!ARGUMENT_PRESENT( LongToPtr(ReserveSize) )) {
        ReserveSize = ROUND_UP( CommitSize, 0x10000 );
    }

    Buffer->Base = VirtualAlloc( NULL,
                                 ReserveSize + BASE_SYSINFO.PageSize,
                                 MEM_RESERVE,
                                 PAGE_READWRITE
                               );
    if (Buffer->Base == NULL) {
        return FALSE;
    }

    MemoryInformationLength = VirtualQuery( Buffer->Base,
                                            &MemoryInformation,
                                            sizeof( MemoryInformation )
                                          );
    if (MemoryInformationLength == sizeof( MemoryInformation )) {
        ReserveSize = (ULONG)MemoryInformation.RegionSize - BASE_SYSINFO.PageSize;
        if (VirtualAlloc( Buffer->Base,
                          CommitSize,
                          MEM_COMMIT,
                          PAGE_READWRITE
                        ) != NULL
           ) {
            MemoryInformationLength = VirtualQuery( Buffer->Base,
                                                    &MemoryInformation,
                                                    sizeof( MemoryInformation )
                                                  );
            if (MemoryInformationLength == sizeof( MemoryInformation )) {
                CommitSize = (ULONG)MemoryInformation.RegionSize;
                Buffer->CommitLimit = (PVOID)
                                      ((char *)Buffer->Base + CommitSize);

                Buffer->ReserveLimit = (PVOID)
                                       ((char *)Buffer->Base + ReserveSize);

                return TRUE;
            }
        }
    }

    VirtualFree( Buffer->Base, 0, MEM_RELEASE );
    return FALSE;
}


BOOLEAN
ExtendVirtualBuffer(
                   IN PVIRTUAL_BUFFER Buffer,
                   IN PVOID Address
                   )
{
    SIZE_T NewCommitSize;
    PVOID NewCommitLimit;

    if (Address >= Buffer->Base) {
        if (Address < Buffer->CommitLimit) {
            return TRUE;
        }

        if (Address >= Buffer->ReserveLimit) {
            return FALSE;
        }

        NewCommitSize =
        ((SIZE_T)ROUND_UP_TO_PAGES( (ULONG_PTR)Address + 1 ) - (ULONG_PTR)Buffer->CommitLimit);

        NewCommitLimit = VirtualAlloc( Buffer->CommitLimit,
                                       NewCommitSize,
                                       MEM_COMMIT,
                                       PAGE_READWRITE
                                     );
        if (NewCommitLimit != NULL) {
            Buffer->CommitLimit = (PVOID)
                                  ((ULONG_PTR)NewCommitLimit + NewCommitSize);

            return TRUE;
        }
    }

    return FALSE;
}


BOOLEAN
TrimVirtualBuffer(
                 IN PVIRTUAL_BUFFER Buffer
                 )
{
    Buffer->CommitLimit = Buffer->Base;
    return (BOOLEAN)VirtualFree( Buffer->Base, 0, MEM_DECOMMIT );
}

BOOLEAN
FreeVirtualBuffer(
                 IN PVIRTUAL_BUFFER Buffer
                 )
{
    return (BOOLEAN)VirtualFree( Buffer->Base, 0, MEM_RELEASE );
}

int
VirtualBufferExceptionHandler(
                             IN DWORD ExceptionCode,
                             IN PEXCEPTION_POINTERS ExceptionInfo,
                             IN OUT PVIRTUAL_BUFFER Buffer
                             )
{
    PVOID BadAddress;

    //
    // If this is an access violation touching memory within
    // our reserved buffer, but outside of the committed portion
    // of the buffer, then we are going to take this exception.
    //

    if (ExceptionCode == STATUS_ACCESS_VIOLATION) {
        BadAddress = (PVOID)ExceptionInfo->ExceptionRecord->ExceptionInformation[ 1 ];
        if (BadAddress >= Buffer->CommitLimit &&
            BadAddress < Buffer->ReserveLimit
           ) {
            //
            // This is our exception.  If there is room to commit
            // more memory, try to do so.  If no room or unable
            // to commit, then execute the exception handler.
            // Otherwise we were able to commit the additional
            // buffer space, so update the commit limit on the
            // caller's stack and retry the faulting instruction.
            //

            if (ExtendVirtualBuffer( Buffer, BadAddress )) {
                return EXCEPTION_CONTINUE_EXECUTION;
            } else {
                return EXCEPTION_EXECUTE_HANDLER;
            }
        }
    }

    //
    // Not an exception we care about, so pass it up the chain.
    //

    return EXCEPTION_CONTINUE_SEARCH;
}

HMODULE BasepNetMsg;

DWORD
APIENTRY
BaseDllFormatMessage(
                    BOOLEAN ArgumentsAreAnsi,
                    DWORD dwFlags,
                    LPVOID lpSource,
                    DWORD dwMessageId,
                    DWORD dwLanguageId,
                    PWSTR lpBuffer,
                    DWORD nSize,
                    va_list *arglist
                    )
{
    VIRTUAL_BUFFER Buffer;
    NTSTATUS Status;
    PVOID DllHandle;
    ULONG MaximumWidth;
    ULONG LengthNeeded, Result;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    PWSTR MessageFormat;
    PWSTR lpAllocedBuffer;
    PWSTR lpDst;
    BOOLEAN IgnoreInserts;
    BOOLEAN ArgumentsAreAnArray;

    /* If this is a Win32 error wrapped as an OLE HRESULT then unwrap it */
    if (((dwMessageId & 0xffff0000) == 0x80070000)  &&
        (dwFlags & FORMAT_MESSAGE_FROM_SYSTEM)      &&
        !(dwFlags & FORMAT_MESSAGE_FROM_HMODULE)    &&
        !(dwFlags & FORMAT_MESSAGE_FROM_STRING)) {
        dwMessageId &= 0x0000ffff;
    }

    if (lpBuffer == NULL) {
        BaseSetLastNTError( STATUS_INVALID_PARAMETER );
        return 0;
    }

    lpAllocedBuffer = NULL;
    if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER) {
        *(PVOID *)lpBuffer = NULL;
    }

    if (!CreateVirtualBuffer( &Buffer,
                              (nSize + 1)*sizeof (WCHAR),
                              0 )) {
        return 0;
    }

    if (dwFlags & FORMAT_MESSAGE_IGNORE_INSERTS) {
        IgnoreInserts = TRUE;
    } else {
        IgnoreInserts = FALSE;
    }

    if (dwFlags & FORMAT_MESSAGE_ARGUMENT_ARRAY) {
        ArgumentsAreAnArray = TRUE;
    } else {
        ArgumentsAreAnArray = FALSE;
    }

    Result = 0;

    try {
        UnicodeString.Buffer = NULL;
        MaximumWidth = dwFlags & FORMAT_MESSAGE_MAX_WIDTH_MASK;
        if (MaximumWidth == FORMAT_MESSAGE_MAX_WIDTH_MASK) {
            MaximumWidth = 0xFFFFFFFF;
        }

        UnicodeString.Buffer = NULL;
        if (dwFlags & FORMAT_MESSAGE_FROM_STRING) {
            MessageFormat = lpSource;
        } else {
            if (dwFlags & FORMAT_MESSAGE_FROM_HMODULE) {
                DllHandle = BasepMapModuleHandle( (HMODULE)lpSource, TRUE );
            } else
                if (dwFlags & FORMAT_MESSAGE_FROM_SYSTEM) {
                retrySystem:
                DllHandle = (PVOID)BaseDllHandle;
            } else {
                BaseSetLastNTError( STATUS_INVALID_PARAMETER );
                leave;
            }

            retrySystem2:
            Status = RtlFindMessage( DllHandle,
                                     PtrToUlong(RT_MESSAGETABLE),
                                     (ULONG)dwLanguageId,
                                     dwMessageId,
                                     &MessageEntry
                                   );

            if (!NT_SUCCESS( Status )) {
                if (Status == STATUS_MESSAGE_NOT_FOUND) {
                    if (dwFlags & FORMAT_MESSAGE_FROM_HMODULE &&
                        dwFlags & FORMAT_MESSAGE_FROM_SYSTEM
                       ) {
                        dwFlags &= ~FORMAT_MESSAGE_FROM_HMODULE;
                        goto retrySystem;
                    }
                    if ( dwFlags & FORMAT_MESSAGE_FROM_SYSTEM &&
                         DllHandle == (PVOID)BaseDllHandle
                       ) {
                        //
                        // The message isn't in kernel32.dll, conditionally
                        // load netmsg.dll to see if the message is there.
                        // Leave the dll mapped for subsequent message lookups
                        //
                        if (!BasepNetMsg) {
                            BasepNetMsg = LoadLibraryExW(L"netmsg.dll",NULL,LOAD_LIBRARY_AS_DATAFILE);
                        }
                        if (BasepNetMsg) {
                            DllHandle = BasepNetMsg;
                            goto retrySystem2;
                        }
                    }
                    SetLastError( ERROR_MR_MID_NOT_FOUND );
                } else {
                    BaseSetLastNTError( Status );
                }
                leave;
            }

            if (!(MessageEntry->Flags & MESSAGE_RESOURCE_UNICODE)) {
                RtlInitAnsiString( &AnsiString, MessageEntry->Text );
                Status = RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, TRUE );
                if (!NT_SUCCESS( Status )) {
                    BaseSetLastNTError( Status );
                    leave;
                }

                MessageFormat = UnicodeString.Buffer;
            } else {
                MessageFormat = (PWSTR)MessageEntry->Text;
            }
        }

        Status = RtlFormatMessage( MessageFormat,
                                   MaximumWidth,
                                   IgnoreInserts,
                                   ArgumentsAreAnsi,
                                   ArgumentsAreAnArray,
                                   arglist,
                                   Buffer.Base,
                                   (ULONG)((PCHAR)Buffer.ReserveLimit - (PCHAR)Buffer.Base),
                                   &LengthNeeded
                                 );

        RtlFreeUnicodeString( &UnicodeString );

        if (NT_SUCCESS( Status )) {
            if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER) {
                lpAllocedBuffer = (PWSTR)LocalAlloc( LMEM_FIXED, LengthNeeded );
                if (lpAllocedBuffer == NULL) {
                    BaseSetLastNTError( STATUS_NO_MEMORY );
                    leave;
                }

                lpDst = lpAllocedBuffer;
            } else
                if ((LengthNeeded / sizeof( WCHAR )) > nSize) {
                BaseSetLastNTError( STATUS_BUFFER_TOO_SMALL );
                leave;
            } else {
                lpDst = lpBuffer;
            }

            RtlMoveMemory( lpDst, Buffer.Base, LengthNeeded );
            Result = (LengthNeeded - sizeof( WCHAR )) / sizeof( WCHAR );
        } else {
            BaseSetLastNTError( Status );
        }
    }
    except( VirtualBufferExceptionHandler( GetExceptionCode(),
                                           GetExceptionInformation(),
                                           &Buffer
                                         )
          ) {
        if (GetExceptionCode() == STATUS_ACCESS_VIOLATION) {
            BaseSetLastNTError( STATUS_NO_MEMORY );
        } else {
            BaseSetLastNTError( GetExceptionCode() );
        }

        Result = 0;
    }

    if (lpAllocedBuffer != NULL) {
        if (Result) {
            *(PVOID *)lpBuffer = lpAllocedBuffer;
        } else {
            LocalFree( lpAllocedBuffer );
        }
    }

    FreeVirtualBuffer( &Buffer );

    return ( Result );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\makefile.inc ===
t.c: dllprof.c

..\base.rc : $(PROJECT_ROOT)\published\$(O)\winerror_msg00001.bin $(PROJECT_ROOT)\published\$(O)\winerror.rc ..\..\winnls\winnls.rc


#
# Build private kernel32.lib.  It contains all the private api's and
# the Win9x api's.
#

$(O)\kernl32p.def: ..\kernel32.src
    @echo Creating $@ from $?
    $(C_PREPROCESSOR_NAME) /DALL_WIN32_EXPORTS /DPRIVATE= $(C_PREPROCESSOR_FLAGS) $** > $@

$(O)\kernl32p.lib: $(O)\kernl32p.def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$@ @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\kernl32p.def
$(LIBRARY_OBJS)
<<NOKEEP

$(SDK_LIB_DEST)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\kernl32p.lib : $(O)\kernl32p.lib
    $(PUBLISH_CMD) {$?=$@}

#
# Build public kernel32.lib with extra Win9x exports.
#

$(O)\w32kernel32.def: ..\kernel32.src
    @echo Creating $@ from $?
    $(C_PREPROCESSOR_NAME) /DALL_WIN32_EXPORTS $(C_PREPROCESSOR_FLAGS) $** > $@

$(O)\w32kernel32.lib : $(O)\w32kernel32.def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$@ @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\w32kernel32.def
$(LIBRARY_OBJS)
<<NOKEEP

$(SDK_LIB_DEST)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\kernel32.lib : $(O)\w32kernel32.lib
    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\mfmt.c ===
/*++

Module Name:

    mfmt.c

Abstract:

    This program is designed to show how to access a physical floppy
    disk using the Win32 API set.

    This program has two major functions.

        - It can be used to display the geometry of a disk

            mfmt -g a:

        - It can be used to produce a disk image, or to write a disk
          image to a floppy.

            mfmt -c a: bootdisk         - produce a disk image of a:

            mfmt -c bootdisk a:         - make a: identical to bootdisk image

    This program is very very simple. Minimal error checking is done. It is
    meant to provide an example of how to:

        - Open a physical disk

        - Read a disk's geometry

        - Perform a low level format operation

        - read and write physical sectors

Author:

    Some Guy in the NT group (sgitng) 05-Oct-1992

Revision History:

--*/

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <winioctl.h>
#include <string.h>
#include <memory.h>

DISK_GEOMETRY SupportedGeometry[20];
DWORD SupportedGeometryCount;

BOOL
GetDiskGeometry(
    HANDLE hDisk,
    PDISK_GEOMETRY lpGeometry
    )

{
    DWORD ReturnedByteCount;

    return DeviceIoControl(
                hDisk,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL,
                0,
                lpGeometry,
                sizeof(*lpGeometry),
                &ReturnedByteCount,
                NULL
                );
}

DWORD
GetSupportedGeometrys(
    HANDLE hDisk
    )
{
    DWORD ReturnedByteCount;
    BOOL b;
    DWORD NumberSupported;

    b = DeviceIoControl(
                hDisk,
                IOCTL_DISK_GET_MEDIA_TYPES,
                NULL,
                0,
                SupportedGeometry,
                sizeof(SupportedGeometry),
                &ReturnedByteCount,
                NULL
                );
    if ( b ) {
        NumberSupported = ReturnedByteCount / sizeof(DISK_GEOMETRY);
        }
    else {
        NumberSupported = 0;
        }
    SupportedGeometryCount = NumberSupported;

    return NumberSupported;
}

VOID
PrintGeometry(
    LPSTR lpDriveName,
    PDISK_GEOMETRY lpGeometry
    )
{
    LPSTR MediaType;

    if (lpDriveName) {
        printf("Geometry for Drive %s\n",lpDriveName);
        }

    switch ( lpGeometry->MediaType ) {
        case F5_1Pt2_512:  MediaType = "5.25, 1.2MB,  512 bytes/sector";break;
        case F3_1Pt44_512: MediaType = "3.5,  1.44MB, 512 bytes/sector";break;
        case F3_2Pt88_512: MediaType = "3.5,  2.88MB, 512 bytes/sector";break;
        case F3_20Pt8_512: MediaType = "3.5,  20.8MB, 512 bytes/sector";break;
        case F3_720_512:   MediaType = "3.5,  720KB,  512 bytes/sector";break;
        case F5_360_512:   MediaType = "5.25, 360KB,  512 bytes/sector";break;
        case F5_320_512:   MediaType = "5.25, 320KB,  512 bytes/sector";break;
        case F5_320_1024:  MediaType = "5.25, 320KB,  1024 bytes/sector";break;
        case F5_180_512:   MediaType = "5.25, 180KB,  512 bytes/sector";break;
        case F5_160_512:   MediaType = "5.25, 160KB,  512 bytes/sector";break;
        case RemovableMedia: MediaType = "Removable media other than floppy";break;
        case FixedMedia:   MediaType = "Fixed hard disk media";break;
        default:           MediaType = "Unknown";break;
    }
    printf("    Media Type %s\n",MediaType);
    printf("    Cylinders %d Tracks/Cylinder %d Sectors/Track %d\n",
        lpGeometry->Cylinders.LowPart,
        lpGeometry->TracksPerCylinder,
        lpGeometry->SectorsPerTrack
        );
}

BOOL
LowLevelFormat(
    HANDLE hDisk,
    PDISK_GEOMETRY lpGeometry
    )
{
    FORMAT_PARAMETERS FormatParameters;
    PBAD_TRACK_NUMBER lpBadTrack;
    UINT i;
    BOOL b;
    DWORD ReturnedByteCount;

    FormatParameters.MediaType = lpGeometry->MediaType;
    FormatParameters.StartHeadNumber = 0;
    FormatParameters.EndHeadNumber = lpGeometry->TracksPerCylinder - 1;
    lpBadTrack = (PBAD_TRACK_NUMBER) LocalAlloc(LMEM_ZEROINIT,lpGeometry->TracksPerCylinder*sizeof(*lpBadTrack));

    for (i = 0; i < lpGeometry->Cylinders.LowPart; i++) {

        FormatParameters.StartCylinderNumber = i;
        FormatParameters.EndCylinderNumber = i;

        b = DeviceIoControl(
                hDisk,
                IOCTL_DISK_FORMAT_TRACKS,
                &FormatParameters,
                sizeof(FormatParameters),
                lpBadTrack,
                lpGeometry->TracksPerCylinder*sizeof(*lpBadTrack),
                &ReturnedByteCount,
                NULL
                );

        if (!b ) {
            LocalFree(lpBadTrack);
            return b;
            }
        }

    LocalFree(lpBadTrack);

    return TRUE;
}

BOOL
LockVolume(
    HANDLE hDisk
    )
{
    DWORD ReturnedByteCount;

    return DeviceIoControl(
                hDisk,
                FSCTL_LOCK_VOLUME,
                NULL,
                0,
                NULL,
                0,
                &ReturnedByteCount,
                NULL
                );
}

BOOL
UnlockVolume(
    HANDLE hDisk
    )
{
    DWORD ReturnedByteCount;

    return DeviceIoControl(
                hDisk,
                FSCTL_UNLOCK_VOLUME,
                NULL,
                0,
                NULL,
                0,
                &ReturnedByteCount,
                NULL
                );
}

BOOL
DismountVolume(
    HANDLE hDisk
    )
{
    DWORD ReturnedByteCount;

    return DeviceIoControl(
                hDisk,
                FSCTL_DISMOUNT_VOLUME,
                NULL,
                0,
                NULL,
                0,
                &ReturnedByteCount,
                NULL
                );
}

DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    char Drive[MAX_PATH];
    HANDLE hDrive, hDiskImage;
    DISK_GEOMETRY Geometry;
    UINT i;
    char c, *p;
    LPSTR DriveName;
    BOOL fUsage = TRUE;
    BOOL fShowGeometry = FALSE;
    BOOL fDiskImage = FALSE;
    BOOL SourceIsDrive;
    LPSTR Source, Destination, DiskImage;

    if ( argc > 1 ) {
        fUsage = FALSE;
        while (--argc) {
            p = *++argv;
            if (*p == '/' || *p == '-') {
                while (c = *++p)
                switch (toupper( c )) {
                case '?':
                    fUsage = TRUE;
                    break;

                case 'C':
                    fDiskImage = TRUE;
                    argc--, argv++;
                    Source = *argv;
                    argc--, argv++;
                    Destination = *argv;
                    break;

                case 'G':
                    fShowGeometry = TRUE;
                    argc--, argv++;
                    DriveName = *argv;
                    break;

                default:
                    printf("MFMT: Invalid switch - /%c\n", c );
                    fUsage = TRUE;
                    break;
                    }
                }
            }
        }

    if ( fUsage ) {
        printf("usage: MFMT switches \n" );
        printf("            [-?] display this message\n" );
        printf("            [-g drive] shows disk geometry\n" );
        printf("            [-c source destination] produce diskimage\n" );
        ExitProcess(1);
        }

    if ( fShowGeometry ) {
        sprintf(Drive,"\\\\.\\%s",DriveName);
        hDrive = CreateFile(
                    Drive,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );
        if ( hDrive == INVALID_HANDLE_VALUE ) {
            printf("MFMT: Open %s failed %d\n",DriveName,GetLastError());
            ExitProcess(1);
            }

        LockVolume(hDrive);

        if ( !GetDiskGeometry(hDrive,&Geometry) ) {
            printf("MFMT: GetDiskGeometry %s failed %d\n",DriveName,GetLastError());
            ExitProcess(1);
            }
        PrintGeometry(DriveName,&Geometry);

        if ( !GetSupportedGeometrys(hDrive) ) {
            printf("MFMT: GetSupportedGeometrys %s failed %d\n",DriveName,GetLastError());
            ExitProcess(1);
            }
        printf("\nDrive %s supports the following disk geometries\n",DriveName);

        for(i=0;i<SupportedGeometryCount;i++) {
            printf("\n");
            PrintGeometry(NULL,&SupportedGeometry[i]);
            }

        printf("\n");
        ExitProcess(0);
        }

    if ( fDiskImage ) {
        SourceIsDrive = FALSE;
        if ( Source[strlen(Source)-1] == ':' ) {
            SourceIsDrive = TRUE;
            sprintf(Drive,"\\\\.\\%s",Source);
            DiskImage = Destination;
            }
        if ( Destination[strlen(Destination)-1] == ':' ) {
            if ( SourceIsDrive ) {
                printf("MFMT: Source and Destination cannot both be drives\n");
                ExitProcess(1);
                }
            SourceIsDrive = FALSE;
            sprintf(Drive,"\\\\.\\%s",Destination);
            DiskImage = Source;
            }
        else {
            if ( !SourceIsDrive ) {
                printf("MFMT: Either Source or Destination must be a drive\n");
                ExitProcess(1);
                }
            }

        //
        // Open and Lock the drive
        //

        hDrive = CreateFile(
                    Drive,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );
        if ( hDrive == INVALID_HANDLE_VALUE ) {
            printf("MFMT: Open %s failed %d\n",DriveName,GetLastError());
            ExitProcess(1);
            }
        LockVolume(hDrive);

        if ( !GetDiskGeometry(hDrive,&Geometry) ) {
            printf("MFMT: GetDiskGeometry %s failed %d\n",DriveName,GetLastError());
            ExitProcess(1);
            }

        if ( !GetSupportedGeometrys(hDrive) ) {
            printf("MFMT: GetSupportedGeometrys %s failed %d\n",DriveName,GetLastError());
            ExitProcess(1);
            }

        //
        // Open the disk image file
        //

        hDiskImage = CreateFile(
                        DiskImage,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        SourceIsDrive ? CREATE_ALWAYS : OPEN_EXISTING,
                        0,
                        NULL
                        );
        if ( hDiskImage == INVALID_HANDLE_VALUE ) {
            printf("MFMT: Open %s failed %d\n",DiskImage,GetLastError());
            ExitProcess(1);
            }

        //
        // Now do the copy
        //
        {
            LPVOID IoBuffer;
            BOOL b;
            DWORD BytesRead, BytesWritten;
            DWORD FileSize;
            DWORD GeometrySize;

            //
            // If we are copying from floppy to file, just do the copy
            // Otherwise, we might have to format the floppy first
            //

            if ( SourceIsDrive ) {

                //
                // Device reads must be sector aligned. VirtualAlloc will
                // garuntee alignment
                //

                GeometrySize = Geometry.Cylinders.LowPart *
                               Geometry.TracksPerCylinder *
                               Geometry.SectorsPerTrack *
                               Geometry.BytesPerSector;

                IoBuffer = VirtualAlloc(NULL,GeometrySize,MEM_COMMIT,PAGE_READWRITE);

                if ( !IoBuffer ) {
                    printf("MFMT: Buffer Allocation Failed\n");
                    ExitProcess(1);
                    }

                b = ReadFile(hDrive,IoBuffer, GeometrySize, &BytesRead, NULL);
                if (b && BytesRead){
                    b = WriteFile(hDiskImage,IoBuffer, BytesRead, &BytesWritten, NULL);
                    if ( !b || ( BytesRead != BytesWritten ) ) {
                        printf("MFMT: Fatal Write Error %d\n",GetLastError());
                        ExitProcess(1);
                        }
                    }
                else {
                    printf("MFMT: Fatal Read Error %d\n",GetLastError());
                    ExitProcess(1);
                    }
                }
            else {

                //
                // Check to see if the image will fit on the floppy. If it
                // will, then LowLevelFormat the floppy and press on
                //

                FileSize = GetFileSize(hDiskImage,NULL);

                b = FALSE;
                for(i=0;i<SupportedGeometryCount;i++) {
                    GeometrySize = SupportedGeometry[i].Cylinders.LowPart *
                                   SupportedGeometry[i].TracksPerCylinder *
                                   SupportedGeometry[i].SectorsPerTrack *
                                   SupportedGeometry[i].BytesPerSector;
                    if ( GeometrySize >= FileSize ) {

                        IoBuffer = VirtualAlloc(NULL,GeometrySize,MEM_COMMIT,PAGE_READWRITE);

                        if ( !IoBuffer ) {
                            printf("MFMT: Buffer Allocation Failed\n");
                            ExitProcess(1);
                            }

                        //
                        // Format the floppy
                        //

                        LowLevelFormat(hDrive,&SupportedGeometry[i]);

                        b = ReadFile(hDiskImage,IoBuffer, GeometrySize, &BytesRead, NULL);
                        if (b && BytesRead){
                            b = WriteFile(hDrive,IoBuffer, BytesRead, &BytesWritten, NULL);
                            if ( !b || ( BytesRead != BytesWritten ) ) {
                                printf("MFMT: Fatal Write Error %d\n",GetLastError());
                                ExitProcess(1);
                                }
                            }
                        else {
                            printf("MFMT: Fatal Read Error %d\n",GetLastError());
                            ExitProcess(1);
                            }
                        b = TRUE;
                        break;
                        }
                    }

                if ( !b ) {
                    printf("MFMT: FileSize %d is not supported on drive %s\n",FileSize,DriveName);
                    ExitProcess(1);
                    }
                }
        }

        //
        // Dismounting forces the filesystem to re-evaluate the media id
        // and geometry. This is the same as popping the floppy in and out
        // of the disk drive
        //

        DismountVolume(hDrive);
        UnlockVolume(hDrive);

        ExitProcess(0);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\lmem.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    lmem.c

Abstract:

    This module contains the Win32 Local Memory Management APIs

Author:

    Steve Wood (stevewo) 24-Sep-1990

Revision History:

--*/

#include "basedll.h"

void
BaseDllInitializeMemoryManager( VOID )
{
    BaseHeap = RtlProcessHeap();
    RtlInitializeHandleTable( 0xFFFF,
                              sizeof( BASE_HANDLE_TABLE_ENTRY ),
                              &BaseHeapHandleTable
                            );
    NtQuerySystemInformation(SystemRangeStartInformation,
                             &SystemRangeStart,
                             sizeof(SystemRangeStart),
                             NULL);
}

#if i386
#pragma optimize("y",off)
#endif

HLOCAL
WINAPI
LocalAlloc(
    UINT uFlags,
    SIZE_T uBytes
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    HANDLE hMem;
    ULONG Flags;
    LPSTR p;

    if (uFlags & ~LMEM_VALID_FLAGS) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
        }

    Flags = 0;
    if (uFlags & LMEM_ZEROINIT) {
        Flags |= HEAP_ZERO_MEMORY;
        }

    if (!(uFlags & LMEM_MOVEABLE)) {
        p = RtlAllocateHeap( BaseHeap,
                             MAKE_TAG( LMEM_TAG ) | Flags,
                             uBytes
                           );
        if (p == NULL) {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            }

        return( p );
        }

    RtlLockHeap( BaseHeap );
    Flags |= HEAP_NO_SERIALIZE | HEAP_SETTABLE_USER_VALUE | BASE_HEAP_FLAG_MOVEABLE;
    try {
        p = NULL;
        HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)RtlAllocateHandle( &BaseHeapHandleTable, NULL );
        if (HandleEntry == NULL) {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            goto Fail;
            }

        hMem = (HANDLE)&HandleEntry->Object;
        if (uBytes != 0) {
            p = (LPSTR)RtlAllocateHeap( BaseHeap, MAKE_TAG( LMEM_TAG ) | Flags, uBytes );
            if (p == NULL) {
                HandleEntry->Flags = RTL_HANDLE_ALLOCATED;
                RtlFreeHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry );
                HandleEntry = NULL;
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                }
            else {
                RtlSetUserValueHeap( BaseHeap, HEAP_NO_SERIALIZE, p, hMem );
                }
            }
        else {
            p = NULL;
            }
Fail:   ;
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        p = NULL;
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    if (HandleEntry != NULL) {
        if (HandleEntry->Object = p) {
            HandleEntry->Flags = RTL_HANDLE_ALLOCATED;
            }
        else {
            HandleEntry->Flags = RTL_HANDLE_ALLOCATED | BASE_HANDLE_DISCARDED;
            }

        if (uFlags & LMEM_DISCARDABLE) {
            HandleEntry->Flags |= BASE_HANDLE_DISCARDABLE;
            }

        if (uFlags & LMEM_MOVEABLE) {
            HandleEntry->Flags |= BASE_HANDLE_MOVEABLE;
            }

        p = (LPSTR)hMem;
        }

    return( (HANDLE)p );
}


HLOCAL
WINAPI
LocalReAlloc(
    HLOCAL hMem,
    SIZE_T uBytes,
    UINT uFlags
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    LPSTR p;
    ULONG Flags;

    if ((uFlags & ~(LMEM_VALID_FLAGS | LMEM_MODIFY)) ||
        ((uFlags & LMEM_DISCARDABLE) && !(uFlags & LMEM_MODIFY))
       ) {
#if DBG
        DbgPrint( "*** LocalReAlloc( %lx ) - invalid flags\n", uFlags );
        BaseHeapBreakPoint();
#endif
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
        }

    Flags = 0;
    if (uFlags & LMEM_ZEROINIT) {
        Flags |= HEAP_ZERO_MEMORY;
        }
    if (!(uFlags & LMEM_MOVEABLE)) {
        Flags |= HEAP_REALLOC_IN_PLACE_ONLY;
        }

    RtlLockHeap( BaseHeap );
    Flags |= HEAP_NO_SERIALIZE;
    try {
        if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (!RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
#if DBG
                DbgPrint( "*** LocalReAlloc( %lx ) - invalid handle\n", hMem );
                BaseHeapBreakPoint();
#endif
                SetLastError( ERROR_INVALID_HANDLE );
                hMem = NULL;
                }
            else
            if (uFlags & LMEM_MODIFY) {
                if (uFlags & LMEM_DISCARDABLE) {
                    HandleEntry->Flags |= BASE_HANDLE_DISCARDABLE;
                    }
                else {
                    HandleEntry->Flags &= ~BASE_HANDLE_DISCARDABLE;
                    }
                }
            else {
                p = HandleEntry->Object;
                if (uBytes == 0) {
                    hMem = NULL;
                    if (p != NULL) {
                        if ((uFlags & LMEM_MOVEABLE) && HandleEntry->LockCount == 0) {
                            if (RtlFreeHeap( BaseHeap, Flags | HEAP_NO_SERIALIZE, p )) {
                                HandleEntry->Object = NULL;
                                HandleEntry->Flags |= BASE_HANDLE_DISCARDED;
                                hMem = (HANDLE)&HandleEntry->Object;
                                }
                            }
                        else {
#if DBG
                            DbgPrint( "*** LocalReAlloc( %lx ) - failing with locked handle\n", &HandleEntry->Object );
                            BaseHeapBreakPoint();
#endif
                            }
                        }
                    else {
                        hMem = (HANDLE)&HandleEntry->Object;
                        }
                    }
                else {
                    Flags |= HEAP_SETTABLE_USER_VALUE | BASE_HEAP_FLAG_MOVEABLE;
                    if (p == NULL) {
                        p = RtlAllocateHeap( BaseHeap, MAKE_TAG( LMEM_TAG ) | Flags, uBytes );
                        if (p != NULL) {
                            RtlSetUserValueHeap( BaseHeap, HEAP_NO_SERIALIZE, p, hMem );
                            }
                        }
                    else {
                        if (!(uFlags & LMEM_MOVEABLE) &&
                            HandleEntry->LockCount != 0
                           ) {
                            Flags |= HEAP_REALLOC_IN_PLACE_ONLY;
                            }
                        else {
                            Flags &= ~HEAP_REALLOC_IN_PLACE_ONLY;
                            }

#pragma prefast(suppress: 308, "Realloc is allowed to lose this pointer")
                        p = RtlReAllocateHeap( BaseHeap, MAKE_TAG( LMEM_TAG ) | Flags, p, uBytes );
                        }

                    if (p != NULL) {
                        HandleEntry->Object = p;
                        HandleEntry->Flags &= ~BASE_HANDLE_DISCARDED;
                        }
                    else {
                        hMem = NULL;
                        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                        }
                    }
                }
            }
        else
        if (!(uFlags & LMEM_MODIFY)) {
#pragma prefast(suppress: 308, "Realloc is allowed to lose this pointer")
            hMem = RtlReAllocateHeap( BaseHeap, MAKE_TAG( LMEM_TAG ) | Flags, (PVOID)hMem, uBytes );
            if (hMem == NULL) {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        hMem = NULL;
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    return( (LPSTR)hMem );
}

PVOID
WINAPI
LocalLock(
    HLOCAL hMem
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    LPSTR p;

    if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
        RtlLockHeap( BaseHeap );

        try {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (!RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
#if DBG
                DbgPrint( "*** LocalLock( %lx ) - invalid handle\n", hMem );
                BaseHeapBreakPoint();
#endif
                SetLastError( ERROR_INVALID_HANDLE );
                p = NULL;
                }
            else {
                p = HandleEntry->Object;
                if (p != NULL) {
                    if (HandleEntry->LockCount++ == LMEM_LOCKCOUNT) {
                        HandleEntry->LockCount--;
                        }
                    }
                else {
                    SetLastError( ERROR_DISCARDED );
                    }
                }
            }
        except (EXCEPTION_EXECUTE_HANDLER) {
            p = NULL;
            BaseSetLastNTError( GetExceptionCode() );
            }

        RtlUnlockHeap( BaseHeap );

        return( p );
        }
    else {
        if ( (ULONG_PTR)hMem >= SystemRangeStart ) {
            return NULL;
            }
        return( (LPSTR)hMem );
        }
}

HLOCAL
WINAPI
LocalHandle(
    LPCVOID pMem
    )
{
    HANDLE Handle;
    ULONG Flags;

    RtlLockHeap( BaseHeap );
    try {
        Handle = NULL;
        if (!RtlGetUserInfoHeap( BaseHeap, HEAP_NO_SERIALIZE, (LPVOID)pMem, &Handle, &Flags )) {
            SetLastError( ERROR_INVALID_HANDLE );
            }
        else
        if (Handle == NULL || !(Flags & BASE_HEAP_FLAG_MOVEABLE)) {
            Handle = (HANDLE)pMem;
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    return( Handle );
}

BOOL
WINAPI
LocalUnlock(
    HLOCAL hMem
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    BOOL Result;

    Result = FALSE;
    if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
        RtlLockHeap( BaseHeap );
        try {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (!RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
#if DBG
                DbgPrint( "*** LocalUnlock( %lx ) - invalid handle\n", hMem );
                BaseHeapBreakPoint();
#endif
                SetLastError( ERROR_INVALID_HANDLE );
                }
            else
            if (HandleEntry->LockCount-- == 0) {
                HandleEntry->LockCount++;
                SetLastError( ERROR_NOT_LOCKED );
                }
            else
            if (HandleEntry->LockCount != 0) {
                Result = TRUE;
                }
            else {
                SetLastError( NO_ERROR );
                }
            }
        except (EXCEPTION_EXECUTE_HANDLER) {
            BaseSetLastNTError( GetExceptionCode() );
            }

        RtlUnlockHeap( BaseHeap );
        }
    else {
        SetLastError( ERROR_NOT_LOCKED );
        }

    return( Result );
}


SIZE_T
WINAPI
LocalSize(
    HLOCAL hMem
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    PVOID Handle;
    ULONG Flags;
    SIZE_T uSize;

    uSize = MAXULONG_PTR;
    Flags = 0;
    RtlLockHeap( BaseHeap );
    try {
        if (!((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT)) {
            Handle = NULL;
            if (!RtlGetUserInfoHeap( BaseHeap, Flags, hMem, &Handle, &Flags )) {
                }
            else
            if (Handle == NULL || !(Flags & BASE_HEAP_FLAG_MOVEABLE)) {
                uSize = RtlSizeHeap( BaseHeap, HEAP_NO_SERIALIZE, (PVOID)hMem );
                }
            else {
                hMem = Handle;
                }
            }

        if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (!RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
#if DBG
                DbgPrint( "*** LocalSize( %lx ) - invalid handle\n", hMem );
                BaseHeapBreakPoint();
#endif
                SetLastError( ERROR_INVALID_HANDLE );
                }
            else
            if (HandleEntry->Flags & BASE_HANDLE_DISCARDED) {
                uSize = HandleEntry->Size;
                }
            else {
                uSize = RtlSizeHeap( BaseHeap, HEAP_NO_SERIALIZE, HandleEntry->Object );
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    if (uSize == MAXULONG_PTR) {
        SetLastError( ERROR_INVALID_HANDLE );
        return 0;
        }
    else {
        return uSize;
        }
}


UINT
WINAPI
LocalFlags(
    HLOCAL hMem
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    HANDLE Handle;
    ULONG Flags;
    UINT uFlags;

    uFlags = LMEM_INVALID_HANDLE;
    RtlLockHeap( BaseHeap );
    try {
        if (!((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT)) {
            Handle = NULL;
            Flags = 0;
            if (!RtlGetUserInfoHeap( BaseHeap, Flags, hMem, &Handle, &Flags )) {
                }
            else
            if (Handle == NULL || !(Flags & BASE_HEAP_FLAG_MOVEABLE)) {
                uFlags = 0;
                }
            else {
                hMem = Handle;
                }
            }

        if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
                uFlags = HandleEntry->LockCount & LMEM_LOCKCOUNT;
                if (HandleEntry->Flags & BASE_HANDLE_DISCARDED) {
                    uFlags |= LMEM_DISCARDED;
                    }

                if (HandleEntry->Flags & BASE_HANDLE_DISCARDABLE) {
                    uFlags |= LMEM_DISCARDABLE;
                    }
                }
            }

        if (uFlags == LMEM_INVALID_HANDLE) {
#if DBG
            DbgPrint( "*** LocalFlags( %lx ) - invalid handle\n", hMem );
            BaseHeapBreakPoint();
#endif
            SetLastError( ERROR_INVALID_HANDLE );
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    return( uFlags );
}


HLOCAL
WINAPI
LocalFree(
    HLOCAL hMem
    )
{
    PBASE_HANDLE_TABLE_ENTRY HandleEntry;
    LPSTR p;

    try {
        if (!((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT)) {
            if (RtlFreeHeap( BaseHeap,
                             0,
                             (PVOID)hMem
                           )
               ) {
                return NULL;
                }
            else {
                SetLastError( ERROR_INVALID_HANDLE );
                return hMem;
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        return hMem;
        }

    RtlLockHeap( BaseHeap );
    try {
        if ((ULONG_PTR)hMem & BASE_HANDLE_MARK_BIT) {
            HandleEntry = (PBASE_HANDLE_TABLE_ENTRY)
                CONTAINING_RECORD( hMem, BASE_HANDLE_TABLE_ENTRY, Object );

            if (!RtlIsValidHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry )) {
#if DBG
                DbgPrint( "*** LocalFree( %lx ) - invalid handle\n", hMem );
                BaseHeapBreakPoint();
#endif
                SetLastError( ERROR_INVALID_HANDLE );
                p = NULL;
                }
            else {
#if DBG
                if (HandleEntry->LockCount != 0) {
                    DbgPrint( "BASE: LocalFree called with a locked object.\n" );
                    BaseHeapBreakPoint();
                    }
#endif
                p = HandleEntry->Object;
                RtlFreeHandle( &BaseHeapHandleTable, (PRTL_HANDLE_TABLE_ENTRY)HandleEntry );
                if (p == NULL) {
                    hMem = NULL;
                    }
                }
            }
        else {
            p = (LPSTR)hMem;
            }

        if (p != NULL) {
            if (RtlFreeHeap( BaseHeap, HEAP_NO_SERIALIZE, p )) {
                hMem = NULL;
                }
            else {
                SetLastError( ERROR_INVALID_HANDLE );
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        }

    RtlUnlockHeap( BaseHeap );

    return( hMem );
}


SIZE_T
WINAPI
LocalCompact(
    UINT uMinFree
    )
{
    return RtlCompactHeap( BaseHeap, 0 );
}

SIZE_T
WINAPI
LocalShrink(
    HLOCAL hMem,
    UINT cbNewSize
    )
{
    return RtlCompactHeap( BaseHeap, 0 );
}


HANDLE
WINAPI
HeapCreate(
    DWORD flOptions,
    SIZE_T dwInitialSize,
    SIZE_T dwMaximumSize
    )
{
    HANDLE hHeap;
    ULONG GrowthThreshold;
    ULONG Flags;


    Flags = (flOptions & (HEAP_GENERATE_EXCEPTIONS | HEAP_NO_SERIALIZE)) | HEAP_CLASS_1;
    GrowthThreshold = 0;

    if (dwMaximumSize < BASE_SYSINFO.PageSize) {

        if (dwMaximumSize == 0) {

            GrowthThreshold = BASE_SYSINFO.PageSize * 16;
            Flags |= HEAP_GROWABLE;
            }
        else {
            dwMaximumSize = BASE_SYSINFO.PageSize;
            }
        }

    if (GrowthThreshold == 0 && dwInitialSize > dwMaximumSize) {
        dwMaximumSize = dwInitialSize;
        }

    hHeap = (HANDLE)RtlCreateHeap( Flags,
                                   NULL,
                                   dwMaximumSize,
                                   dwInitialSize,
                                   0,
                                   NULL
                                 );
    if (hHeap == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }

    return( hHeap );
}

BOOL
WINAPI
HeapDestroy(
    HANDLE hHeap
    )
{
    if (RtlDestroyHeap( (PVOID)hHeap ) == NULL ) {
        return( TRUE );
        }
    else {
        SetLastError( ERROR_INVALID_HANDLE );
        return( FALSE );
        }
}

BOOL
WINAPI
HeapExtend(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpBase,
    DWORD dwBytes
    )
{
    NTSTATUS Status;

    Status = RtlExtendHeap( hHeap, dwFlags, lpBase, dwBytes );
    if (NT_SUCCESS( Status )) {
        return TRUE;
        }
    else {
        BaseSetLastNTError( Status );
        }
    return FALSE;
}

WINBASEAPI
DWORD
WINAPI
HeapCreateTagsW(
    HANDLE hHeap,
    DWORD dwFlags,
    LPCWSTR lpTagPrefix,
    LPCWSTR lpTagNames
    )
{
    return RtlCreateTagHeap( hHeap, dwFlags, (PWSTR)lpTagPrefix, (PWSTR)lpTagNames );
}

WINBASEAPI
LPCWSTR
WINAPI
HeapQueryTagW(
    HANDLE hHeap,
    DWORD dwFlags,
    WORD wTagIndex,
    BOOL bResetCounters,
    LPHEAP_TAG_INFO TagInfo
    )
{
    ASSERT( sizeof(RTL_HEAP_TAG_INFO) == sizeof(HEAP_TAG_INFO) );
    return RtlQueryTagHeap( hHeap,
                            dwFlags,
                            wTagIndex,
                            (BOOLEAN)bResetCounters,
                            (PRTL_HEAP_TAG_INFO)TagInfo
                          );
}


BOOL
WINAPI
HeapSummary(
    HANDLE hHeap,
    DWORD dwFlags,
    LPHEAP_SUMMARY lpSummary
    )
{
    NTSTATUS Status;
    RTL_HEAP_USAGE HeapInfo;

    if (lpSummary->cb != sizeof( *lpSummary )) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
        }

    HeapInfo.Length = sizeof( HeapInfo );
    Status = RtlUsageHeap( hHeap,
                           dwFlags & ~(HEAP_USAGE_ALLOCATED_BLOCKS |
                                       HEAP_USAGE_FREE_BUFFER
                                      ),
                           &HeapInfo
                         );
    if (NT_SUCCESS( Status )) {
        lpSummary->cbAllocated = HeapInfo.BytesAllocated;
        lpSummary->cbCommitted = HeapInfo.BytesCommitted;
        return TRUE;
        }
    else {
        BaseSetLastNTError( Status );
        return FALSE;
        }
}

BOOL
WINAPI
HeapUsage(
    HANDLE hHeap,
    DWORD dwFlags,
    BOOL bFirstCall,
    BOOL bLastCall,
    PHEAP_USAGE lpUsage
    )
{
    NTSTATUS Status;

    if (lpUsage->cb != sizeof( *lpUsage ) || (bFirstCall & bLastCall)) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
        }

    dwFlags &= ~(HEAP_USAGE_ALLOCATED_BLOCKS |
                 HEAP_USAGE_FREE_BUFFER
                );

    if (bLastCall) {
        dwFlags |= HEAP_USAGE_FREE_BUFFER;
        }
    else {
        dwFlags |= HEAP_USAGE_ALLOCATED_BLOCKS;
        if (bFirstCall) {
            RtlZeroMemory( (&lpUsage->cb)+1, sizeof( *lpUsage ) - sizeof( lpUsage->cb ) );
            }
        }

    ASSERT( sizeof(RTL_HEAP_USAGE) == sizeof(HEAP_USAGE) );
    Status = RtlUsageHeap( hHeap, dwFlags, (PRTL_HEAP_USAGE)lpUsage );
    if (NT_SUCCESS( Status )) {
        if (Status == STATUS_MORE_ENTRIES) {
            return TRUE;
            }
        else {
            SetLastError( NO_ERROR );
            return FALSE;
            }
        }
    else {
        BaseSetLastNTError( Status );
        return FALSE;
        }
}

BOOL
WINAPI
HeapValidate(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem
    )
{
    return RtlValidateHeap( hHeap, dwFlags, lpMem );
}

HANDLE
WINAPI
GetProcessHeap( VOID )
{
    return RtlProcessHeap();
}


WINBASEAPI
DWORD
WINAPI
GetProcessHeaps(
    DWORD NumberOfHeaps,
    PHANDLE ProcessHeaps
    )
{
    return RtlGetProcessHeaps( NumberOfHeaps, ProcessHeaps );
}


WINBASEAPI
SIZE_T
WINAPI
HeapCompact(
    HANDLE hHeap,
    DWORD dwFlags
    )
{
    return RtlCompactHeap( hHeap, dwFlags );
}


WINBASEAPI
BOOL
WINAPI
HeapLock(
    HANDLE hHeap
    )
{
    return RtlLockHeap( hHeap );
}


WINBASEAPI
BOOL
WINAPI
HeapUnlock(
    HANDLE hHeap
    )
{
    return RtlUnlockHeap( hHeap );
}

WINBASEAPI
BOOL
WINAPI
HeapWalk(
    HANDLE hHeap,
    LPPROCESS_HEAP_ENTRY lpEntry
    )
{
    RTL_HEAP_WALK_ENTRY Entry;
    NTSTATUS Status;

    if (lpEntry->lpData == NULL) {
        Entry.DataAddress = NULL;
        Status = RtlWalkHeap( hHeap, &Entry );
        }
    else {
        Entry.DataAddress = lpEntry->lpData;
        Entry.SegmentIndex = lpEntry->iRegionIndex;
        if (lpEntry->wFlags & PROCESS_HEAP_REGION) {
            Entry.Flags = RTL_HEAP_SEGMENT;
            }
        else
        if (lpEntry->wFlags & PROCESS_HEAP_UNCOMMITTED_RANGE) {
            Entry.Flags = RTL_HEAP_UNCOMMITTED_RANGE;
            Entry.DataSize = lpEntry->cbData;
            }
        else
        if (lpEntry->wFlags & PROCESS_HEAP_ENTRY_BUSY) {
            Entry.Flags = RTL_HEAP_BUSY;
            }
        else {
            Entry.Flags = 0;
            }

        Status = RtlWalkHeap( hHeap, &Entry );
        }

    if (NT_SUCCESS( Status )) {
        lpEntry->lpData = Entry.DataAddress;
        lpEntry->cbData = (DWORD)Entry.DataSize;
        lpEntry->cbOverhead = Entry.OverheadBytes;
        lpEntry->iRegionIndex = Entry.SegmentIndex;
        if (Entry.Flags & RTL_HEAP_BUSY) {
            lpEntry->wFlags = PROCESS_HEAP_ENTRY_BUSY;
            if (Entry.Flags & BASE_HEAP_FLAG_DDESHARE) {
                lpEntry->wFlags |= PROCESS_HEAP_ENTRY_DDESHARE;
                }

            if (Entry.Flags & BASE_HEAP_FLAG_MOVEABLE) {
                lpEntry->wFlags |= PROCESS_HEAP_ENTRY_MOVEABLE;
                lpEntry->Block.hMem = (HLOCAL)Entry.Block.Settable;
                }

            memset( lpEntry->Block.dwReserved, 0, sizeof( lpEntry->Block.dwReserved ) );
            }
        else
        if (Entry.Flags & RTL_HEAP_SEGMENT) {
            lpEntry->wFlags = PROCESS_HEAP_REGION;
            lpEntry->Region.dwCommittedSize = Entry.Segment.CommittedSize;
            lpEntry->Region.dwUnCommittedSize = Entry.Segment.UnCommittedSize;
            lpEntry->Region.lpFirstBlock = Entry.Segment.FirstEntry;
            lpEntry->Region.lpLastBlock = Entry.Segment.LastEntry;
            }
        else
        if (Entry.Flags & RTL_HEAP_UNCOMMITTED_RANGE) {
            lpEntry->wFlags = PROCESS_HEAP_UNCOMMITTED_RANGE;
            memset( &lpEntry->Region, 0, sizeof( lpEntry->Region ) );
            }
        else {
            lpEntry->wFlags = 0;
            }

        return TRUE;
        }
    else {
        BaseSetLastNTError( Status );
        return FALSE;
        }
}

WINBASEAPI
BOOL
WINAPI
HeapSetInformation (
    IN HANDLE HeapHandle, 
    IN HEAP_INFORMATION_CLASS HeapInformationClass,
    IN PVOID HeapInformation OPTIONAL,
    IN SIZE_T HeapInformationLength OPTIONAL
    )
{
    NTSTATUS Status;

    Status = RtlSetHeapInformation( (PVOID)HeapHandle, 
                                    HeapInformationClass, 
                                    HeapInformation, 
                                    HeapInformationLength );
    if (NT_SUCCESS( Status )) {
        return TRUE;
        }
    else {
        BaseSetLastNTError( Status );
        }
    return FALSE;
}

WINBASEAPI
BOOL
WINAPI
HeapQueryInformation (
    IN HANDLE HeapHandle, 
    IN HEAP_INFORMATION_CLASS HeapInformationClass,
    OUT PVOID HeapInformation OPTIONAL,
    IN SIZE_T HeapInformationLength OPTIONAL,
    OUT PSIZE_T ReturnLength OPTIONAL
    )
{
    NTSTATUS Status;

    Status = RtlQueryHeapInformation( (PVOID)HeapHandle, 
                                      HeapInformationClass, 
                                      HeapInformation, 
                                      HeapInformationLength,
                                      ReturnLength );
    if (NT_SUCCESS( Status )) {
        return TRUE;
        }
    else {
        BaseSetLastNTError( Status );
        }
    return FALSE;
}

#if DBG
VOID
BaseHeapBreakPoint( VOID )
{
    if (NtCurrentPeb()->BeingDebugged)
        {
#if i386
        _asm {  int 3 }
#else
        DbgBreakPoint();
#endif
        }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\mtbnch.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

//
// - hStartOfRace is a manual reset event that is signalled when
//   all of the threads are supposed to cut loose and begin working
//
// - hEndOfRace is a manual reset event that is signalled once the end time
//   has been retrieved and it is ok for the threads to exit
//

HANDLE hStartOfRace;
HANDLE hEndOfRace;

#define MAX_THREADS 32

//
// - ThreadReadyDoneEvents are an array of autoclearing events. The threads
//   initially signal these events once they have reached their start routines
//   and are ready to being processing. Once they are done processing, they
//   signal thier event to indicate that they are done processing.
//
// - ThreadHandles are an array of thread handles to the worker threads. The
//   main thread waits on these to know when all of the threads have exited.
//

HANDLE ThreadReadyDoneEvents[MAX_THREADS];
HANDLE ThreadHandles[MAX_THREADS];

//
// Each thread has a THREAD_WORK structure. This contains the address
// of the cells that this thread is responsible for, and the number of
// cells it is supposed to process.
//

typedef struct _THREAD_WORK {
    PDWORD CellVector;
    DWORD NumberOfCells;
    DWORD RecalcResult;
} THREAD_WORK, *PTHREAD_WORK;

THREAD_WORK ThreadWork[MAX_THREADS];

#define ONE_MB      (1024*1024)

DWORD Mb = 4;
DWORD NumberOfThreads = 1;
DWORD ExpectedRecalcValue;
DWORD ActualRecalcValue;
DWORD ContentionValue;
BOOL fMemoryContention;

DWORD WorkerThread(PVOID ThreadIndex);

int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    DWORD StartTicks, EndTicks;
    DWORD i;
    BOOL fShowUsage;
    char c, *p, *whocares;
    PDWORD CellVector;
    DWORD NumberOfDwords;
    DWORD DwordsPerThread;
    DWORD ThreadId;
    LPSTR Answer;

    fShowUsage = FALSE;
    fMemoryContention = FALSE;

    if (argc <= 1) {
        goto showUsage;
        }

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
            switch (toupper( c )) {
            case '?':
                fShowUsage = TRUE;
                goto showUsage;
                break;

            case 'M':
                if (!argc--) {
                    fShowUsage = TRUE;
                    goto showUsage;
                    }
                argv++;
                Mb = strtoul(*argv,&whocares,10);
                break;

            case 'C':
                fMemoryContention = TRUE;
                break;

            case 'T':
                if (!argc--) {
                    fShowUsage = TRUE;
                    goto showUsage;
                    }
                argv++;
                NumberOfThreads = strtoul(*argv,&whocares,10);
                if ( NumberOfThreads > MAX_THREADS ) {
                    fShowUsage = TRUE;
                    goto showUsage;
                    }
                break;

            default:
                fprintf( stderr, "MTBNCH: Invalid switch - /%c\n", c );
                goto showUsage;
                break;
                }
            }
        }

showUsage:
    if ( fShowUsage ) {
        fprintf(stderr,"usage: MTBNCH\n" );
        fprintf(stderr,"              [-?] display this message\n" );
        fprintf(stderr,"              [-t n] use n threads for benchmark (less than 32)\n" );
        fprintf(stderr,"              [-m n] use an n Mb spreadsheet size (default 4)\n" );
        fprintf(stderr,"              [-c] cause memory contention on each loop iteration\n" );
        ExitProcess(1);
        }

    //
    // Prepare the race events. These are manual reset events.
    //

    hStartOfRace = CreateEvent(NULL,TRUE,FALSE,NULL);
    hEndOfRace = CreateEvent(NULL,TRUE,FALSE,NULL);

    if ( !hStartOfRace || !hEndOfRace ) {
        fprintf(stderr,"MTBNCH: Race Event Creation Failed\n");
        ExitProcess(1);
        }

    //
    // Prepare the ready done events. These are auto clearing events
    //

    for(i=0; i<NumberOfThreads; i++ ) {
        ThreadReadyDoneEvents[i] = CreateEvent(NULL,FALSE,FALSE,NULL);
        if ( !ThreadReadyDoneEvents[i] ) {
            fprintf(stderr,"MTBNCH: Ready Done Event Creation Failed %d\n",GetLastError());
            ExitProcess(1);
            }
        }

    //
    // Allocate and initialize the CellVector
    //

    CellVector = (PDWORD)VirtualAlloc(NULL,Mb*ONE_MB,MEM_COMMIT,PAGE_READWRITE);
    if ( !CellVector ) {
        fprintf(stderr,"MTBNCH: Cell Vector Allocation Failed %d\n",GetLastError());
        ExitProcess(1);
        }

    NumberOfDwords = (Mb*ONE_MB) / sizeof(DWORD);
    DwordsPerThread = NumberOfDwords / NumberOfThreads;

    //
    // Initialize the Cell Vector
    //

    for(i=0, ExpectedRecalcValue; i<NumberOfDwords; i++ ){
        ExpectedRecalcValue += i;
        CellVector[i] = i;
        }

    //
    // Partition the work to the worker threads
    //

    for(i=0; i<NumberOfThreads; i++ ){
        ThreadWork[i].CellVector = &CellVector[i*DwordsPerThread];
        ThreadWork[i].NumberOfCells = DwordsPerThread;
        NumberOfDwords -= DwordsPerThread;

        //
        // If we have a remainder, give the remaining work to the last thread
        //

        if ( NumberOfDwords < DwordsPerThread ) {
            ThreadWork[i].NumberOfCells += NumberOfDwords;
            }
        }

    //
    // Create the worker threads
    //

    for(i=0; i<NumberOfThreads; i++ ) {
        ThreadHandles[i] = CreateThread(
                                NULL,
                                0,
                                WorkerThread,
                                (PVOID)i,
                                0,
                                &ThreadId
                                );
        if ( !ThreadHandles[i] ) {
            fprintf(stderr,"MTBNCH: Worker Thread Creation Failed %d\n",GetLastError());
            ExitProcess(1);
            }
        }

    //
    // All of the worker threads will signal thier ready done event
    // when they are idle and ready to proceed. Once all events have been
    // set, then setting the hStartOfRaceEvent will begin the recalc
    //

    i = WaitForMultipleObjects(
            NumberOfThreads,
            ThreadReadyDoneEvents,
            TRUE,
            INFINITE
            );

    if ( i == WAIT_FAILED ) {
        fprintf(stderr,"MTBNCH: Wait for threads to stabalize Failed %d\n",GetLastError());
        ExitProcess(1);
        }

    //
    // Everthing is set to begin the recalc operation
    //

    StartTicks = GetTickCount();
    if ( !SetEvent(hStartOfRace) ) {
        fprintf(stderr,"MTBNCH: SetEvent(hStartOfRace) Failed %d\n",GetLastError());
        ExitProcess(1);
        }

    //
    // Now just wait for the recalc to complete
    //

    i = WaitForMultipleObjects(
            NumberOfThreads,
            ThreadReadyDoneEvents,
            TRUE,
            INFINITE
            );

    if ( i == WAIT_FAILED ) {
        fprintf(stderr,"MTBNCH: Wait for threads to complete Failed %d\n",GetLastError());
        ExitProcess(1);
        }

    //
    // Now pick up the individual recalc values
    //

    for(i=0, ActualRecalcValue = 0; i<NumberOfThreads; i++ ){
        ActualRecalcValue += ThreadWork[i].RecalcResult;
        }

    EndTicks = GetTickCount();

    if ( fMemoryContention ) {
        if ( ContentionValue == (Mb*ONE_MB) / sizeof(DWORD) ) {
            if ( ActualRecalcValue == ExpectedRecalcValue ) {
                Answer = "Correct";
                }
            else {
                Answer = "Recalc Failure";
                }
            }
        else {
            Answer = "Contention Failure";
            }
        }
    else {
        if ( ActualRecalcValue == ExpectedRecalcValue ) {
            Answer = "Correct";
            }
        else {
            Answer = "Recalc Failure";
            }
        }

    fprintf(stdout,"MTBNCH: %d Thread Recalc complete in %dms, Answer = %s\n",
        NumberOfThreads,
        EndTicks-StartTicks,
        Answer
        );

    ExitProcess(2);
}

//
// The worker threads perform the recalc operation on their
// assigned cells. They begin by setting their ready done event
// to indicate that they are ready to begin the recalc. Then they
// wait until the hStartOfRace event is signaled. Once this occurs, they
// do their part of the recalc and when done they signal their ready done
// event and then wait on the hEndOfRaceEvent
//

DWORD
WorkerThread(
    PVOID ThreadIndex
    )
{

    DWORD Me;
    PDWORD MyCellVectorBase;
    PDWORD CurrentCellVector;
    DWORD MyRecalcValue;
    DWORD MyNumberOfCells;
    DWORD i;
    BOOL MemoryContention;

    Me = (DWORD)ThreadIndex;
    MyRecalcValue = 0;
    MyCellVectorBase = ThreadWork[Me].CellVector;
    MyNumberOfCells = ThreadWork[Me].NumberOfCells;
    MemoryContention = fMemoryContention;

    //
    // Signal that I am ready to go
    //

    if ( !SetEvent(ThreadReadyDoneEvents[Me]) ) {
        fprintf(stderr,"MTBNCH: (1) SetEvent(ThreadReadyDoneEvent[%d]) Failed %d\n",Me,GetLastError());
        ExitProcess(1);
        }

    //
    // Wait for the master to release us to do the recalc
    //

    i = WaitForSingleObject(hStartOfRace,INFINITE);
    if ( i == WAIT_FAILED ) {
        fprintf(stderr,"MTBNCH: Thread %d Wait for start of recalc Failed %d\n",Me,GetLastError());
        ExitProcess(1);
        }

    //
    // perform the recalc operation
    //

    for (i=0, CurrentCellVector = MyCellVectorBase; i<MyNumberOfCells; i++ ) {
        MyRecalcValue += *CurrentCellVector++;
        if ( MemoryContention ) {
            InterlockedIncrement(&ContentionValue);
            }
        }
    ThreadWork[Me].RecalcResult = MyRecalcValue;

    //
    // Signal that I am done and then wait for further instructions
    //

    if ( !SetEvent(ThreadReadyDoneEvents[Me]) ) {
        fprintf(stderr,"MTBNCH: (2) SetEvent(ThreadReadyDoneEvent[%d]) Failed %d\n",Me,GetLastError());
        ExitProcess(1);
        }

    i = WaitForSingleObject(hEndOfRace,INFINITE);
    if ( i == WAIT_FAILED ) {
        fprintf(stderr,"MTBNCH: Thread %d Wait for end of recalc Failed %d\n",Me,GetLastError());
        ExitProcess(1);
        }

    return MyRecalcValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\module.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    module.c

Abstract:

    This module contains the Win32 Module Management APIs

Author:

    Steve Wood (stevewo) 24-Sep-1990

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop
#include <winsafer.h>
#include <winuserp.h>
#include <sxstypes.h>

PVOID
BasepMapModuleHandle(
    IN HMODULE hModule OPTIONAL,
    IN BOOLEAN bResourcesOnly
    )
{
    if (ARGUMENT_PRESENT( hModule )) {
        if (LDR_IS_DATAFILE(hModule)) {
            if (bResourcesOnly) {
                return( (PVOID)hModule );
            } else {
                return( NULL );
            }
        } else {
            return( (PVOID)hModule );
        }
    } else {
        return( (PVOID)NtCurrentPeb()->ImageBaseAddress);
    }
}

NTSTATUS
BasepLoadLibraryAsDataFile(
    IN PWSTR DllPath OPTIONAL,
    IN PUNICODE_STRING DllName,
    OUT PVOID *DllHandle
    )

{
    WCHAR FullPath[ MAX_PATH ];
    PWSTR FilePart;
    HANDLE FileHandle;
    HANDLE MappingHandle;
    UNICODE_STRING FullPathPreAllocatedString;
    UNICODE_STRING FullPathDynamicString = {0};
    UNICODE_STRING DefaultExtensionString = RTL_CONSTANT_STRING(L".DLL");
    PUNICODE_STRING FullPathString = NULL;
    LPVOID DllBase = NULL;
    SIZE_T DllSize = 0;
    PIMAGE_NT_HEADERS NtHeaders;
    PTEB Teb;
    NTSTATUS Status;
    ACTIVATION_CONTEXT_SECTION_KEYED_DATA askd;

    Teb = NtCurrentTeb();

    *DllHandle = NULL;

    FullPathPreAllocatedString.MaximumLength = sizeof(FullPath);
    FullPathPreAllocatedString.Length = 0;
    FullPathPreAllocatedString.Buffer = FullPath;

    Status = RtlDosApplyFileIsolationRedirection_Ustr(
        RTL_DOS_APPLY_FILE_REDIRECTION_USTR_FLAG_RESPECT_DOT_LOCAL,
        DllName,
        &DefaultExtensionString,
        &FullPathPreAllocatedString,
        &FullPathDynamicString,
        &FullPathString,
        NULL,
        NULL,
        NULL);
    if (NT_ERROR(Status)) {
        if (Status != STATUS_SXS_KEY_NOT_FOUND)
            goto Exit;

        if (!SearchPathW( DllPath,
                          DllName->Buffer,
                          DefaultExtensionString.Buffer,
                          sizeof(FullPath) / sizeof(FullPath[0]),
                          FullPath,
                          &FilePart
                        )
           ) {
            Status = Teb->LastStatusValue;
            goto Exit;
        }

        FullPathString = &FullPathPreAllocatedString;
    }

    FileHandle = CreateFileW( FullPathString->Buffer,
                              GENERIC_READ,
                              FILE_SHARE_READ | FILE_SHARE_DELETE,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL
                            );

    if (FileHandle == INVALID_HANDLE_VALUE) {
        Status = Teb->LastStatusValue;
        goto Exit;
    }

    MappingHandle = CreateFileMappingW( FileHandle,
                                        NULL,
                                        PAGE_READONLY,
                                        0,
                                        0,
                                        NULL
                                      );
    CloseHandle( FileHandle );
    if (MappingHandle == NULL) {
        Status = Teb->LastStatusValue;
        goto Exit;
    }

    Status = NtMapViewOfSection (
                   MappingHandle,
                   NtCurrentProcess(),
                   &DllBase,
                   0,
                   0,
                   NULL,
                   &DllSize,
                   ViewShare,
                   0,
                   PAGE_READONLY
                   );
    CloseHandle( MappingHandle );
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    Status = RtlImageNtHeaderEx(0, DllBase, DllSize, &NtHeaders);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    *DllHandle = LDR_VIEW_TO_DATAFILE(DllBase);
    LdrLoadAlternateResourceModule(*DllHandle, FullPathString->Buffer);

    Status = STATUS_SUCCESS;

Exit:
    if (!NT_SUCCESS(Status) && DllBase != NULL) {
        UnmapViewOfFile( DllBase );
    }
    if (FullPathDynamicString.Buffer != NULL)
        RtlFreeUnicodeString(&FullPathDynamicString);
    return Status;
}

typedef struct _BASEP_GET_DLL_DIR_FROM_ADDRESS_CONTEXT {
    IN PVOID Address;
    OUT LPWSTR *Dir;
    OUT NTSTATUS Status;
} BASEP_GET_DLL_DIR_FROM_ADDRESS_CONTEXT,
    *PBASEP_GET_DLL_DIR_FROM_ADDRESS_CONTEXT;

VOID
BasepGetDllDirFromAddress(
    IN PCLDR_DATA_TABLE_ENTRY Entry,
    IN PVOID ContextIn,
    IN OUT BOOLEAN *StopEnumeration
    )

/*++

Routine Description:

    This function is a LDR_LOADED_MODULE_ENUMBERATION_CALLBACK_FUNCTION
    which locates a given dll by address.

Arguments:

    Entry - the entry currently being enumerated.

    ContextIn - a pointer to a BASEP_GET_DLL_DIR_FROM_ADDRESS_CONTEXT

    StopEnumeration - used to stop the enumeration.

Return Value:

    None.  The directory name of the indicated module is returned via
    the context, as is the status of the operation.

--*/

{
    PBASEP_GET_DLL_DIR_FROM_ADDRESS_CONTEXT Context =
        (PBASEP_GET_DLL_DIR_FROM_ADDRESS_CONTEXT) ContextIn;

    SIZE_T NameLengthInChars;
    PCWSTR DllDirEnd;

    ASSERT(Entry);
    ASSERT(Context);
    ASSERT(StopEnumeration);

    if (Entry->DllBase <= Context->Address
        && ((PCHAR)Context->Address
            < ((PCHAR)Entry->DllBase + Entry->SizeOfImage))) {

        // One way or another, we're done...
        *StopEnumeration = TRUE;

        if (BasepExeLdrEntry && Entry == BasepExeLdrEntry) {
            // There's no point in adding the exe's directory to the
            // path.
            return;
        }

        DllDirEnd = BasepEndOfDirName(Entry->FullDllName.Buffer);

        ASSERT(DllDirEnd);

        if (! DllDirEnd) {
            // In case we couldn't find the end on some production
            // machine, we'll just return.
            return;
        }

        NameLengthInChars = DllDirEnd - Entry->FullDllName.Buffer;

        ASSERT(0 < NameLengthInChars);

        if (NameLengthInChars == 0) {
            // Again, just in case we weren't able to compute this,
            // we'll just return.
            return;
        }
        
        *Context->Dir = RtlAllocateHeap(RtlProcessHeap(),
                                        MAKE_TAG(TMP_TAG),
                                        (NameLengthInChars + 1) << 1);

        if (! *Context->Dir) {
            Context->Status = STATUS_NO_MEMORY;
            return;
        }

        RtlCopyMemory(*Context->Dir,
                      Entry->FullDllName.Buffer,
                      NameLengthInChars << 1);

        (*Context->Dir)[NameLengthInChars] = UNICODE_NULL;
    }
}

HMODULE
LoadLibraryExW(
    LPCWSTR lpwLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    )

/*++

Routine Description:

    This function loads the library module contained in the specified
    file and retrieves a handle to the loaded module.

    It is important to note that module handles are NOT global, in that
    a LoadLibrary call by one application does not produce a handle that
    another application can use, say in calling GetProcAddress.  The
    other application would need to do its own call to LoadLibrary for
    the module before calling GetProcAddress.  Module handles will have
    the same 32-bit value across all processes, but a module handle is
    only valid in the context of a process after the module has been
    loaded into that process, either as a result of an explicit call to
    LoadLibrary or as a result of an implicit call caused by a loadtime
    dynamic link to an entry point in the module.

    The library file name does not need to specify an extension.  If one
    is not specified, then the default library file extension, .DLL, is
    used (note that this is different than Win16. Under Win16 specifying
    no extension would not cause ".DLL" to be appended to the name. To get
    Win16 behavior, if the module name has no extension, the caller must
    supply a trailing ".").

    The library file name does not need to specify a directory path.  If
    one is specified, then the specified file must exist.  If a path is
    not specified, this function will look for the library file in using
    the Windows search path:

      - The current process image file directory

      - The current directory

      - The Windows system directory

      - The Windows directory

      - The directories listed in the PATH environment variable

    The first directory searched is the directory that contains the
    image file that was used to create the current process (see
    CreateProcess).  This allows private dynamic link library files
    associated with an application to be found without having to add the
    application's installed directory to the PATH environment variable.

    The image file loader optimizes the search by remembering for each
    loaded library module that unqualified module name that was searched
    for when a module was loaded into the current process the first
    time.  This unqualified name has nothing to do with the module name
    that is stored within the library module itself, as specified by the
    NAME keyword in the .DEF file.  This is a change from the Windows
    3.1 behavior, where the search was optimized by comparing to the
    name within the library module itself, which could lead to confusing
    result if the internal name differed from the external file name.

    Once a fully qualified path name to a library module file is
    obtained, a search is made to see if that library module file has
    been loaded into the current process.  The search is case
    insensitive and includes the full path name of each library module
    file.  If a match is found for the library module file, then it has
    already been loaded into the current process, so this function just
    increments the reference count for the module and returns the module
    handle for that library.

    Otherwise, this is the first time the specified module has been
    loaded for the current process, so the library module's DLL Instance
    Initialization entry point will be called.  See the Task Management
    section for a description of the DLL Instance Initialization entry
    point.

    Fine Point: If DLL re-direction is enabled for the app./process requesting
    this load, if we find a DLL in the app. folder (with same base name),
    we load that file (ignoring any path qualifications passed in).

Arguments:

    lpwLibFileName - Points to a string that names the library file.  The
    string must be a null-terminated unicode string.

    hFile - optional file handle, that if specified, while be used to
        create the mapping object for the module.

    dwFlags - flags that specify optional behavior.  Valid flags are:

        DONT_RESOLVE_DLL_REFERENCES - loads the library but does not
            attempt to resolve any of its DLL references nor does it
            attempt to call its initialization procedure.

        LOAD_LIBRARY_AS_DATAFILE - If this value is used, the system
            maps the file into the calling process's virtual address
            space as if it were a data file.

        LOAD_WITH_ALTERED_SEARCH_PATH - If this value is used, and
            lpFileName specifies a path, the system uses the alternate
            file search strategy

        LOAD_IGNORE_CODE_AUTHZ_LEVEL - Indicates that WinSafer sandbox
            restrictions should be ignored when loading the library
            and that load should be allowed to continue, even if the
            library is less trustworthy than the process loading it.

Return Value:

    The return value identifies the loaded module if the function is
    successful.  A return value of NULL indicates an error and extended
    error status is available using the GetLastError function.

--*/

{
    LPWSTR TrimmedDllName = NULL;
    LPWSTR AllocatedPath = NULL;
    LPWSTR InitiatorDllDirBuffer = NULL;
    LPCWSTR InitiatorDllDir;
    NTSTATUS Status = STATUS_SUCCESS;
    HMODULE hModule = NULL;
    UNICODE_STRING DllName_U;
    UNICODE_STRING AllocatedPath_U;
    ULONG DllCharacteristics;

    const DWORD ValidFlags = (DONT_RESOLVE_DLL_REFERENCES
                              | LOAD_LIBRARY_AS_DATAFILE
                              | LOAD_WITH_ALTERED_SEARCH_PATH
                              | LOAD_IGNORE_CODE_AUTHZ_LEVEL);

    // Parameter validation
    if (! (lpwLibFileName // Make sure we have a dll

           && !(dwFlags & ~ValidFlags) // Ensure flag validity

           && !hFile // and no hFile for now
        )) {
        
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    DllCharacteristics = 0;
    if (dwFlags & DONT_RESOLVE_DLL_REFERENCES) {
        DllCharacteristics |= IMAGE_FILE_EXECUTABLE_IMAGE;
    }
    if ( dwFlags & LOAD_IGNORE_CODE_AUTHZ_LEVEL ) {
        DllCharacteristics |= IMAGE_FILE_SYSTEM;
    }

    RtlInitUnicodeString(&DllName_U, lpwLibFileName);

    //
    // Quick check to see if dll being loaded is the main exe. For some reason
    // hook stuff tends to do this and this is worst path through the loader
    //

    BasepCheckExeLdrEntry();

    if ( !(dwFlags & LOAD_LIBRARY_AS_DATAFILE) && BasepExeLdrEntry && (DllName_U.Length == BasepExeLdrEntry->FullDllName.Length) ){
        if ( RtlEqualUnicodeString(&DllName_U,&BasepExeLdrEntry->FullDllName,TRUE) ) {
            return (HMODULE)BasepExeLdrEntry->DllBase;
        }
    }

    //
    // check to see if there are trailing spaces in the dll name (Win95 compat)
    //
    if ( DllName_U.Length && DllName_U.Buffer[(DllName_U.Length-1)>>1] == (WCHAR)' ') {
        TrimmedDllName = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), DllName_U.MaximumLength);
        if ( !TrimmedDllName ) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }
        RtlCopyMemory(TrimmedDllName,DllName_U.Buffer,DllName_U.MaximumLength);
        DllName_U.Buffer = TrimmedDllName;
        while (DllName_U.Length && DllName_U.Buffer[(DllName_U.Length-1)>>1] == (WCHAR)' ') {
            DllName_U.Buffer[(DllName_U.Length-1)>>1] = UNICODE_NULL;
            DllName_U.Length -= sizeof(WCHAR);
            DllName_U.MaximumLength -= sizeof(WCHAR);
        }
    }


    AllocatedPath = NULL;

    //
    // Determine the path to use for the load
    //
    AllocatedPath
        = BaseComputeProcessDllPath(
            dwFlags & LOAD_WITH_ALTERED_SEARCH_PATH ? DllName_U.Buffer : NULL,
            NULL
            );

    if ( !AllocatedPath ) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    //
    // Actually perform the library loading sequence.
    //
    RtlInitUnicodeString(&AllocatedPath_U, AllocatedPath);

    try {
        if (dwFlags & LOAD_LIBRARY_AS_DATAFILE) {
#ifdef WX86
            // LdrGetDllHandle clears UseKnownWx86Dll, but the value is
            // needed again by LdrLoadDll.
            BOOLEAN Wx86KnownDll = NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll;
#endif
            Status = LdrGetDllHandle(
                        AllocatedPath_U.Buffer,
                        NULL,
                        &DllName_U,
                        (PVOID *)&hModule
                        );
            if (NT_SUCCESS( Status )) {
#ifdef WX86
                NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = Wx86KnownDll;
#endif
                goto alreadyLoaded;
            }
            Status = BasepLoadLibraryAsDataFile( AllocatedPath_U.Buffer,
                                                 &DllName_U,
                                                 (PVOID *)&hModule
                                               );
        } else {
alreadyLoaded:
            Status = LdrLoadDll(
                        AllocatedPath_U.Buffer,
                        &DllCharacteristics,
                        &DllName_U,
                        (PVOID *)&hModule
                        );
        }
    } except ((GetExceptionCode () == STATUS_POSSIBLE_DEADLOCK) ?
                  EXCEPTION_CONTINUE_SEARCH :
                  EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }
Exit:
    if ( TrimmedDllName )
        RtlFreeHeap(RtlProcessHeap(), 0, TrimmedDllName);

    if ( AllocatedPath )
        RtlFreeHeap(RtlProcessHeap(), 0, AllocatedPath);

    if ( InitiatorDllDirBuffer )
        RtlFreeHeap(RtlProcessHeap(), 0, InitiatorDllDirBuffer);

    if (!NT_SUCCESS(Status))
        BaseSetLastNTError(Status);

    return hModule;
}


HMODULE
LoadLibraryExA(
    LPCSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    )
{
    PUNICODE_STRING Unicode;

    Unicode = Basep8BitStringToStaticUnicodeString( lpLibFileName );
    if (Unicode == NULL) {
        return NULL;
    }

    return LoadLibraryExW( Unicode->Buffer,
                           hFile,
                           dwFlags);
}

HMODULE
LoadLibraryA(
    LPCSTR lpLibFileName
    )
{
    PUNICODE_STRING Unicode;


    //
    // The specification for twain_32.dll says that this
    // DLL is supposed to be installed in %windir%. Some
    // apps put a twain_32.dll in the system32 directory
    // and all the apps using this dll will blow up.
    //

    if (ARGUMENT_PRESENT(lpLibFileName) &&
        _strcmpi(lpLibFileName, "twain_32.dll") == 0) {

        LPSTR pszBuffer;
        UINT BufferSize, StrLength;

#define SLASH_TWAIN_DLL     "\\twain_32.dll"
#define TWAIN_DLL_SIZE      sizeof(SLASH_TWAIN_DLL)

        BufferSize = MAX_PATH * sizeof(char);

        pszBuffer = RtlAllocateHeap(RtlProcessHeap(),
                                    MAKE_TAG( TMP_TAG ),
                                    BufferSize);

        if (pszBuffer != NULL) {

            HMODULE hMod;

            BufferSize = BufferSize - TWAIN_DLL_SIZE + sizeof(char);

            StrLength = GetWindowsDirectoryA(pszBuffer, BufferSize);

            if ((StrLength != 0) && (StrLength < BufferSize)) {

                strncat(pszBuffer, SLASH_TWAIN_DLL,
                        TWAIN_DLL_SIZE - sizeof(char));

                hMod = LoadLibraryA(pszBuffer);

                if (hMod != NULL) {
                    RtlFreeHeap(RtlProcessHeap(), 0, pszBuffer);
                    return hMod;
                }
            }

            RtlFreeHeap(RtlProcessHeap(), 0, pszBuffer);
        }

#undef SLASH_TWAIN_DLL
#undef TWAIN_DLL_SIZE

    }


    return LoadLibraryExA( lpLibFileName,
                           NULL,
                           0 );
}

HMODULE
LoadLibraryW(
    LPCWSTR lpwLibFileName
    )
{
    return LoadLibraryExW( lpwLibFileName,
                           NULL,
                           0 );
}

BOOL
FreeLibrary(
    HMODULE hLibModule
    )

/*++

Routine Description:

    This function decreases the reference count of the loaded library
    module by one.  The reference count is maintain for each process.

    When the reference count for the specified library module is
    decremented to zero, the library module's DLL Instance Termination
    entry point is called.  This will allow a library module a chance to
    cleanup resources that we allocated on behalf of the current
    process.  See the Task Management section for a description of the
    DLL Instance Termination entry point.  Finally, after the
    termination entry point returns, the library module is removed from
    the address space of the current process.

    If more than one process has loaded a library module, then the
    library module will remain in use until all process's that loaded
    the module have called FreeLibrary to unload the library.

Arguments:

    hLibModule - Identifies the loaded library module.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using the GetLastError function.

--*/

{
    NTSTATUS Status;

    if (LDR_IS_DATAFILE(hLibModule)) {

        if (RtlImageNtHeader(LDR_DATAFILE_TO_VIEW(hLibModule))) {

            Status = NtUnmapViewOfSection( NtCurrentProcess(),
                                           LDR_DATAFILE_TO_VIEW(hLibModule)
                                         );
            LdrUnloadAlternateResourceModule(hLibModule);

        } else {
            Status = STATUS_INVALID_IMAGE_FORMAT;
        }
    } else {
        Status = LdrUnloadDll( (PVOID)hLibModule );
    }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    } else {
        return TRUE;
    }
}

VOID
WINAPI
FreeLibraryAndExitThread(
    HMODULE hLibModule,
    DWORD dwExitCode
    )

/*++

Routine Description:

    This function decreases the reference count of the loaded library
    module by one, and then calls ExitThread.

    The purpose of this function is to allow threads that are created
    within a dll, and execute within that DLL an opportunity to safely
    unload the DLL and to exit.

    When the reference count for the specified library module is
    decremented to zero, the library module's DLL Instance Termination
    entry point is called.  This will allow a library module a chance to
    cleanup resources that we allocated on behalf of the current
    process.  See the Task Management section for a description of the
    DLL Instance Termination entry point.  Finally, after the
    termination entry point returns, the library module is removed from
    the address space of the current process.

    If more than one process has loaded a library module, then the
    library module will remain in use until all process's that loaded
    the module have called FreeLibrary to unload the library.

Arguments:

    hLibModule - Identifies the loaded library module.

    dwExitCode - Supplies the exit code for the thread

Return Value:

    This function never returns. invalid hLibModule values are silently ignored

--*/

{
    if (LDR_IS_DATAFILE(hLibModule)) {
        if (RtlImageNtHeader(LDR_DATAFILE_TO_VIEW(hLibModule))) {

            NtUnmapViewOfSection( NtCurrentProcess(),
                                  LDR_DATAFILE_TO_VIEW(hLibModule) );

            LdrUnloadAlternateResourceModule(hLibModule);
        }
    } else {
        LdrUnloadDll( (PVOID)hLibModule );
    }

    ExitThread(dwExitCode);
}

BOOL
WINAPI
DisableThreadLibraryCalls(
    HMODULE hLibModule
    )

/*++

Routine Description:

    This function disables DLL_THREAD_ATTACH and DLL_THREAD_DETACH notifications
    for the DLL specified by hLibModule. Attempting to call this on a DLL with
    inuse static thread local storage is an error.

Arguments:

    hLibModule - Identifies the loaded library module.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using the GetLastError function.

--*/

{
    NTSTATUS Status;
    BOOL rv;

    rv = TRUE;
    Status = LdrDisableThreadCalloutsForDll(hLibModule);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        rv = FALSE;
    }
    return rv;
}

BOOL
WINAPI
SetDllDirectoryW(
    IN LPCWSTR lpPathName
    )

/*++

Routine Description:

    This function sets the effective current directory used
    for the LoadLibrary() dll search path.

Arguments:

    lpPathName - Specifies the directory to use.

                 If the directory is NULL, switch back to the default
                 dll search path behavior (in case a SetDllDirectory()
                 call was already in effect).

                 If the directory is the empty string, omit both the
                 dll directory and the current directory from the
                 search path.

                 Note that setting the directory to L"." has the
                 effect of reverting back to the original
                 LoadLibrary() path.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.  Extended error status is available
            via GetLastError().

Notes:

    Moving the current directory after the system directories (which
    we have to do for security considerations) breaks applications
    which depend on using { SetCurrentDirectory(); LoadLibrary(); } to
    pick up specific versions of libraries.

    We recognize that this solution is suboptimal, but we're stuck
    with the current LoadLibrary() API, which has been around for
    quite some time.  We did try changing it, but ran into serious
    application compatibility issues; moving the current directory
    later in the search path caused the least number of problems, and
    this API makes it easy for applications and application
    compatibility shims to get back the old behavior.

--*/

{
    UNICODE_STRING OldDllDirectory;
    UNICODE_STRING NewDllDirectory;
    
    if (lpPathName) {

        if (wcschr(lpPathName, L';')) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if (! RtlCreateUnicodeString(&NewDllDirectory, lpPathName)) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
    } else {
        RtlInitUnicodeString(&NewDllDirectory, NULL);
    }

    RtlEnterCriticalSection(&BaseDllDirectoryLock);

    OldDllDirectory = BaseDllDirectory;
    BaseDllDirectory = NewDllDirectory;

    RtlLeaveCriticalSection(&BaseDllDirectoryLock);

    RtlFreeUnicodeString(&OldDllDirectory);

    return TRUE;
}

BOOL
WINAPI
SetDllDirectoryA(
    IN LPCSTR lpPathName
    )

/*++

Routine Description:

    ANSI implementation of SetDllDirectoryW

--*/

{
    ANSI_STRING AnsiDllDirectory;
    UNICODE_STRING OldDllDirectory;
    UNICODE_STRING NewDllDirectory;
    NTSTATUS Status;
    
    if (lpPathName) {

        if (strchr(lpPathName, ';')) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        Status = RtlInitAnsiStringEx(&AnsiDllDirectory,
                                     lpPathName);
        if (! NT_SUCCESS(Status)) {
            BaseSetLastNTError(Status);
            return FALSE;
        }
        Status = Basep8BitStringToUnicodeString(&NewDllDirectory,
                                                &AnsiDllDirectory,
                                                TRUE);
        if (! NT_SUCCESS(Status)) {
            BaseSetLastNTError(Status);
            return FALSE;
        }
    } else {
        RtlInitUnicodeString(&NewDllDirectory, NULL);
    }

    RtlEnterCriticalSection(&BaseDllDirectoryLock);

    OldDllDirectory = BaseDllDirectory;
    BaseDllDirectory = NewDllDirectory;

    RtlLeaveCriticalSection(&BaseDllDirectoryLock);

    RtlFreeUnicodeString(&OldDllDirectory);

    return TRUE;
}

DWORD
WINAPI
GetDllDirectoryW(
    IN  DWORD  nBufferLength,
    OUT LPWSTR lpBuffer
    )

/*++

Routine Description:

    This function retrieves the effective current directory used for
    the LoadLibrary() dll search path.

Arguments:

    nBufferLength - Specifies the size of the output buffer.

    lpBuffer - The buffer where the current dll directory will be written.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than nBufferLength, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/

{
    DWORD Result;
    
    RtlEnterCriticalSection(&BaseDllDirectoryLock);

    if (nBufferLength * sizeof(WCHAR) <= BaseDllDirectory.Length) {
        Result = ((BaseDllDirectory.Length + sizeof(UNICODE_NULL))
                  / sizeof(WCHAR));
        if (lpBuffer) {
            lpBuffer[0] = UNICODE_NULL;
        }
    } else {
        RtlCopyMemory(lpBuffer,
                      BaseDllDirectory.Buffer,
                      BaseDllDirectory.Length);
        Result = BaseDllDirectory.Length / sizeof(WCHAR);
        lpBuffer[Result] = UNICODE_NULL;
    }

    RtlLeaveCriticalSection(&BaseDllDirectoryLock);

    return Result;
}

DWORD
WINAPI
GetDllDirectoryA(
    IN  DWORD  nBufferLength,
    OUT LPSTR lpBuffer
    )

/*++

Routine Description:

    ANSI implementation of GetDllDirectoryW

--*/

{
    ANSI_STRING Ansi;
    DWORD       Result;
    NTSTATUS    Status;

    RtlInitEmptyUnicodeString(&Ansi, lpBuffer, nBufferLength);

    RtlEnterCriticalSection(&BaseDllDirectoryLock);

    // Includes the NULL
    Result = BasepUnicodeStringTo8BitSize(&BaseDllDirectory);

    if (Result <= nBufferLength) {
        Status = BasepUnicodeStringTo8BitString(&Ansi,
                                                &BaseDllDirectory,
                                                FALSE);
        Result--; // trim off the space needed for the NULL
    } else {
        Status = STATUS_SUCCESS;
        if (lpBuffer) {
            lpBuffer[0] = ANSI_NULL;
        }
    }

    RtlLeaveCriticalSection(&BaseDllDirectoryLock);

    if (! NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        Result = 0;
        lpBuffer[0] = ANSI_NULL;
    }

    return Result;
}

DWORD
WINAPI
GetModuleFileNameW(
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    )

/*++

Routine Description:

    This function retrieves the full pathname of the executable file
    from which the specified module was loaded.  The function copies the
    null-terminated filename into the buffer pointed to by the
    lpFilename parameter.

Routine Description:

    hModule - Identifies the module whose executable file name is being
        requested.  A value of NULL references the module handle
        associated with the image file that was used to create the
        current process.

    lpFilename - Points to the buffer that is to receive the filename.

    nSize - Specifies the maximum number of characters to copy.  If the
        filename is longer than the maximum number of characters
        specified by the nSize parameter, it is truncated.

Return Value:

    The return value specifies the actual length of the string copied to
    the buffer.  A return value of zero indicates an error and extended
    error status is available using the GetLastError function.

Arguments:

--*/

{
    PLDR_DATA_TABLE_ENTRY Entry;
    PLIST_ENTRY Head,Next;
    DWORD ReturnLength, CopySize;
    PWCHAR ReturnPointer;
    PVOID DllHandle = BasepMapModuleHandle( hModule, FALSE );
    PUNICODE_STRING Ustr;
    PVOID LoaderLockCookie = NULL;
    PRTL_PERTHREAD_CURDIR CurDir;
    BOOLEAN LoaderLocked;

    ReturnLength = 0;
    ReturnPointer = NULL;
    LoaderLocked = FALSE;


    try {
        //
        // If we are looking at the current image, then check for name
        // redirection
        //

        if (!ARGUMENT_PRESENT (hModule)) {
            CurDir = RtlGetPerThreadCurdir ();

            if (CurDir && CurDir->ImageName) {
                Ustr = CurDir->ImageName;

                ReturnPointer = Ustr->Buffer;
                ReturnLength = Ustr->Length / sizeof (WCHAR);

                goto copy_back;
            }
        }


        Head = &NtCurrentPeb ()->Ldr->InLoadOrderModuleList;

        LoaderLocked = TRUE;

        LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, NULL, &LoaderLockCookie);

        Next = Head->Flink;

        while (Next != Head) {
            Entry = CONTAINING_RECORD (Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
            if (DllHandle == (PVOID)Entry->DllBase) {
                ReturnLength = Entry->FullDllName.Length / sizeof (WCHAR);
                ReturnPointer = Entry->FullDllName.Buffer;
                goto copy_back;
            }
            Next = Next->Flink;
        }

        leave;

copy_back:;

        CopySize = ReturnLength;
        if (nSize < ReturnLength + 1) {
            ReturnLength = nSize;
            CopySize = nSize - 1;
            SetLastError (ERROR_INSUFFICIENT_BUFFER);
        } else {
            SetLastError (NO_ERROR);
        }

        if (nSize > 0) {
            RtlCopyMemory (lpFilename,
                           ReturnPointer,
                           CopySize * sizeof (WCHAR));

            lpFilename[CopySize] = UNICODE_NULL;
        }

    } finally {
        if (LoaderLocked) {
            LdrUnlockLoaderLock (LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LoaderLockCookie);
        }
    }
    return ReturnLength;
}

DWORD
GetModuleFileNameA(
    HMODULE hModule,
    LPSTR lpFilename,
    DWORD nSize
    )
{
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    DWORD ReturnCode;

    UnicodeString.Buffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), nSize*2);
    if ( !UnicodeString.Buffer ) {
        BaseSetLastNTError( STATUS_NO_MEMORY );
        return 0;
    }
    ReturnCode = GetModuleFileNameW(hModule, UnicodeString.Buffer, nSize);
    UnicodeString.Length = UnicodeString.MaximumLength = (USHORT)ReturnCode*2;
    UnicodeString.MaximumLength++;
    UnicodeString.MaximumLength++;

    if (ReturnCode) {
        Status = BasepUnicodeStringTo8BitString(&AnsiString, &UnicodeString, TRUE);
        if (!NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            RtlFreeUnicodeString(&UnicodeString);
            return 0;
        }

        ReturnCode = min( nSize, AnsiString.Length );

        RtlCopyMemory(
            lpFilename,
            AnsiString.Buffer,
            nSize <= ReturnCode ? nSize : ReturnCode + 1
            );

        RtlFreeAnsiString(&AnsiString);
    }

    RtlFreeUnicodeString(&UnicodeString);
    return ReturnCode;
}

HMODULE
GetModuleHandleA(
    LPCSTR lpModuleName
    )

/*++

Routine Description:

    ANSI thunk to GetModuleHandleW

--*/

{
    PUNICODE_STRING Unicode;

    if ( !ARGUMENT_PRESENT(lpModuleName) ) {
        return( (HMODULE)(PVOID)NtCurrentPeb()->ImageBaseAddress );
    }

    Unicode = Basep8BitStringToStaticUnicodeString( lpModuleName );
    if (Unicode == NULL) {
        return NULL;
    }

    return GetModuleHandleW(Unicode->Buffer);
}

HMODULE
WINAPI
GetModuleHandleForUnicodeString(
    IN PUNICODE_STRING ModuleName
    )
/*++

Routine Description:

    This function is the helper routine for GetModuleHandleW. See that for
    more details on return value, etc.

Arguments:

    ModuleName - Points to counted unicode string that names the library file.
        Caller guarantees that ModuleName->Buffer is not NULL.

Return Value:

    See GetModuleHandleW for this.

--*/

{
    LPWSTR AllocatedPath;
    NTSTATUS Status;
    HMODULE hModule;
#ifdef WX86
    BOOLEAN Wx86KnownDll;
#endif

#ifdef WX86
    // LdrGetDllHandle clears UseKnownWx86Dll, but the value is needed again
    // for the second LdrGetDllHandle call.
    Wx86KnownDll = NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll;
#endif
    Status = LdrGetDllHandle(
                (PWSTR)1,
                NULL,
                ModuleName,
                (PVOID *)&hModule
                );
    if ( NT_SUCCESS(Status) ) {
        return hModule;
    }

    //
    // Determine the path that the program was created from
    //

    AllocatedPath = BaseComputeProcessDllPath(NULL,
                                              NULL);
    if (!AllocatedPath) {
        Status = STATUS_NO_MEMORY;
        goto bail;
    }
#ifdef WX86
    NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = Wx86KnownDll;
#endif

    try {

        Status = LdrGetDllHandle(
                    AllocatedPath,
                    NULL,
                    ModuleName,
                    (PVOID *)&hModule
                    );
        RtlFreeHeap(RtlProcessHeap(), 0, AllocatedPath);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        RtlFreeHeap(RtlProcessHeap(), 0, AllocatedPath);
    }

bail:
    if (!NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
    } else {
        return hModule;
    }
}

HMODULE
WINAPI
GetModuleHandleW(
    LPCWSTR lpwModuleName
    )
/*++

Routine Description:

    This function returns the handle of a module that is loaded into the
    context of the calling process.

    In a multi-thread environment, this function is not reliable, since
    while one thread is calling this function and getting back a module
    handle, another thread in the same process could be calling
    FreeLibrary for the same module, therefore invalidating the returned
    module handle for the first thread.

Arguments:

    lpwModuleName - Points to a string that names the library file.  The
    string must be a null-terminated unicode string.  If this
        parameter is NULL, then the handle for the current image file is
        returned.

Return Value:

    The return value is a module handle.  A return value of NULL
    indicates either that the module has not been loaded into the
    context of the current process or an error occured.  The exact
    reason is available using the GetLastError function.

--*/
{
    HMODULE hModule;
    BOOL    fSuccess;

    if (!ARGUMENT_PRESENT(lpwModuleName)) {
        return( (HMODULE)(PVOID)NtCurrentPeb()->ImageBaseAddress );
    }

    fSuccess =
        BasepGetModuleHandleExW(
            BASEP_GET_MODULE_HANDLE_EX_NO_LOCK,
            GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
            lpwModuleName,
            &hModule
            );
    return fSuccess ? hModule : NULL;
}

ULONG
WINAPI
BasepGetModuleHandleExParameterValidation(
    IN DWORD        dwFlags,
    IN CONST VOID*  lpModuleName,
    OUT HMODULE*    phModule
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (phModule != NULL)
        *phModule = NULL;

    if ((dwFlags & ~(
              GET_MODULE_HANDLE_EX_FLAG_PIN
            | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT
            | GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS
            )) != 0) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Error;
    }
    if ((dwFlags & GET_MODULE_HANDLE_EX_FLAG_PIN) != 0
            && (dwFlags & GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT) != 0
            ) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Error;
    }
    if (!ARGUMENT_PRESENT(lpModuleName)
            && (dwFlags & GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS) != 0
            ) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Error;
    }
    if (phModule == NULL) {
        Status = STATUS_INVALID_PARAMETER_2;
        goto Error;
    }

    if (!ARGUMENT_PRESENT(lpModuleName)) {
        *phModule = ( (HMODULE)(PVOID)NtCurrentPeb()->ImageBaseAddress );
        goto Success;
    }
    goto Continue;
Error:
    BaseSetLastNTError(Status);
    return BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_ERROR;
Success:
    return BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_SUCCESS;
Continue:
    return BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_CONTINUE;
}

BOOL
GetModuleHandleExA(
    IN DWORD        dwFlags,
    IN LPCSTR       lpaModuleName,
    OUT HMODULE*    phModule
    )
/*++

Routine Description:

    ANSI thunk to GetModuleHandleExW

--*/

{
    PUNICODE_STRING Unicode;
    ULONG Disposition;
    LPCWSTR lpwModuleName;
    BOOL    fSuccess = FALSE;

    Disposition = BasepGetModuleHandleExParameterValidation(dwFlags, lpaModuleName, phModule);
    switch (Disposition)
    {
    case BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_ERROR:
        goto Exit;
    case BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_SUCCESS:
        fSuccess = TRUE;
        goto Exit;
    case BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_CONTINUE:
        break;
    }

    if ((dwFlags & GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS) == 0) {
        Unicode = Basep8BitStringToStaticUnicodeString(lpaModuleName);
        if (Unicode == NULL) {
            goto Exit;
        }
        lpwModuleName = Unicode->Buffer;
    } else {
        lpwModuleName = (LPCWSTR)(CONST VOID*)lpaModuleName;
    }

    if (!BasepGetModuleHandleExW(0, dwFlags, lpwModuleName, phModule))
        goto Exit;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
WINAPI
GetModuleHandleExW(
    IN DWORD        dwFlags,
    IN LPCWSTR      lpwModuleName,
    OUT HMODULE*    phModule
    )
{
    ULONG Disposition;
    BOOL   fSuccess = FALSE;

    Disposition = BasepGetModuleHandleExParameterValidation(dwFlags, lpwModuleName, phModule);
    switch (Disposition)
    {
    case BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_ERROR:
        goto Exit;
    case BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_SUCCESS:
        fSuccess = TRUE;
        goto Exit;
    case BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_CONTINUE:
        break;
    }
    if (!BasepGetModuleHandleExW(0, dwFlags, lpwModuleName, phModule))
        goto Exit;
    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
WINAPI
BasepGetModuleHandleExW(
    IN DWORD        dwPrivateFlags,
    IN DWORD        dwPublicFlags,
    IN LPCWSTR      lpwModuleName,
    OUT HMODULE*    phModule
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    HMODULE hModule = NULL;
    UNICODE_STRING DllName_U, AppPathDllName_U, LocalDirDllName_U;
    BOOL DoDllRedirection = FALSE;
    WCHAR DllNameUnderImageDirBuffer[MAX_PATH];
    WCHAR DllNameUnderLocalDirBuffer[MAX_PATH];
    BOOL HoldingLoaderLock = FALSE;
    ULONG LdrFlags;
    PVOID LdrLockCookie = NULL;

    RTL_SOFT_ASSERT(BasepGetModuleHandleExParameterValidation(dwPublicFlags, lpwModuleName, phModule) == BASEP_GET_MODULE_HANDLE_EX_PARAMETER_VALIDATION_CONTINUE);

    AppPathDllName_U.Buffer = DllNameUnderImageDirBuffer;
    AppPathDllName_U.Length = 0 ;
    AppPathDllName_U.MaximumLength = sizeof(DllNameUnderImageDirBuffer);

    LocalDirDllName_U.Buffer = DllNameUnderLocalDirBuffer;
    LocalDirDllName_U.Length = 0 ;
    LocalDirDllName_U.MaximumLength = sizeof(DllNameUnderLocalDirBuffer);

    if ((dwPrivateFlags & BASEP_GET_MODULE_HANDLE_EX_NO_LOCK) == 0) {
        Status = LdrLockLoaderLock(0, NULL, &LdrLockCookie);
        if (!NT_SUCCESS(Status))
            goto Exit;
        HoldingLoaderLock = TRUE;
    }
    __try {
        if (dwPublicFlags & GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS) {
            hModule = RtlPcToFileHeader((PVOID)lpwModuleName, (PVOID*)&hModule);
            if (hModule == NULL) {
                Status = STATUS_DLL_NOT_FOUND;
                __leave;
            }
        } else {
            RtlInitUnicodeString(&DllName_U, lpwModuleName);

            if ((NtCurrentPeb()->ProcessParameters != NULL) &&
                (NtCurrentPeb()->ProcessParameters->Flags & RTL_USER_PROC_DLL_REDIRECTION_LOCAL))
               DoDllRedirection = TRUE;

            if (DoDllRedirection) {
                Status = RtlComputePrivatizedDllName_U(&DllName_U, &AppPathDllName_U, &LocalDirDllName_U);
                if(!NT_SUCCESS(Status)) {
                    __leave;
                }

                hModule = GetModuleHandleForUnicodeString(&LocalDirDllName_U) ;
                if (!hModule )
                    hModule = GetModuleHandleForUnicodeString(&AppPathDllName_U) ;
                // Didn't find any re-directed DLL with this name loaded. Now we can just check for the
                // original name passed in.
            }
            if ( ! hModule)
                hModule = GetModuleHandleForUnicodeString(&DllName_U) ;
            if (hModule == NULL) {
                Status = NtCurrentTeb()->LastStatusValue;
                __leave;
            }
        }
        if (dwPublicFlags & GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT) {
            Status = STATUS_SUCCESS;
            __leave;
        }
        LdrFlags = (dwPublicFlags & GET_MODULE_HANDLE_EX_FLAG_PIN) ? LDR_ADDREF_DLL_PIN : 0;
        Status = LdrAddRefDll(LdrFlags, (PVOID)hModule);
    } __finally {
        if (HoldingLoaderLock) {
            NTSTATUS Status2 = LdrUnlockLoaderLock(0, LdrLockCookie);
            ASSERT(NT_SUCCESS(Status2));
            HoldingLoaderLock = FALSE;
        }
    }

Exit : // cleanup
    if (AppPathDllName_U.Buffer != DllNameUnderImageDirBuffer)
        RtlFreeUnicodeString(&AppPathDllName_U);

    if (LocalDirDllName_U.Buffer != DllNameUnderLocalDirBuffer)
        RtlFreeUnicodeString(&LocalDirDllName_U);
    if (!NT_SUCCESS(Status))
        BaseSetLastNTError(Status);

    if (phModule != NULL)
        *phModule = hModule;

    return NT_SUCCESS(Status);
}

FARPROC
GetProcAddress(
    HMODULE hModule,
    LPCSTR lpProcName
    )

/*++

Routine Description:

    This function retrieves the memory address of the function whose
    name is pointed to by the lpProcName parameter.  The GetProcAddress
    function searches for the function in the module specified by the
    hModule parameter, or in the module associated with the current
    process if hModule is NULL.  The function must be an exported
    function; the module's definition file must contain an appropriate
    EXPORTS line for the function.

    If the lpProcName parameter is an ordinal value and a function with
    the specified ordinal does not exist in the module, GetProcAddress
    can still return a non-NULL value.  In cases where the function may
    not exist, specify the function by name rather than ordinal value.

    Only use GetProcAddress to retrieve addresses of exported functions
    that belong to library modules.

    The spelling of the function name (pointed to by lpProcName) must be
    identical to the spelling as it appears in the source library's
    definition (.DEF) file.  The function can be renamed in the
    definition file.  Case sensitive matching is used???

Arguments:

    hModule - Identifies the module whose executable file contains the
        function.  A value of NULL references the module handle
        associated with the image file that was used to create the
        current process.


    lpProcName - Points to the function name, or contains the ordinal
        value of the function.  If it is an ordinal value, the value
        must be in the low-order word and zero must be in the high-order
        word.  The string must be a null-terminated character string.

Return Value:

    The return value points to the function's entry point if the
    function is successful.  A return value of NULL indicates an error
    and extended error status is available using the GetLastError function.


--*/

{
    NTSTATUS Status;
    PVOID ProcedureAddress;
    STRING ProcedureName;

    if ( (ULONG_PTR)lpProcName > 0xffff ) {
        RtlInitString(&ProcedureName,lpProcName);
        Status = LdrGetProcedureAddress(
                        BasepMapModuleHandle( hModule, FALSE ),
                        &ProcedureName,
                        0L,
                        &ProcedureAddress
                        );
    } else {
        Status = LdrGetProcedureAddress(
                        BasepMapModuleHandle( hModule, FALSE ),
                        NULL,
                        PtrToUlong((PVOID)lpProcName),
                        &ProcedureAddress
                        );
    }
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
    } else {
        if ( ProcedureAddress == BasepMapModuleHandle( hModule, FALSE ) ) {
            if ( (ULONG_PTR)lpProcName > 0xffff ) {
                Status = STATUS_ENTRYPOINT_NOT_FOUND;
            } else {
                Status = STATUS_ORDINAL_NOT_FOUND;
            }
            BaseSetLastNTError(Status);
            return NULL;
        } else {
            return (FARPROC)ProcedureAddress;
        }
    }
}

DWORD
GetVersion(
    VOID
    )

/*++

Routine Description:

    This function returns the current version number of Windows.

Arguments:

    None.

Return Value:

    The return value specifies the major and minor version numbers of
    Windows.  The high-order word specifies the minor version (revision)
    number; the low-order word specifies the major version number.

--*/

{
    PPEB Peb;

    Peb = NtCurrentPeb();

    return (((Peb->OSPlatformId ^ 0x2) << 30) |
            (Peb->OSBuildNumber << 16) |
            (Peb->OSMinorVersion << 8) |
             Peb->OSMajorVersion
           );
}

WINBASEAPI
BOOL
WINAPI
GetVersionExA(
    LPOSVERSIONINFOA lpVersionInformation
    )
{
    OSVERSIONINFOEXW VersionInformationU;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;

    if (lpVersionInformation->dwOSVersionInfoSize != sizeof( OSVERSIONINFOEXA ) &&
        lpVersionInformation->dwOSVersionInfoSize != sizeof( *lpVersionInformation )
       ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    VersionInformationU.dwOSVersionInfoSize = sizeof( VersionInformationU );
    if (GetVersionExW( (LPOSVERSIONINFOW)&VersionInformationU )) {
        lpVersionInformation->dwMajorVersion = VersionInformationU.dwMajorVersion;
        lpVersionInformation->dwMinorVersion = VersionInformationU.dwMinorVersion;
        lpVersionInformation->dwBuildNumber  = VersionInformationU.dwBuildNumber;
        lpVersionInformation->dwPlatformId   = VersionInformationU.dwPlatformId;
        if (lpVersionInformation->dwOSVersionInfoSize == sizeof( OSVERSIONINFOEXA )) {
            ((POSVERSIONINFOEXA)lpVersionInformation)->wServicePackMajor = VersionInformationU.wServicePackMajor;
            ((POSVERSIONINFOEXA)lpVersionInformation)->wServicePackMinor = VersionInformationU.wServicePackMinor;
            ((POSVERSIONINFOEXA)lpVersionInformation)->wSuiteMask = VersionInformationU.wSuiteMask;
            ((POSVERSIONINFOEXA)lpVersionInformation)->wProductType = VersionInformationU.wProductType;
            ((POSVERSIONINFOEXA)lpVersionInformation)->wReserved = VersionInformationU.wReserved;
        }

        AnsiString.Buffer = lpVersionInformation->szCSDVersion;
        AnsiString.Length = 0;
        AnsiString.MaximumLength = sizeof( lpVersionInformation->szCSDVersion );

        RtlInitUnicodeString( &UnicodeString, VersionInformationU.szCSDVersion );
        Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                               &UnicodeString,
                                               FALSE
                                             );
        if (NT_SUCCESS( Status )) {
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        return FALSE;
    }
}

WINBASEAPI
BOOL
WINAPI
GetVersionExW(
    LPOSVERSIONINFOW lpVersionInformation
    )
{
    PPEB Peb;
    NTSTATUS Status;

    if (lpVersionInformation->dwOSVersionInfoSize != sizeof( OSVERSIONINFOEXW ) &&
        lpVersionInformation->dwOSVersionInfoSize != sizeof( *lpVersionInformation )
       ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }
    Status = RtlGetVersion(lpVersionInformation);
    if (Status == STATUS_SUCCESS) {
        if (lpVersionInformation->dwOSVersionInfoSize ==
                                            sizeof( OSVERSIONINFOEXW))
            ((POSVERSIONINFOEXW)lpVersionInformation)->wReserved =
                                        (UCHAR)BaseRCNumber;
        return TRUE;
    } else {
        return FALSE;
    }
}


WINBASEAPI
BOOL
WINAPI
VerifyVersionInfoW(
    IN LPOSVERSIONINFOEXW VersionInfo,
    IN DWORD TypeMask,
    IN DWORDLONG ConditionMask
    )

/*++

Routine Description:

    This function verifies a version condition.  Basically, this
    function lets an app query the system to see if the app is
    running on a specific version combination.


Arguments:

    VersionInfo     - a version structure containing the comparison data
    TypeMask        - a mask comtaining the data types to look at
    ConditionMask   - a mask containing conditionals for doing the comparisons


Return Value:

    TRUE  - the version condition exists
    FALSE - the version condition does NOT exists

--*/

{
    DWORD i;
    OSVERSIONINFOEXW CurrVersion;
    BOOL SuiteFound = FALSE;
    NTSTATUS Status;


    Status = RtlVerifyVersionInfo(VersionInfo, TypeMask, ConditionMask);
    if (Status == STATUS_INVALID_PARAMETER) {
        SetLastError( ERROR_BAD_ARGUMENTS );
        return FALSE;
    } else if (Status == STATUS_REVISION_MISMATCH) {
        SetLastError(ERROR_OLD_WIN_VERSION);
        return FALSE;
    }

    return TRUE;
}

WINBASEAPI
BOOL
WINAPI
VerifyVersionInfoA(
    IN LPOSVERSIONINFOEXA VersionInfo,
    IN DWORD TypeMask,
    IN DWORDLONG ConditionMask
    )

/*++

Routine Description:

    This function verifies a version condition.  Basically, this
    function lets an app query the system to see if the app is
    running on a specific version combination.


Arguments:

    VersionInfo     - a version structure containing the comparison data
    TypeMask        - a mask comtaining the data types to look at
    ConditionMask   - a mask containing conditionals for doing the comparisons


Return Value:

    TRUE  - the version condition exists
    FALSE - the version condition does NOT exists

--*/

{
    OSVERSIONINFOEXW VersionInfoW;


    VersionInfoW.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);

    VersionInfoW.dwMajorVersion      = VersionInfo->dwMajorVersion;
    VersionInfoW.dwMinorVersion      = VersionInfo->dwMinorVersion;
    VersionInfoW.dwBuildNumber       = VersionInfo->dwBuildNumber;
    VersionInfoW.dwPlatformId        = VersionInfo->dwPlatformId;
    VersionInfoW.wServicePackMajor   = VersionInfo->wServicePackMajor;
    VersionInfoW.wServicePackMinor   = VersionInfo->wServicePackMinor;
    VersionInfoW.wSuiteMask          = VersionInfo->wSuiteMask;
    VersionInfoW.wProductType        = VersionInfo->wProductType;
    VersionInfoW.wReserved           = VersionInfo->wReserved;

    return VerifyVersionInfoW( &VersionInfoW, TypeMask, ConditionMask );
}

HRSRC
FindResourceA(
    HMODULE hModule,
    LPCSTR lpName,
    LPCSTR lpType
    )

/*++

Routine Description:

    This function determines the location of a resource in the specified
    resource file.  The lpName and lpType parameters define the resource
    name and type, respectively.

    If the high-order word of the lpName or lpType parameter is zero,
    the low-order word specifies the integer ID of the name or type of
    the given resource.  Otherwise, the parameters are pointers to
    null-terminated character strings.  If the first character of the
    string is a pound sign (#), the remaining characters represent a
    decimal number that specifies the integer ID of the resource's name
    or type.  For example, the string "#258" represents the integer ID
    258.

    To reduce the amount of memory required for the resources used by an
    application, applications should refer to their resources by integer
    ID instead of by name.

    An application must not call FindResource and the LoadResource
    function to load cursor, icon, or string resources.  Instead, it
    must load these resources by calling the following functions:

      - LoadCursor

      - LoadIcon

      - LoadString

    An application can call FindResource and LoadResource to load other
    predefined resource types.  However, it is recommended that the
    application load the corresponding resources by calling the
    following functions:

      - LoadAccelerators

      - LoadBitmap

      - LoadMenu

    The above six API calls are documented with the Graphical User
    Interface API specification.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource.  A value of NULL references the module handle
        associated with the image file that was used to create the
        current process.

    lpName - Points to a null-terminated character string that
        represents the name of the resource.

    lpType - Points to a null-terminated character string that
        represents the type name of the resource.  For predefined
        resource types, the lpType parameter should be one of the
        following values:

        RT_ACCELERATOR - Accelerator table

        RT_BITMAP - Bitmap resource

        RT_DIALOG - Dialog box

        RT_FONT - Font resource

        RT_FONTDIR - Font directory resource

        RT_MENU - Menu resource

        RT_RCDATA - User-defined resource (raw data)

Return Value:

    The return value identifies the named resource.  It is NULL if the
    requested resource cannot be found.

--*/


{
    NTSTATUS Status;
    ULONG_PTR IdPath[ 3 ];
    PVOID p;

    IdPath[ 0 ] = 0;
    IdPath[ 1 ] = 0;
    try {
        if ((IdPath[ 0 ] = BaseDllMapResourceIdA( lpType )) == -1) {
            Status = STATUS_INVALID_PARAMETER;
        } else
        if ((IdPath[ 1 ] = BaseDllMapResourceIdA( lpName )) == -1) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            IdPath[ 2 ] = 0;
            p = NULL;
            Status = LdrFindResource_U( BasepMapModuleHandle( hModule, TRUE ),
                                        IdPath,
                                        3,
                                        (PIMAGE_RESOURCE_DATA_ENTRY *)&p
                                      );
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    //
    // Free any strings allocated by BaseDllMapResourceIdA
    //
    BaseDllFreeResourceId( IdPath[ 0 ] );
    BaseDllFreeResourceId( IdPath[ 1 ] );

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( NULL );
    } else {
        return( (HRSRC)p );
    }
}

HRSRC
FindResourceExA(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    WORD  wLanguage
    )

/*++

Routine Description:

    This function determines the location of a resource in the specified
    resource file.  The lpType, lpName and wLanguage parameters define
    the resource type, name and language respectively.

    If the high-order word of the lpType or lpName parameter
    is zero, the low-order word specifies the integer ID of the type, name
    or language of the given resource.  Otherwise, the parameters are pointers
    to null-terminated character strings.  If the first character of the
    string is a pound sign (#), the remaining characters represent a
    decimal number that specifies the integer ID of the resource's name
    or type.  For example, the string "#258" represents the integer ID
    258.

    If the wLanguage parameter is zero, then the current language
    associated with the calling thread will be used.

    To reduce the amount of memory required for the resources used by an
    application, applications should refer to their resources by integer
    ID instead of by name.

    An application must not call FindResource and the LoadResource
    function to load cursor, icon, or string resources.  Instead, it
    must load these resources by calling the following functions:

      - LoadCursor

      - LoadIcon

      - LoadString

    An application can call FindResource and LoadResource to load other
    predefined resource types.  However, it is recommended that the
    application load the corresponding resources by calling the
    following functions:

      - LoadAccelerators

      - LoadBitmap

      - LoadMenu

    The above six API calls are documented with the Graphical User
    Interface API specification.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource.  A value of NULL references the module handle
        associated with the image file that was used to create the
        current process.

    lpType - Points to a null-terminated character string that
        represents the type name of the resource.  For predefined
        resource types, the lpType parameter should be one of the
        following values:

        RT_ACCELERATOR - Accelerator table

        RT_BITMAP - Bitmap resource

        RT_DIALOG - Dialog box

        RT_FONT - Font resource

        RT_FONTDIR - Font directory resource

        RT_MENU - Menu resource

        RT_RCDATA - User-defined resource (raw data)

    lpName - Points to a null-terminated character string that
        represents the name of the resource.

    wLanguage -  represents the language of the resource.  If this parameter
        is zero then the current language associated with the calling
        thread is used.

Return Value:

    The return value identifies the named resource.  It is NULL if the
    requested resource cannot be found.

--*/


{
    NTSTATUS Status;
    ULONG_PTR IdPath[ 3 ];
    PVOID p;

    IdPath[ 0 ] = 0;
    IdPath[ 1 ] = 0;
    try {
        if ((IdPath[ 0 ] = BaseDllMapResourceIdA( lpType )) == -1) {
            Status = STATUS_INVALID_PARAMETER;
        } else if ((IdPath[ 1 ] = BaseDllMapResourceIdA( lpName )) == -1) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            IdPath[ 2 ] = (ULONG_PTR)wLanguage;
            p = NULL;
            Status = LdrFindResource_U( BasepMapModuleHandle( hModule, TRUE ),
                                        IdPath,
                                        3,
                                        (PIMAGE_RESOURCE_DATA_ENTRY *)&p
                                      );
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    //
    // Free any strings allocated by BaseDllMapResourceIdA
    //
    BaseDllFreeResourceId( IdPath[ 0 ] );
    BaseDllFreeResourceId( IdPath[ 1 ] );

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( NULL );
    } else {
        return( (HRSRC)p );
    }
}

HGLOBAL
LoadResource(
    HMODULE hModule,
    HRSRC hResInfo
    )

/*++

Routine Description:

    This function loads a resource identified by the hResInfo parameter
    from the executable file associated with the module specified by the
    hModule parameter.  The function loads the resource into memory only
    if it has not been previously loaded.  Otherwise, it retrieves a
    handle to the existing resource.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource.  A value of NULL references the module handle
        associated with the image file that was used to create the
        current process.

    hResInfo - Identifies the desired resource.  This handle is assumed
        to have been returned by the FindResource function.

Return Value:

    The return value identifies the global memory block that contains
    the data associated with the resource.  It is NULL if no such
    resource exists.

--*/

{
    NTSTATUS Status;
    PVOID p;

    try {
        Status = LdrAccessResource( BasepMapModuleHandle( hModule, TRUE ),
                                    (PIMAGE_RESOURCE_DATA_ENTRY)hResInfo,
                                    &p,
                                    (PULONG)NULL
                                  );
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( NULL );
    } else {
        return( (HGLOBAL)p );
    }
}

DWORD
SizeofResource(
    HMODULE hModule,
    HRSRC hResInfo
    )

/*++

Routine Description:

    This function supplies the size (in bytes) of the specified
    resource.

    The value returned may be larger than the actual resource due to
    alignment.  An application should not rely upon this value for the
    exact size of a resource.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource.  A value of NULL references the module handle
        associated with the image file that was used to create the
        current process.

    hResInfo - Identifies the desired resource.  This handle is assumed
        to have been returned by the FindResource function.

Return Value:

    The return value specifies the number of bytes in the resource.  It
    is zero if the resource cannot be found.

--*/

{
    NTSTATUS Status;
    ULONG cb;

    try {
        Status = LdrAccessResource( BasepMapModuleHandle( hModule, TRUE ),
                                    (PIMAGE_RESOURCE_DATA_ENTRY)hResInfo,
                                    (PVOID *)NULL,
                                    &cb
                                  );
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( 0 );
    } else {
        return( (DWORD)cb );
    }
}

#ifdef _X86_
BOOL
__stdcall
_ResourceCallEnumTypeRoutine(
    ENUMRESTYPEPROCA EnumProc,
    HMODULE hModule,
    LPSTR lpType,
    LONG lParam);
#else
#define _ResourceCallEnumTypeRoutine( EnumProc, hModule, lpType, lParam ) \
    (*EnumProc)(hModule, lpType, lParam)
#endif


BOOL
WINAPI
EnumResourceTypesA(
    HMODULE hModule,
    ENUMRESTYPEPROCA lpEnumFunc,
    LONG_PTR lParam
    )

/*++

Routine Description:

    This function enumerates all of the resource type names contained in
    a module.  It enumerates them by passing each type name to the callback
    function pointed to by the lpEnumFunc parameter.

    The EnumResourceTypes function continues to enumerate type names until
    called function returns FALSE or the last type name in the module has
    been enumerated.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource type names to be enumerated.  A value of NULL
        references the module handle associated with the image file that
        was used to create the current process.

    lpEnumFunc - Points to the callback function that will be called
        for each enumerated resource type name.

    lParam - Specifies the value to be passed to the callback function
        for the application's use.

Return Value:

    TRUE - All resource type names were enumerated.

    FALSE/NULL - The enumeration was terminated before all resource type
        names were enumerated.

Callback Function:

    BOOL
    EnumFunc(
        HMODULE hModule,
        LPSTR lpType,
        LONG lParam
        );

    Routine Description:

        EnumFunc is a placeholder for the application-supplied function name.

    Arguments:

        hModule - Identifies the module whose executable file contains the
            resource type names to be enumerated.  A value of NULL
            references the module handle associated with the image file that
            was used to create the current process.

        lpType - Points to a null-terminated character string that
            represents the type name of the resource.  For predefined
            resource types, the lpType parameter will be one of the
            following values:

            RT_ACCELERATOR - Accelerator table

            RT_BITMAP - Bitmap resource

            RT_DIALOG - Dialog box

            RT_FONT - Font resource

            RT_FONTDIR - Font directory resource

            RT_MENU - Menu resource

            RT_RCDATA - User-defined resource (raw data)

            RT_STRING - String table

            RT_MESSAGETABLE - Message table

            RT_CURSOR - Hardware dependent cursor resource

            RT_GROUP_CURSOR - Directory of cursor resources

            RT_ICON - Hardware dependent cursor resource

            RT_GROUP_ICON - Directory of icon resources

        lParam - Specifies the 32-bit arugment of the EnumResourceTypes
            function.

    Return Value:

        TRUE - Continue the enumeration.

        FALSE/NULL - Stop enumerating resource type names.

--*/

{
    BOOL Result;
    NTSTATUS Status;
    ULONG i;
    HANDLE DllHandle;
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory, TopResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirectoryEntry;
    PIMAGE_RESOURCE_DIR_STRING_U ResourceNameString;
    LPSTR lpType;
    LPSTR Buffer;
    ULONG BufferLength;
    ULONG Length;

    DllHandle = BasepMapModuleHandle( hModule, TRUE );
    TopResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
        RtlImageDirectoryEntryToData( (PVOID)DllHandle,
                                      TRUE,
                                      IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                      &i
                                     );
    if (!TopResourceDirectory) {
        BaseSetLastNTError( STATUS_RESOURCE_DATA_NOT_FOUND );
        return FALSE;
    }

    Status = LdrFindResourceDirectory_U( (PVOID)DllHandle,
                                         NULL,
                                         0,
                                         &ResourceDirectory
                                       );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return FALSE;
    }

    Buffer = NULL;
    BufferLength = 0;
    Result = TRUE;
    try {
        ResourceDirectoryEntry =
            (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(ResourceDirectory+1);
        for (i=0; i<ResourceDirectory->NumberOfNamedEntries; i++) {
            ResourceNameString = (PIMAGE_RESOURCE_DIR_STRING_U)
                ((PCHAR)TopResourceDirectory + ResourceDirectoryEntry->NameOffset);
            if ((ULONG)(ResourceNameString->Length+1) >= BufferLength) {
                if (Buffer) {
                    RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
                    Buffer = NULL;
                }

                BufferLength = ((ResourceNameString->Length + 64) & ~63) * sizeof(WCHAR);
                Buffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), BufferLength );
                if (! Buffer) {
                    /* Status will be set by RtlAllocateHeap */
                    Result = FALSE;
                    break;
                }
            }

            Status = RtlUnicodeToMultiByteN( Buffer,
                                             BufferLength - 1,
                                             &Length,
                                             ResourceNameString->NameString,
                                             ResourceNameString->Length * sizeof( WCHAR )
                                           );

            if (!NT_SUCCESS( Status )) {
                BaseSetLastNTError( Status );
                Result = FALSE;
                break;
            }

            Buffer[ Length ] = '\0';

            if (!_ResourceCallEnumTypeRoutine(lpEnumFunc, hModule, (LPSTR)Buffer, lParam )) {
                Result = FALSE;
                break;
            }

            ResourceDirectoryEntry++;
        }

        if (Result) {
            for (i=0; i<ResourceDirectory->NumberOfIdEntries; i++) {
                lpType = (LPSTR)ResourceDirectoryEntry->Id;
                if (!_ResourceCallEnumTypeRoutine(lpEnumFunc, hModule, lpType, lParam )) {
                    Result = FALSE;
                    break;
                }

                ResourceDirectoryEntry++;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    if (Buffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
    }

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    } else {
        return Result;
    }
}


#ifdef _X86_
BOOL
__stdcall
_ResourceCallEnumNameRoutine(
    ENUMRESNAMEPROCA EnumProc,
    HMODULE hModule,
    LPCSTR lpType,
    LPSTR lpName,
    LONG lParam);
#else
#define _ResourceCallEnumNameRoutine( EnumProc, hModule, lpType, lpName, lParam ) \
    (*EnumProc)(hModule, lpType, lpName, lParam)
#endif

BOOL
WINAPI
EnumResourceNamesA(
    HMODULE hModule,
    LPCSTR lpType,
    ENUMRESNAMEPROCA lpEnumFunc,
    LONG_PTR lParam
    )

/*++

Routine Description:

    This function enumerates all of the resource names for a specific
    resource type name contained in a module.  It enumerates them by
    passing each resource name and type name to the callback function
    pointed to by the lpEnumFunc parameter.

    The EnumResourceNames function continues to enumerate resource names
    until called function returns FALSE or the last resource name for the
    specified resource type name has been enumerated.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource names to be enumerated.  A value of NULL references the
        module handle associated with the image file that was used to
        create the current process.

    lpType - Points to a null-terminated character string that
        represents the type name of the resources whose names are to be
        enumerated.  For predefined resource types, the lpType parameter
        should be one of the following values:

        RT_ACCELERATOR - Accelerator table

        RT_BITMAP - Bitmap resource

        RT_DIALOG - Dialog box

        RT_FONT - Font resource

        RT_FONTDIR - Font directory resource

        RT_MENU - Menu resource

        RT_RCDATA - User-defined resource (raw data)

    lpEnumFunc - Points to the callback function that will be called
        for each enumerated resource name.

    lParam - Specifies the value to be passed to the callback function
        for the application's use.

Return Value:

    TRUE - All resource names were enumerated.

    FALSE/NULL - The enumeration was terminated before all resource
        names were enumerated.

Callback Function:

    BOOL
    EnumFunc(
        HMODULE hModule,
        LPSTR lpType,
        LPSTR lpName,
        LONG lParam
        );

    Routine Description:

        EnumFunc is a placeholder for the application-supplied function name.

    Arguments:

        hModule - Identifies the module whose executable file contains
            the resource names to be enumerated.  A value of NULL
            references the module handle associated with the image file
            that was used to create the current process.

        lpType - Points to a null-terminated character string that
            represents the type name of the resource being enumerated.
            For predefined resource types, the lpType parameter will be
            one of the following values:

            RT_ACCELERATOR - Accelerator table

            RT_BITMAP - Bitmap resource

            RT_DIALOG - Dialog box

            RT_FONT - Font resource

            RT_FONTDIR - Font directory resource

            RT_MENU - Menu resource

            RT_RCDATA - User-defined resource (raw data)

            RT_STRING - String table

            RT_MESSAGETABLE - Message table

            RT_CURSOR - Hardware dependent cursor resource

            RT_GROUP_CURSOR - Directory of cursor resources

            RT_ICON - Hardware dependent cursor resource

            RT_GROUP_ICON - Directory of icon resources

        lpName - Points to a null-terminated character string that
            represents the name of the resource being enumerated.

        lParam - Specifies the 32-bit arugment of the EnumResourceNames
            function.

    Return Value:

        TRUE - Continue the enumeration.

        FALSE/NULL - Stop enumerating resource names.

--*/

{
    BOOL Result;
    NTSTATUS Status;
    ULONG i;
    ULONG_PTR IdPath[ 1 ];
    HANDLE DllHandle;
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory, TopResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirectoryEntry;
    PIMAGE_RESOURCE_DIR_STRING_U ResourceNameString;
    LPSTR lpName;
    PCHAR Buffer;
    ULONG BufferLength;
    ULONG Length;

    if ((IdPath[0] = BaseDllMapResourceIdA (lpType)) == -1) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    DllHandle = BasepMapModuleHandle (hModule, TRUE);
    TopResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
        RtlImageDirectoryEntryToData ((PVOID)DllHandle,
                                      TRUE,
                                      IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                      &i);
    if (!TopResourceDirectory) {
        Status = STATUS_RESOURCE_DATA_NOT_FOUND;
    } else {
        Status = LdrFindResourceDirectory_U ((PVOID)DllHandle,
                                             IdPath,
                                             1,
                                             &ResourceDirectory);
    }

    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        BaseDllFreeResourceId (IdPath[ 0 ]);
        return FALSE;
    }

    Buffer = NULL;
    BufferLength = 0;
    Result = TRUE;
    SetLastError( NO_ERROR );
    try {
        ResourceDirectoryEntry =
            (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(ResourceDirectory+1);
        for (i=0; i<ResourceDirectory->NumberOfNamedEntries; i++) {
            ResourceNameString = (PIMAGE_RESOURCE_DIR_STRING_U)
                ((PCHAR)TopResourceDirectory + ResourceDirectoryEntry->NameOffset);
            if ((ULONG)(ResourceNameString->Length+1) >= BufferLength) {
                if (Buffer) {
                    RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
                    Buffer = NULL;
                }

                BufferLength = (ResourceNameString->Length + 64) & ~63;
                Buffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), BufferLength );
                if (Buffer == NULL) {
                    BaseSetLastNTError (STATUS_NO_MEMORY);
                    Result = FALSE;
                    break;
                }
            }

            Status = RtlUnicodeToMultiByteN (Buffer,
                                             BufferLength - 1,
                                             &Length,
                                             ResourceNameString->NameString,
                                             ResourceNameString->Length * sizeof(WCHAR));

            if (!NT_SUCCESS (Status)) {
                BaseSetLastNTError (Status);
                Result = FALSE;
                break;
            }

            Buffer[Length] = '\0';

            if (!_ResourceCallEnumNameRoutine (lpEnumFunc, hModule, lpType, (LPSTR)Buffer, lParam)) {
                Result = FALSE;
                break;
            }

            ResourceDirectoryEntry++;
        }

        if (Result) {
            for (i=0; i<ResourceDirectory->NumberOfIdEntries; i++) {
                lpName = (LPSTR)ResourceDirectoryEntry->Id;
                if (!_ResourceCallEnumNameRoutine (lpEnumFunc, hModule, lpType, lpName, lParam )) {
                    Result = FALSE;
                    break;
                }

                ResourceDirectoryEntry++;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        Result = FALSE;
    }

    if (Buffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
    }

    //
    // Free any string allocated by BaseDllMapResourceIdA
    //
    BaseDllFreeResourceId( IdPath[ 0 ] );

    return Result;
}


#ifdef _X86_
BOOL
__stdcall
_ResourceCallEnumLangRoutine(
    ENUMRESLANGPROCA EnumProc,
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    WORD wLanguage,
    LONG lParam);
#else
#define _ResourceCallEnumLangRoutine( EnumProc, hModule, lpType, lpName, wLanguage, lParam ) \
    (*EnumProc)(hModule, lpType, lpName, wLanguage, lParam)
#endif

BOOL
WINAPI
EnumResourceLanguagesA(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    ENUMRESLANGPROCA lpEnumFunc,
    LONG_PTR lParam
    )

/*++

Routine Description:

    This function enumerates all of the language specific resources
    contained in a module for a given resource type and name ID.  It
    enumerates them by passing each resource type, name and language to
    the callback function pointed to by the lpEnumFunc parameter.

    The EnumResourceLanguares function continues to enumerate resources
    until called function returns FALSE or the last resource for
    the specified language has been enumerated.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource names to be enumerated.  A value of NULL references the
        module handle associated with the image file that was used to
        create the current process.

    lpType - Points to a null-terminated character string that
        represents the type name of the resources whose names are to be
        enumerated.  For predefined resource types, the lpType parameter
        should be one of the following values:

        RT_ACCELERATOR - Accelerator table

        RT_BITMAP - Bitmap resource

        RT_DIALOG - Dialog box

        RT_FONT - Font resource

        RT_FONTDIR - Font directory resource

        RT_MENU - Menu resource

        RT_RCDATA - User-defined resource (raw data)

    lpName - Points to a null-terminated character string that
        represents the name of the resource being enumerated.

    lpEnumFunc - Points to the callback function that will be called
        for each enumerated resource name.

    lParam - Specifies the value to be passed to the callback function
        for the application's use.

Return Value:

    TRUE - All resource names were enumerated.

    FALSE/NULL - The enumeration was terminated before all resource
        names were enumerated.

Callback Function:

    BOOL
    EnumFunc(
        HMODULE hModule,
        LPSTR lpType,
        LPSTR lpName,
        WORD  wLanguage,
        LONG lParam
        );

    Routine Description:

        EnumFunc is a placeholder for the application-supplied function name.

    Arguments:

        hModule - Identifies the module whose executable file contains
            the resource names to be enumerated.  A value of NULL
            references the module handle associated with the image file
            that was used to create the current process.

        lpType - Points to a null-terminated character string that
            represents the type name of the resource being enumerated.
            For predefined resource types, the lpType parameter will be
            one of the following values:

            RT_ACCELERATOR - Accelerator table

            RT_BITMAP - Bitmap resource

            RT_DIALOG - Dialog box

            RT_FONT - Font resource

            RT_FONTDIR - Font directory resource

            RT_MENU - Menu resource

            RT_RCDATA - User-defined resource (raw data)

            RT_STRING - String table

            RT_MESSAGETABLE - Message table

            RT_CURSOR - Hardware dependent cursor resource

            RT_GROUP_CURSOR - Directory of cursor resources

            RT_ICON - Hardware dependent cursor resource

            RT_GROUP_ICON - Directory of icon resources

        lpName - Points to a null-terminated character string that
            represents the name of the resource being enumerated.

        wLanguage -  represents the language of the resource.

        lParam - Specifies the 32-bit arugment of the EnumResourceNames
            function.

    Return Value:

        TRUE - Continue the enumeration.

        FALSE/NULL - Stop enumerating resource names.

--*/

{
    BOOL Result;
    NTSTATUS Status;
    ULONG i;
    ULONG_PTR IdPath[ 2 ];
    HANDLE DllHandle;
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory, TopResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirectoryEntry;
    USHORT wLanguage;

    IdPath[ 1 ] = 0;
    if ((IdPath[ 0 ] = BaseDllMapResourceIdA( lpType )) == -1) {
        Status = STATUS_INVALID_PARAMETER;
    } else
    if ((IdPath[ 1 ] = BaseDllMapResourceIdA( lpName )) == -1) {
        Status = STATUS_INVALID_PARAMETER;
    } else {
        DllHandle = BasepMapModuleHandle( hModule, TRUE );
        TopResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
            RtlImageDirectoryEntryToData( (PVOID)DllHandle,
                                          TRUE,
                                          IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                          &i
                                        );
        if (!TopResourceDirectory) {
            Status = STATUS_RESOURCE_DATA_NOT_FOUND;
        } else {
            Status = LdrFindResourceDirectory_U( (PVOID)DllHandle,
                                                 IdPath,
                                                 2,
                                                 &ResourceDirectory
                                               );
        }
    }

    if (!NT_SUCCESS( Status )) {
        BaseDllFreeResourceId( IdPath[ 0 ] );
        BaseDllFreeResourceId( IdPath[ 1 ] );
        BaseSetLastNTError( Status );
        return FALSE;
    }

    Result = TRUE;
    SetLastError( NO_ERROR );
    try {
        ResourceDirectoryEntry =
            (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(ResourceDirectory+1);
        if (ResourceDirectory->NumberOfNamedEntries != 0) {
            BaseSetLastNTError( STATUS_INVALID_IMAGE_FORMAT );
            Result = FALSE;
        } else {
            for (i=0; i<ResourceDirectory->NumberOfIdEntries; i++) {
                wLanguage = ResourceDirectoryEntry->Id;
                if (!_ResourceCallEnumLangRoutine(lpEnumFunc, hModule, lpType, lpName, wLanguage, lParam )) {
                    Result = FALSE;
                    break;
                }

                ResourceDirectoryEntry++;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        Result = FALSE;
    }

    //
    // Free any strings allocated by BaseDllMapResourceIdA
    //
    BaseDllFreeResourceId( IdPath[ 0 ] );
    BaseDllFreeResourceId( IdPath[ 1 ] );
    return Result;
}


BOOL
WINAPI
FreeResource(
    HGLOBAL hResData
    )
{
    //
    // Can't fail so return Win 3.x success code.
    //

    return FALSE;
}

LPVOID
WINAPI
LockResource(
    HGLOBAL hResData
    )
{
    return( (LPVOID)hResData );
}


HRSRC
FindResourceW(
    HMODULE hModule,
    LPCWSTR lpName,
    LPCWSTR lpType
    )

/*++

Routine Description:

    This function determines the location of a resource in the specified
    resource file.  The lpName and lpType parameters define the resource
    name and type, respectively.

    If the high-order word of the lpName or lpType parameter is zero,
    the low-order word specifies the integer ID of the name or type of
    the given resource.  Otherwise, the parameters are pointers to
    null-terminated character strings.  If the first character of the
    string is a pound sign (#), the remaining characters represent a
    decimal number that specifies the integer ID of the resource's name
    or type.  For example, the string "#258" represents the integer ID
    258.

    To reduce the amount of memory required for the resources used by an
    application, applications should refer to their resources by integer
    ID instead of by name.

    An application must not call FindResource and the LoadResource
    function to load cursor, icon, or string resources.  Instead, it
    must load these resources by calling the following functions:

      - LoadCursor

      - LoadIcon

      - LoadString

    An application can call FindResource and LoadResource to load other
    predefined resource types.  However, it is recommended that the
    application load the corresponding resources by calling the
    following functions:

      - LoadAccelerators

      - LoadBitmap

      - LoadMenu

    The above six API calls are documented with the Graphical User
    Interface API specification.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource.  A value of NULL references the module handle
        associated with the image file that was used to create the
        current process.

    lpName - Points to a null-terminated character string that
        represents the name of the resource.

    lpType - Points to a null-terminated character string that
        represents the type name of the resource.  For predefined
        resource types, the lpType parameter should be one of the
        following values:

        RT_ACCELERATOR - Accelerator table

        RT_BITMAP - Bitmap resource

        RT_DIALOG - Dialog box

        RT_FONT - Font resource

        RT_FONTDIR - Font directory resource

        RT_MENU - Menu resource

        RT_RCDATA - User-defined resource (raw data)

Return Value:

    The return value identifies the named resource.  It is NULL if the
    requested resource cannot be found.

--*/


{
    NTSTATUS Status;
    ULONG_PTR IdPath[ 3 ];
    PVOID p;

    IdPath[ 0 ] = 0;
    IdPath[ 1 ] = 0;
    try {
        if ((IdPath[ 0 ] = BaseDllMapResourceIdW( lpType )) == -1) {
            Status = STATUS_INVALID_PARAMETER;
        } else if ((IdPath[ 1 ] = BaseDllMapResourceIdW( lpName )) == -1) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            IdPath[ 2 ] = 0;
            p = NULL;
            Status = LdrFindResource_U( BasepMapModuleHandle( hModule, TRUE ),
                                        IdPath,
                                        3,
                                        (PIMAGE_RESOURCE_DATA_ENTRY *)&p
                                      );
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    //
    // Free any strings allocated by BaseDllMapResourceIdW
    //
    BaseDllFreeResourceId( IdPath[ 0 ] );
    BaseDllFreeResourceId( IdPath[ 1 ] );

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( NULL );
    } else {
        return( (HRSRC)p );
    }
}

HRSRC
FindResourceExW(
    HMODULE hModule,
    LPCWSTR lpType,
    LPCWSTR lpName,
    WORD  wLanguage
    )

/*++

Routine Description:

    This function determines the location of a resource in the specified
    resource file.  The lpType, lpName and wLanguage parameters define
    the resource type, name and language respectively.

    If the high-order word of the lpType or lpName parameter
    is zero, the low-order word specifies the integer ID of the type, name
    or language of the given resource.  Otherwise, the parameters are pointers
    to null-terminated character strings.  If the first character of the
    string is a pound sign (#), the remaining characters represent a
    decimal number that specifies the integer ID of the resource's name
    or type.  For example, the string "#258" represents the integer ID
    258.

    If the wLanguage parameter is zero, then the current language
    associated with the calling thread will be used.

    To reduce the amount of memory required for the resources used by an
    application, applications should refer to their resources by integer
    ID instead of by name.

    An application must not call FindResource and the LoadResource
    function to load cursor, icon, or string resources.  Instead, it
    must load these resources by calling the following functions:

      - LoadCursor

      - LoadIcon

      - LoadString

    An application can call FindResource and LoadResource to load other
    predefined resource types.  However, it is recommended that the
    application load the corresponding resources by calling the
    following functions:

      - LoadAccelerators

      - LoadBitmap

      - LoadMenu

    The above six API calls are documented with the Graphical User
    Interface API specification.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource.  A value of NULL references the module handle
        associated with the image file that was used to create the
        current process.

    lpType - Points to a null-terminated character string that
        represents the type name of the resource.  For predefined
        resource types, the lpType parameter should be one of the
        following values:

        RT_ACCELERATOR - Accelerator table

        RT_BITMAP - Bitmap resource

        RT_DIALOG - Dialog box

        RT_FONT - Font resource

        RT_FONTDIR - Font directory resource

        RT_MENU - Menu resource

        RT_RCDATA - User-defined resource (raw data)

    lpName - Points to a null-terminated character string that
        represents the name of the resource.

    wLanguage -  represents the language of the resource.  If this parameter
        is zero then the current language associated with the calling
        thread is used.

Return Value:

    The return value identifies the named resource.  It is NULL if the
    requested resource cannot be found.

--*/


{
    NTSTATUS Status;
    ULONG_PTR IdPath[ 3 ];
    PVOID p;

    IdPath[ 0 ] = 0;
    IdPath[ 1 ] = 0;
    try {
        if ((IdPath[ 0 ] = BaseDllMapResourceIdW( lpType )) == -1) {
            Status = STATUS_INVALID_PARAMETER;
        } else if ((IdPath[ 1 ] = BaseDllMapResourceIdW( lpName )) == -1) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            IdPath[ 2 ] = (ULONG_PTR)wLanguage;
            p = NULL;
            Status = LdrFindResource_U( BasepMapModuleHandle( hModule, TRUE ),
                                      IdPath,
                                      3,
                                      (PIMAGE_RESOURCE_DATA_ENTRY *)&p
                                    );
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    //
    // Free any strings allocated by BaseDllMapResourceIdW
    //

    BaseDllFreeResourceId( IdPath[ 0 ] );
    BaseDllFreeResourceId( IdPath[ 1 ] );

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( NULL );
    } else {
        return( (HRSRC)p );
    }
}


BOOL
APIENTRY
EnumResourceTypesW(
    HMODULE hModule,
    ENUMRESTYPEPROCW lpEnumFunc,
    LONG_PTR lParam
    )

/*++

Routine Description:

    This function enumerates all of the resource type names contained in
    a module.  It enumerates them by passing each type name to the callback
    function pointed to by the lpEnumFunc parameter.

    The EnumResourceTypes function continues to enumerate type names until
    called function returns FALSE or the last type name in the module has
    been enumerated.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource type names to be enumerated.  A value of NULL
        references the module handle associated with the image file that
        was used to create the current process.

    lpEnumFunc - Points to the callback function that will be called
        for each enumerated resource type name.

    lParam - Specifies the value to be passed to the callback function
        for the application's use.

Return Value:

    TRUE - All resource type names were enumerated.

    FALSE/NULL - The enumeration was terminated before all resource type
        names were enumerated.

Callback Function:

    BOOL
    EnumFunc(
        HMODULE hModule,
        LPWSTR lpType,
        LONG lParam
        );

    Routine Description:

        EnumFunc is a placeholder for the application-supplied function name.

    Arguments:

        hModule - Identifies the module whose executable file contains the
            resource type names to be enumerated.  A value of NULL
            references the module handle associated with the image file that
            was used to create the current process.

        lpType - Points to a null-terminated character string that
            represents the type name of the resource.  For predefined
            resource types, the lpType parameter will be one of the
            following values:

            RT_ACCELERATOR - Accelerator table

            RT_BITMAP - Bitmap resource

            RT_DIALOG - Dialog box

            RT_FONT - Font resource

            RT_FONTDIR - Font directory resource

            RT_MENU - Menu resource

            RT_RCDATA - User-defined resource (raw data)

            RT_STRING - String table

            RT_MESSAGETABLE - Message table

            RT_CURSOR - Hardware dependent cursor resource

            RT_GROUP_CURSOR - Directory of cursor resources

            RT_ICON - Hardware dependent cursor resource

            RT_GROUP_ICON - Directory of icon resources

        lParam - Specifies the 32-bit arugment of the EnumResourceTypes
            function.

    Return Value:

        TRUE - Continue the enumeration.

        FALSE/NULL - Stop enumerating resource type names.

--*/

{
    BOOL Result;
    NTSTATUS Status;
    ULONG i;
    HANDLE DllHandle;
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory, TopResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirectoryEntry;
    PIMAGE_RESOURCE_DIR_STRING_U ResourceNameString;
    LPWSTR lpType;
    LPWSTR Buffer;
    ULONG BufferLength;

    DllHandle = BasepMapModuleHandle( hModule, TRUE );
    TopResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
        RtlImageDirectoryEntryToData( (PVOID)DllHandle,
                                      TRUE,
                                      IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                      &i
                                     );
    if (!TopResourceDirectory) {
        BaseSetLastNTError( STATUS_RESOURCE_DATA_NOT_FOUND );
        return FALSE;
        }

    Status = LdrFindResourceDirectory_U( (PVOID)DllHandle,
                                         NULL,
                                         0,
                                         &ResourceDirectory
                                       );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return FALSE;
        }

    Buffer = NULL;
    BufferLength = 0;
    Result = TRUE;
    try {
        ResourceDirectoryEntry =
            (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(ResourceDirectory+1);
        for (i=0; i<ResourceDirectory->NumberOfNamedEntries; i++) {
            ResourceNameString = (PIMAGE_RESOURCE_DIR_STRING_U)
                ((PCHAR)TopResourceDirectory + ResourceDirectoryEntry->NameOffset);
            if ((ULONG)((ResourceNameString->Length+1) * sizeof( WCHAR )) >= BufferLength) {
                if (Buffer) {
                    RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
                    Buffer = NULL;
                }

                BufferLength = ((ResourceNameString->Length * sizeof( WCHAR )) + 64) & ~63;
                Buffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), BufferLength );
                if (Buffer == NULL) {
                    BaseSetLastNTError( STATUS_NO_MEMORY );
                    Result = FALSE;
                    break;
                }
            }
            RtlCopyMemory( Buffer,
                           ResourceNameString->NameString,
                           ResourceNameString->Length * sizeof( WCHAR )
                         );
            Buffer[ ResourceNameString->Length ] = UNICODE_NULL;

            if (!_ResourceCallEnumTypeRoutine((ENUMRESTYPEPROCA)lpEnumFunc, hModule, (LPSTR)Buffer, lParam )) {
                Result = FALSE;
                break;
            }

            ResourceDirectoryEntry++;
        }

        if (Result) {
            for (i=0; i<ResourceDirectory->NumberOfIdEntries; i++) {
                lpType = (LPWSTR)ResourceDirectoryEntry->Id;
                if (!_ResourceCallEnumTypeRoutine((ENUMRESTYPEPROCA)lpEnumFunc, hModule, (LPSTR)lpType, lParam )) {
                    Result = FALSE;
                    break;
                }

                ResourceDirectoryEntry++;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    if (Buffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
    }

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    } else {
        return Result;
    }
}


BOOL
APIENTRY
EnumResourceNamesW(
    HMODULE hModule,
    LPCWSTR lpType,
    ENUMRESNAMEPROCW lpEnumFunc,
    LONG_PTR lParam
    )

/*++

Routine Description:

    This function enumerates all of the resource names for a specific
    resource type name contained in a module.  It enumerates them by
    passing each resource name and type name to the callback function
    pointed to by the lpEnumFunc parameter.

    The EnumResourceNames function continues to enumerate resource names
    until called function returns FALSE or the last resource name for the
    specified resource type name has been enumerated.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource names to be enumerated.  A value of NULL references the
        module handle associated with the image file that was used to
        create the current process.

    lpType - Points to a null-terminated character string that
        represents the type name of the resources whose names are to be
        enumerated.  For predefined resource types, the lpType parameter
        should be one of the following values:

        RT_ACCELERATOR - Accelerator table

        RT_BITMAP - Bitmap resource

        RT_DIALOG - Dialog box

        RT_FONT - Font resource

        RT_FONTDIR - Font directory resource

        RT_MENU - Menu resource

        RT_RCDATA - User-defined resource (raw data)

    lpEnumFunc - Points to the callback function that will be called
        for each enumerated resource name.

    lParam - Specifies the value to be passed to the callback function
        for the application's use.

Return Value:

    TRUE - All resource names were enumerated.

    FALSE/NULL - The enumeration was terminated before all resource
        names were enumerated.

Callback Function:

    BOOL
    EnumFunc(
        HMODULE hModule,
        LPWSTR lpType,
        LPWSTR lpName,
        LONG lParam
        );

    Routine Description:

        EnumFunc is a placeholder for the application-supplied function name.

    Arguments:

        hModule - Identifies the module whose executable file contains
            the resource names to be enumerated.  A value of NULL
            references the module handle associated with the image file
            that was used to create the current process.

        lpType - Points to a null-terminated character string that
            represents the type name of the resource being enumerated.
            For predefined resource types, the lpType parameter will be
            one of the following values:

            RT_ACCELERATOR - Accelerator table

            RT_BITMAP - Bitmap resource

            RT_DIALOG - Dialog box

            RT_FONT - Font resource

            RT_FONTDIR - Font directory resource

            RT_MENU - Menu resource

            RT_RCDATA - User-defined resource (raw data)

            RT_STRING - String table

            RT_MESSAGETABLE - Message table

            RT_CURSOR - Hardware dependent cursor resource

            RT_GROUP_CURSOR - Directory of cursor resources

            RT_ICON - Hardware dependent cursor resource

            RT_GROUP_ICON - Directory of icon resources

        lpName - Points to a null-terminated character string that
            represents the name of the resource being enumerated.

        lParam - Specifies the 32-bit arugment of the EnumResourceNames
            function.

    Return Value:

        TRUE - Continue the enumeration.

        FALSE/NULL - Stop enumerating resource names.

--*/

{
    BOOL Result;
    NTSTATUS Status;
    ULONG i;
    ULONG_PTR IdPath[ 1 ];
    HANDLE DllHandle;
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory, TopResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirectoryEntry;
    PIMAGE_RESOURCE_DIR_STRING_U ResourceNameString;
    LPWSTR lpName;
    LPWSTR Buffer;
    ULONG BufferLength;

    if ((IdPath[ 0 ] = BaseDllMapResourceIdW( lpType )) == -1) {
        Status = STATUS_INVALID_PARAMETER;
    } else {
        DllHandle = BasepMapModuleHandle( hModule, TRUE );
        TopResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
            RtlImageDirectoryEntryToData( (PVOID)DllHandle,
                                          TRUE,
                                          IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                          &i
                                        );
        if (!TopResourceDirectory) {
            Status = STATUS_RESOURCE_DATA_NOT_FOUND;
        } else {
            Status = LdrFindResourceDirectory_U( (PVOID)DllHandle,
                                                 IdPath,
                                                 1,
                                                 &ResourceDirectory
                                               );
        }
    }

    if (!NT_SUCCESS( Status )) {
        BaseDllFreeResourceId( IdPath[ 0 ] );
        BaseSetLastNTError( Status );
        return FALSE;
    }

    Buffer = NULL;
    BufferLength = 0;
    Result = TRUE;
    try {
        ResourceDirectoryEntry =
            (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(ResourceDirectory+1);
        for (i=0; i<ResourceDirectory->NumberOfNamedEntries; i++) {
            ResourceNameString = (PIMAGE_RESOURCE_DIR_STRING_U)
                ((PCHAR)TopResourceDirectory + ResourceDirectoryEntry->NameOffset);
            if ((ULONG)((ResourceNameString->Length+1) * sizeof( WCHAR )) >= BufferLength) {
                if (Buffer) {
                    RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
                    Buffer = NULL;
                }

                BufferLength = ((ResourceNameString->Length * sizeof( WCHAR )) + 64) & ~63;
                Buffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), BufferLength );
                if (Buffer == NULL) {
                    BaseSetLastNTError( STATUS_NO_MEMORY );
                    Result = FALSE;
                    break;
                }
            }
            RtlCopyMemory( Buffer,
                           ResourceNameString->NameString,
                           ResourceNameString->Length * sizeof( WCHAR )
                         );
            Buffer[ ResourceNameString->Length ] = UNICODE_NULL;

            if (!_ResourceCallEnumNameRoutine((ENUMRESNAMEPROCA)lpEnumFunc, hModule, (LPSTR)lpType, (LPSTR)Buffer, lParam )) {
                Result = FALSE;
                break;
            }

            ResourceDirectoryEntry++;
        }

        if (Result) {
            for (i=0; i<ResourceDirectory->NumberOfIdEntries; i++) {
                lpName = (LPWSTR)ResourceDirectoryEntry->Id;
                if (!_ResourceCallEnumNameRoutine((ENUMRESNAMEPROCA)lpEnumFunc, hModule, (LPSTR)lpType, (LPSTR)lpName, lParam )) {
                    Result = FALSE;
                    break;
                }

                ResourceDirectoryEntry++;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        Result = FALSE;
    }

    if (Buffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, Buffer );
    }

    //
    // Free any string allocated by BaseDllMapResourceIdW
    //
    BaseDllFreeResourceId( IdPath[ 0 ] );

    return Result;
}


BOOL
APIENTRY
EnumResourceLanguagesW(
    HMODULE hModule,
    LPCWSTR lpType,
    LPCWSTR lpName,
    ENUMRESLANGPROCW lpEnumFunc,
    LONG_PTR lParam
    )

/*++

Routine Description:

    This function enumerates all of the language specific resources
    contained in a module for a given resource type and name ID.  It
    enumerates them by passing each resource type, name and language to
    the callback function pointed to by the lpEnumFunc parameter.

    The EnumResourceLanguares function continues to enumerate resources
    until called function returns FALSE or the last resource for
    the specified language has been enumerated.

Arguments:

    hModule - Identifies the module whose executable file contains the
        resource names to be enumerated.  A value of NULL references the
        module handle associated with the image file that was used to
        create the current process.

    lpType - Points to a null-terminated character string that
        represents the type name of the resources whose names are to be
        enumerated.  For predefined resource types, the lpType parameter
        should be one of the following values:

        RT_ACCELERATOR - Accelerator table

        RT_BITMAP - Bitmap resource

        RT_DIALOG - Dialog box

        RT_FONT - Font resource

        RT_FONTDIR - Font directory resource

        RT_MENU - Menu resource

        RT_RCDATA - User-defined resource (raw data)

    lpName - Points to a null-terminated character string that
        represents the name of the resource being enumerated.

    lpEnumFunc - Points to the callback function that will be called
        for each enumerated resource name.

    lParam - Specifies the value to be passed to the callback function
        for the application's use.

Return Value:

    TRUE - All resource names were enumerated.

    FALSE/NULL - The enumeration was terminated before all resource
        names were enumerated.

Callback Function:

    BOOL
    EnumFunc(
        HMODULE hModule,
        LPWSTR lpType,
        LPWSTR lpName,
        WORD  wLanguage,
        LONG lParam
        );

    Routine Description:

        EnumFunc is a placeholder for the application-supplied function name.

    Arguments:

        hModule - Identifies the module whose executable file contains
            the resource names to be enumerated.  A value of NULL
            references the module handle associated with the image file
            that was used to create the current process.

        lpType - Points to a null-terminated character string that
            represents the type name of the resource being enumerated.
            For predefined resource types, the lpType parameter will be
            one of the following values:

            RT_ACCELERATOR - Accelerator table

            RT_BITMAP - Bitmap resource

            RT_DIALOG - Dialog box

            RT_FONT - Font resource

            RT_FONTDIR - Font directory resource

            RT_MENU - Menu resource

            RT_RCDATA - User-defined resource (raw data)

            RT_STRING - String table

            RT_MESSAGETABLE - Message table

            RT_CURSOR - Hardware dependent cursor resource

            RT_GROUP_CURSOR - Directory of cursor resources

            RT_ICON - Hardware dependent cursor resource

            RT_GROUP_ICON - Directory of icon resources

        lpName - Points to a null-terminated character string that
            represents the name of the resource being enumerated.

        wLanguage -  represents the language of the resource.

        lParam - Specifies the 32-bit arugment of the EnumResourceNames
            function.

    Return Value:

        TRUE - Continue the enumeration.

        FALSE/NULL - Stop enumerating resource names.

--*/

{
    BOOL Result;
    NTSTATUS Status;
    ULONG i;
    ULONG_PTR IdPath[ 2 ];
    HANDLE DllHandle;
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory, TopResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirectoryEntry;
    USHORT wLanguage;

    IdPath[ 1 ] = 0;
    if ((IdPath[ 0 ] = BaseDllMapResourceIdW( lpType )) == -1) {
        Status = STATUS_INVALID_PARAMETER;
        }
    else
    if ((IdPath[ 1 ] = BaseDllMapResourceIdW( lpName )) == -1) {
        Status = STATUS_INVALID_PARAMETER;
        }
    else {
        DllHandle = BasepMapModuleHandle( hModule, TRUE );
        TopResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
            RtlImageDirectoryEntryToData( (PVOID)DllHandle,
                                          TRUE,
                                          IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                          &i
                                        );
        if (!TopResourceDirectory) {
            Status = STATUS_RESOURCE_DATA_NOT_FOUND;
        } else {
            Status = LdrFindResourceDirectory_U( (PVOID)DllHandle,
                                                 IdPath,
                                                 2,
                                                 &ResourceDirectory
                                               );
        }
    }

    if (!NT_SUCCESS( Status )) {
        BaseDllFreeResourceId( IdPath[ 0 ] );
        BaseDllFreeResourceId( IdPath[ 1 ] );
        BaseSetLastNTError( Status );
        return FALSE;
    }

    Result = TRUE;
    try {
        ResourceDirectoryEntry =
            (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(ResourceDirectory+1);
        if (ResourceDirectory->NumberOfNamedEntries != 0) {
            BaseSetLastNTError( STATUS_INVALID_IMAGE_FORMAT );
            Result = FALSE;
        } else {
            for (i=0; i<ResourceDirectory->NumberOfIdEntries; i++) {
                wLanguage = ResourceDirectoryEntry->Id;
                if (!_ResourceCallEnumLangRoutine((ENUMRESLANGPROCA)lpEnumFunc, hModule, (LPSTR)lpType, (LPSTR)lpName, wLanguage, lParam )) {
                    Result = FALSE;
                    break;
                }

                ResourceDirectoryEntry++;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        Result = FALSE;
    }

    //
    // Free any strings allocated by BaseDllMapResourceIdW
    //
    BaseDllFreeResourceId( IdPath[ 0 ] );
    BaseDllFreeResourceId( IdPath[ 1 ] );

    return Result;
}


ULONG_PTR
BaseDllMapResourceIdA(
    LPCSTR lpId
    )
{
    NTSTATUS Status;
    ULONG_PTR Id;
    ULONG ulId;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    PWSTR s;

    try {
        if ((ULONG_PTR)lpId >= LDR_RESOURCE_ID_NAME_MINVAL) {

            if (*lpId == '#') {
                Status = RtlCharToInteger( lpId+1, 10, &ulId );
                Id = ulId;
                if (!NT_SUCCESS( Status ) || (Id & LDR_RESOURCE_ID_NAME_MASK)) {
                    if (NT_SUCCESS( Status )) {
                        Status = STATUS_INVALID_PARAMETER;
                    }
                    BaseSetLastNTError( Status );
                    Id = (ULONG)-1;
                }
            } else {
                RtlInitAnsiString( &AnsiString, lpId );
                Status = RtlAnsiStringToUnicodeString( &UnicodeString,
                                                       &AnsiString,
                                                       TRUE
                                                     );
                if (!NT_SUCCESS( Status )){
                    BaseSetLastNTError( Status );
                    Id = (ULONG_PTR)-1;
                } else {
                    s = UnicodeString.Buffer;
                    while (*s != UNICODE_NULL) {
                        *s = RtlUpcaseUnicodeChar( *s );
                        s++;
                    }

                    Id = (ULONG_PTR)UnicodeString.Buffer;
                }
            }
        } else {
            Id = (ULONG_PTR)lpId;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        Id =  (ULONG_PTR)-1;
    }
    return Id;
}

ULONG_PTR
BaseDllMapResourceIdW(
    LPCWSTR lpId
    )
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    ULONG_PTR Id;
    ULONG ulId;
    PWSTR s;

    try {
        if ((ULONG_PTR)lpId >= LDR_RESOURCE_ID_NAME_MINVAL) {
            if (*lpId == '#') {
                RtlInitUnicodeString( &UnicodeString, lpId+1 );
                Status = RtlUnicodeStringToInteger( &UnicodeString, 10, &ulId );
                Id = ulId;
                if (!NT_SUCCESS( Status ) || Id > LDR_RESOURCE_ID_NAME_MASK) {
                    if (NT_SUCCESS( Status )) {
                        Status = STATUS_INVALID_PARAMETER;
                    }
                    BaseSetLastNTError( Status );
                    Id = (ULONG_PTR)-1;
                }
            } else {
                s = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (wcslen( lpId ) + 1) * sizeof( WCHAR ) );
                if (s == NULL) {
                    BaseSetLastNTError( STATUS_NO_MEMORY );
                    Id = (ULONG_PTR)-1;
                } else {
                    Id = (ULONG_PTR)s;

                    while (*lpId != UNICODE_NULL) {
                        *s++ = RtlUpcaseUnicodeChar( *lpId++ );
                    }

                    *s = UNICODE_NULL;
                }
            }
        } else {
            Id = (ULONG_PTR)lpId;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        BaseSetLastNTError( GetExceptionCode() );
        Id =  (ULONG_PTR)-1;
    }

    return Id;
}


VOID
BaseDllFreeResourceId(
    ULONG_PTR Id
    )
{
    UNICODE_STRING UnicodeString;

    if (Id >= LDR_RESOURCE_ID_NAME_MINVAL && Id != -1) {
        UnicodeString.Buffer = (PWSTR)Id;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = 0;
        RtlFreeUnicodeString( &UnicodeString );
    }
}


INT_PTR ReturnMem16Data(
    DWORD dwReserved1,
    DWORD dwReserved2,
    DWORD dwReserved3
    )
{
// Since there's _currently_ no other app we know that this will be useful for, we can
// always return "our" value.

    // Elmo's Preschool Deluxe is looking for free physical or virtual mem.  Give it a
    // Number it will be happy with.
    // Incoming params from Elmo's (in case they're needed one day):
    // dwReserved1 will be 0
    // dwReserved2 will be 1 or 2 (physical/virtual)
    // dwReserved3 will be 0
    return 0x2000;
}


BOOL
UTRegister(
    HMODULE hInst32,
    LPSTR lpszDll16,
    LPSTR lpszInitFunc,
    LPSTR lpszThunkFunc,
    FARPROC *ppfnThunk32Func,
    FARPROC Callback,
    PVOID lpvData
    )
{

    //
    // This function is supposed to return an error code.  VOID happens to work because
    // the stub would just leave EAX alone.  If something happens and EAX starts getting
    // zero'ed out, it'll cause problems and return type here should be changed to int
    // and success should return NON-ZERO.   - bjm 09/98
    //

    // Sure, we could have checked this on a compat bit instead, but the ISV is the
    // Children's Television Workshop people and if they do this silliness in any
    // of their other apps, we'll get those fixed "for free".
    if ( 0 == lstrcmpi( lpszDll16, (LPCSTR)"mem16.dll" ) &&
         0 == lstrcmpi( lpszThunkFunc, (LPCSTR)"GetMemory" ) )
    {
        //
        // Elmo's Preschool Deluxe calls to a 16bit dll they ship just
        // to get physical and virtual mem.  Let's give 'em a pointer to our routine that
        // will give it numbers that makes it happy.
        //
        *ppfnThunk32Func = ReturnMem16Data;
       return(TRUE);
    }

    // Stub this function for King's Quest and Bodyworks 5.0 and other random Win 95 apps.
    return(FALSE);
}


VOID
UTUnRegister(
    HMODULE hInst32
    )
{
    // Stub this function for King's Quest and Bodyworks 5.0 and other random Win 95 apps.
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\numa.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    numa.c

Abstract:

    This module implements Win32 Non Uniform Memory Architecture
    information APIs.

Author:

    Peter Johnston (peterj) 21-Sep-2000

Revision History:

--*/

#include "basedll.h"

BOOL
WINAPI
GetNumaHighestNodeNumber(
    PULONG HighestNodeNumber
    )

/*++

Routine Description:

    Return the (current) highest numbered node in the system.

Arguments:

    HighestNodeNumber   Supplies a pointer to receive the number of
                        last (highest) node in the system.

Return Value:

    TRUE unless something impossible happened.

--*/

{
    NTSTATUS Status;
    ULONG ReturnedSize;
    ULONGLONG Information;
    PSYSTEM_NUMA_INFORMATION Numa;

    Numa = (PSYSTEM_NUMA_INFORMATION)&Information;

    Status = NtQuerySystemInformation(SystemNumaProcessorMap,
                                      Numa,
                                      sizeof(Information),
                                      &ReturnedSize);

    if (!NT_SUCCESS(Status)) {

        //
        // This can't possibly happen.   Attempt to handle it
        // gracefully.
        //

        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (ReturnedSize < sizeof(ULONG)) {

        //
        // Nor can this.
        //

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Return the number of nodes in the system.
    //

    *HighestNodeNumber = Numa->HighestNodeNumber;
    return TRUE;
}

BOOL
WINAPI
GetNumaProcessorNode(
    UCHAR Processor,
    PUCHAR NodeNumber
    )

/*++

Routine Description:

    Return the Node number for a given processor.

Arguments:

    Processor       Supplies the processor number.
    NodeNumber      Supplies a pointer to the UCHAR to receive the
                    node number this processor belongs to.

Return Value:

    BOOL - TRUE if function succeeded, FALSE if it failed.  If it
           failed because the processor wasn't present, then set the
           NodeNumber to 0xFF

--*/

{
    ULONGLONG Mask;
    NTSTATUS Status;
    ULONG ReturnedSize;
    UCHAR Node;
    SYSTEM_NUMA_INFORMATION Map;

    //
    // If the requested processor number is not reasonable, return
    // error value.
    //

    if (Processor >= MAXIMUM_PROCESSORS) {
        *NodeNumber = 0xFF;
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Get the Node -> Processor Affinity map from the system.
    //

    Status = NtQuerySystemInformation(SystemNumaProcessorMap,
                                      &Map,
                                      sizeof(Map),
                                      &ReturnedSize);

    if (!NT_SUCCESS(Status)) {

        //
        // This can't happen,... but try to stay sane if possible.
        //

        *NodeNumber = 0xFF;
        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // Look thru the nodes returned for the node in which the
    // requested processor's affinity is non-zero.
    //

    Mask = 1 << Processor;

    for (Node = 0; Node <= Map.HighestNodeNumber; Node++) {
        if ((Map.ActiveProcessorsAffinityMask[Node] & Mask) != 0) {
            *NodeNumber = Node;
            return TRUE;
        }
    }
    //
    // Didn't find this processor in any node, return error value.
    //

    *NodeNumber = 0xFF;
    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}

BOOL
WINAPI
GetNumaNodeProcessorMask(
    UCHAR Node,
    PULONGLONG ProcessorMask
    )

/*++

Routine Description:

    This routine is used to obtain the bitmask of processors for a
    given node.

Arguments:

    Node            Supplies the Node number for which the set of
                    processors is returned.
    ProcessorMask Pointer to a ULONGLONG to receivethe bitmask of 
                    processors on this node.

Return Value:

    TRUE is the Node number was reasonable, FALSE otherwise.

--*/

{
    NTSTATUS Status;
    ULONG ReturnedSize;
    SYSTEM_NUMA_INFORMATION Map;

    //
    // Get the node -> processor mask table from the system.
    //

    Status = NtQuerySystemInformation(SystemNumaProcessorMap,
                                      &Map,
                                      sizeof(Map),
                                      &ReturnedSize);
    if (!NT_SUCCESS(Status)) {

        //
        // This can't possibly have happened.
        //

        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // If the requested node doesn't exist, return a zero processor
    // mask.
    //

    if (Node > Map.HighestNodeNumber) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Return the processor mask for the requested node.
    //

    *ProcessorMask = Map.ActiveProcessorsAffinityMask[Node];
    return TRUE;
}

BOOL
WINAPI
GetNumaAvailableMemoryNode(
    UCHAR Node,
    PULONGLONG AvailableBytes
    )


/*++

Routine Description:

    This routine returns the (aproximate) amount of memory available
    on a given node.

Arguments:

    Node        Node number for which available memory count is
                needed.
    AvailableBytes  Supplies a pointer to a ULONGLONG in which the
                    number of bytes of available memory will be 
                    returned.

Return Value:

    TRUE is this call was successful, FALSE otherwise.

--*/

{
    NTSTATUS Status;
    ULONG ReturnedSize;
    SYSTEM_NUMA_INFORMATION Memory;

    //
    // Get the per node available memory table from the system.
    //

    Status = NtQuerySystemInformation(SystemNumaAvailableMemory,
                                      &Memory,
                                      sizeof(Memory),
                                      &ReturnedSize);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // If the requested node doesn't exist, it doesn't have any
    // available memory either.
    //

    if (Node > Memory.HighestNodeNumber) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Return the amount of available memory on the requested node.
    //

    *AvailableBytes = Memory.AvailableMemory[Node];
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\perfctr.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    perfctr.c

Abstract:

    This module contains the Win32 Performance Counter APIs

Author:

    Russ Blake (russbl)  29-May-1992

Revision History:

--*/

#include "basedll.h"


BOOL
WINAPI
QueryPerformanceCounter(
    LARGE_INTEGER *lpPerformanceCount
    )

/*++

    QueryPerformanceCounter -   provides access to a high-resolution
                                counter; frequency of this counter
                                is supplied by QueryPerformanceFrequency

        Inputs:

            lpPerformanceCount  -   a pointer to variable which
                                    will receive the counter

        Outputs:

            lpPerformanceCount  -   the current value of the counter,
                                    or 0 if it is not available

        Returns:

            TRUE if the performance counter is supported by the
            hardware, or FALSE if the performance counter is not
            supported by the hardware.


                                                                                            will receive the count

--*/

{
    LARGE_INTEGER PerfFreq;
    NTSTATUS Status;

    Status = NtQueryPerformanceCounter(lpPerformanceCount, &PerfFreq);

    if (!NT_SUCCESS(Status)) {
        // Call failed, report error
        SetLastError(RtlNtStatusToDosError(Status));
        return FALSE;
    }

    if (PerfFreq.LowPart == 0 && PerfFreq.HighPart == 0 ) {
        // Counter not supported
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }
    return TRUE;
}

BOOL
WINAPI
QueryPerformanceFrequency(
    LARGE_INTEGER *lpFrequency
    )

/*++

    QueryPerformanceFrequency -   provides the frequency of the high-
                                  resolution counter returned by
                                  QueryPerformanceCounter

        Inputs:


            lpFrequency         -   a pointer to variable which
                                    will receive the frequency

        Outputs:

            lpPerformanceCount  -   the frequency of the counter,
                                    or 0 if it is not available

        Returns:

            TRUE if the performance counter is supported by the
            hardware, or FALSE if the performance counter is not
            supported by the hardware.

--*/
{
    LARGE_INTEGER PerfCount;
    NTSTATUS Status;

    Status = NtQueryPerformanceCounter(&PerfCount, lpFrequency);

    if (!NT_SUCCESS(Status)) {
        // Call failed, report error
        SetLastError(RtlNtStatusToDosError(Status));
        return FALSE;
    }

    if (lpFrequency->LowPart == 0 && lpFrequency->HighPart == 0 ) {
        // Counter not supported
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\ntwow64b.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ntwow64b.h

Abstract:

    This header contains the fake Nt functions in Win32 Base used WOW64 to call
    into 64 bit code.

Author:

    Michael Zoran (mzoran) 21-Jun-1998

Revision History:

    Samer Arafeh (samera)  20-May-2000
    Add Side-by-Side support to wow64

    Jay Krell (a-JayK) July 2000
    big changes to Side-by-Side

--*/

#ifndef _NTWOW64B_
#define _NTWOW64B_

#if _MSC_VER > 1000
#pragma once
#endif

#include "basesxs.h"

extern BOOL RunningInWow64;

//
//  csrbeep.c
//
VOID
NTAPI
NtWow64CsrBasepSoundSentryNotification(
    IN ULONG VideoMode
    );

//
//  csrdlini.c
//
NTSTATUS
NTAPI
NtWow64CsrBasepRefreshIniFileMapping(
    IN PUNICODE_STRING BaseFileName
    );

//
//  csrdosdv.c
//
NTSTATUS
NTAPI
NtWow64CsrBasepDefineDosDevice(
    IN DWORD dwFlags,
    IN PUNICODE_STRING pDeviceName,
    IN PUNICODE_STRING pTargetPath
    );

//
//  csrpathm.c
//
UINT
NTAPI
NtWow64CsrBasepGetTempFile(
    VOID
    );

//
//  csrpro.c
//

NTSTATUS
NtWow64CsrBasepCreateProcess(
    IN PBASE_CREATEPROCESS_MSG a
    );

VOID
NtWow64CsrBasepExitProcess(
    IN UINT uExitCode
    );

NTSTATUS
NtWow64CsrBasepSetProcessShutdownParam(
    IN DWORD dwLevel,
    IN DWORD dwFlags
    );

NTSTATUS
NtWow64CsrBasepGetProcessShutdownParam(
    OUT LPDWORD lpdwLevel,
    OUT LPDWORD lpdwFlags
    );

BOOL
NtWow64CsrBaseCheckRunApp(
    IN  HANDLE  FileHandle,
    IN  LPCWSTR pwszApplication,
    IN  PVOID   pEnvironment,
    IN  USHORT  uExeType,
    IN  DWORD   dwReason,
    OUT PVOID*  ppData,
    OUT PDWORD  pcbData,
    OUT PVOID*  ppSxsData,
    OUT PDWORD  pcbSxsData,
    OUT PDWORD  pdwFusionFlags
    );

//
//  csrterm.c
//
NTSTATUS
NtWow64CsrBasepSetTermsrvAppInstallMode(
    IN BOOL bState
    );

NTSTATUS
NtWow64CsrBasepSetClientTimeZoneInformation(
    IN PBASE_SET_TERMSRVCLIENTTIMEZONE c
    );

//
//  csrthrd.c
//
NTSTATUS
NtWow64CsrBasepCreateThread(
    IN HANDLE ThreadHandle,
    IN CLIENT_ID ClientId
    );

//
//  csrbinit.c
//
NTSTATUS
NtWow64CsrBaseClientConnectToServer(
    IN PWSTR szSessionDir,
    OUT PHANDLE phMutant,
    OUT PBOOLEAN pServerProcess
    );


//
// csrsxs.c
//
NTSTATUS
NtWow64CsrBasepCreateActCtx(
    IN PBASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG Message
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\namepipe.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    namepipe.c

Abstract:

    This module contains the Win32 Named Pipe API

Author:

    Colin Watson (ColinW)  13-March-1991

Revision History:

--*/

#include "basedll.h"

#define DOS_LOCAL_PIPE_PREFIX   L"\\\\.\\pipe\\"
#define DOS_LOCAL_PIPE          L"\\DosDevices\\pipe\\"
#define DOS_REMOTE_PIPE         L"\\DosDevices\\UNC\\"

#define INVALID_PIPE_MODE_BITS  ~(PIPE_READMODE_BYTE    \
                                | PIPE_READMODE_MESSAGE \
                                | PIPE_WAIT             \
                                | PIPE_NOWAIT)
BOOL
NpGetUserNamep(
    HANDLE hNamedPipe,
    LPWSTR lpUserName,
    DWORD nMaxUserNameSize
    );

typedef
BOOL (WINAPI *REVERTTOSELF)( VOID );

typedef
BOOL (WINAPI *GETUSERNAMEW)( LPWSTR, LPDWORD );

typedef
BOOL (WINAPI *IMPERSONATENAMEDPIPECLIENT)( HANDLE );

HANDLE
APIENTRY
CreateNamedPipeA(
    LPCSTR lpName,
    DWORD dwOpenMode,
    DWORD dwPipeMode,
    DWORD nMaxInstances,
    DWORD nOutBufferSize,
    DWORD nInBufferSize,
    DWORD nDefaultTimeOut,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++
    Ansi thunk to CreateNamedPipeW.

--*/
{
    NTSTATUS Status;
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(&AnsiString,lpName);
    Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
        } else {
            BaseSetLastNTError(Status);
        }
        return INVALID_HANDLE_VALUE;
    }

    return CreateNamedPipeW(
            (LPCWSTR)Unicode->Buffer,
            dwOpenMode,
            dwPipeMode,
            nMaxInstances,
            nOutBufferSize,
            nInBufferSize,
            nDefaultTimeOut,
            lpSecurityAttributes);
}

HANDLE
APIENTRY
CreateNamedPipeW(
    LPCWSTR lpName,
    DWORD dwOpenMode,
    DWORD dwPipeMode,
    DWORD nMaxInstances,
    DWORD nOutBufferSize,
    DWORD nInBufferSize,
    DWORD nDefaultTimeOut,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++


Parameters:

    lpName --Supplies the pipe name Documented in "Pipe Names" section
        earlier.  This must be a local name.

    dwOpenMode --Supplies the set of flags that define the mode which the
        pipe is to be opened with.  The open mode consists of access
        flags (one of three values) logically ORed with a writethrough
        flag (one of two values) and an overlapped flag (one of two
        values), as described below.

        dwOpenMode Flags:

        PIPE_ACCESS_DUPLEX --Pipe is bidirectional.  (This is
            semantically equivalent to calling CreateFile with access
            flags of GENERIC_READ | GENERIC_WRITE.)

        PIPE_ACCESS_INBOUND --Data goes from client to server only.
            (This is semantically equivalent to calling CreateFile with
            access flags of GENERIC_READ.)

        PIPE_ACCESS_OUTBOUND --Data goes from server to client only.
            (This is semantically equivalent to calling CreateFile with
            access flags of GENERIC_WRITE.)

        PIPE_WRITETHROUGH --The redirector is not permitted to delay the
            transmission of data to the named pipe buffer on the remote
            server. This disables a performance enhancement for
            applications that need synchronization with every write
            operation.

        FILE_FLAG_OVERLAPPED --Indicates that the system should
            initialize the file so that ReadFile, WriteFile and other
            operations that may take a significant time to process will
            return ERROR_IO_PENDING. An event will be set to the
            signalled state when the operation completes.

        FILE_FLAG_WRITETHROUGH -- No intermediate buffering.

        WRITE_DAC --            Standard security desired access
        WRITE_OWNER --          ditto
        ACCESS_SYSTEM_SECURITY -- ditto

    dwPipeMode --Supplies the pipe-specific modes (as flags) of the pipe.
        This parameter is a combination of a read-mode flag, a type flag,
        and a wait flag.

        dwPipeMode Flags:

        PIPE_WAIT --Blocking mode is to be used for this handle.

        PIPE_NOWAIT --Nonblocking mode is to be used for this handle.

        PIPE_READMODE_BYTE --Read pipe as a byte stream.

        PIPE_READMODE_MESSAGE --Read pipe as a message stream.  Note that
            this is not allowed with PIPE_TYPE_BYTE.

        PIPE_TYPE_BYTE --Pipe is a byte-stream pipe.  Note that this is
            not allowed with PIPE_READMODE_MESSAGE.

        PIPE_TYPE_MESSAGE --Pipe is a message-stream pipe.

    nMaxInstances --Gives the maximum number of instances for this pipe.
        Acceptable values are 1 to PIPE_UNLIMITED_INSTANCES-1 and
        PIPE_UNLIMITED_INSTANCES.

        nMaxInstances Special Values:

        PIPE_UNLIMITED_INSTANCES --Unlimited instances of this pipe can
            be created.

    nOutBufferSize --Specifies an advisory on the number of bytes to
        reserve for the outgoing buffer.

    nInBufferSize --Specifies an advisory on the number of bytes to
        reserve for the incoming buffer.

    nDefaultTimeOut -- Specifies an optional pointer to a timeout value
        that is to be used if a timeout value is not specified when
        waiting for an instance of a named pipe. This parameter is only
        meaningful when the first instance of a named pipe is created. If
        neither CreateNamedPipe or WaitNamedPipe specify a timeout 50
        milliseconds will be used.

    lpSecurityAttributes --An optional parameter that, if present and
        supported on the target system, supplies a security descriptor
        for the named pipe.  This parameter includes an inheritance flag
        for the handle.  If this parameter is not present, the handle is
        not inherited by child processes.

Return Value:

    Returns one of the following:

    INVALID_HANDLE_VALUE --An error occurred.  Call GetLastError for more
    information.

    Anything else --Returns a handle for use in the server side of
    subsequent named pipe operations.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    LARGE_INTEGER Timeout;
    PVOID FreeBuffer;
    LPWSTR FilePart;
    ULONG CreateFlags;
    ULONG DesiredAccess;
    ULONG ShareAccess;
    ULONG MaxInstances;
    SECURITY_DESCRIPTOR SecurityDescriptor;
    PACL DefaultAcl = NULL;

    if ((nMaxInstances == 0) ||
        (nMaxInstances > PIPE_UNLIMITED_INSTANCES)) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    // Convert Win32 maximum Instances to Nt maximum instances.
    MaxInstances = (nMaxInstances == PIPE_UNLIMITED_INSTANCES)?
        0xffffffff : nMaxInstances;


    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            lpName,
                            &FileName,
                            &FilePart,
                            NULL
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
    }

    FreeBuffer = FileName.Buffer;

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle ) {
            Obja.Attributes |= OBJ_INHERIT;
        }
    }

    if (Obja.SecurityDescriptor == NULL) {

        //
        // Apply default security if none specified (bug 131090)
        //

        Status = RtlDefaultNpAcl( &DefaultAcl );
        if (NT_SUCCESS( Status )) {
            RtlCreateSecurityDescriptor( &SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );
            RtlSetDaclSecurityDescriptor( &SecurityDescriptor, TRUE, DefaultAcl, FALSE );
            Obja.SecurityDescriptor = &SecurityDescriptor;
        } else {
            RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
            BaseSetLastNTError(Status);
            return INVALID_HANDLE_VALUE;
        }
    }

    //  End of code common with fileopcr.c CreateFile()

    CreateFlags = (dwOpenMode & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwOpenMode & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT);

    //
    //  Determine the timeout. Convert from milliseconds to an Nt delta time
    //

    if ( nDefaultTimeOut ) {
        Timeout.QuadPart = - (LONGLONG)UInt32x32To64( 10 * 1000, nDefaultTimeOut );
    } else {
        //  Default timeout is 50 Milliseconds
        Timeout.QuadPart =  -10 * 1000 * 50;
    }

    //  Check no reserved bits are set by mistake.

    if (( dwOpenMode & ~(PIPE_ACCESS_DUPLEX |
                         FILE_FLAG_OVERLAPPED | FILE_FLAG_WRITE_THROUGH |
                         FILE_FLAG_FIRST_PIPE_INSTANCE | WRITE_DAC |
                         WRITE_OWNER | ACCESS_SYSTEM_SECURITY ))||

        ( dwPipeMode & ~(PIPE_NOWAIT | PIPE_READMODE_MESSAGE |
                         PIPE_TYPE_MESSAGE ))) {

            RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
            if (DefaultAcl != NULL) {
                RtlFreeHeap(RtlProcessHeap(),0,DefaultAcl);
            }
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
    }

    //
    //  Translate the open mode into a sharemode to restrict the clients access
    //  and derive the appropriate local desired access.
    //

    switch ( dwOpenMode & PIPE_ACCESS_DUPLEX ) {
        case PIPE_ACCESS_INBOUND:
            ShareAccess = FILE_SHARE_WRITE;
            DesiredAccess = GENERIC_READ;
            break;

        case PIPE_ACCESS_OUTBOUND:
            ShareAccess = FILE_SHARE_READ;
            DesiredAccess = GENERIC_WRITE;
            break;

        case PIPE_ACCESS_DUPLEX:
            ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE;
            DesiredAccess = GENERIC_READ | GENERIC_WRITE;
            break;

        default:
            RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
            if (DefaultAcl != NULL) {
                RtlFreeHeap(RtlProcessHeap(),0,DefaultAcl);
            }
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
    }

    DesiredAccess |= SYNCHRONIZE |
         ( dwOpenMode & (WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY ));

    Status = NtCreateNamedPipeFile (
        &Handle,
        DesiredAccess,
        &Obja,
        &IoStatusBlock,
        ShareAccess,
        (dwOpenMode & FILE_FLAG_FIRST_PIPE_INSTANCE) ?
            FILE_CREATE : FILE_OPEN_IF, // Create first instance or subsequent
        CreateFlags,                    // Create Options
        dwPipeMode & PIPE_TYPE_MESSAGE ?
            FILE_PIPE_MESSAGE_TYPE : FILE_PIPE_BYTE_STREAM_TYPE,
        dwPipeMode & PIPE_READMODE_MESSAGE ?
            FILE_PIPE_MESSAGE_MODE : FILE_PIPE_BYTE_STREAM_MODE,
        dwPipeMode & PIPE_NOWAIT ?
            FILE_PIPE_COMPLETE_OPERATION : FILE_PIPE_QUEUE_OPERATION,
        MaxInstances,                   // Max instances
        nInBufferSize,                  // Inbound quota
        nOutBufferSize,                 // Outbound quota
        (PLARGE_INTEGER)&Timeout
        );

    if ( Status == STATUS_NOT_SUPPORTED ||
         Status == STATUS_INVALID_DEVICE_REQUEST ) {

        //
        // The request must have been processed by some other device driver
        // (other than NPFS).  Map the error to something reasonable.
        //

        Status = STATUS_OBJECT_NAME_INVALID;
    }

    RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
    if (DefaultAcl != NULL) {
        RtlFreeHeap(RtlProcessHeap(),0,DefaultAcl);
    }
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError (Status);
        return INVALID_HANDLE_VALUE;
    } else {
        if (IoStatusBlock.Information == FILE_OPENED) {
            SetLastError (ERROR_ALREADY_EXISTS);
        } else {
            SetLastError (0);
        }
    }

    return Handle;
}

NTSTATUS
GetTempIOEvent (
   PHANDLE pEvent
   )

/*++

Routine Description:

    Gets a temporary event to synchronize an I/O operation

Arguments:

    pEvent - Pointer to the event thats returned

Return Value:

    Return status.

--*/
{
    OBJECT_ATTRIBUTES oa;
    NTSTATUS Status;

    InitializeObjectAttributes (&oa, NULL, 0, NULL, NULL);
    Status = NtCreateEvent (pEvent,
                            EVENT_ALL_ACCESS,
                            &oa,
                            NotificationEvent,
                            FALSE);

    return Status;
}

NTSTATUS
FreeTempIOEvent (
   HANDLE Event
   )

/*++

Routine Description:

    Free a temporary event

Arguments:

    Event - Event handle previously allocated with 

Return Value:

    Return status.

--*/
{
    NTSTATUS Status;

    Status = NtClose (Event);
    ASSERT (NT_SUCCESS (Status));

    return Status;
}

BOOL
APIENTRY
ConnectNamedPipe(
    HANDLE hNamedPipe,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    The ConnectNamedPipe function is used by the server side of a named pipe
    to wait for a client to connect to the named pipe with a CreateFile
    request. The handle provided with the call to ConnectNamedPipe must have
    been previously returned by a successful call to CreateNamedPipe. The pipe
    must be in the disconnected, listening or connected states for
    ConnectNamedPipe to succeed.

    The behavior of this call depends on the blocking/nonblocking mode selected
    with the PIPE_WAIT/PIPE_NOWAIT flags when the server end of the pipe was
    created with CreateNamedPipe.

    If blocking mode is specified, ConnectNamedPipe will change the state from
    disconnected to listening and block. When a client connects with a
    CreateFile, the state will be changed from listening to connected and the
    ConnectNamedPipe returns TRUE. When the file handle is created with
    FILE_FLAG_OVERLAPPED on a blocking mode pipe, the lpOverlapped parameter
    can be specified. This allows the caller to continue processing while the
    ConnectNamedPipe API awaits a connection. When the pipe enters the
    signalled state the event is set to the signalled state.

    When nonblocking is specified ConnectNamedPipe will not block. On the
    first call the state will change from disconnected to listening. When a
    client connects with an Open the state will be changed from listening to
    connected. The ConnectNamedPipe will return FALSE (with GetLastError
    returning ERROR_PIPE_LISTENING) until the state is changed to the listening
    state.

Arguments:

    hNamedPipe - Supplies a Handle to the server side of a named pipe.

    lpOverlapped - Supplies an overlap structure to be used with the request.
        If NULL then the API will not return until the operation completes. When
        FILE_FLAG_OVERLAPPED is specified when the handle was created,
        ConnectNamedPipe may return ERROR_IO_PENDING to allow the caller to
        continue processing while the operation completes. The event (or File
        handle if hEvent=NULL) will be set to the not signalled state before
        ERROR_IO_PENDING is returned. The event will be set to the signalled
        state upon completion of the request. GetOverlappedResult is used to
        determine the error status.

Return Value:

    TRUE -- The operation was successful, the pipe is in the
        connected state.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    if (lpOverlapped != NULL) {
        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
    }
    
    Status = NtFsControlFile(
                hNamedPipe,
                (lpOverlapped==NULL)? NULL : lpOverlapped->hEvent,
                NULL,   // ApcRoutine
                lpOverlapped ? ((ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped) : NULL,
                (lpOverlapped==NULL) ? &Iosb : (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                FSCTL_PIPE_LISTEN,
                NULL,   // InputBuffer
                0,      // InputBufferLength,
                NULL,   // OutputBuffer
                0       // OutputBufferLength
                );

    if (lpOverlapped == NULL && Status == STATUS_PENDING) {
        // Operation must complete before return & Iosb destroyed
        Status = NtWaitForSingleObject (hNamedPipe, FALSE, NULL);
        if (NT_SUCCESS (Status)) {
            Status = Iosb.Status;
        }
    }

    if (NT_SUCCESS (Status) && Status != STATUS_PENDING) {
        return TRUE;
    } else {
        BaseSetLastNTError (Status);
        return FALSE;
    }
}

BOOL
APIENTRY
DisconnectNamedPipe(
    HANDLE hNamedPipe
    )

/*++

Routine Description:

    The DisconnectNamedPipe function can be used by the server side of a named
    pipe to force the client side to close the client side's handle. (Note that
    the client side must still call CloseFile to do this.)  The client will
    receive an error the next time it attempts to access the pipe. Disconnecting
    the pipe may cause data to be lost before the client reads it. (If the
    application wants to make sure that data is not lost, the serving side
    should call FlushFileBuffers before calling DisconnectNamedPipe.)

Arguments:

    hNamedPipe - Supplies a Handle to the server side of a named pipe.

Return Value:

    TRUE -- The operation was successful, the pipe is in the disconnected state.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{
    NTSTATUS Status;
    NTSTATUS Status1;
    IO_STATUS_BLOCK Iosb;
    HANDLE Event;
    OBJECT_ATTRIBUTES oa;

    Status = GetTempIOEvent (&Event);

    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return FALSE;
    }

    Status = NtFsControlFile (hNamedPipe,
                              Event,  // Event handle
                              NULL,   // ApcRoutine
                              NULL,   // ApcContext
                              &Iosb,
                              FSCTL_PIPE_DISCONNECT,
                              NULL,   // InputBuffer
                              0,      // InputBufferLength,
                              NULL,   // OutputBuffer
                              0);     // OutputBufferLength

    if (Status == STATUS_PENDING) {
        //
        // Operation must complete before return & Iosb destroyed
        //

        Status = NtWaitForSingleObject (Event, FALSE, NULL);
        if (NT_SUCCESS (Status)) {
            Status = Iosb.Status;
        }
    }

    FreeTempIOEvent (Event);

    if (NT_SUCCESS (Status)) {
        return TRUE;
    } else {
        BaseSetLastNTError (Status);
        return FALSE;
    }
}

BOOL
APIENTRY
GetNamedPipeHandleStateA(
    HANDLE hNamedPipe,
    LPDWORD lpState,
    LPDWORD lpCurInstances,
    LPDWORD lpMaxCollectionCount,
    LPDWORD lpCollectDataTimeout,
    LPSTR lpUserName,
    DWORD nMaxUserNameSize
    )
/*++

Routine Description:

    Ansi thunk to GetNamedPipeHandleStateW

---*/
{
    if (ARGUMENT_PRESENT (lpUserName)) {

        BOOL b;
        NTSTATUS Status;
        ANSI_STRING AnsiUserName;
        UNICODE_STRING UnicodeUserName;

        UnicodeUserName.MaximumLength = (USHORT)(nMaxUserNameSize << 1);
        UnicodeUserName.Buffer = RtlAllocateHeap(
                                        RtlProcessHeap(),MAKE_TAG( TMP_TAG ),
                                        UnicodeUserName.MaximumLength
                                        );

        AnsiUserName.Buffer = lpUserName;
        AnsiUserName.MaximumLength = (USHORT)nMaxUserNameSize;


        if ( !UnicodeUserName.Buffer ) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }


        b = GetNamedPipeHandleStateW(
                hNamedPipe,
                lpState,
                lpCurInstances,
                lpMaxCollectionCount,
                lpCollectDataTimeout,
                UnicodeUserName.Buffer,
                UnicodeUserName.MaximumLength/2);

        if ( b ) {

            //  Set length correctly in UnicodeUserName
            RtlInitUnicodeString(
                &UnicodeUserName,
                UnicodeUserName.Buffer
                );

            Status = RtlUnicodeStringToAnsiString(
                        &AnsiUserName,
                        &UnicodeUserName,
                        FALSE
                        );

            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                b = FALSE;
            }
        }

        if ( UnicodeUserName.Buffer ) {
            RtlFreeHeap(RtlProcessHeap(),0,UnicodeUserName.Buffer);
        }

        return b;
    } else {
        return GetNamedPipeHandleStateW(
                hNamedPipe,
                lpState,
                lpCurInstances,
                lpMaxCollectionCount,
                lpCollectDataTimeout,
                NULL,
                0);
    }

}

BOOL
APIENTRY
GetNamedPipeHandleStateW(
    HANDLE hNamedPipe,
    LPDWORD lpState,
    LPDWORD lpCurInstances,
    LPDWORD lpMaxCollectionCount,
    LPDWORD lpCollectDataTimeout,
    LPWSTR lpUserName,
    DWORD nMaxUserNameSize
    )
/*++

Routine Description:

The GetNamedPipeHandleState function retrieves information about a given
named pipe handle. The information returned by this function can vary during
the lifetime of an instance of a named pipe. The handle must be created with
the GENERIC_READ access rights.

Arguments:

    hNamedPipe - Supplies the handle of an opened named pipe.

    lpState - An optional parameter that if non-null, points to a DWORD which
        will be set with flags indicating the current state of the handle.
        The following flags may be specified:

        PIPE_NOWAIT
            Nonblocking mode is to be used for this handle.

        PIPE_READMODE_MESSAGE
            Read the pipe as a message stream. If this flag is not set, the pipe is
            read as a byte stream.

    lpCurInstances - An optional parameter that if non-null, points to a DWORD
        which will be set with the number of current pipe instances.

    lpMaxCollectionCount - If non-null, this points to a DWORD which will be
        set to the maximum number of bytes that will be collected on the clients
        machine before transmission to the server. This parameter must be NULL
        on a handle to the server end of a named pipe or when client and
        server applications are on the same machine.

    lpCollectDataTimeout - If non-null, this points to a DWORD which will be
        set to the maximum time (in milliseconds) that can pass before a
        remote named pipe transfers information over the network. This parameter
        must be NULL if the handle is for the server end of a named pipe or
        when client and server applications are on the same machine.

    lpUserName - An optional parameter on the server end of a named pipe.
        Points to an area which will be filled-in with the null-terminated
        string containing the name of the username of the client application.
        This parameter is invalid if not NULL on a handle to a client end of
        a named pipe.

    nMaxUserNameSize - Size in characters of the memory allocated at lpUserName.
        Ignored if lpUserName is NULL.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    if (ARGUMENT_PRESENT (lpState)) {
        FILE_PIPE_INFORMATION Common;

        Status = NtQueryInformationFile(
                    hNamedPipe,
                    &Iosb,
                    &Common,
                    sizeof(FILE_PIPE_INFORMATION),
                    FilePipeInformation );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
        }

        *lpState = (Common.CompletionMode == FILE_PIPE_QUEUE_OPERATION) ?
            PIPE_WAIT : PIPE_NOWAIT;

        *lpState |= (Common.ReadMode == FILE_PIPE_BYTE_STREAM_MODE) ?
            PIPE_READMODE_BYTE : PIPE_READMODE_MESSAGE;
    }

    if (ARGUMENT_PRESENT( lpCurInstances ) ){
        FILE_PIPE_LOCAL_INFORMATION Local;

        Status = NtQueryInformationFile(
                    hNamedPipe,
                    &Iosb,
                    &Local,
                    sizeof(FILE_PIPE_LOCAL_INFORMATION),
                    FilePipeLocalInformation );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
        }

        if (Local.CurrentInstances >= PIPE_UNLIMITED_INSTANCES) {
            *lpCurInstances = PIPE_UNLIMITED_INSTANCES;
        } else {
            *lpCurInstances = Local.CurrentInstances;
        }

    }

    if (ARGUMENT_PRESENT( lpMaxCollectionCount ) ||
        ARGUMENT_PRESENT( lpCollectDataTimeout ) ) {
        FILE_PIPE_REMOTE_INFORMATION Remote;

        Status = NtQueryInformationFile(
                    hNamedPipe,
                    &Iosb,
                    &Remote,
                    sizeof(FILE_PIPE_REMOTE_INFORMATION),
                    FilePipeRemoteInformation );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
        }

        if (ARGUMENT_PRESENT( lpMaxCollectionCount ) ) {
            *lpMaxCollectionCount = Remote.MaximumCollectionCount;
        }

        if (ARGUMENT_PRESENT( lpCollectDataTimeout ) ) {
            LARGE_INTEGER TimeWorkspace;
            LARGE_INTEGER LiTemporary;

            // Convert delta NT LARGE_INTEGER to milliseconds delay

            LiTemporary.QuadPart = -Remote.CollectDataTime.QuadPart;
            TimeWorkspace = RtlExtendedLargeIntegerDivide (
                    LiTemporary,
                    10000,
                    NULL ); // Not interested in any remainder

            if ( TimeWorkspace.HighPart ) {

                //
                //  Timeout larger than we can return- but not infinity.
                //  Must have been set with the direct NT Interface.
                //

                *lpCollectDataTimeout = 0xfffffffe;   //  Maximum we can set
            } else {
                *lpCollectDataTimeout = TimeWorkspace.LowPart;
            }
        }
    }

    if ( ARGUMENT_PRESENT( lpUserName ) ) {
        return NpGetUserNamep(hNamedPipe, lpUserName, nMaxUserNameSize );
    }

    return TRUE;
}

BOOL
NpGetUserNamep(
    HANDLE hNamedPipe,
    LPWSTR lpUserName,
    DWORD nMaxUserNameSize
    )
/*++

Routine Description:

The NpGetUserNamep function retrieves user name for the client at the other
end of the named pipe indicated by the handle.

Arguments:

    hNamedPipe - Supplies the handle of an opened named pipe.

    lpUserName - Points to an area which will be filled-in with the null-terminated
        string containing the name of the username of the client application.
        This parameter is invalid if not NULL on a handle to a client end of
        a named pipe.

    nMaxUserNameSize - Size in characters of the memory allocated at lpUserName.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{
    HANDLE   hToken;
    NTSTATUS Status;
    DWORD Size = nMaxUserNameSize;
    BOOL res;
    HANDLE advapi32;

    REVERTTOSELF RevertToSelfp;

    GETUSERNAMEW GetUserNameWp;

    IMPERSONATENAMEDPIPECLIENT ImpersonateNamedPipeClientp;

    advapi32 = LoadLibraryW(AdvapiDllString);

    if (advapi32 == NULL ) {
        return FALSE;
    }

    RevertToSelfp = (REVERTTOSELF)GetProcAddress(advapi32,"RevertToSelf");
    if ( RevertToSelfp == NULL) {
        FreeLibrary(advapi32);
        return FALSE;
    }

    GetUserNameWp = (GETUSERNAMEW)GetProcAddress(advapi32,"GetUserNameW");
    if ( GetUserNameWp == NULL) {
        FreeLibrary(advapi32);
        return FALSE;
    }

    ImpersonateNamedPipeClientp = (IMPERSONATENAMEDPIPECLIENT)GetProcAddress(advapi32,"ImpersonateNamedPipeClient");
    if ( ImpersonateNamedPipeClientp == NULL) {
        FreeLibrary(advapi32);
        return FALSE;
        }

    //  Save whoever the thread is currently impersonating.

    Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_IMPERSONATE,
                    TRUE,
                    &hToken
                    );

    if (!(ImpersonateNamedPipeClientp)( hNamedPipe )) {
        if (NT_SUCCESS (Status)) {
            if (!CloseHandle (hToken)) {
                ASSERTMSG ("CloseHandle failed for previously opened token", 0);
            }
        }
        FreeLibrary(advapi32);
        return FALSE;
    }

    res = (GetUserNameWp)( lpUserName, &Size );

    if ( !NT_SUCCESS( Status ) ) {
        //  We were not impersonating anyone

        (RevertToSelfp)();

    } else {

        //
        //  Set thread back to whoever it was originally impersonating.
        //  An error on this API overrides any error from  GetUserNameW
        //

        Status = NtSetInformationThread(
                     NtCurrentThread(),
                     ThreadImpersonationToken,
                     (PVOID)&hToken,
                     (ULONG)sizeof(HANDLE)
                     );

        if (!CloseHandle (hToken)) {
            ASSERTMSG ("CloseHandle failed for previously opened token", 0);
        }
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            FreeLibrary(advapi32);
            return FALSE;
        }
    }

    FreeLibrary(advapi32);

    return res;
}

BOOL
APIENTRY
SetNamedPipeHandleState(
    HANDLE hNamedPipe,
    LPDWORD lpMode,
    LPDWORD lpMaxCollectionCount,
    LPDWORD lpCollectDataTimeout
    )
/*++

Routine Description:


    The SetNamedPipeHandleState function is used to set the read
    mode and the blocking mode of a named pipe. On the client end
    of a remote named pipe this function can also control local
    buffering. The handle must be created with the GENERIC_WRITE
    access rights.

Arguments:

    hNamedPipe - Supplies a handle to a named pipe.

    lpMode - If non-null, this points to a DWORD which supplies the new
        mode. The mode is a combination of a read-mode flag and a wait flag.
        The following values may be used:

    PIPE_READMODE_BYTE
        Read pipe as a byte stream.

    PIPE_READMODE_MESSAGE
        Read pipe as a message stream.

    PIPE_WAIT
        Blocking mode is to be used for this handle.

    PIPE_NOWAIT
        Nonblocking mode is to be used for this handle.

    lpMaxCollectionCount - If non-null, this points to
        a DWORD which supplies the maximum number of
        bytes that will be collected on the client machine before
        transmission to the server. This parameter must be NULL on
        a handle to the server end of a named pipe or when client
        and server applications are on the same machine. This parameter
        is ignored if the client specified write through
        when the handle was created.

    lpCollectDataTimeout - If non-null, this points to a DWORD which
        supplies the maximum time (in milliseconds) that can pass before
        a remote named pipe transfers information over the network. This
        parameter must be NULL if the handle is for the server end of a
        named pipe or when client and server applications are on the same
        machine. This parameter is ignored if the client specified write
        through when the handle was created.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT( lpMode ) ){
        FILE_PIPE_INFORMATION Common;

        if (*lpMode & INVALID_PIPE_MODE_BITS) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        Common.ReadMode = ( *lpMode & PIPE_READMODE_MESSAGE ) ?
            FILE_PIPE_MESSAGE_MODE: FILE_PIPE_BYTE_STREAM_MODE;

        Common.CompletionMode = ( *lpMode & PIPE_NOWAIT ) ?
            FILE_PIPE_COMPLETE_OPERATION : FILE_PIPE_QUEUE_OPERATION;

        Status = NtSetInformationFile(
                    hNamedPipe,
                    &Iosb,
                    &Common,
                    sizeof(FILE_PIPE_INFORMATION),
                    FilePipeInformation );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
        }
    }

    if ( ARGUMENT_PRESENT( lpMaxCollectionCount ) ||
         ARGUMENT_PRESENT( lpCollectDataTimeout ) ){
        FILE_PIPE_REMOTE_INFORMATION Remote;

        if ( ( lpMaxCollectionCount == NULL ) ||
             ( lpCollectDataTimeout == NULL ) ){

            //
            // User is setting only one of the two parameters so read
            // the other value. There is a small window where another
            // thread using the same handle could set the other value.
            // in this case the setting would be lost.
            //

            Status = NtQueryInformationFile(
                    hNamedPipe,
                    &Iosb,
                    &Remote,
                    sizeof(FILE_PIPE_REMOTE_INFORMATION),
                    FilePipeRemoteInformation );

            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                return FALSE;
            }
        }

        if (ARGUMENT_PRESENT( lpMaxCollectionCount ) ) {
            Remote.MaximumCollectionCount = *lpMaxCollectionCount;
        }

        if (ARGUMENT_PRESENT( lpCollectDataTimeout ) ) {

            //
            //  Convert from milliseconds to an Nt delta time.
            //

            Remote.CollectDataTime.QuadPart =
                        - (LONGLONG)UInt32x32To64( 10 * 1000, *lpCollectDataTimeout );
        }

        Status = NtSetInformationFile(
                    hNamedPipe,
                    &Iosb,
                    &Remote,
                    sizeof(FILE_PIPE_REMOTE_INFORMATION),
                    FilePipeRemoteInformation );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            return FALSE;
        }
    }


    return TRUE;
}

BOOL
APIENTRY
GetNamedPipeInfo(
    HANDLE hNamedPipe,
    LPDWORD lpFlags,
    LPDWORD lpOutBufferSize,
    LPDWORD lpInBufferSize,
    LPDWORD lpMaxInstances
    )
/*++

Routine Description:

    The GetNamedPipeInfo function retrieves information about a named
    pipe. The information returned by this API is preserved the lifetime
    of an instance of a named pipe. The handle must be created with the
    GENERIC_READ access rights.

Arguments:
    hNamedPipe - Supplies a handle to a named pipe.

    lpFlags - An optional parameter that if non-null, points to a DWORD
        which will be set with flags indicating the type of named pipe and handle.

        PIPE_END_SERVER
            The handle is the server end of a named pipe.

        PIPE_TYPE_MESSAGE
            The pipe is a message-stream pipe. If this flag is not set, the pipe is
            a byte-stream pipe.

    lpOutBufferSize - An optional parameter that if non-null, points to a
        DWORD which will be set with the size (in bytes) of the buffer for
        outgoing data. A return value of zero indicates the buffer is allocated
        as needed.

    lpInBufferSize - An optional parameter that if non-null, points to a DWORD
        which will be set with the size (in bytes) of the buffer for incoming
        data. A return
        value of zero indicates the buffer is allocated as needed.

    lpMaxInstances - An optional parameter that if non-null, points to a
        DWORD which will be set with the maximum number of pipe instances
        that can be created. Besides various numeric values, a special value
        may be returned for this.

        PIPE_UNLIMITED_INSTANCES
            Unlimited instances of the pipe can be created. This is an
            indicator that the maximum is requested; the value of the
            equate may be higher or lower than the actual implementation's limit,
            which may vary over time.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    FILE_PIPE_LOCAL_INFORMATION Local;

    Status = NtQueryInformationFile(
                    hNamedPipe,
                    &Iosb,
                    &Local,
                    sizeof(FILE_PIPE_LOCAL_INFORMATION),
                    FilePipeLocalInformation );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (ARGUMENT_PRESENT( lpFlags ) ) {
        *lpFlags = (Local.NamedPipeEnd == FILE_PIPE_CLIENT_END) ?
            PIPE_CLIENT_END : PIPE_SERVER_END;
        *lpFlags |= (Local.NamedPipeType == FILE_PIPE_BYTE_STREAM_TYPE) ?
            PIPE_TYPE_BYTE : PIPE_TYPE_MESSAGE;
    }

    if (ARGUMENT_PRESENT( lpOutBufferSize ) ) {
        *lpOutBufferSize = Local.OutboundQuota;
    }

    if (ARGUMENT_PRESENT( lpInBufferSize ) ) {
        *lpInBufferSize = Local.InboundQuota;
    }

    if (ARGUMENT_PRESENT( lpMaxInstances ) ) {
        if (Local.MaximumInstances >= PIPE_UNLIMITED_INSTANCES) {
            *lpMaxInstances = PIPE_UNLIMITED_INSTANCES;
        } else {
            *lpMaxInstances = Local.MaximumInstances;
        }
    }


    return TRUE;
}


BOOL
APIENTRY
PeekNamedPipe(
    HANDLE hNamedPipe,
    LPVOID lpBuffer,
    DWORD nBufferSize,
    LPDWORD lpBytesRead,
    LPDWORD lpTotalBytesAvail,
    LPDWORD lpBytesLeftThisMessage
    )
/*++

Routine Description:

    The PeekNamedPipe function copies a named pipe's data into a buffer for
    preview without removing it. The results of a PeekNamedPipe are similar to
    a ReadFile on the pipe except more information is returned, the function
    never blocks and if the pipe handle is reading in message mode, a partial
    message can be returned.

    A partial message peek'd on a message mode pipe will return TRUE.

    It is not an error if all of the pointers passed to this function are
    null. However, there is no reason for calling it this way.

    The NT peek call has the received data immediately after the state
    information so this routine needs to allocate an intermediate buffer
    large enough for the state information plus data.

Arguments:

    hNamedPipe - Supplies a handle to a named pipe.

    lpBuffer - If non-null, pointer to buffer to read data into.

    nBufferSize - Size of input buffer, in bytes. (Ignored if lpBuffer
        is null.)

    lpBytesRead - If non-null, this points to a DWORD which will be set
        with the number of bytes actually read.

    lpTotalBytesAvail - If non-null, this points to a DWORD which receives
        a value giving the number of bytes that were available to be read.

    lpBytesLeftThisMessage - If non-null, this points to a DWORD which
        will be set to the number of bytes left in this message. (This will
        be zero for a byte-stream pipe.)

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;
    PFILE_PIPE_PEEK_BUFFER PeekBuffer;
    DWORD IOLength;
    HANDLE Event;

    // Allocate enough for the users data and FILE_PIPE_PEEK_BUFFER

    IOLength = nBufferSize + FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0]);
    PeekBuffer = RtlAllocateHeap(RtlProcessHeap(),MAKE_TAG( TMP_TAG ), IOLength);
    if (PeekBuffer == NULL) {
        BaseSetLastNTError (STATUS_INSUFFICIENT_RESOURCES);
        return FALSE;
    }

    Status = GetTempIOEvent (&Event);
    if (!NT_SUCCESS (Status)) {
        RtlFreeHeap (RtlProcessHeap (), 0, PeekBuffer);
        BaseSetLastNTError (Status);
        return FALSE;
    }

    try {

        Status = NtFsControlFile (hNamedPipe,
                                  Event,          // Completion event
                                  NULL,           // APC routine
                                  NULL,           // APC Context
                                  &Iosb,          // I/O Status block
                                  FSCTL_PIPE_PEEK,// IoControlCode
                                  NULL,           // Buffer for data to the FS
                                  0,              // Length.
                                  PeekBuffer,     // OutputBuffer for data from the FS
                                  IOLength);      // OutputBuffer Length

        if (Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject (Event, FALSE, NULL);
            if (NT_SUCCESS (Status)) {
                Status = Iosb.Status;
            }
        }

        //
        //  Buffer overflow simply means that lpBytesLeftThisMessage != 0
        //

        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            Status = STATUS_SUCCESS;
        }

        //
        //  Peek is complete, package up data for caller ensuring that
        //  the PeekBuffer is deleted even if an invalid pointer was given.
        //

        if ( NT_SUCCESS(Status)) {

            try {

                if (ARGUMENT_PRESENT (lpTotalBytesAvail)) {
                    *lpTotalBytesAvail = PeekBuffer->ReadDataAvailable;
                }

                if (ARGUMENT_PRESENT (lpBytesRead)) {
                    *lpBytesRead = (ULONG)(Iosb.Information - FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0]));
                }

                if (ARGUMENT_PRESENT (lpBytesLeftThisMessage)) {
                    *lpBytesLeftThisMessage =
                        PeekBuffer->MessageLength -
                        (ULONG)(Iosb.Information - FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0]));
                }

                if (ARGUMENT_PRESENT (lpBuffer)) {
                    RtlCopyMemory(
                        lpBuffer,
                        PeekBuffer->Data,
                        Iosb.Information - FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0]));
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                Status = GetExceptionCode ();
            }
        }
    } finally {

        RtlFreeHeap (RtlProcessHeap (), 0, PeekBuffer);
        FreeTempIOEvent (Event);
    }

    if (NT_SUCCESS (Status)) {
        return TRUE;
    } else {
        BaseSetLastNTError (Status);
        return FALSE;
    }
}

BOOL
APIENTRY
TransactNamedPipe(
    HANDLE hNamedPipe,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesRead,
    LPOVERLAPPED lpOverlapped
    )
/*++

Routine Description:

    The TransactNamedPipe function writes data to and reads data from a named
    pipe. This function fails if the named pipe contains any unread data or if
    the named pipe is not in message mode. A named pipe's blocking state has no
    effect on the TransactNamedPipe function. This API does not complete until
    data is written into the InBuffer buffer. The lpOverlapped parameter is
    available to allow an application to continue processing while the operation
    takes place.

Arguments:
    hNamedPipe - Supplies a handle to a named pipe.

    lpInBuffer - Supplies the buffer containing the data that is written to
        the pipe.

    nInBufferSize - Supplies the size (in bytes) of the output buffer.

    lpOutBuffer - Supplies the buffer that receives the data read from the pipe.

    nOutBufferSize - Supplies the size (in bytes) of the input buffer.

    lpBytesRead - Points to a DWORD that receives the number of bytes actually
        read from the pipe.

    lpOverlapped - An optional parameter that supplies an overlap structure to
        be used with the request. If NULL or the handle was created without
        FILE_FLAG_OVERLAPPED then the TransactNamedPipe will not return until
        the operation completes.

        When lpOverlapped is supplied and FILE_FLAG_OVERLAPPED was specified
        when the handle was created, TransactNamedPipeFile may return
        ERROR_IO_PENDING to allow the caller to continue processing while the
        operation completes. The event (or File handle if hEvent == NULL) will
        be set to the not signalled state before ERROR_IO_PENDING is
        returned. The event will be set to the signalled state upon completion
        of the request. GetOverlappedResult is used to determine the result
        when ERROR_IO_PENDING is returned.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    NTSTATUS Status;

    if (ARGUMENT_PRESENT (lpOverlapped)) {

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;

        Status = NtFsControlFile(hNamedPipe,
                    lpOverlapped->hEvent,
                    NULL,           // APC routine
                    (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                    (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                    FSCTL_PIPE_TRANSCEIVE,// IoControlCode
                    lpInBuffer,    // Buffer for data to the FS
                    nInBufferSize,
                    lpOutBuffer,     // OutputBuffer for data from the FS
                    nOutBufferSize   // OutputBuffer Length
                    );

        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
            if ( ARGUMENT_PRESENT(lpBytesRead) ) {
                try {
                    *lpBytesRead = (DWORD)lpOverlapped->InternalHigh;
                    }
                except(EXCEPTION_EXECUTE_HANDLER) {
                    *lpBytesRead = 0;
                    }
                }
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                if ( ARGUMENT_PRESENT(lpBytesRead) ) {
                    try {
                        *lpBytesRead = (DWORD)lpOverlapped->InternalHigh;
                        }
                    except(EXCEPTION_EXECUTE_HANDLER) {
                        *lpBytesRead = 0;
                        }
                    }
            }
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
    else
        {
        IO_STATUS_BLOCK Iosb;

        Status = NtFsControlFile(hNamedPipe,
                    NULL,
                    NULL,           // APC routine
                    NULL,           // APC Context
                    &Iosb,
                    FSCTL_PIPE_TRANSCEIVE,// IoControlCode
                    lpInBuffer,    // Buffer for data to the FS
                    nInBufferSize,
                    lpOutBuffer,     // OutputBuffer for data from the FS
                    nOutBufferSize   // OutputBuffer Length
                    );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & Iosb destroyed
            Status = NtWaitForSingleObject( hNamedPipe, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = Iosb.Status;
                }
            }

        if ( NT_SUCCESS(Status) ) {
            *lpBytesRead = (DWORD)Iosb.Information;
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                *lpBytesRead = (DWORD)Iosb.Information;
            }
            BaseSetLastNTError(Status);
            return FALSE;
            }
        }
}

BOOL
APIENTRY
CallNamedPipeA(
    LPCSTR lpNamedPipeName,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesRead,
    DWORD nTimeOut
    )
/*++

    ANSI thunk to CallNamedPipeW

--*/
{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(&AnsiString,lpNamedPipeName);
    Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return FALSE;
        }

    return ( CallNamedPipeW( (LPCWSTR)Unicode->Buffer,
                lpInBuffer,
                nInBufferSize,
                lpOutBuffer,
                nOutBufferSize,
                lpBytesRead,
                nTimeOut)
           );
}


BOOL
APIENTRY
CallNamedPipeW(
    LPCWSTR lpNamedPipeName,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesRead,
    DWORD nTimeOut
    )
/*++

Routine Description:

    CallNamedPipe is equivalent to a series of calls to CreateFile, perhaps
    WaitNamedPipe (if CreateFile can't open the pipe immediately),
    SetNamedPipeHandleState, TransactNamedPipe, and CloseFile. Refer to
    the documentation for those APIs for more information.

Arguments:

    lpNamedPipeName - Supplies the name of the named pipe.

    lpInBuffer - Supplies the buffer containing the data that is written to
        the pipe.

    nInBufferSize - Supplies the size (in bytes) of the output buffer.

    lpOutBuffer - Supplies the buffer that receives the data read from the pipe.

    nOutBufferSize - Supplies the size (in bytes) of the input buffer.

    lpBytesRead - Points to a DWORD that receives the number of bytes actually
        read from the pipe.

    nTimeOut - Gives a value (in milliseconds) that is the amount of time
        this function should wait for the pipe to become available. (Note
        that the function may take longer than that to execute, due to
        various factors.)

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    HANDLE Pipe;
    BOOL FirstChance = TRUE; //  Allow only one chance at WaitNamedPipe
    BOOL Result;

    while ( 1 ) {

        Pipe = CreateFileW(lpNamedPipeName,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,       // Security Attributes
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

        if ( Pipe != INVALID_HANDLE_VALUE ) {
            break;  //  Created a handle
            }

        if ( FirstChance == FALSE ) {
           //  Already called WaitNamedPipe once so give up.
           return FALSE;
        }

        WaitNamedPipeW(lpNamedPipeName, nTimeOut);

        FirstChance = FALSE;

        }


    try {
        DWORD ReadMode = PIPE_READMODE_MESSAGE | PIPE_WAIT;

        //  Default open is readmode byte stream- change to message mode.
        Result = SetNamedPipeHandleState( Pipe, &ReadMode, NULL, NULL);

        if ( Result == TRUE ) {
            Result = TransactNamedPipe(
                Pipe,
                lpInBuffer,
                nInBufferSize,
                lpOutBuffer,
                nOutBufferSize,
                lpBytesRead,
                NULL);
            }
        }
    finally {
        CloseHandle( Pipe );
        }

    return Result;
}

BOOL
APIENTRY
WaitNamedPipeA(
    LPCSTR lpNamedPipeName,
    DWORD nTimeOut
    )
/*++

    Ansi thunk to WaitNamedPipeW

--*/
{
    UNICODE_STRING UnicodeString;
    BOOL b;

    if (!Basep8BitStringToDynamicUnicodeString( &UnicodeString, lpNamedPipeName )) {
        return FALSE;
    }

    b = WaitNamedPipeW( UnicodeString.Buffer, nTimeOut );

    RtlFreeUnicodeString(&UnicodeString);

    return b;

}


BOOL
APIENTRY
WaitNamedPipeW(
    LPCWSTR lpNamedPipeName,
    DWORD nTimeOut
    )
/*++

Routine Description:

    The WaitNamedPipe function waits for a named pipe to become available.

Arguments:

    lpNamedPipeName - Supplies the name of the named pipe.

    nTimeOut - Gives a value (in milliseconds) that is the amount of time
        this function should wait for the pipe to become available. (Note
        that the function may take longer than that to execute, due to
        various factors.)

    nTimeOut Special Values:

        NMPWAIT_WAIT_FOREVER
            No timeout.

        NMPWAIT_USE_DEFAULT_WAIT
            Use default timeout set in call to CreateNamedPipe.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    IO_STATUS_BLOCK Iosb;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    RTL_PATH_TYPE PathType;
    ULONG WaitPipeLength;
    PFILE_PIPE_WAIT_FOR_BUFFER WaitPipe;
    PWSTR FreeBuffer;
    UNICODE_STRING FileSystem;
    UNICODE_STRING PipeName;
    UNICODE_STRING OriginalPipeName;
    UNICODE_STRING ValidUnicodePrefix;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    LPWSTR Pwc;
    ULONG Index;

    //
    //  Open a handle either to the redirector or the NPFS depending on
    //  the start of the pipe name. Split lpNamedPipeName into two
    //  halves as follows:
    //      \\.\pipe\pipename       \\.\pipe\ and pipename
    //      \\server\pipe\pipename  \\ and server\pipe\pipename
    //

    if (!RtlCreateUnicodeString( &OriginalPipeName, lpNamedPipeName)) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
        }

    //
    //  Change all the forward slashes into backward slashes.
    //

    for ( Index =0; Index < (OriginalPipeName.Length/sizeof(WCHAR)); Index++ ) {
        if (OriginalPipeName.Buffer[Index] == L'/') {
            OriginalPipeName.Buffer[Index] = L'\\';
            }
        }

    PipeName = OriginalPipeName;

    PathType = RtlDetermineDosPathNameType_U(lpNamedPipeName);

    FreeBuffer = NULL;

    switch ( PathType ) {
    case RtlPathTypeLocalDevice:

            //  Name should be of the form \\.\pipe\pipename (IgnoreCase)

            RtlInitUnicodeString( &ValidUnicodePrefix, DOS_LOCAL_PIPE_PREFIX);

            if (RtlPrefixString((PSTRING)&ValidUnicodePrefix,
                    (PSTRING)&PipeName,
                    TRUE) == FALSE) {
                RtlFreeUnicodeString(&OriginalPipeName);
                BaseSetLastNTError(STATUS_OBJECT_PATH_SYNTAX_BAD);
                return FALSE;
                }

            //  Skip first 9 characters "\\.\pipe\"
            PipeName.Buffer+=9;
            PipeName.Length-=9*sizeof(WCHAR);

            RtlInitUnicodeString( &FileSystem, DOS_LOCAL_PIPE);

            break;

        case RtlPathTypeUncAbsolute:
            //  Name is of the form \\server\pipe\pipename

            //  Find the pipe name.

            for ( Pwc = &PipeName.Buffer[2]; *Pwc != 0; Pwc++) {
                if ( *Pwc == L'\\') {
                    //  Found backslash after servername
                    break;
                    }
                }

            if ( (*Pwc != 0) &&
                 ( _wcsnicmp( Pwc + 1, L"pipe\\", 5 ) == 0 ) ) {

                // Temporarily, break this up into 2 strings
                //    string1 = \\server\pipe
                //    string2 = the-rest

                Pwc += (sizeof (L"pipe\\") / sizeof( WCHAR ) ) - 1;

            } else {

                // This is not a valid remote path name.

                RtlFreeUnicodeString(&OriginalPipeName);
                BaseSetLastNTError(STATUS_OBJECT_PATH_SYNTAX_BAD);
                return FALSE;
                }

            //  Pwc now points to the first path seperator after \\server\pipe.
            //  Attempt to open \DosDevices\Unc\Servername\Pipe.

            PipeName.Buffer = &PipeName.Buffer[2];
            PipeName.Length = (USHORT)((PCHAR)Pwc - (PCHAR)PipeName.Buffer);
            PipeName.MaximumLength = PipeName.Length;

            FileSystem.MaximumLength =
                (USHORT)sizeof( DOS_REMOTE_PIPE ) +
                PipeName.MaximumLength;

            FileSystem.Buffer = RtlAllocateHeap(
                                    RtlProcessHeap(),MAKE_TAG( TMP_TAG ),
                                    FileSystem.MaximumLength
                                    );

            if ( !FileSystem.Buffer ) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                RtlFreeUnicodeString(&OriginalPipeName);
                return FALSE;
                }
            FreeBuffer = FileSystem.Buffer;

            RtlCopyMemory(
                FileSystem.Buffer,
                DOS_REMOTE_PIPE,
                sizeof( DOS_REMOTE_PIPE ) - sizeof(WCHAR)
                );

            FileSystem.Length = sizeof( DOS_REMOTE_PIPE ) - sizeof(WCHAR);

            RtlAppendUnicodeStringToString( &FileSystem, &PipeName );

            // Set up pipe name, skip leading backslashes.

            RtlInitUnicodeString( &PipeName, (PWCH)Pwc + 1 );

            break;

        default:
            BaseSetLastNTError(STATUS_OBJECT_PATH_SYNTAX_BAD);
            RtlFreeUnicodeString(&OriginalPipeName);
            return FALSE;
        }


    InitializeObjectAttributes(
        &Obja,
        &FileSystem,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT
                );

    if (FreeBuffer != NULL) {
        RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
        }

    if ( !NT_SUCCESS(Status) ) {
        RtlFreeUnicodeString(&OriginalPipeName);
        BaseSetLastNTError(Status);
        return FALSE;
        }

    WaitPipeLength =
        FIELD_OFFSET(FILE_PIPE_WAIT_FOR_BUFFER, Name[0]) + PipeName.Length;
    WaitPipe = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), WaitPipeLength);
    if ( !WaitPipe ) {
        RtlFreeUnicodeString(&OriginalPipeName);
        NtClose(Handle);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);

        return FALSE;
        }

    if ( nTimeOut == NMPWAIT_USE_DEFAULT_WAIT ) {
        WaitPipe->TimeoutSpecified = FALSE;
        }
    else {
        if ( nTimeOut == NMPWAIT_WAIT_FOREVER ) {
            WaitPipe->Timeout.LowPart = 0;
            WaitPipe->Timeout.HighPart =0x80000000;
            }
        else {
            //
            //  Convert from milliseconds to an Nt delta time.
            //

            WaitPipe->Timeout.QuadPart =
                                - (LONGLONG)UInt32x32To64( 10 * 1000, nTimeOut );
            }
        WaitPipe->TimeoutSpecified = TRUE;
        }

    WaitPipe->NameLength = PipeName.Length;

    RtlCopyMemory(
        WaitPipe->Name,
        PipeName.Buffer,
        PipeName.Length
        );

    RtlFreeUnicodeString(&OriginalPipeName);

    Status = NtFsControlFile(Handle,
                        NULL,
                        NULL,           // APC routine
                        NULL,           // APC Context
                        &Iosb,
                        FSCTL_PIPE_WAIT,// IoControlCode
                        WaitPipe,       // Buffer for data to the FS
                        WaitPipeLength,
                        NULL,           // OutputBuffer for data from the FS
                        0               // OutputBuffer Length
                        );

    RtlFreeHeap(RtlProcessHeap(),0,WaitPipe);

    NtClose(Handle);

    if (NT_SUCCESS( Status ) ) {
        return TRUE;
        }
    else
        {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\power.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    power.c

Abstract:

    Stubs for unimplemented power management APIs

Author:

    Steve Wood (stevewo) 18-Nov-1994

Revision History:

--*/

#include "basedll.h"


BOOL
WINAPI
GetSystemPowerStatus(
    LPSYSTEM_POWER_STATUS lpStatus
    )
{
    SYSTEM_BATTERY_STATE    BatteryState;
    NTSTATUS                Status;

    //
    // Get power policy managers Battery State
    //

    Status = NtPowerInformation (
                SystemBatteryState,
                NULL,
                0,
                &BatteryState,
                sizeof (BatteryState)
                );

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // Convert it to the legacy System Power State structure
    //

    RtlZeroMemory (lpStatus, sizeof(*lpStatus));

    lpStatus->ACLineStatus = AC_LINE_ONLINE;
    if (BatteryState.BatteryPresent && !BatteryState.AcOnLine) {
        lpStatus->ACLineStatus = AC_LINE_OFFLINE;
    }

    if (BatteryState.Charging) {
        lpStatus->BatteryFlag |= BATTERY_FLAG_CHARGING;
    }

    if (!BatteryState.BatteryPresent) {
        lpStatus->BatteryFlag |= BATTERY_FLAG_NO_BATTERY;
    }

    lpStatus->BatteryLifePercent = BATTERY_PERCENTAGE_UNKNOWN;
    if (BatteryState.MaxCapacity) {
        if (BatteryState.RemainingCapacity > BatteryState.MaxCapacity) {

            //
            // Values greater than 100% should not be returned
            // According to the SDK they are reserved.
            //

            lpStatus->BatteryLifePercent = 100;
        } else {
            lpStatus->BatteryLifePercent = (UCHAR)
                (((BatteryState.RemainingCapacity * 100) +
                  (BatteryState.MaxCapacity/2)) /
                 BatteryState.MaxCapacity);
        }

        if (lpStatus->BatteryLifePercent > 66) {
            lpStatus->BatteryFlag |= BATTERY_FLAG_HIGH;
        }

        if (lpStatus->BatteryLifePercent < 33) {
            lpStatus->BatteryFlag |= BATTERY_FLAG_LOW;
        }
    }

    lpStatus->BatteryLifeTime = BATTERY_LIFE_UNKNOWN;
    lpStatus->BatteryFullLifeTime = BATTERY_LIFE_UNKNOWN;
    if (BatteryState.EstimatedTime) {
        lpStatus->BatteryLifeTime = BatteryState.EstimatedTime;
    }

    return TRUE;
}

BOOL
WINAPI
SetSystemPowerState(
    BOOL fSuspend,
    BOOL fForce
    )
{
    NTSTATUS        Status;

    Status = NtInitiatePowerAction (fSuspend ? PowerActionSleep : PowerActionHibernate,
                                    fSuspend ? PowerSystemSleeping1 : PowerSystemHibernate,
                                    fForce == TRUE ? 0 : POWER_ACTION_QUERY_ALLOWED,
                                    FALSE);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}


EXECUTION_STATE
WINAPI
SetThreadExecutionState(
    EXECUTION_STATE esFlags
    )
{
    NTSTATUS            Status;
    EXECUTION_STATE     PreviousFlags;

    Status = NtSetThreadExecutionState (esFlags, &PreviousFlags);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return (EXECUTION_STATE) 0;
    }

    return PreviousFlags;
}

BOOL
WINAPI
RequestWakeupLatency (
    LATENCY_TIME    latency
    )
{
    NTSTATUS        Status;

    Status = NtRequestWakeupLatency (latency);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
GetDevicePowerState(
    HANDLE  h,
    OUT BOOL *pfOn
    )
{
    NTSTATUS Status;
    DEVICE_POWER_STATE PowerState;

    Status = NtGetDevicePowerState(h, &PowerState);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return(FALSE);
    }
    if ((PowerState == PowerDeviceD0) ||
        (PowerState == PowerDeviceUnspecified)) {
        *pfOn = TRUE;
    } else {
        *pfOn = FALSE;
    }
    return TRUE;
}

BOOL
WINAPI
IsSystemResumeAutomatic(
    VOID
    )
{
    return(NtIsSystemResumeAutomatic());
}

BOOL
WINAPI
RequestDeviceWakeup (
    HANDLE  h
    )
{
    NTSTATUS Status;

    Status = NtRequestDeviceWakeup(h);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    } else {
        return(TRUE);
    }
}


BOOL
WINAPI
CancelDeviceWakeupRequest(
    HANDLE  h
    )
{
    NTSTATUS Status;

    Status = NtCancelDeviceWakeupRequest(h);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    } else {
        return(TRUE);
    }
}



BOOL
WINAPI
SetMessageWaitingIndicator (
    IN HANDLE hMsgIndicator,
    IN ULONG ulMsgCount
    )
{
    BaseSetLastNTError(STATUS_NOT_IMPLEMENTED);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\pperf.c ===
#include "stdio.h"
#include "string.h"
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"

#define SPD_PROCESS_ITERATIONS 15

//
// Define local types.
//

typedef struct _PERFINFO {
    LARGE_INTEGER StartTime;
    LARGE_INTEGER StopTime;
    ULONG ContextSwitches;
    ULONG InterruptCount;
    ULONG FirstLevelFills;
    ULONG SecondLevelFills;
    ULONG SystemCalls;
    PCHAR Title;
    ULONG Iterations;
} PERFINFO, *PPERFINFO;

VOID
SuspendedProcessTest(
    VOID
    );

VOID
FinishBenchMark (
    IN PPERFINFO PerfInfo
    );

VOID
StartBenchMark (
    IN PCHAR Title,
    IN ULONG Iterations,
    IN PPERFINFO PerfInfo
    );

VOID
main(
    int argc,
    char *argv[]
    )

{
    if ( !_strcmpi("just exit",GetCommandLine()) ) {
        return;
        }
    SuspendedProcessTest();
    return;
}

VOID
SuspendedProcessTest (
    VOID
    )

{

    PERFINFO PerfInfo;
    STARTUPINFO si;
    PROCESS_INFORMATION pi[SPD_PROCESS_ITERATIONS];
    BOOL b;
    int Index;
    CHAR Buffer[256];
    KPRIORITY Base;

    GetModuleFileName(0,Buffer,256);

    RtlZeroMemory(&si,sizeof(si));
    si.cb = sizeof(si);

    Base = 13;
    NtSetInformationProcess(
        NtCurrentProcess(),
        ProcessBasePriority,
        (PVOID) &Base,
        sizeof(Base)
        );
//    SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS);
    StartBenchMark("Suspended Process Creation Benchmark)",
                   SPD_PROCESS_ITERATIONS,
                   &PerfInfo);

    for (Index = 0; Index < SPD_PROCESS_ITERATIONS; Index += 1) {
        b = CreateProcess(
                Buffer,
                "just exit",
                NULL,
                NULL,
                TRUE,
                CREATE_SUSPENDED,
                NULL,
                NULL,
                &si,
                &pi[Index]
                );
        if ( !b ) {
            printf("failed %ld\n",Index);
            }
        }
    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);
//    SetPriorityClass(GetCurrentProcess(),NORMAL_PRIORITY_CLASS);

    StartBenchMark("Process Startup/Exit Benchmark)",
                   SPD_PROCESS_ITERATIONS,
                   &PerfInfo);
    for (Index = 0; Index < SPD_PROCESS_ITERATIONS; Index += 1) {
        ResumeThread(pi[Index].hThread);
        CloseHandle(pi[Index].hThread);
        WaitForSingleObject(pi[Index].hProcess,-1);
        CloseHandle(pi[Index].hProcess);
        }
    FinishBenchMark(&PerfInfo);

    //
    // End of event1 context switch test.
    //

    return;
}

VOID
FinishBenchMark (
    IN PPERFINFO PerfInfo
    )

{

    ULONG ContextSwitches;
    LARGE_INTEGER Duration;
    ULONG FirstLevelFills;
    ULONG InterruptCount;
    ULONG Length;
    ULONG Performance;
    ULONG SecondLevelFills;
    NTSTATUS Status;
    ULONG SystemCalls;
    SYSTEM_PERFORMANCE_INFORMATION SystemInfo;


    //
    // Print results and announce end of test.
    //

    NtQuerySystemTime((PLARGE_INTEGER)&PerfInfo->StopTime);
    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      (PVOID)&SystemInfo,
                                      sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                      NULL);

    if (NT_SUCCESS(Status) == FALSE) {
        printf("Failed to query performance information, status = %lx\n", Status);
        return;
    }

    Duration = RtlLargeIntegerSubtract(PerfInfo->StopTime, PerfInfo->StartTime);
    Length = Duration.LowPart / 10000;
    printf("        Test time in milliseconds %d\n", Length);
    printf("        Number of iterations      %d\n", PerfInfo->Iterations);

    Performance = PerfInfo->Iterations * 1000 / Length;
    printf("        Iterations per second     %d\n", Performance);

    ContextSwitches = SystemInfo.ContextSwitches - PerfInfo->ContextSwitches;
    FirstLevelFills = SystemInfo.FirstLevelTbFills - PerfInfo->FirstLevelFills;
    InterruptCount = SystemInfo.InterruptCount - PerfInfo->InterruptCount;
    SecondLevelFills = SystemInfo.SecondLevelTbFills - PerfInfo->SecondLevelFills;
    SystemCalls = SystemInfo.SystemCalls - PerfInfo->SystemCalls;
    printf("        First Level TB Fills      %d\n", FirstLevelFills);
    printf("        Second Level TB Fills     %d\n", SecondLevelFills);
    printf("        Number of Interrupts      %d\n", InterruptCount);
    printf("        Total Context Switches    %d\n", ContextSwitches);
    printf("        Number of System Calls    %d\n", SystemCalls);

    printf("*** End of Test ***\n\n");
    return;
}

VOID
StartBenchMark (
    IN PCHAR Title,
    IN ULONG Iterations,
    IN PPERFINFO PerfInfo
    )

{

    NTSTATUS Status;
    SYSTEM_PERFORMANCE_INFORMATION SystemInfo;

    //
    // Announce start of test and the number of iterations.
    //

    printf("*** Start of test ***\n    %s\n", Title);
    PerfInfo->Title = Title;
    PerfInfo->Iterations = Iterations;
    NtQuerySystemTime((PLARGE_INTEGER)&PerfInfo->StartTime);
    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      (PVOID)&SystemInfo,
                                      sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                      NULL);

    if (NT_SUCCESS(Status) == FALSE) {
        printf("Failed to query performance information, status = %lx\n", Status);
        return;
    }

    PerfInfo->ContextSwitches = SystemInfo.ContextSwitches;
    PerfInfo->FirstLevelFills = SystemInfo.FirstLevelTbFills;
    PerfInfo->InterruptCount = SystemInfo.InterruptCount;
    PerfInfo->SecondLevelFills = SystemInfo.SecondLevelTbFills;
    PerfInfo->SystemCalls = SystemInfo.SystemCalls;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\pathmisc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    pathmisc.c

Abstract:

    Win32 misceleneous path functions

Author:

    Mark Lucovsky (markl) 16-Oct-1990

Revision History:

--*/

#include "basedll.h"
#include "apcompat.h"
#include <wow64t.h>

BOOL
IsThisARootDirectory(
    HANDLE RootHandle,
    PUNICODE_STRING FileName OPTIONAL
    )
{
    PFILE_NAME_INFORMATION FileNameInfo;
    WCHAR Buffer[MAX_PATH+sizeof(FileNameInfo)];
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    BOOL rv;

    OBJECT_ATTRIBUTES Attributes;
    HANDLE LinkHandle;
    WCHAR LinkValueBuffer[2*MAX_PATH];
    UNICODE_STRING LinkValue;
    ULONG ReturnedLength;

    rv = FALSE;

    FileNameInfo = (PFILE_NAME_INFORMATION)Buffer;
    if (RootHandle == NULL) {
        Status = STATUS_INVALID_HANDLE;
    } else {
        Status = NtQueryInformationFile (RootHandle,
                                         &IoStatusBlock,
                                         FileNameInfo,
                                         sizeof(Buffer),
                                         FileNameInformation);
    }

    if (NT_SUCCESS (Status)) {
        if ( FileNameInfo->FileName[(FileNameInfo->FileNameLength>>1)-1] == (WCHAR)'\\' ) {
            rv = TRUE;
        }
    }

    if ( !rv ) {

        //
        // See if this is a dos substed drive (or) redirected net drive
        //

        if (ARGUMENT_PRESENT (FileName)) {

            FileName->Length = FileName->Length - sizeof((WCHAR)'\\');

            InitializeObjectAttributes( &Attributes,
                                        FileName,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL
                                      );
            Status = NtOpenSymbolicLinkObject (&LinkHandle,
                                               SYMBOLIC_LINK_QUERY,
                                               &Attributes);
            FileName->Length = FileName->Length + sizeof((WCHAR)'\\');
            if (NT_SUCCESS (Status)) {

                //
                // Now query the link and see if there is a redirection
                //

                LinkValue.Buffer = LinkValueBuffer;
                LinkValue.Length = 0;
                LinkValue.MaximumLength = (USHORT)(sizeof(LinkValueBuffer));
                ReturnedLength = 0;
                Status = NtQuerySymbolicLinkObject( LinkHandle,
                                                    &LinkValue,
                                                    &ReturnedLength
                                                  );
                NtClose( LinkHandle );

                if ( NT_SUCCESS(Status) ) {
                    rv = TRUE;
                }
            }

        }
    }
    return rv;
}


UINT
APIENTRY
GetSystemDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    )

/*++

Routine Description:

    ANSI thunk to GetSystemDirectoryW

--*/

{
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    ULONG cbAnsiString;
    PUNICODE_STRING WindowsSystemDirectory = &BaseWindowsSystemDirectory;

#ifdef WX86
    if (NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll) {
        NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = FALSE;
        WindowsSystemDirectory = &BaseWindowsSys32x86Directory;
        }
#endif



    // BaseWindowsSystemDirectory.Length contains the byte
    // count of unicode string.
    // Original code does "UnicodeLength / sizeof(WCHAR)" to
    // get the size of corresponding ansi string.
    // This is correct in SBCS environment. However in DBCS
    // environment, it's definitely WRONG.

    Status = RtlUnicodeToMultiByteSize(&cbAnsiString,
                                       WindowsSystemDirectory->Buffer,
                                       WindowsSystemDirectory->MaximumLength
                                       );
    if ( !NT_SUCCESS(Status) ) {
        return 0;
        }

    if ( (USHORT)uSize < (USHORT)cbAnsiString ) {
        return cbAnsiString;
        }

    AnsiString.MaximumLength = (USHORT)(uSize);
    AnsiString.Buffer = lpBuffer;

    Status = BasepUnicodeStringTo8BitString(
                &AnsiString,
                WindowsSystemDirectory,
                FALSE
                );
    if ( !NT_SUCCESS(Status) ) {
        return 0;
        }
    return AnsiString.Length;
}


UINT
APIENTRY
GetSystemDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    )

/*++

Routine Description:

    This function obtains the pathname of the Windows system
    subdirectory.  The system subdirectory contains such files as
    Windows libraries, drivers, and font files.

    The pathname retrieved by this function does not end with a
    backslash unless the system directory is the root directory.  For
    example, if the system directory is named WINDOWS\SYSTEM on drive
    C:, the pathname of the system subdirectory retrieved by this
    function is C:\WINDOWS\SYSTEM.

Arguments:

    lpBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the pathname.

    uSize - Specifies the maximum size (in WCHARs) of the buffer.  This
        value should be set to at least MAX_PATH to allow sufficient room in
        the buffer for the pathname.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than uSize, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/

{
    PUNICODE_STRING WindowsSystemDirectory = &BaseWindowsSystemDirectory;

#ifdef WX86
    if (NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll) {
        NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = FALSE;
        WindowsSystemDirectory = &BaseWindowsSys32x86Directory;
    }
#endif

    if ( uSize*2 < WindowsSystemDirectory->MaximumLength ) {
        return WindowsSystemDirectory->MaximumLength/2;
    }
    RtlCopyMemory(
        lpBuffer,
        WindowsSystemDirectory->Buffer,
        WindowsSystemDirectory->Length
        );
    lpBuffer[(WindowsSystemDirectory->Length>>1)] = UNICODE_NULL;
    return WindowsSystemDirectory->Length/2;
}

UINT
APIENTRY
GetSystemWindowsDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    )

/*++

Routine Description:

    ANSI thunk to GetSystemWindowsDirectoryW

--*/

{
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    ULONG cbAnsiString;

    // BaseWindowsDirectory.Length contains the byte
    // count of unicode string.
    // Original code does "UnicodeLength / sizeof(WCHAR)" to
    // get the size of corresponding ansi string.
    // This is correct in SBCS environment. However in DBCS
    // environment, it's definitely WRONG.

    Status = RtlUnicodeToMultiByteSize( &cbAnsiString,
                               BaseWindowsDirectory.Buffer,
                               BaseWindowsDirectory.MaximumLength);
    if ( !NT_SUCCESS(Status) ) {
        return 0;
    }

    if ( (USHORT)uSize < (USHORT)cbAnsiString ) {
        return cbAnsiString;
    }

    AnsiString.MaximumLength = (USHORT)(uSize);
    AnsiString.Buffer = lpBuffer;

    Status = BasepUnicodeStringTo8BitString(
                &AnsiString,
                &BaseWindowsDirectory,
                FALSE
                );
    if ( !NT_SUCCESS(Status) ) {
        return 0;
    }
    return AnsiString.Length;
}

UINT
APIENTRY
GetSystemWindowsDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    )

/*++

Routine Description:

    This function obtains the pathname of the system Windows directory.

Arguments:

    lpBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the pathname.

    uSize - Specifies the maximum size (in wchars) of the buffer.  This
        value should be set to at least MAX_PATH to allow sufficient room in
        the buffer for the pathname.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than uSize, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/

{

    if ( uSize*2 < BaseWindowsDirectory.MaximumLength ) {
        return BaseWindowsDirectory.MaximumLength/2;
    }
    RtlCopyMemory(
        lpBuffer,
        BaseWindowsDirectory.Buffer,
        BaseWindowsDirectory.Length
        );
    lpBuffer[(BaseWindowsDirectory.Length>>1)] = UNICODE_NULL;
    return BaseWindowsDirectory.Length/2;
}

UINT
APIENTRY
GetSystemWow64DirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    )

/*++

Routine Description:

    This function obtains the pathname of the system wow64 directory.

Arguments:

    lpBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the pathname.

    uSize - Specifies the maximum size (in bytes) of the buffer.  This
        value should be set to at least MAX_PATH to allow sufficient room in
        the buffer for the pathname.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than uSize, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/
{
#if ! defined(BUILD_WOW6432) && ! defined(_WIN64)

  SetLastError(ERROR_CALL_NOT_IMPLEMENTED);

  return 0;

#else // BUILD_WOW6432 || _WIN64

  const CHAR syswowdir[] = "\\" WOW64_SYSTEM_DIRECTORY;
  UINT Available, Needed;

  if (uSize < sizeof(syswowdir)) {

    // We don't even have enough room to hold the syswow64
    // subdirectory component, much less the whole path.  Pass in a
    // zero length so that we get back the length needed.
    Available = 0;

  } else {

    // We might have enough room; decrement the size passed in by the
    // amount of overhead we'll use.
    Available = uSize - sizeof(syswowdir) + 1 /* NULL compensation */;

  }

  Needed = GetSystemWindowsDirectoryA(lpBuffer, Available);

  if (Needed == 0) {

    // The call failed -- just return zero.
    return 0;

  }

  if (Needed <= Available) {

    // We had enough buffer space, even with our overhead; we can go
    // ahead and tack on the syswow64 directory name.

    RtlCopyMemory(lpBuffer + Needed,
          syswowdir,
          sizeof(syswowdir));
  }

  return (Needed + sizeof(syswowdir) - 1);

#endif // BUILD_WOW6432 || _WIN64
}

UINT
APIENTRY
GetSystemWow64DirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    )

/*++

Routine Description:

    This function obtains the pathname of the system wow64 directory.

Arguments:

    lpBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the pathname.

    uSize - Specifies the maximum size (in wchars) of the buffer.  This
        value should be set to at least MAX_PATH to allow sufficient room in
        the buffer for the pathname.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than uSize, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/
{
#if ! defined(BUILD_WOW6432) && ! defined(_WIN64)

  SetLastError(ERROR_CALL_NOT_IMPLEMENTED);

  return 0;

#else // BUILD_WOW6432 || _WIN64

  const WCHAR syswowdir[] = L"\\" WOW64_SYSTEM_DIRECTORY_U;
  UINT Available, Needed;
  const UINT SysWCharSize = sizeof(syswowdir) / sizeof(WCHAR);

  if (uSize < SysWCharSize) {

    // We don't even have enough room to hold the syswow64
    // subdirectory component, much less the whole path.  Pass in a
    // zero length so that we get back the length needed.
    Available = 0;

  } else {

    // We might have enough room; decrement the size passed in by the
    // amount of overhead we'll use.
    Available = uSize - SysWCharSize + 1 /* NULL compensation */;

  }

  Needed = GetSystemWindowsDirectoryW(lpBuffer, Available);

  if (Needed == 0) {

    // The call failed -- just return zero.
    return 0;

  }

  if (Needed <= Available) {

    // We had enough buffer space, even with our overhead; we can go
    // ahead and tack on the syswow64 directory name.

    RtlCopyMemory(lpBuffer + Needed,
          syswowdir,
          sizeof(syswowdir));
  }

  return (Needed + SysWCharSize - 1);

#endif // BUILD_WOW6432 || _WIN64
}


UINT
APIENTRY
GetWindowsDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    )

/*++

Routine Description:


--*/

{

    if (gpTermsrvGetWindowsDirectoryA) {

        //
        //  If Terminal Server get the Per User Windows Directory
        //

        UINT retval;
        if (retval = gpTermsrvGetWindowsDirectoryA(lpBuffer, uSize)) {
            return retval;
        }
    }


    return GetSystemWindowsDirectoryA(lpBuffer,uSize);
}

UINT
APIENTRY
GetWindowsDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    )

/*++

Routine Description:

    This function obtains the pathname of the Windows directory.  The
    Windows directory contains such files as Windows applications,
    initialization files, and help files.
    425
    The pathname retrieved by this function does not end with a
    backslash unless the Windows directory is the root directory.  For
    example, if the Windows directory is named WINDOWS on drive C:, the
    pathname of the Windows directory retrieved by this function is
    C:\WINDOWS If Windows was installed in the root directory of drive
    C:, the pathname retrieved by this function is C:\

Arguments:

    lpBuffer - Points to the buffer that is to receive the
        null-terminated character string containing the pathname.

    uSize - Specifies the maximum size (in bytes) of the buffer.  This
        value should be set to at least MAX_PATH to allow sufficient room in
        the buffer for the pathname.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than uSize, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/

{
    if (gpTermsrvGetWindowsDirectoryW) {
        //
        //  If Terminal Server get the Per User Windows Directory
        //

        UINT retval;
        if (retval = gpTermsrvGetWindowsDirectoryW(lpBuffer, uSize)) {
            return retval;
        }
    }

    return GetSystemWindowsDirectoryW(lpBuffer,uSize);

}



UINT
APIENTRY
GetDriveTypeA(
    LPCSTR lpRootPathName
    )

/*++

Routine Description:

    ANSI thunk to GetDriveTypeW

--*/

{
    PUNICODE_STRING Unicode;
    LPCWSTR lpRootPathName_U;

    if (ARGUMENT_PRESENT(lpRootPathName)) {
        Unicode = Basep8BitStringToStaticUnicodeString( lpRootPathName );
        if (Unicode == NULL) {
            return 1;
        }

        lpRootPathName_U = (LPCWSTR)Unicode->Buffer;
        }
    else {
        lpRootPathName_U = NULL;
        }

    return GetDriveTypeW(lpRootPathName_U);
}

UINT
APIENTRY
GetDriveTypeW(
    LPCWSTR lpRootPathName
    )

/*++

Routine Description:

    This function determines whether a disk drive is removeable, fixed,
    remote, CD ROM, or a RAM disk.

    The return value is zero if the function cannot determine the drive
    type, or 1 if the specified root directory does not exist.

Arguments:

    lpRootPathName - An optional parameter, that if specified, supplies
        the root directory of the disk whose drive type is to be
        determined.  If this parameter is not specified, then the root
        of the current directory is used.

Return Value:

    The return value specifies the type of drive.  It can be one of the
    following values:

    DRIVE_UNKNOWN - The drive type can not be determined.

    DRIVE_NO_ROOT_DIR - The root directory does not exist.

    DRIVE_REMOVABLE - Disk can be removed from the drive.

    DRIVE_FIXED - Disk cannot be removed from the drive.

    DRIVE_REMOTE - Drive is a remote (network) drive.

    DRIVE_CDROM - Drive is a CD rom drive.

    DRIVE_RAMDISK - Drive is a RAM disk.

--*/

{
    WCHAR wch;
    ULONG n, DriveNumber;
    WCHAR DefaultPath[MAX_PATH];
    PWSTR RootPathName;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName, volumeNameString;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    PVOID FreeBuffer;
    DWORD ReturnValue;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;
    PROCESS_DEVICEMAP_INFORMATION ProcessDeviceMapInfo;
    WCHAR volumeName[MAX_PATH];

    if (!ARGUMENT_PRESENT(lpRootPathName)) {
        n = RtlGetCurrentDirectory_U(sizeof(DefaultPath), DefaultPath);
        RootPathName = DefaultPath;
        if (n > (3 * sizeof(WCHAR))) {
            RootPathName[3]=UNICODE_NULL;
            }
        }
    else
    if (lpRootPathName == (PWSTR)IntToPtr(0xFFFFFFFF)) {
        //
        // Hack to be compatible with undocumented feature of old
        // implementation.
        //

        return 0;
        }
    else {
        //
        // If input string is just C: then convert to C:\ so it does
        // not default to current directory which may or may not be
        // at the root.
        //
        RootPathName = (PWSTR)lpRootPathName;
        if (wcslen( RootPathName ) == 2) {
            wch = RtlUpcaseUnicodeChar( *RootPathName );
            if (wch >= (WCHAR)'A' &&
                wch <= (WCHAR)'Z' &&
                RootPathName[1] == (WCHAR)':'
               ) {
                RootPathName = wcscpy(DefaultPath, lpRootPathName);
                RootPathName[2] = (WCHAR)'\\';
                RootPathName[3] = UNICODE_NULL;
                }
            }
        }

    //
    // If input string is of the form C:\ then look in the drive letter
    // cache maintained by the kernel to see if the drive type is already
    // known.
    //
    wch = RtlUpcaseUnicodeChar( *RootPathName );
    if (wch >= (WCHAR)'A' &&
        wch <= (WCHAR)'Z' &&
        RootPathName[1]==(WCHAR)':' &&
        RootPathName[2]==(WCHAR)'\\' &&
        RootPathName[3]==UNICODE_NULL
       ) {
        Status = NtQueryInformationProcess( NtCurrentProcess(),
                                            ProcessDeviceMap,
                                            &ProcessDeviceMapInfo.Query,
                                            sizeof( ProcessDeviceMapInfo.Query ),
                                            NULL
                                          );
        if (!NT_SUCCESS( Status )) {
            RtlZeroMemory( &ProcessDeviceMapInfo, sizeof( ProcessDeviceMapInfo ) );
            }

        DriveNumber = wch - (WCHAR)'A';
        if (ProcessDeviceMapInfo.Query.DriveMap & (1 << DriveNumber)) {
            switch ( ProcessDeviceMapInfo.Query.DriveType[ DriveNumber ] ) {
                case DOSDEVICE_DRIVE_UNKNOWN:
                    return DRIVE_UNKNOWN;

                case DOSDEVICE_DRIVE_REMOVABLE:
                    return DRIVE_REMOVABLE;

                case DOSDEVICE_DRIVE_FIXED:
                    return DRIVE_FIXED;

                case DOSDEVICE_DRIVE_REMOTE:
                    return DRIVE_REMOTE;

                case DOSDEVICE_DRIVE_CDROM:
                    return DRIVE_CDROM;

                case DOSDEVICE_DRIVE_RAMDISK:
                    return DRIVE_RAMDISK;
                }
            }
        }


    //
    // Either not C:\ or kernel does not know the drive type, so try to
    // calculate the drive type by opening the root directory and doing
    // a query volume information.
    //


    //
    // If curdir is a UNC connection, and default path is used,
    // the RtlGetCurrentDirectory logic is wrong, so throw it away.
    //

    if (!ARGUMENT_PRESENT(lpRootPathName)) {
        RootPathName = L"\\";
        }

    TranslationStatus = RtlDosPathNameToNtPathName_U( RootPathName,
                                                      &FileName,
                                                      NULL,
                                                      NULL
                                                    );
    if (!TranslationStatus) {
        return DRIVE_NO_ROOT_DIR;
        }
    FreeBuffer = FileName.Buffer;

    //
    // Check to make sure a root was specified
    //

    if (FileName.Buffer[(FileName.Length >> 1)-1] != '\\') {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        return DRIVE_NO_ROOT_DIR;
        }

    FileName.Length -= 2;
    InitializeObjectAttributes( &Obja,
                                &FileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    //
    // Open the file
    //
    Status = NtOpenFile( &Handle,
                         (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                       );

    //
    //
    // substd drives are really directories, so if we are dealing with one
    // of them, bypass this
    //

    if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {

        if (BasepGetVolumeNameFromReparsePoint(lpRootPathName, volumeName,
                                               MAX_PATH, NULL)) {

            RtlInitUnicodeString(&volumeNameString, volumeName);

            volumeNameString.Buffer[1] = '?';
            volumeNameString.Length -= sizeof(WCHAR);

            InitializeObjectAttributes( &Obja,
                                        &volumeNameString,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL
                                      );

            }

            Status = NtOpenFile(
                        &Handle,
                        (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_NONALERT
                        );
        }

    else {

        //
        // check for substed drives another way just in case
        //

        FileName.Length = FileName.Length + sizeof((WCHAR)'\\');
        if (!IsThisARootDirectory(NULL,&FileName) ) {
            FileName.Length = FileName.Length - sizeof((WCHAR)'\\');
            if (NT_SUCCESS(Status)) {
                NtClose(Handle);
                }
            Status = NtOpenFile(
                        &Handle,
                        (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_NONALERT
                        );
            }
        }
    RtlFreeHeap( RtlProcessHeap(), 0, FreeBuffer );
    if (!NT_SUCCESS( Status )) {
        return DRIVE_NO_ROOT_DIR;
        }

    //
    // Determine if this is a network or disk file system. If it
    // is a disk file system determine if this is removable or not
    //

    Status = NtQueryVolumeInformationFile( Handle,
                                           &IoStatusBlock,
                                           &DeviceInfo,
                                           sizeof(DeviceInfo),
                                           FileFsDeviceInformation
                                         );
    if (!NT_SUCCESS( Status )) {
        ReturnValue = DRIVE_UNKNOWN;
        }
    else
    if (DeviceInfo.Characteristics & FILE_REMOTE_DEVICE) {
        ReturnValue = DRIVE_REMOTE;
        }
    else {
        switch (DeviceInfo.DeviceType) {

            case FILE_DEVICE_NETWORK:
            case FILE_DEVICE_NETWORK_FILE_SYSTEM:
                ReturnValue = DRIVE_REMOTE;
                break;

            case FILE_DEVICE_CD_ROM:
            case FILE_DEVICE_CD_ROM_FILE_SYSTEM:
                ReturnValue = DRIVE_CDROM;
                break;

            case FILE_DEVICE_VIRTUAL_DISK:
                ReturnValue = DRIVE_RAMDISK;
                break;

            case FILE_DEVICE_DISK:
            case FILE_DEVICE_DISK_FILE_SYSTEM:

                if ( DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA ) {
                    ReturnValue = DRIVE_REMOVABLE;
                    }
                else {
                    ReturnValue = DRIVE_FIXED;
                    }
                break;

            default:
                ReturnValue = DRIVE_UNKNOWN;
                break;
            }
        }

    NtClose( Handle );
    return ReturnValue;
}

DWORD
APIENTRY
SearchPathA(
    LPCSTR lpPath,
    LPCSTR lpFileName,
    LPCSTR lpExtension,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    )

/*++

Routine Description:

    ANSI thunk to SearchPathW

--*/

{

    UNICODE_STRING xlpPath;
    PUNICODE_STRING Unicode;
    UNICODE_STRING xlpExtension;
    PWSTR xlpBuffer;
    DWORD ReturnValue;
    NTSTATUS Status;
    PWSTR FilePart;
    PWSTR *FilePartPtr;

    if ( ARGUMENT_PRESENT(lpFilePart) ) {
        FilePartPtr = &FilePart;
        }
    else {
        FilePartPtr = NULL;
        }

    Unicode = Basep8BitStringToStaticUnicodeString( lpFileName );
    if (Unicode == NULL) {
        return 0;
    }

    if ( ARGUMENT_PRESENT(lpExtension) ) {

        if (!Basep8BitStringToDynamicUnicodeString( &xlpExtension, lpExtension )) {
            return 0;
        }

    } else {
        xlpExtension.Buffer = NULL;
    }

    if ( ARGUMENT_PRESENT(lpPath) ) {

        if (!Basep8BitStringToDynamicUnicodeString( &xlpPath, lpPath )) {
            if ( ARGUMENT_PRESENT(lpExtension) ) {
                RtlFreeUnicodeString(&xlpExtension);
            }
            return 0;
        }
    } else {
        xlpPath.Buffer = NULL;
    }

    xlpBuffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), nBufferLength<<1);
    if ( !xlpBuffer ) {
        BaseSetLastNTError(STATUS_NO_MEMORY);
        ReturnValue = 0;
        goto bail0;
        }
    ReturnValue = SearchPathW(
                    xlpPath.Buffer,
                    Unicode->Buffer,
                    xlpExtension.Buffer,
                    nBufferLength,
                    xlpBuffer,
                    FilePartPtr
                    );
    //
    // === DBCS modification note [takaok] ===
    //
    // SearchPathW retruns:
    //
    //   buffer size needed(including null terminator) if buffer size is too small.
    //   number of characters( not including null terminator) if buffer size is enougth
    //
    // This means SearchPathW never returns value which is equal to nBufferLength.
    //

    if ( ReturnValue > nBufferLength ) {
        //
        // To know the ansi buffer size needed, we should get all of
        // unicode string.
        //
        RtlFreeHeap(RtlProcessHeap(), 0,xlpBuffer);
        xlpBuffer = RtlAllocateHeap(RtlProcessHeap(),
                                    MAKE_TAG( TMP_TAG ),
                                    ReturnValue * sizeof(WCHAR));
        if ( !xlpBuffer ) {
            BaseSetLastNTError(STATUS_NO_MEMORY);
            goto bail0;
        }
        ReturnValue = SearchPathW(
                        xlpPath.Buffer,
                        Unicode->Buffer,
                        xlpExtension.Buffer,
                        ReturnValue,
                        xlpBuffer,
                        FilePartPtr
                        );
        if ( ReturnValue > 0 ) {
            //
            // We called SearchPathW with the enough size of buffer.
            // So, ReturnValue is the size of the path not including the
            // terminating null character.
            //
            Status = RtlUnicodeToMultiByteSize( &ReturnValue,
                                       xlpBuffer,
                                       ReturnValue * sizeof(WCHAR));
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                ReturnValue = 0;
            }
            else {
                ReturnValue += 1;
            }
        }
    } else if ( ReturnValue > 0 ) {

        INT AnsiByteCount;

        //
        // We have unicode string. We need to compute the ansi byte count
        // of the string.
        //
        // ReturnValue   : unicode character count not including null terminator
        // AnsiByteCount : ansi byte count not including null terminator
        //
        Status = RtlUnicodeToMultiByteSize( &AnsiByteCount,
                                   xlpBuffer,
                                   ReturnValue * sizeof(WCHAR) );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            ReturnValue = 0;
            }
        else {
            if ( AnsiByteCount < (INT)nBufferLength ) {
            //
            // The string (including null terminator) fits to the buffer
            //
                Status = RtlUnicodeToMultiByteN ( lpBuffer,
                                                  nBufferLength - 1,
                                                  &AnsiByteCount,
                                                  xlpBuffer,
                                                  ReturnValue * sizeof(WCHAR)
                                                );
                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(Status);
                    ReturnValue = 0;
                }
                else {

                    lpBuffer[ AnsiByteCount ] = '\0';

                    //
                    // The return value is the byte count copied to the buffer
                    // not including the terminating null character.
                    //
                    ReturnValue = AnsiByteCount;


                    if ( ARGUMENT_PRESENT(lpFilePart) ) {
                        if ( FilePart == NULL ) {
                            *lpFilePart = NULL;
                        } else {

                            INT PrefixLength;

                            PrefixLength = (INT)(FilePart - xlpBuffer);
                            Status = RtlUnicodeToMultiByteSize( &PrefixLength,
                                                       xlpBuffer,
                                                       PrefixLength * sizeof(WCHAR));
                            if ( !NT_SUCCESS(Status) ) {
                                BaseSetLastNTError(Status);
                                ReturnValue = 0;
                            }
                            else {
                                *lpFilePart = lpBuffer + PrefixLength;
                            }
                        }
                    }
                }

            } else {
            //
            // We should return the size of the buffer required to
            // hold the path. The size should include the
            // terminating null character.
            //
                ReturnValue = AnsiByteCount + 1;

            }
        }
    }

    RtlFreeHeap(RtlProcessHeap(), 0,xlpBuffer);
bail0:
    if ( ARGUMENT_PRESENT(lpExtension) ) {
        RtlFreeUnicodeString(&xlpExtension);
        }

    if ( ARGUMENT_PRESENT(lpPath) ) {
        RtlFreeUnicodeString(&xlpPath);
        }
    return ReturnValue;
}



#ifdef WX86

ULONG
GetFullPathNameWithWx86Override(
    PCWSTR lpFileName,
    ULONG nBufferLength,
    PWSTR lpBuffer,
    PWSTR *lpFilePart
    )
{
    UNICODE_STRING FullPathName, PathUnicode, Wx86PathName;
    PUNICODE_STRING FoundFileName;
    RTL_PATH_TYPE PathType;
    PWSTR FilePart;
    ULONG Length, LengthPath;
    ULONG  PathNameLength;

    FullPathName.Buffer = NULL;
    Wx86PathName.Buffer = NULL;

    if (lpFilePart) {
        *lpFilePart = NULL;
        }

    FullPathName.MaximumLength = (USHORT)(MAX_PATH * sizeof(WCHAR)) + sizeof(WCHAR);
    FullPathName.Length = 0;
    FullPathName.Buffer = RtlAllocateHeap(RtlProcessHeap(),
                                          MAKE_TAG( TMP_TAG ),
                                          FullPathName.MaximumLength
                                          );
    if (!FullPathName.Buffer) {
        PathNameLength = 0;
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto WDOExitCleanup;
        }

    FoundFileName = &FullPathName;
    PathNameLength = RtlGetFullPathName_U(lpFileName,
                                          FullPathName.MaximumLength,
                                          FullPathName.Buffer,
                                          &FilePart
                                          );

    if (!PathNameLength || PathNameLength >= FullPathName.MaximumLength) {
        PathNameLength = 0;
        goto WDOExitCleanup;
        }

    FullPathName.Length = (USHORT)PathNameLength;


    PathUnicode = FullPathName;
    PathUnicode.Length = (USHORT)((ULONG_PTR)FilePart -
                                  (ULONG_PTR)FullPathName.Buffer);

    PathUnicode.Length -= sizeof(WCHAR);
    if (!RtlEqualUnicodeString(&PathUnicode, &BaseWindowsSystemDirectory, TRUE)) {
        goto WDOExitCleanup;
        }


    Wx86PathName.MaximumLength = BaseWindowsSys32x86Directory.Length +
                                 FullPathName.Length - PathUnicode.Length +
                                 2*sizeof(WCHAR);
    Wx86PathName.Length = 0;
    Wx86PathName.Buffer = RtlAllocateHeap(RtlProcessHeap(),
                                          MAKE_TAG( TMP_TAG ),
                                          Wx86PathName.MaximumLength
                                          );

    if (!Wx86PathName.Buffer) {
        goto WDOExitCleanup;
        }

    RtlCopyUnicodeString(&Wx86PathName, &BaseWindowsSys32x86Directory);
    Length = Wx86PathName.Length + sizeof(WCHAR);
    RtlAppendUnicodeToString (&Wx86PathName, FilePart - 1);
    if (RtlDoesFileExists_U(Wx86PathName.Buffer)) {
        FoundFileName = &Wx86PathName;
        FilePart = Wx86PathName.Buffer + Length/sizeof(WCHAR);
        }



WDOExitCleanup:

    if (PathNameLength) {
        if (FoundFileName->Length >= nBufferLength) {
            PathNameLength = FoundFileName->Length + sizeof(WCHAR);
            }
        else {
            RtlMoveMemory(lpBuffer,
                          FoundFileName->Buffer,
                          FoundFileName->Length + sizeof(WCHAR)
                          );

            PathNameLength = FoundFileName->Length;
            Length = (ULONG)(FilePart - FoundFileName->Buffer);

            if (lpFilePart) {
                *lpFilePart = lpBuffer + Length/sizeof(WCHAR);
                }
            }
        }


    if (FullPathName.Buffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, FullPathName.Buffer);
        }

    if (Wx86PathName.Buffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, Wx86PathName.Buffer);
        }

    return PathNameLength;

}
#endif










DWORD
APIENTRY
SearchPathW(
    LPCWSTR lpPath,
    LPCWSTR lpFileName,
    LPCWSTR lpExtension,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    )

/*++

Routine Description:

    This function is used to search for a file specifying a search path
    and a filename.  It returns with a fully qualified pathname of the
    found file.

    This function is used to locate a file using the specified path.  If
    the file is found, its fully qualified pathname is returned.  In
    addition to this, it calculates the address of the file name portion
    of the fully qualified pathname.

Arguments:

    lpPath - An optional parameter, that if specified, supplies the
        search path to be used when locating the file.  If this
        parameter is not specified, the default windows search path is
        used.  The default path is:

          - The current directory

          - The windows directory

          - The windows system directory

          - The directories listed in the path environment variable

    lpFileName - Supplies the file name of the file to search for.

    lpExtension - An optional parameter, that if specified, supplies an
        extension to be added to the filename when doing the search.
        The extension is only added if the specified filename does not
        end with an extension.

    nBufferLength - Supplies the length in characters of the buffer that
        is to receive the fully qualified path.

    lpBuffer - Returns the fully qualified pathname corresponding to the
        file that was found.

    lpFilePart - Returns the address of the last component of the fully
        qualified pathname.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than nBufferLength, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/

{
    UNICODE_STRING Path;
    UNICODE_STRING FileName;
    UNICODE_STRING DefaultExtension;
    UNICODE_STRING CallersBuffer;
    LPWSTR AllocatedPath = NULL;
    SIZE_T BytesRequired = 0;
    SIZE_T FilePartPrefixCch = 0;
    NTSTATUS Status;
    DWORD dwReturnValue = 0;

    //
    //  The guts of this function are now in common ntdll code; however the win32 search
    //  path has a few interesting differences from the ntdll search path code.  First, it
    //  does not search the path if the filename is ".\foo" or "..\foo" and second, when the
    //  filename passed in is not a relative path but the file is not found, the default
    //  extension is applied regardless of whether the existing filename has an extension.
    //
    //  These flags enable those feature-compatibility modes.
    //
    ULONG SearchPathFlags =
        RTL_DOS_SEARCH_PATH_FLAG_DISALLOW_DOT_RELATIVE_PATH_SEARCH |
        RTL_DOS_SEARCH_PATH_FLAG_APPLY_DEFAULT_EXTENSION_WHEN_NOT_RELATIVE_PATH_EVEN_IF_FILE_HAS_EXTENSION;

    if (lpFilePart != NULL)
        *lpFilePart = NULL;

    Path.Buffer = NULL;

    RtlInitUnicodeString(&FileName, lpFileName);

    //
    // trim trailing spaces, and then check for a real filelength
    // if length is 0 (NULL, "", or " ") passed in then abort the
    // search
    //

    while ((FileName.Length >= sizeof(WCHAR)) &&
           (FileName.Buffer[(FileName.Length / sizeof(WCHAR)) - 1] == L' '))
        FileName.Length -= sizeof(WCHAR);

    if (FileName.Length == 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    RtlInitUnicodeString(&DefaultExtension, lpExtension);

    if ( !ARGUMENT_PRESENT(lpPath) ) {
        SIZE_T Cch;

        Path.Buffer = BaseComputeProcessSearchPath();
        if (Path.Buffer == NULL) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Exit;
        }

        Cch = lstrlenW(Path.Buffer);

        if (Cch > UNICODE_STRING_MAX_CHARS) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            goto Exit;
        }

        Path.Length = (USHORT) (Cch * sizeof(WCHAR));
        Path.MaximumLength = Path.Length;
        SearchPathFlags |= RTL_DOS_SEARCH_PATH_FLAG_APPLY_ISOLATION_REDIRECTION;
    } else {
        Status = RtlInitUnicodeStringEx(&Path, lpPath);
        if (NT_ERROR(Status)) {
            BaseSetLastNTError(Status);
            goto Exit;
        }
    }

    CallersBuffer.Length = 0;

    if (nBufferLength > UNICODE_STRING_MAX_CHARS) {
        CallersBuffer.MaximumLength = UNICODE_STRING_MAX_BYTES;
    } else {
        CallersBuffer.MaximumLength = (USHORT) (nBufferLength * sizeof(WCHAR));
    }
    CallersBuffer.Buffer = lpBuffer;

    Status = RtlDosSearchPath_Ustr(
        SearchPathFlags,
        &Path,
        &FileName,
        &DefaultExtension,
        &CallersBuffer,
        NULL,               // dynamicstring
        NULL,               // fullfilenameout
        &FilePartPrefixCch,
        &BytesRequired);
    if (NT_ERROR(Status)) {

#if DBG
        // Don't bother with debug spew for the two common expected cases.
        if ((Status != STATUS_NO_SUCH_FILE) && (Status != STATUS_BUFFER_TOO_SMALL)) {
            DbgPrint("%s on file %wZ failed; NTSTATUS = %08lx\n", __FUNCTION__, &FileName, Status);
            DbgPrint("   Path = %wZ\n", &Path);
        }
#endif // DBG

        if (Status == STATUS_BUFFER_TOO_SMALL) {
            SIZE_T CchRequired = BytesRequired / sizeof(WCHAR);
            if (CchRequired > 0xffffffff) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                goto Exit;
            }
            dwReturnValue = (DWORD) CchRequired;
            goto Exit;
        }

        // Only set the last error if it wasn't an insufficient buffer; this is just preserving
        // Windows 2000 behavior.
        BaseSetLastNTError(Status);
        goto Exit;
    }

#ifdef WX86
    if (UseKnownWx86Dll) {
        WCHAR TempBuffer[MAX_PATH];

        RtlCopyMemory(TempBuffer, lpBuffer, CallersBuffer.Length);
        TempBuffer[CallersBuffer.Length / sizeof(WCHAR)] = UNICODE_NULL;

        dwReturnValue = GetFullPathNameWithWx86Override(
                 TempBuffer,
                 nBufferLength,
                 lpBuffer,
                 lpFilePart
                 );
        goto Exit;

    } else if (lpFilePart != NULL) {
        *lpFilePart = lpBuffer + FilePartPrefixCch;
    }
#else
    if (lpFilePart != NULL) {
        *lpFilePart = lpBuffer + FilePartPrefixCch;
    }
#endif // WX86

    dwReturnValue = CallersBuffer.Length / sizeof(WCHAR);

Exit:
    if ((Path.Buffer != lpPath) && (Path.Buffer != NULL))
        RtlFreeHeap(RtlProcessHeap(), 0, Path.Buffer);

    return dwReturnValue;
}


DWORD
APIENTRY
GetTempPathA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    )

/*++

Routine Description:

    ANSI thunk to GetTempPathW

--*/

{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    ULONG  cbAnsiString;

    UnicodeString.MaximumLength = (USHORT)((nBufferLength<<1)+sizeof(UNICODE_NULL));
    UnicodeString.Buffer = RtlAllocateHeap(
                                RtlProcessHeap(), MAKE_TAG( TMP_TAG ),
                                UnicodeString.MaximumLength
                                );
    if ( !UnicodeString.Buffer ) {
        BaseSetLastNTError(STATUS_NO_MEMORY);
        return 0;
        }
    UnicodeString.Length = (USHORT)GetTempPathW(
                                        (DWORD)(UnicodeString.MaximumLength-sizeof(UNICODE_NULL))/2,
                                        UnicodeString.Buffer
                                        )*2;
    if ( UnicodeString.Length > (USHORT)(UnicodeString.MaximumLength-sizeof(UNICODE_NULL)) ) {
        RtlFreeHeap(RtlProcessHeap(), 0,UnicodeString.Buffer);

        //
        // given buffer size is too small.
        // allocate enough size of buffer and try again
        //
        // we need to get entire unicode temporary path
        // otherwise we can't figure out the exact length
        // of corresponding ansi string (cbAnsiString).

        UnicodeString.Buffer = RtlAllocateHeap ( RtlProcessHeap(),
                                                 MAKE_TAG( TMP_TAG ),
                                                 UnicodeString.Length+ sizeof(UNICODE_NULL));
        if ( !UnicodeString.Buffer ) {
            BaseSetLastNTError(STATUS_NO_MEMORY);
            return 0;
            }

        UnicodeString.Length = (USHORT)GetTempPathW(
                                     (DWORD)(UnicodeString.Length)/2,
                                     UnicodeString.Buffer) * 2;
        Status = RtlUnicodeToMultiByteSize( &cbAnsiString,
                                            UnicodeString.Buffer,
                                            UnicodeString.Length );
        if ( !NT_SUCCESS(Status) ) {
            RtlFreeHeap(RtlProcessHeap(), 0, UnicodeString.Buffer);
            BaseSetLastNTError(Status);
            return 0;
            }
        else if ( nBufferLength <= cbAnsiString ) {
            RtlFreeHeap(RtlProcessHeap(), 0, UnicodeString.Buffer);
            return cbAnsiString + sizeof(ANSI_NULL);
            }
        }
    AnsiString.Buffer = lpBuffer;
    AnsiString.MaximumLength = (USHORT)(nBufferLength+1);
    Status = BasepUnicodeStringTo8BitString(&AnsiString,&UnicodeString,FALSE);
    RtlFreeHeap(RtlProcessHeap(), 0,UnicodeString.Buffer);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return 0;
        }
    return AnsiString.Length;
}

DWORD
APIENTRY
GetTempPathW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    )
/*++

Routine Description:

    This function is used to return the pathname of the directory that
    should be used to create temporary files.

Arguments:

    nBufferLength - Supplies the length in bytes of the buffer that is
        to receive the temporary file path.

    lpBuffer - Returns the pathname of the directory that should be used
        to create temporary files in.

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than nSize, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/
{
    return BasepGetTempPathW(0, nBufferLength, lpBuffer);
}

DWORD
APIENTRY
BasepGetTempPathW(
    ULONG  Flags,
    DWORD nBufferLength,
    LPWSTR lpBuffer
    )

/*++

Routine Description:

    This function is used to return the pathname of the directory that
    should be used to create temporary files.

Arguments:

    nBufferLength - Supplies the length in bytes of the buffer that is
        to receive the temporary file path.

    lpBuffer - Returns the pathname of the directory that should be used
        to create temporary files in.

    Flags -

Return Value:

    The return value is the length of the string copied to lpBuffer, not
    including the terminating null character.  If the return value is
    greater than nSize, the return value is the size of the buffer
    required to hold the pathname.  The return value is zero if the
    function failed.

--*/

{

    DWORD Length;
    BOOLEAN AddTrailingSlash;
    UNICODE_STRING EnvironmentValue;
    NTSTATUS Status;
    LPWSTR Name;
    ULONG Position;
    DWORD ReturnLength;

    if (
        (Flags & ~BASEP_GET_TEMP_PATH_PRESERVE_TEB) != 0
        ) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER_1);
        return 0;
    }

    //
    // Some apps don't work with the new long path for the temp directory
    //

    if (APPCOMPATFLAG(KACF_GETTEMPPATH)) {

        #define OLD_TEMP_PATH       L"c:\\temp\\"
        #define OLD_TEMP_PATH_SIZE  (sizeof(OLD_TEMP_PATH) / sizeof(WCHAR))

        BOOL bRet;

        //
        // If there isn't enough space provided in the buffer return
        // the desired size.
        //

        if (nBufferLength < OLD_TEMP_PATH_SIZE) {
            return OLD_TEMP_PATH_SIZE;
        }

        wcscpy(lpBuffer, OLD_TEMP_PATH);

        //
        // Use the correct drive letter
        //

        lpBuffer[0] = BaseWindowsDirectory.Buffer[0];

        bRet = CreateDirectoryW(lpBuffer, NULL);

        if (!bRet) {

            if (GetLastError() != ERROR_ALREADY_EXISTS)
                return 0;
        }

        return OLD_TEMP_PATH_SIZE - 1;
    }

    nBufferLength *= 2;
    EnvironmentValue = NtCurrentTeb()->StaticUnicodeString;
    if (Flags & BASEP_GET_TEMP_PATH_PRESERVE_TEB) {
        EnvironmentValue.Buffer = (PWSTR)RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), EnvironmentValue.MaximumLength);
        if (EnvironmentValue.Buffer == NULL) {
            BaseSetLastNTError(STATUS_NO_MEMORY);
            return 0;
        }
    }

    ReturnLength = 0;
    __try {

        AddTrailingSlash = FALSE;

        Status = RtlQueryEnvironmentVariable_U(NULL,&BaseTmpVariableName,&EnvironmentValue);
        if ( !NT_SUCCESS(Status) ) {
            Status = RtlQueryEnvironmentVariable_U(NULL,&BaseTempVariableName,&EnvironmentValue);
            if ( !NT_SUCCESS(Status) ) {
                Status = RtlQueryEnvironmentVariable_U(NULL,&BaseUserProfileVariableName,&EnvironmentValue);
            }
        }

        if ( NT_SUCCESS(Status) ) {
            Name = EnvironmentValue.Buffer;
            if ( Name[(EnvironmentValue.Length>>1)-1] != (WCHAR)'\\' ) {
                AddTrailingSlash = TRUE;
            }
        }
        else {
            Name = BaseWindowsDirectory.Buffer;
            if ( Name[(BaseWindowsDirectory.Length>>1)-1] != (WCHAR)'\\' ) {
                AddTrailingSlash = TRUE;
            }
        }

        Length = RtlGetFullPathName_U(
                    Name,
                    nBufferLength,
                    lpBuffer,
                    NULL
                    );
        Position = Length>>1;

        //
        // Make sure there is room for a trailing back slash
        //

        if ( Length && Length < nBufferLength ) {
            if ( lpBuffer[Position-1] != '\\' ) {
                if ( Length+sizeof((WCHAR)'\\') < nBufferLength ) {
                    lpBuffer[Position] = (WCHAR)'\\';
                    lpBuffer[Position+1] = UNICODE_NULL;
                    ReturnLength = (Length+sizeof((WCHAR)'\\'))/2;
                    __leave;
                    }
                else {
                    ReturnLength = (Length+sizeof((WCHAR)'\\')+sizeof(UNICODE_NULL))/2;
                    __leave;
                    }
                }
            else {
                ReturnLength = Length/2;
                __leave;
            }
        }
        else {
            if ( AddTrailingSlash ) {
                Length += sizeof((WCHAR)'\\');
            }
            ReturnLength = Length/2;
            __leave;
        }

    }
    __finally {
        if (Flags & BASEP_GET_TEMP_PATH_PRESERVE_TEB) {
            RtlFreeHeap(RtlProcessHeap(), 0, EnvironmentValue.Buffer);
        }
    }

    return ReturnLength;
}

UINT
APIENTRY
GetTempFileNameA(
    LPCSTR lpPathName,
    LPCSTR lpPrefixString,
    UINT uUnique,
    LPSTR lpTempFileName
    )

/*++

Routine Description:

    ANSI thunk to GetTempFileNameW

--*/

{
    PUNICODE_STRING Unicode;
    UNICODE_STRING UnicodePrefix;
    NTSTATUS Status;
    UINT ReturnValue;
    UNICODE_STRING UnicodeResult;

    Unicode = Basep8BitStringToStaticUnicodeString( lpPathName );
    if (Unicode == NULL) {
        return 0;
    }

    if (!Basep8BitStringToDynamicUnicodeString( &UnicodePrefix, lpPrefixString )) {
        return 0;
    }

    UnicodeResult.MaximumLength = (USHORT)((MAX_PATH<<1));
    UnicodeResult.Buffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), UnicodeResult.MaximumLength);
    if ( !UnicodeResult.Buffer ) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        RtlFreeUnicodeString(&UnicodePrefix);
        return 0;
        }

    ReturnValue = GetTempFileNameW(
                    Unicode->Buffer,
                    UnicodePrefix.Buffer,
                    uUnique,
                    UnicodeResult.Buffer
                    );
    if ( ReturnValue ) {
        ANSI_STRING AnsiString;

        RtlInitUnicodeString(&UnicodeResult,UnicodeResult.Buffer);
        AnsiString.Buffer = lpTempFileName;
        AnsiString.MaximumLength = MAX_PATH;
        Status = BasepUnicodeStringTo8BitString(&AnsiString,&UnicodeResult,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            ReturnValue = 0;
            }
        }
    RtlFreeUnicodeString(&UnicodePrefix);
    RtlFreeHeap(RtlProcessHeap(), 0,UnicodeResult.Buffer);

    return ReturnValue;
}

UINT
APIENTRY
GetTempFileNameW(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
    )

/*++

Routine Description:

    This function creates a temporary filename of the following form:

        drive:\path\prefixuuuu.tmp

    In this syntax line, drive:\path\ is the path specified by the
    lpPathName parameter; prefix is all the letters (up to the first
    three) of the string pointed to by the lpPrefixString parameter; and
    uuuu is the hexadecimal value of the number specified by the
    uUnique parameter.

    To avoid problems resulting from converting OEM character an string
    to an ANSI string, an application should call the CreateFile
    function to create the temporary file.

    If the uUnique parameter is zero, GetTempFileName attempts to form a
    unique number based on the current system time.  If a file with the
    resulting filename exists, the number is increased by one and the
    test for existence is repeated.  This continues until a unique
    filename is found; GetTempFileName then creates a file by that name
    and closes it.  No attempt is made to create and open the file when
    uUnique is nonzero.

Arguments:

    lpPathName - Specifies the null terminated pathname of the directory
        to create the temporary file within.

    lpPrefixString - Points to a null-terminated character string to be
        used as the temporary filename prefix.  This string must consist
        of characters in the OEM-defined character set.

    uUnique - Specifies an unsigned integer.

    lpTempFileName - Points to the buffer that is to receive the
        temporary filename.  This string consists of characters in the
        OEM-defined character set.  This buffer should be at least MAX_PATH
        characters in length to allow sufficient room for the pathname.

Return Value:

    The return value specifies a unique numeric value used in the
    temporary filename.  If a nonzero value was given for the uUnique
    parameter, the return value specifies this same number.

--*/

{
#if !defined(BUILD_WOW6432)
    BASE_API_MSG m;
    PBASE_GETTEMPFILE_MSG a = &m.u.GetTempFile;
#endif
    LPWSTR p,savedp;
    ULONG Length;
    HANDLE FileHandle;
    ULONG PassCount;
    DWORD LastError;
    UNICODE_STRING UnicodePath, UnicodePrefix;
    CHAR UniqueAsAnsi[8];
    CHAR *c;
    ULONG i;

#if defined(BUILD_WOW6432)
    UINT uNewUnique;
#endif

    PassCount = 0;
    RtlInitUnicodeString(&UnicodePath,lpPathName);
    Length = UnicodePath.Length;

    if ( !Length || lpPathName[(Length>>1)-1] != (WCHAR)'\\' ) {
        Length += sizeof(UNICODE_NULL);
    }

    // Length is the number of bytes of data in lpPathName, *not*
    // including the trailing NULL but including the whack.
    // 12 is the number of characters we might append, including the
    // trailing NULL but not including the whack -- preXXXX.tmp\0.
    if (Length > ((MAX_PATH - 12) * sizeof(WCHAR))) {
        SetLastError(ERROR_BUFFER_OVERFLOW);
        return FALSE;
    }

    if (lpTempFileName != lpPathName) {

        // N.B. Must use RtlMoveMemory here -- some callers depend on
        // lpPathName and lpTempFileName overlapping.

        RtlMoveMemory(lpTempFileName,lpPathName,UnicodePath.Length);
    }

    lpTempFileName[(Length>>1)-1] = UNICODE_NULL;
    i = GetFileAttributesW(lpTempFileName);
    if (i == 0xFFFFFFFF) {
        lpTempFileName[(Length>>1)-1] = (WCHAR)'\\';
        lpTempFileName[(Length>>1)] = UNICODE_NULL;
        i = GetFileAttributesW(lpTempFileName);
        lpTempFileName[(Length>>1)-1] = UNICODE_NULL;
    }
    if ( (i == 0xFFFFFFFF) ||
         !(i & FILE_ATTRIBUTE_DIRECTORY) ) {
        SetLastError(ERROR_DIRECTORY);
        return FALSE;
    }
    lpTempFileName[(Length>>1)-1] = (WCHAR)'\\';

    RtlInitUnicodeString(&UnicodePrefix,lpPrefixString);
    if ( UnicodePrefix.Length > (USHORT)6 ) {
        UnicodePrefix.Length = (USHORT)6;
    }
    p = &lpTempFileName[Length>>1];
    Length = UnicodePrefix.Length;
    RtlMoveMemory(p,lpPrefixString,Length);
    p += (Length>>1);
    savedp = p;
    //
    // If uUnique is not specified, then get one
    //

    uUnique = uUnique & 0x0000ffff;

try_again:
    p = savedp;
    if ( !uUnique ) {

#if defined(BUILD_WOW6432)
        uNewUnique = CsrBasepGetTempFile();
        if ( uNewUnique == 0 ) {
#else
        CsrClientCallServer( (PCSR_API_MSG)&m,
                             NULL,
                             CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                                  BasepGetTempFile
                                                ),
                             sizeof( *a )
                           );
        a->uUnique = (UINT)m.ReturnValue;
        if ( m.ReturnValue == 0 ) {
#endif

            PassCount++;
            if ( PassCount & 0xffff0000 ) {
                return 0;
            }
            goto try_again;
        }
    } else {
#if defined(BUILD_WOW6432)
        uNewUnique = uUnique;
#else
        a->uUnique = uUnique;
#endif
    }

    //
    // Convert the unique value to a 4 byte character string
    //

#if defined(BUILD_WOW6432)
    RtlIntegerToChar ((ULONG) uNewUnique,16,5,UniqueAsAnsi);
#else
    RtlIntegerToChar ((ULONG) a->uUnique,16,5,UniqueAsAnsi);
#endif
    c = UniqueAsAnsi;
    for(i=0;i<4;i++){
        *p = RtlAnsiCharToUnicodeChar(&c);
        if ( *p == UNICODE_NULL ) {
            break;
        }
        p++;
    }
    RtlMoveMemory(p,BaseDotTmpSuffixName.Buffer,BaseDotTmpSuffixName.MaximumLength);

    if ( !uUnique ) {

        //
        // test for resulting name being a device (prefix com, uUnique 1-9...
        //

        if ( RtlIsDosDeviceName_U(lpTempFileName) ) {
            PassCount++;
            if ( PassCount & 0xffff0000 ) {
                SetLastError(ERROR_INVALID_NAME);
                return 0;
                }
            goto try_again;
        }

        FileHandle = CreateFileW(
                        lpTempFileName,
                        GENERIC_READ,
                        0,
                        NULL,
                        CREATE_NEW,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        //
        // If the create worked, then we are ok. Just close the file.
        // Otherwise, try again.
        //

        if ( FileHandle != INVALID_HANDLE_VALUE ) {
            NtClose(FileHandle);
        } else {

            //
            // NTRAID#60021-2002/03/14-earhart: This test should be
            // inverted when time permits sufficient testing to nail
            // down the error codes that would indicate is is
            // reasonable to continue the loop as opposed to stop the
            // loop. All it currently takes is CreateFile coming back
            // with an error we don't know about to make us spin here
            // for a long time.
            //

            LastError = GetLastError();
            switch (LastError) {
                case ERROR_INVALID_PARAMETER     :
                case ERROR_WRITE_PROTECT         :
                case ERROR_FILE_NOT_FOUND        :
                case ERROR_BAD_PATHNAME          :
                case ERROR_INVALID_NAME          :
                case ERROR_PATH_NOT_FOUND        :
                case ERROR_NETWORK_ACCESS_DENIED :
                case ERROR_DISK_CORRUPT          :
                case ERROR_FILE_CORRUPT          :
                case ERROR_DISK_FULL             :
                case ERROR_CANNOT_MAKE           :
                    return 0;
                case ERROR_ACCESS_DENIED         :
                    // It's possible for us to hit this if there's a
                    // directory with the name we're trying; in that
                    // case, we can usefully continue.
                    // CreateFile() uses BaseSetLastNTError() to set
                    // LastStatusValue to the actual NT error in the
                    // TEB; we just need to check it, and only abort
                    // if it's not a directory.
                    // This was bug #397477.
                    if (NtCurrentTeb()->LastStatusValue
                        != STATUS_FILE_IS_A_DIRECTORY)
                        return 0;
            }

            PassCount++;
            if ( PassCount & 0xffff0000 ) {
                return 0;
            }
            goto try_again;
        }
    }
#if defined(BUILD_WOW6432)
    return uNewUnique;
#else
    return a->uUnique;
#endif
}

BOOL
APIENTRY
GetDiskFreeSpaceA(
    LPCSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    )

/*++

Routine Description:

    ANSI thunk to GetDiskFreeSpaceW

--*/

{
    PUNICODE_STRING Unicode;

    if (!ARGUMENT_PRESENT( lpRootPathName )) {
        lpRootPathName = "\\";
    }

    Unicode = Basep8BitStringToStaticUnicodeString( lpRootPathName );
    if (Unicode == NULL) {
        return FALSE;
    }

    return ( GetDiskFreeSpaceW(
                (LPCWSTR)Unicode->Buffer,
                lpSectorsPerCluster,
                lpBytesPerSector,
                lpNumberOfFreeClusters,
                lpTotalNumberOfClusters
                )
            );
}

BOOL
APIENTRY
GetDiskFreeSpaceW(
    LPCWSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    )

#define MAKE2GFRIENDLY(lpOut, dwSize)                                           \
                                                                                \
    if (!bAppHack) {                                                            \
        *lpOut =  dwSize;                                                       \
    } else {                                                                    \
        dwTemp = SizeInfo.SectorsPerAllocationUnit * SizeInfo.BytesPerSector;   \
                                                                                \
        if (0x7FFFFFFF / dwTemp < dwSize) {                                     \
                                                                                \
            *lpOut = 0x7FFFFFFF / dwTemp;                                       \
        } else {                                                                \
            *lpOut =  dwSize;                                                   \
        }                                                                       \
    }



/*++

Routine Description:

    The free space on a disk and the size parameters can be returned
    using GetDiskFreeSpace.

Arguments:

    lpRootPathName - An optional parameter, that if specified, supplies
        the root directory of the disk whose free space is to be
        returned for.  If this parameter is not specified, then the root
        of the current directory is used.

    lpSectorsPerCluster - Returns the number of sectors per cluster
        where a cluster is the allocation granularity on the disk.

    lpBytesPerSector - Returns the number of bytes per sector.

    lpNumberOfFreeClusters - Returns the total number of free clusters
        on the disk.

    lpTotalNumberOfClusters - Returns the total number of clusters on
        the disk.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    PVOID FreeBuffer;
    FILE_FS_SIZE_INFORMATION SizeInfo;
    WCHAR DefaultPath[2];
    DWORD dwTemp;
    BOOL  bAppHack;

    DefaultPath[0] = (WCHAR)'\\';
    DefaultPath[1] = UNICODE_NULL;

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            ARGUMENT_PRESENT(lpRootPathName) ? lpRootPathName : DefaultPath,
                            &FileName,
                            NULL,
                            NULL
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_FREE_SPACE_QUERY
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

        //
        // Prior releases of NT where these parameters were not optional
        // zeroed out this field even in the failure case.  Some applications
        // failed to check the return value from this function and instead
        // relied on this side effect.  I'm putting that back now so the apps
        // can still treat an unformatted volume as a zero size volume.
        //

        if (ARGUMENT_PRESENT( lpBytesPerSector )) {
            *lpBytesPerSector = 0;
            }
        return FALSE;
        }

    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    //
    // Determine the size parameters of the volume.
    //

    Status = NtQueryVolumeInformationFile(
                Handle,
                &IoStatusBlock,
                &SizeInfo,
                sizeof(SizeInfo),
                FileFsSizeInformation
                );
    NtClose(Handle);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    //
    // See if the calling process needs hack to work with HDD > 2GB
    // 2GB is 0x80000000 bytes and some apps treat that as a signed LONG.
    //

    if (APPCOMPATFLAG(KACF_GETDISKFREESPACE)) {

        bAppHack = TRUE;
    } else {
        bAppHack = FALSE;
    }

    //
    // Deal with 64 bit sizes
    //

    if ( SizeInfo.TotalAllocationUnits.HighPart ) {
        SizeInfo.TotalAllocationUnits.LowPart = (ULONG)-1;
        }
    if ( SizeInfo.AvailableAllocationUnits.HighPart ) {
        SizeInfo.AvailableAllocationUnits.LowPart = (ULONG)-1;
        }

    if (ARGUMENT_PRESENT( lpSectorsPerCluster )) {
        *lpSectorsPerCluster = SizeInfo.SectorsPerAllocationUnit;
        }
    if (ARGUMENT_PRESENT( lpBytesPerSector )) {
        *lpBytesPerSector = SizeInfo.BytesPerSector;
        }
    if (ARGUMENT_PRESENT( lpNumberOfFreeClusters )) {
        MAKE2GFRIENDLY(lpNumberOfFreeClusters, SizeInfo.AvailableAllocationUnits.LowPart);
        }
    if (ARGUMENT_PRESENT( lpTotalNumberOfClusters )) {
        MAKE2GFRIENDLY(lpTotalNumberOfClusters, SizeInfo.TotalAllocationUnits.LowPart);
        }

    return TRUE;
}

WINBASEAPI
BOOL
WINAPI
GetDiskFreeSpaceExA(
    LPCSTR lpDirectoryName,
    PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER lpTotalNumberOfBytes,
    PULARGE_INTEGER lpTotalNumberOfFreeBytes
    )
{
    PUNICODE_STRING Unicode;

    if (!ARGUMENT_PRESENT( lpDirectoryName )) {
        lpDirectoryName = "\\";
    }

    Unicode = Basep8BitStringToStaticUnicodeString( lpDirectoryName );
    if (Unicode == NULL) {
        return FALSE;
    }

    return ( GetDiskFreeSpaceExW(
                (LPCWSTR)Unicode->Buffer,
                lpFreeBytesAvailableToCaller,
                lpTotalNumberOfBytes,
                lpTotalNumberOfFreeBytes
                )
            );
}


WINBASEAPI
BOOL
WINAPI
GetDiskFreeSpaceExW(
    LPCWSTR lpDirectoryName,
    PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER lpTotalNumberOfBytes,
    PULARGE_INTEGER lpTotalNumberOfFreeBytes
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    PVOID FreeBuffer;
    union {
        FILE_FS_SIZE_INFORMATION Normal;
        FILE_FS_FULL_SIZE_INFORMATION Full;
    } SizeInfo;

    WCHAR DefaultPath[2];
    ULARGE_INTEGER BytesPerAllocationUnit;
    ULARGE_INTEGER FreeBytesAvailableToCaller;
    ULARGE_INTEGER TotalNumberOfBytes;

    DefaultPath[0] = (WCHAR)'\\';
    DefaultPath[1] = UNICODE_NULL;

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            ARGUMENT_PRESENT(lpDirectoryName) ? lpDirectoryName : DefaultPath,
                            &FileName,
                            NULL,
                            NULL
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                0,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_FREE_SPACE_QUERY
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        if ( GetLastError() == ERROR_FILE_NOT_FOUND ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            }
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        return FALSE;
        }

    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    //
    // If the caller wants the volume total then try to get a full
    // file size.
    //

    if ( ARGUMENT_PRESENT(lpTotalNumberOfFreeBytes) ) {

        Status = NtQueryVolumeInformationFile(
                    Handle,
                    &IoStatusBlock,
                    &SizeInfo,
                    sizeof(SizeInfo.Full),
                    FileFsFullSizeInformation
                    );

        if ( NT_SUCCESS(Status) ) {

            NtClose(Handle);

            BytesPerAllocationUnit.QuadPart =
                SizeInfo.Full.BytesPerSector * SizeInfo.Full.SectorsPerAllocationUnit;

            if ( ARGUMENT_PRESENT(lpFreeBytesAvailableToCaller) ) {
                lpFreeBytesAvailableToCaller->QuadPart =
                    BytesPerAllocationUnit.QuadPart *
                    SizeInfo.Full.CallerAvailableAllocationUnits.QuadPart;
                }
            if ( ARGUMENT_PRESENT(lpTotalNumberOfBytes) ) {
                lpTotalNumberOfBytes->QuadPart =
                    BytesPerAllocationUnit.QuadPart * SizeInfo.Full.TotalAllocationUnits.QuadPart;
                }
            lpTotalNumberOfFreeBytes->QuadPart =
                BytesPerAllocationUnit.QuadPart *
                SizeInfo.Full.ActualAvailableAllocationUnits.QuadPart;

            return TRUE;
        }
    }

    //
    // Determine the size parameters of the volume.
    //

    Status = NtQueryVolumeInformationFile(
                Handle,
                &IoStatusBlock,
                &SizeInfo,
                sizeof(SizeInfo.Normal),
                FileFsSizeInformation
                );
    NtClose(Handle);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    BytesPerAllocationUnit.QuadPart =
        SizeInfo.Normal.BytesPerSector * SizeInfo.Normal.SectorsPerAllocationUnit;

    FreeBytesAvailableToCaller.QuadPart =
        BytesPerAllocationUnit.QuadPart * SizeInfo.Normal.AvailableAllocationUnits.QuadPart;

    TotalNumberOfBytes.QuadPart =
        BytesPerAllocationUnit.QuadPart * SizeInfo.Normal.TotalAllocationUnits.QuadPart;

    if ( ARGUMENT_PRESENT(lpFreeBytesAvailableToCaller) ) {
        lpFreeBytesAvailableToCaller->QuadPart = FreeBytesAvailableToCaller.QuadPart;
        }
    if ( ARGUMENT_PRESENT(lpTotalNumberOfBytes) ) {
        lpTotalNumberOfBytes->QuadPart = TotalNumberOfBytes.QuadPart;
        }
    if ( ARGUMENT_PRESENT(lpTotalNumberOfFreeBytes) ) {
        lpTotalNumberOfFreeBytes->QuadPart = FreeBytesAvailableToCaller.QuadPart;
        }

    return TRUE;
}

BOOL
APIENTRY
GetVolumeInformationA(
    LPCSTR lpRootPathName,
    LPSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    LPSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    )

/*++

Routine Description:

    ANSI thunk to GetVolumeInformationW

--*/

{
    PUNICODE_STRING Unicode;
    NTSTATUS Status;
    UNICODE_STRING UnicodeVolumeName;
    UNICODE_STRING UnicodeFileSystemName;
    ANSI_STRING AnsiVolumeName;
    ANSI_STRING AnsiFileSystemName;
    BOOL ReturnValue;

    if (!ARGUMENT_PRESENT( lpRootPathName )) {
        lpRootPathName = "\\";
    }

    Unicode = Basep8BitStringToStaticUnicodeString( lpRootPathName );
    if (Unicode == NULL) {
        return FALSE;
    }

    UnicodeVolumeName.Buffer = NULL;
    UnicodeFileSystemName.Buffer = NULL;
    UnicodeVolumeName.MaximumLength = 0;
    UnicodeFileSystemName.MaximumLength = 0;
    AnsiVolumeName.Buffer = lpVolumeNameBuffer;
    AnsiVolumeName.MaximumLength = (USHORT)(nVolumeNameSize+1);
    AnsiFileSystemName.Buffer = lpFileSystemNameBuffer;
    AnsiFileSystemName.MaximumLength = (USHORT)(nFileSystemNameSize+1);

    try {
        if ( ARGUMENT_PRESENT(lpVolumeNameBuffer) ) {
            UnicodeVolumeName.MaximumLength = AnsiVolumeName.MaximumLength << 1;
            UnicodeVolumeName.Buffer = RtlAllocateHeap(
                                            RtlProcessHeap(), MAKE_TAG( TMP_TAG ),
                                            UnicodeVolumeName.MaximumLength
                                            );

            if ( !UnicodeVolumeName.Buffer ) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                ReturnValue = FALSE;
                leave;
            }
        }

        if ( ARGUMENT_PRESENT(lpFileSystemNameBuffer) ) {
            UnicodeFileSystemName.MaximumLength = AnsiFileSystemName.MaximumLength << 1;
            UnicodeFileSystemName.Buffer = RtlAllocateHeap(
                                                RtlProcessHeap(), MAKE_TAG( TMP_TAG ),
                                                UnicodeFileSystemName.MaximumLength
                                                );

            if ( !UnicodeFileSystemName.Buffer ) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                ReturnValue = FALSE;
                leave;
            }
        }

        ReturnValue = GetVolumeInformationW(
                            (LPCWSTR)Unicode->Buffer,
                            UnicodeVolumeName.Buffer,
                            nVolumeNameSize,
                            lpVolumeSerialNumber,
                            lpMaximumComponentLength,
                            lpFileSystemFlags,
                            UnicodeFileSystemName.Buffer,
                            nFileSystemNameSize
                            );

        if ( ReturnValue ) {

            if ( ARGUMENT_PRESENT(lpVolumeNameBuffer) ) {
                RtlInitUnicodeString(
                    &UnicodeVolumeName,
                    UnicodeVolumeName.Buffer
                    );

                Status = BasepUnicodeStringTo8BitString(
                            &AnsiVolumeName,
                            &UnicodeVolumeName,
                            FALSE
                            );

                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(Status);
                    ReturnValue = FALSE;
                    leave;
                }
            }

            if ( ARGUMENT_PRESENT(lpFileSystemNameBuffer) ) {
                RtlInitUnicodeString(
                    &UnicodeFileSystemName,
                    UnicodeFileSystemName.Buffer
                    );

                Status = BasepUnicodeStringTo8BitString(
                            &AnsiFileSystemName,
                            &UnicodeFileSystemName,
                            FALSE
                            );

                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(Status);
                    ReturnValue = FALSE;
                    leave;
                    }
                }
            }
        }
    finally {
        if ( UnicodeVolumeName.Buffer ) {
            RtlFreeHeap(RtlProcessHeap(), 0,UnicodeVolumeName.Buffer);
            }
        if ( UnicodeFileSystemName.Buffer ) {
            RtlFreeHeap(RtlProcessHeap(), 0,UnicodeFileSystemName.Buffer);
            }
        }

    return ReturnValue;
}

BOOL
APIENTRY
GetVolumeInformationW(
    LPCWSTR lpRootPathName,
    LPWSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    LPWSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    )

/*++

Routine Description:

    This function returns information about the file system whose root
    directory is specified.

Arguments:

    lpRootPathName - An optional parameter, that if specified, supplies
        the root directory of the file system that information is to be
        returned about.  If this parameter is not specified, then the
        root of the current directory is used.

    lpVolumeNameBuffer - An optional parameter that if specified returns
        the name of the specified volume.

    nVolumeNameSize - Supplies the length of the volume name buffer.
        This parameter is ignored if the volume name buffer is not
        supplied.

    lpVolumeSerialNumber - An optional parameter that if specified
        points to a DWORD.  The DWORD contains the 32-bit of the volume
        serial number.

    lpMaximumComponentLength - An optional parameter that if specified
        returns the maximum length of a filename component supported by
        the specified file system.  A filename component is that portion
        of a filename between pathname seperators.

    lpFileSystemFlags - An optional parameter that if specified returns
        flags associated with the specified file system.

        lpFileSystemFlags Flags:

            FS_CASE_IS_PRESERVED - Indicates that the case of file names
                is preserved when the name is placed on disk.

            FS_CASE_SENSITIVE - Indicates that the file system supports
                case sensitive file name lookup.

            FS_UNICODE_STORED_ON_DISK - Indicates that the file system
                supports unicode in file names as they appear on disk.

    lpFileSystemNameBuffer - An optional parameter that if specified returns
        the name for the specified file system (e.g. FAT, HPFS...).

    nFileSystemNameSize - Supplies the length of the file system name
        buffer.  This parameter is ignored if the file system name
        buffer is not supplied.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    PVOID FreeBuffer;
    PFILE_FS_ATTRIBUTE_INFORMATION AttributeInfo;
    PFILE_FS_VOLUME_INFORMATION VolumeInfo;
    ULONG AttributeInfoLength;
    ULONG VolumeInfoLength;
    WCHAR DefaultPath[2];
    BOOL rv;
    ULONG OriginalErrorMode;

    rv = FALSE;
    DefaultPath[0] = (WCHAR)'\\';
    DefaultPath[1] = UNICODE_NULL;

    nVolumeNameSize *= 2;
    nFileSystemNameSize *= 2;

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            ARGUMENT_PRESENT(lpRootPathName) ? lpRootPathName : DefaultPath,
                            &FileName,
                            NULL,
                            NULL
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
    }

    FreeBuffer = FileName.Buffer;

    //
    // Check to make sure a root was specified
    //

    if ( FileName.Buffer[(FileName.Length >> 1)-1] != '\\' ) {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
        return FALSE;
    }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    AttributeInfo = NULL;
    VolumeInfo = NULL;

    //
    // Open the file
    //
    RtlSetThreadErrorMode(RTL_ERRORMODE_FAILCRITICALERRORS,
                          &OriginalErrorMode);

    Status = NtOpenFile(
                &Handle,
                SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                0,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                );

    RtlSetThreadErrorMode(OriginalErrorMode, NULL);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        return FALSE;
    }

    if ( !IsThisARootDirectory(Handle,&FileName) ) {
        NtClose(Handle);
        SetLastError(ERROR_DIR_NOT_ROOT);
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        return FALSE;
    }
    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    if ( ARGUMENT_PRESENT(lpVolumeNameBuffer) ||
         ARGUMENT_PRESENT(lpVolumeSerialNumber) ) {
        if ( ARGUMENT_PRESENT(lpVolumeNameBuffer) ) {
            VolumeInfoLength = sizeof(*VolumeInfo)+nVolumeNameSize;
        } else {
            VolumeInfoLength = sizeof(*VolumeInfo)+MAX_PATH;
        }
        VolumeInfo = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), VolumeInfoLength);

        if ( !VolumeInfo ) {
            NtClose(Handle);
            BaseSetLastNTError(STATUS_NO_MEMORY);
            return FALSE;
        }
    }

    if ( ARGUMENT_PRESENT(lpFileSystemNameBuffer) ||
         ARGUMENT_PRESENT(lpMaximumComponentLength) ||
         ARGUMENT_PRESENT(lpFileSystemFlags) ) {
        if ( ARGUMENT_PRESENT(lpFileSystemNameBuffer) ) {
            AttributeInfoLength = sizeof(*AttributeInfo) + nFileSystemNameSize;
        } else {
            AttributeInfoLength = sizeof(*AttributeInfo) + MAX_PATH;
        }
        AttributeInfo = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), AttributeInfoLength);
        if ( !AttributeInfo ) {
            NtClose(Handle);
            if ( VolumeInfo ) {
                RtlFreeHeap(RtlProcessHeap(), 0,VolumeInfo);
            }
            BaseSetLastNTError(STATUS_NO_MEMORY);
            return FALSE;
        }
    }

    try {
        if ( VolumeInfo ) {
            Status = NtQueryVolumeInformationFile(
                        Handle,
                        &IoStatusBlock,
                        VolumeInfo,
                        VolumeInfoLength,
                        FileFsVolumeInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                rv = FALSE;
                goto finally_exit;
            }
        }

        if ( AttributeInfo ) {
            Status = NtQueryVolumeInformationFile(
                        Handle,
                        &IoStatusBlock,
                        AttributeInfo,
                        AttributeInfoLength,
                        FileFsAttributeInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                rv = FALSE;
                goto finally_exit;
            }
        }
        try {

            if ( ARGUMENT_PRESENT(lpVolumeNameBuffer) ) {
                if ( VolumeInfo->VolumeLabelLength >= nVolumeNameSize ) {
                    SetLastError(ERROR_BAD_LENGTH);
                    rv = FALSE;
                    goto finally_exit;
                } else {
                    RtlCopyMemory( lpVolumeNameBuffer,
                                   VolumeInfo->VolumeLabel,
                                   VolumeInfo->VolumeLabelLength );

                    *(lpVolumeNameBuffer + (VolumeInfo->VolumeLabelLength >> 1)) = UNICODE_NULL;
                }
            }

            if ( ARGUMENT_PRESENT(lpVolumeSerialNumber) ) {
                *lpVolumeSerialNumber = VolumeInfo->VolumeSerialNumber;
            }

            if ( ARGUMENT_PRESENT(lpFileSystemNameBuffer) ) {

                if ( AttributeInfo->FileSystemNameLength >= nFileSystemNameSize ) {
                    SetLastError(ERROR_BAD_LENGTH);
                    rv = FALSE;
                    goto finally_exit;
                } else {
                    RtlCopyMemory( lpFileSystemNameBuffer,
                                   AttributeInfo->FileSystemName,
                                   AttributeInfo->FileSystemNameLength );

                    *(lpFileSystemNameBuffer + (AttributeInfo->FileSystemNameLength >> 1)) = UNICODE_NULL;
                }
            }

            if ( ARGUMENT_PRESENT(lpMaximumComponentLength) ) {
                *lpMaximumComponentLength = AttributeInfo->MaximumComponentNameLength;
            }

            if ( ARGUMENT_PRESENT(lpFileSystemFlags) ) {
                *lpFileSystemFlags = AttributeInfo->FileSystemAttributes;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            BaseSetLastNTError(STATUS_ACCESS_VIOLATION);
            rv = FALSE;
            goto finally_exit;
        }
        rv = TRUE;
finally_exit:;
    } finally {
        NtClose(Handle);
        if ( VolumeInfo ) {
            RtlFreeHeap(RtlProcessHeap(), 0,VolumeInfo);
        }
        if ( AttributeInfo ) {
            RtlFreeHeap(RtlProcessHeap(), 0,AttributeInfo);
        }
    }
    return rv;
}

DWORD
APIENTRY
GetLogicalDriveStringsA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    )
{
    ULONG DriveMap;
    ANSI_STRING RootName;
    int i;
    PUCHAR Dst;
    DWORD BytesLeft;
    DWORD BytesNeeded;
    BOOL WeFailed;
    CHAR szDrive[] = "A:\\";

    BytesNeeded = 0;
    BytesLeft = nBufferLength;
    Dst = (PUCHAR)lpBuffer;
    WeFailed = FALSE;

    RtlInitAnsiString(&RootName, szDrive);
    DriveMap = GetLogicalDrives();
    for ( i=0; i<26; i++ ) {
        RootName.Buffer[0] = (CHAR)((CHAR)i+'A');
        if (DriveMap & (1 << i) ) {

            BytesNeeded += RootName.MaximumLength;
            if ( BytesNeeded < (USHORT)BytesLeft ) {
                RtlCopyMemory(Dst,RootName.Buffer,RootName.MaximumLength);
                Dst += RootName.MaximumLength;
                *Dst = '\0';
            } else {
                WeFailed = TRUE;
            }
        }
    }

    if ( WeFailed ) {
        BytesNeeded++;
    }
    //
    // Need to handle network uses;
    //

    return( BytesNeeded );
}

DWORD
APIENTRY
GetLogicalDriveStringsW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    )
{
    ULONG DriveMap;
    UNICODE_STRING RootName;
    int i;
    PUCHAR Dst;
    DWORD BytesLeft;
    DWORD BytesNeeded;
    BOOL WeFailed;
    WCHAR wszDrive[] = L"A:\\";

    nBufferLength = nBufferLength*2;
    BytesNeeded = 0;
    BytesLeft = nBufferLength;
    Dst = (PUCHAR)lpBuffer;
    WeFailed = FALSE;

    RtlInitUnicodeString(&RootName, wszDrive);

    DriveMap = GetLogicalDrives();
    for ( i=0; i<26; i++ ) {
        RootName.Buffer[0] = (WCHAR)((CHAR)i+'A');
        if (DriveMap & (1 << i) ) {

            BytesNeeded += RootName.MaximumLength;
            if ( BytesNeeded < (USHORT)BytesLeft ) {
                RtlCopyMemory(Dst,RootName.Buffer,RootName.MaximumLength);
                Dst += RootName.MaximumLength;
                *(PWSTR)Dst = UNICODE_NULL;
            } else {
                WeFailed = TRUE;
            }
        }
    }

    if ( WeFailed ) {
        BytesNeeded += 2;
    }

    //
    // Need to handle network uses;
    //

    return( BytesNeeded/2 );
}

BOOL
WINAPI
SetVolumeLabelA(
    LPCSTR lpRootPathName,
    LPCSTR lpVolumeName
    )
{
    PUNICODE_STRING Unicode;
    UNICODE_STRING UnicodeVolumeName;
    BOOL ReturnValue;

    if (!ARGUMENT_PRESENT( lpRootPathName )) {
        lpRootPathName = "\\";
    }

    Unicode = Basep8BitStringToStaticUnicodeString( lpRootPathName );

    if (Unicode == NULL) {
        return FALSE;
        }

    if ( ARGUMENT_PRESENT(lpVolumeName) ) {
        if (!Basep8BitStringToDynamicUnicodeString( &UnicodeVolumeName, lpVolumeName )) {
            return FALSE;
        }

    } else {
        UnicodeVolumeName.Buffer = NULL;
    }

    ReturnValue = SetVolumeLabelW((LPCWSTR)Unicode->Buffer,(LPCWSTR)UnicodeVolumeName.Buffer);

    RtlFreeUnicodeString(&UnicodeVolumeName);

    return ReturnValue;
}

BOOL
WINAPI
SetVolumeLabelW(
    LPCWSTR lpRootPathName,
    LPCWSTR lpVolumeName
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    UNICODE_STRING LabelName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    PVOID FreeBuffer;
    PFILE_FS_LABEL_INFORMATION LabelInformation;
    ULONG LabelInfoLength;
    WCHAR DefaultPath[2];
    BOOL rv;
    WCHAR volumeName[MAX_PATH];
    BOOL usingVolumeName;

    rv = FALSE;
    DefaultPath[0] = (WCHAR)'\\';
    DefaultPath[1] = UNICODE_NULL;

    if ( ARGUMENT_PRESENT(lpVolumeName) ) {
        RtlInitUnicodeString(&LabelName,lpVolumeName);
        }
    else {
        LabelName.Length = 0;
        LabelName.MaximumLength = 0;
        LabelName.Buffer = NULL;
        }

    if (ARGUMENT_PRESENT(lpRootPathName)) {
        if (GetVolumeNameForVolumeMountPointW(lpRootPathName, volumeName,
                                              MAX_PATH)) {

            usingVolumeName = TRUE;
        } else {
            usingVolumeName = FALSE;
        }
    } else {
        usingVolumeName = FALSE;
    }

    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            usingVolumeName ? volumeName : (ARGUMENT_PRESENT(lpRootPathName) ? lpRootPathName : DefaultPath),
                            &FileName,
                            NULL,
                            NULL
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    //
    // Check to make sure a root was specified
    //

    if ( FileName.Buffer[(FileName.Length >> 1)-1] != '\\' ) {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
        return FALSE;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_WRITE_DATA | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT
                );
    if ( !NT_SUCCESS(Status) ) {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        BaseSetLastNTError(Status);
        return FALSE;
        }

    if ( !IsThisARootDirectory(Handle,NULL) ) {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        NtClose(Handle);
        SetLastError(ERROR_DIR_NOT_ROOT);
        return FALSE;
        }

    NtClose(Handle);

    //
    // Now open the volume DASD by ignoring the ending backslash
    //

    FileName.Length -= 2;

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the volume
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_WRITE_DATA | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT
                );
    RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    //
    // Set the volume label
    //

    LabelInformation = NULL;

    try {

        rv = TRUE;

        //
        // the label info buffer contains a single wchar that is the basis of
        // the label name. Subtract this out so the info length is the length
        // of the label and the structure (not including the extra wchar)
        //

        if ( LabelName.Length ) {
            LabelInfoLength = sizeof(*LabelInformation) + LabelName.Length - sizeof(WCHAR);
            }
        else {
            LabelInfoLength = sizeof(*LabelInformation);
            }

        LabelInformation = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), LabelInfoLength);
        if ( LabelInformation ) {
            RtlCopyMemory(
                LabelInformation->VolumeLabel,
                LabelName.Buffer,
                LabelName.Length
                );
            LabelInformation->VolumeLabelLength = LabelName.Length;
            Status = NtSetVolumeInformationFile(
                        Handle,
                        &IoStatusBlock,
                        (PVOID) LabelInformation,
                        LabelInfoLength,
                        FileFsLabelInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                rv = FALSE;
                BaseSetLastNTError(Status);
                }
            }
        else {
            rv = FALSE;
            BaseSetLastNTError(STATUS_NO_MEMORY);
            }
        }
    finally {
        NtClose(Handle);
        if ( LabelInformation ) {
            RtlFreeHeap(RtlProcessHeap(), 0,LabelInformation);
            }
        }
    return rv;
}


BOOL
APIENTRY
CheckNameLegalDOS8Dot3A(
    IN LPCSTR lpName,
    OUT LPSTR lpOemName OPTIONAL,
    IN DWORD OemNameSize OPTIONAL,
    OUT PBOOL pbNameContainsSpaces OPTIONAL,
    OUT PBOOL pbNameLegal
    )
/*++

    ANSI thunk to IsNameLegalDOS8Dot3W

--*/

{
    ANSI_STRING AnsiStr;
    PUNICODE_STRING pUnicodeStr;
    NTSTATUS Status;
    BOOL Result;

    if( (lpName == NULL) || (pbNameLegal == NULL) ||
        ((lpOemName == NULL) && (OemNameSize != 0)) ||
        (OemNameSize > MAXUSHORT)
      ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    pUnicodeStr = Basep8BitStringToStaticUnicodeString( lpName );

    if( pUnicodeStr == NULL ) {
        //
        // LastError already set by Basep8BitStringToStaticUnicodeString
        //
        return FALSE;
    }

    Result = CheckNameLegalDOS8Dot3W(
                (LPCWSTR)(pUnicodeStr->Buffer),
                lpOemName,
                OemNameSize,
                pbNameContainsSpaces,
                pbNameLegal
                );

    return Result;
}

BOOL
APIENTRY
CheckNameLegalDOS8Dot3W(
    IN LPCWSTR lpName,
    OUT LPSTR lpOemName OPTIONAL,
    IN DWORD OemNameSize OPTIONAL,
    OUT PBOOL pbNameContainsSpaces OPTIONAL,
    OUT PBOOL pbNameLegal
    )

/*++

Routine Description:

    This function determines whether this name can successfully be used to
    create a file on the FAT file system.

    This routine can therefore also be used to determine if a name is
    appropriate to be passed back to a Win31 or DOS app, i.e. whether
    the downlevel APP will understand the name.

Arguments:

    lpName - The UNICODE name to test for conformance to 8.3 symantics.

    lpOemName - If specified, will receive the Oem name corresponding
        to the passed in lpName.  Storage must be provided by the caller.
        The name is undefined if the routine returns FALSE or lpName
        does not conform to 8.3 symantics.

    OemNameSize - If lpOemName is specified, then OemNameSize must specify
        the size of the lpOemName buffer in chars.  If lpOemName is not
        specified, then OemNameSize must be set to zero.

    pbNameContainsSpaces - If the name is a valid 8.3 FAT name, then this
        parameter will indicate if the names contains spaces.  If
        the name is not 8.3 compliant, this parameter is undefined. In
        many instances, the alternate name is more appropriate to
        use if spaces are present in the principle name, even if
        it is 8.3 compliant.

    pbNameLegal - If the function returns TRUE, then this
        parameter will indicate if the passed in UNICODE name forms a valid
        8.3 FAT name when upcased to the current Oem code page.  If
        the name is not 8.3 compliant, this parameter is undefined.
        TRUE  - passed in UNICODE name forms a valid 8.3 FAT name
        FALSE - passed in UNICODE name does not forms a valid 8.3 FAT name

Return Value:

    TRUE  - function succeeds
    FALSE - Function fails.  Extended error status is available using
            GetLastError.

--*/
{

#define BASEP_LOCAL_OEM_BUFFER_SIZE (12 * sizeof(ANSI_NULL))

    UNICODE_STRING UnicodeStr;
    OEM_STRING OemStr;
    POEM_STRING pOemStr;
    UCHAR OemBuffer[BASEP_LOCAL_OEM_BUFFER_SIZE];
    BOOLEAN SpacesInName, Result;

    if( (lpName == NULL) || (pbNameLegal == NULL) ||
        ((lpOemName == NULL) && (OemNameSize != 0)) ||
        (OemNameSize > MAXUSHORT)
      ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if( lpOemName != NULL ) {
        //
        // Use a local buffer so that RtlIsNameLegalDOS8Dot3 will not fail
        // due to insufficent OemName buffer size
        //
        OemStr.Length = 0;
        OemStr.MaximumLength = BASEP_LOCAL_OEM_BUFFER_SIZE;
        OemStr.Buffer = OemBuffer;
        pOemStr = &OemStr;
    }
    else {
        pOemStr = NULL;
    }

    RtlInitUnicodeString( &UnicodeStr, lpName );

    Result = RtlIsNameLegalDOS8Dot3(
                &UnicodeStr,
                pOemStr,
                &SpacesInName
                );

    if( Result != FALSE ) {

        if( pOemStr != NULL ) {

            if( OemNameSize < (OemStr.Length + sizeof(ANSI_NULL)) ) {

                SetLastError( ERROR_INSUFFICIENT_BUFFER );
                return FALSE;
            }
            RtlCopyMemory( lpOemName, OemStr.Buffer, OemStr.Length );
            lpOemName[OemStr.Length/sizeof(ANSI_NULL)] = ANSI_NULL;
        }

        if( pbNameContainsSpaces != NULL ) {
            *pbNameContainsSpaces = SpacesInName;
        }
    }

    *pbNameLegal = Result;

    return TRUE;

#undef BASEP_LOCAL_OEM_BUFFER_SIZE
}


#if 0
//
// frankar, let me know if this is needed...
//
UINT
WINAPI
GetZawSysDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    )
{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    ULONG  cbAnsiString;

    UnicodeString.MaximumLength = (USHORT)((uSize<<1)+sizeof(UNICODE_NULL));
    UnicodeString.Buffer = RtlAllocateHeap(
                                RtlProcessHeap(), MAKE_TAG( TMP_TAG ),
                                UnicodeString.MaximumLength
                                );
    if ( !UnicodeString.Buffer ) {
        BaseSetLastNTError(STATUS_NO_MEMORY);
        return 0;
        }
    UnicodeString.Length = (USHORT)GetZawSysDirectoryW(
                                        UnicodeString.Buffer,
                                        (DWORD)(UnicodeString.MaximumLength-sizeof(UNICODE_NULL))/2
                                        )*2;
    if ( UnicodeString.Length > (USHORT)(UnicodeString.MaximumLength-sizeof(UNICODE_NULL)) ) {
        RtlFreeHeap(RtlProcessHeap(), 0,UnicodeString.Buffer);

        //
        // given buffer size is too small.
        // allocate enough size of buffer and try again
        //
        // we need to get entire unicode path
        // otherwise we can't figure out the exact length
        // of corresponding ansi string (cbAnsiString).

        UnicodeString.Buffer = RtlAllocateHeap ( RtlProcessHeap(),
                                                 MAKE_TAG( TMP_TAG ),
                                                 UnicodeString.Length+ sizeof(UNICODE_NULL));
        if ( !UnicodeString.Buffer ) {
             BaseSetLastNTError(STATUS_NO_MEMORY);
             return 0;
             }

        UnicodeString.Length = (USHORT)GetZawSysDirectoryW(
                                     UnicodeString.Buffer,
                                     (DWORD)(UnicodeString.MaximumLength-sizeof(UNICODE_NULL))/2,
                                     ) * 2;
        Status = RtlUnicodeToMultiByteSize( &cbAnsiString,
                                            UnicodeString.Buffer,
                                            UnicodeString.Length );
        if ( !NT_SUCCESS(Status) ) {
            RtlFreeHeap(RtlProcessHeap(), 0, UnicodeString.Buffer);
            BaseSetLastNTError(Status);
            return 0;
            }
        else if ( nBufferLength < cbAnsiString ) {
            RtlFreeHeap(RtlProcessHeap(), 0, UnicodeString.Buffer);
            return cbAnsiString;
            }
        }
    AnsiString.Buffer = lpBuffer;
    AnsiString.MaximumLength = (USHORT)(uSize+1);
    Status = BasepUnicodeStringTo8BitString(&AnsiString,&UnicodeString,FALSE);
    RtlFreeHeap(RtlProcessHeap(), 0,UnicodeString.Buffer);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return 0;
        }
    return AnsiString.Length;
}

UINT
WINAPI
GetZawWindDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    )
{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    ULONG  cbAnsiString;

    UnicodeString.MaximumLength = (USHORT)((uSize<<1)+sizeof(UNICODE_NULL));
    UnicodeString.Buffer = RtlAllocateHeap(
                                RtlProcessHeap(), MAKE_TAG( TMP_TAG ),
                                UnicodeString.MaximumLength
                                );
    if ( !UnicodeString.Buffer ) {
        BaseSetLastNTError(STATUS_NO_MEMORY);
        return 0;
        }
    UnicodeString.Length = (USHORT)GetZawWindDirectoryW(
                                        UnicodeString.Buffer,
                                        (DWORD)(UnicodeString.MaximumLength-sizeof(UNICODE_NULL))/2
                                        )*2;
    if ( UnicodeString.Length > (USHORT)(UnicodeString.MaximumLength-sizeof(UNICODE_NULL)) ) {
        RtlFreeHeap(RtlProcessHeap(), 0,UnicodeString.Buffer);

        //
        // given buffer size is too small.
        // allocate enough size of buffer and try again
        //
        // we need to get entire unicode path
        // otherwise we can't figure out the exact length
        // of corresponding ansi string (cbAnsiString).

        UnicodeString.Buffer = RtlAllocateHeap ( RtlProcessHeap(),
                                                 MAKE_TAG( TMP_TAG ),
                                                 UnicodeString.Length+ sizeof(UNICODE_NULL));
        if ( !UnicodeString.Buffer ) {
            BaseSetLastNTError(STATUS_NO_MEMORY);
            return 0;
            }

        UnicodeString.Length = (USHORT)GetZawWindDirectoryW(
                                     UnicodeString.Buffer,
                                     (DWORD)(UnicodeString.MaximumLength-sizeof(UNICODE_NULL))/2
                                     ) * 2;
        Status = RtlUnicodeToMultiByteSize( &cbAnsiString,
                                            UnicodeString.Buffer,
                                            UnicodeString.Length );
        if ( !NT_SUCCESS(Status) ) {
            RtlFreeHeap(RtlProcessHeap(), 0, UnicodeString.Buffer);
            BaseSetLastNTError(Status);
            return 0;
            }
        else if ( nBufferLength < cbAnsiString ) {
            RtlFreeHeap(RtlProcessHeap(), 0, UnicodeString.Buffer);
            return cbAnsiString;
            }
        }
    AnsiString.Buffer = lpBuffer;
    AnsiString.MaximumLength = (USHORT)(uSize+1);
    Status = BasepUnicodeStringTo8BitString(&AnsiString,&UnicodeString,FALSE);
    RtlFreeHeap(RtlProcessHeap(), 0,UnicodeString.Buffer);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return 0;
        }
    return AnsiString.Length;
}

UINT
WINAPI
GetZawSysDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    )
{
    NTSTATUS Status;
    HANDLE CurrentUserKey;
    HANDLE DirKey;
    UNICODE_STRING KeyName;
    UNICODE_STRING KeyValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG DataLength;
    ULONG ValueInfoBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+MAX_PATH/2];
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo;

    Status = RtlOpenCurrentUser(GENERIC_READ,&CurrentUserKey);

    if ( !NT_SUCCESS(Status) ) {
bail_gzsd:
        return GetSystemDirectoryW(lpBuffer,uSize);
        }

    RtlInitUnicodeString(&KeyName,L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ZAW");

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                CurrentUserKey,
                                NULL
                              );
    Status = NtOpenKey( &DirKey,
                        KEY_READ | KEY_NOTIFY | KEY_WRITE,
                        &ObjectAttributes
                      );

    NtClose(CurrentUserKey);
    if ( !NT_SUCCESS(Status) ) {
        goto bail_gzsd;
        }

    RtlInitUnicodeString(&KeyValueName,L"ZawSys");
    ValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)&ValueInfoBuffer;
    Status = NtQueryValueKey( DirKey,
                              &KeyValueName,
                              KeyValuePartialInformation,
                              ValueInfo,
                              sizeof(ValueInfoBuffer),
                              &DataLength
                            );
    NtClose(DirKey);
    if ( !NT_SUCCESS(Status) ) {
        goto bail_gzsd;
        }
    if ( ValueInfo->DataLength > (uSize<<1) ) {
        goto bail_gzsd;
        }
    RtlCopyMemory(lpBuffer,ValueInfo->Data,ValueInfo->DataLength);
    return (ValueInfo->DataLength >> 1)-1;
}

UINT
WINAPI
GetZawWindDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    )
{
    NTSTATUS Status;
    HANDLE CurrentUserKey;
    HANDLE DirKey;
    UNICODE_STRING KeyName;
    UNICODE_STRING KeyValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG DataLength;
    ULONG ValueInfoBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+MAX_PATH/2];
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo;

    Status = RtlOpenCurrentUser(GENERIC_READ,&CurrentUserKey);

    if ( !NT_SUCCESS(Status) ) {
bail_gzwd:
        return GetWindowsDirectoryW(lpBuffer,uSize);
        }

    RtlInitUnicodeString(&KeyName,L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ZAW");

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                CurrentUserKey,
                                NULL
                              );
    Status = NtOpenKey( &DirKey,
                        KEY_READ | KEY_NOTIFY | KEY_WRITE,
                        &ObjectAttributes
                      );

    NtClose(CurrentUserKey);
    if ( !NT_SUCCESS(Status) ) {
        goto bail_gzwd;
        }

    RtlInitUnicodeString(&KeyValueName,L"ZawWind");
    ValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)&ValueInfoBuffer;
    Status = NtQueryValueKey( DirKey,
                              &KeyValueName,
                              KeyValuePartialInformation,
                              ValueInfo,
                              sizeof(ValueInfoBuffer),
                              &DataLength
                            );
    NtClose(DirKey);
    if ( !NT_SUCCESS(Status) ) {
        goto bail_gzwd;
        }
    if ( ValueInfo->DataLength > (uSize<<1) ) {
        goto bail_gzwd;
        }
    RtlCopyMemory(lpBuffer,ValueInfo->Data,ValueInfo->DataLength);
    return (ValueInfo->DataLength >> 1)-1;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\pipe.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    pipe.c

Abstract:

    This module contains the Win32 Anonymous Pipe API

Author:

    Steve Wood (stevewo) 24-Sep-1990

Revision History:

--*/

#include "basedll.h"

ULONG PipeSerialNumber;

BOOL
APIENTRY
CreatePipe(
    OUT LPHANDLE lpReadPipe,
    OUT LPHANDLE lpWritePipe,
    IN LPSECURITY_ATTRIBUTES lpPipeAttributes,
    IN DWORD nSize
    )

/*++

Routine Description:

    The CreatePipe API is used to create an anonymous pipe I/O device.
    Two handles to the device are created.  One handle is opened for
    reading and the other is opened for writing.  These handles may be
    used in subsequent calls to ReadFile and WriteFile to transmit data
    through the pipe.

Arguments:

    lpReadPipe - Returns a handle to the read side of the pipe.  Data
        may be read from the pipe by specifying this handle value in a
        subsequent call to ReadFile.

    lpWritePipe - Returns a handle to the write side of the pipe.  Data
        may be written to the pipe by specifying this handle value in a
        subsequent call to WriteFile.

    lpPipeAttributes - An optional parameter that may be used to specify
        the attributes of the new pipe.  If the parameter is not
        specified, then the pipe is created without a security
        descriptor, and the resulting handles are not inherited on
        process creation.  Otherwise, the optional security attributes
        are used on the pipe, and the inherit handles flag effects both
        pipe handles.

    nSize - Supplies the requested buffer size for the pipe.  This is
        only a suggestion and is used by the operating system to
        calculate an appropriate buffering mechanism.  A value of zero
        indicates that the system is to choose the default buffering
        scheme.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    WCHAR PipeNameBuffer[ MAX_PATH ];
    ANSI_STRING PipeName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ReadPipeHandle, WritePipeHandle;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    LARGE_INTEGER Timeout;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    UNICODE_STRING Unicode;
    static HANDLE PipeDirectory = NULL;

    //
    //  Set the default timeout to 120 seconds
    //

    Timeout.QuadPart = - 10 * 1000 * 1000 * 120;

    if (nSize == 0) {
        nSize = 4096;
    }

    //
    // Cache the directory to the pipe driver.
    //
    if (PipeDirectory == NULL) {
        HANDLE TempDir;

        Unicode.Buffer = L"\\Device\\NamedPipe\\";
        Unicode.Length = sizeof (L"\\Device\\NamedPipe\\") - sizeof (WCHAR);

        InitializeObjectAttributes (&ObjectAttributes,
                                    &Unicode,
                                    0,
                                    NULL,
                                    NULL);

        Status = NtOpenFile (&TempDir,
                             GENERIC_READ | SYNCHRONIZE,
                             &ObjectAttributes,
                             &Iosb,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_SYNCHRONOUS_IO_NONALERT);
        if (!NT_SUCCESS (Status)) {
            BaseSetLastNTError (Status);
            return (FALSE);
        }

        if (InterlockedCompareExchangePointer (&PipeDirectory, TempDir, NULL) != NULL) {
            NtClose (TempDir);
        }
    }


    swprintf (PipeNameBuffer,
              L"Win32Pipes.%08x.%08x",
              HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess),
              InterlockedIncrement(&PipeSerialNumber));

    Unicode.Buffer = PipeNameBuffer;
    Unicode.Length = 12 * 2 + 8 * 2 * 2;

    if (ARGUMENT_PRESENT (lpPipeAttributes)) {
        Attributes =
              lpPipeAttributes->bInheritHandle ? (OBJ_INHERIT | OBJ_CASE_INSENSITIVE) : (OBJ_CASE_INSENSITIVE);
        SecurityDescriptor = lpPipeAttributes->lpSecurityDescriptor;
    } else {
        Attributes = OBJ_CASE_INSENSITIVE;
        SecurityDescriptor = NULL;
    }

    InitializeObjectAttributes (&ObjectAttributes,
                                &Unicode,
                                Attributes,
                                PipeDirectory,
                                SecurityDescriptor);

    Status = NtCreateNamedPipeFile (&ReadPipeHandle,
                                    GENERIC_READ | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                                    &ObjectAttributes,
                                    &Iosb,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    FILE_CREATE,
                                    FILE_SYNCHRONOUS_IO_NONALERT,
                                    FILE_PIPE_BYTE_STREAM_TYPE,
                                    FILE_PIPE_BYTE_STREAM_MODE,
                                    FILE_PIPE_QUEUE_OPERATION,
                                    1,
                                    nSize,
                                    nSize,
                                    (PLARGE_INTEGER) &Timeout);
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return (FALSE);
    }

    //
    // Now do a relative open with no filename from the created pipe.
    // We do this to eliminate all the name parsing etc.
    //

    Unicode.Buffer = L"";
    Unicode.Length = 0;
    InitializeObjectAttributes (&ObjectAttributes,
                                &Unicode,
                                Attributes,
                                ReadPipeHandle,
                                SecurityDescriptor);

    Status = NtOpenFile (&WritePipeHandle,
                         GENERIC_WRITE | SYNCHRONIZE,
                         &ObjectAttributes,
                         &Iosb,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE);
    if (!NT_SUCCESS (Status)) {
        NtClose (ReadPipeHandle);
        BaseSetLastNTError (Status);
        return (FALSE);
    }

    *lpReadPipe = ReadPipeHandle;
    *lpWritePipe = WritePipeHandle;
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\res.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    res.c

Abstract:

    This module implements Win32 Resource Manager APIs

Author:

    Rob Earhart (Earhart) 04-Apr-2001

Revision History:

--*/

#include "basedll.h"

//
// N.B. This is a stub implementation intended to provide basic
//      resource management interfaces for applications which care
//      about their memory usage.  It is NOT the final version of the
//      usermode side of the resource manager.
//


//
// Globals used by the routines in this module
//

const WCHAR BasepMmLowMemoryConditionEventName[] = L"\\KernelObjects\\LowMemoryCondition";
const WCHAR BasepMmHighMemoryConditionEventName[] = L"\\KernelObjects\\HighMemoryCondition";

HANDLE
APIENTRY
CreateMemoryResourceNotification(
    IN MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType
    )

/*++

Routine Description:

    Creates a memory resource notification handle.  Memory resource
    notification handles monitor memory for changes, and are used
    to query information about memory.

Arguments:

    NotificationType -- the type of notification requested

Return Value:

    Non-NULL - a handle to the new subscription object.

    NULL - The operation failed.  Extended error status is available
           using GetLastError.

--*/

{
    LPCWSTR           EventName;
    HANDLE            Handle;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING    ObjectName;
    NTSTATUS          Status;

    //
    // Determine the event in which the caller's interested.
    //
    switch (NotificationType) {
    case LowMemoryResourceNotification:
        //
        // It's the low memory condition event
        //
        EventName = BasepMmLowMemoryConditionEventName;
        break;

    case HighMemoryResourceNotification:
        //
        // It's the high memory condition event
        //
        EventName = BasepMmHighMemoryConditionEventName;
        break;

    default:
        //
        // Not one of our known event-of-interest types; all we can do 
        // is indicate an invalid parameter, and return a failure
        // condition.
        //

        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;

    }
    

    //
    // Attempt the actual event open
    //
    RtlInitUnicodeString(&ObjectName, EventName);

    InitializeObjectAttributes(&Obja,
                               &ObjectName,
                               0,
                               NULL,
                               NULL);

    Status = NtOpenEvent(&Handle,
                         SYNCHRONIZE | EVENT_QUERY_STATE,
                         &Obja);

    if (! NT_SUCCESS(Status)) {
        //
        // We failed to open the event for some reason.
        //
        BaseSetLastNTError(Status);
        return NULL;
    }

    //
    // Otherwise, we have the handle, so we're all set; just return it.
    //

    return Handle;
}

BOOL
APIENTRY
QueryMemoryResourceNotification(
    IN HANDLE ResourceNotificationHandle,
    IN PBOOL  ResourceState
    )

/*++

Routine Description:

    Query a memory resource notification handle for information about
    the associated memory resources.

Arguments:

    ResourceNotificationHandle - a handle to the memory resource
                                 notification to query.

    ResourceState - location to put the information about the memory
                    resource

Return Value:

    TRUE - The query succeeded.

    FALSE - The query failed.  Extended error status is available
            using GetLastError.

--*/

{
    EVENT_BASIC_INFORMATION      EventInfo;
    NTSTATUS                     Status;

    //
    // Check parameter validity
    //
    if (! ResourceNotificationHandle
        || ResourceNotificationHandle == INVALID_HANDLE_VALUE
        || ! ResourceState) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Get the event's current state
    //
    Status = NtQueryEvent(ResourceNotificationHandle,
                          EventBasicInformation,
                          &EventInfo,
                          sizeof(EventInfo),
                          NULL);

    if (! NT_SUCCESS(Status)) {
        //
        // On failure, set the last NT error and indicate the failure
        // condition to our caller.
        //
        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // Fill in the state
    //
    *ResourceState = (EventInfo.EventState == 1);

    //
    // And we're done -- return success to our caller.
    //
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\sessdev.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sessdev.c

Abstract:

    Per Session Dos Device access routines

Author:


Revision History:

--*/

#include "basedll.h"


#define SESSION0_ROOT L"GLOBALROOT"
#define SESSIONX_ROOT L"GLOBALROOT\\Sessions\\"



BOOL
WINAPI
DosPathToSessionPathA(
    IN DWORD   SessionId,
    IN LPCSTR pInPath,
    OUT LPSTR  *ppOutPath
    )

/*++

Routine Description:

    Converts a DOS path relative to the current session to a DOS path
    that allows access to a specific session.

Arguments:

    SessionId - SessionId to access.

    pInPath   - WIN32 DOS path. Could be of the form "C:", "LPT1:",
                "C:\file\path", etc.

    ppOutPath - Output path that accesses the specified session.
                If pIniPath is "C:" and SessionId is 6, the output would be
                "GLOBALROOT\Sessions\6\DosDevices\C:".

Return Value:

    TRUE - Path returned in *ppOutPath in newly allocated memory from
           LocalAlloc.
    FALSE - Call failed. Error code returned via GetLastError()

--*/

{
    BOOL rc;
    DWORD Len;
    PCHAR Buf;
    NTSTATUS Status;
    PWCHAR pOutPath;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    // if the input path is null or the pointer is a bad pointer, return
    // an error.

    if( (pInPath == 0) ||
        (IsBadReadPtr( pInPath, sizeof( CHAR ))) ||
        (IsBadWritePtr( ppOutPath, sizeof(LPSTR) )) ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    try {

        RtlInitAnsiString( &AnsiString, pInPath );
        Status = RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, TRUE );

    } except (EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
    }

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return FALSE;
    }

    rc = DosPathToSessionPathW(
             SessionId,
             UnicodeString.Buffer,
             &pOutPath
             );

    RtlFreeUnicodeString( &UnicodeString );

    if( !rc ) {
        return( rc );
    }

    RtlInitUnicodeString( &UnicodeString, pOutPath );
    Status = RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeString, TRUE );
    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        LocalFree( pOutPath );
        return FALSE;
    }

    Len = strlen( AnsiString.Buffer ) + 1;
    Buf = LocalAlloc(LMEM_FIXED, Len);

    if( Buf == NULL ) {
        LocalFree( pOutPath );
        RtlFreeAnsiString( &AnsiString );
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    strcpy( Buf, AnsiString.Buffer );

    *ppOutPath = Buf;

    LocalFree( pOutPath );
    RtlFreeAnsiString( &AnsiString );

    return(TRUE);
}


BOOL
WINAPI
DosPathToSessionPathW(
    IN DWORD   SessionId,
    IN LPCWSTR  pInPath,
    OUT LPWSTR  *ppOutPath
    )

/*++

Routine Description:

    Converts a DOS path relative to the current session to a DOS path
    that allows access to a specific session.

Arguments:

    SessionId - SessionId to access.

    pInPath   - WIN32 DOS path. Could be of the form "C:", "LPT1:",
                "C:\file\path", etc.

    ppOutPath - Output path that accesses the specified session.
                If pIniPath is "C:" and SessionId is 6, the output would be
                "GLOBALROOT\Sessions\6\DosDevices\C:".

Return Value:

    TRUE - Path returned in *ppOutPath in newly allocated memory from
           LocalAlloc.
    FALSE - Call failed. Error code returned via GetLastError()

--*/

{
    PWCHAR Buf;
    ULONG  Len;

    //
    // SessionId 0 has no per session object directories.
    //
    if (BaseStaticServerData->LUIDDeviceMapsEnabled == TRUE) {

        Len = 0;

    } else {

        if( SessionId == 0 ) {
            Len =  wcslen(SESSION0_ROOT);
        }
        else {
            Len =  wcslen(SESSIONX_ROOT);
            Len += 10;                     // Max DWORD width
        }
    }

    Len += 13;                         // \DosDevices\ ... <NULL>

    // if the input path is null or the pointer is a bad pointer, return
    // an error.

    if( (pInPath == 0) ||
        (IsBadReadPtr( pInPath, sizeof( WCHAR ))) ||
        (IsBadWritePtr( ppOutPath, sizeof(LPWSTR) )) ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    Len += wcslen(pInPath);

    Buf = LocalAlloc(LMEM_FIXED, Len * sizeof(WCHAR));
    if( Buf == NULL ) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    try {
        if (BaseStaticServerData->LUIDDeviceMapsEnabled == TRUE) {

            // C: -> C:
            swprintf(
                Buf,
                L"%ws",
                pInPath
                );

        } else {

            if( SessionId == 0 ) {
                // C: -> GLOBALROOT\DosDevices\C:
                swprintf(
                    Buf,
                    L"%ws\\DosDevices\\%ws",
                    SESSION0_ROOT,
                    pInPath
                    );
            }
            else {
                // C: -> GLOBALROOT\Sessions\6\DosDevices\C:
                swprintf(
                    Buf,
                    L"%ws%u\\DosDevices\\%ws",
                    SESSIONX_ROOT,
                    SessionId,
                    pInPath
                    );
            }
        }

        *ppOutPath = Buf;

    } except (EXCEPTION_EXECUTE_HANDLER) {

        BaseSetLastNTError(GetExceptionCode());
        return(FALSE);
    }


    return(TRUE);
}


BOOL
WINAPI
ProcessIdToSessionId(
    IN  DWORD  dwProcessId,
    OUT DWORD *pSessionId
    )

/*++

Routine Description:

    Given a ProcessId, return the SessionId.

    This is useful for services that impersonate a caller, and
    redefine a drive letter for the caller. An example is the
    workstation service. Transport specific routines allow the
    ProcessId of the caller to be retrieved.

Arguments:

    Process -  Process identifies process to
                return the SessionId for.

    pSessionId - returned SessionId.

Return Value:

    TRUE - SessionId returned in *pSessionId
    FALSE - Call failed. Error code returned via GetLastError()

--*/

{
    HANDLE Handle;
    NTSTATUS Status;
    CLIENT_ID ClientId;
    OBJECT_ATTRIBUTES Obja;
    PROCESS_SESSION_INFORMATION Info;


    if( IsBadWritePtr( pSessionId, sizeof(DWORD) ) )   {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    InitializeObjectAttributes(
        &Obja,
        NULL,
        0,
        NULL,
        NULL
        );

    ClientId.UniqueProcess = (HANDLE) LongToHandle(dwProcessId);
    ClientId.UniqueThread = (HANDLE)NULL;

    Status = NtOpenProcess(
                 &Handle,
                 (ACCESS_MASK)PROCESS_QUERY_INFORMATION,
                 &Obja,
                 &ClientId
                 );

    if( !NT_SUCCESS(Status) ) {
        SetLastError(RtlNtStatusToDosError(Status));
        return(FALSE);
    }

    Status = NtQueryInformationProcess(
                 Handle,
                 ProcessSessionInformation,
                 &Info,
                 sizeof(Info),
                 NULL
                 );

    if( !NT_SUCCESS(Status) ) {
        NtClose( Handle );
        SetLastError(RtlNtStatusToDosError(Status));
        return(FALSE);
    }

    *pSessionId = Info.SessionId;

    NtClose( Handle );

    return(TRUE);
}


DWORD
WINAPI
WTSGetActiveConsoleSessionId ()
/*++

Routine Description:

    returns the Session ID for the session, attached to Console.

Arguments:

    none

Return Value:

    SessionID for the console (session attached to console not necessarily session 0 ) session.
    return 0xFFFFFFFF if there is no session attached to console.
    This could happen if session disconnect / connect is taking place

    This is a session id for the session currently connected to console, it changes when
    new session is connected at console. to keep track of the current console sesion, use
    WTSRegisterSessionNotification


--*/
{
    return (USER_SHARED_DATA->ActiveConsoleId);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\sources.inc ===
MAJORCOMP=windows
MINORCOMP=base

!include $(PROJECT_ROOT)\prerelease.inc

SYNCHRONIZE_DRAIN=1

TARGETNAME=kernel32
TARGETPATH=obj
TARGETTYPE=DYNLINK
W32_SB=1

NTTARGETFILE1= \
    $(SDK_LIB_DEST)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\kernl32p.lib \
    $(SDK_LIB_DEST)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\kernel32.lib

DLLDEF=$(O)\kernel32.def

LINKLIBS=\
    $(WINDOWS_LIB_PATH)\conlibk.lib \
    $(PROJECT_ROOT)\win32\winnls\$(ALT_PROJECT)\$(O)\nlslib.lib \
    $(PROJECT_LIB_PATH)\dload.lib \
    $(SDK_LIB_PATH)\ntdll.lib

TARGETLIBS=\
    $(PROJECT_ROOT)\win32\lz32\winlza\$(O)\winlza.lib \
    $(SDK_LIB_PATH)\uuid.lib

DLLENTRY=BaseDllInitialize

USE_NTDLL=1

INCLUDES=\
    ..;\
    ..\..\inc;\
    $(DS_INC_PATH);\
    $(WINDOWS_INC_PATH);\
    $(TERMSRV_INC_PATH);\
    $(SDKTOOLS_INC_PATH);\
    $(PROJECT_ROOT)\published\$(O);\
    $(PROJECT_ROOT)\win32\lz32\winlza;

CONDITIONAL_INCLUDES=doswin32.h

C_DEFINES=$(C_DEFINES) -D_KERNEL32_

MSC_WARNING_LEVEL=/W3 /WX

DLLORDER=..\kernel32.prf

SOURCES= \
    ..\alignstr.c \
    ..\base.rc    \
    ..\backup.c   \
    ..\beep.c     \
    ..\compname.c \
    ..\copylz.c   \
    ..\curdir.c   \
    ..\datetime.c \
    ..\debug.c    \
    ..\dir.c      \
    ..\dllatom.c  \
    ..\dllini.c   \
    ..\dload.c   \
    ..\dosdev.c   \
    ..\error.c    \
    ..\filefind.c \
    ..\filehops.c \
    ..\filemap.c  \
    ..\filemisc.c \
    ..\fileopcr.c \
    ..\firmware.c \
    ..\gmem.c     \
    ..\handle.c   \
    ..\baseinit.c \
    ..\lcompat.c  \
    ..\lmem.c     \
    ..\mailslot.c \
    ..\message.c  \
    ..\module.c   \
    ..\namepipe.c \
    ..\numa.c     \
    ..\pathmisc.c \
    ..\perfctr.c  \
    ..\pipe.c     \
    ..\power.c    \
    ..\process.c  \
    ..\res.c      \
    ..\sessdev.c  \
    ..\support.c  \
    ..\synch.c    \
    ..\termutil.c \
    ..\thread.c   \
    ..\toolhelp.c \
    ..\ustubs.c   \
    ..\winlzexp.c \
    ..\comm.c     \
    ..\vdm.c      \
    ..\volmount.c \
    ..\updrsrc.cpp   \
    ..\blddcb.c   \
    ..\tapeapi.c  \
    ..\job.c      \
    ..\winlinks.c \
    ..\w98stubs.c \
    ..\sxs.c      \
    ..\sxsfind.c  \
    ..\csrsxs.c   \
    ..\compsup.c  \
    ..\ahcache.c  \
    ..\csrahcache.c \
    ..\webblade.c

UMTYPE=console
OPTIONAL_UMTEST=tatom*tprof*taskstrs*winperf*tbase*tprof*tfile*ttask*tmem*tlfn

PRECOMPILED_INCLUDE=..\basedll.h
PRECOMPILED_PCH=basedll.pch
PRECOMPILED_OBJ=basedll.obj

# No overflow checking for kernel32.dll
BUFFER_OVERFLOW_CHECKS=0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\process.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    process.c

Abstract:

    This module implements Win32 Thread Object APIs

Author:

    Mark Lucovsky (markl) 21-Sep-1990

Revision History:

--*/



#include "basedll.h"
#pragma hdrstop
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>
#include <winsafer.h>
#include <softpub.h>
#include "webbladep.h"

RTL_QUERY_REGISTRY_TABLE BasepAppCertTable[] = {

    {(PRTL_QUERY_REGISTRY_ROUTINE )BasepConfigureAppCertDlls,     RTL_QUERY_REGISTRY_SUBKEY,
     L"AppCertDlls",                &BasepAppCertDllsList,
     REG_NONE, NULL, 0},

    {NULL, 0,
     NULL, NULL,
     REG_NONE, NULL, 0}

};

#define IsEmbeddedNT() (BOOLEAN)(USER_SHARED_DATA->SuiteMask & (1 << EmbeddedNT))
#define IsWebBlade() ((USER_SHARED_DATA->SuiteMask & (VER_SUITE_EMBEDDED_RESTRICTED | VER_SUITE_BLADE)) != 0)

BOOL
BuildSubSysCommandLine(
    LPWSTR  SubSysName,
    LPCWSTR lpApplicationName,
    LPCWSTR lpCommandLine,
    PUNICODE_STRING SubSysCommandLine
    );

PVOID
BasepIsRealtimeAllowed(
    BOOLEAN LeaveEnabled
    );

#ifdef WX86

PWCHAR
BasepWx86KnownExe(
    LPCWSTR ExeName
    )
/*++

Routine Description:

    Checks for Wx86 Known Exes which wx86 applications must run
    compatible binaries. We currently have Known exes for
    regedit.exe, regsvr32.exe, and msiexec.exe

Arguments:

     ExeName - name to check for match.

Return Value:

     if the name needs to be swapped, a buffer is allocated off
     of the process heap filled with new name and returned.
     otherwise NULL is returned.

--*/

{
     UNICODE_STRING NameUnicode;
     PWCHAR pwch, pwcNewName = NULL;

     //
     // Compare the base name, and see if its regedit.exe
     // Note that we are expecting a fully qualified path name.
     //

     pwch = wcsrchr(ExeName, L'\\');
     if (pwch && *pwch++ && *pwch ) {
        if (!_wcsicmp(pwch, L"regedit.exe")) {
           pwcNewName = L"\\wiregedt.exe";
        } else {
           if (!_wcsicmp(pwch, L"regsvr32.exe")) {
              pwcNewName = L"\\regsvr32.exe";
           } else {
              if (!_wcsicmp(pwch, L"msiexec.exe")) {
                 pwcNewName = L"\\msiexec.exe";
              } else {
                 return NULL;
              }
           }
        }
     } else {
        return NULL;
     }



     //
     // It matches, so formulate new name
     //

     pwch = RtlAllocateHeap(RtlProcessHeap(),
                               MAKE_TAG( TMP_TAG ),
                               MAX_PATH + sizeof(WCHAR)
                               );

     if (!pwch) {
         return NULL;
         }

     NameUnicode.Buffer = pwch;
     NameUnicode.MaximumLength = MAX_PATH + sizeof(WCHAR);
     RtlCopyUnicodeString(&NameUnicode, &BaseWindowsSystemDirectory);
     if (NameUnicode.Buffer[(NameUnicode.Length>>1)-1] == (WCHAR)'\\') {
         NameUnicode.Buffer[(NameUnicode.Length>>1)-1] = UNICODE_NULL;
         NameUnicode.Length -= sizeof(WCHAR);
         }

     RtlAppendUnicodeToString(&NameUnicode, pwcNewName);

     return pwch;
}


#endif

PFNWAITFORINPUTIDLE UserWaitForInputIdleRoutine = NULL;
#define DEFAULT_WAIT_FOR_INPUT_IDLE_TIMEOUT 30000

BOOL
BasepIsImageVersionOk(
    IN ULONG ImageMajorVersion,
    IN ULONG ImageMinorVersion
    )
{
    //
    // Make sure image is at least 3.10
    //

    if ( ( ImageMajorVersion < 3 ) ||
         ( ImageMajorVersion == 3 && ImageMinorVersion < 10 ) ) {
        return FALSE;
        }

    //
    // And not greater than what we are
    //

    if ( ( ImageMajorVersion > USER_SHARED_DATA->NtMajorVersion ) ||
         ( ImageMajorVersion == USER_SHARED_DATA->NtMajorVersion &&
           ImageMinorVersion > USER_SHARED_DATA->NtMinorVersion
         )
       ) {
        return FALSE;
        }

    return TRUE;
}





NTSTATUS
BasepIsProcessAllowed(LPCWSTR lpApplicationName)
/*++

    Validate that the image lpApplicationName
    is listed in certified/authorized executables
--*/

{
    NTSTATUS                        Status;
    LPWSTR                          DllNameBuf;
    PLIST_ENTRY                     Head, Next;

    static BOOL              fInitialized = FALSE;
    static BOOL              fCertifyEnabled = TRUE;
    static NTSTATUS          CertifyErrorCode = STATUS_ACCESS_DENIED;
    static HINSTANCE         hEmbeddedCertDll = NULL;
    static NTSTATUS (WINAPI *fEmbeddedCertFunc)(LPCWSTR lpApplicationName) = NULL;


    //
    // Initialization occures when this routine is first entered. After init
    // is done, fInitialized is TRUE, and one of the following must hold
    // - Certification is OFF, and dwCertifyErrorCode indicates whether this
    //   is because no certification is needed, or due to an initialization
    //   error.
    // - Certification is ON, call the EmbeddedNT and/or Plugin dlls to verify
    //
InitDone:

    if ( fInitialized ) {

       PBASEP_APPCERT_ENTRY p;
       NTSTATUS tempStatus;
       ULONG Reason;

        if ( !fCertifyEnabled ) {
            return CertifyErrorCode;
        }

        ASSERT( fEmbeddedCertFunc || !IsListEmpty( &BasepAppCertDllsList ) );

        Status = STATUS_SUCCESS;

        if ( fEmbeddedCertFunc ) {
            Status = (*fEmbeddedCertFunc)( lpApplicationName );
            return Status;
        }

        Head = &BasepAppCertDllsList;

        Reason = APPCERT_CREATION_ALLOWED;
        //
        // Two phase notification scheme. In the first phase we get every dll to
        // vote whether the process should be created. In the second phase we
        // let them know if the process is going to get created or not.
        //

        //
        // Phase 1 : Voting
        //
        Next = Head->Flink;
        while (Next != Head) {
           p = CONTAINING_RECORD( Next,
                                  BASEP_APPCERT_ENTRY,
                                  Entry
                                );
           ASSERT(p->fPluginCertFunc != NULL);

           tempStatus = (*(p->fPluginCertFunc))( lpApplicationName, APPCERT_IMAGE_OK_TO_RUN );

           if (!NT_SUCCESS(tempStatus)) {
              Status = tempStatus;
              Reason = APPCERT_CREATION_DENIED;
           }

           Next = Next->Flink;
        }


        //
        // Phase 2: Announce Results
        //

        Next = Head->Flink;

        while (Next != Head) {
           p = CONTAINING_RECORD( Next,
                                  BASEP_APPCERT_ENTRY,
                                  Entry
                                );
           ASSERT(p->fPluginCertFunc != NULL);

           (*(p->fPluginCertFunc))( lpApplicationName, Reason );

           Next = Next->Flink;
        }

        return Status;
    }


    //
    // Initialize locals
    //
    Status = STATUS_SUCCESS;
    DllNameBuf = NULL;

    //
    // Start initialization
    //
    RtlEnterCriticalSection(&gcsAppCert);


    //
    // check if someone did init while we waited on the crit sect
    //
    if (fInitialized) {
        goto Initialized;
    }

    //
    // check if this is EmbeddedNT
    //
    if (IsEmbeddedNT()) {

        HINSTANCE  hDll;
        ULONG      Length;

        //
        // build the full path DLL name
        //
        DllNameBuf = RtlAllocateHeap(RtlProcessHeap(),
                                     MAKE_TAG( TMP_TAG ),
                                     (MAX_PATH + 1) << 1);

        if (DllNameBuf == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        Length = GetSystemDirectoryW(
                      DllNameBuf,
                      MAX_PATH - 1 - sizeof(CERTAPP_EMBEDDED_DLL_NAME)/2);

        if (!Length ||
             Length > (MAX_PATH - 1 - sizeof(CERTAPP_EMBEDDED_DLL_NAME)/2) ) {
            Status = STATUS_UNSUCCESSFUL;
            goto Cleanup;
        }

        if (DllNameBuf[ Length - 1 ] != L'\\') {
            DllNameBuf[ Length++ ] = L'\\';
        }

        RtlCopyMemory(
                &DllNameBuf[ Length ],
                CERTAPP_EMBEDDED_DLL_NAME,
                sizeof(CERTAPP_EMBEDDED_DLL_NAME));

        hDll = LoadLibraryW( DllNameBuf );
        if (hDll == NULL) {
            //
            // The library was not loaded, return.
            //
            Status = STATUS_UNSUCCESSFUL;
            goto Cleanup;
        }

        //
        // get the entry point
        //
        fEmbeddedCertFunc = (NTSTATUS (WINAPI *)(LPCWSTR))
                                GetProcAddress(hDll,
                                               CERTAPP_EMBEDDED_DLL_EP
                                               );
        if (fEmbeddedCertFunc == NULL) {
            //
            // Unable to retrieve routine address, fail.
            //
            Status = STATUS_UNSUCCESSFUL;
        }
        goto Cleanup;

    } else {
       //
       // On non-embedded NT
       // Do a quick test of top level key to find out if app cert is on.
       //
          static const UNICODE_STRING     UnicodeString =
              RTL_CONSTANT_STRING(CERTAPP_KEY_NAME);
          static const OBJECT_ATTRIBUTES  obja =
              RTL_CONSTANT_OBJECT_ATTRIBUTES(&UnicodeString, OBJ_CASE_INSENSITIVE);
          HANDLE                          hKey;

          if ( !NT_SUCCESS(NtOpenKey(&hKey,
                             KEY_QUERY_VALUE,
                             (POBJECT_ATTRIBUTES) &obja))) {

              goto Cleanup;

          } else {
             NtClose(hKey);
          }

    }


    //
    // load and initialize the list of certification DLLs
    //

    Status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL,
                                     L"Session Manager",
                                     BasepAppCertTable,
                                     NULL,
                                     NULL
                                   );


    if (!NT_SUCCESS(Status)) {

       if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
          //
          // If the registry Key is missing AppCert is turned off
          //
          Status = STATUS_SUCCESS;
       }
    }


Cleanup:

    if (DllNameBuf) {
        RtlFreeHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), DllNameBuf);
    }

    if (NT_SUCCESS( Status ) && (fEmbeddedCertFunc || !IsListEmpty( &BasepAppCertDllsList))) {
        fCertifyEnabled = TRUE;
    } else {
        fCertifyEnabled = FALSE;
        CertifyErrorCode = Status;
    }

    fInitialized = TRUE;

Initialized:
    RtlLeaveCriticalSection(&gcsAppCert);

    goto InitDone;
}


BOOL
WINAPI
IsShimInfrastructureDisabled(
    void
    )
{
    static int g_nDisableShims = -1;
            // -1 means we didn't check for disabled shims yet
            //  0 means the shim infrastructure is enabled
            //  1 means the shim infrastructure is disabled

    static const UNICODE_STRING KeyNameSafeBoot =
        RTL_CONSTANT_STRING(L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\SafeBoot\\Option");
    static const UNICODE_STRING ValueNameSafeBoot =
        RTL_CONSTANT_STRING(L"OptionValue");
    static const OBJECT_ATTRIBUTES objaSafeBoot =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&KeyNameSafeBoot, OBJ_CASE_INSENSITIVE);


    static const UNICODE_STRING KeyNameAppCompat =
        RTL_CONSTANT_STRING(L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility");
    static const UNICODE_STRING ValueNameDisableShims =
        RTL_CONSTANT_STRING(L"DisableAppCompat");
    static const OBJECT_ATTRIBUTES objaAppCompat =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&KeyNameAppCompat, OBJ_CASE_INSENSITIVE);

    static const UNICODE_STRING KeyNameAppCompatPolicy =
        RTL_CONSTANT_STRING(L"\\Registry\\MACHINE\\Software\\Policies\\Microsoft\\Windows\\AppCompat");
    static const UNICODE_STRING ValueNameDisableShimsPolicy =
        RTL_CONSTANT_STRING(L"DisableEngine");
    static const OBJECT_ATTRIBUTES objaAppCompatPolicy =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&KeyNameAppCompatPolicy, OBJ_CASE_INSENSITIVE);

    HANDLE                      hKey;
    BYTE ValueBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD)];
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInformation =
            (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
    DWORD                       ValueLength;
    NTSTATUS                    Status;

    //
    // First see if we already checked the registry
    //
    if (g_nDisableShims == 1) {
        return TRUE;
    }

    if (g_nDisableShims == 0) {
        return FALSE;
    }

    //
    // This is the only time we check for safeboot by going to the registry
    //
    Status = NtOpenKey(&hKey, KEY_QUERY_VALUE, (POBJECT_ATTRIBUTES) &objaSafeBoot);

    if (NT_SUCCESS(Status)) {
        Status = NtQueryValueKey(hKey,
                                 (PUNICODE_STRING) &ValueNameSafeBoot,
                                 KeyValuePartialInformation,
                                 pKeyValueInformation,
                                 sizeof(ValueBuffer),
                                 &ValueLength);

        NtClose(hKey);

        if (NT_SUCCESS(Status) &&
            pKeyValueInformation->Type == REG_DWORD &&
            pKeyValueInformation->DataLength == sizeof(DWORD)) {
            //
            // If the value exists and it's not 0 then we are in one of SafeBoot modes.
            // Return TRUE in this case to disable the shim infrastructure
            //
            if (*((PDWORD) pKeyValueInformation->Data) > 0) {
                g_nDisableShims = 1;
                return TRUE;
            }
        }
    }

    //
    // Now see if the shim infrastructure is disabled for this machine
    //
    Status = NtOpenKey(&hKey, KEY_QUERY_VALUE, (POBJECT_ATTRIBUTES) &objaAppCompat);

    if (NT_SUCCESS(Status)) {
        Status = NtQueryValueKey(hKey,
                                 (PUNICODE_STRING) &ValueNameDisableShims,
                                 KeyValuePartialInformation,
                                 pKeyValueInformation,
                                 sizeof(ValueBuffer),
                                 &ValueLength);

        NtClose(hKey);

        if (NT_SUCCESS(Status) &&
            pKeyValueInformation->Type == REG_DWORD &&
            pKeyValueInformation->DataLength == sizeof(DWORD)) {
            if (*((PDWORD) pKeyValueInformation->Data) != 0) {
                g_nDisableShims = 1;
                return TRUE;
            }
        }
    }

    //
    // Also check the new group policy
    //
    Status = NtOpenKey(&hKey, KEY_QUERY_VALUE, (POBJECT_ATTRIBUTES) &objaAppCompatPolicy);

    if (NT_SUCCESS(Status)) {
        Status = NtQueryValueKey(hKey,
                                 (PUNICODE_STRING) &ValueNameDisableShimsPolicy,
                                 KeyValuePartialInformation,
                                 pKeyValueInformation,
                                 sizeof(ValueBuffer),
                                 &ValueLength);

        NtClose(hKey);

        if (NT_SUCCESS(Status) &&
            pKeyValueInformation->Type == REG_DWORD &&
            pKeyValueInformation->DataLength == sizeof(DWORD)) {
            if (*((PDWORD) pKeyValueInformation->Data) != 0) {
                g_nDisableShims = 1;
                return TRUE;
            }
        }
    }

    g_nDisableShims = 0;

    return FALSE;
}

//
// the code below should never be called on non-386 platform
//

NTSTATUS
BasepCheckBadapp(
    HANDLE hFile,
    WCHAR* pwszApplication,          // IN
    WCHAR* pEnvironment,             // IN
    USHORT uExeType,                 // IN
    PVOID* ppData,                   // OUT
    PDWORD pcbData,                  // OUT
    PVOID* ppSxsData,                // OUT
    PDWORD pcbSxsData,               // OUT
    PDWORD pdwFusionFlags            // OUT
    )
{
    typedef BOOL (STDAPICALLTYPE *PFNCheckRunApp)(
        HANDLE FileHandle,
        WCHAR* pwszPath,
        WCHAR* pEnvironment,
        USHORT uExeType,
        DWORD  dwReason,
        PVOID* ppData,
        PDWORD pcbData,
        PVOID* ppDataSxs,
        PDWORD pcbDataSxs,
        PDWORD pdwFusionFlags);

    NTSTATUS                  RetStatus = STATUS_SUCCESS;
    NTSTATUS                  Status;
    HANDLE                    ModuleHandle;
    static PFNCheckRunApp     pfnCheckRunApp = NULL;
    PUNICODE_STRING           pStaticString;
    UNICODE_STRING            BackupUnicodeString;
    ULONG                     BackupStringSize;
    WCHAR                     Apphelp_dllBuffer[MAX_PATH];
    UNICODE_STRING            Apphelp_dllPath;
    DWORD                     dwReason = 0; // reason for having avoided cache

    static const UNICODE_STRING Apphelp_dllModuleName        = RTL_CONSTANT_STRING(L"\\system32\\Apphelp.dll");
    static const STRING         CheckRunAppProcedureName     = RTL_CONSTANT_STRING("ApphelpCheckRunApp");

    //
    // Do nothing if the shim infrastructure is disabled
    //
    if (IsShimInfrastructureDisabled()) {
        return STATUS_SUCCESS;
    }

    //
    // We can't re-enter this code even within the same thread.
    // Such an occasion is when apphelp needs to do ShellExecute
    // which comes back here -- clobbering our state
    //
    pStaticString = &NtCurrentTeb()->StaticUnicodeString;
    BackupUnicodeString.MaximumLength = pStaticString->MaximumLength;
    BackupUnicodeString.Length = pStaticString->Length;
    BackupStringSize = pStaticString->Length + sizeof(UNICODE_NULL);

    if (BackupStringSize > BackupUnicodeString.MaximumLength) {
        BackupStringSize = BackupUnicodeString.MaximumLength;
    }

    BackupUnicodeString.Buffer = RtlAllocateHeap(RtlProcessHeap(),
                                                 MAKE_TAG(TMP_TAG),
                                                 BackupStringSize);

    if (BackupUnicodeString.Buffer == NULL) {
        //
        // we failed to allocate memory to save the static string
        // return success and try to run an app
        //
        return STATUS_SUCCESS;
    }

    RtlCopyMemory(BackupUnicodeString.Buffer,
                  pStaticString->Buffer,
                  BackupStringSize);


    //
    // Check our internal cache -- no touching apphelp.dll before we check with the cache
    //
    if (BaseCheckAppcompatCache(pwszApplication, hFile, pEnvironment, &dwReason)) {
        RetStatus = STATUS_SUCCESS;
        //
        // we can't just return here since we need to restore the static
        // unicode string, so we go around the code that calls into apphelp
        //
        goto CheckDone;
    }

    //
    // check appcompat now - the hard way
    //
    if (!BaseCheckRunApp(hFile,
                         pwszApplication,
                         pEnvironment,
                         uExeType,
                         dwReason,
                         ppData,
                         pcbData,
                         ppSxsData,
                         pcbSxsData,
                         pdwFusionFlags)) {
        RetStatus = STATUS_ACCESS_DENIED;
    }


CheckDone:

    //
    // Store appcompat data -- only returns something if we are running an app!
    //

    // now restore
    RtlCopyMemory(pStaticString->Buffer,
                  BackupUnicodeString.Buffer,
                  BackupStringSize);

    pStaticString->Length = BackupUnicodeString.Length;

    RtlFreeHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), BackupUnicodeString.Buffer);

    return RetStatus;
}


BOOL
WINAPI
CreateProcessInternalA(
    HANDLE hUserToken,
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation,
    PHANDLE hRestrictedUserToken
    )

/*++

    ANSI thunk to CreateProcessW

--*/

{
    NTSTATUS Status;
    PUNICODE_STRING CommandLine;
    UNICODE_STRING ApplicationName;
    UNICODE_STRING CurrentDirectory;
    STARTUPINFOW StartupInfo;
    ANSI_STRING AnsiString;
    UNICODE_STRING Unicode;
    UNICODE_STRING DynamicCommandLine;
    UNICODE_STRING NullUnicodeString;
    BOOL ReturnStatus;

    if (ARGUMENT_PRESENT (lpCommandLine)) {
        if (!Basep8BitStringToDynamicUnicodeString( &DynamicCommandLine,
                                                    lpCommandLine )) {
            return FALSE;
        }
    } else {
         DynamicCommandLine.Buffer = NULL;
         CommandLine = &NullUnicodeString;
         CommandLine->Buffer = NULL;
    }

    ApplicationName.Buffer = NULL;
    ApplicationName.Buffer = NULL;
    CurrentDirectory.Buffer = NULL;
    RtlCopyMemory (&StartupInfo,lpStartupInfo,sizeof(*lpStartupInfo));
    ASSERT(sizeof(StartupInfo) == sizeof(*lpStartupInfo));
    StartupInfo.lpReserved = NULL;
    StartupInfo.lpDesktop = NULL;
    StartupInfo.lpTitle = NULL;

    try {
        try {
            if (ARGUMENT_PRESENT(lpApplicationName)) {

                if (!Basep8BitStringToDynamicUnicodeString( &ApplicationName,
                                                            lpApplicationName )) {
                    ReturnStatus = FALSE;
                    goto tryexit;
                }
            }

            if (ARGUMENT_PRESENT(lpCurrentDirectory)) {
                if (!Basep8BitStringToDynamicUnicodeString( &CurrentDirectory,
                                                            lpCurrentDirectory )) {
                    ReturnStatus = FALSE;
                    goto tryexit;
                }
            }

            if (ARGUMENT_PRESENT(lpStartupInfo->lpReserved)) {

                //
                // Win95 does not touch reserved, and Intergraph Voxtel passes
                // garbage for this. Handle this by probing lpReserved, and if
                // the pointer is bad, ignore it
                //

                try {

                    RtlInitAnsiString(&AnsiString,lpStartupInfo->lpReserved);

                    }
                except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION
                            ? EXCEPTION_EXECUTE_HANDLER
                            : EXCEPTION_CONTINUE_SEARCH) {
                    goto bail_on_reserved;
                    }

                Unicode.MaximumLength = (USHORT)RtlAnsiStringToUnicodeSize(&AnsiString) ;
                StartupInfo.lpReserved = RtlAllocateHeap( RtlProcessHeap(),
                                                          MAKE_TAG( TMP_TAG ),
                                                          Unicode.MaximumLength);
                if ( !StartupInfo.lpReserved ) {
                    BaseSetLastNTError(STATUS_NO_MEMORY);
                    ReturnStatus = FALSE;
                    goto tryexit;
                    }
                Unicode.Buffer = StartupInfo.lpReserved;
                Status = RtlAnsiStringToUnicodeString(&Unicode,&AnsiString,FALSE);
                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(Status);
                    ReturnStatus = FALSE;
                    goto tryexit;
                    }
                }

bail_on_reserved:
            if (ARGUMENT_PRESENT(lpStartupInfo->lpDesktop)) {
                RtlInitAnsiString(&AnsiString,lpStartupInfo->lpDesktop);
                Unicode.MaximumLength = (USHORT)RtlAnsiStringToUnicodeSize(&AnsiString) ;
                StartupInfo.lpDesktop = RtlAllocateHeap( RtlProcessHeap(),
                                                         MAKE_TAG( TMP_TAG ),
                                                         Unicode.MaximumLength);
                if ( !StartupInfo.lpDesktop ) {
                    BaseSetLastNTError(STATUS_NO_MEMORY);
                    ReturnStatus = FALSE;
                    goto tryexit;
                    }
                Unicode.Buffer = StartupInfo.lpDesktop;
                Status = RtlAnsiStringToUnicodeString(&Unicode,&AnsiString,FALSE);
                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(Status);
                    ReturnStatus = FALSE;
                    goto tryexit;
                    }
                }

            if (ARGUMENT_PRESENT(lpStartupInfo->lpTitle)) {
                RtlInitAnsiString(&AnsiString,lpStartupInfo->lpTitle);
                Unicode.MaximumLength = (USHORT)RtlAnsiStringToUnicodeSize(&AnsiString) ;
                StartupInfo.lpTitle = RtlAllocateHeap( RtlProcessHeap(),
                                                       MAKE_TAG( TMP_TAG ),
                                                       Unicode.MaximumLength);
                if ( !StartupInfo.lpTitle ) {
                    BaseSetLastNTError(STATUS_NO_MEMORY);
                    ReturnStatus = FALSE;
                    goto tryexit;
                    }
                Unicode.Buffer = StartupInfo.lpTitle;
                Status = RtlAnsiStringToUnicodeString(&Unicode,&AnsiString,FALSE);
                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(Status);
                    ReturnStatus = FALSE;
                    goto tryexit;
                    }
                }
            }
        except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION
                    ? EXCEPTION_EXECUTE_HANDLER
                    : EXCEPTION_CONTINUE_SEARCH) {
            BaseSetLastNTError(GetExceptionCode());
            ReturnStatus = FALSE;
            goto tryexit;
            }
        ReturnStatus = CreateProcessInternalW(
                            hUserToken,
                            ApplicationName.Buffer,
                            DynamicCommandLine.Buffer ? DynamicCommandLine.Buffer
                                                      : CommandLine->Buffer,
                            lpProcessAttributes,
                            lpThreadAttributes,
                            bInheritHandles,
                            dwCreationFlags,
                            lpEnvironment,
                            CurrentDirectory.Buffer,
                            &StartupInfo,
                            lpProcessInformation,
                            hRestrictedUserToken
                            );
tryexit:;
        }
    finally {
        RtlFreeUnicodeString(&DynamicCommandLine);
        RtlFreeUnicodeString(&ApplicationName);
        RtlFreeUnicodeString(&CurrentDirectory);
        RtlFreeHeap(RtlProcessHeap(), 0,StartupInfo.lpReserved);
        RtlFreeHeap(RtlProcessHeap(), 0,StartupInfo.lpDesktop);
        RtlFreeHeap(RtlProcessHeap(), 0,StartupInfo.lpTitle);
        }

    return ReturnStatus;

}

BOOL
WINAPI
CreateProcessA(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )

/*++

    ANSI thunk to CreateProcessW

--*/

{
    return CreateProcessInternalA(
               NULL, // Create new process with the token on the creator process
               lpApplicationName,
               lpCommandLine,
               lpProcessAttributes,
               lpThreadAttributes,
               bInheritHandles,
               dwCreationFlags,
               lpEnvironment,
               lpCurrentDirectory,
               lpStartupInfo,
               lpProcessInformation,
               NULL  // Do not return the restricted token
               );

}

void
WINAPI
RegisterWaitForInputIdle(
    IN PFNWAITFORINPUTIDLE WaitForInputIdleRoutine
    )
{
    //
    // Soft link in the USER call back for the routine needed for WinExec()
    // synchronization. The only reason this is a soft link is so we can
    // run char mode without gui.
    //

    UserWaitForInputIdleRoutine = WaitForInputIdleRoutine;
}

void
StuffStdHandle(
    HANDLE ProcessHandle,
    HANDLE StdHandle,
    PHANDLE TargetHandleAddress
    )
{
    NTSTATUS Status;
    HANDLE TargetStdHandle;
    SIZE_T NumberOfBytesWritten;

    if (StdHandle == NULL) {
        return;
    }
    Status = NtDuplicateObject (NtCurrentProcess(),
                                StdHandle,
                                ProcessHandle,
                                &TargetStdHandle,
                                DUPLICATE_SAME_ACCESS | DUPLICATE_SAME_ATTRIBUTES,
                                0,
                                0);
    if (!NT_SUCCESS( Status )) {
        return;
    }

    Status = NtWriteVirtualMemory (ProcessHandle,
                                   TargetHandleAddress,
                                   &TargetStdHandle,
                                   sizeof( TargetStdHandle ),
                                   &NumberOfBytesWritten);
    return;
}


static HANDLE AdvApi32ModuleHandle = (HANDLE) (ULONG_PTR) -1;

NTSTATUS
BasepCheckWinSaferRestrictions(
        IN HANDLE       hUserToken          OPTIONAL,
        IN LPCWSTR      lpApplicationName,
        IN HANDLE       FileImageHandle     OPTIONAL,
        OUT LPDWORD     pdwJobMemberLevel,
        OUT PHANDLE     phRestrictedToken,
        OUT PHANDLE     phAssignmentJob
        )
// Note: May return -1 for the ERROR_ACCESS_DISABLED_BY_POLICY case.
{

#define SAFER_USER_KEY_NAME L"\\Software\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers"

    typedef BOOL (WINAPI *ComputeAccessTokenFromCodeAuthzLevelT) (
        IN SAFER_LEVEL_HANDLE LevelObject,
        IN HANDLE             InAccessToken         OPTIONAL,
        OUT PHANDLE           OutAccessToken,
        IN DWORD              dwFlags,
        IN LPVOID             lpReserved
        );

    typedef BOOL (WINAPI *IdentifyCodeAuthzLevelWT) (
        IN DWORD                dwCheckFlags,
        IN PSAFER_CODE_PROPERTIES    CodeProperties,
        OUT SAFER_LEVEL_HANDLE        *pLevelObject,
        IN LPVOID               lpReserved
        );

    typedef BOOL (WINAPI *CloseCodeAuthzLevelT) (
        IN SAFER_LEVEL_HANDLE      hLevelObject);

    typedef BOOL (WINAPI *CodeAuthzRecordEventLogEntryT) (
        IN SAFER_LEVEL_HANDLE      hAuthzLevel,
        IN LPCWSTR          szTargetPath,
        IN LPVOID           lpReserved
        );

    NTSTATUS Status;
    SAFER_CODE_PROPERTIES codeproperties;
    SAFER_LEVEL_HANDLE hAuthzLevel;
    HANDLE hProcessToken = NULL;
    HANDLE hThreadToken = NULL;
    HANDLE hEffectiveToken = NULL;
    static DWORD dwSaferAuthenticodeFlag = 0;

    const static SID_IDENTIFIER_AUTHORITY NtAuthority =
            SECURITY_NT_AUTHORITY;
    const static UNICODE_STRING UnicodeSafeBootKeyName =
        RTL_CONSTANT_STRING(L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\SafeBoot\\Option");
    const static UNICODE_STRING UnicodeSafeBootValueName =
        RTL_CONSTANT_STRING(L"OptionValue");
    const static OBJECT_ATTRIBUTES ObjectAttributesSafeBoot =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&UnicodeSafeBootKeyName, OBJ_CASE_INSENSITIVE);
    const static UNICODE_STRING UnicodeKeyName =
        RTL_CONSTANT_STRING(L"\\Registry\\Machine\\Software\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers");
    const static UNICODE_STRING UnicodeTransparentValueName =
        RTL_CONSTANT_STRING(L"TransparentEnabled");
    const static OBJECT_ATTRIBUTES ObjectAttributesCodeIdentifiers =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&UnicodeKeyName, OBJ_CASE_INSENSITIVE);
    const static UNICODE_STRING ModuleName =
        RTL_CONSTANT_STRING(L"ADVAPI32.DLL");
    const static ANSI_STRING ProcedureNameIdentify =
        RTL_CONSTANT_STRING("SaferIdentifyLevel");
    const static ANSI_STRING ProcedureNameCompute =
        RTL_CONSTANT_STRING("SaferComputeTokenFromLevel");
    const static ANSI_STRING ProcedureNameClose =
        RTL_CONSTANT_STRING("SaferCloseLevel");
    const static ANSI_STRING ProcedureNameLogEntry =
        RTL_CONSTANT_STRING("SaferRecordEventLogEntry");
    const static UNICODE_STRING SaferAuthenticodeValueName =
        RTL_CONSTANT_STRING(L"AuthenticodeEnabled");

    static IdentifyCodeAuthzLevelWT lpfnIdentifyCodeAuthzLevelW;
    static ComputeAccessTokenFromCodeAuthzLevelT
            lpfnComputeAccessTokenFromCodeAuthzLevel;
    static CloseCodeAuthzLevelT lpfnCloseCodeAuthzLevel;
    static CodeAuthzRecordEventLogEntryT lpfnCodeAuthzRecordEventLogEntry;


    //
    // Verify that our required arguments were supplied.
    //
    if (!ARGUMENT_PRESENT(lpApplicationName) || !*lpApplicationName) {
        return STATUS_INVALID_PARAMETER;
    }
    if (!ARGUMENT_PRESENT(pdwJobMemberLevel) ||
        !ARGUMENT_PRESENT(phRestrictedToken) ||
        !ARGUMENT_PRESENT(phAssignmentJob)) {
        return STATUS_ACCESS_VIOLATION;
    }


    //
    // Enter a critical section for the entire trust evalation.
    // (We borrow the critical section used by AppCert).
    //
    RtlEnterCriticalSection(&gcsAppCert);


    //
    // If either of these two cases are true, then we should bail out
    // as quickly as possible because we know that WinSafer evaluations
    // should definitely not occur for this process anymore.
    //
    if (AdvApi32ModuleHandle == NULL) {
        // We tried to load ADVAPI32.DLL once before, but failed.
        Status = STATUS_ENTRYPOINT_NOT_FOUND;
        goto ExitHandler;
    } else if (AdvApi32ModuleHandle == LongToHandle(-2)) {
        // Indicates that DLL checking should never be done for this process.
        Status = STATUS_SUCCESS;
        goto ExitHandler;
    }

    //
    // We only need the process token if no token is supplied.
    //

    if (hUserToken == NULL) {


        //
        // Open and save the thread token.
        //

        Status = NtOpenThreadToken(
                     NtCurrentThread(),
                     MAXIMUM_ALLOWED,
                     TRUE,
                     &hThreadToken);

        if (Status == STATUS_NO_TOKEN) {

        // The thread is not impersonating. It is ok to fall thru.

        } else if (!NT_SUCCESS(Status)) {
            goto ExitHandler;
        } else {


            HANDLE NewToken = NULL;
            //
            // Revert to self.
            //

            Status = NtSetInformationThread(
                                   NtCurrentThread(),
                                   ThreadImpersonationToken,
                                   (PVOID)&NewToken,
                                   (ULONG)sizeof(HANDLE)
                                   );
            //
            // This should never happen unless kernel gives up on us.
            //

            if ( !NT_SUCCESS(Status) ) {
                NtClose(hThreadToken);
                hThreadToken = NULL;
                goto ExitHandler;
            }
        }


        //
        // Open a handle to the current process's access token.
        // We care only about the process token, and not the
        // thread impersonation token.
        //
        Status = NtOpenProcessToken(
                        NtCurrentProcess(),
                        TOKEN_DUPLICATE | TOKEN_QUERY,
                        &hProcessToken);
        if (Status == STATUS_ACCESS_DENIED) {
            // Failed to open with query and duplicate privs.  Retry with
            // only query privileges, which might be enough to do simply
            // determine that we should not allow futher loading.  But without
            // duplicate access, we won't be able to restrict tokens later.
            Status = NtOpenProcessToken(
                            NtCurrentProcess(),
                            TOKEN_QUERY,
                            &hProcessToken);
        }

        if (hThreadToken != NULL) {

            //
            // Set the thread token to the saved one.
            //

            NTSTATUS lStatus = NtSetInformationThread(
                                   NtCurrentThread(),
                                   ThreadImpersonationToken,
                                   (PVOID)&hThreadToken,
                                   (ULONG)sizeof(HANDLE)
                                   );

            NtClose(hThreadToken);
            hThreadToken = NULL;

            //
            // This should never happen unless kernel gives up on us.
            //

            if ( !NT_SUCCESS(lStatus) ) {
                Status = lStatus;
                goto ExitHandler2;
            }

        }

        if (!NT_SUCCESS(Status)) {
            if (AdvApi32ModuleHandle == LongToHandle(-1)) {
                // If this is our first pass through, then it is unlikely
                // that any later attempts will succeed, so remember that.
                AdvApi32ModuleHandle = LongToHandle(-2);
                Status = STATUS_SUCCESS;
            }
            goto ExitHandler;
        }
        hEffectiveToken = hProcessToken;
    } else {
        hEffectiveToken = hUserToken;
    }

    //
    // Load ADVAPI32.DLL and get pointers to our functions.
    //
    if (AdvApi32ModuleHandle == LongToHandle(-1)) {
        HANDLE TempModuleHandle;

        //
        // Check if this process's access token is running as
        // the Local SYSTEM, LOCAL SERVICE or NETWORK SERVICE account,
        // and disable enforcement if so.
        //
        {
            BYTE tokenuserbuff[sizeof(TOKEN_USER) + 128];
            PTOKEN_USER ptokenuser = (PTOKEN_USER) tokenuserbuff;
            BYTE localsystembuff[128];
            PSID LocalSystemSid = (PSID) localsystembuff;
            ULONG ulReturnLength;

            Status = NtQueryInformationToken(
                            hEffectiveToken, TokenUser,
                            tokenuserbuff, sizeof(tokenuserbuff),
                            &ulReturnLength);
            if (NT_SUCCESS(Status)) {
                Status = RtlInitializeSid(
                            LocalSystemSid,
                            (PSID_IDENTIFIER_AUTHORITY) &NtAuthority, 1);
                ASSERTMSG("InitializeSid should not fail.", NT_SUCCESS(Status));
                *RtlSubAuthoritySid(LocalSystemSid, 0) = SECURITY_LOCAL_SYSTEM_RID;

                if (RtlEqualSid(ptokenuser->User.Sid, LocalSystemSid)) {
                    goto FailSuccessfully;
                }

                *RtlSubAuthoritySid(LocalSystemSid, 0) = SECURITY_LOCAL_SERVICE_RID;
                if (RtlEqualSid(ptokenuser->User.Sid, LocalSystemSid)) {
                    goto FailSuccessfully;
                }

                *RtlSubAuthoritySid(LocalSystemSid, 0) = SECURITY_NETWORK_SERVICE_RID;
                if (RtlEqualSid(ptokenuser->User.Sid, LocalSystemSid)) {
                    goto FailSuccessfully;
                }
            }
        }


        //
        // If we are booting in safe mode and the user is a member of
        // the local Administrators group, then disable enforcement.
        // Notice that Windows itself does not perform any implicit
        // restriction of only allowing Administrators to log in during
        // Safe mode boot, so we must perform the test ourself.
        //
        {
            HANDLE hKeySafeBoot;
            BYTE QueryBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 64];
            PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo =
                (PKEY_VALUE_PARTIAL_INFORMATION) QueryBuffer;
            DWORD dwActualSize;
            BOOLEAN bSafeModeBoot = FALSE;

            // We open the key for SET access (in addition to QUERY)
            // because only Administrators should be able to modify values
            // under this key.  This allows us to combine our test of
            // being an Administrator and having booted in Safe mode.
            Status = NtOpenKey(&hKeySafeBoot, KEY_QUERY_VALUE | KEY_SET_VALUE,
                               (POBJECT_ATTRIBUTES) &ObjectAttributesSafeBoot);
            if (NT_SUCCESS(Status)) {
                Status = NtQueryValueKey(
                            hKeySafeBoot,
                            (PUNICODE_STRING) &UnicodeSafeBootValueName,
                            KeyValuePartialInformation,
                            pKeyValueInfo,
                            sizeof(QueryBuffer),
                            &dwActualSize);
                NtClose(hKeySafeBoot);
                if (NT_SUCCESS(Status)) {
                    if (pKeyValueInfo->Type == REG_DWORD &&
                        pKeyValueInfo->DataLength == sizeof(DWORD) &&
                        *((PDWORD) pKeyValueInfo->Data) > 0) {
                        bSafeModeBoot = TRUE;
                    }
                }
            }

            if (bSafeModeBoot) {
                AdvApi32ModuleHandle = LongToHandle(-2);
FailSuccessfully:
                Status = STATUS_SUCCESS;
                goto ExitHandler2;
            }
        }



        //
        // Allow a way for policy to enable whether transparent
        // enforcement should be enabled or not (default to disable).
        // Note that the following values have meanings:
        //      0 = Transparent WinSafer enforcement disabled.
        //      1 = means enable transparent EXE enforcement
        //     >1 = means enable transparent EXE and DLL enforcement.
        //
        {
            // BUG 240635: change to use existence of policy instead.
            HANDLE hKeyEnabled;
            BYTE QueryBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 64];
            PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo =
                (PKEY_VALUE_PARTIAL_INFORMATION) QueryBuffer;
            DWORD dwActualSize;
            BOOLEAN bPolicyEnabled = FALSE;

            Status = NtOpenKey(&hKeyEnabled, KEY_QUERY_VALUE,
                               (POBJECT_ATTRIBUTES) &ObjectAttributesCodeIdentifiers);
            if (NT_SUCCESS(Status)) {
                Status = NtQueryValueKey(
                            hKeyEnabled,
                            (PUNICODE_STRING) &UnicodeTransparentValueName,
                            KeyValuePartialInformation,
                            pKeyValueInfo, sizeof(QueryBuffer), &dwActualSize);
                if (NT_SUCCESS(Status)) {
                    if (pKeyValueInfo->Type == REG_DWORD &&
                        pKeyValueInfo->DataLength == sizeof(DWORD) &&
                        *((PDWORD) pKeyValueInfo->Data) > 0) {
                        bPolicyEnabled = TRUE;
                    }
                }

                //
                // do authenticode checks only if a regvalue is set
                //

                Status = NtQueryValueKey(
                            hKeyEnabled,
                            (PUNICODE_STRING) &SaferAuthenticodeValueName,
                            KeyValuePartialInformation,
                            pKeyValueInfo, sizeof(QueryBuffer), &dwActualSize);
                if (NT_SUCCESS(Status)) {
                    if (pKeyValueInfo->Type == REG_DWORD &&
                        pKeyValueInfo->DataLength == sizeof(DWORD) &&
                        *((PDWORD) pKeyValueInfo->Data) > 0) {
                        dwSaferAuthenticodeFlag = SAFER_CRITERIA_AUTHENTICODE;
                    }
                }
                NtClose(hKeyEnabled);
            }

            //
            // There was no machine policy. Check if user policy is enabled.
            //

            if (!bPolicyEnabled) {
                UNICODE_STRING CurrentUserKeyPath;
                UNICODE_STRING SubKeyNameUser;
                OBJECT_ATTRIBUTES ObjectAttributesUser;

                //
                // Get the prefix for the user key.
                //

                Status = RtlFormatCurrentUserKeyPath( &CurrentUserKeyPath );

                if (NT_SUCCESS( Status ) ) {

                    SubKeyNameUser.Length = 0;
                    SubKeyNameUser.MaximumLength = CurrentUserKeyPath.Length +
                                                   sizeof(WCHAR) +
                                                   sizeof(SAFER_USER_KEY_NAME);

                    //
                    // Allocate memory big enough to hold the unicode string.
                    //

                    SubKeyNameUser.Buffer = RtlAllocateHeap(
                                                RtlProcessHeap(),
                                                MAKE_TAG( TMP_TAG ),
                                                SubKeyNameUser.MaximumLength);

                    if (SubKeyNameUser.Buffer != NULL) {

                        //
                        // Copy the prefix into the string.
                        // This is of the type Registry\S-1-5-21-xxx-xxx-xxx-xxx.
                        //

                        Status = RtlAppendUnicodeStringToString(
                                    &SubKeyNameUser,
                                    &CurrentUserKeyPath );

                        if (NT_SUCCESS( Status ) ) {

                            //
                            // Append the Safer suffix.
                            //

                            Status = RtlAppendUnicodeToString(
                                         &SubKeyNameUser,
                                         SAFER_USER_KEY_NAME );

                            if (NT_SUCCESS( Status ) ) {

                                InitializeObjectAttributes(
                                    &ObjectAttributesUser,
                                    &SubKeyNameUser,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL
                                );

                                Status = NtOpenKey( &hKeyEnabled,KEY_QUERY_VALUE,
                                             (POBJECT_ATTRIBUTES) &ObjectAttributesUser);

                                if (NT_SUCCESS(Status)) {
                                    Status = NtQueryValueKey(
                                                hKeyEnabled,
                                                (PUNICODE_STRING) &UnicodeTransparentValueName,
                                                KeyValuePartialInformation,
                                                pKeyValueInfo, sizeof(QueryBuffer), &dwActualSize);

                                    if (NT_SUCCESS(Status)) {
                                        if (pKeyValueInfo->Type == REG_DWORD &&
                                            pKeyValueInfo->DataLength == sizeof(DWORD) &&
                                            *((PDWORD) pKeyValueInfo->Data) > 0) {
                                            bPolicyEnabled = TRUE;
                                        }
                                    }
                                }
                            }

                        }
                        RtlFreeHeap(RtlProcessHeap(), 0, SubKeyNameUser.Buffer);
                    }
                    RtlFreeUnicodeString( &CurrentUserKeyPath );
                }
            }

            if (!bPolicyEnabled) {
                AdvApi32ModuleHandle = LongToHandle(-2);
                goto FailSuccessfully;
            }
        }


        //
        // Finally load the library.  We'll pass a special flag in
        // DllCharacteristics to eliminate WinSafer checking on advapi.
        //
        {
            ULONG DllCharacteristics = IMAGE_FILE_SYSTEM;
            Status = LdrLoadDll(UNICODE_NULL,
                                &DllCharacteristics,
                                (PUNICODE_STRING) &ModuleName,
                                &TempModuleHandle);
            if (!NT_SUCCESS(Status)) {
                Status = STATUS_ENTRYPOINT_NOT_FOUND;
                AdvApi32ModuleHandle = NULL;
                goto ExitHandler2;
            }
        }


        //
        // Get function pointers to the APIs that we'll need.  If we fail
        // to get pointers for any of them, then just unload advapi and
        // ignore all future attempts to load it within this process.
        //

        Status = LdrGetProcedureAddress(
                TempModuleHandle,
                (PANSI_STRING) &ProcedureNameIdentify,
                0,
                (PVOID*)&lpfnIdentifyCodeAuthzLevelW);

        if (!NT_SUCCESS(Status) ||
            !lpfnIdentifyCodeAuthzLevelW) {
AdvapiLoadFailure:
            LdrUnloadDll(TempModuleHandle);
            AdvApi32ModuleHandle = NULL;
            Status = STATUS_ENTRYPOINT_NOT_FOUND;
            goto ExitHandler2;
        }

        Status = LdrGetProcedureAddress(
                TempModuleHandle,
                (PANSI_STRING) &ProcedureNameCompute,
                0,
                (PVOID*)&lpfnComputeAccessTokenFromCodeAuthzLevel);

        if (!NT_SUCCESS(Status) ||
            !lpfnComputeAccessTokenFromCodeAuthzLevel) {
            goto AdvapiLoadFailure;
        }

        Status = LdrGetProcedureAddress(
                TempModuleHandle,
                (PANSI_STRING) &ProcedureNameClose,
                0,
                (PVOID*)&lpfnCloseCodeAuthzLevel);

        if (!NT_SUCCESS(Status) || !lpfnCloseCodeAuthzLevel) {
            goto AdvapiLoadFailure;
        }

        Status = LdrGetProcedureAddress(
                TempModuleHandle,
                (PANSI_STRING) &ProcedureNameLogEntry,
                0,
                (PVOID*)&lpfnCodeAuthzRecordEventLogEntry);

        if (!NT_SUCCESS(Status) || !lpfnCodeAuthzRecordEventLogEntry) {
            goto AdvapiLoadFailure;
        }

        AdvApi32ModuleHandle = TempModuleHandle;

    }



    //
    // Prepare the code properties struct.
    //

    RtlZeroMemory(&codeproperties, sizeof(codeproperties));
    codeproperties.cbSize = sizeof(codeproperties);
    codeproperties.dwCheckFlags =
            (SAFER_CRITERIA_IMAGEPATH | SAFER_CRITERIA_IMAGEHASH | dwSaferAuthenticodeFlag);
    codeproperties.ImagePath = lpApplicationName;
    codeproperties.dwWVTUIChoice = WTD_UI_NONE;  //harmless if AUTHZCRITERIA_AUTHENTICODE is not passed in
    codeproperties.hImageFileHandle = FileImageHandle;

    //
    // Ask the system to find the Authorization Level that classifies it.
    //
    ASSERT(lpfnIdentifyCodeAuthzLevelW != NULL);
    if (lpfnIdentifyCodeAuthzLevelW(
                                   1,                      // 1 structure
                                   &codeproperties,        // details to identify
                                   &hAuthzLevel,           // Safer level
                                   NULL)) {                  // reserved.
        // We found an Authorization Level applicable to this application.
        HANDLE hRestrictedToken = NULL;
        DWORD dwSaferFlags = 0;
        HANDLE hActualJobObject = NULL;
        DWORD dwJobMemberLevel = 0;


        //
        // Generate the Restricted Token that we will use.
        //
        ASSERT(lpfnComputeAccessTokenFromCodeAuthzLevel != NULL);
        if (!lpfnComputeAccessTokenFromCodeAuthzLevel(
                                                     hAuthzLevel,                // Safer Level
                                                     hEffectiveToken,
                                                     &hRestrictedToken,          // target token
                                                     SAFER_TOKEN_NULL_IF_EQUAL |  // flags
                                                     SAFER_TOKEN_WANT_FLAGS,
                                                     &dwSaferFlags)) {             // reserved
            DWORD dwLastError = GetLastError();
            ASSERT(lpfnCloseCodeAuthzLevel != NULL);
            if (dwLastError == ERROR_ACCESS_DISABLED_BY_POLICY) {
                lpfnCodeAuthzRecordEventLogEntry(
                                                hAuthzLevel, lpApplicationName, NULL);
                Status = -1;
            } else {
                Status = STATUS_ACCESS_DENIED;
            }
            lpfnCloseCodeAuthzLevel(hAuthzLevel);
            goto ExitHandler2;
        }

        ASSERT(lpfnCloseCodeAuthzLevel != NULL);
        lpfnCloseCodeAuthzLevel(hAuthzLevel);


        //
        // If the identified Authorization Level needs to be run
        // within an isolation Job Object, then do the Job setup.
        //
        if ((dwSaferFlags & SAFER_POLICY_JOBID_MASK) != 0) {
            JOB_SET_ARRAY jobsetarray[2];
            DWORD dwNumJobSetMembers = 0;


            //
            // Verify that the job member level is one that we support.
            //
            dwJobMemberLevel = (dwSaferFlags & SAFER_POLICY_JOBID_MASK);
            if (dwJobMemberLevel != SAFER_POLICY_JOBID_UNTRUSTED &&
                dwJobMemberLevel != SAFER_POLICY_JOBID_CONSTRAINED) {
                NtClose(hRestrictedToken);
                Status = STATUS_ACCESS_DENIED;
                goto ExitHandler2;
            }



            Status = NtIsProcessInJob(GetCurrentProcess(), NULL);
            if (Status == STATUS_PROCESS_IN_JOB) {
                //
                // The parent process is already within a job, so
                // we will assume that its job is one of the WinSafer
                // jobs and is thus within a WinSafer "jobset" and
                // that NtCreateProcessEx can directly transition to it.
                //
                *phAssignmentJob = NULL;

            } else if (Status == STATUS_PROCESS_NOT_IN_JOB) {
                //
                // The parent process is not in any job (nor jobset)
                // so we must create all of the Jobs and place then
                // within a new Jobset.
                //

                //if (dwJobMemberLevel >= AUTHZPOL_SAFERFLAGS_JOBID_UNTRUSTED)
                {
                    HANDLE hThisJobObject;
                    JOBOBJECT_BASIC_UI_RESTRICTIONS RestrictUI;

                    Status = NtCreateJobObject(
                                              &hThisJobObject,
                                              JOB_OBJECT_ALL_ACCESS,
                                              NULL);
                    if (!NT_SUCCESS(Status)) {
                        goto JobCreationFailure;
                    }
                    RestrictUI.UIRestrictionsClass =
                    JOB_OBJECT_UILIMIT_DESKTOP |
                    JOB_OBJECT_UILIMIT_DISPLAYSETTINGS |
                    JOB_OBJECT_UILIMIT_EXITWINDOWS |
                    JOB_OBJECT_UILIMIT_GLOBALATOMS |
                    JOB_OBJECT_UILIMIT_HANDLES |
                    JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS;
                    if (!SetInformationJobObject(
                                                hThisJobObject,
                                                JobObjectBasicUIRestrictions,
                                                &RestrictUI,
                                                sizeof(JOBOBJECT_BASIC_UI_RESTRICTIONS))) {
                        NtClose(hThisJobObject);
                        Status = STATUS_ACCESS_DENIED;
                        goto JobCreationFailure;
                    }
                    jobsetarray[dwNumJobSetMembers].MemberLevel =
                    SAFER_POLICY_JOBID_UNTRUSTED;
                    jobsetarray[dwNumJobSetMembers].Flags = 0;
                    jobsetarray[dwNumJobSetMembers].JobHandle = hThisJobObject;
                    dwNumJobSetMembers++;
                    if (dwJobMemberLevel == SAFER_POLICY_JOBID_UNTRUSTED) {
                        hActualJobObject = hThisJobObject;
                    }
                }


                //if (dwJobMemberLevel >= AUTHZPOL_SAFERFLAGS_JOBID_CONSTRAINED)
                {
                    HANDLE hThisJobObject;
                    JOBOBJECT_BASIC_UI_RESTRICTIONS RestrictUI;

                    Status = NtCreateJobObject(
                                              &hThisJobObject,
                                              JOB_OBJECT_ALL_ACCESS,
                                              NULL);
                    if (!NT_SUCCESS(Status)) {
                        goto JobCreationFailure;
                    }
                    RestrictUI.UIRestrictionsClass =
                    JOB_OBJECT_UILIMIT_DESKTOP |
                    JOB_OBJECT_UILIMIT_DISPLAYSETTINGS |
                    JOB_OBJECT_UILIMIT_EXITWINDOWS |
                    JOB_OBJECT_UILIMIT_GLOBALATOMS |
                    JOB_OBJECT_UILIMIT_HANDLES |
                    JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS;
                    if (!SetInformationJobObject(
                                                hThisJobObject,
                                                JobObjectBasicUIRestrictions,
                                                &RestrictUI,
                                                sizeof(JOBOBJECT_BASIC_UI_RESTRICTIONS))) {
                        NtClose(hThisJobObject);
                        Status = STATUS_ACCESS_DENIED;
                        goto JobCreationFailure;
                    }
                    jobsetarray[dwNumJobSetMembers].MemberLevel =
                    SAFER_POLICY_JOBID_CONSTRAINED;
                    jobsetarray[dwNumJobSetMembers].Flags = 0;
                    jobsetarray[dwNumJobSetMembers].JobHandle = hThisJobObject;
                    dwNumJobSetMembers++;
                    if (dwJobMemberLevel == SAFER_POLICY_JOBID_CONSTRAINED) {
                        hActualJobObject = hThisJobObject;
                    }
                }


                //
                // Create the Job Set that will hold all of the Job Objects.
                //
                ASSERT(dwNumJobSetMembers > 1 &&
                       dwNumJobSetMembers <= sizeof(jobsetarray) / sizeof(jobsetarray[0]));
                ASSERT(hActualJobObject != NULL);
                Status = NtCreateJobSet(dwNumJobSetMembers, jobsetarray, 0);
                if (!NT_SUCCESS(Status)) {
                    JobCreationFailure:
                    for (; dwNumJobSetMembers > 0; dwNumJobSetMembers--) {
                        NtClose(jobsetarray[dwNumJobSetMembers - 1].JobHandle);
                    }
                    NtClose(hRestrictedToken);
                    goto ExitHandler2;
                }

                //
                // Close all Job Handles except the one that we are returning.
                //
                for (; dwNumJobSetMembers > 0; dwNumJobSetMembers--) {
                    if (jobsetarray[dwNumJobSetMembers - 1].JobHandle != hActualJobObject)
                        NtClose(jobsetarray[dwNumJobSetMembers - 1].JobHandle);
                }

                dwJobMemberLevel = 0;
            } else if (!NT_SUCCESS(Status)) {
                // Some other failure.
                goto ExitHandler2;
            } else {
                Status = STATUS_UNSUCCESSFUL;
                goto ExitHandler2;
            }
        }


        //
        // Pass back the restricted token, and the Job handle/level.
        //
        ASSERTMSG("Only one may be specified (job handle or job member)\n",
                  hActualJobObject == NULL || dwJobMemberLevel == 0);
        *phRestrictedToken = hRestrictedToken;
        *phAssignmentJob = hActualJobObject;
        *pdwJobMemberLevel = dwJobMemberLevel;
        Status = STATUS_SUCCESS;

    } else {
        //
        // Failed to identify an Authorization Level for this
        // application so it will not run.
        //
        *phRestrictedToken = NULL;
        *phAssignmentJob = NULL;
        *pdwJobMemberLevel = 0;
        Status = STATUS_ACCESS_DENIED;
    }

ExitHandler2:
    if (hProcessToken != NULL)
    {
        NtClose(hProcessToken);
    }

ExitHandler:

    RtlLeaveCriticalSection(&gcsAppCert);

    return Status;
}



NTSTATUS
BasepReplaceProcessThreadTokens(
    IN HANDLE       NewTokenHandle,
    IN HANDLE       ProcessHandle,
    IN HANDLE       ThreadHandle
    )
{
    typedef BOOL (WINAPI *CodeAuthzReplaceProcessThreadTokensT) (
        IN HANDLE       NewTokenHandle,
        IN HANDLE       ProcessHandle,
        IN HANDLE       ThreadHandle);

    NTSTATUS Status;
    static const ANSI_STRING ProcedureNameReplaceTokens =
            RTL_CONSTANT_STRING("SaferiReplaceProcessThreadTokens");
    static CodeAuthzReplaceProcessThreadTokensT
            lpfnCodeAuthzReplaceProcessThreadTokens = NULL;


    //
    // Enter a critical section for the entire trust evalation.
    // (We borrow the critical section used by AppCert).
    //
    RtlEnterCriticalSection(&gcsAppCert);


    //
    // Get a pointer to our private function in ADVAPI32.DLL.
    //
    if (!lpfnCodeAuthzReplaceProcessThreadTokens) {

        if (!AdvApi32ModuleHandle ||
            AdvApi32ModuleHandle == LongToHandle(-1) ||
            AdvApi32ModuleHandle == LongToHandle(-2))
        {
            // ADVAPI32 has not been loaded yet, or it was loaded
            // but we already failed to get one of our entrypoints.
            Status = STATUS_ENTRYPOINT_NOT_FOUND;
            goto ExitHandler;
        }


        Status = LdrGetProcedureAddress(
                AdvApi32ModuleHandle,
                (PANSI_STRING) &ProcedureNameReplaceTokens,
                0,
                (PVOID*)&lpfnCodeAuthzReplaceProcessThreadTokens);

        if (!NT_SUCCESS(Status) ||
            !lpfnCodeAuthzReplaceProcessThreadTokens) {
            //
            // Couldn't get the fn ptr. Make sure we won't try again
            //
            LdrUnloadDll(AdvApi32ModuleHandle);
            AdvApi32ModuleHandle = NULL;
            Status = STATUS_ENTRYPOINT_NOT_FOUND;
            goto ExitHandler;
        }
    }


    //
    // Actually call the function and return the results.
    //
    ASSERT(lpfnCodeAuthzReplaceProcessThreadTokens != NULL);
    if (!lpfnCodeAuthzReplaceProcessThreadTokens(
                    NewTokenHandle,
                    ProcessHandle,
                    ThreadHandle)) {
        Status = STATUS_UNSUCCESSFUL;
    } else {
        Status = STATUS_SUCCESS;
    }

ExitHandler:
    RtlLeaveCriticalSection(&gcsAppCert);
    return Status;
}





#if defined(_WIN64) || defined(BUILD_WOW6432)
BOOL
NtVdm64CreateProcess(
    BOOL fPrefixMappedApplicationName,
    LPCWSTR lpApplicationName,
    LPCWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );
#endif

#define PRIORITY_CLASS_MASK (NORMAL_PRIORITY_CLASS|IDLE_PRIORITY_CLASS|                 \
                             HIGH_PRIORITY_CLASS|REALTIME_PRIORITY_CLASS|               \
                             BELOW_NORMAL_PRIORITY_CLASS|ABOVE_NORMAL_PRIORITY_CLASS)

BOOL
WINAPI
CreateProcessInternalW(
    HANDLE hUserToken,
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation,
    PHANDLE hRestrictedUserToken
    )

/*++

Routine Description:

    This is the worker routine for CreateProcess and CreateProcessAsUser.
    CreateProcessAsUser supplies a User token to be stamped on the new process.
    CreateProcess supplies NULL and the current process token is used.

    A process and thread object are created and a handle opened to each
    object using CreateProcessInternal.  Note that WinExec and LoadModule are
    still supported, but are implemented as a call to CreateProcess.

Arguments:

    hUserToken - Supplies an optional token handle to be set on the new process.
        Process token is used is this parameter is NULL.

    lpApplicationName - Supplies an optional pointer to a null terminated
        character string that contains the name of the image file to
        execute.  This is a fully qualified DOS path name.  If not
        specified, then the image file name is the first whitespace
        delimited token on the command line.

    lpCommandLine - Supplies a null terminated character string that
        contains the command line for the application to be executed.
        The entire command line is made available to the new process
        using GetCommandLine.  If the lpApplicationName parameter was
        not specified, then the first token of the command line
        specifies file name of the application (note that this token
        begins at the beginning of the command line and ends at the
        first "white space" character).  If the file name does not
        contain an extension (the presence of a "."), then .EXE is
        assumed.  If the file name does not contain a directory path,
        Windows will search for the executable file in:

          - The current directory

          - The windows directory

          - The windows system directory

          - The directories listed in the path environment variable

        This parameter is optional onlu if the lpApplicationName
        parameter is specified.  In this case the command line the
        application receives will be the application name.

    lpProcessAttributes - An optional parameter that may be used to
        specify the attributes of the new process.  If the parameter is
        not specified, then the process is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation:

        SECURITY_ATTRIBUTES Structure:

        DWORD nLength - Specifies the length of this structure.  Must be
            set to sizeof( SECURITY_ATTRUBUTES ).

        LPVOID lpSecurityDescriptor - Points to a security descriptor for
            the object (must be NULL for Win32, used on NT/Win32). The
            security descriptor controls the sharing of an object.

        BOOL bInheritHandle - Supplies a flag that indicates whether
            or not the returned handle is to be inherited by a new
            process during process creation.  A value of TRUE
            indicates that the new process will inherit the handle.

    lpThreadAttributes - An optional parameter that may be used to specify
        the attributes of the new thread.  If the parameter is not
        specified, then the thread is created without a security
        descriptor, and the resulting handle is not inherited on
        process creation.

    dwCreationFlags - Supplies additional flags that control the creation
        of the process.

        dwCreationFlags Flags:

        DEBUG_PROCESS - If this flag bit is set, then the creating
            process is treated as a debugger, and the process being
            created is created as a debugee.  All debug events occuring
            in the debugee are reported to the debugger.  If this bit is
            clear, but the calling process is a debugee, then the
            process becomes a debugee of the calling processes debugger.
            If this bit is clear and the calling processes is not a
            debugee then no debug related actions occur.

        DEBUG_ONLY_THIS_PROCESS - If this flag is set, then the
            DEBUG_PROCESS flag bit must also be set.  The calling
            process is is treated as a debugger, and the new process is
            created as its debuggee.  If the new process creates
            additional processes, no debug related activities (with
            respect to the debugger) occur.

        CREATE_SUSPENDED - The process is created, but the initial thread
            of the process remains suspended. The creator can resume this
            thread using ResumeThread. Until this is done, code in the
            process will not execute.

        CREATE_UNICODE_ENVIRONMENT - If set, the environment pointer
            points to a Unicode environment block.  Otherwise, the
            block is ANSI (actually OEM.)

    bInheritHandles - Supplies a flag that specifies whether or not the
        new process is to inherit handles to objects visible to the
        calling process.  A value of TRUE causes handles to be inherited
        by the new process.  If TRUE was specified, then for each handle
        visible to the calling process, if the handle was created with
        the inherit handle option, the handle is inherited to the new
        process.  The handle has the same granted access in the new
        process as it has in the calling process, and the value of the
        handle is the same.

    lpEnvironment - An optional parameter, that if specified, supplies a
        pointer to an environment block.  If the parameter is not
        specified, the environment block of the current process is used.
        This environment block is made available to the new process
        using GetEnvironmentStrings.

    lpCurrentDirectory - An optional parameter, that if specified,
        supplies a string representing the current drive and directory
        for the new process.  The string must be a fully qualified
        pathname that includes a drive letter.  If the parameter is not
        specified, then the new process is created with the same current
        drive and directory as the calling process.  This option is
        provided primarily for shells that want to start an application
        and specify its initial drive and working directory.

    lpStartupInfo - Supplies information that specified how the
        applications window is to be shown. This structure is described
        in the Win32 User Interface API Book.

    lpProcessInformation - Returns identification information about the
        new process.

    PROCESS_INFORMATION Structure:

        HANDLE hProcess - Returns a handle to the newly created process.
            Through the handle, all operations on process objects are
            allowed.

        HANDLE hThread - Returns a handle to the newly created thread.
            Through the handle, all operations on thread objects are
            allowed.

        DWORD dwProcessId - Returns a global process id that may be used
            to identify a process.  The value is valid from the time the
            process is created until the time the process is terminated.

        DWORD dwThreadId - Returns a global thread id that may be used
            to identify a thread.  The value is valid from the time the
            thread is created until the time the thread is terminated.

    hRestrictedUserToken - Returns a restricted token if a UsetToken was
        supplied. This is applicable for the CreateProcessAsUser case.
        The token is released by CreateProcessAsUser.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE ProcessHandle, ThreadHandle, VdmWaitHandle = NULL;
    HANDLE FileHandle, SectionHandle;
    CLIENT_ID ClientId;
    UNICODE_STRING PathName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;
    LPWSTR FullPathBuffer;
    LPWSTR NameBuffer;
    LPWSTR WhiteScan;
    ULONG Length,i;
#if defined(BUILD_WOW6432)
    PROCESS_BASIC_INFORMATION ProcessInfo;
#endif
    SECTION_IMAGE_INFORMATION ImageInformation;
    BOOLEAN ImageInformationValid = FALSE;
    NTSTATUS StackStatus;
    BOOL bStatus;
    INITIAL_TEB InitialTeb;
    CONTEXT ThreadContext={0};
    PPEB Peb;
    BASE_API_MSG m;
    PBASE_CREATEPROCESS_MSG a = &m.u.CreateProcess;
    PBASE_CHECKVDM_MSG b = &m.u.CheckVDM;
    PWCH TempNull = NULL;
    WCHAR TempChar;
    UNICODE_STRING VdmNameString;
    PVOID BaseAddress;
    ULONG VdmReserve;
    SIZE_T BigVdmReserve;
    ULONG iTask=0;
    LPWSTR CurdirBuffer, CurdirFilePart;
    DWORD CurdirLength,CurdirLength2;
    ULONG VDMCreationState=0;
    ULONG VdmBinaryType = 0;
    BOOL  bMeowBinary = FALSE;
    UNICODE_STRING  SubSysCommandLine;
    PIMAGE_NT_HEADERS NtHeaders;
    DWORD dwNoWindow = (dwCreationFlags & CREATE_NO_WINDOW);
    ANSI_STRING AnsiStringVDMEnv;
    UNICODE_STRING UnicodeStringVDMEnv;
    WCHAR ImageFileDebuggerCommand[ MAX_PATH ];
    LPWSTR QuotedBuffer;
    BOOLEAN QuoteInsert;
    BOOLEAN QuoteCmdLine = FALSE;
    BOOLEAN QuoteFound;
    BOOLEAN SearchRetry;
    BOOLEAN IsWowBinary = FALSE;
    STARTUPINFOW StartupInfo;
    DWORD LastError;
    DWORD fileattr;
    PROCESS_PRIORITY_CLASS PriClass;
    PVOID State;
    HANDLE DebugPortHandle = NULL;
    PVOID pAppCompatData  = NULL;
    DWORD cbAppCompatData = 0;    // for the future
    DWORD dwFusionFlags = 0;
    BOOLEAN bVdmRetry = FALSE;
    BOOL bSaferChecksNeeded = FALSE;
    DWORD Flags;
    PVOID pAppCompatSxsData = NULL;
    DWORD cbAppCompatSxsData = 0;
    SXS_OVERRIDE_STREAM AppCompatSxsManifest;
    PCSR_CAPTURE_HEADER CaptureBuffer = NULL;
    SIZE_T SxsConglomeratedBufferSizeBytes;
    PBYTE SxsConglomeratedByteBuffer = NULL; // this contains all the of the below in one large right-sized heap allocation
                            // if we compute its size wrong, other code (if it gets it right..) should
                            // do more heap allocation
    ULONG sxsi; // for loop counter
    RTL_UNICODE_STRING_BUFFER SxsWin32ManifestPathBuffer;
    RTL_UNICODE_STRING_BUFFER SxsWin32PolicyPathBuffer;
    RTL_UNICODE_STRING_BUFFER SxsWin32AssemblyDirectoryBuffer;
    RTL_UNICODE_STRING_BUFFER SxsNtManifestPathBuffer;
    RTL_UNICODE_STRING_BUFFER SxsNtPolicyPathBuffer;
    const PRTL_UNICODE_STRING_BUFFER SxsStringBuffers[] = {
        // The order here does not matter.
        &SxsWin32ManifestPathBuffer,
        &SxsWin32PolicyPathBuffer,
        &SxsWin32AssemblyDirectoryBuffer,
        &SxsNtManifestPathBuffer,
        &SxsNtPolicyPathBuffer
    };
    UNICODE_STRING SxsWin32ExePath;
    UNICODE_STRING SxsNtExePath;
    BASE_MSG_SXS_HANDLES SxsExeHandles = {0};
    BASE_MSG_SXS_HANDLES SxsManifestFileHandles = {0};
    CONST SXS_CONSTANT_WIN32_NT_PATH_PAIR SxsExePathPair = { &SxsWin32ExePath, &SxsNtExePath };
    CONST SXS_WIN32_NT_PATH_PAIR SxsManifestPathPair = { &SxsWin32ManifestPathBuffer, &SxsNtManifestPathBuffer };
    CONST SXS_WIN32_NT_PATH_PAIR SxsPolicyPathPair = { &SxsWin32PolicyPathBuffer, &SxsNtPolicyPathBuffer };
    BASE_MSG_SXS_HANDLES SxsPolicyHandles = {0};
    PWSTR ExePathFullBuffer = NULL;

    DWORD dwJobMemberLevel = 0;
    HANDLE hSaferAssignmentJob = NULL;
    HANDLE hSaferRestrictedToken = NULL;

    DWORD dwBasePushProcessParametersFlags = 0;
    LPWSTR PathToSearch = NULL;
    
    SECURITY_ATTRIBUTES LocalProcessAttributes = {0};
    SECURITY_ATTRIBUTES LocalThreadAttributes = {0};

#if defined(BUILD_WOW6432) || defined(_WIN64)
    BOOLEAN ComPlusILImage;
    LPCWSTR lpOriginalApplicationName = lpApplicationName;
    LPWSTR lpOriginalCommandLine = lpCommandLine;
#endif
    PTEB Teb;
    PVOID ArbitraryUserPointer;

#if defined(WX86)
    HANDLE Wx86Info = NULL;
#endif

#if defined WX86
    BOOLEAN UseKnownWx86Dll;
    UseKnownWx86Dll = NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll;
    NtCurrentTeb()->Wx86Thread.UseKnownWx86Dll = FALSE;
#endif

    Teb = NtCurrentTeb();
    RtlZeroMemory(&a->Sxs, sizeof(a->Sxs));
    RtlZeroMemory(lpProcessInformation,sizeof(*lpProcessInformation));

    if (ARGUMENT_PRESENT( hRestrictedUserToken )) {
        *hRestrictedUserToken = NULL;
        }

    // Private VDM flag should be ignored; Its meant for internal use only.
    dwCreationFlags &= (ULONG)~CREATE_NO_WINDOW;

    if ((dwCreationFlags & (DETACHED_PROCESS | CREATE_NEW_CONSOLE)) ==
        (DETACHED_PROCESS | CREATE_NEW_CONSOLE)) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }

    AnsiStringVDMEnv.Buffer = NULL;
    UnicodeStringVDMEnv.Buffer = NULL;

    //
    // the lowest specified priority class is used.
    //

    if (dwCreationFlags & IDLE_PRIORITY_CLASS ) {
        PriClass.PriorityClass = PROCESS_PRIORITY_CLASS_IDLE;
        }
    else if (dwCreationFlags & BELOW_NORMAL_PRIORITY_CLASS ) {
        PriClass.PriorityClass = PROCESS_PRIORITY_CLASS_BELOW_NORMAL;
        }
    else if (dwCreationFlags & NORMAL_PRIORITY_CLASS ) {
        PriClass.PriorityClass = PROCESS_PRIORITY_CLASS_NORMAL;
        }
    else if (dwCreationFlags & ABOVE_NORMAL_PRIORITY_CLASS ) {
        PriClass.PriorityClass = PROCESS_PRIORITY_CLASS_ABOVE_NORMAL;
        }
    else if (dwCreationFlags & HIGH_PRIORITY_CLASS ) {
        PriClass.PriorityClass =  PROCESS_PRIORITY_CLASS_HIGH;
        }
    else if (dwCreationFlags & REALTIME_PRIORITY_CLASS ) {
        if ( BasepIsRealtimeAllowed(FALSE) ) {
            PriClass.PriorityClass =  PROCESS_PRIORITY_CLASS_REALTIME;
            }
        else {
            PriClass.PriorityClass =  PROCESS_PRIORITY_CLASS_HIGH;
            }
        }
    else {
        PriClass.PriorityClass = PROCESS_PRIORITY_CLASS_UNKNOWN;
        }
    PriClass.Foreground = FALSE;

    dwCreationFlags = (dwCreationFlags & ~PRIORITY_CLASS_MASK );

    //
    // Default separate/shared VDM option if not explicitly specified.
    //

    if (dwCreationFlags & CREATE_SEPARATE_WOW_VDM) {
        if (dwCreationFlags & CREATE_SHARED_WOW_VDM) {
            SetLastError(ERROR_INVALID_PARAMETER);

            return FALSE;
            }
        }
    else if ((dwCreationFlags & CREATE_SHARED_WOW_VDM) == 0) {
        if (BaseStaticServerData->DefaultSeparateVDM) {
            dwCreationFlags |= CREATE_SEPARATE_WOW_VDM;
            }
        }

    if ((dwCreationFlags & CREATE_SEPARATE_WOW_VDM) == 0) {
        //
        // If the creator is running inside a job object, always
        // set SEPERATE_WOW_VDM so the VDM is part of the job.
        //
        if (NtIsProcessInJob (NtCurrentProcess (), NULL) == STATUS_PROCESS_IN_JOB) {
            dwCreationFlags = (dwCreationFlags & (~CREATE_SHARED_WOW_VDM)) |
                                  CREATE_SEPARATE_WOW_VDM;
            }
        }


    //
    //  If ANSI environment, convert to Unicode
    //

    if (lpEnvironment && !(dwCreationFlags & CREATE_UNICODE_ENVIRONMENT) ) {
        PUCHAR s;
        STRING Ansi;
        UNICODE_STRING Unicode;
        MEMORY_BASIC_INFORMATION MemoryInformation;

        Ansi.Buffer = s = lpEnvironment;
        while (*s || *(s+1))            // find end of block
            s++;

        Ansi.Length = (USHORT)(s - Ansi.Buffer) + 1;
        Ansi.MaximumLength = Ansi.Length + 1;
        MemoryInformation.RegionSize = Ansi.MaximumLength * sizeof(WCHAR);
        Unicode.Buffer = NULL;
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &Unicode.Buffer,
                                          0,
                                          &MemoryInformation.RegionSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
        if (!NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);

            return FALSE;
            }

        Unicode.MaximumLength = (USHORT)MemoryInformation.RegionSize;
        Status = RtlAnsiStringToUnicodeString(&Unicode, &Ansi, FALSE);
        if (!NT_SUCCESS(Status) ) {
            NtFreeVirtualMemory( NtCurrentProcess(),
                                 &Unicode.Buffer,
                                 &MemoryInformation.RegionSize,
                                 MEM_RELEASE
                               );
            BaseSetLastNTError(Status);

            return FALSE;
            }
        lpEnvironment = Unicode.Buffer;
        }

    FileHandle = NULL;
    SectionHandle = NULL;
    ProcessHandle = NULL;
    ThreadHandle = NULL;
    FreeBuffer = NULL;
    NameBuffer = NULL;
    VdmNameString.Buffer = NULL;
    BaseAddress = (PVOID)1;
    VdmReserve = 0;
    CurdirBuffer = NULL;
    CurdirFilePart = NULL;
    SubSysCommandLine.Buffer = NULL;
    QuoteFound = FALSE;
    QuoteInsert = FALSE;
    QuotedBuffer = NULL;

    try {

        //
        // Make a copy of the startup info so we can change it.
        //

        StartupInfo = *lpStartupInfo;

        //
        // STARTF_USEHOTKEY means hStdInput is really the hotkey value.
        // STARTF_HASSHELLDATA means std handles are used for shell-private
        // data.  This flag is used if an icon is passed to ShellExecuteEx.
        // As a result they cannot be specified with STARTF_USESTDHANDLES.
        // Consistent with Win95, USESTDHANDLES is ignored.
        //

        if (StartupInfo.dwFlags & STARTF_USESTDHANDLES &&
            StartupInfo.dwFlags & (STARTF_USEHOTKEY | STARTF_HASSHELLDATA)) {

            StartupInfo.dwFlags &= ~STARTF_USESTDHANDLES;
            }

VdmRetry:
        //
        // None of this cleanup/reinit occurs for launching a Win32 or Win64 .exe,
        // but they generally do occur for launching 16bit, .bat, etc.
        //
        if (NameBuffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, NameBuffer);
            NameBuffer = NULL;
        }
        if (FreeBuffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
            FreeBuffer = NULL;
        }
        if (FileHandle) {
            NtClose(FileHandle);
            FileHandle = NULL;
        }

        LastError = 0;
        SearchRetry = TRUE;
        QuoteInsert = FALSE;
        QuoteCmdLine = FALSE;
        if (!ARGUMENT_PRESENT( lpApplicationName )) {

            //
            // Locate the image
            //

            // forgot to free NameBuffer before goto VdmRetry???
            ASSERT(NameBuffer == NULL);

            NameBuffer = RtlAllocateHeap( RtlProcessHeap(),
                                          MAKE_TAG( TMP_TAG ),
                                          MAX_PATH * sizeof( WCHAR ));
            if ( !NameBuffer ) {
                BaseSetLastNTError(STATUS_NO_MEMORY);
                bStatus = FALSE;
                leave;
                }
            lpApplicationName = lpCommandLine;
            TempNull = (PWCH)lpApplicationName;
            WhiteScan = (LPWSTR)lpApplicationName;

            //
            // check for lead quote
            //
            if ( *WhiteScan == L'\"' ) {
                SearchRetry = FALSE;
                WhiteScan++;
                lpApplicationName = WhiteScan;
                while(*WhiteScan) {
                    if ( *WhiteScan == (WCHAR)'\"' ) {
                        TempNull = (PWCH)WhiteScan;
                        QuoteFound = TRUE;
                        break;
                        }
                    WhiteScan++;
                    TempNull = (PWCH)WhiteScan;
                    }
                }
            else {
retrywsscan:
                lpApplicationName = lpCommandLine;
                while(*WhiteScan) {
                    if ( *WhiteScan == (WCHAR)' ' ||
                         *WhiteScan == (WCHAR)'\t' ) {
                        TempNull = (PWCH)WhiteScan;
                        break;
                        }
                    WhiteScan++;
                    TempNull = (PWCH)WhiteScan;
                    }
                }
            TempChar = *TempNull;
            *TempNull = UNICODE_NULL;

#ifdef WX86

            //
            // Wx86 applications must use x86 version of known exes
            // for compatibility.
            //

            if (UseKnownWx86Dll) {
               LPWSTR KnownName;

               Teb->Wx86Thread.UseKnownWx86Dll = FALSE;

               KnownName = BasepWx86KnownExe(lpApplicationName);
               if (KnownName) {
                  lpApplicationName = KnownName;
                  }
               }
#endif

            if (PathToSearch) {
                RtlFreeHeap(RtlProcessHeap(), 0, PathToSearch);
                PathToSearch = NULL;
            }

            PathToSearch = BaseComputeProcessExePath(lpApplicationName);

            if (! PathToSearch) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                bStatus = FALSE;
                leave;
            }

            Length = SearchPathW(
                        PathToSearch,
                        lpApplicationName,
                        L".exe",
                        MAX_PATH,
                        NameBuffer,
                        NULL
                        )*2;

            if (Length != 0 && Length < MAX_PATH * sizeof( WCHAR )) {
                //
                // SearchPathW worked, but file might be a directory
                // if this happens, we need to keep trying
                //
                fileattr = GetFileAttributesW(NameBuffer);
                if ( fileattr != 0xffffffff &&
                     (fileattr & FILE_ATTRIBUTE_DIRECTORY) ) {
                    Length = 0;
                } else {
                    Length++;
                    Length++;
                }
            }

            if ( !Length || Length >= MAX_PATH<<1 ) {

                //
                // If we search pathed, then return file not found.
                // otherwise, try to be more specific.
                //
                RTL_PATH_TYPE PathType;
                HANDLE hFile;

                PathType = RtlDetermineDosPathNameType_U(lpApplicationName);
                if ( PathType != RtlPathTypeRelative ) {

                    //
                    // The failed open should set get last error properly.
                    //

                    hFile = CreateFileW(
                                lpApplicationName,
                                GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                                );
                    if ( hFile != INVALID_HANDLE_VALUE ) {
                        CloseHandle(hFile);
                        BaseSetLastNTError(STATUS_OBJECT_NAME_NOT_FOUND);
                        }
                    }
                else {
                    BaseSetLastNTError(STATUS_OBJECT_NAME_NOT_FOUND);
                    }

                //
                // remember initial last error value for the retry scan path
                //

                if ( LastError ) {
                    SetLastError(LastError);
                    }
                else {
                    LastError = GetLastError();
                    }

                //
                // restore the command line
                //

                *TempNull = TempChar;
                lpApplicationName = NameBuffer;

                //
                // If we still have command line left, then keep going
                // the point is to march through the command line looking
                // for whitespace so we can try to find an image name
                // launches of things like:
                // c:\word 95\winword.exe /embedding -automation
                // require this. Our first iteration will stop at c:\word, our next
                // will stop at c:\word 95\winword.exe
                //
                if (*WhiteScan && SearchRetry) {
                    WhiteScan++;
                    TempNull = WhiteScan;
                    QuoteInsert = TRUE;
                    QuoteFound = TRUE;
                    goto retrywsscan;
                }

                bStatus = FALSE;
                leave;
                }
            //
            // restore the command line
            //

            *TempNull = TempChar;
            lpApplicationName = NameBuffer;
        }
        else
        if (!ARGUMENT_PRESENT( lpCommandLine ) || *lpCommandLine == UNICODE_NULL ) {
            QuoteCmdLine = TRUE;
            lpCommandLine = (LPWSTR)lpApplicationName;
            }


#ifdef WX86

       //
       // Wx86 applications must use x86 version of known exes
       // for compatibility.
       //

       if (UseKnownWx86Dll) {
           LPWSTR KnownName;

           Teb->Wx86Thread.UseKnownWx86Dll = FALSE;

           KnownName = BasepWx86KnownExe(lpApplicationName);
           if (KnownName) {

               RtlFreeHeap(RtlProcessHeap(), 0, NameBuffer);
               NameBuffer = KnownName;
               lpApplicationName = KnownName;
               }
           }

#endif

        //
        // Translate to an NT name.
        //

        TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                                lpApplicationName,
                                &PathName,
                                NULL,
                                &RelativeName
                                );

        if ( !TranslationStatus ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            bStatus = FALSE;
            leave;
            }

        // forgot to free FreeBuffer before goto VdmRetry????
        ASSERT(FreeBuffer == NULL);
        FreeBuffer = PathName.Buffer;

        //
        // save full path buffer ptr
        // we need this pointer to verify application compatibility cache
        // use of PathName.Buffer is restricted since it will be optimized to use
        // relative path
        //
        FullPathBuffer = PathName.Buffer;

        //
        // We already have the full NT path but the Win32 path we
        // have might be relative; get the full Win32 path.
        //
        {
            RTL_PATH_TYPE SxsWin32ExePathType;

            RtlInitUnicodeString(&SxsWin32ExePath, lpApplicationName);
            SxsWin32ExePathType = RtlDetermineDosPathNameType_U(lpApplicationName);

            if ((SxsWin32ExePathType != RtlPathTypeDriveAbsolute) &&
                (SxsWin32ExePathType != RtlPathTypeLocalDevice) &&
                (SxsWin32ExePathType != RtlPathTypeRootLocalDevice) &&
                (SxsWin32ExePathType != RtlPathTypeUncAbsolute)) {

                UNICODE_STRING ExePathFullBufferString;

                RtlInitEmptyUnicodeString(&ExePathFullBufferString, NULL, 0);

                Status = RtlGetFullPathName_UstrEx(
                    &SxsWin32ExePath,
                    NULL, // statically sized string
                    &ExePathFullBufferString, // dynamically sized string
                    NULL, // OUT PUNICODE_STRING *StringUsed (always the dynamic one)
                    NULL, // OUT SIZE_T *FilePartPrefixCch OPTIONAL
                    NULL, // OUT PBOOLEAN NameInvalid OPTIONAL
                    &SxsWin32ExePathType, // We're done with this variable
                                          // so reuse it. We don't use
                                          // the returned value, but
                                          // it is not optional.
                    NULL // OUT SIZE_T *BytesRequired OPTIONAL
                    );
                if ( !NT_SUCCESS(Status)) {
                    RtlReleaseRelativeName(&RelativeName);
                    BaseSetLastNTError(Status);
                    bStatus = FALSE;
                    leave;
                }

                SxsWin32ExePath = ExePathFullBufferString;
                ExePathFullBuffer = ExePathFullBufferString.Buffer;
                ExePathFullBufferString.Buffer = NULL;
            }
        }

        SxsNtExePath = PathName;

        if ( RelativeName.RelativeName.Length ) {
            PathName = RelativeName.RelativeName;
            }
        else {
            RelativeName.ContainingDirectory = NULL;
            }

        InitializeObjectAttributes(
            &Obja,
            &PathName,
            OBJ_CASE_INSENSITIVE,
            RelativeName.ContainingDirectory,
            NULL
            );

        //
        // Open the file for execute access
        //

        Status = NtOpenFile(
                    &FileHandle,
                    SYNCHRONIZE | FILE_EXECUTE | FILE_READ_ATTRIBUTES | FILE_READ_DATA,
                    &Obja,
                    &IoStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_DELETE,
                    FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                    );

        if (!NT_SUCCESS(Status) ) {
            Status = NtOpenFile(
                        &FileHandle,
                        SYNCHRONIZE | FILE_EXECUTE,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                        );
        }

        RtlReleaseRelativeName(&RelativeName);

        if (!NT_SUCCESS(Status) ) {

            //
            // if we failed, see if this is a device. If it is a device,
            // then just return invalid image format
            //

            if ( RtlIsDosDeviceName_U(lpApplicationName) ) {
                SetLastError(ERROR_BAD_DEVICE);
                }
            else {
                BaseSetLastNTError(Status);
                }

            bStatus = FALSE;
            leave;
            }


        //
        // If no desktop has been specified, use the caller's
        // desktop.
        //

        if (StartupInfo.lpDesktop == NULL) {
            StartupInfo.lpDesktop =
                    (LPWSTR)((PRTL_USER_PROCESS_PARAMETERS)NtCurrentPeb()->
                        ProcessParameters)->DesktopInfo.Buffer;
            }

        //
        // Create a section object backed by the file
        //

        Status = NtCreateSection(
                    &SectionHandle,
                    SECTION_ALL_ACCESS,
                    NULL,
                    NULL,
                    PAGE_EXECUTE,
                    SEC_IMAGE,
                    FileHandle
                    );

        //
        // Web blade SKU restrictions handling
        //
        //  Webblade restrictions handling (for PE format exes only)
        //
        if ( IsWebBlade() &&
             STATUS_INVALID_IMAGE_NOT_MZ != Status &&
             STATUS_INVALID_IMAGE_LE_FORMAT != Status &&
             STATUS_INVALID_IMAGE_PROTECT != Status &&
             STATUS_INVALID_IMAGE_WIN_16 != Status ) {

            NTSTATUS BladeStatus = BasepCheckWebBladeHashes( FileHandle );

            if ( BladeStatus == STATUS_ACCESS_DENIED ) {
                SetLastError(ERROR_ACCESS_DISABLED_WEBBLADE);
                bStatus = FALSE;
                leave;
            }

            if (!NT_SUCCESS(BladeStatus)) {
                SetLastError(ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER);
                bStatus = FALSE;
                leave;
            }
        }


        //
        // App Certification DLL
        //

        if (NT_SUCCESS(Status)) {
            Status = BasepIsProcessAllowed(lpApplicationName);

            if (!NT_SUCCESS(Status)) {
                BaseSetLastNTError(Status);
                NtClose(SectionHandle);
                SectionHandle = NULL;
                bStatus = FALSE;
                leave;
            }



          //
          // If Meow subsystem is enabled and caller specified CREATE_FORECEDOS for a win32 image
          // push it into the meow subsystem
          //

          if ((dwCreationFlags & CREATE_FORCEDOS) && BaseStaticServerData->ForceDos) {
               dwCreationFlags &= ~(CREATE_SHARED_WOW_VDM | CREATE_FORCEDOS);
               dwCreationFlags |= CREATE_SEPARATE_WOW_VDM;
               Status = STATUS_INVALID_IMAGE_WIN_16;
               bMeowBinary = TRUE;

               NtClose(SectionHandle);
               SectionHandle = NULL;
               ImageInformationValid = FALSE;
          }


       }

        //
        // check appcompat (aka apphelp)
        //
        // if we are running under debugger, bVdmRetry will be FALSE
        // yet pAppCompatData may have some data (from the app itself)
        // debugger will do a separate CreateProcess on debugee
        //
        // apphelp gets called if it is win32 app or if it is a .bat or .cmd

       if(!bVdmRetry &&
          (NT_SUCCESS(Status) ||
           (Status == STATUS_INVALID_IMAGE_NOT_MZ && !BaseIsDosApplication(&PathName,Status)))
         ) {
            NTSTATUS BadAppStatus;
            USHORT   uExeType = 0;
            NTSTATUS Status1;

            BasepFreeAppCompatData(pAppCompatData, cbAppCompatData, pAppCompatSxsData, cbAppCompatSxsData);
            pAppCompatData    = NULL;
            pAppCompatSxsData = NULL;

            if (SectionHandle != NULL) {
                if (!ImageInformationValid) {
                    Status1 = NtQuerySection (SectionHandle,
                                              SectionImageInformation,
                                              &ImageInformation,
                                              sizeof( ImageInformation ),
                                              NULL);
                } else {
                    Status1 = STATUS_SUCCESS;
                }

                if (NT_SUCCESS (Status1)) {
                    ImageInformationValid = TRUE;
                    uExeType = ImageInformation.Machine;
                }
            }

            //
            // we only check ONCE --
            // the second time around is rather meaningless - to check for posix/ntvdm/os2 emulation
            //
            BadAppStatus = BasepCheckBadapp(FileHandle,
                                            FullPathBuffer,
                                            (WCHAR*)lpEnvironment,
                                            uExeType,
                                            &pAppCompatData,
                                            &cbAppCompatData,
                                            &pAppCompatSxsData,
                                            &cbAppCompatSxsData,
                                            &dwFusionFlags);

            if (!NT_SUCCESS(BadAppStatus)) {
                if (BadAppStatus == STATUS_ACCESS_DENIED) {
                    SetLastError(ERROR_CANCELLED);
                } else {
                    BaseSetLastNTError(BadAppStatus);
                }

                if (SectionHandle) {
                    NtClose(SectionHandle);
                    SectionHandle = NULL;
                }
                bStatus = FALSE;
                leave;
            }
        }

        ASSERT((dwFusionFlags & ~SXS_APPCOMPACT_FLAG_APP_RUNNING_SAFEMODE) == 0);

        //
        // Winsafer code
        //
        // If this is the first time then we will have to do Safer checks.
        // Note that we do not impose any restrictions on the interpreter
        // itself since it is part of OS.
        //


        if ((!bVdmRetry) &&
            ( (dwCreationFlags & CREATE_PRESERVE_CODE_AUTHZ_LEVEL) == 0 )) {

            NTSTATUS SaferStatus;

            bSaferChecksNeeded = TRUE;

            //
            // We do not want to restrict .txt files. So, skip Safer checks in
            // the default error case.
            //

            if (!NT_SUCCESS(Status)) {
                switch (Status) {
                    case STATUS_INVALID_IMAGE_NE_FORMAT:
                    case STATUS_INVALID_IMAGE_WIN_16:
                    case STATUS_FILE_IS_OFFLINE:
                    case STATUS_INVALID_IMAGE_PROTECT:
                        break;
                    case STATUS_INVALID_IMAGE_NOT_MZ:
                        if (BaseIsDosApplication(&PathName,Status))
                        {
                            break;
                        }
                    default :
                        bSaferChecksNeeded = FALSE;
                }
            }


            if (bSaferChecksNeeded) {

                //
                // WinSafer process sandbox restrictions handling.
                // Should be done for non .NET images only.
                //

                SaferStatus = BasepCheckWinSaferRestrictions(
                                                       hUserToken,
                                                       lpApplicationName,   // same as PathName.Buffer
                                                       FileHandle,
                                                       &dwJobMemberLevel,
                                                       &hSaferRestrictedToken,
                                                       &hSaferAssignmentJob);
                if (SaferStatus == -1) {
                    SetLastError(ERROR_ACCESS_DISABLED_BY_POLICY);
                    bStatus =  FALSE;
                    leave;
                } else if (!NT_SUCCESS(SaferStatus)) {
                    BaseSetLastNTError(SaferStatus);
                    bStatus = FALSE;
                    leave;
                }
            }
        }

        if (!NT_SUCCESS(Status)) {
            switch (Status) {
                // 16 bit OS/2 exe
                case STATUS_INVALID_IMAGE_NE_FORMAT:
#if defined(i386) && defined(OS2_SUPPORT_ENABLED)
                //
                // Use OS/2 if x86 (OS/2 not supported on risc),
                //    and CreationFlags don't have forcedos bit
                //    and Registry didn't specify ForceDos
                //
                // else execute as a DOS bound app.
                //
                //

                if (!(dwCreationFlags & CREATE_FORCEDOS) &&
                    !BaseStaticServerData->ForceDos)
                  {

                    if ( !BuildSubSysCommandLine( L"OS2 /P ",
                                                  lpApplicationName,
                                                  lpCommandLine,
                                                  &SubSysCommandLine
                                                ) ) {
                        bStatus = FALSE;
                        leave;
                        }

                    lpCommandLine = SubSysCommandLine.Buffer;

                    lpApplicationName = NULL;

                    bVdmRetry = TRUE;
                    goto VdmRetry;
                    }
#endif
                    // Falls into Dos case, so that stub message will be
                    // printed, and bound apps will run w/o OS/2 subsytem

                // Dos .exe or .com

                case STATUS_INVALID_IMAGE_PROTECT:
                case STATUS_INVALID_IMAGE_NOT_MZ:
ForceDos:
                    {
                    ULONG BinarySubType;

                    BinarySubType = BINARY_TYPE_DOS_EXE;
                    if (Status == STATUS_INVALID_IMAGE_PROTECT   ||
                        Status == STATUS_INVALID_IMAGE_NE_FORMAT ||
                       (BinarySubType = BaseIsDosApplication(&PathName,Status)) )
                       {
#if defined(_WIN64) || defined(BUILD_WOW6432)
                        //
                        // If this a DOS application, then we need to pop up a dialog
                        // saying that this an invalid win32 application.
                        //
                        goto RaiseInvalidWin32Error;
#endif
                        VdmBinaryType = BINARY_TYPE_DOS;

                        // create the environment before going to the
                        // server. This was done becuase we want NTVDM
                        // to have the new environment when it gets
                        // created.
                        if (!BaseCreateVDMEnvironment(
                                    lpEnvironment,
                                    &AnsiStringVDMEnv,
                                    &UnicodeStringVDMEnv
                                    )) {
                            bStatus = FALSE;
                            leave;
                        }

                        Status = BaseCheckVDM(VdmBinaryType | BinarySubType,
                                         lpApplicationName,
                                         lpCommandLine,
                                         lpCurrentDirectory,
                                         &AnsiStringVDMEnv,
                                         &m,
                                         &iTask,
                                         dwCreationFlags,
                                         &StartupInfo,
                                         NULL
                                         );
                        if (!NT_SUCCESS(Status)) {
                            BaseSetLastNTError(Status);
                            bStatus = FALSE;
                            leave;
                        }

                        // Check the return value from the server
                        switch (b->VDMState & VDM_STATE_MASK) {
                            case VDM_NOT_PRESENT:
                                // mark this so the server can undo
                                // creation if something goes wrong.
                                // We marked it "partially created" because
                                // the NTVDM has yet not been fully created.
                                // a call to UpdateVdmEntry to update
                                // process handle will signal the NTVDM
                                // process completed creation
                                VDMCreationState = VDM_PARTIALLY_CREATED;
                                // fail the call if NTVDM process is being
                                // created DETACHED.
                                // note that, we let it go if NTVDM process
                                // is already running.
                                if (dwCreationFlags & DETACHED_PROCESS) {
                                    SetLastError(ERROR_ACCESS_DENIED);
                                    bStatus = FALSE;
                                    leave;
                                    }
                                if (!BaseGetVdmConfigInfo(lpCommandLine,
                                                          iTask,
                                                          VdmBinaryType,
                                                          &VdmNameString,
                                                          &VdmReserve)) {
                                    BaseSetLastNTError(Status);
                                    bStatus = FALSE;
                                    leave;
                                    }

                                lpCommandLine = VdmNameString.Buffer;
                                lpApplicationName = NULL;

                                break;

                            case VDM_PRESENT_NOT_READY:
                                SetLastError (ERROR_NOT_READY);
                                bStatus = FALSE;
                                leave;

                            case VDM_PRESENT_AND_READY:
                                VDMCreationState = VDM_BEING_REUSED;
                                VdmWaitHandle = b->WaitObjectForParent;
                                break;
                            }
                         VdmReserve--;               // we reserve from addr 1
                         if(VdmWaitHandle)
                            goto VdmExists;
                         else{
                            bInheritHandles = FALSE;
                            if (lpEnvironment &&
                                !(dwCreationFlags & CREATE_UNICODE_ENVIRONMENT)){
                                RtlDestroyEnvironment(lpEnvironment);
                                }
                            lpEnvironment = UnicodeStringVDMEnv.Buffer;
                            bVdmRetry = TRUE;
                            goto VdmRetry;
                            }
                        }
                    else {

                        //
                        //  must be a .bat or .cmd file
                        //

                        static PWCHAR CmdPrefix = L"cmd /c ";
                        PWCHAR NewCommandLine;
                        ULONG Length;
                        PWCHAR Last4 = &PathName.Buffer[PathName.Length / sizeof( WCHAR )-4];

                        if ( PathName.Length < 8 ) {
                            SetLastError(ERROR_BAD_EXE_FORMAT);
                            bStatus = FALSE;
                            leave;
                            }

                        if (_wcsnicmp( Last4, L".bat", 4 ) && _wcsnicmp( Last4, L".cmd", 4 )) {
                            SetLastError(ERROR_BAD_EXE_FORMAT);
                            bStatus = FALSE;
                            leave;
                        }

                        Length = wcslen( CmdPrefix )
                                 + (QuoteCmdLine || QuoteFound )
                                 + wcslen( lpCommandLine )
                                 + (QuoteCmdLine || QuoteFound)
                                 + 1;

                        NewCommandLine = RtlAllocateHeap( RtlProcessHeap( ),
                                                          MAKE_TAG( TMP_TAG ),
                                                          Length * sizeof( WCHAR ) );

                        if (NewCommandLine == NULL) {
                            BaseSetLastNTError(STATUS_NO_MEMORY);
                            bStatus = FALSE;
                            leave;
                        }

                        wcscpy( NewCommandLine, CmdPrefix );
                        if (QuoteCmdLine || QuoteFound) {
                            wcscat( NewCommandLine, L"\"" );
                        }
                        wcscat( NewCommandLine, lpCommandLine );
                        if (QuoteCmdLine || QuoteFound) {
                            wcscat( NewCommandLine, L"\"" );
                        }

                        RtlInitUnicodeString( &SubSysCommandLine, NewCommandLine );

                        lpCommandLine = SubSysCommandLine.Buffer;

                        lpApplicationName = NULL;

                        bVdmRetry = TRUE;
                        goto VdmRetry;

                        }

                    }

                // 16 bit windows exe
                case STATUS_INVALID_IMAGE_WIN_16:
#if defined(BUILD_WOW6432) || defined(_WIN64)
                   if (lpOriginalApplicationName == NULL) {
                       // pass in the part of the command line after the exe name
                       // including whitespace
                       lpCommandLine = ((*TempNull == '\"') ? TempNull + 1 : TempNull);
                   } else {
                       lpCommandLine = lpOriginalCommandLine;
                   }

                   bStatus = NtVdm64CreateProcess(lpOriginalApplicationName == NULL,
                                               lpApplicationName,             // this is now the real file name we've loaded
                                               lpCommandLine,
                                               lpProcessAttributes,
                                               lpThreadAttributes,
                                               bInheritHandles,
                                               (dwCreationFlags & ~CREATE_UNICODE_ENVIRONMENT),  // the environment has already been converted to unicode
                                               lpEnvironment,
                                               lpCurrentDirectory,
                                               lpStartupInfo,
                                               lpProcessInformation
                                               );
                   leave;
#endif
                   if (dwCreationFlags & CREATE_FORCEDOS) {
                       goto ForceDos;
                       }

                    IsWowBinary = TRUE;
                    if (!BaseCreateVDMEnvironment(lpEnvironment,
                                                  &AnsiStringVDMEnv,
                                                  &UnicodeStringVDMEnv)) {
                        bStatus = FALSE;
                        leave;
                        }

RetrySepWow:
                    VdmBinaryType = dwCreationFlags & CREATE_SEPARATE_WOW_VDM
                                     ? BINARY_TYPE_SEPWOW : BINARY_TYPE_WIN16;

                    Status = BaseCheckVDM(VdmBinaryType,
                                      lpApplicationName,
                                      lpCommandLine,
                                      lpCurrentDirectory,
                                      &AnsiStringVDMEnv,
                                      &m,
                                      &iTask,
                                      dwCreationFlags,
                                      &StartupInfo,
                                      hUserToken
                                      );
                    if (!NT_SUCCESS(Status)) {

                        BaseSetLastNTError(Status);

                        //
                        // If we failed with access denied, caller may not
                        // be allowed allowed to access the shared wow's
                        // desktop, so retry as a separate wow
                        //
                        if (STATUS_VDM_DISALLOWED != Status &&
                            VdmBinaryType == BINARY_TYPE_WIN16 &&
                            GetLastError() == ERROR_ACCESS_DENIED)
                          {
                           dwCreationFlags |= CREATE_SEPARATE_WOW_VDM;
                           }
                        else {
                            bStatus = FALSE;
                            leave;
                            }
                        goto RetrySepWow;
                        }

                    // Check the return value from the server
                    switch (b->VDMState & VDM_STATE_MASK){
                        case VDM_NOT_PRESENT:
                            // mark this so the server can undo
                            // creation if something goes wrong.
                            // We marked it "partitially created" because
                            // the NTVDM has yet not been fully created.
                            // a call to UpdateVdmEntry to update
                            // process handle will signal the NTVDM
                            // process completed creation

                            VDMCreationState = VDM_PARTIALLY_CREATED;

                            // jarbats: 1/8/2001
                            // Tell BaseGetVdmConfigInfo to create
                            // vdm commandline for meow
                            //

                            if (bMeowBinary)
                               {
                               VdmReserve = 1;
                               }

                            if (!BaseGetVdmConfigInfo(
                                    lpCommandLine,
                                    iTask,
                                    VdmBinaryType,
                                    &VdmNameString,
                                    &VdmReserve
                                    )) {
                                BaseSetLastNTError(Status);
                                bStatus = FALSE;
                                leave;
                                }

                            lpCommandLine = VdmNameString.Buffer;
                            lpApplicationName = NULL;


                            //
                            // Wow must have a hidden console
                            // Throw away DETACHED_PROCESS flag which isn't
                            // meaningful for Win16 apps.
                            //

                            dwCreationFlags |= CREATE_NO_WINDOW;
                            dwCreationFlags &= ~(CREATE_NEW_CONSOLE | DETACHED_PROCESS);


                            //
                            // We're starting a WOW VDM, turn on feedback unless
                            // the creator passed STARTF_FORCEOFFFEEDBACK.
                            //

                            StartupInfo.dwFlags |= STARTF_FORCEONFEEDBACK;

                            break;

                        case VDM_PRESENT_NOT_READY:
                            SetLastError (ERROR_NOT_READY);
                            bStatus = FALSE;
                            leave;

                        case VDM_PRESENT_AND_READY:
                            VDMCreationState = VDM_BEING_REUSED;
                            VdmWaitHandle = b->WaitObjectForParent;
                            break;
                        }

                    VdmReserve--;               // we reserve from addr 1
                    if(VdmWaitHandle)
                        goto VdmExists;
                    else {
                        bInheritHandles = FALSE;
                        // replace the environment with ours
                        if (lpEnvironment &&
                            !(dwCreationFlags & CREATE_UNICODE_ENVIRONMENT)) {
                            RtlDestroyEnvironment(lpEnvironment);
                            }
                        lpEnvironment = UnicodeStringVDMEnv.Buffer;
                        bVdmRetry = TRUE;
                        goto VdmRetry;
                        }

                case STATUS_FILE_IS_OFFLINE:
                    SetLastError(ERROR_FILE_OFFLINE);
                    break;

                default :
                    SetLastError(ERROR_BAD_EXE_FORMAT);
                    bStatus = FALSE;
                    leave;
            }
        }

        //
        // Make sure only WOW apps can have the CREATE_SEPARATE_WOW_VDM flag.
        //

        if (!IsWowBinary && (dwCreationFlags & CREATE_SEPARATE_WOW_VDM)) {
            dwCreationFlags &= ~CREATE_SEPARATE_WOW_VDM;
        }

        //
        // Query the section to determine the stack parameters and
        // image entrypoint.
        //


        if (!ImageInformationValid) {
            Status = NtQuerySection(
                        SectionHandle,
                        SectionImageInformation,
                        &ImageInformation,
                        sizeof( ImageInformation ),
                        NULL
                        );

            if (!NT_SUCCESS( Status )) {
                BaseSetLastNTError(Status);
                bStatus = FALSE;
                leave;
            }
            ImageInformationValid = TRUE;
        }

        if (ImageInformation.ImageCharacteristics & IMAGE_FILE_DLL) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            bStatus = FALSE;
            leave;
        }

        ImageFileDebuggerCommand[ 0 ] = UNICODE_NULL;
        if (!(dwCreationFlags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS)) ||
            NtCurrentPeb()->ReadImageFileExecOptions
           ) {
            if (!NT_SUCCESS (LdrQueryImageFileExecutionOptions (&PathName,
                                                                L"Debugger",
                                                                REG_SZ,
                                                                ImageFileDebuggerCommand,
                                                                sizeof( ImageFileDebuggerCommand ),
                                                                NULL))) {
                ImageFileDebuggerCommand[ 0 ] = UNICODE_NULL;
            }
        }

        if ((ImageInformation.Machine < USER_SHARED_DATA->ImageNumberLow) ||
            (ImageInformation.Machine > USER_SHARED_DATA->ImageNumberHigh)) {
#if defined(_WIN64) || defined(BUILD_WOW6432)
            if (ImageInformation.Machine == IMAGE_FILE_MACHINE_I386) {
               // Fall through since this is a valid machine type.
                }
             else
#endif
                {
                ULONG_PTR ErrorParameters[2];
                ULONG ErrorResponse;

#if defined(_WIN64) || defined(BUILD_WOW6432)
RaiseInvalidWin32Error:
#endif
                ErrorResponse = ResponseOk;
                ErrorParameters[0] = (ULONG_PTR)&PathName;

                NtRaiseHardError( STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE,
                                  1,
                                  1,
                                  ErrorParameters,
                                  OptionOk,
                                  &ErrorResponse
                                );
                if ( NtCurrentPeb()->ImageSubsystemMajorVersion <= 3 ) {
                    SetLastError(ERROR_BAD_EXE_FORMAT);
                    }
                else {
                    SetLastError(ERROR_EXE_MACHINE_TYPE_MISMATCH);
                    }
                bStatus = FALSE;
                leave;
                }
            }

        if ( ImageInformation.SubSystemType != IMAGE_SUBSYSTEM_WINDOWS_GUI &&
             ImageInformation.SubSystemType != IMAGE_SUBSYSTEM_WINDOWS_CUI ) {

            // POSIX exe

            NtClose(SectionHandle);
            SectionHandle = NULL;
            ImageInformationValid = FALSE;

            if ( ImageInformation.SubSystemType == IMAGE_SUBSYSTEM_POSIX_CUI ) {

                if ( !BuildSubSysCommandLine( L"POSIX /P ",
                                              lpApplicationName,
                                              lpCommandLine,
                                              &SubSysCommandLine
                                            ) ) {
                    bStatus = FALSE;
                    leave;
                }

                lpCommandLine = SubSysCommandLine.Buffer;

                lpApplicationName = NULL;
                bVdmRetry = TRUE;
                goto VdmRetry;
                }
            else {
                SetLastError(ERROR_CHILD_NOT_COMPLETE);
                bStatus = FALSE;
                leave;
                }
            }
        else {
            if (!BasepIsImageVersionOk( ImageInformation.SubSystemMajorVersion,
                                        ImageInformation.SubSystemMinorVersion) ) {
                SetLastError(ERROR_BAD_EXE_FORMAT);
                bStatus = FALSE;
                leave;
                }
            }

        if (ImageFileDebuggerCommand[ 0 ] != UNICODE_NULL) {
            SIZE_T n;

            n = wcslen( lpCommandLine );
            if (n == 0) {
                lpCommandLine = (LPWSTR)lpApplicationName;
                n = wcslen( lpCommandLine );
            }

            n += wcslen( ImageFileDebuggerCommand ) + 1 + 2;
            n *= sizeof( WCHAR );

            SubSysCommandLine.Buffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), n );
            if (SubSysCommandLine.Buffer == NULL) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                bStatus = FALSE;
                leave;
            }

            SubSysCommandLine.Length = 0;
            SubSysCommandLine.MaximumLength = (USHORT)n;
            RtlAppendUnicodeToString( &SubSysCommandLine, ImageFileDebuggerCommand );
            RtlAppendUnicodeToString( &SubSysCommandLine, L" " );
            RtlAppendUnicodeToString( &SubSysCommandLine, lpCommandLine );
#if DBG
            DbgPrint( "BASE: Calling debugger with '%wZ'\n", &SubSysCommandLine );
#endif
            lpCommandLine = SubSysCommandLine.Buffer;
            lpApplicationName = NULL;
            NtClose(SectionHandle);
            SectionHandle = NULL;
            ImageInformationValid = FALSE;
            RtlFreeHeap(RtlProcessHeap(), 0, NameBuffer);
            NameBuffer = NULL;
            RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
            FreeBuffer = NULL;
            goto VdmRetry;
        }

        //
        // Create the process object
        //

        pObja = BaseFormatObjectAttributes(&Obja,lpProcessAttributes,NULL);
        
        if (hUserToken)
        {
            //
            // Apply default security if we are called from CreateProcessAsUser.
            // We will fix up the security descriptors in L32CommonCreate.
            //

            if (lpProcessAttributes)
            {
                LocalProcessAttributes = *lpProcessAttributes;
                LocalProcessAttributes.lpSecurityDescriptor = NULL;
                pObja = BaseFormatObjectAttributes(&Obja,&LocalProcessAttributes,NULL);
            }
        }

        Flags = 0;
        if (dwCreationFlags & CREATE_BREAKAWAY_FROM_JOB ) {
            Flags |= PROCESS_CREATE_FLAGS_BREAKAWAY;
        }

        if ( dwCreationFlags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS) ) {
            Status = DbgUiConnectToDbg();
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                bStatus = FALSE;
                leave;
            }
            DebugPortHandle = DbgUiGetThreadDebugObject ();
            if (dwCreationFlags & DEBUG_ONLY_THIS_PROCESS) {
                Flags |= PROCESS_CREATE_FLAGS_NO_DEBUG_INHERIT;
            }
        }

        if (bInheritHandles) {
            Flags |= PROCESS_CREATE_FLAGS_INHERIT_HANDLES;
        }

        if (((ImageInformation.LoaderFlags & IMAGE_LOADER_FLAGS_COMPLUS) != 0)) {

#if defined(_WIN64) || defined(BUILD_WOW6432)

            //
            // Check if this is a 32-bit IL_ONLY COM+ image that needs to run natively
            // on Win64.
            //

            if ( ImageInformation.Machine == IMAGE_FILE_MACHINE_I386 ) {

                Status = BasepIsComplusILImage(
                                              SectionHandle,
                                              &ComPlusILImage
                                              );

                if ((NT_SUCCESS (Status)) && (ComPlusILImage != FALSE)) {
                    Flags |= PROCESS_CREATE_FLAGS_OVERRIDE_ADDRESS_SPACE;
                }
            }

#endif
        }

        //
        // NtCreateProcessEx writes the PEB address for the created process into the TEB
        //

        ArbitraryUserPointer = Teb->NtTib.ArbitraryUserPointer;
        Status = NtCreateProcessEx(
                    &ProcessHandle,
                    PROCESS_ALL_ACCESS,
                    pObja,
                    NtCurrentProcess(),
                    Flags,
                    SectionHandle,
                    DebugPortHandle,
                    NULL,
                    dwJobMemberLevel         // Job member level
                    );

        Peb = Teb->NtTib.ArbitraryUserPointer;
        Teb->NtTib.ArbitraryUserPointer = ArbitraryUserPointer;

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            bStatus = FALSE;
            leave;
        }

        //
        // NtCreateProcess will set to normal OR inherit if parent is IDLE or Below
        // only override if a mask is given during the create.
        //

        if ( PriClass.PriorityClass != PROCESS_PRIORITY_CLASS_UNKNOWN ) {
            State = NULL;
            if ( PriClass.PriorityClass ==  PROCESS_PRIORITY_CLASS_REALTIME ) {
                State = BasepIsRealtimeAllowed(TRUE);
                }
            Status = NtSetInformationProcess(
                        ProcessHandle,
                        ProcessPriorityClass,
                        (PVOID)&PriClass,
                        sizeof(PriClass)
                        );
            if ( State ) {
                BasepReleasePrivilege( State );
                }

            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                bStatus = FALSE;
                leave;
                }
            }

        if (dwCreationFlags & CREATE_DEFAULT_ERROR_MODE) {
            UINT NewMode;
            NewMode = SEM_FAILCRITICALERRORS;
            NtSetInformationProcess(
                ProcessHandle,
                ProcessDefaultHardErrorMode,
                &NewMode,
                sizeof(NewMode)
                );
            }

        //
        // If the process is being created for a VDM call the server with
        // process handle.
        //

        if (VdmBinaryType) {
            VdmWaitHandle = ProcessHandle;
            if (!BaseUpdateVDMEntry(UPDATE_VDM_PROCESS_HANDLE,
                                    &VdmWaitHandle,
                                    iTask,
                                    VdmBinaryType
                                    ))
                {
                //make sure we don't close the handle twice --
                //(VdmWaitHandle == ProcessHandle) if we don't do this.
                VdmWaitHandle = NULL;
                bStatus = FALSE;
                leave;
                }

            //
            // For Sep wow the VdmWaitHandle = NULL (there is none!)
            //

            VDMCreationState |= VDM_FULLY_CREATED;
            }


#if defined(i386)
        //
        // Reserve memory in the new process' address space if necessary
        // (for vdms). This is required only for x86 system.
        //

        if ( VdmReserve ) {
                BigVdmReserve = VdmReserve;
                Status = NtAllocateVirtualMemory(
                            ProcessHandle,
                            &BaseAddress,
                            0L,
                            &BigVdmReserve,
                            MEM_RESERVE,
                            PAGE_EXECUTE_READWRITE
                            );
                if ( !NT_SUCCESS(Status) ){
                    BaseSetLastNTError(Status);
                    bStatus = FALSE;
                    leave;
                }
        }
#endif

        if (!ImageInformationValid) {
            Status = NtQuerySection(
                        SectionHandle,
                        SectionImageInformation,
                        &ImageInformation,
                        sizeof( ImageInformation ),
                        NULL
                        );

            if (!NT_SUCCESS( Status )) {
                BaseSetLastNTError(Status);
                bStatus = FALSE;
                leave;
                }
            ImageInformationValid = TRUE;
        }

        if (!(ImageInformation.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NO_ISOLATION)) {

            //
            // Abuse the StaticSize fields temporarily.
            // They are somewhat private, but we are using them for temporary space, sort of.
            // These are the right values for them, but we need to call the proper initialization function,
            // which will store the values a second time (possibly optimized away).
            //
            SxsWin32ManifestPathBuffer.ByteBuffer.StaticSize = SxsWin32ExePath.Length + sizeof(SXS_MANIFEST_SUFFIX);
            SxsWin32PolicyPathBuffer.ByteBuffer.StaticSize = SxsWin32ExePath.Length + sizeof(SXS_POLICY_SUFFIX);
            SxsWin32AssemblyDirectoryBuffer.ByteBuffer.StaticSize = SxsWin32ExePath.Length + sizeof(WCHAR); // Win32AssemblyDirectory overestimate
            SxsNtManifestPathBuffer.ByteBuffer.StaticSize = SxsNtExePath.Length + sizeof(SXS_MANIFEST_SUFFIX);
            SxsNtPolicyPathBuffer.ByteBuffer.StaticSize = SxsNtExePath.Length + sizeof(SXS_POLICY_SUFFIX);
            //
            // now add them up as BYTE sizes
            //
            SxsConglomeratedBufferSizeBytes = 0;
            for (sxsi = 0 ; sxsi != RTL_NUMBER_OF(SxsStringBuffers) ; ++sxsi) {
                SxsConglomeratedBufferSizeBytes += SxsStringBuffers[sxsi]->ByteBuffer.StaticSize;
            }
    #if DBG
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_INFO_LEVEL,
                "SXS: SxsConglomeratedBufferSizeBytes:%Id\n",
                SxsConglomeratedBufferSizeBytes
                );
    #endif
            //
            // one honking heap allocation
            //
            SxsConglomeratedByteBuffer = (PBYTE)RtlAllocateHeap(RtlProcessHeap(), 0, SxsConglomeratedBufferSizeBytes);
            if (SxsConglomeratedByteBuffer == NULL) {
                BaseSetLastNTError(STATUS_NO_MEMORY);
                bStatus = FALSE;
                leave;
            }
            //
            // now dole out pieces, calling the proper initialization function
            //
            for (sxsi= 0 ; sxsi != RTL_NUMBER_OF(SxsStringBuffers) ; ++sxsi) {
                RtlInitUnicodeStringBuffer(
                    SxsStringBuffers[sxsi],
                    (sxsi != 0) ? SxsStringBuffers[sxsi - 1]->ByteBuffer.Buffer + SxsStringBuffers[sxsi- 1]->ByteBuffer.StaticSize
                             : SxsConglomeratedByteBuffer,
                    SxsStringBuffers[sxsi]->ByteBuffer.StaticSize
                    );
            }

            SxsExeHandles.Process = ProcessHandle;
            SxsExeHandles.File = FileHandle;
             // The 1 bit here means something different than in the loader.
            ASSERT((((ULONG_PTR)SectionHandle) & (ULONG_PTR)1) == 0);
            SxsExeHandles.Section = SectionHandle;

            // if we have an override stream, use it
            if (NULL != pAppCompatSxsData) {
                AppCompatSxsManifest.Name    = SxsWin32ExePath;     // unicode string
                AppCompatSxsManifest.Address = pAppCompatSxsData;   // pointer to unicode manifest
                AppCompatSxsManifest.Size    = cbAppCompatSxsData;  // byte count
            }

            Status = BasepSxsCreateProcessCsrMessage(
                (NULL != pAppCompatSxsData) ? &AppCompatSxsManifest : NULL, // override manifest (appcompat hook)
                NULL, // override policy (appcompat hook)
                &SxsManifestPathPair,
                &SxsManifestFileHandles,
                &SxsExePathPair,
                &SxsExeHandles,
                &SxsPolicyPathPair,
                &SxsPolicyHandles,
                &SxsWin32AssemblyDirectoryBuffer,
                &a->Sxs
                );
    #if DBG
            // verify the buffer size calculation
            for (sxsi = 0 ; sxsi != RTL_NUMBER_OF(SxsStringBuffers) ; ++sxsi)
            {
                if (SxsStringBuffers[sxsi]->ByteBuffer.Buffer != SxsStringBuffers[sxsi]->ByteBuffer.StaticBuffer)
                {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_WARNING_LEVEL,
                        "SXS: SxsStringBuffers[%lu]'s StaticSize was computed too small (%Id, %Id)\n",
                        sxsi,
                        SxsStringBuffers[sxsi]->ByteBuffer.StaticSize,
                        SxsStringBuffers[sxsi]->ByteBuffer.Size
                        );
                }
            }
    #endif
            if ( !NT_SUCCESS( Status ) ) {
                BaseSetLastNTError(Status);
                bStatus = FALSE;
                leave;
            }
        }

        // set sxs flag 
        if (dwFusionFlags & SXS_APPCOMPACT_FLAG_APP_RUNNING_SAFEMODE)
            a->Sxs.Flags |= BASE_MSG_SXS_APP_RUNNING_IN_SAFEMODE;

#if defined(BUILD_WOW6432)

        // Determine the location of the
        // processes PEB.
        //

        Status = NtQueryInformationProcess(
                    ProcessHandle,
                    ProcessBasicInformation,
                    &ProcessInfo,
                    sizeof( ProcessInfo ),
                    NULL
                    );
        if ( !NT_SUCCESS( Status ) ) {
            BaseSetLastNTError(Status);
            bStatus = FALSE;
            leave;
        }

        Peb = ProcessInfo.PebBaseAddress;

#else

#endif


        //
        // Push the parameters into the address space of the new process
        //

        if ( ARGUMENT_PRESENT(lpCurrentDirectory) ) {
            CurdirBuffer = RtlAllocateHeap( RtlProcessHeap(),
                                            MAKE_TAG( TMP_TAG ),
                                            (MAX_PATH + 1) * sizeof( WCHAR ) );
            if ( !CurdirBuffer ) {
                BaseSetLastNTError(STATUS_NO_MEMORY);
                bStatus = FALSE;
                leave;
                }
            CurdirLength2 = GetFullPathNameW(
                                lpCurrentDirectory,
                                MAX_PATH,
                                CurdirBuffer,
                                &CurdirFilePart
                                );
            if ( CurdirLength2 > MAX_PATH ) {
                SetLastError(ERROR_DIRECTORY);
                bStatus = FALSE;
                leave;
                }

            //
            // now make sure the directory exists
            //

            CurdirLength = GetFileAttributesW(CurdirBuffer);
            if ( (CurdirLength == 0xffffffff) ||
                 !(CurdirLength & FILE_ATTRIBUTE_DIRECTORY) ) {
                SetLastError(ERROR_DIRECTORY);
                bStatus = FALSE;
                leave;
                }
            }


        if ( QuoteInsert || QuoteCmdLine) {
            QuotedBuffer = RtlAllocateHeap(RtlProcessHeap(),0,wcslen(lpCommandLine)*2+6);

            if ( QuotedBuffer ) {
                wcscpy(QuotedBuffer,L"\"");

                if ( QuoteInsert ) {
                    TempChar = *TempNull;
                    *TempNull = UNICODE_NULL;
                    }

                wcscat(QuotedBuffer,lpCommandLine);
                wcscat(QuotedBuffer,L"\"");

                if ( QuoteInsert ) {
                    *TempNull = TempChar;
                    wcscat(QuotedBuffer,TempNull);
                    }

                }
            else {
                if ( QuoteInsert ) {
                    QuoteInsert = FALSE;
                    }
                if ( QuoteCmdLine ) {
                    QuoteCmdLine = FALSE;
                    }
                }
            }

        // If we found a manifest, we want to push that fact to the new process.
        if (a->Sxs.Flags & BASE_MSG_SXS_MANIFEST_PRESENT)
            dwBasePushProcessParametersFlags |= BASE_PUSH_PROCESS_PARAMETERS_FLAG_APP_MANIFEST_PRESENT;

        if (!BasePushProcessParameters(
                dwBasePushProcessParametersFlags,
                ProcessHandle,
                Peb,
                lpApplicationName,
                CurdirBuffer,
                QuoteInsert || QuoteCmdLine ? QuotedBuffer : lpCommandLine,
                lpEnvironment,
                &StartupInfo,
                dwCreationFlags | dwNoWindow,
                bInheritHandles,
                IsWowBinary ? IMAGE_SUBSYSTEM_WINDOWS_GUI : 0,
                pAppCompatData,
                cbAppCompatData
                ) ) {
            bStatus = FALSE;
            leave;
            }


        RtlFreeUnicodeString(&VdmNameString);
        VdmNameString.Buffer = NULL;

        //
        // Stuff in the standard handles if needed
        //
        if (!VdmBinaryType &&
            !bInheritHandles &&
            !(StartupInfo.dwFlags & STARTF_USESTDHANDLES) &&
            !(dwCreationFlags & (DETACHED_PROCESS | CREATE_NEW_CONSOLE | CREATE_NO_WINDOW)) &&
            ImageInformation.SubSystemType == IMAGE_SUBSYSTEM_WINDOWS_CUI
           ) {
            PRTL_USER_PROCESS_PARAMETERS ParametersInNewProcess;

            Status = NtReadVirtualMemory( ProcessHandle,
                                          &Peb->ProcessParameters,
                                          &ParametersInNewProcess,
                                          sizeof( ParametersInNewProcess ),
                                          NULL
                                        );
            if (NT_SUCCESS( Status )) {
                if (!CONSOLE_HANDLE( NtCurrentPeb()->ProcessParameters->StandardInput )) {
                    StuffStdHandle( ProcessHandle,
                                    NtCurrentPeb()->ProcessParameters->StandardInput,
                                    &ParametersInNewProcess->StandardInput
                                  );
                    }
                if (!CONSOLE_HANDLE( NtCurrentPeb()->ProcessParameters->StandardOutput )) {
                    StuffStdHandle( ProcessHandle,
                                    NtCurrentPeb()->ProcessParameters->StandardOutput,
                                    &ParametersInNewProcess->StandardOutput
                                  );
                    }
                if (!CONSOLE_HANDLE( NtCurrentPeb()->ProcessParameters->StandardError )) {
                    StuffStdHandle( ProcessHandle,
                                    NtCurrentPeb()->ProcessParameters->StandardError,
                                    &ParametersInNewProcess->StandardError
                                  );
                    }
                }
            }

        //
        // Create the thread...
        //

        //
        // Allocate a stack for this thread in the address space of the target
        // process.
        //

        StackStatus = BaseCreateStack(
                        ProcessHandle,
                        ImageInformation.CommittedStackSize,
                        (ImageInformation.MaximumStackSize < 256*1024) ? 256*1024 : ImageInformation.MaximumStackSize,
                        &InitialTeb
                        );

        if ( !NT_SUCCESS(StackStatus) ) {
            BaseSetLastNTError(StackStatus);
            bStatus = FALSE;
            leave;
            }


        //
        // Create an initial context for the new thread.
        //

        BaseInitializeContext(
            &ThreadContext,
            Peb,
            ImageInformation.TransferAddress,
            InitialTeb.StackBase,
            BaseContextTypeProcess
            );


        //
        // Create the actual thread object
        //

        pObja = BaseFormatObjectAttributes(&Obja,lpThreadAttributes,NULL);

        if (hUserToken)
        {
            //
            // Apply default security if we are called from CreateProcessAsUser.
            // We will fix up the security descriptors in L32CommonCreate.
            //

            if (lpThreadAttributes)
            {
                LocalThreadAttributes = *lpThreadAttributes;
                LocalThreadAttributes.lpSecurityDescriptor = NULL;
                pObja = BaseFormatObjectAttributes(&Obja,&LocalThreadAttributes,NULL);
            }
        }

        Status = NtCreateThread(
                    &ThreadHandle,
                    THREAD_ALL_ACCESS,
                    pObja,
                    ProcessHandle,
                    &ClientId,
                    &ThreadContext,
                    &InitialTeb,
                    TRUE
                    );

        if (!NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            bStatus = FALSE;
            leave;
        }

        a->Peb = (ULONGLONG) Peb;
#if defined(BUILD_WOW6432)
        a->RealPeb = (ULONG_PTR) NULL;
#else
        a->RealPeb = (ULONG_PTR) Peb;
#endif

        //
        // From here on out, do not modify the address space of the
        // new process.  WOW64's implementation of NtCreateThread()
        // reshuffles the new process' address space if the current
        // process is 32-bit and the new process is 64-bit.
        //
#if DBG
        Peb = NULL;
#endif

#if defined(WX86)

        //
        // if this is a Wx86 Process, setup for a Wx86 emulated Thread
        //

        if (Wx86Info) {

            //
            // create a WX86Tib and initialize it's Teb->Vdm.
            //
            Status = BaseCreateWx86Tib(ProcessHandle,
                                       ThreadHandle,
                                       (ULONG)((ULONG_PTR)ImageInformation.TransferAddress),
                                       (ULONG)ImageInformation.CommittedStackSize,
                                       (ULONG)ImageInformation.MaximumStackSize,
                                       TRUE
                                       );

            if (!NT_SUCCESS(Status)) {
                BaseSetLastNTError(Status);
                bStatus = FALSE;
                leave;
                }


            //
            // Mark Process as WX86
            //
            Status = NtSetInformationProcess (ProcessHandle,
                                              ProcessWx86Information,
                                              &Wx86Info,
                                              sizeof(Wx86Info)
                                              );

            if (!NT_SUCCESS(Status)) {
                BaseSetLastNTError(Status);
                bStatus = FALSE;
                leave;
                }
            }
#endif


        //
        // Call the Windows server to let it know about the
        // process.
        //

        a->ProcessHandle = ProcessHandle;
        a->ThreadHandle = ThreadHandle;
        a->ClientId = ClientId;

        switch (ImageInformation.Machine) {
        case IMAGE_FILE_MACHINE_I386:
#if defined(_WIN64) || defined(BUILD_WOW6432)
            //
            // If this is a .NET ILONLY that needs to run in a 64-bit address
            // space, then let SXS be aware of this
            //
            if ((Flags & PROCESS_CREATE_FLAGS_OVERRIDE_ADDRESS_SPACE) != 0) {
                a->ProcessorArchitecture = NativeProcessorInfo.ProcessorArchitecture;
            } else {
                a->ProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA32_ON_WIN64;
            }
#else
            a->ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
#endif
            break;

        case IMAGE_FILE_MACHINE_IA64:
            a->ProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA64;
            break;

        case IMAGE_FILE_MACHINE_AMD64:
            a->ProcessorArchitecture = PROCESSOR_ARCHITECTURE_AMD64;
            break;

        default:
            DbgPrint("kernel32: No mapping for ImageInformation.Machine == %04x\n", ImageInformation.Machine);
            a->ProcessorArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;
            break;
        }

        //
        // remove debug flags now its not being done by CSR
        //
        a->CreationFlags = dwCreationFlags & ~ (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS);

        //
        // Set the 2 bit if a gui app is starting. The window manager needs to
        // know this so it can synchronize the startup of this app
        // (WaitForInputIdle api). This info is passed using the process
        // handle tag bits.  The 1 bit asks the window manager to turn on
        // or turn off the application start cursor (hourglass/pointer).
        //
        // When starting a WOW process, lie and tell UserSrv NTVDM.EXE is a GUI
        // process.  We also turn on bit 0x8 so that UserSrv can ignore the
        // UserNotifyConsoleApplication call made by the console during startup.
        //

        if ( ImageInformation.SubSystemType == IMAGE_SUBSYSTEM_WINDOWS_GUI ||
             IsWowBinary ) {

            a->ProcessHandle = (HANDLE)((ULONG_PTR)a->ProcessHandle | 2);

            //
            // If the creating process is a GUI app, turn on the app. start cursor
            // by default.  This can be overridden by STARTF_FORCEOFFFEEDBACK.
            //

            NtHeaders = RtlImageNtHeader((PVOID)GetModuleHandle(NULL));
            if ( NtHeaders
                 && (NtHeaders->OptionalHeader.Subsystem
                     == IMAGE_SUBSYSTEM_WINDOWS_GUI ) ) {
                a->ProcessHandle = (HANDLE)((ULONG_PTR)a->ProcessHandle | 1);
                }
            }


        //
        // If feedback is forced on, turn it on. If forced off, turn it off.
        // Off overrides on.
        //

        if (StartupInfo.dwFlags & STARTF_FORCEONFEEDBACK)
            a->ProcessHandle = (HANDLE)((ULONG_PTR)a->ProcessHandle | 1);
        if (StartupInfo.dwFlags & STARTF_FORCEOFFFEEDBACK)
            a->ProcessHandle = (HANDLE)((ULONG_PTR)a->ProcessHandle & ~1);

        a->VdmBinaryType = VdmBinaryType; // just tell server the truth

        if (VdmBinaryType){
           a->hVDM    = iTask ? 0 : NtCurrentPeb()->ProcessParameters->ConsoleHandle;
           a->VdmTask = iTask;
        } else if (VdmReserve) {

            //
            // Possible VDM related binary, check VDM Allowed.
            //

            a->VdmBinaryType |= BINARY_TYPE_INJWOW;
        }

#if defined(BUILD_WOW6432)
        m.ReturnValue = CsrBasepCreateProcess(a);
#else
        m.u.CreateProcess = *a;
        if (m.u.CreateProcess.Sxs.Flags != 0)
        {
            const PUNICODE_STRING StringsToCapture[] =
            {
                &m.u.CreateProcess.Sxs.Manifest.Path,
                    &m.u.CreateProcess.Sxs.Policy.Path,
                    &m.u.CreateProcess.Sxs.AssemblyDirectory
            };

            Status =
                CsrCaptureMessageMultiUnicodeStringsInPlace(
                &CaptureBuffer,
                RTL_NUMBER_OF(StringsToCapture),
                StringsToCapture
                );
            if (!NT_SUCCESS(Status)) {
                BaseSetLastNTError(Status);
                bStatus = FALSE;
                leave;
            }
        }

        CsrClientCallServer( (PCSR_API_MSG)&m,
                             CaptureBuffer,
                             CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                                  BasepCreateProcess
                                                ),
                             sizeof( *a )
                           );

        if ( CaptureBuffer ) {
            CsrFreeCaptureBuffer( CaptureBuffer );
            CaptureBuffer = NULL;
        }

#endif

        if (!NT_SUCCESS((NTSTATUS)m.ReturnValue)) {
            BaseSetLastNTError((NTSTATUS)m.ReturnValue);
            NtTerminateProcess(ProcessHandle, (NTSTATUS)m.ReturnValue);
            bStatus = FALSE;
            leave;
            }



        //
        // If the WinSafer sandboxing policy indicates that the
        // process needs to be run with a restricted token or placed
        // into a restricted job object, then do those actions now.
        // Do not replace the token if the restricted token was created
        // from a caller supplied token i.e. the CreateProcessAsUser case.
        //
        if ((hSaferRestrictedToken != NULL) && (hUserToken == NULL)) {
            Status = BasepReplaceProcessThreadTokens(
                    hSaferRestrictedToken,
                    ProcessHandle,
                    ThreadHandle);
            if (!NT_SUCCESS(Status)) {
                // kill and cleanup.
                NtTerminateProcess(ProcessHandle, Status);
                BaseSetLastNTError(Status);
                bStatus = FALSE;
                leave;
            }
        }
        if (hSaferAssignmentJob != NULL) {
            Status = NtAssignProcessToJobObject(
                    hSaferAssignmentJob, ProcessHandle);
            if (!NT_SUCCESS(Status)) {
                // kill and cleanup.
                NtTerminateProcess(ProcessHandle, STATUS_ACCESS_DENIED);
                BaseSetLastNTError(Status);
                bStatus = FALSE;
                leave;
            }
        }


        //
        // Make the thread start execution if we are allowed to.
        //
        if (!( dwCreationFlags & CREATE_SUSPENDED) ) {
            NtResumeThread(ThreadHandle,&i);
            }

VdmExists:
        bStatus = TRUE;
        if (VDMCreationState)
            VDMCreationState |= VDM_CREATION_SUCCESSFUL;

        try {
            if (VdmWaitHandle) {

                //
                // tag Shared WOW VDM handles so that wait for input idle has a
                // chance to work.  Shared WOW VDM "process" handles are actually
                // event handles,  Separate WOW VDM handles are real process
                // handles. Also mark DOS handles with 0x1 so WaitForInputIdle
                // has a way to distinguish DOS apps and not block forever.
                //

                if (VdmBinaryType == BINARY_TYPE_WIN16)  {
                    lpProcessInformation->hProcess =
                            (HANDLE)((ULONG_PTR)VdmWaitHandle | 0x2);

                    //
                    // Shared WOW doesn't always start a process, so
                    // we don't have a process ID or thread ID to
                    // return if the VDM already existed.
                    //
                    // Separate WOW doesn't hit this codepath
                    // (no VdmWaitHandle).
                    //

                    if (VDMCreationState & VDM_BEING_REUSED) {
                        ClientId.UniqueProcess = 0;
                        ClientId.UniqueThread = 0;
                        }

                    }
                else  {
                    lpProcessInformation->hProcess =
                            (HANDLE)((ULONG_PTR)VdmWaitHandle | 0x1);
                    }


                //
                // Close the ProcessHandle, since we are returning the
                // VdmProcessHandle instead.
                //

                if (ProcessHandle != NULL)
                    NtClose(ProcessHandle);
                }
            else{
                lpProcessInformation->hProcess = ProcessHandle;
                }

            lpProcessInformation->hThread = ThreadHandle;
            lpProcessInformation->dwProcessId = HandleToUlong(ClientId.UniqueProcess);
            lpProcessInformation->dwThreadId = HandleToUlong(ClientId.UniqueThread);
            ProcessHandle = NULL;
            ThreadHandle = NULL;
            }
        __except ( EXCEPTION_EXECUTE_HANDLER ) {
            NtClose( ProcessHandle );
            NtClose( ThreadHandle );
            ProcessHandle = NULL;
            ThreadHandle = NULL;
            if (VDMCreationState)
                VDMCreationState &= ~VDM_CREATION_SUCCESSFUL;
            }
        }
    __finally {

        if (ExePathFullBuffer != NULL) {
            SxsWin32ExePath.Buffer = NULL;
            SxsWin32ExePath.Length = 0;
            SxsWin32ExePath.MaximumLength = 0;
            RtlFreeHeap(RtlProcessHeap(), 0, ExePathFullBuffer);
            ExePathFullBuffer = NULL;
        }

        if (!VdmBinaryType) {
            NTSTATUS Status1;

            BasepSxsCloseHandles(&SxsManifestFileHandles);
            BasepSxsCloseHandles(&SxsPolicyHandles);
            //
            // don't close SxsExeHandles, they are
            // aliases of other variables that are either closed
            // or returned to the caller
            //

            //
            // This loop only really frees any memory if our computation
            // of the overall buffer size was too low, which it is not supposed to be.
            //
            if (SxsConglomeratedByteBuffer != NULL) {
                for (sxsi= 0 ; sxsi != RTL_NUMBER_OF(SxsStringBuffers) ; ++sxsi) {
                    RtlFreeUnicodeStringBuffer(SxsStringBuffers[sxsi]);
                    }
                RtlFreeHeap(RtlProcessHeap(), 0,SxsConglomeratedByteBuffer);
                }
            }
        if (lpEnvironment && !(dwCreationFlags & CREATE_UNICODE_ENVIRONMENT) ) {
            RtlDestroyEnvironment(lpEnvironment);

            //
            // In VDM cases UnicodeStringVDMEnv.Buffer is assigned to lpEnvironment
            //
            if(UnicodeStringVDMEnv.Buffer == lpEnvironment ) {
               UnicodeStringVDMEnv.Buffer = NULL;
               }

            lpEnvironment = NULL;
            }
        RtlFreeHeap(RtlProcessHeap(), 0,QuotedBuffer);
        RtlFreeHeap(RtlProcessHeap(), 0,NameBuffer);
        RtlFreeHeap(RtlProcessHeap(), 0,CurdirBuffer);
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
        if ( FileHandle ) {
            NtClose(FileHandle);
            }
        if ( SectionHandle ) {
            NtClose(SectionHandle);
            }
        if ( ThreadHandle ) {
            NtTerminateProcess(ProcessHandle,STATUS_SUCCESS);
            NtClose(ThreadHandle);
            }
        if ( ProcessHandle ) {
            NtClose(ProcessHandle);
            }
        if ( hSaferAssignmentJob ) {
            NtClose(hSaferAssignmentJob);
            }
        if ( hSaferRestrictedToken ) {
            if (hUserToken == NULL) {
                // CreateProcess case
                NtClose(hSaferRestrictedToken);
                }
            else{
                // CreateProcessAsUser case
                *hRestrictedUserToken = hSaferRestrictedToken;
                }
            }

        BasepFreeAppCompatData(pAppCompatData, cbAppCompatData, pAppCompatSxsData, cbAppCompatSxsData);

        RtlFreeUnicodeString(&VdmNameString);
        RtlFreeUnicodeString(&SubSysCommandLine);
        if (AnsiStringVDMEnv.Buffer || UnicodeStringVDMEnv.Buffer)
            BaseDestroyVDMEnvironment(&AnsiStringVDMEnv, &UnicodeStringVDMEnv);

        if (VDMCreationState && !(VDMCreationState & VDM_CREATION_SUCCESSFUL)){
            BaseUpdateVDMEntry (
                UPDATE_VDM_UNDO_CREATION,
                (HANDLE *)&iTask,
                VDMCreationState,
                VdmBinaryType
                );
            if(VdmWaitHandle) {
                NtClose(VdmWaitHandle);
                }
            }

        if (PathToSearch) {
            RtlFreeHeap(RtlProcessHeap(), 0, PathToSearch);
            }
        }

    if (lpEnvironment && !(dwCreationFlags & CREATE_UNICODE_ENVIRONMENT) ) {
        RtlDestroyEnvironment(lpEnvironment);
        }
    return bStatus;
}

BOOL
WINAPI
CreateProcessW(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )

/*++

Routine Description:

    A process and thread object are created and a handle opened to each
    object using CreateProcess.  Note that WinExec and LoadModule are
    still supported, but are implemented as a call to CreateProcess.

Arguments:

    lpApplicationName - Supplies an optional pointer to a null terminated
        character string that contains the name of the image file to
        execute.  This is a fully qualified DOS path name.  If not
        specified, then the image file name is the first whitespace
        delimited token on the command line.

    lpCommandLine - Supplies a null terminated character string that
        contains the command line for the application to be executed.
        The entire command line is made available to the new process
        using GetCommandLine.  If the lpApplicationName parameter was
        not specified, then the first token of the command line
        specifies file name of the application (note that this token
        begins at the beginning of the command line and ends at the
        first "white space" character).  If the file name does not
        contain an extension (the presence of a "."), then .EXE is
        assumed.  If the file name does not contain a directory path,
        Windows will search for the executable file in:

          - The current directory

          - The windows directory

          - The windows system directory

          - The directories listed in the path environment variable

        This parameter is optional onlu if the lpApplicationName
        parameter is specified.  In this case the command line the
        application receives will be the application name.

    lpProcessAttributes - An optional parameter that may be used to
        specify the attributes of the new process.  If the parameter is
        not specified, then the process is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation:

        SECURITY_ATTRIBUTES Structure:

        DWORD nLength - Specifies the length of this structure.  Must be
            set to sizeof( SECURITY_ATTRUBUTES ).

        LPVOID lpSecurityDescriptor - Points to a security descriptor for
            the object (must be NULL for Win32, used on NT/Win32). The
            security descriptor controls the sharing of an object.

        BOOL bInheritHandle - Supplies a flag that indicates whether
            or not the returned handle is to be inherited by a new
            process during process creation.  A value of TRUE
            indicates that the new process will inherit the handle.

    lpThreadAttributes - An optional parameter that may be used to specify
        the attributes of the new thread.  If the parameter is not
        specified, then the thread is created without a security
        descriptor, and the resulting handle is not inherited on
        process creation.

    dwCreationFlags - Supplies additional flags that control the creation
        of the process.

        dwCreationFlags Flags:

        DEBUG_PROCESS - If this flag bit is set, then the creating
            process is treated as a debugger, and the process being
            created is created as a debugee.  All debug events occuring
            in the debugee are reported to the debugger.  If this bit is
            clear, but the calling process is a debugee, then the
            process becomes a debugee of the calling processes debugger.
            If this bit is clear and the calling processes is not a
            debugee then no debug related actions occur.

        DEBUG_ONLY_THIS_PROCESS - If this flag is set, then the
            DEBUG_PROCESS flag bit must also be set.  The calling
            process is is treated as a debugger, and the new process is
            created as its debuggee.  If the new process creates
            additional processes, no debug related activities (with
            respect to the debugger) occur.

        CREATE_SUSPENDED - The process is created, but the initial thread
            of the process remains suspended. The creator can resume this
            thread using ResumeThread. Until this is done, code in the
            process will not execute.

        CREATE_UNICODE_ENVIRONMENT - If set, the environment pointer
            points to a Unicode environment block.  Otherwise, the
            block is ANSI (actually OEM.)

    bInheritHandles - Supplies a flag that specifies whether or not the
        new process is to inherit handles to objects visible to the
        calling process.  A value of TRUE causes handles to be inherited
        by the new process.  If TRUE was specified, then for each handle
        visible to the calling process, if the handle was created with
        the inherit handle option, the handle is inherited to the new
        process.  The handle has the same granted access in the new
        process as it has in the calling process, and the value of the
        handle is the same.

    lpEnvironment - An optional parameter, that if specified, supplies a
        pointer to an environment block.  If the parameter is not
        specified, the environment block of the current process is used.
        This environment block is made available to the new process
        using GetEnvironmentStrings.

    lpCurrentDirectory - An optional parameter, that if specified,
        supplies a string representing the current drive and directory
        for the new process.  The string must be a fully qualified
        pathname that includes a drive letter.  If the parameter is not
        specified, then the new process is created with the same current
        drive and directory as the calling process.  This option is
        provided primarily for shells that want to start an application
        and specify its initial drive and working directory.

    lpStartupInfo - Supplies information that specified how the
        applications window is to be shown. This structure is described
        in the Win32 User Interface API Book.

    lpProcessInformation - Returns identification information about the
        new process.

    PROCESS_INFORMATION Structure:

        HANDLE hProcess - Returns a handle to the newly created process.
            Through the handle, all operations on process objects are
            allowed.

        HANDLE hThread - Returns a handle to the newly created thread.
            Through the handle, all operations on thread objects are
            allowed.

        DWORD dwProcessId - Returns a global process id that may be used
            to identify a process.  The value is valid from the time the
            process is created until the time the process is terminated.

        DWORD dwThreadId - Returns a global thread id that may be used
            to identify a thread.  The value is valid from the time the
            thread is created until the time the thread is terminated.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return CreateProcessInternalW(
               NULL, // Create new process with the token on the creator process
               lpApplicationName,
               lpCommandLine,
               lpProcessAttributes,
               lpThreadAttributes,
               bInheritHandles,
               dwCreationFlags,
               lpEnvironment,
               lpCurrentDirectory,
               lpStartupInfo,
               lpProcessInformation,
               NULL  // Do not return the restricted token
               );
}

HANDLE
WINAPI
OpenProcess(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwProcessId
    )

/*++

Routine Description:

    A handle to a process object may be created using OpenProcess.

    Opening a process creates a handle to the specified process.
    Associated with the process handle is a set of access rights that
    may be performed using the process handle.  The caller specifies the
    desired access to the process using the DesiredAccess parameter.

Arguments:

    mDesiredAccess - Supplies the desired access to the process object.
        For NT/Win32, this access is checked against any security
        descriptor on the target process.  The following object type
        specific access flags can be specified in addition to the
        STANDARD_RIGHTS_REQUIRED access flags.

        DesiredAccess Flags:

        PROCESS_DUP_HANDLE - Duplicate object access to the process is
            desired.  This access is required in order to duplicate an
            object handle into or out of a process.

        PROCESS_QUERY_INFORMATION - This access is required to read
            certain information from the process object.

        PROCESS_VM_READ - This access is required to read the memory of
            another process.

        PROCESS_VM_WRITE - This access is required to write the memory
            of another process.

        SYNCHRONIZE - This access is required to wait on a process object.

        PROCESS_ALL_ACCESS - This set of access flags specifies all of the
            possible access flags for a process object.

    bInheritHandle - Supplies a flag that indicates whether or not the
        returned handle is to be inherited by a new process during
        process creation.  A value of TRUE indicates that the new
        process will inherit the handle.

    dwProcessId - Supplies the process id of the process to open.

Return Value:

    NON-NULL - Returns an open handle to the specified process.  The
        handle may be used by the calling process in any API that
        requires a handle to a process.  If the open is successful, the
        handle is granted access to the process object only to the
        extent that it requested access through the DesiredAccess
        parameter.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    CLIENT_ID ClientId;

    ClientId.UniqueThread = NULL;
    ClientId.UniqueProcess = LongToHandle(dwProcessId);

    InitializeObjectAttributes(
        &Obja,
        NULL,
        (bInheritHandle ? OBJ_INHERIT : 0),
        NULL,
        NULL
        );
    Status = NtOpenProcess(
                &Handle,
                (ACCESS_MASK)dwDesiredAccess,
                &Obja,
                &ClientId
                );
    if ( NT_SUCCESS(Status) ) {
        return Handle;
        }
    else {
        BaseSetLastNTError(Status);
        return NULL;
        }
}

VOID
WINAPI
#if defined(_X86_)
_ExitProcess(
#else
ExitProcess(
#endif
    UINT uExitCode
    )

/*++

Routine Description:

    The current process can exit using ExitProcess.

    ExitProcess is the prefered method of exiting an application.  This
    API provides a clean application shutdown.  This includes calling
    all attached DLLs at their instance termination entrypoint.  If an
    application terminates by any other method:

        - TerminateProcess

        - TerminateThread of last thread in the process

        - ExitThread of last thread in the process

    The DLLs that the process is attached to will not be notified of the
    process termination.

    After notifying all DLLs of the process termination, this API
    terminates the current process as if a call to
    TerminateProcess(GetCurrentProcess()) were made.

Arguments:

    uExitCode - Supplies the termination status for each thread
        in the process.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    BASE_API_MSG m;
    PBASE_EXITPROCESS_MSG a = &m.u.ExitProcess;

    if ( BaseRunningInServerProcess ) {
        ASSERT(!BaseRunningInServerProcess);
        }
    else {

        RtlAcquirePebLock();

        try {
            Status = NtTerminateProcess(NULL,(NTSTATUS)uExitCode);

            LdrShutdownProcess();

#if defined(BUILD_WOW6432)
            CsrBasepExitProcess(uExitCode);
#else
            a->uExitCode = uExitCode;
            CsrClientCallServer( (PCSR_API_MSG)&m,
                                 NULL,
                                 CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                                      BasepExitProcess
                                                    ),
                                 sizeof( *a )
                               );
#endif

            NtTerminateProcess(NtCurrentProcess(),(NTSTATUS)uExitCode);
            }
        finally {
                RtlReleasePebLock();
            }
    }
}

#if defined(_X86_)
// Appcompat: There's code that depends on the old EH frame setup/teardown.  Simulate it here
// then call the real function.  ExitProcess is a no-return function so don't bother cleaning up.
__declspec(naked) VOID WINAPI ExitProcess( UINT uExitCode )
{
    __asm {
        push ebp
        mov  ebp,esp
        push -1
        push 0x77e8f3b0
        push uExitCode
        call _ExitProcess
    }
}
#endif

BOOL
WINAPI
TerminateProcess(
    HANDLE hProcess,
    UINT uExitCode
    )

/*++

Routine Description:

    A process and all of its threads may be terminated using
    TerminateProcess.

    TerminateProcess is used to cause all of the threads within a
    process to terminate.

    While TerminateProcess will cause all threads within a process to
    terminate, and will cause an application to exit, it does not notify
    DLLs that the process is attached to that the process is
    terminating.  TerminateProcess is used to unconditionally cause a
    process to exit.  It should only be used in extreme circumstances.
    The state of global data maintained by DLLs may be comprimised if
    TerminateProcess is used rather that ExitProcess.

    Once all of the threads have terminated, the process attains a state
    of signaled satisfying any waits on the process.  The process's
    termination status is updated from its initial value of
    STATUS_PENDING to the termination status of the last thread in the
    process to terminate (usually this is the same value as the
    TerminationStatus parameter).  Terminating a process does not remove
    a process from the system.  It simply causes all of the threads in
    the process to terminate their execution, and causes all of the
    object handles opened by the process to be closed.  The process is
    not removed from the system until the last handle to the process is
    closed.

Arguments:

    hProcess - Supplies a handle to the process to terminate.  The handle
        must have been created with PROCESS_TERMINATE access.

    uExitCode - Supplies the termination status for each thread
        in the process.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    if ( hProcess == NULL ) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
        }
    Status = NtTerminateProcess(hProcess,(NTSTATUS)uExitCode);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
WINAPI
GetExitCodeProcess(
    HANDLE hProcess,
    LPDWORD lpExitCode
    )

/*++

Routine Description:

    The termination status of a process can be read using
    GetExitCodeProcess.

    If a process is in the signaled state, calling this function returns
    the termination status of the process.
    If the process is not yet signaled, the termination
    status returned is STILL_ACTIVE.


Arguments:

    hProcess - Supplies a handle to the process whose termination status
        is to be read.  The handle must have been created with
        PROCESS_QUERY_INFORMATION access.

    lpExitCode - Returns the current termination status of the process.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION BasicInformation;


    Status = NtQueryInformationProcess (hProcess,
                                        ProcessBasicInformation,
                                        &BasicInformation,
                                        sizeof(BasicInformation),
                                        NULL);

    if ( NT_SUCCESS(Status) ) {
        *lpExitCode = BasicInformation.ExitStatus;
        return TRUE;
    } else {
        if (BaseCheckForVDM (hProcess, lpExitCode) == TRUE) {
            return TRUE;
        }
        BaseSetLastNTError(Status);
        return FALSE;
    }
}

VOID
WINAPI
GetStartupInfoW(
    LPSTARTUPINFOW lpStartupInfo
    )

/*++

Routine Description:

    The startup information for the current process is available using this
    API.

Arguments:

    lpStartupInfo - a pointer to a STARTUPINFO structure that will be filed
        in by the API.  The pointer fields of the structure will point
        to static strings.

Return Value:

    None.

--*/

{
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;

    ProcessParameters = NtCurrentPeb()->ProcessParameters;
    lpStartupInfo->cb = sizeof( *lpStartupInfo );
    lpStartupInfo->lpReserved  = (LPWSTR)ProcessParameters->ShellInfo.Buffer;
    lpStartupInfo->lpDesktop   = (LPWSTR)ProcessParameters->DesktopInfo.Buffer;
    lpStartupInfo->lpTitle     = (LPWSTR)ProcessParameters->WindowTitle.Buffer;
    lpStartupInfo->dwX         = ProcessParameters->StartingX;
    lpStartupInfo->dwY         = ProcessParameters->StartingY;
    lpStartupInfo->dwXSize     = ProcessParameters->CountX;
    lpStartupInfo->dwYSize     = ProcessParameters->CountY;
    lpStartupInfo->dwXCountChars = ProcessParameters->CountCharsX;
    lpStartupInfo->dwYCountChars = ProcessParameters->CountCharsY;
    lpStartupInfo->dwFillAttribute = ProcessParameters->FillAttribute;
    lpStartupInfo->dwFlags     = ProcessParameters->WindowFlags;
    lpStartupInfo->wShowWindow = (WORD)ProcessParameters->ShowWindowFlags;
    lpStartupInfo->cbReserved2 = ProcessParameters->RuntimeData.Length;
    lpStartupInfo->lpReserved2 = (LPBYTE)ProcessParameters->RuntimeData.Buffer;

    if (lpStartupInfo->dwFlags & (STARTF_USESTDHANDLES | STARTF_USEHOTKEY | STARTF_HASSHELLDATA)) {
        lpStartupInfo->hStdInput   = ProcessParameters->StandardInput;
        lpStartupInfo->hStdOutput  = ProcessParameters->StandardOutput;
        lpStartupInfo->hStdError   = ProcessParameters->StandardError;
    }

    return;
}


VOID
WINAPI
GetStartupInfoA(
    LPSTARTUPINFOA lpStartupInfo
    )
/*++

Routine Description:

    The startup information for the current process is available using this
    API.

Arguments:

    lpStartupInfo - a pointer to a STARTUPINFO structure that will be filed
        in by the API.  The pointer fields of the structure will point
        to static strings.

Return Value:

    None.

--*/

{
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    NTSTATUS Status;
    ANSI_STRING AnsiString1, AnsiString2, AnsiString3;
    LPSTARTUPINFOA StartupInfo;

    ProcessParameters = NtCurrentPeb()->ProcessParameters;

    StartupInfo = BaseAnsiStartupInfo;
    if (StartupInfo == NULL) {
        StartupInfo = RtlAllocateHeap (RtlProcessHeap(), MAKE_TAG(TMP_TAG), sizeof (*StartupInfo));
        if (StartupInfo == NULL) {
            Status = STATUS_NO_MEMORY;
            goto error1;
                }
        StartupInfo->cb              = sizeof (*StartupInfo);
        StartupInfo->lpReserved      = NULL;
        StartupInfo->lpDesktop       = NULL;
        StartupInfo->lpTitle         = NULL;
        StartupInfo->dwX             = ProcessParameters->StartingX;
        StartupInfo->dwY             = ProcessParameters->StartingY;
        StartupInfo->dwXSize         = ProcessParameters->CountX;
        StartupInfo->dwYSize         = ProcessParameters->CountY;
        StartupInfo->dwXCountChars   = ProcessParameters->CountCharsX;
        StartupInfo->dwYCountChars   = ProcessParameters->CountCharsY;
        StartupInfo->dwFillAttribute = ProcessParameters->FillAttribute;
        StartupInfo->dwFlags         = ProcessParameters->WindowFlags;
        StartupInfo->wShowWindow     = (WORD)ProcessParameters->ShowWindowFlags;
        StartupInfo->cbReserved2     = ProcessParameters->RuntimeData.Length;
        StartupInfo->lpReserved2     = (LPBYTE)ProcessParameters->RuntimeData.Buffer;
        StartupInfo->hStdInput       = ProcessParameters->StandardInput;
        StartupInfo->hStdOutput      = ProcessParameters->StandardOutput;
        StartupInfo->hStdError       = ProcessParameters->StandardError;

        Status = RtlUnicodeStringToAnsiString (&AnsiString1, &ProcessParameters->ShellInfo, TRUE);
            if ( !NT_SUCCESS(Status) ) {
            goto error2;
        } else {
            StartupInfo->lpReserved = AnsiString1.Buffer;
        }

        Status = RtlUnicodeStringToAnsiString (&AnsiString2, &ProcessParameters->DesktopInfo, TRUE);
            if ( !NT_SUCCESS(Status) ) {
            goto error3;
        } else {
            StartupInfo->lpDesktop = AnsiString2.Buffer;
                }

        Status = RtlUnicodeStringToAnsiString(&AnsiString3, &ProcessParameters->WindowTitle, TRUE);
            if ( !NT_SUCCESS(Status) ) {
            goto error4;
        } else {
            StartupInfo->lpTitle = AnsiString3.Buffer;
        }

        //
        // Put the cached value into place making sure all previous writes have occured.
        //
        if (InterlockedCompareExchangePointer (&BaseAnsiStartupInfo, StartupInfo, NULL) != NULL) {
            RtlFreeAnsiString (&AnsiString3);
            RtlFreeAnsiString (&AnsiString2);
            RtlFreeAnsiString (&AnsiString1);
            RtlFreeHeap (RtlProcessHeap (), 0, StartupInfo);
            StartupInfo = BaseAnsiStartupInfo;
        }

    }


    lpStartupInfo->cb              = StartupInfo->cb;
    lpStartupInfo->lpReserved      = StartupInfo->lpReserved;
    lpStartupInfo->lpDesktop       = StartupInfo->lpDesktop;
    lpStartupInfo->lpTitle         = StartupInfo->lpTitle;
    lpStartupInfo->dwX             = StartupInfo->dwX;
    lpStartupInfo->dwY             = StartupInfo->dwY;
    lpStartupInfo->dwXSize         = StartupInfo->dwXSize;
    lpStartupInfo->dwYSize         = StartupInfo->dwYSize;
    lpStartupInfo->dwXCountChars   = StartupInfo->dwXCountChars;
    lpStartupInfo->dwYCountChars   = StartupInfo->dwYCountChars;
    lpStartupInfo->dwFillAttribute = StartupInfo->dwFillAttribute;
    lpStartupInfo->dwFlags         = StartupInfo->dwFlags;
    lpStartupInfo->wShowWindow     = StartupInfo->wShowWindow;
    lpStartupInfo->cbReserved2     = StartupInfo->cbReserved2;
    lpStartupInfo->lpReserved2     = StartupInfo->lpReserved2;

    if (lpStartupInfo->dwFlags & (STARTF_USESTDHANDLES | STARTF_USEHOTKEY | STARTF_HASSHELLDATA)) {
        lpStartupInfo->hStdInput   = StartupInfo->hStdInput;
        lpStartupInfo->hStdOutput  = StartupInfo->hStdOutput;
        lpStartupInfo->hStdError   = StartupInfo->hStdError;
    } else {
        lpStartupInfo->hStdInput   = INVALID_HANDLE_VALUE;
        lpStartupInfo->hStdOutput  = INVALID_HANDLE_VALUE;
        lpStartupInfo->hStdError   = INVALID_HANDLE_VALUE;
        }
    return;
error4:
    RtlFreeAnsiString (&AnsiString2);
error3:
    RtlFreeAnsiString (&AnsiString1);
error2:
    RtlFreeHeap (RtlProcessHeap (), 0, StartupInfo);
error1:
    RtlRaiseStatus (Status);
    return;
}


LPSTR
WINAPI
GetCommandLineA(
    VOID
    )

/*++

Routine Description:

    The command line of the current process is available using this
    API.

Arguments:

    None.

Return Value:

    The address of the current processes command line is returned.  The
    return value is a pointer to null terminate string.

--*/

{
    return (LPSTR)BaseAnsiCommandLine.Buffer;
}

LPWSTR
WINAPI
GetCommandLineW(
    VOID
    )
/*++

Routine Description:

    The command line of the current process is available using this
    API.

Arguments:

    None.

Return Value:

    The address of the current processes command line is returned.  The
    return value is a pointer to null terminate string.

--*/

{
    return BaseUnicodeCommandLine.Buffer;
}



BOOL
WINAPI
FreeEnvironmentStringsW(
    LPWSTR penv
    )

/*++

Routine Description:

    This API is intended to be called after the environment block
    pointer returned by GetEnvironmentStringsW is no longer needed.

Arguments:

    penv - Environment block returned by GetEnvironmentStringsW

Return Value:

    TRUE, since the process environment block is never freed until
    the process terminates.

--*/

{
    return RtlFreeHeap (RtlProcessHeap (), 0, penv);
}


BOOL
WINAPI
FreeEnvironmentStringsA(
    LPSTR penv
    )

/*++

Routine Description:

    This API is intended to be called after the environment block
    pointer returned by GetEnvironmentStringsA is no longer needed.

Arguments:

    penv - Environment block returned by GetEnvironmentStrings

Return Value:

    The return code from RtlFreeHeap.

--*/

{
    return RtlFreeHeap(RtlProcessHeap(), 0, penv );
}


LPWSTR
WINAPI
GetEnvironmentStringsW(
    VOID
    )

/*++

Routine Description:

    The environment strings of the current process are available using
    this API.

Arguments:

    None.

Return Value:

    The address of the current processes environment block is returned.
    The block is opaque and must only be interpreted via the environment
    variable access functions.

--*/

{
    PPEB Peb;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    LPWSTR pUnicode;
    SIZE_T Len = 0;
    LPWSTR DstBuffer, SrcBuffer;

    Peb = NtCurrentPeb ();
    ProcessParameters = Peb->ProcessParameters;

    RtlAcquirePebLock ();

    SrcBuffer = pUnicode = (LPWSTR)(ProcessParameters->Environment);

    while (1) {
        Len = wcslen (pUnicode);
        pUnicode += Len + 1;
        if (*pUnicode == L'\0') {
            pUnicode++;
            break;
        }
    }

    //
    // Calculate total size of buffer needed to hold the block
    //
    Len = (PUCHAR)pUnicode - (PUCHAR)SrcBuffer;

    DstBuffer = RtlAllocateHeap (RtlProcessHeap (), MAKE_TAG (ENV_TAG), Len);
    if (DstBuffer == NULL) {
        RtlReleasePebLock ();
        BaseSetLastNTError (STATUS_NO_MEMORY);
        return NULL;
    }

    RtlCopyMemory (DstBuffer, SrcBuffer, Len);

    RtlReleasePebLock ();

    return DstBuffer;

}


LPSTR
WINAPI
GetEnvironmentStrings(
    VOID
    )

/*++

Routine Description:

    The environment strings of the current process are available using
    this API.

Arguments:

    None.

Return Value:

    The address of the current processes environment block is returned.
    The block is opaque and must only be interpreted via the environment
    variable access functions.

--*/

{
    NTSTATUS       Status;
    LPWSTR         pUnicode;
    LPWSTR         BufferW;
    LPSTR          BufferA;
    ULONG          LenW;
    ULONG          LenA;
    PPEB           Peb;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;

    Peb = NtCurrentPeb ();
    ProcessParameters = Peb->ProcessParameters;

    RtlAcquirePebLock ();

    pUnicode = (LPWSTR)(ProcessParameters->Environment);
    BufferW = pUnicode;

    while (1) {
        LenW = wcslen (pUnicode);
        pUnicode += LenW + 1;
        if (*pUnicode == L'\0') {
            pUnicode++;
            break;
        }
    }

    //
    // Calculate total size of buffer needed to hold the block
    //
    LenW = (ULONG)((PUCHAR)pUnicode - (PUCHAR)BufferW);


    Status = RtlUnicodeToMultiByteSize (&LenA,
                                        BufferW,
                                        LenW);

    if (!NT_SUCCESS (Status)) {
        RtlReleasePebLock ();
        BaseSetLastNTError (Status);
        return NULL;
    }


    BufferA = RtlAllocateHeap (RtlProcessHeap (), MAKE_TAG (ENV_TAG), LenA);
    if (BufferA == NULL) {
        RtlReleasePebLock ();
        BaseSetLastNTError (STATUS_NO_MEMORY);
        return NULL;
    }

    Status = RtlUnicodeToOemN (BufferA,
                               LenA,
                               NULL,
                               BufferW,
                               LenW);

    if (!NT_SUCCESS (Status)) {
        RtlReleasePebLock ();
        RtlFreeHeap (RtlProcessHeap (), 0, BufferA);
        BaseSetLastNTError (Status);
        return NULL;
    }

    RtlReleasePebLock ();


    return BufferA;
}


BOOL
WINAPI
SetEnvironmentStringsA(
    LPSTR NewEnvironment
    )
/*++

Routine Description:

    This function sets the environment block of the current process

Arguments:

    NewEnvironment - Zero terminated strings terminated by an extra termination

Return Value:

    TRUE - The function suceeded, FALSE - The function failed and GetLastError() gives the error

--*/
{
    PSTR           Temp;
    OEM_STRING     Buffer;
    UNICODE_STRING Unicode;
    SIZE_T         Len;
    NTSTATUS       Status;

    Temp = NewEnvironment;
 
    while (1) {
        Len = strlen (Temp);
        if (Len == 0 || strchr (Temp+1, '=') == NULL) {
            BaseSetLastNTError (STATUS_INVALID_PARAMETER);
            return FALSE;
        }
        Temp += Len + 1;
        if (*Temp == '\0') {
            Temp++;
            break;
        }
    }

    //
    // Calculate total size of buffer needed to hold the block
    //

    Len = Temp - NewEnvironment;

    if (Len > UNICODE_STRING_MAX_CHARS) {
        BaseSetLastNTError (STATUS_INVALID_PARAMETER);
        return FALSE;
    }

    Buffer.Length = (USHORT) Len;
    Buffer.Buffer = NewEnvironment;


    Status = RtlOemStringToUnicodeString (&Unicode, &Buffer, TRUE);
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (STATUS_INVALID_PARAMETER);
        return FALSE;
    }
    Status = RtlSetEnvironmentStrings (Unicode.Buffer, Unicode.Length);

    RtlFreeUnicodeString (&Unicode);

    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (STATUS_INVALID_PARAMETER);
        return FALSE;
    }
    return TRUE;
}

BOOL
WINAPI
SetEnvironmentStringsW(
    LPWSTR NewEnvironment
    )
/*++

Routine Description:

    This function sets the environment block of the current process

Arguments:

    NewEnvironment - Zero terminated strings terminated by an extra termination

Return Value:

    TRUE - The function suceeded, FALSE - The function failed and GetLastError() gives the error

--*/
{
    SIZE_T   Len;
    PWSTR    Temp, p;
    NTSTATUS Status;

    Temp = NewEnvironment;
 
    while (1) {
        Len = wcslen (Temp);

        //
        // Reject zero length strings
        //
        if (Len == 0) {
            BaseSetLastNTError (STATUS_INVALID_PARAMETER);
            return FALSE;
        }

        //
        // Reject strings without '=' in the name or if the first part of the string is too big.
        //
        p = wcschr (Temp+1, '=');
        if (p == NULL || (p - Temp) > UNICODE_STRING_MAX_CHARS || Len - (p - Temp) - 1 > UNICODE_STRING_MAX_CHARS) {
            BaseSetLastNTError (STATUS_INVALID_PARAMETER);
            return FALSE;
        }
        Temp += Len + 1;
        if (*Temp == L'\0') {
            Temp++;
            break;
        }
    }

    //
    // Calculate total size of buffer needed to hold the block
    //

    Len = (PUCHAR)Temp - (PUCHAR)NewEnvironment;

    Status = RtlSetEnvironmentStrings (NewEnvironment, Len);
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (STATUS_INVALID_PARAMETER);
        return FALSE;
    }
    return TRUE;
}

DWORD
WINAPI
GetEnvironmentVariableA(
    LPCSTR lpName,
    LPSTR lpBuffer,
    DWORD nSize
    )

/*++

Routine Description:

    The value of an environment variable of the current process is available
    using this API.

Arguments:

    lpName - Pointer to a null terminate string that is the name of the
        environment variable whose value is being requested.

    lpBuffer - Pointer to a buffer that is to contain the value of the
        specified variable name.

    nSize - Specifies the maximum number of bytes that can be stored in
        the buffer pointed to by lpBuffer, including the null terminator.

Return Value:

    The actual number of bytes stored in the memory pointed to by the
    lpBuffer parameter.  The return value is zero if the environment
    variable name was not found in the current process's environment.
    On successful return (returned value < nSize) the returned value
    does not include the null terminator byte. On buffer overflow failure
    (returned value > nSize), the returned value does include the null
    terminator byte.

--*/

{
    NTSTATUS Status;
    STRING Value, Name;
    UNICODE_STRING UnicodeName;
    UNICODE_STRING UnicodeValue;
    DWORD iSize;
    DWORD Result;

    RtlInitString(&Name, lpName);
    RtlInitUnicodeString(&UnicodeName, NULL);
    RtlInitUnicodeString(&UnicodeValue, NULL);

    Status = RtlAnsiStringToUnicodeString(&UnicodeName, &Name, TRUE);
    if (!NT_SUCCESS(Status)) {
        goto cleanup;
    }

    if (nSize > (MAXUSHORT >> 1)-2) {
        iSize = (MAXUSHORT >> 1)-2;
    } else {
        iSize = nSize;
    }

    UnicodeValue.MaximumLength = (USHORT)(iSize ? iSize - 1 : iSize)*sizeof(WCHAR);
    UnicodeValue.Buffer = (PWCHAR) RtlAllocateHeap(RtlProcessHeap(),
                                                   MAKE_TAG(TMP_TAG),
                                                   UnicodeValue.MaximumLength);
    if (UnicodeValue.Buffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

    // We need to guarantee that the environment doesn't change while
    // we're looking at it -- and RtlQueryEnvironmentVariable_U will
    // acquire the peb lock anyway, so this shouldn't create any new
    // deadlocks, we'll just hold the lock a little longer
    RtlAcquirePebLock();

    Status = RtlQueryEnvironmentVariable_U(NULL,
                                           &UnicodeName,
                                           &UnicodeValue);

    if (NT_SUCCESS(Status) && (nSize == 0)) {
        Status = STATUS_BUFFER_TOO_SMALL; // No room for terminator
    }

    if (NT_SUCCESS(Status)) {

        if (nSize > MAXUSHORT-2) {
            iSize = MAXUSHORT-2;
        } else {
            iSize = nSize;
        }

        Result = RtlUnicodeStringToAnsiSize(&UnicodeValue);

        // Note that this test will not automatically succeed in an
        // MBCS world--we might have more bytes than chars but fewer
        // bytes than we need to represent the chars.
        if (Result <= iSize) {

            Value.Buffer = lpBuffer;
            Value.MaximumLength = (USHORT)iSize;

            Status = RtlUnicodeStringToAnsiString(&Value, &UnicodeValue, FALSE);

            if (NT_SUCCESS(Status)) {
                lpBuffer[Value.Length] = '\0';
                Result = Value.Length;
            }
        }

    } else if (Status == STATUS_BUFFER_TOO_SMALL) {

        UnicodeValue.MaximumLength = UnicodeValue.Length + sizeof(WCHAR); // for NULL

        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeValue.Buffer);

        UnicodeValue.Buffer = (PWCHAR) RtlAllocateHeap(RtlProcessHeap(),
                                                       MAKE_TAG(TMP_TAG),
                                                       UnicodeValue.MaximumLength);

        if (UnicodeValue.Buffer == NULL) {

            Status = STATUS_NO_MEMORY;

        } else {

            Status = RtlQueryEnvironmentVariable_U(NULL,
                                                   &UnicodeName,
                                                   &UnicodeValue);

            if (NT_SUCCESS(Status)) {
                Result = RtlUnicodeStringToAnsiSize(&UnicodeValue);
                // Result already includes the NULL character.
            }
        }
    }

    RtlReleasePebLock();

 cleanup:
    RtlFreeUnicodeString(&UnicodeName);
    if (UnicodeValue.Buffer) {
        RtlFreeHeap(RtlProcessHeap(),
                    0,
                    UnicodeValue.Buffer);
    }

    if (! NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        Result = 0;
    }

    return Result;
}


BOOL
WINAPI
SetEnvironmentVariableA(
    LPCSTR lpName,
    LPCSTR lpValue
    )

/*++

Routine Description:

    The value of an environment variable of the current process is available
    using this API.

Arguments:

    lpName - Pointer to a null terminate string that is the name of the
        environment variable whose value is being requested.

    lpValue - An optional pointer to a null terminated string that is to be
        the new value of the specified variable name.  If this parameter
        is NULL, then the variable will be deleted from the current
        process's environment.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    STRING Name;
    STRING Value;
    UNICODE_STRING UnicodeName;
    UNICODE_STRING UnicodeValue;

    RtlInitString( &Name, lpName );
    Status = RtlAnsiStringToUnicodeString(&UnicodeName, &Name, TRUE);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError( Status );
        return FALSE;
        }

    if (ARGUMENT_PRESENT( lpValue )) {
        RtlInitString( &Value, lpValue );
        Status = RtlAnsiStringToUnicodeString(&UnicodeValue, &Value, TRUE);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError( Status );
            RtlFreeUnicodeString(&UnicodeName);
            return FALSE;
            }
        Status = RtlSetEnvironmentVariable( NULL, &UnicodeName, &UnicodeValue);
        RtlFreeUnicodeString(&UnicodeValue);
        }
    else {
        Status = RtlSetEnvironmentVariable( NULL, &UnicodeName, NULL);
        }
    RtlFreeUnicodeString(&UnicodeName);

    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        BaseSetLastNTError( Status );
        return( FALSE );
        }
}


DWORD
WINAPI
GetEnvironmentVariableW(
    LPCWSTR lpName,
    LPWSTR lpBuffer,
    DWORD nSize
    )
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    DWORD iSize;

    if (nSize > UNICODE_STRING_MAX_CHARS - 1) {
        iSize = UNICODE_STRING_MAX_BYTES - sizeof (WCHAR);
    } else {
        if (nSize > 0) {
            iSize = (nSize - 1) * sizeof (WCHAR);
        } else {
            iSize = 0;
        }
    }

    Status = RtlInitUnicodeStringEx (&Name, lpName);
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return( 0 );
    }

    Value.Buffer = lpBuffer;
    Value.Length = 0;
    Value.MaximumLength = (USHORT)iSize;

    Status = RtlQueryEnvironmentVariable_U (NULL,
                                            &Name,
                                            &Value);

    if (NT_SUCCESS (Status) && (nSize == 0)) {
        Status = STATUS_BUFFER_TOO_SMALL; // No room for terminator
    }

    if (NT_SUCCESS (Status)) {
        lpBuffer[Value.Length / sizeof(WCHAR)] = L'\0';
        return (Value.Length / sizeof(WCHAR));
    } else {
        if (Status == STATUS_BUFFER_TOO_SMALL) {
            return Value.Length / sizeof(WCHAR) + 1;
        } else {
            BaseSetLastNTError (Status);
            return (0);
        }
    }
}


BOOL
WINAPI
SetEnvironmentVariableW(
    LPCWSTR lpName,
    LPCWSTR lpValue
    )
{
    NTSTATUS Status;
    UNICODE_STRING Name, Value;

    Status = RtlInitUnicodeStringEx (&Name, lpName);
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return (FALSE);
    }


    if (ARGUMENT_PRESENT (lpValue)) {
        Status = RtlInitUnicodeStringEx (&Value, lpValue);
        if (!NT_SUCCESS (Status)) {
            BaseSetLastNTError (Status);
            return (FALSE);
        }

        Status = RtlSetEnvironmentVariable (NULL, &Name, &Value);
    } else {
        Status = RtlSetEnvironmentVariable (NULL, &Name, NULL);
    }

    if (NT_SUCCESS (Status)) {
        return (TRUE);
    } else {
        BaseSetLastNTError (Status);
        return (FALSE);
    }
}


DWORD
WINAPI
ExpandEnvironmentStringsA(
    LPCSTR lpSrc,
    LPSTR lpDst,
    DWORD nSize
    )
{
    NTSTATUS Status;
    ANSI_STRING Source, Destination;
    ULONG Length;
    UNICODE_STRING UnicodeSource;
    UNICODE_STRING UnicodeDest;
    DWORD iSize;
    DWORD Result;

    if (nSize > (MAXUSHORT >> 1)-2) {
        iSize = (MAXUSHORT >> 1)-2;
    } else {
        iSize = nSize;
    }

    if(lpDst != NULL) {
        *lpDst = '\0';
    }

    RtlInitUnicodeString(&UnicodeSource, NULL);
    RtlInitUnicodeString(&UnicodeDest, NULL);
    RtlInitString( &Source, lpSrc );

    Status = RtlAnsiStringToUnicodeString(&UnicodeSource,
                                          &Source,
                                          TRUE);
    if (!NT_SUCCESS(Status)) {
        goto cleanup;
    }
    UnicodeDest.MaximumLength = (USHORT)(iSize ? iSize - 1 : iSize)*sizeof(WCHAR);
    UnicodeDest.Buffer = (PWCHAR)
        RtlAllocateHeap(RtlProcessHeap(),
                        MAKE_TAG(TMP_TAG),
                        UnicodeDest.MaximumLength);
    if (UnicodeDest.Buffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

    Length = 0;
    Status = RtlExpandEnvironmentStrings_U(NULL,
                                           (PUNICODE_STRING)&UnicodeSource,
                                           (PUNICODE_STRING)&UnicodeDest,
                                           &Length);
    if (NT_SUCCESS(Status)) {

        if (nSize > MAXUSHORT-2) {
            iSize = MAXUSHORT-2;
        } else {
            iSize = nSize;
        }

        Result = RtlUnicodeStringToAnsiSize(&UnicodeDest);

        if (Result <= iSize) {

            Destination.MaximumLength = (USHORT)iSize;
            Destination.Buffer = lpDst;
            Status = RtlUnicodeStringToAnsiString(&Destination,&UnicodeDest,FALSE);

            if (!NT_SUCCESS(Status)) {
                *lpDst = '\0';
                goto cleanup;
            }

            //
            // Unlike most Win32 APIs, on success, this one returns
            // the length including the terminating NULL.  So Result
            // is already the correct value; we just need to return
            // it.
            //
        }

    } else if (Status == STATUS_BUFFER_TOO_SMALL) {

        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeDest.Buffer);
        UnicodeDest.MaximumLength = (USHORT)Length;
        UnicodeDest.Buffer = (PWCHAR)
            RtlAllocateHeap(RtlProcessHeap(),
                            MAKE_TAG(TMP_TAG),
                            UnicodeDest.MaximumLength);
        if (UnicodeDest.Buffer == NULL) {
            Status = STATUS_NO_MEMORY;
        } else {
            Status = RtlExpandEnvironmentStrings_U(NULL,
                                                   (PUNICODE_STRING)&UnicodeSource,
                                                   (PUNICODE_STRING)&UnicodeDest,
                                                   &Length);
            if (NT_SUCCESS(Status)) {
                Result = RtlUnicodeStringToAnsiSize(&UnicodeDest) + 1;
            }
        }
    }

 cleanup:
    RtlFreeUnicodeString(&UnicodeSource);
    if (UnicodeDest.Buffer) {
        RtlFreeHeap(RtlProcessHeap(),
                    0,
                    UnicodeDest.Buffer);
    }

    if (! NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        Result = 0;
    }

    return Result;
}


DWORD
WINAPI
ExpandEnvironmentStringsW(
    LPCWSTR lpSrc,
    LPWSTR lpDst,
    DWORD nSize
    )
{
    NTSTATUS Status;
    UNICODE_STRING Source, Destination;
    ULONG Length;
    DWORD iSize;

    if ( nSize > (MAXUSHORT >> 1)-2 ) {
        iSize = (MAXUSHORT >> 1)-2;
        }
    else {
        iSize = nSize;
        }

    RtlInitUnicodeString( &Source, lpSrc );
    Destination.Buffer = lpDst;
    Destination.Length = 0;
    Destination.MaximumLength = (USHORT)(iSize * sizeof( WCHAR ));
    Length = 0;
    Status = RtlExpandEnvironmentStrings_U( NULL,
                                            &Source,
                                            &Destination,
                                            &Length
                                          );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_TOO_SMALL) {
        return( Length / sizeof( WCHAR ) );
        }
    else {
        BaseSetLastNTError( Status );
        return( 0 );
        }
}


UINT
WINAPI
WinExec(
    LPCSTR lpCmdLine,
    UINT uCmdShow
    )

/*++

Routine Description:

    This function executes the Windows or non-Windows application
    identified by the lpCmdLine parameter.  The uCmdShow parameter
    specifies the initial state of the application's main window when it
    is created.

    The WinExec function is obsolete.  CreateProcess is the prefered
    mechanism for creating a process to run an application.  The Win32
    implementation of WinExec is layered on top of CreateProcess.  For
    each parameter to CreateProcess, the following section describes how
    the parameter is formed, and its meaning with respect to WinExec.

        lpApplicationName - NULL

        lpCommandLine - The value of lpCmdLine is passed.

        lpProcessAttributes - A value of NULL is used.

        lpThreadAttributes - A value of NULL is used.

        bInheritHandles - A value of FALSE is used.

        dwCreationFlags - A value of 0 is used

        lpEnvironment - The value of NULL is used.

        lpCurrentDirectory - A value of NULL is used.

        lpStartupInfo - The structure is initialized to NULL.  The cb
            field is initialized, and the wShowWindow field is set to
            the value of uCmdShow.

        lpProcessInformation.hProcess - The handle is immediately closed.

        lpProcessInformation.hThread - The handle is immediately closed.

Arguments:

    lpCmdLine - Points to a null-terminated character string that
        contains the command line (filename plus optional parameters)
        for the application to be executed.  If the lpCmdLine string
        does not contain a directory path, Windows will search for the
        executable file in this order:

        1.  The current directory

        2.  The Windows directory (the directory containing WIN.COM);
            the GetWindowsDirectory function obtains the pathname of
            this directory

        3.  The Windows system directory (the directory containing such
            system files as KERNEL.EXE); the GetSystemDirectory function
            obtains the pathname of this directory

        4.  The directories listed in the PATH environment variable

    uCmdShow - Specifies how a Windows application window is to be
        shown.  See the description of the ShowWindow function for a
        list of the acceptable values for the uCmdShow parameter.  For a
        non-Windows application, the PIF file, if any, for the
        application determines the window state.

Return Value:

    33 - The operation was successful

     2 - File not found.

     3 - Path not found.

    11 - Invalid .EXE file (non-Win32 .EXE or error in .EXE image).

     0 - Out of memory or system resources.


--*/

{
    STARTUPINFOA StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    BOOL CreateProcessStatus;
    DWORD ErrorCode;

retry:
    RtlZeroMemory(&StartupInfo,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.dwFlags = STARTF_USESHOWWINDOW;
    StartupInfo.wShowWindow = (WORD)uCmdShow;
    CreateProcessStatus = CreateProcess(
                            NULL,
                            (LPSTR)lpCmdLine,
                            NULL,
                            NULL,
                            FALSE,
                            0,
                            NULL,
                            NULL,
                            &StartupInfo,
                            &ProcessInformation
                            );

    if ( CreateProcessStatus ) {
        //
        // Wait for the started process to go idle. If it doesn't go idle in
        // 10 seconds, return anyway.
        //
        if (UserWaitForInputIdleRoutine != NULL)
            (*UserWaitForInputIdleRoutine)(ProcessInformation.hProcess,
                    DEFAULT_WAIT_FOR_INPUT_IDLE_TIMEOUT);
        NtClose(ProcessInformation.hProcess);
        NtClose(ProcessInformation.hThread);
        return 33;
        }
    else {
        //
        // If CreateProcess failed, then look at GetLastError to determine
        // appropriate return code.
        //

        //
        // Take a closer look at CreateProcess errors. For instance,
        // Claris Works 5.0 launches hyperterm.exe as hyperterm.exe"<null>
        // the trailing " is causing problems so nuke it and then retry.
        //

        if ( !lstrcmpiA(lpCmdLine,"hypertrm.exe\"") ) {
            lpCmdLine = "hypertrm.exe";
            goto retry;
            }

        ErrorCode = GetLastError();
        switch ( ErrorCode ) {
            case ERROR_FILE_NOT_FOUND:
                return 2;

            case ERROR_PATH_NOT_FOUND:
                return 3;

            case ERROR_BAD_EXE_FORMAT:
                return 11;

            default:
                return 0;
            }
        }
}

DWORD
WINAPI
LoadModule(
    LPCSTR lpModuleName,
    LPVOID lpParameterBlock
    )

/*++

Routine Description:

    This function loads and executes a Windows program.  This function
    is designed to layer directly on top of CreateProcess.

    The LoadModule function is obsolete.  CreateProcess is the prefered
    mechanism for creating a process to run an application.  The Win32
    implementation of LoadModule is layered on top of CreateProcess.
    For each parameter to CreateProcess, the following section describes
    how the parameter is formed, and its meaning with respect to
    LoadModule.

        lpApplicationName - The value of lpModuleName

        lpCommandLine - The value of lpParameterBlock->lpCmdLine.

        lpProcessAttributes - A value of NULL is used.

        lpThreadAttributes - A value of NULL is used.

        bInheritHandles - A value of FALSE is used.

        dwCreationFlags - A value of 0 is used

        lpEnvironment - The value of lpEnvAddress from the parameter
            block is used.

        lpCurrentDirectory - A value of NULL is used.

        lpStartupInfo - The structure is initialized to NULL.  The cb
            field is initialized, and the wShowWindow field is set to
            the value of second word of the lpCmdShow field of the
            parameter block is used.

        lpProcessInformation.hProcess - The handle is immediately closed.

        lpProcessInformation.hThread - The handle is immediately closed.

Arguments:

    lpModuleName - Points to a null-terminated string that contains the
        filename of the application to be run.  If the lpModuleName
        string does not contain a directory path, Windows will search
        for the executable file in this order:

        1.  The current directory

        2.  The Windows directory.  the GetWindowsDirectory function
            obtains the pathname of this directory

        3.  The Windows system directory (the directory containing such
            system files as KERNEL.EXE); the GetSystemDirectory function
            obtains the pathname of this directory

        4.  The directories listed in the PATH environment variable

    lpParameterBlock - Points to a data structure consisting of four
        fields that defines a parameter block.  This data structure
        consists of the following fields:

        lpEnvAddress - Points to an array of NULL terminated strings
            that supply the environment strings for the new process.
            The array has a value of NULL as its last entry.  A value of
            NULL for this parameter causes the new process to start with
            the same environment as the calling process.

        lpCmdLine - Points to a null-terminated string that contains a
            correctly formed command line.

        lpCmdShow - Points to a structure containing two WORD values.
            The first value must always be set to two.  The second value
            specifies how the application window is to be shown and is used
            to supply the dwShowWindow parameter to CreateProcess.  See
            the description of the <uCmdShow> paramter of the ShowWindow
            function for a list of the acceptable values.

        dwReserved - Is reserved and must be NULL.

        All unused fields should be set to NULL, except for lpCmdLine,
        which must point to a null string if it is not used.

Return Value:

    33 - The operation was successful

     2 - File not found.

     3 - Path not found.

    11 - Invalid .EXE file (non-Win32 .EXE or error in .EXE image).

     0 - Out of memory or system resources.

--*/

{
    STARTUPINFOA StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    BOOL CreateProcessStatus;
    PLOAD_MODULE_PARAMS LoadModuleParams;
    LPSTR NameBuffer;
    LPSTR CommandLineBuffer;
    DWORD Length;
    DWORD CreateFlag;

    CreateFlag = 0;
    LoadModuleParams = (PLOAD_MODULE_PARAMS)lpParameterBlock;

    if ( LoadModuleParams->dwReserved ||
         LoadModuleParams->lpCmdShow->wMustBe2 != 2 ) {

        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return 0;
        }
    CommandLineBuffer = NULL;
    NameBuffer = NULL;
    try {

        //
        // Locate the image
        //

        NameBuffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), MAX_PATH);

        if (!NameBuffer) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            CreateProcessStatus = FALSE;
            leave;
        }

        Length = SearchPath(
                    NULL,
                    lpModuleName,
                    ".exe",
                    MAX_PATH,
                    NameBuffer,
                    NULL
                    );
        if ( !Length || Length >= MAX_PATH ) {

            //
            // If we search pathed, then return file not found.
            // otherwise, try to be more specific.
            //
            RTL_PATH_TYPE PathType;
            HANDLE hFile;
            UNICODE_STRING u;
            ANSI_STRING a;

            RtlInitAnsiString(&a,lpModuleName);
            if ( !NT_SUCCESS(RtlAnsiStringToUnicodeString(&u,&a,TRUE)) ) {
                if ( NameBuffer ) {
                    RtlFreeHeap(RtlProcessHeap(), 0,NameBuffer);
                    }
                return 2;
                }
            PathType = RtlDetermineDosPathNameType_U(u.Buffer);
            RtlFreeUnicodeString(&u);
            if ( PathType != RtlPathTypeRelative ) {

                //
                // The failed open should set get last error properly.
                //

                hFile = CreateFile(
                            lpModuleName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );
                RtlFreeHeap(RtlProcessHeap(), 0,NameBuffer);
                if ( hFile != INVALID_HANDLE_VALUE ) {
                    CloseHandle(hFile);
                    return 2;
                    }
                return GetLastError();
                }
            else {
                RtlFreeHeap(RtlProcessHeap(), 0,NameBuffer);
                return 2;
                }
            }

        RtlZeroMemory(&StartupInfo,sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);
        StartupInfo.dwFlags = STARTF_USESHOWWINDOW;
        StartupInfo.wShowWindow =
            LoadModuleParams->lpCmdShow->wShowWindowValue;

        CommandLineBuffer = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), (ULONG)LoadModuleParams->lpCmdLine[0]+1+Length+1);

        RtlCopyMemory(CommandLineBuffer,NameBuffer,Length);
        CommandLineBuffer[Length] = ' ';
        RtlCopyMemory(&CommandLineBuffer[Length+1],&LoadModuleParams->lpCmdLine[1],(ULONG)LoadModuleParams->lpCmdLine[0]);
        CommandLineBuffer[Length+1+LoadModuleParams->lpCmdLine[0]] = '\0';

        CreateProcessStatus = CreateProcess(
                                NameBuffer,
                                CommandLineBuffer,
                                NULL,
                                NULL,
                                FALSE,
                                CreateFlag,
                                LoadModuleParams->lpEnvAddress,
                                NULL,
                                &StartupInfo,
                                &ProcessInformation
                                );
        RtlFreeHeap(RtlProcessHeap(), 0,NameBuffer);
        NameBuffer = NULL;
        RtlFreeHeap(RtlProcessHeap(), 0,CommandLineBuffer);
        CommandLineBuffer = NULL;
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        RtlFreeHeap(RtlProcessHeap(), 0,NameBuffer);
        RtlFreeHeap(RtlProcessHeap(), 0,CommandLineBuffer);
        BaseSetLastNTError(GetExceptionCode());
        return 0;
        }

    if ( CreateProcessStatus ) {

        //
        // Wait for the started process to go idle. If it doesn't go idle in
        // 10 seconds, return anyway.
        //

        if (UserWaitForInputIdleRoutine != NULL)
            (*UserWaitForInputIdleRoutine)(ProcessInformation.hProcess,
                    DEFAULT_WAIT_FOR_INPUT_IDLE_TIMEOUT);
        NtClose(ProcessInformation.hProcess);
        NtClose(ProcessInformation.hThread);
        return 33;
        }
    else {

        //
        // If CreateProcess failed, then look at GetLastError to determine
        // appropriate return code.
        //

        Length = GetLastError();
        switch ( Length ) {
            case ERROR_FILE_NOT_FOUND:
                return 2;

            case ERROR_PATH_NOT_FOUND:
                return 3;

            case ERROR_BAD_EXE_FORMAT:
                return 11;

            default:
                return 0;
            }
        }
}

HANDLE
WINAPI
GetCurrentProcess(
    VOID
    )

/*++

Routine Description:

    A pseudo handle to the current process may be retrieved using
    GetCurrentProcess.

    A special constant is exported by Win32 that is interpreted as a
    handle to the current process.  This handle may be used to specify
    the current process whenever a process handle is required.  On
    Win32, this handle has PROCESS_ALL_ACCESS to the current process.
    On NT/Win32, this handle has the maximum access allowed by any
    security descriptor placed on the current process.

Arguments:

    None.

Return Value:

    Returns the pseudo handle of the current process.

--*/

{
    return NtCurrentProcess();
}

DWORD
WINAPI
GetCurrentProcessId(
    VOID
    )

/*++

Routine Description:

    The process ID of the current process may be retrieved using
    GetCurrentProcessId.

Arguments:

    None.

Return Value:

    Returns a unique value representing the process ID of the currently
    executing process.  The return value may be used to open a handle to
    a process.

--*/

{
    return HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess);
}

DWORD
APIENTRY
GetProcessId(
    HANDLE Process
    )
/*++

Routine Description:

    Gets the process ID of the process open via the specified handle

Arguments:

    Process - Handle of the process to do the query on

Return Value:

    Returns a unique value representing the process ID of the
    executing process.  The return value may be used to identify a process
    in the system. If the function fails the return value is zero.

--*/

{
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION pbi;

    Status = NtQueryInformationProcess (Process,
                                        ProcessBasicInformation,
                                        &pbi,
                                        sizeof (pbi),
                                        NULL);

    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return 0;
    }

    return  (DWORD) pbi.UniqueProcessId;
}

BOOL
WINAPI
ReadProcessMemory(
    HANDLE hProcess,
    LPCVOID lpBaseAddress,
    LPVOID lpBuffer,
    SIZE_T nSize,
    SIZE_T *lpNumberOfBytesRead
    )

/*++

Routine Description:

    Memory within a specified process can be read using
    ReadProcessMemory.

    This function copies the data in the specified address range from
    the specified process into the specified buffer of the current
    process.  The specified process does not have to be being debugged
    in order for this API to operate.  The caller must simply have a
    handle to the process that was created with PROCESS_VM_READ access.

Arguments:

    hProcess - Supplies an open handle to a process whose memory is to
        be read.  The handle must have been created with PROCESS_VM_READ
        access to the process.

    lpBaseAddress - Supplies the base address in the specified process
        to be read.  Before any data transfer occurs, the system
        verifies that all data within the base address and the specified
        size is accessible for read access.  If this is the case, then
        the API proceeds.  Otherwise the API fail.

    lpBuffer - Supplies the address of a buffer which receives the
        contents from the specified process address space.

    nSize - Supplies the requested number of bytes to read from the
        specified process.

    lpNumberOfBytesRead - An optional parameter, that if supplied
        receives the actual number of bytes transferred into the
        specified buffer.  This can be different than the value of nSize
        if the requested read crosses into an area of the process that
        is inaccessible (and that was made inaccessible during the data
        transfer).  If this occurs a value of FALSE is returned and
        GetLastError returns a "short read" error indicator.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    SIZE_T NtNumberOfBytesRead;

    Status = NtReadVirtualMemory(
                hProcess,
                (PVOID)lpBaseAddress,
                lpBuffer,
                nSize,
                &NtNumberOfBytesRead
                );

    if ( lpNumberOfBytesRead != NULL ) {
        *lpNumberOfBytesRead = NtNumberOfBytesRead;
        }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    else {
        return TRUE;
        }
}

BOOL
WINAPI
WriteProcessMemory(
    HANDLE hProcess,
    LPVOID lpBaseAddress,
    LPCVOID lpBuffer,
    SIZE_T nSize,
    SIZE_T *lpNumberOfBytesWritten
    )

/*++

Routine Description:

    Memory within a specified process can be written using
    WriteProcessMemory.

    This function copies the from the specified buffer in the current
    process to the address range of the specified process.  The
    specified process does not have to be being debugged in order for
    this API to operate.  The caller must simply have a handle to the
    process that was created with PROCESS_VM_WRITE access.

Arguments:

    hProcess - Supplies an open handle to a process whose memory is to
        be written.  The handle must have been created with PROCESS_VM_WRITE
        access to the process.

    lpBaseAddress - Supplies the base address in the specified process
        to be written.  Before any data transfer occurs, the system
        verifies that all data within the base address and the specified
        size is accessible for write access.  If this is the case, then
        the API proceeds.  Otherwise the API fail.

    lpBuffer - Supplies the address of a buffer which supplies the data
        to be written into the specified process address space.

    nSize - Supplies the requested number of bytes to write into the
        specified process.

    lpNumberOfBytesWritten - An optional parameter, that if supplied
        receives the actual number of bytes transferred into the
        specified process.  This can be different than the value of
        nSize if the requested write crosses into an area of the process
        that is inaccessible (and that was made inaccessible during the
        data transfer).  .  If this occurs a value of FALSE is returned
        and GetLastError returns a "short write" error indicator.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status, xStatus;
    ULONG OldProtect;
    SIZE_T RegionSize;
    PVOID Base;
    SIZE_T NtNumberOfBytesWritten;

    //
    // Set the protection to allow writes
    //

    RegionSize =  nSize;
    Base = lpBaseAddress;
    Status = NtProtectVirtualMemory(
                hProcess,
                &Base,
                &RegionSize,
                PAGE_READWRITE,
                &OldProtect
                );
    if ( NT_SUCCESS(Status) ) {

        //
        // See if previous protection was writable. If so,
        // then reset protection and do the write.
        // Otherwise, see if previous protection was read-only or
        // no access. In this case, don't do the write, just fail
        //

        if ( (OldProtect & PAGE_READWRITE) == PAGE_READWRITE ||
             (OldProtect & PAGE_WRITECOPY) == PAGE_WRITECOPY ||
             (OldProtect & PAGE_EXECUTE_READWRITE) == PAGE_EXECUTE_READWRITE ||
             (OldProtect & PAGE_EXECUTE_WRITECOPY) == PAGE_EXECUTE_WRITECOPY ) {

            Status = NtProtectVirtualMemory(
                        hProcess,
                        &Base,
                        &RegionSize,
                        OldProtect,
                        &OldProtect
                        );
            Status = NtWriteVirtualMemory(
                        hProcess,
                        lpBaseAddress,
                        lpBuffer,
                        nSize,
                        &NtNumberOfBytesWritten
                        );

            if ( lpNumberOfBytesWritten != NULL ) {
                *lpNumberOfBytesWritten = NtNumberOfBytesWritten;
                }

            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(Status);
                return FALSE;
                }
            NtFlushInstructionCache(hProcess,lpBaseAddress,nSize);
            return TRUE;
            }
        else {

            //
            // See if the previous protection was read only or no access. If
            // this is the case, restore the previous protection and return
            // an access violation error.
            //
            if ( (OldProtect & PAGE_NOACCESS) == PAGE_NOACCESS ||
                 (OldProtect & PAGE_READONLY) == PAGE_READONLY ) {

                Status = NtProtectVirtualMemory(
                            hProcess,
                            &Base,
                            &RegionSize,
                            OldProtect,
                            &OldProtect
                            );
                BaseSetLastNTError(STATUS_ACCESS_VIOLATION);
                return FALSE;
                }
            else {

                //
                // The previous protection must have been code and the caller
                // is trying to set a breakpoint or edit the code. Do the write
                // and then restore the previous protection.
                //

                Status = NtWriteVirtualMemory(
                            hProcess,
                            lpBaseAddress,
                            lpBuffer,
                            nSize,
                            &NtNumberOfBytesWritten
                            );

                if ( lpNumberOfBytesWritten != NULL ) {
                    *lpNumberOfBytesWritten = NtNumberOfBytesWritten;
                    }

                xStatus = NtProtectVirtualMemory(
                            hProcess,
                            &Base,
                            &RegionSize,
                            OldProtect,
                            &OldProtect
                            );
                if ( !NT_SUCCESS(Status) ) {
                    BaseSetLastNTError(STATUS_ACCESS_VIOLATION);
                    return STATUS_ACCESS_VIOLATION;
                    }
                NtFlushInstructionCache(hProcess,lpBaseAddress,nSize);
                return TRUE;
                }
            }
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

VOID
WINAPI
FatalAppExitW(
    UINT uAction,
    LPCWSTR lpMessageText
    )
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    ULONG Response;
    ULONG_PTR ErrorParameters[1];

    RtlInitUnicodeString(&UnicodeString,lpMessageText);

    ErrorParameters[0] = (ULONG_PTR)&UnicodeString;

    Status =NtRaiseHardError( STATUS_FATAL_APP_EXIT | HARDERROR_OVERRIDE_ERRORMODE,
                              1,
                              1,
                              ErrorParameters,
#if DBG
                              OptionOkCancel,
#else
                              OptionOk,
#endif
                              &Response
                            );


    if ( NT_SUCCESS(Status) && Response == ResponseCancel ) {
        return;
        }
    else {
        ExitProcess(0);
        }
}


VOID
WINAPI
FatalAppExitA(
    UINT uAction,
    LPCSTR lpMessageText
    )
{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(
        &AnsiString,
        lpMessageText
        );
    Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        ExitProcess(0);
        }
    FatalAppExitW(uAction,Unicode->Buffer);
}

VOID
WINAPI
FatalExit(
    int ExitCode
    )
{
#if DBG
    char Response[ 2 ];
    DbgPrint("FatalExit...\n");
    DbgPrint("\n");

    while (TRUE) {
        DbgPrompt( "A (Abort), B (Break), I (Ignore)? ",
                   Response,
                   sizeof( Response )
                 );
        switch (Response[0]) {
            case 'B':
            case 'b':
                DbgBreakPoint();
                break;

            case 'I':
            case 'i':
                return;

            case 'A':
            case 'a':
                ExitProcess(ExitCode);
                break;
            }
        }
#endif
    ExitProcess(ExitCode);
}

BOOL
WINAPI
IsProcessorFeaturePresent(
    DWORD ProcessorFeature
    )
{
    BOOL rv;

    if ( ProcessorFeature < PROCESSOR_FEATURE_MAX ) {
        rv = (BOOL)(USER_SHARED_DATA->ProcessorFeatures[ProcessorFeature]);
        }
    else {
        rv = FALSE;
        }
    return rv;
}

VOID
GetSystemInfoInternal(
    IN PSYSTEM_BASIC_INFORMATION BasicInfo,
    IN PSYSTEM_PROCESSOR_INFORMATION ProcessorInfo,
    OUT LPSYSTEM_INFO lpSystemInfo
    )
/*++

Routine Description:

    The GetSystemInfo function is used to return information about the
    current system.  This includes the processor type, page size, oem
    id, and other interesting pieces of information.

Arguments:

    BasicInfo - Pointer to an initialized SYSTEM_BASIC_INFORMATION structure.

    ProcessorInfo - Pointer to an initialized SYSTEM_PROCESSOR_INFORMATION structure.

    lpSystemInfo - Returns information about the current system.


Return Value:

    None.

--*/
{
    RtlZeroMemory(lpSystemInfo,sizeof(*lpSystemInfo));

    lpSystemInfo->wProcessorArchitecture = ProcessorInfo->ProcessorArchitecture;
    lpSystemInfo->wReserved = 0;
    lpSystemInfo->dwPageSize = BasicInfo->PageSize;
    lpSystemInfo->lpMinimumApplicationAddress = (LPVOID)BasicInfo->MinimumUserModeAddress;
    lpSystemInfo->lpMaximumApplicationAddress = (LPVOID)BasicInfo->MaximumUserModeAddress;
    lpSystemInfo->dwActiveProcessorMask = BasicInfo->ActiveProcessorsAffinityMask;
    lpSystemInfo->dwNumberOfProcessors = BasicInfo->NumberOfProcessors;
    lpSystemInfo->wProcessorLevel = ProcessorInfo->ProcessorLevel;
    lpSystemInfo->wProcessorRevision = ProcessorInfo->ProcessorRevision;

    if (ProcessorInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {
        if (ProcessorInfo->ProcessorLevel == 3) {
            lpSystemInfo->dwProcessorType = PROCESSOR_INTEL_386;
            }
        else
        if (ProcessorInfo->ProcessorLevel == 4) {
            lpSystemInfo->dwProcessorType = PROCESSOR_INTEL_486;
            }
        else {
            lpSystemInfo->dwProcessorType = PROCESSOR_INTEL_PENTIUM;
            }
        }
    else
    if (ProcessorInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64) {
        lpSystemInfo->dwProcessorType = PROCESSOR_INTEL_IA64;
        }
    else
    if (ProcessorInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) {
        lpSystemInfo->dwProcessorType = PROCESSOR_AMD_X8664;
    }
    else {
        lpSystemInfo->dwProcessorType = 0;
        }

    lpSystemInfo->dwAllocationGranularity = BasicInfo->AllocationGranularity;

    //
    // for apps less than 3.51, then return 0 in dwReserved. This allows borlands
    // debugger to continue to run since it mistakenly used dwReserved
    // as AllocationGranularity
    //

    if ( GetProcessVersion(0) < 0x30033 ) {
        lpSystemInfo->wProcessorLevel = 0;
        lpSystemInfo->wProcessorRevision = 0;
        }

    return;
}

VOID
WINAPI
GetSystemInfo(
    LPSYSTEM_INFO lpSystemInfo
    )

/*++

Routine Description:

    The GetSystemInfo function is used to return information about the
    current system.  This includes the processor type, page size, oem
    id, and other interesting pieces of information.

Arguments:

    lpSystemInfo - Returns information about the current system.

        SYSTEM_INFO Structure:

        WORD wProcessorArchitecture - returns the architecture of the
            processors in the system: e.g. Intel, Mips, Alpha or PowerPC

        DWORD dwPageSize - Returns the page size.  This is specifies the
            granularity of page protection and commitment.

        LPVOID lpMinimumApplicationAddress - Returns the lowest memory
            address accessible to applications and DLLs.

        LPVOID lpMaximumApplicationAddress - Returns the highest memory
            address accessible to applications and DLLs.

        DWORD dwActiveProcessorMask - Returns a mask representing the
            set of processors configured into the system.  Bit 0 is
            processor 0, bit 31 is processor 31.

        DWORD dwNumberOfProcessors - Returns the number of processors in
            the system.

        WORD wProcessorLevel - Returns the level of the processors in the
            system.  All processors are assumed to be of the same level,
            stepping, and are configured with the same options.

        WORD wProcessorRevision - Returns the revision or stepping of the
            processors in the system.  All processors are assumed to be
            of the same level, stepping, and are configured with the
            same options.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_PROCESSOR_INFORMATION ProcessorInfo;


    Status = NtQuerySystemInformation(
                SystemBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return;
        }

    Status = NtQuerySystemInformation(
                SystemProcessorInformation,
                &ProcessorInfo,
                sizeof(ProcessorInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return;
        }

    GetSystemInfoInternal(
        &BasicInfo,
        &ProcessorInfo,
        lpSystemInfo);

    return;
}

VOID
WINAPI
GetNativeSystemInfo(
    LPSYSTEM_INFO lpSystemInfo
    )

/*++

Routine Description:

    The GetSystemInfo function is used to return information about the
    native current system.  The function returns the native system information
    ragarding the processor type, page size, oem id, and other interesting pieces of information
    when running inside a Wow64 process. If this function is called from a non-Wow64
    process, then the results would be the same as of GetSystemInfo.

Arguments:

    lpSystemInfo - Returns information about the current system.

        SYSTEM_INFO Structure:

        WORD wProcessorArchitecture - returns the architecture of the
            processors in the system: e.g. Intel, Mips, Alpha or PowerPC

        DWORD dwPageSize - Returns the page size.  This is specifies the
            granularity of page protection and commitment.

        LPVOID lpMinimumApplicationAddress - Returns the lowest memory
            address accessible to applications and DLLs.

        LPVOID lpMaximumApplicationAddress - Returns the highest memory
            address accessible to applications and DLLs.

        DWORD dwActiveProcessorMask - Returns a mask representing the
            set of processors configured into the system.  Bit 0 is
            processor 0, bit 31 is processor 31.

        DWORD dwNumberOfProcessors - Returns the number of processors in
            the system.

        WORD wProcessorLevel - Returns the level of the processors in the
            system.  All processors are assumed to be of the same level,
            stepping, and are configured with the same options.

        WORD wProcessorRevision - Returns the revision or stepping of the
            processors in the system.  All processors are assumed to be
            of the same level, stepping, and are configured with the
            same options.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_PROCESSOR_INFORMATION ProcessorInfo;


    Status = RtlGetNativeSystemInformation(
                SystemBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return;
        }

    Status = RtlGetNativeSystemInformation(
                SystemProcessorInformation,
                &ProcessorInfo,
                sizeof(ProcessorInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return;
        }

    GetSystemInfoInternal(
        &BasicInfo,
        &ProcessorInfo,
        lpSystemInfo);

    return;
}


#if defined(REMOTE_BOOT)
BOOL
WINAPI
GetSystemInfoExA(
    IN SYSTEMINFOCLASS dwSystemInfoClass,
    OUT LPVOID lpSystemInfoBuffer,
    IN OUT LPDWORD nSize
    )

/*++

    ANSI thunk to GetSystemInfoExW

--*/

{
    DWORD requiredSize;
    BOOL isRemoteBoot;
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;
    NTSTATUS Status;

    isRemoteBoot = (BOOL)((USER_SHARED_DATA->SystemFlags & SYSTEM_FLAG_REMOTE_BOOT_CLIENT) != 0);

    //
    // Determine the required buffer size.
    //

    switch ( dwSystemInfoClass ) {

    case SystemInfoRemoteBoot:
        requiredSize = sizeof(BOOL);
        break;

    case SystemInfoRemoteBootServerPath:
        if ( isRemoteBoot ) {
            RtlInitUnicodeString( &unicodeString, USER_SHARED_DATA->RemoteBootServerPath );
            requiredSize = RtlUnicodeStringToAnsiSize( &unicodeString );
        } else {

            //
            // This is not a remote boot client. Return success with a
            // zero-length buffer.
            //

            *nSize = 0;
            return TRUE;
        }
        break;

    default:

        //
        // Unrecognized information class.
        //

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // If the buffer isn't big enough, tell the caller how big the buffer
    // needs to be and return an error.
    //

    if ( *nSize < requiredSize ) {
        *nSize = requiredSize;
        SetLastError(ERROR_BUFFER_OVERFLOW);
        return FALSE;
    }

    *nSize = requiredSize;

    //
    // The buffer is big enough. Return the requested information.
    //

    switch ( dwSystemInfoClass ) {

    case SystemInfoRemoteBoot:
        *(LPBOOL)lpSystemInfoBuffer = isRemoteBoot;
        break;

    case SystemInfoRemoteBootServerPath:
        ansiString.Buffer = lpSystemInfoBuffer;
        ansiString.MaximumLength = (USHORT)*nSize;
        Status = RtlUnicodeStringToAnsiString( &ansiString, &unicodeString, FALSE );
        if (! Status) {
            BaseSetLastNTError(Status);
            return FALSE;
        }
        break;

    }

    return TRUE;
}

BOOL
WINAPI
GetSystemInfoExW(
    IN SYSTEMINFOCLASS dwSystemInfoClass,
    OUT LPVOID lpSystemInfoBuffer,
    IN OUT LPDWORD nSize
    )

/*++

Routine Description:

    The GetSystemInfoEx function is used to return information about the
    current system.  It returns different information depending on the
    requested class.

Arguments:

    dwSystemInfoClass - Specifies the class of information to return.

    lpSystemInfoBuffer - Supplies a pointer to a buffer in which the
        requested information is returned. The structure of this buffer
        varies based on dwSystemInfoClass.

    nSize - On input, supplies the length, in bytes, of the buffer. On output,
        return the length of the data written to the buffer, or, if the
        buffer was too small, the required buffer size.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

    If the return value is FALSE and GetLastError returns
    ERROR_BUFFER_OVERFLOW, then the supplied buffer was too small
    too contain all of the information, and nSize returns the
    required buffer size.

--*/
{
    DWORD requiredSize;
    BOOL isRemoteBoot;

    isRemoteBoot = (BOOL)((USER_SHARED_DATA->SystemFlags & SYSTEM_FLAG_REMOTE_BOOT_CLIENT) != 0);

    //
    // Determine the required buffer size.
    //

    switch ( dwSystemInfoClass ) {

    case SystemInfoRemoteBoot:
        requiredSize = sizeof(BOOL);
        break;

    case SystemInfoRemoteBootServerPath:
        if ( isRemoteBoot ) {
            requiredSize = (wcslen(USER_SHARED_DATA->RemoteBootServerPath) + 1) * sizeof(WCHAR);
        } else {

            //
            // This is not a remote boot client. Return success with a
            // zero-length buffer.
            //

            *nSize = 0;
            return TRUE;
        }
        break;

    default:

        //
        // Unrecognized information class.
        //

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // If the buffer isn't big enough, tell the caller how big the buffer
    // needs to be and return an error.
    //

    if ( *nSize < requiredSize ) {
        *nSize = requiredSize;
        SetLastError(ERROR_BUFFER_OVERFLOW);
        return FALSE;
    }

    *nSize = requiredSize;

    //
    // The buffer is big enough. Return the requested information.
    //

    switch ( dwSystemInfoClass ) {

    case SystemInfoRemoteBoot:
        *(LPBOOL)lpSystemInfoBuffer = isRemoteBoot;
        break;

    case SystemInfoRemoteBootServerPath:
        wcscpy( lpSystemInfoBuffer, USER_SHARED_DATA->RemoteBootServerPath );
        break;

    }

    return TRUE;
}
#endif // defined(REMOTE_BOOT)

BOOL
WINAPI
GetLogicalProcessorInformation(
    PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer,
    PDWORD ReturnedLength
    )
/*++

Routine Description:

    This function returns information about the logical processors in
    the system.  A group of structures will be written to the output
    buffer describing groups of logical processors, and the
    relationship between them.

    Currently it returns information about the logical processors that
    are produced by individual processor cores and the logical
    processors associated with individual NUMA nodes.  The former
    makes it possible for an application to understand the
    relationship between logical processors and physical processors in
    hyperthreading scenarios which supports some licensing and
    performance optimization scenarios.

    This function may be extended in the future to support multicore
    processors and platform caches.

Arguments:

    Buffer - Supplies a pointer to a buffer in which the
        SYSTEM_LOGICAL_PROCESSOR_INFORMATION structures will be stored.

    ReturnedLength - On input, supplies the length, in bytes, of the
        buffer. On output, return the length of the data written to
        the buffer, or, if the buffer was too small, the required
        buffer size.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

    If the return value is FALSE and GetLastError returns
    ERROR_INSUFFICIENT_BUFFER, then the supplied buffer was too small
    too contain all of the information, and ReturnedLength returns the
    required buffer size.

--*/
{
    NTSTATUS Status;

    if (ReturnedLength == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    Status = NtQuerySystemInformation( SystemLogicalProcessorInformation,
                                       Buffer,
                                       *ReturnedLength,
                                       ReturnedLength);
    if (Status == STATUS_INFO_LENGTH_MISMATCH) {
        Status = STATUS_BUFFER_TOO_SMALL;
    }

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    } else {
        return TRUE;
    }
}

BOOL
BuildSubSysCommandLine(
    LPWSTR  lpSubSysName,
    LPCWSTR lpApplicationName,
    LPCWSTR lpCommandLine,
    PUNICODE_STRING SubSysCommandLine
    )
{
    UNICODE_STRING Args;
    UNICODE_STRING Command;
    BOOLEAN        ReturnStatus = TRUE;

    //
    // build the command line as follows:
    // [OS2 | POSIX] /P <full path> /C <original CommandLine>
    //

    // Get application name length
    RtlInitUnicodeString(&Command, lpApplicationName);

    // get lpCommandLine length
    RtlInitUnicodeString(&Args, lpCommandLine);

    SubSysCommandLine->Length = 0;
    SubSysCommandLine->MaximumLength = Command.MaximumLength
                                       + Args.MaximumLength
                                       + (USHORT)32;

    SubSysCommandLine->Buffer = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( VDM_TAG ),
                                                 SubSysCommandLine->MaximumLength
                                               );
    if ( SubSysCommandLine->Buffer ) {

        // New command line begins with either L"OS2 /P " or L"POSIX /P "
        RtlAppendUnicodeToString(SubSysCommandLine, lpSubSysName);

        // append full path name
        RtlAppendUnicodeStringToString(SubSysCommandLine, &Command);

        RtlAppendUnicodeToString(SubSysCommandLine, L" /C ");

        // and append to new command line
        RtlAppendUnicodeStringToString(SubSysCommandLine, &Args);

    } else {

        BaseSetLastNTError(STATUS_NO_MEMORY);
        ReturnStatus = FALSE;
    }

    return ReturnStatus;
}




BOOL
WINAPI
SetPriorityClass(
    HANDLE hProcess,
    DWORD dwPriorityClass
    )

/*++

Routine Description:

    This API is used to set the priority class of the specified process.
    PROCESS_SET_INFORMATION and PROCESS_QUERY_INFORMATION access is
    required to the process in order to call this API.  Using this API
    has a dramatic impact on the scheduling characteristics of the
    effected process.  Applications should use this API carefully and
    understand the impact of making a process run in either the Idle or
    High priority classes.

Arguments:

    hProcess - Supplies an open handle to the process whose priority is
        to change.

    dwPriorityClass - Supplies the new priority class for the process.
        The priority class constants are described above.  If more than
        one priority class is specified, the lowest specified priority
        class is used.

Return Value:

    TRUE - The operation was was successful.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    UCHAR PriorityClass;
    BOOL ReturnValue;
    // NOTE: The following construct is used to ensure the PriClass struct
    // is allocated on a dword boundary.  w/o it, the compiler may choose
    // to put it on a word boundary and the NtxxxInformationProces call will
    // fail with a datatype misalignment fault.
    union {
        PROCESS_PRIORITY_CLASS PriClass;
        ULONG x;
    }x;
    PVOID State = NULL;
    ReturnValue = TRUE;
    if (dwPriorityClass & IDLE_PRIORITY_CLASS ) {
        PriorityClass = PROCESS_PRIORITY_CLASS_IDLE;
        }
    else if (dwPriorityClass & BELOW_NORMAL_PRIORITY_CLASS ) {
        PriorityClass = PROCESS_PRIORITY_CLASS_BELOW_NORMAL;
        }
    else if (dwPriorityClass & NORMAL_PRIORITY_CLASS ) {
        PriorityClass = PROCESS_PRIORITY_CLASS_NORMAL;
        }
    else if (dwPriorityClass & ABOVE_NORMAL_PRIORITY_CLASS ) {
        PriorityClass = PROCESS_PRIORITY_CLASS_ABOVE_NORMAL;
        }
    else if (dwPriorityClass & HIGH_PRIORITY_CLASS ) {
        PriorityClass =  PROCESS_PRIORITY_CLASS_HIGH;
        }
    else if (dwPriorityClass & REALTIME_PRIORITY_CLASS ) {
        if ( State = BasepIsRealtimeAllowed(TRUE) ) {
            PriorityClass =  PROCESS_PRIORITY_CLASS_REALTIME;
            }
        else {
            PriorityClass =  PROCESS_PRIORITY_CLASS_HIGH;
            }
        }
    else {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }
    x.PriClass.PriorityClass = PriorityClass;
    x.PriClass.Foreground = FALSE;

    Status = NtSetInformationProcess(
                hProcess,
                ProcessPriorityClass,
                (PVOID)&x.PriClass,
                sizeof(x.PriClass)
                );

    if ( State ) {
        BasepReleasePrivilege( State );
        }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        ReturnValue = FALSE;
        }
    return ReturnValue;
}

DWORD
WINAPI
GetPriorityClass(
    HANDLE hProcess
    )

/*++

Routine Description:

    This API is used to get the priority class of the specified process.
    PROCESS_QUERY_INFORMATION access is required to the process in order
    to call this API.

Arguments:

    hProcess - Supplies an open handle to the process whose priority is
        to be returned.

Return Value:

    Non-Zero - Returns the priority class of the specified process.

    0 - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    ULONG PriorityClass;
    // NOTE: The following construct is used to ensure the PriClass struct
    // is allocated on a dword boundary.  w/o it, the compiler may choose
    // to put it on a word boundary and the NtxxxInformationProces call will
    // fail with a datatype misalignment fault.
    union _x {
        PROCESS_PRIORITY_CLASS PriClass;
        ULONG x;
    }x;

    PriorityClass = 0;


    Status = NtQueryInformationProcess(
                hProcess,
                ProcessPriorityClass,
                &x.PriClass,
                sizeof(x.PriClass),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return 0;
        }

    switch ( x.PriClass.PriorityClass ) {
        case PROCESS_PRIORITY_CLASS_IDLE:
            PriorityClass = IDLE_PRIORITY_CLASS;
            break;

        case PROCESS_PRIORITY_CLASS_HIGH:
            PriorityClass = HIGH_PRIORITY_CLASS;
            break;

        case PROCESS_PRIORITY_CLASS_REALTIME:
            PriorityClass = REALTIME_PRIORITY_CLASS;
            break;

        case PROCESS_PRIORITY_CLASS_BELOW_NORMAL:
            PriorityClass = BELOW_NORMAL_PRIORITY_CLASS;
            break;

        case PROCESS_PRIORITY_CLASS_ABOVE_NORMAL:
            PriorityClass = ABOVE_NORMAL_PRIORITY_CLASS;
            break;

        case PROCESS_PRIORITY_CLASS_NORMAL:
        default:
            PriorityClass = NORMAL_PRIORITY_CLASS;
            break;
        }

    return PriorityClass;
}

BOOL
WINAPI
IsBadReadPtr(
    CONST VOID *lp,
    UINT_PTR cb
    )

/*++

Routine Description:

    This function verifies that the range of memory specified by the
    input parameters can be read by the calling process.

    If the entire range of memory is accessible, then a value of FALSE
    is returned; otherwise, a value of TRUE is returned.

    Note that since Win32 is a pre-emptive multi-tasking environment,
    the results of this test are only meaningful if the other threads in
    the process do not manipulate the range of memory being tested by
    this call.  Even after a pointer validation, an application should
    use the structured exception handling capabilities present in the
    system to gaurd access through pointers that it does not control.

Arguments:

    lp - Supplies the base address of the memory that is to be checked
        for read access.

    cb - Supplies the length in bytes to be checked.

Return Value:

    TRUE - Some portion of the specified range of memory is not accessible
        for read access.

    FALSE - All pages within the specified range have been successfully
        read.

--*/

{

    PSZ EndAddress;
    PSZ StartAddress;
    ULONG PageSize;

    PageSize = BASE_SYSINFO.PageSize;

    //
    // If the structure has zero length, then do not probe the structure for
    // read accessibility or alignment.
    //

    if (cb != 0) {

        //
        // If it is a NULL pointer just return TRUE, they are always bad
        //
        if (lp == NULL) {
            return TRUE;
            }

        StartAddress = (PSZ)lp;

        //
        // Compute the ending address of the structure and probe for
        // read accessibility.
        //

        EndAddress = StartAddress + cb - 1;
        if ( EndAddress < StartAddress ) {
           return TRUE;
            }
        else {
            try {
                *(volatile CHAR *)StartAddress;
                StartAddress = (PCHAR)((ULONG_PTR)StartAddress & (~((LONG)PageSize - 1)));
                EndAddress = (PCHAR)((ULONG_PTR)EndAddress & (~((LONG)PageSize - 1)));
                while (StartAddress != EndAddress) {
                    StartAddress = StartAddress + PageSize;
                    *(volatile CHAR *)StartAddress;
                    }
                }
            except(EXCEPTION_EXECUTE_HANDLER) {
                return TRUE;
                }
            }
        }
    return FALSE;
}

BOOL
WINAPI
IsBadHugeReadPtr(
    CONST VOID *lp,
    UINT_PTR cb
    )

/*++

    Same as IsBadReadPtr

--*/

{
    return IsBadReadPtr(lp,cb);
}



BOOL
WINAPI
IsBadWritePtr(
    LPVOID lp,
    UINT_PTR cb
    )
/*++

Routine Description:

    This function verifies that the range of memory specified by the
    input parameters can be written by the calling process.

    If the entire range of memory is accessible, then a value of FALSE
    is returned; otherwise, a value of TRUE is returned.

    Note that since Win32 is a pre-emptive multi-tasking environment,
    the results of this test are only meaningful if the other threads in
    the process do not manipulate the range of memory being tested by
    this call.  Even after a pointer validation, an application should
    use the structured exception handling capabilities present in the
    system to gaurd access through pointers that it does not control.

    Also not that implementations are free to do a write test by reading
    a value and then writing it back.

Arguments:

    lp - Supplies the base address of the memory that is to be checked
        for write access.

    cb - Supplies the length in bytes to be checked.

Return Value:

    TRUE - Some portion of the specified range of memory is not accessible
        for write access.

    FALSE - All pages within the specified range have been successfully
        written.

--*/
{
    PSZ EndAddress;
    PSZ StartAddress;
    ULONG PageSize;

    PageSize = BASE_SYSINFO.PageSize;

    //
    // If the structure has zero length, then do not probe the structure for
    // write accessibility.
    //

    if (cb != 0) {

        //
        // If it is a NULL pointer just return TRUE, they are always bad
        //
        if (lp == NULL) {
            return TRUE;
            }

        StartAddress = (PCHAR)lp;

        //
        // Compute the ending address of the structure and probe for
        // write accessibility.
        //

        EndAddress = StartAddress + cb - 1;
        if ( EndAddress < StartAddress ) {
            return TRUE;
            }
        else {
            try {
                *(volatile CHAR *)StartAddress = *(volatile CHAR *)StartAddress;
                StartAddress = (PCHAR)((ULONG_PTR)StartAddress & (~((LONG)PageSize - 1)));
                EndAddress = (PCHAR)((ULONG_PTR)EndAddress & (~((LONG)PageSize - 1)));
                while (StartAddress != EndAddress) {
                    StartAddress = StartAddress + PageSize;
                    *(volatile CHAR *)StartAddress = *(volatile CHAR *)StartAddress;
                    }
                }
            except(EXCEPTION_EXECUTE_HANDLER) {
                return TRUE;
                }
            }
        }
    return FALSE;
}

BOOL
WINAPI
IsBadHugeWritePtr(
    LPVOID lp,
    UINT_PTR cb
    )

/*++

    Same as IsBadWritePtr

--*/

{
    return IsBadWritePtr(lp,cb);
}

BOOL
WINAPI
IsBadCodePtr(
    FARPROC lpfn
    )

/*++

    Same as IsBadReadPtr with a length of 1

--*/

{
    return IsBadReadPtr((LPVOID)lpfn,1);
}

BOOL
WINAPI
IsBadStringPtrA(
    LPCSTR lpsz,
    UINT_PTR cchMax
    )

/*++

Routine Description:

    This function verifies that the range of memory specified by the
    input parameters can be read by the calling process.

    The range is the smaller of the number of bytes covered by the
    specified NULL terminated ANSI string, or the number of bytes specified
    by cchMax.

    If the entire range of memory is accessible, then a value of FALSE
    is returned; otherwise, a value of TRUE is returned.

    Note that since Win32 is a pre-emptive multi-tasking environment,
    the results of this test are only meaningful if the other threads in
    the process do not manipulate the range of memory being tested by
    this call.  Even after a pointer validation, an application should
    use the structured exception handling capabilities present in the
    system to gaurd access through pointers that it does not control.

Arguments:

    lpsz - Supplies the base address of the memory that is to be checked
        for read access.

    cchMax - Supplies the length in bytes to be checked.

Return Value:

    TRUE - Some portion of the specified range of memory is not accessible
        for read access.

    FALSE - All pages within the specified range have been successfully
        read.

--*/

{

    PSZ EndAddress;
    PSZ StartAddress;
    CHAR c;

    //
    // If the structure has zero length, then do not probe the structure for
    // read accessibility.
    //

    if (cchMax != 0) {

        //
        // If it is a NULL pointer just return TRUE, they are always bad
        //
        if (lpsz == NULL) {
            return TRUE;
            }

        StartAddress = (PSZ)lpsz;

        //
        // Compute the ending address of the structure and probe for
        // read accessibility.
        //

        EndAddress = StartAddress + cchMax - 1;
        try {
            c = *(volatile CHAR *)StartAddress;
            while ( c && StartAddress != EndAddress ) {
                StartAddress++;
                c = *(volatile CHAR *)StartAddress;
                }
            }
        except(EXCEPTION_EXECUTE_HANDLER) {
            return TRUE;
            }
        }
    return FALSE;
}

BOOL
WINAPI
IsBadStringPtrW(
    LPCWSTR lpsz,
    UINT_PTR cchMax
    )

/*++

Routine Description:

    This function verifies that the range of memory specified by the
    input parameters can be read by the calling process.

    The range is the smaller of the number of bytes covered by the
    specified NULL terminated UNICODE string, or the number of bytes
    specified by cchMax.

    If the entire range of memory is accessible, then a value of FALSE
    is returned; otherwise, a value of TRUE is returned.

    Note that since Win32 is a pre-emptive multi-tasking environment,
    the results of this test are only meaningful if the other threads in
    the process do not manipulate the range of memory being tested by
    this call.  Even after a pointer validation, an application should
    use the structured exception handling capabilities present in the
    system to gaurd access through pointers that it does not control.

Arguments:

    lpsz - Supplies the base address of the memory that is to be checked
        for read access.

    cchMax - Supplies the length in characters to be checked.

Return Value:

    TRUE - Some portion of the specified range of memory is not accessible
        for read access.

    FALSE - All pages within the specified range have been successfully
        read.

--*/

{

    LPCWSTR EndAddress;
    LPCWSTR StartAddress;
    WCHAR c;

    //
    // If the structure has zero length, then do not probe the structure for
    // read accessibility.
    //

    if (cchMax != 0) {

        //
        // If it is a NULL pointer just return TRUE, they are always bad
        //
        if (lpsz == NULL) {
            return TRUE;
            }

        StartAddress = lpsz;

        //
        // Compute the ending address of the structure and probe for
        // read accessibility.
        //

        EndAddress = (LPCWSTR)((PSZ)StartAddress + (cchMax*2) - 2);
        try {
            c = *(volatile WCHAR *)StartAddress;
            while ( c && StartAddress != EndAddress ) {
                StartAddress++;
                c = *(volatile WCHAR *)StartAddress;
                }
            }
        except(EXCEPTION_EXECUTE_HANDLER) {
            return TRUE;
            }
        }
    return FALSE;
}

BOOL
WINAPI
SetProcessShutdownParameters(
    DWORD dwLevel,
    DWORD dwFlags
    )

/*++

Routine Description:

    This function sets shutdown parameters for the currently calling
    process. dwLevel is the field that defines this processes shutdown
    order relative to the other processes in the system. Higher levels
    shutdown first, lower levels shutdown last.

Arguments:

    dwLevel - Specifies shutdown order relative to other processes in the
        system. Higher levels shutdown first. System level shutdown orders
        are pre-defined.

    dwFlags - A flags parameter. The flags can be added together:

        SHUTDOWN_NORETRY - If this process takes longer than the user
            specified timeout to shutdown, do not put up a retry dialog
            for the user.

Notes:

    Applications running in the system security context do not get shut down
    by the system. They will get notified of shutdown or logoff through the
    callback installable via SetConsoleCtrlRoutine() (see that for more info).
    They also will get notified in the order specified by the dwLevel
    parameter.

Return Value

    TRUE - Successful in setting the process shutdown parameters.

    FALSE - Unsuccessful in setting the process shutdown parameters.

--*/

{

#if defined(BUILD_WOW6432)

    NTSTATUS Status;

    Status = CsrBasepSetProcessShutdownParam(dwLevel, dwFlags);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return TRUE;

#else

    BASE_API_MSG m;
    PBASE_SHUTDOWNPARAM_MSG a = &m.u.ShutdownParam;

    a->ShutdownLevel = dwLevel;
    a->ShutdownFlags = dwFlags;

    CsrClientCallServer((PCSR_API_MSG)&m, NULL,
            CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
            BasepSetProcessShutdownParam),
            sizeof(*a));

    if (!NT_SUCCESS((NTSTATUS)m.ReturnValue)) {
        BaseSetLastNTError((NTSTATUS)m.ReturnValue);
        return FALSE;
        }

    return TRUE;

#endif

}

BOOL
WINAPI
GetProcessShutdownParameters(
    LPDWORD lpdwLevel,
    LPDWORD lpdwFlags
    )

/*++

Routine Description:

    This function gets shutdown parameters for the currently calling
    process. See SetProcessShutdownParameters() for the parameter
    description.

Arguments:

    lpdwLevel - Pointer to the DWORD where the shutdown level information
        should be put.

    lpdwFlags - Pointer to the DWORD where the shutdown flags information
        should be put.
Return Value

    TRUE - Successful in getting the process shutdown parameters.

    FALSE - Unsuccessful in getting the process shutdown parameters.

--*/

{

#if defined(BUILD_WOW6432)

    NTSTATUS Status;

    Status = CsrBasepGetProcessShutdownParam(lpdwLevel, lpdwFlags);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return TRUE;

#else

    BASE_API_MSG m;
    PBASE_SHUTDOWNPARAM_MSG a = &m.u.ShutdownParam;

    CsrClientCallServer((PCSR_API_MSG)&m, NULL,
            CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
            BasepGetProcessShutdownParam),
            sizeof(*a));

    if (!NT_SUCCESS((NTSTATUS)m.ReturnValue)) {
        BaseSetLastNTError((NTSTATUS)m.ReturnValue);
        return FALSE;
        }

    *lpdwLevel = a->ShutdownLevel;
    *lpdwFlags = a->ShutdownFlags;

    return TRUE;

#endif

}


PVOID
BasepIsRealtimeAllowed(
    BOOLEAN LeaveEnabled
    )
{
    PVOID State;
    NTSTATUS Status;

    Status = BasepAcquirePrivilegeEx( SE_INC_BASE_PRIORITY_PRIVILEGE, &State );
    if (!NT_SUCCESS( Status )) {
        return NULL;
        }
    if ( !LeaveEnabled ) {
        BasepReleasePrivilege( State );
        State = (PVOID)1;
        }
    return State;
}

BOOL
WINAPI
GetSystemTimes(
    PFILETIME lpIdleTime,
    PFILETIME lpKernelTime,
    PFILETIME lpUserTime
    )

/*++

Routine Description:

    This function is used to return various timing information about
    the system.  On a multiprocessor system, these values are the sum
    of the appropriate times across all processors.

Arguments:

    lpIdleTime - Returns the amount of time that the system has been
        idle.

    lpKernelTime - Returns the amount of time that the system (all
        threads in all processes) has executed in kernel-mode.

    lpUserTime - Returns the amount of time that the system (all
        threads in all processes) has executed in user-mode.

Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    LONG           Lupe;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
                   ProcessorTimes;
    ULONG          ProcessorTimesCb;
    NTSTATUS       Status;
    ULARGE_INTEGER Sum;
    ULONG          ReturnLength;

#if (!defined(BUILD_WOW6432) && !defined(_WIN64))
#define BASEP_GST_NPROCS BaseStaticServerData->SysInfo.NumberOfProcessors
#else
#define BASEP_GST_NPROCS SysInfo.NumberOfProcessors
#endif

    ProcessorTimesCb = BASEP_GST_NPROCS * sizeof(*ProcessorTimes);

    ProcessorTimes = ((PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION)
                      RtlAllocateHeap(RtlProcessHeap(),
                                      MAKE_TAG(TMP_TAG),
                                      ProcessorTimesCb));
    if (! ProcessorTimes) {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

    Status = NtQuerySystemInformation(SystemProcessorPerformanceInformation,
                                      ProcessorTimes,
                                      ProcessorTimesCb,
                                      &ReturnLength);
    if (! NT_SUCCESS(Status)) {
        goto cleanup;
    }

    if (ReturnLength != ProcessorTimesCb) {
        Status = STATUS_INTERNAL_ERROR;
        goto cleanup;
    }

#define BASEP_GST_SUM(DST, SRC)                                         \
    if ( DST ) {                                                        \
        Sum.QuadPart = 0;                                               \
        for (Lupe = 0;                                                  \
             Lupe < BASEP_GST_NPROCS;                                   \
             Lupe++) {                                                  \
            Sum.QuadPart += ProcessorTimes[Lupe]. SRC .QuadPart ;       \
        }                                                               \
        DST ->dwLowDateTime = Sum.LowPart;                              \
        DST ->dwHighDateTime = Sum.HighPart;                            \
    }

    BASEP_GST_SUM(lpIdleTime, IdleTime);
    BASEP_GST_SUM(lpKernelTime, KernelTime);
    BASEP_GST_SUM(lpUserTime, UserTime);

#undef BASEP_GST_SUM
#undef BASEP_GST_NPROCS

    Status = STATUS_SUCCESS;

 cleanup:
    if (ProcessorTimes) {
        RtlFreeHeap(RtlProcessHeap(),
                    MAKE_TAG(TMP_TAG),
                    ProcessorTimes);
    }

    if (! NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
GetProcessTimes(
    HANDLE hProcess,
    LPFILETIME lpCreationTime,
    LPFILETIME lpExitTime,
    LPFILETIME lpKernelTime,
    LPFILETIME lpUserTime
    )

/*++

Routine Description:

    This function is used to return various timing information about the
    process specified by hProcess.

    All times are in units of 100ns increments. For lpCreationTime and lpExitTime,
    the times are in terms of the SYSTEM time or GMT time.

Arguments:

    hProcess - Supplies an open handle to the specified process.  The
        handle must have been created with PROCESS_QUERY_INFORMATION
        access.

    lpCreationTime - Returns a creation time of the process.

    lpExitTime - Returns the exit time of a process.  If the process has
        not exited, this value is not defined.

    lpKernelTime - Returns the amount of time that this process (all
        it's threads), have executed in kernel-mode.

    lpUserTime - Returns the amount of time that this process (all it's
        threads), have executed in user-mode.


Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;
    KERNEL_USER_TIMES TimeInfo;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessTimes,
                (PVOID)&TimeInfo,
                sizeof(TimeInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    *lpCreationTime = *(LPFILETIME)&TimeInfo.CreateTime;
    *lpExitTime = *(LPFILETIME)&TimeInfo.ExitTime;
    *lpKernelTime = *(LPFILETIME)&TimeInfo.KernelTime;
    *lpUserTime = *(LPFILETIME)&TimeInfo.UserTime;

    return TRUE;

}

BOOL
WINAPI
GetProcessAffinityMask(
    HANDLE hProcess,
    PDWORD_PTR lpProcessAffinityMask,
    PDWORD_PTR lpSystemAffinityMask
    )

/*++

Routine Description:

    This function is used to return the processor affinity mask for the
    selected process and for the system.  The process affinity mask is a
    bit vector where each bit represents the processors that the process
    is allowed to run on.  The system affinity mask is a bit vector
    where each bit represents the processors configured into the system

    The process affinity mask is a proper subset of the system affinity mask.

Arguments:

    hProcess - Supplies an open handle to the specified process.  The
        handle must have been created with PROCESS_QUERY_INFORMATION
        access.

    lpProcessAffinityMask - Supplies the address of a DWORD that returns the
        specified process' affinity mask.

    lpSystemAffinityMask - Supplies the address of a DWORD that returns the
        system affinity mask.

Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    PROCESS_BASIC_INFORMATION BasicInformation;
    NTSTATUS Status;
    BOOL rv;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessBasicInformation,
                &BasicInformation,
                sizeof(BasicInformation),
                NULL
                );
    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        rv = FALSE;
    } else {
        *lpProcessAffinityMask = BasicInformation.AffinityMask;
        *lpSystemAffinityMask = BASE_SYSINFO.ActiveProcessorsAffinityMask;
        rv = TRUE;
    }

    return rv;
}



BOOL
WINAPI
GetProcessWorkingSetSizeEx(
    HANDLE hProcess,
    PSIZE_T lpMinimumWorkingSetSize,
    PSIZE_T lpMaximumWorkingSetSize,
    LPDWORD Flags
    )

/*++

Routine Description:

    This function allows the caller to determine the minimum and maximum working
    set sizes of the specified process. The working set sizes effect the virtual
    memory paging behavior for the process.

Arguments:

    hProcess - Supplies an open handle to the specified process.  The
        handle must have been created with PROCESS_QUERY_INFORMATION
        access.

    lpMinimumWorkingSetSize - Supplies the address of the variable that
        will receive the minimum working set size of the specified
        process.  The virtual memory manager will attempt to keep at
        least this much memory resident in the process whenever the
        process is active.


    lpMaximumWorkingSetSize - Supplies the address of the variable that
        will receive the maximum working set size of the specified
        process.  In tight memory situations, the virtual memory manager
        will attempt to keep at no more than this much memory resident
        in the process whenever the process is active.

    Flags - Output flags, QUOTA_LIMITS_HARDWS_ENABLE enables hard WS
                          QUOTA_LIMITS_HARDWS_DISABLE disabled hard WS

Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    QUOTA_LIMITS_EX QuotaLimits;
    NTSTATUS Status;
    BOOL rv;

    Status = NtQueryInformationProcess (hProcess,
                                        ProcessQuotaLimits,
                                        &QuotaLimits,
                                        sizeof (QuotaLimits),
                                        NULL);

    if (NT_SUCCESS (Status)) {
        *lpMinimumWorkingSetSize = QuotaLimits.MinimumWorkingSetSize;
        *lpMaximumWorkingSetSize = QuotaLimits.MaximumWorkingSetSize;
        *Flags = QuotaLimits.Flags;
        rv = TRUE;
    } else {
        rv = FALSE;
        BaseSetLastNTError (Status);
    }
    return rv;
}

BOOL
WINAPI
GetProcessWorkingSetSize(
    HANDLE hProcess,
    PSIZE_T lpMinimumWorkingSetSize,
    PSIZE_T lpMaximumWorkingSetSize
    )
/*++

Routine Description:

    This function allows the caller to determine the minimum and maximum working
    set sizes of the specified process. The working set sizes effect the virtual
    memory paging behavior for the process.

Arguments:

    hProcess - Supplies an open handle to the specified process.  The
        handle must have been created with PROCESS_QUERY_INFORMATION
        access.

    lpMinimumWorkingSetSize - Supplies the address of the variable that
        will receive the minimum working set size of the specified
        process.  The virtual memory manager will attempt to keep at
        least this much memory resident in the process whenever the
        process is active.


    lpMaximumWorkingSetSize - Supplies the address of the variable that
        will receive the maximum working set size of the specified
        process.  In tight memory situations, the virtual memory manager
        will attempt to keep at no more than this much memory resident
        in the process whenever the process is active.

Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    DWORD Flags;

    return GetProcessWorkingSetSizeEx (hProcess,
                                       lpMinimumWorkingSetSize,
                                       lpMaximumWorkingSetSize,
                                       &Flags);
}

BOOL
WINAPI
SetProcessWorkingSetSizeEx(
    HANDLE hProcess,
    SIZE_T dwMinimumWorkingSetSize,
    SIZE_T dwMaximumWorkingSetSize,
    ULONG  Flags
    )

/*++

Routine Description:

    This function allows the caller to set the minimum and maximum
    working set sizes of the specified process.  The working set sizes
    effect the virtual memory paging behavior for the process.  The
    specified process's working set be emptied (essentially swapping out
    the process) by specifying the distinguished values 0xffffffff for
    both the minimum and maximum working set sizes.

    If you are not trimming an address space, SE_INC_BASE_PRIORITY_PRIVILEGE
    must be held by the process

Arguments:

    hProcess - Supplies an open handle to the specified process.  The
        handle must have been created with PROCESS_SET_QUOTA
        access.

    dwMinimumWorkingSetSize - Supplies the minimum working set size for
        the specified process.  The virtual memory manager will attempt
        to keep at least this much memory resident in the process
        whenever the process is active.  A value of (SIZE_T)-1 and the
        same value in dwMaximumWorkingSetSize will temporarily trim the
        working set of the specified process (essentially out swap the
        process).


    dwMaximumWorkingSetSize - Supplies the maximum working set size for
        the specified process.  In tight memory situations, the virtual
        memory manager will attempt to keep at no more than this much
        memory resident in the process whenever the process is active.
        A value of (SIZE_T)-1 and the same value in
        dwMinimumWorkingSetSize will temporarily trim the working set of
        the specified process (essentially out swap the process).

    Flags - Supplied flags, QUOTA_LIMITS_HARDWS_ENABLE enables hard WS
                            QUOTA_LIMITS_HARDWS_DISABLE disabled hard ws

Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    QUOTA_LIMITS_EX QuotaLimits={0};
    NTSTATUS Status, PrivStatus;
    BOOL rv;
    PVOID State;

#ifdef _WIN64
    ASSERT(dwMinimumWorkingSetSize != 0xffffffff && dwMaximumWorkingSetSize != 0xffffffff);
#endif

    if (dwMinimumWorkingSetSize == 0 || dwMaximumWorkingSetSize == 0) {
        Status = STATUS_INVALID_PARAMETER;
        rv = FALSE;
    } else {

        QuotaLimits.MaximumWorkingSetSize = dwMaximumWorkingSetSize;
        QuotaLimits.MinimumWorkingSetSize = dwMinimumWorkingSetSize;
        QuotaLimits.Flags = Flags;

        //
        // Attempt to acquire the appropriate privilege.  If this
        // fails, it's no big deal -- we'll attempt to make the
        // NtSetInformationProcess call anyway, in case it turns out
        // to be a decrease operation (which will succeed anyway).
        //
        PrivStatus = BasepAcquirePrivilegeEx (SE_INC_BASE_PRIORITY_PRIVILEGE, &State);

        Status = NtSetInformationProcess (hProcess,
                                          ProcessQuotaLimits,
                                          &QuotaLimits,
                                          sizeof(QuotaLimits));
        if (!NT_SUCCESS (Status)) {
            rv = FALSE;
        } else {
            rv = TRUE;
        }

        if (NT_SUCCESS (PrivStatus)) {
            //
            // We successfully acquired the privilege above; we need to relinquish it.
            //
            ASSERT (State != NULL);
            BasepReleasePrivilege (State);
            State = NULL;
        }

    }

    if (!rv) {
        BaseSetLastNTError (Status);
    }
    return rv;
}


BOOL
WINAPI
SetProcessWorkingSetSize(
    HANDLE hProcess,
    SIZE_T dwMinimumWorkingSetSize,
    SIZE_T dwMaximumWorkingSetSize
    )
/*++

Routine Description:

    This function allows the caller to set the minimum and maximum
    working set sizes of the specified process.  The working set sizes
    effect the virtual memory paging behavior for the process.  The
    specified process's working set be emptied (essentially swapping out
    the process) by specifying the distinguished values 0xffffffff for
    both the minimum and maximum working set sizes.

    If you are not trimming an address space, SE_INC_BASE_PRIORITY_PRIVILEGE
    must be held by the process

Arguments:

    hProcess - Supplies an open handle to the specified process.  The
        handle must have been created with PROCESS_SET_QUOTA
        access.

    dwMinimumWorkingSetSize - Supplies the minimum working set size for
        the specified process.  The virtual memory manager will attempt
        to keep at least this much memory resident in the process
        whenever the process is active.  A value of (SIZE_T)-1 and the
        same value in dwMaximumWorkingSetSize will temporarily trim the
        working set of the specified process (essentially out swap the
        process).


    dwMaximumWorkingSetSize - Supplies the maximum working set size for
        the specified process.  In tight memory situations, the virtual
        memory manager will attempt to keep at no more than this much
        memory resident in the process whenever the process is active.
        A value of (SIZE_T)-1 and the same value in
        dwMinimumWorkingSetSize will temporarily trim the working set of
        the specified process (essentially out swap the process).

Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/
{
    return SetProcessWorkingSetSizeEx (hProcess,
                                       dwMinimumWorkingSetSize,
                                       dwMaximumWorkingSetSize,
                                       0);
}


DWORD
WINAPI
GetProcessVersion(
    DWORD ProcessId
    )
{
    PIMAGE_NT_HEADERS NtHeader;
    PPEB Peb;
    HANDLE hProcess;
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION ProcessInfo;
    BOOL b;
    struct {
        USHORT  MajorSubsystemVersion;
        USHORT  MinorSubsystemVersion;
    } SwappedVersion;
    union {
        struct {
            USHORT  MinorSubsystemVersion;
            USHORT  MajorSubsystemVersion;
        };
        DWORD SubsystemVersion;
    } Version;

    PVOID ImageBaseAddress;
    LONG   e_lfanew;

    hProcess = NULL;
    Version.SubsystemVersion = 0;
    try {
        if ( ProcessId == 0 || ProcessId == GetCurrentProcessId() ) {
            Peb = NtCurrentPeb();
            NtHeader = RtlImageNtHeader(Peb->ImageBaseAddress);
            if (! NtHeader) {
                BaseSetLastNTError(STATUS_INVALID_IMAGE_FORMAT);
                goto finally_exit;
            }
            Version.MajorSubsystemVersion = NtHeader->OptionalHeader.MajorSubsystemVersion;
            Version.MinorSubsystemVersion = NtHeader->OptionalHeader.MinorSubsystemVersion;
            }
        else {
            hProcess = OpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ,FALSE,ProcessId);
            if ( !hProcess ) {
                goto finally_exit;
                }

            //
            // Get the Peb address
            //

            Status = NtQueryInformationProcess(
                        hProcess,
                        ProcessBasicInformation,
                        &ProcessInfo,
                        sizeof( ProcessInfo ),
                        NULL
                        );
            if ( !NT_SUCCESS( Status ) ) {
                BaseSetLastNTError(Status);
                goto finally_exit;
                }
            Peb = ProcessInfo.PebBaseAddress;


            //
            // Read the image base address from the Peb
            //

            b = ReadProcessMemory(
                    hProcess,
                    &Peb->ImageBaseAddress,
                    &ImageBaseAddress,
                    sizeof(ImageBaseAddress),
                    NULL
                    );
            if ( !b ) {
                goto finally_exit;
                }

            //
            // read e_lfanew from imageheader
            //

            b = ReadProcessMemory(
                    hProcess,
                    &((PIMAGE_DOS_HEADER)ImageBaseAddress)->e_lfanew,
                    &e_lfanew,
                    sizeof(e_lfanew),
                    NULL
                    );

            if ( !b ) {
                goto finally_exit;
                }

            NtHeader = (PIMAGE_NT_HEADERS)((PUCHAR)ImageBaseAddress + e_lfanew);

            //
            // Read subsystem version info
            //

            b = ReadProcessMemory(
                    hProcess,
                    &NtHeader->OptionalHeader.MajorSubsystemVersion,
                    &SwappedVersion,
                    sizeof(SwappedVersion),
                    NULL
                    );
            if ( !b ) {
                goto finally_exit;
                }
            Version.MajorSubsystemVersion = SwappedVersion.MajorSubsystemVersion;
            Version.MinorSubsystemVersion = SwappedVersion.MinorSubsystemVersion;
            }
finally_exit:;
        }
    finally {
        if ( hProcess ) {
            CloseHandle(hProcess);
            }
        }

        return Version.SubsystemVersion;
}


BOOL
WINAPI
SetProcessAffinityMask(
    HANDLE hProcess,
    DWORD_PTR dwProcessAffinityMask
    )
{
    NTSTATUS Status;

    Status = NtSetInformationProcess(
                hProcess,
                ProcessAffinityMask,
                &dwProcessAffinityMask,
                sizeof(dwProcessAffinityMask)
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return TRUE;

}

BOOL
WINAPI
SetProcessPriorityBoost(
    HANDLE hProcess,
    BOOL bDisablePriorityBoost
    )
{
    NTSTATUS Status;
    ULONG DisableBoost;

    DisableBoost = bDisablePriorityBoost ? 1 : 0;

    Status = NtSetInformationProcess(
                hProcess,
                ProcessPriorityBoost,
                &DisableBoost,
                sizeof(DisableBoost)
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return TRUE;
}

BOOL
WINAPI
GetProcessPriorityBoost(
    HANDLE hProcess,
    PBOOL pDisablePriorityBoost
    )
{
    NTSTATUS Status;
    DWORD DisableBoost;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessPriorityBoost,
                &DisableBoost,
                sizeof(DisableBoost),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }


    *pDisablePriorityBoost = DisableBoost;

    return TRUE;
}

BOOL
WINAPI
GetProcessIoCounters(
    IN HANDLE hProcess,
    OUT PIO_COUNTERS lpIoCounters
    )
{
    NTSTATUS Status;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessIoCounters,
                lpIoCounters,
                sizeof(IO_COUNTERS),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return TRUE;
}

BOOL
WINAPI
GetProcessHandleCount(
    IN HANDLE hProcess,
    OUT PDWORD pdwHandleCount
    )

/*++

Routine Description:

    This function returns the count of handles open by the specified process.

Arguments:

    hProcess - Supplies an open handle to the specified process.  The
        handle must have been created with PROCESS_QUERY_INFORMATION
        access.

    pdwHandleCount - Supplies the location in which the process's
        handle count should be written.

Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    ULONG HandleCount;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessHandleCount,
                &HandleCount,
                sizeof(HandleCount),
                NULL);

    if (! NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    *pdwHandleCount = HandleCount;

    return TRUE;
}

BOOL
WINAPI
GetSystemRegistryQuota(
    OUT PDWORD pdwQuotaAllowed,
    OUT PDWORD pdwQuotaUsed
    )

/*++

Routine Description:

    This function returns the system registry's quota.

Arguments:

    pdwQuotaAllowed - Supplies the location in which to write the
        maximum size the registry may attain.

    pdwQuotaUsed - Supplies the location in which to write the amount
        of registry quota currently in use.

Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    SYSTEM_REGISTRY_QUOTA_INFORMATION QuotaInfo;

    Status = NtQuerySystemInformation(
                SystemRegistryQuotaInformation,
                &QuotaInfo,
                sizeof(QuotaInfo),
                NULL);

    if (! NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (pdwQuotaAllowed) {
        *pdwQuotaAllowed = QuotaInfo.RegistryQuotaAllowed;
    }

    if (pdwQuotaUsed) {
        *pdwQuotaUsed = QuotaInfo.RegistryQuotaUsed;
    }

    return TRUE;
}


NTSTATUS
BasepConfigureAppCertDlls(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
   UNREFERENCED_PARAMETER( Context );

   return (BasepSaveAppCertRegistryValue( (PLIST_ENTRY)EntryContext,
                                ValueName,
                                ValueData
                              )
         );
}


NTSTATUS
BasepSaveAppCertRegistryValue(
    IN OUT PLIST_ENTRY ListHead,
    IN PWSTR Name,
    IN PWSTR Value OPTIONAL
    )
{
    PLIST_ENTRY Next;
    PBASEP_APPCERT_ENTRY p;
    UNICODE_STRING UnicodeName;

    RtlInitUnicodeString( &UnicodeName, Name );

    Next = ListHead->Flink;
    while ( Next != ListHead ) {
       p = CONTAINING_RECORD( Next,
                              BASEP_APPCERT_ENTRY,
                              Entry
                            );
       if (!RtlCompareUnicodeString( &p->Name, &UnicodeName, TRUE )) {
#if DBG
          DbgPrint("BasepSaveRegistryValue: Entry already exists for Certification Component %ws\n",Name);
#endif
          return( STATUS_SUCCESS );
           }

       Next = Next->Flink;
       }

     p = RtlAllocateHeap( RtlProcessHeap(), MAKE_TAG( TMP_TAG ), sizeof( *p ) + UnicodeName.MaximumLength );

     if (p == NULL) {
#if DBG
         DbgPrint("BasepSaveRegistryValue: Failed to allocate memory\n");
#endif
         return( STATUS_NO_MEMORY );
         }

     InitializeListHead( &p->Entry );

     p->Name.Buffer = (PWSTR)(p+1);
     p->Name.Length = UnicodeName.Length;
     p->Name.MaximumLength = UnicodeName.MaximumLength;
     RtlCopyMemory( p->Name.Buffer,
                    UnicodeName.Buffer,
                    UnicodeName.MaximumLength
                  );

     InsertTailList( ListHead, &p->Entry );


    if (ARGUMENT_PRESENT( Value )) {
      //
      // load certification DLL
      //

      HINSTANCE hDll = LoadLibraryW( Value );

      if (hDll == NULL) {
         //
         // The library was not loaded, return.
         //
         RemoveEntryList( &p->Entry );
         RtlFreeHeap( RtlProcessHeap(), 0, p );
#if DBG
         DbgPrint("BasepSaveRegistryValue: Certification DLL %ws not found\n", Value);
#endif
         return( STATUS_SUCCESS );
          }

      //
      // get entry point
      //
      p->fPluginCertFunc = (NTSTATUS (WINAPI *)(LPCWSTR,ULONG))
                          GetProcAddress(hDll,
                                         CERTAPP_ENTRYPOINT_NAME
                                         );

      if (p->fPluginCertFunc == NULL) {
          //
          // Unable to retrieve routine address, fail.
          //
          RemoveEntryList( &p->Entry );
          RtlFreeHeap( RtlProcessHeap(), 0, p );
          FreeLibrary(hDll);
#if DBG
          DbgPrint("BasepSaveRegistryValue: DLL %ws does not have entry point %s\n", Value,CERTAPP_ENTRYPOINT_NAME);
#endif
          return( STATUS_SUCCESS );
         }

        }
    else {
       RemoveEntryList( &p->Entry );
       RtlFreeHeap( RtlProcessHeap(), 0, p );
#if DBG
       DbgPrint("BasepSaveRegistryValue: Entry %ws is empty \n", Name);
#endif
       return( STATUS_SUCCESS );
        }

    return( STATUS_SUCCESS );

}

BOOL
IsWow64Process(
    HANDLE hProcess,
    PBOOL Wow64Process
    )
/*++

Routine Description:

    Checks if a process is running inside Wow64 (emulation for 32-bit applications
    on Win64).

Arguments:

    hProcess - Process handle to check if it is running inside Wow64.

    Wow64Process - Pointer to a boolean that receives the result if the function succeeds.

Return Value:

    BOOL

--*/

{
    NTSTATUS NtStatus;
    BOOL bRet;
    ULONG_PTR Peb32;

    NtStatus = NtQueryInformationProcess (
        hProcess,
        ProcessWow64Information,
        &Peb32,
        sizeof (Peb32),
        NULL
        );

    if (!NT_SUCCESS (NtStatus)) {

        BaseSetLastNTError (NtStatus);
    } else {

        if (Peb32 == 0) {
            *Wow64Process = FALSE;
        } else {
            *Wow64Process = TRUE;
        }
    }

    return (NT_SUCCESS (NtStatus));
}

#if defined(_WIN64) || defined(BUILD_WOW6432)

BOOL
NtVdm64CreateProcess(
    BOOL fPrefixMappedApplicationName,
    LPCWSTR lpApplicationName,
    LPCWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
/*++

Routine Description:

    Checks if there is a ported version of the Win16 lpApplicationName and
    if so creates a process with the ported version.

Arguments:

    fPrefixMappedApplicationName
        - TRUE means that the original lpApplicationName was NULL.
               The application name was stripped from the head of
               lpCommandLine.
               The mapped application name needs to be added to the
               head of the mapped command line.
        - FALSE means that the original lpApplicationName was non-NULL.
               the lpCommandLine argument is identical to the original
               lpCommandLine argument.
    lpApplicationName - Win16 file name not optional
    lpCommandLine - see comment for fPrefixMappedApplicationName.

    other arguments are identical to CreateProcessW.

Return Value:

    Same as CreateProcessW

--*/
{
    typedef BOOL
    (*LPNtVdm64CreateProcessFn)(
        BOOL fPrefixMappedApplicationName,
        LPCWSTR lpApplicationName,
        LPCWSTR lpCommandLine,
        LPSECURITY_ATTRIBUTES lpProcessAttributes,
        LPSECURITY_ATTRIBUTES lpThreadAttributes,
        BOOL bInheritHandles,
        DWORD dwCreationFlags,
        LPVOID lpEnvironment,
        LPCWSTR lpCurrentDirectory,
        LPSTARTUPINFOW lpStartupInfo,
        LPPROCESS_INFORMATION lpProcessInformation
        );

    HINSTANCE hInstance;
    LPNtVdm64CreateProcessFn lpfn;
    BOOL result;
    NTSTATUS Status;
    WCHAR StaticUnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];
    HRESULT hResult;

    hInstance = NULL;
    Status = ERROR_BAD_EXE_FORMAT;
    result = FALSE;

    // so it turns out that there is a high probability that
    // lpCommandLine sits in the StaticUnicodeBuffer in the Teb
    // and also a high probability that LoadLibrary will trash that
    // buffer in a bad way
    if (lpCommandLine >= NtCurrentTeb()->StaticUnicodeBuffer &&
        lpCommandLine < NtCurrentTeb()->StaticUnicodeBuffer + STATIC_UNICODE_BUFFER_LENGTH) {
        hResult = StringCchCopyW(StaticUnicodeBuffer,
                                 RTL_NUMBER_OF(StaticUnicodeBuffer),
                                 lpCommandLine);
        if (FAILED(hResult)) {
            Status = HRESULT_CODE(hResult);
            goto ErrorExit;
        }
        lpCommandLine = StaticUnicodeBuffer;
    }

    hInstance = LoadLibraryW(L"NtVdm64.Dll");
    if (hInstance == NULL) {
        goto ErrorExit;
    }

    lpfn = (LPNtVdm64CreateProcessFn) GetProcAddress(hInstance, "NtVdm64CreateProcess");
    if (lpfn == NULL) {
        goto ErrorExit;
    }

    result = (*lpfn)(fPrefixMappedApplicationName,
                     lpApplicationName,
                     lpCommandLine,
                     lpProcessAttributes,
                     lpThreadAttributes,
                     bInheritHandles,
                     dwCreationFlags,
                     lpEnvironment,
                     lpCurrentDirectory,
                     lpStartupInfo,
                     lpProcessInformation
                     );
    Status = GetLastError();

ErrorExit:
    if (hInstance != NULL) {
        FreeLibrary(hInstance);
    }
    SetLastError(Status);

    return result;
}
#endif

BOOL
BasepIsCurDirAllowedForPlainExeNames(
    VOID
    )

/*++

Routine Description:

    This function determines whether or not the current directory
    should be used as part of the process of locating an executable
    whose name contains no directory components.

Arguments:

    None.

Return Value:

    TRUE - The current directory should be a part of the path used to
           search for executables whose names contain no directory
           components.

    FALSE - The current directory should NOT be a part of the path
            used to search for executables whose names contain no
            directory components.

--*/

{
    NTSTATUS Status;

    static const UNICODE_STRING Name =
        RTL_CONSTANT_STRING(L"NoDefaultCurrentDirectoryInExePath");

    UNICODE_STRING Value;

    RtlInitEmptyUnicodeString(&Value, NULL, 0);

    Status = RtlQueryEnvironmentVariable_U(NULL, &Name, &Value);

    if (Status == STATUS_BUFFER_TOO_SMALL || Status == STATUS_SUCCESS) {
        return FALSE;
    } else {
        return TRUE;
    }
}

BOOL
WINAPI
NeedCurrentDirectoryForExePathA(
    IN LPCSTR ExeName
    )

/*++

Routine Description:

    This function determines whether or not the current directory
    should be used as part of the process of locating an executable.

Arguments:

    ExeName - The name of the exe which will be looked for.

Return Value:

    TRUE - The current directory should be a part of the path used to
           search for executables.

    FALSE - The current directory should NOT be a part of the path
            used to search for executables.

--*/

{
    // N.B. Changes here should be reflected in the Unicode version as well.

    if (strchr(ExeName, '\\')) { // if it contains a '\'
        return TRUE;             // allow the current directory
    }

    // Otherwise, either it doesn't matter, or we want to optionally restrict it.

    return BasepIsCurDirAllowedForPlainExeNames();
}

BOOL
WINAPI
NeedCurrentDirectoryForExePathW(
    IN LPCWSTR ExeName
    )

/*++

Routine Description:

    This function determines whether or not the current directory
    should be used as part of the process of locating an executable.

Arguments:

    ExeName - The name of the exe which will be looked for.

Return Value:

    TRUE - The current directory should be a part of the path used to
           search for executables.

    FALSE - The current directory should NOT be a part of the path
            used to search for executables.

--*/

{
    // N.B. Changes here should be reflected in the ANSI version as well.
    
    if (wcschr(ExeName, L'\\')) { // if it contains a '\'
        return TRUE;              // allow the current directory
    }

    // Otherwise, either it doesn't matter, or we want to optionally restrict it.

    return BasepIsCurDirAllowedForPlainExeNames();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\synch.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    synch.c

Abstract:

    This module implements all Win32 syncronization
    objects.

Author:

    Mark Lucovsky (markl) 19-Sep-1990

Revision History:

--*/

#include "basedll.h"

//
// Critical Section Services
//

VOID
InitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    )

/*++

Routine Description:

    A critical section object is initialized using
    Win32InitializeCriticalSection.

    Once a critical section object has been initialized threads within a
    single process may enter and exit critical sections using the
    critical section object.  A critical section object may not me moved
    or copied.  The application must also not modify the insides of the
    object, but must treat it as logically opaque.
    description-of-function.

Arguments:

    lpCriticalSection - Supplies the address of a critical section object
        to be initialized.  It is the callers resposibility to allocate
        the storage used by a critical section object.

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    Status = RtlInitializeCriticalSection(lpCriticalSection);
    if ( !NT_SUCCESS(Status) ){
        RtlRaiseStatus(Status);
        }
}

BOOL
InitializeCriticalSectionAndSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
    )

/*++

Routine Description:

    A critical section object is initialized using
    Win32InitializeCriticalSection.

    Once a critical section object has been initialized threads within a
    single process may enter and exit critical sections using the
    critical section object.  A critical section object may not me moved
    or copied.  The application must also not modify the insides of the
    object, but must treat it as logically opaque.
    description-of-function.

Arguments:

    lpCriticalSection - Supplies the address of a critical section object
        to be initialized.  It is the callers resposibility to allocate
        the storage used by a critical section object.

Return Value:

    TRUE is the code suceeded, FALSE otherwise.

--*/

{
    NTSTATUS Status;
    BOOL rv;

    rv = TRUE;
    Status = RtlInitializeCriticalSectionAndSpinCount(lpCriticalSection,dwSpinCount);
    if ( !NT_SUCCESS(Status) ){
        BaseSetLastNTError(Status);
        rv = FALSE;
        }
    return rv;
}



//
// Event Services
//
HANDLE
APIENTRY
CreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to CreateEventW


--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    LPCWSTR NameBuffer;

    NameBuffer = NULL;
    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        NameBuffer = (LPCWSTR)Unicode->Buffer;
        }

    return CreateEventW(
                lpEventAttributes,
                bManualReset,
                bInitialState,
                NameBuffer
                );
}


HANDLE
APIENTRY
CreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    )

/*++

Routine Description:

    An event object is created and a handle opened for access to the
    object with the CreateEvent function.

    The CreateEvent function creates an event object with the specified
    initial state.  If an event is in the Signaled state (TRUE), a wait
    operation on the event does not block.  If the event is in the Not-
    Signaled state (FALSE), a wait operation on the event blocks until
    the specified event attains a state of Signaled, or the timeout
    value is exceeded.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the following
    object type specific access flags are valid for event objects:

        - EVENT_MODIFY_STATE - Modify state access (set and reset) to
          the event is desired.

        - SYNCHRONIZE - Synchronization access (wait) to the event is
          desired.

        - EVENT_ALL_ACCESS - This set of access flags specifies all of
          the possible access flags for an event object.


Arguments:

    lpEventAttributes - An optional parameter that may be used to
        specify the attributes of the new event.  If the parameter is
        not specified, then the event is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation.

    bManualReset - Supplies a flag which if TRUE specifies that the
        event must be manually reset.  If the value is FALSE, then after
        releasing a single waiter, the system automaticaly resets the
        event.

    bInitialState - The initial state of the event object, one of TRUE
        or FALSE.  If the InitialState is specified as TRUE, the event's
        current state value is set to one, otherwise it is set to zero.

    lpName - Optional unicode name of event

Return Value:

    NON-NULL - Returns a handle to the new event.  The handle has full
        access to the new event and may be used in any API that requires
        a handle to an event object.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    UNICODE_STRING ObjectName;

    if ( ARGUMENT_PRESENT(lpName) ) {
        RtlInitUnicodeString(&ObjectName,lpName);
        pObja = BaseFormatObjectAttributes(&Obja,lpEventAttributes,&ObjectName);
        }
    else {
        pObja = BaseFormatObjectAttributes(&Obja,lpEventAttributes,NULL);
        }

    Status = NtCreateEvent(
                &Handle,
                EVENT_ALL_ACCESS,
                pObja,
                bManualReset ? NotificationEvent : SynchronizationEvent,
                (BOOLEAN)bInitialState
                );

    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        return Handle;
        }
    else {
        BaseSetLastNTError(Status);
        return NULL;
        }
}


HANDLE
APIENTRY
OpenEventA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to OpenNamedEventW

--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        }
    else {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    return OpenEventW(
                dwDesiredAccess,
                bInheritHandle,
                (LPCWSTR)Unicode->Buffer
                );
}

HANDLE
APIENTRY
OpenEventW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING ObjectName;
    NTSTATUS Status;
    HANDLE Object;

    if ( !lpName ) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    RtlInitUnicodeString(&ObjectName,lpName);

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        (bInheritHandle ? OBJ_INHERIT : 0),
        BaseGetNamedObjectDirectory(),
        NULL
        );

    Status = NtOpenEvent(
                &Object,
                dwDesiredAccess,
                &Obja
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
        }
    return Object;
}


BOOL
SetEvent(
    HANDLE hEvent
    )

/*++

Routine Description:

    An event can be set to the signaled state (TRUE) with the SetEvent
    function.

    Setting the event causes the event to attain a state of Signaled,
    which releases all currently waiting threads (for manual reset
    events), or a single waiting thread (for automatic reset events).

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtSetEvent(hEvent,NULL);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}


BOOL
ResetEvent(
    HANDLE hEvent
    )

/*++

Routine Description:

    The state of an event is set to the Not-Signaled state (FALSE) using
    the ClearEvent function.

    Once the event attains a state of Not-Signaled, any threads which
    wait on the event block, awaiting the event to become Signaled.  The
    reset event service sets the event count to zero for the state of
    the event.

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtClearEvent(hEvent);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}


BOOL
PulseEvent(
    HANDLE hEvent
    )

/*++

Routine Description:

    An event can be set to the Signaled state and reset to the Not-
    Signaled state atomically with the PulseEvent function.

    Pulsing the event causes the event to attain a state of Signaled,
    release appropriate threads, and then reset the event.  When no
    waiters are currently waiting on the event, pulsing an event causes
    the event to release no threads and end up in the Not-Signaled
    state.  With waiters waiting on an event, pulsing an event has a
    different effect for manual reset events that it does for automatic
    reset events.  For manual reset events, pulsing releases all waiters
    and then leaves the event in the Not-Signaled state.  For automatic
    reset events, pulsing the event releases a single waiter and then
    leaves the event in the Not-Signaled state.

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtPulseEvent(hEvent,NULL);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}



//
// Semaphore Services
//

HANDLE
APIENTRY
CreateSemaphoreA(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to CreateSemaphoreW


--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    LPCWSTR NameBuffer;

    NameBuffer = NULL;
    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        NameBuffer = (LPCWSTR)Unicode->Buffer;
        }

    return CreateSemaphoreW(
                lpSemaphoreAttributes,
                lInitialCount,
                lMaximumCount,
                NameBuffer
                );
}


HANDLE
APIENTRY
CreateSemaphoreW(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCWSTR lpName
    )

/*++

Routine Description:

    A semaphore object is created and a handle opened for access to the
    object with the CreateSemaphore function.

    The CreateSemaphore function causes a semaphore object to be created
    which contains the specified initial and maximum counts.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the
    following object type specific access flags are valid for semaphore
    objects:

        - SEMAPHORE_MODIFY_STATE - Modify state access (release) to the
            semaphore is desired.

        - SYNCHRONIZE - Synchronization access (wait) to the semaphore
            is desired.

        - SEMAPHORE_ALL_ACCESS - This set of access flags specifies all
            of the possible access flags for a semaphore object.


Arguments:

    lpSemaphoreAttributes - An optional parameter that may be used to
        specify the attributes of the new semaphore.  If the parameter
        is not specified, then the semaphore is created without a
        security descriptor, , and the resulting handle is not inherited
        on process creation.

    lInitialCount - The initial count for the semaphore, this value
        must be positive and less than or equal to the maximum count.

    lMaximumCount - The maximum count for the semaphore, this value
        must be greater than zero..

    lpName - Supplies an optional unicode name for the object.

Return Value:

    NON-NULL - Returns a handle to the new semaphore.  The handle has
        full access to the new semaphore and may be used in any API that
        requires a handle to a semaphore object.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    UNICODE_STRING ObjectName;

    if ( ARGUMENT_PRESENT(lpName) ) {
        RtlInitUnicodeString(&ObjectName,lpName);
        pObja = BaseFormatObjectAttributes(&Obja,lpSemaphoreAttributes,&ObjectName);
        }
    else {
        pObja = BaseFormatObjectAttributes(&Obja,lpSemaphoreAttributes,NULL);
        }

    Status = NtCreateSemaphore(
                &Handle,
                SEMAPHORE_ALL_ACCESS,
                pObja,
                lInitialCount,
                lMaximumCount
                );

    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        return Handle;
        }
    else {
        BaseSetLastNTError(Status);
        return NULL;
        }
}


HANDLE
APIENTRY
OpenSemaphoreA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to OpenSemaphoreW

--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        }
    else {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    return OpenSemaphoreW(
                dwDesiredAccess,
                bInheritHandle,
                (LPCWSTR)Unicode->Buffer
                );
}

HANDLE
APIENTRY
OpenSemaphoreW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING ObjectName;
    NTSTATUS Status;
    HANDLE Object;

    if ( !lpName ) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    RtlInitUnicodeString(&ObjectName,lpName);

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        (bInheritHandle ? OBJ_INHERIT : 0),
        BaseGetNamedObjectDirectory(),
        NULL
        );

    Status = NtOpenSemaphore(
                &Object,
                dwDesiredAccess,
                &Obja
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
        }
    return Object;
}


BOOL
ReleaseSemaphore(
    HANDLE hSemaphore,
    LONG lReleaseCount,
    LPLONG lpPreviousCount
    )

/*++

Routine Description:

    A semaphore object can be released with the ReleaseSemaphore
    function.

    When the semaphore is released, the current count of the semaphore
    is incremented by the ReleaseCount.  Any threads that are waiting
    for the semaphore are examined to see if the current semaphore value
    is sufficient to satisfy their wait.

    If the value specified by ReleaseCount would cause the maximum count
    for the semaphore to be exceeded, then the count for the semaphore
    is not affected and an error status is returned.


Arguments:

    hSemaphore - Supplies an open handle to a semaphore object.  The
        handle must have SEMAPHORE_MODIFY_STATE access to the semaphore.

    lReleaseCount - The release count for the semaphore.  The count
        must be greater than zero and less than the maximum value
        specified for the semaphore.

    lpPreviousCount - An optional pointer to a variable that receives
        the previous count for the semaphore.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtReleaseSemaphore(hSemaphore,lReleaseCount,lpPreviousCount);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}



//
// Mutex Services
//

HANDLE
APIENTRY
CreateMutexA(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to CreateMutexW

--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    LPCWSTR NameBuffer;

    NameBuffer = NULL;
    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }

        NameBuffer = (LPCWSTR)Unicode->Buffer;
        }

    return CreateMutexW(
                lpMutexAttributes,
                bInitialOwner,
                NameBuffer
                );
}

HANDLE
APIENTRY
CreateMutexW(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName
    )

/*++

Routine Description:

    A mutex object can be created and a handle opened for access to the
    object with the CreateMutex function.

    A new mutex object is created and a handle opened to the object with
    ownership as determined by the InitialOwner parameter.  The status
    of the newly created mutex object is set to not abandoned.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the
    following object type specific access flags are valid for mutex
    objects:

        - MUTEX_MODIFY_STATE - Modify access to the mutex is desired.
          This allows a process to release a mutex.

        - SYNCHRONIZE - Synchronization access (wait or release) to the
          mutex object is desired.

        - MUTEX_ALL_ACCESS - All possible types of access to the mutex
          object are desired.


Arguments:

    lpMutexAttributes - An optional parameter that may be used to specify
        the attributes of the new mutex.  If the parameter is not
        specified, then the mutex is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation.

    bInitialOwner - A boolean value that determines whether the creator
        of the object desires immediate ownership of the mutex object.


    lpName - Supplies an optional unicode name for the mutex.

Return Value:

    NON-NULL - Returns a handle to the new mutex.  The handle has full
        access to the new mutex and may be used in any API that
        requires a handle to a mutex object.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    UNICODE_STRING ObjectName;

    if ( ARGUMENT_PRESENT(lpName) ) {
        RtlInitUnicodeString(&ObjectName,lpName);
        pObja = BaseFormatObjectAttributes(&Obja,lpMutexAttributes,&ObjectName);
        }
    else {
        pObja = BaseFormatObjectAttributes(&Obja,lpMutexAttributes,NULL);
        }

    Status = NtCreateMutant(
                &Handle,
                MUTANT_ALL_ACCESS,
                pObja,
                (BOOLEAN)bInitialOwner
                );

    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        return Handle;
        }
    else {
        BaseSetLastNTError(Status);
        return NULL;
        }
}

HANDLE
APIENTRY
OpenMutexA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to OpenMutexW

--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        }
    else {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    return OpenMutexW(
                dwDesiredAccess,
                bInheritHandle,
                (LPCWSTR)Unicode->Buffer
                );
}

HANDLE
APIENTRY
OpenMutexW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING ObjectName;
    NTSTATUS Status;
    HANDLE Object;

    if ( !lpName ) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    RtlInitUnicodeString(&ObjectName,lpName);

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        (bInheritHandle ? OBJ_INHERIT : 0),
        BaseGetNamedObjectDirectory(),
        NULL
        );

    Status = NtOpenMutant(
                &Object,
                dwDesiredAccess,
                &Obja
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
        }
    return Object;
}

BOOL
ReleaseMutex(
    HANDLE hMutex
    )

/*++

Routine Description:

    Ownership of a mutex object can be released with the ReleaseMutex
    function.

    A mutex object can only be released by a thread that currently owns
    the mutex object.  When the mutex is released, the current count of
    the mutex object is incremented by one.  If the resultant count is
    one, then the mutex object is no longer owned.  Any threads that are
    waiting for the mutex object are examined to see if their wait can
    be satisfied.

Arguments:

    hMutex - An open handle to a mutex object.  The handle must
        have MUTEX_MODIFY_STATE access to the mutex.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtReleaseMutant(hMutex,NULL);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}


//
// Wait Services
//

DWORD
WaitForSingleObject(
    HANDLE hHandle,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    A wait operation on a waitable object is accomplished with the
    WaitForSingleObject function.

    Waiting on an object checks the current state of the object.  If the
    current state of the object allows continued execution, any
    adjustments to the object state are made (for example, decrementing
    the semaphore count for a semaphore object) and the thread continues
    execution.  If the current state of the object does not allow
    continued execution, the thread is placed into the wait state
    pending the change of the object's state or time-out.

Arguments:

    hHandle - An open handle to a waitable object. The handle must have
        SYNCHRONIZE access to the object.

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    WAIT_TIME_OUT - Indicates that the wait was terminated due to the
        TimeOut conditions.

    0 - indicates the specified object attained a Signaled
        state thus completing the wait.

    WAIT_ABANDONED - indicates the specified object attained a Signaled
        state but was abandoned.

--*/

{
    return WaitForSingleObjectEx(hHandle,dwMilliseconds,FALSE);
}

DWORD
APIENTRY
WaitForSingleObjectEx(
    HANDLE hHandle,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    A wait operation on a waitable object is accomplished with the
    WaitForSingleObjectEx function.

    Waiting on an object checks the current state of the object.  If the
    current state of the object allows continued execution, any
    adjustments to the object state are made (for example, decrementing
    the semaphore count for a semaphore object) and the thread continues
    execution.  If the current state of the object does not allow
    continued execution, the thread is placed into the wait state
    pending the change of the object's state or time-out.

    If the bAlertable parameter is FALSE, the only way the wait
    terminates is because the specified timeout period expires, or
    because the specified object entered the signaled state.  If the
    bAlertable parameter is TRUE, then the wait can return due to any
    one of the above wait termination conditions, or because an I/O
    completion callback terminated the wait early (return value of
    WAIT_IO_COMPLETION).

Arguments:

    hHandle - An open handle to a waitable object. The handle must have
        SYNCHRONIZE access to the object.

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of
        0xffffffff specifies an infinite timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        wait may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    WAIT_TIME_OUT - Indicates that the wait was terminated due to the
        TimeOut conditions.

    0 - indicates the specified object attained a Signaled
        state thus completing the wait.

    0xffffffff - The wait terminated due to an error. GetLastError may be
        used to get additional error information.

    WAIT_ABANDONED - indicates the specified object attained a Signaled
        state but was abandoned.

    WAIT_IO_COMPLETION - The wait terminated due to one or more I/O
        completion callbacks.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    PPEB Peb;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    if (bAlertable) {
        // make the process default activation context active so that
        // APCs are delivered under it
        RtlActivateActivationContextUnsafeFast(&Frame, NULL);
    }
    __try {

        Peb = NtCurrentPeb();
        switch( HandleToUlong(hHandle) ) {
            case STD_INPUT_HANDLE:  hHandle = Peb->ProcessParameters->StandardInput;
                                    break;
            case STD_OUTPUT_HANDLE: hHandle = Peb->ProcessParameters->StandardOutput;
                                    break;
            case STD_ERROR_HANDLE:  hHandle = Peb->ProcessParameters->StandardError;
                                    break;
            }

        if (CONSOLE_HANDLE(hHandle) && VerifyConsoleIoHandle(hHandle)) {
            hHandle = GetConsoleInputWaitHandle();
            }

        pTimeOut = BaseFormatTimeOut(&TimeOut,dwMilliseconds);
    rewait:
        Status = NtWaitForSingleObject(hHandle,(BOOLEAN)bAlertable,pTimeOut);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            Status = (NTSTATUS)0xffffffff;
            }
        else {
            if ( bAlertable && Status == STATUS_ALERTED ) {
                goto rewait;
                }
            }
    } __finally {
        if (bAlertable) {
            RtlDeactivateActivationContextUnsafeFast(&Frame);
        }
    }

    return (DWORD)Status;
}


DWORD
WINAPI
SignalObjectAndWait(
    HANDLE hObjectToSignal,
    HANDLE hObjectToWaitOn,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    PPEB Peb;

    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    if (bAlertable) {
        // make the process default activation context active so that
        // APCs are delivered under it
        RtlActivateActivationContextUnsafeFast(&Frame, NULL);
    }
    __try {
        Peb = NtCurrentPeb();
        switch( HandleToUlong(hObjectToWaitOn) ) {
            case STD_INPUT_HANDLE:  hObjectToWaitOn = Peb->ProcessParameters->StandardInput;
                                    break;
            case STD_OUTPUT_HANDLE: hObjectToWaitOn = Peb->ProcessParameters->StandardOutput;
                                    break;
            case STD_ERROR_HANDLE:  hObjectToWaitOn = Peb->ProcessParameters->StandardError;
                                    break;
            }

        if (CONSOLE_HANDLE(hObjectToWaitOn) && VerifyConsoleIoHandle(hObjectToWaitOn)) {
            hObjectToWaitOn = GetConsoleInputWaitHandle();
            }

        pTimeOut = BaseFormatTimeOut(&TimeOut,dwMilliseconds);
    rewait:
        Status = NtSignalAndWaitForSingleObject(
                    hObjectToSignal,
                    hObjectToWaitOn,
                    (BOOLEAN)bAlertable,
                    pTimeOut
                    );

        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            Status = (NTSTATUS)0xffffffff;
            }
        else {
            if ( bAlertable && Status == STATUS_ALERTED ) {
                goto rewait;
                }
            }
    } __finally {
        if (bAlertable) {
            RtlDeactivateActivationContextUnsafeFast(&Frame);
        }
    }

    return (DWORD)Status;
}



DWORD
WaitForMultipleObjects(
    DWORD nCount,
    CONST HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

A wait operation on multiple waitable objects (up to
MAXIMUM_WAIT_OBJECTS) is accomplished with the WaitForMultipleObjects
function.

Arguments:

    nCount - A count of the number of objects that are to be waited on.

    lpHandles - An array of object handles.  Each handle must have
        SYNCHRONIZE access to the associated object.

    bWaitAll - A flag that supplies the wait type.  A value of TRUE
        indicates a "wait all".  A value of false indicates a "wait
        any".

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    WAIT_TIME_OUT - indicates that the wait was terminated due to the
        TimeOut conditions.

    0 to MAXIMUM_WAIT_OBJECTS-1, indicates, in the case of wait for any
        object, the object number which satisfied the wait.  In the case
        of wait for all objects, the value only indicates that the wait
        was completed successfully.

    WAIT_ABANDONED_0 to (WAIT_ABANDONED_0)+(MAXIMUM_WAIT_OBJECTS - 1),
        indicates, in the case of wait for any object, the object number
        which satisfied the event, and that the object which satisfied
        the event was abandoned.  In the case of wait for all objects,
        the value indicates that the wait was completed successfully and
        at least one of the objects was abandoned.

--*/

{
    return WaitForMultipleObjectsEx(nCount,lpHandles,bWaitAll,dwMilliseconds,FALSE);
}

DWORD
APIENTRY
WaitForMultipleObjectsEx(
    DWORD nCount,
    CONST HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    A wait operation on multiple waitable objects (up to
    MAXIMUM_WAIT_OBJECTS) is accomplished with the
    WaitForMultipleObjects function.

    This API can be used to wait on any of the specified objects to
    enter the signaled state, or all of the objects to enter the
    signaled state.

    If the bAlertable parameter is FALSE, the only way the wait
    terminates is because the specified timeout period expires, or
    because the specified objects entered the signaled state.  If the
    bAlertable parameter is TRUE, then the wait can return due to any one of
    the above wait termination conditions, or because an I/O completion
    callback terminated the wait early (return value of
    WAIT_IO_COMPLETION).

Arguments:

    nCount - A count of the number of objects that are to be waited on.

    lpHandles - An array of object handles.  Each handle must have
        SYNCHRONIZE access to the associated object.

    bWaitAll - A flag that supplies the wait type.  A value of TRUE
        indicates a "wait all".  A value of false indicates a "wait
        any".

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of
        0xffffffff specifies an infinite timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        wait may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    WAIT_TIME_OUT - indicates that the wait was terminated due to the
        TimeOut conditions.

    0 to MAXIMUM_WAIT_OBJECTS-1, indicates, in the case of wait for any
        object, the object number which satisfied the wait.  In the case
        of wait for all objects, the value only indicates that the wait
        was completed successfully.

    0xffffffff - The wait terminated due to an error. GetLastError may be
        used to get additional error information.

    WAIT_ABANDONED_0 to (WAIT_ABANDONED_0)+(MAXIMUM_WAIT_OBJECTS - 1),
        indicates, in the case of wait for any object, the object number
        which satisfied the event, and that the object which satisfied
        the event was abandoned.  In the case of wait for all objects,
        the value indicates that the wait was completed successfully and
        at least one of the objects was abandoned.

    WAIT_IO_COMPLETION - The wait terminated due to one or more I/O
        completion callbacks.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    DWORD i;
    LPHANDLE HandleArray;
    HANDLE Handles[ 8 ];
    PPEB Peb;
    DWORD RetVal;

    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    if (bAlertable) {
        // make the process default activation context active so that
        // APCs are delivered under it
        RtlActivateActivationContextUnsafeFast(&Frame, NULL);
    }

    __try {
        if (nCount > sizeof (Handles) / sizeof (Handles[0])) {
            HandleArray = (LPHANDLE) RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG( TMP_TAG ), nCount*sizeof(HANDLE));
            if (HandleArray == NULL) {
                Status = STATUS_NO_MEMORY;
                RetVal = 0xffffffff;
                leave;
            }
        } else {
            HandleArray = Handles;
        }
        RtlCopyMemory(HandleArray,(LPVOID)lpHandles,nCount*sizeof(HANDLE));

        Peb = NtCurrentPeb();
        for (i=0;i<nCount;i++) {
            switch( HandleToUlong(HandleArray[i]) ) {
                case STD_INPUT_HANDLE:  HandleArray[i] = Peb->ProcessParameters->StandardInput;
                                        break;
                case STD_OUTPUT_HANDLE: HandleArray[i] = Peb->ProcessParameters->StandardOutput;
                                        break;
                case STD_ERROR_HANDLE:  HandleArray[i] = Peb->ProcessParameters->StandardError;
                                        break;
            }

            if (CONSOLE_HANDLE(HandleArray[i]) && VerifyConsoleIoHandle(HandleArray[i])) {
                HandleArray[i] = GetConsoleInputWaitHandle();
            }
        }

        pTimeOut = BaseFormatTimeOut(&TimeOut,dwMilliseconds);
    rewait:
        Status = NtWaitForMultipleObjects(
                     nCount,
                     HandleArray,
                     bWaitAll ? WaitAll : WaitAny,
                     (BOOLEAN)bAlertable,
                     pTimeOut
                     );
        if (!NT_SUCCESS (Status)) {
            RetVal = 0xffffffff;
        } else {
            if ( bAlertable && Status == STATUS_ALERTED ) {
                goto rewait;
            }
            RetVal = (DWORD) Status;
        }

        if (HandleArray != Handles) {
            RtlFreeHeap(RtlProcessHeap(), 0, HandleArray);
        }
    } __finally {
        if (bAlertable) {
            RtlDeactivateActivationContextUnsafeFast(&Frame);
        }
    }

    if (RetVal == 0xffffffff) {
        BaseSetLastNTError (Status);
    }

    return RetVal;
}

VOID
Sleep(
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    The execution of the current thread can be delayed for a specified
    interval of time with the Sleep function.

    The Sleep function causes the current thread to enter a
    waiting state until the specified interval of time has passed.

Arguments:

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    None.

--*/

{
    SleepEx(dwMilliseconds,FALSE);
}

DWORD
APIENTRY
SleepEx(
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    The execution of the current thread can be delayed for a specified
    interval of time with the SleepEx function.

    The SleepEx function causes the current thread to enter a waiting
    state until the specified interval of time has passed.

    If the bAlertable parameter is FALSE, the only way the SleepEx
    returns is when the specified time interval has passed.  If the
    bAlertable parameter is TRUE, then the SleepEx can return due to the
    expiration of the time interval (return value of 0), or because an
    I/O completion callback terminated the SleepEx early (return value
    of WAIT_IO_COMPLETION).

Arguments:

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  A timeout value of -1 specifies an infinite
        timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        SleepEx may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    0 - The SleepEx terminated due to expiration of the time interval.

    WAIT_IO_COMPLETION - The SleepEx terminated due to one or more I/O
        completion callbacks.

--*/
{
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    NTSTATUS Status;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    if (bAlertable) {
        // make the process default activation context active so that
        // APCs are delivered under it
        RtlActivateActivationContextUnsafeFast(&Frame, NULL);
    }
    __try {
        pTimeOut = BaseFormatTimeOut(&TimeOut,dwMilliseconds);
        if (pTimeOut == NULL) {
            //
            // If Sleep( -1 ) then delay for the longest possible integer
            // relative to now.
            //

            TimeOut.LowPart = 0x0;
            TimeOut.HighPart = 0x80000000;
            pTimeOut = &TimeOut;
            }

    rewait:
        Status = NtDelayExecution(
                    (BOOLEAN)bAlertable,
                    pTimeOut
                    );
        if ( bAlertable && Status == STATUS_ALERTED ) {
            goto rewait;
            }
    } __finally {
        if (bAlertable) {
            RtlDeactivateActivationContextUnsafeFast(&Frame);
        }
    }

    return Status == STATUS_USER_APC ? WAIT_IO_COMPLETION : 0;
}

HANDLE
WINAPI
CreateWaitableTimerA(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    BOOL bManualReset,
    LPCSTR lpTimerName
    )

/*++

Routine Description:

    ANSI thunk to CreateWaitableTimerW


--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    LPCWSTR NameBuffer;

    NameBuffer = NULL;
    if ( ARGUMENT_PRESENT(lpTimerName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpTimerName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        NameBuffer = (LPCWSTR)Unicode->Buffer;
        }

    return CreateWaitableTimerW(
                lpTimerAttributes,
                bManualReset,
                NameBuffer
                );
}

HANDLE
WINAPI
CreateWaitableTimerW(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    BOOL bManualReset,
    LPCWSTR lpTimerName
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    UNICODE_STRING ObjectName;

    if ( ARGUMENT_PRESENT(lpTimerName) ) {
        RtlInitUnicodeString(&ObjectName,lpTimerName);
        pObja = BaseFormatObjectAttributes(&Obja,lpTimerAttributes,&ObjectName);
        }
    else {
        pObja = BaseFormatObjectAttributes(&Obja,lpTimerAttributes,NULL);
        }

    Status = NtCreateTimer(
                &Handle,
                TIMER_ALL_ACCESS,
                pObja,
                bManualReset ? NotificationTimer : SynchronizationTimer
                );

    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        return Handle;
        }
    else {
        BaseSetLastNTError(Status);
        return NULL;
        }
}

HANDLE
WINAPI
OpenWaitableTimerA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpTimerName
    )
{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    if ( ARGUMENT_PRESENT(lpTimerName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpTimerName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        }
    else {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    return OpenWaitableTimerW(
                dwDesiredAccess,
                bInheritHandle,
                (LPCWSTR)Unicode->Buffer
                );
}


HANDLE
WINAPI
OpenWaitableTimerW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpTimerName
    )
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING ObjectName;
    NTSTATUS Status;
    HANDLE Object;

    if ( !lpTimerName ) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }
    RtlInitUnicodeString(&ObjectName,lpTimerName);

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        (bInheritHandle ? OBJ_INHERIT : 0),
        BaseGetNamedObjectDirectory(),
        NULL
        );

    Status = NtOpenTimer(
                &Object,
                dwDesiredAccess,
                &Obja
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
        }
    return Object;
}

static
VOID
CALLBACK
BasepTimerAPCProc(
    PVOID pvContext,
    ULONG TimerLowValue,
    LONG TimerHighValue
    )
{
    PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK ActivationBlock = (PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK) pvContext;
    const PVOID CallbackContext = ActivationBlock->CallbackContext;
    const PTIMERAPCROUTINE TimerAPCRoutine = (PTIMERAPCROUTINE) ActivationBlock->CallbackFunction;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME ActivationFrame = { sizeof(ActivationFrame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };
    const PACTIVATION_CONTEXT ActivationContext = ActivationBlock->ActivationContext;

    if ((ActivationBlock->Flags & BASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_FREE_AFTER_CALLBACK) == 0) {
        BasepFreeActivationContextActivationBlock(ActivationBlock);
    }

    RtlActivateActivationContextUnsafeFast(&ActivationFrame, ActivationContext);
    __try {
        (*TimerAPCRoutine)(CallbackContext, TimerLowValue, TimerHighValue);
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&ActivationFrame);
    }
}

BOOL
WINAPI
SetWaitableTimer(
    HANDLE hTimer,
    const LARGE_INTEGER *lpDueTime,
    LONG lPeriod,
    PTIMERAPCROUTINE pfnCompletionRoutine,
    LPVOID lpArgToCompletionRoutine,
    BOOL fResume
    )
{
    NTSTATUS Status;
    PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK ActivationBlock = NULL;
    PTIMER_APC_ROUTINE TimerApcRoutine = (PTIMER_APC_ROUTINE) pfnCompletionRoutine;
    PVOID TimerApcContext = lpArgToCompletionRoutine;

    // If there's an APC routine to call and we have a non-default activation
    // context active for this thread, we need to allocate a little chunk of heap
    // to pass to the APC callback.
    if (pfnCompletionRoutine != NULL) {
        DWORD dwActivationBlockAllocationFlags = BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_ALLOCATE_IF_PROCESS_DEFAULT;

        // If it's a periodic timer, don't free the block until the timer is cancelled.
        if (lPeriod > 0)
            dwActivationBlockAllocationFlags |= BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_FREE_AFTER_CALLBACK;

        Status = BasepAllocateActivationContextActivationBlock(dwActivationBlockAllocationFlags, pfnCompletionRoutine, lpArgToCompletionRoutine, &ActivationBlock);
        if (!NT_SUCCESS(Status)) {
            BaseSetLastNTError(Status);
            return FALSE;
        }

        if (ActivationBlock != NULL) {
            TimerApcRoutine = &BasepTimerAPCProc;
            TimerApcContext = ActivationBlock;
        }
    }

    Status = NtSetTimer(
                hTimer,
                (PLARGE_INTEGER) lpDueTime,
                TimerApcRoutine,                // will be NULL if pfnCompletionRoutine was null
                TimerApcContext,
                (BOOLEAN) fResume,
                lPeriod,
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        if (ActivationBlock != NULL)
            BasepFreeActivationContextActivationBlock(ActivationBlock);
        BaseSetLastNTError(Status);
        return FALSE;
    } else {
        if ( Status == STATUS_TIMER_RESUME_IGNORED ) {
            SetLastError(ERROR_NOT_SUPPORTED);
        } else {
            SetLastError(ERROR_SUCCESS);
        }
        return TRUE;
    }
}

BOOL
WINAPI
CancelWaitableTimer(
    HANDLE hTimer
    )
{
    NTSTATUS Status;
    
    Status = NtCancelTimer(hTimer, NULL);
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    else {
        return TRUE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\support.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    support.c

Abstract:

    This module implements various conversion routines
    that transform Win32 parameters into NT parameters.

Author:

    Mark Lucovsky (markl) 20-Sep-1990

Revision History:

--*/

#include "basedll.h"
#if defined(BUILD_WOW6432)
#include "wow64reg.h"
#include <wow64t.h>
#endif

PCLDR_DATA_TABLE_ENTRY BasepExeLdrEntry = NULL;

// N.B. These are the registry values we check for SafeDllSearchMode,
//      and MUST match the entries in BasepDllSearchPaths
typedef enum {
    BasepCurrentDirUninitialized = -1,
    BasepCurrentDirAtStart       =  0,
    BasepCurrentDirAfterSystem32 =  1,
    MaxBasepCurrentDir
} BASEP_CURDIR_PLACEMENT;

#define BASEP_DEFAULT_DLL_CURDIR_PLACEMENT (BasepCurrentDirAfterSystem32)

#define BASEP_VALID_CURDIR_PLACEMENT_P(c) (BasepCurrentDirUninitialized < (c)  \
                                           && (c) < MaxBasepCurrentDir)

LONG BasepDllCurrentDirPlacement = BasepCurrentDirUninitialized;

typedef enum {
    BasepSearchPathEnd,         // end of path
    BasepSearchPathDlldir,      // use the dll dir; fallback to nothing
    BasepSearchPathAppdir,      // use the exe dir; fallback to base exe dir
    BasepSearchPathDefaultDirs, // use the default system dirs
    BasepSearchPathEnvPath,     // use %PATH%
    BasepSearchPathCurdir,      // use "."
    MaxBasepSearchPath
} BASEP_SEARCH_PATH_ELEMENT;

// N.B. The ordering of these must match the definitions for
//      BASEP_CURDIR_PLACEMENT.
static const BASEP_SEARCH_PATH_ELEMENT BasepDllSearchPaths[MaxBasepCurrentDir][7] = 
{
    {
        // BasepCurrentDirAtStart
        BasepSearchPathAppdir,
        BasepSearchPathCurdir,
        BasepSearchPathDefaultDirs,
        BasepSearchPathEnvPath,
        BasepSearchPathEnd
    },
    {
        // BasepCurrentDirAfterSystem32
        BasepSearchPathAppdir,
        BasepSearchPathDefaultDirs,
        BasepSearchPathCurdir,
        BasepSearchPathEnvPath,
        BasepSearchPathEnd
    }
};


POBJECT_ATTRIBUTES
BaseFormatObjectAttributes(
    OUT POBJECT_ATTRIBUTES ObjectAttributes,
    IN PSECURITY_ATTRIBUTES SecurityAttributes,
    IN PUNICODE_STRING ObjectName
    )

/*++

Routine Description:

    This function transforms a Win32 security attributes structure into
    an NT object attributes structure.  It returns the address of the
    resulting structure (or NULL if SecurityAttributes was not
    specified).

Arguments:

    ObjectAttributes - Returns an initialized NT object attributes
        structure that contains a superset of the information provided
        by the security attributes structure.

    SecurityAttributes - Supplies the address of a security attributes
        structure that needs to be transformed into an NT object
        attributes structure.

    ObjectName - Supplies a name for the object relative to the
        BaseNamedObjectDirectory object directory.

Return Value:

    NULL - A value of null should be used to mimic the behavior of the
        specified SecurityAttributes structure.

    NON-NULL - Returns the ObjectAttributes value.  The structure is
        properly initialized by this function.

--*/

{
    HANDLE RootDirectory;
    ULONG Attributes;
    PVOID SecurityDescriptor;

    if ( ARGUMENT_PRESENT(SecurityAttributes) ||
         ARGUMENT_PRESENT(ObjectName) ) {

        if ( SecurityAttributes ) {
            Attributes = (SecurityAttributes->bInheritHandle ? OBJ_INHERIT : 0);
            SecurityDescriptor = SecurityAttributes->lpSecurityDescriptor;
            }
        else {
            Attributes = 0;
            SecurityDescriptor = NULL;
            }

        if ( ARGUMENT_PRESENT(ObjectName) ) {
            Attributes |= OBJ_OPENIF;
            RootDirectory = BaseGetNamedObjectDirectory();
            }
        else {
            RootDirectory = NULL;
            }

        InitializeObjectAttributes(
            ObjectAttributes,
            ObjectName,
            Attributes,
            RootDirectory,
            SecurityDescriptor
            );
        return ObjectAttributes;
        }
    else {
        return NULL;
        }
}

PLARGE_INTEGER
BaseFormatTimeOut(
    OUT PLARGE_INTEGER TimeOut,
    IN DWORD Milliseconds
    )

/*++

Routine Description:

    This function translates a Win32 style timeout to an NT relative
    timeout value.

Arguments:

    TimeOut - Returns an initialized NT timeout value that is equivalent
         to the Milliseconds parameter.

    Milliseconds - Supplies the timeout value in milliseconds.  A value
         of -1 indicates indefinite timeout.

Return Value:


    NULL - A value of null should be used to mimic the behavior of the
        specified Milliseconds parameter.

    NON-NULL - Returns the TimeOut value.  The structure is properly
        initialized by this function.

--*/

{
    if ( (LONG) Milliseconds == -1 ) {
        return( NULL );
        }
    TimeOut->QuadPart = UInt32x32To64( Milliseconds, 10000 );
    TimeOut->QuadPart *= -1;
    return TimeOut;
}


NTSTATUS
BaseCreateStack(
    IN HANDLE Process,
    IN SIZE_T StackSize,
    IN SIZE_T MaximumStackSize,
    OUT PINITIAL_TEB InitialTeb
    )

/*++

Routine Description:

    This function creates a stack for the specified process.

Arguments:

    Process - Supplies a handle to the process that the stack will
        be allocated within.

    StackSize - An optional parameter, that if specified, supplies
        the initial commit size for the stack.

    MaximumStackSize - Supplies the maximum size for the new threads stack.
        If this parameter is not specified, then the reserve size of the
        current images stack descriptor is used.

    InitialTeb - Returns a populated InitialTeb that contains
        the stack size and limits.

Return Value:

    TRUE - A stack was successfully created.

    FALSE - The stack counld not be created.

--*/

{
    NTSTATUS Status;
    PCH Stack;
    BOOLEAN GuardPage;
    SIZE_T RegionSize;
    ULONG OldProtect;
    SIZE_T ImageStackSize, ImageStackCommit;
    PIMAGE_NT_HEADERS NtHeaders;
    PPEB Peb;
    ULONG PageSize;

    Peb = NtCurrentPeb();

    BaseStaticServerData = BASE_SHARED_SERVER_DATA;
    PageSize = BASE_SYSINFO.PageSize;

    //
    // If the stack size was not supplied, then use the sizes from the
    // image header.
    //

    NtHeaders = RtlImageNtHeader(Peb->ImageBaseAddress);
    if (!NtHeaders) {
        return STATUS_INVALID_IMAGE_FORMAT;
    }
    ImageStackSize = NtHeaders->OptionalHeader.SizeOfStackReserve;
    ImageStackCommit = NtHeaders->OptionalHeader.SizeOfStackCommit;

    if ( !MaximumStackSize ) {
        MaximumStackSize = ImageStackSize;
    }
    if (!StackSize) {
        StackSize = ImageStackCommit;
    }
    else {

        //
        // Now Compute how much additional stack space is to be
        // reserved.  This is done by...  If the StackSize is <=
        // Reserved size in the image, then reserve whatever the image
        // specifies.  Otherwise, round up to 1Mb.
        //

        if ( StackSize >= MaximumStackSize ) {
            MaximumStackSize = ROUND_UP(StackSize, (1024*1024));
        }
    }

    //
    // Align the stack size to a page boundry and the reserved size
    // to an allocation granularity boundry.
    //

    StackSize = ROUND_UP( StackSize, PageSize );

    MaximumStackSize = ROUND_UP(
                        MaximumStackSize,
                        BASE_SYSINFO.AllocationGranularity
                        );

    //
    // Enforce a minimal stack commit if there is a PEB setting
    // for this.
    //

    {
        SIZE_T MinimumStackCommit;

        MinimumStackCommit = NtCurrentPeb()->MinimumStackCommit;
        
        if (MinimumStackCommit != 0 && StackSize < MinimumStackCommit) {
            StackSize = MinimumStackCommit;
        }

        //
        // Recheck and realign reserve size
        //
        
        if ( StackSize >= MaximumStackSize ) {
            MaximumStackSize = ROUND_UP (StackSize, (1024*1024));
        }
    
        StackSize = ROUND_UP (StackSize, PageSize);
        MaximumStackSize = ROUND_UP (MaximumStackSize, BASE_SYSINFO.AllocationGranularity);
    }

#if !defined (_IA64_)

    //
    // Reserve address space for the stack
    //

    Stack = NULL;

    Status = NtAllocateVirtualMemory(
                Process,
                (PVOID *)&Stack,
                0,
                &MaximumStackSize,
                MEM_RESERVE,
                PAGE_READWRITE
                );
#else

    //
    // Take RseStack into consideration.
    // RSE stack has same size as memory stack, has same StackBase,
    // has a guard page at the end, and grows upwards towards higher
    // memory addresses
    //

    //
    // Reserve address space for the two stacks
    //
    {
        SIZE_T TotalStackSize = MaximumStackSize * 2;

        Stack = NULL;

        Status = NtAllocateVirtualMemory(
                    Process,
                    (PVOID *)&Stack,
                    0,
                    &TotalStackSize,
                    MEM_RESERVE,
                    PAGE_READWRITE
                    );
    }

#endif // IA64
    if ( !NT_SUCCESS( Status ) ) {
        return Status;
        }

    InitialTeb->OldInitialTeb.OldStackBase = NULL;
    InitialTeb->OldInitialTeb.OldStackLimit = NULL;
    InitialTeb->StackAllocationBase = Stack;
    InitialTeb->StackBase = Stack + MaximumStackSize;

#if defined (_IA64_)
    InitialTeb->OldInitialTeb.OldBStoreLimit = NULL;
#endif //IA64

    Stack += MaximumStackSize - StackSize;
    if (MaximumStackSize > StackSize) {
        Stack -= PageSize;
        StackSize += PageSize;
        GuardPage = TRUE;
        }
    else {
        GuardPage = FALSE;
        }

    //
    // Commit the initially valid portion of the stack
    //

#if !defined(_IA64_)

    Status = NtAllocateVirtualMemory(
                Process,
                (PVOID *)&Stack,
                0,
                &StackSize,
                MEM_COMMIT,
                PAGE_READWRITE
                );
#else
    {
	//
	// memory and rse stacks are expected to be contiguous
	// reserver virtual memory for both stack at once
	//
        SIZE_T NewCommittedStackSize = StackSize * 2;

        Status = NtAllocateVirtualMemory(
                    Process,
                    (PVOID *)&Stack,
                    0,
                    &NewCommittedStackSize,
                    MEM_COMMIT,
                    PAGE_READWRITE
                    );
    }

#endif //IA64

    if ( !NT_SUCCESS( Status ) ) {

        //
        // If the commit fails, then delete the address space for the stack
        //

        RegionSize = 0;
        NtFreeVirtualMemory(
            Process,
            (PVOID *)&Stack,
            &RegionSize,
            MEM_RELEASE
            );

        return Status;
        }

    InitialTeb->StackLimit = Stack;

#if defined(_IA64_)
    InitialTeb->BStoreLimit = Stack + 2 * StackSize;
#endif

    //
    // if we have space, create a guard page.
    //

    if (GuardPage) {
        RegionSize = PageSize;
        Status = NtProtectVirtualMemory(
                    Process,
                    (PVOID *)&Stack,
                    &RegionSize,
                    PAGE_GUARD | PAGE_READWRITE,
                    &OldProtect
                    );
        if ( !NT_SUCCESS( Status ) ) {
            return Status;
            }
        InitialTeb->StackLimit = (PVOID)((PUCHAR)InitialTeb->StackLimit + RegionSize);

#if defined(_IA64_)
	//
        // additional code to Create RSE stack guard page
        //
        Stack = ((PCH)InitialTeb->StackBase) + StackSize - PageSize;
        RegionSize = PageSize;
        Status = NtProtectVirtualMemory(
                    Process,
                    (PVOID *)&Stack,
                    &RegionSize,
                    PAGE_GUARD | PAGE_READWRITE,
                    &OldProtect
                    );
        if ( !NT_SUCCESS( Status ) ) {
            return Status;
            }
        InitialTeb->BStoreLimit = (PVOID)Stack;

#endif // IA64

        }

    return STATUS_SUCCESS;
}

VOID
BaseThreadStart(
    IN LPTHREAD_START_ROUTINE lpStartAddress,
    IN LPVOID lpParameter
    )

/*++

Routine Description:

    This function is called to start a Win32 thread. Its purpose
    is to call the thread, and if the thread returns, to terminate
    the thread and delete its stack.

Arguments:

    lpStartAddress - Supplies the starting address of the new thread.  The
        address is logically a procedure that never returns and that
        accepts a single 32-bit pointer argument.

    lpParameter - Supplies a single parameter value passed to the thread.

Return Value:

    None.

--*/

{
    try {

        //
        // test for fiber start or new thread
        //

        //
        // WARNING WARNING DO NOT CHANGE INIT OF NtTib.Version. There is
        // external code depending on this initialization !
        //
        if ( NtCurrentTeb()->NtTib.Version == OS2_VERSION ) {
            if ( !BaseRunningInServerProcess ) {
                CsrNewThread();
                }
            }
        ExitThread((lpStartAddress)(lpParameter));
        }
    except(UnhandledExceptionFilter( GetExceptionInformation() )) {
        if ( !BaseRunningInServerProcess ) {
            ExitProcess(GetExceptionCode());
            }
        else {
            ExitThread(GetExceptionCode());
            }
        }
}

VOID
BaseProcessStart(
    PPROCESS_START_ROUTINE lpStartAddress
    )

/*++

Routine Description:

    This function is called to start a Win32 process.  Its purpose is to
    call the initial thread of the process, and if the thread returns,
    to terminate the thread and delete its stack.

Arguments:

    lpStartAddress - Supplies the starting address of the new thread.  The
        address is logically a procedure that never returns.

Return Value:

    None.

--*/

{
    try {
#if defined(BUILD_WOW6432)
        void Report32bitAppLaunching ( );
        Report32bitAppLaunching ();
#endif 
        NtSetInformationThread( NtCurrentThread(),
                                ThreadQuerySetWin32StartAddress,
                                &lpStartAddress,
                                sizeof( lpStartAddress )
                              );
        ExitThread((lpStartAddress)());
        }
    except(UnhandledExceptionFilter( GetExceptionInformation() )) {
        if ( !BaseRunningInServerProcess ) {
            ExitProcess(GetExceptionCode());
            }
        else {
            ExitThread(GetExceptionCode());
            }
        }
}

VOID
BaseFreeStackAndTerminate(
    IN PVOID OldStack,
    IN DWORD ExitCode
    )

/*++

Routine Description:

    This API is called during thread termination to delete a thread's
    stack and then terminate.

Arguments:

    OldStack - Supplies the address of the stack to free.

    ExitCode - Supplies the termination status that the thread
        is to exit with.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    SIZE_T Zero;
    PVOID BaseAddress;

#if defined (WX86)
    PWX86TIB Wx86Tib;
    PTEB Teb;
#endif

    Zero = 0;
    BaseAddress = OldStack;

    Status = NtFreeVirtualMemory(
                NtCurrentProcess(),
                &BaseAddress,
                &Zero,
                MEM_RELEASE
                );
    ASSERT(NT_SUCCESS(Status));

#if defined (WX86)
    Teb = NtCurrentTeb();
    if (Teb && (Wx86Tib = Wx86CurrentTib())) {
        BaseAddress = Wx86Tib->DeallocationStack;
        Zero = 0;
        Status = NtFreeVirtualMemory(
                    NtCurrentProcess(),
                    &BaseAddress,
                    &Zero,
                    MEM_RELEASE
                    );
        ASSERT(NT_SUCCESS(Status));

        if (Teb->Wx86Thread.DeallocationCpu) {
            BaseAddress = Teb->Wx86Thread.DeallocationCpu;
            Zero = 0;
            Status = NtFreeVirtualMemory(
                        NtCurrentProcess(),
                        &BaseAddress,
                        &Zero,
                        MEM_RELEASE
                        );
            ASSERT(NT_SUCCESS(Status));
            }

        }
#endif

    //
    // Don't worry, no commenting precedent has been set by SteveWo.  this
    // comment was added by an innocent bystander.
    //
    // NtTerminateThread will return if this thread is the last one in
    // the process.  So ExitProcess will only be called if that is the
    // case.
    //

    NtTerminateThread(NULL,(NTSTATUS)ExitCode);
    ExitProcess(ExitCode);
}



#if defined(WX86) || defined(_AXP64_)

NTSTATUS
BaseCreateWx86Tib(
    HANDLE Process,
    HANDLE Thread,
    ULONG InitialPc,
    ULONG CommittedStackSize,
    ULONG MaximumStackSize,
    BOOLEAN EmulateInitialPc
    )

/*++

Routine Description:

    This API is called to create a Wx86Tib for Wx86 emulated threads

Arguments:


    Process  - Target Process

    Thread   - Target Thread


    Parameter - Supplies the thread's parameter.

    InitialPc - Supplies an initial program counter value.

    StackSize - BaseCreateStack parameters

    MaximumStackSize - BaseCreateStack parameters

    BOOLEAN

Return Value:

    NtStatus from mem allocations

--*/

{
    NTSTATUS Status;
    PTEB Teb;
    ULONG Size, SizeWx86Tib;
    PVOID   TargetWx86Tib;
    PIMAGE_NT_HEADERS NtHeaders;
    WX86TIB Wx86Tib;
    INITIAL_TEB InitialTeb;
    THREAD_BASIC_INFORMATION ThreadInfo;


    Status = NtQueryInformationThread(
                Thread,
                ThreadBasicInformation,
                &ThreadInfo,
                sizeof( ThreadInfo ),
                NULL
                );
    if (!NT_SUCCESS(Status)) {
        return Status;
        }

    Teb = ThreadInfo.TebBaseAddress;


    //
    // if stack size not supplied, get from current image
    //
    NtHeaders = RtlImageNtHeader(NtCurrentPeb()->ImageBaseAddress);
    if (!NtHeaders) {
        return STATUS_INVALID_IMAGE_FORMAT;
    }
    if (!MaximumStackSize) {
        MaximumStackSize = (ULONG)NtHeaders->OptionalHeader.SizeOfStackReserve;
    }
    if (!CommittedStackSize) {
        CommittedStackSize = (ULONG)NtHeaders->OptionalHeader.SizeOfStackCommit;
    }



    //
    // Increase stack size for Wx86Tib, which sits at the top of the stack.
    //

    //
    // x86 Borland C++ 4.1 (and perhaps other versions) Rudely assumes that
    // it can use the top of the stack. Even tho this is completly bogus,
    // leave some space on the top of the stack, to avoid problems.
    //
    SizeWx86Tib = sizeof(WX86TIB) + 16;

    SizeWx86Tib = ROUND_UP(SizeWx86Tib, sizeof(ULONG));
    Size = (ULONG)ROUND_UP_TO_PAGES(SizeWx86Tib + 4096);
    if (CommittedStackSize < 1024 * 1024) {  // 1 MB
        CommittedStackSize += Size;
        }
    if (MaximumStackSize < 1024 * 1024 * 16) {  // 10 MB
        MaximumStackSize += Size;
        }

    if (MaximumStackSize < 256 * 1024) {
        // Enforce a minimum stack size of 256k since the CPU emulator
        // grabs several pages of the x86 stack for itself
        MaximumStackSize = 256 * 1024;
    }

    Status = BaseCreateStack( Process,
                              CommittedStackSize,
                              MaximumStackSize,
                              &InitialTeb
                              );

    if (!NT_SUCCESS(Status)) {
        return Status;
        }


    //
    //  Fill in the Teb->Vdm with pWx86Tib
    //
    TargetWx86Tib = (PVOID)((ULONG_PTR)InitialTeb.StackBase - SizeWx86Tib);
    Status = NtWriteVirtualMemory(Process,
                                  &Teb->Vdm,
                                  &TargetWx86Tib,
                                  sizeof(TargetWx86Tib),
                                  NULL
                                  );


    if (NT_SUCCESS(Status)) {

        //
        // Write the initial Wx86Tib information
        //
        RtlZeroMemory(&Wx86Tib, sizeof(WX86TIB));
        Wx86Tib.Size = sizeof(WX86TIB);
        Wx86Tib.InitialPc = InitialPc;
        Wx86Tib.InitialSp = (ULONG)((ULONG_PTR)TargetWx86Tib);
        Wx86Tib.StackBase = (VOID * POINTER_32) InitialTeb.StackBase;
        Wx86Tib.StackLimit = (VOID * POINTER_32) InitialTeb.StackLimit;
        Wx86Tib.DeallocationStack = (VOID * POINTER_32) InitialTeb.StackAllocationBase;
        Wx86Tib.EmulateInitialPc = EmulateInitialPc;

        Status = NtWriteVirtualMemory(Process,
                                      TargetWx86Tib,
                                      &Wx86Tib,
                                      sizeof(WX86TIB),
                                      NULL
                                      );
        }


    if (!NT_SUCCESS(Status)) {
        BaseFreeThreadStack(Process, NULL, &InitialTeb);
        }


    return Status;
}


#endif


VOID
BaseFreeThreadStack(
     HANDLE hProcess,
     HANDLE hThread,
     PINITIAL_TEB InitialTeb
     )

/*++

Routine Description:

    Deletes a thread's stack

Arguments:

    Process - Target process

    Thread - Target thread OPTIONAL

    InitialTeb - stack paremeters


Return Value:

    VOID


--*/


{
   NTSTATUS Status;
   DWORD dwStackSize;
   SIZE_T stStackSize;
   PVOID BaseAddress;

   stStackSize = 0;
   dwStackSize = 0;
   BaseAddress = InitialTeb->StackAllocationBase;
   NtFreeVirtualMemory( hProcess,
                        &BaseAddress,
                        &stStackSize,
                        MEM_RELEASE
                        );

#if defined (WX86)

    if (hThread) {
        PTEB Teb;
        PWX86TIB pWx86Tib;
        WX86TIB Wx86Tib;
        THREAD_BASIC_INFORMATION ThreadInfo;

        Status = NtQueryInformationThread(
                    hThread,
                    ThreadBasicInformation,
                    &ThreadInfo,
                    sizeof( ThreadInfo ),
                    NULL
                    );

        Teb = ThreadInfo.TebBaseAddress;
        if (!NT_SUCCESS(Status) || !Teb) {
            return;
            }

        Status = NtReadVirtualMemory(
                    hProcess,
                    &Teb->Vdm,
                    &pWx86Tib,
                    sizeof(pWx86Tib),
                    NULL
                    );
        if (!NT_SUCCESS(Status) || !pWx86Tib) {
            return;
        }

        Status = NtReadVirtualMemory(
                    hProcess,
                    pWx86Tib,
                    &Wx86Tib,
                    sizeof(Wx86Tib),
                    NULL
                    );

        if (NT_SUCCESS(Status) && Wx86Tib.Size == sizeof(WX86TIB)) {

            // release the wx86tib stack
            dwStackSize = 0;
            stStackSize = 0;
            BaseAddress = Wx86Tib.DeallocationStack;
            NtFreeVirtualMemory(hProcess,
                                &BaseAddress,
                                &stStackSize,
                                MEM_RELEASE
                                );

            // set Teb->Vdm = NULL;
            dwStackSize = 0;
            Status = NtWriteVirtualMemory(
                        hProcess,
                        &Teb->Vdm,
                        &dwStackSize,
                        sizeof(pWx86Tib),
                        NULL
                        );
            }
        }
#endif

}

#if defined(BUILD_WOW6432)

typedef HANDLE (WINAPI* __imp_RegisterEventSourceWType) (HANDLE, PWCHAR );
typedef HANDLE (WINAPI* __imp_DeregisterEventSourceType) (HANDLE);
typedef HANDLE (WINAPI* __imp_ReportEventType)(
                        HANDLE hEventLog,       // handle to event log
                        WORD wType,             // event type
                        WORD wCategory,         // event category
                        DWORD dwEventID,        // event identifier
                        PVOID lpUserSid,        // user security identifier
                        WORD wNumStrings,       // number of strings to merge
                        DWORD dwDataSize,       // size of binary data
                        PWCHAR *lpStrings,      // array of strings to merge
                        LPVOID lpRawData        // binary data buffer
                        );


void 
Wow64LogMessageInEventLogger(
    PWCHAR *szMsg
    )

/*++

Routine Description:

    This function logs an event into the application log.

Arguments:

    szMsg - event-log message pointer. 

Return Value:

    None.
--*/

{

    HMODULE hMod;
    HANDLE h; 
    __imp_RegisterEventSourceWType __imp_RegisterEventSourceW;
    __imp_DeregisterEventSourceType __imp_DeregisterEventSource; 
    __imp_ReportEventType __imp_ReportEvent; 

    
    hMod =LoadLibraryW (L"advapi32.dll");

    if (hMod != NULL) {

        __imp_RegisterEventSourceW = (__imp_RegisterEventSourceWType)GetProcAddress (hMod, "RegisterEventSourceW");
        __imp_DeregisterEventSource = (__imp_DeregisterEventSourceType)GetProcAddress (hMod, "DeregisterEventSource");
        __imp_ReportEvent = (__imp_ReportEventType)GetProcAddress (hMod, "ReportEventW");

        if ((__imp_RegisterEventSourceW != NULL) &&
            (__imp_DeregisterEventSource != NULL) && 
            (__imp_ReportEvent != NULL)) {

            h = __imp_RegisterEventSourceW (NULL,  L"Wow64 Emulation Layer");
            
            if (h != NULL) {
 
                if (!__imp_ReportEvent (
                        h,                                      // event log handle 
                        EVENTLOG_INFORMATION_TYPE,              // EVENTLOG_WARNING_TYPE
                        0,                                      // category zero 
                        EVENT_WOW64_RUNNING32BIT_APPLICATION ,  // event identifier 
                        NULL,                                   // no user security identifier 
                        1,                                      // one substitution string 
                        0,                                      // no data 
                        szMsg,                                  // pointer to string array 
                        NULL)) {                                // pointer to data 
                        
                    DbgPrint ("Wow64-EventLog: Couldn't report event - %lx\n", GetLastError ());
                }
                
                __imp_DeregisterEventSource (h);  
            }
        }

        FreeLibrary (hMod);
    }
}

void
Report32bitAppLaunching ()
/*++

Routine Description:

      This routine is called whenever a 32-bit is launched on win64 (inside Wow64). It will
      check to see if application loggin is enabled, and if so, will log an event to the 
      application log.
      
Arguments:

    None.

Return Value:

    None.
--*/

{

    
    const static UNICODE_STRING KeyName = RTL_CONSTANT_STRING  (L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\wow64\\config");
    static UNICODE_STRING ValueName = RTL_CONSTANT_STRING  (L"LogAppLaunchingEvent");
    static OBJECT_ATTRIBUTES ObjA = RTL_CONSTANT_OBJECT_ATTRIBUTES (&KeyName, OBJ_CASE_INSENSITIVE);
    
    WCHAR Buffer [MAX_PATH];
    const PWCHAR Msg [2] = {Buffer, NULL};
    PWCHAR pAppName;
    HKEY  hKey;
    PUNICODE_STRING ImageName;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    NTSTATUS Status;
    PPEB Peb;
    PWSTR PtrToCopy;
    DWORD CopyLength;

    
    Status = NtOpenKey (&hKey, KEY_READ | KEY_WOW64_64KEY, &ObjA);

    if (NT_SUCCESS(Status)) {
        
        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
  
        Status = NtQueryValueKey(
                                hKey,
                                &ValueName,
                                KeyValuePartialInformation,
                                KeyValueInformation,
                                sizeof (Buffer),
                                &CopyLength
                                );
        NtClose (hKey);

        if ((NT_SUCCESS (Status)) && 
            (KeyValueInformation->Type == REG_DWORD) &&
            (KeyValueInformation->DataLength == sizeof (DWORD))) {

            if (*(LONG *)KeyValueInformation->Data == 0x1) {

                Peb = NtCurrentPeb ();
                PtrToCopy = NULL;

                if (Peb->ProcessParameters != NULL) {

                    ImageName = &Peb->ProcessParameters->ImagePathName;

                    ASSERT (ImageName->Buffer != NULL);
                    if (ImageName->Length > (sizeof (Buffer) - sizeof (UNICODE_NULL))) {
                        
                        CopyLength = (sizeof (Buffer) - sizeof (UNICODE_NULL));
                        PtrToCopy = (PWSTR)((PSTR)ImageName->Buffer + (ImageName->Length - sizeof (Buffer)) + sizeof (UNICODE_NULL));
                    } else {

                        CopyLength = ImageName->Length;
                        PtrToCopy = ImageName->Buffer;
                    }

                    if ( CopyLength){
                        RtlCopyMemory (Buffer, PtrToCopy, CopyLength);
                        Buffer [(CopyLength >> 1)] = UNICODE_NULL;
                    } else swprintf (Buffer, L"PID=%d",NtCurrentTeb()->ClientId.UniqueProcess);  
                }
                Wow64LogMessageInEventLogger ((PWCHAR *)Msg);
            }
        }
    }
}



typedef struct _ENVIRONMENT_THUNK_TABLE
{
    WCHAR *Native;

    WCHAR *X86;

    WCHAR *FakeName;

} ENVIRONMENT_THUNK_TABLE, *PENVIRONMENT_THUNK_TABLE;

ENVIRONMENT_THUNK_TABLE ProgramFilesEnvironment[] = 
{
    { 
        L"ProgramFiles", 
        L"ProgramFiles(x86)", 
        L"ProgramW6432" 
    },
    { 
        L"CommonProgramFiles", 
        L"CommonProgramFiles(x86)", 
        L"CommonProgramW6432" 
    },
    {
        L"PROCESSOR_ARCHITECTURE",
        L"PROCESSOR_ARCHITECTURE",
        L"PROCESSOR_ARCHITEW6432"
    }
};


NTSTATUS
Wow64pThunkEnvironmentVariables (
    IN OUT PVOID *Environment
    )

/*++

Routine Description:

    This routine is called when we are about to create a 64-bit process for
    a 32-bit process. It thunks back the ProgramFiles environment
    variables so that they point to the native directory.
    
    This routine must stay in sync with what's in \base\wow64\wow64\init.c.

Arguments:

    Environment - Address of pointer of environment variable to thunk.


Return Value:

    NTSTATUS.
--*/

{
    UNICODE_STRING Name, Value;
    WCHAR Buffer [ MAX_PATH ];
    NTSTATUS NtStatus;
    ULONG i=0;
    
    while (i < (sizeof(ProgramFilesEnvironment) / sizeof(ProgramFilesEnvironment[0]))) {

        RtlInitUnicodeString (&Name, ProgramFilesEnvironment[i].FakeName);

        Value.Length = 0;
        Value.MaximumLength = sizeof (Buffer);
        Value.Buffer = Buffer;
        
        NtStatus = RtlQueryEnvironmentVariable_U (*Environment,
                                                  &Name,
                                                  &Value                                                  
                                                  );

        if (NT_SUCCESS (NtStatus)) {

            RtlSetEnvironmentVariable (Environment,
                                       &Name,
                                       NULL
                                       );

            RtlInitUnicodeString (&Name, ProgramFilesEnvironment[i].Native);
            
            NtStatus = RtlSetEnvironmentVariable (Environment,
                                                  &Name,
                                                  &Value
                                                  );
        }
        
        if (!NT_SUCCESS (NtStatus)) {
            break;
        }
        i++;
    }

    return NtStatus;
}
#endif


BOOL
BasePushProcessParameters(
    DWORD dwFlags,
    HANDLE Process,
    PPEB NewPeb,
    LPCWSTR ApplicationPathName,
    LPCWSTR CurrentDirectory,
    LPCWSTR CommandLine,
    LPVOID Environment,
    LPSTARTUPINFOW lpStartupInfo,
    DWORD dwCreationFlags,
    BOOL bInheritHandles,
    DWORD dwSubsystem,
    PVOID pAppCompatData,
    DWORD cbAppCompatData
    )

/*++

Routine Description:

    This function allocates a process parameters record and
    formats it. The parameter record is then written into the
    address space of the specified process.

Arguments:

    dwFlags - bitmask of flags to affect the behavior of
        BasePushProcessParameters.

        BASE_PUSH_PROCESS_PARAMETERS_FLAG_APP_MANIFEST_PRESENT
            Set to indicate that an application manifest was found/used
            for the given executable.

    Process - Supplies a handle to the process that is to get the
        parameters.

    Peb - Supplies the address of the new processes PEB.

    ApplicationPathName - Supplies the application path name for the
        process.

    CurrentDirectory - Supplies an optional current directory for the
        process.  If not specified, then the current directory is used.

    CommandLine - Supplies a command line for the new process.

    Environment - Supplies an optional environment variable list for the
        process. If not specified, then the current processes arguments
        are passed.

    lpStartupInfo - Supplies the startup information for the processes
        main window.

    dwCreationFlags - Supplies creation flags for the process

    bInheritHandles - TRUE if child process inherited handles from parent

    dwSubsystem - if non-zero, then value will be stored in child process
        PEB.  Only non-zero for separate VDM applications, where the child
        process has NTVDM.EXE subsystem type, not the 16-bit application
        type, which is what we want.

    pAppCompatData   - data that is needed for appcompat backend
    cbAppCompatData  - data size in bytes

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation Failed.

--*/


{
    BOOL bStatus;
    UNICODE_STRING ImagePathName;
    UNICODE_STRING CommandLineString;
    UNICODE_STRING CurrentDirString;
    UNICODE_STRING DllPath;
    UNICODE_STRING WindowTitle;
    UNICODE_STRING DesktopInfo;
    UNICODE_STRING ShellInfo;
    UNICODE_STRING RuntimeInfo;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PRTL_USER_PROCESS_PARAMETERS ParametersInNewProcess;
    ULONG ParameterLength, EnvironmentLength;
    SIZE_T RegionSize;
    PWCHAR s;
    NTSTATUS Status;
    WCHAR FullPathBuffer[MAX_PATH+5];
    WCHAR *fp;
    DWORD Rvalue;
    LPWSTR DllPathData;
    LPVOID pAppCompatDataInNewProcess;
    BOOLEAN PebLocked = FALSE;
    PPEB Peb;

#if defined(BUILD_WOW6432)
    ULONG_PTR Peb32;
    PVOID TempEnvironment = NULL;
#endif

    
    Peb = NtCurrentPeb ();

    Rvalue = GetFullPathNameW(ApplicationPathName,MAX_PATH+4,FullPathBuffer,&fp);
    if ( Rvalue == 0 || Rvalue > MAX_PATH+4 ) {
        DllPathData = BaseComputeProcessDllPath( ApplicationPathName,
                                                 Environment);
        if (!DllPathData) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        RtlInitUnicodeString( &DllPath, DllPathData );
        RtlInitUnicodeString( &ImagePathName, ApplicationPathName );
    } else {
        DllPathData = BaseComputeProcessDllPath( FullPathBuffer,
                                                 Environment);
        if ( !DllPathData ) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        RtlInitUnicodeString( &DllPath, DllPathData );
        RtlInitUnicodeString( &ImagePathName, FullPathBuffer );
    }

    RtlInitUnicodeString( &CommandLineString, CommandLine );

    RtlInitUnicodeString( &CurrentDirString, CurrentDirectory );

    if ( lpStartupInfo->lpDesktop ) {
        RtlInitUnicodeString( &DesktopInfo, lpStartupInfo->lpDesktop );
    } else {
        RtlInitUnicodeString( &DesktopInfo, L"");
    }

    if ( lpStartupInfo->lpReserved ) {
        RtlInitUnicodeString( &ShellInfo, lpStartupInfo->lpReserved );
    } else {
        RtlInitUnicodeString( &ShellInfo, L"");
    }

    RuntimeInfo.Buffer = (PWSTR)lpStartupInfo->lpReserved2;
    RuntimeInfo.Length = lpStartupInfo->cbReserved2;
    RuntimeInfo.MaximumLength = RuntimeInfo.Length;

    if (NULL == pAppCompatData) {
        cbAppCompatData = 0;
    } 

    if ( lpStartupInfo->lpTitle ) {
        RtlInitUnicodeString( &WindowTitle, lpStartupInfo->lpTitle );
    } else {
        RtlInitUnicodeString( &WindowTitle, ApplicationPathName );
    }

    Status = RtlCreateProcessParameters( &ProcessParameters,
                                         &ImagePathName,
                                         &DllPath,
                                         (ARGUMENT_PRESENT(CurrentDirectory) ? &CurrentDirString : NULL),
                                         &CommandLineString,
                                         Environment,
                                         &WindowTitle,
                                         &DesktopInfo,
                                         &ShellInfo,
                                         &RuntimeInfo
                                       );

    if (!NT_SUCCESS( Status )) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if ( !bInheritHandles ) {
        ProcessParameters->CurrentDirectory.Handle = NULL;
    }

    try {
        if (Environment == NULL) {
            PebLocked = TRUE;
            RtlAcquirePebLock ();
            Environment = Peb->ProcessParameters->Environment;
        } else {
            Environment = ProcessParameters->Environment;
        }
        if (s = Environment) {
            while (s[0] != L'\0' || s[1] != L'\0') {
                s++;
            }
            s += 2;

            EnvironmentLength = (ULONG)((PUCHAR)s - (PUCHAR)Environment);

            ProcessParameters->Environment = NULL;
            RegionSize = EnvironmentLength;
            Status = NtAllocateVirtualMemory( Process,
                                              (PVOID *)&ProcessParameters->Environment,
                                              0,
                                              &RegionSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE
                                            );
            if ( !NT_SUCCESS( Status ) ) {
                BaseSetLastNTError(Status);
                bStatus = FALSE;
                leave;
            }

#if defined(BUILD_WOW6432)

            //
            // Let's try and thunk back some environment variables if we are about to
            // launch a 64-bit process
            //

            Status = NtQueryInformationProcess (Process,
                                                ProcessWow64Information,
                                                &Peb32,
                                                sizeof (Peb32),
                                                NULL
                                                );
            
            if (NT_SUCCESS (Status) && (Peb32 == 0)) {

                RegionSize = EnvironmentLength;
                
                Status = NtAllocateVirtualMemory (NtCurrentProcess(),
                                                  &TempEnvironment,
                                                  0,
                                                  &RegionSize,
                                                  MEM_COMMIT,
                                                  PAGE_READWRITE
                                                  );

                if (NT_SUCCESS (Status)) {
                    
                    try {
                        
                        RtlCopyMemory (TempEnvironment, 
                                       Environment,
                                       EnvironmentLength
                                       );
                    } except (EXCEPTION_EXECUTE_HANDLER) {
                        Status = GetExceptionCode ();
                    }

                    if (NT_SUCCESS (Status)) {
                        
                        //
                        // Thunk back special environment variables so that they won't be inherited 
                        // for 64-bit processes
                        //

                        Status = Wow64pThunkEnvironmentVariables (&TempEnvironment);

                        if (NT_SUCCESS (Status)) {
                            Environment = TempEnvironment;
                        }
                    }
                }
            }
#endif

            Status = NtWriteVirtualMemory( Process,
                                           ProcessParameters->Environment,
                                           Environment,
                                           EnvironmentLength,
                                           NULL
                                         );

            if (PebLocked) {
                RtlReleasePebLock ();
                PebLocked = FALSE;
            }

#if defined(BUILD_WOW6432)            
            
            if (TempEnvironment != NULL) {
                
                RegionSize = 0;
                NtFreeVirtualMemory(NtCurrentProcess(),
                                    &TempEnvironment,
                                    &RegionSize,
                                    MEM_RELEASE
                                    );
            }
#endif

            if ( !NT_SUCCESS( Status ) ) {
                BaseSetLastNTError(Status);
                bStatus = FALSE;
                leave;
            }
        }

        //
        // Push the parameters into the new process
        //

        ProcessParameters->StartingX       = lpStartupInfo->dwX;
        ProcessParameters->StartingY       = lpStartupInfo->dwY;
        ProcessParameters->CountX          = lpStartupInfo->dwXSize;
        ProcessParameters->CountY          = lpStartupInfo->dwYSize;
        ProcessParameters->CountCharsX     = lpStartupInfo->dwXCountChars;
        ProcessParameters->CountCharsY     = lpStartupInfo->dwYCountChars;
        ProcessParameters->FillAttribute   = lpStartupInfo->dwFillAttribute;
        ProcessParameters->WindowFlags     = lpStartupInfo->dwFlags;
        ProcessParameters->ShowWindowFlags = lpStartupInfo->wShowWindow;

        if (lpStartupInfo->dwFlags & (STARTF_USESTDHANDLES | STARTF_USEHOTKEY | STARTF_HASSHELLDATA)) {
            ProcessParameters->StandardInput = lpStartupInfo->hStdInput;
            ProcessParameters->StandardOutput = lpStartupInfo->hStdOutput;
            ProcessParameters->StandardError = lpStartupInfo->hStdError;
        }

        if (dwCreationFlags & DETACHED_PROCESS) {
            ProcessParameters->ConsoleHandle = (HANDLE)CONSOLE_DETACHED_PROCESS;
        } else if (dwCreationFlags & CREATE_NEW_CONSOLE) {
            ProcessParameters->ConsoleHandle = (HANDLE)CONSOLE_NEW_CONSOLE;
        } else if (dwCreationFlags & CREATE_NO_WINDOW) {
            ProcessParameters->ConsoleHandle = (HANDLE)CONSOLE_CREATE_NO_WINDOW;
        } else {
            ProcessParameters->ConsoleHandle = Peb->ProcessParameters->ConsoleHandle;
            if (!(lpStartupInfo->dwFlags & (STARTF_USESTDHANDLES | STARTF_USEHOTKEY | STARTF_HASSHELLDATA))) {
                if (bInheritHandles ||
                    CONSOLE_HANDLE( Peb->ProcessParameters->StandardInput )
                   ) {
                    ProcessParameters->StandardInput =
                        Peb->ProcessParameters->StandardInput;
                }
                if (bInheritHandles ||
                    CONSOLE_HANDLE( Peb->ProcessParameters->StandardOutput )
                   ) {
                    ProcessParameters->StandardOutput =
                        Peb->ProcessParameters->StandardOutput;
                }
                if (bInheritHandles ||
                    CONSOLE_HANDLE( Peb->ProcessParameters->StandardError )
                   ) {
                    ProcessParameters->StandardError =
                        Peb->ProcessParameters->StandardError;
                }
            }
        }

        //
        // CREATE_NEW_PROCESS_GROUP, in the absence of CREATE_NEW_CONSOLE,
        // means that CTRL+C events should be ignored. This is solely for
        // appcompat.
        //
        if ((dwCreationFlags & CREATE_NEW_PROCESS_GROUP) != 0 &&
            (dwCreationFlags & CREATE_NEW_CONSOLE) == 0) {
            ProcessParameters->ConsoleFlags |= CONSOLE_IGNORE_CTRL_C;
        }

        ProcessParameters->Flags |=
            (Peb->ProcessParameters->Flags & RTL_USER_PROC_DISABLE_HEAP_DECOMMIT);
        ParameterLength = ProcessParameters->Length;

        if (dwFlags & BASE_PUSH_PROCESS_PARAMETERS_FLAG_APP_MANIFEST_PRESENT)
            ProcessParameters->Flags |= RTL_USER_PROC_APP_MANIFEST_PRESENT;

        //
        // Allocate memory in the new process to push the parameters
        //

        ParametersInNewProcess = NULL;
        RegionSize = ParameterLength;
        Status = NtAllocateVirtualMemory(
                    Process,
                    (PVOID *)&ParametersInNewProcess,
                    0,
                    &RegionSize,
                    MEM_COMMIT,
                    PAGE_READWRITE
                    );
        ParameterLength = (ULONG)RegionSize;
        if ( !NT_SUCCESS( Status ) ) {
            BaseSetLastNTError(Status);
            bStatus = FALSE;
            leave;
        }
        ProcessParameters->MaximumLength = ParameterLength;

        if ( dwCreationFlags & PROFILE_USER ) {
            ProcessParameters->Flags |= RTL_USER_PROC_PROFILE_USER;
        }

        if ( dwCreationFlags & PROFILE_KERNEL ) {
            ProcessParameters->Flags |= RTL_USER_PROC_PROFILE_KERNEL;
        }

        if ( dwCreationFlags & PROFILE_SERVER ) {
            ProcessParameters->Flags |= RTL_USER_PROC_PROFILE_SERVER;
        }

        //
        // Push the parameters
        //

        Status = NtWriteVirtualMemory(
                    Process,
                    ParametersInNewProcess,
                    ProcessParameters,
                    ProcessParameters->Length,
                    NULL
                    );
        if ( !NT_SUCCESS( Status ) ) {
            BaseSetLastNTError(Status);
            bStatus = FALSE;
            leave;
        }

        //
        // Make the processes PEB point to the parameters.
        //

        Status = NtWriteVirtualMemory(
                    Process,
                    &NewPeb->ProcessParameters,
                    &ParametersInNewProcess,
                    sizeof( ParametersInNewProcess ),
                    NULL
                    );
        if ( !NT_SUCCESS( Status ) ) {
            BaseSetLastNTError(Status);
            bStatus = FALSE;
            leave;
        }

        
        // 
        // allocate and write appcompat data for the new process
        //
        
        pAppCompatDataInNewProcess = NULL;
        if ( NULL != pAppCompatData ) {
            RegionSize = cbAppCompatData;
            Status = NtAllocateVirtualMemory(
                        Process,
                        (PVOID*)&pAppCompatDataInNewProcess,
                        0,
                        &RegionSize,
                        MEM_COMMIT,
                        PAGE_READWRITE
                        );
            if ( !NT_SUCCESS( Status ) ) {
                BaseSetLastNTError(Status);
                bStatus = FALSE;
                leave;
            }

            //
            // write the data itself
            //
            Status = NtWriteVirtualMemory(
                        Process,
                        pAppCompatDataInNewProcess,
                        pAppCompatData,
                        cbAppCompatData,
                        NULL
                        );
                        
            if ( !NT_SUCCESS( Status ) ) {
                BaseSetLastNTError(Status);
                bStatus = FALSE;
                leave;
            }
        }

        // 
        // save the pointer to appcompat data in peb 
        //
        Status = NtWriteVirtualMemory(
                    Process,
                    &NewPeb->pShimData,
                    &pAppCompatDataInNewProcess,
                    sizeof( pAppCompatDataInNewProcess ),
                    NULL
                    );
        if ( !NT_SUCCESS( Status ) ) {
            BaseSetLastNTError(Status);
            bStatus = FALSE;
            leave;
        }
                    


        //
        // Set subsystem type in PEB if requested by caller.  Ignore error
        //

        if (dwSubsystem != 0) {
            NtWriteVirtualMemory(
               Process,
               &NewPeb->ImageSubsystem,
               &dwSubsystem,
               sizeof( NewPeb->ImageSubsystem ),
               NULL
               );
        }
        bStatus = TRUE;
    } finally {
        if (PebLocked) {
            RtlReleasePebLock ();
        }
        RtlFreeHeap (RtlProcessHeap(), 0,DllPath.Buffer);
        if ( ProcessParameters ) {
            RtlDestroyProcessParameters(ProcessParameters);
        }
    }

    return bStatus;
}

LPCWSTR
BasepEndOfDirName(
    IN LPCWSTR FileName
    )
{
    LPCWSTR FileNameEnd,
            FileNameFirstWhack = wcschr(FileName, L'\\');

    if (FileNameFirstWhack) {

        FileNameEnd = wcsrchr(FileNameFirstWhack, L'\\');
        ASSERT(FileNameEnd);

        if (FileNameEnd == FileNameFirstWhack)
            FileNameEnd++;

    } else {
        FileNameEnd = NULL;
    }

    return FileNameEnd;
}

VOID
BasepLocateExeLdrEntry(
    IN PCLDR_DATA_TABLE_ENTRY Entry,
    IN PVOID Context,
    IN OUT BOOLEAN *StopEnumeration
    )

/*++

Routine Description:

    This function is a LDR_LOADED_MODULE_ENUMBERATION_CALLBACK_FUNCTION
    which locates the exe's loader data table entry.

Arguments:

    Entry - the entry currently being enumerated.

    Context - the image base address (NtCurrentPeb()->ImageBaseAddress).

    StopEnumeration - used to stop the enumeration.

Return Value:

    None.  The exe's loader data table entry, if found, is stored in
    the global BasepExeLdrEntry.

--*/

{
    ASSERT(Entry);
    ASSERT(Context);
    ASSERT(StopEnumeration);

    if (BasepExeLdrEntry) {

        *StopEnumeration = TRUE;

    } else if (Entry->DllBase == Context) {

        BasepExeLdrEntry = Entry;
        *StopEnumeration = TRUE;

    }
}


LPWSTR
BasepComputeProcessPath(
    IN const BASEP_SEARCH_PATH_ELEMENT *Elements,
    IN LPCWSTR AppName,
    IN LPVOID  Environment
    )

/*++

Routine Description:

    This function computes a process path.

Arguments:

    Elements - The elements to build into a path.

    AppName - An optional argument that specifies the name of
              the application.  If this parameter is not specified,
              then the current application is used.

    Environment - Supplies the environment block to be used to calculate
        the path variable value.

Return Value:

    The return value is the value of the requested path.

--*/

{
    LPCWSTR        AppNameEnd;
    const BASEP_SEARCH_PATH_ELEMENT *Element;
    UNICODE_STRING EnvPath;
    LPWSTR         EnvPathBuffer = NULL;
    LPWSTR         PathBuffer = NULL,
                   PathCurrent;
    ULONG          PathLengthInBytes;
    NTSTATUS       Status = STATUS_SUCCESS;

    __try {

        // First, figure out how much space we'll need.
        PathLengthInBytes = 0;
        for (Element = Elements;
             *Element != BasepSearchPathEnd;
             Element++) {

            switch (*Element) {

            case BasepSearchPathCurdir:
                PathLengthInBytes += 2 * sizeof(UNICODE_NULL); // .;
                break;

            case BasepSearchPathDlldir:

                ASSERT(BaseDllDirectory.Buffer != NULL);

                PathLengthInBytes += BaseDllDirectory.Length;
                if (BaseDllDirectory.Length) {
                    PathLengthInBytes += sizeof(UNICODE_NULL);
                }

                break;

            case BasepSearchPathAppdir:

                if (AppName) {
                    // Try to use the passed-in appname
                    AppNameEnd = BasepEndOfDirName(AppName);
                }

                if (!AppName || !AppNameEnd) {

                    // We didn't have or were unable to use the passed-in
                    // appname -- so attempt to use the current exe's name

                    if (RtlGetPerThreadCurdir()
                        && RtlGetPerThreadCurdir()->ImageName) {

                        AppName = RtlGetPerThreadCurdir()->ImageName->Buffer;

                    } else {

                        BasepCheckExeLdrEntry();

                        if (BasepExeLdrEntry) {
                            AppName = BasepExeLdrEntry->FullDllName.Buffer;
                        }
                    }

                    if (AppName) {
                        AppNameEnd = BasepEndOfDirName(AppName);
                    }
                }

                if (AppName && AppNameEnd) {

                    // Either we had a passed-in appname which worked, or
                    // we found the current exe's name and that worked.
                    //
                    // AppNameEnd points to the end of the base of the exe
                    // name -- so the difference is the number of
                    // characters in the base name, and we add one for the
                    // trailing semicolon / NULL.

                    PathLengthInBytes += ((AppNameEnd - AppName + 1)
                                          * sizeof(UNICODE_NULL));
                }

                break;

            case BasepSearchPathDefaultDirs:
                ASSERT(! (BaseDefaultPath.Length & 1));

                // We don't need an extra UNICODE_NULL here -- baseinit.c
                // appends our trailing semicolon for us.

                PathLengthInBytes += BaseDefaultPath.Length;
                break;

            case BasepSearchPathEnvPath:

                if (! Environment) {
                    RtlAcquirePebLock();
                }

                __try {
                    EnvPath.MaximumLength = 0;
                
                    Status = RtlQueryEnvironmentVariable_U(Environment,
                                                           &BasePathVariableName,
                                                           &EnvPath);

                    if (Status == STATUS_BUFFER_TOO_SMALL) {

                        // Now that we know how much to allocate, attempt
                        // to alloc a buffer that's actually big enough.

                        EnvPath.MaximumLength = EnvPath.Length + sizeof(UNICODE_NULL);

                        EnvPathBuffer = RtlAllocateHeap(RtlProcessHeap(),
                                                        MAKE_TAG(TMP_TAG),
                                                        EnvPath.MaximumLength);
                        if (! EnvPathBuffer) {
                            Status = STATUS_NO_MEMORY;
                            __leave;
                        }

                        EnvPath.Buffer = EnvPathBuffer;

                        Status = RtlQueryEnvironmentVariable_U(Environment,
                                                               &BasePathVariableName,
                                                               &EnvPath);
                    }
                } __finally {
                    if (! Environment) {
                        RtlReleasePebLock();
                    }
                }

                if (Status == STATUS_VARIABLE_NOT_FOUND) {
                    EnvPath.Length = 0;
                    Status = STATUS_SUCCESS;
                } else if (! NT_SUCCESS(Status)) {
                    __leave;
                } else {
                    // The final tally is the length, in bytes, of whatever
                    // we're using for our path, plus a character for the
                    // trailing whack or NULL.
                    ASSERT(! (EnvPath.Length & 1));
                    PathLengthInBytes += EnvPath.Length + sizeof(UNICODE_NULL);
                }
                
                break;

            DEFAULT_UNREACHABLE;

            } // switch (*Element)
        } // foreach Element (Elements) -- size loop

        ASSERT(PathLengthInBytes > 0);
        ASSERT(! (PathLengthInBytes & 1));

        // Now we have the length, in bytes, of the buffer we'll need for
        // our path.  Time to allocate it...

        PathBuffer = RtlAllocateHeap(RtlProcessHeap(),
                                     MAKE_TAG(TMP_TAG),
                                     PathLengthInBytes);

        if (! PathBuffer) {
            Status = STATUS_NO_MEMORY;
            __leave;
        }

        // Now go through the loop again, this time appending onto the
        // PathBuffer.

        PathCurrent = PathBuffer;
    
        for (Element = Elements;
             *Element != BasepSearchPathEnd;
             Element++) {

            switch (*Element) {
            case BasepSearchPathCurdir:
                ASSERT(((PathCurrent - PathBuffer + 2)
                        * sizeof(UNICODE_NULL))
                       <= PathLengthInBytes);
                *PathCurrent++ = L'.';
                *PathCurrent++ = L';';
                break;

            case BasepSearchPathDlldir:
                if (BaseDllDirectory.Length) {
                    ASSERT((((PathCurrent - PathBuffer + 1)
                             * sizeof(UNICODE_NULL))
                            + BaseDllDirectory.Length)
                           <= PathLengthInBytes);
                    RtlCopyMemory(PathCurrent,
                                  BaseDllDirectory.Buffer,
                                  BaseDllDirectory.Length);

                    PathCurrent += (BaseDllDirectory.Length >> 1);
                    *PathCurrent++ = L';';
                }

                break;

            case BasepSearchPathAppdir:
                if (AppName && AppNameEnd) {
                    ASSERT(((PathCurrent - PathBuffer + 1
                             + (AppNameEnd - AppName))
                            * sizeof(UNICODE_NULL))
                           <= PathLengthInBytes);
                    RtlCopyMemory(PathCurrent,
                                  AppName,
                                  ((AppNameEnd - AppName)
                                   * sizeof(UNICODE_NULL)));
                    PathCurrent += AppNameEnd - AppName;
                    *PathCurrent++ = L';';
                }

                break;

            case BasepSearchPathDefaultDirs:
                ASSERT((((PathCurrent - PathBuffer)
                         * sizeof(UNICODE_NULL))
                        + BaseDefaultPath.Length)
                       <= PathLengthInBytes);
                RtlCopyMemory(PathCurrent,
                              BaseDefaultPath.Buffer,
                              BaseDefaultPath.Length);
                PathCurrent += (BaseDefaultPath.Length >> 1);

                // We don't need to add a semicolon here -- baseinit.c
                // appends our trailing semicolon for us.

                break;

            case BasepSearchPathEnvPath:
                if (EnvPath.Length) {
                    ASSERT((((PathCurrent - PathBuffer + 1)
                             * sizeof(UNICODE_NULL))
                            + EnvPath.Length)
                           <= PathLengthInBytes);
                    RtlCopyMemory(PathCurrent,
                                  EnvPath.Buffer,
                                  EnvPath.Length);
                    PathCurrent += (EnvPath.Length >> 1);
                    *PathCurrent++ = L';';
                }
                break;

            DEFAULT_UNREACHABLE;
            
            } // switch (*Element)
        } // foreach Element (Elements) -- append loop

        // At this point, PathCurrent points just beyond PathBuffer.
        // Let's assert that...
        ASSERT((PathCurrent - PathBuffer) * sizeof(UNICODE_NULL)
               == PathLengthInBytes);

        // ... and turn the final ';' into the string terminator.
        ASSERT(PathCurrent > PathBuffer);
        PathCurrent[-1] = UNICODE_NULL;

    } __finally {
        if (EnvPathBuffer) {
            RtlFreeHeap(RtlProcessHeap(),
                        0,
                        EnvPathBuffer);
        }

        if (PathBuffer
            && (AbnormalTermination()
                || ! NT_SUCCESS(Status))) {
            RtlFreeHeap(RtlProcessHeap(),
                        0,
                        PathBuffer);
            PathBuffer = NULL;
        }
    }

    return PathBuffer;
}

LPWSTR
BaseComputeProcessDllPath(
    IN LPCWSTR AppName,
    IN LPVOID  Environment
    )

/*++

Routine Description:

    This function computes a process DLL path.

Arguments:

    AppName - An optional argument that specifies the name of
        the application. If this parameter is not specified, then the
        current application is used.

    Environment - Supplies the environment block to be used to calculate
        the path variable value.

Return Value:

    The return value is the value of the processes DLL path.

--*/

{
    NTSTATUS          Status;
    HANDLE            Key;

    static UNICODE_STRING
        KeyName = RTL_CONSTANT_STRING(L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\Session Manager"),
        ValueName = RTL_CONSTANT_STRING(L"SafeDllSearchMode");

    static OBJECT_ATTRIBUTES
        ObjA = RTL_CONSTANT_OBJECT_ATTRIBUTES(&KeyName, OBJ_CASE_INSENSITIVE);
    
    CHAR              Buffer[FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)
                            + sizeof(DWORD)];
    PKEY_VALUE_PARTIAL_INFORMATION Info;
    ULONG             ResultLength;
    LONG              CurrentDirPlacement,
                      PrevCurrentDirPlacement;
    LPWSTR            Result;

    static const BASEP_SEARCH_PATH_ELEMENT DllDirSearchPath[] = {
        BasepSearchPathAppdir,
        BasepSearchPathDlldir,
        BasepSearchPathDefaultDirs,
        BasepSearchPathEnvPath,
        BasepSearchPathEnd
    };

    RtlEnterCriticalSection(&BaseDllDirectoryLock);
    if (BaseDllDirectory.Buffer) {
        Result = BasepComputeProcessPath(DllDirSearchPath,
                                         AppName,
                                         Environment);
        RtlLeaveCriticalSection(&BaseDllDirectoryLock);
        return Result;
    }
    RtlLeaveCriticalSection(&BaseDllDirectoryLock);

    CurrentDirPlacement = BasepDllCurrentDirPlacement;

    if (CurrentDirPlacement == BasepCurrentDirUninitialized) {

        Status = NtOpenKey(&Key,
                           KEY_QUERY_VALUE,
                           &ObjA);

        if (! NT_SUCCESS(Status)) {
            goto compute_path;
        }
    
        Info = (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;
        Status = NtQueryValueKey(Key,
                                 &ValueName,
                                 KeyValuePartialInformation,
                                 Info,
                                 sizeof(Buffer),
                                 &ResultLength);
        if (! NT_SUCCESS(Status)) {
            goto close_key;
        }

        if (ResultLength != sizeof(Buffer)) {
            goto close_key;
        }

        RtlCopyMemory(&CurrentDirPlacement,
                      Info->Data,
                      sizeof(DWORD));

  close_key:
        NtClose(Key);

  compute_path:
        if (! BASEP_VALID_CURDIR_PLACEMENT_P(CurrentDirPlacement)) {
            CurrentDirPlacement = BASEP_DEFAULT_DLL_CURDIR_PLACEMENT;
        }

        PrevCurrentDirPlacement = InterlockedCompareExchange(&BasepDllCurrentDirPlacement,
                                                             CurrentDirPlacement,
                                                             BasepCurrentDirUninitialized);
        
        if (PrevCurrentDirPlacement != BasepCurrentDirUninitialized) {
            CurrentDirPlacement = PrevCurrentDirPlacement;
        }
    }

    if (! BASEP_VALID_CURDIR_PLACEMENT_P(CurrentDirPlacement)) {
        CurrentDirPlacement = BASEP_DEFAULT_DLL_CURDIR_PLACEMENT;
    }

    return BasepComputeProcessPath(BasepDllSearchPaths[CurrentDirPlacement],
                                   AppName,
                                   Environment);
}

LPWSTR
BaseComputeProcessSearchPath(
    VOID
    )

/*++

Routine Description:

    This function computes a process search path.

Arguments:

    None

Return Value:

    The return value is the value of the processes search path.

--*/

{
    static const BASEP_SEARCH_PATH_ELEMENT SearchPath[] = {
        BasepSearchPathAppdir,
        BasepSearchPathCurdir,
        BasepSearchPathDefaultDirs,
        BasepSearchPathEnvPath,
        BasepSearchPathEnd
    };

    return BasepComputeProcessPath(SearchPath,
                                   NULL,
                                   NULL);
}

LPWSTR
BaseComputeProcessExePath(
    LPCWSTR ExeName
    )

/*++

Routine Description:

    This function computes a process exe path.

Arguments:

    ExeName - The name of the exe which will be looked for.

Return Value:

    The return value is the value of the processes exe path.

--*/

{
    static const BASEP_SEARCH_PATH_ELEMENT UseDotSearchPath[] = {
        BasepSearchPathAppdir,
        BasepSearchPathCurdir,
        BasepSearchPathDefaultDirs,
        BasepSearchPathEnvPath,
        BasepSearchPathEnd
    };

    static const BASEP_SEARCH_PATH_ELEMENT NoDotSearchPath[] = {
        BasepSearchPathAppdir,
        BasepSearchPathDefaultDirs,
        BasepSearchPathEnvPath,
        BasepSearchPathEnd
    };

    return BasepComputeProcessPath((NeedCurrentDirectoryForExePathW(ExeName)
                                    ? UseDotSearchPath
                                    : NoDotSearchPath),
                                   NULL,
                                   NULL);
}

PUNICODE_STRING
Basep8BitStringToStaticUnicodeString(
    IN LPCSTR lpSourceString
    )

/*++

Routine Description:

    Captures and converts a 8-bit (OEM or ANSI) string into the Teb Static
    Unicode String

Arguments:

    lpSourceString - string in OEM or ANSI

Return Value:

    Pointer to the Teb static string if conversion was successful, NULL
    otherwise.  If a failure occurred, the last error is set.

--*/

{
    PUNICODE_STRING StaticUnicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    //
    //  Get pointer to static per-thread string
    //

    StaticUnicode = &NtCurrentTeb()->StaticUnicodeString;

    //
    //  Convert input string into unicode string
    //

    Status = RtlInitAnsiStringEx( &AnsiString, lpSourceString );
    if( NT_SUCCESS(Status) ) {
        Status = Basep8BitStringToUnicodeString( StaticUnicode, &AnsiString, FALSE );
    } else {
        Status = STATUS_BUFFER_OVERFLOW;
    }

    //
    //  If we couldn't convert the string
    //

    if ( !NT_SUCCESS( Status ) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError( ERROR_FILENAME_EXCED_RANGE );
        } else {
            BaseSetLastNTError( Status );
        }
        return NULL;
    } else {
        return StaticUnicode;
    }
}

BOOL
Basep8BitStringToDynamicUnicodeString(
    OUT PUNICODE_STRING UnicodeString,
    IN LPCSTR lpSourceString
    )
/*++

Routine Description:

    Captures and converts a 8-bit (OEM or ANSI) string into a heap-allocated
    UNICODE string

Arguments:

    UnicodeString - location where UNICODE_STRING is stored

    lpSourceString - string in OEM or ANSI

Return Value:

    TRUE if string is correctly stored, FALSE if an error occurred.  In the
    error case, the last error is correctly set.

--*/

{
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    //
    //  Convert input into dynamic unicode string
    //

    Status = RtlInitAnsiStringEx( &AnsiString, lpSourceString );
    if( NT_SUCCESS(Status) ) {
        Status = Basep8BitStringToUnicodeString( UnicodeString, &AnsiString, TRUE );
    } else {
        Status = STATUS_BUFFER_OVERFLOW;
    }


    //
    //  If we couldn't do this, fail
    //

    if (!NT_SUCCESS( Status )){
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError( ERROR_FILENAME_EXCED_RANGE );
        } else {
            BaseSetLastNTError( Status );
        }
        return FALSE;
        }

    return TRUE;
}


//
//  Thunks for converting between ANSI/OEM and UNICODE
//

ULONG
BasepAnsiStringToUnicodeSize(
    PANSI_STRING AnsiString
    )
/*++

Routine Description:

    Determines the size of a UNICODE version of an ANSI string

Arguments:

    AnsiString - string to examine

Return Value:

    Byte size of UNICODE version of string including a trailing L'\0'.

--*/
{
    return RtlAnsiStringToUnicodeSize( AnsiString );
}



ULONG
BasepOemStringToUnicodeSize(
    PANSI_STRING OemString
    )
/*++

Routine Description:

    Determines the size of a UNICODE version of an OEM string

Arguments:

    OemString - string to examine

Return Value:

    Byte size of UNICODE version of string including a trailing L'\0'.

--*/
{
    return RtlOemStringToUnicodeSize( OemString );
}



ULONG
BasepUnicodeStringToOemSize(
    PUNICODE_STRING UnicodeString
    )
/*++

Routine Description:

    Determines the size of an OEM version of a UNICODE string

Arguments:

    UnicodeString - string to examine

Return Value:

    Byte size of OEM version of string including a trailing '\0'.

--*/
{
    return RtlUnicodeStringToOemSize( UnicodeString );
}



ULONG
BasepUnicodeStringToAnsiSize(
    PUNICODE_STRING UnicodeString
    )
/*++

Routine Description:

    Determines the size of an ANSI version of a UNICODE string

Arguments:

    UnicodeString - string to examine

Return Value:

    Byte size of ANSI version of string including a trailing '\0'.

--*/
{
    return RtlUnicodeStringToAnsiSize( UnicodeString );
}



typedef struct _BASEP_ACQUIRE_STATE {
    HANDLE Token;
    PTOKEN_PRIVILEGES OldPrivileges;
    PTOKEN_PRIVILEGES NewPrivileges;
    ULONG Revert;
    ULONG Spare;
    BYTE OldPrivBuffer[ 1024 ];
} BASEP_ACQUIRE_STATE, *PBASEP_ACQUIRE_STATE;


//
// This function does the correct thing - it checks for the thread token
// before opening the process token.
//


NTSTATUS
BasepAcquirePrivilegeEx(
    ULONG Privilege,
    PVOID *ReturnedState
    )
{
    PBASEP_ACQUIRE_STATE State;
    ULONG cbNeeded;
    LUID LuidPrivilege;
    NTSTATUS Status, Status1;
    BOOL St;

    //
    // Make sure we have access to adjust and to get the old token privileges
    //

    *ReturnedState = NULL;
    State = RtlAllocateHeap (RtlProcessHeap(),
                             MAKE_TAG( TMP_TAG ),
                             sizeof(BASEP_ACQUIRE_STATE) +
                             sizeof(TOKEN_PRIVILEGES) +
                                (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES));
    if (State == NULL) {
        return STATUS_NO_MEMORY;
    }

    State->Revert = 0;

    if (RtlIsImpersonating()) {
        //
        // We're impersonating.  So make sure we use the specified
        // impersonation token.
        //

        Status = NtOpenThreadToken (NtCurrentThread(),
                                    TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                    FALSE,
                                    &State->Token);
        if (! NT_SUCCESS(Status)) {
            RtlFreeHeap(RtlProcessHeap(), 0, State);
            return Status;
        }
    } else {
        //
        // We're not impersonating.  So make a copy of the process
        // token, and impersonate that, so that we're monkeying about
        // with our own privs instead of everyone's.
        //

        Status = RtlImpersonateSelf (SecurityDelegation);
        if (!NT_SUCCESS (Status)) {
            RtlFreeHeap (RtlProcessHeap(), 0, State);
            return Status;
        }
        Status = NtOpenThreadToken (NtCurrentThread(),
                                    TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                    FALSE,
                                    &State->Token);

        if (!NT_SUCCESS (Status)) {
            State->Token = NULL;
            Status1 = NtSetInformationThread (NtCurrentThread(),
                                              ThreadImpersonationToken,
                                              &State->Token,
                                              sizeof (State->Token));
            ASSERT (NT_SUCCESS (Status1));
            RtlFreeHeap( RtlProcessHeap(), 0, State );
            return Status;
        }

        State->Revert = 1;
    }

    State->NewPrivileges = (PTOKEN_PRIVILEGES)(State+1);
    State->OldPrivileges = (PTOKEN_PRIVILEGES)(State->OldPrivBuffer);

    //
    // Initialize the privilege adjustment structure
    //

    LuidPrivilege = RtlConvertUlongToLuid(Privilege);
    State->NewPrivileges->PrivilegeCount = 1;
    State->NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    State->NewPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the privilege
    //

    cbNeeded = sizeof( State->OldPrivBuffer );
    Status = NtAdjustPrivilegesToken (State->Token,
                                      FALSE,
                                      State->NewPrivileges,
                                      cbNeeded,
                                      State->OldPrivileges,
                                      &cbNeeded);



    if (Status == STATUS_BUFFER_TOO_SMALL) {
        State->OldPrivileges = RtlAllocateHeap (RtlProcessHeap(), MAKE_TAG( TMP_TAG ), cbNeeded);
        if (State->OldPrivileges  == NULL) {
            Status = STATUS_NO_MEMORY;
        } else {
            Status = NtAdjustPrivilegesToken (State->Token,
                                              FALSE,
                                              State->NewPrivileges,
                                              cbNeeded,
                                              State->OldPrivileges,
                                              &cbNeeded);
        }
    }

    //
    // STATUS_NOT_ALL_ASSIGNED means that the privilege isn't
    // in the token, so we can't proceed.
    //
    // This is a warning level status, so map it to an error status.
    //

    if (Status == STATUS_NOT_ALL_ASSIGNED) {
        Status = STATUS_PRIVILEGE_NOT_HELD;
    }


    if (!NT_SUCCESS( Status )) {
        if (State->OldPrivileges != (PTOKEN_PRIVILEGES)State->OldPrivBuffer) {
            RtlFreeHeap( RtlProcessHeap(), 0, State->OldPrivileges );
        }

        St = CloseHandle (State->Token);
        ASSERT (St);
        State->Token = NULL;
        if (State->Revert) {
            Status1 = NtSetInformationThread (NtCurrentThread(),
                                              ThreadImpersonationToken,
                                              &State->Token,
                                              sizeof (State->Token));
            ASSERT (NT_SUCCESS (Status1));
        }
        RtlFreeHeap( RtlProcessHeap(), 0, State );
        return Status;
    }

    *ReturnedState = State;
    return STATUS_SUCCESS;
}


VOID
BasepReleasePrivilege(
    PVOID StatePointer
    )
{
    BOOL St;
    NTSTATUS Status;
    PBASEP_ACQUIRE_STATE State = (PBASEP_ACQUIRE_STATE)StatePointer;

    if (!State->Revert) {
        NtAdjustPrivilegesToken (State->Token,
                                 FALSE,
                                 State->OldPrivileges,
                                 0,
                                 NULL,
                                 NULL);
    }

    if (State->OldPrivileges != (PTOKEN_PRIVILEGES)State->OldPrivBuffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, State->OldPrivileges );
    }

    St = CloseHandle( State->Token );
    ASSERT (St);

    State->Token = NULL;
    if (State->Revert) {
        Status = NtSetInformationThread (NtCurrentThread(),
                                         ThreadImpersonationToken,
                                         &State->Token,
                                         sizeof (State->Token));
        ASSERT (NT_SUCCESS (Status));
    }
    RtlFreeHeap( RtlProcessHeap(), 0, State );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\sxs.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sxs.c

Abstract:

    Side-by-side activation APIs for Win32

Author:

    Michael Grier (MGrier) 2/29/2000

Revision History:

    Jay Krell (a-JayK) June - July 2000
        factored/merged with sxs.c, source code duplication eliminated
        moved file opening out of csrss.exe to client process
        merged with MGrier: flag per added api struct field, assembly dir support

    Jon Wiswall (jonwis) Dec. 2000
        Moved code here from csrsxs.c to make csrsxs.c tiny and more in-line with general
          csrxxxx.c coding patterns, and to fix when we look in system32 vs. when
          we look in syswow64

    Jon Wiswall (jonwis) December 2000
        ACTCTX's that don't specify what resource ID they want now automagically
            search through the sources to find a resource type in the "actctx
            source."  This requires a gross EnumResourceNamesW call, after a
            stomach-churning LoadLibraryExW to load the object.

    Jay Krell (JayKrell) May 2001
        CreateActCtx now honors "administrative" override for .dlls. (foo.dll.2.manifest)
        (not) CreateActCtx now implements ACTCTX_FLAG_LIKE_CREATEPROCESS flag (foo.exe.manifest)

    Jay Krell (JayKrell) March 2002
        remove never finished, never used, dead ACTCTX_FLAG_LIKE_CREATEPROCESS code

    Jon Wiswall (jonwis) May 2002
        Change probing order to look for resources in PE's first and then look for
        foo.exe.manifest
--*/

#include "basedll.h"
#include <sxstypes.h>
#include "sxsapi.h"
#include "winuser.h"
#include "wow64t.h"
#include "ntwow64.h"

#if DBG
BOOLEAN DebugFilter_SxsTrace;
#endif

#define DPFLTR_LEVEL_STATUS(x) ((NT_SUCCESS(x) \
                                    || (x) == STATUS_OBJECT_NAME_NOT_FOUND    \
                                    || (x) == STATUS_RESOURCE_DATA_NOT_FOUND  \
                                    || (x) == STATUS_RESOURCE_TYPE_NOT_FOUND  \
                                    || (x) == STATUS_RESOURCE_NAME_NOT_FOUND  \
                                    || (x) == STATUS_RESOURCE_LANG_NOT_FOUND  \
                                    || (x) == STATUS_SXS_CANT_GEN_ACTCTX      \
                                    || (x) == STATUS_SXS_ASSEMBLY_NOT_FOUND   \
                                    || (x) == STATUS_NO_SUCH_FILE             \
                                    ) \
                                ? DPFLTR_TRACE_LEVEL : DPFLTR_ERROR_LEVEL)

#define ACTCTX_VALID_FLAGS \
    ( \
        ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID | \
        ACTCTX_FLAG_LANGID_VALID | \
        ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID | \
        ACTCTX_FLAG_RESOURCE_NAME_VALID | \
        ACTCTX_FLAG_SET_PROCESS_DEFAULT | \
        ACTCTX_FLAG_APPLICATION_NAME_VALID | \
        ACTCTX_FLAG_HMODULE_VALID \
    )

// This is the name for the manifest if we are given an assembly root directory but no manifest name is specified.
const WCHAR ManifestDefaultName[] = L"Application.Manifest";

#define MAXSIZE_T  (~(SIZE_T)0)

extern const UNICODE_STRING SxsManifestSuffix = RTL_CONSTANT_STRING(L".Manifest");
extern const UNICODE_STRING SxsPolicySuffix   = RTL_CONSTANT_STRING(L".Config");

#define MEDIUM_PATH (64)

#define IsSxsAcceptablePathType(x)  ((x == RtlPathTypeUncAbsolute) || (x == RtlPathTypeDriveAbsolute) || (x == RtlPathTypeLocalDevice))

VOID
BasepSxsOverrideStreamToMessageStream(
    IN  PCSXS_OVERRIDE_STREAM OverrideStream,
    OUT PBASE_MSG_SXS_STREAM  MessageStream
    );

HANDLE
WINAPI
CreateActCtxA(
    PCACTCTXA pParamsA
    )
{
    ACTCTXW ParamsW = {sizeof(ParamsW)};
    PUNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE ActivationContextHandle = INVALID_HANDLE_VALUE;
    UNICODE_STRING AssemblyDir = {0};
    WCHAR AssemblyDirBuffer[STATIC_UNICODE_BUFFER_LENGTH];
    ULONG_PTR MappedResourceName = 0;
    const PTEB Teb = NtCurrentTeb();

    if (pParamsA == NULL
        || !RTL_CONTAINS_FIELD(pParamsA, pParamsA->cbSize, lpSource)
        ) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() Null %p or size 0x%lx too small\n",
            __FUNCTION__,
            pParamsA,
            pParamsA->cbSize
            );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    ParamsW.dwFlags =  pParamsA->dwFlags;

    if (((ParamsW.dwFlags & ~ACTCTX_VALID_FLAGS) != 0) ||
        ((ParamsW.dwFlags & ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID) && !RTL_CONTAINS_FIELD(pParamsA, pParamsA->cbSize, wProcessorArchitecture)) ||
        ((ParamsW.dwFlags & ACTCTX_FLAG_LANGID_VALID) && !RTL_CONTAINS_FIELD(pParamsA, pParamsA->cbSize, wLangId)) ||
        ((ParamsW.dwFlags & ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID) && !RTL_CONTAINS_FIELD(pParamsA, pParamsA->cbSize, lpAssemblyDirectory)) ||
        ((ParamsW.dwFlags & ACTCTX_FLAG_RESOURCE_NAME_VALID) && !RTL_CONTAINS_FIELD(pParamsA, pParamsA->cbSize, lpResourceName)) ||
        ((ParamsW.dwFlags & ACTCTX_FLAG_APPLICATION_NAME_VALID) && !RTL_CONTAINS_FIELD(pParamsA, pParamsA->cbSize, lpApplicationName)) ||
        ((ParamsW.dwFlags & ACTCTX_FLAG_HMODULE_VALID) && !RTL_CONTAINS_FIELD(pParamsA, pParamsA->cbSize, hModule))) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() Bad flags/size 0x%lx/0x%lx\n",
            __FUNCTION__,
            pParamsA->dwFlags,
            pParamsA->cbSize);
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (pParamsA->lpSource != NULL) {
        UnicodeString = &Teb->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString, pParamsA->lpSource);
        Status = Basep8BitStringToUnicodeString(UnicodeString, &AnsiString, FALSE);
        if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_BUFFER_OVERFLOW) {
                Status = STATUS_NAME_TOO_LONG;
            }
            goto Exit;
        }
        ParamsW.lpSource = UnicodeString->Buffer;
    } else {
        if ((ParamsW.dwFlags & ACTCTX_FLAG_HMODULE_VALID) == 0) {
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        ParamsW.lpSource = NULL;
    }

    if (ParamsW.dwFlags & ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID) {
        ParamsW.wProcessorArchitecture = pParamsA->wProcessorArchitecture;
    }

    if (ParamsW.dwFlags & ACTCTX_FLAG_LANGID_VALID) {
        ParamsW.wLangId = pParamsA->wLangId;
    }

    if (ParamsW.dwFlags & ACTCTX_FLAG_HMODULE_VALID) {
        ParamsW.hModule = pParamsA->hModule;
    }

    if (ParamsW.dwFlags & ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID) {
        RtlInitAnsiString(&AnsiString, pParamsA->lpAssemblyDirectory);
        AssemblyDir.MaximumLength = sizeof(AssemblyDirBuffer);
        AssemblyDir.Buffer = AssemblyDirBuffer;

        Status = Basep8BitStringToUnicodeString(&AssemblyDir, &AnsiString, FALSE);

#if 0 // This is inconsistent. Two string ANSI APIs like MoveFileA are only
      // documented to support MAX_PATH. They actually support one of the strings
      // being unlimited, but let's stick to what is documented.
        if (Status == STATUS_BUFFER_OVERFLOW) {
            // Try again, this time with dynamic allocation
            Status = Basep8BitStringToUnicodeString(&AssemblyDir, &AnsiString, TRUE);
        }
#endif
        if (Status == STATUS_BUFFER_OVERFLOW) {
            Status = STATUS_NAME_TOO_LONG;
        }

        if (NT_ERROR(Status))
            goto Exit;

        ParamsW.lpAssemblyDirectory = AssemblyDir.Buffer;
    }

    if (ParamsW.dwFlags & ACTCTX_FLAG_RESOURCE_NAME_VALID) {
        MappedResourceName = BaseDllMapResourceIdA(pParamsA->lpResourceName);
        if (MappedResourceName == -1) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() BaseDllMapResourceIdA failed\n",
                __FUNCTION__);
            Status = Teb->LastStatusValue;
            goto Exit;
        }
        ParamsW.lpResourceName = (PCWSTR) MappedResourceName;
    }

    ActivationContextHandle = CreateActCtxW(&ParamsW);
    if (ActivationContextHandle == INVALID_HANDLE_VALUE) {
        Status = Teb->LastStatusValue;
    }
Exit:
    if (AssemblyDir.Buffer != NULL
        && AssemblyDir.Buffer != AssemblyDirBuffer) {
        RtlFreeUnicodeString(&AssemblyDir);
    }
    BaseDllFreeResourceId(MappedResourceName);
    if (ActivationContextHandle == INVALID_HANDLE_VALUE) {
        BaseSetLastNTError(Status);
    }
#if DBG
    if ( ActivationContextHandle == INVALID_HANDLE_VALUE ) {
        DbgPrintEx( DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status),
            "SXS: Exiting %s(%s, %p), Handle:%p, Status:0x%lx\n",
            __FUNCTION__,
            (pParamsA != NULL) ? pParamsA->lpSource : NULL,
            (pParamsA != NULL) ? pParamsA->lpResourceName : NULL,
            ActivationContextHandle,
            Status
        );
    }
#endif
    return ActivationContextHandle;
}

USHORT
BasepSxsGetProcessorArchitecture(
    VOID
    )
{
//
// Return the processor architecture of the currently executing code/process.
//
    USHORT Result;
#if defined(BUILD_WOW6432)
    Result = PROCESSOR_ARCHITECTURE_IA32_ON_WIN64;
#elif defined(_M_IX86)
    Result = PROCESSOR_ARCHITECTURE_INTEL;
#elif defined(_M_IA64)
    Result = PROCESSOR_ARCHITECTURE_IA64;
#elif defined(_M_AMD64)
    Result = PROCESSOR_ARCHITECTURE_AMD64;
#else
    static USHORT StaticResult;
    static BOOL   Inited = FALSE;
    if (!Inited) {
        SYSTEM_INFO SystemInfo;

        SystemInfo.wProcessorArchictecure = 0;
        GetSystemInfo(&SystemInfo);
        StaticResult = SystemInfo.wProcessorArchictecure;
        Inited = TRUE;
    }
    Result = StaticResult;
#endif
    return Result;
}

VOID
NTAPI
BasepSxsActivationContextNotification(
    IN ULONG NotificationType,
    IN PACTIVATION_CONTEXT ActivationContext,
    IN const VOID *ActivationContextData,
    IN PVOID NotificationContext,
    IN PVOID NotificationData,
    IN OUT PBOOLEAN DisableNotification
    )
{
    switch (NotificationType)
    {
    case ACTIVATION_CONTEXT_NOTIFICATION_DESTROY:
        RTL_SOFT_VERIFY(NT_SUCCESS(NtUnmapViewOfSection(NtCurrentProcess(), (PVOID) ActivationContextData)));
        break;

    default:
        // Otherwise, we don't need to see this notification ever again.
        *DisableNotification = TRUE;
        break;
    }
}

#if DBG
VOID
DbgPrintActCtx(
    PCSTR     FunctionPlus,
    PCACTCTXW ActCtx
    )
{
    // odd but correct
    if (NtQueryDebugFilterState(DPFLTR_SXS_ID, DPFLTR_INFO_LEVEL) != TRUE)
        return;

    DbgPrint("%s Flags 0x%08lx(%s%s%s%s%s%s%s%s)\n",
        FunctionPlus,
        ActCtx->dwFlags,
        (ActCtx->dwFlags & ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID ) ? " processor" : "",
        (ActCtx->dwFlags & ACTCTX_FLAG_LANGID_VALID                 ) ? " langid" : "",
        (ActCtx->dwFlags & ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID     ) ? " directory" : "",
        (ActCtx->dwFlags & ACTCTX_FLAG_RESOURCE_NAME_VALID          ) ? " resource" : "",
        (ActCtx->dwFlags & ACTCTX_FLAG_SET_PROCESS_DEFAULT          ) ? " setdefault" : "",
        (ActCtx->dwFlags & ACTCTX_FLAG_APPLICATION_NAME_VALID       ) ? " appname" : "",
        (ActCtx->dwFlags & ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF        ) ? " asmref" : "",
        (ActCtx->dwFlags & ACTCTX_FLAG_HMODULE_VALID                ) ? " hmodule" : ""
        );

    DbgPrint("%s Source %ls\n", FunctionPlus, ActCtx->lpSource);

    if (ActCtx->dwFlags & ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID)
        DbgPrint("%s ProcessorArchitecture 0x%08lx\n", FunctionPlus, ActCtx->wProcessorArchitecture);

    if (ActCtx->dwFlags & ACTCTX_FLAG_LANGID_VALID)
        DbgPrint("%s LangId 0x%08lx\n", FunctionPlus, ActCtx->wLangId);

    if (ActCtx->dwFlags & ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID)
        DbgPrint("%s AssemblyDirectory %ls\n", FunctionPlus, ActCtx->lpAssemblyDirectory);

    if (ActCtx->dwFlags & ACTCTX_FLAG_RESOURCE_NAME_VALID)
        DbgPrint("%s ResourceName %p (%Id)\n",  FunctionPlus, ActCtx->lpResourceName, (ULONG_PTR) ActCtx->lpResourceName);

    if (ActCtx->dwFlags & ACTCTX_FLAG_APPLICATION_NAME_VALID)
        DbgPrint("%s ApplicationName %ls\n",  FunctionPlus, ActCtx->lpApplicationName);

    if (ActCtx->dwFlags & ACTCTX_FLAG_HMODULE_VALID)
        DbgPrint("%s hModule = %p\n", FunctionPlus, ActCtx->hModule);

}
#endif

typedef struct EnumResParams {
    ULONG_PTR *MappedResourceName;
    BOOL FoundManifest;
    BOOL ErrorEncountered;
} EnumResParams;

BOOL CALLBACK
BasepSxsSuitableManifestCallback(
    HMODULE hModule,
    PCWSTR lpszType,
    PWSTR lpszName,
    LONG_PTR lParam
)
{
    EnumResParams *pParams = (EnumResParams*)lParam;
    BOOL fContinueEnumeration = FALSE;

#if DBG
    if (DebugFilter_SxsTrace)
        DbgPrintEx( DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL,
            "Sxs.c: %s(%p, %p, %p, %p)\n",
            __FUNCTION__, hModule, lpszType, lpszName, lParam
            );
#endif

    ASSERT((pParams != NULL) &&
           (!pParams->ErrorEncountered) &&
           (!pParams->FoundManifest) &&
           (pParams->MappedResourceName != NULL));

    ASSERT(lpszType == MAKEINTRESOURCEW(RT_MANIFEST));

    // Boo! Boooooo!
    if ((pParams == NULL) ||
        (pParams->ErrorEncountered) ||
        (pParams->FoundManifest) ||
        (pParams->MappedResourceName == NULL)) {
        // None of these should be able to happen except if there is a coding error in the caller
        // of EnumResourceNamesW() or in the code for EnumResourceNamesW().
        if (pParams != NULL)
            pParams->ErrorEncountered = TRUE;

        SetLastError(ERROR_INVALID_PARAMETER);
        fContinueEnumeration = FALSE;
        goto Exit;
    }

#if DBG
    if (DebugFilter_SxsTrace)
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "   Params (start): { ResName: *(%p) = %p, Found: %s, Error: %s }",
            pParams->MappedResourceName, pParams->MappedResourceName,
            pParams->FoundManifest ? "true" : "false",
            pParams->ErrorEncountered ? "true" : "false");
#endif

    if (lpszType == MAKEINTRESOURCEW(RT_MANIFEST)) {
        // We found one - we don't care about others
        *pParams->MappedResourceName = BaseDllMapResourceIdW(lpszName);
        pParams->FoundManifest = TRUE;
        fContinueEnumeration = FALSE;
        goto Exit;
    }

    // This should not be able to happen; we should only be called for
    // RT_MANIFEST resources, but in case it somehow does happen, go on to the
    // next one.
    fContinueEnumeration = TRUE;

Exit:

#if DBG
    if ((pParams != NULL) && (pParams->MappedResourceName))
        if (DebugFilter_SxsTrace)
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_TRACE_LEVEL,
                " Params (end): { ResName: *(%p) = %p, Found: %s, Error: %s }",
                pParams->MappedResourceName, pParams->MappedResourceName,
                pParams->FoundManifest ? "true" : "false",
                pParams->ErrorEncountered ? "true" : "false");
#endif

    return fContinueEnumeration;
}



NTSTATUS
BasepSxsFindSuitableManifestResourceFor(
    PCACTCTXW Params,
    ULONG_PTR *MappedResourceName,
    BOOL *FoundManifest
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    EnumResParams FinderParameters = { MappedResourceName, FALSE, FALSE };
    HMODULE hSourceItem = NULL;
    BOOL FreeSourceModule = FALSE;

    if (FoundManifest != NULL)
        *FoundManifest = FALSE;

    if (MappedResourceName != NULL)
        *MappedResourceName = 0;

    if ((FoundManifest == NULL) ||
        (MappedResourceName == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    //
    // General pattern - open Params->lpSource and attempt to find the first
    // resource with type == RT_MANIFEST (24).  Stuff its resource name into
    // MappedResourceName.
    //

    if (Params->dwFlags & ACTCTX_FLAG_HMODULE_VALID) {
        hSourceItem = Params->hModule;
        FreeSourceModule = FALSE;
    } else {
        //
        // Map the dll/exe/etc.  If this fails, then there's a good chance that the
        // thing isn't a dll or exe, so don't fail out, just indicate that no manifest
        // was found.
        //
        hSourceItem = LoadLibraryExW(Params->lpSource, NULL, LOAD_LIBRARY_AS_DATAFILE);
        if ((hSourceItem == NULL) || (hSourceItem == INVALID_HANDLE_VALUE)) {
            Status = NtCurrentTeb()->LastStatusValue;
            goto Exit;
        }

        FreeSourceModule = TRUE;
    }

    //
    // If this fails with something other than ERROR_RESOURCE_TYPE_NOT_FOUND
    // then we're in an interesting state.
    //
    if (!EnumResourceNamesW(
            hSourceItem,
            MAKEINTRESOURCEW(RT_MANIFEST),
            &BasepSxsSuitableManifestCallback,
            (LONG_PTR) &FinderParameters)) {
        DWORD dwError = GetLastError();
        if ((dwError != ERROR_SUCCESS) && (dwError != ERROR_RESOURCE_TYPE_NOT_FOUND)) {
            Status = NtCurrentTeb()->LastStatusValue;
            goto Exit;
        }
    }

#if DBG
    if (DebugFilter_SxsTrace && FreeSourceModule && *MappedResourceName != 0) {
        // Debugging code for mgrier to see what DLLs we're actually using the enum pattern for.
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "SXS: Found resource %d in %ls (process %wZ) by enumeration\n",
            (INT) *MappedResourceName,
            Params->lpSource,
            &NtCurrentPeb()->ProcessParameters->ImagePathName);
    }
#endif

    Status = STATUS_SUCCESS;
Exit:
    if ((hSourceItem != NULL) &&
        (hSourceItem != INVALID_HANDLE_VALUE) &&
        (FreeSourceModule))
        FreeLibrary(hSourceItem);

    return Status;
}

HANDLE
WINAPI
CreateActCtxW(
    PCACTCTXW pParamsW
    )
{
    HANDLE ActivationContextHandle = INVALID_HANDLE_VALUE;
    NTSTATUS Status = STATUS_SUCCESS;
    ACTCTXW Params = { sizeof(Params) };
    ULONG_PTR MappedResourceName = 0;
    PVOID ActivationContextData = NULL;
    // lpTempSourcePath is used to hold a pointer to the source path if it needs to be created
    // in this function. It should be freed before leaving the function.
    LPWSTR lpTempSourcePath = NULL;
    PPEB Peb = NULL;
    RTL_UNICODE_STRING_BUFFER AssemblyDirectoryFromSourceBuffer = { 0 };
    RTL_UNICODE_STRING_BUFFER SourceBuffer = { 0 };
    RTL_UNICODE_STRING_BUFFER ApplicationNameManifest = { 0 };
    UCHAR StaticBuffer[256];
    UCHAR SourceStaticBuffer[256];
    UCHAR ApplicationNameStaticBuffer[128];
    BOOLEAN PebLockAcquired = FALSE;
    ULONG BasepCreateActCtxFlags = 0;

#if DBG
    DebugFilter_SxsTrace = (NtQueryDebugFilterState(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL) == TRUE);

    DbgPrintActCtx(__FUNCTION__ " before munging", pParamsW);
#endif

    if ((pParamsW == NULL) ||
        !RTL_CONTAINS_FIELD(pParamsW, pParamsW->cbSize, lpSource)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() Null %p or size 0x%lx too small\n",
            __FUNCTION__,
            pParamsW,
            pParamsW->cbSize
            );
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Params.dwFlags =  pParamsW->dwFlags;

    if ((Params.dwFlags & ~ACTCTX_VALID_FLAGS) ||
        ((Params.dwFlags & ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID) && !RTL_CONTAINS_FIELD(pParamsW, pParamsW->cbSize, wProcessorArchitecture)) ||
        ((Params.dwFlags & ACTCTX_FLAG_LANGID_VALID) && !RTL_CONTAINS_FIELD(pParamsW, pParamsW->cbSize, wLangId)) ||
        ((Params.dwFlags & ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID) && !RTL_CONTAINS_FIELD(pParamsW, pParamsW->cbSize, lpAssemblyDirectory)) ||
        ((Params.dwFlags & ACTCTX_FLAG_RESOURCE_NAME_VALID) && !RTL_CONTAINS_FIELD(pParamsW, pParamsW->cbSize, lpResourceName)) ||
        ((Params.dwFlags & ACTCTX_FLAG_APPLICATION_NAME_VALID) && !RTL_CONTAINS_FIELD(pParamsW, pParamsW->cbSize, lpApplicationName)) ||
        ((Params.dwFlags & ACTCTX_FLAG_HMODULE_VALID) && !RTL_CONTAINS_FIELD(pParamsW, pParamsW->cbSize, hModule))) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() Bad flags/size 0x%lx/0x%lx\n",
            __FUNCTION__,
            pParamsW->dwFlags,
            pParamsW->cbSize);
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (Params.dwFlags & ACTCTX_FLAG_SET_PROCESS_DEFAULT) {
        Peb = NtCurrentPeb();
        if (Peb->ActivationContextData != NULL) {
            Status = STATUS_SXS_PROCESS_DEFAULT_ALREADY_SET;
            goto Exit;
        }
    }

    Params.lpSource = pParamsW->lpSource;

    // We need at least either a source path or an HMODULE.
    if ((Params.lpSource == NULL) &&
        ((Params.dwFlags & ACTCTX_FLAG_HMODULE_VALID) == 0) &&
        ((Params.dwFlags & ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID) == 0)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if (Params.dwFlags & ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID) {
        USHORT wProcessorArchitecture = pParamsW->wProcessorArchitecture;
#if defined(BUILD_WOW6432)
        if (wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
            wProcessorArchitecture = PROCESSOR_ARCHITECTURE_IA32_ON_WIN64;
#endif

        if ((wProcessorArchitecture != PROCESSOR_ARCHITECTURE_UNKNOWN) &&
            (wProcessorArchitecture != BasepSxsGetProcessorArchitecture())) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() bad wProcessorArchitecture 0x%x\n",
                __FUNCTION__,
                pParamsW->wProcessorArchitecture);
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
        Params.wProcessorArchitecture = wProcessorArchitecture;
    } else {
        Params.wProcessorArchitecture = BasepSxsGetProcessorArchitecture();
        Params.dwFlags |= ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID;
    }

    if (Params.dwFlags & ACTCTX_FLAG_LANGID_VALID) {
        Params.wLangId = pParamsW->wLangId;
    } else {
        Params.wLangId = GetUserDefaultUILanguage();
        Params.dwFlags |= ACTCTX_FLAG_LANGID_VALID;
    }

    if (Params.dwFlags & ACTCTX_FLAG_HMODULE_VALID)
        Params.hModule = pParamsW->hModule;

    if (Params.dwFlags & ACTCTX_FLAG_APPLICATION_NAME_VALID)
        Params.lpApplicationName = pParamsW->lpApplicationName;

    // If the assembly root dir is specified, then the valid values for lpSource are
    // NULL - This implies that we look for a file called "application.manifest" in the assembly root dir.
    // Relative FilePath - if lpSource is relative then we combine it with the assembly root dir to get the path.
    // Absolute path - used unmodified.

    Params.lpAssemblyDirectory = pParamsW->lpAssemblyDirectory;

    if (Params.dwFlags & ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID) {
        RTL_PATH_TYPE AssemblyPathType;
        RTL_PATH_TYPE SourcePathType;
         // if this is true, implies we will make the source path from the assembly dir.
        BOOL MakeSourcePath = FALSE ;
        LPCWSTR RelativePath = NULL;

        if ((Params.lpAssemblyDirectory == NULL) ||
            (Params.lpAssemblyDirectory[0] == 0)) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() Bad lpAssemblyDirectory %ls\n",
                __FUNCTION__,
                Params.lpAssemblyDirectory);
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
        // Next check that the assembly dir is an absolute file name.
        AssemblyPathType = RtlDetermineDosPathNameType_U(Params.lpAssemblyDirectory);
        if (!IsSxsAcceptablePathType(AssemblyPathType)) {
#if DBG
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() Bad lpAssemblyDirectory PathType %ls, 0x%lx\n",
                __FUNCTION__,
                Params.lpAssemblyDirectory,
                (LONG) AssemblyPathType);
#endif
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        if (Params.lpSource != NULL) {
            SourcePathType = RtlDetermineDosPathNameType_U(Params.lpSource);
            if (IsSxsAcceptablePathType(SourcePathType)){
                MakeSourcePath = FALSE ; // We don't need to mess with lpSource in this case.
            } else if ( SourcePathType == RtlPathTypeRelative ) {
                MakeSourcePath = TRUE ;
                RelativePath = Params.lpSource;
            } else {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_ERROR_LEVEL,
                    "SXS: %s() Bad lpSource PathType %ls, 0x%lx\n",
                    __FUNCTION__,
                    Params.lpSource,
                    (LONG)SourcePathType);
                Status = STATUS_INVALID_PARAMETER;
                goto Exit;
            }
        }
        else {
            MakeSourcePath = TRUE;

            // If they told us an application name, then try using it instead. There's no
            // validation done here, as we'll just fail later on with a 'bad path' error
            // if the application name is invalid.
            if (Params.dwFlags & ACTCTX_FLAG_APPLICATION_NAME_VALID) {

                UNICODE_STRING TempBuffer;

                if ((Params.lpApplicationName == NULL) || 
                    (Params.lpApplicationName[0] == UNICODE_NULL)) {
                    DbgPrintEx(
                        DPFLTR_SXS_ID,
                        DPFLTR_ERROR_LEVEL,
                        "SXS: %s() Bad lpApplication name '%ls'\n",
                        __FUNCTION__,
                        Params.lpApplicationName);
                    Status = STATUS_INVALID_PARAMETER;
                    goto Exit;
                }

                RtlInitUnicodeString(&TempBuffer, Params.lpApplicationName);
                RtlInitUnicodeStringBuffer(&ApplicationNameManifest, ApplicationNameStaticBuffer, sizeof(ApplicationNameStaticBuffer));
                
                Status = RtlAssignUnicodeStringBuffer(&ApplicationNameManifest, &TempBuffer);
                if (!NT_SUCCESS(Status)) {
                    goto Exit;
                }

                Status = RtlAppendUnicodeStringBuffer(&ApplicationNameManifest, &SxsManifestSuffix);
                if (!NT_SUCCESS(Status)) {
                    goto Exit;
                }

                // Ensure that we null-terminate the name we're building is NUL terminated
                Status = RtlEnsureUnicodeStringBufferSizeBytes(&ApplicationNameManifest, ApplicationNameManifest.String.Length + sizeof(WCHAR));
                if (!NT_SUCCESS(Status)) {
                    goto Exit;
                }

                RTL_STRING_NUL_TERMINATE(&ApplicationNameManifest.String);

                RelativePath = ApplicationNameManifest.String.Buffer;
            }
            else {
                RelativePath = ManifestDefaultName;
            }
        }

        if (MakeSourcePath) {
            ULONG LengthAssemblyDir;
            ULONG LengthRelativePath ;
            ULONG Length ; // Will hold total number of characters we
            BOOL AddTrailingSlash = FALSE;
            LPWSTR lpCurrent;

            LengthAssemblyDir = wcslen(Params.lpAssemblyDirectory);
            AddTrailingSlash = (Params.lpAssemblyDirectory[LengthAssemblyDir - 1] != L'\\');
            LengthRelativePath = wcslen(RelativePath);

            // Do this at least once with the given path, do it again if we have to switch
            // from the relative path to Assembly.Manifest.
RepeatAssemblyPathProbing:

            Length = LengthAssemblyDir + (AddTrailingSlash ? 1 : 0) + LengthRelativePath;
            Length++ ; // For NULL terminator

            ASSERT(lpTempSourcePath == NULL);
            lpTempSourcePath = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG),
                                                    Length * sizeof(WCHAR));

            if (lpTempSourcePath == NULL) {
                Status = STATUS_NO_MEMORY;
                goto Exit;
            }

            lpCurrent = lpTempSourcePath;

            memcpy(lpCurrent, Params.lpAssemblyDirectory, LengthAssemblyDir * sizeof(WCHAR));
            lpCurrent += LengthAssemblyDir;

            if (AddTrailingSlash) {
                *lpCurrent = L'\\';
                lpCurrent++;
            }

            memcpy(lpCurrent, RelativePath, LengthRelativePath * sizeof(WCHAR));
            lpCurrent += LengthRelativePath;

            *lpCurrent = L'\0';

            // If the resulting file doesn't exist and the current 'relativepath' is
            // the same as the ApplicationNameManifest stringbuffer, then reset it
            // and try again with Application.Manifest (making sure to free the 
            // temp source path too.
            if (!RtlDoesFileExists_U(lpTempSourcePath) &&
                (RelativePath == ApplicationNameManifest.String.Buffer)) {
                    
                RelativePath = ManifestDefaultName;
                LengthRelativePath = RTL_NUMBER_OF(ManifestDefaultName) - 1;

                
                RtlFreeHeap(RtlProcessHeap(), 0, lpTempSourcePath);
                lpTempSourcePath = NULL;
                goto RepeatAssemblyPathProbing;
            }
            
            // make this the new lpSource member.
            Params.lpSource = lpTempSourcePath;
        }
    } else {
        SIZE_T         SourceLength;

        //
        // Ensure that this is a full absolute path.  If it's relative, then this
        // must be expanded out to the full path before we use it to default the
        // lpAssemblyDirectory member.
        //
        // There is no precedent for using the peb lock this way, but it is the correct
        // thing. FullPaths can change as the current working directory is modified
        // on other threads. The behavior isn't predictable either way, but our
        // code works better.
        //
        Status = STATUS_SUCCESS;
        RtlAcquirePebLock();
        __try {
            RtlInitUnicodeStringBuffer(&SourceBuffer, SourceStaticBuffer, sizeof(SourceStaticBuffer));
            SourceLength = RtlGetFullPathName_U( Params.lpSource, (ULONG)SourceBuffer.ByteBuffer.Size, SourceBuffer.String.Buffer, NULL );
            if (SourceLength == 0) {
                Status = STATUS_NO_MEMORY;
                leave;
            } else if (SourceLength > SourceBuffer.ByteBuffer.Size) {
                Status = RtlEnsureUnicodeStringBufferSizeBytes(&SourceBuffer, SourceLength);
                if ( !NT_SUCCESS(Status) )
                    leave;
                SourceLength = RtlGetFullPathName_U( Params.lpSource, (ULONG)SourceBuffer.ByteBuffer.Size, SourceBuffer.String.Buffer, NULL );
                if (SourceLength == 0) {
                    Status = STATUS_NO_MEMORY;
                    leave;
                }
            }
            SourceBuffer.String.Length = (USHORT)SourceLength;
            Params.lpSource = SourceBuffer.String.Buffer;
        } __finally {
            RtlReleasePebLock();
        }

        if ( !NT_SUCCESS(Status) )
            goto Exit;

        // This would be a nice place to use
        // RtlTakeRemainingStaticBuffer(&SourceBuffer, &DirectoryBuffer, &DirectoryBufferSize);
        // RtlInitUnicodeStringBuffer(&DirectoryBuffer, &DirectoryBuffer, &DirectoryBufferSize);
        // but RtlTakeRemainingStaticBuffer has not yet been tested.

        RtlInitUnicodeStringBuffer(&AssemblyDirectoryFromSourceBuffer, StaticBuffer, sizeof(StaticBuffer));
        Status = RtlAssignUnicodeStringBuffer(&AssemblyDirectoryFromSourceBuffer, &SourceBuffer.String);
        if (!NT_SUCCESS(Status)) {
            goto Exit;
        }
        Status = RtlRemoveLastFullDosOrNtPathElement(0, &AssemblyDirectoryFromSourceBuffer);
        if (!NT_SUCCESS(Status)) {
            goto Exit;
        }
        RTL_NUL_TERMINATE_STRING(&AssemblyDirectoryFromSourceBuffer.String);
        Params.lpAssemblyDirectory = AssemblyDirectoryFromSourceBuffer.String.Buffer;
        Params.dwFlags |= ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID;
    }

    if (Params.dwFlags & ACTCTX_FLAG_RESOURCE_NAME_VALID) {
        if (pParamsW->lpResourceName == 0) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() ACTCTX_FLAG_RESOURCE_NAME_VALID set but lpResourceName == 0\n",
                __FUNCTION__
                );
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        MappedResourceName = BaseDllMapResourceIdW(pParamsW->lpResourceName);
        if (MappedResourceName == -1) {
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() BaseDllMapResourceIdW failed\n",
                __FUNCTION__
                );
            Status = NtCurrentTeb()->LastStatusValue;
            goto Exit;
        }

        Params.lpResourceName = (PCWSTR) MappedResourceName;
    } else {
        BOOL ProbeFoundManifestResource;
        //
        // Otherwise, probe through the filename that was passed in via the resource
        // enumeration functions to find the first suitable manifest.
        //
        Status = BasepSxsFindSuitableManifestResourceFor(&Params, &MappedResourceName, &ProbeFoundManifestResource);
        if ((!NT_SUCCESS(Status)) &&
            (Status != STATUS_INVALID_IMAGE_FORMAT))
            goto Exit;

        if (ProbeFoundManifestResource) {
            Params.lpResourceName = (PCWSTR) MappedResourceName;
            Params.dwFlags |= ACTCTX_FLAG_RESOURCE_NAME_VALID;
        }
        BasepCreateActCtxFlags = BASEP_CREATE_ACTCTX_FLAG_NO_ADMIN_OVERRIDE;
    }

#if DBG
    DbgPrintActCtx(__FUNCTION__ " after munging", &Params);
#endif

    Status = BasepCreateActCtx(BasepCreateActCtxFlags, &Params, &ActivationContextData);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    if (Params.dwFlags & ACTCTX_FLAG_SET_PROCESS_DEFAULT) {
        if (Peb->ActivationContextData != NULL) {
            Status = STATUS_SXS_PROCESS_DEFAULT_ALREADY_SET;
            goto Exit;
        }
        if (InterlockedCompareExchangePointer(
                (PVOID*)&Peb->ActivationContextData,
                ActivationContextData,
                NULL
                )
                != NULL) {
            Status = STATUS_SXS_PROCESS_DEFAULT_ALREADY_SET;
            goto Exit;
        }
        ActivationContextData = NULL; // don't unmap it
        ActivationContextHandle = NULL; // unusual success value, INVALID_HANDLE_VALUE is failure
                                        // and we don't need to return anything to be cleaned up
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    Status = RtlCreateActivationContext(
        0,
        ActivationContextData,
        0,                                      // no extra bytes required today
        BasepSxsActivationContextNotification,
        NULL,
        (PACTIVATION_CONTEXT *) &ActivationContextHandle);
    if (!NT_SUCCESS(Status)) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_LEVEL_STATUS(Status),
            "SXS: RtlCreateActivationContext() failed 0x%08lx\n", Status);

        // Just in case RtlCreateActivationContext() set it to NULL...
        ActivationContextHandle = INVALID_HANDLE_VALUE;
        goto Exit;
    }

    ActivationContextData = NULL; // Don't unmap in exit if we actually succeeded.
    Status = STATUS_SUCCESS;
Exit:
    if (ActivationContextData != NULL) {
        NtUnmapViewOfSection(NtCurrentProcess(), ActivationContextData);
    }
    BaseDllFreeResourceId(MappedResourceName);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        ActivationContextHandle = INVALID_HANDLE_VALUE;
    }

#if DBG
    if (ActivationContextHandle == INVALID_HANDLE_VALUE) {
        DbgPrintEx( 
            DPFLTR_SXS_ID, 
            DPFLTR_LEVEL_STATUS(Status),
            "SXS: Exiting %s(%ls / %ls, %p), ActivationContextHandle:%p, Status:0x%lx\n",
            __FUNCTION__,
            Params.lpSource, pParamsW->lpSource,
            Params.lpResourceName,
            ActivationContextHandle,
            Status
        );
    }
#endif

    // Do these after DbgPrintEx because at least one of them can get printed.
    RtlFreeUnicodeStringBuffer(&AssemblyDirectoryFromSourceBuffer);
    RtlFreeUnicodeStringBuffer(&SourceBuffer);
    RtlFreeUnicodeStringBuffer(&ApplicationNameManifest);
    if (lpTempSourcePath != NULL) {
        // Set the lpSource value back to the original so we don't access freed memory.
        Params.lpSource = pParamsW->lpSource;
        RtlFreeHeap(RtlProcessHeap(), 0, lpTempSourcePath);
    }
    return ActivationContextHandle;
}

VOID
WINAPI
AddRefActCtx(
    HANDLE hActCtx
    )
{
    RtlAddRefActivationContext((PACTIVATION_CONTEXT) hActCtx);
}

VOID
WINAPI
ReleaseActCtx(
    HANDLE hActCtx
    )
{
    RtlReleaseActivationContext((PACTIVATION_CONTEXT) hActCtx);
}

BOOL
WINAPI
ZombifyActCtx(
    HANDLE hActCtx
    )
{
    NTSTATUS Status = RtlZombifyActivationContext((PACTIVATION_CONTEXT) hActCtx);
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }
    return TRUE;
}

BOOL
WINAPI
ActivateActCtx(
    HANDLE hActCtx,
    ULONG_PTR *lpCookie
    )
{
   NTSTATUS Status;

    if (hActCtx == INVALID_HANDLE_VALUE) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return FALSE;
    }

    Status = RtlActivateActivationContext(0, (PACTIVATION_CONTEXT) hActCtx, lpCookie);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
DeactivateActCtx(
    DWORD dwFlags,
    ULONG_PTR ulCookie
    )
{
    DWORD dwFlagsDown = 0;

    if ((dwFlags & ~(DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION)) != 0) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return FALSE;
    }

    if (dwFlags & DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION)
        dwFlagsDown |= RTL_DEACTIVATE_ACTIVATION_CONTEXT_FLAG_FORCE_EARLY_DEACTIVATION;

    // The Rtl function does not fail...
    RtlDeactivateActivationContext(dwFlagsDown, ulCookie);
    return TRUE;
}

BOOL
WINAPI
GetCurrentActCtx(
    HANDLE *lphActCtx)
{
    NTSTATUS Status;
    BOOL fSuccess = FALSE;

    if (lphActCtx == NULL) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        goto Exit;
    }

    Status = RtlGetActiveActivationContext((PACTIVATION_CONTEXT *) lphActCtx);
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        goto Exit;
    }

    fSuccess = TRUE;

Exit:
    return fSuccess;
}

NTSTATUS
BasepAllocateActivationContextActivationBlock(
    IN DWORD Flags,
    IN PVOID Callback,
    IN PVOID CallbackContext,
    OUT PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK *ActivationBlock
    )
{
    NTSTATUS Status;
    ACTIVATION_CONTEXT_BASIC_INFORMATION acbi = {0};

    if (ActivationBlock != NULL)
        *ActivationBlock = NULL;

    if ((Flags & ~(
            BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_FREE_AFTER_CALLBACK |
            BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_ALLOCATE_IF_PROCESS_DEFAULT)) != 0) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto Exit;
    }

    if (ActivationBlock == NULL) {
        Status = STATUS_INVALID_PARAMETER_4;
        goto Exit;
    }

    Status =
        RtlQueryInformationActivationContext(
            RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_USE_ACTIVE_ACTIVATION_CONTEXT,
            NULL,
            0,
            ActivationContextBasicInformation,
            &acbi,
            sizeof(acbi),
            NULL);
    if (!NT_SUCCESS(Status)) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s - Failure getting active activation context; ntstatus %08lx\n", __FUNCTION__, Status);
        goto Exit;
    }

    if (acbi.Flags & ACTIVATION_CONTEXT_FLAG_NO_INHERIT) {
        RtlReleaseActivationContext(acbi.ActivationContext);
        acbi.ActivationContext = NULL;
    }

    // If the activation context is non-NULL or the caller always wants the block allocated
    if (((Flags & BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_ALLOCATE_IF_PROCESS_DEFAULT) == 0) ||
        (acbi.ActivationContext != NULL)) {

        *ActivationBlock = (PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK) RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), sizeof(BASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK));
        if (*ActivationBlock == NULL) {
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }

        (*ActivationBlock)->Flags = 0;
        (*ActivationBlock)->ActivationContext = acbi.ActivationContext;
        acbi.ActivationContext = NULL; // don't release in exit path...

        if (Flags & BASEP_ALLOCATE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_FREE_AFTER_CALLBACK)
            (*ActivationBlock)->Flags |= BASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK_FLAG_DO_NOT_FREE_AFTER_CALLBACK;

        (*ActivationBlock)->CallbackFunction = Callback;
        (*ActivationBlock)->CallbackContext = CallbackContext;
    }

    Status = STATUS_SUCCESS;
Exit:
    if (acbi.ActivationContext != NULL)
        RtlReleaseActivationContext(acbi.ActivationContext);

    return Status;
}

VOID
BasepFreeActivationContextActivationBlock(
    PBASE_ACTIVATION_CONTEXT_ACTIVATION_BLOCK ActivationBlock
    )
{
    if (ActivationBlock != NULL) {
        if (ActivationBlock->ActivationContext != NULL) {
            RtlReleaseActivationContext(ActivationBlock->ActivationContext);
            ActivationBlock->ActivationContext = NULL;
        }
        RtlFreeHeap(RtlProcessHeap(), 0, ActivationBlock);
    }
}



VOID
BasepSxsCloseHandles(
    IN PCBASE_MSG_SXS_HANDLES Handles
    )
{
    NTSTATUS Status;

    ASSERT(Handles != NULL);

    //
    // We are never asked to unmap a section from another process.
    //
    ASSERT(Handles->Process == NULL || Handles->Process == NtCurrentProcess());

    if (Handles->File != NULL) {
        Status = NtClose(Handles->File);
        ASSERT(NT_SUCCESS(Status));
    }
    if (Handles->Section != NULL) {
        Status = NtClose(Handles->Section);
        ASSERT(NT_SUCCESS(Status));
    }
    if (Handles->ViewBase != 0) {
        Status = NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)(ULONG_PTR)Handles->ViewBase);
        ASSERT(NT_SUCCESS(Status));
    }
}

NTSTATUS
BasepCreateActCtx(
    ULONG           Flags,
    IN PCACTCTXW    ActParams,
    OUT PVOID*      ActivationContextData
    )
{
    RTL_PATH_TYPE PathType = RtlPathTypeUnknown;
    IO_STATUS_BLOCK IoStatusBlock;
    UCHAR  Win32PolicyPathStaticBuffer[MEDIUM_PATH * sizeof(WCHAR)];
    UCHAR  NtPolicyPathStaticBuffer[MEDIUM_PATH * sizeof(WCHAR)];
    UNICODE_STRING Win32ManifestPath;
    UNICODE_STRING NtManifestPath;
    CONST SXS_CONSTANT_WIN32_NT_PATH_PAIR ManifestPathPair = { &Win32ManifestPath, &NtManifestPath };
    RTL_UNICODE_STRING_BUFFER Win32PolicyPath;
    RTL_UNICODE_STRING_BUFFER NtPolicyPath;
    CONST SXS_CONSTANT_WIN32_NT_PATH_PAIR PolicyPathPair = { &Win32PolicyPath.String, &NtPolicyPath.String };
    USHORT RemoveManifestExtensionFromPolicy = 0;
    BASE_SXS_CREATE_ACTIVATION_CONTEXT_MSG Message;
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING PolicyPathPieces[3];
    WCHAR PolicyManifestResourceId[sizeof(".65535\0")];
    BOOL IsImage = FALSE;
    BOOL IsExe = FALSE;
    PIMAGE_NT_HEADERS ImageNtHeader = NULL;
    OBJECT_ATTRIBUTES Obja;
    SIZE_T ViewSize = 0;
    PBASE_MSG_SXS_HANDLES ManifestFileHandles = NULL;
    PBASE_MSG_SXS_HANDLES ManifestImageHandles = NULL;
    BASE_MSG_SXS_HANDLES ManifestHandles = { 0 };
    BASE_MSG_SXS_HANDLES ManifestHandles2 = { 0 };
    BASE_MSG_SXS_HANDLES PolicyHandles = { 0 };
    BOOL CloseManifestImageHandles = TRUE;
    PCWSTR ManifestExtension = NULL;
    ULONG LdrCreateOutOfProcessImageFlags = 0;
    UCHAR  Win32ManifestAdminOverridePathStaticBuffer[MEDIUM_PATH * sizeof(WCHAR)];
    UCHAR  NtManifestAdminOverridePathStaticBuffer[MEDIUM_PATH * sizeof(WCHAR)];
    RTL_UNICODE_STRING_BUFFER Win32ManifestAdminOverridePath;
    RTL_UNICODE_STRING_BUFFER NtManifestAdminOverridePath;
    UNICODE_STRING ManifestAdminOverridePathPieces[3];
    CONST SXS_CONSTANT_WIN32_NT_PATH_PAIR ManifestAdminOverridePathPair =
        { &Win32ManifestAdminOverridePath.String, &NtManifestAdminOverridePath.String };
    BOOL PassFilePair = FALSE;
    PCSXS_CONSTANT_WIN32_NT_PATH_PAIR FilePairToPass = NULL;
    ULONG BasepSxsCreateStreamsFlags = 0;
    ULONG RtlImageNtHeaderExFlags = 0;

#if DBG
    if (DebugFilter_SxsTrace) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() beginning\n",  __FUNCTION__);
    }

    ASSERT(ActParams != NULL);
    ASSERT(ActParams->cbSize == sizeof(*ActParams));
    ASSERT(ActParams->dwFlags & ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID);
    ASSERT(ActParams->dwFlags & ACTCTX_FLAG_LANGID_VALID);
    ASSERT(ActParams->dwFlags & ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID);
    ASSERT(ActivationContextData != NULL);
    ASSERT(*ActivationContextData == NULL);
#endif

    RtlZeroMemory(&Message, sizeof(Message));
    RtlInitUnicodeStringBuffer(&Win32PolicyPath, Win32PolicyPathStaticBuffer, sizeof(Win32PolicyPathStaticBuffer));
    RtlInitUnicodeStringBuffer(&NtPolicyPath, NtPolicyPathStaticBuffer, sizeof(NtPolicyPathStaticBuffer));
    RtlInitUnicodeStringBuffer(&Win32ManifestAdminOverridePath, Win32ManifestAdminOverridePathStaticBuffer, sizeof(Win32ManifestAdminOverridePathStaticBuffer));
    RtlInitUnicodeStringBuffer(&NtManifestAdminOverridePath, NtManifestAdminOverridePathStaticBuffer, sizeof(NtManifestAdminOverridePathStaticBuffer));
    NtManifestPath.Buffer = NULL;

    Message.ProcessorArchitecture = ActParams->wProcessorArchitecture;
    Message.LangId = ActParams->wLangId;
    RtlInitUnicodeString(&Message.AssemblyDirectory, RTL_CONST_CAST(PWSTR)(ActParams->lpAssemblyDirectory));
    if (Message.AssemblyDirectory.Length != 0) {
        ASSERT(RTL_STRING_IS_NUL_TERMINATED(&Message.AssemblyDirectory));
        if (!RTL_STRING_IS_NUL_TERMINATED(&Message.AssemblyDirectory)) {
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SXS: %s() AssemblyDirectory is not null terminated\n", __FUNCTION__);
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }
    }

    if (ActParams->lpSource == NULL || ActParams->lpSource[0] == 0) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SXS: %s() empty lpSource %ls\n", __FUNCTION__, ActParams->lpSource);
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if ((ActParams->dwFlags & ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF) != 0) {
        Message.Flags = BASE_MSG_SXS_SYSTEM_DEFAULT_TEXTUAL_ASSEMBLY_IDENTITY_PRESENT;
        RtlInitUnicodeString(&Message.TextualAssemblyIdentity, ActParams->lpSource);
        // no streams, no handles, no manifest
        // no policy, no last modified time
        // no paths
        goto CsrMessageFilledIn;
    }

    RtlInitUnicodeString(&Win32ManifestPath, ActParams->lpSource);
    PathType = RtlDetermineDosPathNameType_U(ActParams->lpSource);
    if (!RtlDosPathNameToNtPathName_U(
        Win32ManifestPath.Buffer,
        &NtManifestPath,
        NULL,
        NULL)) {
        //
        // NTRAID#NTBUG9-147881-2000/7/21-a-JayK errors mutated into bools in ntdll
        //
        Status = STATUS_OBJECT_PATH_NOT_FOUND;
        goto Exit;
    }

    // If there's an explicitly set HMODULE, we need to verify that the HMODULE came from the lpSource
    // specified and then we can avoid opening/mapping the file.
    if (ActParams->dwFlags & ACTCTX_FLAG_HMODULE_VALID) {
        ManifestHandles.File = NULL;
        ManifestHandles.Section = NULL;
        ManifestHandles.ViewBase = (ULONG_PTR)ActParams->hModule;

        RtlImageNtHeaderExFlags |= RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK;

        if (LDR_IS_DATAFILE(ActParams->hModule))
            LdrCreateOutOfProcessImageFlags = LDR_DLL_MAPPED_AS_DATA;
        else
            LdrCreateOutOfProcessImageFlags = LDR_DLL_MAPPED_AS_IMAGE;

        // Don't try to close the handles or unmap the view on exit of this function...
        CloseManifestImageHandles = FALSE;
    } else {
        InitializeObjectAttributes(
            &Obja,
            &NtManifestPath,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

        Status =
            NtOpenFile(
                &ManifestHandles.File,
                FILE_GENERIC_READ | FILE_EXECUTE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                );
        if (!NT_SUCCESS(Status)) {
            if (DPFLTR_LEVEL_STATUS(Status) == DPFLTR_ERROR_LEVEL) {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_LEVEL_STATUS(Status),
                    "SXS: %s() NtOpenFile(%wZ) failed\n",
                    __FUNCTION__,
                    Obja.ObjectName
                    );
            }
            goto Exit;
        }
#if DBG
        if (DebugFilter_SxsTrace) {
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() NtOpenFile(%wZ) succeeded\n", __FUNCTION__, Obja.ObjectName);
        }
#endif
        Status =
            NtCreateSection(
                &ManifestHandles.Section,
                SECTION_MAP_READ,
                NULL, // ObjectAttributes
                NULL, // MaximumSize (whole file)
                PAGE_READONLY, // SectionPageProtection
                SEC_COMMIT, // AllocationAttributes
                ManifestHandles.File
                );
        if (!NT_SUCCESS(Status)) {
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() NtCreateSection() failed\n", __FUNCTION__);
            goto Exit;
        }
#if DBG
        if (DebugFilter_SxsTrace) {
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() NtCreateSection() succeeded\n", __FUNCTION__);
        }
#endif
        {
            PVOID ViewBase = 0;

            Status =
                NtMapViewOfSection(
                    ManifestHandles.Section,
                    NtCurrentProcess(),
                    &ViewBase,
                    0, // ZeroBits,
                    0, // CommitSize,
                    NULL, // SectionOffset,
                    &ViewSize, // ViewSize,
                    ViewShare, // InheritDisposition,
                    0, // AllocationType,
                    PAGE_READONLY // Protect
                    );
            if (!NT_SUCCESS(Status)) {
                DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() NtMapViewOfSection failed\n", __FUNCTION__);
                goto Exit;
            }
            ManifestHandles.ViewBase = (ULONG_PTR)ViewBase;
        }

        LdrCreateOutOfProcessImageFlags = LDR_DLL_MAPPED_AS_DATA;
    }

    Status = RtlImageNtHeaderEx(RtlImageNtHeaderExFlags, LDR_DATAFILE_TO_VIEW(ManifestHandles.ViewBase), ViewSize, &ImageNtHeader);
    if (NT_SUCCESS(Status)) {
        IsImage = TRUE;
        ASSERT(ImageNtHeader != NULL);
    } else if (Status != STATUS_INVALID_IMAGE_FORMAT) {
        goto Exit;
    } else {
        IsImage = FALSE;
    }
    if (IsImage) {
        IsExe = ((ImageNtHeader->FileHeader.Characteristics & IMAGE_FILE_DLL) == 0);
        ManifestImageHandles = &ManifestHandles;
        ManifestFileHandles = &ManifestHandles2;
    } else {
        IsExe = FALSE;
        ManifestFileHandles = &ManifestHandles;
        ManifestImageHandles = NULL;
    }

    // See if someone's trying to load a resource from something that is not an EXE
    if ((!IsImage) && (ActParams->lpResourceName != NULL)) {
        // Yup...
        Status = STATUS_INVALID_IMAGE_FORMAT;
        goto Exit;
    }
    // or if an exe but no resource (and none found by probing earlier)
    else if (IsImage && (ActParams->dwFlags & ACTCTX_FLAG_RESOURCE_NAME_VALID) == 0) {
        Status = STATUS_RESOURCE_TYPE_NOT_FOUND;
        goto Exit;
    }


    //
    // form up the policy path
    //   foo.manifest => foo.policy
    //   foo.dll, resourceid == n, resourceid != 1 => foo.dll.n.policy
    //   foo.dll, resourceid == 1 => foo.dll.policy
    //   foo.dll, resourceid == "bar" => foo.dll.bar.policy
    //
    PolicyPathPieces[0] = Win32ManifestPath;

    PolicyPathPieces[1].Length = 0;
    PolicyPathPieces[1].MaximumLength = 0;
    PolicyPathPieces[1].Buffer = NULL;
    if (ActParams->dwFlags & ACTCTX_FLAG_RESOURCE_NAME_VALID) {
        if (IS_INTRESOURCE(ActParams->lpResourceName)) {
            if (ActParams->lpResourceName != MAKEINTRESOURCEW(CREATEPROCESS_MANIFEST_RESOURCE_ID)) {
                PolicyPathPieces[1].Length = (USHORT) (_snwprintf(PolicyManifestResourceId, RTL_NUMBER_OF(PolicyManifestResourceId) - 1, L".%lu", (ULONG)(ULONG_PTR)ActParams->lpResourceName) * sizeof(WCHAR));
                PolicyManifestResourceId[RTL_NUMBER_OF(PolicyManifestResourceId) - 1] = 0;
                ASSERT(PolicyPathPieces[1].Length < sizeof(PolicyManifestResourceId));
                PolicyPathPieces[1].MaximumLength = sizeof(PolicyManifestResourceId);
                PolicyPathPieces[1].Buffer = PolicyManifestResourceId;
            }
        } else {
            RtlInitUnicodeString(&PolicyPathPieces[1], ActParams->lpResourceName);
        }
    }
    PolicyPathPieces[2] = SxsPolicySuffix;
    ManifestExtension = wcsrchr(Win32ManifestPath.Buffer, L'.');
    if (ManifestExtension != NULL && _wcsicmp(ManifestExtension, SxsManifestSuffix.Buffer) == 0) {
        RemoveManifestExtensionFromPolicy = SxsManifestSuffix.Length;
        PolicyPathPieces[0].Length -= RemoveManifestExtensionFromPolicy;
    }

    if (!NT_SUCCESS(Status = RtlMultiAppendUnicodeStringBuffer(&Win32PolicyPath, RTL_NUMBER_OF(PolicyPathPieces), PolicyPathPieces))) {
        goto Exit;
    }
    PolicyPathPieces[0] = NtManifestPath;
    PolicyPathPieces[0].Length -= RemoveManifestExtensionFromPolicy;
    if (!NT_SUCCESS(Status = RtlMultiAppendUnicodeStringBuffer(&NtPolicyPath, RTL_NUMBER_OF(PolicyPathPieces), PolicyPathPieces))) {
        goto Exit;
    }

    //
    // form up the path to the administrative override file for manifests in resources
    //
    // not an image => no override
    // manifest=foo.dll, resourceid=n, n != 1 => foo.dll.n.manifest
    // manifest=foo.dll, resourceid=n, n == 1 => foo.dll.manifest
    //
    // the second to last element is the same as for the policy file
    //
    if (IsImage) {
        ManifestAdminOverridePathPieces[0] = Win32ManifestPath;
        ManifestAdminOverridePathPieces[1] = PolicyPathPieces[1];
        ManifestAdminOverridePathPieces[2] = SxsManifestSuffix;
        if (!NT_SUCCESS(Status = RtlMultiAppendUnicodeStringBuffer(
                &Win32ManifestAdminOverridePath,
                RTL_NUMBER_OF(ManifestAdminOverridePathPieces),
                ManifestAdminOverridePathPieces))
                ) {
            goto Exit;
        }
        ManifestAdminOverridePathPieces[0] = NtManifestPath;
        if (!NT_SUCCESS(Status = RtlMultiAppendUnicodeStringBuffer(
                &NtManifestAdminOverridePath,
                RTL_NUMBER_OF(ManifestAdminOverridePathPieces),
                ManifestAdminOverridePathPieces))
                ) {
            goto Exit;
        }
    }

    Message.ActivationContextData = ActivationContextData;
    ManifestHandles.Process = NtCurrentProcess();

#if DBG
    if (DebugFilter_SxsTrace) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s:        Win32ManifestPath: \"%wZ\"\n", __FUNCTION__, &Win32ManifestPath);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s:           NtManifestPath: \"%wZ\"\n", __FUNCTION__, &NtManifestPath);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s:   Win32ManifestAdminPath: \"%wZ\"\n", __FUNCTION__, &Win32ManifestAdminOverridePath);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s:      NtManifestAdminPath: \"%wZ\"\n", __FUNCTION__, &NtManifestAdminOverridePath);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s:          Win32PolicyPath: \"%wZ\"\n", __FUNCTION__, &Win32PolicyPath);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s:           Nt32PolicyPath: \"%wZ\"\n", __FUNCTION__, &NtPolicyPath);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s:  ManifestHandles.Process: %p\n", __FUNCTION__, ManifestHandles.Process);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s:     ManifestHandles.File: %p\n", __FUNCTION__, ManifestHandles.File);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s:  ManifestHandles.Section: %p\n", __FUNCTION__, ManifestHandles.Section);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s: ManifestHandles.ViewBase: 0x%I64x\n", __FUNCTION__, ManifestHandles.ViewBase);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s:                  IsImage: %lu\n", __FUNCTION__, (ULONG) IsImage);
    }
#endif

    PassFilePair = (!IsImage || (Flags & BASEP_CREATE_ACTCTX_FLAG_NO_ADMIN_OVERRIDE) == 0);
    FilePairToPass = IsImage ? &ManifestAdminOverridePathPair : &ManifestPathPair;

    Status =
        BasepSxsCreateStreams(
            BasepSxsCreateStreamsFlags,
            LdrCreateOutOfProcessImageFlags,
            FILE_GENERIC_READ | FILE_EXECUTE,   // AccessMask,
            NULL,                               // override manifest
            NULL,                               // override policy
            PassFilePair ? FilePairToPass : NULL,
            ManifestFileHandles,
            IsImage ? &ManifestPathPair : NULL,
            ManifestImageHandles,
            (ULONG_PTR)(ActParams->lpResourceName),
            &PolicyPathPair,
            &PolicyHandles,
            &Message.Flags,
            &Message.Manifest,
            &Message.Policy
            );
CsrMessageFilledIn:
    if (Message.Flags == 0) {
        ASSERT(!NT_SUCCESS(Status));
        //
        // BasepSxsCreateStreams doesn't DbgPrint for the file not found, but
        // we want to.
        //
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_LEVEL_STATUS(Status),
            "SXS: %s() BasepSxsCreateStreams() failed\n",
            __FUNCTION__
            );
        goto Exit;
    }
    ASSERT(Message.Flags & (BASE_MSG_SXS_MANIFEST_PRESENT | BASE_MSG_SXS_TEXTUAL_ASSEMBLY_IDENTITY_PRESENT));

    //
    // file not found for .policy is ok
    //
    if (((Message.Flags & BASE_MSG_SXS_POLICY_PRESENT) == 0) &&
        BasepSxsIsStatusFileNotFoundEtc(Status)) {
        Status = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(Status)) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() BasepSxsCreateStreams() failed\n", __FUNCTION__);
        goto Exit;
    }

    // Fly my pretties, fly!
    Status = CsrBasepCreateActCtx( &Message );

    if (!NT_SUCCESS(Status)) {
        ASSERT(*ActivationContextData == NULL);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() Calling csrss server failed\n", __FUNCTION__);
        goto Exit;
    }

    Status = STATUS_SUCCESS;

Exit:
    if (ManifestFileHandles != NULL) {
        BasepSxsCloseHandles(ManifestFileHandles);
    }
    if (ManifestImageHandles != NULL && CloseManifestImageHandles) {
        BasepSxsCloseHandles(ManifestImageHandles);
    }
    BasepSxsCloseHandles(&PolicyHandles);

    RtlFreeHeap(RtlProcessHeap(), 0, NtManifestPath.Buffer);
    RtlFreeUnicodeStringBuffer(&Win32PolicyPath);
    RtlFreeUnicodeStringBuffer(&NtPolicyPath);
    RtlFreeUnicodeStringBuffer(&Win32ManifestAdminOverridePath);
    RtlFreeUnicodeStringBuffer(&NtManifestAdminOverridePath);
    if (!NT_SUCCESS(Status) && (ActivationContextData != NULL) && (*ActivationContextData != NULL)) {
        NtUnmapViewOfSection(NtCurrentProcess(), *ActivationContextData);
    }

#if DBG
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_LEVEL_STATUS(Status),
        "SXS: %s(%ls) exiting 0x%08lx\n",
        __FUNCTION__,
        (ActParams != NULL ? ActParams->lpSource : NULL),
        Status
        );
#endif
    return Status;
}

NTSTATUS
BasepSxsCreateResourceStream(
    IN ULONG                            LdrCreateOutOfProcessImageFlags,
    PCSXS_CONSTANT_WIN32_NT_PATH_PAIR   Win32NtPathPair,
    IN OUT PBASE_MSG_SXS_HANDLES        Handles,
    IN ULONG_PTR                        MappedResourceName,
    OUT PBASE_MSG_SXS_STREAM            MessageStream
    )
{
//
// Any handles passed in, we do not close.
// Any handles we open, we close, except the ones passed out in MessageStream.
//
    IO_STATUS_BLOCK   IoStatusBlock;
    IMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry;
    FILE_BASIC_INFORMATION FileBasicInfo;
    NTSTATUS Status = STATUS_SUCCESS;
    LDR_OUT_OF_PROCESS_IMAGE OutOfProcessImage = {0};
    ULONG_PTR ResourcePath[] = { ((ULONG_PTR)RT_MANIFEST), 0, 0 };
    ULONG64 ResourceAddress = 0;
    ULONG ResourceSize = 0;

#if DBG
    if (DebugFilter_SxsTrace)
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "SXS: %s(%wZ) beginning\n",
            __FUNCTION__,
            (Win32NtPathPair != NULL) ? Win32NtPathPair->Win32 : (PCUNICODE_STRING)NULL
            );
#endif

    ASSERT(Handles != NULL);
    ASSERT(Handles->Process != NULL);
    ASSERT(MessageStream != NULL);
    ASSERT(Win32NtPathPair != NULL);

    // LdrFindCreateProcessManifest currently does not search on id or langid, just type.
    // If you give it a nonzero id, it will only find it if is the first one.
    // Another approach would be to have LdrFindOutOfProcessResource return the id it found.
    ASSERT((MappedResourceName == (ULONG_PTR)CREATEPROCESS_MANIFEST_RESOURCE_ID) || (Handles->Process == NtCurrentProcess()));

    //
    // We could open any null handles like CreateFileStream does, but we happen to know
    // that our clients open all of them.
    //

    // CreateActCtx maps the view earlier to determine if it starts MZ.
    // CreateProcess gives us the view from the peb.
    // .policy files are never resources.
    ASSERT(Handles->ViewBase != 0);

    Status =
        LdrCreateOutOfProcessImage(
            LdrCreateOutOfProcessImageFlags,
            Handles->Process,
            Handles->ViewBase,
            &OutOfProcessImage
            );
    if (!NT_SUCCESS(Status)) {
#if DBG
        if (DebugFilter_SxsTrace)
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() LdrCreateOutOfProcessImage failed\n", __FUNCTION__);
#endif
        goto Exit;
    }

    ResourcePath[1] = MappedResourceName;

    Status =
        LdrFindCreateProcessManifest(
            0, // flags
            &OutOfProcessImage,
            ResourcePath,
            RTL_NUMBER_OF(ResourcePath),
            &ResourceDataEntry
            );
    if (!NT_SUCCESS(Status)) {
#if DBG
        if (DebugFilter_SxsTrace)
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() LdrFindOutOfProcessResource failed; nt status = %08lx\n", __FUNCTION__, Status);
#endif
        goto Exit;
    }

    Status =
        LdrAccessOutOfProcessResource(
            0, // flags
            &OutOfProcessImage,
            &ResourceDataEntry,
            &ResourceAddress,
            &ResourceSize);
    if (!NT_SUCCESS(Status)) {
#if DBG
        if (DebugFilter_SxsTrace)
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() LdrAccessOutOfProcessResource failed; nt status = %08lx\n", __FUNCTION__, Status);
#endif
        goto Exit;
    }

    MessageStream->Handle = Handles->Process;
    MessageStream->FileHandle = Handles->File;
    MessageStream->PathType = BASE_MSG_PATHTYPE_FILE;
    MessageStream->FileType = BASE_MSG_FILETYPE_XML;
    MessageStream->Path = *Win32NtPathPair->Win32; // it will be put in the csr capture buffer later
    MessageStream->HandleType = BASE_MSG_HANDLETYPE_PROCESS;
    MessageStream->Offset = ResourceAddress;
    MessageStream->Size = ResourceSize;

#if DBG
    if (DebugFilter_SxsTrace) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() ResourceAddress:0x%I64x\n", __FUNCTION__, ResourceAddress);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() OutOfProcessImage.DllHandle:0x%I64x\n", __FUNCTION__, OutOfProcessImage.DllHandle);
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() MessageStream->Offset:0x%I64x\n", __FUNCTION__, MessageStream->Offset);
    }
#endif

    Status = STATUS_SUCCESS;
Exit:
    LdrDestroyOutOfProcessImage(&OutOfProcessImage);
#if DBG
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_LEVEL_STATUS(Status),
        "SXS: %s(%wZ) exiting 0x%08lx\n",
        __FUNCTION__,
        (Win32NtPathPair != NULL) ? Win32NtPathPair->Win32 : (PCUNICODE_STRING)NULL,
        Status
        );
#endif
    return Status;
}

VOID
BasepSxsOverrideStreamToMessageStream(
    IN  PCSXS_OVERRIDE_STREAM OverrideStream,
    OUT PBASE_MSG_SXS_STREAM  MessageStream
    )
{
    MessageStream->FileType = BASE_MSG_FILETYPE_XML;
    MessageStream->PathType = BASE_MSG_PATHTYPE_OVERRIDE;
    MessageStream->Path = OverrideStream->Name;
    MessageStream->FileHandle = NULL;
    MessageStream->HandleType = BASE_MSG_HANDLETYPE_CLIENT_PROCESS;
    MessageStream->Handle = NULL;
    MessageStream->Offset = (ULONGLONG)OverrideStream->Address;
    MessageStream->Size = OverrideStream->Size;
}

NTSTATUS
BasepSxsCreateStreams(
    IN ULONG                                Flags,
    IN ULONG                                LdrCreateOutOfProcessImageFlags,
    IN ACCESS_MASK                          AccessMask,
    IN PCSXS_OVERRIDE_STREAM                OverrideManifest OPTIONAL,
    IN PCSXS_OVERRIDE_STREAM                OverridePolicy OPTIONAL,
    IN PCSXS_CONSTANT_WIN32_NT_PATH_PAIR    ManifestFilePathPair,
    IN OUT PBASE_MSG_SXS_HANDLES            ManifestFileHandles,
    IN PCSXS_CONSTANT_WIN32_NT_PATH_PAIR    ManifestExePathPair,
    IN OUT PBASE_MSG_SXS_HANDLES            ManifestExeHandles,
    IN ULONG_PTR                            MappedManifestResourceName OPTIONAL,
    IN PCSXS_CONSTANT_WIN32_NT_PATH_PAIR    PolicyPathPair,
    IN OUT PBASE_MSG_SXS_HANDLES            PolicyHandles,
    OUT PULONG                              MessageFlags,
    OUT PBASE_MSG_SXS_STREAM                ManifestMessageStream,
    OUT PBASE_MSG_SXS_STREAM                PolicyMessageStream OPTIONAL
    )
/*
A mismash of combined code for CreateActCtx and CreateProcess.
*/
{
    NTSTATUS         Status = STATUS_SUCCESS;
    NTSTATUS FirstProbeStatus = STATUS_SUCCESS;
    BOOLEAN LookForPolicy = TRUE;

#if DBG
    ASSERT(MessageFlags != NULL);
    ASSERT(ManifestMessageStream != NULL);
    ASSERT((ManifestFilePathPair != NULL) || (ManifestExePathPair != NULL));
    ASSERT((MappedManifestResourceName == 0) || (ManifestExePathPair != NULL));
    ASSERT((PolicyPathPair != NULL) == (PolicyMessageStream != NULL));
    if (ManifestFilePathPair != NULL) {
        ASSERT(ManifestFilePathPair->Win32 != NULL);
        ASSERT(ManifestFilePathPair->Nt != NULL);
    }
    if (ManifestExePathPair != NULL) {
        ASSERT(ManifestExePathPair->Win32 != NULL);
        ASSERT(ManifestExePathPair->Nt != NULL);
    }
    if (PolicyPathPair != NULL) {
        ASSERT(PolicyPathPair->Win32 != NULL);
        ASSERT(PolicyPathPair->Nt != NULL);
    }
    if (OverrideManifest != NULL && OverrideManifest->Size != 0) {
        ASSERT(OverrideManifest->Address != NULL);
    }
    if (OverridePolicy != NULL && OverridePolicy->Size != 0) {
        ASSERT(OverridePolicy->Address != NULL);
    }

    if (DebugFilter_SxsTrace)
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "SXS: %s(ManifestFilePath:%wZ, ManifestExePath:%wZ, PolicyPath:%wZ) beginning\n",
            __FUNCTION__,
            (ManifestFilePathPair != NULL) ? ManifestFilePathPair->Win32 : (PCUNICODE_STRING)NULL,
            (ManifestExePathPair != NULL) ? ManifestExePathPair->Win32 : (PCUNICODE_STRING)NULL,
            (PolicyPathPair != NULL) ? PolicyPathPair->Win32 : (PCUNICODE_STRING)NULL
            );
#endif

    if (OverrideManifest != NULL) {
        BasepSxsOverrideStreamToMessageStream(OverrideManifest, ManifestMessageStream);
        Status = STATUS_SUCCESS;
        //
        // When appcompat provides a manifest, do not look for a policy.
        // This let's us fix the Matrix DVD.
        //
        LookForPolicy = FALSE;
        goto ManifestFound;
    }

    if (ManifestExePathPair != NULL) {
        Status =
            BasepSxsCreateResourceStream(
                LdrCreateOutOfProcessImageFlags,
                ManifestExePathPair,
                ManifestExeHandles,
                MappedManifestResourceName,
                ManifestMessageStream);
        if (NT_SUCCESS(Status)) {
            goto ManifestFound;
        }
        if (!BasepSxsIsStatusResourceNotFound(Status)) {
            goto Exit;
        }

        FirstProbeStatus = Status;
    }

    if (ManifestFilePathPair != NULL) {
        Status =
            BasepSxsCreateFileStream(
                AccessMask,
                ManifestFilePathPair,
                ManifestFileHandles,
                ManifestMessageStream);
        if (NT_SUCCESS(Status)) {
            goto ManifestFound;
        }
        if (!BasepSxsIsStatusFileNotFoundEtc(Status)) {
            goto Exit;
        }

        if (FirstProbeStatus != STATUS_SUCCESS)
            Status = FirstProbeStatus;
    }

    ASSERT(!NT_SUCCESS(Status)); // otherwise this should be unreachable
    goto Exit;
ManifestFound:
    // indicate partial success even if policy file not found
    *MessageFlags |= BASE_MSG_SXS_MANIFEST_PRESENT;

    if (OverridePolicy != NULL) {
        BasepSxsOverrideStreamToMessageStream(OverridePolicy, PolicyMessageStream);
        *MessageFlags |= BASE_MSG_SXS_POLICY_PRESENT;
        Status = STATUS_SUCCESS;
    } else if (LookForPolicy && PolicyPathPair != NULL) {
        Status = BasepSxsCreateFileStream(AccessMask, PolicyPathPair, PolicyHandles, PolicyMessageStream);
        if (!NT_SUCCESS(Status)) {
            goto Exit; // our caller knows this is not necessarily fatal
        }
        *MessageFlags |= BASE_MSG_SXS_POLICY_PRESENT;
    }

    Status = STATUS_SUCCESS;
Exit:
#if DBG
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_LEVEL_STATUS(Status),
        "SXS: %s(MessageFlags=%lu) exiting 0x%08lx\n",
        __FUNCTION__,
        *MessageFlags,
        Status);
#endif // DBG

    return Status;
}

BOOL
BasepSxsIsStatusFileNotFoundEtc(
    NTSTATUS Status
    )
{
    DWORD Error;
    if (NT_SUCCESS(Status)) {
        return FALSE;
    }

    // First check the most obvious sounding, probably the most common.
    if (
        Status == STATUS_OBJECT_PATH_NOT_FOUND
        || Status == STATUS_OBJECT_NAME_NOT_FOUND
        || Status == STATUS_NO_SUCH_FILE
        )
    {
        return TRUE;
    }
    // Then get the eight or so less obvious ones by their mapping
    // to the two obvious Win32 values and the two inobvious Win32 values.
    Error = RtlNtStatusToDosErrorNoTeb(Status);
    // REVIEW
    //     STATUS_PATH_NOT_COVERED, ERROR_HOST_UNREACHABLE,
    if (   Error == ERROR_FILE_NOT_FOUND
        || Error == ERROR_PATH_NOT_FOUND
        || Error == ERROR_BAD_NETPATH // \\a\b
        || Error == ERROR_BAD_NET_NAME // \\a-jayk2\b
        )
    {
        return TRUE;
    }
    return FALSE;
}

BOOL
BasepSxsIsStatusResourceNotFound(
    NTSTATUS Status
    )
{
    if (NT_SUCCESS(Status))
        return FALSE;
    if (
           Status == STATUS_RESOURCE_DATA_NOT_FOUND
        || Status == STATUS_RESOURCE_TYPE_NOT_FOUND
        || Status == STATUS_RESOURCE_NAME_NOT_FOUND
        || Status == STATUS_RESOURCE_LANG_NOT_FOUND
        )
    {
        return TRUE;
    }
    return FALSE;
}

#if defined(BUILD_WOW6432)
#define BasepSxsNativeQueryInformationProcess NtWow64QueryInformationProcess64
#define BasepSxsNativeReadVirtualMemory NtWow64ReadVirtualMemory64
#else
#define BasepSxsNativeQueryInformationProcess NtQueryInformationProcess
#define BasepSxsNativeReadVirtualMemory NtReadVirtualMemory
#endif

NTSTATUS
BasepSxsGetProcessImageBaseAddress(
    PBASE_MSG_SXS_HANDLES Handles
    )
{
    NATIVE_PROCESS_BASIC_INFORMATION ProcessBasicInfo;
    NATIVE_ULONG_PTR ViewBase;
    C_ASSERT(RTL_FIELD_SIZE(NATIVE_PEB, ImageBaseAddress) == sizeof(ViewBase));
    NTSTATUS Status;

    Status =
        BasepSxsNativeQueryInformationProcess(
            Handles->Process,
            ProcessBasicInformation,
            &ProcessBasicInfo,
            sizeof(ProcessBasicInfo),
            NULL
            );
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    //
    // Wow6432 could save a syscall in CreateProcess by passing
    // ProcessBasicInfo.PebBaseAddress out to a->RealPeb in CreateProcessInternal.
    //
    Status =
        BasepSxsNativeReadVirtualMemory(
            Handles->Process,
            (NATIVE_PVOID)(((NATIVE_ULONG_PTR)ProcessBasicInfo.PebBaseAddress) + FIELD_OFFSET(NATIVE_PEB, ImageBaseAddress)),
            &ViewBase,
            sizeof(ViewBase),
            NULL
            );
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    Handles->ViewBase = ViewBase;
    Status = STATUS_SUCCESS;
Exit:
    return Status;
}

extern const SXS_OVERRIDE_STREAM SxsForceEmptyPolicy =
{
    RTL_CONSTANT_STRING(L"SxsForceEmptyPolicy"),
    NULL,
    0
};

NTSTATUS
BasepSxsCreateProcessCsrMessage(
    IN PCSXS_OVERRIDE_STREAM             OverrideManifest OPTIONAL,
    IN PCSXS_OVERRIDE_STREAM             OverridePolicy   OPTIONAL,
    IN OUT PCSXS_WIN32_NT_PATH_PAIR      ManifestPathPair,
    IN OUT PBASE_MSG_SXS_HANDLES         ManifestFileHandles,
    IN PCSXS_CONSTANT_WIN32_NT_PATH_PAIR ExePathPair,
    IN OUT PBASE_MSG_SXS_HANDLES         ManifestExeHandles,
    IN OUT PCSXS_WIN32_NT_PATH_PAIR      PolicyPathPair,
    IN OUT PBASE_MSG_SXS_HANDLES         PolicyHandles,
    IN OUT PRTL_UNICODE_STRING_BUFFER    Win32AssemblyDirectoryBuffer,
    OUT PBASE_SXS_CREATEPROCESS_MSG      Message
    )
{
    UNICODE_STRING PathPieces[2];
    NTSTATUS Status = STATUS_SUCCESS;

    CONST SXS_CONSTANT_WIN32_NT_PATH_PAIR ConstantManifestPathPair =
        { &ManifestPathPair->Win32->String, &ManifestPathPair->Nt->String };

    CONST SXS_CONSTANT_WIN32_NT_PATH_PAIR ConstantPolicyPathPair =
        { &PolicyPathPair->Win32->String, &PolicyPathPair->Nt->String };

#if DBG
    DebugFilter_SxsTrace = (NtQueryDebugFilterState(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL) == TRUE);

    //
    // assertions are anded to avoid access violating
    //
    ASSERT(ExePathPair != NULL
        && ExePathPair->Win32 != NULL
        && NT_SUCCESS(RtlValidateUnicodeString(0, ExePathPair->Win32))
        && (ExePathPair->Win32->Buffer[1] == '\\'
           ||  ExePathPair->Win32->Buffer[1] == ':')
        && ExePathPair->Nt != NULL
        && ExePathPair->Nt->Buffer[0] == '\\'
        && NT_SUCCESS(RtlValidateUnicodeString(0, ExePathPair->Nt)));
    ASSERT(ManifestPathPair != NULL
        && ManifestPathPair->Win32 != NULL
        && NT_SUCCESS(RtlValidateUnicodeString(0, &ManifestPathPair->Win32->String))
        && ManifestPathPair->Nt != NULL
        && NT_SUCCESS(RtlValidateUnicodeString(0, &ManifestPathPair->Nt->String)));
    ASSERT(PolicyPathPair != NULL
        && PolicyPathPair->Win32 != NULL
        && NT_SUCCESS(RtlValidateUnicodeString(0, &PolicyPathPair->Win32->String))
        && PolicyPathPair->Nt != NULL
        && NT_SUCCESS(RtlValidateUnicodeString(0, &PolicyPathPair->Nt->String)));
    ASSERT(Win32AssemblyDirectoryBuffer != NULL
       && NT_SUCCESS(RtlValidateUnicodeString(0, &Win32AssemblyDirectoryBuffer->String)));
    ASSERT(ManifestExeHandles != NULL
        && ManifestExeHandles->Process != NULL
        && ManifestExeHandles->ViewBase == 0);
    ASSERT(Message != NULL);
    if (DebugFilter_SxsTrace) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "SXS: %s(%wZ) beginning\n",
            __FUNCTION__,
            (ExePathPair != NULL) ? ExePathPair->Win32 : (PCUNICODE_STRING)NULL
            );
    }
#endif

    // C_ASSERT didn't work.
    ASSERT(BASE_MSG_FILETYPE_NONE == 0);
    ASSERT(BASE_MSG_PATHTYPE_NONE == 0);
    RtlZeroMemory(Message, sizeof(*Message));

    Status = BasepSxsGetProcessImageBaseAddress(ManifestExeHandles);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    //
    // form up foo.exe.manifest and foo.exe.policy, nt and win32 flavors
    //
    PathPieces[0] = *ExePathPair->Win32;
    PathPieces[1] = SxsManifestSuffix;
    if (!NT_SUCCESS(Status = RtlMultiAppendUnicodeStringBuffer(ManifestPathPair->Win32, 2, PathPieces)))
        goto Exit;
    PathPieces[1] = SxsPolicySuffix;
    if (!NT_SUCCESS(Status = RtlMultiAppendUnicodeStringBuffer(PolicyPathPair->Win32, 2, PathPieces)))
        goto Exit;
    PathPieces[0] = *ExePathPair->Nt;
    PathPieces[1] = SxsManifestSuffix;
    if (!NT_SUCCESS(Status = RtlMultiAppendUnicodeStringBuffer(ManifestPathPair->Nt, 2, PathPieces)))
        goto Exit;
    PathPieces[1] = SxsPolicySuffix;
    if (!NT_SUCCESS(Status = RtlMultiAppendUnicodeStringBuffer(PolicyPathPair->Nt, 2, PathPieces)))
        goto Exit;

    Status =
        BasepSxsCreateStreams(
            0,
            LDR_DLL_MAPPED_AS_UNFORMATED_IMAGE, // LdrCreateOutOfProcessImageFlags
            FILE_GENERIC_READ | FILE_EXECUTE,
            OverrideManifest,
            OverridePolicy,
            &ConstantManifestPathPair,
            ManifestFileHandles,
            ExePathPair,
            ManifestExeHandles,
            (ULONG_PTR)CREATEPROCESS_MANIFEST_RESOURCE_ID,
            &ConstantPolicyPathPair,
            PolicyHandles,
            &Message->Flags,
            &Message->Manifest,
            &Message->Policy
            );

    //
    // did we find manifest and policy
    // it's ok to find neither but if either then always manifest
    //
    if (BasepSxsIsStatusFileNotFoundEtc(Status)
        || BasepSxsIsStatusResourceNotFound(Status)) {
        Status = STATUS_SUCCESS;
    }
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    if (Message->Flags == 0) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    //
    // Set the assembly directory. Use a copy to not violate const.
    // We can't just shorten the path because basesrv expects the string to be nul
    // terminated, and better to meet that expection here than there.
    //
    Status = RtlAssignUnicodeStringBuffer(Win32AssemblyDirectoryBuffer, ExePathPair->Win32);
    if (!NT_SUCCESS(Status))
        goto Exit;
    Status = RtlRemoveLastFullDosOrNtPathElement(0, Win32AssemblyDirectoryBuffer);
    if (!NT_SUCCESS(Status))
        goto Exit;
    RTL_NUL_TERMINATE_STRING(&Win32AssemblyDirectoryBuffer->String);
    Message->AssemblyDirectory = Win32AssemblyDirectoryBuffer->String;

    Status = STATUS_SUCCESS;
Exit:

#if DBG
    if (DebugFilter_SxsTrace) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "SXS: %s() Message {\n"
            "SXS:   Flags:(%s | %s | %s)\n"
            "SXS: }\n",
            __FUNCTION__,
            (Message->Flags & BASE_MSG_SXS_MANIFEST_PRESENT) ? "MANIFEST_PRESENT" : "0",
            (Message->Flags & BASE_MSG_SXS_POLICY_PRESENT) ? "POLICY_PRESENT" : "0",
            (Message->Flags & BASE_MSG_SXS_TEXTUAL_ASSEMBLY_IDENTITY_PRESENT) ? "TEXTUAL_ASSEMBLY_IDENTITY_PRESENT" : "0"
            );
        if (Message->Flags & BASE_MSG_SXS_MANIFEST_PRESENT) {
            BasepSxsDbgPrintMessageStream(__FUNCTION__, "Manifest", &Message->Manifest);
        }
        if (Message->Flags & BASE_MSG_SXS_POLICY_PRESENT) {
            BasepSxsDbgPrintMessageStream(__FUNCTION__, "Policy", &Message->Policy);
        }
        //
        // CreateProcess does not support textual identities.
        //
        ASSERT((Message->Flags & BASE_MSG_SXS_TEXTUAL_ASSEMBLY_IDENTITY_PRESENT) == 0);
    }
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_LEVEL_STATUS(Status),
        "SXS: %s(%wZ) exiting 0x%08lx\n",
        __FUNCTION__,
        (ExePathPair != NULL) ? ExePathPair->Win32 : (PCUNICODE_STRING)NULL,
        Status
        );
#endif
    return Status;
}

NTSTATUS
BasepSxsCreateFileStream(
    IN ACCESS_MASK                      AccessMask,
    PCSXS_CONSTANT_WIN32_NT_PATH_PAIR   Win32NtPathPair,
    IN OUT PBASE_MSG_SXS_HANDLES        Handles,
    PBASE_MSG_SXS_STREAM                MessageStream
    )
{
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK   IoStatusBlock;
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS Status1 = STATUS_SUCCESS;
    FILE_STANDARD_INFORMATION FileBasicInformation;

#if DBG
    DebugFilter_SxsTrace = (NtQueryDebugFilterState(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL) == TRUE);

    ASSERT(Win32NtPathPair != NULL);
    if (Win32NtPathPair != NULL) {
        ASSERT(Win32NtPathPair->Win32 != NULL);
        ASSERT(Win32NtPathPair->Nt != NULL);
    }
    ASSERT(MessageStream != NULL);
    if (DebugFilter_SxsTrace) {
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_TRACE_LEVEL,
            "SXS: %s(Path:%wZ, Handles:%p(Process:%p, File:%p, Section:%p), MessageStream:%p) beginning\n",
            __FUNCTION__,
            (Win32NtPathPair != NULL) ? Win32NtPathPair->Win32 : (PCUNICODE_STRING)NULL,
            Handles,
            (Handles != NULL) ? Handles->Process : NULL,
            (Handles != NULL) ? Handles->File : NULL,
            (Handles != NULL) ? Handles->Section : NULL,
            MessageStream
            );
    }
#endif

    if (Handles->File == NULL) {

        CONST PCUNICODE_STRING NtPath = Win32NtPathPair->Nt;

        InitializeObjectAttributes(
            &Obja,
            RTL_CONST_CAST(PUNICODE_STRING)(NtPath),
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status =
            NtOpenFile(
                &Handles->File,
                AccessMask,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                );
        if (!NT_SUCCESS(Status)) {
            if (DPFLTR_LEVEL_STATUS(Status) == DPFLTR_ERROR_LEVEL) {
                DbgPrintEx(
                    DPFLTR_SXS_ID,
                    DPFLTR_LEVEL_STATUS(Status),
                    "SXS: %s() NtOpenFile(%wZ) failed\n",
                    __FUNCTION__,
                    Obja.ObjectName
                    );
            }
            goto Exit;
        }
#if DBG
        if (DebugFilter_SxsTrace) {
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() NtOpenFile(%wZ) succeeded\n", __FUNCTION__, Obja.ObjectName);
        }
#endif
    }
    if (Handles->Section == NULL) {
        Status =
            NtCreateSection(
                &Handles->Section,
                SECTION_MAP_READ,
                NULL, // ObjectAttributes
                NULL, // MaximumSize (whole file)
                PAGE_READONLY, // SectionPageProtection
                SEC_COMMIT, // AllocationAttributes
                Handles->File
                );
        if (!NT_SUCCESS(Status)) {
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SXS: %s() NtCreateSection() failed\n", __FUNCTION__);
            goto Exit;
        }
#if DBG
        if (DebugFilter_SxsTrace) {
            DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_TRACE_LEVEL, "SXS: %s() NtCreateSection() succeeded\n", __FUNCTION__);
        }
#endif
    }

    Status =
        NtQueryInformationFile(
            Handles->File,
            &IoStatusBlock,
            &FileBasicInformation,
            sizeof(FileBasicInformation),
            FileStandardInformation
            );
    if (!NT_SUCCESS(Status)) {
        DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_ERROR_LEVEL, "SXS: %s() NtQueryInformationFile failed\n", __FUNCTION__);
        goto Exit;
    }
    // clamp >4gig on 32bit to 4gig (instead of modulo)
    // we should get an error later like STATUS_SECTION_TOO_BIG
    if (FileBasicInformation.EndOfFile.QuadPart > MAXSIZE_T) {
        FileBasicInformation.EndOfFile.QuadPart = MAXSIZE_T;
    }

    MessageStream->FileHandle = Handles->File;
    MessageStream->PathType = BASE_MSG_PATHTYPE_FILE;
    MessageStream->FileType = BASE_MSG_FILETYPE_XML;
    MessageStream->Path = *Win32NtPathPair->Win32; // it will be put in the csr capture buffer later
    MessageStream->HandleType = BASE_MSG_HANDLETYPE_SECTION;
    MessageStream->Handle = Handles->Section;
    MessageStream->Offset = 0;
     // cast to 32bits on 32bit platform
    MessageStream->Size   = (SIZE_T)FileBasicInformation.EndOfFile.QuadPart;

    Status = STATUS_SUCCESS;
Exit:
#if DBG
    DbgPrintEx(DPFLTR_SXS_ID, DPFLTR_LEVEL_STATUS(Status), "SXS: %s() exiting 0x%08lx\n", __FUNCTION__, Status);
#endif // DBG

    return Status;
}

WINBASEAPI
BOOL
WINAPI
QueryActCtxW(
    IN DWORD dwFlags,
    IN HANDLE hActCtx,
    IN PVOID pvSubInstance,
    IN ULONG ulInfoClass,
    OUT PVOID pvBuffer,
    IN SIZE_T cbBuffer OPTIONAL,
    OUT SIZE_T *pcbWrittenOrRequired OPTIONAL
    )
{
    NTSTATUS Status;
    BOOL fSuccess = FALSE;
    ULONG FlagsToRtl = 0;
    ULONG ValidFlags =
              QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX
            | QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE
            | QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS
            | QUERY_ACTCTX_FLAG_NO_ADDREF
            ;

    if (pcbWrittenOrRequired != NULL)
        *pcbWrittenOrRequired = 0;

    //
    // compatibility with old values
    //  define QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX (0x00000001)
    //  define QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE (0x00000002)
    //  define QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS (0x00000003)
    //
    // 80000003 is in heavy use by -DISOLATION_AWARE_ENABLED.
    //
    switch (dwFlags & 3)
    {
        case 0: break; // It is legal to pass none of the flags, like if a real hActCtx is passed.
        case 1: dwFlags |= QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX; break;
        case 2: dwFlags |= QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE; break;
        case 3: dwFlags |= QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS; break;
    }
    dwFlags &= ~3; // These bits have been abandoned.

    if (dwFlags & ~ValidFlags) {
#if DBG
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() bad flags(passed: 0x%lx, allowed: 0x%lx, bad: 0x%lx)\n",
            __FUNCTION__,
            dwFlags,
            ValidFlags,
            (dwFlags & ~ValidFlags)
            );
#endif
        BaseSetLastNTError(STATUS_INVALID_PARAMETER_1);
        goto Exit;
    }

    switch (ulInfoClass)
    {
    default:
#if DBG
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() bad InfoClass(0x%lx)\n",
            __FUNCTION__,
            ulInfoClass
            );
#endif
        BaseSetLastNTError(STATUS_INVALID_PARAMETER_2);
        goto Exit;

    case ActivationContextBasicInformation:
    case ActivationContextDetailedInformation:
        break;

    case AssemblyDetailedInformationInActivationContext:
    case FileInformationInAssemblyOfAssemblyInActivationContext:
        if (pvSubInstance == NULL) 
        {
#if DBG
            DbgPrintEx(
                DPFLTR_SXS_ID,
                DPFLTR_ERROR_LEVEL,
                "SXS: %s() InfoClass 0x%lx requires SubInstance != NULL\n",
                __FUNCTION__,
                ulInfoClass
                );
#endif
            BaseSetLastNTError(STATUS_INVALID_PARAMETER_3);
            goto Exit;
        }
    }


    if ((pvBuffer == NULL) && (cbBuffer != 0)) {
        // This probably means that they forgot to check for a failed allocation so we'll
        // attribute the failure to parameter 3.
#if DBG
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() (pvBuffer == NULL) && ((cbBuffer=0x%lu) != 0)\n",
            __FUNCTION__,
            cbBuffer
            );
#endif
        BaseSetLastNTError(STATUS_INVALID_PARAMETER_4);
        goto Exit;
    }

    if ((pvBuffer == NULL) && (pcbWrittenOrRequired == NULL)) {
#if DBG
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s() (pvBuffer == NULL) && (pcbWrittenOrRequired == NULL)\n",
            __FUNCTION__
            );
#endif
        BaseSetLastNTError(STATUS_INVALID_PARAMETER_5);
        goto Exit;
    }

    ValidFlags = 
              QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX
            | QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE
            | QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS
            ;
    switch (dwFlags & ValidFlags)
    {
    default:
#if DBG
        DbgPrintEx(
            DPFLTR_SXS_ID,
            DPFLTR_ERROR_LEVEL,
            "SXS: %s(dwFlags=0x%lx) more than one flag in 0x%lx was passed\n",
            __FUNCTION__,
            dwFlags,
            ValidFlags
            );
#endif
        BaseSetLastNTError(STATUS_INVALID_PARAMETER_1);
        goto Exit;
    case 0: // It is legal to pass none of the flags, like if a real hActCtx is passed.
        break;
    case QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX:
        FlagsToRtl |= RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_USE_ACTIVE_ACTIVATION_CONTEXT;
        break;
    case QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE:
        FlagsToRtl |= RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_ACTIVATION_CONTEXT_IS_MODULE;
        break;
    case QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS:
        FlagsToRtl |= RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_ACTIVATION_CONTEXT_IS_ADDRESS;
        break;
    }
    if ((dwFlags & QUERY_ACTCTX_FLAG_NO_ADDREF) != 0)
        FlagsToRtl |= RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_NO_ADDREF;

    Status = RtlQueryInformationActivationContext(FlagsToRtl, (PACTIVATION_CONTEXT) hActCtx, pvSubInstance, ulInfoClass, pvBuffer, cbBuffer, pcbWrittenOrRequired);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

NTSTATUS
NTAPI
BasepProbeForDllManifest(
    IN PVOID DllBase,
    IN PCWSTR FullDllPath,
    OUT PVOID *ActivationContextOut
    )
{
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    PACTIVATION_CONTEXT ActivationContext = NULL;
    ACTCTXW acw = { sizeof(acw) };
    static const ULONG_PTR ResourceIdPath[2] = { (ULONG_PTR) RT_MANIFEST, (ULONG_PTR) ISOLATIONAWARE_MANIFEST_RESOURCE_ID };
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory = NULL;

    if (ActivationContextOut != NULL)
        *ActivationContextOut = NULL;

    ASSERT(ActivationContextOut != NULL);
    if (ActivationContextOut == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Status = LdrFindResourceDirectory_U(DllBase, ResourceIdPath, RTL_NUMBER_OF(ResourceIdPath), &ResourceDirectory);
    if (!NT_SUCCESS(Status))
        goto Exit;

    acw.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID | ACTCTX_FLAG_HMODULE_VALID;
    acw.lpSource = FullDllPath;
    acw.lpResourceName = MAKEINTRESOURCEW(ISOLATIONAWARE_MANIFEST_RESOURCE_ID);
    acw.hModule = DllBase;

    ActivationContext = (PACTIVATION_CONTEXT) CreateActCtxW(&acw);

    if (ActivationContext == INVALID_HANDLE_VALUE) {
        Status = NtCurrentTeb()->LastStatusValue;
        goto Exit;
    }

    *ActivationContextOut = ActivationContext;
    Status = STATUS_SUCCESS;

Exit:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\sxsfind.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    sxsfind.c

Abstract:

    Side-by-side activation APIs for Win32, broken out of sxs.c

Author:

    Jay Krell (JayKrell) November 2001

Revision History:

--*/

#include "basedll.h"
#include <sxstypes.h>
#include "sxsapi.h"

BOOL
BasepFindActCtxSection_FillOutReturnData(
    IN  DWORD                                   dwWin32FlagsIn,
    OUT PACTCTX_SECTION_KEYED_DATA              ReturnedData,
    IN  PCACTIVATION_CONTEXT_SECTION_KEYED_DATA RtlData
    )
{
    ReturnedData->ulDataFormatVersion = RtlData->DataFormatVersion;
    ReturnedData->lpData = RtlData->Data;
    ReturnedData->ulLength = RtlData->Length;
    ReturnedData->lpSectionGlobalData = RtlData->SectionGlobalData;
    ReturnedData->ulSectionGlobalDataLength = RtlData->SectionGlobalDataLength;
    ReturnedData->lpSectionBase = RtlData->SectionBase;
    ReturnedData->ulSectionTotalLength = RtlData->SectionTotalLength;

    //
    // The size check happens earlier.
    // We then don't pay attention to the flag, but just always copy the data
    // out, as 2600 does.
    //
    ASSERT(RTL_CONTAINS_FIELD(ReturnedData, ReturnedData->cbSize, hActCtx));
    ReturnedData->hActCtx = (HANDLE) RtlData->ActivationContext;

    //
    // There's no flag for this. 2600 always returns it if it fits.
    //
    if (RTL_CONTAINS_FIELD(ReturnedData, ReturnedData->cbSize, ulAssemblyRosterIndex)) {
        ReturnedData->ulAssemblyRosterIndex = RtlData->AssemblyRosterIndex;
    }

    if ((dwWin32FlagsIn & FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS) != 0) {
        ReturnedData->ulFlags = RtlData->Flags;
    }

    if ((dwWin32FlagsIn & FIND_ACTCTX_SECTION_KEY_RETURN_ASSEMBLY_METADATA) != 0) {

        ReturnedData->AssemblyMetadata.lpInformation = RtlData->AssemblyMetadata.Information;
        ReturnedData->AssemblyMetadata.lpSectionBase = RtlData->AssemblyMetadata.SectionBase;
        ReturnedData->AssemblyMetadata.ulSectionLength = RtlData->AssemblyMetadata.SectionLength;
        ReturnedData->AssemblyMetadata.lpSectionGlobalDataBase = RtlData->AssemblyMetadata.SectionGlobalDataBase;
        ReturnedData->AssemblyMetadata.ulSectionGlobalDataLength = RtlData->AssemblyMetadata.SectionGlobalDataLength;

    }
    return TRUE;
}

BOOL
BasepFindActCtxSection_CheckAndConvertParameters(
    IN DWORD dwWin32Flags,
    IN PCACTCTX_SECTION_KEYED_DATA pWin32ReturnedData,
    OUT PULONG pulRtlFlags
    )
{
    BOOL fSuccess = FALSE;
    ULONG cbWin32Size = 0;
    ULONG ulRtlFlags = 0;

    if (pulRtlFlags != NULL) {
        *pulRtlFlags = 0;
    }
    if (pWin32ReturnedData == NULL) {
        goto InvalidParameter;
    }
    if (pulRtlFlags == NULL) {
        goto InvalidParameter;
    }
    cbWin32Size = pWin32ReturnedData->cbSize;
    if (cbWin32Size < RTL_SIZEOF_THROUGH_FIELD(ACTCTX_SECTION_KEYED_DATA, hActCtx)) {
        goto InvalidParameter;
    }

    if (((dwWin32Flags & ~(FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX |
                      FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS |
                      FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ASSEMBLY_METADATA
                      )) != 0)
        ) {
        goto InvalidParameter;
    }

    if (dwWin32Flags & FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX) {
        if (!RTL_CONTAINS_FIELD(pWin32ReturnedData, cbWin32Size, hActCtx)) {
            goto InvalidParameter;
        }
        ulRtlFlags |= FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ACTIVATION_CONTEXT;
    }
    if (dwWin32Flags & FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS) {
        if (!RTL_CONTAINS_FIELD(pWin32ReturnedData, cbWin32Size, ulFlags)) {
            goto InvalidParameter;
        }
        ulRtlFlags |= FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_FLAGS;
    }
    if (dwWin32Flags & FIND_ACTCTX_SECTION_KEY_RETURN_ASSEMBLY_METADATA) {
        if (!RTL_CONTAINS_FIELD(pWin32ReturnedData, cbWin32Size, AssemblyMetadata)) {
            goto InvalidParameter;
        }
        ulRtlFlags |= FIND_ACTIVATION_CONTEXT_SECTION_KEY_RETURN_ASSEMBLY_METADATA;
    }

    *pulRtlFlags = ulRtlFlags;
    fSuccess = TRUE;
Exit:
    return fSuccess;

InvalidParameter:
    DbgPrintEx(
        DPFLTR_SXS_ID,
        DPFLTR_ERROR_LEVEL,
        "SXS: Invalid parameter(s) passed to FindActCtxSection*()\n"
        "   dwFlags = 0x%08lx\n"
        "   ReturnedData = %p\n"
        "      ->cbSize = %u\n",
        dwWin32Flags,
        pWin32ReturnedData,
        (pWin32ReturnedData != NULL) ? cbWin32Size : 0);
    SetLastError(ERROR_INVALID_PARAMETER);
    goto Exit;
}

BOOL
BasepFindActCtxSectionString(
    DWORD dwFlags,
    const GUID *lpExtensionGuid,
    ULONG ulSectionId,
    PCUNICODE_STRING PUnicodeString,
    PACTCTX_SECTION_KEYED_DATA ReturnedData
    )
{
    BOOL fSuccess = FALSE;
    NTSTATUS Status;
    ULONG ulRtlFindFlags = 0;
    ACTIVATION_CONTEXT_SECTION_KEYED_DATA TempData;

    if (!BasepFindActCtxSection_CheckAndConvertParameters(
        dwFlags,
        ReturnedData,
        &ulRtlFindFlags
        )) {
        goto Exit;
    }

    RtlZeroMemory(&TempData, sizeof(TempData));
    TempData.Size = sizeof(TempData);

    Status = RtlFindActivationContextSectionString(
                ulRtlFindFlags,
                lpExtensionGuid,
                ulSectionId,
                PUnicodeString,
                &TempData);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        goto Exit;
    }

    if (!BasepFindActCtxSection_FillOutReturnData(
        dwFlags,
        ReturnedData,
        &TempData
        )) {
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

#if !defined(COMPILE_FIND_ACTCTX_SECTION_STRING_A) || COMPILE_FIND_ACTCTX_SECTION_STRING_A
WINBASEAPI
BOOL
FindActCtxSectionStringA(
    DWORD dwFlags,
    const GUID *lpExtensionGuid,
    ULONG ulSectionId,
    LPCSTR lpStringToFind,
    PACTCTX_SECTION_KEYED_DATA ReturnedData
    )
{
    BOOL fSuccess = FALSE;
    UNICODE_STRING UnicodeString;
    PUNICODE_STRING PUnicodeString = NULL;

    if (lpStringToFind != NULL) {
        if (!Basep8BitStringToDynamicUnicodeString(&UnicodeString, lpStringToFind))
            goto Exit;

        PUnicodeString = &UnicodeString;
    }

    if (!BasepFindActCtxSectionString(dwFlags, lpExtensionGuid, ulSectionId, PUnicodeString, ReturnedData))
        goto Exit;

    fSuccess = TRUE;
Exit:
    if (PUnicodeString != NULL)
        RtlFreeUnicodeString(PUnicodeString);

    return fSuccess;
}
#endif

BOOL
FindActCtxSectionStringW(
    DWORD dwFlags,
    const GUID *lpExtensionGuid,
    ULONG ulSectionId,
    LPCWSTR lpStringToFind,
    PACTCTX_SECTION_KEYED_DATA ReturnedData
    )
{
    BOOL fSuccess = FALSE;
    UNICODE_STRING UnicodeString;
    PUNICODE_STRING PUnicodeString = NULL;

    if (lpStringToFind != NULL) {
        RtlInitUnicodeString(&UnicodeString, lpStringToFind);
        PUnicodeString = &UnicodeString;
    }
    if (!BasepFindActCtxSectionString(dwFlags, lpExtensionGuid, ulSectionId, PUnicodeString, ReturnedData))
        goto Exit;

    fSuccess = TRUE;
Exit:
    return fSuccess;
}

BOOL
WINAPI
FindActCtxSectionGuid(
    DWORD dwFlags,
    const GUID *lpExtensionGuid,
    ULONG ulSectionId,
    const GUID *lpGuidToFind,
    PACTCTX_SECTION_KEYED_DATA ReturnedData
    )
{
    BOOL fSuccess = FALSE;
    NTSTATUS Status;
    ULONG ulRtlFindFlags = 0;
    ACTIVATION_CONTEXT_SECTION_KEYED_DATA TempData;

    if (!BasepFindActCtxSection_CheckAndConvertParameters(
        dwFlags,
        ReturnedData,
        &ulRtlFindFlags
        )) {
        goto Exit;
    }

    RtlZeroMemory(&TempData, sizeof(TempData));
    TempData.Size = sizeof(TempData);

    Status = RtlFindActivationContextSectionGuid(
                ulRtlFindFlags,
                lpExtensionGuid,
                ulSectionId,
                lpGuidToFind,
                &TempData);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        goto Exit;
    }

    if (!BasepFindActCtxSection_FillOutReturnData(
        dwFlags,
        ReturnedData,
        &TempData
        )) {
        goto Exit;
    }

    fSuccess = TRUE;
Exit:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\tapeapi.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tapeapi.c

Abstract:

    This module implements Win32 Tape APIs

Author:

    Steve Wood (stevewo) 26-Mar-1992
    Lori Brown (Maynard)

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop

#include <ntddtape.h>

DWORD
BasepDoTapeOperation(
    IN HANDLE TapeDevice,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );

DWORD
BasepDoTapeOperation(
    IN HANDLE TapeDevice,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    )
{
    HANDLE NotificationEvent;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    PIO_STATUS_BLOCK IoStatusBlock;

    IoStatusBlock = &IoStatus;

    NotificationEvent = CreateEvent(NULL, FALSE, FALSE, 
                                    NULL);
    if (NotificationEvent == NULL) {
        return GetLastError();
    }

    Status = NtDeviceIoControlFile( TapeDevice,
                                    NotificationEvent,
                                    NULL,
                                    NULL,
                                    IoStatusBlock,
                                    IoControlCode,
                                    InputBuffer,
                                    InputBufferLength,
                                    OutputBuffer,
                                    OutputBufferLength
                                  );
    if (Status == STATUS_PENDING) {

        WaitForSingleObject(NotificationEvent, INFINITE);

        Status = IoStatus.Status;

    }

    CloseHandle(NotificationEvent);

    if (!NT_SUCCESS( Status )) {
        return BaseSetLastNTError( Status );
    }
    else {
        return NO_ERROR;
    }
}


DWORD
WINAPI
SetTapePosition(
    HANDLE hDevice,
    DWORD dwPositionMethod,
    DWORD dwPartition,
    DWORD dwOffsetLow,
    DWORD dwOffsetHigh,
    BOOL bImmediate
    )

/*++

Routine Description:

    This API is used to set the tape position.

Arguments:

    hDevice - Handle to the device on which to set the tape position.

    dwPositionMethod - Type of positioning to perform.
        This parameter can have one of the following values:

        TAPE_REWIND - Position the tape to beginning-of-tape or to
            beginning-of-partition if a multiple partition mode is in
            effect (ref: CreateTapePartition API). The parameters
            dwPartition, dwOffsetHigh, and dwOffsetLow are ignored.

        TAPE_ABSOLUTE_BLOCK - Position the tape to the device specific
            block address specified by dwOffsetHigh/dwOffsetLow. The
            dwPartition parameter is ignored.

        TAPE_LOGICAL_BLOCK - Position the tape to the logical block address
            specified by dwOffsetHigh/dwOffsetLow. If a multiple partition
            mode is in effect (ref: CreateTapePartition API), then the tape
            is positioned to the specified logical block address in the
            partition specified by dwPartition; otherwise, the dwPartition
            parameter value must be 0.

        TAPE_SPACE_END_OF_DATA - Position the tape to the end-of-data
            on tape or to the end-of-data in the current partition if a
            multiple partition mode is in effect (ref: CreateTapePartition
            API). The parameters dwPartition, dwOffsetHigh, and dwOffsetLow
            are ignored.

        TAPE_SPACE_RELATIVE_BLOCKS - Position forward or reverse the number
            of blocks specified by dwOffsetHigh/dwOffsetLow. The dwPartition
            parameter is ignored.

        TAPE_SPACE_FILEMARKS - Position forward or reverse the number of
            filemarks specified by dwOffsetHigh/dwOffsetLow. The dwPartition
            parameter is ignored.

        TAPE_SPACE_SEQUENTIAL_FMKS - Position forward or reverse to the
            next occurrence, if any, of the consecutive number of filemarks
            specified by dwOffsetHigh/dwOffsetLow. The dwPartition parameter
            is ignored.

        TAPE_SPACE_SETMARKS - Position forward or reverse the number of
            setmarks specified by dwOffsetHigh/dwOffsetLow. The dwPartition
            parameter is ignored.

        TAPE_SPACE_SEQUENTIAL_SMKS - Position forward or reverse to the
            next occurrence, if any, of the consecutive number of setmarks
            specified by dwOffsetHigh/dwOffsetLow. The dwPartition parameter
            is ignored.

        Note that a drive/tape may not support all dwPositionMethod values:
        an "unsupported" error indication is returned if the dwPositionMethod
        is one that is not flagged as supported in the drive's features bits
        (ref: GetTapeParameters API).

    dwPartition - The partition number for the position operation specified
        by dwPositionMethod (if not ignored).

        A partition number value of 0 selects the current partition for
        the position operation.

        Partitions are numbered logically from 1 to N: the first partition
        of the tape is partition number 1, the next is partition number 2,
        etc. However, a partition number does not imply a physical/linear
        position on tape -- partition number 1 on tape may not be at BOT.

        This parameter must be set to 0 if a multiple partition mode is not
        in effect (ref: CreateTapePartition API).

    dwOffsetHigh/dwOffsetLow - The block address or count for the position
        operation specified by dwPositionMethod.

        When the offset specifies the number of blocks, filemarks, or
        setmarks to position over, a positive value N in the offset shall
        cause forward positioning over N blocks, filemarks, or setmarks,
        ending on the end-of-partition/tape side of a block, filemark, or
        setmark. A zero value in the offset shall cause no change of
        position. A negative value N in the offset shall cause reverse
        positioning (toward beginning-of-partition/tape) over N blocks,
        filemarks, or setmarks, ending on the beginning-of-partition side
        of a block, filemark, or setmark.

    bImmediate - Return immediately without waiting for the operation to
        complete.

        Note that a drive/tape may not support the bImmediate option for
        either some or all dwPositionMethod values: an "unsupported" error
        indication is returned if the bImmediate dwPositionMethod is one
        that is not flagged as supported in the drive's features bits
        (ref: GetTapeParameters API).


Return Value:

    If the function is successful, the return value is NO_ERROR. Otherwise,
    it is a Win32 API error code.

--*/

{
    TAPE_SET_POSITION TapeSetPosition;

    TapeSetPosition.Method = dwPositionMethod;
    TapeSetPosition.Partition = dwPartition;
    TapeSetPosition.Offset.LowPart = dwOffsetLow;
    TapeSetPosition.Offset.HighPart = dwOffsetHigh;
    TapeSetPosition.Immediate = (BOOLEAN)bImmediate;

    return BasepDoTapeOperation( hDevice,
                                 IOCTL_TAPE_SET_POSITION,
                                 &TapeSetPosition,
                                 sizeof( TapeSetPosition ),
                                 NULL,
                                 0
                               );
}


DWORD
WINAPI
GetTapePosition(
    HANDLE hDevice,
    DWORD dwPositionType,
    LPDWORD lpdwPartition,
    LPDWORD lpdwOffsetLow,
    LPDWORD lpdwOffsetHigh
    )

/*++

Routine Description:

    This API is used to get the tape position.

Arguments:

    hDevice - Handle to the device on which to get the tape position.

    dwPositionType - Type of position to return.
        This parameter can have one of the following values:

        TAPE_ABSOLUTE_POSITION - Return a device specific block address to
            the LARGE_INTEGER pointed to by lpliOffset.

            The DWORD pointed to by the lpdwPartition parameter is set to 0.

        TAPE_LOGICAL_POSITION - Return a logical block address to the
            LARGE_INTEGER pointed to by lpliOffset.

            The DWORD pointed to by the lpdwPartition parameter is set to 0
            if a multiple partition mode is not in effect; otherwise, it is
            set to the partition number of the currently selected partition
            (ref: CreateTapePartition API).

            Logical block addresses are 0 based -- 0 is a valid logical
            block address. A logical block address is a relative reference
            point (ref: logical positioning whitepaper).

    lpdwPartition - Pointer to a DWORD that receives the appropriate return
            value for the dwPositionType values explained above.

    lpliOffset - Pointer to a LARGE_INTEGER that receives the appropriate
            return value for the dwPositionType values explained above.

Return Value:

    If the function is successful, the return value is NO_ERROR. Otherwise,
    it is a Win32 API error code.

--*/

{
    TAPE_GET_POSITION TapeGetPosition;
    DWORD rc;

    TapeGetPosition.Type = dwPositionType;

    rc = BasepDoTapeOperation( hDevice,
                               IOCTL_TAPE_GET_POSITION,
                               &TapeGetPosition,
                               sizeof( TapeGetPosition ),
                               &TapeGetPosition,
                               sizeof( TapeGetPosition )
                             );

    if (rc == NO_ERROR) {
        *lpdwPartition = TapeGetPosition.Partition;
        *lpdwOffsetLow = TapeGetPosition.Offset.LowPart;
        *lpdwOffsetHigh = TapeGetPosition.Offset.HighPart;
    }
    else {
        *lpdwPartition = 0;
        *lpdwOffsetLow = 0;
        *lpdwOffsetHigh = 0;
    }

    return rc;
}


DWORD
WINAPI
PrepareTape(
    HANDLE hDevice,
    DWORD dwOperation,
    BOOL bImmediate
    )

/*++

Routine Description:

    This API is used to prepare the tape.

Arguments:

    hDevice - Handle to the device on which to prepare the tape.

    dwOperation - Type of tape preparation to perform.
        This parameter can have one of the following values:

        TAPE_LOAD - Load the tape and position the tape to beginning-of-medium.

        TAPE_UNLOAD - Position the tape to beginning-of-medium for removal from
            the device.

            Following a successful unload operation, the device shall return an
            error for all subsequent medium-access commands until a load
            operation is successfully completed.

        TAPE_TENSION - Tension the tape in the device as required.  The
            implementation of this operation is device specific.

        TAPE_LOCK - Disable the removal of the tape from the device.

        TAPE_UNLOCK - Enable the removal of the tape from the device.

        TAPE_FORMAT - Format media in tape device.

    bImmediate - Return immediately without waiting for operation to complete.

Return Value:

    If the function is successful, the return value is NO_ERROR. Otherwise,
    it is a Win32 API error code.

--*/

{
    TAPE_PREPARE TapePrepare;

    TapePrepare.Operation = dwOperation;
    TapePrepare.Immediate = (BOOLEAN)bImmediate;

    return BasepDoTapeOperation( hDevice,
                                 IOCTL_TAPE_PREPARE,
                                 &TapePrepare,
                                 sizeof( TapePrepare ),
                                 NULL,
                                 0
                               );
}


DWORD
WINAPI
EraseTape(
    HANDLE hDevice,
    DWORD dwEraseType,
    BOOL bImmediate
    )

/*++

Routine Description:

    This API is used to erase the tape partition.

Arguments:

    hDevice - Handle to the device on which to erase the tape partition.

    dwEraseType - Type of erase to perform.
        This parameter can have one of the following values:

        TAPE_ERASE_SHORT - Write an erase gap or end-of-recorded data marker
            beginning at the current position.

        TAPE_ERASE_LONG - Erase all remaining media in the current partition
            beginning at the current position.

    bImmediate - Return immediately without waiting for operation to complete.

Return Value:

    If the function is successful, the return value is NO_ERROR. Otherwise,
    it is a Win32 API error code.

--*/

{
    TAPE_ERASE TapeErase;

    TapeErase.Type = dwEraseType;
    TapeErase.Immediate = (BOOLEAN)bImmediate;

    return BasepDoTapeOperation( hDevice,
                                 IOCTL_TAPE_ERASE,
                                 &TapeErase,
                                 sizeof( TapeErase ),
                                 NULL,
                                 0
                               );
}


DWORD
WINAPI
CreateTapePartition(
    HANDLE hDevice,
    DWORD dwPartitionMethod,
    DWORD dwCount,
    DWORD dwSize
    )

/*++

Routine Description:

    This API is used to create partitions.

Arguments:

    hDevice - Handle to the device on which to create partitions.

    dwPartitionMethod - Type of partitioning to perform.

        Creating partitions causes the tape to be reformatted.  All previous
        information recorded on the tape is destroyed.

        This parameter can have one of the following values:

        TAPE_FIXED_PARTITIONS - Partition the tape based on the device's fixed
            definition of partitions.  The dwCount and dwSize parameters are
            ignored.

        TAPE_SELECT_PARTITIONS - Partition the tape into the number of
            partitions specified by dwCount using the partition sizes defined
            by the device.  The dwSize parameter is ignored.

        TAPE_INITIATOR_PARTITIONS - Partition the tape into the number of
            partitions specified by dwCount using the partition size specified
            by dwSize for all but the last partition.  The size of the last
            partition is the remainder of the tape.

    dwCount - Number of partitions to create.  The maximum number of partitions
        a device can create is returned by GetTapeParameters.

    dwSize - Partition size in megabytes.  The maximum capacity of a tape is
        returned by GetTapeParameters.

Return Value:

    If the function is successful, the return value is NO_ERROR. Otherwise,
    it is a Win32 API error code.

--*/

{
    TAPE_CREATE_PARTITION TapeCreatePartition;

    TapeCreatePartition.Method = dwPartitionMethod;
    TapeCreatePartition.Count = dwCount;
    TapeCreatePartition.Size = dwSize;

    return BasepDoTapeOperation( hDevice,
                                 IOCTL_TAPE_CREATE_PARTITION,
                                 &TapeCreatePartition,
                                 sizeof( TapeCreatePartition ),
                                 NULL,
                                 0
                               );
}


DWORD
WINAPI
WriteTapemark(
    HANDLE hDevice,
    DWORD dwTapemarkType,
    DWORD dwTapemarkCount,
    BOOL bImmediate
    )

/*++

Routine Description:

    This API is used to write tapemarks.

Arguments:

    hDevice - Handle to the device on which to write the tapemarks.

    dwTapemarkType - Type of tapemarks to write.
        This parameter can have one of the following values:

        TAPE_SETMARKS - Write the number of setmarks specified by
            dwTapemarkCount to the tape.

            A setmark is a special recorded element containing no user data.
            A setmark provides a segmentation scheme hierarchically superior
            to filemarks.

        TAPE_FILEMARKS - Write the number of filemarks specified by
            dwTapemarkCount to the tape.

            A filemark is a special recorded element containing no user data.

        TAPE_SHORT_FILEMARKS - Write the number of short filemarks specified by
            dwTapemarkCount to the tape.

            A short filemark contains a short erase gap that does not allow a
            write operation to be performed.  The short filemark cannot be
            overwritten except when the write operation is performed from the
            beginning-of-partition or from a previous long filemark.

        TAPE_LONG_FILEMARKS - Write the number of long filemarks specified by
            dwTapemarkCount to the tape.

            A long filemark includes a long erase gap.  This gap allows the
            initiator to position on the beginning-of-partition side of the
            filemark, in the erase gap, and append data with the write
            operation.  This causes the long filemark and any data following
            the long filemark to be erased.

    dwTapemarkCount - The number of tapemarks to write.

    bImmediate - Return immediately without waiting for operation to complete.

Return Value:

    If the function is successful, the return value is NO_ERROR. Otherwise,
    it is a Win32 API error code.

--*/

{
    TAPE_WRITE_MARKS TapeWriteMarks;

    TapeWriteMarks.Type = dwTapemarkType;
    TapeWriteMarks.Count = dwTapemarkCount;
    TapeWriteMarks.Immediate = (BOOLEAN)bImmediate;

    return BasepDoTapeOperation( hDevice,
                                 IOCTL_TAPE_WRITE_MARKS,
                                 &TapeWriteMarks,
                                 sizeof( TapeWriteMarks ),
                                 NULL,
                                 0
                               );
}


DWORD
WINAPI
GetTapeParameters(
    HANDLE hDevice,
    DWORD dwOperation,
    LPDWORD lpdwSize,
    LPVOID lpTapeInformation
    )

/*++

Routine Description:

    This API is used to get information about a tape device.

Arguments:

    hDevice - Handle to the device on which to get the information.

    dwOperation - Type of information to get.
        This parameter can have one of the following values:

        GET_TAPE_MEDIA_INFORMATION - Return the media specific information in
            lpTapeInformation.

        GET_TAPE_DRIVE_INFORMATION - Return the device specific information in
            lpTapeInformation.

    lpdwSize - Pointer to a DWORD containing the size of the buffer pointed to
        by lpTapeInformation.  If the buffer is too small, this parameter
        returns with the required size in bytes.

    lpTapeInformation - Pointer to a buffer to receive the information.  The
        structure returned in the buffer is determined by dwOperation.

        For GET_TAPE_MEDIA_INFORMATION, lpTapeInformation returns the following
        structure:

        LARGE_INTEGER Capacity - The maximum tape capacity in bytes.

        LARGE_INTEGER Remaining - The remaining tape capacity in bytes.

        DWORD BlockSize - The size of a fixed-length logical block in bytes.
            A block size of  0 indicates variable-length block mode, where the
            length of a block is set by the write operation.  The default
            fixed-block size and the range of valid block sizes are returned
            by GetTapeParameters.

        DWORD PartitionCount - Number of partitions on the tape.  If only one
            partition is supported by the device, this parameter is set to 0.

        BOOLEAN WriteProtected - Indicates if the tape is write protected:
            0 is write enabled, 1 is write protected.


        For GET_TAPE_DRIVE_INFORMATION, lpTapeInformation returns the following
        structure:

        BOOLEAN ECC - Indicates if hardware error correction is enabled or
            disabled: 0 is disabled, 1 is enabled.

        BOOLEAN Compression - Indicates if hardware data compression is enabled
            or disabled: 0 is disabled, 1 is enabled.

        BOOLEAN DataPadding - Indicates if data padding is disabled or enabled:
            0 is disabled, 1 is enabled.

        BOOLEAN ReportSetmarks - Indicates if reporting setmarks is enabled or
            disabled: 0 is disabled, 1 is enabled.

        DWORD DefaultBlockSize - Returns the default fixed-block size for the
            device.

        DWORD MaximumBlockSize - Returns the maximum block size for the device.

        DWORD MinimumBlockSize - Returns the minimum block size for the device.

        DWORD MaximumPartitionCount - Returns the maximum number of partitions
            the device can create.

        DWORD FeaturesLow - The lower 32 bits of the device features flag.

        DWORD FeaturesHigh - The upper 32 bits of the device features flag.

            The device features flag represents the operations a device
            supports by returning a value of 1 in the appropriate bit for each
            feature supported.

            This parameter can have one or more of the following bit values
            set in the lower 32 bits:

            TAPE_DRIVE_FIXED - Supports creating fixed data partitions.

            TAPE_DRIVE_SELECT - Supports creating select data partitions.

            TAPE_DRIVE_INITIATOR - Supports creating initiator-defined
                partitions.

            TAPE_DRIVE_ERASE_SHORT - Supports short erase operation.

            TAPE_DRIVE_ERASE_LONG - Supports long erase operation.

            TAPE_DRIVE_ERASE_BOP_ONLY - Supports erase operation from the
                beginning-of-partition only.

            TAPE_DRIVE_TAPE_CAPACITY - Supports returning the maximum capacity
                of the tape.

            TAPE_DRIVE_TAPE_REMAINING - Supports returning the remaining
                capacity of the tape.

            TAPE_DRIVE_FIXED_BLOCK - Supports fixed-length block mode.

            TAPE_DRIVE_VARIABLE_BLOCK - Supports variable-length block mode.

            TAPE_DRIVE_WRITE_PROTECT - Supports returning if the tape is write
                enabled or write protected.

            TAPE_DRIVE_ECC - Supports hardware error correction.

            TAPE_DRIVE_COMPRESSION - Supports hardware data compression.

            TAPE_DRIVE_PADDING - Supports data padding.

            TAPE_DRIVE_REPORT_SMKS - Supports reporting setmarks.

            TAPE_DRIVE_GET_ABSOLUTE_BLK - Supports returning the current device
                specific block address.

            TAPE_DRIVE_GET_LOGICAL_BLK - Supports returning the current logical
                block address (and logical tape partition).

            This parameter can have one or more of the following bit values
            set in the upper 32 bits:

            TAPE_DRIVE_LOAD_UNLOAD - Supports enabling and disabling the device
                for further operations.

            TAPE_DRIVE_TENSION - Supports tensioning the tape.

            TAPE_DRIVE_LOCK_UNLOCK - Supports enabling and disabling removal of
                the tape from the device.

            TAPE_DRIVE_SET_BLOCK_SIZE - Supports setting the size of a
                fixed-length logical block or setting variable-length block
                mode.

            TAPE_DRIVE_SET_ECC - Supports enabling and disabling hardware error
                correction.

            TAPE_DRIVE_SET_COMPRESSION - Supports enabling and disabling
                hardware data compression.

            TAPE_DRIVE_SET_PADDING - Supports enabling and disabling data
                padding.

            TAPE_DRIVE_SET_REPORT_SMKS - Supports enabling and disabling
                reporting of setmarks.

            TAPE_DRIVE_ABSOLUTE_BLK - Supports positioning to a device specific
                block address.

            TAPE_DRIVE_ABS_BLK_IMMED - Supports immediate positioning to a
                device specific block address.

            TAPE_DRIVE_LOGICAL_BLK - Supports positioning to a logical block
                address in a partition.

            TAPE_DRIVE_LOG_BLK_IMMED - Supports immediate positioning to a
                logical block address in a partition.

            TAPE_DRIVE_END_OF_DATA - Supports positioning to the end-of-data
                in a partition.

            TAPE_DRIVE_RELATIVE_BLKS - Supports positioning forward (or
                reverse) a specified number of blocks.

            TAPE_DRIVE_FILEMARKS - Supports positioning forward (or reverse)
                a specified number of filemarks.

            TAPE_DRIVE_SEQUENTIAL_FMKS - Supports positioning forward (or
                reverse) to the first occurrence of a specified number of
                consecutive filemarks.

            TAPE_DRIVE_SETMARKS - Supports positioning forward (or reverse)
                a specified number of setmarks.

            TAPE_DRIVE_SEQUENTIAL_SMKS - Supports positioning forward (or
                reverse) to the first occurrence of a specified number of
                consecutive setmarks.

            TAPE_DRIVE_REVERSE_POSITION - Supports positioning over blocks,
                filemarks, or setmarks in the reverse direction.

            TAPE_DRIVE_WRITE_SETMARKS - Supports writing setmarks.

            TAPE_DRIVE_WRITE_FILEMARKS - Supports writing filemarks.

            TAPE_DRIVE_WRITE_SHORT_FMKS - Supports writing short filemarks.

            TAPE_DRIVE_WRITE_LONG_FMKS - Supports writing long filemarks.

Return Value:

    If the function is successful, the return value is NO_ERROR. Otherwise,
    it is a Win32 API error code.

--*/

{
    DWORD rc;

    switch (dwOperation) {
        case GET_TAPE_MEDIA_INFORMATION:

            if (*lpdwSize < sizeof(TAPE_GET_MEDIA_PARAMETERS)) {
                *lpdwSize = sizeof(TAPE_GET_MEDIA_PARAMETERS);
                rc = ERROR_MORE_DATA ;
            } else {
                rc = BasepDoTapeOperation( hDevice,
                                           IOCTL_TAPE_GET_MEDIA_PARAMS,
                                           NULL,
                                           0,
                                           lpTapeInformation,
                                           sizeof( TAPE_GET_MEDIA_PARAMETERS )
                                         );
            }
            break;

        case GET_TAPE_DRIVE_INFORMATION:
            if (*lpdwSize < sizeof(TAPE_GET_DRIVE_PARAMETERS)) {
                *lpdwSize = sizeof(TAPE_GET_DRIVE_PARAMETERS);
                rc = ERROR_MORE_DATA ;
            } else {
                rc = BasepDoTapeOperation( hDevice,
                                           IOCTL_TAPE_GET_DRIVE_PARAMS,
                                           NULL,
                                           0,
                                           lpTapeInformation,
                                           sizeof( TAPE_GET_DRIVE_PARAMETERS )
                                         );
            }
            break;

        default:
            rc = ERROR_INVALID_FUNCTION;
            break;
    }

    return rc;
}


DWORD
WINAPI
SetTapeParameters(
    HANDLE hDevice,
    DWORD dwOperation,
    LPVOID lpTapeInformation
    )

/*++

Routine Description:

    This API is used to set information about a tape device.

Arguments:

    hDevice - Handle to the device on which to set the information.

    dwOperation - Type of information to set.
        This parameter can have one of the following values:

        SET_TAPE_MEDIA_INFORMATION - Set the media specific information
            specified in lpTapeInformation.

        SET_TAPE_DRIVE_INFORMATION - Set the device specific information
            specified in lpTapeInformation.

    lpTapeInformation - Pointer to a buffer containing the information to set.
        The structure returned in the buffer is determined by dwOperation.

        For SET_TAPE_MEDIA_INFORMATION, lpTapeInformation contains the
        following structure:

        DWORD BlockSize - The size of a fixed-length logical block in bytes.
            A block size of 0 indicates variable-length block mode, where the
            length of a block is set by the write operation.  The default
            fixed-block size and the range of valid block sizes are returned
            by GetTapeParameters.


        For SET_TAPE_DRIVE_INFORMATION, lpTapeInformation contains the
        following structure:

        BOOLEAN ECC - Enables or disables hardware error correction: 0 is
            disabled, 1 is enabled.

        BOOLEAN Compression - Enables or disables hardware data compression:
            0 is disabled, 1 is enabled.

        BOOLEAN DataPadding - Enables or disables data padding: 0 is disabled,
            1 is enabled.

        BOOLEAN ReportSetmarks - Enables or disables reporting of setmarks:
            0 is disabled, 1 is enabled.

Return Value:

    If the function is successful, the return value is NO_ERROR. Otherwise,
    it is a Win32 API error code.

--*/

{
    DWORD rc;

    switch (dwOperation) {
        case SET_TAPE_MEDIA_INFORMATION:
            rc = BasepDoTapeOperation( hDevice,
                                       IOCTL_TAPE_SET_MEDIA_PARAMS,
                                       lpTapeInformation,
                                       sizeof( TAPE_SET_MEDIA_PARAMETERS ),
                                       NULL,
                                       0
                                     );
            break;

        case SET_TAPE_DRIVE_INFORMATION:
            rc = BasepDoTapeOperation( hDevice,
                                       IOCTL_TAPE_SET_DRIVE_PARAMS,
                                       lpTapeInformation,
                                       sizeof( TAPE_SET_DRIVE_PARAMETERS ),
                                       NULL,
                                       0
                                     );
            break;

        default:
            rc = ERROR_INVALID_FUNCTION;
            break;
    }

    return rc;
}


DWORD
WINAPI
GetTapeStatus(
    HANDLE hDevice
    )

/*++

Routine Description:

    This API is used to get the status of a tape device.

Arguments:

    hDevice - Handle to the device on which to get the status.

Return Value:

    If the device is ready to accept an appropriate medium-access command
    without returning an error, the return value is NO_ERROR. Otherwise,
    it is a Win32 API error code.

--*/

{
    return BasepDoTapeOperation( hDevice,
                                 IOCTL_TAPE_GET_STATUS,
                                 NULL,
                                 0,
                                 NULL,
                                 0
                               );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\tatom.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tatom.c

Abstract:

    Win32 Base API Test Program for Atom Manager calls

Author:

    Steve Wood (stevewo) 26-Oct-1990

Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <windows.h>

DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    ATOM Atom1, Atom2, Atom3;
    BOOL Atom1Found, Atom2Found, Atom3Found;
    DWORD Atom1Length, Atom2Length, Atom3Length;
    TCHAR NameBuffer[ 128 ];

    printf( "TATOM: Entering Test Program\n" );

    Atom1 = AddAtom( TEXT("Atom1") );
    Atom2 = AddAtom( TEXT("#4095") );
    Atom3 = AddAtom( (LPTSTR)0x1234 );

    printf( "AddAtom( ""Atom1"" ) == %X\n", Atom1 );
    printf( "AddAtom( ""#4095"" ) == %X\n", Atom2 );
    printf( "AddAtom( 0x1234 ) == %X\n", Atom3 );

    Atom1 = AddAtom( TEXT("Atom1") );
    Atom2 = AddAtom( TEXT("#4095") );
    Atom3 = AddAtom( (LPTSTR)0x1234 );

    printf( "AddAtom( ""Atom1"" ) == %X\n", Atom1 );
    printf( "AddAtom( ""#4095"" ) == %X\n", Atom2 );
    printf( "AddAtom( 0x1234 ) == %X\n", Atom3 );

    assert( Atom1Found = (Atom1 == FindAtom( TEXT("Atom1") )) );
    assert( Atom2Found = (Atom2 == FindAtom( TEXT("#4095") )) );
    assert( Atom3Found = (Atom3 == FindAtom( (LPTSTR)0x1234 )) );

    printf( "FindAtom( ""Atom1"" ) == %X\n", Atom1 );
    printf( "FindAtom( ""#4095"" ) == %X\n", Atom2 );
    printf( "FindAtom( 0x1234 ) == %X\n", Atom3 );

    Atom1Length = GetAtomName( Atom1, NameBuffer, sizeof( NameBuffer ));
#ifdef UNICODE
    printf( "GetAtomName( %X ) == %ws\n", Atom1, NameBuffer );
#else
    printf( "GetAtomName( %X ) == %s\n", Atom1, NameBuffer );
#endif
    Atom2Length = GetAtomName( Atom2, NameBuffer, sizeof( NameBuffer ));
#ifdef UNICODE
    printf( "GetAtomName( %X ) == %ws\n", Atom2, NameBuffer );
#else
    printf( "GetAtomName( %X ) == %s\n", Atom2, NameBuffer );
#endif
    Atom3Length = GetAtomName( Atom3, NameBuffer, sizeof( NameBuffer ));
#ifdef UNICODE
    printf( "GetAtomName( %X ) == %ws\n", Atom3, NameBuffer );
#else
    printf( "GetAtomName( %X ) == %s\n", Atom3, NameBuffer );
#endif

    printf( "DeleteAtom( %X ) == %X\n", Atom1, DeleteAtom( Atom1 ) );
    printf( "DeleteAtom( %X ) == %X\n", Atom1, DeleteAtom( Atom1 ) );
    printf( "DeleteAtom( %X ) == %X\n", Atom1, DeleteAtom( Atom1 ) );
    printf( "DeleteAtom( %X ) == %X\n", Atom1, DeleteAtom( Atom1 ) );
    printf( "DeleteAtom( %X ) == %X\n", Atom2, DeleteAtom( Atom2 ) );
    printf( "DeleteAtom( %X ) == %X\n", Atom3, DeleteAtom( Atom3 ) );

    Atom1 = GlobalAddAtom( TEXT("Atom1") );
    Atom2 = GlobalAddAtom( TEXT("#4095") );
    Atom3 = GlobalAddAtom( (LPTSTR)0x1234 );

    printf( "GlobalAddAtom( ""Atom1"" ) == %X\n", Atom1 );
    printf( "GlobalAddAtom( ""#4095"" ) == %X\n", Atom2 );
    printf( "GlobalAddAtom( 0x1234 ) == %X\n", Atom3 );

    Atom1 = GlobalAddAtom( TEXT("Atom1") );
    Atom2 = GlobalAddAtom( TEXT("#4095") );
    Atom3 = GlobalAddAtom( (LPTSTR)0x1234 );

    printf( "GlobalAddAtom( ""Atom1"" ) == %X\n", Atom1 );
    printf( "GlobalAddAtom( ""#4095"" ) == %X\n", Atom2 );
    printf( "GlobalAddAtom( 0x1234 ) == %X\n", Atom3 );

    assert( Atom1Found = (Atom1 == GlobalFindAtom( TEXT("Atom1") )) );
    assert( Atom2Found = (Atom2 == GlobalFindAtom( TEXT("#4095") )) );
    assert( Atom3Found = (Atom3 == GlobalFindAtom( (LPTSTR)0x1234 )) );

    printf( "GlobalFindAtom( ""Atom1"" ) == %X\n", Atom1 );
    printf( "GlobalFindAtom( ""#4095"" ) == %X\n", Atom2 );
    printf( "GlobalFindAtom( 0x1234 ) == %X\n", Atom3 );

    Atom1Length = GlobalGetAtomName( Atom1, NameBuffer, sizeof( NameBuffer ));
#ifdef UNICODE
    printf( "GlobalGetAtomName( %X ) == %ws\n", Atom1, NameBuffer );
#else
    printf( "GlobalGetAtomName( %X ) == %s\n", Atom1, NameBuffer );
#endif
    Atom2Length = GlobalGetAtomName( Atom2, NameBuffer, sizeof( NameBuffer ));
#ifdef UNICODE
    printf( "GlobalGetAtomName( %X ) == %ws\n", Atom2, NameBuffer );
#else
    printf( "GlobalGetAtomName( %X ) == %s\n", Atom2, NameBuffer );
#endif
    Atom3Length = GlobalGetAtomName( Atom3, NameBuffer, sizeof( NameBuffer ));
#ifdef UNICODE
    printf( "GlobalGetAtomName( %X ) == %ws\n", Atom3, NameBuffer );
#else
    printf( "GlobalGetAtomName( %X ) == %s\n", Atom3, NameBuffer );
#endif

    printf( "GlobalDeleteAtom( %X ) == %X\n", Atom1, GlobalDeleteAtom( Atom1 ) );
    printf( "GlobalDeleteAtom( %X ) == %X\n", Atom1, GlobalDeleteAtom( Atom1 ) );
    printf( "GlobalDeleteAtom( %X ) == %X\n", Atom1, GlobalDeleteAtom( Atom1 ) );
    printf( "GlobalDeleteAtom( %X ) == %X\n", Atom1, GlobalDeleteAtom( Atom1 ) );
    printf( "GlobalDeleteAtom( %X ) == %X\n", Atom2, GlobalDeleteAtom( Atom2 ) );
    printf( "GlobalDeleteAtom( %X ) == %X\n", Atom3, GlobalDeleteAtom( Atom3 ) );

    printf( "TATOM: Exiting Test Program\n" );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\taskstrs.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    taststrs.c

Abstract:

    Tasking stress test.

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>

HANDLE Semaphore, Event;

VOID
TestThread(
    LPVOID ThreadParameter
    )
{
    DWORD st;

    (ReleaseSemaphore(Semaphore,1,NULL));

    st = WaitForSingleObject(Event,500);

    ExitThread(0);
}

VOID
NewProcess()
{

    DWORD st;
    DWORD ThreadId;
    HANDLE Thread;
    DWORD NumberOfThreads;
    DWORD MaximumThreadCount;
    DWORD i;

    //
    // Create an Event that is never signaled
    //

    Event = CreateEvent(NULL,TRUE,FALSE,NULL);

    //
    // Create a semaphore signaled by each thread as it starts
    //

    Semaphore = CreateSemaphore(NULL,0,256,NULL);

    (Event);
    (Semaphore);

    MaximumThreadCount = 15;
    NumberOfThreads = 0;

    //
    // Create the threads
    //

    printf("Creating %d threads... ",MaximumThreadCount);
    for ( i = 0;i<MaximumThreadCount;i++ ) {
        Thread = CreateThread(NULL,0L,(PVOID)TestThread,(LPVOID)99,0,&ThreadId);
        if ( Thread ) {
            NumberOfThreads++;
            CloseHandle(Thread);
            }
        }
    printf("%d threads Created\n",NumberOfThreads);

    for(i=0;i<NumberOfThreads;i++) {
        st = WaitForSingleObject((HANDLE)Semaphore,(DWORD)-1);
        (st == 0);
        }
    Sleep(3000);

    TerminateProcess(GetCurrentProcess(),0);
}


DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    STARTUPINFO	StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    BOOL Success;
    DWORD st;
    DWORD ProcessCount;
    SMALL_RECT Window;

    ProcessCount = 0;
    if ( strchr(GetCommandLine(),'+') ) {
        NewProcess();
        }

    GetStartupInfo(&StartupInfo);
    Window.Left = 0;
    Window.Top = 0;
    Window.Right = 15;
    Window.Bottom = 5;

    SetConsoleWindowInfo(GetStdHandle(STD_OUTPUT_HANDLE),
                         TRUE,
                         &Window
                        );


    while ( TRUE ) {

        Success = CreateProcess(
                        NULL,
                        "taskstrs +",
                        NULL,
                        NULL,
                        FALSE,
                        CREATE_NEW_CONSOLE,
                        NULL,
                        NULL,
                        &StartupInfo,
                        &ProcessInfo
                        );

        if (Success) {
            ProcessCount++;
            printf("Process %d Created\n",ProcessCount);
            st = WaitForSingleObject((HANDLE)ProcessInfo.hProcess,(DWORD)-1);
            (st == 0);
            CloseHandle(ProcessInfo.hProcess);
            CloseHandle(ProcessInfo.hThread);
            }
        }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\tbase.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tbase.c

Abstract:

    Skeleton for a Win32 Base API Test Program

Author:

    Steve Wood (stevewo) 26-Oct-1990

Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <windows.h>

LPSTR Inserts[ 9 ] = {
    "Insert 1",
    "Insert 2",
    "Insert 3",
    "Insert 4",
    "Insert 5",
    "Insert 6",
    "Insert 7",
    "Insert 8",
    "Insert 9"
};

void
TestEnvironment( void );

DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    int i;
    HANDLE hMod,x;
    CHAR Buff[256];
    PCHAR s;
    FARPROC f;
    DWORD Version;
    HANDLE Handle;
    DWORD  rc;
    STARTUPINFO StartupInfo;


    GetStartupInfo(&StartupInfo);
    printf("Title %s\n",StartupInfo.lpTitle);


    printf( "TBASE: Entering Test Program\n" );

    assert(GetModuleFileName(0,Buff,256) < 255);
    printf("Image Name %s\n",Buff);
#if 0
    printf( "argc: %ld\n", argc );
    for (i=0; i<argc; i++) {
        printf( "argv[ %3ld ]: '%s'\n", i, argv[ i ] );
        }

    for (i=0; envp[ i ]; i++) {
        printf( "envp[ %3ld ]: %s\n", i, envp[ i ] );
        }

    DbgBreakPoint();

    s = "ync ""Yes or No""";
    printf( "Invoking: '%s'\nResult: %d\n", s, system(s) );

    TestEnvironment();
    for (i=1; i<=256; i++) {
        rc = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            NULL,
                            i, NULL, sizeof( Buff ), (va_list *)Inserts );
        if (rc != 0) {
            rc = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY, NULL,
                                i, Buff, rc, (va_list *)Inserts );
            if (rc != 0) {
                cprintf( "SYS%05u: %s\r\n", i, Buff );
                }
            }
        }

    Handle = CreateFile( "\\config.sys",
                         GENERIC_READ,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,
                         OPEN_EXISTING,
                         0,
                         NULL
                       );
    if (Handle != INVALID_HANDLE_VALUE) {
        printf( "CreateFile successful, handle = %lX\n", Handle );
        }
    else {
        printf( "CreateFile failed\n" );
        }

    rc = SetFilePointer(Handle, 0, NULL, FILE_END);
    if (rc != -1) {
        printf( "File size = %ld\n", rc );
        }
    else {
        printf( "SetFilePointer failed\n" );
        }

    Version = GetVersion();
    assert( (Version & 0x0000ffff) == 4);
    assert( (Version >> 16) == 0);
#endif
    hMod = LoadLibrary("dbgdll");
    assert(hMod);
    assert(hMod == GetModuleHandle("dbgdll"));

    hMod = LoadLibrary("c:\\nt\\dll\\csr.dll");
    assert(hMod);

    assert(GetModuleFileName(hMod,Buff,256) == strlen("c:\\nt\\dll\\csr.dll")+1);
    assert(_strcmpi(Buff,"c:\\nt\\dll\\csr.dll") == 0 );

    hMod = LoadLibrary("nt\\dll\\csrrtl.dll");
    assert(hMod);

    x = LoadLibrary("csrrtl");
    assert( x && x == hMod);
    assert(FreeLibrary(x));
    assert(FreeLibrary(x));
    hMod = GetModuleHandle("csrrtl");
    assert(hMod == NULL);
    x = LoadLibrary("csrrtl");
    assert( x );
    assert(FreeLibrary(x));

    hMod = LoadLibrary("kernel32");
    assert(hMod);

    f = GetProcAddress(hMod,"GetProcAddress");
    assert(f);
    assert(f == (f)(hMod,"GetProcAddress"));
    assert(f == MakeProcInstance(f,hMod));
    FreeProcInstance(f);
    DebugBreak();
    assert(FreeLibrary(hMod));

//    hMod = LoadLibrary("baddll");
//    assert(!hMod);

    printf( "TBASE: Exiting Test Program\n" );

    return 0;
}

VOID
DumpEnvironment( VOID )
{
    PCHAR s;

    s = (PCHAR)GetEnvironmentStrings();
    while (*s) {
        printf( "%s\n", s );
        while (*s++) {
            }
        }
}

VOID
SetEnvironment(
    PCHAR Name,
    PCHAR Value
    );

VOID
SetEnvironment(
    PCHAR Name,
    PCHAR Value
    )
{
    BOOL Success;

    Success = SetEnvironmentVariable( Name, Value );
    if (Value != NULL) {
        printf( "TENV: set variable %s=%s", Name, Value );
        }
    else {
        printf( "TENV: delete variable %Z", Name );
        }

    if (Success) {
        printf( "\n" );
        }
    else {
        printf( " - failed\n" );
        }

    DumpEnvironment();
    printf( "\n" );
}


void
TestEnvironment( void )
{
    DumpEnvironment();
    SetEnvironment( "aaaa", "12345" );
    SetEnvironment( "aaaa", "1234567890" );
    SetEnvironment( "aaaa", "1" );
    SetEnvironment( "aaaa", "" );
    SetEnvironment( "aaaa", NULL );
    SetEnvironment( "AAAA", "12345" );
    SetEnvironment( "AAAA", "1234567890" );
    SetEnvironment( "AAAA", "1" );
    SetEnvironment( "AAAA", "" );
    SetEnvironment( "AAAA", NULL );
    SetEnvironment( "MMMM", "12345" );
    SetEnvironment( "MMMM", "1234567890" );
    SetEnvironment( "MMMM", "1" );
    SetEnvironment( "MMMM", "" );
    SetEnvironment( "MMMM", NULL );
    SetEnvironment( "ZZZZ", "12345" );
    SetEnvironment( "ZZZZ", "1234567890" );
    SetEnvironment( "ZZZZ", "1" );
    SetEnvironment( "ZZZZ", "" );
    SetEnvironment( "ZZZZ", NULL );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\tblddcb.c ===
#include "windows.h"
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>

void __cdecl main(int argc,char *argv[]) {

    DCB NewDCB;
    COMMTIMEOUTS To = {0};
    char firstString[] = "1200,n,8,1";
    char secondString[] = "COM1 1200,n,8,1";
    char thirdString[] = "HOST1 1200,8,N,1";
    char fourthString[] = "COM1:1200,n,8,1";
    char fifthString[] = "COM1: baud=9600 TO=ON";

    printf("About to do %s\n",&firstString[0]);
    if (!BuildCommDCB(
             &firstString[0],
             &NewDCB
             )) {

        printf("Bad BuildDCB: %d\n",GetLastError());

    }
    printf("About to do %s\n",&secondString[0]);
    if (!BuildCommDCB(
             &secondString[0],
             &NewDCB
             )) {

        printf("Bad BuildDCB: %d\n",GetLastError());

    }
    printf("About to do %s\n",&thirdString[0]);
    if (!BuildCommDCB(
             &thirdString[0],
             &NewDCB
             )) {

        printf("Bad BuildDCB: %d\n",GetLastError());

    }
    printf("About to do %s\n",&fourthString[0]);
    if (!BuildCommDCB(
             &fourthString[0],
             &NewDCB
             )) {

        printf("Bad BuildDCB: %d\n",GetLastError());

    }
    printf("About to do %s\n",&fifthString[0]);
    if (!BuildCommDCBAndTimeouts(
             &fifthString[0],
             &NewDCB,
             &To
             )) {

        printf("Bad BuildDCB: %d\n",GetLastError());

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\th2.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>

DWORD Size;
LPSTR WriteData = "Hello World\n";
HANDLE ReadHandle, WriteHandle;

VOID
WriterThread(
    LPVOID ThreadParameter
    )
{
    DWORD n;
    Sleep(10000);
    printf("Writing...\n");
    WriteFile(WriteHandle,WriteData,Size, &n, NULL);
    assert(n==Size);
    printf("Done Writing...\n");
    Sleep(10000);
    printf("Done Sleeping...\n");
}


int
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    BOOL b;
    DWORD n;
    LPSTR l;
    HANDLE Thread;
    DWORD ThreadId;
DebugBreak();
    b = CreatePipe(&ReadHandle, &WriteHandle,NULL,0);
    assert(b);

    Size = strlen(WriteData)+1;
    l = LocalAlloc(LMEM_ZEROINIT,Size);
    assert(l);

    Thread = CreateThread(NULL,0L,WriterThread,(LPVOID)99,0,&ThreadId);
    assert(Thread);
    printf("Reading\n");
    ReadFile(ReadHandle,l,Size, &n, NULL);
    assert(n==Size);
    printf("Reading Done %s\n",l);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\tfile.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tfile.c

Abstract:

    Test program for Win32 Base File API calls

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <assert.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>
#include <memory.h>

#define xassert ASSERT

DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    HANDLE iFile,oFile,fFile,mFile,n1,o1;
    DWORD n,n2;
    LONG Size;
    BYTE buff[512],cbuff[512];
    DWORD attr;
    FILETIME Mtime, Mtime0, Mtime1;
    PWIN32_FIND_DATA FindFileData;
    BOOL b;
    WORD w1,w2;
    DWORD dw,spc,bps,fc,tc;
    LPSTR base;
    LPSTR l;
    OFSTRUCT reopen1, reopen2;
    DWORD volsn[2];

    printf("Drives = 0x%lx\n",GetLogicalDrives());
    n = GetLogicalDriveStrings(511,buff);
    if ( n < 512 ) {
        l = buff;
        while ( *l ) {
            printf("%s\n",l);
            n2 = strlen(l);
            l += (n2+1);;
            }
        }
    n = GetLogicalDriveStringsW(511,buff);
    xassert(!SetCurrentDirectory("X:\\"));

    FindFileData = (PWIN32_FIND_DATA)buff;
    fFile =  FindFirstFile(
                "e:\\nt\\dll\\nul",
                FindFileData
                );
    xassert(fFile != INVALID_HANDLE_VALUE);
    FindClose(fFile);

    FindFileData = (PWIN32_FIND_DATA)buff;
    fFile =  FindFirstFile(
                "e:\\",
                FindFileData
                );
    xassert(fFile == INVALID_HANDLE_VALUE);

    b = GetVolumeInformation("",NULL,0,volsn,NULL,NULL,NULL,0);
    assert(!b);

    b = GetVolumeInformation("e:\\",NULL,0,volsn,NULL,NULL,NULL,0);
    assert(b);

    w2 = GetTempFileName("e:\\zzzxtmp","zz",0,buff);
    xassert(w2 == 0 );

    b = GetDiskFreeSpace(NULL,&spc,&bps,&fc,&tc);
    xassert(b && spc && (bps == 512) && fc && tc);
    printf("SPC = %d, BPS = %d, FC = %d, TC = %d\n",spc,bps,fc,tc);

    SearchPath(
        ".;e:\\nt;e:\\nt\\dll",
        "base",
        ".dll",
        512,
        cbuff,
        NULL
        );

    SearchPath(
        NULL,
        "win386.exe",
        ".EXe",
        512,
        cbuff,
        NULL
        );

    (VOID)argc;
    (VOID)argv;
    (VOID)envp;

#if 0
    CreateDirectory("e:\\zyx",NULL);
    xassert(SetCurrentDirectory("e:\\zyx"));
    *buff = '\0';
    xassert(GetTempPath(8,buff) == 7 && !_strcmpi(buff,"e:\\zyx\\") );
    *buff = '\0';
    xassert(GetTempPath(7,buff) == 7 && !_strcmpi(buff,"e:\\zyx\\") );
    *buff = '\0';
    xassert(GetTempPath(6,buff) == 7 && _strcmpi(buff,"e:\\zyx\\") );
    *buff = '\0';
    xassert(GetTempPath(5,buff) == 7 && _strcmpi(buff,"e:\\zyx\\") );
    *buff = '\0';
    xassert(GetTempPath(4,buff) == 7 && _strcmpi(buff,"e:\\zyx\\") );
    *buff = '\0';
    xassert(GetTempPath(3,buff) == 7 && _strcmpi(buff,"e:\\zyx\\") );
    *buff = '\0';
    xassert(GetTempPath(2,buff) == 7 && _strcmpi(buff,"e:\\zyx\\") );
    *buff = '\0';
    xassert(GetTempPath(1,buff) == 7 && _strcmpi(buff,"e:\\zyx\\") );
    *buff = '\0';
    xassert(GetTempPath(0,buff) == 7 && _strcmpi(buff,"e:\\zyx\\") );
#endif
    xassert(SetCurrentDirectory("e:\\nt"));
    b = SetEnvironmentVariable("TMP","d:\\tmp");
    xassert(b);
#if 0
    *buff = '\0';
    xassert(GetTempPath(8,buff) == 7 && !_strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(7,buff) == 7 && !_strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(6,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(5,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(4,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(3,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(2,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(1,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(0,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
#endif
    b = SetEnvironmentVariable("TMP","d:\\tmp\\");
    xassert(b);
#if 0
    *buff = '\0';
    xassert(GetTempPath(8,buff) == 7 && !_strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(7,buff) == 7 && !_strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(6,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(5,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(4,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(3,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(2,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(1,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
    *buff = '\0';
    xassert(GetTempPath(0,buff) == 7 && _strcmpi(buff,"d:\\tmp\\") );
#endif
    w1 = GetTempFileName("e:\\tmp\\","foo",0,buff);
    iFile = CreateFile(
                buff,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    xassert(iFile != INVALID_HANDLE_VALUE);
    w2 = GetTempFileName("e:\\tmp","foobar",w1,buff);
    xassert(w1 == w2);
    oFile = CreateFile(
                buff,
                GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    xassert(oFile == INVALID_HANDLE_VALUE);

    CloseHandle(iFile);
    xassert(CopyFile("e:\\nt\\dll\\usersrv.dll",buff,FALSE));
    DeleteFile("xyzzy");
    xassert(MoveFile(buff,"xyzzy"));
    xassert(!DeleteFile(buff));
    DeleteFile("rrxyzzy");
    xassert(MoveFile("xyzzy","rrxyzzy"));

    oFile = CreateFile(
                "rrxyzzy",
                GENERIC_READ,
                0,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    xassert(oFile != INVALID_HANDLE_VALUE);

    iFile = CreateFile(
                "e:\\nt\\dll\\usersrv.dll",
                GENERIC_READ,
                0,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    xassert(iFile != INVALID_HANDLE_VALUE);

    fFile = CreateFileMapping(INVALID_HANDLE_VALUE,NULL,PAGE_READWRITE,0,8192,NULL);
    xassert(fFile);
    base = MapViewOfFile(fFile,FILE_MAP_WRITE,0,0,0);
    xassert(base);
    strcpy(base,"Hello World\n");
    printf("%s",base);
    xassert(UnmapViewOfFile(base));
    CloseHandle(fFile);
    fFile = CreateFileMapping(INVALID_HANDLE_VALUE,NULL,PAGE_READONLY,0,8192,NULL);
    xassert(fFile);
    CloseHandle(fFile);
    fFile = CreateFileMapping(INVALID_HANDLE_VALUE,NULL,PAGE_READONLY,0,0,NULL);
    xassert(!fFile);

    mFile = CreateFileMapping(oFile,NULL,PAGE_READONLY,0,0,NULL);
    xassert(mFile);
    n1 = CreateFileMapping(oFile,NULL,PAGE_READONLY,0,0,"named-map");
    xassert(n1);
    o1 = OpenFileMapping(FILE_MAP_WRITE,FALSE,"named-map");
    xassert(o1);
    base = MapViewOfFile(o1,FILE_MAP_WRITE,0,0,0);
    xassert(!base);
    base = MapViewOfFile(n1,FILE_MAP_READ,0,0,0);
    xassert(base);

    FindFileData = (PWIN32_FIND_DATA)buff;
    fFile =  FindFirstFile(
                "e:\\nt\\dll\\usersrv.dll",
                FindFileData
                );
    xassert(fFile != INVALID_HANDLE_VALUE);

    l = LocalAlloc(LMEM_ZEROINIT,FindFileData->nFileSizeLow);
    xassert(l);
    b = ReadFile(iFile,l,FindFileData->nFileSizeLow,&n,NULL);
    xassert(b);
    xassert(n == FindFileData->nFileSizeLow);
    CloseHandle(oFile);
    xassert(memcmp(l,base,FindFileData->nFileSizeLow) == 0 );

    xassert(DeleteFile("rrxyzzy"));

    w2 = GetTempFileName("e:\\tmp","foobar",(WORD)0xf7ff,buff);
    xassert(w2 == 0xf7ff);
    oFile = CreateFile(
                buff,
                GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    xassert(oFile == INVALID_HANDLE_VALUE);

    w2 = GetTempFileName("e:\\xtmp","foobar",0,buff);
    xassert(w2 == 0);

    xassert(!RemoveDirectory("e:\\"));

    xassert(SetCurrentDirectory("e:\\nt"));
    xassert(!RemoveDirectory("."));
    n = GetCurrentDirectory(0,buff);
    xassert(n == 5);
    n = GetCurrentDirectory(4,buff);
    xassert(n == 5);
    *buff = '\0';
    n = GetCurrentDirectory(5,buff);
    xassert(n == 5 && strcmp(buff,"e:\\nt") == 0 );
    *buff = '\0';
    n = GetCurrentDirectory(500,buff);
    xassert(n == 5 && strcmp(buff,"e:\\nt") == 0 );

    xassert(SetCurrentDirectory("e:\\"));
    *buff = '\0';
    n = GetCurrentDirectory(500,buff);
    xassert(n == 3 && strcmp(buff,"e:\\") == 0 );
    *buff = '\0';
    n = GetCurrentDirectory(3,buff);
    xassert(n == 3 && strcmp(buff,"e:\\") == 0 );
    *buff = '\0';
    n = GetCurrentDirectory(2,buff);
    xassert(n == 3 && strcmp(buff,"e:\\") != 0 );
    xassert(SetCurrentDirectory("e:\\nt"));
    *buff = '\0';
    n = GetCurrentDirectory(500,buff);
    xassert(n == 5 && strcmp(buff,"e:\\nt") == 0 );
    xassert(SetCurrentDirectory("."));
    *buff = '\0';
    n = GetCurrentDirectory(500,buff);
    xassert(n == 5 && strcmp(buff,"e:\\nt") == 0 );

    xassert(GetDriveType("Z:\\") == 1);
    xassert(GetDriveType(".") == 1);
    xassert(GetDriveType("e:\\NT") == 1);
    xassert(GetDriveType(NULL) == DRIVE_FIXED);
    xassert(GetDriveType("e:\\") == DRIVE_FIXED);
    xassert(GetDriveType("A:\\") == DRIVE_REMOVABLE);


    xassert(!CreateDirectory(".",NULL));
    xassert(CreateDirectory("xyzzy",NULL));
    FindFileData = (PWIN32_FIND_DATA)buff;
    fFile =  FindFirstFile(
                "xyzzy\\*.*",
                FindFileData
                );
    xassert(fFile != INVALID_HANDLE_VALUE);
    b = TRUE;
    while(b) {
        printf("0x%08x %08d %s\n",
            FindFileData->dwFileAttributes,
            FindFileData->nFileSizeLow,
            FindFileData->cFileName
            );
        b = FindNextFile(fFile,FindFileData);
        }
    FindClose(fFile);
    xassert(!FindClose(fFile));

    xassert(RemoveDirectory("xyzzy"));

    iFile = CreateFile(
                "",
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    xassert(iFile == INVALID_HANDLE_VALUE);

    iFile = CreateFile(
                "nt.cfg",
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    xassert(iFile != INVALID_HANDLE_VALUE);
    xassert(!FlushFileBuffers(iFile));

    xassert(LockFile(iFile,0,0,10,0));
    xassert(LockFile(iFile,10,0,10,0));
    xassert(!LockFile(iFile,1,0,1,0));
    xassert(!LockFile(iFile,0,0,11,0));
    xassert(!LockFile(iFile,0,0,20,0));
    xassert(!UnlockFile(iFile,1,0,1,0));
    xassert(!UnlockFile(iFile,0,0,11,0));
    xassert(!UnlockFile(iFile,0,0,20,0));
    xassert(UnlockFile(iFile,0,0,10,0));
    xassert(UnlockFile(iFile,10,0,10,0));
    xassert(LockFile(iFile,0,0,10,0));
    xassert(LockFile(iFile,10,0,10,0));
    fFile = CreateFile(
                "nt.cfg",
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    xassert(fFile != INVALID_HANDLE_VALUE);
    b = ReadFile(fFile,&buff,1, &n, NULL);
    xassert(!b);
    xassert(SetFilePointer(INVALID_HANDLE_VALUE,0,NULL,FILE_BEGIN) == 0xffffffff);
    b = ReadFile(fFile,&buff,11, &n, NULL);
    xassert(SetFilePointer(fFile,0,NULL,FILE_BEGIN) == 0);
    b = ReadFile(fFile,&buff,11, &n, NULL);
    xassert(!b);
    xassert(SetFilePointer(fFile,10,NULL,FILE_BEGIN) == 10);
    b = ReadFile(fFile,&buff,1,&n,NULL);
    xassert(!b);
    xassert(SetFilePointer(fFile,10,NULL,FILE_BEGIN) == 10);
    b = ReadFile(fFile,&buff,1,&n,NULL);
    xassert(!b);
    xassert(SetFilePointer(fFile,20,NULL,FILE_BEGIN) == 20);
    b = ReadFile(fFile,&buff,1, &n, NULL);
    xassert(b && n == 1);
    xassert(UnlockFile(iFile,0,0,10,0));
    xassert(UnlockFile(iFile,10,0,10,0));
    CloseHandle(fFile);
    SetHandleCount(255);

    oFile = CreateFile(
            "ntos3.cfg",
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_HIDDEN,
            NULL
            );
    xassert(oFile != INVALID_HANDLE_VALUE);
    xassert(FlushFileBuffers(oFile));

    //
    // Copy iFile to oFile
    //

    Size = 0;
    b = ReadFile(iFile,&buff,512, &n, NULL);
    while(b && n){
        Size += n;
        b = WriteFile(oFile,&buff,n, &n, NULL);
        xassert(b && n);
        b = ReadFile(iFile,&buff,512, &n, NULL);
        }

    //
    // Make sure that we can not truncate a read only file
    //

    xassert(!SetEndOfFile(iFile));

    //
    // Go back to beginning of the iFile
    //

    xassert(SetFilePointer(iFile,0,NULL,FILE_BEGIN) == 0);
    xassert(SetFilePointer(oFile,-Size,NULL,FILE_CURRENT) == 0);

    b = ReadFile(iFile,&buff,512, &n, NULL);
    xassert(b && n);
    b = ReadFile(oFile,&cbuff,n, &n2, NULL);
    xassert(b && (n2 == n) );
    while(n && (n == n2) ){
        xassert(memcmp(&buff,&cbuff,n) == 0);
        ReadFile(iFile,&buff,512, &n, NULL);
        ReadFile(oFile,&cbuff,n, &n2, NULL);
        xassert(n2 == n);
        }
    printf("End of Loop. n2 = %ld GLE = 0x%lx\n",n2,GetLastError());

    //
    // Truncate the file to 128 bytes
    //

    xassert(SetFilePointer(oFile,128,NULL,FILE_BEGIN) == 128);
    xassert(SetEndOfFile(oFile));

    xassert(SetFilePointer(oFile,0,NULL,FILE_BEGIN) == 0);
    xassert(SetFilePointer(oFile,0,NULL,FILE_END) != -1);
    xassert(SetFilePointer(oFile,0,NULL,FILE_BEGIN) == 0);
    ReadFile(oFile,&cbuff,512, &n2, NULL);
    xassert(n2 == 128);

    CloseHandle(iFile);
    CloseHandle(oFile);

    oFile = CreateFile(
            "ntos3.cfg",
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            CREATE_NEW,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
    xassert(oFile == INVALID_HANDLE_VALUE);

    attr = GetFileAttributes("ntos3.cfg");
    xassert(attr == (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_ARCHIVE));

    xassert(SetFileAttributes("ntos3.cfg", FILE_ATTRIBUTE_NORMAL));

    attr = GetFileAttributes("ntos3.cfg");
    xassert(attr == FILE_ATTRIBUTE_NORMAL);

    oFile = CreateFile(
                "ntos3.cfg",
                GENERIC_WRITE | GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    xassert(oFile != INVALID_HANDLE_VALUE);


    xassert(!DeleteFile("ntos3.cfg"));
    CloseHandle(oFile);

    xassert(DeleteFile("ntos3.cfg"));
    oFile = CreateFile(
                "ntos3.cfg",
                GENERIC_WRITE | GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );
    xassert(oFile == INVALID_HANDLE_VALUE);

    FindFileData = (PWIN32_FIND_DATA)buff;
    fFile =  FindFirstFile(
                "dll\\*.*",
                FindFileData
                );
    xassert(fFile != INVALID_HANDLE_VALUE);
    b = TRUE;
    while(b) {
        printf("0x%08x %08d %s\n",
            FindFileData->dwFileAttributes,
            FindFileData->nFileSizeLow,
            FindFileData->cFileName
            );
        b = FindNextFile(fFile,FindFileData);
        }
    FindClose(fFile);
    xassert(!FindClose(fFile));

    n = GetWindowsDirectory(cbuff,512);
    printf("Windows directory %s length %d\n",cbuff,n);
    strcat(cbuff,"\\*.*");
    fFile =  FindFirstFile(
                cbuff,
                FindFileData
                );
    xassert(fFile != INVALID_HANDLE_VALUE);
    b = TRUE;
    while(b) {
        printf("0x%08x %08d %s\n",
            FindFileData->dwFileAttributes,
            FindFileData->nFileSizeLow,
            FindFileData->cFileName
            );
        b = FindNextFile(fFile,FindFileData);
        }
    FindClose(fFile);
    xassert(!FindClose(fFile));

    GetSystemDirectory(cbuff,512);
    strcat(cbuff,"\\*.*");
    fFile =  FindFirstFile(
                cbuff,
                FindFileData
                );
    xassert(fFile != INVALID_HANDLE_VALUE);
    b = TRUE;
    while(b) {
        printf("0x%08x %08d %s\n",
            FindFileData->dwFileAttributes,
            FindFileData->nFileSizeLow,
            FindFileData->cFileName
            );
        b = FindNextFile(fFile,FindFileData);
        }
    FindClose(fFile);
    xassert(!FindClose(fFile));

    iFile = (HANDLE)OpenFile("xyzzy.ggg",&reopen1, OF_PARSE);
    xassert(iFile == 0);
    dw = GetFullPathName("xyzzy.ggg",512,buff,&l);
    xassert(!_stricmp(buff,&reopen1.szPathName[0]));

    iFile = (HANDLE)OpenFile("",&reopen1, OF_READ);
    xassert(iFile == INVALID_HANDLE_VALUE);

    iFile = (HANDLE)OpenFile("ls.exe",&reopen1, OF_READ);
    xassert(iFile && iFile != INVALID_HANDLE_VALUE);
    xassert(!_stricmp("e:\\nt\\bin\\ls.exe",&reopen1.szPathName[0]));
    CloseHandle(iFile);
    reopen2 = reopen1;
    iFile = (HANDLE)OpenFile("ls.exe",&reopen1, OF_VERIFY | OF_READ);
    xassert(iFile && iFile != INVALID_HANDLE_VALUE);
    xassert(!_stricmp("e:\\nt\\bin\\ls.exe",&reopen1.szPathName[0]));
    CloseHandle(iFile);
    iFile = (HANDLE)OpenFile("",&reopen1, OF_REOPEN | OF_READ);
    xassert(iFile && iFile != INVALID_HANDLE_VALUE);
    xassert(!_stricmp("e:\\nt\\bin\\ls.exe",&reopen1.szPathName[0]));
    CloseHandle(iFile);
    iFile = (HANDLE)OpenFile("ls.exe",&reopen2, OF_VERIFY | OF_READ);
    xassert(iFile && iFile != INVALID_HANDLE_VALUE);
    xassert(!_stricmp("e:\\nt\\bin\\ls.exe",&reopen2.szPathName[0]));
    CloseHandle(iFile);
    iFile = (HANDLE)OpenFile("ls.exe",&reopen2, OF_EXIST );
    xassert(!CloseHandle(iFile));
    xassert(CopyFile("e:\\nt\\bin\\ls.exe","xxx.xxx",FALSE));
    iFile = (HANDLE)OpenFile("xxx.xxx",&reopen1, OF_EXIST );
    xassert(!CloseHandle(iFile));
    iFile = (HANDLE)OpenFile("xxx.xxx",&reopen1, OF_READWRITE );
    xassert(iFile && iFile != INVALID_HANDLE_VALUE);
    Sleep(3000);
    b = WriteFile(iFile,"Hello World",12,&n,NULL);
    xassert(b && n == 12);
    CloseHandle(iFile);
    iFile = (HANDLE)OpenFile("xxx.xxx",&reopen1, OF_VERIFY | OF_READ);
    xassert(iFile == INVALID_HANDLE_VALUE);
    iFile = (HANDLE)OpenFile("xxx.xxx",&reopen1, OF_DELETE );
    xassert(!CloseHandle(iFile));
    iFile = (HANDLE)OpenFile("xxx.xxx",&reopen1, OF_EXIST );
    printf("iFile %lx nErrCode %d\n",iFile,reopen1.nErrCode);
    xassert(iFile == INVALID_HANDLE_VALUE && reopen1.nErrCode == ERROR_FILE_NOT_FOUND);

    fFile =  FindFirstFile(
                "e:\\nt\\nt.cfg",
                FindFileData
                );
    xassert(fFile != INVALID_HANDLE_VALUE);
    iFile = (HANDLE)OpenFile("e:\\nt\\nt.cfg",&reopen1, OF_READ);
    xassert(iFile && iFile != INVALID_HANDLE_VALUE);
    n = GetFileSize(iFile,NULL);
    xassert(n != -1);
    xassert(n==FindFileData->nFileSizeLow);
    FindClose(fFile);
    CloseHandle(iFile);

    xassert(CopyFile("e:\\nt\\bin\\ls.exe","xxx.xxx",FALSE));
    iFile = _lopen("xxx.xxx",OF_READ);
    xassert(iFile != INVALID_HANDLE_VALUE);
    oFile = _lcreat("xxx.zzz",0);
    xassert(oFile != INVALID_HANDLE_VALUE);

    Size = 0;
    b = ReadFile(iFile,&buff,512, &n, NULL);
    while(b && n){
        Size += n;
        b = WriteFile(oFile,&buff,n, &n, NULL);
        xassert(b && n);
        b = ReadFile(iFile,&buff,512, &n, NULL);
        }
    CloseHandle(iFile);
    CloseHandle(oFile);

    iFile = _lopen("xxx.xxx",OF_WRITE);
    xassert(iFile != INVALID_HANDLE_VALUE);
    CloseHandle(iFile);
    iFile = _lopen("xxx.xxx",OF_READ);
    b = ReadFile(iFile,&buff,512, &n, NULL);
    xassert(b && n == 0 && GetLastError() == 0);

    return 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\thread.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    thread.c

Abstract:

    This module implements Win32 Thread Object APIs

Author:

    Mark Lucovsky (markl) 21-Sep-1990

Revision History:

--*/

#include "basedll.h"
#include "faultrep.h"
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>


//
// Define the fiber local storage data structure.
//

typedef struct _FLS_DATA {
    LIST_ENTRY Entry;
    PVOID Slots[FLS_MAXIMUM_AVAILABLE];
} FLS_DATA, *PFLS_DATA;

HANDLE BasepDefaultTimerQueue ;
ULONG BasepTimerQueueInitFlag ;
ULONG BasepTimerQueueDoneFlag ;

HANDLE
APIENTRY
CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    )

/*++

Routine Description:

    A thread object can be created to execute within the address space of the
    calling process using CreateThread.

    See CreateRemoteThread for a description of the arguments and return value.

--*/
{
    return CreateRemoteThread( NtCurrentProcess(),
                               lpThreadAttributes,
                               dwStackSize,
                               lpStartAddress,
                               lpParameter,
                               dwCreationFlags,
                               lpThreadId
                             );
}

HANDLE
APIENTRY
CreateRemoteThread(
    HANDLE hProcess,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    )

/*++

Routine Description:

    A thread object can be created to execute within the address space of the
    another process using CreateRemoteThread.

    Creating a thread causes a new thread of execution to begin in the address
    space of the current process. The thread has access to all objects opened
    by the process.

    The thread begins executing at the address specified by the StartAddress
    parameter. If the thread returns from this procedure, the results are
    un-specified.

    The thread remains in the system until it has terminated and
    all handles to the thread
    have been closed through a call to CloseHandle.

    When a thread terminates, it attains a state of signaled satisfying all
    waits on the object.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the following
    object type specific access flags are valid for thread objects:

        - THREAD_QUERY_INFORMATION - This access is required to read
          certain information from the thread object.

        - SYNCHRONIZE - This access is required to wait on a thread
          object.

        - THREAD_GET_CONTEXT - This access is required to read the
          context of a thread using GetThreadContext.

        - THREAD_SET_CONTEXT - This access is required to write the
          context of a thread using SetThreadContext.

        - THREAD_SUSPEND_RESUME - This access is required to suspend or
          resume a thread using SuspendThread or ResumeThread.

        - THREAD_ALL_ACCESS - This set of access flags specifies all of
          the possible access flags for a thread object.

Arguments:

    hProcess - Supplies the handle to the process in which the thread is
        to be create in.

    lpThreadAttributes - An optional parameter that may be used to specify
        the attributes of the new thread.  If the parameter is not
        specified, then the thread is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation.

    dwStackSize - Supplies the size in bytes of the stack for the new thread.
        A value of zero specifies that the thread's stack size should be
        the same size as the stack size of the first thread in the process.
        This size is specified in the application's executable file.

    lpStartAddress - Supplies the starting address of the new thread.  The
        address is logically a procedure that never returns and that
        accepts a single 32-bit pointer argument.

    lpParameter - Supplies a single parameter value passed to the thread.

    dwCreationFlags - Supplies additional flags that control the creation
        of the thread.

        dwCreationFlags Flags:

        CREATE_SUSPENDED - The thread is created in a suspended state.
            The creator can resume this thread using ResumeThread.
            Until this is done, the thread will not begin execution.

        STACK_SIZE_PARAM_IS_A_RESERVATION - Use stack size as a reservation rather than commit

    lpThreadId - Returns the thread identifier of the thread.  The
        thread ID is valid until the thread terminates.

Return Value:

    NON-NULL - Returns a handle to the new thread.  The handle has full
        access to the new thread and may be used in any API that
        requires a handle to a thread object.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    CONTEXT ThreadContext={0};
    INITIAL_TEB InitialTeb;
    CLIENT_ID ClientId;
    ULONG i;
    ACTIVATION_CONTEXT_BASIC_INFORMATION ActivationContextInfo = {0};
    const ACTIVATION_CONTEXT_INFO_CLASS ActivationContextInfoClass = ActivationContextBasicInformation;

#if !defined(BUILD_WOW6432)
    BASE_API_MSG m;
    PBASE_CREATETHREAD_MSG a = &m.u.CreateThread;
#endif

#if defined(WX86) || defined(_AXP64_)
    BOOL bWx86 = FALSE;
    HANDLE Wx86Info;
    PWX86TIB Wx86Tib;
#endif



    //
    // Allocate a stack for this thread in the address space of the target
    // process.
    //
    if (dwCreationFlags&STACK_SIZE_PARAM_IS_A_RESERVATION) {
        Status = BaseCreateStack (hProcess,
                                  0L,
                                  dwStackSize,
                                  &InitialTeb);
    } else {
        Status = BaseCreateStack (hProcess,
                                  dwStackSize,
                                  0L,
                                  &InitialTeb);
    }

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return NULL;
    }

    //
    // Create an initial context for the new thread.
    //

    BaseInitializeContext(
        &ThreadContext,
        lpParameter,
        (PVOID)lpStartAddress,
        InitialTeb.StackBase,
        BaseContextTypeThread
        );

    pObja = BaseFormatObjectAttributes(&Obja,lpThreadAttributes,NULL);

    Status = NtCreateThread(
                &Handle,
                THREAD_ALL_ACCESS,
                pObja,
                hProcess,
                &ClientId,
                &ThreadContext,
                &InitialTeb,
                TRUE // CreateSuspended
                );
    if (!NT_SUCCESS(Status)) {
        BaseFreeThreadStack(hProcess,NULL, &InitialTeb);
        BaseSetLastNTError(Status);
        return NULL;
    }

    __try {
        // If the current thread has a non-default, inheriting activation context active, send it
        // on over to the new thread.
        if (hProcess == NtCurrentProcess()) {
            THREAD_BASIC_INFORMATION tbi;
            ULONG_PTR Cookie; // not really used but non-optional parameter

            // We need the TEB pointer for the new thread...
            Status = NtQueryInformationThread(
                Handle,
                ThreadBasicInformation,
                &tbi,
                sizeof(tbi),
                NULL);
            if (!NT_SUCCESS(Status)) {
                DbgPrint("SXS: %s - Failing thread create becuase NtQueryInformationThread() failed with status %08lx\n", __FUNCTION__, Status);
                __leave;
            }

            // There might be some per-context activation going on in the current thread;
            // we need to propogate it to the new thread.
            Status =
                RtlQueryInformationActivationContext(
                    RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_USE_ACTIVE_ACTIVATION_CONTEXT,
                    NULL,
                    0,
                    ActivationContextInfoClass,
                    &ActivationContextInfo,
                    sizeof(ActivationContextInfo),
                    NULL       
                    );
            if (!NT_SUCCESS(Status)) {
                DbgPrint("SXS: %s - Failing thread create because RtlQueryInformationActivationContext() failed with status %08lx\n", __FUNCTION__, Status);
                __leave;
            }

            // Only do the propogation if an activation context other than the process default is active and the NO_INHERIT flag isn't set.
            if ((ActivationContextInfo.ActivationContext != NULL) &&
                (!(ActivationContextInfo.Flags & ACTIVATION_CONTEXT_FLAG_NO_INHERIT))) {
                Status = RtlActivateActivationContextEx(
                    RTL_ACTIVATE_ACTIVATION_CONTEXT_EX_FLAG_RELEASE_ON_STACK_DEALLOCATION,
                    tbi.TebBaseAddress,
                    ActivationContextInfo.ActivationContext,
                    &Cookie);
                if (!NT_SUCCESS(Status)) {
                    DbgPrint("SXS: %s - Failing thread create because RtlActivateActivationContextEx() failed with status %08lx\n", __FUNCTION__, Status);
                    __leave;
                }
            }
        }


        //
        // Call the Windows server to let it know about the
        // thread.
        //
        if ( !BaseRunningInServerProcess ) {

#if defined(BUILD_WOW6432)
            Status = CsrBasepCreateThread(Handle,
                                          ClientId
                                          );
#else
            a->ThreadHandle = Handle;
            a->ClientId = ClientId;
            CsrClientCallServer( (PCSR_API_MSG)&m,
                                 NULL,
                                 CSR_MAKE_API_NUMBER( BASESRV_SERVERDLL_INDEX,
                                                      BasepCreateThread
                                                    ),
                                 sizeof( *a )
                               );

            Status = m.ReturnValue;
#endif
        } else {
            if (hProcess != NtCurrentProcess()) {
                CSRREMOTEPROCPROC ProcAddress;
                ProcAddress = (CSRREMOTEPROCPROC)GetProcAddress(
                                                    GetModuleHandleA("csrsrv"),
                                                    "CsrCreateRemoteThread"
                                                    );
                if (ProcAddress) {
                    Status = (ProcAddress)(Handle, &ClientId);
                }
            }
        }


        if (!NT_SUCCESS(Status)) {
            Status = (NTSTATUS)STATUS_NO_MEMORY;
        } else {

            if ( ARGUMENT_PRESENT(lpThreadId) ) {
                *lpThreadId = HandleToUlong(ClientId.UniqueThread);
            }

            if (!( dwCreationFlags & CREATE_SUSPENDED) ) {
                NtResumeThread(Handle,&i);
            }
        }

    } __finally {
        if (ActivationContextInfo.ActivationContext != NULL) {
            RtlReleaseActivationContext(ActivationContextInfo.ActivationContext);
        }

        if (!NT_SUCCESS(Status)) {
            //
            // A second release is needed because we activated the activation context
            // on the new thread but we did not succeed in completing creation of the
            // thread. Had the thread been created, it would have deactivated the
            // activation context upon exit (RtlFreeThreadActivationContextStack).
            // This extra addref/releasing is triggered
            // by the flags ACTIVATE_ACTIVATION_CONTEXT_FLAG_RELEASE_ON_STACK_DEALLOCATION
            // and ACTIVATION_CONTEXT_STACK_FRAME_RELEASE_ON_DEACTIVATION.
            //
            if (ActivationContextInfo.ActivationContext != NULL) {
                RtlReleaseActivationContext (ActivationContextInfo.ActivationContext);
            }

            NtTerminateThread (Handle, Status);

            //
            // Wait for the thread before deleting its stack. the kernel might be in the
            // process of writing to it until we exit (say in user APC dispatch).
            //

            WaitForSingleObject (Handle, INFINITE);

            BaseFreeThreadStack (hProcess,
                                 Handle,
                                 &InitialTeb);
            NtClose (Handle);
            BaseSetLastNTError (Status);
            Handle = NULL;
        }
    }


    return Handle;
}

NTSTATUS
NTAPI
BaseCreateThreadPoolThread(
    PUSER_THREAD_START_ROUTINE Function,
    PVOID Parameter,
    HANDLE * ThreadHandleReturn
    )
{
    NTSTATUS Status;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    RtlActivateActivationContextUnsafeFast(&Frame, NULL);
    __try {
        *ThreadHandleReturn
            = CreateRemoteThread(
                NtCurrentProcess(),
                NULL,
                0,
                (LPTHREAD_START_ROUTINE) Function,
                Parameter,
                CREATE_SUSPENDED,
                NULL);

        if (*ThreadHandleReturn) {
            Status = STATUS_SUCCESS;
        } else {
            Status = NtCurrentTeb()->LastStatusValue;

            if (NT_SUCCESS(Status)) {
                Status = STATUS_UNSUCCESSFUL;
            }
        }
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&Frame);
    }

    return Status;
}

NTSTATUS
NTAPI
BaseExitThreadPoolThread(
    NTSTATUS Status
    )
{
    ExitThread( (DWORD) Status );
    return STATUS_SUCCESS ;
}

HANDLE
WINAPI
OpenThread(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwThreadId
    )

/*++

Routine Description:

    A handle to a thread object may be created using OpenThread.

    Opening a thread creates a handle to the specified thread.
    Associated with the thread handle is a set of access rights that
    may be performed using the thread handle.  The caller specifies the
    desired access to the thread using the DesiredAccess parameter.

Arguments:

    mDesiredAccess - Supplies the desired access to the thread object.
        For NT/Win32, this access is checked against any security
        descriptor on the target thread.  The following object type
        specific access flags can be specified in addition to the
        STANDARD_RIGHTS_REQUIRED access flags.

        DesiredAccess Flags:

        THREAD_TERMINATE - This access is required to terminate the
            thread using TerminateThread.

        THREAD_SUSPEND_RESUME - This access is required to suspend and
            resume the thread using SuspendThread and ResumeThread.

        THREAD_GET_CONTEXT - This access is required to use the
            GetThreadContext API on a thread object.

        THREAD_SET_CONTEXT - This access is required to use the
            SetThreadContext API on a thread object.

        THREAD_SET_INFORMATION - This access is required to set certain
            information in the thread object.

        THREAD_SET_THREAD_TOKEN - This access is required to set the
            thread token using SetTokenInformation.

        THREAD_QUERY_INFORMATION - This access is required to read
            certain information from the thread object.

        SYNCHRONIZE - This access is required to wait on a thread object.

        THREAD_ALL_ACCESS - This set of access flags specifies all of the
            possible access flags for a thread object.

    bInheritHandle - Supplies a flag that indicates whether or not the
        returned handle is to be inherited by a new process during
        process creation.  A value of TRUE indicates that the new
        process will inherit the handle.

    dwThreadId - Supplies the thread id of the thread to open.

Return Value:

    NON-NULL - Returns an open handle to the specified thread.  The
        handle may be used by the calling process in any API that
        requires a handle to a thread.  If the open is successful, the
        handle is granted access to the thread object only to the
        extent that it requested access through the DesiredAccess
        parameter.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    CLIENT_ID ClientId;

    ClientId.UniqueThread = (HANDLE)LongToHandle(dwThreadId);
    ClientId.UniqueProcess = (HANDLE)NULL;

    InitializeObjectAttributes(
        &Obja,
        NULL,
        (bInheritHandle ? OBJ_INHERIT : 0),
        NULL,
        NULL
        );
    Status = NtOpenThread(
                &Handle,
                (ACCESS_MASK)dwDesiredAccess,
                &Obja,
                &ClientId
                );
    if ( NT_SUCCESS(Status) ) {
        return Handle;
        }
    else {
        BaseSetLastNTError(Status);
        return NULL;
        }
}


BOOL
APIENTRY
SetThreadPriority(
    HANDLE hThread,
    int nPriority
    )

/*++

Routine Description:

    The specified thread's priority can be set using SetThreadPriority.

    A thread's priority may be set using SetThreadPriority.  This call
    allows the thread's relative execution importance to be communicated
    to the system.  The system normally schedules threads according to
    their priority.  The system is free to temporarily boost the
    priority of a thread when signifigant events occur (e.g.  keyboard
    or mouse input...).  Similarly, as a thread runs without blocking,
    the system will decay its priority.  The system will never decay the
    priority below the value set by this call.

    In the absence of system originated priority boosts, threads will be
    scheduled in a round-robin fashion at each priority level from
    THREAD_PRIORITY_TIME_CRITICAL to THREAD_PRIORITY_IDLE.  Only when there
    are no runnable threads at a higher level, will scheduling of
    threads at a lower level take place.

    All threads initially start at THREAD_PRIORITY_NORMAL.

    If for some reason the thread needs more priority, it can be
    switched to THREAD_PRIORITY_ABOVE_NORMAL or THREAD_PRIORITY_HIGHEST.
    Switching to THREAD_PRIORITY_TIME_CRITICAL should only be done in extreme
    situations.  Since these threads are given the highes priority, they
    should only run in short bursts.  Running for long durations will
    soak up the systems processing bandwidth starving threads at lower
    levels.

    If a thread needs to do low priority work, or should only run there
    is nothing else to do, its priority should be set to
    THREAD_PRIORITY_BELOW_NORMAL or THREAD_PRIORITY_LOWEST.  For extreme
    cases, THREAD_PRIORITY_IDLE can be used.

    Care must be taken when manipulating priorites.  If priorities are
    used carelessly (every thread is set to THREAD_PRIORITY_TIME_CRITICAL),
    the effects of priority modifications can produce undesireable
    effects (e.g.  starvation, no effect...).

Arguments:

    hThread - Supplies a handle to the thread whose priority is to be
        set.  The handle must have been created with
        THREAD_SET_INFORMATION access.

    nPriority - Supplies the priority value for the thread.  The
        following five priority values (ordered from lowest priority to
        highest priority) are allowed.

        nPriority Values:

        THREAD_PRIORITY_IDLE - The thread's priority should be set to
            the lowest possible settable priority.

        THREAD_PRIORITY_LOWEST - The thread's priority should be set to
            the next lowest possible settable priority.

        THREAD_PRIORITY_BELOW_NORMAL - The thread's priority should be
            set to just below normal.

        THREAD_PRIORITY_NORMAL - The thread's priority should be set to
            the normal priority value.  This is the value that all
            threads begin execution at.

        THREAD_PRIORITY_ABOVE_NORMAL - The thread's priority should be
            set to just above normal priority.

        THREAD_PRIORITY_HIGHEST - The thread's priority should be set to
            the next highest possible settable priority.

        THREAD_PRIORITY_TIME_CRITICAL - The thread's priority should be set
            to the highest possible settable priority.  This priority is
            very likely to interfere with normal operation of the
            system.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.
--*/

{
    NTSTATUS Status;
    LONG BasePriority;

    BasePriority = (LONG)nPriority;


    //
    // saturation is indicated by calling with a value of 16 or -16
    //

    if ( BasePriority == THREAD_PRIORITY_TIME_CRITICAL ) {
        BasePriority = ((HIGH_PRIORITY + 1) / 2);
        }
    else if ( BasePriority == THREAD_PRIORITY_IDLE ) {
        BasePriority = -((HIGH_PRIORITY + 1) / 2);
        }
    Status = NtSetInformationThread(
                hThread,
                ThreadBasePriority,
                &BasePriority,
                sizeof(BasePriority)
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return TRUE;
}

int
APIENTRY
GetThreadPriority(
    HANDLE hThread
    )

/*++

Routine Description:

    The specified thread's priority can be read using GetThreadPriority.

Arguments:

    hThread - Supplies a handle to the thread whose priority is to be
        set.  The handle must have been created with
        THREAD_QUERY_INFORMATION access.

Return Value:

    The value of the thread's current priority is returned.  If an error
    occured, the value THREAD_PRIORITY_ERROR_RETURN is returned.
    Extended error status is available using GetLastError.

--*/

{
    NTSTATUS Status;
    THREAD_BASIC_INFORMATION BasicInfo;
    int returnvalue;

    Status = NtQueryInformationThread(
                hThread,
                ThreadBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return (int)THREAD_PRIORITY_ERROR_RETURN;
        }

    returnvalue = (int)BasicInfo.BasePriority;
    if ( returnvalue == ((HIGH_PRIORITY + 1) / 2) ) {
        returnvalue = THREAD_PRIORITY_TIME_CRITICAL;
        }
    else if ( returnvalue == -((HIGH_PRIORITY + 1) / 2) ) {
        returnvalue = THREAD_PRIORITY_IDLE;
        }
    return returnvalue;
}

BOOL
WINAPI
SetThreadPriorityBoost(
    HANDLE hThread,
    BOOL bDisablePriorityBoost
    )
{
    NTSTATUS Status;
    ULONG DisableBoost;

    DisableBoost = bDisablePriorityBoost ? 1 : 0;

    Status = NtSetInformationThread(
                hThread,
                ThreadPriorityBoost,
                &DisableBoost,
                sizeof(DisableBoost)
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return TRUE;

}

BOOL
WINAPI
GetThreadPriorityBoost(
    HANDLE hThread,
    PBOOL pDisablePriorityBoost
    )
{
    NTSTATUS Status;
    DWORD DisableBoost;

    Status = NtQueryInformationThread(
                hThread,
                ThreadPriorityBoost,
                &DisableBoost,
                sizeof(DisableBoost),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }


    *pDisablePriorityBoost = DisableBoost;

    return TRUE;
}

VOID
BaseRundownFls (
    IN PFLS_DATA FlsData
    )

/*++

Routine Description:

    This routine removes the specified fiber local storage data structure
    from the process list and runs down data entries by invoking callback
    routines as necessary.

Arguments:

    FlsData - Supplies a pointer to fiber local storage data structure.

Return Value:

    None.

--*/

{

    PFLS_CALLBACK_FUNCTION Callback;
    DWORD HighIndex;
    DWORD Index;
    PPEB Peb;

    //
    // Remove the fiber local storage data structure from the process list.
    //

    Peb = NtCurrentPeb();
    RtlAcquirePebLock();
    try {
        HighIndex = Peb->FlsHighIndex;
        RemoveEntryList(&FlsData->Entry);

    } finally {
        RtlReleasePebLock();
    }

    //
    // Scan the process fiber local storage callback array and invoke callback
    // routines as necessary.
    //
    // N.B. If the callback pointers are corrupted or a DLL has leaked memory
    //      and been freed, then an exception can occur during the processing
    //      of callbacks. This exception will be ignored and will stop callback
    //      processing.

    try {
        for (Index = 1; Index <= HighIndex; Index += 1) {
            Callback = Peb->FlsCallback[Index];
            if ((Callback != NULL) && (FlsData->Slots[Index] != NULL)) {
                (Callback)(FlsData->Slots[Index]);
            }
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }

    //
    // Deallocate fiber local storage data structure.
    //

    RtlFreeHeap(Peb->ProcessHeap, 0, FlsData);
    return;
}

VOID
APIENTRY
ExitThread(
    DWORD dwExitCode
    )

/*++

Routine Description:

    The current thread can exit using ExitThread.

    ExitThread is the prefered method of exiting a thread.  When this
    API is called (either explicitly or by returning from a thread
    procedure), The current thread's stack is deallocated and the thread
    terminates.  If the thread is the last thread in the process when
    this API is called, the behavior of this API does not change.  DLLs
    are not notified as a result of a call to ExitThread.

Arguments:

    dwExitCode - Supplies the termination status for the thread.

Return Value:

    None.

--*/

{

    PFIBER Fiber;
    MEMORY_BASIC_INFORMATION MemInfo;
    NTSTATUS st;
    ULONG LastThread;
    PTEB Teb = NtCurrentTeb();

#if DBG
    {
        //
        // Assert on exiting while holding loader lock.
        //

        PRTL_CRITICAL_SECTION LoaderLock;

        LoaderLock = NtCurrentPeb()->LoaderLock;
        if (LoaderLock != NULL) {
            ASSERT(Teb->ClientId.UniqueThread != LoaderLock->OwningThread);
        }
    }
#endif

    //
    // Check if this is the last thread in the process.
    //

    st = NtQueryInformationThread(NtCurrentThread(),
                                  ThreadAmILastThread,
                                  &LastThread,
                                  sizeof(LastThread),
                                  NULL);

    //
    // If this is the last thread in the process, then exit the process.
    // Otherwise, exit the thread.
    // 

    if ((st == STATUS_SUCCESS) && LastThread) {
        ExitProcess(dwExitCode);

    } else {
        RtlFreeThreadActivationContextStack();
        LdrShutdownThread();

        //
        // If expansion slots have been allocated, then free the memory.
        //
        // N.B. The following code needs to hold the PEB lock to prevent
        //      heap corruption.
        //

        if (Teb->TlsExpansionSlots != NULL) {
            RtlAcquirePebLock();
            try {
                RtlFreeHeap(RtlProcessHeap(), 0, Teb->TlsExpansionSlots);
                Teb->TlsExpansionSlots = NULL;
    
            } finally {
                RtlReleasePebLock();
            }
        }

        //
        // If a fiber local storage data structure has been allocated, then
        // rundown the structure.
        //

        if (Teb->FlsData != NULL) {
            BaseRundownFls((PFLS_DATA)Teb->FlsData);
            Teb->FlsData = NULL;
        }

        //
        // If the thread is associated with a fiber, then free the fiber
        // storage.
        //

        if (Teb->HasFiberData == TRUE) {
            Fiber = Teb->NtTib.FiberData;
            Teb->NtTib.FiberData = NULL;

            ASSERT(Fiber != NULL);

            RtlFreeHeap(RtlProcessHeap(), 0, Fiber);
        }

        Teb->FreeStackOnTermination = TRUE;
        NtTerminateThread(NULL, (NTSTATUS)dwExitCode);
        ExitProcess(dwExitCode);
    }
}

BOOL
APIENTRY
TerminateThread(
    HANDLE hThread,
    DWORD dwExitCode
    )

/*++

Routine Description:

    A thread may be terminated using TerminateThread.

    TerminateThread is used to cause a thread to terminate user-mode
    execution.  There is nothing a thread can to to predict or prevent
    when this occurs.  If a process has a handle with appropriate
    termination access to the thread or to the threads process, then the
    thread can be unconditionally terminated without notice.  When this
    occurs, the target thread has no chance to execute any user-mode
    code and its initial stack is not deallocated.  The thread attains a
    state of signaled satisfying any waits on the thread.  The thread's
    termination status is updated from its initial value of
    STATUS_PENDING to the value of the TerminationStatus parameter.
    Terminating a thread does not remove a thread from the system.  The
    thread is not removed from the system until the last handle to the
    thread is closed.

Arguments:

    hThread - Supplies a handle to the thread to terminate.  The handle
        must have been created with THREAD_TERMINATE access.

    dwExitCode - Supplies the termination status for the thread.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    NTSTATUS Status;

#if DBG
    PRTL_CRITICAL_SECTION LoaderLock;
    HANDLE ThreadId;
    THREAD_BASIC_INFORMATION ThreadInfo;
#endif

    if ( hThread == NULL ) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
        }

    //
    // Assert on suicide while holding loader lock
    //

#if DBG
    LoaderLock = NtCurrentPeb()->LoaderLock;
    if (LoaderLock) {
        Status = NtQueryInformationThread(
                                hThread,
                                ThreadBasicInformation,
                                &ThreadInfo,
                                sizeof(ThreadInfo),
                                NULL
                                );

        if (NT_SUCCESS(Status)) {
            ASSERT( NtCurrentTeb()->ClientId.UniqueThread != ThreadInfo.ClientId.UniqueThread ||
                    NtCurrentTeb()->ClientId.UniqueThread != LoaderLock->OwningThread);
            }
        }
#endif

    Status = NtTerminateThread(hThread,(NTSTATUS)dwExitCode);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}


BOOL
APIENTRY
GetExitCodeThread(
    HANDLE hThread,
    LPDWORD lpExitCode
    )

/*++

Routine Description:

    The termination status of a thread can be read using
    GetExitCodeThread.

    If a Thread is in the signaled state, calling this function returns
    the termination status of the thread.  If the thread is not yet
    signaled, the termination status returned is STILL_ACTIVE.

Arguments:

    hThread - Supplies a handle to the thread whose termination status is
        to be read.  The handle must have been created with
        THREAD_QUERY_INFORMATION access.

    lpExitCode - Returns the current termination status of the
        thread.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    THREAD_BASIC_INFORMATION BasicInformation;

    Status = NtQueryInformationThread(
                hThread,
                ThreadBasicInformation,
                &BasicInformation,
                sizeof(BasicInformation),
                NULL
                );

    if ( NT_SUCCESS(Status) ) {
        *lpExitCode = BasicInformation.ExitStatus;
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

HANDLE
APIENTRY
GetCurrentThread(
    VOID
    )

/*++

Routine Description:

    A pseudo handle to the current thread may be retrieved using
    GetCurrentThread.

    A special constant is exported by Win32 that is interpreted as a
    handle to the current thread.  This handle may be used to specify
    the current thread whenever a thread handle is required.  On Win32,
    this handle has THREAD_ALL_ACCESS to the current thread.  On
    NT/Win32, this handle has the maximum access allowed by any security
    descriptor placed on the current thread.

Arguments:

    None.

Return Value:

    Returns the pseudo handle of the current thread.

--*/

{
    return NtCurrentThread();
}

DWORD
APIENTRY
GetCurrentThreadId(
    VOID
    )

/*++

Routine Description:

The thread ID of the current thread may be retrieved using
GetCurrentThreadId.

Arguments:

    None.

Return Value:

    Returns a unique value representing the thread ID of the currently
    executing thread.  The return value may be used to identify a thread
    in the system.

--*/

{
    return HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread);
}

DWORD
APIENTRY
GetThreadId(
    HANDLE Thread
    )
/*++

Routine Description:

    Gets the thread ID of the thread open via the specified handle

Arguments:

    Thread - Handle of thread to do the query on

Return Value:

    Returns a unique value representing the thread ID of the
    executing thread.  The return value may be used to identify a thread
    in the system. If the function fails the return value is zero.

--*/

{
    NTSTATUS Status;
    THREAD_BASIC_INFORMATION tbi;

    Status = NtQueryInformationThread (Thread,
                                       ThreadBasicInformation,
                                       &tbi,
                                       sizeof (tbi),
                                       NULL);

    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return 0;
    }

    return HandleToUlong (tbi.ClientId.UniqueThread);
}

DWORD
APIENTRY
GetProcessIdOfThread(
    HANDLE Thread
    )
/*++

Routine Description:

    Gets the process ID of the thread opened via the specified handle

Arguments:

    Thread - Handle of thread to do the query on

Return Value:

    Returns a unique value representing the process ID of the
    executing thread.  The return value may be used to identify a process
    in the system. If the function fails the return value is zero.

--*/

{
    NTSTATUS Status;
    THREAD_BASIC_INFORMATION tbi;

    Status = NtQueryInformationThread (Thread,
                                       ThreadBasicInformation,
                                       &tbi,
                                       sizeof (tbi),
                                       NULL);

    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return 0;
    }

    return HandleToUlong (tbi.ClientId.UniqueProcess);
}

BOOL
APIENTRY
GetThreadContext(
    HANDLE hThread,
    LPCONTEXT lpContext
    )

/*++

Routine Description:

    The context of a specified thread can be retreived using
    GetThreadContext.

    This function is used to retreive the context of the specified
    thread.  The API allows selective context to be retrieved based on
    the value of the ContextFlags field of the context structure.  The
    specified thread does not have to be being debugged in order for
    this API to operate.  The caller must simply have a handle to the
    thread that was created with THREAD_GET_CONTEXT access.

Arguments:

    hThread - Supplies an open handle to a thread whose context is to be
        retreived.  The handle must have been created with
        THREAD_GET_CONTEXT access to the thread.

    lpContext - Supplies the address of a context structure that
        receives the appropriate context of the specified thread.  The
        value of the ContextFlags field of this structure specifies
        which portions of a threads context are to be retreived.  The
        context structure is highly machine specific.  There are
        currently two versions of the context structure.  One version
        exists for x86 processors, and another exists for MIPS
        processors.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;

    Status = NtGetContextThread (hThread, lpContext);

    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        return FALSE;
    } else {
        return TRUE;
    }
}

BOOL
APIENTRY
SetThreadContext(
    HANDLE hThread,
    CONST CONTEXT *lpContext
    )

/*++

Routine Description:

    This function is used to set the context in the specified thread.
    The API allows selective context to be set based on the value of the
    ContextFlags field of the context structure.  The specified thread
    does not have to be being debugged in order for this API to operate.
    The caller must simply have a handle to the thread that was created
    with THREAD_SET_CONTEXT access.

Arguments:

    hThread - Supplies an open handle to a thread whose context is to be
        written.  The handle must have been created with
        THREAD_SET_CONTEXT access to the thread.

    lpContext - Supplies the address of a context structure that
        contains the context that is to be set in the specified thread.
        The value of the ContextFlags field of this structure specifies
        which portions of a threads context are to be set.  Some values
        in the context structure are not settable and are silently set
        to the correct value.  This includes cpu status register bits
        that specify the priviledged processor mode, debug register
        global enabling bits, and other state that must be completely
        controlled by the operating system.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtSetContextThread(hThread,(PCONTEXT)lpContext);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    else {
        return TRUE;
        }
}

DWORD
APIENTRY
SuspendThread(
    HANDLE hThread
    )

/*++

Routine Description:

    A thread can be suspended using SuspendThread.

    Suspending a thread causes the thread to stop executing user-mode
    (or application) code.  Each thread has a suspend count (with a
    maximum value of MAXIMUM_SUSPEND_COUNT).  If the suspend count is
    greater than zero, the thread is suspended; otherwise, the thread is
    not suspended and is eligible for execution.

    Calling SuspendThread causes the target thread's suspend count to
    increment.  Attempting to increment past the maximum suspend count
    causes an error without incrementing the count.

Arguments:

    hThread - Supplies a handle to the thread that is to be suspended.
        The handle must have been created with THREAD_SUSPEND_RESUME
        access to the thread.

Return Value:

    -1 - The operation failed.  Extended error status is available using
         GetLastError.

    Other - The target thread was suspended. The return value is the thread's
        previous suspend count.

--*/

{
    NTSTATUS Status;
    DWORD PreviousSuspendCount;

    Status = NtSuspendThread(hThread,&PreviousSuspendCount);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return (DWORD)-1;
        }
    else {
        return PreviousSuspendCount;
        }
}

DWORD
APIENTRY
ResumeThread(
    IN HANDLE hThread
    )

/*++

Routine Description:

    A thread can be resumed using ResumeThread.

    Resuming a thread object checks the suspend count of the subject
    thread.  If the suspend count is zero, then the thread is not
    currently suspended and no operation is performed.  Otherwise, the
    subject thread's suspend count is decremented.  If the resultant
    value is zero , then the execution of the subject thread is resumed.

    The previous suspend count is returned as the function value.  If
    the return value is zero, then the subject thread was not previously
    suspended.  If the return value is one, then the subject thread's
    the subject thread is still suspended and must be resumed the number
    of times specified by the return value minus one before it will
    actually resume execution.

    Note that while reporting debug events, all threads withing the
    reporting process are frozen.  This has nothing to do with
    SuspendThread or ResumeThread.  Debuggers are expected to use
    SuspendThread and ResumeThread to limit the set of threads that can
    execute within a process.  By suspending all threads in a process
    except for the one reporting a debug event, it is possible to
    "single step" a single thread.  The other threads will not be
    released by a continue if they are suspended.

Arguments:

    hThread - Supplies a handle to the thread that is to be resumed.
        The handle must have been created with THREAD_SUSPEND_RESUME
        access to the thread.

Return Value:

    -1 - The operation failed.  Extended error status is available using
        GetLastError.

    Other - The target thread was resumed (or was not previously
        suspended).  The return value is the thread's previous suspend
        count.

--*/

{
    NTSTATUS Status;
    DWORD PreviousSuspendCount;

    Status = NtResumeThread(hThread,&PreviousSuspendCount);

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return (DWORD)-1;
        }
    else {
        return PreviousSuspendCount;
        }
}

VOID
APIENTRY
RaiseException(
    DWORD dwExceptionCode,
    DWORD dwExceptionFlags,
    DWORD nNumberOfArguments,
    CONST ULONG_PTR *lpArguments
    )

/*++

Routine Description:

    Raising an exception causes the exception dispatcher to go through
    its search for an exception handler.  This includes debugger
    notification, frame based handler searching, and system default
    actions.

Arguments:

    dwExceptionCode - Supplies the exception code of the exception being
        raised.  This value may be obtained in exception filters and in
        exception handlers by calling GetExceptionCode.

    dwExceptionFlags - Supplies a set of flags associated with the exception.

    dwExceptionFlags Flags:

        EXCEPTION_NONCONTINUABLE - The exception is non-continuable.
            Returning EXCEPTION_CONTINUE_EXECUTION from an exception
            marked in this way causes the
            STATUS_NONCONTINUABLE_EXCEPTION exception.

    nNumberOfArguments - Supplies the number of arguments associated
        with the exception.  This value may not exceed
        EXCEPTION_MAXIMUM_PARAMETERS.  This parameter is ignored if
        lpArguments is NULL.

    lpArguments - An optional parameter, that if present supplies the
        arguments for the exception.

Return Value:

    None.

--*/

{
    EXCEPTION_RECORD ExceptionRecord;
    ULONG n;
    PULONG_PTR s,d;
    ExceptionRecord.ExceptionCode = (DWORD)dwExceptionCode;
    ExceptionRecord.ExceptionFlags = dwExceptionFlags & EXCEPTION_NONCONTINUABLE;
    ExceptionRecord.ExceptionRecord = NULL;
    ExceptionRecord.ExceptionAddress = (PVOID)RaiseException;
    if ( ARGUMENT_PRESENT(lpArguments) ) {
        n =  nNumberOfArguments;
        if ( n > EXCEPTION_MAXIMUM_PARAMETERS ) {
            n = EXCEPTION_MAXIMUM_PARAMETERS;
            }
        ExceptionRecord.NumberParameters = n;
        s = (PULONG_PTR)lpArguments;
        d = ExceptionRecord.ExceptionInformation;
        while(n--){
            *d++ = *s++;
            }
        }
    else {
        ExceptionRecord.NumberParameters = 0;
        }
    RtlRaiseException(&ExceptionRecord);
}


BOOLEAN BasepAlreadyHadHardError = FALSE;

LPTOP_LEVEL_EXCEPTION_FILTER BasepCurrentTopLevelFilter;

LPTOP_LEVEL_EXCEPTION_FILTER
WINAPI
SetUnhandledExceptionFilter(
    LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    )

/*++

Routine Description:

    This function allows an application to supersede the top level
    exception handler that Win32 places at the top of each thread and
    process.

    If an exception occurs, and it makes it to the Win32 unhandled
    exception filter, and the process is not being debugged, the Win32
    filter will call the unhandled exception filter specified by
    lpTopLevelExceptionFilter.

    This filter may return:

        EXCEPTION_EXECUTE_HANDLER - Return from the Win32
            UnhandledExceptionFilter and execute the associated
            exception handler.  This will usually result in process
            termination

        EXCEPTION_CONTINUE_EXECUTION - Return from the Win32
            UnhandledExceptionFilter and continue execution from the
            point of the exception.  The filter is of course free to
            modify the continuation state my modifying the passed
            exception information.

        EXCEPTION_CONTINUE_SEARCH - Proceed with normal execution of the
            Win32 UnhandledExceptionFilter.  e.g.  obey the SetErrorMode
            flags, or invoke the Application Error popup.

    This function is not a general vectored exception handling
    mechanism.  It is intended to be used to establish a per-process
    exception filter that can monitor unhandled exceptions at the
    process level and respond to these exceptions appropriately.

Arguments:

    lpTopLevelExceptionFilter - Supplies the address of a top level
        filter function that will be called whenever the Win32
        UnhandledExceptionFilter gets control, and the process is NOT
        being debugged.  A value of NULL specifies default handling
        within the Win32 UnhandledExceptionFilter.


Return Value:

    This function returns the address of the previous exception filter
    established with this API.  A value of NULL means that there is no
    current top level handler.

--*/

{
    LPTOP_LEVEL_EXCEPTION_FILTER PreviousTopLevelFilter;

    PreviousTopLevelFilter = BasepCurrentTopLevelFilter;
    BasepCurrentTopLevelFilter = lpTopLevelExceptionFilter;

    return PreviousTopLevelFilter;
}

LONG
BasepCheckForReadOnlyResource(
    PVOID Va
    )
{
    SIZE_T RegionSize;
    ULONG OldProtect;
    NTSTATUS Status;
    MEMORY_BASIC_INFORMATION MemInfo;
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory;
    ULONG ResourceSize;
    char *rbase, *va;
    LONG ReturnValue;

    //
    // Locate the base address that continas this va
    //

    Status = NtQueryVirtualMemory(
                NtCurrentProcess(),
                Va,
                MemoryBasicInformation,
                (PVOID)&MemInfo,
                sizeof(MemInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        return EXCEPTION_CONTINUE_SEARCH;
        }

    //
    // if the va is readonly and in an image then continue
    //

    if ( !((MemInfo.Protect == PAGE_READONLY) && (MemInfo.Type == MEM_IMAGE)) ){
        return EXCEPTION_CONTINUE_SEARCH;
        }

    ReturnValue = EXCEPTION_CONTINUE_SEARCH;

    try {
        ResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)
            RtlImageDirectoryEntryToData(MemInfo.AllocationBase,
                                         TRUE,
                                         IMAGE_DIRECTORY_ENTRY_RESOURCE,
                                         &ResourceSize
                                         );

        rbase = (char *)ResourceDirectory;
        va = (char *)Va;

        if ( rbase && va >= rbase && va < rbase+ResourceSize ) {
            RegionSize = 1;
            Status = NtProtectVirtualMemory(
                        NtCurrentProcess(),
                        &va,
                        &RegionSize,
                        PAGE_READWRITE,
                        &OldProtect
                        );
            if ( NT_SUCCESS(Status) ) {
                ReturnValue = EXCEPTION_CONTINUE_EXECUTION;
                }
            }
        }
    except (EXCEPTION_EXECUTE_HANDLER) {
        ;
        }

    return ReturnValue;
}

// 
// Used for fault reporting in UnhandledExceptionFilter
//
static WCHAR *WStrStrIA(const WCHAR *cs1, const WCHAR *cs2)
{
    WCHAR *cp = (WCHAR *)cs1;
    WCHAR *s1, *s2;

    while (*cp != L'\0')
    {
        s1 = cp;
        s2 = (WCHAR *)cs2;

        while (*s1 != L'\0' && *s2 !=L'\0' && (towlower(*s1) - towlower(*s2)) == 0)
            s1++, s2++;

        if (*s2 == L'\0')
             return(cp);

        cp++;
    }

    return(NULL);
}


LONG
UnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    EFaultRepRetVal frrv = frrvErrNoDW;
    NTSTATUS Status;
    ULONG_PTR Parameters[ 4 ];
    ULONG Response;
    HANDLE DebugPort;
    WCHAR AeDebuggerCmdLine[256];
    CHAR AeAutoDebugString[8];
    BOOLEAN AeAutoDebug;
    ULONG ResponseFlag;
    LONG FilterReturn;
    PRTL_CRITICAL_SECTION PebLockPointer;
    JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimit;

    //
    // If we take a write fault, then attempt to make the memory writable. If this
    // succeeds, then silently proceed.
    //

    if ( ExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_ACCESS_VIOLATION
        && ExceptionInfo->ExceptionRecord->ExceptionInformation[0] ) {

        FilterReturn = BasepCheckForReadOnlyResource((PVOID)ExceptionInfo->ExceptionRecord->ExceptionInformation[1]);

        if ( FilterReturn == EXCEPTION_CONTINUE_EXECUTION ) {
            return FilterReturn;
            }
        }

    //
    // If the process is being debugged, just let the exception happen
    // so that the debugger can see it. This way the debugger can ignore
    // all first chance exceptions.
    //

    DebugPort = (HANDLE)NULL;
    Status = NtQueryInformationProcess(
                GetCurrentProcess(),
                ProcessDebugPort,
                (PVOID)&DebugPort,
                sizeof(DebugPort),
                NULL
                );

    if ( NT_SUCCESS(Status) && DebugPort ) {

        //
        // Process is being debugged.
        // Return a code that specifies that the exception
        // processing is to continue
        //
        
        return EXCEPTION_CONTINUE_SEARCH;
    }

    if ( BasepCurrentTopLevelFilter ) {
        FilterReturn = (BasepCurrentTopLevelFilter)(ExceptionInfo);
        if ( FilterReturn == EXCEPTION_EXECUTE_HANDLER ||
             FilterReturn == EXCEPTION_CONTINUE_EXECUTION ) {
            return FilterReturn;
            }
        }

    if ( (GetErrorMode() & SEM_NOGPFAULTERRORBOX)
         || (RtlGetThreadErrorMode() & RTL_ERRORMODE_NOGPFAULTERRORBOX)) {
        return EXCEPTION_EXECUTE_HANDLER;
        }

    //
    // See if the process's job has been programmed to NOGPFAULTERRORBOX
    //
    Status = NtQueryInformationJobObject(
                NULL,
                JobObjectBasicLimitInformation,
                &BasicLimit,
                sizeof(BasicLimit),
                NULL
                );
    if ( NT_SUCCESS(Status) && (BasicLimit.LimitFlags & JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION) ) {
        return EXCEPTION_EXECUTE_HANDLER;
        }

    //
    // The process is not being debugged, so do the hard error
    // popup.
    //

    Parameters[ 0 ] = (ULONG_PTR)ExceptionInfo->ExceptionRecord->ExceptionCode;
    Parameters[ 1 ] = (ULONG_PTR)ExceptionInfo->ExceptionRecord->ExceptionAddress;

    //
    // For inpage i/o errors, juggle the real status code to overwrite the
    // read/write field
    //

    if ( ExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_IN_PAGE_ERROR ) {
        Parameters[ 2 ] = ExceptionInfo->ExceptionRecord->ExceptionInformation[ 2 ];
        }
    else {
        Parameters[ 2 ] = ExceptionInfo->ExceptionRecord->ExceptionInformation[ 0 ];
        }

    Parameters[ 3 ] = ExceptionInfo->ExceptionRecord->ExceptionInformation[ 1 ];

    //
    // See if a debugger has been programmed in. If so, use the
    // debugger specified. If not then there is no AE Cancel support
    // DEVL systems will default the debugger command line. Retail
    // systems will not.
    // Also, check to see if we need to report the exception up to anyone
    //

    ResponseFlag = OptionOk;
    AeAutoDebug = FALSE;

    //
    // If we are holding the PebLock, then the createprocess will fail
    // because a new thread will also need this lock. Avoid this by peeking
    // inside the PebLock and looking to see if we own it. If we do, then just allow
    // a regular popup.
    //

    PebLockPointer = NtCurrentPeb()->FastPebLock;

    if ( PebLockPointer->OwningThread != NtCurrentTeb()->ClientId.UniqueThread ) {
        
        HMODULE hmodFaultRep = NULL;

        if (GetProfileStringW(L"AeDebug",
                              L"Debugger",
                              NULL,
                              AeDebuggerCmdLine,
                              RTL_NUMBER_OF(AeDebuggerCmdLine)-1)) {
                ResponseFlag = OptionOkCancel;
        }

        if (GetProfileString ("AeDebug",
                              "Auto",
                              "0",
                              AeAutoDebugString,
                              sizeof(AeAutoDebugString)-1)) {

            if (!strcmp (AeAutoDebugString, "1")) {
                if (ResponseFlag == OptionOkCancel) {
                        AeAutoDebug = TRUE;
                }
            }
        }

        // 
        // Attempt to report the fault back to Microsoft.  ReportFault 
        //  will return the following:
        //  frrvErrNoDW:    Always show our own fault notification.
        // 
        //  frrvErrTimeout: see frrvOkHeadless
        //  frrvOkQueued:   see frrvOkHeadless
        //  frrvOkHeadless: If we need to ask whether to launch a debugger,
        //                   then we ask.  Otherwise, show nothing else.
        //
        //  frrvOk:         see frrvOkManifest
        //  frrvOkManifest: We're done.  Show nothing else.
        //
        //  frrvLaunchDebugger: Launch the configured debugger.
        //

        frrv = frrvErrNoDW;
        if ( BasepAlreadyHadHardError == FALSE &&
             (AeAutoDebug == FALSE ||
              WStrStrIA(AeDebuggerCmdLine, L"drwtsn32") != NULL)) {
            WCHAR wszDll[MAX_PATH];
            PVOID pvLdrLockCookie = NULL;
            ULONG ulLockState = 0;

            /*
             *  Insure that we get the full %sys32%\faultrep.dll" correctly formed path, 
             *  or else we can fail in a well mannered way.
             */
            if (GetSystemDirectoryW(wszDll, (sizeof(wszDll) / sizeof(WCHAR)) - 1 - wcslen (L"\\faultrep.dll")))
            {
                wcscat(wszDll, L"\\faultrep.dll");
            }
            else
                wszDll[0] = 0;

            // make sure that no one else owns the loader lock because we
            //  could otherwise deadlock
            LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY, &ulLockState, 
                              &pvLdrLockCookie);
            if (ulLockState == LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED) {
                hmodFaultRep = LoadLibraryExW(wszDll, NULL, 0);
                LdrUnlockLoaderLock(0, pvLdrLockCookie);
            }

            if (hmodFaultRep != NULL) {
                pfn_REPORTFAULT  pfn;
                DWORD            dwDebug;

                // parameter 2 to ReportFault should be:
                //  froNoDebugWait: don't display a debug button but wait 
                //                   for DW to finish- this is a special 
                //                   case to make sure DW is done before 
                //                   Dr. Watson starts
                //  froNoDebugWait : don't display a debug button
                //  froDebug : display a debug button and wait for DW to 
                //              finish
                if (ResponseFlag == OptionOkCancel) {
                   dwDebug = (AeAutoDebug) ? froNoDebugWait : froDebug;
                } else {
                   dwDebug = froNoDebug;
                }

                pfn = (pfn_REPORTFAULT)GetProcAddress(hmodFaultRep, 
                                                      "ReportFault");
                if (pfn != NULL)
                    frrv = (*pfn)(ExceptionInfo, dwDebug);

                FreeLibrary(hmodFaultRep);
                hmodFaultRep = NULL;
            }
        }

        // 
        // Since we're supposed to launch the debugger anyway, just set the 
        // AeAutoDebug flag to true to minimize code munging below
        //
        if ( frrv == frrvLaunchDebugger ) {
            AeAutoDebug = TRUE;
        }

    }

    // 
    // only display this dialog if we couldn't show DW & we're not set to 
    //  automatically launch a debugger.  The conditions here are:
    //  1.  cannot be directly launching a debugger (auto == 1)
    //  2a. DW must have failed to launch
    //      -or- 
    //      we needed to ask the user if he wanted to debug but could not (due
    //       to either no UI being shown or us not being able to wait long enuf
    //       to find out.)
    if ( !AeAutoDebug && 
         ( frrv == frrvErrNoDW || 
           ( ResponseFlag == OptionOkCancel && 
             ( frrv == frrvErrTimeout || frrv == frrvOkQueued || 
               frrv == frrvOkHeadless ) ) ) )
        {
        Status =NtRaiseHardError( STATUS_UNHANDLED_EXCEPTION | HARDERROR_OVERRIDE_ERRORMODE,
                                  4,
                                  0,
                                  Parameters,
                                  BasepAlreadyHadHardError ? OptionOk : ResponseFlag,
                                  &Response
                                );

        }
    else {
        Status = STATUS_SUCCESS;
        Response = (AeAutoDebug) ? ResponseCancel : ResponseOk;
        }

    //
    // Internally, send OkCancel. If we get back Ok then die.
    // If we get back Cancel, then enter the debugger
    //

    if ( NT_SUCCESS(Status) && Response == ResponseCancel && BasepAlreadyHadHardError == FALSE) {
        if ( !BaseRunningInServerProcess ) {
            BOOL b = FALSE;
            STARTUPINFOW StartupInfo;
            PROCESS_INFORMATION ProcessInformation;
            PWCHAR CmdLine;
            NTSTATUS Status;
            HANDLE EventHandle;
            SECURITY_ATTRIBUTES sa;
            HANDLE CurrentProcess;
            HANDLE CurrentThread;
            ULONG cchSysDir;

            // 21 => 10 for the pid, 10 for the handle, 1 for the
            // trailing null.
            ULONG cchAeCmdLine = wcslen(AeDebuggerCmdLine) + 21;
            
            //
            // Duplicate the processes handle. We make it inheritable so the debugger will get a copy of it.
            // We do this to prevent the process ID from being reused if this process gets killed before the
            // attach occurs. Process ID are reused very quickly and attaching to the wrong process is
            // confusing.
            //
            if (!DuplicateHandle (GetCurrentProcess (),
                                  GetCurrentProcess (),
                                  GetCurrentProcess (),
                                  &CurrentProcess,
                                  0,
                                  TRUE,
                                  DUPLICATE_SAME_ACCESS)) {
                CurrentProcess = NULL;
            }

            if (!DuplicateHandle (GetCurrentProcess (),
                                  GetCurrentThread (),
                                  GetCurrentProcess (),
                                  &CurrentThread,
                                  0,
                                  TRUE,
                                  DUPLICATE_SAME_ACCESS)) {
                CurrentThread = NULL;
            }

            sa.nLength = sizeof(sa);
            sa.lpSecurityDescriptor = NULL;
            sa.bInheritHandle = TRUE;
            EventHandle = CreateEvent(&sa,TRUE,FALSE,NULL);
            RtlZeroMemory(&StartupInfo,sizeof(StartupInfo));

            //
            // If there's a leading quote, assume that the writer of
            // the regkey knew what it was doing.  Otherwise, if it's
            // not a relative name, assume the writer knew what it was 
            // doing.
            //
            if (AeDebuggerCmdLine[0] != L'\"'
                && RtlDetermineDosPathNameType_U(AeDebuggerCmdLine)
                == RtlPathTypeRelative) {
                //
                // There's no leading quote, and it's a relative name
                // -- so force it into the system directory
                //

                cchSysDir = GetSystemDirectoryW(NULL, 0);
                if (!cchSysDir || (cchSysDir + cchAeCmdLine + 1) > MAX_PATH) {
                    // MAX_PATH is the limit to what we're willing to allocate.
                    goto cleanup;
                }
                try {
                    CmdLine = (PWCHAR) _alloca((cchSysDir + cchAeCmdLine + 1)
                                               * sizeof(WCHAR));
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    goto cleanup;
                }
                cchSysDir = GetSystemDirectoryW(CmdLine, cchSysDir);
                if (! cchSysDir) {
                    goto cleanup;
                }
                if (CmdLine[cchSysDir - 1] != L'\\') {
                    CmdLine[cchSysDir] = L'\\';
                    cchSysDir++;
                }
            } else {
                cchSysDir = 0;
                if (cchAeCmdLine > MAX_PATH) {
                    // MAX_PATH is the limit to what we're willing to allocate.
                    goto cleanup;
                }
                try {
                    CmdLine = (PWCHAR) _alloca(cchAeCmdLine * sizeof(WCHAR));
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    goto cleanup;
                }
            }

            if (FAILED(StringCchPrintfW(CmdLine + cchSysDir,
                                        cchAeCmdLine,
                                        AeDebuggerCmdLine,
                                        GetCurrentProcessId(),EventHandle))) {
                goto cleanup;
            }

            StartupInfo.cb = sizeof(StartupInfo);
            StartupInfo.lpDesktop = L"Winsta0\\Default";
            CsrIdentifyAlertableThread();
            b =  CreateProcessW(
                    NULL,
                    CmdLine,
                    NULL,
                    NULL,
                    TRUE,
                    0,
                    NULL,
                    NULL,
                    &StartupInfo,
                    &ProcessInformation
                    );

      cleanup:
            if (CurrentProcess != NULL) {
                CloseHandle (CurrentProcess);
            }
            if (CurrentThread != NULL) {
                CloseHandle (CurrentThread);
            }
            if ( b && EventHandle) {

                //
                // Do an alertable wait on the event
                //

                do {
                    HANDLE WaitHandles[2];

                    WaitHandles[0] = EventHandle;
                    WaitHandles[1] = ProcessInformation.hProcess;
                    Status = NtWaitForMultipleObjects (2,
                                                       WaitHandles,
                                                       WaitAny,
                                                       TRUE,
                                                       NULL);
                } while (Status == STATUS_USER_APC || Status == STATUS_ALERTED);

                //
                // If the debugger process died then see if the debugger is now
                // attached by another thread
                //
                if (Status == 1) {
                    Status = NtQueryInformationProcess (GetCurrentProcess(),
                                                        ProcessDebugPort,
                                                        &DebugPort,
                                                        sizeof (DebugPort),
                                                        NULL);
                    if (!NT_SUCCESS (Status) || DebugPort == NULL) {
                        BasepAlreadyHadHardError = TRUE;
                    }
                }
                CloseHandle (EventHandle);
                CloseHandle (ProcessInformation.hProcess);
                CloseHandle (ProcessInformation.hThread);

                return EXCEPTION_CONTINUE_SEARCH;
            }

        }
        BasepAlreadyHadHardError = TRUE;
    }

#if DBG
    if (!NT_SUCCESS( Status )) {
        DbgPrint( "BASEDLL: Unhandled exception: %lx  IP: %x\n",
                  ExceptionInfo->ExceptionRecord->ExceptionCode,
                  ExceptionInfo->ExceptionRecord->ExceptionAddress
                );
        }
#endif
    if ( BasepAlreadyHadHardError ) {
        NtTerminateProcess(NtCurrentProcess(),ExceptionInfo->ExceptionRecord->ExceptionCode);
        }
    return EXCEPTION_EXECUTE_HANDLER;
}

DWORD
APIENTRY
TlsAlloc(
    VOID
    )

/*++

Routine Description:

    A TLS index may be allocated using TlsAlloc.  Win32 garuntees a
    minimum number of TLS indexes are available in each process.  The
    constant TLS_MINIMUM_AVAILABLE defines the minimum number of
    available indexes.  This minimum is at least 64 for all Win32
    systems.

Arguments:

    None.

Return Value:

    Not-0xffffffff - Returns a TLS index that may be used in a
        subsequent call to TlsFree, TlsSetValue, or TlsGetValue.  The
        storage associated with the index is initialized to NULL.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    PPEB Peb;
    PTEB Teb;
    DWORD Index;

    Teb = NtCurrentTeb();
    Peb = Teb->ProcessEnvironmentBlock;

    RtlAcquirePebLock();
    try {

        Index = RtlFindClearBitsAndSet((PRTL_BITMAP)Peb->TlsBitmap,1,0);
        if ( Index == 0xffffffff ) {
            Index = RtlFindClearBitsAndSet((PRTL_BITMAP)Peb->TlsExpansionBitmap,1,0);
            if ( Index == 0xffffffff ) {
                BaseSetLastNTError(STATUS_NO_MEMORY);
                }
            else {
                if ( !Teb->TlsExpansionSlots ) {
                    Teb->TlsExpansionSlots = RtlAllocateHeap(
                                                RtlProcessHeap(),
                                                MAKE_TAG( TMP_TAG ) | HEAP_ZERO_MEMORY,
                                                TLS_EXPANSION_SLOTS * sizeof(PVOID)
                                                );
                    if ( !Teb->TlsExpansionSlots ) {
                        RtlClearBits((PRTL_BITMAP)Peb->TlsExpansionBitmap,Index,1);
                        Index = 0xffffffff;
                        BaseSetLastNTError(STATUS_NO_MEMORY);
                        leave;
                        }
                    }
                Teb->TlsExpansionSlots[Index] = NULL;
                Index += TLS_MINIMUM_AVAILABLE;
                }
            }
        else {
            Teb->TlsSlots[Index] = NULL;
            }
        }
    finally {
        RtlReleasePebLock();
        }
    
    return Index;
}

LPVOID
APIENTRY
TlsGetValue(
    DWORD dwTlsIndex
    )

/*++

Routine Description:

    This function is used to retrive the value in the TLS storage
    associated with the specified index.

    If the index is valid this function clears the value returned by
    GetLastError(), and returns the value stored in the TLS slot
    associated with the specified index.  Otherwise a value of NULL is
    returned with GetLastError updated appropriately.

    It is expected, that DLLs will use TlsAlloc and TlsGetValue as
    follows:

      - Upon DLL initialization, a TLS index will be allocated using
        TlsAlloc.  The DLL will then allocate some dynamic storage and
        store its address in the TLS slot using TlsSetValue.  This
        completes the per thread initialization for the initial thread
        of the process.  The TLS index is stored in instance data for
        the DLL.

      - Each time a new thread attaches to the DLL, the DLL will
        allocate some dynamic storage and store its address in the TLS
        slot using TlsSetValue.  This completes the per thread
        initialization for the new thread.

      - Each time an initialized thread makes a DLL call requiring the
        TLS, the DLL will call TlsGetValue to get the TLS data for the
        thread.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAlloc.  The
        index specifies which TLS slot is to be located.  Translating a
        TlsIndex does not prevent a TlsFree call from proceding.

Return Value:

    NON-NULL - The function was successful. The value is the data stored
        in the TLS slot associated with the specified index.

    NULL - The operation failed, or the value associated with the
        specified index was NULL.  Extended error status is available
        using GetLastError.  If this returns non-zero, the index was
        invalid.

--*/

{
    PTEB Teb;
    LPVOID *Slot;

    Teb = NtCurrentTeb();

    if ( dwTlsIndex < TLS_MINIMUM_AVAILABLE ) {
        Slot = &Teb->TlsSlots[dwTlsIndex];
        Teb->LastErrorValue = 0;
        return *Slot;
        }
    else {
        if ( dwTlsIndex >= TLS_MINIMUM_AVAILABLE+TLS_EXPANSION_SLOTS ) {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return NULL;
            }
        else {
            Teb->LastErrorValue = 0;
            if ( Teb->TlsExpansionSlots ) {
                return  Teb->TlsExpansionSlots[dwTlsIndex-TLS_MINIMUM_AVAILABLE];
                }
            else {
                return NULL;
                }
            }
        }
}

BOOL
APIENTRY
TlsSetValue(
    DWORD dwTlsIndex,
    LPVOID lpTlsValue
    )

/*++

Routine Description:

    This function is used to store a value in the TLS storage associated
    with the specified index.

    If the index is valid this function stores the value and returns
    TRUE. Otherwise a value of FALSE is returned.

    It is expected, that DLLs will use TlsAlloc and TlsSetValue as
    follows:

      - Upon DLL initialization, a TLS index will be allocated using
        TlsAlloc.  The DLL will then allocate some dynamic storage and
        store its address in the TLS slot using TlsSetValue.  This
        completes the per thread initialization for the initial thread
        of the process.  The TLS index is stored in instance data for
        the DLL.

      - Each time a new thread attaches to the DLL, the DLL will
        allocate some dynamic storage and store its address in the TLS
        slot using TlsSetValue.  This completes the per thread
        initialization for the new thread.

      - Each time an initialized thread makes a DLL call requiring the
        TLS, the DLL will call TlsGetValue to get the TLS data for the
        thread.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAlloc.  The
        index specifies which TLS slot is to be located.  Translating a
        TlsIndex does not prevent a TlsFree call from proceding.

    lpTlsValue - Supplies the value to be stored in the TLS Slot.

Return Value:

    TRUE - The function was successful. The value lpTlsValue was
        stored.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PTEB Teb;

    Teb = NtCurrentTeb();

    if ( dwTlsIndex >= TLS_MINIMUM_AVAILABLE ) {
        dwTlsIndex -= TLS_MINIMUM_AVAILABLE;
        if ( dwTlsIndex < TLS_EXPANSION_SLOTS ) {
            if ( !Teb->TlsExpansionSlots ) {
                RtlAcquirePebLock();
                if ( !Teb->TlsExpansionSlots ) {
                    Teb->TlsExpansionSlots = RtlAllocateHeap(
                                                RtlProcessHeap(),
                                                MAKE_TAG( TMP_TAG ) | HEAP_ZERO_MEMORY,
                                                TLS_EXPANSION_SLOTS * sizeof(PVOID)
                                                );
                    if ( !Teb->TlsExpansionSlots ) {
                        RtlReleasePebLock();
                        BaseSetLastNTError(STATUS_NO_MEMORY);
                        return FALSE;
                        }
                    }
                RtlReleasePebLock();
                }
            Teb->TlsExpansionSlots[dwTlsIndex] = lpTlsValue;
            }
        else {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;
            }
        }
    else {
        Teb->TlsSlots[dwTlsIndex] = lpTlsValue;
        }
    return TRUE;
}

BOOL
APIENTRY
TlsFree(
    DWORD dwTlsIndex
    )

/*++

Routine Description:

    A valid TLS index may be free'd using TlsFree.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAlloc.  If the
        index is a valid index, it is released by this call and is made
        available for reuse.  DLLs should be carefull to release any
        per-thread data pointed to by all of their threads TLS slots
        before calling this function.  It is expected that DLLs will
        only call this function (if at ALL) during their process detach
        routine.

Return Value:

    TRUE - The operation was successful.  Calling TlsTranslateIndex with
        this index will fail.  TlsAlloc is free to reallocate this
        index.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PPEB Peb;
    BOOLEAN ValidIndex;
    PRTL_BITMAP TlsBitmap;
    NTSTATUS Status;
    DWORD Index2;

    Peb = NtCurrentPeb();

    RtlAcquirePebLock();
    try {

        if ( dwTlsIndex >= TLS_MINIMUM_AVAILABLE ) {
            Index2 = dwTlsIndex - TLS_MINIMUM_AVAILABLE;
            if ( Index2 >= TLS_EXPANSION_SLOTS ) {
                ValidIndex = FALSE;
                }
            else {
                TlsBitmap = (PRTL_BITMAP)Peb->TlsExpansionBitmap;
                ValidIndex = RtlAreBitsSet(TlsBitmap,Index2,1);
                }
            }
        else {
            TlsBitmap = (PRTL_BITMAP)Peb->TlsBitmap;
            Index2 = dwTlsIndex;
            ValidIndex = RtlAreBitsSet(TlsBitmap,Index2,1);
            }
        if ( ValidIndex ) {

            Status = NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadZeroTlsCell,
                        &dwTlsIndex,
                        sizeof(dwTlsIndex)
                        );
            if ( !NT_SUCCESS(Status) ) {
                BaseSetLastNTError(STATUS_INVALID_PARAMETER);
                ValidIndex = FALSE;
                leave;
                }

            RtlClearBits(TlsBitmap,Index2,1);
            }
        else {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            }
        }
    finally {
        RtlReleasePebLock();
        }
    return ValidIndex;
}

BOOL
WINAPI
GetThreadTimes(
    HANDLE hThread,
    LPFILETIME lpCreationTime,
    LPFILETIME lpExitTime,
    LPFILETIME lpKernelTime,
    LPFILETIME lpUserTime
    )

/*++

Routine Description:

    This function is used to return various timing information about the
    thread specified by hThread.

    All times are in units of 100ns increments. For lpCreationTime and lpExitTime,
    the times are in terms of the SYSTEM time or GMT time.

Arguments:

    hThread - Supplies an open handle to the specified thread.  The
        handle must have been created with THREAD_QUERY_INFORMATION
        access.

    lpCreationTime - Returns a creation time of the thread.

    lpExitTime - Returns the exit time of a thread.  If the thread has
        not exited, this value is not defined.

    lpKernelTime - Returns the amount of time that this thread has
        executed in kernel-mode.

    lpUserTime - Returns the amount of time that this thread has
        executed in user-mode.


Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/


{
    NTSTATUS Status;
    KERNEL_USER_TIMES TimeInfo;

    Status = NtQueryInformationThread(
                hThread,
                ThreadTimes,
                (PVOID)&TimeInfo,
                sizeof(TimeInfo),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    *lpCreationTime = *(LPFILETIME)&TimeInfo.CreateTime;
    *lpExitTime = *(LPFILETIME)&TimeInfo.ExitTime;
    *lpKernelTime = *(LPFILETIME)&TimeInfo.KernelTime;
    *lpUserTime = *(LPFILETIME)&TimeInfo.UserTime;

    return TRUE;
}

BOOL
WINAPI
GetThreadIOPendingFlag(
    IN HANDLE hThread,
    OUT PBOOL lpIOIsPending
    )

/*++

Routine Description:

    This function is used to determine whether the thread in question
    has any IO requests pending.

Arguments:

    hThread - Specifies an open handle to the desired thread.  The
              handle must have been created with
              THREAD_QUERY_INFORMATION access.

    lpIOIsPending - Specifes the location to receive the flag.

Return Value:

    TRUE - The call was successful.

    FALSE - The call failed.  Extended error status is available
        using GetLastError().

--*/

{
    NTSTATUS Status;
    ULONG Pending;

    Status = NtQueryInformationThread(hThread,
                                      ThreadIsIoPending,
                                      &Pending,
                                      sizeof(Pending),
                                      NULL);
    if (! NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    *lpIOIsPending = (Pending ? TRUE : FALSE);
    return TRUE;
}

DWORD_PTR
WINAPI
SetThreadAffinityMask(
    HANDLE hThread,
    DWORD_PTR dwThreadAffinityMask
    )

/*++

Routine Description:

    This function is used to set the specified thread's processor
    affinity mask.  The thread affinity mask is a bit vector where each
    bit represents the processors that the thread is allowed to run on.
    The affinity mask MUST be a proper subset of the containing process'
    process level affinity mask.

Arguments:

    hThread - Supplies a handle to the thread whose priority is to be
        set.  The handle must have been created with
        THREAD_SET_INFORMATION access.

    dwThreadAffinityMask - Supplies the affinity mask to be used for the
        specified thread.

Return Value:

    non-0 - The API was successful.  The return value is the previous
        affinity mask for the thread.

    0 - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    THREAD_BASIC_INFORMATION BasicInformation;
    NTSTATUS Status;
    DWORD_PTR rv;
    DWORD_PTR LocalThreadAffinityMask;


    Status = NtQueryInformationThread(
                hThread,
                ThreadBasicInformation,
                &BasicInformation,
                sizeof(BasicInformation),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        rv = 0;
        }
    else {
        LocalThreadAffinityMask = dwThreadAffinityMask;

        Status = NtSetInformationThread(
                    hThread,
                    ThreadAffinityMask,
                    &LocalThreadAffinityMask,
                    sizeof(LocalThreadAffinityMask)
                    );
        if ( !NT_SUCCESS(Status) ) {
            rv = 0;
            }
        else {
            rv = BasicInformation.AffinityMask;
            }
        }


    if ( !rv ) {
        BaseSetLastNTError(Status);
        }

    return rv;
}

VOID
BaseDispatchAPC(
    LPVOID lpApcArgument1,
    LPVOID lpApcArgument2,
    LPVOID lpApcArgument3
    )
{
    PAPCFUNC pfnAPC;
    ULONG_PTR dwData;
    PACTIVATION_CONTEXT ActivationContext;
    NTSTATUS Status;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME ActivationFrame = { sizeof(ActivationFrame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    pfnAPC = (PAPCFUNC) lpApcArgument1;
    dwData = (ULONG_PTR) lpApcArgument2;
    ActivationContext = (PACTIVATION_CONTEXT) lpApcArgument3;

    if (ActivationContext == INVALID_ACTIVATION_CONTEXT) {
        (*pfnAPC)(dwData);
    } else {
        RtlActivateActivationContextUnsafeFast(&ActivationFrame, ActivationContext);
        __try {
            (*pfnAPC)(dwData);
        } __finally {
            RtlDeactivateActivationContextUnsafeFast(&ActivationFrame);
            RtlReleaseActivationContext(ActivationContext);
        }
    }
}


WINBASEAPI
DWORD
WINAPI
QueueUserAPC(
    PAPCFUNC pfnAPC,
    HANDLE hThread,
    ULONG_PTR dwData
    )
/*++

Routine Description:

    This function is used to queue a user-mode APC to the specified thread. The APC
    will fire when the specified thread does an alertable wait.

Arguments:

    pfnAPC - Supplies the address of the APC routine to execute when the
        APC fires.

    hHandle - Supplies a handle to a thread object.  The caller
        must have THREAD_SET_CONTEXT access to the thread.

    dwData - Supplies a DWORD passed to the APC

Return Value:

    TRUE - The operations was successful

    FALSE - The operation failed. GetLastError() is not defined.

--*/

{
    NTSTATUS Status;
    PVOID Argument1 = (PVOID) pfnAPC;
    PVOID Argument2 = (PVOID) dwData;
    PVOID Argument3 = NULL;
    ACTIVATION_CONTEXT_BASIC_INFORMATION acbi = { 0 };

    Status =
        RtlQueryInformationActivationContext(
            RTL_QUERY_INFORMATION_ACTIVATION_CONTEXT_FLAG_USE_ACTIVE_ACTIVATION_CONTEXT,
            NULL,
            0,
            ActivationContextBasicInformation,
            &acbi,
            sizeof(acbi),
            NULL);
    if (!NT_SUCCESS(Status)) {
        DbgPrint("SXS: %s failing because RtlQueryInformationActivationContext() returned status %08lx\n", __FUNCTION__, Status);
        return FALSE;
    }

    Argument3 = acbi.ActivationContext;

    if (acbi.Flags & ACTIVATION_CONTEXT_FLAG_NO_INHERIT) {
        // We're not supposed to propogate the activation context; set it to a value to indicate such.
        Argument3 = INVALID_ACTIVATION_CONTEXT;
    }

    Status = NtQueueApcThread(
                hThread,
                &BaseDispatchAPC,
                Argument1,
                Argument2,
                Argument3
                );

    if ( !NT_SUCCESS(Status) ) {
        return 0;
        }
    return 1;
}


DWORD
WINAPI
SetThreadIdealProcessor(
    HANDLE hThread,
    DWORD dwIdealProcessor
    )
{
    NTSTATUS Status;
    ULONG rv;

    Status = NtSetInformationThread(
                hThread,
                ThreadIdealProcessor,
                &dwIdealProcessor,
                sizeof(dwIdealProcessor)
                );
    if ( !NT_SUCCESS(Status) ) {
        rv = (DWORD)0xFFFFFFFF;
        BaseSetLastNTError(Status);
        }
    else {
        rv = (ULONG)Status;
        }

    return rv;
}

DWORD
APIENTRY
FlsAlloc (
    IN PFLS_CALLBACK_FUNCTION lpCallback OPTIONAL
    )

/*++

Routine Description:

    This function allocates a fiber local storage index.

    N.B. Fiber local storage is per fiber per thread and is context switched
         on fiber switches. Fiber local storage indexes are allocate across
         a process. 

Arguments:

    lpCallback - Supplies an optional pointer to a callback function.

Return Value:

    If no fiber local storage index is available, then the last error value
    is set and the distinguished value 0xffffffff is returned. Otherwise,
    the callback function address is saved and the allocated fiber local
    storage index is returned.

--*/

{

    DWORD Index;
    PPEB Peb;
    PTEB Teb;

    //
    // Attempt to allocate a fiber local storage index.
    //

    Teb = NtCurrentTeb();
    Peb = Teb->ProcessEnvironmentBlock;
    RtlAcquirePebLock();
    try {

        //
        // Search for the first free entry in the fiber local storage
        // bitmap.
        //

        Index = RtlFindClearBitsAndSet((PRTL_BITMAP)Peb->FlsBitmap, 1, 0);

        //
        // If no fiber local storage is available, then set the last error
        // value and return the distinguished value.
        //

        if (Index == 0xffffffff) {
            BaseSetLastNTError(STATUS_NO_MEMORY);

        } else {

            //
            // A fiber local storage index was successfully allocated.
            //
            // If a callback function array has not yet been allocated,
            // then allocate it now.
            //

            if (Peb->FlsCallback == NULL) {
                Peb->FlsCallback = RtlAllocateHeap(Peb->ProcessHeap,
                                                   MAKE_TAG(TMP_TAG) | HEAP_ZERO_MEMORY,
                                                   FLS_MAXIMUM_AVAILABLE * sizeof(PVOID));

                //
                // If a callback function array was not allocated, then clear
                // the allocated slot in the bitmap, set the last error value,
                // and return the distinguished value.
                //

                if (Peb->FlsCallback == NULL) {
                    RtlClearBits((PRTL_BITMAP)Peb->FlsBitmap, Index, 1);
                    Index = 0xffffffff;
                    BaseSetLastNTError(STATUS_NO_MEMORY);
                    leave;
                } 
            }

            //
            // If the fiber local storage data structure has not yet been
            // allocated for the current thread, then attempt to allocate
            // it now.
            //

            if (Teb->FlsData == NULL) {
                Teb->FlsData = RtlAllocateHeap(Peb->ProcessHeap,
                                               MAKE_TAG(TMP_TAG) | HEAP_ZERO_MEMORY,
                                               sizeof(FLS_DATA));

                //
                // If a fiber local storage data structure was allocated, then
                // insert the allocated data structure in the process local
                // storage data structure list. Otherwise, clear the allocated
                // slot in the bitmap, set the last error value, return the
                // distuiguished value.
                //

                if (Teb->FlsData != NULL) {
                    InsertTailList(&Peb->FlsListHead,
                                   &((PFLS_DATA)Teb->FlsData)->Entry);

                } else {
                    RtlClearBits((PRTL_BITMAP)Peb->FlsBitmap, Index, 1);
                    Index = 0xffffffff;
                    BaseSetLastNTError(STATUS_NO_MEMORY);
                    leave;
                } 
            }

            //
            // Initialize the free function callback address and the fiber
            // local storage value.
            //

            Peb->FlsCallback[Index] = lpCallback;
            ((PFLS_DATA)Teb->FlsData)->Slots[Index] = NULL;

            //
            // If the allocated index is greater than the highest allocated
            // index, then save the new high.
            //

            if (Index > Peb->FlsHighIndex) {
                Peb->FlsHighIndex = Index;
            }
        }

    } finally {
        RtlReleasePebLock();
    }
    
    return Index;
}

PVOID
APIENTRY
FlsGetValue (
    DWORD dwFlsIndex
    )

/*++

Routine Description:

    This function retrieves a value from the fiber local storage data entry
    specified by the index value.

    N.B. This routine is not synchronized with the possible freeing of
         the specified fiber local storage slot. Therefore, it is possible
         to get stale data. If this type of synchronization is desired it
         must be supplied by the caller.

Arguments:

    dwFlsIndex - Supplies a fiber local storage index.

Return Value:

    If the specified fiber local storage index is valid, then the last error
    value is cleared and the value of the fiber local storage data entry is
    returned. Otherwise, the last error value is set and a value of NULL is
    returned.

--*/

{

    PTEB Teb;

    //
    // If the fiber local storage index is invalid or the fiber local storage
    // data structure has not been allocated, then set the last error value
    // and return NULL. Otherwise, return the specified value from fiber local
    // storage data.
    //

    Teb = NtCurrentTeb();
    if ((dwFlsIndex > 0) &&
        (dwFlsIndex < FLS_MAXIMUM_AVAILABLE) &&
        (Teb->FlsData != NULL)) {

        ASSERT(RtlAreBitsSet((PRTL_BITMAP)NtCurrentPeb()->FlsBitmap, dwFlsIndex, 1));

        ASSERT(dwFlsIndex <= NtCurrentPeb()->FlsHighIndex);

        Teb->LastErrorValue = 0;
        return ((PFLS_DATA)Teb->FlsData)->Slots[dwFlsIndex];

    } else {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
    }
}

BOOL
APIENTRY
FlsSetValue (
    DWORD dwFlsIndex,
    IN PVOID lpFlsData
    )

/*++

Routine Description:

    This function stores a value in the fiber local storage data entry
    specified by the index value.

    N.B. This routine is not synchronized with the possible freeing of
         the specified fiber local storage slot. Therefore, it is possible
         to set stale data. If this type of synchronization is desired it
         must be supplied by the caller.

Arguments:

    dwTlsIndex - Supplies a fiber local storage index.

    lpFlsData - Supplies the value to be stored in the fiber local storage
        data entry.

Return Value:

    If the specified index is valid, then the specified value is stored in
    the associated fiber local storage entry and TRUE is returned. Otherwise,
    the last error value is set and FALSE is returned.

--*/

{

    PPEB Peb;
    PTEB Teb;

    //
    // If the fiber local storage index is invalid, then set the last error
    // value and return FALSE. Otherwise, attempt to store the specified
    // value in the associated fiber local storage data.
    //

    Teb = NtCurrentTeb();
    Peb = Teb->ProcessEnvironmentBlock;
    if ((dwFlsIndex > 0) && (dwFlsIndex < FLS_MAXIMUM_AVAILABLE)) {

        ASSERT(RtlAreBitsSet((PRTL_BITMAP)Peb->FlsBitmap, dwFlsIndex, 1));

        ASSERT(dwFlsIndex <= Peb->FlsHighIndex);

        //
        // If the fiber local storage data structure has not yet been
        // allocated for the current thread, then attempt to allocate it
        // now.
        //

        if (Teb->FlsData == NULL) {
            Teb->FlsData = RtlAllocateHeap(Peb->ProcessHeap,
                                           MAKE_TAG(TMP_TAG) | HEAP_ZERO_MEMORY,
                                           sizeof(FLS_DATA));

            //
            // If a fiber local storage data structure was allocated, then
            // insert the allocated structure in the process fiber local
            // storage list. Otherwise, clear the allocated slot in the bitmap,
            // set the last error value, return the distuiguished value.
            //

            if (Teb->FlsData != NULL) {
                RtlAcquirePebLock();
                try {
                    InsertTailList(&Peb->FlsListHead,
                                   &((PFLS_DATA)Teb->FlsData)->Entry);

                } finally {
                    RtlReleasePebLock();
                }

            } else {
                BaseSetLastNTError(STATUS_NO_MEMORY);
                return FALSE;
            } 
        }

        //
        // Store the specfied value in the fiber local storage data entry and
        // return TRUE.
        //

        ((PFLS_DATA)Teb->FlsData)->Slots[dwFlsIndex] = lpFlsData;
        return TRUE;

    } else {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return FALSE;
    }
}

BOOL
APIENTRY
FlsFree (
    DWORD dwFlsIndex
    )

/*++

Routine Description:

    This function frees a fiber local storage index.

Arguments:

    dwFlsIndex - Supplies a fiber local storage index.

Return Value:

    If the specified index is valid, then the callback function associated
    with the fiber local storage data entry is called if necessary for all
    instances of fiber local storage, the specified index is freed, and TRUE
    is returned. Otherwise, the last error value is set and FALSE is returned.

--*/

{

    PFLS_CALLBACK_FUNCTION Callback;
    PFLS_DATA FlsData;
    PLIST_ENTRY NextEntry;
    PPEB Peb;
    BOOLEAN Result;
    PTEB Teb;

    //
    // If the fiber local storage index is invalid, then return FALSE.
    // Otherwise, invoke the callback function associated with the fiber
    // local storage data entry if necessary, free the specified index,
    // and return TRUE.
    //

    Teb = NtCurrentTeb();
    Peb = Teb->ProcessEnvironmentBlock;
    RtlAcquirePebLock();
    try {
        if ((dwFlsIndex > 0) &&
            (dwFlsIndex < FLS_MAXIMUM_AVAILABLE) &&
            (RtlAreBitsSet((PRTL_BITMAP)Peb->FlsBitmap, dwFlsIndex, 1))) {

            //
            // Clear the allocated slot in the fiber local storage bitmap,
            // enumerate fiber local data structures, and invoke callback
            // routines if necessary.
            //

            RtlClearBits((PRTL_BITMAP)Peb->FlsBitmap, dwFlsIndex, 1);
            Callback = Peb->FlsCallback[dwFlsIndex];
            NextEntry = Peb->FlsListHead.Flink;
            while (NextEntry != &Peb->FlsListHead) {
                FlsData = CONTAINING_RECORD(NextEntry, FLS_DATA, Entry);
                if ((Callback != NULL) && (FlsData->Slots[dwFlsIndex])) {
                    (Callback)(FlsData->Slots[dwFlsIndex]);
                }

                FlsData->Slots[dwFlsIndex] = NULL;
                NextEntry = NextEntry->Flink;
            }

            Peb->FlsCallback[dwFlsIndex] = NULL;
            Result = TRUE;
    
        } else {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            Result = FALSE;
        }

    } finally {
        RtlReleasePebLock();
    }

    return Result;
}

WINBASEAPI
LPVOID
WINAPI
CreateFiber(
    SIZE_T dwStackSize,
    LPFIBER_START_ROUTINE lpStartAddress,
    LPVOID lpParameter
    )
/*++

Routine Description:

    This function creates a fiber that executing at lpStartAddress as soon
    as a thread is switched to it.

Arguments:

    dwStackSize    - Commit size of the stack
    lpStartAddress - Routine that the fiber will start running
    lpParameter    - Arbitrary context that is passed to the fiber

Return Value:

    LPVOID - Handle to the Fiber

--*/
{
    return CreateFiberEx (dwStackSize, // dwStackCommitSize
                          0,           // dwStackReserveSize
                          0,           // dwFlags
                          lpStartAddress,
                          lpParameter);
}

WINBASEAPI
LPVOID
WINAPI
CreateFiberEx(
    SIZE_T dwStackCommitSize,
    SIZE_T dwStackReserveSize,
    DWORD dwFlags,
    LPFIBER_START_ROUTINE lpStartAddress,
    LPVOID lpParameter
    )
/*++

Routine Description:

    This function creates a fiber that executing at lpStartAddress as soon
    as a thread is switched to it.

Arguments:

    dwStackCommitSize  - Commit size of the stack
    dwStackReserveSize - Reserve size of the stack
    dwFlags            - Flags DWORD, FIBER_FLAG_FLOAT_SWITCH is the only valid flag
    lpStartAddress     - Routine that the fiber will start running
    lpParameter        - Arbitrary context that is passed to the fiber

Return Value:

    LPVOID - Handle to the Fiber

--*/
{

    PFIBER Fiber;
    INITIAL_TEB InitialTeb;
    NTSTATUS Status;

    //
    // If any reserved flags are set, then return an error.
    //

    if ((dwFlags & ~FIBER_FLAG_FLOAT_SWITCH) != 0) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return NULL;
    }

    //
    // Allocate the fiber structure.
    //

    Fiber = RtlAllocateHeap (RtlProcessHeap (), MAKE_TAG (TMP_TAG), sizeof(FIBER));
    if (Fiber == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return Fiber;
    }

    Status = BaseCreateStack (NtCurrentProcess(),
                              dwStackCommitSize,
                              dwStackReserveSize,
                              &InitialTeb);

    if (!NT_SUCCESS (Status)) {
        BaseSetLastNTError (Status);
        RtlFreeHeap (RtlProcessHeap(), 0, Fiber);
        return NULL;
    }

    RtlZeroMemory (&Fiber->FiberContext, sizeof (Fiber->FiberContext));

    //
    // Initialize the fiber data.
    //

    Fiber->FiberData = lpParameter;
    Fiber->StackBase = InitialTeb.StackBase;
    Fiber->StackLimit = InitialTeb.StackLimit;
    Fiber->DeallocationStack = InitialTeb.StackAllocationBase;
    Fiber->ExceptionList = (struct _EXCEPTION_REGISTRATION_RECORD *)-1;
    Fiber->Wx86Tib = NULL;
    Fiber->FlsData = NULL;

    //
    // If switching of the floating state is specified, then set the floating
    // point flag in the fiber context.
    //

    if ((dwFlags & FIBER_FLAG_FLOAT_SWITCH) != 0) {
        Fiber->FiberContext.ContextFlags = CONTEXT_FLOATING_POINT;

    } else {
        Fiber->FiberContext.ContextFlags = 0;
    }

#ifdef _IA64_

    Fiber->BStoreLimit = InitialTeb.BStoreLimit;
    Fiber->DeallocationBStore = (PVOID) ((ULONG_PTR)InitialTeb.StackBase +
                      ((ULONG_PTR)InitialTeb.StackBase - (ULONG_PTR)InitialTeb.StackAllocationBase));

#endif // _IA64_

    //
    // Create an initial context for the new fiber.
    //

    BaseInitializeContext (&Fiber->FiberContext,
                           lpParameter,
                           (PVOID)lpStartAddress,
                           InitialTeb.StackBase,
                           BaseContextTypeFiber);

    return Fiber;
}

WINBASEAPI
VOID
WINAPI
DeleteFiber(
    LPVOID lpFiber
    )

{

    SIZE_T dwStackSize;
    PFIBER Fiber = lpFiber;
    PTEB Teb;

    //
    // If the current fiber makes this call, then it's just a thread exit
    //

    Teb = NtCurrentTeb();
    if ((Teb->HasFiberData != FALSE) && (Teb->NtTib.FiberData == Fiber)) {
        ExitThread(1);
    }

    dwStackSize = 0;
    NtFreeVirtualMemory(NtCurrentProcess(),
                        &Fiber->DeallocationStack,
                        &dwStackSize,
                        MEM_RELEASE);

#if defined (WX86)

    if (Fiber->Wx86Tib && Fiber->Wx86Tib->Size == sizeof(WX86TIB)) {
        PVOID BaseAddress = Fiber->Wx86Tib->DeallocationStack;

        dwStackSize = 0;
        NtFreeVirtualMemory(NtCurrentProcess(),
                            &BaseAddress,
                            &dwStackSize,
                            MEM_RELEASE);
    }

#endif

    //
    // If a fiber local storage data structure has been allocated, then
    // rundown the structure.
    //

    if (Fiber->FlsData != NULL) {
        BaseRundownFls((PFLS_DATA)Fiber->FlsData);
    }

    //
    // Free fiber storage.
    //

    RtlFreeHeap(RtlProcessHeap(), 0, Fiber);
    return;
}

WINBASEAPI
LPVOID
WINAPI
ConvertThreadToFiber(
    IN LPVOID lpParameter
    )

{

    return ConvertThreadToFiberEx(lpParameter, 0);
}

WINBASEAPI
LPVOID
WINAPI
ConvertThreadToFiberEx(
    IN LPVOID lpParameter,
    IN DWORD dwFlags
    )

{

    PFIBER Fiber;
    PTEB Teb;

    //
    // If any reserved flags are set, then return an error.
    //

    if ((dwFlags & ~FIBER_FLAG_FLOAT_SWITCH) != 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    //
    // If the thread has already been converted to a fiber, then return an
    // error.
    //

    Teb = NtCurrentTeb();
    if (Teb->HasFiberData != FALSE) {
        SetLastError(ERROR_ALREADY_FIBER);
        return NULL;
    }

    //
    // Allocate the fiber structure.
    //

    Fiber = RtlAllocateHeap(RtlProcessHeap(), MAKE_TAG(TMP_TAG), sizeof(FIBER));
    if (Fiber == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    //
    // Initialize the fiber data.
    //

    Fiber->FiberData = lpParameter;
    Fiber->StackBase = Teb->NtTib.StackBase;
    Fiber->StackLimit = Teb->NtTib.StackLimit;
    Fiber->DeallocationStack = Teb->DeallocationStack;
    Fiber->ExceptionList = Teb->NtTib.ExceptionList;
    Fiber->FlsData = Teb->FlsData;

    //
    // If switching of the floating state is specified, then set the floating
    // point flag in the fiber context.
    //

    Fiber->FiberContext.ContextFlags = CONTEXT_FULL;
    if ((dwFlags & FIBER_FLAG_FLOAT_SWITCH) != 0) {
        Fiber->FiberContext.ContextFlags |= CONTEXT_FLOATING_POINT;
    }

#ifdef _IA64_

    Fiber->BStoreLimit = Teb->BStoreLimit;
    Fiber->DeallocationBStore = Teb->DeallocationBStore;

#endif // _IA64_

    //
    // Initialize the fiber address and set thread has fiber data.
    //

    Fiber->Wx86Tib = NULL;
    Teb->NtTib.FiberData = Fiber;
    Teb->HasFiberData = TRUE;
    return Fiber;
}

WINBASEAPI
BOOL
WINAPI
ConvertFiberToThread(
    VOID
    )

{

    PFIBER Fiber;
    PTEB Teb;

    //
    // If the current thread has been converted to a fiber, then convert
    // if back to a thread and return TRUE. Otherwise, set the last error
    // value and return FALSE.
    //

    Teb = NtCurrentTeb();
    if (Teb->HasFiberData == FALSE) {
        SetLastError(ERROR_ALREADY_THREAD);
        return FALSE;

    } else {
        Teb->HasFiberData = FALSE;
        Fiber = Teb->NtTib.FiberData;
        Teb->NtTib.FiberData = NULL;
    
        ASSERT(Fiber != NULL);
        
        RtlFreeHeap(RtlProcessHeap (), 0, Fiber);
        return TRUE;
    }
}

BOOL
WINAPI
SwitchToThread(
    VOID
    )

/*++

Routine Description:

    This function causes a yield from the running thread to any other
    thread that is ready and can run on the current processor.  The
    yield will be effective for up to one quantum and then the yielding
    thread will be scheduled again according to its priority and
    whatever other threads may also be avaliable to run.  The thread
    that yields will not bounce to another processor even it another
    processor is idle or running a lower priority thread.

Arguments:

    None

Return Value:

    TRUE - Calling this function caused a switch to another thread to occur
    FALSE - There were no other ready threads, so no context switch occured

--*/

{

    if (NtYieldExecution() == STATUS_NO_YIELD_PERFORMED) {
        return FALSE;

    } else {
        return TRUE;
    }
}


BOOL
WINAPI
RegisterWaitForSingleObject(
    PHANDLE phNewWaitObject,
    HANDLE hObject,
    WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    )
/*++

Routine Description:

    This function registers a wait for a particular object, with an optional
    timeout.  This differs from WaitForSingleObject because the wait is performed
    by a different thread that combines several such calls for efficiency.  The
    function supplied in Callback is called when the object is signalled, or the
    timeout expires.

Arguments:

    phNewWaitObject - pointer to new WaitObject returned by this function.

    hObject -   HANDLE to a Win32 kernel object (Event, Mutex, File, Process,
                Thread, etc.) that will be waited on.  Note:  if the object
                handle does not immediately return to the not-signalled state,
                e.g. an auto-reset event, then either WT_EXECUTEINWAITTHREAD or
                WT_EXECUTEONLYONCE should be specified.  Otherwise, the thread
                pool will continue to fire the callbacks. If WT_EXECUTEINWAITTHREAD
                is specified, the the object should be deregistered or reset in the
                callback.

    Callback -  Function that will be called when the object is signalled or the
                timer expires.

    Context -   Context that will be passed to the callback function.

    dwMilliseconds - timeout for the wait. Each time the timer is fired or the event
                is fired, the timer is reset (except if WT_EXECUTEONLYONCE is set).

    dwFlags -   Flags indicating options for this wait:
                WT_EXECUTEDEFAULT       - Default (0)
                WT_EXECUTEINIOTHREAD    - Select an I/O thread for execution
                WT_EXECUTEINUITHREAD    - Select a UI thread for execution
                WT_EXECUTEINWAITTHREAD  - Execute in the thread that handles waits
                WT_EXECUTEONLYONCE      - The callback function will be called only once
                WT_EXECUTELONGFUNCTION  - The Callback function can potentially block
                                          for a long time. Is valid only if
                                          WT_EXECUTEINWAITTHREAD flag is not set.
Return Value:

    FALSE - an error occurred, use GetLastError() for more information.

    TRUE - success.

--*/
{
    NTSTATUS Status ;
    PPEB Peb;

    *phNewWaitObject = NULL;
    Peb = NtCurrentPeb();
    switch( HandleToUlong(hObject) )
    {
        case STD_INPUT_HANDLE:  hObject = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hObject = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hObject = Peb->ProcessParameters->StandardError;
                                break;
    }

    if (CONSOLE_HANDLE(hObject) && VerifyConsoleIoHandle(hObject))
    {
        hObject = GetConsoleInputWaitHandle();
    }

    Status = RtlRegisterWait(
                phNewWaitObject,
                hObject,
                Callback,
                Context,
                dwMilliseconds,
                dwFlags );

    if ( NT_SUCCESS( Status ) )
    {
        return TRUE ;
    }

    BaseSetLastNTError( Status );

    return FALSE ;

}


HANDLE
WINAPI
RegisterWaitForSingleObjectEx(
    HANDLE hObject,
    WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    )
/*++

Routine Description:

    This function registers a wait for a particular object, with an optional
    timeout.  This differs from WaitForSingleObject because the wait is performed
    by a different thread that combines several such calls for efficiency.  The
    function supplied in Callback is called when the object is signalled, or the
    timeout expires.

Arguments:

    hObject -   HANDLE to a Win32 kernel object (Event, Mutex, File, Process,
                Thread, etc.) that will be waited on.  Note:  if the object
                handle does not immediately return to the not-signalled state,
                e.g. an auto-reset event, then either WT_EXECUTEINWAITTHREAD or
                WT_EXECUTEONLYONCE should be specified.  Otherwise, the thread
                pool will continue to fire the callbacks. If WT_EXECUTEINWAITTHREAD
                is specified, the the object should be deregistered or reset in the
                callback.

    Callback -  Function that will be called when the object is signalled or the
                timer expires.

    Context -   Context that will be passed to the callback function.

    dwMilliseconds - timeout for the wait. Each time the timer is fired or the event
                is fired, the timer is reset (except if WT_EXECUTEONLYONCE is set).

    dwFlags -   Flags indicating options for this wait:
                WT_EXECUTEDEFAULT       - Default (0)
                WT_EXECUTEINIOTHREAD    - Select an I/O thread for execution
                WT_EXECUTEINUITHREAD    - Select a UI thread for execution
                WT_EXECUTEINWAITTHREAD  - Execute in the thread that handles waits
                WT_EXECUTEONLYONCE      - The callback function will be called only once
                WT_EXECUTELONGFUNCTION  - The Callback function can potentially block
                                          for a long time. Is valid only if
                                          WT_EXECUTEINWAITTHREAD flag is not set.
Return Value:

    NULL - an error occurred, use GetLastError() for more information.

    non-NULL - a virtual handle that can be passed later to
               UnregisterWait

--*/
{
    HANDLE WaitHandle ;
    NTSTATUS Status ;
    PPEB Peb;

    Peb = NtCurrentPeb();
    switch( HandleToUlong(hObject) )
    {
        case STD_INPUT_HANDLE:  hObject = Peb->ProcessParameters->StandardInput;
                                break;
        case STD_OUTPUT_HANDLE: hObject = Peb->ProcessParameters->StandardOutput;
                                break;
        case STD_ERROR_HANDLE:  hObject = Peb->ProcessParameters->StandardError;
                                break;
    }

    if (CONSOLE_HANDLE(hObject) && VerifyConsoleIoHandle(hObject))
    {
        hObject = GetConsoleInputWaitHandle();
    }

    Status = RtlRegisterWait(
                &WaitHandle,
                hObject,
                Callback,
                Context,
                dwMilliseconds,
                dwFlags );

    if ( NT_SUCCESS( Status ) )
    {
        return WaitHandle ;
    }

    BaseSetLastNTError( Status );

    return NULL ;

}

BOOL
WINAPI
UnregisterWait(
    HANDLE WaitHandle
    )
/*++

Routine Description:

    This function cancels a wait for a particular object.
    All objects that were registered by the RtlWaitForSingleObject(Ex) call
    should be deregistered. This is a non-blocking call, and the associated
    callback function can still be executing after the return of this function.

Arguments:

    WaitHandle - Handle returned from RegisterWaitForSingleObject(Ex)

Return Value:

    TRUE - The wait was cancelled
    FALSE - an error occurred or a callback function was still executing,
            use GetLastError() for more information.

--*/
{
    NTSTATUS Status ;

    if ( WaitHandle )
    {
        Status = RtlDeregisterWait( WaitHandle );

        // set error if it is a non-blocking call and STATUS_PENDING was returned

        if ( Status == STATUS_PENDING  || !NT_SUCCESS( Status ) )
        {

            BaseSetLastNTError( Status );
            return FALSE;
        }

        return TRUE ;

    }

    SetLastError( ERROR_INVALID_HANDLE );

    return FALSE ;
}


BOOL
WINAPI
UnregisterWaitEx(
    HANDLE WaitHandle,
    HANDLE CompletionEvent
    )
/*++

Routine Description:

    This function cancels a wait for a particular object.
    All objects that were registered by the RtlWaitForSingleObject(Ex) call
    should be deregistered.

Arguments:

    WaitHandle - Handle returned from RegisterWaitForSingleObject

    CompletionEvent - Handle to wait on for completion.
        NULL - NonBlocking call.
        INVALID_HANDLE_VALUE - Blocking call. Block till all Callback functions
                    associated with the WaitHandle have completed
        Event - NonBlocking call. The Object is deregistered. The Event is signalled
                    when the last callback function has completed execution.
Return Value:

    TRUE - The wait was cancelled
    FALSE - an error occurred or a callback was still executing,
            use GetLastError() for more information.

--*/
{
    NTSTATUS Status ;

    if ( WaitHandle )
    {
        Status = RtlDeregisterWaitEx( WaitHandle, CompletionEvent );

        // set error if it is a non-blocking call and STATUS_PENDING was returned
        
        if ( (CompletionEvent != INVALID_HANDLE_VALUE && Status == STATUS_PENDING)
            || ( ! NT_SUCCESS( Status ) ) )
        {

            BaseSetLastNTError( Status );
            return FALSE;
        }
        
        return TRUE ;

    }

    SetLastError( ERROR_INVALID_HANDLE );

    return FALSE ;
}

BOOL
WINAPI
QueueUserWorkItem(
    LPTHREAD_START_ROUTINE Function,
    PVOID Context,
    ULONG Flags
    )
/*++

Routine Description:

    This function queues a work item to a thread out of the thread pool.  The
    function passed is invoked in a different thread, and passed the Context
    pointer.  The caller can specify whether the thread pool should select
    a thread that can have I/O pending, or any thread.

Arguments:

    Function -  Function to call

    Context -   Pointer passed to the function when it is invoked.

    Flags   -
        - WT_EXECUTEINIOTHREAD
                Indictes to the thread pool that this thread will perform
                I/O.  A thread that starts an asynchronous I/O operation
                must wait for it to complete.  If a thread exits with
                outstanding I/O requests, those requests will be cancelled.
                This flag is a hint to the thread pool that this function
                will start I/O, so that a thread which can have pending I/O
                will be used.

        - WT_EXECUTELONGFUNCTION
                Indicates to the thread pool that the function might block
                for a long time.

Return Value:

    TRUE - The work item was queued to another thread.
    FALSE - an error occurred, use GetLastError() for more information.

--*/

{
    NTSTATUS Status ;

    Status = RtlQueueWorkItem(
                (WORKERCALLBACKFUNC) Function,
                Context,
                Flags );

    if ( NT_SUCCESS( Status ) )
    {
        return TRUE ;
    }

    BaseSetLastNTError( Status );

    return FALSE ;
}

BOOL
WINAPI
BindIoCompletionCallback (
    HANDLE FileHandle,
    LPOVERLAPPED_COMPLETION_ROUTINE Function,
    ULONG Flags
    )
/*++

Routine Description:

    This function binds the FileHandle opened for overlapped operations
    to the IO completion port associated with worker threads.

Arguments:

    FileHandle -  File Handle on which IO operations will be initiated.

    Function -    Function executed in a non-IO worker thread when the
                  IO operation completes.

    Flags   -     Currently set to 0. Not used.

Return Value:

    TRUE - The file handle was associated with the IO completion port.
    FALSE - an error occurred, use GetLastError() for more information.

--*/

{
    NTSTATUS Status ;

    Status = RtlSetIoCompletionCallback(
                FileHandle,
                (APC_CALLBACK_FUNCTION) Function,
                Flags );

    if ( NT_SUCCESS( Status ) )
    {
        return TRUE ;
    }

    BaseSetLastNTError( Status );

    return FALSE ;
}


//+---------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   BasepCreateDefaultTimerQueue
//
//  Synopsis:   Creates the default timer queue for the process
//
//  Arguments:  (none)
//
//  History:    5-26-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
BasepCreateDefaultTimerQueue(
    VOID
    )
{
    NTSTATUS Status ;

    while ( 1 )
    {
        if ( !InterlockedExchange( &BasepTimerQueueInitFlag, 1 ) )
        {
            //
            // Force the done flag to 0.  If it was 1, so one already tried to
            // init and failed.
            //

            InterlockedExchange( &BasepTimerQueueDoneFlag, 0 );

            Status = RtlCreateTimerQueue( &BasepDefaultTimerQueue );

            if ( NT_SUCCESS( Status ) )
            {
                InterlockedIncrement( &BasepTimerQueueDoneFlag );

                return TRUE ;
            }

            //
            // This is awkward.  We aren't able to create a timer queue,
            // probably because of low memory.  We will fail this call, but decrement
            // the init flag, so that others can try again later.  Need to increment
            // the done flag, or any other threads would be stuck.
            //

            BaseSetLastNTError( Status );

            InterlockedIncrement( &BasepTimerQueueDoneFlag );

            InterlockedDecrement( &BasepTimerQueueInitFlag );

            return FALSE ;
        }
        else
        {
            LARGE_INTEGER TimeOut ;

            TimeOut.QuadPart = -1 * 10 * 10000 ;

            //
            // yield the quantum so that the other thread can
            // try to create the timer queue.
            //

            while ( !BasepTimerQueueDoneFlag )
            {
                NtDelayExecution( FALSE, &TimeOut );
            }

            //
            // Make sure it was created.  Otherwise, try it again (memory might have
            // freed up).  This way, every thread gets an individual chance to create
            // the queue if another thread failed.
            //

            if ( BasepDefaultTimerQueue )
            {
                return TRUE ;
            }

        }
    }
}

HANDLE
WINAPI
CreateTimerQueue(
    VOID
    )
/*++

Routine Description:

    This function creates a queue for timers.  Timers on a timer queue are
    lightweight objects that allow the caller to specify a function to
    be called at some point in the future.  Any number of timers can be
    created in a particular timer queue.

Arguments:

    None.

Return Value:

    non-NULL  - a timer queue handle that can be passed to SetTimerQueueTimer,
                ChangeTimerQueueTimer, CancelTimerQueueTimer, and
                DeleteTimerQueue.

    NULL - an error occurred, use GetLastError() for more information.

--*/
{
    NTSTATUS Status ;
    HANDLE Handle ;

    Status = RtlCreateTimerQueue( &Handle );

    if ( NT_SUCCESS( Status ) )
    {
        return Handle ;
    }

    BaseSetLastNTError( Status );

    return NULL ;

}


BOOL
WINAPI
CreateTimerQueueTimer(
    PHANDLE phNewTimer,
    HANDLE TimerQueue,
    WAITORTIMERCALLBACK Callback,
    PVOID Parameter,
    DWORD DueTime,
    DWORD Period,
    ULONG Flags
    )
/*++

Routine Description:

    This function creates a timer queue timer, a lightweight timer that
    will fire at the DueTime, and then every Period milliseconds afterwards.
    When the timer fires, the function passed in Callback will be invoked,
    and passed the Parameter pointer.

Arguments:

    phNewTimer - pointer to new timer handle

    TimerQueue - Timer Queue to attach this timer to.  NULL indicates that the
                 default process timer queue be used.

    Function -  Function to call

    Context -   Pointer passed to the function when it is invoked.

    DueTime -   Time from now that the timer should fire, expressed in
                milliseconds. If set to INFINITE, then it will never fire.
                If set to 0, then it will fire immediately.

    Period -    Time in between firings of this timer.
                If 0, then it is a one shot timer.

    Flags  -  by default the Callback function is queued to a non-IO worker thread.

            - WT_EXECUTEINIOTHREAD
                Indictes to the thread pool that this thread will perform
                I/O.  A thread that starts an asynchronous I/O operation
                must wait for it to complete.  If a thread exits with
                outstanding I/O requests, those requests will be cancelled.
                This flag is a hint to the thread pool that this function
                will start I/O, so that a thread with I/O already pending
                will be used.

            - WT_EXECUTEINTIMERTHREAD
                The callback function will be executed in the timer thread.

            - WT_EXECUTELONGFUNCTION
                Indicates that the function might block for a long time. Useful
                only if it is queued to a worker thread.

Return Value:

    TRUE -  no error

    FALSE - an error occurred, use GetLastError() for more information.

--*/
{
    NTSTATUS Status ;

    *phNewTimer = NULL ;

    //
    // if the passed timer queue is NULL, use the default one.  If it is null,
    // call the initializer that will do it in a nice thread safe fashion.
    //

    if ( !TimerQueue )
    {
        if ( !BasepDefaultTimerQueue )
        {
            if ( !BasepCreateDefaultTimerQueue( ) )
            {
                return FALSE ;
            }
        }

        TimerQueue = BasepDefaultTimerQueue ;
    }

    Status = RtlCreateTimer(
                TimerQueue,
                phNewTimer,
                Callback,
                Parameter,
                DueTime,
                Period,
                Flags );

    if ( NT_SUCCESS( Status ) )
    {
        return TRUE ;
    }

    BaseSetLastNTError( Status );

    return FALSE ;

}



BOOL
WINAPI
ChangeTimerQueueTimer(
    HANDLE TimerQueue,
    HANDLE Timer,
    ULONG DueTime,
    ULONG Period
    )
/*++

Routine Description:

    This function updates a timer queue timer created with SetTimerQueueTimer.

Arguments:

    TimerQueue - Timer Queue to attach this timer to.  NULL indicates the default
                 process timer queue.

    Timer -     Handle returned from SetTimerQueueTimer.

    DueTime -   Time from now that the timer should fire, expressed in
                milliseconds.

    Period -    Time in between firings of this timer. If set to 0, then it becomes
                a one shot timer.


Return Value:

    TRUE - the timer was changed

    FALSE - an error occurred, use GetLastError() for more information.

--*/

{
    NTSTATUS Status ;

    //
    // Use the default timer queue if none was passed in.  If there isn't one, then
    // the process hasn't created one with SetTimerQueueTimer, and that's an error.
    //

    if ( !TimerQueue )
    {
        TimerQueue = BasepDefaultTimerQueue ;

        if ( !TimerQueue )
        {
            SetLastError( ERROR_INVALID_PARAMETER );

            return FALSE ;
        }
    }

    Status = RtlUpdateTimer( TimerQueue,
                             Timer,
                             DueTime,
                             Period );

    if ( NT_SUCCESS( Status ) )
    {
        return TRUE ;
    }

    BaseSetLastNTError( Status );

    return FALSE ;
}


BOOL
WINAPI
DeleteTimerQueueTimer(
    HANDLE TimerQueue,
    HANDLE Timer,
    HANDLE CompletionEvent
    )
/*++

Routine Description:

    This function cancels a timer queue timer created with SetTimerQueueTimer.

Arguments:

    TimerQueue - Timer Queue that this timer was created on.

    Timer -     Handle returned from SetTimerQueueTimer.

    CompletionEvent -
            - NULL : NonBlocking call. returns immediately.
            - INVALID_HANDLE_VALUE : Blocking call. Returns after all callbacks have executed
            - Event (handle to an event) : NonBlocking call. Returns immediately.
                    Event signalled after all callbacks have executed.

Return Value:

    TRUE - the timer was cancelled.

    FALSE - an error occurred or the call is pending, use GetLastError()
            for more information.

--*/
{
    NTSTATUS Status ;

    //
    // Use the default timer queue if none was passed in.  If there isn't one, then
    // the process hasn't created one with SetTimerQueueTimer, and that's an error.
    //

    if ( !TimerQueue )
    {
        TimerQueue = BasepDefaultTimerQueue ;

        if ( !TimerQueue )
        {
            SetLastError( ERROR_INVALID_PARAMETER );

            return FALSE ;
        }
    }

    Status = RtlDeleteTimer( TimerQueue, Timer, CompletionEvent );

    // set error if it is a non-blocking call and STATUS_PENDING was returned
    
    if ( (CompletionEvent != INVALID_HANDLE_VALUE && Status == STATUS_PENDING)
        || ( ! NT_SUCCESS( Status ) ) )
    {

        BaseSetLastNTError( Status );
        return FALSE;
    }
    
    return TRUE ;

}


BOOL
WINAPI
DeleteTimerQueueEx(
    HANDLE TimerQueue,
    HANDLE CompletionEvent
    )
/*++

Routine Description:

    This function deletes a timer queue created with CreateTimerQueue.
    Any pending timers on the timer queue are cancelled and deleted.

Arguments:

    TimerQueue - Timer Queue to delete.

    CompletionEvent -
            - NULL : NonBlocking call. returns immediately.
            - INVALID_HANDLE_VALUE : Blocking call. Returns after all callbacks
                    have executed
            - Event (handle to an event) : NonBlocking call. Returns immediately.
                    Event signalled after all callbacks have executed.

Return Value:

    TRUE - the timer queue was deleted.

    FALSE - an error occurred, use GetLastError() for more information.

--*/
{
    NTSTATUS Status ;

    if ( TimerQueue )
    {
        Status = RtlDeleteTimerQueueEx( TimerQueue, CompletionEvent );

        // set error if it is a non-blocking call and STATUS_PENDING was returned
        
        if ( (CompletionEvent != INVALID_HANDLE_VALUE && Status == STATUS_PENDING)
            || ( ! NT_SUCCESS( Status ) ) )
        {

            BaseSetLastNTError( Status );
            return FALSE;
        }
       
        return TRUE ;

    }


    SetLastError( ERROR_INVALID_HANDLE );
    return FALSE ;
}

BOOL
WINAPI
ThreadPoolCleanup (
    ULONG Flags
    )
/*++

Routine Description:

    Called by terminating process for thread pool to cleanup and
    delete all its threads.

Arguments:

    Flags - currently not used

Return Value:

    NO_ERROR

--*/
{

    // RtlThreadPoolCleanup( Flags ) ;

    return TRUE ;
}


/*OBSOLETE FUNCTION - REPLACED BY CreateTimerQueueTimer */
HANDLE
WINAPI
SetTimerQueueTimer(
    HANDLE TimerQueue,
    WAITORTIMERCALLBACK Callback,
    PVOID Parameter,
    DWORD DueTime,
    DWORD Period,
    BOOL PreferIo
    )
/*OBSOLETE FUNCTION - REPLACED BY CreateTimerQueueTimer */
{
    NTSTATUS Status ;
    HANDLE Handle ;

    //
    // if the passed timer queue is NULL, use the default one.  If it is null,
    // call the initializer that will do it in a nice thread safe fashion.
    //

    if ( !TimerQueue )
    {
        if ( !BasepDefaultTimerQueue )
        {
            if ( !BasepCreateDefaultTimerQueue( ) )
            {
                return NULL ;
            }
        }

        TimerQueue = BasepDefaultTimerQueue ;
    }

    Status = RtlCreateTimer(
                TimerQueue,
                &Handle,
                Callback,
                Parameter,
                DueTime,
                Period,
                (PreferIo ? WT_EXECUTEINIOTHREAD : 0 ) );

    if ( NT_SUCCESS( Status ) )
    {
        return Handle ;
    }

    BaseSetLastNTError( Status );

    return NULL ;
}


/*OBSOLETE: Replaced by DeleteTimerQueueEx */
BOOL
WINAPI
DeleteTimerQueue(
    HANDLE TimerQueue
    )
/*++

  OBSOLETE: Replaced by DeleteTimerQueueEx

Routine Description:

    This function deletes a timer queue created with CreateTimerQueue.
    Any pending timers on the timer queue are cancelled and deleted.
    This is a non-blocking call. Callbacks might still be running after
    this call returns.

Arguments:

    TimerQueue - Timer Queue to delete.

Return Value:

    TRUE - the timer queue was deleted.

    FALSE - an error occurred, use GetLastError() for more information.

--*/
{
    NTSTATUS Status ;

    if (TimerQueue)
    {
        Status = RtlDeleteTimerQueueEx( TimerQueue, NULL );

        // set error if it is a non-blocking call and STATUS_PENDING was returned
        /*
        if ( Status == STATUS_PENDING || ! NT_SUCCESS( Status ) )
        {

            BaseSetLastNTError( Status );
            return FALSE;
        }
        */
        return TRUE ;

    }

    SetLastError( ERROR_INVALID_HANDLE );

    return FALSE ;
}


/*OBSOLETE: USE DeleteTimerQueueTimer*/
BOOL
WINAPI
CancelTimerQueueTimer(
    HANDLE TimerQueue,
    HANDLE Timer
    )
/*OBSOLETE: USE DeleteTimerQueueTimer*/
{
    NTSTATUS Status ;

    //
    // Use the default timer queue if none was passed in.  If there isn't one, then
    // the process hasn't created one with SetTimerQueueTimer, and that's an error.
    //

    if ( !TimerQueue )
    {
        TimerQueue = BasepDefaultTimerQueue ;

        if ( !TimerQueue )
        {
            SetLastError( ERROR_INVALID_PARAMETER );

            return FALSE ;
        }
    }

    Status = RtlDeleteTimer( TimerQueue, Timer, NULL );

    if ( NT_SUCCESS( Status ) )
    {
        return TRUE ;
    }

    BaseSetLastNTError( Status );

    return FALSE ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\tmem.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tbase.c

Abstract:

    Skeleton for a Win32 Base API Test Program

Author:

    Steve Wood (stevewo) 26-Oct-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <string.h>
#include <stdarg.h>
#include <assert.h>
#include <stdio.h>

#ifndef DBG
#define DBG 0
#endif
#if DBG
#define IF_DEBUG if (TRUE)
#else
#define IF_DEBUG if (FALSE)
#endif
#include "basertl.h"

DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    NTSTATUS Status;
    LPVOID p1, p2, p3, p4, p5, p6;
    HANDLE h1, h2, h3, h4, h5, h6;
    BOOL result;
    LPDWORD p;

    printf( "TMEM: Entering Test Program\n" );

    p1 = LocalAlloc( LMEM_ZEROINIT, 0 );
    printf( "LocalAlloc( 0 ) == %lX\n", p1 );
    printf( "LocalSize( %lX ) == %ld\n", p1, LocalSize( p1 ) );

    p2 = LocalReAlloc( p1, 23, 0 );
    printf( "LocalReAlloc( %lX, 23 ) == %lX\n", p1, p2 );
    printf( "LocalSize( %lX ) == %ld\n", p2, LocalSize( p2 ) );
    printf( "LocalFree( %lX ) == %ld\n", p2, LocalFree( p2 ) );

    p1 = LocalAlloc( LMEM_ZEROINIT, 123 );
    printf( "LocalAlloc( 123 ) == %lX\n", p1 );
    printf( "LocalSize( %lX ) == %ld\n", p1, LocalSize( p1 ) );

    p2 = LocalReAlloc( p1, 23, 0 );
    printf( "LocalReAlloc( %lX, 23 ) == %lX\n", p1, p2 );
    printf( "LocalSize( %lX ) == %ld\n", p2, LocalSize( p2 ) );

    p3 = LocalReAlloc( p2, 223, LMEM_ZEROINIT );
    printf( "LocalReAlloc( %lX, 223 ) == %lX\n", p2, p3 );
    printf( "LocalSize( %lX ) == %ld\n", p3, LocalSize( p3 ) );

    p4 = LocalReAlloc( p3, 22, 0 );
    printf( "LocalReAlloc( %lX, 22 ) == %lX\n", p3, p4 );
    printf( "LocalSize( %lX ) == %ld\n", p4, LocalSize( p4 ) );
    printf( "LocalFree( %lX ) == %ld\n", p4, LocalFree( p4 ) );

    h1 = LocalAlloc( LMEM_MOVEABLE | LMEM_ZEROINIT, 123 );
    printf( "LocalAlloc( MOVEABLE, 123 ) == %lX (-> %lX)\n", h1, LocalLock( h1 ) );
    printf( "LocalSize( %lX ) == %ld\n", h1, LocalSize( h1 ) );

    h2 = LocalReAlloc( h1, 23, 0 );
    printf( "LocalReAlloc( %lX, 23 ) == %lX\n", h1, h2, LocalLock( h2 ) );
    printf( "LocalSize( %lX ) == %ld\n", h2, LocalSize( h2 ) );

    h3 = LocalReAlloc( h2, 223, LMEM_ZEROINIT );
    printf( "LocalReAlloc( %lX, 223 ) == %lX\n", h2, h3, LocalLock( h3 ) );
    printf( "LocalSize( %lX ) == %ld\n", h3, LocalSize( h3 ) );

    h4 = LocalReAlloc( h3, 22, 0 );
    printf( "LocalReAlloc( %lX, 22 ) == %lX\n", h3, h4, LocalLock( h4 ) );
    printf( "LocalSize( %lX ) == %ld\n", h4, LocalSize( h4 ) );
    printf( "LocalFree( %lX ) == %ld\n", h4, LocalFree( h4 ) );


    h1 = GlobalAlloc( GMEM_ZEROINIT, 123 );
    printf( "GlobalAlloc( 123 ) == %lX\n", h1 );
    printf( "GlobalFlags( %lX ) == %ld\n", h1, GlobalFlags( h1 ) );
    printf( "GlobalSize( %lX ) == %ld\n", h1, GlobalSize( h1 ) );

    h2 = GlobalReAlloc( h1, 23, 0 );
    printf( "GlobalReAlloc( %lX, 23 ) == %lX\n", h1, h2 );
    printf( "GlobalSize( %lX ) == %ld\n", h2, GlobalSize( h2 ) );

    h3 = GlobalReAlloc( h2, 223, GMEM_ZEROINIT );
    printf( "GlobalReAlloc( %lX, 223 ) == %lX\n", h2, h3 );
    printf( "GlobalSize( %lX ) == %ld\n", h3, GlobalSize( h3 ) );

    h4 = GlobalReAlloc( h3, 22, 0 );
    printf( "GlobalReAlloc( %lX, 22 ) == %lX\n", h3, h4 );
    printf( "GlobalSize( %lX ) == %ld\n", h4, GlobalSize( h4 ) );
    printf( "GlobalFree( %lX ) == %ld\n", h4, GlobalFree( h4 ) );

    h1 = GlobalAlloc( GMEM_ZEROINIT, 12003 );
    printf( "GlobalAlloc( 123 ) == %lX\n", h1 );
    printf( "GlobalFlags( %lX ) == %ld\n", h1, GlobalFlags( h1 ) );
    printf( "GlobalSize( %lX ) == %ld\n", h1, GlobalSize( h1 ) );

    h2 = GlobalReAlloc( h1, 4000, 0 );
    printf( "GlobalReAlloc( %lX, 23 ) == %lX\n", h1, h2 );
    printf( "GlobalSize( %lX ) == %ld\n", h2, GlobalSize( h2 ) );

    h3 = GlobalReAlloc( h2, 8000, GMEM_ZEROINIT );
    printf( "GlobalReAlloc( %lX, 223 ) == %lX\n", h2, h3 );
    printf( "GlobalSize( %lX ) == %ld\n", h3, GlobalSize( h3 ) );

    h4 = GlobalReAlloc( h3, 22, 0 );
    printf( "GlobalReAlloc( %lX, 22 ) == %lX\n", h3, h4 );
    printf( "GlobalSize( %lX ) == %ld\n", h4, GlobalSize( h4 ) );
    printf( "GlobalFree( %lX ) == %ld\n", h4, GlobalFree( h4 ) );

    DbgBreakPoint();

    h1 = GlobalAlloc( GMEM_DDESHARE, 123 );
    printf( "GlobalAlloc( 123 ) == %lX\n", h1 );
    printf( "GlobalFlags( %lX ) == %ld\n", h1, GlobalFlags( h1 ) );
    printf( "GlobalSize( %lX ) == %ld\n", h1, GlobalSize( h1 ) );

    p = GlobalLock( h1 );
    if (*p != 0xABCDEF01) {
        DbgBreakPoint();
        }

    h2 = GlobalReAlloc( h1, 23, 0 );
    printf( "GlobalReAlloc( %lX, 23 ) == %lX\n", h1, h2 );
    printf( "GlobalSize( %lX ) == %ld\n", h2, GlobalSize( h2 ) );

    h3 = GlobalReAlloc( h2, 223, GMEM_ZEROINIT );
    printf( "GlobalReAlloc( %lX, 223 ) == %lX\n", h2, h3 );
    printf( "GlobalSize( %lX ) == %ld\n", h3, GlobalSize( h3 ) );

    h4 = GlobalReAlloc( h3, 22, 0 );
    printf( "GlobalReAlloc( %lX, 22 ) == %lX\n", h3, h4 );
    printf( "GlobalSize( %lX ) == %ld\n", h4, GlobalSize( h4 ) );
    printf( "GlobalFree( %lX ) == %ld\n", h4, GlobalFree( h4 ) );

    printf( "TMEM: Exiting Test Program\n" );

    return 0;
}

#if 0
    MEMORY_BASIC_INFORMATION MemoryInformation;
    DWORD cb;
    DWORD oldProtect;

    p1 = VirtualAlloc( NULL, 8192, MEM_RESERVE, PAGE_READONLY );
    p2 = VirtualAlloc( (LPVOID)((LPSTR)p1 + 4096), 4096, MEM_COMMIT, PAGE_READWRITE );
    try {
        *(LPDWORD)p1 = -1;
        *(LPDWORD)p2 = -2;
        }
    except( 1 ) {
        }

    cb = VirtualQuery( (LPVOID)p1, &MemoryInformation, sizeof( MemoryInformation ) );
    printf( "VirtualQuery( %X ) = %u (%d)\n", p1, cb, GetLastError() );
    printf( "    BaseAddress:       %x\n", MemoryInformation.BaseAddress       );
    printf( "    AllocationBase:    %x\n", MemoryInformation.AllocationBase    );
    printf( "    AllocationProtect: %x\n", MemoryInformation.AllocationProtect );
    printf( "    RegionSize:        %u\n", MemoryInformation.RegionSize        );
    printf( "    State:             %x\n", MemoryInformation.State             );
    printf( "    Protect:           %x\n", MemoryInformation.Protect           );
    printf( "    Type:              %x\n", MemoryInformation.Type              );

    cb = VirtualQuery( (LPVOID)p2, &MemoryInformation, sizeof( MemoryInformation ) );
    printf( "VirtualQuery( %X ) = %u (%d)\n", p2, cb, GetLastError() );
    printf( "    BaseAddress:       %x\n", MemoryInformation.BaseAddress       );
    printf( "    AllocationBase:    %x\n", MemoryInformation.AllocationBase    );
    printf( "    AllocationProtect: %x\n", MemoryInformation.AllocationProtect );
    printf( "    RegionSize:        %u\n", MemoryInformation.RegionSize        );
    printf( "    State:             %x\n", MemoryInformation.State             );
    printf( "    Protect:           %x\n", MemoryInformation.Protect           );
    printf( "    Type:              %x\n", MemoryInformation.Type              );

    result = VirtualProtect( (LPVOID)p2, 4096, PAGE_READONLY, &oldProtect );
    printf( "VirtualProtect( %X, 4096, PAGE_READONLY, oldProtect == %x ) = %d (%d)\n", p2, oldProtect, result, GetLastError() );

    cb = VirtualQuery( (LPVOID)p2, &MemoryInformation, sizeof( MemoryInformation ) );
    printf( "VirtualQuery( %X ) = %u (%d)\n", p2, cb, GetLastError() );
    printf( "    BaseAddress:       %x\n", MemoryInformation.BaseAddress       );
    printf( "    AllocationBase:    %x\n", MemoryInformation.AllocationBase    );
    printf( "    AllocationProtect: %x\n", MemoryInformation.AllocationProtect );
    printf( "    RegionSize:        %u\n", MemoryInformation.RegionSize        );
    printf( "    State:             %x\n", MemoryInformation.State             );
    printf( "    Protect:           %x\n", MemoryInformation.Protect           );
    printf( "    Type:              %x\n", MemoryInformation.Type              );

    result = VirtualFree( (LPVOID)p2, 4096, MEM_DECOMMIT );
    printf( "VirtualFree( %X, 4096, MEM_DECOMMIT ) = %d\n", p2, result, GetLastError() );

    cb = VirtualQuery( (LPVOID)p2, &MemoryInformation, sizeof( MemoryInformation ) );
    printf( "VirtualQuery( %X ) = %u (%d)\n", p2, cb, GetLastError() );
    printf( "    BaseAddress:       %x\n", MemoryInformation.BaseAddress       );
    printf( "    AllocationBase:    %x\n", MemoryInformation.AllocationBase    );
    printf( "    AllocationProtect: %x\n", MemoryInformation.AllocationProtect );
    printf( "    RegionSize:        %u\n", MemoryInformation.RegionSize        );
    printf( "    State:             %x\n", MemoryInformation.State             );
    printf( "    Protect:           %x\n", MemoryInformation.Protect           );
    printf( "    Type:              %x\n", MemoryInformation.Type              );

    result = VirtualFree( (LPVOID)p2, 4096, MEM_RELEASE );
    printf( "VirtualFree( %X, 4096, MEM_RELEASE ) = %d\n", p2, result, GetLastError() );

    cb = VirtualQuery( (LPVOID)p2, &MemoryInformation, sizeof( MemoryInformation ) );
    printf( "VirtualQuery( %X ) = %u (%d)\n", p2, cb, GetLastError() );
    printf( "    BaseAddress:       %x\n", MemoryInformation.BaseAddress       );
    printf( "    AllocationBase:    %x\n", MemoryInformation.AllocationBase    );
    printf( "    AllocationProtect: %x\n", MemoryInformation.AllocationProtect );
    printf( "    RegionSize:        %u\n", MemoryInformation.RegionSize        );
    printf( "    State:             %x\n", MemoryInformation.State             );
    printf( "    Protect:           %x\n", MemoryInformation.Protect           );
    printf( "    Type:              %x\n", MemoryInformation.Type              );

    result = VirtualFree( (LPVOID)p1, 4096, MEM_RELEASE );
    printf( "VirtualFree( %X, 4096, MEM_RELEASE ) = %d\n", p1, result, GetLastError() );

    cb = VirtualQuery( (LPVOID)p1, &MemoryInformation, sizeof( MemoryInformation ) );
    printf( "VirtualQuery( %X ) = %u (%d)\n", p1, cb, GetLastError() );
    printf( "    BaseAddress:       %x\n", MemoryInformation.BaseAddress       );
    printf( "    AllocationBase:    %x\n", MemoryInformation.AllocationBase    );
    printf( "    AllocationProtect: %x\n", MemoryInformation.AllocationProtect );
    printf( "    RegionSize:        %u\n", MemoryInformation.RegionSize        );
    printf( "    State:             %x\n", MemoryInformation.State             );
    printf( "    Protect:           %x\n", MemoryInformation.Protect           );
    printf( "    Type:              %x\n", MemoryInformation.Type              );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\termutil.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    termutil.c

Abstract:

    Terminal server support functions and inifile syncing/merging code

Author:


Revision History:

--*/

#include "basedll.h"
#include "regapi.h"
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#define TERMSRV_INIFILE_TIMES L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Install\\IniFile Times"

BOOL IsTerminalServerCompatible(VOID)
{
    PIMAGE_NT_HEADERS NtHeader = RtlImageNtHeader( NtCurrentPeb()->ImageBaseAddress );

    if ((NtHeader) && (NtHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

NTSTATUS
IsTSAppCompatEnabled(
    OUT PBOOL ReturnValue
    )
{
    NTSTATUS NtStatus;
    const static UNICODE_STRING UniString_REG_NTAPI_CONTROL_TSERVER = RTL_CONSTANT_STRING(REG_NTAPI_CONTROL_TSERVER);
    const static UNICODE_STRING UniString_TSAppCompat = RTL_CONSTANT_STRING(L"TSAppCompat");
    const static OBJECT_ATTRIBUTES ObjectAttributes =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(
            &UniString_REG_NTAPI_CONTROL_TSERVER,
            OBJ_CASE_INSENSITIVE
            );       
    HKEY   hKey = 0;
    ULONG  ul, ulcbuf;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValInfo = NULL;
    BOOL retval = TRUE;

   // Determine the value info buffer size
   ulcbuf = sizeof(KEY_VALUE_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR) +
            sizeof(ULONG);

    pKeyValInfo = (PKEY_VALUE_PARTIAL_INFORMATION)RtlAllocateHeap(RtlProcessHeap(),
                                 0,
                                 ulcbuf);

    if (pKeyValInfo == NULL)
        return STATUS_NO_MEMORY;

    NtStatus = NtOpenKey(&hKey, KEY_READ, RTL_CONST_CAST(POBJECT_ATTRIBUTES)(&ObjectAttributes));

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = NtQueryValueKey(hKey,
                                  RTL_CONST_CAST(PUNICODE_STRING)(&UniString_TSAppCompat),
                                  KeyValuePartialInformation,
                                  pKeyValInfo,
                                  ulcbuf,
                                  &ul);

        if (NT_SUCCESS(NtStatus) && (REG_DWORD == pKeyValInfo->Type)) {

            if ((*(PULONG)pKeyValInfo->Data) == 0) {
                retval = FALSE;
            }
        }

        NtClose(hKey);
    }

    // Free up the buffers we allocated
    // Need to zero out the buffers, because some apps (MS Internet Assistant)
    // won't install if the heap is not zero filled.
    memset(pKeyValInfo, 0, ulcbuf);
    RtlFreeHeap( RtlProcessHeap(), 0, pKeyValInfo );

    *ReturnValue = retval;

    return STATUS_SUCCESS;
}

BOOL IsSystemLUID(VOID)
{
    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ sizeof( TOKEN_STATISTICS ) ];
    ULONG       ReturnLength;
    LUID        CurrentLUID = { 0, 0 };
    LUID        SystemLUID = SYSTEM_LUID;
    NTSTATUS Status;

    if ( CurrentLUID.LowPart == 0 && CurrentLUID.HighPart == 0 ) {

        Status = NtOpenProcessToken( NtCurrentProcess(),
                                     TOKEN_QUERY,
                                     &TokenHandle );
        if ( !NT_SUCCESS( Status ) )
            return(TRUE);

        NtQueryInformationToken( TokenHandle, TokenStatistics, TokenInformation,
                                 sizeof(TokenInformation), &ReturnLength );
        NtClose( TokenHandle );

        RtlCopyLuid(&CurrentLUID,
                    &(((PTOKEN_STATISTICS)TokenInformation)->AuthenticationId));
    }

    if (RtlEqualLuid(&CurrentLUID, &SystemLUID)) {
        return(TRUE);
    } else {
        return(FALSE );
    }
}

typedef struct _BASEP_PROCNAME_PROCADDRESS_PAIR {
    PCSTR   ProcName;
    PVOID * ProcAddress;
} BASEP_PROCNAME_PROCADDRESS_PAIR, *PBASEP_PROCNAME_PROCADDRESS_PAIR;
typedef const BASEP_PROCNAME_PROCADDRESS_PAIR *PCBASEP_PROCNAME_PROCADDRESS_PAIR;

NTSTATUS
BasepInitializeTermsrvFpns(
    VOID
    )
{
    HANDLE          dllHandle;
    BOOL            TSAppCompatEnabled;
    NTSTATUS        Status;
    SIZE_T          i;
    const static BASEP_PROCNAME_PROCADDRESS_PAIR Procs[] = {
        { "TermsrvGetComputerName", (PVOID*)&gpTermsrvGetComputerName },
        { "TermsrvAdjustPhyMemLimits", (PVOID*)&gpTermsrvAdjustPhyMemLimits },
        { "TermsrvGetWindowsDirectoryA", (PVOID*)&gpTermsrvGetWindowsDirectoryA},
        { "TermsrvGetWindowsDirectoryW", (PVOID*)&gpTermsrvGetWindowsDirectoryW},
        { "TermsrvConvertSysRootToUserDir", (PVOID*)&gpTermsrvConvertSysRootToUserDir},
        { "TermsrvBuildIniFileName", (PVOID*)&gpTermsrvBuildIniFileName},
        { "TermsrvCORIniFile", (PVOID*)&gpTermsrvCORIniFile },
        { "GetTermsrCompatFlags", (PVOID*)&gpGetTermsrCompatFlags },
        { "TermsrvBuildSysIniPath", (PVOID*)&gpTermsrvBuildSysIniPath },
        { "TermsrvCopyIniFile", (PVOID*)&gpTermsrvCopyIniFile },
        { "TermsrvGetString", (PVOID*)&gpTermsrvGetString },
        { "TermsrvLogInstallIniFile", (PVOID*)&gpTermsrvLogInstallIniFile }
    };

    if (IsTerminalServerCompatible() ||
       (IsSystemLUID())) {

        Status = STATUS_SUCCESS;
        goto Exit;
    }

    Status = IsTSAppCompatEnabled(&TSAppCompatEnabled);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    if (!TSAppCompatEnabled) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    //
    // Load Terminal Server application compatibility dll
    //
    dllHandle = LoadLibraryW(L"tsappcmp.dll");
    if (dllHandle == NULL) {
        Status = NtCurrentTeb()->LastStatusValue;
        goto Exit;
    }

    for (i = 0 ; i != RTL_NUMBER_OF(Procs) ; ++i) {

        const PCBASEP_PROCNAME_PROCADDRESS_PAIR Proc = &Procs[i];

        *Proc->ProcAddress = GetProcAddress(dllHandle, Proc->ProcName);
    }

    Status = STATUS_SUCCESS;
Exit:
    return Status;
}


/*****************************************************************************
 *
 *  TermsrvAppInstallMode
 *
 *   Returns whether the system is in Install mode or not
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

WINBASEAPI
BOOL
WINAPI
TermsrvAppInstallMode( VOID )
{

    if ( BaseStaticServerData->fTermsrvAppInstallMode )
        return( TRUE );

    return( FALSE );
}


WINBASEAPI BOOL WINAPI IsCallerAdminOrSystem( VOID)
{
 typedef BOOL ( APIENTRY  Func_CheckTokenMembership )( HANDLE , PSID , PBOOL);
    BOOL     rc;
    NTSTATUS Status;
    PSID pSid = NULL ;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    HINSTANCE  dllHandle;
    
    dllHandle = LoadLibraryW(L"advapi32.dll");
    
    if (dllHandle)
    {
        Func_CheckTokenMembership     *fPtr;
        fPtr =  (Func_CheckTokenMembership * )GetProcAddress(dllHandle,"CheckTokenMembership");
        if (fPtr)
        {
            Status = RtlAllocateAndInitializeSid(
                    &SidAuthority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pSid
                    );

            if (NT_SUCCESS(Status))
            {
                BOOL    FoundAdmin;
                if ( fPtr (NULL, pSid , &FoundAdmin)) 
                {
                    if (FoundAdmin) 
                    {
                        SetLastError( ERROR_SUCCESS );
                        rc = TRUE;
                    }
                    else 
                    {
                        // caller does not have access
                        SetLastError( ERROR_ACCESS_DENIED );
                        rc = FALSE;
                    }
                }
                else
                {
                    // call to CheckTokenMembership() failed, it set the last error
                    rc = FALSE;
                }
            }
            else
            {
                // attempt to allocate and init SID failed.
                SetLastError( RtlNtStatusToDosError( Status ) );
                rc = FALSE; 
            }

            if (pSid) 
            {
                RtlFreeSid( pSid );
                pSid = NULL;
            }

            // if caller is not admin, see if caller is local system
            if ( !rc )
            {
                Status = RtlAllocateAndInitializeSid(
                        &SidAuthority,
                        1,
                        SECURITY_LOCAL_SYSTEM_RID , 
                        0, 0, 0, 0, 0, 0, 0,
                        &pSid
                        );
    
                if (NT_SUCCESS(Status))
                {
                    BOOL    FoundLocalSystem;
                    if ( fPtr (NULL, pSid , &FoundLocalSystem)) 
                    {
                        if (FoundLocalSystem) 
                        {
                            SetLastError( ERROR_SUCCESS );
                            rc = TRUE;
                        }
                        else 
                        {
                            // caller does not have access
                            SetLastError( ERROR_ACCESS_DENIED );
                            rc = FALSE;
                        }
                    }
                    else
                    {
                        // call to CheckTokenMembership() failed, it set the last error
                        rc = FALSE;
                    }
                }
                else
                {
                    // attempt to allocate and init SID failed.
                    SetLastError( RtlNtStatusToDosError( Status ) );
                    rc = FALSE; 
                }

            }
        }                       
        else
        {
            // function not found, GetProc() set the last error.
            rc = FALSE;
        }
        FreeLibrary( dllHandle );
    }
    else
    {
        // library not found, LoadLib() set the last error
        rc = FALSE;
    }

    if (pSid) 
    {
        RtlFreeSid( pSid );
    }

    return rc;
}


/*****************************************************************************
 *
 *  SetTermsrvAppInstallMode
 *
 *   Turns App install mode on or off. Default is off
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/
BOOL
WINAPI
SetTermsrvAppInstallMode( BOOL bState )
{
    BOOL     rc = FALSE;
    NTSTATUS Status = STATUS_INTERNAL_ERROR;
    HINSTANCE  dllHandle;
    BOOL TSAppCompatEnabled;
#if !defined(BUILD_WOW6432)
    BASE_API_MSG m;
    PBASE_SET_TERMSRVAPPINSTALLMODE c;
#endif
    
    if (!IsTerminalServer()) {
        //
        // last error should be set to something..
        //
        rc = FALSE;
        goto Exit;
    }

    Status = IsTSAppCompatEnabled(&TSAppCompatEnabled);
    if (!NT_SUCCESS(Status)) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        rc = FALSE;
        goto Exit;
    }
    if (!TSAppCompatEnabled) {
        //
        // last error should be set to something..
        //
        rc = FALSE;
        goto Exit;
    }


#if defined(BUILD_WOW6432)
    Status = CsrBasepSetTermsrvAppInstallMode(bState);
#else

    c = (PBASE_SET_TERMSRVAPPINSTALLMODE)&m.u.SetTermsrvAppInstallMode;

    c->bState = bState;
    Status = CsrClientCallServer((PCSR_API_MSG)&m, NULL,
                                 CSR_MAKE_API_NUMBER(BASESRV_SERVERDLL_INDEX,
                                 BasepSetTermsrvAppInstallMode),
                                 sizeof( *c ));
#endif
        
    if (!NT_SUCCESS(Status)) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        rc = FALSE; 
        goto Exit;
    }
    //
    // Load tsappcmp.dll
    //
    if (gpTermsrvUpdateAllUserMenu == NULL) 
    {
        //
        // Load Terminal Server application compatibility dll
        //
        dllHandle = LoadLibraryW(L"tsappcmp.dll");

        if (dllHandle) 
        {
            gpTermsrvUpdateAllUserMenu =
                    (PTERMSRVUPDATEALLUSERMENU)GetProcAddress(dllHandle,"TermsrvUpdateAllUserMenu");
        }
        else
        {
            // ..
        }
    }
    if (gpTermsrvUpdateAllUserMenu) 
    {
        gpTermsrvUpdateAllUserMenu( bState == TRUE ? 0 : 1 );
    }
    rc = TRUE;
Exit:
    return rc;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/*
  Ini File syncing/merging code

*/
//////////////////////////////////////////////////////////////////////////////
/* External Functions */
NTSTATUS
BaseDllOpenIniFileOnDisk(
    PINIFILE_PARAMETERS a
    );

NTSTATUS
BaseDllWriteKeywordValue(
    IN PINIFILE_PARAMETERS a,
    IN PUNICODE_STRING VariableName OPTIONAL
    );

NTSTATUS
BaseDllCloseIniFileOnDisk(
    IN PINIFILE_PARAMETERS a
    );

NTSTATUS
BaseDllFindSection(
    IN PINIFILE_PARAMETERS a
    );

NTSTATUS
BaseDllFindKeyword(
    IN PINIFILE_PARAMETERS a
    );

NTSTATUS
TermsrvIniSyncLoop( HANDLE SrcHandle,
                PINIFILE_PARAMETERS a,
                PBOOLEAN pfIniUpdated
              );
NTSTATUS
TermsrvGetSyncTime( PUNICODE_STRING pSysIniPath,
                PUNICODE_STRING pUserBasePath,
                PLARGE_INTEGER  pLastSyncTime
              );

NTSTATUS
TermsrvPutSyncTime( PUNICODE_STRING pSysIniPath,
                PUNICODE_STRING pUserBasePath,
                PLARGE_INTEGER  pLastSyncTime
              );


/*****************************************************************************
 *
 *  TermsrvGetSyncTime
 *
 *  This routine will get the time of the system ini file that the user ini
 *  file was last sync'd with.
 *
 * ENTRY:
 *   PUNICODE_STRING pSysIniPath (In) - NT fully qualified system ini path
 *   PUNICODE_STRING pUserBasePath (In) - NT fully qualified user directory path
 *   PLARGE_INTEGER pLastSyncTime (OUT) - ptr to return last sync time
 *
 * EXIT:
 *   STATUS_SUCCESS - successfully retrieved the last sync time from infile.upd
 *
 ****************************************************************************/

NTSTATUS
TermsrvGetSyncTime(
    PUNICODE_STRING pSysIniPath,
    PUNICODE_STRING pUserBasePath,
    PLARGE_INTEGER  pLastSyncTime)
{
    NTSTATUS Status;
    HANDLE   hUpdate = NULL;
    OBJECT_ATTRIBUTES ObjAUpd;
    IO_STATUS_BLOCK   Iosb;
    FILE_STANDARD_INFORMATION StandardInfo;
    WCHAR             wcUpdateFile[MAX_PATH+1];
    UNICODE_STRING    UniUpdateName = {0,
                                       sizeof(wcUpdateFile),
                                       wcUpdateFile};
    PCHAR             pBuff = NULL, pBuffEnd;
    PWCH              pwch;
    SIZE_T            ulBuffSize;
    LONG              lresult;

    if (!pSysIniPath) {
        return STATUS_INVALID_PARAMETER_1;
    }
    if (!pUserBasePath) {
        return STATUS_INVALID_PARAMETER_2;
    }
    if (!pLastSyncTime) {
        return STATUS_INVALID_PARAMETER_3;
    }

    Status = RtlAppendUnicodeStringToString(&UniUpdateName,
                                            pUserBasePath);
    if (NT_SUCCESS(Status)) {
      Status = RtlAppendUnicodeToString(&UniUpdateName,
                                        L"\\inifile.upd");
    }

    if (! NT_SUCCESS(Status)) {
      return Status;
    }

    pLastSyncTime->LowPart = 0;
    pLastSyncTime->HighPart = 0;

    InitializeObjectAttributes( &ObjAUpd,
                                &UniUpdateName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    // Open the update log
    Iosb.Status = STATUS_SUCCESS;
    Status = NtOpenFile( &hUpdate,
                         FILE_GENERIC_READ,
                         &ObjAUpd,
                         &Iosb,
                         FILE_SHARE_READ|FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT    // OpenOptions
                       );

    // Get the size of the file
    if (NT_SUCCESS( Status )) {
        Status = NtQueryInformationFile( hUpdate,
                                         &Iosb,
                                         &StandardInfo,
                                         sizeof(StandardInfo),
                                         FileStandardInformation
                                       );
        if (Status == STATUS_BUFFER_OVERFLOW) {
            Status = STATUS_SUCCESS;
        }
#if DBG
        else if (!NT_SUCCESS( Status )) {
            DbgPrint( "TermsrvGetSyncTime: Unable to QueryInformation for %wZ - Status == %x\n", &UniUpdateName, Status );
        }
#endif
    }

    if (NT_SUCCESS( Status )) {
        ulBuffSize = StandardInfo.EndOfFile.LowPart + 4 * sizeof(WCHAR);
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &pBuff,
                                          0,
                                          &ulBuffSize,
                                          MEM_RESERVE,
                                          PAGE_READWRITE
                                        );
    }

    if (NT_SUCCESS( Status )) {
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &pBuff,
                                          0,
                                          &ulBuffSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
    }

    if (NT_SUCCESS( Status )) {
        Status = NtReadFile( hUpdate,
                             NULL,
                             NULL,
                             NULL,
                             &Iosb,
                             pBuff,
                             StandardInfo.EndOfFile.LowPart,
                             NULL,
                             NULL
                           );

        if ( Status == STATUS_PENDING ) {
            Status = NtWaitForSingleObject( hUpdate, FALSE, NULL );
        }

        if ( NT_SUCCESS(Status) ) {
            // Get final I/O status
            Status = Iosb.Status;
        }
    }

    // Look for this ini file in the list
    if (NT_SUCCESS(Status)) {

        pwch = (PWCHAR)pBuff;
        pBuffEnd = pBuff + StandardInfo.EndOfFile.LowPart;

        // Look for the file in the sorted list
        while ((pwch < (PWCHAR)pBuffEnd) &&
               ((lresult = _wcsicmp(pwch, pSysIniPath->Buffer)) < 0)) {
            pwch += wcslen(pwch) + sizeof(LARGE_INTEGER)/sizeof(WCHAR) + 1;
        }

        if ((pwch < (PWCHAR)pBuffEnd) && (lresult == 0)) {
            pwch += wcslen(pwch) + 1;
            pLastSyncTime->LowPart = ((LARGE_INTEGER UNALIGNED *)pwch)->LowPart;
            pLastSyncTime->HighPart = ((LARGE_INTEGER UNALIGNED *)pwch)->HighPart;
        }
    }

    if (NT_SUCCESS(Status) ) {
        // Get final I/O status
        Status = Iosb.Status;
    }

    if (pBuff) {
        NtFreeVirtualMemory( NtCurrentProcess(),
                             &pBuff,
                             &ulBuffSize,
                             MEM_RELEASE
                           );
    }

    if (hUpdate) {
        Status = NtClose( hUpdate );
    }
    return(Status);
}


/*****************************************************************************
 *
 *  TermsrvPutSyncTime
 *
 *  This routine will write the time of the system ini file that the user ini
 *  file was last sync'd with.
 *
 * ENTRY:
 *   PUNICODE_STRING pSysIniPath (In) - NT fully qualified system ini path
 *   PUNICODE_STRING pUserBasePath (In) - NT fully qualified user directory path
 *   PLARGE_INTEGER pLastSyncTime (OUT) - ptr to return last sync time
 *
 * EXIT:
 *   STATUS_SUCCESS - successfully stored the last sync time in infile.upd
 *
 ****************************************************************************/

NTSTATUS
TermsrvPutSyncTime(
    PUNICODE_STRING pSysIniPath,
    PUNICODE_STRING pUserBasePath,
    PLARGE_INTEGER  pLastSyncTime)
{
    NTSTATUS Status;
    HANDLE   hUpdate = NULL;
    OBJECT_ATTRIBUTES ObjAUpd;
    IO_STATUS_BLOCK   Iosb;
    FILE_STANDARD_INFORMATION StandardInfo;
    WCHAR             wcUpdateFile[MAX_PATH+1];
    UNICODE_STRING    UniUpdateName = {0,
                                       sizeof(wcUpdateFile),
                                       wcUpdateFile};
    PCHAR             pBuff = NULL, pBuffEnd;
    PWCH              pwch;
    SIZE_T            ulBuffSize;
    ULONG             ulLength;
    SIZE_T            ulRegionSize;
    LONG              lresult;
    LARGE_INTEGER     FileLength;
    FILE_POSITION_INFORMATION CurrentPos;

    if (!pSysIniPath) {
        return STATUS_INVALID_PARAMETER_1;
    }
    if (!pUserBasePath) {
        return STATUS_INVALID_PARAMETER_2;
    }
    if (!pLastSyncTime) {
        return STATUS_INVALID_PARAMETER_3;
    }

    Status = RtlAppendUnicodeStringToString(&UniUpdateName,
                                            pUserBasePath);
    if (NT_SUCCESS(Status)) {
      Status = RtlAppendUnicodeToString(&UniUpdateName,
                                        L"\\inifile.upd");
    }

    if (! NT_SUCCESS(Status)) {
      return Status;
    }

    InitializeObjectAttributes( &ObjAUpd,
                                &UniUpdateName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    // Open the update log
    Iosb.Status = STATUS_SUCCESS;
    Status = NtCreateFile( &hUpdate,
                             FILE_READ_DATA | FILE_WRITE_DATA |
                               FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                             &ObjAUpd,
                             &Iosb,
                           NULL,                  // Allocation size
                           FILE_ATTRIBUTE_NORMAL, // dwFlagsAndAttributes
                             FILE_SHARE_WRITE,      // dwShareMode
                           FILE_OPEN_IF,          // CreateDisposition
                             FILE_SYNCHRONOUS_IO_NONALERT |
                               FILE_NON_DIRECTORY_FILE, // CreateFlags
                           NULL, // EaBuffer
                           0     // EaLength
                           );

    if (NT_SUCCESS( Status )) {
        Status = NtQueryInformationFile( hUpdate,
                                         &Iosb,
                                         &StandardInfo,
                                         sizeof(StandardInfo),
                                         FileStandardInformation
                                       );
        if (Status == STATUS_BUFFER_OVERFLOW) {
            Status = STATUS_SUCCESS;
        }
#if DBG
        else if (!NT_SUCCESS( Status )) {
            DbgPrint( "TermsrvPutLastSyncTime: Unable to QueryInformation for %wZ - Status == %x\n", &UniUpdateName, Status );
        }
#endif
    }

    if (NT_SUCCESS( Status )) {
        ulBuffSize = StandardInfo.EndOfFile.LowPart + 4 * sizeof(WCHAR);
        ulRegionSize = ulBuffSize + 0x1000; // Room for 4K of growth
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &pBuff,
                                          0,
                                          &ulRegionSize,
                                          MEM_RESERVE,
                                          PAGE_READWRITE
                                        );
    }

    if (NT_SUCCESS( Status )) {
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &pBuff,
                                          0,
                                          &ulBuffSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE
                                        );
    }

    if (NT_SUCCESS( Status ) && StandardInfo.EndOfFile.LowPart) {
        Status = NtReadFile( hUpdate,
                             NULL,
                             NULL,
                             NULL,
                             &Iosb,
                             pBuff,
                             StandardInfo.EndOfFile.LowPart,
                             NULL,
                             NULL
                           );

        if ( Status == STATUS_PENDING ) {
            Status = NtWaitForSingleObject( hUpdate, FALSE, NULL );
        }

        if ( NT_SUCCESS(Status) ) {
            // Get final I/O status
            Status = Iosb.Status;
        }
    }

    // Look for this ini file in the list
    if (NT_SUCCESS(Status)) {

        pwch = (PWCHAR)pBuff;
        pBuffEnd = pBuff + StandardInfo.EndOfFile.LowPart;

        // Look for the file in the list
        while ((pwch < (PWCHAR)pBuffEnd) &&
               ((lresult = _wcsicmp(pwch, pSysIniPath->Buffer)) < 0)) {
            pwch += wcslen(pwch) + (sizeof(LARGE_INTEGER)/sizeof(WCHAR)) + 1;
        }

        // If the ini file is already in the file, just update the time
        if ((pwch < (PWCHAR)pBuffEnd) && (lresult == 0)) {
            pwch += wcslen(pwch) + 1;
            ((PLARGE_INTEGER)pwch)->LowPart = pLastSyncTime->LowPart;
            ((PLARGE_INTEGER)pwch)->HighPart = pLastSyncTime->HighPart;

        } else {                    // Ini file not in list

            // Figure out the size to grow the file
            ulLength = (pSysIniPath->Length + 2) + sizeof(LARGE_INTEGER);
            ulBuffSize += ulLength;

            // Grow the memory region
            Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                              &pBuff,
                                              0,
                                              &ulBuffSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE
                                            );

            if (NT_SUCCESS(Status)) {
                // figure out where the entry goes in the file
                if (pwch < (PWCHAR)pBuffEnd) {
                    RtlMoveMemory( pwch+(ulLength/sizeof(WCHAR)),
                                   pwch,
                                   pBuffEnd - (PCHAR)pwch
                                 );
                }

                pBuffEnd += ulLength;
                wcscpy(pwch, pSysIniPath->Buffer);
                pwch += (pSysIniPath->Length + 2)/sizeof(WCHAR);
                ((PLARGE_INTEGER)pwch)->LowPart = pLastSyncTime->LowPart;
                ((PLARGE_INTEGER)pwch)->HighPart = pLastSyncTime->HighPart;
            }
        }
    }

    if (NT_SUCCESS(Status)) {
        CurrentPos.CurrentByteOffset.LowPart = 0;
        CurrentPos.CurrentByteOffset.HighPart = 0;
        Status = NtSetInformationFile( hUpdate,
                                       &Iosb,
                                       &CurrentPos,
                                       sizeof(CurrentPos),
                                       FilePositionInformation
                                     );

        Status = NtWriteFile( hUpdate,
                              NULL,
                              NULL,
                              NULL,
                              &Iosb,
                              pBuff,
                              (ULONG)(pBuffEnd - pBuff + 1),
                              NULL,
                              NULL
                            );

        if( Status == STATUS_PENDING ) {
            Status = NtWaitForSingleObject( hUpdate, FALSE, NULL );
        }

        if( NT_SUCCESS(Status) ) {
            // Get final I/O status
            Status = Iosb.Status;
        }
    }

    if (NT_SUCCESS( Status )) {
        FileLength.LowPart = (ULONG)(pBuffEnd - pBuff);
        FileLength.HighPart = 0;
        Status = NtSetInformationFile( hUpdate,
                                       &Iosb,
                                       &FileLength,
                                       sizeof( FileLength ),
                                       FileEndOfFileInformation
                                     );
    }

    if (pBuff) {
        NtFreeVirtualMemory( NtCurrentProcess(),
                             &pBuff,
                             &ulRegionSize,
                             MEM_RELEASE
                           );
    }

    if (hUpdate) {
        Status = NtClose( hUpdate );
    }

    return(Status);
}


/*****************************************************************************
 *
 *  TermsrvCheckIniSync
 *
 *  This routine will get the time of the system ini file that the user ini
 *  file was last sync'd with.
 *
 * ENTRY:
 *   PUNICODE_STRING pSysIniPath (In) - NT fully qualified system ini path
 *   PUNICODE_STRING pUserBasePath (In) - NT fully qualified user directory path
 *   BOOLEAN fGet (In) - TRUE means to get last sync time, FALSE means to write it
 *   PLARGE_INTEGER pLastSyncTime (OUT) - ptr to return last sync time
 *
 * EXIT:
 *   TRUE  - User ini file should be sync'd
 *   FALSE - User ini file should be sync'd
 *
 ****************************************************************************/

BOOLEAN
TermsrvCheckIniSync(
    PUNICODE_STRING pSysIniPath,
    PUNICODE_STRING pUserBasePath)
{
    LARGE_INTEGER          LastSyncTime;
    OBJECT_ATTRIBUTES      objaIni;
    FILE_NETWORK_OPEN_INFORMATION BasicInfo;
    NTSTATUS               Status;

    // Get the last sync time of the ini file from the inifile.upd file
    Status = TermsrvGetSyncTime(pSysIniPath, pUserBasePath, &LastSyncTime);
    if (!NT_SUCCESS(Status)  )
    {
        return FALSE;   // if we can't get the time, no point doing an update.
    }

    // Get the last write time of the system ini file
    InitializeObjectAttributes(
        &objaIni,
        pSysIniPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    // Now query it
    Status = NtQueryFullAttributesFile( &objaIni, &BasicInfo );

    // If we couldn't get the time or the system ini file has been updated
    // since we last sync'd, return TRUE
    if (!NT_SUCCESS(Status) ||
        ((BasicInfo.LastWriteTime.HighPart > LastSyncTime.HighPart) ||
         ((BasicInfo.LastWriteTime.HighPart == LastSyncTime.HighPart) &&
         (BasicInfo.LastWriteTime.LowPart > LastSyncTime.LowPart)))) {
        return(TRUE);
    }
    return(FALSE);
}
/*****************************************************************************
 *
 *  TermsrvDoesFileExist
 *
 *   Returns whether the file exists or not.
 *
 *   Must use NT, not WIN32 pathnames.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
TermsrvDoesFileExist(
    PUNICODE_STRING pFileName
    )
{
    NTSTATUS Status;
    FILE_BASIC_INFORMATION BasicInfo;
    OBJECT_ATTRIBUTES Obja;

    InitializeObjectAttributes(
        &Obja,
        pFileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    /*
     * Now query it
     */
    Status = NtQueryAttributesFile( &Obja, &BasicInfo );

    if( NT_SUCCESS( Status ) ) {
        return( TRUE );
    }

    return( FALSE );
}



/*****************************************************************************
 *
 *  TermsrvSyncUserIniFile
 *
 *   This routine will check that the user's ini file is "sync'd" with the
 *   system version of the ini file.  This means that it walks through the
 *   system ini file and checks that there is a corresponding entry in the
 *   user's ini file.
 *
 * ENTRY:
 *   IN PINIFILE_PARAMETERS a - ptr to inifile structure
 *
 * EXIT:
 *   True  - Ini file updated
 *   False - User Ini file was unchanged
 *
 ****************************************************************************/
BOOL TermsrvSyncUserIniFile(PINIFILE_PARAMETERS a)
{
    WCHAR          wcIniPath[MAX_PATH+1];
    PWCHAR         pIniPathEnd;
    UNICODE_STRING IniFilePath = {MAX_PATH * sizeof(WCHAR),
                                  (MAX_PATH+1) * sizeof(WCHAR),
                                  wcIniPath};
    HRESULT        hr;
    size_t         cbIniPathRemaining;
    PWCH           pwch, pwcIniName = NULL;
    UNICODE_STRING UniSysPath;
    UNICODE_STRING UserBasePath;
    NTSTATUS       Status;
    HANDLE         SrcHandle;
    ULONG          ulCompatFlags;
    OBJECT_ATTRIBUTES SrcObja;
    IO_STATUS_BLOCK   SrcIosb;
    INIFILE_OPERATION OrigOperation;
    BOOLEAN           OrigWrite, OrigMultiValue, OrigUnicode,
                      OrigWriteOperation, fIniUpdated = FALSE;
    ANSI_STRING       OrigAppName, OrigVarName;
    ULONG             OrigResultChars, OrigResultMaxChars;
    LPSTR             OrigResultBuffer;
    OBJECT_ATTRIBUTES      objaIni;
    FILE_NETWORK_OPEN_INFORMATION BasicInfo;
    
    // If INI file mapping is not on, return
    if (IsSystemLUID() || TermsrvAppInstallMode()) {
        return(FALSE);
    }

    // Build full system path to the Ini file, and get BasePath to user dir
    if ((gpTermsrvBuildSysIniPath == NULL) || !(gpTermsrvBuildSysIniPath(&a->NtFileName, &UniSysPath, &UserBasePath))) {
        #if DBG
        //DbgPrint("TermsrvSyncUserIniFile: Error building Sys Ini Path!\n");
        #endif
        return(FALSE);
    }
    
    // From here on out, execute the cleanup code.

    // Get the ini file name
    pwch = wcsrchr(a->NtFileName.Buffer, L'\\') ;
    if (pwch == NULL) {
        goto Cleanup;
    } else{
        pwch++;
    }

    pwcIniName = RtlAllocateHeap( RtlProcessHeap(),
                                  0,
                                  (wcslen(pwch) + 1)*sizeof(WCHAR));
    if (pwcIniName == NULL) {
        goto Cleanup;
    }

    wcscpy(pwcIniName, pwch);
    pwch = wcsrchr(pwcIniName, L'.');
    if (pwch) {
        *pwch = L'\0';
    }

    if (gpGetTermsrCompatFlags) 
    {
        if ( ! gpGetTermsrCompatFlags(pwcIniName, &ulCompatFlags, CompatibilityIniFile) )
        {
            goto Cleanup;
        }
    } 
    else 
    {
        goto Cleanup;
    }

    // If the INISYNC compatibility flag is set in the registry and the
    // system version of the ini file exists, sync up the user version
    if (((ulCompatFlags & (TERMSRV_COMPAT_INISYNC | TERMSRV_COMPAT_WIN16)) ==
         (TERMSRV_COMPAT_INISYNC | TERMSRV_COMPAT_WIN16)) &&
        TermsrvDoesFileExist(&UniSysPath) &&
        TermsrvCheckIniSync(&UniSysPath, &UserBasePath)) {

        // Create a backup copy of the original file (inifile.ctx)
        hr = StringCbCopyExW(wcIniPath,
                             sizeof(wcIniPath),
                             UserBasePath.Buffer,
                             &pIniPathEnd,
                             &cbIniPathRemaining,
                             0);

        if (FAILED(hr)) {
            goto Cleanup;
        }

        if (UserBasePath.Buffer[UserBasePath.Length/sizeof(WCHAR) - 1] != L'\\') {
            hr = StringCbCatExW(pIniPathEnd,
                                cbIniPathRemaining,
                                L"\\",
                                &pIniPathEnd,
                                &cbIniPathRemaining,
                                0);
            if (FAILED(hr)) {
                goto Cleanup;
            }
        }

        hr = StringCbCatExW(pIniPathEnd,
                            cbIniPathRemaining,
                            pwcIniName,
                            &pIniPathEnd,
                            &cbIniPathRemaining,
                            0);
        if (FAILED(hr)) {
            goto Cleanup;
        }

        hr = StringCbCatExW(pIniPathEnd,
                            cbIniPathRemaining,
                            L".ctx",
                            &pIniPathEnd,
                            &cbIniPathRemaining,
                            0);

        if (FAILED(hr)) {
            goto Cleanup;
        }

        IniFilePath.Length = (USHORT)((LPBYTE)pIniPathEnd - (LPBYTE)wcIniPath);

        if (gpTermsrvCopyIniFile) {
            BOOL copy_result = gpTermsrvCopyIniFile(&a->NtFileName, NULL, &IniFilePath);
    #if DBG
            if (!copy_result) {
                DbgPrint("TermsrvSyncUserIniFile: Error creating backup ini file %ws\n",
                         wcIniPath);
            }
    #endif
        } else {
            goto Cleanup;
        }

        // Check that each entry in the system version is in the user's version
        InitializeObjectAttributes(&SrcObja,
                                   &UniSysPath,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        // Open the src
        SrcIosb.Status = STATUS_SUCCESS;
        Status = NtOpenFile(&SrcHandle,
                             FILE_GENERIC_READ,
                            &SrcObja,
                            &SrcIosb,
                            FILE_SHARE_READ|FILE_SHARE_WRITE,
                            FILE_SYNCHRONOUS_IO_NONALERT);

        if( NT_SUCCESS(Status) ) {
            // Get final I/O status
                  Status = SrcIosb.Status;
        }

        if( !NT_SUCCESS(Status) ) {
#if DBG
            DbgPrint("TermsrvSyncUserIniFile: Error 0x%x opening SrcFile %ws\n",
                     Status,
                     &UniSysPath.Buffer);
#endif
            goto Cleanup;
        }

        // Save the original values
        OrigOperation = a->Operation;
        OrigMultiValue = a->MultiValueStrings;
        OrigAppName = a->ApplicationName;
        OrigVarName = a->VariableName;
        OrigResultChars = a->ResultChars;
        OrigResultMaxChars = a->ResultMaxChars;
        OrigResultBuffer = a->ResultBuffer;
        OrigUnicode = a->Unicode;
        OrigWriteOperation = a->WriteOperation;

        // Set up the open for writes
        a->WriteOperation = TRUE;
        a->Operation = WriteKeyValue;
        a->MultiValueStrings = FALSE;
        a->Unicode = FALSE;

        Status = BaseDllOpenIniFileOnDisk( a );

        if( !NT_SUCCESS(Status) ) {
#if DBG
            DbgPrint("TermsrvSyncUserIniFile: Error 0x%x opening DestFile %ws\n",
                     Status,
                     &a->NtFileName.Buffer);
#endif
            NtClose( SrcHandle );
                goto Cleanup;
        }

        // set the data up for writing
        a->TextEnd = (PCHAR)a->IniFile->BaseAddress +
                            a->IniFile->EndOfFile;
        a->TextCurrent = a->IniFile->BaseAddress;

        // Make sure entries in system ini file are in user ini file
        Status = TermsrvIniSyncLoop( SrcHandle, a, &fIniUpdated );
#if DBG
        if( !NT_SUCCESS(Status) ) {
            DbgPrint("TermsrvSyncUserIniFile: Error 0x%x Doing sync loop\n",Status);
        }
#endif

        // Close the file handles
        NtClose( SrcHandle );
        BaseDllCloseIniFileOnDisk( a );

        // Restore the variables in the ini file structure
        a->Operation = OrigOperation;
        a->MultiValueStrings = OrigMultiValue;
        a->ApplicationName = OrigAppName;
        a->VariableName = OrigVarName;
        a->ResultChars = OrigResultChars;
        a->ResultMaxChars = OrigResultMaxChars;
        a->ResultBuffer = OrigResultBuffer;
        a->WriteOperation = FALSE;
        a->Unicode = OrigUnicode;
        a->WriteOperation = OrigWriteOperation;

        // Get the last write time of the system ini file
        InitializeObjectAttributes( &objaIni,
                                    &UniSysPath,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL
                                  );

        // Now query it
        Status = NtQueryFullAttributesFile( &objaIni, &BasicInfo );

        // Update the sync time in the inisync file
        if (NT_SUCCESS(Status)) {
            TermsrvPutSyncTime( &UniSysPath,
                            &UserBasePath,
                            &BasicInfo.LastWriteTime
                          );
        }
    }

 Cleanup:
    // Free the unicode buffers
    if (UniSysPath.Buffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, UniSysPath.Buffer );
    }
    if (UserBasePath.Buffer) {
        RtlFreeHeap( RtlProcessHeap(), 0, UserBasePath.Buffer );
    }
    if (pwcIniName) {
        RtlFreeHeap( RtlProcessHeap(), 0, pwcIniName);
    }

    return(fIniUpdated);
}


/*****************************************************************************
 *
 *  TermsrvIniSyncLoop
 *
 *  This routine will verify that there's a corresponding entry in the user's
 *  ini file for each entry in the system ini file.
 *
 * ENTRY:
 *   HANDLE SrcHandle (INPUT)  - Handle to system ini file
 *   PINIFILE_PARAMETERS a (INPUT) - pointer to current ini file structure
 *   PBOOLEAN pfIniUpdated (OUTPUT) - Returns TRUE if user ini file is modified
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
TermsrvIniSyncLoop(HANDLE SrcHandle,
               PINIFILE_PARAMETERS a,
               PBOOLEAN pfIniUpdated)
{
    PCHAR pStr;
    NTSTATUS Status;
    ULONG StringSize;
    CHAR  IOBuf[512];
    ULONG IOBufSize = 512;
    ULONG IOBufIndex = 0;
    ULONG IOBufFillSize = 0;
    ANSI_STRING AnsiSection;
    PCH pch;
    PVOID pSection, origbase;

    AnsiSection.Buffer = NULL;
    *pfIniUpdated = FALSE;

    while( 1 ) {

        pStr = NULL;
        StringSize = 0;

        if (gpTermsrvGetString == NULL) {
            return STATUS_UNSUCCESSFUL;
        }

        // Get a string from the source ini file
        Status = gpTermsrvGetString(SrcHandle,
                               &pStr,
                               &StringSize,
                               IOBuf,
                               IOBufSize,
                              &IOBufIndex,
                               &IOBufFillSize);

        if( !NT_SUCCESS(Status) ) {

            ASSERT( pStr == NULL );

            if( Status == STATUS_END_OF_FILE ) {
                Status = STATUS_SUCCESS;
            }
            if (AnsiSection.Buffer) {
                RtlFreeHeap( RtlProcessHeap(), 0, AnsiSection.Buffer );
            }

            a->IniFile->UpdateEndOffset = a->IniFile->EndOfFile;
            return( Status );
        }

        // Make sure we got some actual data
        ASSERT( pStr != NULL );

        // Is this a section name?
        if (*pStr == '[') {
            if (AnsiSection.Buffer) {
                RtlFreeHeap( RtlProcessHeap(), 0, AnsiSection.Buffer );
                AnsiSection.Buffer = NULL;
            }
            pch = strrchr(pStr, ']');
            if (pch) {
                AnsiSection.MaximumLength = (USHORT)(pch - pStr);
                *pch = '\0';
            } else {
                AnsiSection.Length = (USHORT)strlen(pStr);
            }
            AnsiSection.Length = AnsiSection.MaximumLength - 1;
            AnsiSection.Buffer = RtlAllocateHeap(RtlProcessHeap(),
                                                 0,
                                                 AnsiSection.MaximumLength);
            if (!AnsiSection.Buffer) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            strcpy(AnsiSection.Buffer, pStr+1);
            a->ApplicationName = AnsiSection;

            a->TextCurrent = a->IniFile->BaseAddress;   // reset file pointer

            // See if the section already exists, if so save the start of it
            Status = BaseDllFindSection( a );
            if (NT_SUCCESS(Status)) {
                pSection = a->TextCurrent;
            } else {
                pSection = NULL;
            }

        // If it's not a comment, see if the entry is in the user's ini file
        } else if (*pStr != ';') {

            pch = strchr(pStr, '=');
            if (pch) {
                a->VariableName.Length = a->VariableName.MaximumLength =
                    (USHORT)(pch - pStr);
                a->VariableName.Buffer = pStr;
                a->ValueBuffer = (++pch);
                a->ValueLength = 0;
                while (*pch && (*pch != 0xa) && (*pch != 0xd)) {
                    pch++;
                    a->ValueLength++;
                }


                // If the section exists, check for the keyword in user's ini
                if (pSection) {
                    a->TextCurrent = pSection;
                    Status = BaseDllFindKeyword( a );
                }

                // If variable isn't found, write it out
                if (!pSection || !NT_SUCCESS( Status )) {

                    origbase = a->TextCurrent = a->IniFile->BaseAddress;
                    Status = BaseDllWriteKeywordValue( a, NULL );
                    a->TextEnd = (PCHAR)a->IniFile->BaseAddress +
                                        a->IniFile->EndOfFile;
                    if (!NT_SUCCESS(Status)) {
                              #if DBG
                              DbgPrint("TermsrvIniSyncLoop: Error 0x%x write Key Value\n",
                                  Status);
                              #endif
                        a->IniFile->UpdateEndOffset = a->IniFile->EndOfFile;
                        RtlFreeHeap( RtlProcessHeap(), 0, pStr );
                        if (AnsiSection.Buffer) {
                            RtlFreeHeap(RtlProcessHeap(),
                                        0,
                                        AnsiSection.Buffer);
                        }
                        return(Status);
                    }
                    *pfIniUpdated = TRUE;
                    if (origbase != a->IniFile->BaseAddress) {
                        a->TextCurrent = a->IniFile->BaseAddress;
                        Status = BaseDllFindSection( a );
                        if (NT_SUCCESS(Status)) {
                            pSection = a->TextCurrent;
                        } else {
                            pSection = NULL;
                        }
                    }
                }
            }
        }


    } // end while(1)
}

/******************************************************************************
 *
 *  GetPerUserWindowsDirectory
 *
 *
 *
 *****************************************************************************/
NTSTATUS
GetPerUserWindowsDirectory(
    OUT PWCHAR  TermSrvWindowsPath,
    IN  SIZE_T  InLength,
    OUT PSIZE_T OutLength
    )
{
    static const UNICODE_STRING BaseHomePathVariableName = RTL_CONSTANT_STRING(L"HOMEPATH");
    static const UNICODE_STRING BaseHomeDriveVariableName = RTL_CONSTANT_STRING(L"HOMEDRIVE");
    NTSTATUS Status;
    UNICODE_STRING Path;
    BOOL TSAppCompatEnabled;
    UNICODE_STRING UnicodeString_TermSrvWindowsPath;

    *OutLength = 0;

    Status = IsTSAppCompatEnabled(&TSAppCompatEnabled);
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }
    if (!TSAppCompatEnabled) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }
    if (IsSystemLUID()) {
        Status = STATUS_SUCCESS;
        goto Exit;
    }
    if (InLength < MAX_PATH) {
        Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    /*
     * Check for HOMEDRIVE and HOMEPATH
     */

    Path.Buffer = TermSrvWindowsPath;
    Path.Length = 0;
    Path.MaximumLength = (MAX_PATH * sizeof(WCHAR)) - (9 * sizeof(WCHAR)); //MAX_PATH - wcslen(L"\\WINDOWS") + 1

    Status = RtlQueryEnvironmentVariable_U(
            NULL,
            &BaseHomeDriveVariableName,
            &Path);

    if (NT_SUCCESS(Status)) {

        UnicodeString_TermSrvWindowsPath.Buffer = TermSrvWindowsPath;
        UnicodeString_TermSrvWindowsPath.MaximumLength = (RTL_STRING_LENGTH_TYPE)(InLength * sizeof(UnicodeString_TermSrvWindowsPath.Buffer[0]));
        UnicodeString_TermSrvWindowsPath.Length = Path.Length;

        Path.MaximumLength -= Path.Length;
        Path.Buffer += Path.Length / sizeof(Path.Buffer[0]);
        Path.Length = 0;

        Status = RtlQueryEnvironmentVariable_U(
            NULL,
            &BaseHomePathVariableName,
            &Path);
        if (NT_SUCCESS(Status)) {
            UnicodeString_TermSrvWindowsPath.Length += Path.Length;
        }
    }
    if (!NT_SUCCESS(Status)) {
        goto Exit;
    }

    /*
    * Add a trailing backslash if one's not already there
    */
    if (RTL_STRING_GET_LAST_CHAR(&UnicodeString_TermSrvWindowsPath) != L'\\') {
        RtlAppendUnicodeToString(&UnicodeString_TermSrvWindowsPath, L"\\");
    }

    RtlAppendUnicodeToString(&UnicodeString_TermSrvWindowsPath, L"WINDOWS");
    *OutLength = RTL_STRING_GET_LENGTH_CHARS(&UnicodeString_TermSrvWindowsPath);
    Status = STATUS_SUCCESS;
Exit:
    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("GetPerUserWindowsDirectory Failed with Status %lx\n", Status);
#endif
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\tlfn.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tlfn.c

Abstract:

    Test program for GetShortPathName and GetLongPathName

Author:

    William Hsieh (williamh) 26-Mar-1997

Revision History:

--*/

#undef UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <assert.h>
#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <windows.h>
#include "basedll.h"

BOOL
CreateTestDirs(LPSTR BasePath, DWORD Depth);
BOOL
DeleteTestDirs(LPSTR BasePath, DWORD Depth);

DWORD
DoTest(LPSTR BasePath, DWORD Depth);

BOOL
DoNullPathTest();

LPSTR	g_BasePath = "C:\\LongDirectoryForTesting";
#define MAX_SUBDIRS  22
// Note that NT file APIs strips trailing white chars automatically,
// thus, path name such as "12345678.12 " will be created as
// "12345678.12". Do not put something like this in the following table
// or the test will fail.
// The TestDepth controls the depth of the testing sub-dirs this program
// creates. It could take a long time to complete the test if TestDepth
// is set to larger than 3. With TestDepth set to 1, the program only tests
// the BasePath. You can always manually test a particular pathname
// by running "tlfn 1 yourpath". In this case, the given directory will not
// be removed by this program.
//
LPSTR	g_subdir[MAX_SUBDIRS] = {
    "12345678.123",
    "12345678.1",
    "8.1",
    "8.123",
    "12345678.1",
    "12345678",
    " 2345678.  3",
    "       8.1 3",
    "1      8. 23",
    "123  678.123",
    "123  678.1 3",
    ".1",
    "..2",
    "...3",
    "1  4 6 8........1 3",
    "1      8..123",
    "12345678..1 3",
    "12345678.12345678",
    "1234567890123456.1111",
    "123456789.123",
    "12345678.1234",
    "12345   1"
    };

CHAR	g_ShortName[MAX_PATH + 1];
CHAR	g_LongName[MAX_PATH + 1];

DWORD	g_TestDepth = 3;


DWORD
_cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    DWORD FailCount;
    LPSTR   BasePath;
    DWORD TestDepth;

    TestDepth =  g_TestDepth;
    BasePath = g_BasePath;

    if (argc > 1 && argv[1])
    {
	TestDepth = atoi(argv[1]);
    }
    if (argc > 2 && argv[2])
    {
	BasePath = argv[2];
    }
    printf("Test depth = %d, Base path = %s\n", TestDepth, BasePath);


    if (!DoNullPathTest()) {
	printf("NullPath test Failed\n");
	return FALSE;
	}
    printf("Null Path test passed\n");

    if (TestDepth != 1 || BasePath == g_BasePath) {
	printf("\n\nCreating testing sub-directories.....\n\n\n");

	if (!CreateTestDirs(BasePath, TestDepth))
	    {
	    printf("Unable to create test path names\n");
	    return FALSE;
	    }
	}

    printf("Start testing....\n");



    FailCount = DoTest(BasePath, TestDepth);

    if (!FailCount)
	printf("Test passed\n");
    else
	printf("Test not passed, failed count = %ld\n", FailCount);

    if (TestDepth != 1 || BasePath == g_BasePath)  {
	printf("Removing test sub-directories\n\n\n");
	DeleteTestDirs(BasePath, TestDepth);
    }
    return TRUE;
}


BOOL
CreateTestDirs(
    LPTSTR BasePath,
    DWORD Depth
    )
{
    int len;
    CHAR szBase[MAX_PATH + 1];
    BOOL    Result;
    DWORD dw;

    Result = TRUE;
    dw = GetFileAttributes(BasePath);
    if (dw == 0xFFFFFFFF)
    {
	if (!CreateDirectory(BasePath, NULL))
	{
	    printf("CreateTestDirs::Unable to create base directory, error = %ld\n",
		    GetLastError());
	    return FALSE;
	}
    }
    dw = GetFileAttributes(BasePath);
    if (dw == 0xFFFFFFFF || !(dw & FILE_ATTRIBUTE_DIRECTORY))
	return FALSE;
    if (Depth > 1)
    {
	int i;
	len = strlen(BasePath);
	strcpy(szBase, BasePath);
	for (i = 0; i < MAX_SUBDIRS; i++)
	{
	    szBase[len] = '\\';
	    strcpy((szBase + len + 1), g_subdir[(Depth & 1) ? i : MAX_SUBDIRS - i - 1]);
	    if (!CreateTestDirs(szBase, Depth - 1))
	    {
		Result = FALSE;
		break;
	    }
	}
    }
    return Result;
}


BOOL
DeleteTestDirs(
    LPSTR BasePath,
    DWORD Depth
    )
{
    int i, len;
    CHAR Temp[MAX_PATH + 1];
    strcpy(Temp, BasePath);
    len = strlen(BasePath);

    if (Depth)
    {
	for (i = 0; i < MAX_SUBDIRS; i++)
	{
	    Temp[len] = '\\';
	    strcpy((Temp + len + 1), g_subdir[(Depth & 1) ?i : MAX_SUBDIRS - i - 1]);
	    DeleteTestDirs(Temp, Depth - 1);
	}
    }
    RemoveDirectory(BasePath);
    return TRUE;
}

DWORD
DoTest(
    LPSTR   BasePath,
    DWORD   Depth
    )
{

    DWORD dw, dwTemp;
    DWORD FailCount;

    LPSTR ShortPath, LongPath;
    CHAR FunnyBuffer[1];
    ASSERT(Depth >= 1);
    ASSERT(BasePath);

    FailCount = 0;

    // this should fail
    dw = GetShortPathName(BasePath, NULL, 0);
    dwTemp = GetShortPathName(BasePath, FunnyBuffer, sizeof(FunnyBuffer) / sizeof(CHAR));
    ASSERT(dw == dwTemp);
    dwTemp = GetShortPathName(BasePath, NULL, 0xffff);
    ASSERT(dw == dwTemp);
    dwTemp = GetShortPathName(BasePath, FunnyBuffer, 0);
    ASSERT(dwTemp == dw);
    ShortPath = (LPTSTR)malloc(dw * sizeof(CHAR));
    if (!ShortPath) {
	printf("Not enough memory\n");
	return 0;
	}
    dwTemp = GetShortPathName(BasePath, ShortPath, dw - 1);
    ASSERT(dwTemp == dw);
    dwTemp  = GetShortPathName(BasePath, ShortPath, dw);
    ASSERT(dwTemp && dwTemp + 1 == dw);
    printf("\"%s\" L-S -> \"%s\"\n", BasePath, ShortPath);
    strcpy(g_LongName, BasePath);
    dw = GetShortPathName(g_LongName, g_LongName, dwTemp - 1);
    if (_stricmp(BasePath, g_LongName))
    {
	printf("Overwrite source string\n");
	ASSERT(FALSE);
	strcpy(g_LongName, BasePath);
    }
    dw = GetShortPathName(g_LongName, g_LongName, dwTemp + 1);
    ASSERT(dw == dwTemp);
    if (_stricmp(ShortPath, g_LongName)) {
	printf("GetShortPathName mismatch with different desitination buffer\n");
	ASSERT(FALSE);
	}
    dw = GetLongPathName(ShortPath, NULL, 0);
    dwTemp = GetLongPathName(ShortPath, FunnyBuffer, sizeof(FunnyBuffer) / sizeof(CHAR));
    ASSERT(dw == dwTemp);
    dwTemp = GetLongPathName(ShortPath, NULL, 0xffff);
    ASSERT(dwTemp == dw);
    dwTemp = GetLongPathName(ShortPath, FunnyBuffer, 0);
    ASSERT(dw == dwTemp);
    LongPath = (LPSTR)malloc(dw * sizeof(CHAR));
    if (!LongPath) {
	printf("Not enough memory\n");
	free(ShortPath);
	return(0);
    }
    dwTemp = GetLongPathName(ShortPath, LongPath, dw - 1);
    ASSERT( dw == dwTemp);
    dwTemp = GetLongPathName(ShortPath, LongPath, dw);
    ASSERT(dwTemp && dwTemp + 1 == dw);
    printf("\"%s\" S-L -> \"%s\"\n", ShortPath, LongPath);
    strcpy(g_ShortName, ShortPath);
    dw = GetLongPathName(g_ShortName, g_ShortName, dwTemp - 1);
    if (_stricmp(ShortPath, g_ShortName))
    {
	printf("Overwrite source string\n");
	ASSERT(FALSE);
	strcpy(g_ShortName, ShortPath);
    }
    dw = GetLongPathName(g_ShortName, g_ShortName, dwTemp + 1);
    ASSERT(dw == dwTemp);
    if (_stricmp(LongPath, g_ShortName)) {
	printf("GetLongPathName mismatch with different desitination buffer\n");
	ASSERT(FALSE);
	}

    if (_stricmp(LongPath, BasePath))
    {
	FailCount++;
	printf("round trip does not match\n");
	ASSERT(FALSE);
    }
    if(Depth > 1) {
	int i, len;
	CHAR TempName[MAX_PATH + 1];
	len = strlen(BasePath);
	strcpy(TempName, BasePath);
	for (i = 0; i < MAX_SUBDIRS; i++)
	{
	    TempName[len] = '\\';
	    strcpy((TempName + len + 1), g_subdir[(Depth & 1) ?i : MAX_SUBDIRS - i - 1]);
	    FailCount += DoTest(TempName, Depth - 1);
	}
    }
    free(ShortPath);
    free(LongPath);
    return FailCount;
}





BOOL
DoNullPathTest()
{

    CHAR ShortName[1];
    CHAR LongName[1];
    DWORD dw;

    LongName[0] = '\0';
    dw = GetShortPathName(LongName, ShortName, 0);
    ASSERT(dw == 1);
    dw = GetShortPathName(LongName, ShortName, 1);
    ASSERT(dw == 0);
    ShortName[0] = '\0';
    dw = GetLongPathName(ShortName, LongName, 0);
    ASSERT(dw == 1);
    dw = GetLongPathName(ShortName, LongName, 1);
    ASSERT(dw == 0);
    return (dw == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\tmssrv.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tmslot.c

Abstract:

    Test program to Win32 mailslot API calls

Author:

    Manny Weiser (mannyw) 5-Mar-1991

Revision History:

--*/

#include "stdio.h"
#include "windows.h"

#define BUFFER_SIZE   100

char Buffer[BUFFER_SIZE];

DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )

{
    BOOL success;
    HANDLE handle;
    LPSTR mailslotName =  "\\\\.\\mailslot\\asdf";

    DWORD maxMessageSize, nextSize, messageCount, readTimeout;
    DWORD bytesRead;

    handle = CreateMailslot( mailslotName,
                             100,
                             MAILSLOT_WAIT_FOREVER,
                             NULL );

    if (handle == (HANDLE)-1) {
        printf ("Failed to open mailslot ""%s""\n", mailslotName);
        return 1;
    }

    printf ("Successfully opened the mailslot.\n");

    success = SetMailslotInfo( handle,
                               atoi( argv[1] ) );
    if (!success) {
        printf ("Failed to set information for mailslot\n");
        return 1;
    }

    printf ("Set mailslot timeout to %d\n", atoi(argv[1]) );

    success = GetMailslotInfo( handle,
                               &maxMessageSize,
                               &nextSize,
                               &messageCount,
                               &readTimeout );

    if (!success) {
        printf ("Failed to get information for mailslot\n");
        return 1;
    }

    printf ("Max message size  = %d\n", maxMessageSize );
    printf ("Next message size = %d\n", nextSize );
    printf ("Message count     = %d\n", messageCount );
    printf ("Read timeout      = %u\n", readTimeout );

    success = ReadFile( handle,
                        Buffer,
                        BUFFER_SIZE,
                        &bytesRead,
                        NULL );

    if (!success) {
        printf ("Failed to read mailslot\n");
        return 1;
    } else {
        printf ("Successfully read %d bytes '%s'\n", bytesRead, Buffer );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\tmscli.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tmscli.c

Abstract:

    Test program to Win32 mailslot API calls

Author:

    Manny Weiser (mannyw) 5-May-1991

Revision History:

--*/

#include "stdio.h"
#include "windows.h"

char Buffer[] = "This is a message";

DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )
        
{
    BOOL success;
    HANDLE handle;
    LPSTR mailslotName =  "\\\\.\\mailslot\\asdf";
    
    DWORD bytesWritten;
    
    handle = CreateFile( mailslotName,
                         GENERIC_WRITE,
                         FILE_SHARE_WRITE | FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         0 );

    if (handle == (HANDLE)-1) {
        printf ("Failed to open mailslot ""%s""\n", mailslotName);
        printf ("Error = %lx\n", GetLastError() );
        return 1;
    }
    
    printf ("Successfully opened the mailslot.\n");
    

    success = WriteFile( handle,
                         Buffer,
                         sizeof(Buffer),
                         &bytesWritten,
                         NULL );
                    
    if (!success) {
        printf ("Failed to read mailslot\n");
        return 1;
    } else {
        printf ("Successfully wrote %d bytes '%s'\n", bytesWritten, Buffer );
    }
                         
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\tnpcli.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tnpcli.c

Abstract:

    This program makes simple client calls to tnpsrv.c

Author:

    Colin Watson (ColinW) 19-March-1991

Revision History:

--*/
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>

CHAR* WriteData1 = "Hello Mars\n";
CHAR* WriteData2 = "Hello Jupiter\n";

int
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    HANDLE C1;
    DWORD Size;
    DWORD Dummy;
    DWORD Count;
    CHAR Data[1024];
    OVERLAPPED Overlapped;

    printf("Create client...\n");

    C1 = CreateFile("\\\\.\\Pipe\\cw\\testpipe",
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,       // Security Attributes
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
    for ( Count = 1; Count < 10; Count++ ) {

        printf("Client Writing...\n");
        if ( FALSE == WriteFile(C1, WriteData1, strlen(WriteData1)+1, &Dummy, NULL) ) {
            printf("Client WriteFile returned Error %lx\n", GetLastError() );
            }

        while (1) {
            printf("Client now Peeking...\n");
            if ( FALSE == PeekNamedPipe(C1,Data, sizeof(Data), &Size, NULL, NULL) ) {
                printf("Client PeekNamedPipe returned Error %lx\n", GetLastError() );
                break;
                }

            if ( Size ) {
                printf("Client PeekNamedPipe Done %lx: %s\n", Size, Data);
                break;
                }
            else {
                printf("Client PeekNamedPipe Done, no data yet, sleep 1 sec\n");
                Sleep(1000);
                }
            }

        printf("Client now Reading...\n");
        if ( FALSE == ReadFile(C1,Data, sizeof(Data), &Size, NULL) ) {
            printf("Client ReadFile returned Error %lx\n", GetLastError() );
            }

        printf("Client Reading Done %lx: %s\n", Size, Data);
        }

    {
        DWORD Flags;
        DWORD OutBufferSize;
        DWORD InBufferSize;
        DWORD MaxInstances;

        printf("Client call GetNamedPipeInfo....\n");

        if ( FALSE == GetNamedPipeInfo(C1, &Flags, &OutBufferSize, &InBufferSize, &MaxInstances) ){
            printf("Client GetNamedPipeInfo returned Error %lx\n", GetLastError() );
            }
        else {
            printf("Flags %lx, OutBufferSize %lx, InBufferSize %lx, MaxInstances %lx\n",
                Flags, OutBufferSize, InBufferSize, MaxInstances);
            }
        }

    {
        DWORD State;
        DWORD CurInstances;

        printf("Client call GetNamedPipeHandleState....\n");

        if ( FALSE == GetNamedPipeHandleState(C1, &State, &CurInstances, NULL, NULL, NULL, 0) ){
            printf("Client GetNamedPipeHandleState returned Error %lx\n", GetLastError() );
            }
        else {
            printf("State %lx, CurInstances %lx\n", State, CurInstances );
            }

        }

    printf("Client attempting 10 second WaitNamedPipe- should timeout...\n");

    if ( FALSE == WaitNamedPipe("\\\\.\\Pipe\\cw\\testpipe", 10000, NULL) ) {
            printf("Client WaitNamedPipe returned Error %lx\n", GetLastError() );
            }

    printf("WaitNamedPipe complete\n");

    printf("Client attempting 10 second WaitNamedPipe- should timeout...\n");

    Overlapped.hEvent = CreateEvent(NULL,TRUE,TRUE);

    if ( FALSE == WaitNamedPipe("\\\\.\\Pipe\\cw\\testpipe", 10000, &Overlapped) ) {
            printf("Client WaitNamedPipe returned Error %lx\n", GetLastError() );
            if ( GetLastError() == ERROR_IO_PENDING ) {
                printf("Server got ERROR_IO_PENDING ok,Waiting for pipe\n");
                assert( FALSE == GetOverlappedResult(NULL , &Overlapped, &Dummy, TRUE ));
                printf("Client WaitNamedPipe returned Error Ok %lx\n", GetLastError() );
                }
            }

    printf("WaitNamedPipe complete\nClient closing...\n");
    CloseHandle(C1);
    printf("Client closed\n");

    printf("Client attempting 10 second WaitNamedPipe- should work...\n");

    if ( FALSE == WaitNamedPipe("\\\\.\\Pipe\\cw\\testpipe", 10000, NULL) ) {
            printf("Client WaitNamedPipe returned Error %lx\n", GetLastError() );
            }

    printf("WaitNamedPipeComplete\n");

    for ( Count = 1; Count < 5; Count++ ) {

        printf("Client CallNamedPipe...\n");

        if ( FALSE == CallNamedPipe(
            "\\\\.\\Pipe\\cw\\testpipe",
            WriteData2,
            strlen(WriteData2)+1,
            Data,
            sizeof(Data),
            &Size,
            10000   // Ten second timeout
            ) ) {
            printf("CallNamedPipe returned Error %lx\n", GetLastError() );
            }
        printf("Client CallNamedPipe Done %lx: %s\n", Size, Data);
        }

    printf("CallNamedPipe complete\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\tnpipe.c ===
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>

DWORD Size;
LPSTR WriteData = "Hello World\n";

VOID
ClientThread(
    LPVOID ThreadParameter
    )
{
    DWORD n;
    HANDLE C1;
    LPSTR l;

    printf("Create client...\n");
    C1 = CreateFile("\\\\.\\Pipe\\cw\\testpipe",
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,       // Security Attributes
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            NULL
            );

    if ( C1 == INVALID_HANDLE_VALUE ) {
        DWORD Status;
        printf("CreateFile returned Error %lx\n", Status = GetLastError() );
        }

    printf("Client writing...\n");

    assert( TRUE == WriteFile(C1,WriteData,Size, &n, NULL) );
    assert( n==Size );
    printf("Client done Writing...\n");

    // Get WriteData back from the server
    l = LocalAlloc(LMEM_ZEROINIT,Size);
    assert(l);
    printf("Client reading\n");

    assert( TRUE == ReadFile(C1,l,Size, &n, NULL));

    printf("Client reading Done %s\n",l);
    Sleep(10000);
    printf("Client done Sleeping...\n");
}


int
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    DWORD n;
    LPSTR l;
    HANDLE Thread;
    HANDLE S1,S2,S3;    //  Server handles
    DWORD ThreadId;
    DWORD Dummy;
    OVERLAPPED S1Overlapped;

    S1 = CreateNamedPipe("\\\\.\\Pipe\\cw\\testpipe",
            PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
            PIPE_WAIT | PIPE_READMODE_MESSAGE| PIPE_TYPE_MESSAGE,
            2,
            1024,
            1024,
            0,
            NULL);

    assert(S1 != INVALID_HANDLE_VALUE);

    S2 = CreateNamedPipe("\\\\.\\Pipe\\cw\\testpipe",
            PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
            PIPE_WAIT | PIPE_READMODE_MESSAGE| PIPE_TYPE_MESSAGE,
            992, //IGNORED
            0,   //IGNORED
            0,   //IGNORED
            0,   //IGNORED
            NULL);

    assert(S2 != INVALID_HANDLE_VALUE);

    S3 = CreateNamedPipe("\\\\.\\Pipe\\cw\\testpipe",
            PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
            PIPE_WAIT | PIPE_READMODE_MESSAGE| PIPE_TYPE_MESSAGE,
            992,
            0,
            0,
            0,
            NULL);

    assert( S3 == INVALID_HANDLE_VALUE );   //Should fail - Used all instances

    S1Overlapped.hEvent = NULL;
    assert( FALSE == ConnectNamedPipe( S1, &S1Overlapped ));
    assert( ERROR_IO_PENDING == GetLastError());

    assert( FALSE == GetOverlappedResult( S1, &S1Overlapped, &Dummy, FALSE ));
    assert( ERROR_IO_INCOMPLETE == GetLastError());

    Size = strlen(WriteData)+1;
    l = LocalAlloc(LMEM_ZEROINIT,Size);
    assert(l);

    Thread = CreateThread(NULL,0L,ClientThread,(LPVOID)99,0,&ThreadId);
    assert(Thread);

    printf("Waiting for connection\n");
    assert( TRUE == GetOverlappedResult( S1, &S1Overlapped, &Dummy, TRUE ));

    printf("Connected, Server now Reading\n");
    if ( FALSE == ReadFile(S1,l,Size, &n, &S1Overlapped) ) {
        DWORD Status;
        printf("Server ReadFile returned Error %lx\n", Status = GetLastError() );

        if ( Status == ERROR_IO_PENDING ) {
            printf("Server got ERROR_IO_PENDING ok,Waiting for data\n");
            assert( TRUE == GetOverlappedResult( S1, &S1Overlapped, &Dummy, TRUE ));
            }

        }
    printf("Server Reading Done %s\n",l);

    printf("Server Writing\n");
    if ( FALSE == WriteFile(S1,l,Size, &n, &S1Overlapped) ) {
        DWORD Status;
        printf("Server WriteFile returned Error %lx\n", Status = GetLastError() );

        if ( Status == ERROR_IO_PENDING ) {
            printf("Server got ERROR_IO_PENDING ok,Waiting for transfer complete\n");
            assert( TRUE == GetOverlappedResult( S1, &S1Overlapped, &Dummy, TRUE ));
            }

        }
    printf("Server Writing Done %s\n",l);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\tnpsrv.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tnpsrv.c

Abstract:

    This program creates a single instance of the pipe \cw\testpipe,
    awaits for a connection. While a client wants to talk it will echo
    data back to the client. When the client closes the pipe tnpsrv will
    wait for another client.

Author:

    Colin Watson (ColinW) 19-March-1991

Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>

int
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    HANDLE S1;
    DWORD Size;
    DWORD Dummy;
    CHAR Data[1024];

    S1 = CreateNamedPipe("\\\\.\\Pipe\\cw\\testpipe",
            PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
            PIPE_WAIT | PIPE_READMODE_MESSAGE| PIPE_TYPE_MESSAGE,
            1,  // One instance only
            sizeof(Data),
            sizeof(Data),
            0,
            NULL);

    assert(S1 != INVALID_HANDLE_VALUE);

    while (1) {

        printf("Waiting for connection\n");
        if ( FALSE == ConnectNamedPipe( S1, NULL )) {
            printf("Server ReadFile returned Error %lx\n", GetLastError() );
            break;
            }

        while (1) {

            printf("Server now Reading\n");
            if ( FALSE == ReadFile(S1,Data, sizeof(Data), &Size, NULL) ) {
                printf("Server ReadFile returned Error %lx\n", GetLastError() );
                break;
                }

            printf("Server Reading Done %s\n",Data);

            printf("Server Writing\n");
            if ( FALSE == WriteFile(S1, Data, Size, &Dummy, NULL) ) {
                printf("Server WriteFile returned Error %lx\n", GetLastError() );
                break;
                }

            printf("Server Writing Done\n");
            }

        if ( FALSE == DisconnectNamedPipe( S1 ) ) {
            printf("Server WriteFile returned Error %lx\n", GetLastError() );
            break;
            }
        }

    CloseHandle(S1);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\tprof.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tprof.c

Abstract:

    Win32 Base API Test Program for Profile File Management calls

Author:

    Steve Wood (stevewo) 26-Oct-1990

Revision History:

--*/

#include <stdio.h>
#include <string.h>

#define WIN32_CONSOLE_APP
#include <windows.h>


void
DumpProfile(
    LPTSTR ProfileFileName
    )
{
    LPTSTR Sections, Section;
    LPTSTR Keywords, Keyword;
    LPTSTR KeyValue;

    Sections = LocalAlloc( 0, 4096 * sizeof( *Sections ) );
    Keywords = LocalAlloc( 0, 4096 * sizeof( *Keywords ) );
    KeyValue = LocalAlloc( 0, 1024 * sizeof( *KeyValue ) );

#ifdef UNICODE
    printf( "\nDump of %ws\n",
#else
    printf( "\nDump of %s\n",
#endif
            ProfileFileName ? ProfileFileName : TEXT("win.ini")
          );
    *Sections = TEXT('\0');
    if (!GetPrivateProfileString( NULL, NULL, NULL,
                                  Sections, 4096 * sizeof( *Sections ),
                                  ProfileFileName
                                )
       ) {
        printf( "*** Unable to read - rc == %d\n", GetLastError() );
        }

    Section = Sections;
    while (*Section) {
#ifdef UNICODE
        printf( "[%ws]\n",
#else
        printf( "[%s]\n",
#endif
                Section
              );
        *Keywords = TEXT('\0');
        GetPrivateProfileString( Section, NULL, NULL,
                                 Keywords, 4096 * sizeof( *Keywords ),
                                 ProfileFileName
                               );
        Keyword = Keywords;
        while (*Keyword) {
            GetPrivateProfileString( Section, Keyword, NULL,
                                     KeyValue, 1024 * sizeof( *KeyValue ),
                                     ProfileFileName
                                   );
#ifdef UNICODE
            printf( "    %ws=%ws\n",
#else
            printf( "    %s=%s\n",
#endif
                    Keyword, KeyValue
                  );

            while (*Keyword++) {
                }
            }

        while (*Section++) {
            }
        }

    LocalFree( Sections );
    LocalFree( Keywords );
    LocalFree( KeyValue );

    return;
}

void
DumpSection(
    LPTSTR ProfileFileName,
    LPTSTR SectionName
    )
{
    LPTSTR SectionValue;
    LPTSTR s;

    SectionValue = LocalAlloc( 0, 4096 * sizeof( TCHAR ) );

#ifdef UNICODE
    printf( "\nDump of Section %ws in %ws\n",
#else
    printf( "\nDump of Section %s in %s\n",
#endif
              SectionName,
              ProfileFileName ? ProfileFileName : TEXT("win.ini")
            );

    *SectionValue = TEXT('\0');
    GetPrivateProfileSection( SectionName,
                              SectionValue, 4096 * sizeof( TCHAR ),
                              ProfileFileName
                            );
#ifdef UNICODE
    printf( "[%ws]\n",
#else
    printf( "[%s]\n",
#endif
            SectionName
          );
    s = SectionValue;
    while (*s) {
#ifdef UNICODE
        printf( "    %ws\n", s );
#else
        printf( "    %s\n", s );
#endif

        while (*s++) {
            }
        }

    LocalFree( SectionValue );
    return;
}

#define MAX_SECTIONS 32
#define MAX_KEYWORDS 32

DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    ULONG n;
    int SectionNumber, KeyNumber;
    LPTSTR SectionValue, KeyValue, Keyword;
    TCHAR SectionName[ 32 ], KeyName[ 32 ], KeyValueBuffer[ 32 ], Buffer[ 32 ];
    FILE *fh;

    printf( "TPROF: Entering Test Program\n" );

    SectionValue = LocalAlloc( 0, 4096 * sizeof( TCHAR ) );
    KeyValue = LocalAlloc( 0, 1024 * sizeof( TCHAR ) );

#if 0
    for (SectionNumber=0; SectionNumber<MAX_SECTIONS; SectionNumber++) {
        sprintf( SectionName, "Section%02u", SectionNumber );
        for (KeyNumber=0; KeyNumber<MAX_KEYWORDS; KeyNumber++) {
            sprintf( KeyName, "KeyName%02u", KeyNumber );
            sprintf( KeyValueBuffer, "KeyValue%02u_%02u", SectionNumber, KeyNumber );
            if (!WritePrivateProfileString( SectionName, KeyName, KeyValueBuffer, "foo.ini"  )) {
                fprintf( stderr, "WriteProfileString( test.ini, [%s].%s=%s )  errno == %u\n",
                         SectionName, KeyName, KeyValueBuffer, GetLastError()
                       );
                }

            GetPrivateProfileString( SectionName, KeyName, "bogus", Buffer, sizeof( Buffer ), "foo.ini" );

            if (strcmp( Buffer, KeyValueBuffer )) {
                fprintf( stderr, "Write: %s != %s, errno == %u\n", KeyValueBuffer, Buffer, GetLastError() );
                }
            }
        }

    for (SectionNumber=0; SectionNumber<MAX_SECTIONS; SectionNumber++) {
        sprintf( SectionName, "Section%02u", SectionNumber );
        for (KeyNumber=0; KeyNumber<MAX_KEYWORDS; KeyNumber++) {
            sprintf( KeyName, "KeyName%02u", KeyNumber );
            sprintf( KeyValueBuffer, "KeyValue%02u_%02u", SectionNumber, KeyNumber );

            GetPrivateProfileString( SectionName, KeyName, "bogus", Buffer, sizeof( Buffer ), "foo.ini" );

            if (strcmp( Buffer, KeyValueBuffer )) {
                fprintf( stderr, "Read: %s != %s, errno == %u\n", KeyValueBuffer, Buffer, GetLastError() );
                }
            }
        }

    for (SectionNumber=0; SectionNumber<MAX_SECTIONS; SectionNumber++) {
        sprintf( SectionName, "Section%02u", SectionNumber );
        for (KeyNumber=0; KeyNumber<MAX_KEYWORDS; KeyNumber++) {
            sprintf( KeyName, "KeyName%02u", KeyNumber );
            sprintf( KeyValueBuffer, "KeyValue%02u_%02u", SectionNumber, KeyNumber );

            if (!WritePrivateProfileString( SectionName, KeyName, NULL, "foo.ini"  )) {
                fprintf( stderr, "WriteProfileString( test.ini, [%s].%s (delete) )  errno == %u\n",
                         SectionName, KeyName, GetLastError()
                       );
                }

            GetPrivateProfileString( SectionName, KeyName, "bogus", Buffer, sizeof( Buffer ), "foo.ini" );

            if (strcmp( Buffer, "bogus" )) {
                fprintf( stderr, "Delete: bogus != %s, errno == %u\n", Buffer, GetLastError() );
                }
            }
        }

    exit( 0 );
#endif

    WriteProfileString( TEXT("TESTINI"), TEXT("Key1"), TEXT("100abc") );
    n = GetProfileString( TEXT("ports"), NULL, TEXT(""), SectionValue, 4096 * sizeof( TCHAR ) );
    Keyword = SectionValue;
    printf( "Keywords in win.ini[ports]\n" );
    while (*Keyword) {
#ifdef UNICODE
        printf( "    %ws\n", Keyword );
#else
        printf( "    %s\n", Keyword );
#endif
        while (*Keyword++) {
            }
        }

    n = GetProfileString( TEXT("ports"), NULL, NULL, SectionValue, 4096 );
    Keyword = SectionValue;
    printf( "Keywords in win.ini[ports]\n" );
    while (*Keyword) {
#ifdef UNICODE
        printf( "    %ws\n", Keyword );
#else
        printf( "    %s\n", Keyword );
#endif
        while (*Keyword++) {
            }
        }

    DeleteFile( TEXT("\\nt\\windows\\test.ini") );
    fh = fopen( "\\nt\\windows\\test.ini", "w" );
    fclose( fh );

    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileString( TEXT("StrApp"), TEXT("StrKey"), TEXT("StrVal"), TEXT("test.ini"));
    DumpProfile( TEXT("test.ini") );


    DeleteFile( TEXT("test.ini") );
    fh = fopen( "\\nt\\test.ini", "w" );
    fprintf( fh, "[IncompleteSectionWithoutTrailingBracket\n\n" );
    fprintf( fh, "[StrApp]\n" );
    fprintf( fh, "StrKey=xxxxxx\n" );
    fclose( fh );

    DumpProfile( TEXT("test.ini") );

    if (!WritePrivateProfileString( TEXT("StrApp"), TEXT("StrKey"), TEXT("StrVal"), TEXT("test.ini"))) {
        printf( "*** Write failed - rc == %d\n", GetLastError() );
        }
    else {
        DumpProfile( TEXT("test.ini") );
        }

    DeleteFile( "test.ini" );

    fh = fopen( "\\nt\\windows\\test.ini", "w" );
    fprintf( fh, "[a]\n" );
    fprintf( fh, "a1=b1\n" );
    fprintf( fh, "[b]\n" );
    fprintf( fh, "a2=b2\n" );
    fclose( fh );
    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileSection( TEXT("Section2"),
        TEXT("Keyword21=Value21\0Keyword22=Value22\0Keyword23=Value23\0Keyword24=\0"),
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    n = GetPrivateProfileString( TEXT("a"), TEXT("\0"), TEXT("Default"),
                                 KeyValue, 1024 * sizeof( TCHAR ),
                                 TEXT("test.ini")
                               );
#ifdef UNICODE
    printf( "GetPrivateProfileString( a, \\0, Default ) == %ld '%ws'\n", n, KeyValue );
#else
    printf( "GetPrivateProfileString( a, \\0, Default ) == %ld '%s'\n", n, KeyValue );
#endif

    n = GetPrivateProfileInt( TEXT("a"), TEXT("\0"), 123, TEXT("test.ini") );
    printf( "GetPrivateProfileString( a, \\0, 123 ) == %ld\n", n );

    WritePrivateProfileString( TEXT("a"), NULL, NULL, TEXT("test.ini") );

    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileString( TEXT("TESTINI"), TEXT("Key1"), TEXT("100abc"), TEXT("test.ini") );

    WritePrivateProfileString( TEXT("    TESTINI    "),
        TEXT("    Key1    "),
        TEXT("  Val1   "),
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    printf( "GetProfileInt( 123 ) == %ld\n",
            GetProfileInt( TEXT("AAAAA"), TEXT("XXXXX"), 123 )
          );

    printf( "GetProfileInt( -123 ) == %ld\n",
            GetProfileInt( TEXT("AAAAA"), TEXT("XXXXX"), -123 )
          );

    WritePrivateProfileString( TEXT("TESTINI"),
        TEXT("Key1"),
        NULL,
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileString( TEXT("TESTINI"),
        TEXT("Key2"),
        TEXT("Val2"),
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileString( TEXT("TESTINI"),
        TEXT("Key2"),
        TEXT(""),
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileString( TEXT("TESTINI"),
        TEXT("Key2"),
        NULL,
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileString( TEXT("TESTINI"),
        TEXT("Key3"),
        TEXT("Val3"),
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileString( TEXT("TESTINI"),
        NULL,
        TEXT("Something"),
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileString( TEXT("Section1"),
        TEXT("Keyword11"),
        TEXT("Value11"),
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileSection( TEXT("Section2"),
        TEXT("Keyword21=Value21\0Keyword22=Value22\0Keyword23=Value23\0Keyword24=\0"),
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    WritePrivateProfileString( TEXT("Section1"),
        TEXT("Keyword12"),
        TEXT("Value12"),
        TEXT("test.ini")
        );
    DumpProfile( TEXT("test.ini") );

    n = GetPrivateProfileSection( TEXT("Section1"),
                                  SectionValue, 4096 * sizeof( TCHAR ),
                                  TEXT("test.ini")
                                );
#if 0
    if (n != 36 ||
        strcmp( SectionValue, "Keyword11=Value11" ) ||
        strcmp( SectionValue+18, "Keyword12=Value12" )
       ) {
        printf( "*** test.ini[ Section1 ] is incorrect (Length == %d)\n", n );
        DumpSection( "test.ini", "Section1"  );
        }

    n = GetPrivateProfileString( "Section2", "Keyword25", "Default25",
                                 KeyValue, 1024,
                                 "test.ini"
                               );
    if (n != 9 || strcmp( KeyValue, "Default25" )) {
        printf( "*** test.ini[ Section2 ].Keyword25 is incorrect (Length == %d)\n", n );
        DumpSection( "test.ini", "Section2"  );
        }

    n = GetPrivateProfileString( "Section2", "Keyword24", NULL,
                                 KeyValue, 1024,
                                 "test.ini"
                               );
    if (n || strcmp( KeyValue, "" )) {
        printf( "*** test.ini[ Section2 ].Keyword24 is incorrect (Length == %d)\n", n );
        DumpSection( "test.ini", "Section2"  );
        }

    n = GetPrivateProfileString( "Section2", "Keyword23", NULL,
                                 KeyValue, 1024,
                                 "test.ini"
                               );
    if (n != 7 || strcmp( KeyValue, "Value23" )) {
        printf( "*** test.ini[ Section2 ].Keyword23 is incorrect (Length == %d)\n", n );
        DumpSection( "test.ini", "Section2"  );
        }

    n = GetPrivateProfileString( "Section2", "Keyword22", NULL,
                                 KeyValue, 1024,
                                 "test.ini"
                               );
    if (n != 7 || strcmp( KeyValue, "Value22" )) {
        printf( "*** test.ini[ Section2 ].Keyword22 is incorrect (Length == %d)\n", n );
        DumpSection( "test.ini", "Section2"  );
        }

    n = GetPrivateProfileString( "Section2", "Keyword21", NULL,
                                 KeyValue, 1024,
                                 "test.ini"
                               );
    if (n != 7 || strcmp( KeyValue, "Value21" )) {
        printf( "*** test.ini[ Section2 ].Keyword21 is incorrect (Length == %d)\n", n );
        DumpSection( "test.ini", "Section2"  );
        }

    DumpProfile( "test.ini" );

    printf( "Deleting [Section1]Keyword11\n" );
    WritePrivateProfileString( "Section1",
        "Keyword11",
        NULL,
        "test.ini"
        );
    DumpProfile( "test.ini" );

    printf( "Deleting all keywords in [Section1]\n" );
    WritePrivateProfileSection( "Section1",
        "",
        "test.ini"
        );
    DumpProfile( "test.ini" );

    printf( "Deleting [Section1]\n" );
    WritePrivateProfileString( "Section1",
        NULL,
        NULL,
        "test.ini"
        );
    DumpProfile( "test.ini" );

    printf( "Setting [Section2]Keyword21=\n" );
    WritePrivateProfileString( "Section2",
        "Keyword21",
        "",
        "test.ini"
        );
#endif
    DumpProfile( TEXT("test.ini") );
    DumpProfile( NULL );
    DumpSection( NULL, TEXT("Extensions")  );

    printf( "TPROF: Exiting Test Program\n" );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\trd.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tfile.c

Abstract:

    Test program for Win32 Base File API calls

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <assert.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>
#include <memory.h>

#define xassert ASSERT

typedef struct _aio {
    LIST_ENTRY Links;
    HANDLE ReadHandle;
    HANDLE WriteHandle;
    LPVOID Buffer;
    OVERLAPPED Overlapped;
} AIO, *PAIO;

HANDLE IoReadsDoneEvent;
HANDLE IoWritesDoneEvent;
HANDLE IoWorkerListLock;
HANDLE IoWorkerListSemaphore;
LIST_ENTRY IoRequestList;
ULONG IoCount;
ULONG IoReadCount;
ULONG IoWriteCount;
#define BSIZE 2048


VOID
WriteIoComplete(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
    )
{
    PAIO paio;

    //
    // If an I/O error occured, display the error and then exit
    //

    if ( dwErrorCode ) {
        printf("FATAL I/O Error %ld I/O Context %lx.%lx\n",
            dwErrorCode,
            lpOverlapped,
            lpOverlapped->hEvent
            );
        ExitProcess(dwErrorCode);
        }
    paio = (PAIO)CONTAINING_RECORD(lpOverlapped,AIO,Overlapped);
    if ( InterlockedDecrement(&IoWriteCount) == 0 ) {
        SetEvent(IoWritesDoneEvent);
        }
    LocalFree(paio->Buffer);
    LocalFree(paio);
}

VOID
ReadIoComplete(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
    )
{
    PAIO paio;
    BOOL IoOperationStatus;

    //
    // If an I/O error occured, display the error and then exit
    //

    if ( dwErrorCode ) {
        printf("FATAL I/O Error %ld I/O Context %lx.%lx\n",
            dwErrorCode,
            lpOverlapped,
            lpOverlapped->hEvent
            );
        ExitProcess(dwErrorCode);
        }
    paio = (PAIO)CONTAINING_RECORD(lpOverlapped,AIO,Overlapped);
//printf("%s",paio->Buffer);

    IoOperationStatus = WriteFileEx(
                            paio->WriteHandle,
                            paio->Buffer,
                            dwNumberOfBytesTransfered,
                            &paio->Overlapped,
                            WriteIoComplete
                            );

    //
    // Test to see if I/O was queued successfully
    //

    if ( !IoOperationStatus ) {
        if ( GetLastError() != ERROR_HANDLE_EOF ) {
            printf("FATAL I/O Error %ld\n",
                GetLastError()
                );
            ExitProcess(1);
            }
        }

    if ( InterlockedDecrement(&IoReadCount) == 0 ) {
        SetEvent(IoReadsDoneEvent);
        }
}

VOID
IoWorkerThread(
    PVOID Unused
    )
{
    HANDLE HandleVector[2];
    DWORD CompletionStatus;
    PAIO paio;
    BOOL IoOperationStatus;

    HandleVector[0] = IoWorkerListLock;
    HandleVector[1] = IoWorkerListSemaphore;

    for(;;){

        //
        // Do an alertable wait on the handle vector. Both objects
        // becoming signaled at the same time means there is an
        // I/O request in the queue, and the caller has exclusive
        // access to the queue
        //


        CompletionStatus = WaitForMultipleObjectsEx(
                                2,
                                HandleVector,
                                TRUE,
                                0xffffffff,
                                TRUE
                                );

        //
        // If the wait failed, error out
        //

        if ( CompletionStatus == 0xffffffff ) {
            printf("FATAL WAIT ERROR %ld\n",GetLastError());
            ExitProcess(1);
            }

        //
        // If an I/O completion occured, then wait for another
        // I/O request or I/O completion
        //

        if ( CompletionStatus != WAIT_IO_COMPLETION ) {

            //
            // Wait was satisfied. We now have exclusive ownership of the
            // I/O request queue, and there is something on the queue.
            // Note that to insert something on the queue, the inserter
            // gets the list lock (mutex), inserts an entry, signals the
            // list semaphore, and finally releases the list lock
            //

            paio = (PAIO)RemoveHeadList(&IoRequestList);

            ReleaseMutex(IoWorkerListLock);

            IoOperationStatus = ReadFileEx(
                                    paio->ReadHandle,
                                    paio->Buffer,
                                    paio->Overlapped.Internal,
                                    &paio->Overlapped,
                                    ReadIoComplete
                                    );

            //
            // Test to see if I/O was queued successfully
            //

            if ( !IoOperationStatus ) {
                if ( GetLastError() != ERROR_HANDLE_EOF ) {
                    printf("FATAL I/O Error %ld\n",
                        GetLastError()
                        );
                    ExitProcess(1);
                    }
                }

            //
            // The I/O was successfully queued. Go back into the alertable
            // wait waiting for I/O completion, or for more I/O requests
            //

            }
        }

}

DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    HANDLE iFile,oFile;
    DWORD FileSize;
    PAIO paio;
    DWORD WaitStatus;
    DWORD Offset;
    HANDLE CompletionHandles[2];
    HANDLE Thread;
    DWORD ThreadId;

    if ( argc < 2 ) {
        printf("Usage: trd source-file destination-file\n");
        }

    iFile = CreateFile(
                argv[1],
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_OVERLAPPED,
                NULL
                );
    if ( iFile == INVALID_HANDLE_VALUE ) {
        printf("OPEN %s failed %ld\n",argv[1],GetLastError());
        ExitProcess(1);
        }

    oFile = CreateFile(
                argv[2],
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_FLAG_OVERLAPPED,
                NULL
                );
    if ( oFile == INVALID_HANDLE_VALUE ) {
        printf("OPEN %s failed %ld\n",argv[2],GetLastError());
        ExitProcess(1);
        }

    IoReadsDoneEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    IoWritesDoneEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    IoWorkerListLock = CreateMutex(NULL,FALSE,NULL);;
    IoWorkerListSemaphore = CreateSemaphore(NULL,0,0x7fffffff,NULL);
    xassert(IoReadsDoneEvent);
    xassert(IoWritesDoneEvent);
    xassert(IoWorkerListLock);
    xassert(IoWorkerListSemaphore);
    InitializeListHead(&IoRequestList);

    Thread = CreateThread(NULL,0L,IoWorkerThread,0,0,&ThreadId);
    xassert(Thread);

    Offset = 0;
    FileSize = GetFileSize(iFile,NULL);

    WaitStatus = WaitForSingleObject(IoWorkerListLock,-1);
    xassert(WaitStatus == 0);

    while(FileSize >= BSIZE) {
        FileSize -= BSIZE;
        paio = LocalAlloc(LMEM_ZEROINIT,sizeof(*paio));
        xassert(paio);
        paio->Buffer = LocalAlloc(LMEM_ZEROINIT,BSIZE+1);
        xassert(paio->Buffer);
        paio->ReadHandle = iFile;
        paio->WriteHandle = oFile;
        paio->Overlapped.Internal = BSIZE;
        paio->Overlapped.Offset = Offset;
        Offset += BSIZE;
        IoCount++;
        if ( IoCount & 1 ) {
            InsertTailList(&IoRequestList,&paio->Links);
            }
        else {
            InsertHeadList(&IoRequestList,&paio->Links);
            }
        ReleaseSemaphore(IoWorkerListSemaphore,1,NULL);
        }
    if ( FileSize != 0 ) {
        paio = LocalAlloc(LMEM_ZEROINIT,sizeof(*paio));
        xassert(paio);
        paio->Buffer = LocalAlloc(LMEM_ZEROINIT,FileSize+1);
        xassert(paio->Buffer);
        paio->ReadHandle = iFile;
        paio->WriteHandle = oFile;
	paio->Overlapped.interlockInternal = FileSize;
        paio->Overlapped.Offset = Offset;
        IoCount++;
        if ( IoCount & 1 ) {
            InsertTailList(&IoRequestList,&paio->Links);
            }
        else {
            InsertHeadList(&IoRequestList,&paio->Links);
            }
        ReleaseSemaphore(IoWorkerListSemaphore,1,NULL);
        }
    IoReadCount = IoCount;
    IoWriteCount = IoCount;
    ReleaseMutex(IoWorkerListLock);

    CompletionHandles[0] = IoReadsDoneEvent;
    CompletionHandles[1] = IoWritesDoneEvent;

    WaitStatus = WaitForMultipleObjects(2,CompletionHandles,TRUE,0xffffffff);
    xassert(WaitStatus != 0xffffffff);
    CloseHandle(iFile);
    CloseHandle(oFile);
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\tse.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    tse.c

Abstract:

    This module tests windows security api.

Author:

    Robert Reichel (RobertRe) 01-Jan-92

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <string.h>
#include <stdarg.h>
#include <assert.h>
#include <stdio.h>



#define _TST_USER_      // User mode test

#define BUFFER_SIZE 256



////////////////////////////////////////////////////////////////////////
//                                                                    //
//   Global Variables                                                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////


LUID SystemAuthenticationId = SYSTEM_LUID;

//
// Universal well known SIDs
//

PSID  NullSid;
PSID  WorldSid;
PSID  LocalSid;
PSID  CreatorOwnerSid;

//
// Sids defined by NT
//

PSID NtAuthoritySid;

PSID DialupSid;
PSID NetworkSid;
PSID BatchSid;
PSID InteractiveSid;
PSID LocalSystemSid;



//
//  Well known privilege values
//


LUID SeCreateTokenPrivilege;
LUID SeAssignPrimaryTokenPrivilege;
LUID SeLockMemoryPrivilege;
LUID SeIncreaseQuotaPrivilege;
LUID SeUnsolicitedInputPrivilege;
LUID SeTcbPrivilege;
LUID SeSecurityPrivilege;
LUID SeTakeOwnershipPrivilege;
LUID SeLoadDriverPrivilege;
LUID SeCreatePagefilePrivilege;
LUID SeIncreaseBasePriorityPrivilege;
LUID SeSystemProfilePrivilege;
LUID SeSystemtimePrivilege;
LUID SeProfileSingleProcessPrivilege;
LUID SeCreatePermanentPrivilege;
LUID SeBackupPrivilege;
LUID SeRestorePrivilege;
LUID SeShutdownPrivilege;
LUID SeDebugPrivilege;
LUID SeAuditPrivilege;
LUID SeSystemEnvironmentPrivilege;
LUID SeChangeNotifyPrivilege;
LUID SeRemoteShutdownPrivilege;



////////////////////////////////////////////////////////////////////////
//                                                                    //
//   Internal Prototypes                                              //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
TestLookupSid();

VOID
TestLookupName();

void
TestGetPrivNameW(
    LPWSTR *PrivName,
    PLUID  lpLuid
    );
void
TestGetPrivNameA(
    LPSTR *PrivName,
    PLUID  lpLuid
    );

VOID
TestLookupPrivilegeValue();

void
TestLookupPrivilegeValueW(
    PLUID lpLuid
    );

void
TestLookupPrivilegeValueA(
    PLUID lpLuid
    );

VOID
TestLookupPrivilegeName();

void
TestLookupPrivilegeNameW(
    PLUID lpLuid
    );

void
TestLookupPrivilegeNameA(
    PLUID lpLuid
    );

VOID
TestLookupPrivilegeDisplayName();

void
TestLookupPrivilegeDisplayNameW(
    PLUID lpLuid
    );

void
TestLookupPrivilegeDisplayNameA(
    PLUID lpLuid
    );


void
initialize (void);

void
TestLookupSidW(
    IN PSID Sid
    );

void
TestLookupSidA(
    IN PSID Sid
    );

void
TestLookupNameW(
    LPWSTR Name
    );

void
DumpWCharString(
    PWSTR String
    );

VOID
DisplayAccountSid(
    PSID Sid
    );

VOID
DisplayUse(
    IN SID_NAME_USE  Use
    );

void
initialize (void)
{

    ULONG SidWithZeroSubAuthorities;
    ULONG SidWithOneSubAuthority;
    ULONG SidWithThreeSubAuthorities;
    ULONG SidWithFourSubAuthorities;

    SID_IDENTIFIER_AUTHORITY NullSidAuthority    = SECURITY_NULL_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY LocalSidAuthority   = SECURITY_LOCAL_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;


    //
    //  The following SID sizes need to be allocated
    //

    SidWithZeroSubAuthorities  = GetSidLengthRequired( 0 );
    SidWithOneSubAuthority     = GetSidLengthRequired( 1 );
    SidWithThreeSubAuthorities = GetSidLengthRequired( 3 );
    SidWithFourSubAuthorities  = GetSidLengthRequired( 4 );

    //
    //  Allocate and initialize the universal SIDs
    //

    NullSid         = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0,SidWithOneSubAuthority);
    WorldSid        = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0,SidWithOneSubAuthority);
    LocalSid        = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0,SidWithOneSubAuthority);
    CreatorOwnerSid = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0,SidWithOneSubAuthority);

    InitializeSid( NullSid,    &NullSidAuthority, 1 );
    InitializeSid( WorldSid,   &WorldSidAuthority, 1 );
    InitializeSid( LocalSid,   &LocalSidAuthority, 1 );
    InitializeSid( CreatorOwnerSid, &CreatorSidAuthority, 1 );

    *(GetSidSubAuthority( NullSid, 0 ))         = SECURITY_NULL_RID;
    *(GetSidSubAuthority( WorldSid, 0 ))        = SECURITY_WORLD_RID;
    *(GetSidSubAuthority( LocalSid, 0 ))        = SECURITY_LOCAL_RID;
    *(GetSidSubAuthority( CreatorOwnerSid, 0 )) = SECURITY_CREATOR_OWNER_RID;

    //
    // Allocate and initialize the NT defined SIDs
    //

    NtAuthoritySid  = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0,SidWithZeroSubAuthorities);
    DialupSid       = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0,SidWithOneSubAuthority);
    NetworkSid      = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0,SidWithOneSubAuthority);
    BatchSid        = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0,SidWithOneSubAuthority);
    InteractiveSid  = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0,SidWithOneSubAuthority);
    LocalSystemSid  = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0,SidWithOneSubAuthority);

    InitializeSid( NtAuthoritySid,   &NtAuthority, 0 );
    InitializeSid( DialupSid,        &NtAuthority, 1 );
    InitializeSid( NetworkSid,       &NtAuthority, 1 );
    InitializeSid( BatchSid,         &NtAuthority, 1 );
    InitializeSid( InteractiveSid,   &NtAuthority, 1 );
    InitializeSid( LocalSystemSid,   &NtAuthority, 1 );

    *(GetSidSubAuthority( DialupSid,       0 )) = SECURITY_DIALUP_RID;
    *(GetSidSubAuthority( NetworkSid,      0 )) = SECURITY_NETWORK_RID;
    *(GetSidSubAuthority( BatchSid,        0 )) = SECURITY_BATCH_RID;
    *(GetSidSubAuthority( InteractiveSid,  0 )) = SECURITY_INTERACTIVE_RID;
    *(GetSidSubAuthority( LocalSystemSid,  0 )) = SECURITY_LOCAL_SYSTEM_RID;


    //
    // Initialize the well known privilege values
    //

    SeCreateTokenPrivilege =
        RtlConvertLongToLargeInteger(SE_CREATE_TOKEN_PRIVILEGE);
    SeAssignPrimaryTokenPrivilege =
        RtlConvertLongToLargeInteger(SE_ASSIGNPRIMARYTOKEN_PRIVILEGE);
    SeLockMemoryPrivilege =
        RtlConvertLongToLargeInteger(SE_LOCK_MEMORY_PRIVILEGE);
    SeIncreaseQuotaPrivilege =
        RtlConvertLongToLargeInteger(SE_INCREASE_QUOTA_PRIVILEGE);
    SeUnsolicitedInputPrivilege =
        RtlConvertLongToLargeInteger(SE_UNSOLICITED_INPUT_PRIVILEGE);
    SeTcbPrivilege =
        RtlConvertLongToLargeInteger(SE_TCB_PRIVILEGE);
    SeSecurityPrivilege =
        RtlConvertLongToLargeInteger(SE_SECURITY_PRIVILEGE);
    SeTakeOwnershipPrivilege =
        RtlConvertLongToLargeInteger(SE_TAKE_OWNERSHIP_PRIVILEGE);
    SeLoadDriverPrivilege =
        RtlConvertLongToLargeInteger(SE_LOAD_DRIVER_PRIVILEGE);
    SeCreatePagefilePrivilege =
        RtlConvertLongToLargeInteger(SE_CREATE_PAGEFILE_PRIVILEGE);
    SeIncreaseBasePriorityPrivilege =
        RtlConvertLongToLargeInteger(SE_INC_BASE_PRIORITY_PRIVILEGE);
    SeSystemProfilePrivilege =
        RtlConvertLongToLargeInteger(SE_SYSTEM_PROFILE_PRIVILEGE);
    SeSystemtimePrivilege =
        RtlConvertLongToLargeInteger(SE_SYSTEMTIME_PRIVILEGE);
    SeProfileSingleProcessPrivilege =
        RtlConvertLongToLargeInteger(SE_PROF_SINGLE_PROCESS_PRIVILEGE);
    SeCreatePermanentPrivilege =
        RtlConvertLongToLargeInteger(SE_CREATE_PERMANENT_PRIVILEGE);
    SeBackupPrivilege =
        RtlConvertLongToLargeInteger(SE_BACKUP_PRIVILEGE);
    SeRestorePrivilege =
        RtlConvertLongToLargeInteger(SE_RESTORE_PRIVILEGE);
    SeShutdownPrivilege =
        RtlConvertLongToLargeInteger(SE_SHUTDOWN_PRIVILEGE);
    SeDebugPrivilege =
        RtlConvertLongToLargeInteger(SE_DEBUG_PRIVILEGE);
    SeAuditPrivilege =
        RtlConvertLongToLargeInteger(SE_AUDIT_PRIVILEGE);
    SeSystemEnvironmentPrivilege =
        RtlConvertLongToLargeInteger(SE_SYSTEM_ENVIRONMENT_PRIVILEGE);
    SeChangeNotifyPrivilege =
        RtlConvertLongToLargeInteger(SE_CHANGE_NOTIFY_PRIVILEGE);
    SeRemoteShutdownPrivilege =
        RtlConvertLongToLargeInteger(SE_REMOTE_SHUTDOWN_PRIVILEGE);


}

void
TestLookupSidW(
    IN PSID Sid
    )

{
    //
    // LookupAccountSidW test
    //

    BOOL          Bool;
    DWORD         cbName = 0;
    DWORD         cbReferencedDomainName = 0;
    DWORD         cbSid = 0;
    WCHAR         Name[BUFFER_SIZE];
    SID_NAME_USE  peUse = SidTypeUser;
    WCHAR         ReferencedDomainName[BUFFER_SIZE];


    printf("      LookupW call . . . . . . . . . . . . . . . . . ");

    cbName = 0;
    cbReferencedDomainName = 0;

    Bool = LookupAccountSidW(
               NULL,
               Sid,
               Name,
               &cbName,
               ReferencedDomainName,
               &cbReferencedDomainName,
               &peUse
               );
    //
    // Expect failure here
    //

    if ( !Bool && GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
        printf("** FAILED **\n");
        printf("        First call.\n");
        printf("        Status:             %d\n", GetLastError());
        printf("        Name Length:        %d\n", cbName);
        printf("        Domain Name Length: %d\n", cbReferencedDomainName);
    } else {


        Bool = LookupAccountSidW(
                   NULL,
                   Sid,
                   Name,
                   &cbName,
                   ReferencedDomainName,
                   &cbReferencedDomainName,
                   &peUse
                   );

        if ( !Bool ) {
            printf("** FAILED **\n");
            printf("        Second call.\n");
            printf("        Status:             %d\n", GetLastError());
            printf("        Name Length:        %d\n", cbName);
            printf("        Domain Name Length: %d\n", cbReferencedDomainName);
        } else {
            printf("Succeeded\n");
            printf("        Name Length:        %d\n", cbName);
            printf("        Name:               *");
            DumpWCharString( Name );
            printf("*\n");
            printf("        Domain Name Length: %d\n", cbReferencedDomainName);
            printf("        Domain Name:        *");
            DumpWCharString( ReferencedDomainName );
            printf("*\n");
            printf("        Use:                ");
            DisplayUse( peUse );
            printf("\n\n");
        }
    }
}





void
TestLookupSidA(
    IN PSID Sid
    )
{
    UCHAR Name[BUFFER_SIZE];
    UCHAR ReferencedDomainName[BUFFER_SIZE];
    BOOL  Bool;
    DWORD cbName = 0;
    DWORD cbReferencedDomainName = 0;
    SID_NAME_USE peUse;

    printf("      LookupA call . . . . . . . . . . . . . . . . . ");

    Bool = LookupAccountSidA(
               NULL,
               Sid,
               Name,
               &cbName,
               ReferencedDomainName,
               &cbReferencedDomainName,
               &peUse
               );

    //
    // Expect failure here
    //

    if ( !Bool && GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
        printf("** FAILED **\n");
        printf("        First call.\n");
        printf("        Status:             %d\n", GetLastError());
        printf("        Name Length:        %d\n", cbName);
        printf("        Domain Name Length: %d\n", cbReferencedDomainName);
    } else {


        Bool = LookupAccountSidA(
                   NULL,
                   Sid,
                   Name,
                   &cbName,
                   ReferencedDomainName,
                   &cbReferencedDomainName,
                   &peUse
                   );

        if ( !Bool ) {
            printf("** FAILED **\n");
            printf("        Second call.\n");
            printf("        Status:             %d\n", GetLastError());
            printf("        Name Length:        %d\n", cbName);
            printf("        Domain Name Length: %d\n", cbReferencedDomainName);
        } else {
            printf("Succeeded\n");
            printf("        Name Length:        %d\n", cbName);
            printf("        Name:               *%s*\n",Name);
            printf("        Domain Name Length: %d\n", cbReferencedDomainName);
            printf("        Domain Name:        *%s*\n", ReferencedDomainName );
            printf("        Use:                ");
            DisplayUse( peUse );
            printf("\n\n");
        }
    }

}


void
TestLookupNameW(
    LPWSTR Name
    )

{

    //
    // LookupAccountNameW test
    //

    BOOL          Bool;
    DWORD         cbSid = 0;
    UCHAR         Sid[BUFFER_SIZE];
    SID_NAME_USE  peUse = SidTypeUser;
    DWORD         cbReferencedDomainName = 0;
    WCHAR         ReferencedDomainName[BUFFER_SIZE];


    printf("      LookupW call . . . . . . . . . . . . . . . . . ");


    Bool = LookupAccountNameW(
               NULL,
               Name,
               Sid,
               &cbSid,
               ReferencedDomainName,
               &cbReferencedDomainName,
               &peUse
               );

    //
    // Expect failure here
    //

    if ( !Bool && GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
        printf("** FAILED **\n");
        printf("        First call.\n");
        printf("        Status:             %d\n", GetLastError());
        printf("        Sid  Length:        %d\n", cbSid);
        printf("        Domain Name Length: %d\n", cbReferencedDomainName);
    } else {


        Bool = LookupAccountNameW(
                   NULL,
                   Name,
                   Sid,
                   &cbSid,
                   ReferencedDomainName,
                   &cbReferencedDomainName,
                   &peUse
                   );

        if ( !Bool ) {
            printf("** FAILED **\n");
            printf("        Second call.\n");
            printf("        Status:             %d\n", GetLastError());
            printf("        Sid  Length:        %d\n", cbSid);
            printf("        Domain Name Length: %d\n", cbReferencedDomainName);
        } else {
            printf("Succeeded\n");
            printf("        Sid  Length:        %d\n", cbSid);
            printf("        Sid:                ");
            DisplayAccountSid( Sid );
            printf("\n");
            printf("        Domain Name Length: %d\n", cbReferencedDomainName);
            printf("        Domain Name:        *");
            DumpWCharString( ReferencedDomainName );
            printf("*\n");
            printf("        Use:                ");
            DisplayUse( peUse );
            printf("\n\n");
        }
    }

}


void
TestLookupNameA(
    LPSTR Name
    )

{

    //
    // LookupAccountNameA test
    //

    BOOL          Bool;
    DWORD         cbSid = 0;
    UCHAR         Sid[BUFFER_SIZE];
    SID_NAME_USE  peUse = SidTypeUser;
    DWORD         cbReferencedDomainName = 0;
    UCHAR         ReferencedDomainName[BUFFER_SIZE];


    printf("      LookupA call . . . . . . . . . . . . . . . . . ");


    Bool = LookupAccountNameA(
               NULL,
               Name,
               Sid,
               &cbSid,
               ReferencedDomainName,
               &cbReferencedDomainName,
               &peUse
               );

    //
    // Expect failure here
    //

    if ( !Bool && GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
        printf("** FAILED **\n");
        printf("        First call.\n");
        printf("        Status:             %d\n", GetLastError());
        printf("        Sid  Length:        %d\n", cbSid);
        printf("        Domain Name Length: %d\n", cbReferencedDomainName);
    } else {


        Bool = LookupAccountNameA(
                   NULL,
                   Name,
                   Sid,
                   &cbSid,
                   ReferencedDomainName,
                   &cbReferencedDomainName,
                   &peUse
                   );

        if ( !Bool ) {
            printf("** FAILED **\n");
            printf("        Second call.\n");
            printf("        Status:             %d\n", GetLastError());
            printf("        Sid  Length:        %d\n", cbSid);
            printf("        Domain Name Length: %d\n", cbReferencedDomainName);
        } else {
            printf("Succeeded\n");
            printf("        Sid  Length:        %d\n", cbSid);
            printf("        Sid:                ");
            DisplayAccountSid( Sid );
            printf("\n");
            printf("        Domain Name Length: %d\n", cbReferencedDomainName);
            printf("        Domain Name:        *%s*\n", ReferencedDomainName);
            printf("        Use:                ");
            DisplayUse( peUse );
            printf("\n\n");
        }
    }

}


void
TestLookupPrivilegeDisplayNameW(
    PLUID lpLuid
    )

{

    //
    // LookupPrivilegeDisplayNameW test
    //

    BOOL          Bool;
    DWORD         cbName = 0;
    WCHAR         Name[BUFFER_SIZE];
    DWORD         LanguageId;
    LPWSTR        PrivName;


    printf("      LookupW call . . . . . . . . . . . . . . . . . ");


    TestGetPrivNameW( &PrivName, lpLuid );
    Bool = LookupPrivilegeDisplayNameW(
               NULL,
               PrivName,
               Name,
               &cbName,
               &LanguageId
               );

    //
    // Expect failure here
    //

    if ( !Bool && GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
        printf("** FAILED **\n");
        printf("        First call.\n");
        printf("        Status:             %d\n", GetLastError());
        printf("        Name Length:        %d\n", cbName);
    } else {


        Bool = LookupPrivilegeDisplayNameW(
                   NULL,
                   PrivName,
                   Name,
                   &cbName,
                   &LanguageId
                   );

        if ( !Bool ) {
            printf("** FAILED **\n");
            printf("        Second call.\n");
            printf("        Status:             %d\n", GetLastError());
            printf("        Name Length:        %d\n", cbName);
        } else {
            printf("Succeeded\n");
            printf("        Name Length:        %d\n", cbName);
            printf("        Name:               *");
            DumpWCharString( Name );
            printf("*\n");
            printf("        LanguageID:         %d\n", LanguageId);
            printf("\n\n");
        }
    }

    RtlFreeHeap( RtlProcessHeap(), 0, PrivName );
    return;
}


void
TestLookupPrivilegeDisplayNameA(
    PLUID lpLuid
    )

{

    //
    // LookupPrivilegeDisplayNameA test
    //

    BOOL          Bool;
    DWORD         cbName = 0;
    UCHAR         Name[BUFFER_SIZE];
    DWORD         LanguageId;
    LPSTR         PrivName;


    printf("      LookupA call . . . . . . . . . . . . . . . . . ");


    TestGetPrivNameA( &PrivName, lpLuid );
    Bool = LookupPrivilegeDisplayNameA(
               NULL,
               PrivName,
               Name,
               &cbName,
               &LanguageId
               );

    //
    // Expect failure here
    //

    if ( !Bool && GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
        printf("** FAILED **\n");
        printf("        First call.\n");
        printf("        Status:             %d\n", GetLastError());
        printf("        Name Length:        %d\n", cbName);
    } else {


        Bool = LookupPrivilegeDisplayNameA(
                   NULL,
                   PrivName,
                   Name,
                   &cbName,
               &LanguageId
                   );

        if ( !Bool ) {
            printf("** FAILED **\n");
            printf("        Second call.\n");
            printf("        Status:             %d\n", GetLastError());
            printf("        Name Length:        %d\n", cbName);
        } else {
            printf("Succeeded\n");
            printf("        Name Length:        %d\n", cbName);
            printf("        Name:               *%s*\n", Name);
            printf("        LanguageID:         %d\n", LanguageId);
            printf("\n\n");
        }
    }

    RtlFreeHeap( RtlProcessHeap(), 0, PrivName );
    return;
}


void
TestLookupPrivilegeValueA(
    PLUID lpLuid
    )

{

    //
    // LookupPrivilegeValueA test
    //

    BOOL          Bool;
    LPSTR         PrivName;
    LUID          ReturnedValue;


    TestGetPrivNameA( &PrivName, lpLuid );

    printf("      LookupA call . . . . . . . . . . . . . . . . . ");


    Bool = LookupPrivilegeValueA(
               NULL,
               PrivName,
               &ReturnedValue
               );

    if ( !Bool ) {
        printf("** FAILED **\n");
        printf("        Status:             %d\n", GetLastError());
    } else {

        if (ReturnedValue.LowPart  != lpLuid->LowPart ||
            ReturnedValue.HighPart != lpLuid->HighPart) {
            printf("** FAILED **\n");
            printf("        Value mismatch.\n");
            printf("        Passed Value:    {0x%lx, 0x%lx}\n",
                            lpLuid->HighPart,lpLuid->LowPart);
            printf("        Retrieved Value: {0x%lx, 0x%lx}\n",
                            ReturnedValue.HighPart,ReturnedValue.LowPart);

        } else {
            printf("Succeeded\n");
        }
    }
    printf("\n\n");

    RtlFreeHeap( RtlProcessHeap(), 0, PrivName );
    return;
}

void
TestLookupPrivilegeValueW(
    PLUID lpLuid
    )

{

    //
    // LookupPrivilegeValueW test
    //

    BOOL          Bool;
    LPWSTR        PrivName;
    LUID          ReturnedValue;

    TestGetPrivNameW( &PrivName, lpLuid );

    printf("      LookupW call . . . . . . . . . . . . . . . . . ");


    Bool = LookupPrivilegeValueW(
               NULL,
               PrivName,
               &ReturnedValue
               );

    if ( !Bool ) {
        printf("** FAILED **\n");
        printf("        Status:             %d\n", GetLastError());
    } else {

        if (ReturnedValue.LowPart  != lpLuid->LowPart ||
            ReturnedValue.HighPart != lpLuid->HighPart) {
            printf("** FAILED **\n");
            printf("        Value mismatch.\n");
            printf("        Passed Value:    {0x%lx, 0x%lx}\n",
                            lpLuid->HighPart,lpLuid->LowPart);
            printf("        Retrieved Value: {0x%lx, 0x%lx}\n",
                            ReturnedValue.HighPart,ReturnedValue.LowPart);

        } else {
            printf("Succeeded\n");
        }
    }

    RtlFreeHeap( RtlProcessHeap(), 0, PrivName );
    return;
}


void
TestGetPrivNameW(
    LPWSTR *PrivName,
    PLUID  lpLuid
    )
{


    BOOL          Bool;
    DWORD         cbName = 0;
    PWCHAR        Name = NULL;


    Bool = LookupPrivilegeNameW(
               NULL,
               lpLuid,
               Name,
               &cbName
               );
    ASSERT( !Bool && GetLastError() == ERROR_INSUFFICIENT_BUFFER );

    Name = RtlAllocateHeap( RtlProcessHeap(), 0, (cbName+1)*sizeof(WCHAR) );

    Bool = LookupPrivilegeNameW(
               NULL,
               lpLuid,
               Name,
               &cbName
               );
    ASSERT(Bool);

    (*PrivName) = (LPWSTR)Name;

    return;
}


void
TestGetPrivNameA(
    LPSTR *PrivName,
    PLUID  lpLuid
    )
{


    BOOL          Bool;
    DWORD         cbName = 0;
    PCHAR         Name = NULL;


    Bool = LookupPrivilegeNameA(
               NULL,
               lpLuid,
               Name,
               &cbName
               );
    ASSERT( !Bool && GetLastError() == ERROR_INSUFFICIENT_BUFFER );

    Name = RtlAllocateHeap( RtlProcessHeap(), 0, (cbName+1)*sizeof(CHAR) );

    Bool = LookupPrivilegeNameA(
               NULL,
               lpLuid,
               Name,
               &cbName
               );
    ASSERT(Bool);

    (*PrivName) = (LPSTR)Name;

    return;
}


void
TestLookupPrivilegeNameW(
    PLUID lpLuid
    )

{

    //
    // LookupPrivilegeNameW test
    //

    BOOL          Bool;
    DWORD         cbName = 0;
    WCHAR         Name[BUFFER_SIZE];


    printf("      LookupW call . . . . . . . . . . . . . . . . . ");


    Bool = LookupPrivilegeNameW(
               NULL,
               lpLuid,
               Name,
               &cbName
               );

    //
    // Expect failure here
    //

    if ( !Bool && GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
        printf("** FAILED **\n");
        printf("        First call.\n");
        printf("        Status:             %d\n", GetLastError());
        printf("        Name Length:        %d\n", cbName);
    } else {


        Bool = LookupPrivilegeNameW(
                   NULL,
                   lpLuid,
                   Name,
                   &cbName
                   );

        if ( !Bool ) {
            printf("** FAILED **\n");
            printf("        Second call.\n");
            printf("        Status:             %d\n", GetLastError());
            printf("        Name Length:        %d\n", cbName);
        } else {
            printf("Succeeded\n");
            printf("        Name Length:        %d\n", cbName);
            printf("        Name:               *");
            DumpWCharString( Name );
            printf("*\n");
            printf("\n\n");
        }
    }

    return;
}


void
TestLookupPrivilegeNameA(
    PLUID lpLuid
    )

{

    //
    // LookupPrivilegeNameA test
    //

    BOOL          Bool;
    DWORD         cbName = 0;
    UCHAR         Name[BUFFER_SIZE];


    printf("      LookupA call . . . . . . . . . . . . . . . . . ");


    Bool = LookupPrivilegeNameA(
               NULL,
               lpLuid,
               Name,
               &cbName
               );

    //
    // Expect failure here
    //

    if ( !Bool && GetLastError() != ERROR_INSUFFICIENT_BUFFER ) {
        printf("** FAILED **\n");
        printf("        First call.\n");
        printf("        Status:             %d\n", GetLastError());
        printf("        Name Length:        %d\n", cbName);
    } else {


        Bool = LookupPrivilegeNameA(
                   NULL,
                   lpLuid,
                   Name,
                   &cbName
                   );

        if ( !Bool ) {
            printf("** FAILED **\n");
            printf("        Second call.\n");
            printf("        Status:             %d\n", GetLastError());
            printf("        Name Length:        %d\n", cbName);
        } else {
            printf("Succeeded\n");
            printf("        Name Length:        %d\n", cbName);
            printf("        Name:               *%s*\n", Name);
            printf("\n\n");
        }
    }

}


VOID
DisplayUse(
    IN SID_NAME_USE  Use
    )
{

    switch (Use) {
    case SidTypeUser:
        printf("user");
        break;

    case SidTypeGroup:
        printf("group");
        break;

    case SidTypeDomain:
        printf("domain");
        break;

    case SidTypeAlias:
        printf("alias");
        break;

    case SidTypeWellKnownGroup:
        printf("well known group");
        break;

    case SidTypeDeletedAccount:
        printf("deleted account");
        break;

    case SidTypeInvalid:
        printf("invalid to lsa");
        break;

    case SidTypeUnknown:
        printf("unknown to lsa");
        break;

    default:
        printf("** invalid use value returned **");

    }

}

void
DumpWCharString(
    PWSTR String
    )
{
    UNICODE_STRING Unicode;
    ANSI_STRING AnsiString;

    RtlInitUnicodeString( &Unicode, String );
//    DbgPrint("*%Z*\n",&Unicode);
//    DbgPrint("  Length: %d\n", Unicode.Length);
//    DbgPrint("  Max: %d\n", Unicode.MaximumLength);
    RtlUnicodeStringToAnsiString( &AnsiString, &Unicode, TRUE );
    AnsiString.Buffer[AnsiString.Length]=0; // null terminate it
    printf("%s", AnsiString.Buffer );
    RtlFreeAnsiString( &AnsiString );
    return;
}

VOID
DisplayAccountSid(
    PSID Sid
    )
{
    UCHAR i;
    ULONG Tmp;
    PSID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    UCHAR SubAuthorityCount;

    IdentifierAuthority = RtlIdentifierAuthoritySid(Sid);

    //
    // HACK! HACK!
    // The next line prints the revision of the SID.  Since there is no
    // rtl routine which gives us the SID revision, we must make due.
    // luckily, the revision field is the first field in the SID, so we
    // can just cast the pointer.
    //

    printf("S-%u-", (USHORT) *((PUCHAR) Sid) );

    if (  (IdentifierAuthority->Value[0] != 0)  ||
          (IdentifierAuthority->Value[1] != 0)     ){
        printf("0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    IdentifierAuthority->Value[0],
                    IdentifierAuthority->Value[1],
                    IdentifierAuthority->Value[2],
                    IdentifierAuthority->Value[3],
                    IdentifierAuthority->Value[4],
                    IdentifierAuthority->Value[5] );
    } else {
        Tmp = IdentifierAuthority->Value[5]          +
              (IdentifierAuthority->Value[4] <<  8)  +
              (IdentifierAuthority->Value[3] << 16)  +
              (IdentifierAuthority->Value[2] << 24);
        printf("%lu", Tmp);
    }

    SubAuthorityCount = *RtlSubAuthorityCountSid(Sid);
    for (i=0;i<SubAuthorityCount ;i++ ) {
        printf("-%lu", (*RtlSubAuthoritySid(Sid, i)));
    }
    printf("\n");
}



VOID
TestLookupSid()
{


    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    //       Sid -> Name test                                              //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    printf("\n\n\n");
    printf("  Sid lookup . . . . . . . . . . . . . . . . . . suite\n");

    printf("    Lookup NullSid\n");
    TestLookupSidW( NullSid ); TestLookupSidA( NullSid );

    printf("    Lookup WorldSid\n");
    TestLookupSidW( WorldSid ); TestLookupSidA( WorldSid );

    printf("    Lookup LocalSid\n");
    TestLookupSidW( LocalSid ); TestLookupSidA( LocalSid );

    printf("    Lookup CreatorOwnerSid\n");
    TestLookupSidW( CreatorOwnerSid ); TestLookupSidA( CreatorOwnerSid );

    printf("    Lookup NtAuthoritySid\n");
    TestLookupSidW( NtAuthoritySid ); TestLookupSidA( NtAuthoritySid );

    printf("    Lookup DialupSid\n");
    TestLookupSidW( DialupSid ); TestLookupSidA( DialupSid );

    printf("    Lookup NetworkSid\n");
    TestLookupSidW( NetworkSid ); TestLookupSidA( NetworkSid );

    printf("    Lookup BatchSid\n");
    TestLookupSidW( BatchSid ); TestLookupSidA( BatchSid );

    printf("    Lookup InteractiveSid\n");
    TestLookupSidW( InteractiveSid ); TestLookupSidA( InteractiveSid );

    printf("    Lookup LocalSystemSid\n");
    TestLookupSidW( LocalSystemSid ); TestLookupSidA( LocalSystemSid );

    printf("\n\n\n");
    return;
}


VOID
TestLookupName()
{


    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    //       Name -> Sid test                                              //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    printf("  Name Lookup  . . . . . . . . . . . . . . . . . suite\n");

    printf("    Lookup Null\n");
    TestLookupNameW( L"" ); TestLookupNameA( "" );

    printf("    Lookup World\n");
    TestLookupNameW( L"World" ); TestLookupNameA( "World" );

    printf("    Lookup Local\n");
    TestLookupNameW( L"Local" ); TestLookupNameA( "Local" );

    printf("    Lookup CreatorOwner\n");
    TestLookupNameW( L"CreatorOwner" ); TestLookupNameA( "CreatorOwner" );

    printf("    Lookup NtAuthority\n");
    TestLookupNameW( L"NtAuthority" ); TestLookupNameA( "NtAuthority" );

    printf("    Lookup DialupName\n");
    TestLookupNameW( L"DialupName" ); TestLookupNameA( "DialupName" );

    printf("    Lookup Network\n");
    TestLookupNameW( L"Network" ); TestLookupNameA( "Network" );

    printf("    Lookup Batch\n");
    TestLookupNameW( L"Batch" ); TestLookupNameA( "Batch" );

    printf("    Lookup Interactive\n");
    TestLookupNameW( L"Interactive" ); TestLookupNameA( "Interactive" );

    printf("    Look up LocalSystem\n");
    TestLookupNameW( L"LocalSystem" ); TestLookupNameA( "LocalSystem" );

    printf("\n\n\n");
    return;

}

VOID
TestLookupPrivilegeValue()
{

    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    //       LookupPrivilegeValue Tests                                    //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    printf("\n\n\n");
    printf("  Privilege Value Lookup . . . . . . . . . . . . suite\n");

    printf("    Lookup SeCreateTokenPrivilege\n");
    TestLookupPrivilegeValueW( &SeCreateTokenPrivilege );
    TestLookupPrivilegeValueA( &SeCreateTokenPrivilege );

    printf("    Lookup SeAssignPrimaryTokenPrivilege\n");
    TestLookupPrivilegeValueW( &SeAssignPrimaryTokenPrivilege );
    TestLookupPrivilegeValueA( &SeAssignPrimaryTokenPrivilege );

    printf("    Lookup SeLockMemoryPrivilege\n");
    TestLookupPrivilegeValueW( &SeLockMemoryPrivilege );
    TestLookupPrivilegeValueA( &SeLockMemoryPrivilege );

    printf("    Lookup SeIncreaseQuotaPrivilege\n");
    TestLookupPrivilegeValueW( &SeIncreaseQuotaPrivilege );
    TestLookupPrivilegeValueA( &SeIncreaseQuotaPrivilege );

    printf("    Lookup SeUnsolicitedInputPrivilege\n");
    TestLookupPrivilegeValueW( &SeUnsolicitedInputPrivilege );
    TestLookupPrivilegeValueA( &SeUnsolicitedInputPrivilege );

    printf("    Lookup SeTcbPrivilege\n");
    TestLookupPrivilegeValueW( &SeTcbPrivilege );
    TestLookupPrivilegeValueA( &SeTcbPrivilege );

    printf("    Lookup SeSecurityPrivilege\n");
    TestLookupPrivilegeValueW( &SeSecurityPrivilege );
    TestLookupPrivilegeValueA( &SeSecurityPrivilege );

    printf("    Lookup SeTakeOwnershipPrivilege\n");
    TestLookupPrivilegeValueW( &SeTakeOwnershipPrivilege );
    TestLookupPrivilegeValueA( &SeTakeOwnershipPrivilege );

    printf("    Lookup SeLoadDriverPrivilege\n");
    TestLookupPrivilegeValueW( &SeLoadDriverPrivilege );
    TestLookupPrivilegeValueA( &SeLoadDriverPrivilege );

    printf("    Lookup SeCreatePagefilePrivilege\n");
    TestLookupPrivilegeValueW( &SeCreatePagefilePrivilege );
    TestLookupPrivilegeValueA( &SeCreatePagefilePrivilege );

    printf("    Lookup SeIncreaseBasePriorityPrivilege\n");
    TestLookupPrivilegeValueW( &SeIncreaseBasePriorityPrivilege );
    TestLookupPrivilegeValueA( &SeIncreaseBasePriorityPrivilege );

    printf("    Lookup SeSystemProfilePrivilege\n");
    TestLookupPrivilegeValueW( &SeSystemProfilePrivilege );
    TestLookupPrivilegeValueA( &SeSystemProfilePrivilege );

    printf("    Lookup SeSystemtimePrivilege\n");
    TestLookupPrivilegeValueW( &SeSystemtimePrivilege );
    TestLookupPrivilegeValueA( &SeSystemtimePrivilege );

    printf("    Lookup SeProfileSingleProcessPrivilege\n");
    TestLookupPrivilegeValueW( &SeProfileSingleProcessPrivilege );
    TestLookupPrivilegeValueA( &SeProfileSingleProcessPrivilege );

    printf("    Lookup SeCreatePermanentPrivilege\n");
    TestLookupPrivilegeValueW( &SeCreatePermanentPrivilege );
    TestLookupPrivilegeValueA( &SeCreatePermanentPrivilege );

    printf("    Lookup SeBackupPrivilege\n");
    TestLookupPrivilegeValueW( &SeBackupPrivilege );
    TestLookupPrivilegeValueA( &SeBackupPrivilege );

    printf("    Lookup SeRestorePrivilege\n");
    TestLookupPrivilegeValueW( &SeRestorePrivilege );
    TestLookupPrivilegeValueA( &SeRestorePrivilege );

    printf("    Lookup SeShutdownPrivilege\n");
    TestLookupPrivilegeValueW( &SeShutdownPrivilege );
    TestLookupPrivilegeValueA( &SeShutdownPrivilege );

    printf("    Lookup SeDebugPrivilege\n");
    TestLookupPrivilegeValueW( &SeDebugPrivilege );
    TestLookupPrivilegeValueA( &SeDebugPrivilege );

    printf("    Lookup SeAuditPrivilege\n");
    TestLookupPrivilegeValueW( &SeAuditPrivilege );
    TestLookupPrivilegeValueA( &SeAuditPrivilege );

    printf("    Lookup SeSystemEnvironmentPrivilege\n");
    TestLookupPrivilegeValueW( &SeSystemEnvironmentPrivilege );
    TestLookupPrivilegeValueA( &SeSystemEnvironmentPrivilege );

    printf("    Lookup SeChangeNotifyPrivilege\n");
    TestLookupPrivilegeValueW( &SeChangeNotifyPrivilege );
    TestLookupPrivilegeValueA( &SeChangeNotifyPrivilege );

    printf("    Lookup SeRemoteShutdownPrivilege\n");
    TestLookupPrivilegeValueW( &SeRemoteShutdownPrivilege );
    TestLookupPrivilegeValueA( &SeRemoteShutdownPrivilege );

    printf("\n\n\n");
    return;
}

VOID
TestLookupPrivilegeName()
{
    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    //       LookupPrivilegeName  Tests                                    //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    printf("\n\n\n");
    printf("  Privilege Name Lookup  . . . . . . . . . . . . suite\n");


    printf("    Lookup SeCreateTokenPrivilege\n");
    TestLookupPrivilegeNameW( &SeCreateTokenPrivilege );
    TestLookupPrivilegeNameA( &SeCreateTokenPrivilege );

    printf("    Lookup SeAssignPrimaryTokenPrivilege\n");
    TestLookupPrivilegeNameW( &SeAssignPrimaryTokenPrivilege );
    TestLookupPrivilegeNameA( &SeAssignPrimaryTokenPrivilege );

    printf("    Lookup SeLockMemoryPrivilege\n");
    TestLookupPrivilegeNameW( &SeLockMemoryPrivilege );
    TestLookupPrivilegeNameA( &SeLockMemoryPrivilege );

    printf("    Lookup SeIncreaseQuotaPrivilege\n");
    TestLookupPrivilegeNameW( &SeIncreaseQuotaPrivilege );
    TestLookupPrivilegeNameA( &SeIncreaseQuotaPrivilege );

    printf("    Lookup SeUnsolicitedInputPrivilege\n");
    TestLookupPrivilegeNameW( &SeUnsolicitedInputPrivilege );
    TestLookupPrivilegeNameA( &SeUnsolicitedInputPrivilege );

    printf("    Lookup SeTcbPrivilege\n");
    TestLookupPrivilegeNameW( &SeTcbPrivilege );
    TestLookupPrivilegeNameA( &SeTcbPrivilege );

    printf("    Lookup SeSecurityPrivilege\n");
    TestLookupPrivilegeNameW( &SeSecurityPrivilege );
    TestLookupPrivilegeNameA( &SeSecurityPrivilege );

    printf("    Lookup SeTakeOwnershipPrivilege\n");
    TestLookupPrivilegeNameW( &SeTakeOwnershipPrivilege );
    TestLookupPrivilegeNameA( &SeTakeOwnershipPrivilege );

    printf("    Lookup SeLoadDriverPrivilege\n");
    TestLookupPrivilegeNameW( &SeLoadDriverPrivilege );
    TestLookupPrivilegeNameA( &SeLoadDriverPrivilege );


    printf("    Lookup SeCreatePagefilePrivilege\n");
    TestLookupPrivilegeNameW( &SeCreatePagefilePrivilege );
    TestLookupPrivilegeNameA( &SeCreatePagefilePrivilege );

    printf("    Lookup SeIncreaseBasePriorityPrivilege\n");
    TestLookupPrivilegeNameW( &SeIncreaseBasePriorityPrivilege );
    TestLookupPrivilegeNameA( &SeIncreaseBasePriorityPrivilege );

    printf("    Lookup SeSystemProfilePrivilege\n");
    TestLookupPrivilegeNameW( &SeSystemProfilePrivilege );
    TestLookupPrivilegeNameA( &SeSystemProfilePrivilege );

    printf("    Lookup SeSystemtimePrivilege\n");
    TestLookupPrivilegeNameW( &SeSystemtimePrivilege );
    TestLookupPrivilegeNameA( &SeSystemtimePrivilege );

    printf("    Lookup SeProfileSingleProcessPrivilege\n");
    TestLookupPrivilegeNameW( &SeProfileSingleProcessPrivilege );
    TestLookupPrivilegeNameA( &SeProfileSingleProcessPrivilege );

    printf("    Lookup SeCreatePermanentPrivilege\n");
    TestLookupPrivilegeNameW( &SeCreatePermanentPrivilege );
    TestLookupPrivilegeNameA( &SeCreatePermanentPrivilege );

    printf("    Lookup SeBackupPrivilege\n");
    TestLookupPrivilegeNameW( &SeBackupPrivilege );
    TestLookupPrivilegeNameA( &SeBackupPrivilege );

    printf("    Lookup SeRestorePrivilege\n");
    TestLookupPrivilegeNameW( &SeRestorePrivilege );
    TestLookupPrivilegeNameA( &SeRestorePrivilege );

    printf("    Lookup SeShutdownPrivilege\n");
    TestLookupPrivilegeNameW( &SeShutdownPrivilege );
    TestLookupPrivilegeNameA( &SeShutdownPrivilege );

    printf("    Lookup SeDebugPrivilege\n");
    TestLookupPrivilegeNameW( &SeDebugPrivilege );
    TestLookupPrivilegeNameA( &SeDebugPrivilege );

    printf("    Lookup SeAuditPrivilege\n");
    TestLookupPrivilegeNameW( &SeAuditPrivilege );
    TestLookupPrivilegeNameA( &SeAuditPrivilege );

    printf("    Lookup SeSystemEnvironmentPrivilege\n");
    TestLookupPrivilegeNameW( &SeSystemEnvironmentPrivilege );
    TestLookupPrivilegeNameA( &SeSystemEnvironmentPrivilege );

    printf("    Lookup SeChangeNotifyPrivilege\n");
    TestLookupPrivilegeNameW( &SeChangeNotifyPrivilege );
    TestLookupPrivilegeNameA( &SeChangeNotifyPrivilege );

    printf("    Lookup SeRemoteShutdownPrivilege\n");
    TestLookupPrivilegeNameW( &SeRemoteShutdownPrivilege );
    TestLookupPrivilegeNameA( &SeRemoteShutdownPrivilege );

    printf("\n\n\n");
    return;
}

VOID
TestLookupPrivilegeDisplayName()
{
    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    //       LookupPrivilegeDisplayName Tests                              //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    printf("  Privilege Display Name Lookup  . . . . . . . . suite\n");


    printf("    Lookup SeCreateTokenPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeCreateTokenPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeCreateTokenPrivilege );

    printf("    Lookup SeAssignPrimaryTokenPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeAssignPrimaryTokenPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeAssignPrimaryTokenPrivilege );

    printf("    Lookup SeLockMemoryPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeLockMemoryPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeLockMemoryPrivilege );

    printf("    Lookup SeIncreaseQuotaPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeIncreaseQuotaPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeIncreaseQuotaPrivilege );

    printf("    Lookup SeUnsolicitedInputPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeUnsolicitedInputPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeUnsolicitedInputPrivilege );

    printf("    Lookup SeTcbPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeTcbPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeTcbPrivilege );

    printf("    Lookup SeSecurityPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeSecurityPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeSecurityPrivilege );

    printf("    Lookup SeTakeOwnershipPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeTakeOwnershipPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeTakeOwnershipPrivilege );

    printf("    Lookup SeLoadDriverPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeLoadDriverPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeLoadDriverPrivilege );

    printf("    Lookup SeCreatePagefilePrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeCreatePagefilePrivilege );
    TestLookupPrivilegeDisplayNameA( &SeCreatePagefilePrivilege );

    printf("    Lookup SeIncreaseBasePriorityPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeIncreaseBasePriorityPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeIncreaseBasePriorityPrivilege );

    printf("    Lookup SeSystemProfilePrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeSystemProfilePrivilege );
    TestLookupPrivilegeDisplayNameA( &SeSystemProfilePrivilege );

    printf("    Lookup SeSystemtimePrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeSystemtimePrivilege );
    TestLookupPrivilegeDisplayNameA( &SeSystemtimePrivilege );

    printf("    Lookup SeProfileSingleProcessPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeProfileSingleProcessPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeProfileSingleProcessPrivilege );

    printf("    Lookup SeCreatePermanentPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeCreatePermanentPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeCreatePermanentPrivilege );

    printf("    Lookup SeBackupPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeBackupPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeBackupPrivilege );

    printf("    Lookup SeRestorePrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeRestorePrivilege );
    TestLookupPrivilegeDisplayNameA( &SeRestorePrivilege );

    printf("    Lookup SeShutdownPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeShutdownPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeShutdownPrivilege );

    printf("    Lookup SeDebugPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeDebugPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeDebugPrivilege );

    printf("    Lookup SeAuditPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeAuditPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeAuditPrivilege );

    printf("    Lookup SeSystemEnvironmentPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeSystemEnvironmentPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeSystemEnvironmentPrivilege );

    printf("    Lookup SeChangeNotifyPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeChangeNotifyPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeChangeNotifyPrivilege );

    printf("    Lookup SeRemoteShutdownPrivilege\n");
    TestLookupPrivilegeDisplayNameW( &SeRemoteShutdownPrivilege );
    TestLookupPrivilegeDisplayNameA( &SeRemoteShutdownPrivilege );

    printf("\n\n\n");
    return;
}

int
main (void)
{

    initialize();

    TestLookupSid();

    TestLookupName();


    TestLookupPrivilegeName();

    TestLookupPrivilegeValue();

    TestLookupPrivilegeDisplayName();


    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\ttask.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ttask.c

Abstract:

    Test program for Win32 Base File API calls

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include <assert.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>

typedef struct _CMDSHOW {
    WORD wMustBe2;
    WORD wShowWindowValue;
} CMDSHOW, *PCMDSHOW;

typedef struct _LOAD_MODULE_PARAMS {
    LPSTR lpEnvAddress;
    LPSTR lpCmdLine;
    PCMDSHOW lpCmdShow;
    DWORD dwReserved;
} LOAD_MODULE_PARAMS, *PLOAD_MODULE_PARAMS;

HANDLE Event1, Event2;

VOID
WaitTestThread(
    LPVOID ThreadParameter
    )
{
    DWORD st;
    printf("In Test Thread... Parameter %ld\n",ThreadParameter);

    assert(SetEvent(Event1));

    st = WaitForSingleObject(Event2,-1);
    assert(st == 0);

    printf("Test Thread Exiting... Parameter %ld\n",ThreadParameter);

    ExitThread((DWORD)ThreadParameter);
}

VOID
TestThread(
    LPVOID ThreadParameter
    )
{
    LPSTR s;
    SYSTEMTIME DateAndTime;
    CHAR ImageName[256];
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;

    printf("In Test Thread... Parameter %ld\n",ThreadParameter);
    GetSystemTime(&DateAndTime);
    printf("%d/%d/%d @ %d:%d.%d\n",
        DateAndTime.wMonth,
        DateAndTime.wDay,
        DateAndTime.wYear,
        DateAndTime.wHour,
        DateAndTime.wMinute,
        DateAndTime.wSecond
        );

    DateAndTime.wMonth = 3;
    DateAndTime.wDay = 23;
    DateAndTime.wYear = 1961;
    DateAndTime.wHour = 7;
    DateAndTime.wMinute = 31;
    DateAndTime.wSecond = 0;

#if 0
    assert(SetSystemTime(&DateAndTime));
    GetSystemTime(&DateAndTime);

    assert(DateAndTime.wMonth == 3);
    assert(DateAndTime.wDay == 23);
    assert(DateAndTime.wYear == 1961);
    assert(DateAndTime.wHour == 7);

    DateAndTime.wMonth = 13;
    assert(!SetSystemTime(&DateAndTime));

    printf("%s\n",GetCommandLine());

    assert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_HIGHEST));
    assert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_HIGHEST);
    assert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_LOWEST));
    assert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_LOWEST);
    assert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_ABOVE_NORMAL));
    assert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_ABOVE_NORMAL);
    assert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_BELOW_NORMAL));
    assert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_BELOW_NORMAL);
    assert(SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL));
    assert(GetThreadPriority(GetCurrentThread()) == THREAD_PRIORITY_NORMAL);
    assert(!SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_HIGHEST+1));
    assert(GetThreadPriority(GetCurrentProcess()) == THREAD_PRIORITY_ERROR_RETURN);

    assert(GetModuleFileName(0,ImageName,256) < 255);

    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.lpReserved = "UsedByShell";
    StartupInfo.lpDesktop = "MarksDesktop";
    StartupInfo.lpTitle = "MarksTestTitle";
    StartupInfo.dwX = 0;
    StartupInfo.dwY = 1;
    StartupInfo.dwXSize = 10;
    StartupInfo.dwYSize = 10;
    StartupInfo.dwFlags = 0;//STARTF_SHELLOVERRIDE;
    StartupInfo.wShowWindow = 0;//SW_SHOWDEFAULT;
    StartupInfo.lpReserved2 = 0;
    StartupInfo.cbReserved2 = 0;

    assert( CreateProcess(
                NULL,
                "ttask +",
                NULL,
                NULL,
                TRUE,
                0,
                NULL,
                NULL,
                &StartupInfo,
                &ProcessInformation
                ) );
    WaitForSingleObject(ProcessInformation.hProcess,-1);
#endif
    ExitThread((DWORD)ThreadParameter);
}


DWORD
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{

    CRITICAL_SECTION Crit;
    HANDLE Event, Semaphore, Mutex, Thread, Process;
    HANDLE NEvent, NSemaphore, NMutex;
    HANDLE OEvent, OSemaphore, OMutex;
    DWORD st;
    DWORD ThreadId;
    CHAR ImageName[256];
    CHAR CommandLine[256];
    CHAR Environment[256];
    CMDSHOW cs;
    LOAD_MODULE_PARAMS lmp;
    LPSTR *s;
    int i;
    DWORD psp;

    (VOID)envp;

    try {
        RaiseException(4,0,0,NULL);
        }
    except(EXCEPTION_EXECUTE_HANDLER){
        printf("In Handler %lx\n",GetExceptionCode());
    }

    i = 0;
    s = argv;
    while(i < argc) {
        printf("argv[%ld] %s\n",i,*s);
        i++;
        s++;
        }
#if 0
    printf("TTASK CommandLine %s\n",GetCommandLine());
    if ( strchr(GetCommandLine(),'+') ) {
        printf("TTASK CommandLine %s\n",GetCommandLine());
        return 1;
        }
    Process=OpenProcess(PROCESS_ALL_ACCESS,FALSE,GetCurrentProcessId());
    assert(Process);
    assert(GetModuleFileName(0,ImageName,256) < 255);
    assert(GetModuleFileName(0,CommandLine,256) < 255);
    strcat(CommandLine," -- + --");

    assert(WinExec(CommandLine,0) == 32);

    lmp.lpEnvAddress = Environment;
    lmp.lpCmdLine = CommandLine;
    lmp.dwReserved = 0;
    lmp.lpCmdShow = &cs;
    cs.wMustBe2 = 2;
    cs.wShowWindowValue = 3;

    RtlFillMemory(Environment,256,'\0');
    strcpy(Environment,"PATH=C:\\FOOBAR;C:\\NT\\DLL");
    strcpy(&Environment[strlen("PATH=C:\\FOOBAR;C:\\NT\\DLL")+1],"XYZZY=X");

    assert(LoadModule(ImageName,&lmp) == 32);
#endif
    InitializeCriticalSection(&Crit);
    Event = CreateEvent(NULL,TRUE,TRUE,NULL);
    Semaphore = CreateSemaphore(NULL,1,256,NULL);
    Mutex = CreateMutex(NULL,FALSE,NULL);

    assert(Event);
    assert(Semaphore);
    assert(Mutex);

    NEvent = CreateEvent(NULL,TRUE,TRUE,"named-event");
    NSemaphore = CreateSemaphore(NULL,1,256,"named-semaphore");
    NMutex = CreateMutex(NULL,FALSE,"named-mutex");

    assert(NEvent);
    assert(NSemaphore);
    assert(NMutex);

    OEvent = OpenEvent(EVENT_ALL_ACCESS,FALSE,"named-event");
    OSemaphore = OpenSemaphore(SEMAPHORE_ALL_ACCESS,FALSE,"named-semaphore");
    OMutex = OpenMutex(MUTEX_ALL_ACCESS,FALSE,"named-mutex");

    assert(OEvent);
    assert(OSemaphore);
    assert(OMutex);

    EnterCriticalSection(&Crit);
    LeaveCriticalSection(&Crit);

    st = WaitForSingleObject(Event,-1);
    assert(st == 0);

    st = WaitForSingleObject(Semaphore,-1);
    assert(st == 0);

    st = WaitForSingleObject(Semaphore,0);
    assert(st == WAIT_TIMEOUT);

    assert(ReleaseSemaphore(Semaphore,1,NULL));

    st = WaitForSingleObject(Mutex,-1);
    assert(st == 0);

    assert(ReleaseMutex(Mutex));

    st = WaitForSingleObject(OEvent,-1);
    assert(st == 0);

    st = WaitForSingleObject(OSemaphore,-1);
    assert(st == 0);

    st = WaitForSingleObject(NSemaphore,0);
    assert(st == WAIT_TIMEOUT);

    assert(ReleaseSemaphore(NSemaphore,1,NULL));

    st = WaitForSingleObject(OMutex,-1);
    assert(st == 0);

    assert(ReleaseMutex(NMutex));

    Thread = CreateThread(NULL,0L,TestThread,(LPVOID)99,0,&ThreadId);
    assert(Thread);

    st = WaitForSingleObject(Thread,-1);
    assert(st == 0);

    assert(GetExitCodeThread(Thread,&st));
    assert(st = 99);

    CloseHandle(Thread);

    Event1 = CreateEvent(NULL,TRUE,FALSE,NULL);
    Event2 = CreateEvent(NULL,TRUE,FALSE,NULL);

    Thread = CreateThread(NULL,0L,WaitTestThread,(LPVOID)99,0,&ThreadId);
    assert(Thread);

    st = WaitForSingleObject(Event1,-1);
    assert(st == 0);

    //
    // thread should now be waiting on event2
    //

    psp = SuspendThread(Thread);
    assert(psp==0);

    assert(SetEvent(Event2));

    psp = SuspendThread(Thread);
    assert(psp==1);

    psp = ResumeThread(Thread);
    assert(psp==2);

    psp = ResumeThread(Thread);
    assert(psp==1);

    st = WaitForSingleObject(Thread,-1);
    assert(st == 0);

    assert(GetExitCodeThread(Thread,&st));
    assert(st = 99);

    CloseHandle(Thread);

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\toolhelp.c ===
/*++

 Copyright (c) 1996 Microsoft Corporation

Module Name:

    tlhelp32.c

Abstract:

    NT implementation of win95 ToolHelp API's

Author:

    John Daly

Environment:

    NT Only

Notes:

    Version 1.0
    structure definitions/documentation in tlhelp32.h


Revision History:

    John Daly (johndaly) 5-Apr-1996
        initial implementation

--*/

#include "basedll.h"
#pragma hdrstop

#include "tlhelp32.h"

#define BUFFER_SIZE 64*1024
#define ARRAYSIZE(x)        (sizeof(x) / sizeof(x[0]))

/*
 snapshot structure

 This is mapped onto the beginning of the memory we use to hold the information.

*/
typedef struct tagSNAPSHOTSTATE {
    /* item list counts */
    ULONG    HeapListCount;
    ULONG    ProcessCount;
    ULONG    ModuleCount;
    ULONG    ThreadCount;
    /* item list head pointers */
    PHEAPLIST32         HeapListHead;
    PPROCESSENTRY32W    ProcessListHead;
    PMODULEENTRY32W     ModuleListHead;
    PTHREADENTRY32      ThreadListHead;
    /* item list current indexes */
    ULONG   HeapListIndex;
    ULONG   ProcessListIndex;
    ULONG   ModuleListIndex;
    ULONG   ThreadListIndex;
    /* data begins here... */
    UCHAR    DataBegin;
}SNAPSHOTSTATE;
typedef SNAPSHOTSTATE * PSNAPSHOTSTATE;


//
// private functions
//

NTSTATUS
ThpCreateRawSnap(
    IN ULONG dwFlags,
    IN ULONG th32ProcessID,
    PUCHAR *RawProcess,
    PRTL_DEBUG_INFORMATION *RawModule,
    PRTL_DEBUG_INFORMATION *RawDebugInfo);

NTSTATUS
ThpAllocateSnapshotSection(
    OUT PHANDLE SnapSection,
    IN DWORD dwFlags,
    IN DWORD th32ProcessID,
    PUCHAR RawProcess,
    PRTL_DEBUG_INFORMATION RawModule,
    PRTL_DEBUG_INFORMATION RawDebugInfo);

NTSTATUS
ThpProcessToSnap(
    IN DWORD dwFlags,
    IN DWORD th32ProcessID,
    IN HANDLE SnapSection,
    PUCHAR RawProcess,
    PRTL_DEBUG_INFORMATION RawModule,
    PRTL_DEBUG_INFORMATION RawDebugInfo);

HANDLE
WINAPI
CreateToolhelp32Snapshot(
    IN DWORD dwFlags,
    IN DWORD th32ProcessID)
/*++

Routine Description:

    Takes a snapshot of the Win32 processes, heaps, modules, and threads used
    by the Win32 processes. Returns an open handle to the specified snapshot if
    successful or  -1 otherwise.

    NOTE that all of the snapshots are global except for the heap and module
    lists which are process specific. To enumerate the heap or module state for
    all WIN32 processes call with TH32CS_SNAPALL and the current process. Then
    for each process in the TH32CS_SNAPPROCESS list that isn't the current
    process, do a call with just TH32CS_SNAPHEAPLIST and/or TH32CS_SNAPMODULE.

    Use CloseHandle to destroy the snapshot

    This function is not multi-thread safe.  All of the other functions are.

Arguments:

    dwFlags - Supplies switches to specify action as follows:
        TH32CS_INHERIT  Indicates that the snapshot handle is to be inheritable.
        TH32CS_SNAPALL  Equivalent to specifying the TH32CS_SNAPHEAPLIST,
                        TH32CS_SNAPMODULE, TH32CS_SNAPPROCESS, and
                        TH32CS_SNAPTHREAD values.
        TH32CS_SNAPHEAPLIST     Includes the heap list of the specified Win32
                                process in the snapshot.
        TH32CS_SNAPMODULE       Includes the module list of the specified Win32
                                process in the snapshot.
        TH32CS_SNAPPROCESS      Includes the Win32 process list in the snapshot.
        TH32CS_SNAPTHREAD       Includes the Win32 thread list in the snapshot.

    th32ProcessID - Supplies a Win32 process identifier. This parameter can be
        zero to indicate the current process. This parameter is used when the
        TH32CS_SNAPHEAPLIST or TH32CS_SNAPMODULE value is specified. Otherwise,
        it is ignored. The snapshot taken by this function is examined by the
        other tool help functions to provide their results.  Access to the
        snapshot is read only. The snapshot handle acts like a Win32 object
        handle and is subject to the same rules regarding which processes and
        threads it is valid in.

Return Value:

    Returns an open handle to the specified snapshot if successful or -1 if not.
    To retrieve an extended error status code generated by this function, use
    the GetLastError function.
    To destroy the snapshot, use the CloseHandle function.

--*/
{
    HANDLE SnapSection;
    PUCHAR RawProcess;
    PRTL_DEBUG_INFORMATION RawModule;
    PRTL_DEBUG_INFORMATION RawDebugInfo;
    NTSTATUS Status = 0;

    if (th32ProcessID == 0) {
        th32ProcessID = GetCurrentProcessId();
    }

    //
    // process the requested data types
    //

    Status = ThpCreateRawSnap(dwFlags,
                              th32ProcessID,
                              &RawProcess,
                              &RawModule,
                              &RawDebugInfo);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return (HANDLE)-1;
    }

    Status = ThpAllocateSnapshotSection(&SnapSection,
                                        dwFlags,
                                        th32ProcessID,
                                        RawProcess,
                                        RawModule,
                                        RawDebugInfo);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return (HANDLE)-1;
    }

    Status = ThpProcessToSnap(dwFlags,
                              th32ProcessID,
                              SnapSection,
                              RawProcess,
                              RawModule,
                              RawDebugInfo);

    if (!NT_SUCCESS(Status)) {
        CloseHandle(SnapSection);
        BaseSetLastNTError(Status);
        return (HANDLE)-1;
    }

    return SnapSection;
}


BOOL
WINAPI
Heap32ListFirst(
   IN HANDLE SnapSection,
   IN OUT LPHEAPLIST32 lphl)
/*++

Routine Description:

    Retrieves information about the first heap that has been allocated by a
    specified Win32 process.

Arguments:

    SnapSection - Supplies the handle of the snapshot returned from a previous
        call to the CreateToolhelp32Snapshot function.

    lphl - Returns a HEAPLIST32 structure.  The calling application must set
        the dwSize member of HEAPLIST32 to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the first entry of the heap list has been copied to the buffer
    or FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the
    GetLastError function when no heap list exists or the snapshot does not contain
    heap list information.

--*/
{
    PSNAPSHOTSTATE SnapshotBase;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    NTSTATUS Status = 0;
    BOOL retv = FALSE;

    if (!lphl || lphl->dwSize != sizeof(HEAPLIST32)) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    SnapshotBase = 0;

    Status = NtMapViewOfSection(SnapSection,
                NtCurrentProcess(),
                &SnapshotBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (SnapshotBase->HeapListCount == 0) {
        RtlZeroMemory((PUCHAR)lphl + sizeof(SIZE_T), (lphl->dwSize - sizeof(SIZE_T)));
        SetLastError(ERROR_NO_MORE_FILES);
    } else {
        memcpy(lphl,
               (LPHEAPLIST32)((ULONG_PTR)SnapshotBase + (ULONG_PTR)SnapshotBase->HeapListHead),
               sizeof(HEAPLIST32));
        retv = TRUE;
        SnapshotBase->HeapListIndex = 1;
    }

    NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)SnapshotBase);
    return retv;
}


BOOL
WINAPI
Heap32ListNext(
   IN HANDLE SnapSection,
   IN OUT LPHEAPLIST32 lphl)
/*++

Routine Description:

    Retrieves information about the next heap that has been allocated by a
    Win32 process.

Arguments:

    SnapSection - Supplies the handle of the snapshot returned from a previous
        call to the CreateToolhelp32Snapshot function.

   lphl - Returns a HEAPLIST32 structure. The calling application must set the
        dwSize member of HEAPLIST32 to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the next entry of the heap list has been copied to the buffer or
    FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the
    GetLastError function when no more entries in the heap list exist.

--*/
{
    PSNAPSHOTSTATE SnapshotBase;
    BOOL retv = FALSE;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    NTSTATUS Status = 0;

    if (!lphl || lphl->dwSize != sizeof(HEAPLIST32)) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    SnapshotBase = 0;

    Status = NtMapViewOfSection(SnapSection,
                NtCurrentProcess(),
                &SnapshotBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (SnapshotBase->HeapListIndex < SnapshotBase->HeapListCount) {
        memcpy(lphl,
               (LPHEAPLIST32)((ULONG_PTR)SnapshotBase + (ULONG_PTR)(&SnapshotBase->HeapListHead[SnapshotBase->HeapListIndex++])),
               sizeof(HEAPLIST32));
        retv = TRUE;
    } else {
        SetLastError(ERROR_NO_MORE_FILES);
    }

    NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)SnapshotBase);

    return(retv);
}


BOOL
WINAPI
Heap32First(
   IN OUT LPHEAPENTRY32 lphe,
   IN DWORD th32ProcessID,
   IN ULONG_PTR th32HeapID)
/*++

Routine Description:

    Retrieves information about the first block of a heap that has been
    allocated by a Win32 process.  Also, create a snapshot of that heap so
    the Heap32Next functions can walk them.

Arguments:

    lphe - Returns a HEAPENTRY32 structure.  The calling application must set
        the dwSize member to the size, in bytes, of the structure.

    th32ProcessID - Supplies the identifier of the Win32 process context that
        owns the heap.

    th32HeapID - Supplies the identifier of the heap to enumerate.

Return Value:

    Returns TRUE if information for the first heap block has been copied to the buffer
    or FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the
    GetLastError function if the heap is invalid or empty.

Notes:

    since there is no way to save heap snapshots or delete heap snapshots in any way that
    makes sense (because this info is not associated with snapshots etc), the information
    needs to be generated completely for each call.  This is very expensive, it would be
    a good idea to redesign this API...
    We could try and cheat by preserving snapshots until they are completyely iterated or
    until a new one is taken, etc, but we will just end up with a bunch of memory leaks

--*/
{
    PRTL_DEBUG_INFORMATION ThRawHeapDebugInfo;
    ULONG HeapListCount;
    PRTL_HEAP_ENTRY p;
    PRTL_HEAP_INFORMATION HeapInfo;
    ULONG HeapEntryAddress;
    NTSTATUS Status = 0;
    BOOL retv = FALSE;

    if (!lphe || lphe->dwSize != sizeof(HEAPENTRY32)) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    //
    // take snapshot
    //

    ThRawHeapDebugInfo = RtlCreateQueryDebugBuffer(0, FALSE);
    if(ThRawHeapDebugInfo == 0)
    {
        return STATUS_UNSUCCESSFUL;
    }
    Status = RtlQueryProcessDebugInformation((HANDLE)LongToHandle(th32ProcessID),
                                          RTL_QUERY_PROCESS_HEAP_SUMMARY |
                                          RTL_QUERY_PROCESS_HEAP_ENTRIES,
                                          ThRawHeapDebugInfo);
    if (!NT_SUCCESS(Status))    {
        RtlDestroyQueryDebugBuffer(ThRawHeapDebugInfo);
        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // query snapshot
    //

    for (HeapListCount = 0;
         HeapListCount < ThRawHeapDebugInfo->Heaps->NumberOfHeaps;
         HeapListCount++) {

        HeapInfo = &ThRawHeapDebugInfo->Heaps->Heaps[HeapListCount];

        if ((ULONG_PTR)HeapInfo->BaseAddress == th32HeapID) {

            p = HeapInfo->Entries;

            lphe->dwResvd = 0;
            lphe->dwLockCount = 0;
            lphe->th32HeapID = th32HeapID;
            lphe->th32ProcessID = th32ProcessID;
            lphe->hHandle = (HANDLE)th32HeapID;// try this way

            // walk up to first non-segment block (I am assuming there is always one)
            // skip segments - can you have 2 in a row?
            // is first block always a segment?
            // We translate the heap flags to the most appropriate LF32_xxx values
            while(RTL_HEAP_SEGMENT & p->Flags)  {
                lphe->dwAddress = (ULONG_PTR)p->u.s2.FirstBlock + ThRawHeapDebugInfo->Heaps->Heaps[HeapListCount].EntryOverhead;    // reset this
                ++lphe->dwResvd;
                ++p;
            }

            //
            // munge flags
            //

            //----------------------------------------------
            if ((p->Flags & RTL_HEAP_BUSY)                ||
                (p->Flags & RTL_HEAP_SETTABLE_VALUE)      ||
                (p->Flags & RTL_HEAP_SETTABLE_FLAG2)      ||
                (p->Flags & RTL_HEAP_SETTABLE_FLAG3)      ||
                (p->Flags & RTL_HEAP_SETTABLE_FLAGS)      ||
                (p->Flags & RTL_HEAP_PROTECTED_ENTRY)
                ) {
                lphe->dwFlags = LF32_FIXED;
            }
            else if ( p->Flags & RTL_HEAP_SETTABLE_FLAG1) {
                lphe->dwFlags = LF32_MOVEABLE;
            }
            else if ( p->Flags & RTL_HEAP_UNCOMMITTED_RANGE) {
                lphe->dwFlags = LF32_FREE;
            }
            //----------------------------------------------

            lphe->dwBlockSize = p->Size;
            retv = TRUE;
            break;
        }
    }

    //
    // free snapshot
    //

    RtlDestroyQueryDebugBuffer(ThRawHeapDebugInfo);

    return retv;

}


BOOL
WINAPI
Heap32Next(
   IN OUT LPHEAPENTRY32 lphe)
/*++

Routine Description:

    Retrieves information about the next block of a heap that has been
    allocated by a Win32 process.

Arguments:

    lphe - Returns a HEAPENTRY32 structure.  The calling application must set
        the dwSize member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if information about the next block in the heap has been
    copied to the buffer or FALSE otherwise. The ERROR_NO_MORE_FILES error
    value is returned by the GetLastError function when no more objects in
    the heap exist.

note:

    this function can be prone to error since the heap can change between
    calls to get heaplists, Heap32First, etc.  There is no good way to
    manage a snapshot using this model, so we just get to live with it.

--*/
{
    PRTL_DEBUG_INFORMATION ThRawHeapDebugInfo;
    PRTL_HEAP_ENTRY p;
    PRTL_HEAP_INFORMATION HeapInfo;
    ULONG HeapListCount;
    BOOL retv = FALSE;
    BOOL hit_seg = FALSE;
    NTSTATUS Status = 0;

    if (!lphe || lphe->dwSize != sizeof(HEAPENTRY32)) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    //
    // take snapshot
    //

    ThRawHeapDebugInfo = RtlCreateQueryDebugBuffer(0, FALSE);
    if(ThRawHeapDebugInfo == 0)
    {
        return STATUS_UNSUCCESSFUL;
    }
    Status = RtlQueryProcessDebugInformation((HANDLE)LongToHandle(lphe->th32ProcessID),
                                          RTL_QUERY_PROCESS_HEAP_SUMMARY |
                                          RTL_QUERY_PROCESS_HEAP_ENTRIES,
                                          ThRawHeapDebugInfo);
    if (!NT_SUCCESS(Status))    {
        RtlDestroyQueryDebugBuffer(ThRawHeapDebugInfo);
        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // get index to correct heap list heap list - th32HeapID / baseadress
    //

    for (HeapListCount = 0; HeapListCount < ThRawHeapDebugInfo->Heaps->NumberOfHeaps; ++HeapListCount)
    {
        if((ULONG_PTR)ThRawHeapDebugInfo->Heaps->Heaps[HeapListCount].BaseAddress == lphe->th32HeapID)
        {
            break;
        }
    }

    //
    // ran out of heaps
    //

    if(HeapListCount >= ThRawHeapDebugInfo->Heaps->NumberOfHeaps)
    {
        RtlDestroyQueryDebugBuffer(ThRawHeapDebugInfo);
        SetLastError(ERROR_NO_MORE_FILES);
        return FALSE;
    }

    //
    // check for last entry
    //

    ++lphe->dwResvd;    // point to next one

    if(lphe->dwResvd >= ThRawHeapDebugInfo->Heaps->Heaps[HeapListCount].NumberOfEntries)
    {
        RtlDestroyQueryDebugBuffer(ThRawHeapDebugInfo);
        SetLastError(ERROR_NO_MORE_FILES);
        return FALSE;
    }

    //
    // point to correct heap entry - index of this is kept in lphe->dwResvd
    //
    p = (PRTL_HEAP_ENTRY)&ThRawHeapDebugInfo->Heaps->Heaps[HeapListCount].Entries[lphe->dwResvd];

    // keep segments in lphe->hHandle
    while(RTL_HEAP_SEGMENT & p->Flags)  {
        lphe->dwAddress = (ULONG_PTR)p->u.s2.FirstBlock + ThRawHeapDebugInfo->Heaps->Heaps[HeapListCount].EntryOverhead;// reset this
        if(lphe->dwResvd >= ThRawHeapDebugInfo->Heaps->Heaps[HeapListCount].NumberOfEntries)
        {
            RtlDestroyQueryDebugBuffer(ThRawHeapDebugInfo);
            SetLastError(ERROR_NO_MORE_FILES);
            return FALSE;
        }
        ++lphe->dwResvd;
        ++p;
        hit_seg = TRUE;
    }

    //
    // calculate the address
    // normally, we could add the size of the previous block to the existing (last) address
    // to get the current address, but this is only for blocks that do not follow a segment
    // I am assuming that there will always be a segment first
    // current address = last address() + last size
    // by the time we reach this point, either we have just exited from scannin a segment, or
    // p-> is pointing at a non-segment entry.
    //

    if(hit_seg == FALSE)
    {
        lphe->dwAddress += lphe->dwBlockSize;
    }

    lphe->dwBlockSize = p->Size;

    //
    // munge flags
    //

    // We translate the heap flags to the most appropriate LF32_xxx values
    //----------------------------------------------
    if( (p->Flags & RTL_HEAP_BUSY)                ||
        (p->Flags & RTL_HEAP_SETTABLE_VALUE)      ||
        (p->Flags & RTL_HEAP_SETTABLE_FLAG2)      ||
        (p->Flags & RTL_HEAP_SETTABLE_FLAG3)      ||
        (p->Flags & RTL_HEAP_SETTABLE_FLAGS)      ||
        (p->Flags & RTL_HEAP_PROTECTED_ENTRY)
        ) {
        lphe->dwFlags = LF32_FIXED;
    }
    else if( p->Flags & RTL_HEAP_SETTABLE_FLAG1) {
        lphe->dwFlags = LF32_MOVEABLE;
    }
    else if( p->Flags & RTL_HEAP_UNCOMMITTED_RANGE) {
        lphe->dwFlags = LF32_FREE;
    }
    //----------------------------------------------

    retv = TRUE;

    //
    // free snapshot
    //

    RtlDestroyQueryDebugBuffer(ThRawHeapDebugInfo);

    return(retv);
}


BOOL
WINAPI
Toolhelp32ReadProcessMemory(
   IN DWORD th32ProcessID,
   IN LPCVOID lpBaseAddress,
   OUT PUCHAR lpBuffer,
   IN SIZE_T cbRead,
   OUT SIZE_T *lpNumberOfBytesRead)
/*++

Routine Description:

    Copies memory allocated to another process into an application-supplied
    buffer.  This function is for people who are to lazy to open
    the process themselves.

Arguments:

    th32ProcessID - Supplies the Identifier of the Win32 process whose memory
        is being copied. This parameter can be zero to copy the memory of the
        current process.

    lpBaseAddress - Supplies the base address in the specified process to read.
        Before transferring any data, the system verifies that all data in the
        base address and memory of the specified size is accessible for read
        access. If this is the case, the function proceeds. Otherwise, the
        function fails.

    lpBuffer - Returns the requested data

    cbRead - Supplies the number of bytes to read from the specified process.

    lpNumberOfBytesRead - Returns the number of bytes copied to the buffer. If
        this parameter is NULL, it is ignored.

Return Value:

    Returns TRUE if successful.

--*/
{
    HANDLE hProcess;
    BOOL RetVal;

    hProcess = OpenProcess(PROCESS_VM_READ, FALSE, th32ProcessID);
    if (hProcess == NULL) {
        return FALSE;
    }

    RetVal = ReadProcessMemory(hProcess,
                               lpBaseAddress,
                               lpBuffer,
                               cbRead,
                               lpNumberOfBytesRead);

    CloseHandle(hProcess);
    return RetVal;
}


BOOL
WINAPI
Process32FirstW(
   IN HANDLE SnapSection,
   IN OUT LPPROCESSENTRY32W lppe)
/*++

Routine Description:

    Retrieves information about the first Win32 process encountered in a system
    snapshot.

Arguments:

    SnapSection - Supplies the handle of a snapshot returned from a previous call
        to the CreateToolhelp32Snapshot function.

    lppe - Returns a PROCESSENTRY32W structure.  The caller must set the dwSize
        member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the first entry of the process list has been copied to the buffer
    or FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the
    GetLastError function if no processes exist or the snapshot does not contain
    process information.

--*/
{
    PSNAPSHOTSTATE SnapshotBase;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    NTSTATUS Status = 0;
    BOOL    retv = FALSE;

    if (!lppe || lppe->dwSize != sizeof(PROCESSENTRY32W)) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    SnapshotBase = 0;

    Status = NtMapViewOfSection(SnapSection,
                NtCurrentProcess(),
                &SnapshotBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (SnapshotBase->ProcessCount == 0) {
        memset((PUCHAR)lppe + 4, 0, lppe->dwSize - 4);
        SetLastError(ERROR_NO_MORE_FILES);
    } else {
        memcpy(lppe,
               (LPPROCESSENTRY32W)((ULONG_PTR)SnapshotBase + (ULONG_PTR)SnapshotBase->ProcessListHead),
               sizeof(PROCESSENTRY32W));
        SnapshotBase->ProcessListIndex = 1;
        retv = TRUE;
    }

    NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)SnapshotBase);

    return retv;
}

BOOL
WINAPI
Process32First(
   IN HANDLE SnapSection,
   IN OUT LPPROCESSENTRY32 lppe)
/*++

Routine Description:

    ANSI version of Process32FirstW.

    Retrieves information about the first Win32 process encountered in a system
    snapshot.

Arguments:

    SnapSection - Supplies the handle of a snapshot returned from a previous call
        to the CreateToolhelp32Snapshot function.

    lppe - Returns a PROCESSENTRY32 structure.  The caller must set the dwSize
        member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the first entry of the process list has been copied to the buffer
    or FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the
    GetLastError function if no processes exist or the snapshot does not contain
    process information.

--*/
{
    PROCESSENTRY32W pe32w;
    BOOL b;

    if (lppe == NULL || (lppe->dwSize < sizeof(PROCESSENTRY32))) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    // Thunk to Process32FirstW
    pe32w.dwSize = sizeof(pe32w);
    b = Process32FirstW(SnapSection,&pe32w);

    WideCharToMultiByte(CP_ACP, 0,
                        pe32w.szExeFile, -1,
                        lppe->szExeFile, ARRAYSIZE(lppe->szExeFile),
                        0, 0);

    lppe->cntUsage = pe32w.cntUsage;    // meaningless on NT, copy anyway
    lppe->th32ProcessID = pe32w.th32ProcessID;
    lppe->th32DefaultHeapID = pe32w.th32DefaultHeapID;
    lppe->th32ModuleID = pe32w.th32ModuleID;
    lppe->cntThreads = pe32w.cntThreads;
    lppe->th32ParentProcessID = pe32w.th32ParentProcessID;
    lppe->pcPriClassBase = pe32w.pcPriClassBase;
    lppe->dwFlags = pe32w.dwFlags;

    return b;
}


BOOL
WINAPI
Process32NextW(
   IN HANDLE SnapSection,
   IN OUT LPPROCESSENTRY32W lppe)
/*++

Routine Description:

    Retrieves information about the next Win32 process recorded in a system snapshot.

Arguments:

    SnapSection - Supplies the handle of a snapshot returned from a previous call
        to the CreateToolhelp32Snapshot function.

    lppe - Returns a PROCESSENTRY32W structure.  The caller must set the dwSize
        member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the next entry of the process list has been copied to the buffer or
    FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the GetLastError
    function if no processes exist or the snapshot does not contain process information.

--*/
{
    PSNAPSHOTSTATE SnapshotBase;
    BOOL    retv = FALSE;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    NTSTATUS Status = 0;

    if (!lppe || lppe->dwSize != sizeof(PROCESSENTRY32W)) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    SnapshotBase = 0;

    Status = NtMapViewOfSection(SnapSection,
                NtCurrentProcess(),
                &SnapshotBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (SnapshotBase->ProcessListIndex < SnapshotBase->ProcessCount) {
        memcpy(lppe,
               (LPPROCESSENTRY32W)((ULONG_PTR)SnapshotBase + (ULONG_PTR)(&SnapshotBase->ProcessListHead[SnapshotBase->ProcessListIndex++])),
               sizeof(PROCESSENTRY32W));
        retv = TRUE;
    } else {
        SetLastError(ERROR_NO_MORE_FILES);
    }

    NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)SnapshotBase);

    return retv;
}

BOOL
WINAPI
Process32Next(
   IN HANDLE SnapSection,
   IN OUT LPPROCESSENTRY32 lppe)
/*++

Routine Description:

    ANSI version of Process32NextW

    Retrieves information about the next Win32 process recorded in a system snapshot.

Arguments:

    SnapSection - Supplies the handle of a snapshot returned from a previous call
        to the CreateToolhelp32Snapshot function.

    lppe - Returns a PROCESSENTRY32 structure.  The caller must set the dwSize
        member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the next entry of the process list has been copied to the buffer or
    FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the GetLastError
    function if no processes exist or the snapshot does not contain process information.

--*/
{
    PROCESSENTRY32W pe32w;
    BOOL b;

    if (lppe == NULL || (lppe->dwSize < sizeof(PROCESSENTRY32))) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    // Thunk to Process32NextW
    pe32w.dwSize = sizeof(pe32w);
    b = Process32NextW(SnapSection,&pe32w);

    WideCharToMultiByte(CP_ACP, 0,
                        pe32w.szExeFile, -1,
                        lppe->szExeFile, ARRAYSIZE(lppe->szExeFile),
                        0, 0);

    lppe->cntUsage = pe32w.cntUsage;    // meaningless on NT, copy anyway
    lppe->th32ProcessID = pe32w.th32ProcessID;
    lppe->th32DefaultHeapID = pe32w.th32DefaultHeapID;
    lppe->th32ModuleID = pe32w.th32ModuleID;
    lppe->cntThreads = pe32w.cntThreads;
    lppe->th32ParentProcessID = pe32w.th32ParentProcessID;
    lppe->pcPriClassBase = pe32w.pcPriClassBase;
    lppe->dwFlags = pe32w.dwFlags;

    return b;
}


BOOL
WINAPI
Thread32First(
   IN HANDLE SnapSection,
   IN OUT LPTHREADENTRY32 lpte)
/*++

Routine Description:

    Retrieves information about the first thread of any Win32 process
    encountered in a system snapshot.

Arguments:

    SnapSection - Supplies the handle of a snapshot returned from a previous
        call to the CreateToolhelp32Snapshot function.

    lpte - Returns a THREADENTRY32 structure.  The caller must set the dwSize
        member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the first entry of the thread list has been copied to the buffer or
    FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the GetLastError
    function if no threads exist or the snapshot does not contain thread information.

--*/
{
    PSNAPSHOTSTATE SnapshotBase;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    NTSTATUS Status = 0;
    BOOL    retv = FALSE;

    if (!lpte || lpte->dwSize != sizeof(THREADENTRY32)) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    SnapshotBase = 0;

    Status = NtMapViewOfSection(SnapSection,
                NtCurrentProcess(),
                &SnapshotBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (SnapshotBase->ThreadCount == 0) {
        memset((PUCHAR)lpte + 4, 0, lpte->dwSize - 4);
        SetLastError(ERROR_NO_MORE_FILES);
    } else {
        memcpy(lpte,
               (LPTHREADENTRY32)((ULONG_PTR)SnapshotBase + (ULONG_PTR)SnapshotBase->ThreadListHead),
               sizeof(THREADENTRY32));
               SnapshotBase->ThreadListIndex = 1;
        retv = TRUE;
    }

    NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)SnapshotBase);

    return(retv);
}


BOOL
WINAPI
Thread32Next(
   IN HANDLE SnapSection,
   IN OUT LPTHREADENTRY32 lpte)
/*++

Routine Description:

    Retrieves information about the next thread of any Win32 process encountered in the
    system memory snapshot.

Arguments:

    SnapSection - Supplies the handle of a snapshot returned from a previous call
        to the CreateToolhelp32Snapshot function.

    lpte - Reeturns a THREADENTRY32 structure.  The caller must set the dwSize
        member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the next entry of the thread list has been copied to the buffer or
    FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the GetLastError
    function if no threads exist or the snapshot does not contain thread information.

--*/
{
    PSNAPSHOTSTATE SnapshotBase;
    BOOL    retv = FALSE;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    NTSTATUS Status = 0;

    if (!lpte || lpte->dwSize != sizeof(THREADENTRY32)) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    SnapshotBase = 0;

    Status = NtMapViewOfSection(SnapSection,
                NtCurrentProcess(),
                &SnapshotBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (SnapshotBase->ThreadListIndex < SnapshotBase->ThreadCount) {
        memcpy(lpte,
               (PTHREADENTRY32)((ULONG_PTR)SnapshotBase + (ULONG_PTR)(&SnapshotBase->ThreadListHead[SnapshotBase->ThreadListIndex++])),
               sizeof(THREADENTRY32));
        retv = TRUE;
    } else {
        SetLastError(ERROR_NO_MORE_FILES);
    }

    NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)SnapshotBase);

    return(retv);
}


BOOL
WINAPI
Module32FirstW(
   IN HANDLE SnapSection,
   IN OUT LPMODULEENTRY32W lpme)
/*++

Routine Description:

    Retrieves information about the first module associated with a Win32 process.

Arguments:

    SnapSection - Supplies the handle of a snapshot returned from a previous call
        to the CreateToolhelp32Snapshot function.

    lpme - Returns a buffer containing a MODULEENTRY32W structure.  The caller
        must set the dwSize member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the first entry of the module list has been copied to the buffer or
    FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the GetLastError
    function if no modules exist or the snapshot does not contain module information.

--*/
{
    PSNAPSHOTSTATE SnapshotBase;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    NTSTATUS Status = 0;
    BOOL    retv = FALSE;

    if (!lpme || lpme->dwSize != sizeof(MODULEENTRY32W)) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    SnapshotBase = 0;

    Status = NtMapViewOfSection(SnapSection,
                NtCurrentProcess(),
                &SnapshotBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (SnapshotBase->ModuleCount == 0) {
        memset((PUCHAR)lpme + 4, 0, lpme->dwSize - 4);
        SetLastError(ERROR_NO_MORE_FILES);
    } else {
        memcpy(lpme,
               (PMODULEENTRY32W)((ULONG_PTR)SnapshotBase + (ULONG_PTR)SnapshotBase->ModuleListHead),
               sizeof(MODULEENTRY32W));
        SnapshotBase->ModuleListIndex = 1;
        retv = TRUE;
    }

    NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)SnapshotBase);

    return retv;
}

BOOL
WINAPI
Module32First(
   IN HANDLE SnapSection,
   IN OUT LPMODULEENTRY32 lpme)
/*++

Routine Description:

    ANSI version of Module32FirstW.

    Retrieves information about the first module associated with a Win32 process.

Arguments:

    SnapSection - Supplies the handle of the snapshot returned from a previous call
        to the CreateToolhelp32Snapshot function.

    lpme - Returns a buffer containing a MODULEENTRY32 structure.  The caller
        must set the dwSize member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the first entry of the module list has been copied to the buffer or
    FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the GetLastError
    function if no modules exist or the snapshot does not contain module information.

--*/
{
    MODULEENTRY32W me32w;
    DWORD dwSizeToCopy;
    BOOL b;

    if (lpme == NULL || (lpme->dwSize < sizeof(MODULEENTRY32))) {
         SetLastError(ERROR_INVALID_PARAMETER);
         return FALSE;
    }

    // Thunk to Module32FirstW
    me32w.dwSize = sizeof(me32w);
    b = Module32FirstW(SnapSection,&me32w);

    WideCharToMultiByte(CP_ACP, 0,
                        me32w.szExePath, -1,
                        lpme->szExePath, ARRAYSIZE(lpme->szExePath),
                        0, 0);

    WideCharToMultiByte(CP_ACP, 0,
                        me32w.szModule, -1,
                        lpme->szModule, ARRAYSIZE(lpme->szModule),
                        0, 0);

    lpme->th32ModuleID  = me32w.th32ModuleID;
    lpme->th32ProcessID = me32w.th32ProcessID;
    lpme->GlblcntUsage  = me32w.GlblcntUsage;
    lpme->ProccntUsage  = me32w.ProccntUsage;
    lpme->modBaseAddr   = me32w.modBaseAddr;
    lpme->modBaseSize   = me32w.modBaseSize;
    lpme->hModule       = me32w.hModule;

    return b;
}


BOOL
WINAPI
Module32NextW(
   IN HANDLE SnapSection,
   IN OUT LPMODULEENTRY32W lpme)
/*++

Routine Description:

    Retrieves information about the next module associated with a Win32 process or thread.

Arguments:

    SnapSection - Supplies the handle of a snapshot returned from a previous call
        to CreateToolhelp32Snapshot.

    lpme - Returns a MODULEENTRY32W structure.  The calling application must set
        the dwSize member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the next entry of the module list has been copied to the buffer or
    FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the GetLastError
    function if no more modules exist.

--*/
{
    PSNAPSHOTSTATE SnapshotBase;
    BOOL    retv = FALSE;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    NTSTATUS Status = 0;

    if (!lpme || lpme->dwSize != sizeof(MODULEENTRY32W)) {
        BaseSetLastNTError(STATUS_INFO_LENGTH_MISMATCH);
        return FALSE;
    }

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    SnapshotBase = 0;

    Status = NtMapViewOfSection(SnapSection,
                NtCurrentProcess(),
                &SnapshotBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if (SnapshotBase->ModuleListIndex < SnapshotBase->ModuleCount) {
        memcpy(lpme,
               (LPMODULEENTRY32W)((ULONG_PTR)SnapshotBase + (ULONG_PTR)(&SnapshotBase->ModuleListHead[SnapshotBase->ModuleListIndex++])),
               sizeof(MODULEENTRY32W));
        retv = TRUE;
    } else {
        SetLastError(ERROR_NO_MORE_FILES);
    }

    NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)SnapshotBase);

    return(retv);
}


BOOL
WINAPI
Module32Next(
   IN HANDLE SnapSection,
   IN OUT LPMODULEENTRY32 lpme)
/*++

Routine Description:

    ANSI version of Module32NextW.

    Retrieves information about the next module associated with a Win32 process or thread.

Arguments:

    SnapSection - Supplies the handle of a snapshot returned from a previous call
        to CreateToolhelp32Snapshot.

    lpme - Returns a MODULEENTRY32 structure.  The calling application must set
        the dwSize member to the size, in bytes, of the structure.

Return Value:

    Returns TRUE if the next entry of the module list has been copied to the buffer or
    FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the GetLastError
    function if no more modules exist.

--*/
{
    MODULEENTRY32W me32w;
    BOOL b;

    if (lpme == NULL || (lpme->dwSize < sizeof(MODULEENTRY32))) {
         SetLastError(ERROR_INVALID_DATA);
         return FALSE;
    }

    // Thunk to Module32NextW
    me32w.dwSize = sizeof(me32w);
    b = Module32NextW(SnapSection,&me32w);

    WideCharToMultiByte(CP_ACP, 0,
                        me32w.szModule, -1,
                        lpme->szModule, ARRAYSIZE(lpme->szModule),
                        0, 0);

    WideCharToMultiByte(CP_ACP, 0,
                        me32w.szExePath, -1,
                        lpme->szExePath, ARRAYSIZE(lpme->szExePath),
                        0, 0);

    lpme->th32ModuleID  = me32w.th32ModuleID;
    lpme->GlblcntUsage  = me32w.GlblcntUsage;
    lpme->ProccntUsage  = me32w.ProccntUsage;
    lpme->modBaseAddr   = me32w.modBaseAddr;
    lpme->modBaseSize   = me32w.modBaseSize;
    lpme->hModule       = me32w.hModule;

    return b;
}

NTSTATUS
ThpCreateRawSnap(
    IN DWORD dwFlags,
    IN DWORD th32ProcessID,
    PUCHAR *RawProcess,
    PRTL_DEBUG_INFORMATION *RawModule,
    PRTL_DEBUG_INFORMATION *RawDebugInfo)
/*++

Routine Description:

    This function gets raw snapshots for the data types specified by dwFlags.

Arguments:

    th32ProcessID - Supplies a WIN32 process ID.  See CreateToolhelp32Snapshot
        for full description.

    dwFlags - Supplies switches requesting various data.  See
        CreateToolhelp32Snapshot for full description

Return Value:

    NTSTATUS as appropriate

--*/
{
    NTSTATUS Status = 0;
    ULONG BufferSize = BUFFER_SIZE;
    SIZE_T stBufferSize = BUFFER_SIZE;

    //
    // get process/thread/module/heap info
    //

    *RawProcess = NULL;
    *RawModule = NULL;
    *RawDebugInfo = NULL;

    if((dwFlags & TH32CS_SNAPPROCESS) || (dwFlags & TH32CS_SNAPTHREAD)){
        do {
            try {
                stBufferSize = BufferSize;
                Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                                 RawProcess,
                                                 0,
                                                 &stBufferSize,
                                                 MEM_COMMIT,
                                                 PAGE_READWRITE);
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                Status = GetExceptionCode();
            }

            if (!NT_SUCCESS(Status)) {
                break;
            }

            BufferSize = (ULONG)stBufferSize;
            //
            // get all of the status information */
            //
            Status = NtQuerySystemInformation(SystemProcessInformation,
                      *RawProcess,
                      BufferSize,
                      NULL);

            if (Status == STATUS_INFO_LENGTH_MISMATCH)   {
                NtFreeVirtualMemory(NtCurrentProcess(),
                                    RawProcess,
                                    &stBufferSize,
                                    MEM_RELEASE);
                *RawProcess = NULL;
                BufferSize += 8192;
            }

        } while(Status == STATUS_INFO_LENGTH_MISMATCH);
    }

    //
    // get module information
    //

    if((dwFlags & TH32CS_SNAPMODULE) || (dwFlags & TH32CS_SNAPMODULE32))
    {
        if (NT_SUCCESS(Status))    {
            *RawModule = RtlCreateQueryDebugBuffer(0, FALSE);
            if (!*RawModule) {
                Status = STATUS_UNSUCCESSFUL;
            }
        }

        if (NT_SUCCESS(Status)) {
            Status = RtlQueryProcessDebugInformation((HANDLE)LongToHandle(th32ProcessID),
                                                     RTL_QUERY_PROCESS_NONINVASIVE |
                                                     ((dwFlags & TH32CS_SNAPMODULE) ? RTL_QUERY_PROCESS_MODULES : 0) |
                                                     ((dwFlags & TH32CS_SNAPMODULE32) ? RTL_QUERY_PROCESS_MODULES32 : 0),
                                                      *RawModule);
        }
    }

    //
    // get the heap summary information for the specified process */
    //

    if (dwFlags & TH32CS_SNAPHEAPLIST)   {
        if (NT_SUCCESS(Status))    {

            *RawDebugInfo = RtlCreateQueryDebugBuffer(0, FALSE);
            if (!*RawDebugInfo) {
                Status = STATUS_UNSUCCESSFUL;
            }
        }
        if (NT_SUCCESS(Status)) {
            Status = RtlQueryProcessDebugInformation((HANDLE)LongToHandle(th32ProcessID),
                                                      RTL_QUERY_PROCESS_HEAP_SUMMARY,
                                                      *RawDebugInfo);
        }
    }


    if (!NT_SUCCESS(Status))    {
        if (*RawProcess) {
            SIZE_T Size = 0;
            NtFreeVirtualMemory(NtCurrentProcess(),
                                RawProcess,
                                &Size,
                                MEM_RELEASE);
            *RawProcess = NULL;
        }
        if (*RawModule) {
            RtlDestroyQueryDebugBuffer(*RawModule);
            *RawModule = NULL;
        }
        if (*RawDebugInfo) {
            RtlDestroyQueryDebugBuffer(*RawDebugInfo);
            *RawDebugInfo = NULL;
        }
    }

    return Status;
}


NTSTATUS
ThpAllocateSnapshotSection(
    OUT PHANDLE SnapSection,
    IN DWORD dwFlags,
    IN DWORD th32ProcessID,
    PUCHAR RawProcess,
    PRTL_DEBUG_INFORMATION RawModule,
    PRTL_DEBUG_INFORMATION RawDebugInfo)
/*++

Routine Description:

    This function calculates the size of the snapshot and allocates a
    file mapping object for it in the pagefile.
    Also, initialize snapshot information in the header

Arguments:

    th32ProcessID - Supplies a WIN32 process ID.  See CreateToolhelp32Snapshot
        for full description.

    dwFlags - Supplies switches describing requested data.  See
        CreateToolhelp32Snapshot for full description.

    th32ProcessID -

    RawProcess -

    RawDebugInfo -

Return Value:

    Handle to to the mapping object if successful, -1 otherwise

--*/
{
    NTSTATUS Status = 0;
    PSNAPSHOTSTATE SnapshotBase;
    SECURITY_ATTRIBUTES SecurityAttributes;
    LPSECURITY_ATTRIBUTES lpSecurityAttributes;
    ULONG SnapShotSize;
    ULONG Offset1;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    LARGE_INTEGER SectionOffset;
    LARGE_INTEGER SectionSize;
    SIZE_T ViewSize;
    SIZE_T Size;
    ULONG ProcessCount = 0;
    ULONG HeapListCount = 0;
    ULONG ModuleCount = 0;
    ULONG ThreadCount = 0;

    SnapShotSize = sizeof(SNAPSHOTSTATE);

    Offset1 = 0;

    //
    // calculate the required snapshot size
    //

    if ((dwFlags & TH32CS_SNAPPROCESS) || (dwFlags & TH32CS_SNAPTHREAD)) {
        do {
            ProcessCount++;
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&RawProcess[Offset1];
            Offset1 += ProcessInfo->NextEntryOffset;
            ThreadCount += ProcessInfo->NumberOfThreads;
        } while (ProcessInfo->NextEntryOffset != 0);

        if (dwFlags & TH32CS_SNAPPROCESS) {
            SnapShotSize += ProcessCount * sizeof(PROCESSENTRY32W);
        }
        if (dwFlags & TH32CS_SNAPTHREAD) {
            SnapShotSize += ThreadCount * sizeof(THREADENTRY32);
        }
    }

    if (dwFlags & TH32CS_SNAPMODULE) {
        SnapShotSize += RawModule->Modules->NumberOfModules * sizeof(MODULEENTRY32W);
        ModuleCount = RawModule->Modules->NumberOfModules;
    }

    if (dwFlags & TH32CS_SNAPHEAPLIST)   {
        SnapShotSize += RawDebugInfo->Heaps->NumberOfHeaps * sizeof(HEAPLIST32);
        HeapListCount = RawDebugInfo->Heaps->NumberOfHeaps;
    }

    //
    // Create a security object if needed
    //

    if (dwFlags & TH32CS_INHERIT) {
        SecurityAttributes.lpSecurityDescriptor = NULL;
        SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
        SecurityAttributes.bInheritHandle = TRUE;
        lpSecurityAttributes = &SecurityAttributes;
    } else {
        lpSecurityAttributes = NULL;
    }

    //
    // create a pagefile section to contain the snapshot
    //

    pObja = BaseFormatObjectAttributes(&Obja, lpSecurityAttributes, NULL);

    SectionSize.LowPart = SnapShotSize;
    SectionSize.HighPart = 0;

    Status = NtCreateSection(SnapSection,
                STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE,
                pObja,
                &SectionSize,
                PAGE_READWRITE,
                SEC_COMMIT,
                NULL);

    if ( !NT_SUCCESS(Status) ) {
        return Status;
    }

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    SnapshotBase = 0;

    Status = NtMapViewOfSection(*SnapSection,
                NtCurrentProcess(),
                &SnapshotBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE);

    //
    // free all memory if failure
    //

    if ( !NT_SUCCESS(Status) ) {
        CloseHandle(*SnapSection);

        if ((dwFlags & TH32CS_SNAPTHREAD) || (dwFlags & TH32CS_SNAPPROCESS)){

        Size = 0;
        NtFreeVirtualMemory(NtCurrentProcess(),
                            &RawProcess,
                            &Size,
                            MEM_RELEASE);

        }

        if (dwFlags & TH32CS_SNAPPROCESS) {
            RtlDestroyQueryDebugBuffer(RawModule);
        }

        if (dwFlags & TH32CS_SNAPHEAPLIST) {
            RtlDestroyQueryDebugBuffer(RawDebugInfo);
        }

        return Status;
    }

    SnapshotBase->ProcessCount  = ProcessCount;
    SnapshotBase->HeapListCount = HeapListCount;
    SnapshotBase->ModuleCount   = ModuleCount;
    SnapshotBase->ThreadCount   = ThreadCount;

    //
    // return resources
    //

    NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)SnapshotBase);

    return STATUS_SUCCESS;
}


NTSTATUS
ThpCopyAnsiToUnicode(
    PWCHAR Dest,
    PUCHAR Src,
    USHORT Max)
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;

    UnicodeString.Buffer = Dest;
    UnicodeString.MaximumLength = Max;

    RtlInitAnsiString(&AnsiString, Src);

    return RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, FALSE );
}


NTSTATUS
ThpProcessToSnap(
    IN DWORD dwFlags,
    IN DWORD th32ProcessID,
    IN HANDLE SnapSection,
    PUCHAR RawProcess,
    PRTL_DEBUG_INFORMATION RawModule,
    PRTL_DEBUG_INFORMATION RawDebugInfo)
/*++

Routine Description:

    This function processes the data in the raw dumps specified by dwFlage into
    a mapped file.

Arguments:

    dwFlags - Supplies switches describing the data requested.  See
        CreateToolhelp32Snapshot for full description.

    th32ProcessID - Supplies a WIN32 process ID. See CreateToolhelp32Snapshot
        for full description.

    SnapSection - Supplies handle to section allocated by ThpAllocateSnapshotSection.

    RawProcess -

    RawDebugInfo -

Return Value:

    TRUE if successful, FALSE if there was a problem encountered

--*/
{
    PSNAPSHOTSTATE SnapshotBase;
    PUCHAR BufferWriteAddr;  /* working pointer into out process data - usually points at end */
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    NTSTATUS Status = 0;
    SIZE_T Size;

    SectionOffset.LowPart = 0;
    SectionOffset.HighPart = 0;
    ViewSize = 0;
    SnapshotBase = 0;

    Status = NtMapViewOfSection(SnapSection,
                NtCurrentProcess(),
                &SnapshotBase,
                0L,
                0L,
                &SectionOffset,
                &ViewSize,
                ViewShare,
                0L,
                PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    BufferWriteAddr = &SnapshotBase->DataBegin;

    //
    // write heap list to snapshot
    // some of this code adapted from dh.c
    //
    if (dwFlags & TH32CS_SNAPHEAPLIST) {
        ULONG HeapListCount = 0;
        ULONG HeapEntryCount = 0;
        LPHEAPLIST32 pHeapList;

        SnapshotBase->HeapListHead = (PHEAPLIST32)(BufferWriteAddr - (PUCHAR)SnapshotBase);
        pHeapList = (LPHEAPLIST32)BufferWriteAddr;

        // heaplist
        for (HeapListCount = 0; HeapListCount < SnapshotBase->HeapListCount; HeapListCount++){
            pHeapList->dwSize = sizeof(HEAPLIST32);
            pHeapList->th32ProcessID = th32ProcessID;
            /* handle = baseaddress = ID we will use internally */
            pHeapList->th32HeapID = (ULONG_PTR)RawDebugInfo->Heaps->Heaps[HeapListCount].BaseAddress;
            pHeapList->dwFlags = RawDebugInfo->Heaps->Heaps[HeapListCount].Flags;
            ++pHeapList;
        }
        // update the pointer to the write area
        BufferWriteAddr = (PCHAR)(BufferWriteAddr + HeapListCount * sizeof(HEAPLIST32));
        RtlDestroyQueryDebugBuffer(RawDebugInfo);
    }

    //
    // write module list to snapshot
    //
    if (dwFlags & TH32CS_SNAPMODULE) {
        LPMODULEENTRY32W pModule;
        ULONG Offset1 = 0;
        ULONG mCount = 0;
        PRTL_PROCESS_MODULE_INFORMATION ModuleInfo;

        SnapshotBase->ModuleListHead = (PMODULEENTRY32W)(BufferWriteAddr - (PUCHAR)SnapshotBase);

        //
        // get module info from buffer
        //

        pModule = (LPMODULEENTRY32W)(BufferWriteAddr);
        ModuleInfo = &RawModule->Modules->Modules[ 0 ];
        for (mCount = 0; mCount < RawModule->Modules->NumberOfModules; mCount++)   {

            pModule->dwSize = sizeof(MODULEENTRY32W);

            pModule->th32ProcessID = th32ProcessID;

            //
            // base == handle
            //

            pModule->hModule = ModuleInfo->ImageBase;

            //
            // Base address of module in th32ProcessID's context
            //

            pModule->modBaseAddr = ModuleInfo->ImageBase;

            //
            // Path
            //

            ThpCopyAnsiToUnicode(pModule->szExePath,
                                 ModuleInfo->FullPathName,
                                 sizeof(pModule->szExePath));

            //
            // module name
            //

            ThpCopyAnsiToUnicode(pModule->szModule,
                                 &ModuleInfo->FullPathName[ModuleInfo->OffsetToFileName],
                                 sizeof(pModule->szModule));

            //
            // Size in bytes of module starting at modBaseAddr
            //

            pModule->modBaseSize = ModuleInfo->ImageSize;


            //
            // these are meaningless on NT
            // but some apps may care... Gruntz (bugid 327009)
            // was failing because th32ModuleID was 0, so
            // now we stick in the address of the Module descriptor
            //
            // However it turns out that a pointer doesn't fit in a DWORD,
            // so we stick in the value 1 instead.
            //

            pModule->th32ModuleID = 1;
            pModule->GlblcntUsage = ModuleInfo->LoadCount;  // will be 0xffff
            pModule->ProccntUsage = ModuleInfo->LoadCount;  // will be 0xffff

            ++ModuleInfo;
            ++pModule;
        }

        //
        // update the pointer to the write area
        //
        BufferWriteAddr = (PCHAR)(BufferWriteAddr + mCount * sizeof(MODULEENTRY32W));
        RtlDestroyQueryDebugBuffer(RawModule);
    }

    //
    // write process list to snapshot
    //
    if (dwFlags & TH32CS_SNAPPROCESS) {

        PSYSTEM_PROCESS_INFORMATION ProcessInfo;
        LPPROCESSENTRY32W pEntry;
        ULONG cProcess = 0;
        ULONG Offset1 = 0;

        SnapshotBase->ProcessListHead = (PPROCESSENTRY32W)(BufferWriteAddr - (PUCHAR)SnapshotBase);
        pEntry = (LPPROCESSENTRY32W)(BufferWriteAddr + cProcess * sizeof(PROCESSENTRY32W));

        do {
            /* get process info from buffer */
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&RawProcess[Offset1];

            pEntry->dwSize              = sizeof(PROCESSENTRY32W);
            pEntry->th32ProcessID       = HandleToUlong(ProcessInfo->UniqueProcessId);
            pEntry->pcPriClassBase      = ProcessInfo->BasePriority;
            pEntry->cntThreads          = ProcessInfo->NumberOfThreads;
            pEntry->th32ParentProcessID = HandleToUlong(ProcessInfo->InheritedFromUniqueProcessId);
            pEntry->cntUsage            = 0;
            pEntry->th32DefaultHeapID   = 0;
            pEntry->th32ModuleID        = 0;
            pEntry->dwFlags             = 0;

            // Path
            if (ProcessInfo->ImageName.Buffer == NULL) {
                lstrcpyW(pEntry->szExeFile, L"[System Process]");
            } else {
                if (ProcessInfo->ImageName.Length >= ARRAYSIZE(pEntry->szExeFile)) {
                    ProcessInfo->ImageName.Length = ARRAYSIZE(pEntry->szExeFile)-1;
                }
                memcpy(pEntry->szExeFile, ProcessInfo->ImageName.Buffer, ProcessInfo->ImageName.Length);
                pEntry->szExeFile[ProcessInfo->ImageName.Length] = TEXT('\0');
            }

            Offset1 += ProcessInfo->NextEntryOffset;
            ++cProcess;
            ++pEntry;

        } while (ProcessInfo->NextEntryOffset != 0);

        // update the pointer to the write area
        BufferWriteAddr = (PCHAR)(BufferWriteAddr + cProcess * sizeof(PROCESSENTRY32W));
    }

    //
    // write thread list to snapshot
    //

    if (dwFlags & TH32CS_SNAPTHREAD) {
        PSYSTEM_PROCESS_INFORMATION ProcessInfo;
        PSYSTEM_THREAD_INFORMATION ThreadInfo;
        LPTHREADENTRY32 tEntry;
        ULONG Offset1 = 0;
        ULONG cThread = 0;

        SnapshotBase->ThreadListHead = (PTHREADENTRY32)(BufferWriteAddr - (PUCHAR)SnapshotBase);
        tEntry = (LPTHREADENTRY32)(BufferWriteAddr + cThread * sizeof(THREADENTRY32));

        do {
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&RawProcess[Offset1];
            ThreadInfo = (PSYSTEM_THREAD_INFORMATION)(ProcessInfo + 1);

            for (cThread = 0; cThread < ProcessInfo->NumberOfThreads; cThread++) {

                tEntry->dwSize              = sizeof(THREADENTRY32);
                tEntry->th32ThreadID        = HandleToUlong(ThreadInfo->ClientId.UniqueThread);
                tEntry->th32OwnerProcessID  = HandleToUlong(ThreadInfo->ClientId.UniqueProcess);
                tEntry->tpBasePri           = ThreadInfo->BasePriority;
                tEntry->tpDeltaPri          = 0;
                tEntry->cntUsage            = 0;
                tEntry->dwFlags             = 0;

            ++ThreadInfo;
            ++tEntry;
            }

            Offset1 += ProcessInfo->NextEntryOffset;

        } while (ProcessInfo->NextEntryOffset != 0);

        BufferWriteAddr = (PUCHAR)(BufferWriteAddr + cThread * sizeof(THREADENTRY32)); // update the pointer to the write area
    }

    if ((dwFlags & TH32CS_SNAPTHREAD) || (dwFlags & TH32CS_SNAPPROCESS)){

        Size = 0;
        NtFreeVirtualMemory(NtCurrentProcess(),
                            &RawProcess,
                            &Size,
                            MEM_RELEASE);
    }

    NtUnmapViewOfSection(NtCurrentProcess(), (PVOID)SnapshotBase);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\tupdrsrc.cpp ===
#define _KERNEL32_
#include <updrsrc.cpp>

extern "C" void __cdecl main(void)
{
    HANDLE hRes;

    hRes = BeginUpdateResourceA("Test.exe", TRUE);
    EndUpdateResourceA(hRes, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\unbufw.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

//
// Unbuffered write test
//

#define TEST_REPEAT_COUNT   10

//
// File is 20mb
//

#define BUFFER_SIZE         (64*1024)
#define NUMBER_OF_WRITES    (320*1)

int BufferSize;
int NumberOfWrites;

char *Buffer;

BOOL fSequentialNew;
BOOL fBufferdIo;
BOOL fRaw;
BOOL fWrite = TRUE;
LPSTR FileName;

VOID
ParseSwitch(
    CHAR chSwitch,
    int *pArgc,
    char **pArgv[]
    );


VOID
ShowUsage(
    VOID
    );

int
__cdecl
main(
    int argc,
    char *argv[],
    char *envp
    )
{
    DWORD Start[TEST_REPEAT_COUNT];
    DWORD End[TEST_REPEAT_COUNT];
    DWORD Diff;
    double fDiff, fSec, fKb, fSumKbs;
    int TestNumber;
    HANDLE hFile, hPort;
    OVERLAPPED ov;
    LPOVERLAPPED ov2;
    int WriteCount;
    DWORD n,n2,key;
    BOOL b;
    int PendingIoCount;
    DWORD Version;
    DWORD FileFlags;
    char chChar, *pchChar;

    Version = GetVersion() >> 16;

    FileName = "unbufw.dat";
    fSequentialNew = FALSE;
    fBufferdIo = FALSE;
    fRaw = FALSE;

    BufferSize = BUFFER_SIZE;
    NumberOfWrites = ( (20*(1024*1024)) / BufferSize);

    while (--argc) {
        pchChar = *++argv;
        if (*pchChar == '/' || *pchChar == '-') {
            while (chChar = *++pchChar) {
                ParseSwitch( chChar, &argc, &argv );
                }
            }
        }




    if ( argc > 1 ) {
        FileName = argv[1];
        }
    else {
        }

    fSumKbs = 0.0;

    Buffer = VirtualAlloc(NULL,BUFFER_SIZE,MEM_COMMIT,PAGE_READWRITE);
    if ( !Buffer ) {
        printf("Error allocating buffer %d\n",GetLastError());
        return 99;
        }

    FileFlags = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED;

    if ( !fBufferdIo ) {
        FileFlags |= FILE_FLAG_NO_BUFFERING;
        }

    DeleteFile(FileName);

    for (TestNumber = 0; TestNumber < TEST_REPEAT_COUNT; TestNumber++ ) {


        hFile = CreateFile(
                    FileName,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    fRaw ? OPEN_EXISTING : OPEN_ALWAYS,
                    FileFlags,
                    NULL
                    );
        if ( hFile == INVALID_HANDLE_VALUE ) {
            printf("Error opening file %s %d\n",FileName,GetLastError());
            return 99;
            }

        hPort = CreateIoCompletionPort(
                    hFile,
                    NULL,
                    (DWORD)hFile,
                    0
                    );
        if ( !hPort ) {
            printf("Error creating completion port %d\n",FileName,GetLastError());
            return 99;
            }

        ZeroMemory(&ov,sizeof(ov));

        if ( TestNumber == 0 && fSequentialNew == FALSE) {

            Start[TestNumber] = GetTickCount();

            //
            // Make sure the file is written out to the end...
            //
            ov.Offset = (NUMBER_OF_WRITES * BUFFER_SIZE) - 1024;

            b = WriteFile(hFile,Buffer,1024,&n,&ov);
            if ( !b && GetLastError() != ERROR_IO_PENDING ) {
                printf("Error in pre-write %d\n",GetLastError());
                return 99;
                }
            b = GetQueuedCompletionStatus(
                    hPort,
                    &n2,
                    &key,
                    &ov2,
                    (DWORD)-1
                    );
            if ( !b ) {
                printf("Error picking up completion pre-write %d\n",GetLastError());
                return 99;
                }

            End[TestNumber] = GetTickCount();

            Diff = End[TestNumber] - Start[TestNumber];

            fDiff = Diff;
            fSec = fDiff/1000.0;
            fKb = ( (NumberOfWrites * BufferSize) / 1024 );

            printf("First Write %2dMb Written in %3.3fs I/O Rate %4.3f Kb/S\n\n",
                (NumberOfWrites * BufferSize) / ( 1024 * 1024),
                fSec,
                fKb / fSec
                );
            }

        ov.Offset = 0;

        PendingIoCount = 0;

        Start[TestNumber] = GetTickCount();

        //
        // Issue the writes
        //

        for (WriteCount = 0; WriteCount < NumberOfWrites; WriteCount++){
reissuewrite:
            if ( fWrite ) {
                b = WriteFile(hFile,Buffer,BufferSize,&n,&ov);
                }
            else {
                b = ReadFile(hFile,Buffer,BufferSize,&n,&ov);
                }
            if ( !b && GetLastError() != ERROR_IO_PENDING ) {

                //
                // we reached our limit on outstanding I/Os
                //

                if ( GetLastError() == ERROR_INVALID_USER_BUFFER ||
                     GetLastError() == ERROR_NOT_ENOUGH_QUOTA ||
                     GetLastError() == ERROR_NOT_ENOUGH_MEMORY ) {

                    //
                    // wait for an outstanding I/O to complete and then go again
                    //
                    b = GetQueuedCompletionStatus(
                            hPort,
                            &n2,
                            &key,
                            &ov2,
                            (DWORD)-1
                            );
                    if ( !b ) {
                        printf("Error picking up completion write %d\n",GetLastError());
                        return 99;
                        }

                    PendingIoCount--;
                    goto reissuewrite;
                    }
                else {
                    printf("Error in write %d (pending count = %d)\n",GetLastError(),PendingIoCount);
                    return 99;
                    }
                }
            PendingIoCount++;
            ov.Offset += BufferSize;
            }

        //
        // Pick up the I/O completion
        //

        for (WriteCount = 0; WriteCount < PendingIoCount; WriteCount++){
            b = GetQueuedCompletionStatus(
                    hPort,
                    &n2,
                    &key,
                    &ov2,
                    (DWORD)-1
                    );
            if ( !b ) {
                printf("Error picking up completion write %d\n",GetLastError());
                return 99;
                }
            }

        End[TestNumber] = GetTickCount();

        CloseHandle(hFile);

        if ( Version > 613 ) {
            CloseHandle(hPort);
            }

        //
        // Dump the results
        //

        Diff = End[TestNumber] - Start[TestNumber];

        fDiff = Diff;
        fSec = fDiff/1000.0;
        fKb = ( (NumberOfWrites * BufferSize) / 1024 );

        printf("Test %2d %2dMb Written in %3.3fs I/O Rate %4.3f Kb/S\n",
            TestNumber,
            (NumberOfWrites * BufferSize) / ( 1024 * 1024),
            fSec,
            fKb / fSec
            );

        fSumKbs += (fKb / fSec);

        if ( fSequentialNew ) {
            DeleteFile(FileName);
            }

        }

    DeleteFile(FileName);

    //
    // Average
    //

    printf("\n Average Throughput %4.3f\n\n",
            fSumKbs/TEST_REPEAT_COUNT
            );
}


VOID
ParseSwitch(
    CHAR chSwitch,
    int *pArgc,
    char **pArgv[]
    )
{
    int bs;
    switch (toupper( chSwitch )) {

        case '?':
            ShowUsage();
            break;

        case 'F':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            FileName =  *(*pArgv);
            break;

        case 'K':
            if (!--(*pArgc)) {
                ShowUsage();
                }
            (*pArgv)++;
            bs = strtoul( *(*pArgv), NULL, 10 );
            bs *= 1024;
            if ( bs > BUFFER_SIZE ) {
                ShowUsage();
                }

            BufferSize = bs;
            NumberOfWrites = ( (20*(1024*1024)) / BufferSize);

            break;


        case 'S':
            fSequentialNew = TRUE;
            break;

        case 'R':
            fRaw = TRUE;
            break;

        case 'B':
            fBufferdIo = TRUE;
            break;

        case 'X':
            fWrite = FALSE;
            break;


        default:
            fprintf( stderr, "UNBUFW: Invalid switch - /%c\n", chSwitch );
            ShowUsage();
            break;

        }
}


VOID
ShowUsage(
    VOID
    )
{
    fputs( "usage: UNBUFW [switches]\n"
           "              [-f filename] supplies the output filename\n"
           "              [-s] write sequentially without pre-allocating the file\n"
           "              [-r] use raw I/O\n"
           "              [-b] use buffered I/O instead of unbuffered I/O\n"
           "              [-x] do reads instead of writes\n"
           "              [-k write-size] use write-size k as write-size (64 is max)\n",
           stderr );

    exit( 1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\updres.h ===
/*++

(C) Copyright Microsoft Corporation 1988-1992

Module Name:

    updres.h

Author:

    Floyd A Rogers 2/7/92

Revision History:
        Floyd Rogers
        Created
--*/

#define	DEFAULT_CODEPAGE	1252
#define	MAJOR_RESOURCE_VERSION	4
#define	MINOR_RESOURCE_VERSION	0

#define BUTTONCODE	0x80
#define EDITCODE	0x81
#define STATICCODE	0x82
#define LISTBOXCODE	0x83
#define SCROLLBARCODE	0x84
#define COMBOBOXCODE	0x85

#define	SEEK_SET	0
#define	SEEK_CUR	1
#define	SEEK_END	2
#define	MAXSTR		(256+1)

//
// An ID_WORD indicates the following WORD is an ordinal rather
// than a string
//

#define ID_WORD 0xffff

//typedef	WCHAR	*PWCHAR;

typedef struct MY_STRING {
	ULONG discriminant;       // long to make the rest of the struct aligned
	union u {
		struct {
		  struct MY_STRING *pnext;
		  ULONG  ulOffsetToString;
		  USHORT cbD;
		  USHORT cb;
		  WCHAR  *sz;
		} ss;
		WORD     Ordinal;
	} uu;
} SDATA, *PSDATA, **PPSDATA;

#define IS_STRING 1
#define IS_ID     2

// defines to make deferencing easier
#define OffsetToString uu.ss.ulOffsetToString
#define cbData         uu.ss.cbD
#define cbsz           uu.ss.cb
#define szStr          uu.ss.sz

typedef struct _RESNAME {
        struct _RESNAME *pnext;	// The first three fields should be the
        PSDATA Name;		// same in both res structures
        ULONG   OffsetToData;

        PSDATA	Type;
	ULONG	SectionNumber;
        ULONG	DataSize;
        ULONG_PTR   OffsetToDataEntry;
        USHORT  ResourceNumber;
        USHORT  NumberOfLanguages;
        WORD	LanguageId;
} RESNAME, *PRESNAME, **PPRESNAME;

typedef struct _RESTYPE {
        struct _RESTYPE *pnext;	// The first three fields should be the
        PSDATA Type;		// same in both res structures
        ULONG   OffsetToData;

        struct _RESNAME *NameHeadID;
        struct _RESNAME *NameHeadName;
        ULONG  NumberOfNamesID;
        ULONG  NumberOfNamesName;
} RESTYPE, *PRESTYPE, **PPRESTYPE;

typedef struct _UPDATEDATA {
        ULONG	cbStringTable;
        PSDATA	StringHead;
        PRESNAME	ResHead;
        PRESTYPE	ResTypeHeadID;
        PRESTYPE	ResTypeHeadName;
        LONG	Status;
        HANDLE	hFileName;
} UPDATEDATA, *PUPDATEDATA;

//
// Round up a byte count to a power of 2:
//
#define ROUNDUP(cbin, align) (((cbin) + (align) - 1) & ~((align) - 1))

//
// Return the remainder, given a byte count and a power of 2:
//
#define REMAINDER(cbin,align) (((align)-((cbin)&((align)-1)))&((align)-1))

#define CBLONG		(sizeof(LONG))
#define BUFSIZE		(4L * 1024L)

/* functions for adding/deleting resources to update list */

LONG
AddResource(
    IN PSDATA Type,
    IN PSDATA Name,
    IN WORD Language,
    IN PUPDATEDATA pupd,
    IN PVOID lpData,
    IN ULONG  cb
    );

PSDATA
AddStringOrID(
    LPCWSTR     lp,
    PUPDATEDATA pupd
    );

BOOL
InsertResourceIntoLangList(
    PUPDATEDATA pUpd,
    PSDATA Type,
    PSDATA Name,
    PRESTYPE pType,
    PRESNAME pName,
    INT	idLang,
    INT	fName,
    INT cb,
    PVOID lpData
    );

BOOL
DeleteResourceFromList(
    PUPDATEDATA pUpd,
    PRESTYPE pType,
    PRESNAME pName,
    INT	idLang,
    INT	fType,
    INT	fName
    );

/* Prototypes for Enumeration done in BeginUpdateResource */

BOOL
EnumTypesFunc(
    HANDLE hModule,
    LPWSTR lpType,
    LPARAM lParam
    );

BOOL
EnumNamesFunc(
    HANDLE hModule,
    LPWSTR lpName,
    LPWSTR lpType,
    LPARAM lParam
    );

BOOL
EnumLangsFunc(
    HANDLE hModule,
    LPWSTR lpType,
    LPWSTR lpName,
    WORD languages,
    LPARAM lParam
    );

/* Prototypes for genral worker functions in updres.c */

LONG
WriteResFile(
    IN HANDLE	hUpdate,
    IN WCHAR	*pDstname
    );

VOID
FreeData(
    PUPDATEDATA pUpd
    );

PRESNAME
WriteResSection(
    PUPDATEDATA pUpdate,
    INT outfh,
    ULONG align,
    ULONG cbLeft,
    PRESNAME pResSave
    );

LONG
PatchRVAs(
    int	inpfh,
    int	outfh,
    PIMAGE_SECTION_HEADER po32,
    ULONG pagedelta,
    PIMAGE_NT_HEADERS pNew,
    ULONG OldSize);

LONG
PatchDebug(
    int	inpfh,
    int	outfh,
    PIMAGE_SECTION_HEADER po32DebugOld,
    PIMAGE_SECTION_HEADER po32DebugNew,
    PIMAGE_SECTION_HEADER po32DebugDirOld,
    PIMAGE_SECTION_HEADER po32DebugDirNew,
    PIMAGE_NT_HEADERS pOld,
    PIMAGE_NT_HEADERS pNew,
    ULONG ibMaxDbgOffsetOld,
    PULONG pPointerToRawData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\win32\client\tth.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    old tth.c

Abstract:

    Test program for Win32 Base File API calls

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <string.h>
#include <memory.h>
#include <process.h>

#define xassert ASSERT
int izero;
int i,j;
#define BASESPIN 1000000

#define NULL_SERVER_SWITCHES 10000
#define PATH_CONVERSION_TEST 1000

//
// Define local types.
//

typedef struct _PERFINFO {
    LARGE_INTEGER StartTime;
    LARGE_INTEGER StopTime;
    ULONG ContextSwitches;
    ULONG FirstLevelFills;
    ULONG SecondLevelFills;
    ULONG SystemCalls;
    PCHAR Title;
    ULONG Iterations;
} PERFINFO, *PPERFINFO;

VOID
FinishBenchMark (
    IN PPERFINFO PerfInfo
    )

{

    ULONG ContextSwitches;
    LARGE_INTEGER Duration;
    ULONG FirstLevelFills;
    ULONG Length;
    ULONG Performance;
    ULONG SecondLevelFills;
    NTSTATUS Status;
    ULONG SystemCalls;
    SYSTEM_PERFORMANCE_INFORMATION SystemInfo;


    //
    // Print results and announce end of test.
    //

    NtQuerySystemTime((PLARGE_INTEGER)&PerfInfo->StopTime);
    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      (PVOID)&SystemInfo,
                                      sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                      NULL);

    if (NT_SUCCESS(Status) == FALSE) {
        printf("Failed to query performance information, status = %lx\n", Status);
        return;
    }

    Duration = RtlLargeIntegerSubtract(PerfInfo->StopTime, PerfInfo->StartTime);
    Length = Duration.LowPart / 10000;
    printf("        Test time in milliseconds %d\n", Length);
    printf("        Number of iterations      %d\n", PerfInfo->Iterations);

    Performance = PerfInfo->Iterations * 1000 / Length;
    printf("        Iterations per second     %d\n", Performance);

    ContextSwitches = SystemInfo.ContextSwitches - PerfInfo->ContextSwitches;
    FirstLevelFills = SystemInfo.FirstLevelTbFills - PerfInfo->FirstLevelFills;
    SecondLevelFills = SystemInfo.SecondLevelTbFills - PerfInfo->SecondLevelFills;
    SystemCalls = SystemInfo.SystemCalls - PerfInfo->SystemCalls;
    printf("        First Level TB Fills      %d\n", FirstLevelFills);
    printf("        Second Level TB Fills     %d\n", SecondLevelFills);
    printf("        Total Context Switches    %d\n", ContextSwitches);
    printf("        Number of System Calls    %d\n", SystemCalls);

    printf("*** End of Test ***\n\n");
    return;
}

VOID
StartBenchMark (
    IN PCHAR Title,
    IN ULONG Iterations,
    IN PPERFINFO PerfInfo
    )

{

    NTSTATUS Status;
    SYSTEM_PERFORMANCE_INFORMATION SystemInfo;

    //
    // Announce start of test and the number of iterations.
    //

    printf("*** Start of test ***\n    %s\n", Title);
    PerfInfo->Title = Title;
    PerfInfo->Iterations = Iterations;
    NtQuerySystemTime((PLARGE_INTEGER)&PerfInfo->StartTime);
    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      (PVOID)&SystemInfo,
                                      sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                      NULL);

    if (NT_SUCCESS(Status) == FALSE) {
        printf("Failed to query performance information, status = %lx\n", Status);
        return;
    }

    PerfInfo->ContextSwitches = SystemInfo.ContextSwitches;
    PerfInfo->FirstLevelFills = SystemInfo.FirstLevelTbFills;
    PerfInfo->SecondLevelFills = SystemInfo.SecondLevelTbFills;
    PerfInfo->SystemCalls = SystemInfo.SystemCalls;
    return;
}

VOID
ScrollTest()
{
    COORD dest,cp;
    SMALL_RECT Sm;
    CHAR_INFO ci;
    CONSOLE_SCREEN_BUFFER_INFO sbi;
    HANDLE ScreenHandle;
    SMALL_RECT Window;

    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &sbi);

    Window.Left = 0;
    Window.Top = 0;
    Window.Right = 79;
    Window.Bottom = 49;

    dest.X = 0;
    dest.Y = 0;

    ci.Char.AsciiChar = ' ';
    ci.Attributes = sbi.wAttributes;

    SetConsoleWindowInfo(GetStdHandle(STD_OUTPUT_HANDLE),
                         TRUE,
                         &Window);

    cp.X = 0;
    cp.Y = 0;

    Sm.Left      = 0;
    Sm.Top       = 1;
    Sm.Right     = 79;
    Sm.Bottom    = 49;

    ScrollConsoleScreenBuffer(GetStdHandle(STD_OUTPUT_HANDLE),
                              &Sm,
                              NULL,
                              dest,
                              &ci);

}






VOID
WinWordOpenFileTest()
{
    PERFINFO PerfInfo;
    ULONG Index;
    OFSTRUCT ofstr;
    HANDLE iFile;

    StartBenchMark("WinWord OpenFile)",
                   3,
                   &PerfInfo);

    for ( Index=0;Index<3;Index++){
        iFile = (HANDLE)OpenFile("foo",&ofstr, OF_PARSE);
        iFile = (HANDLE)OpenFile("E:\\xxxxxxx\\winword.ini",&ofstr, 0x20);
        iFile = (HANDLE)OpenFile("E:\\xxxxxxx\\perftest.doc",&ofstr, 0x22);
        iFile = (HANDLE)OpenFile("E:foo",&ofstr, OF_PARSE);
        iFile = (HANDLE)OpenFile("E:foo",&ofstr, OF_PARSE);
        iFile = (HANDLE)OpenFile("E:foo",&ofstr, OF_PARSE);
        iFile = (HANDLE)OpenFile("E:foo",&ofstr, OF_PARSE);
        iFile = (HANDLE)OpenFile("E:\\xxxxxxx\\custom.dic",&ofstr, 0x4022 );
        iFile = (HANDLE)OpenFile("E:\\xxxxxxx\\sp_am.exc",&ofstr, 0x4040 );
        iFile = (HANDLE)OpenFile("E:foo",&ofstr, OF_PARSE);
        iFile = (HANDLE)OpenFile("foo",&ofstr, OF_PARSE);
        iFile = (HANDLE)OpenFile("E:~doc3d08.tmp",&ofstr, 0x1022);
        iFile = (HANDLE)OpenFile("E:\\xxxxxxx\\tempx.doc",&ofstr, 0xa022 );
        iFile = (HANDLE)OpenFile("E:\\xxxxxxx\\~$rftest.doc",&ofstr, 0x4012 );
        iFile = (HANDLE)OpenFile("foo",&ofstr, OF_PARSE);
        iFile = (HANDLE)OpenFile("E:~doc391f.tmp",&ofstr, 0x1022);
        iFile = (HANDLE)OpenFile("E:\\xxxxxxx\\tempy.doc",&ofstr, 0xa022 );
        iFile = (HANDLE)OpenFile("E:\\xxxxxxx\\winword.ini",&ofstr, 0x12);
    }

    FinishBenchMark(&PerfInfo);
}

VOID
gettictst(int x)
{
    PERFINFO PerfInfo;
    ULONG i,j;
    ULONG tnt,tw32;

    if ( !x ) {
        StartBenchMark("NtGetTickCount)",
                       100000,
                       &PerfInfo);
        for ( i=0;i<100000;i++){
            j = GetTickCount();
        }

        FinishBenchMark(&PerfInfo);

        }
    else {
        while(1)GetTickCount();
        }
}

VOID
latst()
{
    PERFINFO PerfInfo;
    ULONG i,j;
    HANDLE h1, h2, h3, h4, h5;

    StartBenchMark("LocalAlloc/Free)",
                   200,
                   &PerfInfo);
    for ( i=0;i<200/5;i++){
        h1 = LocalAlloc(0, 500);
        h2 = LocalAlloc(0, 600);
        h3 = LocalAlloc(0, 700);
        LocalFree(h2);
        h4 = LocalAlloc(0, 1000);
        h5 = LocalAlloc(0, 100);
        LocalFree(h1);
        LocalFree(h3);
        LocalFree(h4);
        LocalFree(h5);
    }

    FinishBenchMark(&PerfInfo);

}

VOID
WinWordGetDriveTypeTest()
{
    PERFINFO PerfInfo;
    ULONG Index,Reps;
    OFSTRUCT ofstr;
    HANDLE iFile;
    CHAR DiskName[4];
    WCHAR WDiskName[4];

//    StartBenchMark("WinWord GetDriveType (1-26)",
//                   26,
//                   &PerfInfo);
//
//    for ( Index=1;Index<27;Index++){
//        GetDriveType(Index);
//    }
//
//    FinishBenchMark(&PerfInfo);

    DiskName[0]='a';
    DiskName[1]=':';
    DiskName[2]='\\';
    DiskName[3]='\0';
    StartBenchMark("WinWord GetDriveTypeA (a-z)",
                   100,
                   &PerfInfo);

    for(Reps=0;Reps<100;Reps++){
        for ( Index=0;Index<26;Index++){
            DiskName[0]='a'+Index;
            GetDriveTypeA(DiskName);
            }
        }

    FinishBenchMark(&PerfInfo);

    WDiskName[0]=(WCHAR)'a';
    WDiskName[1]=(WCHAR)':';
    WDiskName[2]=(WCHAR)'\\';
    WDiskName[3]=(WCHAR)'\0';
    StartBenchMark("WinWord GetDriveTypeW (a-z)",
                   100,
                   &PerfInfo);

    for(Reps=0;Reps<100;Reps++){
        for ( Index=0;Index<26;Index++){
            WDiskName[0]=(WCHAR)'a'+Index;
            GetDriveTypeW(WDiskName);
            }
        }

    FinishBenchMark(&PerfInfo);
}

VOID
BogusOrdinalTest()
{
    HANDLE hBase;
    FARPROC z;

    WaitForSingleObject(0,-2);
    hBase = GetModuleHandle("base");
    xassert(hBase);
    z = GetProcAddress(hBase,0x00001345);
}


VOID
NullServerSwitchTest (
    VOID
    )

{

    PERFINFO PerfInfo;
    NTSTATUS Status;
    ULONG Index;

    StartBenchMark("Null Server Call Benchmark)",
                   NULL_SERVER_SWITCHES,
                   &PerfInfo);


    for (Index = 0; Index < NULL_SERVER_SWITCHES; Index += 1) {
        CsrIdentifyAlertableThread();
    }
    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    return;
}

VOID
PathConvertTest (
    VOID
    )

{

    PERFINFO PerfInfo;
    NTSTATUS Status;
    ULONG Index;
    UNICODE_STRING FileName;
    BOOLEAN TranslationStatus;

    StartBenchMark("Path Conversion Test (foo)",
                   PATH_CONVERSION_TEST,
                   &PerfInfo);


    for (Index = 0; Index < PATH_CONVERSION_TEST; Index += 1) {
        RtlDosPathNameToNtPathName_U(
            L"foo",
            &FileName,
            NULL,
            NULL
            );
        RtlFreeHeap(RtlProcessHeap(),FileName.Buffer);
    }
    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    StartBenchMark("Path Conversion Test (e:\\nt\\windows\\foo)",
                   PATH_CONVERSION_TEST,
                   &PerfInfo);


    for (Index = 0; Index < PATH_CONVERSION_TEST; Index += 1) {
        RtlDosPathNameToNtPathName_U(
            L"e:\\nt\\windows\\foo",
            &FileName,
            NULL,
            NULL
            );
        RtlFreeHeap(RtlProcessHeap(),FileName.Buffer);
    }
    //
    // Print out performance statistics.
    //

    FinishBenchMark(&PerfInfo);

    return;
}

z(){}

bar()
{
    for (i=0;i<2*BASESPIN;i++)j = i++;
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
}
foo()
{
    for (i=0;i<BASESPIN;i++)j = i++;
    bar();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
}
proftst()
{
    for (i=0;i<BASESPIN;i++)j = i++;
    foo();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
    z();
}

VOID
probtst(
    VOID
    )
{
    LPVOID ReadOnly;
    LPVOID ReadWrite;
    LPVOID ReadWrite2;
    LPVOID NoReadWrite;
    LPVOID MappedReadWrite;
    LPVOID p;
    HANDLE MappedFile;
    LPSTR l;
    LPWSTR w;
    BOOL b;

    ReadOnly = VirtualAlloc(NULL,4096,MEM_COMMIT,PAGE_READONLY);
    ASSERT(ReadOnly);

    ASSERT(!IsBadReadPtr(ReadOnly,1024));
    ASSERT(!IsBadReadPtr(ReadOnly,4096));
    ASSERT(IsBadReadPtr(ReadOnly,4097));
    ASSERT(!IsBadHugeReadPtr(ReadOnly,1024));
    ASSERT(!IsBadHugeReadPtr(ReadOnly,4096));
    ASSERT(IsBadHugeReadPtr(ReadOnly,4097));

    ASSERT(IsBadWritePtr(ReadOnly,1024));
    ASSERT(IsBadWritePtr(ReadOnly,4096));
    ASSERT(IsBadWritePtr(ReadOnly,4097));
    ASSERT(IsBadHugeWritePtr(ReadOnly,1024));
    ASSERT(IsBadHugeWritePtr(ReadOnly,4096));
    ASSERT(IsBadHugeWritePtr(ReadOnly,4097));

    ReadWrite = VirtualAlloc(NULL,4096,MEM_COMMIT,PAGE_READWRITE);
    ASSERT(ReadWrite);

    ASSERT(!IsBadReadPtr(ReadWrite,1024));
    ASSERT(!IsBadReadPtr(ReadWrite,4096));
    ASSERT(IsBadReadPtr(ReadWrite,4097));
    ASSERT(!IsBadHugeReadPtr(ReadWrite,1024));
    ASSERT(!IsBadHugeReadPtr(ReadWrite,4096));
    ASSERT(IsBadHugeReadPtr(ReadWrite,4097));

    ASSERT(!IsBadWritePtr(ReadWrite,1024));
    ASSERT(!IsBadWritePtr(ReadWrite,4096));
    ASSERT(IsBadWritePtr(ReadWrite,4097));
    ASSERT(!IsBadHugeWritePtr(ReadWrite,1024));
    ASSERT(!IsBadHugeWritePtr(ReadWrite,4096));
    ASSERT(IsBadHugeWritePtr(ReadWrite,4097));

    NoReadWrite = VirtualAlloc(NULL,4096,MEM_COMMIT,PAGE_NOACCESS);
    ASSERT(NoReadWrite);

    ASSERT(IsBadReadPtr(NoReadWrite,1024));
    ASSERT(IsBadReadPtr(NoReadWrite,4096));
    ASSERT(IsBadReadPtr(NoReadWrite,4097));
    ASSERT(IsBadHugeReadPtr(NoReadWrite,1024));
    ASSERT(IsBadHugeReadPtr(NoReadWrite,4096));
    ASSERT(IsBadHugeReadPtr(NoReadWrite,4097));

    ASSERT(IsBadWritePtr(NoReadWrite,1024));
    ASSERT(IsBadWritePtr(NoReadWrite,4096));
    ASSERT(IsBadWritePtr(NoReadWrite,4097));
    ASSERT(IsBadHugeWritePtr(NoReadWrite,1024));
    ASSERT(IsBadHugeWritePtr(NoReadWrite,4096));
    ASSERT(IsBadHugeWritePtr(NoReadWrite,4097));

    l = ReadWrite;
    l[4092]='a';
    l[4093]='b';
    l[4094]='c';
    l[4095]='\0';
    ASSERT(!IsBadStringPtrA(&l[4092],2));
    ASSERT(!IsBadStringPtrA(&l[4092],3));
    ASSERT(!IsBadStringPtrA(&l[4092],4));
    ASSERT(!IsBadStringPtrA(&l[4092],5));
    l[4095]='d';
    ASSERT(!IsBadStringPtrA(&l[4092],2));
    ASSERT(!IsBadStringPtrA(&l[4092],3));
    ASSERT(!IsBadStringPtrA(&l[4092],4));
    ASSERT(IsBadStringPtrA(&l[4092],5));

    w = ReadWrite;
    w[2044]=(WCHAR)'a';
    w[2045]=(WCHAR)'b';
    w[2046]=(WCHAR)'c';
    w[2047]=UNICODE_NULL;
    ASSERT(!IsBadStringPtrW(&w[2044],2));
    ASSERT(!IsBadStringPtrW(&w[2044],3));
    ASSERT(!IsBadStringPtrW(&w[2044],4));
    ASSERT(!IsBadStringPtrW(&w[2044],5));
    w[2047]=(WCHAR)'d';
    ASSERT(!IsBadStringPtrW(&w[2044],2));
    ASSERT(!IsBadStringPtrW(&w[2044],3));
    ASSERT(!IsBadStringPtrW(&w[2044],4));
    ASSERT(IsBadStringPtrW(&w[2044],5));

    ReadWrite2 = VirtualAlloc(NULL,4096,MEM_COMMIT,PAGE_READWRITE);
    ASSERT(ReadWrite2);

    ASSERT(VirtualLock(ReadWrite2,4096));
    ASSERT(VirtualUnlock(ReadWrite2,4));
    ASSERT(!VirtualUnlock(ReadWrite2,4));
    ASSERT(!VirtualLock(ReadWrite2,4097));
    ASSERT(!VirtualUnlock(ReadWrite2,4097));
    ASSERT(VirtualLock(ReadWrite2,4096));
    ASSERT(VirtualUnlock(ReadWrite2,4096));
    ASSERT(!VirtualUnlock(ReadWrite2,4096));

    MappedFile = CreateFileMapping(INVALID_HANDLE_VALUE,NULL,PAGE_READWRITE,0,8192,NULL);
    ASSERT(MappedFile);
    MappedReadWrite = MapViewOfFileEx(MappedFile,FILE_MAP_WRITE,0,0,0,(LPVOID)0x50000000);
    ASSERT(MappedReadWrite);

    p = MapViewOfFileEx(MappedFile,FILE_MAP_WRITE,0,0,0,(LPVOID)GetModuleHandle(NULL));
    ASSERT(!p);

    ASSERT(SetPriorityClass(GetCurrentProcess(),IDLE_PRIORITY_CLASS));
    ASSERT(GetPriorityClass(GetCurrentProcess()) == IDLE_PRIORITY_CLASS);

    ASSERT(SetPriorityClass(GetCurrentProcess(),NORMAL_PRIORITY_CLASS));
    ASSERT(GetPriorityClass(GetCurrentProcess()) == NORMAL_PRIORITY_CLASS);

    ASSERT(SetPriorityClass(GetCurrentProcess(),HIGH_PRIORITY_CLASS));
    ASSERT(GetPriorityClass(GetCurrentProcess()) == HIGH_PRIORITY_CLASS);

    ASSERT(SetPriorityClass(GetCurrentProcess(),NORMAL_PRIORITY_CLASS));
    ASSERT(GetPriorityClass(GetCurrentProcess()) == NORMAL_PRIORITY_CLASS);

}


void
notifytst()
{
    HANDLE nHandle;
    DWORD wret;
    HANDLE fFile;
    WIN32_FIND_DATA FindFileData;
    int n;
    BOOL b;

    fFile =  FindFirstFile(
                "c:\\*.*",
                &FindFileData
                );
    xassert(fFile != INVALID_HANDLE_VALUE);
    n = 0;
    b = TRUE;
    while(b) {
        n++;
        b = FindNextFile(fFile,&FindFileData);
        }
    FindClose(fFile);
    printf("%d files\n",n);

    nHandle = FindFirstChangeNotification(
                "C:\\",
                TRUE,
                FILE_NOTIFY_CHANGE_NAME
                );
    xassert(nHandle != INVALID_HANDLE_VALUE);

    wret = WaitForSingleObject(nHandle,-1);
    xassert(wret == 0);

    fFile =  FindFirstFile(
                "c:\\*.*",
                &FindFileData
                );
    xassert(fFile != INVALID_HANDLE_VALUE);
    n = 0;
    b = TRUE;
    while(b) {
        n++;
        b = FindNextFile(fFile,&FindFileData);
        }
    FindClose(fFile);
    printf("%d files\n",n);

    b = FindNextChangeNotification(nHandle);
    xassert(b);

    wret = WaitForSingleObject(nHandle,-1);
    xassert(wret == 0);

    fFile =  FindFirstFile(
                "c:\\*.*",
                &FindFileData
                );
    xassert(fFile != INVALID_HANDLE_VALUE);
    n = 0;
    b = TRUE;
    while(b) {
        n++;
        b = FindNextFile(fFile,&FindFileData);
        }
    FindClose(fFile);
    printf("%d files\n",n);

    xassert(FindCloseChangeNotification(nHandle));
    xassert(!FindCloseChangeNotification(nHandle));
}

void
openiftst()
{
    HANDLE NEvent, NSemaphore, NMutex;
    HANDLE sEvent, sSemaphore, sMutex;

    NEvent = CreateEvent(NULL,TRUE,TRUE,"named-event");
    xassert(NEvent);
    xassert(GetLastError()==0);
    sEvent = CreateEvent(NULL,TRUE,TRUE,"named-event");
    xassert(sEvent);
    xassert(GetLastError()==ERROR_ALREADY_EXISTS);
    NSemaphore = CreateSemaphore(NULL,1,256,"named-event");

    NSemaphore = CreateSemaphore(NULL,1,256,"named-semaphore");
    xassert(NSemaphore);
    xassert(GetLastError()==0);
    sSemaphore = CreateSemaphore(NULL,1,256,"named-semaphore");
    xassert(sSemaphore);
    xassert(GetLastError()==ERROR_ALREADY_EXISTS);

    NMutex = CreateMutex(NULL,FALSE,"named-mutex");
    xassert(NMutex);
    xassert(GetLastError()==0);
    sMutex = CreateMutex(NULL,FALSE,"named-mutex");
    xassert(sMutex);
    xassert(GetLastError()==ERROR_ALREADY_EXISTS);

}

void
NewRip(int flag, LPSTR str)
{
    DWORD ExceptionArguments[3];
    try {
        ExceptionArguments[0]=strlen(str);
        ExceptionArguments[1]=(DWORD)str;
        ExceptionArguments[2]=(DWORD)flag;
        RaiseException(0x0eab7190,0,3,ExceptionArguments);
        }
    except(EXCEPTION_EXECUTE_HANDLER) {
        ;
        }
}

void
Ofprompt()
{
    HFILE h;
    OFSTRUCT of;

    SetErrorMode(SEM_NOOPENFILEERRORBOX);
    h = OpenFile("e:\\nt\\xt.cfg",&of,OF_PROMPT);
    printf("OpenFile(e:\\nt\\xt.cfg) h = %lx, GLE = %d\n",h,GetLastError());

    h = OpenFile("e:\\zznt\\xt.cfg",&of,OF_PROMPT);
    printf("OpenFile(e:\\zznt\\xt.cfg) h = %lx, GLE = %d\n",h,GetLastError());

    h = OpenFile("e:\\nt\\xt.cfg",&of,OF_PROMPT | OF_CANCEL);
    printf("OpenFile(e:\\nt\\xt.cfg) h = %lx, GLE = %d\n",h,GetLastError());
    SetErrorMode(0);
    h = OpenFile("e:\\nt\\xt.cfg",&of,OF_PROMPT);
    printf("OpenFile(e:\\nt\\xt.cfg) h = %lx, GLE = %d\n",h,GetLastError());

    h = OpenFile("e:\\zznt\\xt.cfg",&of,OF_PROMPT);
    printf("OpenFile(e:\\zznt\\xt.cfg) h = %lx, GLE = %d\n",h,GetLastError());

    h = OpenFile("e:\\nt\\xt.cfg",&of,OF_PROMPT | OF_CANCEL);
    printf("OpenFile(e:\\nt\\xt.cfg) h = %lx, GLE = %d\n",h,GetLastError());
}
void
rtldevn()
{
    UNICODE_STRING ustr;
    ANSI_STRING astr;
    CHAR buf[256];
    DWORD dw;

    printf("name -> ");
    scanf("%s",buf);
    RtlInitAnsiString(&astr,buf);
    RtlAnsiStringToUnicodeString(&ustr,&astr,TRUE);

    dw = RtlIsDosDeviceName_U(ustr.Buffer);

    printf("dw %x Name %s \n",dw,buf);
}

typedef struct _CMDSHOW {
    WORD wMustBe2;
    WORD wShowWindowValue;
} CMDSHOW, *PCMDSHOW;
typedef struct _LOAD_MODULE_PARAMS {
    LPSTR lpEnvAddress;
    LPSTR lpCmdLine;
    PCMDSHOW lpCmdShow;
    DWORD dwReserved;
} LOAD_MODULE_PARAMS, *PLOAD_MODULE_PARAMS;

typedef DWORD (*PFNWAITFORINPUTIDLE)(HANDLE hProcess, DWORD dwMilliseconds);
void
cptst()
{
    CHAR buf[256];
    CHAR cline[256];
    DWORD dw;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    LOAD_MODULE_PARAMS lmp;
    CHAR Environment[256];
    CMDSHOW cs;
    PFNWAITFORINPUTIDLE WaitForInputIdleRoutine;
    HANDLE hMod;

    hMod = LoadLibrary("user32");
    WaitForInputIdleRoutine = GetProcAddress(hMod,"WaitForInputIdle");

    printf("name -> ");
    scanf("%s",buf);

    RtlZeroMemory(&StartupInfo,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    SetLastError(0);
    CreateProcess(
        NULL,
        buf,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &StartupInfo,
        &ProcessInformation
        );
    (WaitForInputIdleRoutine)(ProcessInformation.hProcess,10000);
    printf("GLE %d\n",GetLastError());
    SetLastError(0);
    printf("WINEXEC %d\n",WinExec(buf,0));

    SetLastError(0);
    lmp.lpEnvAddress = Environment;
    lmp.lpCmdLine = cline;
    lmp.dwReserved = 0;
    lmp.lpCmdShow = &cs;
    cs.wMustBe2 = 2;
    cs.wShowWindowValue = 3;
    cline[0] = strlen(buf);
    RtlMoveMemory(&cline[1],buf,cline[0]);
    cline[cline[0