RIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_GetString()
			{ return (nCol == 0) ? GetDisplayName() : NULL; }

	// Base handler notifications we handle
	OVERRIDE_BaseHandlerNotify_OnExpand();
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();    

	// Result handler functionality we override
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();

    OVERRIDE_ResultHandler_OnGetResultViewType();
	OVERRIDE_ResultHandler_GetVirtualString(); 
	OVERRIDE_ResultHandler_GetVirtualImage();
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_HasPropertyPages();
	OVERRIDE_ResultHandler_CreatePropertyPages();

	STDMETHODIMP CacheHint(int nStartIndex, int nEndIndex);
	STDMETHODIMP SortItems(int     nColumn, 
						   DWORD   dwSortOptions,    
						   LPARAM  lUserParam);

    // base handler overrides
	virtual HRESULT LoadColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

	// CHandler overridden
    virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);

    // multi select support
    virtual const GUID * GetVirtualGuid(int nIndex) 
	{ 
		return &GUID_IpsmQmPolicyNodeType; 
	}

public:
	// CMTIpsmHandler functionality
	virtual HRESULT  InitializeNode(ITFSNode * pNode);
	virtual int      GetImageIndex(BOOL bOpenImage);
	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

public:
	// implementation specific	
    HRESULT InitData(ISpdInfo * pSpdInfo);
    HRESULT UpdateStatus(ITFSNode * pNode);
    
// Implementation
private:
	// Command handlers
    HRESULT OnDelete(ITFSNode * pNode);

private:
    SPISpdInfo          m_spSpdInfo;
};


#endif _LINES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\qmpolpp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    Servpp.h   
        Server properties implementation file

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "qmpolpp.h"
#include "spdutil.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// CQmPolicyProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CQmPolicyProperties::CQmPolicyProperties
(
    ITFSNode *          pNode,
    IComponentData *    pComponentData,
    ITFSComponentData * pTFSCompData,
	CQmPolicyInfo *		pPolInfo,
    ISpdInfo *          pSpdInfo,
    LPCTSTR             pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
    //ASSERT(pFolderNode == GetContainerNode());

    m_bAutoDeletePages = FALSE; // we have the pages as embedded members

    AddPageToList((CPropertyPageBase*) &m_pageGeneral);

    Assert(pTFSCompData != NULL);
    m_spTFSCompData.Set(pTFSCompData);
    
    m_spSpdInfo.Set(pSpdInfo);

	m_PolInfo = *pPolInfo;

	m_bTheme = TRUE;
}

CQmPolicyProperties::~CQmPolicyProperties()
{
    RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CQmPolGenProp property page

IMPLEMENT_DYNCREATE(CQmPolGenProp, CPropertyPageBase)

CQmPolGenProp::CQmPolGenProp() : CPropertyPageBase(CQmPolGenProp::IDD)
{
    //{{AFX_DATA_INIT(CQmPolGenProp)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CQmPolGenProp::~CQmPolGenProp()
{
}

void CQmPolGenProp::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPageBase::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CQmPolGenProp)
    DDX_Control(pDX, IDC_QM_POL_GEN_LIST, m_listOffers);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CQmPolGenProp, CPropertyPageBase)
    //{{AFX_MSG_MAP(CQmPolGenProp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQmPolGenProp message handlers

BOOL CQmPolGenProp::OnInitDialog() 
{
    CPropertyPageBase::OnInitDialog();
    
	PopulateOfferInfo();	

    SetDirty(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CQmPolGenProp::PopulateOfferInfo()
{
	CString st;
	int nRows;
	int nWidth;
	
	CQmPolicyProperties * pPolProp;
	CQmPolicyInfo * pPolInfo;

	pPolProp = (CQmPolicyProperties *) GetHolder();
	Assert(pPolProp);

	pPolProp->GetPolicyInfo(&pPolInfo);

	st.LoadString(IDS_QM_POL_GEN_AUTH);
	nWidth = m_listOffers.GetStringWidth(st) + 20;
	m_listOffers.InsertColumn(0, st, LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_QM_POL_GEN_ESP_CONF);
	nWidth = m_listOffers.GetStringWidth(st) + 20;
	m_listOffers.InsertColumn(1, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_QM_POL_GEN_ESP_INTEG);
	nWidth = m_listOffers.GetStringWidth(st) + 20;
	m_listOffers.InsertColumn(2, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_QM_POL_GEN_KEY_LIFE);
	nWidth = m_listOffers.GetStringWidth(st) + 20;
	m_listOffers.InsertColumn(3, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_QM_POL_GEN_PFS);
	nWidth = m_listOffers.GetStringWidth(st) + 20;
	m_listOffers.InsertColumn(4, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_QM_POL_GEN_PFS_GP);
	nWidth = m_listOffers.GetStringWidth(st) + 20;
	m_listOffers.InsertColumn(5, st,  LVCFMT_LEFT, nWidth);


	nRows = 0;
	for (int i = 0; i < (int)pPolInfo->m_arrOffers.GetSize(); i++)
	{
		nRows = m_listOffers.InsertItem(nRows, _T(""));

		if (-1 != nRows)		
		{
			QmAlgorithmToString(QM_ALGO_AUTH, pPolInfo->m_arrOffers[i], &st);
			m_listOffers.SetItemText(nRows, 0, st);

			QmAlgorithmToString(QM_ALGO_ESP_CONF, pPolInfo->m_arrOffers[i], &st);
			m_listOffers.SetItemText(nRows, 1, st);

			QmAlgorithmToString(QM_ALGO_ESP_INTEG, pPolInfo->m_arrOffers[i], &st);
			m_listOffers.SetItemText(nRows, 2, st);

			KeyLifetimeToString(pPolInfo->m_arrOffers[i]->m_Lifetime, &st);
			m_listOffers.SetItemText(nRows, 3, st);

			BoolToString(pPolInfo->m_arrOffers[i]->m_fPFSRequired, &st);
			m_listOffers.SetItemText(nRows, 4, st);

			PFSGroupToString(pPolInfo->m_arrOffers[i]->m_dwPFSGroup, &st);
			m_listOffers.SetItemText(nRows, 5, st);
		}
		nRows++;
	}

    if ( nRows > 0 )
    {
        //select the first item
        m_listOffers.SetFocus();
        m_listOffers.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);
    }
}


BOOL CQmPolGenProp::OnApply() 
{
    if (!IsDirty())
        return TRUE;

    UpdateData();

	//TODO
	//Do nothing at this time
	
	//CPropertyPageBase::OnApply();

    return TRUE;
}

BOOL CQmPolGenProp::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\qmpol.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    provider.cpp
        Main Mode Policy node handler

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "server.h"
#include "QmPol.h"
#include "QmPolpp.h"
#include "SpdUtil.h"


/*---------------------------------------------------------------------------
    Class CQmPolicyHandler implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    Constructor and destructor
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
CQmPolicyHandler::CQmPolicyHandler
(
    ITFSComponentData * pComponentData
) : CIpsmHandler(pComponentData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
}


CQmPolicyHandler::~CQmPolicyHandler()
{
}

/*!--------------------------------------------------------------------------
    CQmPolicyHandler::InitializeNode
        Initializes node specific data
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CQmPolicyHandler::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    CString strTemp;  
	strTemp.LoadString(IDS_QM_POL_NODE);
    SetDisplayName(strTemp);

    // Make the node immediately visible
    pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
    pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_FOLDER_CLOSED);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_FOLDER_OPEN);
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, IPSECMON_QM_POLICY);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

    SetColumnStringIDs(&aColumns[IPSECMON_QM_POLICY][0]);
    SetColumnWidths(&aColumnWidths[IPSECMON_QM_POLICY][0]);

    return hrOK;
}


/*---------------------------------------------------------------------------
    CQmPolicyHandler::GetImageIndex
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CQmPolicyHandler::GetImageIndex(BOOL bOpenImage) 
{
    int nIndex = -1;

    return nIndex;
}


/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CQmPolicyHandler::OnAddMenuItems
        Adds context menu items for the SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CQmPolicyHandler::OnAddMenuItems
(
    ITFSNode *              pNode,
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    LPDATAOBJECT            lpDataObject, 
    DATA_OBJECT_TYPES       type, 
    DWORD                   dwType,
    long *                  pInsertionAllowed
)
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    LONG        fFlags = 0, fLoadingFlags = 0;
    HRESULT     hr = S_OK;
    CString     strMenuItem;

    if (type == CCT_SCOPE)
    {
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
        }

    }

    return hr; 
}

/*!--------------------------------------------------------------------------
    CQmPolicyHandler::AddMenuItems
        Adds context menu items for virtual list box (result pane) items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CQmPolicyHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
    MMC_COOKIE              cookie,
    LPDATAOBJECT            pDataObject, 
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    long *                  pInsertionAllowed
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT     hr = hrOK;
    CString     strMenuItem;
    SPINTERNAL  spInternal;
    LONG        fFlags = 0;

    spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or this SA
    // node itself.
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        //load and view menu items here
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CQmPolicyHandler::OnRefresh
        Default implementation for the refresh functionality
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CQmPolicyHandler::OnRefresh
(
    ITFSNode *      pNode,
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg,
    LPARAM          param
)
{
	HRESULT hr = S_OK;
    int i = 0; 
    SPIConsole      spConsole;

    CORg(CHandler::OnRefresh(pNode, pDataObject, dwType, arg, param));

	CORg(m_spSpdInfo->EnumQmPolicies());
        
    i = m_spSpdInfo->GetQmPolicyCount();
    
    // now notify the virtual listbox
    CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE));

Error:
	return hr;
}

/*---------------------------------------------------------------------------
    CQmPolicyHandler::OnCommand
        Handles context menu commands for QM Policy scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CQmPolicyHandler::OnCommand
(
    ITFSNode *          pNode, 
    long                nCommandId, 
    DATA_OBJECT_TYPES   type, 
    LPDATAOBJECT        pDataObject, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	//handle the scope context menu commands here
    return S_OK;
}

/*!--------------------------------------------------------------------------
    CQmPolicyHandler::Command
        Handles context menu commands for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CQmPolicyHandler::Command
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    int             nCommandID,
    LPDATAOBJECT    pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    SPITFSNode spNode;

    m_spResultNodeMgr->FindNode(cookie, &spNode);

	// handle result context menu and view menus here	

    return hr;
}

/*!--------------------------------------------------------------------------
    CQmPolicyHandler::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    NOTE: the root node handler has to over-ride this function to 
    handle the snapin manager property page (wizard) case!!!
    
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CQmPolicyHandler::HasPropertyPages
(
    ITFSNode *          pNode,
    LPDATAOBJECT        pDataObject, 
    DATA_OBJECT_TYPES   type, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    return hrFalse;
}

/*---------------------------------------------------------------------------
    CQmPolicyHandler::CreatePropertyPages
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CQmPolicyHandler::CreatePropertyPages
(
    ITFSNode *              pNode,
    LPPROPERTYSHEETCALLBACK lpSA,
    LPDATAOBJECT            pDataObject, 
    LONG_PTR                handle, 
    DWORD                   dwType
)
{
    return hrFalse;
}

/*---------------------------------------------------------------------------
    CQmPolicyHandler::OnPropertyChange
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CQmPolicyHandler::OnPropertyChange
(   
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataobject, 
    DWORD           dwType, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    //CServerProperties * pServerProp = reinterpret_cast<CServerProperties *>(lParam);

    LONG_PTR changeMask = 0;

    // tell the property page to do whatever now that we are back on the
    // main thread
    //pServerProp->OnPropertyChange(TRUE, &changeMask);

    //pServerProp->AcknowledgeNotify();

    if (changeMask)
        pNode->ChangeNode(changeMask);

    return hrOK;
}

/*---------------------------------------------------------------------------
    CQmPolicyHandler::OnExpand
        Handles enumeration of a scope item
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CQmPolicyHandler::OnExpand
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    CORg (CIpsmHandler::OnExpand(pNode, pDataObject, dwType, arg, param));

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    CQmPolicyHandler::OnResultSelect
        Handles the MMCN_SELECT notifcation 
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CQmPolicyHandler::OnResultSelect
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie,
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    SPINTERNAL      spInternal;
    SPIConsole      spConsole;
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    int             i;
    LONG_PTR        dwNodeType;
	IConsole2 *pConsole2 = NULL;
    BOOL            fSelect = HIWORD(arg);

	// virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or the active
    // registrations node itself.
    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

	m_verbDefault = MMC_VERB_OPEN;

	//get pConsole2 for writing to the status bar, if fails not to worry
	pComponent->GetConsole(&pConsole2);

    if (!fSelect)
	{
		if(pConsole2) {
			pConsole2->SetStatusText(_T(""));
			pConsole2->Release();
		}
        return hr;
	}

    if (m_spSpdInfo)
    {
        DWORD dwInitInfo;

        dwInitInfo=m_spSpdInfo->GetInitInfo();
        if (!(dwInitInfo & MON_QM_POLICY)) {
            CORg(m_spSpdInfo->EnumQmPolicies());            
            m_spSpdInfo->SetInitInfo(dwInitInfo | MON_QM_POLICY);
        }
        m_spSpdInfo->SetActiveInfo(MON_QM_POLICY);


        // Get the current count
        i = m_spSpdInfo->GetQmPolicyCount();

        // now notify the virtual listbox
        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
        CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE) );
		
		if(pConsole2)
		{
			CString strTemp;
			WCHAR szTemp[20];
			wsprintf(szTemp, L"%d", i);
		    AfxFormatString1(strTemp, IDS_STATUS_NUM_ITEMS, szTemp);
			LPCTSTR szNumItems = (LPCTSTR) strTemp;
		    pConsole2->SetStatusText((LPOLESTR)szNumItems);
		    pConsole2->Release();
		}
		
    }

    // now update the verbs...
    spInternal = ExtractInternalFormat(pDataObject);
    Assert(spInternal);


    if (spInternal->HasVirtualIndex())
    {
		//TODO add to here if we want to have some result console verbs
        // we gotta do special stuff for the virtual index items
        dwNodeType = IPSECMON_QM_POLICY_ITEM;
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
		
		//enable the "properties" menu
		bStates[MMC_VERB_PROPERTIES & 0x000F] = TRUE;
		m_verbDefault = MMC_VERB_PROPERTIES;
    }
    else
    {
        // enable/disable delete depending if the node supports it
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
        dwNodeType = spNode->GetData(TFS_DATA_TYPE);

        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);

        //hide "delete" context menu
        bStates[MMC_VERB_DELETE & 0x000F] = FALSE;
    }

    EnableVerbs(spConsoleVerb, g_ConsoleVerbStates[dwNodeType], bStates);
	
COM_PROTECT_ERROR_LABEL;
    return hr;
}


/*!--------------------------------------------------------------------------
    CQmPolicyHandler::OnDelete
        The base handler calls this when MMC sends a MMCN_DELETE for a 
        scope pane item.  We just call our delete command handler.
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CQmPolicyHandler::OnDelete
(
    ITFSNode *  pNode, 
    LPARAM      arg, 
    LPARAM      lParam
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
    CQmPolicyHandler::HasPropertyPages
        Handle the result notification
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CQmPolicyHandler::HasPropertyPages(
   ITFSComponent *pComponent,
   MMC_COOKIE cookie,
   LPDATAOBJECT pDataObject)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
    CQmPolicyHandler::HasPropertyPages
        Handle the result notification. Create the filter property sheet
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP CQmPolicyHandler::CreatePropertyPages
(
	ITFSComponent * 		pComponent, 
   MMC_COOKIE			   cookie,
   LPPROPERTYSHEETCALLBACK lpProvider, 
   LPDATAOBJECT 		 pDataObject, 
   LONG_PTR 			 handle
)
{
 
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT	hr = hrOK;

	SPINTERNAL  spInternal;
	SPITFSNode  spNode;
	int		nIndex;
	SPIComponentData spComponentData;
	CQmPolicyInfo PolInfo;
	CQmPolicyProperties * pQmPolProp;
    
 
	Assert(m_spNodeMgr);
	
	CORg( m_spNodeMgr->FindNode(cookie, &spNode) );
	CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

	spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node that is selected.
    // assert that this notification is for a virtual listbox item 
    Assert(spInternal);
    if (!spInternal->HasVirtualIndex())
        return hr;

    nIndex = spInternal->GetVirtualIndex();

	CORg(m_spSpdInfo->GetQmPolicyInfo(nIndex, &PolInfo));

	pQmPolProp = new CQmPolicyProperties(
												spNode,
												spComponentData,
												m_spTFSCompData,
												&PolInfo,
												m_spSpdInfo,
												NULL);

	hr = pQmPolProp->CreateModelessSheet(lpProvider, handle);

COM_PROTECT_ERROR_LABEL;

	return hr;
}


/*---------------------------------------------------------------------------
    CQmPolicyHandler::OnGetResultViewType
        Return the result view that this node is going to support
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CQmPolicyHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE            cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    if (cookie != NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;
    }

    return S_FALSE;
}

/*---------------------------------------------------------------------------
    CQmPolicyHandler::GetVirtualImage
        Returns the image index for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CQmPolicyHandler::GetVirtualImage
(
    int     nIndex
)
{
    return ICON_IDX_POLICY;
}

/*---------------------------------------------------------------------------
    CQmPolicyHandler::GetVirtualString
        returns a pointer to the string for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
LPCWSTR 
CQmPolicyHandler::GetVirtualString
(
    int     nIndex,
    int     nCol
)
{
	HRESULT hr = S_OK;
	static CString strTemp;

	strTemp.Empty();

	if (nCol >= DimensionOf(aColumns[IPSECMON_QM_POLICY]))
		return NULL;
	
	CQmPolicyInfo QmPol;
	CORg(m_spSpdInfo->GetQmPolicyInfo(nIndex, &QmPol));

    switch (aColumns[IPSECMON_QM_POLICY][nCol])
    {
        case IDS_COL_QM_POL_NAME:
			if( QmPol.m_dwFlags & IPSEC_QM_POLICY_DEFAULT_POLICY) {
				AfxFormatString1(strTemp, IDS_POL_DEFAULT_RESPONSE, (LPCTSTR) QmPol.m_stName);
			} else {
				 strTemp = QmPol.m_stName;
			}
			return strTemp;
            break;

        case IDS_COL_QM_POL_OFFER:
			strTemp.Format(_T("%d"), QmPol.m_arrOffers.GetSize());
			return strTemp;
            break;

        default:
            Panic0("CQmPolicyHandler::GetVirtualString - Unknown column!\n");
            break;
    }

COM_PROTECT_ERROR_LABEL;
    return NULL;
}

/*---------------------------------------------------------------------------
    CQmPolicyHandler::CacheHint
        MMC tells us which items it will need before it requests things
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CQmPolicyHandler::CacheHint
(
    int nStartIndex, 
    int nEndIndex
)
{
    HRESULT hr = hrOK;;

    Trace2("CacheHint - Start %d, End %d\n", nStartIndex, nEndIndex);
    return hr;
}

/*---------------------------------------------------------------------------
    CQmPolicyHandler::SortItems
        We are responsible for sorting of virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CQmPolicyHandler::SortItems
(
    int     nColumn, 
    DWORD   dwSortOptions, 
    LPARAM    lUserParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;

	if (nColumn >= DimensionOf(aColumns[IPSECMON_QM_POLICY]))
		return E_INVALIDARG;
	
	BEGIN_WAIT_CURSOR
	
	DWORD dwIndexType = aColumns[IPSECMON_QM_POLICY][nColumn];

	hr = m_spSpdInfo->SortQmPolicies(dwIndexType, dwSortOptions);
	
	END_WAIT_CURSOR
    return hrOK;
}

/*!--------------------------------------------------------------------------
    CQmPolicyHandler::OnResultUpdateView
        Implementation of ITFSResultHandler::OnResultUpdateView
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT CQmPolicyHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM        data, 
    LONG_PTR      hint
)
{
    HRESULT    hr = hrOK;
    SPITFSNode spSelectedNode;

    pComponent->GetSelectedNode(&spSelectedNode);
    if (spSelectedNode == NULL)
        return S_OK; // no selection for our IComponentData

    if ( hint == IPSECMON_UPDATE_STATUS )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);
        SPITFSNode spSelectedNode;

        pComponent->GetSelectedNode(&spSelectedNode);

        if (pNode == spSelectedNode)
        {       
            // if we are the selected node, then we need to update
            SPIResultData spResultData;

            CORg (pComponent->GetResultData(&spResultData));
            CORg (spResultData->SetItemCount((int) data, MMCLV_UPDATE_NOSCROLL));
        }
    }
    else
    {
        // we don't handle this message, let the base class do it.
        return CIpsmHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

COM_PROTECT_ERROR_LABEL;

    return hr;
}



/*!--------------------------------------------------------------------------
    CQmPolicyHandler::LoadColumns
        Set the correct column header and then call the base class
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CQmPolicyHandler::LoadColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
	//set column info
    return CIpsmHandler::LoadColumns(pComponent, cookie, arg, lParam);
}

/*---------------------------------------------------------------------------
    Command handlers
 ---------------------------------------------------------------------------*/

 
/*---------------------------------------------------------------------------
    CQmPolicyHandler::OnDelete
        Removes a service SA
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CQmPolicyHandler::OnDelete
(
    ITFSNode * pNode
)
{
    HRESULT         hr = S_FALSE;
    return hr;
}


/*---------------------------------------------------------------------------
    CQmPolicyHandler::UpdateStatus
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CQmPolicyHandler::UpdateStatus
(
    ITFSNode * pNode
)
{
    HRESULT             hr = hrOK;

    SPIComponentData    spComponentData;
    SPIConsole          spConsole;
    IDataObject *       pDataObject;
    SPIDataObject       spDataObject;
    int                 i = 0;
    
    Trace0("CQmPolicyHandler::UpdateStatus - Updating status for Filter");

    // force the listbox to update.  We do this by setting the count and 
    // telling it to invalidate the data
    CORg(m_spNodeMgr->GetComponentData(&spComponentData));
    CORg(m_spNodeMgr->GetConsole(&spConsole));
    
    // grab a data object to use
    CORg(spComponentData->QueryDataObject((MMC_COOKIE) pNode, CCT_RESULT, &pDataObject) );
    spDataObject = pDataObject;

    i = m_spSpdInfo->GetQmPolicyCount();
    CORg(spConsole->UpdateAllViews(pDataObject, i, IPSECMON_UPDATE_STATUS));

COM_PROTECT_ERROR_LABEL;

    return hr;
}

/*---------------------------------------------------------------------------
    Misc functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CQmPolicyHandler::InitData
        Initializes data for this node
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CQmPolicyHandler::InitData
(
    ISpdInfo *     pSpdInfo
)
{

    m_spSpdInfo.Set(pSpdInfo);

    return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\modenode.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
	ModeNode.h
		This file contains all of the "Main Mode" and "Quick Mode" 
		objects that appear in the scope pane of the MMC framework.
		The objects are:

    FILE HISTORY:
        
*/
#ifndef _HEADER_MODENODE
#define _HEADER_MODENODE

class CQmNodeHandler : public CIpsmHandler
{
// Interface
public:
    CQmNodeHandler(ITFSComponentData *pCompData);

    OVERRIDE_NodeHandler_GetString()
		{ return (nCol == 0) ? GetDisplayName() : NULL; }

    // base handler functionality we override
    OVERRIDE_BaseHandlerNotify_OnExpand();

public:
    // helper routines
	HRESULT	InitData(ISpdInfo * pSpdInfo);
	HRESULT UpdateStatus(ITFSNode * pNode);
    
    // CIpsmHandler overrides
    virtual HRESULT InitializeNode(ITFSNode * pNode);

// Implementation
private:

protected:
	SPISpdInfo         m_spSpdInfo;
   
};

class CMmNodeHandler : public CIpsmHandler
{
// Interface
public:
    CMmNodeHandler(ITFSComponentData *pCompData);

    OVERRIDE_NodeHandler_GetString()
		{ return (nCol == 0) ? GetDisplayName() : NULL; }

    // base handler functionality we override
    OVERRIDE_BaseHandlerNotify_OnExpand();

public:
    // helper routines
	HRESULT	InitData(ISpdInfo * pSpdInfo);
	HRESULT UpdateStatus(ITFSNode * pNode);
    
    // CIpsmHandler overrides
    virtual HRESULT InitializeNode(ITFSNode * pNode);

// Implementation
private:

protected:
	SPISpdInfo         m_spSpdInfo;
   
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\qmpolpp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    Servpp.h   
        Server properties header file

    FILE HISTORY:
        
*/

#if !defined(AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3358C__INCLUDED_)
#define AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3358C__INCLUDED_

#ifndef _SPDDB_H
#include "spddb.h"
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CQmPolGenProp dialog

class CQmPolGenProp : public CPropertyPageBase
{
    DECLARE_DYNCREATE(CQmPolGenProp)

// Construction
public:
    CQmPolGenProp();
    ~CQmPolGenProp();

// Dialog Data
    //{{AFX_DATA(CQmPolGenProp)
    enum { IDD = IDP_QM_POLICY_GENERAL };
    CListCtrl	m_listOffers;
    //}}AFX_DATA

    virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);

    // Context Help Support
    virtual DWORD * GetHelpMap() { return (DWORD *) &g_aHelpIDs_IDP_QM_POLICY_GENERAL[0]; }


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CQmPolGenProp)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CQmPolGenProp)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

	void PopulateOfferInfo();
};


class CQmPolicyProperties : public CPropertyPageHolderBase
{
    friend class CQmPolGenProp;

public:
    CQmPolicyProperties(ITFSNode *         pNode,
                      IComponentData *    pComponentData,
                      ITFSComponentData * pTFSCompData,
                      CQmPolicyInfo * pFltrInfo,
					  ISpdInfo *          pSpdInfo,
                      LPCTSTR             pszSheetName);
    virtual ~CQmPolicyProperties();

    ITFSComponentData * GetTFSCompData()
    {
        if (m_spTFSCompData)
            m_spTFSCompData->AddRef();
        return m_spTFSCompData;
    }

	HRESULT GetPolicyInfo(CQmPolicyInfo **ppPolInfo)
	{
		Assert(ppPolInfo);
		*ppPolInfo = &m_PolInfo;
		return hrOK;
	}


public:
    CQmPolGenProp			   m_pageGeneral;

protected:
	SPITFSComponentData     m_spTFSCompData;
	CQmPolicyInfo	m_PolInfo;
	SPISpdInfo				m_spSpdInfo;
    
    BOOL                    m_fSpdInfoLoaded;
};


#endif // !defined(AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\qmsapp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    Servpp.h   
        Server properties implementation file

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "QmSApp.h"
#include "spdutil.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// CQmSAProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CQmSAProperties::CQmSAProperties
(
    ITFSNode *				pNode,
    IComponentData *		pComponentData,
    ITFSComponentData *		pTFSCompData,
	CQmSA *					pSA,
    ISpdInfo *				pSpdInfo,
    LPCTSTR					pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
    //ASSERT(pFolderNode == GetContainerNode());

    m_bAutoDeletePages = FALSE; // we have the pages as embedded members

    AddPageToList((CPropertyPageBase*) &m_pageGeneral);

    Assert(pTFSCompData != NULL);
    m_spTFSCompData.Set(pTFSCompData);
    
    m_spSpdInfo.Set(pSpdInfo);

	m_SA = *pSA;

	m_bTheme = TRUE;
}

CQmSAProperties::~CQmSAProperties()
{
    RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CQmSAGenProp property page

IMPLEMENT_DYNCREATE(CQmSAGenProp, CPropertyPageBase)

CQmSAGenProp::CQmSAGenProp() : CPropertyPageBase(CQmSAGenProp::IDD)
{
    //{{AFX_DATA_INIT(CQmSAGenProp)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CQmSAGenProp::~CQmSAGenProp()
{
}

void CQmSAGenProp::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPageBase::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CQmSAGenProp)
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CQmSAGenProp, CPropertyPageBase)
    //{{AFX_MSG_MAP(CQmSAGenProp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQmSAGenProp message handlers

BOOL CQmSAGenProp::OnInitDialog() 
{
    CPropertyPageBase::OnInitDialog();
    
	PopulateSAInfo();	

    SetDirty(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CQmSAGenProp::PopulateSAInfo()
{
	CString st;
	
	CQmSAProperties * pSAProp;
	CQmSA	*	pSA;
	CMmFilterInfo * pFltrInfo;

	pSAProp = (CQmSAProperties *) GetHolder();
	Assert(pSAProp);

	pSAProp->GetSAInfo(&pSA);

	AddressToString(pSA->m_QmDriverFilter.m_SrcAddr, &st);
	GetDlgItem(IDC_QMSA_SRC)->SetWindowText(st);

	AddressToString(pSA->m_QmDriverFilter.m_DesAddr, &st);
	GetDlgItem(IDC_QMSA_DEST)->SetWindowText(st);

	PortToString(pSA->m_QmDriverFilter.m_SrcPort, &st);
	GetDlgItem(IDC_QMSA_SRC_PORT)->SetWindowText(st);

	PortToString(pSA->m_QmDriverFilter.m_DesPort, &st);
	GetDlgItem(IDC_QMSA_DEST_PORT)->SetWindowText(st);

	ProtocolToString(pSA->m_QmDriverFilter.m_Protocol, &st);
	GetDlgItem(IDC_QMSA_PROT)->SetWindowText(st);

	TnlEpToString(pSA->m_QmDriverFilter.m_Type, 
				  pSA->m_QmDriverFilter.m_MyTunnelEndpt, 
				  &st);
	GetDlgItem(IDC_QMSA_ME_TNL)->SetWindowText(st);

	TnlEpToString(pSA->m_QmDriverFilter.m_Type, 
				  pSA->m_QmDriverFilter.m_PeerTunnelEndpt, 
				  &st);
	GetDlgItem(IDC_QMSA_PEER_TNL)->SetWindowText(st);

    st = pSA->m_stPolicyName;
    if ( pSA->m_dwPolFlags & IPSEC_QM_POLICY_DEFAULT_POLICY )
    {
        AfxFormatString1(st, IDS_POL_DEFAULT_RESPONSE, (LPCTSTR) pSA->m_stPolicyName);
    }
	GetDlgItem(IDC_QMSA_NEGPOL)->SetWindowText(st);

	QmAlgorithmToString(QM_ALGO_AUTH, &pSA->m_SelectedOffer, &st);
	GetDlgItem(IDC_QMSA_AUTH)->SetWindowText(st);

	QmAlgorithmToString(QM_ALGO_ESP_CONF, &pSA->m_SelectedOffer, &st);
	GetDlgItem(IDC_QMSA_ESP_CONF)->SetWindowText(st);

	QmAlgorithmToString(QM_ALGO_ESP_INTEG, &pSA->m_SelectedOffer, &st);
	GetDlgItem(IDC_QMSA_ESP_INTEG)->SetWindowText(st);

	KeyLifetimeToString(pSA->m_SelectedOffer.m_Lifetime, &st);
	GetDlgItem(IDC_QMSA_KEYLIFE)->SetWindowText(st);

	BoolToString(pSA->m_SelectedOffer.m_fPFSRequired, &st);
	GetDlgItem(IDC_QMSA_PFS_ENABLE)->SetWindowText(st);

	PFSGroupToString(pSA->m_SelectedOffer.m_dwPFSGroup, &st);
	GetDlgItem(IDC_QMSA_PFS_GRP)->SetWindowText(st);
}


BOOL CQmSAGenProp::OnApply() 
{
    if (!IsDirty())
        return TRUE;

    UpdateData();

	//TODO
	//Do nothing at this time
	
	//CPropertyPageBase::OnApply();

    return TRUE;
}

BOOL CQmSAGenProp::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\qmsa.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
	FltrNode.h

    FILE HISTORY:
        
*/

#ifndef _QMSA_H
#define _QMSA_H

#ifndef _IPSMHAND_H
#include "ipsmhand.h"
#endif

#ifndef _SPDDB_H
#include "spddb.h"
#endif


/*---------------------------------------------------------------------------
	Class:	CQmSAHandler
 ---------------------------------------------------------------------------*/
class CQmSAHandler : public CIpsmHandler
{
public:
    CQmSAHandler(ITFSComponentData* pTFSComponentData);
	virtual ~CQmSAHandler();

// Interface
public:
	// base handler functionality we override
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_GetString()
			{ return (nCol == 0) ? GetDisplayName() : NULL; }

	// Base handler notifications we handle
	OVERRIDE_BaseHandlerNotify_OnExpand();
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();    

	// Result handler functionality we override
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();

    OVERRIDE_ResultHandler_OnGetResultViewType();
	OVERRIDE_ResultHandler_GetVirtualString(); 
	OVERRIDE_ResultHandler_GetVirtualImage();
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_HasPropertyPages();
	OVERRIDE_ResultHandler_CreatePropertyPages();

	STDMETHODIMP CacheHint(int nStartIndex, int nEndIndex);
	STDMETHODIMP SortItems(int     nColumn, 
						   DWORD   dwSortOptions,    
						   LPARAM  lUserParam);

    // base handler overrides
	virtual HRESULT LoadColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

	// CHandler overridden
    virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);

    // multi select support
    virtual const GUID * GetVirtualGuid(int nIndex) 
	{ 
		return &GUID_IpsmQmSANodeType; 
	}

public:
	// CMTIpsmHandler functionality
	virtual HRESULT  InitializeNode(ITFSNode * pNode);
	virtual int      GetImageIndex(BOOL bOpenImage);
	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

public:
	// implementation specific	
    HRESULT BuildDisplayName(CString * pstrDisplayName);
    HRESULT InitData(ISpdInfo * pSpdInfo);
    HRESULT UpdateStatus(ITFSNode * pNode);
    
// Implementation
private:
	// Command handlers
    HRESULT OnDelete(ITFSNode * pNode);

private:
    SPISpdInfo          m_spSpdInfo;
};


#endif _LINES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\qmsapp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    Servpp.h   
        Server properties header file

    FILE HISTORY:
        
*/

#if !defined(AFX_QMSAPP_H__037BF46A_6E87_11D1_93B6_00C04FC3358D__INCLUDED_)
#define AFX_QMSAPP_H__037BF46A_6E87_11D1_93B6_00C04FC3358D__INCLUDED_

#ifndef _SPDDB_H
#include "spddb.h"
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CQmSAGenProp dialog

class CQmSAGenProp : public CPropertyPageBase
{
    DECLARE_DYNCREATE(CQmSAGenProp)

// Construction
public:
    CQmSAGenProp();
    ~CQmSAGenProp();

// Dialog Data
    //{{AFX_DATA(CQmSAGenProp)
    enum { IDD = IDP_QM_SA_GENERAL };
    //}}AFX_DATA

    virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);

    // Context Help Support
    virtual DWORD * GetHelpMap() 
	{ 
		return (DWORD *) &g_aHelpIDs_IDP_QM_SA_GENERAL[0]; 
	}


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CQmSAGenProp)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CQmSAGenProp)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

	void PopulateSAInfo();
};


class CQmSAProperties : public CPropertyPageHolderBase
{
    friend class CQmSAGenProp;

public:
    CQmSAProperties(ITFSNode *    pNode,
                      IComponentData *		pComponentData,
                      ITFSComponentData *	pTFSCompData,
                      CQmSA *				pSA,
					  ISpdInfo *			pSpdInfo,
                      LPCTSTR				pszSheetName);
    virtual ~CQmSAProperties();

    ITFSComponentData * GetTFSCompData()
    {
        if (m_spTFSCompData)
            m_spTFSCompData->AddRef();
        return m_spTFSCompData;
    }

	HRESULT GetSAInfo(CQmSA ** ppSA)
	{
		Assert(ppSA);
		*ppSA = &m_SA;
		return hrOK;
	}

    HRESULT GetSpdInfo(ISpdInfo ** ppSpdInfo) 
    {   
        Assert(ppSpdInfo);
        *ppSpdInfo = NULL;
        SetI((LPUNKNOWN *) ppSpdInfo, m_spSpdInfo);
        return hrOK;
    }



public:
    CQmSAGenProp			   m_pageGeneral;

protected:
	SPITFSComponentData     m_spTFSCompData;
	CQmSA					m_SA;
	SPISpdInfo				m_spSpdInfo;
    
    BOOL                    m_fSpdInfoLoaded;
};


#endif // !defined(AFX_QMSAPP_H__037BF46A_6E87_11D1_93B6_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\redblack.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1998 - 2002   **/
/**********************************************************************/

#include "stdafx.h"
#include "redblack.h"

/*
    redblack.c

    Implementation of red-black binary tree insertion, deletion, and search.
    This algorithm efficiently guarantees that the tree depth will never exceed
    2*Lg(N), so a one million node tree would have a worst case depth of 40.
    This insertion implementation is non-recursive and very efficient (the
    average insertion speed is less than twice the average search speed).

    Author: Tom McGuire (tommcg) 1/98

    2/98, modified this version of redblack.c for debug symbol lookups.
    8/98, modified this version of redblack.h for generic name table.

*/

//
//  Rather than storing NULL links as NULL, we point NULL links to a special
//  "Empty" node which is always black and its children links point to itself.
//  We do this to simplify the color testing for children and grandchildren
//  such that any link can be dereferenced and even double-dereferenced without
//  explicitly checking for NULL.  The empty node must be colored black.
//

const NAME_NODE NameRbEmptyNode = { RBNIL, RBNIL };

extern PVOID __fastcall SubAllocate(IN HANDLE hAllocator, IN ULONG  Size);

ULONG
__fastcall
NameRbHash(
    IN LPCSTR Name,
    IN ULONG  Length
    )
    {
    ULONG Hash = ~Length;

    while ( Length-- ) {
        Hash = _rotl( Hash, 3 ) ^ *Name++;
        }

    return Hash;
    }


VOID
NameRbInitTree(
    IN OUT PNAME_TREE Tree,
    IN HANDLE SubAllocator
    )
    {
    Tree->Root = RBNIL;
    Tree->SubAllocator = SubAllocator;
    }


PNAME_NODE
NameRbFind(
    IN PNAME_TREE Tree,
    IN LPCSTR Name
    )
    {
    PNAME_NODE Node;
    ULONG      NameLength;
    ULONG      Hash;
    int        Compare;

    NameLength = strlen( Name );

    Hash = NameRbHash( Name, NameLength );

    Node = Tree->Root;

    while ( Node != RBNIL ) {

        if ( Hash < Node->Hash ) {
            Node = Node->Left;
            }
        else if ( Hash > Node->Hash ) {
            Node = Node->Right;
            }
        else {

            //
            //  Hashes equal, switch to strlen
            //

            do  {

                if ( NameLength < Node->NameLength ) {
                    Node = Node->Left;
                    }
                else if ( NameLength > Node->NameLength ) {
                    Node = Node->Right;
                    }
                else {

                    //
                    //  Lengths equal, switch to memcmp
                    //

                    do  {

                        Compare = memcmp( Name, Node->Name, NameLength );

                        if ( Compare == 0 ) {
                            return Node;
                            }
                        else if ( Compare < 0 ) {
                            Node = Node->Left;
                            }
                        else {
                            Node = Node->Right;
                            }
                        }

                    while ( Node != RBNIL );

                    }
                }

            while ( Node != RBNIL );

            }
        }

    return NULL;
    }


PNAME_NODE
NameRbInsert(
    IN OUT PNAME_TREE Tree,
    IN     LPCSTR Name
    )
    {
    PNAME_NODE * Stack[ MAX_DEPTH ];
    PNAME_NODE **StackPointer = Stack;
    PNAME_NODE * Link;
    PNAME_NODE   Node;
    PNAME_NODE   Sibling;
    PNAME_NODE   Parent;
    PNAME_NODE   Child;
    PNAME_NODE   NewNode;
    ULONG        NameLength;
    ULONG        Hash;
    int          Compare;

    NameLength = strlen( Name );

    Hash = NameRbHash( Name, NameLength );

    *StackPointer++ = &Tree->Root;

    Node = Tree->Root;

    //
    //  Walk down the tree to find either an existing node with the same key
    //  (in which case we simply return) or the insertion point for the new
    //  node.  At each traversal we need to store the address of the link to
    //  the next node so we can retrace the traversal path for balancing.
    //  The speed of insertion is highly dependent on traversing the tree
    //  quickly, so all balancing operations are deferred until after the
    //  traversal is complete.
    //

    while ( Node != RBNIL ) {

        if ( Hash < Node->Hash ) {
            *StackPointer++ = &Node->Left;
            Node = Node->Left;
            }
        else if ( Hash > Node->Hash ) {
            *StackPointer++ = &Node->Right;
            Node = Node->Right;
            }
        else {

            //
            //  Hashes equal, switch to strlen
            //

            do  {

                if ( NameLength < Node->NameLength ) {
                    *StackPointer++ = &Node->Left;
                    Node = Node->Left;
                    }
                else if ( NameLength > Node->NameLength ) {
                    *StackPointer++ = &Node->Right;
                    Node = Node->Right;
                    }
                else {

                    //
                    //  Lengths equal, switch to memcmp
                    //

                    do  {

                        Compare = memcmp( Name, Node->Name, NameLength );

                        if ( Compare == 0 ) {
                            return Node;
                            }
                        else if ( Compare < 0 ) {
                            *StackPointer++ = &Node->Left;
                            Node = Node->Left;
                            }
                        else {
                            *StackPointer++ = &Node->Right;
                            Node = Node->Right;
                            }
                        }

                    while ( Node != RBNIL );

                    }
                }

            while ( Node != RBNIL );

            }
        }


    //
    //  Didn't find a matching entry, so allocate a new node and add it
    //  to the tree.  Note that we're not allocating space for a terminator
    //  for the name data since we store the length of the name in the node.
    //

    NewNode = (PNAME_NODE)SubAllocate( Tree->SubAllocator, ( sizeof( NAME_NODE ) + NameLength ));

    if ( NewNode == NULL ) {
        return NULL;
        }

    NewNode->Left  = RBNIL;
    NewNode->Right = RBNIL;
    NewNode->Hash  = Hash;
    NewNode->NameLengthAndColorBit = NameLength | 0x80000000;   // MARK_RED
    memcpy( NewNode->Name, Name, NameLength );

    //
    //  Insert new node under last link we traversed.  The top of the stack
    //  contains the address of the last link we traversed.
    //

    Link = *( --StackPointer );
    *Link = NewNode;

    //
    //  Now walk back up the traversal chain to see if any balancing is
    //  needed.  This terminates in one of three ways: we walk all the way
    //  up to the root (StackPointer == Stack), or find a black node that
    //  we don't need to change (no balancing needs to be done above a
    //  black node), or we perform a balancing rotation (only one necessary).
    //

    Node = NewNode;
    Child = RBNIL;

    while ( StackPointer > Stack ) {

        Link = *( --StackPointer );
        Parent = *Link;

        //
        //  Node is always red here.
        //

        if ( IS_BLACK( Parent )) {

            Sibling = ( Parent->Left == Node ) ? Parent->Right : Parent->Left;

            if ( IS_RED( Sibling )) {

                //
                //  Both Node and its Sibling are red, so change them both to
                //  black and make the Parent red.  This essentially moves the
                //  red link up the tree so balancing can be performed at a
                //  higher level.
                //
                //        Pb                     Pr
                //       /  \       ---->       /  \
                //      Cr  Sr                 Cb  Sb
                //

                MARK_BLACK( Sibling );
                MARK_BLACK( Node );
                MARK_RED( Parent );
                }

            else {

                //
                //  This is a terminal case.  The Parent is black, and it's
                //  not going to be changed to red.  If the Node's child is
                //  red, we perform an appropriate rotation to balance the
                //  tree.  If the Node's child is black, we're done.
                //

                if ( IS_RED( Child )) {

                    if ( Node->Left == Child ) {

                        if ( Parent->Left == Node ) {

                            //
                            //       Pb             Nb
                            //      /  \           /  \
                            //     Nr   Z   to    Cr  Pr
                            //    /  \                / \
                            //   Cr   Y              Y   Z
                            //

                            MARK_RED( Parent );
                            Parent->Left = Node->Right;
                            Node->Right = Parent;
                            MARK_BLACK( Node );
                            *Link = Node;
                            }

                        else {

                            //
                            //       Pb                Cb
                            //      /  \              /  \
                            //     W    Nr    to     Pr   Nr
                            //         /  \         / \   / \
                            //        Cr   Z       W   X Y   Z
                            //       /  \
                            //      X    Y
                            //

                            MARK_RED( Parent );
                            Parent->Right = Child->Left;
                            Child->Left = Parent;
                            Node->Left = Child->Right;
                            Child->Right = Node;
                            MARK_BLACK( Child );
                            *Link = Child;
                            }
                        }

                    else {

                        if ( Parent->Right == Node ) {

                            MARK_RED( Parent );
                            Parent->Right = Node->Left;
                            Node->Left = Parent;
                            MARK_BLACK( Node );
                            *Link = Node;
                            }

                        else {

                            MARK_RED( Parent );
                            Parent->Left = Child->Right;
                            Child->Right = Parent;
                            Node->Right = Child->Left;
                            Child->Left = Node;
                            MARK_BLACK( Child );
                            *Link = Child;
                            }
                        }
                    }

                return NewNode;
                }
            }

        Child = Node;
        Node = Parent;
        }

    //
    //  We bubbled red up to the root -- restore it to black.
    //

    MARK_BLACK( Tree->Root );
    return NewNode;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\qmsa.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    provider.cpp
        Quick Mode SA node handler

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "server.h"
#include "QmSA.h"
#include "SpdUtil.h"
#include "QmSApp.h"

/*---------------------------------------------------------------------------
    Class CQmSAHandler implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    Constructor and destructor
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
CQmSAHandler::CQmSAHandler
(
    ITFSComponentData * pComponentData
) : CIpsmHandler(pComponentData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
}


CQmSAHandler::~CQmSAHandler()
{
}

/*!--------------------------------------------------------------------------
    CQmSAHandler::InitializeNode
        Initializes node specific data
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CQmSAHandler::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    CString strTemp;  
	strTemp.LoadString(IDS_QM_SA_NODE);
    SetDisplayName(strTemp);

    // Make the node immediately visible
    pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
    pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_FOLDER_CLOSED);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_FOLDER_OPEN);
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, IPSECMON_QM_SA);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

    SetColumnStringIDs(&aColumns[IPSECMON_QM_SA][0]);
    SetColumnWidths(&aColumnWidths[IPSECMON_QM_SA][0]);

    return hrOK;
}


/*---------------------------------------------------------------------------
    CQmSAHandler::GetImageIndex
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CQmSAHandler::GetImageIndex(BOOL bOpenImage) 
{
    int nIndex = -1;

    return nIndex;
}


/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CQmSAHandler::OnAddMenuItems
        Adds context menu items for the SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CQmSAHandler::OnAddMenuItems
(
    ITFSNode *              pNode,
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    LPDATAOBJECT            lpDataObject, 
    DATA_OBJECT_TYPES       type, 
    DWORD                   dwType,
    long *                  pInsertionAllowed
)
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    LONG        fFlags = 0, fLoadingFlags = 0;
    HRESULT     hr = S_OK;
    CString     strMenuItem;

    if (type == CCT_SCOPE)
    {
		//load scope node context menu items here
// these menu items go in the new menu,
// only visible from scope pane
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
        }
        
     }
    return hr; 
}

/*!--------------------------------------------------------------------------
    CQmSAHandler::AddMenuItems
        Adds context menu items for virtual list box (result pane) items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CQmSAHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
    MMC_COOKIE              cookie,
    LPDATAOBJECT            pDataObject, 
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    long *                  pInsertionAllowed
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT     hr = hrOK;
    CString     strMenuItem;
    SPINTERNAL  spInternal;
    LONG        fFlags = 0;

    spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or this SA
    // node itself.
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        //load and view menu items here
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CQmSAHandler::OnRefresh
        Default implementation for the refresh functionality
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CQmSAHandler::OnRefresh
(
    ITFSNode *      pNode,
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg,
    LPARAM          param
)
{
	HRESULT hr = S_OK;
    int i = 0; 
    SPIConsole      spConsole;

    CORg(CHandler::OnRefresh(pNode, pDataObject, dwType, arg, param));
	CORg(m_spSpdInfo->EnumQmSAs());
        
    i = m_spSpdInfo->GetQmSACount();
    
    // now notify the virtual listbox
    CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE));

Error:
	return hr;
}

/*---------------------------------------------------------------------------
    CQmSAHandler::OnCommand
        Handles context menu commands for SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CQmSAHandler::OnCommand
(
    ITFSNode *          pNode, 
    long                nCommandId, 
    DATA_OBJECT_TYPES   type, 
    LPDATAOBJECT        pDataObject, 
    DWORD               dwType
)
{

    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	//handle the scope context menu commands here

    return S_OK;
}

/*!--------------------------------------------------------------------------
    CQmSAHandler::Command
        Handles context menu commands for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CQmSAHandler::Command
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    int             nCommandID,
    LPDATAOBJECT    pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    SPITFSNode spNode;

    m_spResultNodeMgr->FindNode(cookie, &spNode);

	// handle result context menu and view menus here	

    return hr;
}

/*---------------------------------------------------------------------------
    CQmSAHandler::OnPropertyChange
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CQmSAHandler::OnPropertyChange
(   
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataobject, 
    DWORD           dwType, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    //CServerProperties * pServerProp = reinterpret_cast<CServerProperties *>(lParam);

    LONG_PTR changeMask = 0;

    // tell the property page to do whatever now that we are back on the
    // main thread
    //pServerProp->OnPropertyChange(TRUE, &changeMask);

    //pServerProp->AcknowledgeNotify();

    if (changeMask)
        pNode->ChangeNode(changeMask);

    return hrOK;
}

/*---------------------------------------------------------------------------
    CQmSAHandler::OnExpand
        Handles enumeration of a scope item
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CQmSAHandler::OnExpand
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    CORg (CIpsmHandler::OnExpand(pNode, pDataObject, dwType, arg, param));

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    CQmSAHandler::OnResultSelect
        Handles the MMCN_SELECT notifcation 
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CQmSAHandler::OnResultSelect
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie,
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    SPINTERNAL      spInternal;
    SPIConsole      spConsole;
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    int             i;
    LONG_PTR        dwNodeType;
	BOOL            fSelect = HIWORD(arg);
	IConsole2 *pConsole2 = NULL;

	//get pConsole2 for writing to the status bar, if fails not to worry
	pComponent->GetConsole(&pConsole2);

	// virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or the active
    // registrations node itself.
    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

	
	m_verbDefault = MMC_VERB_OPEN;
    if (!fSelect)
	{
		if(pConsole2) {
			pConsole2->SetStatusText(_T(""));
			pConsole2->Release();
		}
        return hr;
	}

    if (m_spSpdInfo)
    {
        DWORD dwInitInfo;

        dwInitInfo=m_spSpdInfo->GetInitInfo();
        if (!(dwInitInfo & MON_QM_SA)) {
            CORg(m_spSpdInfo->EnumQmSAs());            
            m_spSpdInfo->SetInitInfo(dwInitInfo | MON_QM_SA);
        }
        m_spSpdInfo->SetActiveInfo(MON_QM_SA);

        i = m_spSpdInfo->GetQmSACount();

        // now notify the virtual listbox
        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
        CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE) );

		if(pConsole2)
		{
			CString strTemp;
			WCHAR szTemp[20];
			wsprintf(szTemp, L"%d", i);
		    AfxFormatString1(strTemp, IDS_STATUS_NUM_ITEMS, szTemp);
			LPCTSTR szNumItems = (LPCTSTR) strTemp;
		    pConsole2->SetStatusText((LPOLESTR)szNumItems);
		    pConsole2->Release();
		}

    }

    // now update the verbs...
    spInternal = ExtractInternalFormat(pDataObject);
    Assert(spInternal);


    if (spInternal->HasVirtualIndex())
    {
		//TODO add to here if we want to have some result console verbs
        // we gotta do special stuff for the virtual index items
        dwNodeType = IPSECMON_QM_SA_ITEM;
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
		
		//enable the "properties" menu
		bStates[MMC_VERB_PROPERTIES & 0x000F] = TRUE;
		m_verbDefault = MMC_VERB_PROPERTIES;
    }
    else
    {
        // enable/disable delete depending if the node supports it
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
        dwNodeType = spNode->GetData(TFS_DATA_TYPE);

        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);

        //hide "delete" context menu
        bStates[MMC_VERB_DELETE & 0x000F] = FALSE;
    }

    EnableVerbs(spConsoleVerb, g_ConsoleVerbStates[dwNodeType], bStates);
	
COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*!--------------------------------------------------------------------------
    CQmSAHandler::OnDelete
        The base handler calls this when MMC sends a MMCN_DELETE for a 
        scope pane item.  We just call our delete command handler.
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CQmSAHandler::OnDelete
(
    ITFSNode *  pNode, 
    LPARAM      arg, 
    LPARAM      lParam
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
    CQmSAHandler::HasPropertyPages
        Handle the result notification
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CQmSAHandler::HasPropertyPages(
   ITFSComponent *pComponent,
   MMC_COOKIE cookie,
   LPDATAOBJECT pDataObject)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
    CQmSAHandler::HasPropertyPages
        Handle the result notification. Create the filter property sheet
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP CQmSAHandler::CreatePropertyPages
(
	ITFSComponent * 		pComponent, 
   MMC_COOKIE			   cookie,
   LPPROPERTYSHEETCALLBACK lpProvider, 
   LPDATAOBJECT 		 pDataObject, 
   LONG_PTR 			 handle
)
{

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT	hr = hrOK;

	SPINTERNAL  spInternal;
	SPITFSNode  spNode;
	int		nIndex;
	SPIComponentData spComponentData;
	CQmSA sa;
	CQmSAProperties * pProp;
    
 
	Assert(m_spNodeMgr);
	
	CORg( m_spNodeMgr->FindNode(cookie, &spNode) );
	CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

	spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node that is selected.
    // assert that this notification is for a virtual listbox item 
    Assert(spInternal);
    if (!spInternal->HasVirtualIndex())
        return hr;

    nIndex = spInternal->GetVirtualIndex();

	CORg(m_spSpdInfo->GetQmSAInfo(nIndex, &sa));

	pProp = new CQmSAProperties(
									spNode,
									spComponentData,
									m_spTFSCompData,
									&sa,
									m_spSpdInfo,
									NULL);

	hr = pProp->CreateModelessSheet(lpProvider, handle);

COM_PROTECT_ERROR_LABEL;

	return hr;
}


/*---------------------------------------------------------------------------
    CQmSAHandler::OnGetResultViewType
        Return the result view that this node is going to support
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CQmSAHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE            cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    if (cookie != NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;
    }

    return S_FALSE;
}

/*---------------------------------------------------------------------------
    CQmSAHandler::GetVirtualImage
        Returns the image index for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CQmSAHandler::GetVirtualImage
(
    int     nIndex
)
{
    return ICON_IDX_FILTER;
}

/*---------------------------------------------------------------------------
    CQmSAHandler::GetVirtualString
        returns a pointer to the string for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
LPCWSTR 
CQmSAHandler::GetVirtualString
(
    int     nIndex,
    int     nCol
)
{
	HRESULT hr = S_OK;
	static CString strTemp;

	strTemp.Empty();

	if (nCol >= DimensionOf(aColumns[IPSECMON_QM_SA]))
		return NULL;

	CQmSA sa;
	CORg(m_spSpdInfo->GetQmSAInfo(nIndex, &sa));

    switch (aColumns[IPSECMON_QM_SA][nCol])
    {
	case IDS_COL_QM_SA_POL:
		strTemp = sa.m_stPolicyName;
        if ( sa.m_dwPolFlags & IPSEC_QM_POLICY_DEFAULT_POLICY )
        {
            AfxFormatString1(strTemp, IDS_POL_DEFAULT_RESPONSE, (LPCTSTR) sa.m_stPolicyName);
        }
		return strTemp;
		break;
	case IDS_COL_QM_SA_AUTH:
		QmAlgorithmToString(QM_ALGO_AUTH, &sa.m_SelectedOffer, &strTemp);
		return strTemp;
		break;
	case IDS_COL_QM_SA_CONF:
		QmAlgorithmToString(QM_ALGO_ESP_CONF, &sa.m_SelectedOffer, &strTemp);
		return strTemp;
		break;
	case IDS_COL_QM_SA_INTEGRITY:
		QmAlgorithmToString(QM_ALGO_ESP_INTEG, &sa.m_SelectedOffer, &strTemp);
		return strTemp;
		break;
	case IDS_COL_QM_SA_SRC:
		AddressToString(sa.m_QmDriverFilter.m_SrcAddr, &strTemp);
		return strTemp;
		break;
	case IDS_COL_QM_SA_DEST:
		AddressToString(sa.m_QmDriverFilter.m_DesAddr, &strTemp);
		return strTemp;
		break;
	case IDS_COL_QM_SA_PROT:
		ProtocolToString(sa.m_QmDriverFilter.m_Protocol, &strTemp);
		return strTemp;
		break;
	case IDS_COL_QM_SA_SRC_PORT:
		PortToString(sa.m_QmDriverFilter.m_SrcPort, &strTemp);		
		return strTemp;
		break;
	case IDS_COL_QM_SA_DES_PORT:
		PortToString(sa.m_QmDriverFilter.m_DesPort, &strTemp);
		return strTemp;
		break;
	case IDS_COL_QM_SA_MY_TNL:
		TnlEpToString(sa.m_QmDriverFilter.m_Type, 
					sa.m_QmDriverFilter.m_MyTunnelEndpt, 
					&strTemp);
		return strTemp;
		break;
	case IDS_COL_QM_SA_PEER_TNL:
		TnlEpToString(sa.m_QmDriverFilter.m_Type, 
					sa.m_QmDriverFilter.m_PeerTunnelEndpt, 
					&strTemp);
		return strTemp;
		break;
    }

COM_PROTECT_ERROR_LABEL;

    return NULL;
}

/*---------------------------------------------------------------------------
    CQmSAHandler::CacheHint
        MMC tells us which items it will need before it requests things
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CQmSAHandler::CacheHint
(
    int nStartIndex, 
    int nEndIndex
)
{
    HRESULT hr = hrOK;;

    Trace2("CacheHint - Start %d, End %d\n", nStartIndex, nEndIndex);
    return hr;
}

/*---------------------------------------------------------------------------
    CQmSAHandler::SortItems
        We are responsible for sorting of virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CQmSAHandler::SortItems
(
    int     nColumn, 
    DWORD   dwSortOptions, 
    LPARAM    lUserParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (nColumn >= DimensionOf(aColumns[IPSECMON_QM_SA]))
		return E_INVALIDARG;
	
	BEGIN_WAIT_CURSOR
	
	DWORD dwIndexType = aColumns[IPSECMON_QM_SA][nColumn];

	m_spSpdInfo->SortQmSAs(dwIndexType, dwSortOptions);
	
	END_WAIT_CURSOR

    return hrOK;
}

/*!--------------------------------------------------------------------------
    CQmSAHandler::OnResultUpdateView
        Implementation of ITFSResultHandler::OnResultUpdateView
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT CQmSAHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM        data, 
    LONG_PTR      hint
)
{
    HRESULT    hr = hrOK;
    SPITFSNode spSelectedNode;

    pComponent->GetSelectedNode(&spSelectedNode);
    if (spSelectedNode == NULL)
        return S_OK; // no selection for our IComponentData

    if ( hint == IPSECMON_UPDATE_STATUS )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);
        SPITFSNode spSelectedNode;

        pComponent->GetSelectedNode(&spSelectedNode);

        if (pNode == spSelectedNode)
        {       
            
            // if we are the selected node, then we need to update
            SPIResultData spResultData;

            CORg (pComponent->GetResultData(&spResultData));
            CORg (spResultData->SetItemCount((int) data, MMCLV_UPDATE_NOSCROLL));
        }
    }
    else
    {
        // we don't handle this message, let the base class do it.
        return CIpsmHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

COM_PROTECT_ERROR_LABEL;

    return hr;
}



/*!--------------------------------------------------------------------------
    CQmSAHandler::LoadColumns
        Set the correct column header and then call the base class
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CQmSAHandler::LoadColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
	//set column info
    return CIpsmHandler::LoadColumns(pComponent, cookie, arg, lParam);
}

/*---------------------------------------------------------------------------
    Command handlers
 ---------------------------------------------------------------------------*/

 
/*---------------------------------------------------------------------------
    CQmSAHandler::OnDelete
        Removes a service SA
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CQmSAHandler::OnDelete
(
    ITFSNode * pNode
)
{
    HRESULT         hr = S_FALSE;
    return hr;
}


/*---------------------------------------------------------------------------
    CQmSAHandler::UpdateStatus
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CQmSAHandler::UpdateStatus
(
    ITFSNode * pNode
)
{
    HRESULT             hr = hrOK;

    SPIComponentData    spComponentData;
    SPIConsole          spConsole;
    IDataObject *       pDataObject;
    SPIDataObject       spDataObject;
    int                 i = 0;
    
    Trace0("CQmSAHandler::UpdateStatus - Updating status for Filter");

    // force the listbox to update.  We do this by setting the count and 
    // telling it to invalidate the data
    CORg(m_spNodeMgr->GetComponentData(&spComponentData));
    CORg(m_spNodeMgr->GetConsole(&spConsole));
    
    // grab a data object to use
    CORg(spComponentData->QueryDataObject((MMC_COOKIE) pNode, CCT_RESULT, &pDataObject) );
    spDataObject = pDataObject;

    i = m_spSpdInfo->GetQmSACount();
    CORg(spConsole->UpdateAllViews(pDataObject, i, IPSECMON_UPDATE_STATUS));

COM_PROTECT_ERROR_LABEL;

    return hr;
}

/*---------------------------------------------------------------------------
    Misc functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CQmSAHandler::InitData
        Initializes data for this node
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CQmSAHandler::InitData
(
    ISpdInfo *     pSpdInfo
)
{

    m_spSpdInfo.Set(pSpdInfo);

    return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\redblack.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1998 - 2002   **/
/**********************************************************************/


/*
    redblack.h

    Prototypes and node structure definition for red-black binary trees.
    See redblack.c for details and implementation.

    Author: Tom McGuire (tommcg) 1/98

    2/98, modified this version of redblack.h for debug symbol lookups.
    8/98, modified this version of redblack.h for generic name table.

*/

#ifndef _REDBLACK_H_
#define _REDBLACK_H_

#pragma warning( disable: 4200 )    // zero-sized array in struct/union

typedef struct _NAME_NODE NAME_NODE, *PNAME_NODE;
typedef struct _NAME_TREE NAME_TREE, *PNAME_TREE;

struct _NAME_NODE {
    PNAME_NODE Left;
    PNAME_NODE Right;
    ULONG      Hash;
    union {
      ULONG    NameLengthAndColorBit;
      struct {
        ULONG  NameLength:31;
        ULONG  Red:1;
        };
      };
    PVOID Context;
    CHAR  Name[ 0 ];
    };

struct _NAME_TREE {
    PNAME_NODE Root;
    HANDLE SubAllocator;
    };


#define RBNIL ((PNAME_NODE)&NameRbEmptyNode)

extern const NAME_NODE NameRbEmptyNode;


//
//  Although "Red" can be stored in its own 1-byte or 4-byte field, keeping the
//  nodes smaller by encoding "Red" as a one-bit field with another value
//  provides better performance (more nodes tend to stay in the cache).  To
//  provide flexibility in storage of the RED property, all references to RED
//  and BLACK are made through the following macros which can be changed as
//  necessary:
//

#define IS_RED( Node )            (   (Node)->Red )
#define IS_BLACK( Node )          ( ! (Node)->Red )
#define MARK_RED( Node )          (   (Node)->Red = 1 )
#define MARK_BLACK( Node )        (   (Node)->Red = 0 )

//
//  The maximum tree depth is 2*Lg(N).  Since we could never have more than
//  2^X nodes with X-bit pointers, we can safely say the absolute maximum
//  depth will be 2*Lg(2^X) which is 2*X.  The size of a pointer in bits is
//  its size in bytes times 8 bits, so 2*(sizeof(p)*8) is our maximum depth.
//  So for 32-bit pointers, our maximum depth is 64.
//
//  If you know the maximum possible number of nodes in advance (like the size
//  of the address space divided by the size of a node), you can tweak this
//  value a bit smaller to 2*Lg(N).  Note that it's important for this max
//  depth be evalutated to a constant value at compile time.
//
//  For this implementation, we'll assume the maximum number of nodes is
//  1 million, so the max depth is 40 (2*Lg(2^20)).  Note that no runtime
//  checks are made to ensure we don't exceed this number.
//

#define MAX_DEPTH 40


//
//  The following prototypes are the red-black tree interface.
//

VOID
NameRbInitTree(
    IN OUT PNAME_TREE Tree,
    IN HANDLE SubAllocator
    );

PNAME_NODE
NameRbInsert(
    IN OUT PNAME_TREE Tree,
    IN     LPCSTR Name
    );

PNAME_NODE
NameRbFind(
    IN PNAME_TREE Tree,
    IN LPCSTR Name
    );

#endif // _REDBLACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\resource.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ipsmsnap.rc
//
#define IDS_SNAPIN_DESC                 1
#define IDI_IPSECMON_SNAPIN             2
#define IDS_SIZE                        3
#define IDS_TYPE                        4
#define IDS_ROOT_NODENAME               5
#define IDS_ROOT_NAME                   6
#define IDS_SERVER_NAME                 7
#define IDC_STATS_REFRESH               8
#define IDS_COL_FLTR_NAME               9
#define IDS_FILTER_NODE                 10
#define IDS_COL_FLTR_SRC_TNL            11
#define IDS_COL_FLTR_DEST_TNL           12
#define IDS_QM_SA_NODE                  13
#define IDS_IPSECMON                    14
#define IDS_COL_FLTR_SRC                15
#define IDS_COL_FLTR_DEST               16
#define IDS_QUICK_MODE_NODENAME         17
#define IDS_SPECIFIC_FILTER_NODE        18
#define IDS_COL_FLTR_SRC_PORT           19
#define IDS_COL_FLTR_DEST_PORT          20
#define IDS_COL_FLTR_PROT               21
#define IDS_COL_FLTR_DIR                22
#define IDS_MAIN_MODE_NODENAME          23
#define IDS_COL_MM_POL_NAME             24
#define IDS_COL_MM_POL_OFFER            25
#define IDS_MM_POL_NODE                 26
#define IDS_COL_QM_POL_NAME             27
#define IDS_COL_QM_POL_OFFER            28
#define IDS_QM_POL_NODE                 29
#define IDS_SNAPIN_NAME                 30
#define IDS_SNAPIN_EXTENSION            31
#define IDS_MM_FILTER_NODE              32
#define IDS_MM_SP_FILTER_NODE           33
#define IDS_COL_FLTR_WEIGHT             34
#define IDS_MM_OFFER_PROP               35
#define IDS_COL_FLTR_FLAG               36
#define IDS_COL_MM_AUTH_METHOD          38
#define IDS_MM_AUTH_NODE                39
#define IDS_COL_MM_AUTH_GUID            40
#define IDS_STATS_TITLE                 41
#define IDS_STATS_NAME                  42
#define IDS_STATS_DATA                  43
#define IDS_COL_QM_POLICY               44
#define IDS_COL_MM_FLTR_POL             45
#define IDS_COL_MM_FLTR_AUTH            46
#define IDS_MM_SA_NODE                  47
#define IDS_COL_MM_SA_ME                48
#define IDS_COL_MM_SA_PEER              49
#define IDS_COL_MM_SA_AUTH              50
#define IDS_COL_MM_SA_ENCRYPITON        51
#define IDS_COL_MM_SA_INTEGRITY         52
#define IDS_COL_MM_SA_DH                53
#define IDS_COL_IF_TYPE                 54
#define IDS_COL_FLTR_OUT_FLAG           55
#define IDS_COL_FLTR_IN_FLAG            56
#define IDS_ACTIVE_POLICY               57
#define IDS_ACTPOL_ITEM                 58
#define IDS_ACTPOL_DESCR                59
#define IDS_ACTPOL_POLNAME              60
#define IDS_ACTPOL_POLDESCR             61
#define IDS_ACTPOL_LASTMODF             62
#define IDS_ACTPOL_POLSTORE             63
#define IDS_ACTPOL_OU                   64
#define IDS_ACTPOL_LOCAL                65
#define IDS_ACTPOL_DOMAIN               66
#define IDS_ACTPOL_NOACTPOL             67
#define IDS_ACTPOL_NA                   68
#define IDS_ACTPOL_POLPATH              69
#define IDS_ACTPOL_GPONAME              70
#define IDS_ACTPOL_NOTAVL               71
#define IDS_IKELOG_LEVEL1               72
#define IDS_IKELOG_SUMMARY              72
#define IDS_IKELOG_LEVEL2               73
#define IDS_IKELOG_DETAIL               73
#define IDS_IKELOG_LEVEL3               74
#define IDS_ERR_GETCONFIG_FAILED        74
#define IDS_ERR_SETCONFIG_FAILED        75
#define IDS_ACTPOL_DOMAIN_CACHED        76
#define IDS_ABOUT_DESCRIPTION           100
#define IDS_ABOUT_PROVIDER              101
#define IDS_ABOUT_VERSION               102
#define IDP_SERVER_REFRESH              140
#define IDB_16x16                       202
#define IDB_32x32                       203
#define IDB_ROOT_SMALL                  216
#define IDB_ROOT_LARGE                  217
#define IDP_FILTER_GENERAL              235
#define IDP_MM_POLICY_GENERAL           236
#define IDP_QM_POLICY_GENERAL           237
#define IDP_MM_FILTER_GENERAL           238
#define IDP_MM_AUTH                     239
#define IDD_SRCH_FLTRS                  240
#define IDD_MM_SRCH_FLTRS               241
#define IDD_ADD_COMPUTER                242
#define IDD_IPSM_STATS                  243
#define IDP_MM_SA_GENERAL               244
#define IDP_QM_SA_GENERAL               245
#define IDD_IKE_OPTIONS                 247
#define IDP_IKE_OPTIONS                 247
#define IDD_FILTER_RECORD               248
#define IDD_IKE_LOGSTATE                249
#define IDD_IKELOG_PROP                 250
#define IDI_ICON_LOGUP_ARROW            251
#define IDI_ICON_LOGDOWN_ARROW          252
#define IDI_ICON_ERR                    253
#define IDI_ICON_INFO                   254
#define IDI_ICON_UNKNOWN                255
#define IDI_ICON_WARN                   256
#define IDI_ICON_RECV_PKT               257
#define IDI_ICON_SEND_PKT               258
#define IDI_ICON_RESEND_PKT             261
#define IDD_IKELOG_ADVANCED             262
#define IDD_IKELOGVIEW_ADVANCED         263
#define IDD_IKE_LOGVIEWDEF              264
#define IDI_ICON_LOG_COPY               265
#define IDI_ICON06                      283
#define IDI_ICON07                      284
#define IDI_ICON05                      296
#define IDI_ICON01                      305
#define IDI_ICON02                      306
#define IDI_ICON03                      307
#define IDI_ICON04                      308
#define IDI_IPSM_FILTER                 309
#define IDI_IPSM_POLICY                 310
#define IDC_BUTTON_ADD_ADMIN            354
#define IDC_BUTTON_REMOVE_ADMIN         355
#define IDC_LIST_USERS                  356
#define IDC_EDIT_NAME                   357
#define IDC_EDIT_PASSWORD               358
#define IDC_CHECK_ENABLE_STATS          360
#define IDC_EDIT_MINUTES                361
#define IDC_EDIT_SECONDS                362
#define IDC_SPIN_MINUTES                364
#define IDC_STATIC_MINUTES              365
#define IDC_SPIN_SECONDS                366
#define IDC_CHECK_ENABLE_SERVER         367
#define IDC_LIST_ADMINS                 368
#define IDC_BUTTON_CHOOSE_USER          371
#define IDC_STATIC_ADMINS               372
#define IDC_STATIC_ACCOUNT              373
#define IDC_STATIC_USERNAME             374
#define IDC_STATIC_PASSWORD             375
#define IDC_STATIC_NOTE                 376
#define IDC_STATIC_LISTBOX              377
#define IDI_TELEPHONY                   378
#define IDC_LIST_DRIVERS                380
#define IDC_BUTTON_EDIT_DRIVER          381
#define IDC_LIST_NEW_DRIVERS            382
#define IDC_BUTTON_ADD_DRIVER           384
#define IDC_BUTTON_REMOVE_DRIVER        386
#define IDC_BUTTON_ADD_USER             387
#define IDC_BUTTON_REMOVE_USER          388
#define IDC_BUTTON_ADD_NEW_DRIVER       389
#define IDC_STATIC_ACCOUNT_INFO         390
#define IDC_EDIT_INFO                   393
#define IDC_LIST_SPECIFIC               394
#define IDC_FLTR_SRC_ADDR_EDIT          395
#define IDC_FLTR_SRC_ADDR               396
#define IDC_STATIC_SRC_MASK             397
#define IDC_STATIC_DEST_MASK            398
#define IDC_MM_POL_GEN_LIST             399
#define IDC_MM_POL_GEN_PROP             400
#define IDC_FLTR_SRC_MASK               401
#define IDC_LIST_MM_POL_AUTH            401
#define IDC_FLTR_IN_FLAG                402
#define IDC_CHECK_ENABLE_DNS            403
#define IDC_FLTR_SRC_PORT               404
#define IDC_SRCH_SRC_ANY                405
#define IDC_SRCH_SRC_SPEC               406
#define IDC_FLTR_PROTOCOL               407
#define IDC_SRCH_SRC_EDIT               408
#define IDC_FLTR_IF_TYPE                409
#define IDC_SRCH_DEST_ANY               410
#define IDC_FLTR_MIRROR                 411
#define IDC_SRCH_DEST_SPEC              412
#define IDC_FLTR_POLICY                 413
#define IDC_SRCH_DEST_EDIT              414
#define IDC_FLTR_OUT_FLAG               415
#define IDC_SRCH_PROTO                  416
#define IDC_FLTR_DEST_ADDR              417
#define IDC_SRCH_SRC_PORT               418
#define IDC_FLTR_DEST_MASK              419
#define IDC_SRCH_DEST_PORT              420
#define IDC_FLTR_DEST_PORT              421
#define IDC_SRCH_LIST                   422
#define IDC_QM_POL_GEN_LIST             423
#define IDC_SRCH_PROTO2                 424
#define IDC_MM_STATIC_SRC_MASK          425
#define IDC_MM_FLTR_SRC_ADDR            426
#define IDC_SRCH_INBOUND                427
#define IDC_MM_FLTR_SRC_MASK            428
#define IDC_SRCH_OUTBOUND               429
#define IDC_MM_FLTR_IF_TYPE             430
#define IDC_SEARCH                      431
#define IDC_MM_FLTR_MIRROR              432
#define IDC_SRCH_SRC_IP                 433
#define IDC_MM_FLTR_POLICY              434
#define IDC_SRCH_DEST_IP                435
#define IDC_MM_STATIC_DEST_MASK         436
#define IDC_SRCH_RADIO_BEST             437
#define IDC_MM_FLTR_DEST_ADDR           438
#define IDC_SRCH_RADIO_ALL              439
#define IDC_MM_FLTR_DEST_MASK           440
#define IDC_MM_SRCH_RADIO_BEST          441
#define IDC_MM_LIST_SPECIFIC            442
#define IDC_MM_SRCH_RADIO_ALL           443
#define IDC_MM_SRCH_SRC_ANY             445
#define IDC_MM_SRCH_SRC_SPEC            448
#define IDC_ADD_LOCAL                   449
#define IDC_STATS_QM_LIST               450
#define IDC_MM_SRCH_SRC_IP              451
#define IDC_ADD_OTHER                   452
#define IDC_MM_SRCH_DEST_ANY            453
#define IDC_ADD_EDIT_NAME               454
#define IDC_MM_SRCH_DEST_SPEC           455
#define IDC_BTN_BROWSE                  456
#define IDC_MM_SRCH_DEST_IP             457
#define IDC_MM_SRCH_INBOUND             459
#define IDC_STATS_MM_LIST               460
#define IDC_MM_SRCH_OUTBOUND            461
#define IDC_MM_SEARCH                   462
#define IDC_MM_SRCH_LIST                463
#define IDS_COL_QM_SA_POL               464
#define IDS_COL_QM_SA_AUTH              465
#define IDS_COL_QM_SA_CONF              467
#define IDS_COL_QM_SA_INTEGRITY         468
#define IDS_COL_QM_SA_SRC               469
#define IDS_COL_QM_SA_DEST              470
#define IDS_COL_QM_SA_PROT              471
#define IDS_COL_QM_SA_SRC_PORT          472
#define IDS_COL_QM_SA_DES_PORT          473
#define IDS_COL_QM_SA_MY_TNL            474
#define IDS_COL_QM_SA_PEER_TNL          475
#define IDC_MM_FLTR_DEST_ADDR_EDIT      476
#define IDS_POL_DEFAULT_RESPONSE        476
#define IDC_MM_FLTR_SRC_ADDR_EDIT       477
#define IDS_STATUS_NUM_ITEMS            477
#define IDS_POL_DEFAULT                 478
#define IDC_MMSA_IKE_POL                481
#define IDC_MMSA_LIST_QM                482
#define IDC_MMSA_AUTH                   483
#define IDC_MMSA_CONF                   484
#define IDC_MMSA_INTEG                  485
#define IDC_MMSA_KEYLIFE                486
#define IDC_MMSA_DH_GRP                 487
#define IDC_QMSA_PFS_ENABLE             488
#define IDC_FLTR_DEST_ADDR_EDIT         489
#define IDC_MMSA_ME                     490
#define IDC_MMSA_PEER                   492
#define IDC_QMSA_AUTH                   492
#define IDC_QMSA_ESP_CONF               493
#define IDC_QMSA_KEYLIFE                494
#define IDC_QMSA_PFS_GRP                495
#define IDC_QMSA_PROT                   496
#define IDC_QMSA_NEGPOL                 498
#define IDC_QMSA_ME_TNL                 499
#define IDC_QMSA_PEER_TNL               500
#define IDC_QMSA_SRC_PORT               501
#define IDC_QMSA_DEST_PORT              502
#define IDC_QMSA_DEST                   503
#define IDC_QMSA_SRC                    504
#define IDC_QMSA_ESP_INTEG              505
#define IDC_SRCH_PROTO_NUMBER           510
#define IDC_SRCH_PROTO_SPIN             512
#define IDC_STATIC_FLTR_SRC             513
#define IDC_STATIC_FLTR_SRC_PORT        514
#define IDC_STATIC_FLTR_SRC_ADDR        515
#define IDC_STATIC_FLTR_DEST_PORT       516
#define IDC_STATIC_FLTR_DEST_ADDR       517
#define IDC_STATIC_FLTR_IN_FLAG         518
#define IDC_STATIC_FLTR_OUT_FLAG        519
#define IDC_STATIC_FLTR_MIRROR          520
#define IDC_STATIC_FLTR_POLICY          521
#define IDC_STATIC_FLTR_PROTOCOL        522
#define IDC_STATIC_FLTR_IF_TYPE         523
#define IDC_STATIC_FLTR_DEST            524
#define IDC_STATIC_MM_FLTR_SRC_ADDR     525
#define IDC_STATIC_MM_FLTR_DEST_ADDR    526
#define IDC_STATIC_MM_FLTR_IF_TYPE      527
#define IDC_STATIC_MM_FLTR_MIRROR       528
#define IDC_STATIC_MM_FLTR_POLICY       529
#define IDC_STATIC_MM_FLTR_SRC          530
#define IDC_STATIC_MM_FLTR_DEST         531
#define IDC_STATIC_MMSA_ME              532
#define IDC_STATIC_MMSA_PEER            533
#define IDC_STATIC_MMSA_AUTH            534
#define IDC_STATIC_MMSA_IKE_POL         535
#define IDC_STATIC_MMSA_CONF            536
#define IDC_STATIC_MMSA_INTEG           537
#define IDC_STATIC_MMSA_DH_GRP          538
#define IDC_STATIC_MMSA_KEYLIFE         539
#define IDC_STATIC_QMSA_SRC             540
#define IDC_STATIC_QMSA_DEST            541
#define IDC_STATIC_QMSA_SRC_PORT        542
#define IDC_STATIC_QMSA_DEST_PORT       543
#define IDC_STATIC_QMSA_PROT            544
#define IDC_STATIC_QMSA_AUTH            545
#define IDC_STATIC_QMSA_ESP_INTEG       546
#define IDC_STATIC_QMSA_KEYLIFE         547
#define IDC_STATIC_QMSA_PFS_ENABLE      548
#define IDC_STATIC_QMSA_PFS_GRP         549
#define IDC_STATIC_QMSA_NEGPOL          550
#define IDC_STATIC_QMSA_ME_TNL          551
#define IDC_STATIC_QMSA_PEER_TNL        552
#define IDC_STATIC_QMSA_ESP_CONF        553
#define IDC_STATIC_INTERVAL             554
#define IDC_STATIC_SECONDS              555
#define IDC_STATIC_MMSA_OFFER           556
#define IDC_STATIC_QMSA_OFFER           557
#define IDC_SRCH_SRC_ANYPORT            558
#define IDC_SRCH_SRC_SPPORT             559
#define IDC_SRCH_DEST_ANYPORT           560
#define IDC_SRCH_DEST_SPPORT            561
#define IDC_SRCH_SRC_IP_TEXT            562
#define IDC_MM_SRCH_SRC_ME              562
#define IDC_SRCH_DEST_IP_TEXT           563
#define IDC_MM_SRCH_DST_ME              563
#define IDC_MM_SRCH_SRC_IP_TEXT         564
#define IDC_MM_SRCH_DEST_IP_TEXT        565
#define IDC_MM_SRCH_SRC_ME_COMBO        566
#define IDC_MM_SRCH_DST_ME_COMBO        567
#define IDC_SRCH_SRC_ME                 568
#define IDC_SRCH_DST_ME                 569
#define IDC_SRCH_SRC_ME_COMBO           570
#define IDC_SRCH_DST_ME_COMBO           571
#define IDC_CHECK_ENABLE_IKE_LOG        574
#define IDC_STATIC_LOG_IKE_DETAIL_LEVEL 576
#define IDC_IKE_DEBUG_LEVEL             578
#define IDC_COMBO_IKE_DEBUG_LEVEL       579
#define IDC_FILTER_FROM_COMBO           580
#define IDC_STATIC_IKE_LOGFILE_LOCATION 581
#define IDC_FILTER_TO_COMBO             581
#define IDC_IKE_LOGFILE_LOCATION        583
#define IDC_FILTER_FROM_DC              584
#define IDC_FILTER_FROM_DATE            584
#define IDC_IKE_ENABLE_CRL_CHECKING     585
#define IDC_CHECK_ENABLE_IKE_CRLCHECK   586
#define IDC_RADIO_IKE_CRL_LEVEL_1       588
#define IDC_RADIO_IKE_CRL_LEVEL_2       590
#define IDC_CHK_IKELOG_ENABLE           591
#define IDC_STATIC_IKELOG_LOGLEVEL      592
#define IDC_CHK_IKELOG_INFO             593
#define IDC_CHK_IKELOG_WARN             594
#define IDC_CHK_IKELOG_ERR              595
#define IDC_CHK_IKELOG_SEND             596
#define IDC_CHK_IKELOG_RECV             597
#define IDC_CHK_IKELOG_RESEND           598
#define IDC_EDIT_IKELOG_SIZE            599
#define IDC_COMBO_IKEADV_SRC_ADDRTYPE   600
#define IDC_COMBO_IKEADV_DEST_ADDRTYPE  601
#define IDC_COMBO_IKEADV_SRCME          602
#define IDC_COMBO_IKEADV_DSTME          603
#define IDC_STATIC_IKEADV_SRCIP         604
#define IDC_IKEADV_SRCIP                605
#define IDC_STATIC_IKEADV_SRCIPMSK      606
#define IDC_IKEADV_SRCIPMSK             607
#define IDC_STATIC_IKEADV_DSTIP         608
#define IDC_IKEADV_DSTIP                609
#define IDC_STATIC_IKEADV_DSTIPMSK      610
#define IDC_IKEADV_DSTIPMSK             611
#define IDC_STATIC_IKEADV_SRCDNS        612
#define IDC_EDIT_IKEADV_SRC_DNS         613
#define IDC_STATIC_IKEADV_DESTDNS       614
#define IDC_EDIT_IKEADV_DEST_DNS        615
#define IDC_BTN_IKEADV_SRC_DNSRES       616
#define IDC_BTN_IKEADV_DEST_DNSRES      617
#define IDC_IKELOGPROP_SRC              619
#define IDC_IKELOGPROP_DEST             620
#define IDC_IKELOGPROP_CATG             623
#define IDC_IKELOGPROP_TIMEST           624
#define IDC_IKELOGPROP_DETAIL           625
#define IDC_BTN_IKELOGPROP_MOVE_UP      626
#define IDC_BTN_IKELOGPROP_MOVE_DOWN    627
#define IDC_IKELOGPROP_COOKIE           628
#define IDC_IKELOGPROP_QMMESGID         629
#define IDC_IKELOGPROP_PARSER_TREE      630
#define IDC_BTN_IKELOGPROP_COPY         631
#define IDC_CHK_IKEVDLOG_INFO           632
#define IDC_CHK_IKEVDLOG_ERR            633
#define IDC_CHK_IKEVDLOG_WARN           634
#define IDC_CHK_IKEVDLOG_SEND           635
#define IDC_CHK_IKEVDLOG_RECV           636
#define IDC_CHK_IKEVDLOG_RESEND         637
#define IDC_COMBO_LOGVADV_SRC_ADDRTYPE  640
#define IDC_COMBO_LOGVADV_DEST_ADDRTYPE 642
#define IDC_STATIC_LOGVADV_SRCIP        643
#define IDC_LOGVADV_SRCIP               645
#define IDC_STATIC_LOGVADV_SRCMASK      646
#define IDC_LOGVADV_SRCMASK             648
#define IDC_STATIC_LOGVADV_DESTIP       649
#define IDC_LOGVADV_DESTIP              651
#define IDC_STATIC_LOGVADV_DESTMASK     652
#define IDC_LOGVADV_DESTMASK            654
#define IDC_COMBO_LOGVADV_SRCME         655
#define IDC_COMBO_LOGVADV_DESTME        656
#define IDC_STATIC_LOGVADV_DESTDNS      657
#define IDC_EDIT_LOGVADV_DEST_DNS       658
#define IDC_BTN_LOGVADV_DEST_DNSRES     659
#define IDC_EDIT_LOGVADV_SRC_DNS        660
#define IDC_BTN_LOGVADV_SRC_DNSRES      661
#define IDC_STATIC_LOGVADV_SRCDNS       662
#define IDC_STATIC_IKEADV_SRC_DNSIP     663
#define IDC_COMBO_IKEADV_SRC_DNSIP      664
#define IDC_STATIC_IKEADV_DST_DNSIP     665
#define IDC_COMBO_IKEADV_DST_DNSIP      666
#define IDC_STATIC_LOGVADV_SRC_DNSIP    667
#define IDC_COMBO_LOGVADV_SRC_DNSIP     668
#define IDC_STATIC_LOGVADV_DST_DNSIP    669
#define IDC_COMBO_LOGVADV_DST_DNSIP     670
#define IDS_ADD_MACHINE                 1000
#define IDS_MENU_RECONNECT              1001
#define IDS_MENU_STATISTICS             1004
#define IDS_VIEW_TASKPAD                1005
#define IDS_FILTER_PP_COL_DIRECTION     1009
#define IDS_FILTER_PP_COL_SRC           1010
#define IDS_FILTER_PP_COL_DEST          1011
#define IDS_FILTER_PP_COL_FLAG          1012
#define IDS_FILTER_PP_COL_WEIGHT        1013
#define IDS_MM_POL_GEN_ENCRYPTION       1014
#define IDS_MM_POL_GEN_AUTH             1015
#define IDS_MM_POL_GEN_DH               1016
#define IDS_MM_POL_GEN_QMLMT            1017
#define IDS_MM_POL_GEN_IKEAUTH          1018
#define IDS_DOI_AH_NONE                 1019
#define IDS_DOI_AH_MD5                  1020
#define IDS_DOI_AH_SHA                  1021
#define IDS_DOI_ESP_NONE                1022
#define IDS_DOI_ESP_DES                 1023
#define IDS_DOI_ESP_3_DES               1024
#define IDS_IKE_PRESHARED_KEY           1025
#define IDS_IKE_DSS_SIGNATURE           1026
#define IDS_IKE_RSA_SIGNATURE           1027
#define IDS_IKE_RSA_ENCRYPTION          1028
#define IDS_IKE_SSPI                    1029
#define IDS_HMAC_AH_MD5                 1030
#define IDS_HMAC_AH_SHA                 1031
#define IDS_QM_POL_GEN_AUTH             1032
#define IDS_QM_POL_GEN_ESP_CONF         1033
#define IDS_QM_POL_GEN_ESP_INTEG        1034
#define IDS_QM_POL_GEN_KEY_LIFE         1035
#define IDS_QM_POL_GEN_PFS              1036
#define IDS_QM_POL_GEN_PFS_GP           1037
#define IDS_DHGROUP_LOW                 1038
#define IDS_DHGROUP_MEDIUM              1039
#define IDS_DHGROUP_HIGH                1040
#define IDS_MM_POL_GEN_KEY_LIFE         1041
#define IDS_FLTR_SEARCH                 1042
#define IDS_MM_AUTH_METHOD              1043
#define IDS_MM_AUTH_DETAIL              1044
#define IDS_ADDR_ME                     1045
#define IDS_ADDR_ANY                    1046
#define IDS_MM_FLTR_SEARCH              1047
#define IDS_FILTER_PP_COL_POLICY        1048
#define IDS_FLTER_PP_COL_IKE_POL        1049
#define IDS_PFS_GROUP_DERIVED           1050
#define IDS_DHGROUP_UNASSIGNED          1051
#define IDS_PASS_THROUGH                1500
#define IDS_BLOCKING                    1501
#define IDS_NEG_SEC                     1502
#define IDS_PROTOCOL_ANY                1503
#define IDS_PROTOCOL_ICMP               1504
#define IDS_PROTOCOL_GGP                1505
#define IDS_PROTOCOL_TCP                1506
#define IDS_PROTOCOL_EGP                1507
#define IDS_PROTOCOL_PUP                1508
#define IDS_PROTOCOL_UDP                1509
#define IDS_PROTOCOL_HMP                1510
#define IDS_PROTOCOL_XNS_IDP            1511
#define IDS_PROTOCOL_RDP                1512
#define IDS_PROTOCOL_RVD                1513
#define IDS_IF_TYPE_ALL                 1514
#define IDS_IF_TYPE_LAN                 1515
#define IDS_IF_TYPE_RAS                 1516
#define IDS_UNKNOWN                     1517
#define IDS_YES                         1518
#define IDS_NO                          1519
#define IDS_FLTR_DIR_IN                 1520
#define IDS_FLTR_DIR_OUT                1521
#define IDS_KEY_LIFE_TIME               1522
#define IDS_ALGO_NONE                   1523
#define IDS_AUTH_PROP                   1524
#define IDS_FLTER_PP_COL_MM_AUTH        1525
#define IDS_STATS_QM_ACTIVE_SA          1526
#define IDS_STATS_QM_PENDING_KEY_OPS    1527
#define IDS_STATS_QM_KEY_ADDITION       1528
#define IDS_STATS_QM_KEY_DEL            1529
#define IDS_STATS_QM_REKEYS             1530
#define IDS_STATS_QM_ACTIVE_TNL         1531
#define IDS_STATS_QM_BAD_SPI            1532
#define IDS_STATS_QM_PKT_NOT_DECRYPT    1533
#define IDS_STATS_QM_PKT_NOT_AUTH       1534
#define IDS_STATS_QM_PKT_REPLAY         1535
#define IDS_STATS_QM_OFFLOAD_SA         1536
#define IDS_STATS_QM_ESP_BYTE_SENT      1537
#define IDS_STATS_QM_ESP_BYTE_RCV       1538
#define IDS_STATS_QM_AUTH_BYTE_SENT     1539
#define IDS_STATS_QM_ATTH_BYTE_RCV      1540
#define IDS_STATS_QM_TNL_BYTE_SENT      1541
#define IDS_STATS_QM_TNL_BYTE_RCV       1542
#define IDS_STATS_QM_OFFLOAD_BYTE_SENT  1543
#define IDS_STATS_QM_OFFLOAD_BYTE_RCV   1544
#define IDS_NOT_AVAILABLE               1545
#define IDS_PORT_ANY                    1546
#define IDS_STATS_MM_ACTIVE_ACQUIRE     1547
#define IDS_STATS_MM_ACTIVE_RCV         1548
#define IDS_STATS_QM_XPORT_BYTE_SENT    1549
#define IDS_STATS_MM_ACQUIRE_FAIL       1550
#define IDS_STATS_MM_RCV_FAIL           1551
#define IDS_STATS_MM_SEND_FAIL          1552
#define IDS_STATS_MM_ACQUIRE_HEAP_SIZE  1553
#define IDS_STATS_MM_RCV_HEAP_SIZE      1554
#define IDS_STATS_MM_NEG_FAIL           1556
#define IDS_STATS_MM_INVALID_COOKIE     1557
#define IDS_STATS_MM_TOTAL_ACQUIRE      1558
#define IDS_STATS_MM_TOTAL_GETSPI       1559
#define IDS_STATS_MM_TOTAL_KEY_ADD      1560
#define IDS_STATS_MM_TOTAL_KEY_UPDATE   1561
#define IDS_STATS_MM_GET_SPI_FAIL       1562
#define IDS_STATS_MM_KEY_ADD_FAIL       1563
#define IDS_STATS_MM_KEY_UPDATE_FAIL    1564
#define IDS_STATS_MM_ISADB_LIST_SIZE    1565
#define IDS_STATS_MM_CONN_LIST_SIZE     1566
#define IDS_STATS_MM_OAKLEY_MM          1567
#define IDS_STATS_MM_OAKLEY_QM          1568
#define IDS_STATS_QM_XPORT_BYTE_RCV     1569
#define IDS_OTHER_PROTO                 1570
#define IDS_STATS_MM_DEAD_ASSOCIATIONS  1571
#define IDS_STATS_MM_INACTIVE_ASSOCIATIONS 1572
#define IDS_STATS_MM_SOFT_ASSOCIATIONS  1573
#define IDS_STATS_QM_KEY_DELETION       1574
#define IDS_VIEW_ALL_FLTR               1575
#define IDS_VIEW_TRANSPORT_FLTR         1576
#define IDS_VIEW_TUNNEL_FLTR            1577
#define IDS_OTHER                       1578
#define IDS_STATS_MM_INVALID_PACKETS    1579
#define IDS_WARN_SERVER_DELETE          2000
#define IDS_ROOT_TASK_TITLE             3000
#define IDS_ROOT_TASK_GETTING_STARTED   3002
#define IDS_ROOT_TASK_GETTING_STARTED_HELP 3003
#define IDS_ROOT_TASK_ADD_SERVER        3006
#define IDS_ROOT_TASK_ADD_SERVER_HELP   3007
#define IDS_FILTER_EXT_DNS_SERVER       3008
#define IDS_FILTER_EXT_WINS_SERVER      3009
#define IDS_FILTER_EXT_DHCP_SERVER      3010
#define IDS_FILTER_EXT_DEF_GATEWAY      3011
#define IDS_FILTER_EXT_INTERNET_PROXY   3012
#define IDS_FILTER_EXT_HTTP_PROXY       3013
#define IDS_COL_LOGDATA_SOURCE          3014
#define IDS_COL_LOGDATA_DEST            3015
#define IDS_COL_LOGDATA_COMPNT          3016
#define IDS_COL_LOGDATA_CATGRY          3017
#define IDS_COL_LOGDATA_TIME            3018
#define IDS_COL_LOGDATA_MSG             3019
#define IDS_IPSECLOG_NODE               3020
#define IDS_FIRST_EVENT                 3021
#define IDS_LAST_EVENT                  3022
#define IDS_EVENTS_ON                   3023
#define IDS_INVALID_FROM_TO             3024
#define IDS_LOG_CATG_INFORMATION        3025
#define IDS_LOG_CATG_WARNING            3026
#define IDS_LOG_CATG_ERROR              3027
#define IDS_LOG_CATG_VERBOSE            3028
#define IDS_LOG_CATG_SEND_IKE_PAYLD     3029
#define IDS_LOG_CATG_RECV_IKE_PAYLD     3030
#define IDS_LOG_CATG_RESEND_IKE_PAYLD   3031
#define IDS_IKE_FLUSHLOG                3032
#define IDS_COL_LOGDATA_COOKIE_PAIR     3033
#define IDS_VIEW_INFO_IKELOGS           3034
#define IDS_VIEW_WARN_IKELOGS           3036
#define IDS_VIEW_ERR_IKELOGS            3037
#define IDS_VIEW_SENDPKT_IKELOGS        3038
#define IDS_VIEW_RECVPKT_IKELOGS        3039
#define IDS_VIEW_ALL_IKELOGS            3040
#define IDS_VIEW_RESENDPKT_IKELOGS      3041
#define IDS_LOGS_MYADDRESS              3042
#define IDS_LOGS_ANYADDRESS             3043
#define IDS_LOGS_IPADDRESS              3044
#define IDS_LOGS_IPSUBNET               3045
#define IDS_COL_LOGDATA_QMMSGID         3046
#define IDS_IKE_LOGVIEW_CUST            3047
#define IDS_IKE_LOGVIEW_CUST_PROP       3048
#define IDS_LOGS_DNSNAME                3049
#define IDS_LOGS_INFO_CLEAR_LOG         3050
#define IDS_LOGS_ERR_CLEAR_LOG          3051
#define IDS_LOGS_ERRINFO_STATUS_UPDATE  3052
#define IDS_LOGS_ERRINFO_SIG_FAILURE    3053
#define IDS_LOGS_ERRINFO_KERB_FAILURE   3054
#define IDS_LOGS_ERRINFO_PRESH_FAILURE  3055
#define IDS_LOGS_ERRINFO_CERT_FAILURE   3056
#define IDS_LOGS_ERRINFO_INVALID_PROP   3057
#define IDS_LOGS_ERRINFO_UNKNOWN        3058
#define IDS_LOGPV_ERR_DATA_LOAD         3059
#define IDS_LOGPV_WARN_SELECT_ONELOG    3060
#define IDS_LOGPV_WARN_SELECT_LOGSIZE   3061
#define IDS_LPGPV_SET_LOGSTATE_FAILED   3062
#define IDS_LOGPV_WARN_SRCDNS_NOTRESLV  3063
#define IDS_LOGPV_WARN_DSTDNS_NOTRESLV  3064
#define IDS_LPGPV_ERR_DNS_RESLV_FAILED  3065
#define IDS_IKELOGPROP_PROPTITLE        3068
#define IDS_LOGPP_COPY_MYADDR           3069
#define IDS_LOGPP_COPY_PEERADDR         3070
#define IDS_LOGPP_COPY_COOKIEPAIR       3071
#define IDS_LOGPP_COPY_MSGID            3072
#define IDS_LOGPP_COPY_CATEGORY         3073
#define IDS_LOGPP_COPY_TIMESTAMP        3074
#define IDS_LOGPP_COPY_DETAILS          3075
#define IDS_IKEEXCH_OAKNONE             3076
#define IDS_IKEEXCH_OAKBASE             3077
#define IDS_IKEEXCH_OAKMM               3078
#define IDS_IKEEXCH_OAKAUTHONLY         3079
#define IDS_IKEEXCH_OAKAGGR             3080
#define IDS_IKEEXCH_ISAKMPINFO          3081
#define IDS_IKEEXCH_OAKQM               3082
#define IDS_IKEEXCH_OAKNGM              3083
#define IDS_IKEEXCH_OAKUNKNOWN          3084
#define IDS_IKEPYLD_HASH                3085
#define IDS_IKEPYLD_KE                  3086
#define IDS_IKEPYLD_NONCE               3087
#define IDS_IKEPYLD_SA                  3088
#define IDS_IKEPYLD_PROP                3089
#define IDS_IKEPYLD_TRANS               3090
#define IDS_IKEPYLD_ID                  3091
#define IDS_IKEPYLD_CERT                3092
#define IDS_IKEPYLD_CERTREQ             3093
#define IDS_IKEPYLD_NOTIFY              3094
#define IDS_IKEPYLD_DELETE              3095
#define IDS_IKEPYLD_VENDORID            3096
#define IDS_IKEPYLD_SSPI                3097
#define IDS_IKEPYLD_NATDISC             3098
#define IDS_IKEPYLD_NATOA               3099
#define IDS_IKEPYLD_SIG                 3100
#define IDS_IKEPYLD_PAYLOAD             3101
#define IDS_IKEPYLD_PAYLOADCHN          3102
#define IDS_ERROR_NOMATCH_FILTER        3103
#define IDS_STATS_MM_ATTH_FAILURE       3104
#define IDS_COL_MM_SA_MYID              3105
#define IDS_COL_MM_SA_PEERID            3106
#define IDS_MENU_START_LOG              3107
#define IDS_MENU_STOP_LOG               3108
#define IDS_MENU_SAVE_LOG               3109
#define IDS_ERR_OUTOFMEMORY             3110
#define IDS_ERROR_LOG_EMPTY             3111
#define IDS_LOGPV_WARN_SELECT_ONELOGVIEW 3112
#define IDS_ERR_MESSAGE_GENERIC         5001
#define IDS_ERR_INVALID_INTEGER         5002
#define IDS_ERR_AUTO_REFRESH_ZERO       5003
#define IDS_ERR_SERVER_IN_LIST          5004
#define IDS_ERR_OLD_CONSOLE_FILE        5005
#define IDS_NO_STATUS                   5006
#define IDS_ERR_SERVER_NODE             5007
#define IDS_ERR_INVALID_PROTOCOLID      5008
#define IDS_ERR_INVALID_SRC_PORT        5009
#define IDS_ERR_INVALID_DEST_PORT       5010
#define IDS_LOCAL_SYSTEM_ACCOUNT        5011
#define IDS_ERR_USER_NOT_ADMIN          5012
#define IDS_ADMIN_ALREADY_IN_LIST       5013
#define IDS_USER_ALREADY_AUTHORIZED     5014
#define IDS_ACCOUNT_CHANGE_START        5015
#define IDS_ERR_NO_DIRECTION            5016
#define IDS_LSAERR_READ_FAILED          5017
#define IDS_LSAERR_WRITE_FAILED         5018
#define IDS_LSAERR_WRITE_SUCCEEDED      5019
#define IDS_ERR_EMPTY_NAME              5020
#define IDS_ERROR_MULTICAST             5021
#define IDS_ERROR_ZEROOCTET             5022
#define IDS_ERROR_NULLNETWORK           5023
#define IDS_ERROR_NULLHOST              5024
#define IDS_SOURCE_SUBNETADJUSTMENT     5025
#define IDS_DESTINATION_SUBNETADJUSTMENT 5026
#define IDS_ERROR_IPCLASSE              5027
#define IDS_ERROR_IPMASK                5028
#define IDS_INFO_SOURCESUBNETISADDRESS  5029
#define IDS_INFO_DESTSUBNETISADDRESS    5030
#define IDS_ERROR_SYMETRICFILTER        5031
#define IDS_ERR_BASE                    63000
#define IDS_ERR_SPD_DOWN                63001
#define IDS_ERR_SPD_UNAVAILABLE         63002
#define IDS_MESG_MAX                    65000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        266
#define _APS_NEXT_COMMAND_VALUE         32807
#define _APS_NEXT_CONTROL_VALUE         699
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\server.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    server.h

    FILE HISTORY:
        
*/

#ifndef _SERVER_H
#define _SERVER_H

#ifndef _IPSMHAND_H
#include "ipsmhand.h"
#endif

#ifndef _SPDDB_H
#include "spddb.h"
#endif


// options for the server outside of the API
#define IPSMSNAP_OPTIONS_REFRESH            0x00000001
#define IPSMSNAP_OPTIONS_EXTENSION          0x00000002
#define IPSMSNAP_OPTIONS_DNS                0x00000004

// custom data types for query object
#define IPSECMON_QDATA_REFRESH_STATS            0x00000001
#define IPSECMON_QDATA_FAILED					0x00000002

class CIpsmServer;

class CTimerDesc
{
public:
    SPITFSNode      spNode;
    CIpsmServer *   pServer;
    UINT_PTR        uTimer;
    TIMERPROC       timerProc;
};

typedef CArray<CTimerDesc *, CTimerDesc *> CTimerArrayBase;

class CTimerMgr : CTimerArrayBase
{
public:
    CTimerMgr();
    ~CTimerMgr();

public:
    int                 AllocateTimer(ITFSNode * pNode, CIpsmServer * pServer, UINT uTimerValue, TIMERPROC TimerProc);
    void                FreeTimer(UINT_PTR uEventId);
    void                ChangeInterval(UINT_PTR uEventId, UINT uNewInterval);
    CTimerDesc *        GetTimerDesc(UINT_PTR uEventId);
    CCriticalSection    m_csTimerMgr;
};

/*---------------------------------------------------------------------------
    Class:  CIpsmServer
 ---------------------------------------------------------------------------*/
class CIpsmServer : public CMTIpsmHandler
{
public:
    CIpsmServer(ITFSComponentData* pTFSComponentData);
    ~CIpsmServer();

// Interface
public:
    // base handler functionality we override
    OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
    OVERRIDE_NodeHandler_OnAddMenuItems();
    OVERRIDE_NodeHandler_OnCommand();
    OVERRIDE_NodeHandler_GetString()
            { return (nCol == 0) ? GetDisplayName() : NULL; }

    // Choose which messages we want to handle
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();    

    // Result handler functionality we override

    // CMTHandler overridden
    virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);

public:
    // CMTIpsmHandler functionality
    virtual HRESULT  InitializeNode(ITFSNode * pNode);
    virtual int      GetImageIndex(BOOL bOpenImage);
    ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);
    virtual void     OnHaveData(ITFSNode * pParentNode, ITFSNode * pNode);
	virtual void     OnHaveData(ITFSNode * pParentNode, LPARAM Data, LPARAM Type);

    STDMETHOD(OnNotifyExiting)(LPARAM);

    virtual void     GetErrorPrefix(ITFSNode * pNode, CString * pstrMessage)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        AfxFormatString1(*pstrMessage, IDS_ERR_SERVER_NODE, GetDisplayName());
    }
    
    virtual void    UpdateConsoleVerbs(IConsoleVerb * pConsoleVerb, LONG_PTR dwNodeType, BOOL bMultiSelect = FALSE);

public:
    // implementation specific  
    HRESULT BuildDisplayName(CString * pstrDisplayName);

    void    SetName(LPCTSTR pName) { m_strServerAddress = pName; }
    LPCTSTR GetName() { return m_strServerAddress; }

    HRESULT OnRefreshStats(ITFSNode *   pNode,
                           LPDATAOBJECT pDataObject,
                           DWORD        dwType,
                           LPARAM       arg,
                           LPARAM       param);

    void    SetOptions(DWORD dwOptions) { m_dwOptions = dwOptions; }
    DWORD   GetOptions() { return m_dwOptions; }

    HRESULT SetAutoRefresh(ITFSNode *  pNode, BOOL bOn, DWORD dwRefreshInterval);
    HRESULT SetDnsResolve(ITFSNode *  pNode, BOOL bEnable);
    BOOL    IsAutoRefreshEnabled() { return m_dwOptions & IPSMSNAP_OPTIONS_REFRESH; }
    DWORD   GetAutoRefreshInterval() { return m_dwRefreshInterval; }
    
    void    SetExtensionName();

// Implementation
private:
    // Command handlers
    HRESULT OnDelete(ITFSNode * pNode);

public:
    BOOL                m_bStatsOnly;

private:
	SPISpdInfo			m_spSpdInfo;

    CString             m_strServerAddress;
    
    DWORD               m_dwOptions;
    DWORD               m_dwRefreshInterval;
    
    int                 m_StatsTimerId;
};



/*---------------------------------------------------------------------------
    Class:  CIpsmServerQueryObj
 ---------------------------------------------------------------------------*/
class CIpsmServerQueryObj : public CIpsmQueryObj
{
public:
    CIpsmServerQueryObj(ITFSComponentData * pTFSComponentData,
                        ITFSNodeMgr *       pNodeMgr) 
            : CIpsmQueryObj(pTFSComponentData, pNodeMgr) {};
    
    STDMETHODIMP Execute();
    
public:
	SPISpdInfo			m_spSpdInfo;
    BOOL                m_bStatsOnly;
};

class HashEntry {
public:
    LIST_ENTRY Linkage;
    in_addr IpAddr;
    CString HostName;
}; 

#define HASH_TABLE_SIZE 128
#define TOTAL_TABLE_SIZE 129  //hash entries 0-127, Pending list is 128
#define PENDING_INDEX 128

//Callback for background resolver thread
UINT HashResolverCallback(LPVOID pParam);

class CHashTable {
public:
    CHashTable();
    ~CHashTable();
    DWORD AddPendingObject(in_addr IpAddr);
    DWORD AddObject(HashEntry *pHE);
    DWORD GetObject(HashEntry **ppHashEntry,in_addr IpAddr);
    HRESULT SetDnsResolve(BOOL bEnable);
    DWORD FlushTable();
    DWORD DnsResolve();

public:
    CCriticalSection m_csHashLock;
    BOOL m_bDnsResolveActive;
    BOOL m_bThreadRunning;

private:
    DWORD HashData(in_addr IPAddr);
    LIST_ENTRY HashTable[TOTAL_TABLE_SIZE];
};

#endif _SERVER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\servpp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    Servpp.h   
        Server properties implementation file

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "Servpp.h"
#include "server.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


BOOL IsLocalSystemAccount(LPCTSTR pszAccount)
{
    BOOL fLocal = FALSE;
    CString strLocalSystemAccount;

    if (pszAccount != NULL)
    {
        strLocalSystemAccount.LoadString(IDS_LOCAL_SYSTEM_ACCOUNT);

        if (strLocalSystemAccount.CompareNoCase(pszAccount) == 0)
            fLocal = TRUE;
    }

    return fLocal;
}

/////////////////////////////////////////////////////////////////////////////
//
// CMachineProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CMachineProperties::CMachineProperties
(
    ITFSNode *          pNode,
    IComponentData *    pComponentData,
    ITFSComponentData * pTFSCompData,
    ISpdInfo *          pSpdInfo,
    LPCTSTR             pszSheetName,
    BOOL                fSpdInfoLoaded
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName),
    m_fSpdInfoLoaded(fSpdInfoLoaded)
{
    //ASSERT(pFolderNode == GetContainerNode());

    m_bAutoDeletePages = FALSE; // we have the pages as embedded members

	AddPageToList((CPropertyPageBase*) &m_pageRefresh);

    Assert(pTFSCompData != NULL);
    m_spTFSCompData.Set(pTFSCompData);
    
    m_spSpdInfo.Set(pSpdInfo);

	m_bTheme = TRUE;
}

CMachineProperties::~CMachineProperties()
{
	RemovePageFromList((CPropertyPageBase*) &m_pageRefresh, FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// CMachinePropRefresh property page

IMPLEMENT_DYNCREATE(CMachinePropRefresh, CPropertyPageBase)

CMachinePropRefresh::CMachinePropRefresh() : CPropertyPageBase(CMachinePropRefresh::IDD)
{
    //{{AFX_DATA_INIT(CMachinePropRefresh)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CMachinePropRefresh::~CMachinePropRefresh()
{
}

void CMachinePropRefresh::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPageBase::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMachinePropRefresh)
    DDX_Control(pDX, IDC_EDIT_SECONDS, m_editSeconds);
    DDX_Control(pDX, IDC_EDIT_MINUTES, m_editMinutes);
    DDX_Control(pDX, IDC_SPIN_SECONDS, m_spinSeconds);
    DDX_Control(pDX, IDC_SPIN_MINUTES, m_spinMinutes);
    DDX_Control(pDX, IDC_CHECK_ENABLE_STATS, m_checkEnableStats);
    DDX_Control(pDX, IDC_CHECK_ENABLE_DNS, m_checkEnableDns);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMachinePropRefresh, CPropertyPageBase)
    //{{AFX_MSG_MAP(CMachinePropRefresh)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_STATS, OnCheckEnableStats)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_DNS, OnCheckEnableDns)
    ON_EN_CHANGE(IDC_EDIT_MINUTES, OnChangeEditMinutes)
    ON_EN_CHANGE(IDC_EDIT_SECONDS, OnChangeEditSeconds)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMachinePropRefresh message handlers

BOOL CMachinePropRefresh::OnInitDialog() 
{
    CPropertyPageBase::OnInitDialog();
    
    m_spinMinutes.SetRange(0, AUTO_REFRESH_MINUTES_MAX);
    m_spinSeconds.SetRange(0, AUTO_REFRESH_SECONDS_MAX);

    m_checkEnableStats.SetCheck(m_bAutoRefresh);
    m_checkEnableDns.SetCheck(m_bEnableDns);

    // update the refresh interval
    int nMinutes, nSeconds;
    DWORD dwRefreshInterval = m_dwRefreshInterval;

    nMinutes = dwRefreshInterval / MILLISEC_PER_MINUTE;
    dwRefreshInterval -= nMinutes * MILLISEC_PER_MINUTE;

    nSeconds = dwRefreshInterval / MILLISEC_PER_SECOND;
    dwRefreshInterval -= nSeconds * MILLISEC_PER_SECOND;

    m_spinMinutes.SetPos(nMinutes);
    m_spinSeconds.SetPos(nSeconds);

    m_editMinutes.LimitText(2);
    m_editSeconds.LimitText(2);

    // set the button states
    UpdateButtons();

    SetDirty(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CMachinePropRefresh::UpdateButtons()
{
    int nCheck = m_checkEnableStats.GetCheck();

    GetDlgItem(IDC_EDIT_MINUTES)->EnableWindow(nCheck != 0);
    GetDlgItem(IDC_EDIT_SECONDS)->EnableWindow(nCheck != 0);

    GetDlgItem(IDC_SPIN_MINUTES)->EnableWindow(nCheck != 0);
    GetDlgItem(IDC_SPIN_SECONDS)->EnableWindow(nCheck != 0);

    GetDlgItem(IDC_CHECK_ENABLE_DNS)->EnableWindow(nCheck != 0);


}

void CMachinePropRefresh::OnCheckEnableStats() 
{
    SetDirty(TRUE);
    
    UpdateButtons();    
}

void CMachinePropRefresh::OnCheckEnableDns() 
{
    SetDirty(TRUE);
    
    UpdateButtons();    
}

void CMachinePropRefresh::OnChangeEditMinutes() 
{
    ValidateMinutes();
    SetDirty(TRUE);
}

void CMachinePropRefresh::OnChangeEditSeconds() 
{
    ValidateSeconds();
    SetDirty(TRUE);
}

void CMachinePropRefresh::ValidateMinutes() 
{
    CString strValue;
    int nValue;

    if (m_editMinutes.GetSafeHwnd() != NULL)
    {
        m_editMinutes.GetWindowText(strValue);
        if (!strValue.IsEmpty())
        {
            nValue = _ttoi(strValue);

            if ((nValue >= 0) &&
                (nValue <= AUTO_REFRESH_MINUTES_MAX))
            {
                // everything is good
                return;
            }

            if (nValue > AUTO_REFRESH_MINUTES_MAX)
                nValue = AUTO_REFRESH_MINUTES_MAX;
            else
            if (nValue < 0)
                nValue = 0;

            // set the new value and beep
            CString strText;
            LPTSTR pBuf = strText.GetBuffer(5);
            
            _itot(nValue, pBuf, 10);
            strText.ReleaseBuffer();

            MessageBeep(MB_ICONEXCLAMATION);

            m_editMinutes.SetWindowText(strText);
            
            m_editMinutes.SetSel(0, -1);
            m_editMinutes.SetFocus();
        }
    }
}

void CMachinePropRefresh::ValidateSeconds() 
{
    CString strValue;
    int nValue;

    if (m_editSeconds.GetSafeHwnd() != NULL)
    {
        m_editSeconds.GetWindowText(strValue);
        if (!strValue.IsEmpty())
        {
            nValue = _ttoi(strValue);

            if ((nValue >= 0) &&
                (nValue <= AUTO_REFRESH_SECONDS_MAX))
            {
                // everything is good
                return;
            }
            
            if (nValue > AUTO_REFRESH_SECONDS_MAX)
                nValue = AUTO_REFRESH_SECONDS_MAX;
            else
            if (nValue < 0)
                nValue = 0;

            CString strText;
            LPTSTR pBuf = strText.GetBuffer(5);
            
            _itot(nValue, pBuf, 10);
            strText.ReleaseBuffer();

            MessageBeep(MB_ICONEXCLAMATION);

            m_editSeconds.SetWindowText(strText);
            
            m_editSeconds.SetSel(0, -1);
            m_editSeconds.SetFocus();
        }
    }
}

BOOL CMachinePropRefresh::OnApply() 
{
    if (!IsDirty())
        return TRUE;

    UpdateData();

    m_bAutoRefresh = (m_checkEnableStats.GetCheck() == 1) ? TRUE : FALSE;
    m_bEnableDns = (m_checkEnableDns.GetCheck() == 1) ? TRUE : FALSE;

    // Make sure that EnableDns only if AutoRefresh is enabled
    if (m_bEnableDns && !m_bAutoRefresh) {
        m_bEnableDns = FALSE;
    }

    int nMinutes = m_spinMinutes.GetPos();
    int nSeconds = m_spinSeconds.GetPos();

    
	//use minutes as seconds.
    m_dwRefreshInterval = nMinutes * MILLISEC_PER_MINUTE;
	m_dwRefreshInterval += nSeconds * MILLISEC_PER_SECOND;

    if (m_bAutoRefresh && m_dwRefreshInterval == 0)
    {
        CString strMessage;
        
        AfxMessageBox(IDS_ERR_AUTO_REFRESH_ZERO);
        m_editMinutes.SetSel(0, -1);
        m_editMinutes.SetFocus();

        return FALSE;
    }
    
    BOOL bRet = CPropertyPageBase::OnApply();

    if (bRet == FALSE)
    {
        // Something bad happened... grab the error code
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        ::IpsmMessageBox(GetHolder()->GetError());
    }

    return bRet;
}

BOOL CMachinePropRefresh::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
    SPITFSNode      spNode;
    CIpsmServer *   pServer;
    DWORD           dwError;

    // do stuff here.
    BEGIN_WAIT_CURSOR;

    spNode = GetHolder()->GetNode();
    pServer = GETHANDLER(CIpsmServer, spNode);

    pServer->SetAutoRefresh(spNode, m_bAutoRefresh, m_dwRefreshInterval);

    pServer->SetDnsResolve(spNode, m_bEnableDns);

    SPITFSNodeMgr   spNodeMgr;
    SPITFSNode spRootNode;

    spNode->GetNodeMgr(&spNodeMgr);
    spNodeMgr->GetRootNode(&spRootNode);
    spRootNode->SetData(TFS_DATA_DIRTY, TRUE);

    END_WAIT_CURSOR;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\root.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    root.cpp
        
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "root.h"
#include "server.h"
#include "tregkey.h"
#include "service.h"
#include "ncglobal.h"  // network console global defines
#include "addserv.h"

unsigned int g_cfMachineName = RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");

LPOLESTR g_RootTaskOverBitmaps[ROOT_TASK_MAX] = 
{
    L"/wlcmroll.bmp",
    L"/srvrroll.bmp",
};

LPOLESTR g_RootTaskOffBitmaps[ROOT_TASK_MAX] = 
{
    L"/wlcm.bmp",
    L"/srvr.bmp",
};

UINT g_RootTaskText[ROOT_TASK_MAX] = 
{
    IDS_ROOT_TASK_GETTING_STARTED,
    IDS_ROOT_TASK_ADD_SERVER,
};

UINT g_RootTaskHelp[ROOT_TASK_MAX] = 
{
    IDS_ROOT_TASK_GETTING_STARTED_HELP,
    IDS_ROOT_TASK_ADD_SERVER_HELP,
};

HRESULT
CRootTasks::Init(BOOL bExtension, BOOL bThisMachine, BOOL bNetServices)
{
    HRESULT     hr = hrOK;
    MMC_TASK    mmcTask;
    int         nPos = 0;
    int         nFinish = ROOT_TASK_MAX;

    m_arrayMouseOverBitmaps.SetSize(ROOT_TASK_MAX);
    m_arrayMouseOffBitmaps.SetSize(ROOT_TASK_MAX);
    m_arrayTaskText.SetSize(ROOT_TASK_MAX);
    m_arrayTaskHelp.SetSize(ROOT_TASK_MAX);

    // setup path for reuse
    OLECHAR szBuffer[MAX_PATH*2];    // that should be enough
    lstrcpy (szBuffer, L"res://");
    ::GetModuleFileName(_Module.GetModuleInstance(), szBuffer + lstrlen(szBuffer), MAX_PATH);
    OLECHAR * temp = szBuffer + lstrlen(szBuffer);

	if (bExtension)
		nPos = ROOT_TASK_MAX;
	/*
    if (bExtension && bThisMachine)
    {
        nPos = ROOT_TASK_MAX - 2;
        nFinish = ROOT_TASK_MAX - 1;
    }
    else
    if (bExtension && bNetServices)
    {
        nPos = ROOT_TASK_MAX - 1;
        nFinish = ROOT_TASK_MAX;
    }
	*/

    for (nPos; nPos < nFinish; nPos++)
    {
        m_arrayMouseOverBitmaps[nPos] = szBuffer;
        m_arrayMouseOffBitmaps[nPos] = szBuffer;
        m_arrayMouseOverBitmaps[nPos] += g_RootTaskOverBitmaps[nPos];
        m_arrayMouseOffBitmaps[nPos] += g_RootTaskOffBitmaps[nPos];

        m_arrayTaskText[nPos].LoadString(g_RootTaskText[nPos]);
        m_arrayTaskHelp[nPos].LoadString(g_RootTaskHelp[nPos]);

        AddTask((LPTSTR) (LPCTSTR) m_arrayMouseOverBitmaps[nPos], 
                (LPTSTR) (LPCTSTR) m_arrayMouseOffBitmaps[nPos], 
                (LPTSTR) (LPCTSTR) m_arrayTaskText[nPos], 
                (LPTSTR) (LPCTSTR) m_arrayTaskHelp[nPos], 
                MMC_ACTION_ID, 
                nPos);
    }
    
    return hr;
}



/*---------------------------------------------------------------------------
    CIpsmRootHandler::CIpsmRootHandler
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
CIpsmRootHandler::CIpsmRootHandler(ITFSComponentData *pCompData) : CIpsmHandler(pCompData)
{
    //m_bTaskPadView = FUseTaskpadsByDefault(NULL);
    m_bTaskPadView = FALSE;
}

/*!--------------------------------------------------------------------------
    CIpsmRootHandler::InitializeNode
        Initializes node specific data
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmRootHandler::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    CString strTemp;
    strTemp.LoadString(IDS_ROOT_NODENAME);

    SetDisplayName(strTemp);

    // Make the node immediately visible
    //pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, 0);
    pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_PRODUCT);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_PRODUCT);
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, IPSMSNAP_ROOT);

    SetColumnStringIDs(&aColumns[IPSMSNAP_ROOT][0]);
    SetColumnWidths(&aColumnWidths[IPSMSNAP_ROOT][0]);

    m_strTaskpadTitle.LoadString(IDS_ROOT_TASK_TITLE);

    return hrOK;
}

/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
    CIpsmRootHandler::GetString
        Implementation of ITFSNodeHandler::GetString
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CIpsmRootHandler::GetString
(
    ITFSNode *  pNode, 
    int         nCol
)
{
    if (nCol == 0 || nCol == -1)
        return GetDisplayName();
    else
        return NULL;
}


/*---------------------------------------------------------------------------
    CIpsmRootHandler::OnExpand
        Handles enumeration of a scope item
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmRootHandler::OnExpand
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    hr = CIpsmHandler::OnExpand(pNode, pDataObject, dwType, arg, param);

    if (dwType & TFS_COMPDATA_EXTENSION)
    {
        // we are extending somebody.  Get the computer name and check that machine
        hr = CheckMachine(pNode, pDataObject);
    }
    else
    {
        int iVisibleCount = 0;
        int iTotalCount = 0;

        pNode->GetChildCount(&iVisibleCount, &iTotalCount);

        if (0 == iTotalCount)
        {
            // check to see if we need to add the local machine to the list
            hr = CheckMachine(pNode, NULL);
        }
    }

    return hr;
}

/*---------------------------------------------------------------------------
    CIpsmRootHandler::OnAddMenuItems
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmRootHandler::OnAddMenuItems
(
    ITFSNode *              pNode,
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    LPDATAOBJECT            lpDataObject, 
    DATA_OBJECT_TYPES       type, 
    DWORD                   dwType,
    long *                  pInsertionAllowed
)
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    CString strMenuItem;

    if (type == CCT_SCOPE)
    {
        // these menu items go in the new menu, 
        // only visible from scope pane
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
            strMenuItem.LoadString(IDS_ADD_MACHINE);
            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                     strMenuItem, 
                                     IDS_ADD_MACHINE,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                     0 );
            ASSERT( SUCCEEDED(hr) );
        }
    }

    return hr; 
}

/*---------------------------------------------------------------------------
    CIpsmRootHandler::OnCommand
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmRootHandler::OnCommand
(
    ITFSNode *          pNode, 
    long                nCommandId, 
    DATA_OBJECT_TYPES   type, 
    LPDATAOBJECT        pDataObject, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;

    switch (nCommandId)
    {
        case IDS_ADD_MACHINE:
            OnAddMachine(pNode);
            break;

        default:
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsmRootHandler::AddMenuItems
        Over-ride this to add our view menu item
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmRootHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
    MMC_COOKIE              cookie,
    LPDATAOBJECT            pDataObject, 
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    long *                  pInsertionAllowed
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    CString strMenuItem;
/*
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        strMenuItem.LoadString(IDS_VIEW_TASKPAD);
        hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                 strMenuItem, 
                                 IDS_VIEW_TASKPAD,
                                 CCM_INSERTIONPOINTID_PRIMARY_VIEW, 
                                 (m_bTaskPadView) ? MF_CHECKED : 0 );
    }
*/
    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsmRootHandler::Command
        Handles commands for the current view
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmRootHandler::Command
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    int             nCommandID,
    LPDATAOBJECT    pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;

    switch (nCommandID)
    {
        case MMCC_STANDARD_VIEW_SELECT:
            m_bTaskPadView = FALSE;
            break;

        case IDS_VIEW_TASKPAD:
            {
                // if we are not viewing the taskpad presently, re-select the node
                // so that the taskpad is visible
                SPIConsole   spConsole;
                SPITFSNode   spNode;

                m_bTaskPadView = !m_bTaskPadView;

                m_spResultNodeMgr->FindNode(cookie, &spNode);
                m_spTFSCompData->GetConsole(&spConsole);
                spConsole->SelectScopeItem(spNode->GetData(TFS_DATA_SCOPEID));
            }
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsmRootHandler::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    NOTE: the root node handler has to over-ride this function to 
    handle the snapin manager property page (wizard) case!!!
    
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmRootHandler::HasPropertyPages
(
    ITFSNode *          pNode,
    LPDATAOBJECT        pDataObject, 
    DATA_OBJECT_TYPES   type, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    HRESULT hr = hrOK;
    
    if (dwType & TFS_COMPDATA_CREATE)
    {
        // This is the case where we are asked to bring up property
        // pages when the user is adding a new snapin.  These calls
        // are forwarded to the root node to handle.
        hr = hrFalse;
    }
    else
    {
        // we have property pages in the normal case
        hr = hrFalse;
    }
    return hr;
}

/*---------------------------------------------------------------------------
    CIpsmRootHandler::CreatePropertyPages
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmRootHandler::CreatePropertyPages
(
    ITFSNode *              pNode,
    LPPROPERTYSHEETCALLBACK lpProvider,
    LPDATAOBJECT            pDataObject, 
    LONG_PTR                handle, 
    DWORD                   dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = hrOK;
    HPROPSHEETPAGE hPage;

    Assert(pNode->GetData(TFS_DATA_COOKIE) == 0);
    
    if (dwType & TFS_COMPDATA_CREATE)
    {
        //
        // We are loading this snapin for the first time, put up a property
        // page to allow them to name this thing.
        // 
    }
    else
    {
        //
        // Object gets deleted when the page is destroyed
        //
    }

    return hr;
}

/*---------------------------------------------------------------------------
    CIpsmRootHandler::OnPropertyChange
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmRootHandler::OnPropertyChange
(   
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataobject, 
    DWORD           dwType, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    return hrOK;
}

/*!--------------------------------------------------------------------------
    CIpsmRootHandler::TaskPadNotify
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmRootHandler::TaskPadNotify
(
    ITFSComponent * pComponent,
    MMC_COOKIE      cookie,
    LPDATAOBJECT    pDataObject,
    VARIANT *       arg,
    VARIANT *       param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    if (arg->vt == VT_I4)
    {
        switch (arg->lVal)
        {
            case ROOT_TASK_GETTING_STARTED:
                {
                    SPIDisplayHelp spDisplayHelp;
                    SPIConsole spConsole;

                    pComponent->GetConsole(&spConsole);

                    HRESULT hr = spConsole->QueryInterface (IID_IDisplayHelp, (LPVOID*) &spDisplayHelp);
                    ASSERT (SUCCEEDED (hr));
                    if ( SUCCEEDED (hr) )
                    {
                        LPCTSTR pszHelpFile = m_spTFSCompData->GetHTMLHelpFileName();
                        if (pszHelpFile == NULL)
                            break;

                        CString szHelpFilePath;
                        UINT nLen = ::GetWindowsDirectory (szHelpFilePath.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
                        if (nLen == 0)
                            return E_FAIL;

                        szHelpFilePath.ReleaseBuffer();
                        szHelpFilePath += g_szDefaultHelpTopic;

                        hr = spDisplayHelp->ShowTopic (T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
                        ASSERT (SUCCEEDED (hr));
                    }
                }
                break;
            
            case ROOT_TASK_ADD_SERVER:
                {
                    SPITFSNode spNode;

                    m_spResultNodeMgr->FindNode(cookie, &spNode);
                    OnAddMachine(spNode);
                }
                break;

            default:
                Panic1("CIpsmRootHandler::TaskPadNotify - Unrecognized command! %d", arg->lVal);
                break;
        }
    }

    return hrOK;
}

/*!--------------------------------------------------------------------------
    CBaseResultHandler::EnumTasks
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmRootHandler::EnumTasks
(
    ITFSComponent * pComponent,
    MMC_COOKIE      cookie,
    LPDATAOBJECT    pDataObject,
    LPOLESTR        pszTaskGroup,
    IEnumTASK **    ppEnumTask
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    CRootTasks *    pTasks = NULL;
    SPIEnumTask     spEnumTasks;
    SPINTERNAL      spInternal = ExtractInternalFormat(pDataObject);
    BOOL            bExtension = FALSE;
    BOOL            bAddThisMachineTasks = FALSE;
    BOOL            bAddNetServicesTasks = FALSE;
    const CLSID *   pNodeClsid = &CLSID_IpsmSnapin;
    CString         strMachineGroup = NETCONS_ROOT_THIS_MACHINE;
    CString         strNetServicesGroup = NETCONS_ROOT_NET_SERVICES;
        
    if ((spInternal == NULL) || (*pNodeClsid != spInternal->m_clsid))
        bExtension = TRUE;

    if (bExtension && 
        strMachineGroup.CompareNoCase(pszTaskGroup) == 0)
    {
        // There are multiple taskpad groups in the network console
        // we need to make sure we are extending the correct one.
        bAddThisMachineTasks = TRUE;
    }

    if (bExtension && 
        strNetServicesGroup.CompareNoCase(pszTaskGroup) == 0)
    {
        // There are multiple taskpad groups in the network console
        // we need to make sure we are extending the correct one.
        bAddNetServicesTasks = TRUE;
    }

    COM_PROTECT_TRY
    {
        pTasks = new CRootTasks();
        spEnumTasks = pTasks;

        if (!(bExtension && !bAddThisMachineTasks && !bAddNetServicesTasks))
            CORg (pTasks->Init(bExtension, bAddThisMachineTasks, bAddNetServicesTasks));

        CORg (pTasks->QueryInterface (IID_IEnumTASK, (void **)ppEnumTask));
    
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsmRootHandler::TaskPadGetTitle
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmRootHandler::TaskPadGetTitle
(
    ITFSComponent * pComponent,
    MMC_COOKIE      cookie,
    LPOLESTR        pszGroup,
    LPOLESTR *      ppszTitle
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    *ppszTitle = (LPOLESTR) CoTaskMemAlloc (sizeof(OLECHAR)*(lstrlen(m_strTaskpadTitle)+1));
    if (!ppszTitle)
        return E_OUTOFMEMORY;

    lstrcpy (*ppszTitle, m_strTaskpadTitle);
   
    return S_OK;
}

/*---------------------------------------------------------------------------
    CIpsmRootHandler::OnGetResultViewType
        Return the result view that this node is going to support
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmRootHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    // if we aren't displaying the taskpad, use the default stuff...
    if (!m_bTaskPadView)
        return CIpsmHandler::OnGetResultViewType(pComponent, cookie, ppViewType, pViewOptions);

	//TODO Should we keep that?
    //
    // In this code we are defaulting to a taskpad view for this node all the time.
    // It is the snapins responsibility to put up a view menu selection that has a
    // selection for the taskpad. Do that in AddMenuItems.
    //
    //
    // We will use the default DHTML provided by MMC. It actually resides as a
    // resource inside MMC.EXE. We just get the path to it and use that.
    // The one piece of magic here is the text following the '#'. That is the special
    // way we have of identifying they taskpad we are talking about. Here we say we are
    // wanting to show a taskpad that we refer to as "CMTP1". We will actually see this
    // string pass back to us later. If someone is extending our taskpad, they also need
    // to know what this secret string is.
    //
    *pViewOptions = MMC_VIEW_OPTIONS_NONE;
    OLECHAR szBuffer[MAX_PATH*2]; // a little extra

    lstrcpy (szBuffer, L"res://");
    OLECHAR * temp = szBuffer + lstrlen(szBuffer);

	//TODO need to hook up the ipsecmon help file
    // get "res://"-type string for custom taskpad
    // the string after the # gets handed back to us in future calls...
    // should be unique for each node
    ::GetModuleFileName (NULL, temp, MAX_PATH);
    lstrcat (szBuffer, L"/default.htm#TAPIROOT");

    // alloc and copy bitmap resource string
    *ppViewType = (LPOLESTR)CoTaskMemAlloc (sizeof(OLECHAR)*(lstrlen(szBuffer)+1));

    if (!*ppViewType)
        return E_OUTOFMEMORY;   // or S_FALSE ???

    lstrcpy (*ppViewType, szBuffer);

    return S_OK;
}

/*!--------------------------------------------------------------------------
    CIpsmRootHandler::OnResultSelect
        For nodes with task pads, we override the select message to set 
        the selected node.  Nodes with taskpads do not get the MMCN_SHOW
        message which is where we normall set the selected node
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT CIpsmRootHandler::OnResultSelect(ITFSComponent *pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT hr = hrOK;

    CORg(DoTaskpadResultSelect(pComponent, pDataObject, cookie, arg, lParam, m_bTaskPadView));

    CORg(CIpsmHandler::OnResultSelect(pComponent, pDataObject, cookie, arg, lParam));

Error:
    return hr;
}


/*---------------------------------------------------------------------------
    Command handlers
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CIpsmRootHandler::OnAddMachine
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmRootHandler::OnAddMachine
(
    ITFSNode *  pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    HRESULT hr = hrOK;
    
    /*
    GETCOMPUTERSELECTIONINFO    info;
    PDSSELECTIONLIST    pSelList = NULL;

    LPCTSTR attrs[] = {_T("dNSHostName")};

    ZeroMemory(&info, sizeof(GETCOMPUTERSELECTIONINFO));
    info.cbSize = sizeof(GETCOMPUTERSELECTIONINFO);
    info.hwndParent = FindMMCMainWindow();
    info.flObjectPicker = 0; // not allow multiple selection
    info.flDsObjectPicker = DSOP_SCOPE_DIRECTORY | 
                            DSOP_SCOPE_DOMAIN_TREE | 
                            DSOP_SCOPE_EXTERNAL_TRUSTED_DOMAINS;
    info.flStartingScope = DSOP_SCOPE_DIRECTORY;
    info.ppDsSelList = &pSelList;
    info.cRequestedAttributes = 1;
    info.aptzRequestedAttributes = attrs;

    hr = GetComputerSelection(&info);
    if(hr != S_OK)  // assume the API will display error message, if there is
        return hr;

    CString strTemp = pSelList->aDsSelection[0].pwzName;
    if (strTemp.Left(2) == _T("\\\\"))
        strTemp = pSelList->aDsSelection[0].pwzName[2];
    */
	
	CAddServ	dlgAddServ(CWnd::FromHandle(FindMMCMainWindow()));
	if (IDOK != dlgAddServ.DoModal())
	{
		return hr;
	}
	
	CString strTemp = dlgAddServ.m_stComputerName;

    // if the machine is already in the list, don't bother.
    if (IsServerInList(pNode, strTemp))
    {
        AfxMessageBox(IDS_ERR_SERVER_IN_LIST);
    }
    else
    {
        AddServer(_T(""), strTemp, TRUE, IPSMSNAP_OPTIONS_REFRESH, IPSECMON_REFRESH_INTERVAL_DEFAULT);
    }

    return hr;
}

/*---------------------------------------------------------------------------
    CIpsmRootHandler::AddServer
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmRootHandler::AddServer
(
    LPCWSTR          pServerIp,
    LPCTSTR          pServerName,
    BOOL             bNewServer,
    DWORD            dwServerOptions,
    DWORD            dwRefreshInterval,
    BOOL             bExtension,
    DWORD            dwLineBuffSize,
    DWORD            dwPhoneBuffSize
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    CIpsmServer *       pServer = NULL;
    SPITFSNodeHandler   spHandler;
    SPITFSNode          spNode, spRootNode;

    // Create a handler for the node
    try
    {
        pServer = new CIpsmServer(m_spTFSCompData);
        //pServer->SetName(pServerName);
        
        // Do this so that it will get released correctly
        spHandler = pServer;
    }
    catch(...)
    {
        hr = E_OUTOFMEMORY;
    }
    CORg( hr );
    
    //
    // Create the server container information
    // 
    CreateContainerTFSNode(&spNode,
                           &GUID_IpsmServerNodeType,
                           pServer,
                           pServer,
                           m_spNodeMgr);

    // Tell the handler to initialize any specific data
    pServer->SetName(pServerName);
    
    pServer->InitializeNode((ITFSNode *) spNode);

    if (dwServerOptions & IPSMSNAP_OPTIONS_EXTENSION)
    {
        pServer->SetExtensionName();
    }

    // Mask out the auto refresh option because we set it next
    pServer->SetOptions(dwServerOptions & ~IPSMSNAP_OPTIONS_REFRESH);

    // if we got a valid refresh interval, then set it.
    pServer->SetAutoRefresh(spNode, dwServerOptions & IPSMSNAP_OPTIONS_REFRESH, dwRefreshInterval);

    pServer->SetDnsResolve(spNode, dwServerOptions & IPSMSNAP_OPTIONS_DNS);

    AddServerSortedName(spNode, bNewServer);

    if (bNewServer)
    {
        // need to get our node descriptor
        CORg(m_spNodeMgr->GetRootNode(&spRootNode));
        spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
    CIpsmRootHandler::IsServerInList
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
BOOL
CIpsmRootHandler::IsServerInList
(
    ITFSNode *      pRootNode,
    LPCTSTR         pszMachineName
)
{
    HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spCurrentNode;
    ULONG           nNumReturned = 0;
    DWORD           dwIpAddressCurrent;
    BOOL            bFound = FALSE;
    CString         strNewName = pszMachineName;

    // get the enumerator for this node
    pRootNode->GetEnum(&spNodeEnum);

    spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
    {
        // walk the list of servers and see if it already exists
        CIpsmServer * pServer = GETHANDLER(CIpsmServer, spCurrentNode);
        if (strNewName.CompareNoCase(pServer->GetName()) == 0)
        {
            bFound = TRUE;
            break;
        }

        // get the next Server in the list
        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    }

    return bFound;
}

/*---------------------------------------------------------------------------
    CIpsmRootHandler::AddServerSortedIp
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmRootHandler::AddServerSortedIp
(
    ITFSNode *      pNewNode,
    BOOL            bNewServer
)
{
    HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spCurrentNode;
    SPITFSNode      spPrevNode;
    SPITFSNode      spRootNode;
    ULONG           nNumReturned = 0;
    DWORD           dwIpAddressCurrent = 0;
    DWORD           dwIpAddressTarget;

    CIpsmServer *   pServer;

    // get our target address
    pServer = GETHANDLER(CIpsmServer, pNewNode);
    //pServer->GetIpAddress(&dwIpAddressTarget);

    // need to get our node descriptor
    CORg(m_spNodeMgr->GetRootNode(&spRootNode));

    // get the enumerator for this node
    CORg(spRootNode->GetEnum(&spNodeEnum));

    CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
    while (nNumReturned)
    {
        // walk the list of servers and see if it already exists
        pServer = GETHANDLER(CIpsmServer, spCurrentNode);
        //pServer->GetIpAddress(&dwIpAddressCurrent);

        //if (dwIpAddressCurrent > dwIpAddressTarget)
        //{
            // Found where we need to put it, break out
            break;
        //}

        // get the next Server in the list
        spPrevNode.Set(spCurrentNode);

        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    }

    // Add the node in based on the PrevNode pointer
    if (spPrevNode)
    {
        if (bNewServer)
        {
            if (spPrevNode->GetData(TFS_DATA_SCOPEID) != NULL)
            {
                pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_PREVIOUS);
                pNewNode->SetData(TFS_DATA_RELATIVE_SCOPEID, spPrevNode->GetData(TFS_DATA_SCOPEID));
            }
        }
        
        CORg(spRootNode->InsertChild(spPrevNode, pNewNode));
    }
    else
    {   
        // add to the head
        if (m_bExpanded)
        {
            pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_FIRST);
        }
        CORg(spRootNode->AddChild(pNewNode));
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
    CIpsmRootHandler::AddServerSortedName
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmRootHandler::AddServerSortedName
(
    ITFSNode *      pNewNode,
    BOOL            bNewServer
)
{
    HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spCurrentNode;
    SPITFSNode      spPrevNode;
    SPITFSNode      spRootNode;
    ULONG           nNumReturned = 0;
    CString         strTarget, strCurrent;

    CIpsmServer *   pServer;

    // get our target address
    pServer = GETHANDLER(CIpsmServer, pNewNode);
    strTarget = pServer->GetName();

    // need to get our node descriptor
    CORg(m_spNodeMgr->GetRootNode(&spRootNode));

    // get the enumerator for this node
    CORg(spRootNode->GetEnum(&spNodeEnum));

    CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
    while (nNumReturned)
    {
        // walk the list of servers and see if it already exists
        pServer = GETHANDLER(CIpsmServer, spCurrentNode);
        strCurrent = pServer->GetName();

        if (strTarget.Compare(strCurrent) < 0)
        {
            // Found where we need to put it, break out
            break;
        }

        // get the next Server in the list
        spPrevNode.Set(spCurrentNode);

        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    }

    // Add the node in based on the PrevNode pointer
    if (spPrevNode)
    {
        if (bNewServer)
        {
            if (spPrevNode->GetData(TFS_DATA_SCOPEID) != NULL)
            {
                pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_PREVIOUS);
                pNewNode->SetData(TFS_DATA_RELATIVE_SCOPEID, spPrevNode->GetData(TFS_DATA_SCOPEID));
            }
        }
        
        CORg(spRootNode->InsertChild(spPrevNode, pNewNode));
    }
    else
    {   
        // add to the head
        if (m_bExpanded)
        {
            pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_FIRST);
        }
        CORg(spRootNode->AddChild(pNewNode));
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
    CIpsmRootHandler::CheckMachine
        adds the machine to the list of servers.
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmRootHandler::CheckMachine
(
    ITFSNode *      pRootNode,
    LPDATAOBJECT    pDataObject
)
{
    HRESULT hr = hrOK;

    // Get the local machine name and check to see if the service
    // is installed.
    CString strMachineName;
    LPTSTR  pBuf;
    DWORD   dwLength = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL    bExtension = (pDataObject != NULL);
    
    if (!bExtension)
    {
        pBuf = strMachineName.GetBuffer(dwLength);
        GetComputerName(pBuf, &dwLength);
        strMachineName.ReleaseBuffer();
    }
    else
    {
        strMachineName = Extract<TCHAR>(pDataObject, (CLIPFORMAT) g_cfMachineName, COMPUTERNAME_LEN_MAX);
    }

    if (strMachineName.IsEmpty())
    {
        DWORD   dwSize = MAX_COMPUTERNAME_LENGTH + 1;
        pBuf = strMachineName.GetBuffer(dwSize);
    
        ::GetComputerName(pBuf, &dwSize);
    
        strMachineName.ReleaseBuffer();
    }

    // if the machine is already in the list, don't bother.
    if (IsServerInList(pRootNode, strMachineName))
        return hr;

    if (bExtension)
        RemoveOldEntries(pRootNode, strMachineName);

    // we always add the local machine or whatever machine we are pointed at even if 
    // we are an extension

    // OK.  add it to the list.
    DWORD dwFlags = 0;

    if (bExtension)
        dwFlags |= IPSMSNAP_OPTIONS_EXTENSION;

    dwFlags |= IPSMSNAP_OPTIONS_REFRESH;

    AddServer(_T(""), strMachineName, TRUE, dwFlags, IPSECMON_REFRESH_INTERVAL_DEFAULT, bExtension);

    return hr;
}

// when running as an extension, it is possible that we were saved as "local machine"
// which means that if the saved console file was moved to another machine we need to remove 
// the old entry that was saved
HRESULT 
CIpsmRootHandler::RemoveOldEntries(ITFSNode * pNode, LPCTSTR pszAddr)
{
    HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spCurrentNode;
    ULONG           nNumReturned = 0;
    CIpsmServer *   pServer;
    CString         strCurAddr;

    // get the enumerator for this node
    CORg(pNode->GetEnum(&spNodeEnum));

    CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
    while (nNumReturned)
    {
        // walk the list of servers and see if it already exists
        pServer = GETHANDLER(CIpsmServer, spCurrentNode);

        strCurAddr = pServer->GetName();

        if (strCurAddr.CompareNoCase(pszAddr) != 0)
        {
            CORg (pNode->RemoveChild(spCurrentNode));
        }

        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    }

Error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\root.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    root.h
        IPSecMon root node information (the root node is not displayed
        in the MMC framework but contains information such as 
        all of the servers in this snapin).
        
    FILE HISTORY:
        
*/

#ifndef _ROOT_H
#define _ROOT_H

#ifndef _IPSMHAND_H
#include "ipsmhand.h"
#endif

#ifndef _TASK_H
#include <task.h>
#endif

#define COMPUTERNAME_LEN_MAX            255

typedef enum _ROOT_TASKS
{
    ROOT_TASK_GETTING_STARTED,
    ROOT_TASK_ADD_SERVER,
    ROOT_TASK_MAX
} ROOT_TASKS;

class CRootTasks : public CTaskList
{
public:
    HRESULT Init(BOOL bExtension, BOOL bThisMachine, BOOL bNetServices);

private:
    CStringArray    m_arrayMouseOverBitmaps;
    CStringArray    m_arrayMouseOffBitmaps;
    CStringArray    m_arrayTaskText;
    CStringArray    m_arrayTaskHelp; 
};

/*---------------------------------------------------------------------------
    Class:  CIpsmRootHandler
 ---------------------------------------------------------------------------*/
class CIpsmRootHandler : public CIpsmHandler
{
// Interface
public:
    CIpsmRootHandler(ITFSComponentData *pCompData);

    // Node handler functionality we override
    OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
    OVERRIDE_NodeHandler_OnAddMenuItems();
    OVERRIDE_NodeHandler_OnCommand();
    OVERRIDE_NodeHandler_GetString();

    // base handler functionality we override
    OVERRIDE_BaseHandlerNotify_OnExpand();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();

    // Result handler functionality
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();

    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
    OVERRIDE_ResultHandler_OnGetResultViewType();
    OVERRIDE_ResultHandler_TaskPadNotify();
    OVERRIDE_ResultHandler_EnumTasks();
    OVERRIDE_ResultHandler_TaskPadGetTitle();

public:
    // helper routines
    HRESULT AddServer(LPCWSTR pServerIp, 
                      LPCTSTR pServerName, 
                      BOOL bNewServer, 
                      DWORD dwServerOptions = 0x00000000, 
                      DWORD dwRefreshInterval = 0xffffffff, 
                      BOOL bExtension = FALSE,  
                      DWORD dwLineBuffSize = 0,
                      DWORD dwPhoneBuffSize = 0
                      );

    BOOL    IsServerInList(ITFSNode * pRootNode, LPCTSTR pszNewName);
    HRESULT AddServerSortedIp(ITFSNode * pNewNode, BOOL bNewServer);
    HRESULT AddServerSortedName(ITFSNode * pNewNode, BOOL bNewServer);

public:
    // CIpsmHandler overrides
    virtual HRESULT InitializeNode(ITFSNode * pNode);

// Implementation
private:
    // Command handlers
    HRESULT OnAddMachine(ITFSNode * pNode);
    HRESULT OnImportOldList(ITFSNode * pNode);
    BOOL    OldServerListExists();

    // helpers
    HRESULT CheckMachine(ITFSNode * pRootNode, LPDATAOBJECT pDataObject);
    HRESULT RemoveOldEntries(ITFSNode * pRootNode, LPCTSTR pszAddr);

protected:
    CString m_strTaskpadTitle;
    BOOL    m_bTaskPadView;
};

#endif _ROOT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\sfltnode.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
	FltrNode.h

    FILE HISTORY:
        
*/

#ifndef _SFLTNODE_H
#define _SFLTNODE_H

#ifndef _IPSMHAND_H
#include "ipsmhand.h"
#endif

#ifndef _SPDDB_H
#include "spddb.h"
#endif

class CSearchFilters;

/*---------------------------------------------------------------------------
	Class:	CSpecificFilterHandler
 ---------------------------------------------------------------------------*/
class CSpecificFilterHandler : public CIpsmHandler
{
public:
    CSpecificFilterHandler(ITFSComponentData* pTFSComponentData);
	~CSpecificFilterHandler();

// Interface
public:
	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_GetString()
			{ return (nCol == 0) ? GetDisplayName() : NULL; }

	// Base handler notifications we handle
	OVERRIDE_BaseHandlerNotify_OnExpand();
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();    

	// Result handler functionality we override
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();

    OVERRIDE_ResultHandler_OnGetResultViewType();
	OVERRIDE_ResultHandler_GetVirtualString(); 
	OVERRIDE_ResultHandler_GetVirtualImage();
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();

	STDMETHODIMP CacheHint(int nStartIndex, int nEndIndex);
	STDMETHODIMP SortItems(int     nColumn, 
						   DWORD   dwSortOptions,    
						   LPARAM  lUserParam);

    // base handler overrides
	virtual HRESULT LoadColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

	// CHandler overridden
    virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);

    // multi select support
    virtual const GUID * GetVirtualGuid(int nIndex) 
	{ 
		return &GUID_IpsmSpecificFilterNodeType; 
	}

public:
	// CMTIpsmHandler functionality
	virtual HRESULT  InitializeNode(ITFSNode * pNode);
	virtual int      GetImageIndex(BOOL bOpenImage);
	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

public:
	// implementation specific	
    HRESULT InitData(ISpdInfo * pSpdInfo);
    HRESULT UpdateStatus(ITFSNode * pNode);
    
    void    SetColumnInfo();


// Implementation
private:
	// Command handlers
    HRESULT OnDelete(ITFSNode * pNode);
	HRESULT UpdateViewType(
				ITFSNode * pNode, 
				FILTER_TYPE NewFltrType
				);

private:
    SPISpdInfo          m_spSpdInfo;
	CSearchFilters *	m_pDlgSrchFltr;
	FILTER_TYPE			m_FltrType;
};


#endif _LINES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\server.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    server.cpp
        IPSecMon machine node handler

    FILE HISTORY:
        
*/


#include "stdafx.h"
#include "server.h"     // Server definition
#include "spddb.h"
#include "servpp.h"
#include "modenode.h"
#include "actpol.h"
#include "objplus.h"
#include "ipaddres.h"


CTimerMgr g_TimerMgr;
CHashTable g_HashTable;

extern ULONG RevertDwordBytes(DWORD dw);

/////////////////////////////////////////////////////////////////////
// 
// CTimerArray implementation
//
/////////////////////////////////////////////////////////////////////
CTimerMgr::CTimerMgr()
{

}

CTimerMgr::~CTimerMgr()
{
    CTimerDesc * pTimerDesc;

    for (int i = (int)GetUpperBound(); i >= 0; --i)
    {
        pTimerDesc = GetAt(i);
        if (pTimerDesc->uTimer != 0)
            FreeTimer(i);

        delete pTimerDesc;
    }

}

int
CTimerMgr::AllocateTimer
(
    ITFSNode *      pNode,
    CIpsmServer *   pServer,
    UINT            uTimerValue,
    TIMERPROC       TimerProc
)
{
    CSingleLock slTimerMgr(&m_csTimerMgr);

    // get a lock on the timer mgr for the scope of this
    // function.
    slTimerMgr.Lock();

    CTimerDesc * pTimerDesc = NULL;

    // look for an empty slot
    for (int i = (int)GetUpperBound(); i >= 0; --i)
    {
        pTimerDesc = GetAt(i);
        if (pTimerDesc->uTimer == 0)
            break;
    }

    // did we find one?  if not allocate one
    if (i < 0)
    {
        pTimerDesc = new CTimerDesc;
        Add(pTimerDesc);
        i = (int)GetUpperBound();
    }
    
    pTimerDesc->uTimer = SetTimer(NULL, (UINT) i, uTimerValue, TimerProc);
    if (pTimerDesc->uTimer == 0)
        return -1;
    
    pTimerDesc->spNode.Set(pNode);
    pTimerDesc->pServer = pServer;
    pTimerDesc->timerProc = TimerProc;    
 
    return i;
}

void 
CTimerMgr::FreeTimer
(
    UINT_PTR uEventId
)
{
    CSingleLock slTimerMgr(&m_csTimerMgr);

    // get a lock on the timer mgr for the scope of this
    // function.
    slTimerMgr.Lock();

    CTimerDesc * pTimerDesc;

    Assert(uEventId <= (UINT) GetUpperBound());
    if (uEventId > (UINT) GetUpperBound())
        return;

    pTimerDesc = GetAt((int) uEventId);
    ::KillTimer(NULL, pTimerDesc->uTimer);

    pTimerDesc->spNode.Release();
    pTimerDesc->pServer = NULL;
    pTimerDesc->uTimer = 0;
}

CTimerDesc *
CTimerMgr::GetTimerDesc
(
    UINT_PTR uEventId
)
{
    CSingleLock slTimerMgr(&m_csTimerMgr);

    // the caller of this function should lock the timer mgr
    // while accessing this pointer
    CTimerDesc * pTimerDesc;

    for (int i = (int)GetUpperBound(); i >= 0; --i)
    {
        pTimerDesc = GetAt(i);
        if (pTimerDesc->uTimer == (UINT) uEventId)
            return pTimerDesc;
    }

    return NULL;
}

void
CTimerMgr::ChangeInterval
(
    UINT_PTR    uEventId,
    UINT        uNewInterval
)
{
    CSingleLock slTimerMgr(&m_csTimerMgr);

    // get a lock on the timer mgr for the scope of this
    // function.
    slTimerMgr.Lock();

    Assert(uEventId <= (UINT) GetUpperBound());
    if (uEventId > (UINT) GetUpperBound())
        return;

    CTimerDesc   tempTimerDesc;
    CTimerDesc * pTimerDesc;

    pTimerDesc = GetAt((int) uEventId);

    // kill the old timer
    ::KillTimer(NULL, pTimerDesc->uTimer);

    // set a new one with the new interval
    pTimerDesc->uTimer = ::SetTimer(NULL, (UINT) uEventId, uNewInterval, pTimerDesc->timerProc);

}

VOID CALLBACK 
StatisticsTimerProc
( 
    HWND        hwnd, 
    UINT        uMsg, 
    UINT_PTR    idEvent, 
    DWORD       dwTime 
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CSingleLock slTimerMgr(&g_TimerMgr.m_csTimerMgr);

    // get a lock on the timer mgr for the scope of this
    // function.
    slTimerMgr.Lock();

    // on the timer, get the timer descriptor for this event
    // Call into the appropriate handler to update the stats.
    CTimerDesc * pTimerDesc;

    pTimerDesc = g_TimerMgr.GetTimerDesc(idEvent);
    
    pTimerDesc->pServer->m_bStatsOnly = TRUE;
    pTimerDesc->pServer->OnRefreshStats(pTimerDesc->spNode,
                                        NULL,
                                        NULL,
                                        0,
                                        0);
    pTimerDesc->pServer->m_bStatsOnly = FALSE;

}

/*---------------------------------------------------------------------------
    Class CIpsmServer implementation
 ---------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------
    Constructor and destructor
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
CIpsmServer::CIpsmServer
(
    ITFSComponentData * pComponentData
) : CMTIpsmHandler(pComponentData),
    m_bStatsOnly(FALSE),
    m_StatsTimerId(-1),
    m_dwOptions(0)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
}

CIpsmServer::~CIpsmServer()
{
    
}

/*!--------------------------------------------------------------------------
    CIpsmServer::InitializeNode
        Initializes node specific data
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmServer::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    HRESULT hr = hrOK;
    CString strTemp;

    COM_PROTECT_TRY
    {
        CORg (CreateSpdInfo(&m_spSpdInfo));

        m_spSpdInfo->SetComputerName((LPTSTR)(LPCTSTR)m_strServerAddress);

        BuildDisplayName(&strTemp);

        SetDisplayName(strTemp);

        // Make the node immediately visible
        pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
        pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_SERVER);
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_SERVER);
        pNode->SetData(TFS_DATA_USER, (LPARAM) this);
        pNode->SetData(TFS_DATA_TYPE, IPSMSNAP_SERVER);

        SetColumnStringIDs(&aColumns[IPSMSNAP_SERVER][0]);
        SetColumnWidths(&aColumnWidths[IPSMSNAP_SERVER][0]);

        //m_StatsDlg.SetData(m_spSpdInfo);

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}


/*---------------------------------------------------------------------------
    CIpsmServer::GetImageIndex
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CIpsmServer::GetImageIndex(BOOL bOpenImage) 
{
    int nIndex = -1;
    switch (m_nState)
    {
        case notLoaded:
            nIndex = ICON_IDX_SERVER;
            break;

        case loading:
            nIndex = ICON_IDX_SERVER_BUSY;
            break;

        case loaded:
            nIndex = ICON_IDX_SERVER_CONNECTED;
            break;

        case unableToLoad:
            nIndex = ICON_IDX_SERVER_LOST_CONNECTION;
            break;
        default:
            ASSERT(FALSE);
    }

    return nIndex;
}

/*---------------------------------------------------------------------------
    CIpsmServer::OnHaveData
        When the background thread enumerates nodes to be added to the UI,
        we get called back here.  We override this to force expansion of the 
        node so that things show up correctly.
    Author: NSun
 ---------------------------------------------------------------------------*/
void 
CIpsmServer::OnHaveData
(
    ITFSNode * pParentNode, 
    ITFSNode * pNewNode
)
{
    CMTIpsmHandler::OnHaveData(pParentNode, pNewNode);
    ExpandNode(pParentNode, TRUE);
}

/*---------------------------------------------------------------------------
    CIpsmServer::OnHaveData
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
void 
CIpsmServer::OnHaveData
(
    ITFSNode * pParentNode, 
    LPARAM      Data,
    LPARAM      Type
)
{
    HRESULT hr = hrOK;
    HWND    hStatsDlg = NULL;

    // This is how we get non-node data back from the background thread.
    switch (Type)
    {
        case IPSECMON_QDATA_REFRESH_STATS:
        {
            // tell all of the child nodes to clear their status caches
            // if any of the nodes is the selected node, then they should
            // repaint the window
            SPITFSNodeEnum      spNodeEnum;
            SPITFSNode          spCurrentNode;
            ULONG               nNumReturned;
            
            CORg(pParentNode->GetEnum(&spNodeEnum));

            CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
            while (nNumReturned)
            {
                LONG_PTR dwDataType = spCurrentNode->GetData(TFS_DATA_TYPE);

                switch (dwDataType)
                {
                    case IPSECMON_QUICK_MODE:
                    {
                        CQmNodeHandler * pQmHandler = GETHANDLER(CQmNodeHandler, spCurrentNode);
                        pQmHandler->UpdateStatus(spCurrentNode);
                    }
                    break;

                    case IPSECMON_MAIN_MODE:
                    {
                        CMmNodeHandler * pMmHandler = GETHANDLER(CMmNodeHandler, spCurrentNode);
                        pMmHandler->UpdateStatus(spCurrentNode);
                    }
                    break;

					case IPSECMON_ACTIVEPOL:
					{
						CActPolHandler * pActivePolHandler = GETHANDLER(CActPolHandler, spCurrentNode);
                        pActivePolHandler->UpdateStatus(spCurrentNode);
					}
					break;

                    //Put it here if there is any other child node under machine node
                    default:
                    break;
                }

                spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
            }

            // reset the timer
            g_TimerMgr.ChangeInterval(m_StatsTimerId, m_dwRefreshInterval);
        }
            
        break;

        case IPSECMON_QDATA_FAILED:
            pParentNode->DeleteAllChildren(TRUE);

            // in OnChangeState, the sate will be changed to unableToLoad
            // and the error will be posted
            m_nState = loading;  
            OnChangeState(pParentNode);
            
            break;
    }

COM_PROTECT_ERROR_LABEL;
}

/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CIpsmServer::OnAddMenuItems
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmServer::OnAddMenuItems
(
    ITFSNode *              pNode,
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    LPDATAOBJECT            lpDataObject, 
    DATA_OBJECT_TYPES       type, 
    DWORD                   dwType,
    long *                  pInsertionAllowed
)
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    LONG    fFlags = 0;
    HRESULT hr = S_OK;
    CString strMenuItem;

    //TODO handle menu items here
    if (m_nState != loaded)
    {
        fFlags |= MF_GRAYED;
    }

    if (type == CCT_SCOPE)
    {
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
            strMenuItem.LoadString(IDS_MENU_RECONNECT);
            hr = LoadAndAddMenuItem( pContextMenuCallback,
                                     strMenuItem,
                                     IDS_MENU_RECONNECT,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                     0
                                     );
            ASSERT( SUCCEEDED(hr) );
        }

    }

    return hr; 
}

/*---------------------------------------------------------------------------
    CIpsmServer::OnCommand
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmServer::OnCommand
(
    ITFSNode *          pNode, 
    long                nCommandId, 
    DATA_OBJECT_TYPES   type, 
    LPDATAOBJECT        pDataObject, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;

    switch (nCommandId)
    {
        case IDS_MENU_RECONNECT:
            OnRefresh(pNode, pDataObject, 0, 0, 0);
            break;
            
        default:
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsmServer::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    NOTE: the root node handler has to over-ride this function to 
    handle the snapin manager property page (wizard) case!!!
    
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmServer::HasPropertyPages
(
    ITFSNode *          pNode,
    LPDATAOBJECT        pDataObject, 
    DATA_OBJECT_TYPES   type, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    HRESULT hr = hrOK;
    
    if (dwType & TFS_COMPDATA_CREATE)
    {
        // This is the case where we are asked to bring up property
        // pages when the user is adding a new snapin.  These calls
        // are forwarded to the root node to handle.  Only for the root node
        hr = hrOK;
        Assert(FALSE); // should never get here
    }
    else
    {
        // we have property pages in the normal case, but don't put the
        // menu up if we are not loaded yet
        if ( (m_nState == loaded) ||
             (m_nState == unableToLoad) )
        {
            hr = hrOK;
        }
        else
        {
            hr = hrFalse;
        }
    }
    
    return hr;
}

/*---------------------------------------------------------------------------
    CIpsmServer::CreatePropertyPages
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmServer::CreatePropertyPages
(
    ITFSNode *              pNode,
    LPPROPERTYSHEETCALLBACK lpProvider,
    LPDATAOBJECT            pDataObject, 
    LONG_PTR                handle, 
    DWORD                   dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Create the property page
    //
    SPIComponentData spComponentData;
    m_spNodeMgr->GetComponentData(&spComponentData);

    CMachineProperties * pMachineProp = new CMachineProperties(
                                                pNode,
                                                spComponentData,
                                                m_spTFSCompData,
                                                m_spSpdInfo, 
                                                NULL, 
                                                loaded == m_nState
                                                );
    

    pMachineProp->m_strMachineName = m_strServerAddress;

    // fill in the auto refresh info
    pMachineProp->m_pageRefresh.m_dwRefreshInterval = GetAutoRefreshInterval();
    pMachineProp->m_pageRefresh.m_bAutoRefresh = GetOptions() & IPSMSNAP_OPTIONS_REFRESH ? TRUE : FALSE;
    
    pMachineProp->m_pageRefresh.m_bEnableDns = GetOptions() & IPSMSNAP_OPTIONS_DNS ? TRUE : FALSE;

    return pMachineProp->CreateModelessSheet(lpProvider, handle);

}

/*---------------------------------------------------------------------------
    CIpsmServer::OnPropertyChange
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmServer::OnPropertyChange
(   
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataobject, 
    DWORD           dwType, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CMachineProperties * pMachineProp = reinterpret_cast<CMachineProperties *>(lParam);

    LONG_PTR changeMask = 0;

    // tell the property page to do whatever now that we are back on the
    // main thread
    pMachineProp->OnPropertyChange(TRUE, &changeMask);

    //Let the main thread know that we are done
    pMachineProp->AcknowledgeNotify();

    if (changeMask)
        pNode->ChangeNode(changeMask);

    return hrOK;

}

/*!--------------------------------------------------------------------------
    CIpsmServer::OnDelete
        The base handler calls this when MMC sends a MMCN_DELETE for a 
        scope pane item.  We just call our delete command handler.
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmServer::OnDelete
(
    ITFSNode *  pNode, 
    LPARAM      arg, 
    LPARAM      lParam
)
{
    return OnDelete(pNode);
}

/*!--------------------------------------------------------------------------
    CIpsmServer::OnNotifyExiting
        We override this for the server node because we don't want the 
        icon to change when the thread goes away.  Normal behavior is that
        the node's icon changes to a wait cursor when the background thread
        is running.  If we are only doing stats collection, then we 
        don't want the icon to change.
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmServer::OnNotifyExiting
(
    LPARAM          lParam
)
{
    CIpsmServerQueryObj * pQuery = (CIpsmServerQueryObj *) lParam;
    
    if (!pQuery->m_bStatsOnly)
        OnChangeState(m_spNode);

    ReleaseThreadHandler();

    Unlock();

    return hrOK;
}

/*---------------------------------------------------------------------------
    Command handlers
 ---------------------------------------------------------------------------*/

 /*!--------------------------------------------------------------------------
    CIpsmServer::OnRefresh
        Default implementation for the refresh functionality
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmServer::OnRefresh
(
    ITFSNode *      pNode,
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg,
    LPARAM          param
)
{
    HRESULT hr = S_OK;
    m_spSpdInfo->Destroy();

    hr = CMTHandler::OnRefresh(pNode, pDataObject, dwType, arg, param);
    
    
    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsmServer::OnRefreshStats
        Default implementation for the Stats refresh functionality
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmServer::OnRefreshStats
(
    ITFSNode *      pNode,
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg,
    LPARAM          param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    SPITFSNode          spNode;
    SPITFSNodeHandler   spHandler;
    ITFSQueryObject *   pQuery = NULL;
    
    if (m_bExpanded == FALSE)
    {
        // we cannot get statistics if the node hasn't been expanded yet
        return hr;
    }

    // only do stats refresh if the server was loaded correctly.
    if (m_nState != loaded)
        return hr;

    BOOL bLocked = IsLocked();
    if (bLocked)
    {
        // cannot refresh stats if this node is locked
        return hr; 
    }

    Lock();

    //OnChangeState(pNode);

    pQuery = OnCreateQuery(pNode);
    Assert(pQuery);

    // notify the UI to change icon, if needed
    //Verify(SUCCEEDED(pComponentData->ChangeNode(this, SCOPE_PANE_CHANGE_ITEM_ICON)));

    Verify(StartBackgroundThread(pNode, m_spTFSCompData->GetHiddenWnd(), pQuery));
    
    pQuery->Release();

    return hrOK;
}


 /*---------------------------------------------------------------------------
    CIpsmServer::OnDelete()
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmServer::OnDelete(ITFSNode * pNode)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;

    CString strMessage;
    AfxFormatString1(strMessage, IDS_WARN_SERVER_DELETE, m_strServerAddress);

    if (AfxMessageBox(strMessage, MB_YESNO) == IDYES)
    {
        // remove this node from the list, there's nothing we need to tell
        // the server, it's just our local list of servers
        SPITFSNode spParent;

        pNode->GetParent(&spParent);
        spParent->RemoveChild(pNode);
    }

    return hr;
}

 
/*---------------------------------------------------------------------------
    Server manipulation functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CIpsmServer::BuildDisplayName
        Builds the string that goes in the UI for this server
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmServer::BuildDisplayName
(
    CString * pstrDisplayName
)
{
    if (pstrDisplayName)
    {
        *pstrDisplayName = GetName();
    }

    return hrOK;
}

/*---------------------------------------------------------------------------
    CIpsmServer::SetAutoRefresh
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmServer::SetAutoRefresh
(
    ITFSNode *  pNode,
    BOOL        bOn,
    DWORD       dwRefreshInterval
)
{
    BOOL bCurrentAutoRefresh = IsAutoRefreshEnabled();

    if (bCurrentAutoRefresh &&
        !bOn)
    {
        // turning off the timer
        g_TimerMgr.FreeTimer(m_StatsTimerId);
    }
    else
    if (!bCurrentAutoRefresh &&
        bOn)
    {
        // gotta turn on the timer
        m_StatsTimerId = g_TimerMgr.AllocateTimer(pNode, this, dwRefreshInterval, StatisticsTimerProc);
    }
    else
    if (bOn && 
        m_dwRefreshInterval != dwRefreshInterval)
    {
        // time to change the timer
        g_TimerMgr.ChangeInterval(m_StatsTimerId, dwRefreshInterval);
    }

    if (bOn)
        m_dwOptions |= IPSMSNAP_OPTIONS_REFRESH;
    else
        m_dwOptions &= ~IPSMSNAP_OPTIONS_REFRESH;

    m_dwRefreshInterval = dwRefreshInterval;

    return hrOK;
}


/*---------------------------------------------------------------------------
    CIpsmServer::SetDnsResolve
        Description
    Author: Briansw
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmServer::SetDnsResolve
(
    ITFSNode *  pNode,
    BOOL        bEnable
)
{

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (bEnable)
        m_dwOptions |= IPSMSNAP_OPTIONS_DNS;
    else
        m_dwOptions &= ~IPSMSNAP_OPTIONS_DNS;

    g_HashTable.SetDnsResolve(bEnable);


    return hrOK;

}


/*---------------------------------------------------------------------------
    CIpsmServer::SetAutoRefresh
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
void
CIpsmServer::SetExtensionName()
{
    CString strName;
    strName.LoadString(IDS_IPSECMON);
    SetDisplayName(strName);
}

 /*!--------------------------------------------------------------------------
    CIpsmServer::UpdateStandardVerbs
        Updates the standard verbs depending upon the state of the node
    Author: NSun
 ---------------------------------------------------------------------------*/
void
CIpsmServer::UpdateConsoleVerbs
(
    IConsoleVerb * pConsoleVerb,
    LONG_PTR       dwNodeType,
    BOOL           bMultiSelect
)
{
    BOOL                bStates[ARRAYLEN(g_ConsoleVerbs)];  
    MMC_BUTTON_STATE *  ButtonState;
    int                 i;
    
    if (bMultiSelect)
    {
        ButtonState = g_ConsoleVerbStatesMultiSel[dwNodeType];
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
    }
    else
    {
        ButtonState = g_ConsoleVerbStates[dwNodeType];
        switch (m_nState)
        {
            case loaded:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
                break;
    
            case notLoaded:
            case loading:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                break;

            case unableToLoad:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                bStates[MMC_VERB_REFRESH & 0x000F] = TRUE;
                bStates[MMC_VERB_DELETE & 0x000F] = TRUE;
                bStates[MMC_VERB_PROPERTIES & 0x000F] = TRUE;
                break;
        }
    }

    EnableVerbs(pConsoleVerb, ButtonState, bStates);
}

/*---------------------------------------------------------------------------
    Background thread functionality
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CIpsmServer::OnCreateQuery
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
ITFSQueryObject* 
CIpsmServer::OnCreateQuery(ITFSNode * pNode)
{
    CIpsmServerQueryObj* pQuery = 
        new CIpsmServerQueryObj(m_spTFSCompData, m_spNodeMgr);
    
    pQuery->m_strServer = GetName();
    pQuery->m_spSpdInfo.Set(m_spSpdInfo);
    pQuery->m_bStatsOnly = m_bStatsOnly;
    
    return pQuery;
}

/*---------------------------------------------------------------------------
    CIpsmServerQueryObj::Execute()
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CIpsmServerQueryObj::Execute()
{
    HRESULT   hr = S_OK;
    DWORD dwActive=m_spSpdInfo->GetActiveInfo();
    DWORD dwInit=m_spSpdInfo->GetInitInfo();
    int i;


    //Query the data from SPD

    switch(dwActive) {
    case MON_MM_FILTER:
    case MON_MM_SP_FILTER:
            CORg(m_spSpdInfo->EnumMmFilters());
            CORg(m_spSpdInfo->EnumMmAuthMethods());
            break;
    case MON_MM_POLICY:
        CORg(m_spSpdInfo->EnumMmPolicies());
        break;
    case MON_MM_SA:
        CORg(m_spSpdInfo->EnumMmSAs());
        break;
    case MON_MM_AUTH:
        CORg(m_spSpdInfo->EnumMmAuthMethods());
        break;
    case MON_QM_FILTER:
		CORg(m_spSpdInfo->EnumQmFilters());
		break;
    case MON_QM_SP_FILTER:
        CORg(m_spSpdInfo->EnumQmSpFilters());
        break;
    case MON_QM_POLICY:
        CORg(m_spSpdInfo->EnumQmPolicies());
        break;
    case MON_QM_SA:
        CORg(m_spSpdInfo->EnumQmSAs());
        break;
    /*case MON_STATS:
        CORg(m_spSpdInfo->LoadStatistics());
        break;*/
    default:
        // Initial load.  Ping server to see if its up
        CORg(m_spSpdInfo->LoadStatistics());
        break;
    }

    if (m_bStatsOnly)
    {
        // we post this message esentially to get back on the main thread 
        // so that we can update the UI
        AddToQueue(NULL, IPSECMON_QDATA_REFRESH_STATS);
        return hrFalse;
    }

	{
	SPITFSNode spActivePolNode;
    CActPolHandler * pActivePolNodeHandler = new CActPolHandler(m_spTFSCompData);
    CreateContainerTFSNode(&spActivePolNode,
                           &GUID_IpsmActivePolNodeType,
                           pActivePolNodeHandler,
                           pActivePolNodeHandler,
                           m_spNodeMgr);
    pActivePolNodeHandler->InitData(m_spSpdInfo);
    pActivePolNodeHandler->InitializeNode(spActivePolNode);
    AddToQueue(spActivePolNode);
    pActivePolNodeHandler->Release();
	}

    {
    SPITFSNode spMmNode;
    CMmNodeHandler * pMmNodeHandler = new CMmNodeHandler(m_spTFSCompData);
    CreateContainerTFSNode(&spMmNode,
                           &GUID_MmNodeType,
                           pMmNodeHandler,
                           pMmNodeHandler,
                           m_spNodeMgr);
    pMmNodeHandler->InitData(m_spSpdInfo);
    pMmNodeHandler->InitializeNode(spMmNode);
    AddToQueue(spMmNode);
    pMmNodeHandler->Release();
    }

    {
    SPITFSNode spQmNode;
    CQmNodeHandler * pQmNodeHandler = new CQmNodeHandler(m_spTFSCompData);
    CreateContainerTFSNode(&spQmNode,
                           &GUID_QmNodeType,
                           pQmNodeHandler,
                           pQmNodeHandler,
                           m_spNodeMgr);
    pQmNodeHandler->InitData(m_spSpdInfo);
    pQmNodeHandler->InitializeNode(spQmNode);
    AddToQueue(spQmNode);
    pQmNodeHandler->Release();
    }
	

COM_PROTECT_ERROR_LABEL;


    if (FAILED(hr))
    {
        PostError(WIN32_FROM_HRESULT(hr));
        if (m_bStatsOnly)
        {
            //If we are doing auto-refresh, tell the main thread 
            //that the query failed
            AddToQueue(NULL, IPSECMON_QDATA_FAILED);
        }
    }

    return hrFalse;
}



CHashTable::CHashTable()
{
    DWORD i;
    
    m_bDnsResolveActive=FALSE;
    m_bThreadRunning=FALSE;
    for (i=0; i < TOTAL_TABLE_SIZE; i++) {
        InitializeListHead(&HashTable[i]);
    }

}

DWORD
CHashTable::AddPendingObject(in_addr IpAddr)
{
    HashEntry *newEntry=new HashEntry;

    CSingleLock slHashLock(&m_csHashLock);
    slHashLock.Lock();

    if (newEntry == NULL) {
        return ERROR_OUTOFMEMORY;
    }
    newEntry->IpAddr=IpAddr;

    InsertHeadList(&HashTable[PENDING_INDEX],&newEntry->Linkage);

    return ERROR_SUCCESS;
}

DWORD
CHashTable::AddObject(HashEntry *pHE)
{

    DWORD Key=HashData(pHE->IpAddr);
    CSingleLock slHashLock(&m_csHashLock);
    slHashLock.Lock();
    
    InsertHeadList(&HashTable[Key],&pHE->Linkage);

    return ERROR_SUCCESS;
}


DWORD
CHashTable::GetObject(HashEntry **ppHashEntry,in_addr IpAddr)
{
    DWORD Key=HashData(IpAddr);
    HashEntry *pHE;
    PLIST_ENTRY pEntry;
    DWORD dwErr;
    
    pHE=NULL;

    CSingleLock slHashLock(&m_csHashLock);
    slHashLock.Lock();

    if (!m_bDnsResolveActive) {
        return ERROR_NOT_READY;
    }

    // Start resolver thread
    if (!m_bThreadRunning) {
        AfxBeginThread((AFX_THREADPROC)HashResolverCallback,
                       NULL);
        m_bThreadRunning=TRUE;
    }

    for (   pEntry = HashTable[Key].Flink;
            pEntry != &HashTable[Key];
            pEntry = pEntry->Flink) {
        
       pHE = CONTAINING_RECORD(pEntry,
                              HashEntry,
                              Linkage);
       if (memcmp(&pHE->IpAddr,&IpAddr,sizeof(in_addr)) == 0) {
           *ppHashEntry = pHE;
           return ERROR_SUCCESS;
       }
    }
    dwErr=AddPendingObject(IpAddr);

    return ERROR_INVALID_PARAMETER;
}


DWORD
CHashTable::FlushTable()
{
    DWORD i;
    PLIST_ENTRY pEntry,pNextEntry;
    HashEntry *pHE;

    CSingleLock slHashLock(&m_csHashLock);
    slHashLock.Lock();

    for (i=0; i < TOTAL_TABLE_SIZE; i++) {
        pEntry = HashTable[i].Flink;
        
        while ( pEntry != &HashTable[i]) {
            
            pHE = CONTAINING_RECORD(pEntry,
                                    HashEntry,
                                    Linkage);
            
            pNextEntry=pEntry->Flink;
            delete pHE;
            pEntry=pNextEntry;
        }
        InitializeListHead(&HashTable[i]);
    }
    return ERROR_SUCCESS;

}


CHashTable::~CHashTable()
{
    DWORD i;
    PLIST_ENTRY pEntry,pNextEntry;
    HashEntry *pHE;

    m_bDnsResolveActive=FALSE;
    while(m_bThreadRunning) {
        Sleep(10);
    }

    CSingleLock slHashLock(&m_csHashLock);
    slHashLock.Lock();

    for (i=0; i < TOTAL_TABLE_SIZE; i++) {
        pEntry = HashTable[i].Flink;
        
        while ( pEntry != &HashTable[i]) {
            
            pHE = CONTAINING_RECORD(pEntry,
                                    HashEntry,
                                    Linkage);
            
            pNextEntry=pEntry->Flink;
            delete pHE;
            pEntry=pNextEntry;
        }

    }

}

HRESULT
CHashTable::SetDnsResolve(BOOL bEnable) 
{

    CSingleLock slHashLock(&m_csHashLock);
    slHashLock.Lock();

    if (m_bDnsResolveActive != bEnable) {
        m_bDnsResolveActive = bEnable;
        FlushTable();
    }

    return hrOK;
}

DWORD
CHashTable::HashData(in_addr IpAddr)
{
    int i;
    int j=0;

    for (i = 0; i < (sizeof(struct in_addr)); i++)
        j ^= (unsigned char)(*((char *)&IpAddr + i));

    return j % HASH_TABLE_SIZE;
}


DWORD
CHashTable::DnsResolve()
{

    PLIST_ENTRY pEntry;
    HashEntry *pHE;
    HOSTENT *pHost;
    BOOL bWorkAvail;

    while(m_bDnsResolveActive) {

        pHE=NULL;
        bWorkAvail=FALSE;

        CSingleLock slHashLock(&m_csHashLock);
        slHashLock.Lock();
        if (!IsListEmpty(&HashTable[PENDING_INDEX])) {
            pEntry=RemoveHeadList(&HashTable[PENDING_INDEX]);
            pHE = CONTAINING_RECORD(pEntry,
                                    HashEntry,
                                    Linkage);
            bWorkAvail=TRUE;
        }
        slHashLock.Unlock();

        // Make sure name resolution is outside of lock for perf
        if (bWorkAvail) {
            pHost=gethostbyaddr((char*)&pHE->IpAddr,sizeof(in_addr),AF_INET);
            if (pHost) {
                //Resolution succeeded
                pHE->HostName = pHost->h_name;
                g_HashTable.AddObject(pHE);
            } else {
                // Resolution attempted, failed, cache failure for perf
                ULONG ul = RevertDwordBytes(*(DWORD*)&pHE->IpAddr);
                CIpAddress TmpIpAddr = ul;
                pHE->HostName = (CString)TmpIpAddr;
                g_HashTable.AddObject(pHE);
            }
        } else {
            Sleep(300);
        }
    }
    
    m_bThreadRunning=FALSE;
    return ERROR_SUCCESS;
}



UINT HashResolverCallback(LPVOID pParam)
{

    g_HashTable.DnsResolve();
    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\servpp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    Servpp.h   
        Server properties header file

    FILE HISTORY:
        
*/

#if !defined(AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3357A__INCLUDED_)
#define AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3357A__INCLUDED_

#ifndef _SPDDB_H
#include "spddb.h"
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define AUTO_REFRESH_MINUTES_MAX       99
#define AUTO_REFRESH_SECONDS_MAX       59

BOOL    IsLocalSystemAccount(LPCTSTR pszAccount);

/////////////////////////////////////////////////////////////////////////////
// CMachinePropRefresh dialog

class CMachinePropRefresh : public CPropertyPageBase
{
    DECLARE_DYNCREATE(CMachinePropRefresh)

// Construction
public:
    CMachinePropRefresh();
    ~CMachinePropRefresh();

// Dialog Data
    //{{AFX_DATA(CMachinePropRefresh)
    enum { IDD = IDP_SERVER_REFRESH };
    CEdit   m_editSeconds;
    CEdit   m_editMinutes;
    CSpinButtonCtrl m_spinSeconds;
    CSpinButtonCtrl m_spinMinutes;
    CButton m_checkEnableStats;
    CButton m_checkEnableDns;
    //}}AFX_DATA

    void UpdateButtons();
    void ValidateMinutes();
    void ValidateSeconds();

    virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);

    // Context Help Support
    virtual DWORD * GetHelpMap() { return (DWORD *) &g_aHelpIDs_IDP_SERVER_REFRESH[0]; }

    BOOL        m_bAutoRefresh;
    BOOL        m_bEnableDns;
    DWORD       m_dwRefreshInterval;

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CMachinePropRefresh)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CMachinePropRefresh)
    virtual BOOL OnInitDialog();
    afx_msg void OnCheckEnableStats();
    afx_msg void OnCheckEnableDns();
    afx_msg void OnChangeEditMinutes();
    afx_msg void OnChangeEditSeconds();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

class CMachineProperties : public CPropertyPageHolderBase
{
    friend class CMachinePropRefresh;

public:
    CMachineProperties(ITFSNode *          pNode,
                      IComponentData *    pComponentData,
                      ITFSComponentData * pTFSCompData,
                      ISpdInfo *         pSpdInfo,
                      LPCTSTR             pszSheetName,
                      BOOL                fSpdInfoLoaded);
    virtual ~CMachineProperties();

    ITFSComponentData * GetTFSCompData()
    {
        if (m_spTFSCompData)
            m_spTFSCompData->AddRef();
        return m_spTFSCompData;
    }

    HRESULT GetSpdInfo(ISpdInfo ** ppSpdInfo) 
    {   
        Assert(ppSpdInfo);
        *ppSpdInfo = NULL;
        SetI((LPUNKNOWN *) ppSpdInfo, m_spSpdInfo);
        return hrOK;
    }


public:
    CMachinePropRefresh      m_pageRefresh;

    CString                 m_strMachineName;

protected:
    SPITFSComponentData     m_spTFSCompData;
    SPISpdInfo             m_spSpdInfo;
    
    BOOL                    m_fSpdInfoLoaded;
};


#endif // !defined(AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\sfltnode.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    provider.cpp
        Filter node handler

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "server.h"
#include "mdlsdlg.h"
#include "SrchFltr.h"
#include "SFltNode.h"
#include "SpdUtil.h"


/*---------------------------------------------------------------------------
    Class CSpecificFilterHandler implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    Constructor and destructor
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
CSpecificFilterHandler::CSpecificFilterHandler
(
    ITFSComponentData * pComponentData
) : CIpsmHandler(pComponentData), 
	m_pDlgSrchFltr(NULL),
	m_FltrType(FILTER_TYPE_ANY)		//by default we display both transport and tunnel filters
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
}


CSpecificFilterHandler::~CSpecificFilterHandler()
{
	if (m_pDlgSrchFltr)
	{
		WaitForModelessDlgClose(m_pDlgSrchFltr);
		delete m_pDlgSrchFltr; //this will also close the window
	}
}

/*!--------------------------------------------------------------------------
    CSpecificFilterHandler::InitializeNode
        Initializes node specific data
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CSpecificFilterHandler::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    CString strTemp;  
	strTemp.LoadString(IDS_SPECIFIC_FILTER_NODE);
    SetDisplayName(strTemp);

    // Make the node immediately visible
    pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
    pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_FOLDER_CLOSED);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_FOLDER_OPEN);
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, IPSECMON_SPECIFIC_FILTER);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

    SetColumnStringIDs(&aColumns[IPSECMON_SPECIFIC_FILTER][0]);
    SetColumnWidths(&aColumnWidths[IPSECMON_SPECIFIC_FILTER][0]);

    return hrOK;
}


/*---------------------------------------------------------------------------
    CSpecificFilterHandler::GetImageIndex
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CSpecificFilterHandler::GetImageIndex(BOOL bOpenImage) 
{
    int nIndex = -1;

    return nIndex;
}


/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CSpecificFilterHandler::OnAddMenuItems
        Adds context menu items for the SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CSpecificFilterHandler::OnAddMenuItems
(
    ITFSNode *              pNode,
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    LPDATAOBJECT            lpDataObject, 
    DATA_OBJECT_TYPES       type, 
    DWORD                   dwType,
    long *                  pInsertionAllowed
)
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    LONG        fFlags = 0, fLoadingFlags = 0;
    HRESULT     hr = S_OK;
    CString     strMenuItem;

    if (type == CCT_SCOPE)
    {
        // these menu items go in the new menu, 
        // only visible from scope pane
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
            strMenuItem.LoadString(IDS_FLTR_SEARCH);
            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                     strMenuItem, 
                                     IDS_FLTR_SEARCH,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                     0 );
            ASSERT( SUCCEEDED(hr) );

        }

    }

    return hr; 
}

/*!--------------------------------------------------------------------------
    CSpecificFilterHandler::AddMenuItems
        Adds context menu items for virtual list box (result pane) items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CSpecificFilterHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
    MMC_COOKIE              cookie,
    LPDATAOBJECT            pDataObject, 
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    long *                  pInsertionAllowed
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT     hr = hrOK;
    CString     strMenuItem;
    SPINTERNAL  spInternal;
    LONG        fFlags = 0;

    spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or this SA
    // node itself.
    if (spInternal->HasVirtualIndex())
    {
    }

    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        //load and view menu items here
    }

	if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
	{
		strMenuItem.LoadString(IDS_VIEW_ALL_FLTR);
		hr = LoadAndAddMenuItem( pContextMenuCallback, 
								 strMenuItem, 
								 IDS_VIEW_ALL_FLTR,
								 CCM_INSERTIONPOINTID_PRIMARY_VIEW, 
								 (FILTER_TYPE_ANY == m_FltrType) ? MF_CHECKED : 0 );

		strMenuItem.LoadString(IDS_VIEW_TRANSPORT_FLTR);
		hr = LoadAndAddMenuItem( pContextMenuCallback, 
								 strMenuItem, 
								 IDS_VIEW_TRANSPORT_FLTR,
								 CCM_INSERTIONPOINTID_PRIMARY_VIEW, 
								 (FILTER_TYPE_TRANSPORT == m_FltrType) ? MF_CHECKED : 0 );

		strMenuItem.LoadString(IDS_VIEW_TUNNEL_FLTR);
		hr = LoadAndAddMenuItem( pContextMenuCallback, 
								 strMenuItem, 
								 IDS_VIEW_TUNNEL_FLTR,
								 CCM_INSERTIONPOINTID_PRIMARY_VIEW, 
								 (FILTER_TYPE_TUNNEL == m_FltrType) ? MF_CHECKED : 0 );
		ASSERT( SUCCEEDED(hr) );
	}


    return hr;
}

/*!--------------------------------------------------------------------------
    CSpecificFilterHandler::OnRefresh
        Default implementation for the refresh functionality
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CSpecificFilterHandler::OnRefresh
(
    ITFSNode *      pNode,
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg,
    LPARAM          param
)
{
	HRESULT hr = S_OK;
    int i = 0; 
    SPIConsole      spConsole;

    CORg(CHandler::OnRefresh(pNode, pDataObject, dwType, arg, param));

    CORg(m_spSpdInfo->EnumQmSpFilters());

    m_spSpdInfo->ChangeQmSpFilterViewType(m_FltrType);
    i = m_spSpdInfo->GetQmSpFilterCountOfCurrentViewType();
            
    // now notify the virtual listbox
    CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE));

Error:
	return hr;
}

/*---------------------------------------------------------------------------
    CSpecificFilterHandler::OnCommand
        Handles context menu commands for SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CSpecificFilterHandler::OnCommand
(
    ITFSNode *          pNode, 
    long                nCommandId, 
    DATA_OBJECT_TYPES   type, 
    LPDATAOBJECT        pDataObject, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
	CThemeContextActivator m_activator;

	//handle the scope context menu commands here
	switch(nCommandId)
	{
		case IDS_FLTR_SEARCH:
			if (NULL == m_pDlgSrchFltr)
			{
				m_pDlgSrchFltr = new CSearchFilters(m_spSpdInfo);
				Assert(m_pDlgSrchFltr);

				if (NULL == m_pDlgSrchFltr)
					break;
			}
				
			CreateModelessDlg(m_pDlgSrchFltr,
							   NULL,
							   IDD_SRCH_FLTRS);
		break;
    }

   return hr;
}

/*!--------------------------------------------------------------------------
    CSpecificFilterHandler::Command
        Handles context menu commands for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CSpecificFilterHandler::Command
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    int             nCommandID,
    LPDATAOBJECT    pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    SPITFSNode spNode;

    m_spResultNodeMgr->FindNode(cookie, &spNode);

	FILTER_TYPE NewFltrType = m_FltrType;

	// handle result context menu and view menus here
	switch (nCommandID)
    {
        case IDS_VIEW_ALL_FLTR:
			NewFltrType = FILTER_TYPE_ANY;
            break;

        case IDS_VIEW_TRANSPORT_FLTR:
			NewFltrType = FILTER_TYPE_TRANSPORT;
            break;

		case IDS_VIEW_TUNNEL_FLTR:
			NewFltrType = FILTER_TYPE_TUNNEL;
			break;

        default:
            break;
    }

	//Update the views if a different view is selected.
	if (NewFltrType != m_FltrType)
	{
		m_FltrType = NewFltrType;
		UpdateViewType(spNode, m_FltrType);
	}


    return hr;
}

/*!--------------------------------------------------------------------------
    CSpecificFilterHandler::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    NOTE: the root node handler has to over-ride this function to 
    handle the snapin manager property page (wizard) case!!!
    
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CSpecificFilterHandler::HasPropertyPages
(
    ITFSNode *          pNode,
    LPDATAOBJECT        pDataObject, 
    DATA_OBJECT_TYPES   type, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    return hrFalse;
}

/*---------------------------------------------------------------------------
    CSpecificFilterHandler::CreatePropertyPages
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CSpecificFilterHandler::CreatePropertyPages
(
    ITFSNode *              pNode,
    LPPROPERTYSHEETCALLBACK lpSA,
    LPDATAOBJECT            pDataObject, 
    LONG_PTR                handle, 
    DWORD                   dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    DWORD       dwError;
    DWORD       dwDynDnsFlags;

    //
    // Create the property page
    //
    SPIComponentData spComponentData;
    m_spNodeMgr->GetComponentData(&spComponentData);

    //CServerProperties * pServerProp = new CServerProperties(pNode, spComponentData, m_spTFSCompData, NULL);

    //
    // Object gets deleted when the page is destroyed
    //
    Assert(lpSA != NULL);

    //return pServerProp->CreateModelessSheet(lpSA, handle);
    return hrFalse;
}

/*---------------------------------------------------------------------------
    CSpecificFilterHandler::OnPropertyChange
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CSpecificFilterHandler::OnPropertyChange
(   
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataobject, 
    DWORD           dwType, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    //CServerProperties * pServerProp = reinterpret_cast<CServerProperties *>(lParam);

    LONG_PTR changeMask = 0;

    // tell the property page to do whatever now that we are back on the
    // main thread
    //pServerProp->OnPropertyChange(TRUE, &changeMask);

    //pServerProp->AcknowledgeNotify();

    if (changeMask)
        pNode->ChangeNode(changeMask);

    return hrOK;
}

/*---------------------------------------------------------------------------
    CSpecificFilterHandler::OnExpand
        Handles enumeration of a scope item
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CSpecificFilterHandler::OnExpand
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    CORg (CIpsmHandler::OnExpand(pNode, pDataObject, dwType, arg, param));

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    CSpecificFilterHandler::OnResultSelect
        Handles the MMCN_SELECT notifcation 
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CSpecificFilterHandler::OnResultSelect
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie,
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    SPINTERNAL      spInternal;
    SPIConsole      spConsole;
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    int             i;
    LONG_PTR        dwNodeType;
    BOOL            fSelect = HIWORD(arg);
    IConsole2 *pConsole2 = NULL;

	//get pConsole2 for writing to the status bar, if fails not to worry
	pComponent->GetConsole(&pConsole2);

    if (!fSelect)
	{
		if(pConsole2) {
			pConsole2->SetStatusText(_T(""));
			pConsole2->Release();
		}
        return hr;
	}

    if (m_spSpdInfo)
    {
        DWORD dwInitInfo;

        dwInitInfo=m_spSpdInfo->GetInitInfo();
        if (!(dwInitInfo & MON_QM_SP_FILTER)) {
            CORg(m_spSpdInfo->EnumQmSpFilters());            
            //m_spSpdInfo->SetInitInfo(dwInitInfo | MON_QM_FILTER);
            m_spSpdInfo->SetInitInfo(dwInitInfo | MON_QM_SP_FILTER);
        }
        m_spSpdInfo->SetActiveInfo(MON_QM_SP_FILTER);

        // Get the current count
        i = m_spSpdInfo->GetQmSpFilterCountOfCurrentViewType();

        // now notify the virtual listbox
        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
        CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE) );
		
		if(pConsole2)
		{
			CString strTemp;
			WCHAR szTemp[20];
			wsprintf(szTemp, L"%d", i);
		    AfxFormatString1(strTemp, IDS_STATUS_NUM_ITEMS, szTemp);
			LPCTSTR szNumItems = (LPCTSTR) strTemp;
		    pConsole2->SetStatusText((LPOLESTR)szNumItems);
		    pConsole2->Release();
		}
    }

    // now update the verbs...
    spInternal = ExtractInternalFormat(pDataObject);
    Assert(spInternal);

    // virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or the active
    // registrations node itself.
    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

    if (spInternal->HasVirtualIndex())
    {
		//TODO add to here if we want to have some result console verbs
        // we gotta do special stuff for the virtual index items
        dwNodeType = IPSECMON_SPECIFIC_FILTER_ITEM;
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
    }
    else
    {
        // enable/disable delete depending if the node supports it
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
        dwNodeType = spNode->GetData(TFS_DATA_TYPE);

        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);

        //hide "delete" context menu
        bStates[MMC_VERB_DELETE & 0x000F] = FALSE;
    }

    EnableVerbs(spConsoleVerb, g_ConsoleVerbStates[dwNodeType], bStates);

COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*!--------------------------------------------------------------------------
    CSpecificFilterHandler::OnDelete
        The base handler calls this when MMC sends a MMCN_DELETE for a 
        scope pane item.  We just call our delete command handler.
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CSpecificFilterHandler::OnDelete
(
    ITFSNode *  pNode, 
    LPARAM      arg, 
    LPARAM      lParam
)
{
    return S_FALSE;
}

/*---------------------------------------------------------------------------
    CSpecificFilterHandler::OnGetResultViewType
        Return the result view that this node is going to support
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CSpecificFilterHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE            cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    if (cookie != NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;
    }

    return S_FALSE;
}

/*---------------------------------------------------------------------------
    CSpecificFilterHandler::GetVirtualImage
        Returns the image index for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CSpecificFilterHandler::GetVirtualImage
(
    int     nIndex
)
{
	//TODO return whatever the icon for specific filters
    return ICON_IDX_FILTER;
}

/*---------------------------------------------------------------------------
    CSpecificFilterHandler::GetVirtualString
        returns a pointer to the string for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
LPCWSTR 
CSpecificFilterHandler::GetVirtualString
(
    int     nIndex,
    int     nCol
)
{
	HRESULT hr = S_OK;

	static CString strTemp;

	if (nCol >= DimensionOf(aColumns[IPSECMON_SPECIFIC_FILTER]))
		return NULL;

	strTemp.Empty();
	
	CFilterInfo filter;
	CORg(m_spSpdInfo->GetSpecificFilterInfo(nIndex, &filter));

    switch (aColumns[IPSECMON_SPECIFIC_FILTER][nCol])
    {
        case IDS_COL_FLTR_NAME:
			{
			strTemp = filter.m_stName;

			if( filter.m_dwFlags & IPSEC_QM_POLICY_DEFAULT_POLICY )
			{
				AfxFormatString1(strTemp, IDS_POL_DEFAULT_RESPONSE, (LPCTSTR) filter.m_stName);
			}
						
			return strTemp;
            break;
			}

        case IDS_COL_FLTR_SRC:
			AddressToString(filter.m_SrcAddr, &strTemp);
			return strTemp;
            break;

        case IDS_COL_FLTR_DEST:
			AddressToString(filter.m_DesAddr, &strTemp);
			return strTemp;
            break;

		case IDS_COL_FLTR_SRC_PORT:
			PortToString(filter.m_SrcPort, &strTemp);
			return strTemp;
			break;
		
		case IDS_COL_FLTR_DEST_PORT:
			PortToString(filter.m_DesPort, &strTemp);
			return strTemp;
			break;

		case IDS_COL_FLTR_SRC_TNL:
			TnlEpToString(filter.m_FilterType,
						  filter.m_MyTnlAddr,
						  &strTemp
						  );
			return strTemp;
			break;

		case IDS_COL_FLTR_DEST_TNL:
			TnlEpToString(filter.m_FilterType,
						  filter.m_PeerTnlAddr,
						  &strTemp
						  );

			return strTemp;
			break;

		case IDS_COL_FLTR_PROT:
			ProtocolToString(filter.m_Protocol, &strTemp);
			return strTemp;
			break;

		case IDS_COL_FLTR_FLAG:
			FilterFlagToString((FILTER_DIRECTION_INBOUND == filter.m_dwDirection) ?
							filter.m_InboundFilterAction : 
							filter.m_OutboundFilterAction,
							&strTemp
							);
			return strTemp;
			break;

		case IDS_COL_FLTR_DIR:
			DirectionToString(filter.m_dwDirection, &strTemp);
			return strTemp;
			break;

		case IDS_COL_QM_POLICY:
			strTemp = filter.m_stPolicyName;
			return strTemp;
			break;

		case IDS_COL_FLTR_WEIGHT:
			strTemp.Format(_T("%d"), filter.m_dwWeight);
			return strTemp;
			break;

        default:
            Panic0("CSpecificFilterHandler::GetVirtualString - Unknown column!\n");
            break;
    }

COM_PROTECT_ERROR_LABEL;
    return NULL;
}

/*---------------------------------------------------------------------------
    CSpecificFilterHandler::CacheHint
        MMC tells us which items it will need before it requests things
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CSpecificFilterHandler::CacheHint
(
    int nStartIndex, 
    int nEndIndex
)
{
    HRESULT hr = hrOK;;

    Trace2("CacheHint - Start %d, End %d\n", nStartIndex, nEndIndex);

    return hr;
}

/*---------------------------------------------------------------------------
    CSpecificFilterHandler::SortItems
        We are responsible for sorting of virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CSpecificFilterHandler::SortItems
(
    int     nColumn, 
    DWORD   dwSortOptions, 
    LPARAM    lUserParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;

	if (nColumn >= DimensionOf(aColumns[IPSECMON_SPECIFIC_FILTER]))
		return E_INVALIDARG;

	BEGIN_WAIT_CURSOR
	
	DWORD	dwIndexType = aColumns[IPSECMON_SPECIFIC_FILTER][nColumn];

	hr = m_spSpdInfo->SortSpecificFilters(dwIndexType, dwSortOptions);
	
	END_WAIT_CURSOR
    return hr;
}

/*!--------------------------------------------------------------------------
    CSpecificFilterHandler::OnResultUpdateView
        Implementation of ITFSResultHandler::OnResultUpdateView
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT CSpecificFilterHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM        data, 
    LONG_PTR      hint
)
{
    HRESULT    hr = hrOK;
    SPITFSNode spSelectedNode;

    pComponent->GetSelectedNode(&spSelectedNode);
    if (spSelectedNode == NULL)
        return S_OK; // no selection for our IComponentData

    if ( hint == IPSECMON_UPDATE_STATUS )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);
        SPITFSNode spSelectedNode;

        pComponent->GetSelectedNode(&spSelectedNode);

        if (pNode == spSelectedNode)
        {       
            // if we are the selected node, then we need to update
            SPIResultData spResultData;

            CORg (pComponent->GetResultData(&spResultData));
            CORg (spResultData->SetItemCount((int) data, MMCLV_UPDATE_NOSCROLL));
        }
    }
    else
    {
        // we don't handle this message, let the base class do it.
        return CIpsmHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

COM_PROTECT_ERROR_LABEL;

    return hr;
}


/*!--------------------------------------------------------------------------
    CSpecificFilterHandler::LoadColumns
        Set the correct column header and then call the base class
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CSpecificFilterHandler::LoadColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    SetColumnInfo();

    return CIpsmHandler::LoadColumns(pComponent, cookie, arg, lParam);
}

/*---------------------------------------------------------------------------
    Command handlers
 ---------------------------------------------------------------------------*/

 
/*---------------------------------------------------------------------------
    CSpecificFilterHandler::OnDelete
        Removes a service SA
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CSpecificFilterHandler::OnDelete
(
    ITFSNode * pNode
)
{
    HRESULT         hr = S_FALSE;
    return hr;
}


/*---------------------------------------------------------------------------
    CSpecificFilterHandler::UpdateStatus
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CSpecificFilterHandler::UpdateStatus
(
    ITFSNode * pNode
)
{
    HRESULT             hr = hrOK;

    SPIComponentData    spComponentData;
    SPIConsole          spConsole;
    IDataObject *       pDataObject;
    SPIDataObject       spDataObject;
    int                 i = 0;
    
    Trace0("CSpecificFilterHandler::UpdateStatus - Updating status for Filter");

/*TODO     
    // clear our status strings
    m_mapStatus.RemoveAll();
*/
    // force the listbox to update.  We do this by setting the count and 
    // telling it to invalidate the data
    CORg(m_spNodeMgr->GetComponentData(&spComponentData));
    CORg(m_spNodeMgr->GetConsole(&spConsole));
    
    // grab a data object to use
    CORg(spComponentData->QueryDataObject((MMC_COOKIE) pNode, CCT_RESULT, &pDataObject) );
    spDataObject = pDataObject;

    m_spSpdInfo->ChangeQmSpFilterViewType(m_FltrType);
    i = m_spSpdInfo->GetQmSpFilterCountOfCurrentViewType();
    CORg(spConsole->UpdateAllViews(pDataObject, i, IPSECMON_UPDATE_STATUS));

COM_PROTECT_ERROR_LABEL;

    return hr;
}

/*---------------------------------------------------------------------------
    Misc functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CSpecificFilterHandler::InitData
        Initializes data for this node
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CSpecificFilterHandler::InitData
(
    ISpdInfo *     pSpdInfo
)
{

    m_spSpdInfo.Set(pSpdInfo);

    return hrOK;
}



/*---------------------------------------------------------------------------
    CSpecificFilterHandler::SetColumnInfo
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
void
CSpecificFilterHandler::SetColumnInfo()
{
    // set the correct column header
	// We don't dynamically set Column info
}

/*---------------------------------------------------------------------------
    CSpecificFilterHandler::UpdateViewType
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CSpecificFilterHandler::UpdateViewType
(
	ITFSNode * pNode, 
	FILTER_TYPE NewFltrType
)
{
	// clear the listbox then set the size

    HRESULT             hr = hrOK;
    SPIComponentData    spCompData;
    SPIConsole          spConsole;
    IDataObject*        pDataObject;
    SPIDataObject       spDataObject;
    LONG_PTR            command;               
    int i;

    COM_PROTECT_TRY
    {
		m_FltrType = NewFltrType;

		//tell the spddb to update its index manager for QM filter
		m_spSpdInfo->ChangeQmSpFilterViewType(m_FltrType);

        i = m_spSpdInfo->GetQmSpFilterCountOfCurrentViewType();

		m_spNodeMgr->GetComponentData(&spCompData);

        CORg ( spCompData->QueryDataObject((MMC_COOKIE) pNode, CCT_RESULT, &pDataObject) );
        spDataObject = pDataObject;

        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    
		//update the result pane virtual list
        CORg ( spConsole->UpdateAllViews(spDataObject, i, RESULT_PANE_CLEAR_VIRTUAL_LB) ); 

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\spddb.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
	spddb.h

    FILE HISTORY:
        
*/

#ifndef _SPDDB_H
#define _SPDDB_H

#ifndef _HARRAY_H
#include "harray.h"
#endif

#include "ipsec.h"
#include "winipsec.h"
#include "ipsecshr.h"
#include "spdutil.h"
#include "wincrypt.h"
#include "redblack.h"
#include "util.h"

interface ISpdInfo;

template <class T>
void
FreeItemsAndEmptyArray (
    T& array);

DWORD   IsAdmin(LPCTSTR szMachineName, LPCTSTR szAccount, LPCTSTR szPassword, BOOL * pfIsAdmin);

typedef enum _IPSECMON_INFO_TYPE {MON_MM_FILTER=0x1,MON_MM_POLICY=0x2,MON_MM_SA=0x4,MON_MM_SP_FILTER=0x8,
                                  MON_QM_FILTER=0x10, MON_QM_SP_FILTER=0x20,
                                  MON_QM_POLICY=0x40,MON_QM_SA=0x80,MON_STATS=0x100,
                                  MON_MM_AUTH=0x200, MON_INIT=0x400} IPSECMON_INFO_TYPE;

typedef struct _QMPOLINFO
{
	DWORD dwFlags;
	WCHAR szPolicyName[1];
} QMPOLOCYINFO, *PQMPOLOCYINFO;

class CFilterInfo
{
public:
	FILTER_TYPE				 m_FilterType;
	GUID					 m_guidFltr;
	CString					 m_stName;
	IF_TYPE                  m_InterfaceType;
    BOOL                     m_bCreateMirror;
    ADDR                     m_SrcAddr;
    ADDR                     m_DesAddr;
	ADDR					 m_MyTnlAddr;		//only valid for tunnel filters
	ADDR					 m_PeerTnlAddr;		//only valid for tunnel filters
    PROTOCOL                 m_Protocol;
    PORT                     m_SrcPort;
    PORT                     m_DesPort;
    FILTER_ACTION            m_InboundFilterAction;
	FILTER_ACTION            m_OutboundFilterAction;
    DWORD                    m_dwDirection;
    DWORD                    m_dwWeight;
    GUID                     m_guidPolicyID;
	CString					 m_stPolicyName;
	DWORD                    m_dwFlags;

public:
	CFilterInfo() { m_FilterType = FILTER_TYPE_ANY; };
	CFilterInfo& operator=(const TRANSPORT_FILTER TransFltr)
	{
		m_FilterType = FILTER_TYPE_TRANSPORT;
		m_guidFltr = TransFltr.gFilterID;
		m_stName = TransFltr.pszFilterName;
		m_InterfaceType = TransFltr.InterfaceType;
		m_bCreateMirror = TransFltr.bCreateMirror;
		m_SrcAddr = TransFltr.SrcAddr;
		m_DesAddr = TransFltr.DesAddr;
		m_Protocol = TransFltr.Protocol;
		m_SrcPort = TransFltr.SrcPort;
		m_DesPort = TransFltr.DesPort;
		m_InboundFilterAction = TransFltr.InboundFilterAction;
		m_OutboundFilterAction = TransFltr.OutboundFilterAction;
		m_dwDirection = TransFltr.dwDirection;
		m_dwWeight = TransFltr.dwWeight;
		m_guidPolicyID = TransFltr.gPolicyID;
		m_stPolicyName = _T("");

		ZeroMemory(&m_MyTnlAddr, sizeof(m_MyTnlAddr));
		ZeroMemory(&m_PeerTnlAddr, sizeof(m_PeerTnlAddr));
		return *this;
	};
	CFilterInfo& operator=(const TUNNEL_FILTER Fltr)
	{
		m_FilterType = FILTER_TYPE_TUNNEL;
		m_guidFltr = Fltr.gFilterID;
		m_stName = Fltr.pszFilterName;
		m_InterfaceType = Fltr.InterfaceType;
		m_bCreateMirror = Fltr.bCreateMirror;
		m_SrcAddr = Fltr.SrcAddr;
		m_DesAddr = Fltr.DesAddr;
		m_Protocol = Fltr.Protocol;
		m_SrcPort = Fltr.SrcPort;
		m_DesPort = Fltr.DesPort;
		m_InboundFilterAction = Fltr.InboundFilterAction;
		m_OutboundFilterAction = Fltr.OutboundFilterAction;
		m_dwDirection = Fltr.dwDirection;
		m_dwWeight = Fltr.dwWeight;
		m_guidPolicyID = Fltr.gPolicyID;
		m_stPolicyName = _T("");

		m_MyTnlAddr = Fltr.SrcTunnelAddr;
		m_PeerTnlAddr = Fltr.DesTunnelAddr;

		return *this;
	}
};

class CMmFilterInfo
{
public:
	GUID					 m_guidFltr;
	CString					 m_stName;
	IF_TYPE                  m_InterfaceType;
    BOOL                     m_bCreateMirror;
    ADDR                     m_SrcAddr;
    ADDR                     m_DesAddr;
    DWORD                    m_dwDirection;
    DWORD                    m_dwWeight;
    GUID                     m_guidPolicyID;
	GUID					 m_guidAuthID;
	CString					 m_stPolicyName;
	CString					 m_stAuthDescription;
	DWORD                    m_dwFlags;

public:
	CMmFilterInfo() {};
	CMmFilterInfo& operator=(const MM_FILTER Fltr)
	{
		m_guidFltr = Fltr.gFilterID;
		m_stName = Fltr.pszFilterName;
		m_InterfaceType = Fltr.InterfaceType;
		m_bCreateMirror = Fltr.bCreateMirror;
		m_SrcAddr = Fltr.SrcAddr;
		m_DesAddr = Fltr.DesAddr;
		m_dwDirection = Fltr.dwDirection;
		m_dwWeight = Fltr.dwWeight;
		m_guidPolicyID = Fltr.gPolicyID;
		m_guidAuthID = Fltr.gMMAuthID;
		m_stPolicyName.Empty();
		m_stAuthDescription.Empty();

		return *this;
	};
};

typedef CArray<CMmFilterInfo *, CMmFilterInfo *> CMmFilterInfoArray;

class CMmAuthInfo
{
public:
	MM_AUTH_ENUM	m_AuthMethod;
	DWORD			m_dwAuthInfoSize;
	LPBYTE			m_pAuthInfo;

public:
	CMmAuthInfo() 
	{
		m_dwAuthInfoSize = 0; 
		m_pAuthInfo = NULL;
	};
	
	CMmAuthInfo(const CMmAuthInfo& info)
	{
		m_AuthMethod = info.m_AuthMethod;
		m_dwAuthInfoSize = info.m_dwAuthInfoSize;

		m_pAuthInfo = new BYTE[m_dwAuthInfoSize];
		Assert(info.m_pAuthInfo);
		if (m_pAuthInfo)
		{
			memcpy(m_pAuthInfo, info.m_pAuthInfo, m_dwAuthInfoSize);
		}
	};

	CMmAuthInfo& operator=(const INT_IPSEC_MM_AUTH_INFO AuthInfo)
	{
		if (m_pAuthInfo)
		{
			delete [] m_pAuthInfo;
			m_pAuthInfo = NULL;
		}

		m_AuthMethod = AuthInfo.AuthMethod;

		if (0 != AuthInfo.dwAuthInfoSize && NULL != AuthInfo.pAuthInfo) {

                    if (m_AuthMethod != IKE_RSA_SIGNATURE) {
			m_dwAuthInfoSize = AuthInfo.dwAuthInfoSize + 2;  //To append the _T('\0') at the end
			m_pAuthInfo = new BYTE[m_dwAuthInfoSize];
			
			if (m_pAuthInfo)
			{
                            ZeroMemory(m_pAuthInfo, m_dwAuthInfoSize * sizeof(BYTE));
                            memcpy(m_pAuthInfo, AuthInfo.pAuthInfo, AuthInfo.dwAuthInfoSize);
			}
                    } else {
                        DWORD dwNameSize=0;                        
                        CRYPT_DATA_BLOB NameBlob;
                        m_pAuthInfo=NULL;

                        NameBlob.pbData=AuthInfo.pAuthInfo;
                        NameBlob.cbData=AuthInfo.dwAuthInfoSize;
                        
                        dwNameSize = CertNameToStr(
                            X509_ASN_ENCODING,
                            &NameBlob,   
                            CERT_X500_NAME_STR, 
                            (LPWSTR)m_pAuthInfo,       
                            dwNameSize);
                        if (dwNameSize >= 1) {
                            m_pAuthInfo=new BYTE[dwNameSize * sizeof(wchar_t)];
                            if (m_pAuthInfo) {
                                dwNameSize=CertNameToStr(
                                    X509_ASN_ENCODING,
                                    &NameBlob,   
                                    CERT_X500_NAME_STR, 
                                    (LPWSTR)m_pAuthInfo,       
                                    dwNameSize);
                            }
                            m_dwAuthInfoSize=dwNameSize;
                        }

                    }
                }
		else
		{
			m_dwAuthInfoSize = 0;
		}

		return *this;
	};

	CMmAuthInfo& operator=(const CMmAuthInfo& info)
	{
		if (this == &info)
			return *this;

		if (m_pAuthInfo)
		{
			delete [] m_pAuthInfo;
		}

		m_AuthMethod = info.m_AuthMethod;
		m_dwAuthInfoSize = info.m_dwAuthInfoSize;

		if (0 != info.m_dwAuthInfoSize && NULL != info.m_pAuthInfo)
		{
			m_pAuthInfo = new BYTE[m_dwAuthInfoSize];

			if (m_pAuthInfo)
			{
				memcpy(m_pAuthInfo, info.m_pAuthInfo, m_dwAuthInfoSize);
			}
		}

		return *this;
	};

	~CMmAuthInfo() 
	{
		if (m_pAuthInfo)
		{
			delete [] m_pAuthInfo;
		}
	};
};

typedef CArray<CMmAuthInfo *, CMmAuthInfo *> CMmAuthInfoArray;

class CMmAuthMethods
{
public:
	GUID					m_guidID;
	CMmAuthInfoArray	m_arrAuthInfo;
	CString					m_stDescription;

	CMmAuthMethods() {}
	CMmAuthMethods(const CMmAuthMethods & methods)
	{
		m_guidID = methods.m_guidID;

		FreeItemsAndEmptyArray (m_arrAuthInfo);
		m_arrAuthInfo.SetSize(methods.m_arrAuthInfo.GetSize());
		for (int i = 0; i < methods.m_arrAuthInfo.GetSize(); i++)
		{
			CMmAuthInfo * pAuth = new CMmAuthInfo;
			*pAuth = *(methods.m_arrAuthInfo[i]);
			m_arrAuthInfo[i] = pAuth;
		}
		m_stDescription = methods.m_stDescription;
	}
	
	CMmAuthMethods& operator=(const CMmAuthMethods & methods)
	{
		if (&methods == this)
			return *this;

		m_guidID = methods.m_guidID;

		FreeItemsAndEmptyArray (m_arrAuthInfo);
		m_arrAuthInfo.SetSize(methods.m_arrAuthInfo.GetSize());
		for (int i = 0; i < methods.m_arrAuthInfo.GetSize(); i++)
		{
			CMmAuthInfo * pAuth = new CMmAuthInfo;
			*pAuth = *(methods.m_arrAuthInfo[i]);
			m_arrAuthInfo[i] = pAuth;
		}

		m_stDescription = methods.m_stDescription;

		return *this;
	}

	CMmAuthMethods& operator=(const INT_MM_AUTH_METHODS & methods)
	{
		m_guidID = methods.gMMAuthID;

		FreeItemsAndEmptyArray (m_arrAuthInfo);
		m_arrAuthInfo.SetSize(methods.dwNumAuthInfos);
		for (int i = 0; i < (int)methods.dwNumAuthInfos; i++)
		{
			CMmAuthInfo * pAuth = new CMmAuthInfo;
			*pAuth = methods.pAuthenticationInfo[i];
			m_arrAuthInfo[i] = pAuth;
		}

		//construct the description
		m_stDescription.Empty();

		CString st;
		for (i = 0; i < m_arrAuthInfo.GetSize(); i++)
		{
			if (0 != i)
			{
				m_stDescription += _T(", ");
			}
	
			MmAuthToString(m_arrAuthInfo[i]->m_AuthMethod, &st);
			m_stDescription += st;
		}

		return *this;
	}

	~CMmAuthMethods() { FreeItemsAndEmptyArray (m_arrAuthInfo); }
	
};

typedef CArray<CMmAuthMethods *, CMmAuthMethods *> CMmAuthMethodsArray;

class CMmOffer
{
public:
	KEY_LIFETIME			m_Lifetime;
	DWORD					m_dwFlags;
	DWORD					m_dwQuickModeLimit;
	DWORD					m_dwDHGroup;
	IPSEC_MM_ALGO			m_EncryptionAlgorithm;
	IPSEC_MM_ALGO			m_HashingAlgorithm;
	
public:
	CMmOffer() {};
	CMmOffer(const CMmOffer & offer)
	{
		m_Lifetime = offer.m_Lifetime;
		m_dwFlags = offer.m_dwFlags;
		m_dwQuickModeLimit = offer.m_dwQuickModeLimit;
		m_dwDHGroup = offer.m_dwDHGroup;
		m_EncryptionAlgorithm = offer.m_EncryptionAlgorithm;
		m_HashingAlgorithm = offer.m_HashingAlgorithm;
	};

	CMmOffer& operator=(const CMmOffer& offer)
	{
		if (this == &offer)
			return *this;

		m_Lifetime = offer.m_Lifetime;
		m_dwFlags = offer.m_dwFlags;
		m_dwQuickModeLimit = offer.m_dwQuickModeLimit;
		m_dwDHGroup = offer.m_dwDHGroup;
		m_EncryptionAlgorithm = offer.m_EncryptionAlgorithm;
		m_HashingAlgorithm = offer.m_HashingAlgorithm;

		return *this;
	};

	CMmOffer& operator=(const IPSEC_MM_OFFER MmOffer)
	{
		m_Lifetime = MmOffer.Lifetime;
		m_dwFlags = MmOffer.dwFlags;
		m_dwQuickModeLimit = MmOffer.dwQuickModeLimit;
		m_dwDHGroup = MmOffer.dwDHGroup;
		m_EncryptionAlgorithm = MmOffer.EncryptionAlgorithm;
		m_HashingAlgorithm = MmOffer.HashingAlgorithm;

		return *this;
	};

	~CMmOffer() {}
};

typedef CArray<CMmOffer *, CMmOffer *> CMmOfferArray;

class CMmPolicyInfo
{
public:
	GUID					m_guidID;
	CString					m_stName;
	DWORD					m_dwFlags;
	DWORD					m_dwOfferCount;
	CMmOfferArray		m_arrOffers;

public:
	CMmPolicyInfo() {};
	CMmPolicyInfo(const CMmPolicyInfo &info)
	{
		m_guidID = info.m_guidID;
		m_stName = info.m_stName;
		m_dwFlags = info.m_dwFlags;
		m_dwOfferCount = info.m_dwOfferCount;

		FreeItemsAndEmptyArray (m_arrOffers);
		m_arrOffers.SetSize(m_dwOfferCount);
		for (DWORD i = 0; i < m_dwOfferCount; i++)
		{
			CMmOffer * pOffer = new CMmOffer;
			*pOffer = *info.m_arrOffers[i];
			m_arrOffers[i] = pOffer;
		}

	};

	CMmPolicyInfo& operator=(const CMmPolicyInfo &info)
	{
		if (&info == this)
			return *this;

		m_guidID = info.m_guidID;
		m_stName = info.m_stName;
		m_dwFlags = info.m_dwFlags;
		m_dwOfferCount = info.m_dwOfferCount;

		FreeItemsAndEmptyArray (m_arrOffers);
		m_arrOffers.SetSize(m_dwOfferCount);
		for (DWORD i = 0; i < m_dwOfferCount; i++)
		{
			CMmOffer * pOffer = new CMmOffer;
			*pOffer = *info.m_arrOffers[i];
			m_arrOffers[i] = pOffer;
		}

		return *this;
	};

	CMmPolicyInfo& operator=(const IPSEC_MM_POLICY MmPol)
	{
		m_guidID = MmPol.gPolicyID;
		m_stName = MmPol.pszPolicyName;
		m_dwFlags = MmPol.dwFlags;
		m_dwOfferCount = MmPol.dwOfferCount;

		FreeItemsAndEmptyArray (m_arrOffers);
		m_arrOffers.SetSize(m_dwOfferCount);
		for (DWORD i = 0; i < m_dwOfferCount; i++)
		{
			CMmOffer * pOffer = new CMmOffer;
			*pOffer = MmPol.pOffers[i];
			m_arrOffers[i] = (pOffer);
		}

		return *this;
	};

	~CMmPolicyInfo() { FreeItemsAndEmptyArray (m_arrOffers); }
};


class CMmSA
{
public:
    GUID			m_guidPolicy;
	CMmOffer		m_SelectedOffer;
    MM_AUTH_ENUM	m_Auth;
    IKE_COOKIE_PAIR m_MMSpi;
    ADDR			m_MeAddr;
	ADDR			m_PeerAddr;

	CString			m_stMyId;
	CString			m_stMyCertChain;

    CString			m_stPeerId;
    CString			m_stPeerCertChain;

	CString			m_stPolicyName;
    DWORD			m_dwFlags;
    DWORD                       m_dwPolFlags;


//
//    TBD - Add UDP encapsulation context later on.
//    IPSEC_UDP_ENCAP_CONTEXT m_UdpEncapContext;
//

public:
	CMmSA() {};

	CMmSA& operator=(const IPSEC_MM_SA sa)
	{
		m_guidPolicy = sa.gMMPolicyID;
		m_SelectedOffer = sa.SelectedMMOffer;
		m_Auth = sa.MMAuthEnum;
		m_MMSpi = sa.MMSpi;
		m_MeAddr = sa.Me;
		m_PeerAddr = sa.Peer;

        
        GetAuthId( (PIPSEC_MM_SA) &sa, &m_stMyId, FALSE);
        GetAuthId( (PIPSEC_MM_SA) &sa, &m_stPeerId, TRUE);

		m_dwFlags = sa.dwFlags;

//
//        TBD - Add UDP encapsulation context later on.
//        m_UdpEncapContext = sa.UdpEncapContext;
//

		m_stPolicyName.Empty(); //Should set the name in LoadMiscMmSAInfo
                m_dwPolFlags = 0;  //should set the flag in LoadMiscMmSAInfo
		return *this;
	};
};

typedef CArray<CMmSA *, CMmSA *> CMmSAArray;

class CQmAlgo
{
public:
	IPSEC_OPERATION			m_Operation;
	ULONG					m_ulAlgo;
	HMAC_AUTH_ALGO_ENUM			m_SecAlgo;
	ULONG					m_ulKeyLen;
	ULONG					m_ulRounds;
	ULONG					m_ulSecKeyLen;
	ULONG					m_ulSecRounds;

public:
	CQmAlgo() {};

	CQmAlgo& operator=(const IPSEC_QM_ALGO algo)
	{
		m_Operation = algo.Operation;
		m_ulAlgo = algo.uAlgoIdentifier;
		m_SecAlgo= algo.uSecAlgoIdentifier;
		m_ulKeyLen = algo.uAlgoKeyLen;
		m_ulRounds = algo.uAlgoRounds;
		m_ulSecKeyLen = algo.uSecAlgoKeyLen;
		m_ulSecRounds = algo.uSecAlgoRounds;

		return *this;
	};
};

typedef CArray<CQmAlgo *, CQmAlgo *> CQmAlgoArray;

class CQmOffer
{
public:
	KEY_LIFETIME			m_Lifetime;
	DWORD					m_dwFlags;
	BOOL					m_fPFSRequired;
	DWORD					m_dwPFSGroup;
	DWORD					m_dwNumAlgos;
	CQmAlgo					m_arrAlgos[QM_MAX_ALGOS];

public:
	CQmOffer() {};

	CQmOffer& operator=(const IPSEC_QM_OFFER offer)
	{
		m_Lifetime = offer.Lifetime;
		m_dwFlags = offer.dwFlags;
		m_fPFSRequired = offer.bPFSRequired;
		m_dwPFSGroup = offer.dwPFSGroup;

		m_dwNumAlgos = offer.dwNumAlgos;
		for (DWORD i = 0; i < m_dwNumAlgos; i++)
		{
			m_arrAlgos[i] = offer.Algos[i];
		}

		return *this;
	};

};

typedef CArray<CQmOffer *, CQmOffer *> CQmOfferArray;

class CQmPolicyInfo
{
public:
	GUID					m_guidID;
	CString					m_stName;
	DWORD					m_dwFlags;
	CQmOfferArray			m_arrOffers;

public:
	CQmPolicyInfo() {};
	~CQmPolicyInfo() { FreeItemsAndEmptyArray(m_arrOffers); }

	CQmPolicyInfo(const CQmPolicyInfo& pol)
	{
		m_guidID = pol.m_guidID;
		m_stName = pol.m_stName;
		m_dwFlags = pol.m_dwFlags;
		
		int nSize = (int)pol.m_arrOffers.GetSize();

		m_arrOffers.SetSize(nSize);
		for(int i = 0; i < nSize; i++)
		{
			CQmOffer * pOffer = new CQmOffer;
			*pOffer = *pol.m_arrOffers[i];
			m_arrOffers[i] = pOffer;
		}
	};

	CQmPolicyInfo& operator=(const CQmPolicyInfo& pol)
	{
		if (&pol == this)
			return *this;

		m_guidID = pol.m_guidID;
		m_stName = pol.m_stName;
		m_dwFlags = pol.m_dwFlags;
		
		int nSize = (int)pol.m_arrOffers.GetSize();

		FreeItemsAndEmptyArray(m_arrOffers);
		m_arrOffers.SetSize(nSize);
		for(int i = 0; i < nSize; i++)
		{
			CQmOffer * pOffer = new CQmOffer;
			*pOffer = *pol.m_arrOffers[i];
			m_arrOffers[i] = pOffer;
		}

		return *this;
	};

	CQmPolicyInfo& operator=(const IPSEC_QM_POLICY& pol)
	{
		m_guidID = pol.gPolicyID;
		m_stName = pol.pszPolicyName;
		m_dwFlags = pol.dwFlags;
		
		
		int nSize = pol.dwOfferCount;

		FreeItemsAndEmptyArray(m_arrOffers);
		m_arrOffers.SetSize(nSize);
		for(int i = 0; i < nSize; i++)
		{
			CQmOffer * pOffer = new CQmOffer;
			*pOffer = pol.pOffers[i];
			m_arrOffers[i] = pOffer;
		}

		return *this;
	};
	
};

//The filter setting used by the driver, corresponding to IPSEC_QM_FILTER
class CQmDriverFilter
{
public:
	QM_FILTER_TYPE	m_Type;
    ADDR			m_SrcAddr;
    ADDR			m_DesAddr;
    PROTOCOL		m_Protocol;
    PORT			m_SrcPort;
    PORT			m_DesPort;
    ADDR			m_MyTunnelEndpt;
    ADDR			m_PeerTunnelEndpt;
    DWORD			m_dwFlags;

	CQmDriverFilter& operator=(const IPSEC_QM_FILTER fltr)
	{
		m_Type = fltr.QMFilterType;
		m_SrcAddr = fltr.SrcAddr;
		m_DesAddr = fltr.DesAddr;
		m_Protocol = fltr.Protocol;
		m_DesPort = fltr.DesPort;
		m_SrcPort = fltr.SrcPort;
		m_MyTunnelEndpt = fltr.MyTunnelEndpt;
		m_PeerTunnelEndpt = fltr.PeerTunnelEndpt;
		m_dwFlags = fltr.dwFlags;

		return *this;
	}
};

class CQmSA
{
public:
    GUID				m_guidPolicy;
	GUID				m_guidFilter;
	CQmOffer			m_SelectedOffer;
	CQmDriverFilter		        m_QmDriverFilter;			
	IKE_COOKIE_PAIR		        m_MMSpi;
	CString				m_stPolicyName;
        DWORD                           m_dwPolFlags;

//
//    TBD - Add UDP encapsulation context later on.
//    IPSEC_UDP_ENCAP_CONTEXT m_UdpEncapContext;
//

	CQmSA& operator=(const IPSEC_QM_SA sa)
	{
		m_guidPolicy = sa.gQMPolicyID;
		m_guidFilter = sa.gQMFilterID;
		m_SelectedOffer = sa.SelectedQMOffer;
		m_QmDriverFilter = sa.IpsecQMFilter;
		m_MMSpi = sa.MMSpi;

		//Need LoadMiscQmSAInfo to set the policy name and m_dwPolFlags
		m_stPolicyName.Empty();
                m_dwPolFlags = 0;

//
//        TBD - Add UDP encapsulation context later on.
//        m_UdpEncapContext = sa.UdpEncapContext;
//

		return *this;
	}
};

typedef CArray<CQmSA *, CQmSA *> CQmSAArray;

class CIkeStatistics
{
public:
    DWORD m_dwActiveAcquire;
    DWORD m_dwActiveReceive;
    DWORD m_dwAcquireFail;
    DWORD m_dwReceiveFail;
    DWORD m_dwSendFail;
    DWORD m_dwAcquireHeapSize;
    DWORD m_dwReceiveHeapSize;
    DWORD m_dwNegotiationFailures;
    DWORD m_dwAuthenticationFailures;
    DWORD m_dwInvalidCookiesReceived;
    DWORD m_dwTotalAcquire;
    DWORD m_dwTotalGetSpi;
    DWORD m_dwTotalKeyAdd;
    DWORD m_dwTotalKeyUpdate;
    DWORD m_dwGetSpiFail;
    DWORD m_dwKeyAddFail;
    DWORD m_dwKeyUpdateFail;
    DWORD m_dwIsadbListSize;
    DWORD m_dwConnListSize;
    DWORD m_dwOakleyMainModes;
    DWORD m_dwOakleyQuickModes;
    DWORD m_dwSoftAssociations;
    DWORD m_dwInvalidPacketsReceived;

	CIkeStatistics & operator=(const IKE_STATISTICS stats)
	{
		m_dwActiveAcquire = stats.dwActiveAcquire;
		m_dwActiveReceive = stats.dwActiveReceive;
		m_dwAcquireFail = stats.dwAcquireFail;
		m_dwReceiveFail = stats.dwReceiveFail;
		m_dwSendFail = stats.dwSendFail;
		m_dwAcquireHeapSize = stats.dwAcquireHeapSize;
		m_dwReceiveHeapSize = stats.dwReceiveHeapSize;
		m_dwNegotiationFailures = stats.dwNegotiationFailures;
		m_dwAuthenticationFailures = stats.dwAuthenticationFailures;
		m_dwInvalidCookiesReceived = stats.dwInvalidCookiesReceived;
		m_dwTotalAcquire = stats.dwTotalAcquire;
		m_dwTotalGetSpi = stats.dwTotalGetSpi;
		m_dwTotalKeyAdd = stats.dwTotalKeyAdd;
		m_dwTotalKeyUpdate = stats.dwTotalKeyUpdate;
		m_dwGetSpiFail = stats.dwGetSpiFail;
		m_dwKeyAddFail = stats.dwKeyAddFail;
		m_dwKeyUpdateFail = stats.dwKeyUpdateFail;
		m_dwIsadbListSize = stats.dwIsadbListSize;
		m_dwConnListSize = stats.dwConnListSize;
		m_dwOakleyMainModes = stats.dwOakleyMainModes;
		m_dwOakleyQuickModes = stats.dwOakleyQuickModes;
		m_dwSoftAssociations = stats.dwSoftAssociations;
                m_dwInvalidPacketsReceived = stats.dwInvalidPacketsReceived;
		return *this;
	}
};

class CIpsecStatistics
{
public:
	DWORD			m_dwNumActiveAssociations;
	DWORD			m_dwNumOffloadedSAs;
    DWORD			m_dwNumPendingKeyOps;
    DWORD			m_dwNumKeyAdditions;
    DWORD			m_dwNumKeyDeletions;
    DWORD			m_dwNumReKeys;
    DWORD			m_dwNumActiveTunnels;
    DWORD			m_dwNumBadSPIPackets;
    DWORD			m_dwNumPacketsNotDecrypted;
    DWORD			m_dwNumPacketsNotAuthenticated;
    DWORD			m_dwNumPacketsWithReplayDetection;
    ULARGE_INTEGER	m_uConfidentialBytesSent;
    ULARGE_INTEGER	m_uConfidentialBytesReceived;
    ULARGE_INTEGER	m_uAuthenticatedBytesSent;
    ULARGE_INTEGER	m_uAuthenticatedBytesReceived;
	ULARGE_INTEGER  m_uTransportBytesSent;
	ULARGE_INTEGER  m_uTransportBytesReceived;
    ULARGE_INTEGER	m_uBytesSentInTunnels;
    ULARGE_INTEGER	m_uBytesReceivedInTunnels;
    ULARGE_INTEGER	m_uOffloadedBytesSent;
    ULARGE_INTEGER	m_uOffloadedBytesReceived;

	CIpsecStatistics & operator=(const IPSEC_STATISTICS stats)
	{
		m_dwNumActiveAssociations = stats.dwNumActiveAssociations;
		m_dwNumOffloadedSAs = stats.dwNumOffloadedSAs;
		m_dwNumPendingKeyOps = stats.dwNumPendingKeyOps;
		m_dwNumKeyAdditions = stats.dwNumKeyAdditions;
		m_dwNumKeyDeletions = stats.dwNumKeyDeletions;
		m_dwNumReKeys = stats.dwNumReKeys;
		m_dwNumActiveTunnels = stats.dwNumActiveTunnels;
		m_dwNumBadSPIPackets = stats.dwNumBadSPIPackets;
		m_dwNumPacketsNotDecrypted = stats.dwNumPacketsNotDecrypted;
		m_dwNumPacketsNotAuthenticated = stats.dwNumPacketsNotAuthenticated;
		m_dwNumPacketsWithReplayDetection = stats.dwNumPacketsWithReplayDetection;
		m_uConfidentialBytesSent = stats.uConfidentialBytesSent;
		m_uConfidentialBytesReceived = stats.uConfidentialBytesReceived;
		m_uAuthenticatedBytesSent = stats.uAuthenticatedBytesSent;
		m_uAuthenticatedBytesReceived = stats.uAuthenticatedBytesReceived;
		m_uBytesSentInTunnels = stats.uBytesSentInTunnels;
		m_uTransportBytesSent = stats.uTransportBytesSent;
		m_uTransportBytesReceived = stats.uTransportBytesReceived;
		m_uBytesReceivedInTunnels = stats.uBytesReceivedInTunnels;
		m_uOffloadedBytesSent = stats.uOffloadedBytesSent;
		m_uOffloadedBytesReceived = stats.uOffloadedBytesReceived;

		return *this;
	}

};
typedef CArray<CQmPolicyInfo *, CQmPolicyInfo *> CQmPolicyInfoArray;
typedef CArray<CMmPolicyInfo *, CMmPolicyInfo *> CMmPolicyInfoArray;
typedef CArray<CFilterInfo *, CFilterInfo *> CFilterInfoArray;

struct SA_ENTRY
{
	IPSEC_SA_INFO * psaInfo;
	CString		stPolicyName;
	CString		stFilterName;
};

// for our interface
#define DeclareISpdInfoMembers(IPURE) \
	STDMETHOD(Destroy) (THIS) IPURE; \
	STDMETHOD(SetComputerName) (THIS_ LPTSTR pszName) IPURE; \
	STDMETHOD(GetComputerName) (THIS_ CString * pstName) IPURE; \
	STDMETHOD(EnumQmFilters) (THIS) IPURE; \
	STDMETHOD(EnumMmPolicies) (THIS) IPURE; \
	STDMETHOD(EnumMmFilters) (THIS) IPURE; \
	STDMETHOD(EnumQmPolicies) (THIS) IPURE; \
	STDMETHOD(EnumSpecificFilters) (THIS_ GUID * pTransFilterGuid, CFilterInfoArray * parraySpecificFilters, FILTER_TYPE fltrType) IPURE; \
	STDMETHOD(EnumMmSpecificFilters) (THIS_ GUID * pGenFilterGuid, CMmFilterInfoArray * parraySpecificFilters) IPURE; \
	STDMETHOD(EnumQmSAsFromMmSA) (THIS_ const CMmSA & MmSA, CQmSAArray * parrayQmSAs) IPURE; \
	STDMETHOD(EnumMmAuthMethods) (THIS) IPURE; \
	STDMETHOD(EnumMmSAs) (THIS) IPURE; \
	STDMETHOD(EnumQmSAs) (THIS) IPURE; \
	STDMETHOD(GetFilterInfo) (THIS_ int iIndex, CFilterInfo * pTransFltr) IPURE; \
	STDMETHOD(GetSpecificFilterInfo) (THIS_ int iIndex, CFilterInfo * pTransFltr) IPURE; \
	STDMETHOD(GetMmPolicyInfo) (THIS_ int iIndex, CMmPolicyInfo * pMmPolicy) IPURE; \
	STDMETHOD(GetMmFilterInfo) (THIS_ int iIndex, CMmFilterInfo * pMmPolicy) IPURE; \
	STDMETHOD(GetMmSpecificFilterInfo) (THIS_ int iIndex, CMmFilterInfo * pMmPolicy) IPURE; \
	STDMETHOD(GetQmPolicyInfo) (THIS_ int iIndex, CQmPolicyInfo * pMmPolicy) IPURE; \
	STDMETHOD(GetQmPolicyNameByGuid) (THIS_ GUID Guid, CString * pst) IPURE; \
	STDMETHOD(GetMmAuthMethodsInfo) (THIS_ int iIndex, CMmAuthMethods * pMmAuth) IPURE; \
	STDMETHOD(GetMmSAInfo) (THIS_ int iIndex, CMmSA * pSA) IPURE; \
	STDMETHOD(GetQmSAInfo) (THIS_ int iIndex, CQmSA * pSA) IPURE; \
	STDMETHOD(GetMmAuthMethodsInfoByGuid) (THIS_ GUID guid, CMmAuthMethods * pMmAuth) IPURE; \
	STDMETHOD(GetMmPolicyNameByGuid) (THIS_ GUID Guid, CString * pst) IPURE; \
	STDMETHOD_(DWORD, GetQmFilterCountOfCurrentViewType) (THIS) IPURE; \
	STDMETHOD_(DWORD, GetQmSpFilterCountOfCurrentViewType) (THIS) IPURE; \
	STDMETHOD_(DWORD, GetMmFilterCount) (THIS) IPURE; \
	STDMETHOD_(DWORD, GetMmSpecificFilterCount) (THIS) IPURE; \
	STDMETHOD_(DWORD, GetMmPolicyCount) (THIS) IPURE; \
	STDMETHOD_(DWORD, GetMmAuthMethodsCount) (THIS) IPURE; \
	STDMETHOD_(DWORD, GetMmSACount) (THIS) IPURE; \
	STDMETHOD_(DWORD, GetQmSACount) (THIS) IPURE; \
	STDMETHOD_(DWORD, GetQmPolicyCount) (THIS) IPURE; \
	STDMETHOD(GetMatchFilters) (THIS_ CFilterInfo * pfltrSearchCondition, DWORD dwPreferredNum, CFilterInfoArray * parrFilters) IPURE; \
	STDMETHOD(GetMatchMMFilters) (THIS_ CMmFilterInfo * pfltrSearchCondition, DWORD dwPreferredNum, CMmFilterInfoArray * parrFilters) IPURE; \
	STDMETHOD(SortFilters) (THIS_ DWORD dwIndexType, DWORD dwSortOptions) IPURE; \
	STDMETHOD(SortSpecificFilters) (THIS_ DWORD dwIndexType, DWORD dwSortOptions) IPURE; \
	STDMETHOD(SortMmFilters) (DWORD dwIndexType, DWORD dwSortOptions) IPURE; \
	STDMETHOD(SortMmSpecificFilters) (DWORD dwIndexType, DWORD dwSortOptions) IPURE; \
	STDMETHOD(SortMmPolicies) (DWORD dwIndexType, DWORD dwSortOptions) IPURE; \
	STDMETHOD(SortQmPolicies) (DWORD dwIndexType, DWORD dwSortOptions) IPURE; \
	STDMETHOD(SortMmSAs) (DWORD dwIndexType, DWORD dwSortOptions) IPURE; \
	STDMETHOD(SortQmSAs) (DWORD dwIndexType, DWORD dwSortOptions) IPURE; \
	STDMETHOD(LoadStatistics) (THIS) IPURE; \
	STDMETHOD_(void, GetLoadedStatistics) (CIkeStatistics * pIkeStats, CIpsecStatistics * pIpsecStats) IPURE; \
	STDMETHOD_(void, ChangeQmFilterViewType) (FILTER_TYPE FltrType) IPURE; \
	STDMETHOD_(void, ChangeQmSpFilterViewType) (FILTER_TYPE FltrType) IPURE; \
	STDMETHOD_(DWORD, GetInitInfo) (THIS) IPURE; \
	STDMETHOD_(void, SetInitInfo) (THIS_ DWORD dwInitInfo) IPURE; \
	STDMETHOD_(DWORD, GetActiveInfo) (THIS) IPURE; \
	STDMETHOD_(void, SetActiveInfo) (THIS_ DWORD dwActiveInfo) IPURE; \
	STDMETHOD(EnumQmSpFilters) (THIS) IPURE; \

#undef INTERFACE
#define INTERFACE ISpdInfo
DECLARE_INTERFACE_(ISpdInfo, IUnknown)
{
public:
	DeclareIUnknownMembers(PURE)
	DeclareISpdInfoMembers(PURE)

};

typedef ComSmartPointer<ISpdInfo, &IID_ISpdInfo> SPISpdInfo;

class CSpdInfo : public ISpdInfo
{
public:
	CSpdInfo();
	~CSpdInfo();

	DeclareIUnknownMembers(IMPL);
	DeclareISpdInfoMembers(IMPL);

private:
	CFilterInfoArray		m_arrayFilters;			//for generic filters
	CIndexMgrFilter			m_IndexMgrFilters;

	CFilterInfoArray		m_arraySpecificFilters; //for specific filters
	CIndexMgrFilter			m_IndexMgrSpecificFilters;

	CMmFilterInfoArray		m_arrayMmFilters;
	CIndexMgrMmFilter		m_IndexMgrMmFilters;
    
	CMmFilterInfoArray		m_arrayMmSpecificFilters;
	CIndexMgrMmFilter		m_IndexMgrMmSpecificFilters;

	CMmPolicyInfoArray		m_arrayMmPolicies;
	CIndexMgrMmPolicy		m_IndexMgrMmPolicies;

	CMmSAArray				m_arrayMmSAs;
	CIndexMgrMmSA			m_IndexMgrMmSAs;

	CQmSAArray				m_arrayQmSAs;
	CIndexMgrQmSA			m_IndexMgrQmSAs;


	CQmPolicyInfoArray		m_arrayQmPolicies;
	CIndexMgrQmPolicy		m_IndexMgrQmPolicies;

	CMmAuthMethodsArray		m_arrMmAuthMethods;
	
	CIkeStatistics			m_IkeStats;
	CIpsecStatistics		m_IpsecStats;

	CCriticalSection        m_csData;
	CString					m_stMachineName;
	LONG                    m_cRef;
    
    DWORD      m_Init;
    DWORD      m_Active;

	HANDLE                    m_hSubAllocator;
	NAME_TREE                 m_QmPolicyTree;
	
	
private:
	void ConvertToExternalFilterData(CFilterInfo * pfltrIn, TRANSPORT_FILTER * pfltrOut);
	void CSpdInfo::ConvertToExternalMMFilterData (
			CMmFilterInfo * pfltrIn, 
			MM_FILTER * pfltrOut);

	HRESULT LoadMiscMmFilterInfo(CMmFilterInfo * pFltr);
	HRESULT LoadMiscFilterInfo(CFilterInfo * pFilter);
	HRESULT LoadMiscMmSAInfo(CMmSA * pSA);
	HRESULT LoadMiscQmSAInfo(CQmSA * pSA);

	HRESULT InternalEnumMmFilters(
					DWORD dwLevel,
					GUID guid,
					CMmFilterInfoArray * pArray,
					DWORD dwPreferredNum = 0 /*by default get all entries*/);
	
	HRESULT InternalEnumTransportFilters(
					DWORD dwLevel,
					GUID guid,
					CFilterInfoArray * pArray,
					DWORD dwPreferredNum = 0 /*by default get all entries*/);

	HRESULT InternalEnumTunnelFilters(
					DWORD dwLevel,
					GUID guid,
					CFilterInfoArray * pArray,
					DWORD dwPreferredNum = 0 /*by default get all entries*/);
	
	HRESULT InternalEnumMmPolicies(
					CMmPolicyInfoArray * pArray,
					DWORD dwPreferredNum = 0 /*by default get all entries*/);

	HRESULT InternalEnumQmPolicies(
					CQmPolicyInfoArray * pArray,
					DWORD dwPreferredNum = 0 /*by default get all entries*/);

	HRESULT InternalEnumMmAuthMethods(
					CMmAuthMethodsArray * pArray,
					DWORD dwPreferredNum = 0 /*by default get all entries*/);

	HRESULT InternalEnumMmSAs(CMmSAArray * pArray);

	HRESULT InternalEnumQmSAs(CQmSAArray * pArray);

	void FreeIpsecSAList();
	HRESULT CallPA();
	HRESULT GetQmPolicyByGuid(GUID guid, PIPSEC_QM_POLICY *ppPolicy);
	HRESULT InitQmPolicyTree();
	HRESULT InsertQmPolicyToTree(PIPSEC_QM_POLICY pPolicy);
	PQMPOLOCYINFO GetQmPolInfoFromTree(GUID PolicyID);
};

HRESULT CreateSpdInfo(ISpdInfo **ppSpdInfo);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\srchmflt.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    edituser.h
        Edit user dialog implementation file

	FILE HISTORY:

*/

#include "stdafx.h"
#include "mdlsdlg.h"
#include "SrchMFlt.h"
#include "spdutil.h"
#include "ncglobal.h"  // network console global defines

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSearchMMFilters dialog


CSearchMMFilters::CSearchMMFilters(ISpdInfo * pSpdInfo)
	: CModelessDlg()
{
	//{{AFX_DATA_INIT(CSearchMMFilters)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_spSpdInfo.Set(pSpdInfo);
}


void CSearchMMFilters::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSearchMMFilters)
	DDX_Control(pDX, IDC_MM_SRCH_LIST, m_listResult);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSearchMMFilters, CBaseDialog)
	//{{AFX_MSG_MAP(CSearchMMFilters)
	ON_BN_CLICKED(IDC_MM_SEARCH, OnButtonSearch)
	ON_BN_CLICKED(IDC_MM_SRCH_SRC_ANY, OnSrcOptionClicked)
	ON_BN_CLICKED(IDC_MM_SRCH_SRC_SPEC, OnSrcOptionClicked)
	ON_BN_CLICKED(IDC_MM_SRCH_DEST_ANY, OnDestOptionClicked)
	ON_BN_CLICKED(IDC_MM_SRCH_SRC_ME, OnSrcMeOptionClicked)
	ON_BN_CLICKED(IDC_MM_SRCH_DST_ME, OnDstMeOptionClicked)
	ON_BN_CLICKED(IDC_MM_SRCH_DEST_SPEC, OnDestOptionClicked)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//To manually create the IP control and disable mirroring if the parent dialog is mirrored
//
//Arguments: 
//          uID  [IN]   the control that the new IP control should overwrite
//			uIDIpCtr [IN] the ID of the IP control to create
//
//Note:  $REVIEW (nsun) this should be removed after the snapin is themed since IP controls
//       in comctl v6 will handle the mirroring by itself
//
HWND CSearchMMFilters::CreateIPControl(UINT uID, UINT uIDIpCtl)
{
	HWND hwndIPControl = NULL;
	RECT rcClient;  // client area of parent window
	CWnd* pWnd = GetDlgItem(uID);
	if (pWnd)
	{
		// get pos info from our template static and then make sure it is hidden
		pWnd->GetWindowRect(&rcClient);
		pWnd->ShowWindow (SW_HIDE);
		ScreenToClient (&rcClient);
		
		//$REVIEW WS_EX_NOINHERITLAYOUT is to fix the mirroring problem of IP control
		//See WinXP bug 261926. We should remove that we switch the comctl32 v6
		LONG lExStyles = 0;
		LONG lExStyles0 = 0;
		
		if (m_hWnd)
		{
			lExStyles0 = lExStyles = GetWindowLong(m_hWnd, GWL_EXSTYLE);
			if (lExStyles & WS_EX_LAYOUTRTL)
			{
				lExStyles |= WS_EX_NOINHERITLAYOUT;
				SetWindowLong(m_hWnd, GWL_EXSTYLE, lExStyles);
			}
		}
		
		// create the new edit control
		hwndIPControl = ::CreateWindowEx(WS_EX_NOINHERITLAYOUT, WC_IPADDRESS, NULL, WS_CHILD | WS_VISIBLE | WS_TABSTOP | WS_BORDER,
			rcClient.left,
			rcClient.top,
			rcClient.right - rcClient.left,
			rcClient.bottom - rcClient.top,
			GetSafeHwnd(),
			(HMENU) IntToPtr(uIDIpCtl),
			AfxGetInstanceHandle (), //g_hinst,
			NULL);
		
		if (lExStyles0 != lExStyles && m_hWnd)
		{
			SetWindowLong(m_hWnd, GWL_EXSTYLE, lExStyles0);
		}
		
		// move the control directly behind the pWnd in the Z order
		if (hwndIPControl)
		{
			::SetWindowPos (hwndIPControl, pWnd->GetSafeHwnd(), 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
		}
		
	}
	
	return hwndIPControl;
}

/////////////////////////////////////////////////////////////////////////////
// CSearchMMFilters message handlers

BOOL CSearchMMFilters::OnInitDialog()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HWND hIpCtrl = CreateIPControl(IDC_MM_SRCH_SRC_IP_TEXT, IDC_MM_SRCH_SRC_IP);
	m_ipSrc.Create(hIpCtrl);

	hIpCtrl = CreateIPControl(IDC_MM_SRCH_DEST_IP_TEXT, IDC_MM_SRCH_DEST_IP);
	m_ipDest.Create(hIpCtrl);

	m_ipSrc.SetFieldRange(0, 1, 223);
	m_ipDest.SetFieldRange(0, 1, 223);

	CBaseDialog::OnInitDialog();

	CString st;

	CheckDlgButton(IDC_MM_SRCH_SRC_ANY, BST_CHECKED);
	OnSrcOptionClicked();
	CheckDlgButton(IDC_MM_SRCH_DEST_ANY, BST_CHECKED);
	OnDestOptionClicked();

	AddIpAddrsToCombo();

	//disable the two combo boxes
	((CWnd*)GetDlgItem(IDC_MM_SRCH_SRC_ME_COMBO))->EnableWindow(FALSE);
	((CWnd*)GetDlgItem(IDC_MM_SRCH_DST_ME_COMBO))->EnableWindow(FALSE);

	CheckDlgButton(IDC_MM_SRCH_INBOUND, BST_CHECKED);
	CheckDlgButton(IDC_MM_SRCH_OUTBOUND, BST_CHECKED);

	CheckDlgButton(IDC_MM_SRCH_RADIO_BEST, BST_CHECKED);

	int nWidth;
    nWidth = m_listResult.GetStringWidth(_T("555.555.555.555 - "));
	st.LoadString(IDS_COL_FLTR_SRC);
	m_listResult.InsertColumn(0, st,  LVCFMT_LEFT, nWidth);

	nWidth = m_listResult.GetStringWidth(_T("555.555.555.555 - "));
	st.LoadString(IDS_COL_FLTR_DEST);
	m_listResult.InsertColumn(1, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_FLTR_DIR_OUT);
	nWidth = m_listResult.GetStringWidth((LPCTSTR)st) + 20;
	st.LoadString(IDS_FILTER_PP_COL_DIRECTION);
	m_listResult.InsertColumn(2, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_FILTER_PP_COL_WEIGHT);
	nWidth = m_listResult.GetStringWidth((LPCTSTR)st) + 20;
	m_listResult.InsertColumn(3, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_FLTER_PP_COL_IKE_POL);
	nWidth = m_listResult.GetStringWidth((LPCTSTR)st) + 20;
	m_listResult.InsertColumn(4, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_FLTER_PP_COL_MM_AUTH);
	nWidth = m_listResult.GetStringWidth((LPCTSTR)st) + 20;
	m_listResult.InsertColumn(5, st,  LVCFMT_LEFT, nWidth);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CSearchMMFilters::AddIpAddrsToCombo()
{
	PMIB_IPADDRTABLE pIpTable;
	ULONG dwSize=0;
	ULONG index;
	DWORD dwRet;
	CString strIP;

	
    dwRet = GetIpAddrTable(
              NULL,       // buffer for mapping table 
              &dwSize,    // size of buffer 
              FALSE       // sort the table 
              );


	
    if( ERROR_INSUFFICIENT_BUFFER != dwRet && ERROR_SUCCESS != dwRet )	{
        return;
	} else {
		pIpTable = (PMIB_IPADDRTABLE) LocalAlloc(LMEM_ZEROINIT,dwSize);
	}

    dwRet = GetIpAddrTable(
              pIpTable,  // buffer for mapping table 
              &dwSize,                 // size of buffer 
              FALSE                     // sort the table 
              );

	if(ERROR_SUCCESS != dwRet) {
		if(pIpTable)
			LocalFree(pIpTable);
		return;
	}

	CComboBox* pComboSrc = (CComboBox*) GetDlgItem(IDC_MM_SRCH_SRC_ME_COMBO);
	CComboBox* pComboDst = (CComboBox*) GetDlgItem(IDC_MM_SRCH_DST_ME_COMBO);

	for(index=0; index<pIpTable->dwNumEntries; index++)	{
		strIP.Format(_T("%d.%d.%d.%d"),GET_SOCKADDR(pIpTable->table[index].dwAddr));
		if(lstrcmp(strIP, _T("127.0.0.1"))) {
            pComboSrc->AddString(strIP);
			pComboDst->AddString(strIP);
		}
	}

	if(pIpTable)
		LocalFree(pIpTable);

}


void CSearchMMFilters::OnButtonSearch()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CMmFilterInfo fltr;
	CMmFilterInfoArray arrMatchFltrs;

	if (!LoadConditionInfoFromControls(&fltr))
		return;

	DWORD dwNum = 1000; //TODO BUGBUG, should change to 0 to mean search all matches
	if(IsDlgButtonChecked(IDC_MM_SRCH_RADIO_BEST))
	{
		dwNum = 1;
	}
	m_spSpdInfo->GetMatchMMFilters(&fltr, dwNum, &arrMatchFltrs);

	PopulateFilterListToControl(&arrMatchFltrs);

	FreeItemsAndEmptyArray(arrMatchFltrs);

}


BOOL CSearchMMFilters::LoadConditionInfoFromControls(CMmFilterInfo * pFltr)
{
	
	CString st;

	if (IsDlgButtonChecked(IDC_MM_SRCH_SRC_ANY))
	{
		pFltr->m_SrcAddr.AddrType = IP_ADDR_SUBNET;
		pFltr->m_SrcAddr.uIpAddr = 0;
		pFltr->m_SrcAddr.uSubNetMask = 0;
	} 
	else if (IsDlgButtonChecked(IDC_MM_SRCH_SRC_ME))
	{
		USES_CONVERSION;

		pFltr->m_SrcAddr.AddrType = IP_ADDR_UNIQUE;
		CComboBox* pCombo = (CComboBox*) GetDlgItem(IDC_MM_SRCH_SRC_ME_COMBO);
		INT nSelected = pCombo->GetCurSel();
		if( CB_ERR != nSelected)
		{
		    pCombo->GetLBText(nSelected, st);
            try
            {
                pFltr->m_SrcAddr.uIpAddr = inet_addr(T2A((LPCTSTR)st));
            }
            catch(...)
            {
                AfxMessageBox(IDS_ERR_OUTOFMEMORY);
                return FALSE;
            }
		    pFltr->m_SrcAddr.uSubNetMask = 0xFFFFFFFF;
		}
	}
	else
	{
		USES_CONVERSION;

		pFltr->m_SrcAddr.AddrType = IP_ADDR_UNIQUE;
		m_ipSrc.GetAddress(st);
        try
        {
            pFltr->m_SrcAddr.uIpAddr = inet_addr(T2A((LPCTSTR)st));
        }
        catch(...)
        {
            AfxMessageBox(IDS_ERR_OUTOFMEMORY);
            return FALSE;
        }
		pFltr->m_SrcAddr.uSubNetMask = 0xFFFFFFFF;
	}

	if (IsDlgButtonChecked(IDC_MM_SRCH_DEST_ANY))
	{
		pFltr->m_DesAddr.AddrType = IP_ADDR_SUBNET;
		pFltr->m_DesAddr.uIpAddr = 0;
		pFltr->m_DesAddr.uSubNetMask = 0;
	}
	else if (IsDlgButtonChecked(IDC_MM_SRCH_DST_ME))
	{
		USES_CONVERSION;

		pFltr->m_DesAddr.AddrType = IP_ADDR_UNIQUE;
		CComboBox* pCombo = (CComboBox*) GetDlgItem(IDC_MM_SRCH_DST_ME_COMBO);
		INT nSelected = pCombo->GetCurSel();
		if( CB_ERR != nSelected)
		{
		    pCombo->GetLBText(nSelected, st);
            try
            {
                pFltr->m_DesAddr.uIpAddr = inet_addr(T2A((LPCTSTR)st));
            }
            catch(...)
            {
                AfxMessageBox(IDS_ERR_OUTOFMEMORY);
                return FALSE;
            }
		    pFltr->m_DesAddr.uSubNetMask = 0xFFFFFFFF;
		}
	}
	else
	{
		USES_CONVERSION;

		pFltr->m_DesAddr.AddrType = IP_ADDR_UNIQUE;
		m_ipDest.GetAddress(st);
        try
        {
            pFltr->m_DesAddr.uIpAddr = inet_addr(T2A((LPCTSTR)st));
        }
        catch(...)
        {
            AfxMessageBox(IDS_ERR_OUTOFMEMORY);
            return FALSE;
        }
		pFltr->m_DesAddr.uSubNetMask = 0xFFFFFFFF;
	}

	if (IsDlgButtonChecked(IDC_MM_SRCH_INBOUND))
	{
		//if both inbound and outbound are chosen, then 
		//set the driection valude as 0
		if (IsDlgButtonChecked(IDC_MM_SRCH_OUTBOUND))
		{
			pFltr->m_dwDirection = 0;
		}
		else
		{
			pFltr->m_dwDirection = FILTER_DIRECTION_INBOUND;
		}
	}
	else if (IsDlgButtonChecked(IDC_MM_SRCH_OUTBOUND))
	{
		pFltr->m_dwDirection = FILTER_DIRECTION_OUTBOUND;
	}
	else
	{
		::AfxMessageBox(IDS_ERR_NO_DIRECTION);
		return FALSE;
	}

	return TRUE;
}

void CSearchMMFilters::PopulateFilterListToControl(CMmFilterInfoArray * parrFltrs)
{
	CString st;
	
	m_listResult.DeleteAllItems();
	int nRows = -1;
	for (int i = 0; i < parrFltrs->GetSize(); i++)
	{
		nRows++;
		nRows = m_listResult.InsertItem(nRows, _T(""));

		if (-1 != nRows)
		{
			AddressToString((*parrFltrs)[i]->m_SrcAddr, &st);
			m_listResult.SetItemText(nRows, 0, st);

			AddressToString((*parrFltrs)[i]->m_DesAddr, &st);
			m_listResult.SetItemText(nRows, 1, st);

			DirectionToString((*parrFltrs)[i]->m_dwDirection, &st);
			m_listResult.SetItemText(nRows, 2, st);

			st.Format(_T("%d"), (*parrFltrs)[i]->m_dwWeight);
			m_listResult.SetItemText(nRows, 3, st);

                        st = (*parrFltrs)[i]->m_stPolicyName;
			if( (*parrFltrs)[i]->m_dwFlags & IPSEC_MM_POLICY_DEFAULT_POLICY )
			{
				AfxFormatString1(st, IDS_POL_DEFAULT, (LPCTSTR) (*parrFltrs)[i]->m_stPolicyName);
			}
			
                        m_listResult.SetItemText(nRows, 4, st);

			m_listResult.SetItemText(nRows, 5, (*parrFltrs)[i]->m_stAuthDescription);

			m_listResult.SetItemData(nRows, i);
		}
	}
        
        if ( 0 == parrFltrs->GetSize() )
        {
             AfxMessageBox(IDS_ERROR_NOMATCH_FILTER);
        }

}

void CSearchMMFilters::OnSrcOptionClicked()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	BOOL fAny = IsDlgButtonChecked(IDC_MM_SRCH_SRC_ANY);

	((CWnd*)GetDlgItem(IDC_MM_SRCH_SRC_ME_COMBO))->EnableWindow(FALSE);
	

	if (fAny)
	{
		m_ipSrc.ClearAddress();
	}

	if (m_ipSrc.m_hIPaddr)
	{
		::EnableWindow(m_ipSrc.m_hIPaddr, !fAny);
	}

	CComboBox* pCombo = (CComboBox*) GetDlgItem(IDC_MM_SRCH_SRC_ME_COMBO);
	pCombo->SetCurSel(-1);
}


void CSearchMMFilters::OnDestOptionClicked()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	BOOL fAny = IsDlgButtonChecked(IDC_MM_SRCH_DEST_ANY);

	((CWnd*)GetDlgItem(IDC_MM_SRCH_DST_ME_COMBO))->EnableWindow(FALSE);

	if (fAny)
	{
		m_ipDest.ClearAddress();
	}
	
	if (m_ipDest.m_hIPaddr)
	{
		::EnableWindow(m_ipDest.m_hIPaddr, !fAny);
	}

	CComboBox* pCombo = (CComboBox*) GetDlgItem(IDC_MM_SRCH_DST_ME_COMBO);
    pCombo->SetCurSel(-1);
	
}

void CSearchMMFilters::OnSrcMeOptionClicked()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	
	((CWnd*)GetDlgItem(IDC_MM_SRCH_SRC_ME_COMBO))->EnableWindow(TRUE);

	::EnableWindow(m_ipSrc.m_hIPaddr, FALSE);

	CComboBox* pCombo = (CComboBox*) GetDlgItem(IDC_MM_SRCH_SRC_ME_COMBO);
	int nCount = pCombo->GetCount();
    if (nCount > 0) {
       pCombo->SetCurSel(0);
	}

}

void CSearchMMFilters::OnDstMeOptionClicked()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	((CWnd*)GetDlgItem(IDC_MM_SRCH_DST_ME_COMBO))->EnableWindow(TRUE);

	::EnableWindow(m_ipDest.m_hIPaddr, FALSE);
	
	CComboBox* pCombo = (CComboBox*) GetDlgItem(IDC_MM_SRCH_DST_ME_COMBO);
    int nCount = pCombo->GetCount();
    if (nCount > 0) {
       pCombo->SetCurSel(0);
	}
}

void CSearchMMFilters::OnOK()
{
	//Since this is a modelless dialog, need to call DestroyWindow
	DestroyWindow();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\spddb.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    spddb.h

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "DynamLnk.h"
#include "spddb.h"
#include "spdutil.h"
#include "ipsecshr.h"

#include "security.h"
#include "lm.h"
#include "service.h"

#define AVG_PREFERRED_ENUM_COUNT       40

#define DEFAULT_SECURITY_PKG    _T("negotiate")
#define NT_SUCCESS(Status)      ((NTSTATUS)(Status) >= 0)
#define STATUS_SUCCESS          ((NTSTATUS)0x00000000L)

// internal functions
BOOL    IsUserAdmin(LPCTSTR pszMachine, PSID    AccountSid);
BOOL    LookupAliasFromRid(LPWSTR TargetComputer, DWORD Rid, LPWSTR Name, PDWORD cchName);
DWORD   ValidateDomainAccount(IN CString Machine, IN CString UserName, IN CString Domain, OUT PSID * AccountSid);
NTSTATUS ValidatePassword(IN LPCWSTR UserName, IN LPCWSTR Domain, IN LPCWSTR Password);
DWORD   GetCurrentUser(CString & strAccount);


template <class T>
void
FreeItemsAndEmptyArray (
    T& array)
{
	for (int i = 0; i < array.GetSize(); i++)
	{
		delete array.GetAt(i);
	}
	array.RemoveAll();
}

DWORD GetCurrentUser(CString & strAccount)
{
    LPBYTE pBuf;

    NET_API_STATUS status = NetWkstaUserGetInfo(NULL, 1, &pBuf);
    if (status == NERR_Success)
    {
        strAccount.Empty();

        WKSTA_USER_INFO_1 * pwkstaUserInfo = (WKSTA_USER_INFO_1 *) pBuf;
 
        strAccount = pwkstaUserInfo->wkui1_logon_domain;
        strAccount += _T("\\");
        strAccount += pwkstaUserInfo->wkui1_username;

        NetApiBufferFree(pBuf);
    }

    return (DWORD) status;
}

/*!--------------------------------------------------------------------------
    IsAdmin
        Connect to the remote machine as administrator with user-supplied
        credentials to see if the user has admin priviledges

        Returns
            TRUE - the user has admin rights
            FALSE - if user doesn't
    Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
DWORD IsAdmin(LPCTSTR szMachineName, LPCTSTR szAccount, LPCTSTR szPassword, BOOL * pIsAdmin)
{
    CString         stAccount;
    CString         stDomain;
    CString         stUser;
    CString         stMachineName;
    DWORD           dwStatus;
    BOOL            fIsAdmin = FALSE;

    // get the current user info
    if (szAccount == NULL)
    {
        GetCurrentUser(stAccount);
    }
    else
    {
        stAccount = szAccount;
    }
    
    // separate the user and domain
    int nPos = stAccount.Find(_T("\\"));
    stDomain = stAccount.Left(nPos);
    stUser = stAccount.Right(stAccount.GetLength() - nPos - 1);

    // build the machine string
    stMachineName = szMachineName;
    if ( stMachineName.Left(2) != TEXT( "\\\\" ) )
    {
        stMachineName = TEXT( "\\\\" ) + stMachineName;
    }

    // validate the domain account and get the sid 
    PSID connectSid;

    dwStatus = ValidateDomainAccount( stMachineName, stUser, stDomain, &connectSid );
    if ( dwStatus != ERROR_SUCCESS  ) 
    {
        goto Error;
    }

    // if a password was supplied, is it correct?
    if (szPassword)
    {
        dwStatus = ValidatePassword( stUser, stDomain, szPassword );

        if ( dwStatus != SEC_E_OK ) 
        {
            switch ( dwStatus ) 
            {
                case SEC_E_LOGON_DENIED:
                    dwStatus = ERROR_INVALID_PASSWORD;
                    break;

                case SEC_E_INVALID_HANDLE:
                    dwStatus = ERROR_INTERNAL_ERROR;
                    break;

                default:
                    dwStatus = ERROR_INTERNAL_ERROR;
                    break;
            } // end of switch

            goto Error;

        } // Did ValidatePassword succeed?
    }

    // now check the machine to see if this account has admin access
    fIsAdmin = IsUserAdmin( stMachineName, connectSid );

Error:
    if (pIsAdmin)
        *pIsAdmin = fIsAdmin;

    return dwStatus;
}


BOOL
IsUserAdmin(LPCTSTR pszMachine,
            PSID    AccountSid)

/*++

Routine Description:

    Determine if the specified account is a member of the local admin's group

Arguments:

    AccountSid - pointer to service account Sid

Return Value:

    True if member

--*/

{
    NET_API_STATUS status;
    DWORD count;
    WCHAR adminGroupName[UNLEN+1];
    DWORD cchName = UNLEN;
    PLOCALGROUP_MEMBERS_INFO_0 grpMemberInfo;
    PLOCALGROUP_MEMBERS_INFO_0 pInfo;
    DWORD entriesRead;
    DWORD totalEntries;
    DWORD_PTR resumeHandle = NULL;
    DWORD bufferSize = 128;
    BOOL foundEntry = FALSE;

    // get the name of the admin's group

    if (!LookupAliasFromRid(NULL,
                            DOMAIN_ALIAS_RID_ADMINS,
                            adminGroupName,
                            &cchName)) {
        return(FALSE);
    }

    // get the Sids of the members of the admin's group

    do 
    {
        status = NetLocalGroupGetMembers(pszMachine,
                                         adminGroupName,
                                         0,             // level 0 - just the Sid
                                         (LPBYTE *)&grpMemberInfo,
                                         bufferSize,
                                         &entriesRead,
                                         &totalEntries,
                                         &resumeHandle);

        bufferSize *= 2;
        if ( status == ERROR_MORE_DATA ) 
        {
            // we got some of the data but I want it all; free this buffer and
            // reset the context handle for the API

            NetApiBufferFree( grpMemberInfo );
            resumeHandle = NULL;
        }
    } while ( status == NERR_BufTooSmall || status == ERROR_MORE_DATA );

    if ( status == NERR_Success ) 
    {
        // loop through the members of the admin group, comparing the supplied
        // Sid to that of the group members' Sids

        for ( count = 0, pInfo = grpMemberInfo; count < totalEntries; ++count, ++pInfo ) 
        {
            if ( EqualSid( AccountSid, pInfo->lgrmi0_sid )) 
            {
                foundEntry = TRUE;
                break;
            }
        }

        NetApiBufferFree( grpMemberInfo );
    }

    return foundEntry;
}

//
//
//

BOOL
LookupAliasFromRid(
    LPWSTR TargetComputer,
    DWORD Rid,
    LPWSTR Name,
    PDWORD cchName
    )
{
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    SID_NAME_USE snu;
    PSID pSid;
    WCHAR DomainName[DNLEN+1];
    DWORD cchDomainName = DNLEN;
    BOOL bSuccess = FALSE;

    //
    // Sid is the same regardless of machine, since the well-known
    // BUILTIN domain is referenced.
    //

    if(AllocateAndInitializeSid(&sia,
                                2,
                                SECURITY_BUILTIN_DOMAIN_RID,
                                Rid,
                                0, 0, 0, 0, 0, 0,
                                &pSid)) {

        bSuccess = LookupAccountSidW(TargetComputer,
                                     pSid,
                                     Name,
                                     cchName,
                                     DomainName,
                                     &cchDomainName,
                                     &snu);

        FreeSid(pSid);
    }

    return bSuccess;
} // LookupAliasFromRid

DWORD
ValidateDomainAccount(
    IN CString Machine,
    IN CString UserName,
    IN CString Domain,
    OUT PSID * AccountSid
    )

/*++

Routine Description:

    For the given credentials, look up the account SID for the specified
    domain. As a side effect, the Sid is stored in theData->m_Sid.

Arguments:

    pointers to strings that describe the user name, domain name, and password

    AccountSid - address of pointer that receives the SID for this user

Return Value:

    TRUE if everything validated ok.

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwSidSize = 128;
    DWORD dwDomainNameSize = 128;
    LPWSTR pwszDomainName;
    SID_NAME_USE SidType;
    CString domainAccount;
    PSID accountSid;

    domainAccount = Domain + _T("\\") + UserName;

    do {
        // Attempt to allocate a buffer for the SID. Note that apparently in the
        // absence of any error theData->m_Sid is freed only when theData goes
        // out of scope.

        accountSid = LocalAlloc( LMEM_FIXED, dwSidSize );
        pwszDomainName = (LPWSTR) LocalAlloc( LMEM_FIXED, dwDomainNameSize * sizeof(WCHAR) );

        // Was space allocated for the SID and domain name successfully?

        if ( accountSid == NULL || pwszDomainName == NULL ) {
            if ( accountSid != NULL ) {
                LocalFree( accountSid );
            }

            if ( pwszDomainName != NULL ) {
                LocalFree( pwszDomainName );
            }

            //FATALERR( IDS_ERR_NOT_ENOUGH_MEMORY, GetLastError() );    // no return
            break;
        }

        // Attempt to Retrieve the SID and domain name. If LookupAccountName failes
        // because of insufficient buffer size(s) dwSidSize and dwDomainNameSize
        // will be set correctly for the next attempt.

        if ( !LookupAccountName( Machine,
                                 domainAccount,
                                 accountSid,
                                 &dwSidSize,
                                 pwszDomainName,
                                 &dwDomainNameSize,
                                 &SidType ))
        {
            // free the Sid buffer and find out why we failed
            LocalFree( accountSid );

            dwStatus = GetLastError();
        }

        // domain name isn't needed at any time
        LocalFree( pwszDomainName );
        pwszDomainName = NULL;

    } while ( dwStatus == ERROR_INSUFFICIENT_BUFFER );

    if ( dwStatus == ERROR_SUCCESS ) {
        *AccountSid = accountSid;
    }

    return dwStatus;
} // ValidateDomainAccount

NTSTATUS
ValidatePassword(
    IN LPCWSTR UserName,
    IN LPCWSTR Domain,
    IN LPCWSTR Password
    )
/*++

Routine Description:

    Uses SSPI to validate the specified password

Arguments:

    UserName - Supplies the user name

    Domain - Supplies the user's domain

    Password - Supplies the password

Return Value:

    TRUE if the password is valid.

    FALSE otherwise.

--*/

{
    SECURITY_STATUS SecStatus;
    SECURITY_STATUS AcceptStatus;
    SECURITY_STATUS InitStatus;
    CredHandle ClientCredHandle;
    CredHandle ServerCredHandle;
    BOOL ClientCredAllocated = FALSE;
    BOOL ServerCredAllocated = FALSE;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    TimeStamp Lifetime;
    ULONG ContextAttributes;
    PSecPkgInfo PackageInfo = NULL;
    ULONG ClientFlags;
    ULONG ServerFlags;
    SEC_WINNT_AUTH_IDENTITY_W AuthIdentity;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;

    SecBufferDesc *pChallengeDesc      = NULL;
    CtxtHandle *  pClientContextHandle = NULL;
    CtxtHandle *  pServerContextHandle = NULL;

    AuthIdentity.User = (LPWSTR)UserName;
    AuthIdentity.UserLength = lstrlenW(UserName);
    AuthIdentity.Domain = (LPWSTR)Domain;
    AuthIdentity.DomainLength = lstrlenW(Domain);
    AuthIdentity.Password = (LPWSTR)Password;
    AuthIdentity.PasswordLength = lstrlenW(Password);
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( DEFAULT_SECURITY_PKG, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }

    //
    // Acquire a credential handle for the server side
    //
    SecStatus = AcquireCredentialsHandle(
                    NULL,
                    DEFAULT_SECURITY_PKG,
                    SECPKG_CRED_INBOUND,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &ServerCredHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }
    ServerCredAllocated = TRUE;

    //
    // Acquire a credential handle for the client side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    DEFAULT_SECURITY_PKG,
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &ClientCredHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }
    ClientCredAllocated = TRUE;

    NegotiateBuffer.pvBuffer = LocalAlloc( 0, PackageInfo->cbMaxToken ); // [CHKCHK] check or allocate this earlier //
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        goto error_exit;
    }

    ChallengeBuffer.pvBuffer = LocalAlloc( 0, PackageInfo->cbMaxToken ); // [CHKCHK]
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        goto error_exit;
    }

    do {

        //
        // Get the NegotiateMessage (ClientSide)
        //

        NegotiateDesc.ulVersion = 0;
        NegotiateDesc.cBuffers = 1;
        NegotiateDesc.pBuffers = &NegotiateBuffer;

        NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
        NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;

        ClientFlags = 0; // ISC_REQ_MUTUAL_AUTH | ISC_REQ_REPLAY_DETECT; // [CHKCHK] 0

        InitStatus = InitializeSecurityContext(
                         &ClientCredHandle,
                         pClientContextHandle, // (NULL on the first pass, partially formed ctx on the next)
                         NULL,                 // [CHKCHK] szTargetName
                         ClientFlags,
                         0,                    // Reserved 1
                         SECURITY_NATIVE_DREP,
                         pChallengeDesc,       // (NULL on the first pass)
                         0,                    // Reserved 2
                         &ClientContextHandle,
                         &NegotiateDesc,
                         &ContextAttributes,
                         &Lifetime );

        // BUGBUG - the following call to NT_SUCCESS should be replaced with something.

        if ( !NT_SUCCESS(InitStatus) ) {
            SecStatus = InitStatus;
            goto error_exit;
        }

        // ValidateBuffer( &NegotiateDesc ) // [CHKCHK]

        pClientContextHandle = &ClientContextHandle;

        //
        // Get the ChallengeMessage (ServerSide)
        //

        NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
        ChallengeDesc.ulVersion = 0;
        ChallengeDesc.cBuffers = 1;
        ChallengeDesc.pBuffers = &ChallengeBuffer;

        ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
        ChallengeBuffer.BufferType = SECBUFFER_TOKEN;

        ServerFlags = ASC_REQ_ALLOW_NON_USER_LOGONS; // ASC_REQ_EXTENDED_ERROR; [CHKCHK]

        AcceptStatus = AcceptSecurityContext(
                        &ServerCredHandle,
                        pServerContextHandle,   // (NULL on the first pass)
                        &NegotiateDesc,
                        ServerFlags,
                        SECURITY_NATIVE_DREP,
                        &ServerContextHandle,
                        &ChallengeDesc,
                        &ContextAttributes,
                        &Lifetime );


        // BUGBUG - the following call to NT_SUCCESS should be replaced with something.

        if ( !NT_SUCCESS(AcceptStatus) ) {
            SecStatus = AcceptStatus;
            goto error_exit;
        }

        // ValidateBuffer( &NegotiateDesc ) // [CHKCHK]

        pChallengeDesc = &ChallengeDesc;
        pServerContextHandle = &ServerContextHandle;


    } while ( AcceptStatus == SEC_I_CONTINUE_NEEDED ); // || InitStatus == SEC_I_CONTINUE_NEEDED );

error_exit:
    if (ServerCredAllocated) {
        FreeCredentialsHandle( &ServerCredHandle );
    }
    if (ClientCredAllocated) {
        FreeCredentialsHandle( &ClientCredHandle );
    }

    //
    // Final Cleanup
    //

    if ( NegotiateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( AuthenticateBuffer.pvBuffer );
    }
    return(SecStatus);
} // ValidatePassword


DEBUG_DECLARE_INSTANCE_COUNTER(CSpdInfo);

CSpdInfo::CSpdInfo() :
	  m_cRef(1)
{
        m_Init=0;
        m_Active=0;
		m_hSubAllocator = NULL;

	DEBUG_INCREMENT_INSTANCE_COUNTER(CSpdInfo);
}

CSpdInfo::~CSpdInfo()
{
	DEBUG_DECREMENT_INSTANCE_COUNTER(CSpdInfo);
	CSingleLock cLock(&m_csData);
	
	cLock.Lock();

	//Convert the data to our internal data structure
	FreeItemsAndEmptyArray(m_arrayFilters);
	FreeItemsAndEmptyArray(m_arraySpecificFilters);
	FreeItemsAndEmptyArray(m_arrayMmFilters);
	FreeItemsAndEmptyArray(m_arrayMmSpecificFilters);
	FreeItemsAndEmptyArray(m_arrayMmPolicies);
	FreeItemsAndEmptyArray(m_arrMmAuthMethods);
	FreeItemsAndEmptyArray(m_arrayMmSAs);
	FreeItemsAndEmptyArray(m_arrayQmSAs);
	FreeItemsAndEmptyArray(m_arrayQmPolicies);

	if ( m_hSubAllocator )
	{
		DestroySubAllocator( m_hSubAllocator );
		m_hSubAllocator = NULL;
	}

	cLock.Unlock();

}

// Although this object is not a COM Interface, we want to be able to
// take advantage of recounting, so we have basic addref/release/QI support
IMPLEMENT_ADDREF_RELEASE(CSpdInfo)

IMPLEMENT_SIMPLE_QUERYINTERFACE(CSpdInfo, ISpdInfo)

HRESULT CSpdInfo::SetComputerName(LPTSTR pszName)
{
	m_stMachineName = pszName;
	return S_OK;
}

HRESULT CSpdInfo::GetComputerName(CString * pstName)
{
	Assert(pstName);

	if (NULL == pstName)
		return E_INVALIDARG;

	
	*pstName = m_stMachineName;

	return S_OK;
	
}


//Call the SPD to enum policies and put it to our array
HRESULT CSpdInfo::InternalEnumMmAuthMethods(
						CMmAuthMethodsArray * pArray,
						DWORD dwPreferredNum /* = 0 by default get all entries*/)
{
	Assert(pArray);

	HRESULT		 hr = hrOK;
	PMM_AUTH_METHODS   pAuths = NULL;
	PINT_MM_AUTH_METHODS   pIntAuths = NULL;
	DWORD	dwNumAuths = 0;
	DWORD	dwTemp = 0;
	DWORD	dwResumeHandle = 0;
    DWORD   dwVersion = 0;
    DWORD   dwRet;

	
	FreeItemsAndEmptyArray(*pArray);

	do
	{
		dwTemp = 0;
		CWRg(::EnumMMAuthMethods(
					(LPTSTR)(LPCTSTR)m_stMachineName,
                    dwVersion,
                    NULL,           // Template.
                    0,              // Flags.
					dwPreferredNum,
					&pAuths,
                    &dwTemp,
                    &dwResumeHandle,
                    NULL
                    ));
		
		pArray->SetSize(dwNumAuths + dwTemp);
		for (int i = 0; i < (int)dwTemp; i++)
		{
			CMmAuthMethods * pAuth = new CMmAuthMethods;
			if (NULL == pAuth)
			{
				hr = E_OUTOFMEMORY;
				break;
			}

			dwRet = ConvertExtMMAuthToInt(
			     pAuths + i,
			     &pIntAuths
			     );

            hr = HRESULT_FROM_WIN32( dwRet );
			
            if ( FAILED(hr) ) {
				SPDApiBufferFree(pAuths);
				goto Error;
			}

			*pAuth = *(pIntAuths);
			(*pArray)[dwNumAuths + i] = pAuth;

			FreeIntMMAuthMethods(pIntAuths);
		}
		dwNumAuths += dwTemp;

		if (pAuths)
		{
			SPDApiBufferFree(pAuths);
		}
	}while (TRUE);  
	// it will automatically break out from the loop when SPD returns ERROR_NO_DATA

Error:
	//this particular error is because we don't have any data. Ignore it
	if (HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
		hr = hrOK;
	return hr;
	
}


HRESULT CSpdInfo::EnumMmAuthMethods()
{
	HRESULT hr = hrOK;
	int i;
	
	CSingleLock cLock(&m_csData);

	CMmAuthMethodsArray arrayTemp;
	CORg(InternalEnumMmAuthMethods(
					  &arrayTemp
                      ));

	cLock.Lock();
	FreeItemsAndEmptyArray(m_arrMmAuthMethods);
	m_arrMmAuthMethods.Copy(arrayTemp);

Error:
	//this particular error is because we don't have any MM policies. Ignore it
	if (HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
		hr = hrOK;

	return hr;
}

//Call the SPD to enum all Main mode SAs
HRESULT CSpdInfo::InternalEnumMmSAs(
						CMmSAArray * pArray)
{
	HRESULT			hr = hrOK;
	
	PIPSEC_MM_SA	pSAs = NULL;
	DWORD			dwNumEntries = 10;
	DWORD			dwTotal = 0;
	DWORD			dwEnumHandle = 0;
    IPSEC_MM_SA     MMTemplate;
    DWORD           dwVersion = 0;

	int				i;

	FreeItemsAndEmptyArray(*pArray);
    memset(&MMTemplate,0,sizeof(IPSEC_MM_SA));
    MMTemplate.IpVersion = IPSEC_PROTOCOL_V4;

	DWORD		dwNumSAs = 0;
	do 
	{
		dwNumEntries = 10; //we request 10 (the Max#) SAs each time
		CWRg(::EnumMMSAs(
							(LPTSTR)(LPCTSTR)m_stMachineName,
                            dwVersion,
							&MMTemplate,
                            0,
                            0,
							&pSAs,
							&dwNumEntries,
							&dwTotal,
							&dwEnumHandle,
                            NULL
							));

		pArray->SetSize(dwNumSAs + dwNumEntries);
		for (i = 0; i < (int)dwNumEntries; i++)
		{
			CMmSA * psa = new CMmSA;
			if (NULL == psa)
			{
				hr = E_OUTOFMEMORY;
				break;
			}

			*psa = *(pSAs + i);
			LoadMiscMmSAInfo(psa);
			(*pArray)[dwNumSAs + i] = psa;
		}
		dwNumSAs += dwNumEntries;

		if (pSAs)
		{
			SPDApiBufferFree(pSAs);
		}
	}while (dwTotal);
	

Error:
	//this particular error is because we don't have any data. Ignore it
	if (HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
		hr = hrOK;

	return hr;
}

HRESULT CSpdInfo::EnumMmSAs()
{
	HRESULT hr = hrOK;
	int i;

	DWORD	dwCurrentIndexType = 0;
	DWORD	dwCurrentSortOption = 0;

	
    DWORD dwNumPol = GetMmPolicyCount();
    if ( dwNumPol == 0 )
	{
		//just call the EnumMmPolicies
		EnumMmPolicies();
	}
    
    CSingleLock cLock(&m_csData);
	
    
	CMmSAArray arrayTemp;
	CORg(InternalEnumMmSAs(
					  &arrayTemp
                      ));

	cLock.Lock();
	FreeItemsAndEmptyArray(m_arrayMmSAs);
	m_arrayMmSAs.Copy(arrayTemp);
	
	//remember the original IndexType and Sort options
	dwCurrentIndexType = m_IndexMgrMmSAs.GetCurrentIndexType();
	dwCurrentSortOption = m_IndexMgrMmSAs.GetCurrentSortOption();

	m_IndexMgrMmSAs.Reset();
	for (i = 0; i < (int)m_arrayMmSAs.GetSize(); i++)
	{
		m_IndexMgrMmSAs.AddItem(m_arrayMmSAs.GetAt(i));
	}
	m_IndexMgrMmSAs.Sort(dwCurrentIndexType, dwCurrentSortOption);


Error:
	//this particular error is because we don't have any MM policies. Ignore it
	if (HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
		hr = hrOK;

	return hr;

}

//Call the SPD to enum all Quick mode SAs
HRESULT CSpdInfo::InternalEnumQmSAs(
						CQmSAArray * pArray)
{
	HRESULT			hr = hrOK;
	
	PIPSEC_QM_SA	pSAs = NULL;
	DWORD			dwNumEntries = 10;
	DWORD			dwTotal = 0;
	DWORD			dwResumeHandle = 0;
	int				i;
    DWORD           dwVersion = 0;


	FreeItemsAndEmptyArray(*pArray);

	DWORD		dwNumSAs = 0;
	do 
	{
		CWRg(::EnumQMSAs(
							(LPTSTR)(LPCTSTR)m_stMachineName,
                            dwVersion,
							NULL,		//pMMTemplate
							0,			//dwFlags
							0,			//We prefer to get all
							&pSAs,
							&dwNumEntries,
							&dwTotal,
							&dwResumeHandle,
                            NULL
							));

		pArray->SetSize(dwNumSAs + dwNumEntries);
		for (i = 0; i < (int)dwNumEntries; i++)
		{
			Assert(pSAs);
			CQmSA * psa = new CQmSA;
			if (NULL == psa)
			{
				hr = E_OUTOFMEMORY;
				break;
			}

			*psa = *(pSAs + i);
			LoadMiscQmSAInfo(psa);
			(*pArray)[dwNumSAs + i] = psa;
		}
		dwNumSAs += dwNumEntries;

		if (pSAs)
		{
			SPDApiBufferFree(pSAs);
		}
	}while (TRUE);
	

Error:
	//this particular error is because we don't have any data. Ignore it
	if (HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
		hr = hrOK;

	return hr;
}

HRESULT CSpdInfo::EnumQmSAs()
{
	HRESULT hr = hrOK;
	int i;

	DWORD	dwCurrentIndexType = 0;
	DWORD	dwCurrentSortOption = 0;

	CSingleLock cLock(&m_csData);

	
	CQmSAArray arrayTemp;

	if ( NULL == m_hSubAllocator )
	{
		CORg(InitQmPolicyTree());
	}

	CORg(InternalEnumQmSAs(
					  &arrayTemp
                      ));

	cLock.Lock();
	FreeItemsAndEmptyArray(m_arrayQmSAs);
	m_arrayQmSAs.Copy(arrayTemp);

	//remember the original IndexType and Sort options
	dwCurrentIndexType = m_IndexMgrQmSAs.GetCurrentIndexType();
	dwCurrentSortOption = m_IndexMgrQmSAs.GetCurrentSortOption();

	m_IndexMgrQmSAs.Reset();
	for (i = 0; i < (int)m_arrayQmSAs.GetSize(); i++)
	{
		m_IndexMgrQmSAs.AddItem(m_arrayQmSAs.GetAt(i));
	}
	m_IndexMgrQmSAs.Sort(dwCurrentIndexType, dwCurrentSortOption);

Error:

	return hr;

}

//Call the SPD to enum filters and put it to our array
HRESULT CSpdInfo::InternalEnumMmFilters(
						DWORD dwLevel,
						GUID guid,
						CMmFilterInfoArray * pArray,
						DWORD dwPreferredNum /* = 0 by default get all entries*/)
{
	Assert(pArray);

	HRESULT		 hr = hrOK;
	PMM_FILTER   pFilters = NULL;

	DWORD dwNumFilters = 0;
	DWORD dwTemp = 0;
	DWORD dwResumeHandle = 0;
    DWORD dwVersion = 0;
	
	FreeItemsAndEmptyArray(*pArray);

	do
	{
		dwTemp = 0;
		CWRg(::EnumMMFilters(
					(LPTSTR)(LPCTSTR)m_stMachineName,
                    dwVersion,
                    NULL,
					dwLevel,
					guid,
					dwPreferredNum,
					&pFilters,
                    &dwTemp,
                    &dwResumeHandle,
                    NULL
                    ));
		
		
		pArray->SetSize(dwNumFilters + dwTemp);
		for (int i = 0; i < (int)dwTemp; i++)
		{
			CMmFilterInfo * pFltr = new CMmFilterInfo;
			if (NULL == pFltr)
			{
				hr = E_OUTOFMEMORY;
				break;
			}

			*pFltr = *(pFilters + i);
			LoadMiscMmFilterInfo(pFltr);
			(*pArray)[dwNumFilters + i] = pFltr;
		}
		dwNumFilters += dwTemp;

		if (pFilters)
		{
			SPDApiBufferFree(pFilters);
		}
		
	}while (TRUE);  
	// it will automatically break out from the loop when SPD returns ERROR_NO_DATA

Error:
	//this particular error is because we don't have any data. Ignore it
	if (HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
		hr = hrOK;

	return hr;
	
}

HRESULT CSpdInfo::EnumMmFilters()
{
	HRESULT hr = S_OK;
	int i;

	DWORD	dwCurrentIndexType = 0;
	DWORD	dwCurrentSortOption = 0;
	DWORD dwNum = 0;


	dwNum = GetMmPolicyCount();
	if ( dwNum == 0 )
	{
		//just call the EnumMmPolicies
		EnumMmPolicies();
	}

	dwNum = 0;
	dwNum = GetMmAuthMethodsCount();
	if ( dwNum == 0 )
	{
		EnumMmAuthMethods();
	}

	CSingleLock cLock(&m_csData);
	
	//TODO we should either read all filters in one short 
	//     or create some assync way to query filters
	GUID   guid;
	ZeroMemory(&guid, sizeof(guid));
	CMmFilterInfoArray arrayTempGeneric;
	CMmFilterInfoArray arrayTempSpecific;
	CORg(InternalEnumMmFilters(
					ENUM_GENERIC_FILTERS,
					guid,
					&arrayTempGeneric
					));

	//Load the specific filters
	CORg(InternalEnumMmFilters(
					ENUM_SPECIFIC_FILTERS,
					guid,
					&arrayTempSpecific
                    ));

	cLock.Lock();
	
	FreeItemsAndEmptyArray(m_arrayMmFilters);
	m_arrayMmFilters.Copy(arrayTempGeneric);

	FreeItemsAndEmptyArray(m_arrayMmSpecificFilters);
	m_arrayMmSpecificFilters.Copy(arrayTempSpecific);

	//remember the original IndexType and Sort options
	dwCurrentIndexType = m_IndexMgrMmFilters.GetCurrentIndexType();
	dwCurrentSortOption = m_IndexMgrMmFilters.GetCurrentSortOption();

	m_IndexMgrMmFilters.Reset();
	for (i = 0; i < m_arrayMmFilters.GetSize(); i++)
	{
		m_IndexMgrMmFilters.AddItem(m_arrayMmFilters.GetAt(i));
	}
	m_IndexMgrMmFilters.SortMmFilters(dwCurrentIndexType, dwCurrentSortOption);

	//Now work on the specific filters
	//remember the original IndexType and Sort options
	dwCurrentIndexType = m_IndexMgrMmSpecificFilters.GetCurrentIndexType();
	dwCurrentSortOption = m_IndexMgrMmSpecificFilters.GetCurrentSortOption();
	m_IndexMgrMmSpecificFilters.Reset();
	for (i = 0; i < m_arrayMmSpecificFilters.GetSize(); i++)
	{
		m_IndexMgrMmSpecificFilters.AddItem(m_arrayMmSpecificFilters.GetAt(i));
	}
	m_IndexMgrMmSpecificFilters.SortMmFilters(dwCurrentIndexType, dwCurrentSortOption);

	
Error:

	return hr;

}

//Call the SPD to enum filters and put it to our array
HRESULT CSpdInfo::InternalEnumTransportFilters(
						DWORD dwLevel,
						GUID guid,
						CFilterInfoArray * pArray,
						DWORD dwPreferredNum /* = 0 by default get all entries*/)
{
	Assert(pArray);

	HRESULT				hr = hrOK;
	PTRANSPORT_FILTER   pFilters = NULL;

	DWORD	dwNumFilters = 0;
	DWORD	dwTemp = 0;
	DWORD	dwResumeHandle = 0;
    DWORD   dwVersion = 0;
	
	
	FreeItemsAndEmptyArray(*pArray);

	do
	{
		dwTemp = 0;
		CWRg(::EnumTransportFilters(
					(LPTSTR)(LPCTSTR)m_stMachineName,
                    dwVersion,
                    NULL,
					dwLevel,
					guid,
					dwPreferredNum,
					&pFilters,
                    &dwTemp,
                    &dwResumeHandle,
                    NULL
                    ));
		
		
		pArray->SetSize(dwNumFilters + dwTemp);
		for (int i = 0; i < (int)dwTemp; i++)
		{
			CFilterInfo * pFltr = new CFilterInfo;
			if (NULL == pFltr)
			{
				hr = E_OUTOFMEMORY;
				break;
			}

			*pFltr = *(pFilters + i);
			LoadMiscFilterInfo(pFltr);
			(*pArray)[dwNumFilters + i] = pFltr;
		}
		dwNumFilters += dwTemp;

		if (pFilters)
		{
			SPDApiBufferFree(pFilters);
		}
		
	}while (TRUE);  
	// it will automatically break out from the loop when SPD returns ERROR_NO_DATA
	
Error:
	//this particular error is because we don't have any data. Ignore it
	if (HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
		hr = hrOK;

	return hr;
	
}

PQMPOLOCYINFO CSpdInfo::GetQmPolInfoFromTree(GUID PolicyID)
{
	PNAME_NODE pQmPolNode = NULL;
	PQMPOLOCYINFO pQmPolInfo = NULL;
	WCHAR szBuf[128];
	CHAR szGuidBuf[256];
	
	StringFromGUID2( PolicyID, szBuf, 128);

	INT iRet = WideCharToMultiByte(
				CP_ACP,            // code page
				0,    // performance and mapping flags
				szBuf,             // wide-character string
				-1,               // number of chars in string
				szGuidBuf,          // buffer for new string
				256,               // size of buffer
				NULL,              // default for unmappable chars
				NULL
			);


	pQmPolNode = NameRbFind( &m_QmPolicyTree, szGuidBuf);
	if ( pQmPolNode )
	{
		pQmPolInfo = ( PQMPOLOCYINFO ) pQmPolNode->Context;
		Assert( pQmPolInfo );
	} 
	
	return pQmPolInfo;
	
}


HRESULT CSpdInfo::InsertQmPolicyToTree(PIPSEC_QM_POLICY pPolicy)
{
	HRESULT hr = S_OK;
	CHAR    szGuidBuf[256];
	WCHAR   szBuf[128];
	PQMPOLOCYINFO pQmPolInfo = NULL;
	PNAME_NODE                pQmPolicyNode;
			
	StringFromGUID2( pPolicy->gPolicyID, szBuf, 128);
	INT iRet = WideCharToMultiByte(
					CP_ACP,            // code page
					0,    // performance and mapping flags
					szBuf,             // wide-character string
					-1,               // number of chars in string
					szGuidBuf,          // buffer for new string
					256,               // size of buffer
					NULL,              // default for unmappable chars
					NULL
				);

	pQmPolicyNode = NULL;
	pQmPolicyNode = NameRbInsert(&m_QmPolicyTree,  szGuidBuf);

	if ( pQmPolicyNode == NULL )
	{
		hr = E_OUTOFMEMORY;
		goto Error;
		
	}

	DWORD dwLen = sizeof(QMPOLOCYINFO) + (lstrlen(pPolicy->pszPolicyName) + 1)*sizeof(WCHAR);
	pQmPolInfo = ( PQMPOLOCYINFO ) SubAllocate ( m_hSubAllocator, dwLen );

	if ( NULL == pQmPolInfo )
	{
		hr = E_OUTOFMEMORY;
		goto Error;
	}

	pQmPolInfo->dwFlags = pPolicy->dwFlags;
	lstrcpy( pQmPolInfo->szPolicyName, pPolicy->pszPolicyName );

	pQmPolicyNode->Context = (PVOID) pQmPolInfo;

Error:
	if ( ERROR_SUCCESS != hr )
	{
		DestroySubAllocator( m_hSubAllocator );
		m_hSubAllocator = NULL;
	}
    return hr;
}

HRESULT CSpdInfo::InitQmPolicyTree()
{
	HRESULT hr = S_OK;
	PIPSEC_QM_POLICY   pPolicies = NULL;
	DWORD	dwNumPolicies = 0;
	DWORD	dwTemp = 0;
	DWORD	dwResumeHandle = 0;
    DWORD   dwVersion = 0;
	DWORD   dwPreferredNum = 0;
	
	
	m_hSubAllocator = CreateSubAllocator( 0x1000, 0x1000 );

	if ( m_hSubAllocator == NULL )
	{
		hr = E_OUTOFMEMORY;
		return hr;
	}
	
	NameRbInitTree( &m_QmPolicyTree, m_hSubAllocator );

	
	do
	{
		DWORD dwIndex;
		dwTemp = 0;
		
		CWRg(::EnumQMPolicies(
					(LPTSTR)(LPCTSTR)m_stMachineName,
                    dwVersion,
                    NULL,           // Template.
                    0,              // Flags.
					dwPreferredNum,
					&pPolicies,
                    &dwTemp,
                    &dwResumeHandle,
                    NULL
                    ));
	    
		for ( dwIndex=0; dwIndex < dwTemp; dwIndex ++ )
		{
			CWRg(InsertQmPolicyToTree( pPolicies + dwIndex ));
		}

		if (pPolicies)
		{
			SPDApiBufferFree(pPolicies);
		}
		
	}while (TRUE);  

	
Error:
	//this particular error is because we don't have any data. Ignore it
	if (HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
		hr = hrOK;

	return hr;
}

HRESULT CSpdInfo::EnumQmFilters()
{
	HRESULT hr = S_OK;
	int i;

	DWORD	dwCurrentIndexType = 0;
	DWORD	dwCurrentSortOption = 0;

	CFilterInfoArray arrayTransportFilters;
	CFilterInfoArray arrayTunnelFilters;
	
	CSingleLock cLock(&m_csData);

	if ( NULL == m_hSubAllocator )
	{
		CORg(InitQmPolicyTree());
	}

	GUID   guid;
	ZeroMemory(&guid, sizeof(guid));
	CORg(InternalEnumTransportFilters(
					ENUM_GENERIC_FILTERS,
					guid,
					&arrayTransportFilters
                    ));

	
	CORg(InternalEnumTunnelFilters(
					ENUM_GENERIC_FILTERS,
					guid,
					&arrayTunnelFilters
					));
	

	

	//Update the internal data now

	cLock.Lock();

	FreeItemsAndEmptyArray(m_arrayFilters);
	m_arrayFilters.Copy(arrayTransportFilters);
	m_arrayFilters.Append(arrayTunnelFilters);

	//remember the original IndexType and Sort options
	dwCurrentIndexType = m_IndexMgrFilters.GetCurrentIndexType();
	dwCurrentSortOption = m_IndexMgrFilters.GetCurrentSortOption();

	m_IndexMgrFilters.Reset();
	for (i = 0; i < (int)m_arrayFilters.GetSize(); i++)
	{
		m_IndexMgrFilters.AddItem(m_arrayFilters.GetAt(i));
	}

	m_IndexMgrFilters.SortFilters(dwCurrentIndexType, dwCurrentSortOption);

	
	cLock.Unlock();


Error:
	//this particular error is because we don't have any MM policies. Ignore it
	if (HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
		hr = hrOK;

	return hr;
}

HRESULT CSpdInfo::EnumQmSpFilters()
{
	HRESULT hr = S_OK;
	int i;

	DWORD	dwCurrentIndexType = 0;
	DWORD	dwCurrentSortOption = 0;

		
	CFilterInfoArray arraySpTransportFilters;
	CFilterInfoArray arraySpTunnelFilters;

	
	CSingleLock cLock(&m_csData);

	GUID   guid;
	ZeroMemory(&guid, sizeof(guid));
	
	if ( NULL == m_hSubAllocator )
	{
		CORg(InitQmPolicyTree());
	}	

	CORg(InternalEnumTransportFilters(
					ENUM_SPECIFIC_FILTERS,
					guid,
					&arraySpTransportFilters
                    ));

	CORg(InternalEnumTunnelFilters(
					ENUM_SPECIFIC_FILTERS,
					guid,
					&arraySpTunnelFilters
					));

	


	//Update the internal data now

	cLock.Lock();

	
	FreeItemsAndEmptyArray(m_arraySpecificFilters);
	m_arraySpecificFilters.Copy(arraySpTransportFilters);
	m_arraySpecificFilters.Append(arraySpTunnelFilters);

	//remember the original IndexType and Sort options
	dwCurrentIndexType = m_IndexMgrSpecificFilters.GetCurrentIndexType();
	dwCurrentSortOption = m_IndexMgrSpecificFilters.GetCurrentSortOption();
	
	m_IndexMgrSpecificFilters.Reset();
	for (i = 0; i < (int)m_arraySpecificFilters.GetSize(); i++)
	{
		m_IndexMgrSpecificFilters.AddItem(m_arraySpecificFilters.GetAt(i));
	}
	m_IndexMgrSpecificFilters.SortFilters(dwCurrentIndexType, dwCurrentSortOption);

	cLock.Unlock();


Error:
	//this particular error is because we don't have any MM policies. Ignore it
	if (HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
		hr = hrOK;

	return hr;
}

//Call the SPD to enum filters and put it to our array
HRESULT CSpdInfo::InternalEnumTunnelFilters(
						DWORD dwLevel,
						GUID guid,
						CFilterInfoArray * pArray,
						DWORD dwPreferredNum /* = 0 by default get all entries*/)
{
	Assert(pArray);

	HRESULT				hr = hrOK;
	FreeItemsAndEmptyArray(*pArray);

	
	PTUNNEL_FILTER   pFilters = NULL;

	DWORD	dwNumFilters = 0;
	DWORD	dwTemp = 0;
	DWORD	dwResumeHandle = 0;
    DWORD   dwVersion = 0;


	do
	{
		dwTemp = 0;
		CWRg(::EnumTunnelFilters(
					(LPTSTR)(LPCTSTR)m_stMachineName,
                    dwVersion,
                    NULL,
					dwLevel,
					guid,
					dwPreferredNum,
					&pFilters,
                    &dwTemp,
                    &dwResumeHandle,
                    NULL
                    ));
		
		
		pArray->SetSize(dwNumFilters + dwTemp);
		for (int i = 0; i < (int)dwTemp; i++)
		{
			CFilterInfo * pFltr = new CFilterInfo;
			if (NULL == pFltr)
			{
				hr = E_OUTOFMEMORY;
				break;
			}

			*pFltr = *(pFilters + i);
			LoadMiscFilterInfo(pFltr);
			(*pArray)[dwNumFilters + i] = pFltr;
		}
		dwNumFilters += dwTemp;

		if (pFilters)
		{
			SPDApiBufferFree(pFilters);
		}
		
	}while (TRUE);  
	// it will automatically break out from the loop when SPD returns ERROR_NO_DATA

Error:
	//this particular error is because we don't have any data. Ignore it
	if (HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
		hr = hrOK;

	return hr;
	
}

HRESULT CSpdInfo::EnumSpecificFilters
(
	GUID * pFilterGuid, 
	CFilterInfoArray * parraySpecificFilters,
	FILTER_TYPE fltrType
)
{
	Assert (pFilterGuid);
	Assert (parraySpecificFilters);

	HRESULT hr = hrOK;

	int		i;

	if (FILTER_TYPE_TUNNEL == fltrType)
	{
		CORg(InternalEnumTunnelFilters(
					ENUM_SELECT_SPECIFIC_FILTERS,
					*pFilterGuid,
					parraySpecificFilters
					));
	}
	else if (FILTER_TYPE_TRANSPORT == fltrType)
	{
		CORg(InternalEnumTransportFilters(
					ENUM_SELECT_SPECIFIC_FILTERS,
					*pFilterGuid,
					parraySpecificFilters
                    ));
	}

Error:
	//this particular error is because we don't have any MM policies. Ignore it
	if (HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
		hr = hrOK;

	return hr;
}

//Convert internal filter data to external spd data structure
//NOTE: the routine only convert severl parameters that are 
//needed for searching match filters
void CSpdInfo::ConvertToExternalFilterData
(
	CFilterInfo * pfltrIn, 
	TRANSPORT_FILTER * pfltrOut
)
{
		ZeroMemory (pfltrOut, sizeof(*pfltrOut));
		//pfltrOut->bCreateMirror = pfltrIn->m_bCreateMirror;
		pfltrOut->DesAddr = pfltrIn->m_DesAddr;
	        if (pfltrOut->DesAddr.AddrType != IP_ADDR_INTERFACE) {
		    pfltrOut->DesAddr.pgInterfaceID = NULL;
        	}
		pfltrOut->DesPort = pfltrIn->m_DesPort;
		pfltrOut->dwDirection = pfltrIn->m_dwDirection;
		//pfltrOut->dwWeight = pfltrIn->m_dwWeight;
		//pfltrOut->FilterFlag = pfltrIn->;
		//pfltrOut->gFilterID = pfltrIn->m_guidFltr;
		//pfltrOut->gPolicyID = pfltrIn->m_guidPolicyID;
		//pfltrOut->InterfaceType = pfltrIn->m_InterfaceType;
		pfltrOut->Protocol = pfltrIn->m_Protocol;
		pfltrOut->SrcAddr = pfltrIn->m_SrcAddr;
	        if (pfltrOut->SrcAddr.AddrType != IP_ADDR_INTERFACE) {
		    pfltrOut->SrcAddr.pgInterfaceID = NULL;
        	}
		pfltrOut->SrcPort = pfltrIn->m_SrcPort;

}

HRESULT CSpdInfo::GetMatchFilters
(
	CFilterInfo * pfltrSearchCondition, 
	DWORD dwPreferredNum, 
	CFilterInfoArray * parrFilters
)
{
	HRESULT hr = S_OK;

	Assert (pfltrSearchCondition);
	Assert (parrFilters);

	PTRANSPORT_FILTER pMatchedFilters = NULL;
	PIPSEC_QM_POLICY pMatchedPolicies = NULL;
	DWORD dwNumMatches = 0;
	DWORD dwResumeHandle = 0;
	DWORD i = 0;
    DWORD dwVersion = 0;


	TRANSPORT_FILTER SpdFltr;
	
	ConvertToExternalFilterData(pfltrSearchCondition, &SpdFltr);
    SpdFltr.IpVersion = IPSEC_PROTOCOL_V4;
	CWRg(::MatchTransportFilter (
				(LPTSTR)((LPCTSTR)m_stMachineName),
                dwVersion,
				&SpdFltr,
				0,					//Don't return default policy if no match
				dwPreferredNum,		//enum all //BUGBUG should be 0 instead of 1000
				&pMatchedFilters,
				&pMatchedPolicies,
				&dwNumMatches,
				&dwResumeHandle,
                NULL
				));

	//Todo check whether we really got all.
	
	parrFilters->SetSize(dwNumMatches);
	for (i = 0; i < dwNumMatches; i++)
	{
		CFilterInfo * pFltr = new CFilterInfo;
		*pFltr = *(pMatchedFilters + i);
		LoadMiscFilterInfo(pFltr);
		(*parrFilters)[i] = pFltr;
	}

	if (pMatchedFilters)
		SPDApiBufferFree(pMatchedFilters);

	if (pMatchedPolicies)
		SPDApiBufferFree(pMatchedPolicies);

Error:
	//this particular error is because we don't have any data. Ignore it
	if (HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
		hr = hrOK;

	return hr;
}


//Convert internal filter data to external spd data structure
//NOTE: the routine only convert severl parameters that are 
//needed for searching match filters
void CSpdInfo::ConvertToExternalMMFilterData
(
	CMmFilterInfo * pfltrIn, 
	MM_FILTER * pfltrOut
)
{
		ZeroMemory (pfltrOut, sizeof(*pfltrOut));
		//pfltrOut->bCreateMirror = pfltrIn->m_bCreateMirror;
		pfltrOut->DesAddr = pfltrIn->m_DesAddr;
        	if (pfltrOut->DesAddr.AddrType != IP_ADDR_INTERFACE) {
		    pfltrOut->DesAddr.pgInterfaceID = NULL;
        	}
		pfltrOut->dwDirection = pfltrIn->m_dwDirection;
		//pfltrOut->dwWeight = pfltrIn->m_dwWeight;
		//pfltrOut->gFilterID = pfltrIn->m_guidFltr;
		//pfltrOut->gPolicyID = pfltrIn->m_guidPolicyID;
		//pfltrOut->InterfaceType = pfltrIn->m_InterfaceType;
		pfltrOut->SrcAddr = pfltrIn->m_SrcAddr;
        	if (pfltrOut->SrcAddr.AddrType != IP_ADDR_INTERFACE) {
		    pfltrOut->SrcAddr.pgInterfaceID = NULL;
        	}
}

HRESULT CSpdInfo::GetMatchMMFilters
(
	CMmFilterInfo * pfltrSearchCondition, 
	DWORD dwPreferredNum, 
	CMmFilterInfoArray * parrFilters
)
{
	HRESULT hr = S_OK;

	Assert (pfltrSearchCondition);
	Assert (parrFilters);

	PMM_FILTER pMatchedFilters = NULL;
	PIPSEC_MM_POLICY pMatchedPolicies = NULL;
	PMM_AUTH_METHODS pMatchedAuths = NULL;
	DWORD dwNumMatches = 0;
	DWORD dwResumeHandle = 0;
	DWORD i = 0;
    DWORD dwVersion = 0;


	MM_FILTER SpdFltr;
	
	ConvertToExternalMMFilterData(pfltrSearchCondition, &SpdFltr);

    SpdFltr.IpVersion = IPSEC_PROTOCOL_V4;
	CWRg(::MatchMMFilter (
				(LPTSTR)((LPCTSTR)m_stMachineName),
                dwVersion,
				&SpdFltr,
				0,					//Don't return default policy if no match
				dwPreferredNum,		//enum all //TODO BUGBUG should be 0 instead of 1000
				&pMatchedFilters,
				&pMatchedPolicies,
				&pMatchedAuths,
				&dwNumMatches,
				&dwResumeHandle,
                NULL
				));

	//Todo check whether we really got all.
	
	parrFilters->SetSize(dwNumMatches);
	for (i = 0; i < dwNumMatches; i++)
	{
		CMmFilterInfo * pFltr = new CMmFilterInfo;
		*pFltr = *(pMatchedFilters + i);
		LoadMiscMmFilterInfo(pFltr);
		
		(*parrFilters)[i] = pFltr;
	}

	if (pMatchedFilters)
		SPDApiBufferFree(pMatchedFilters);

	if (pMatchedPolicies)
		SPDApiBufferFree(pMatchedPolicies);

	if (pMatchedAuths)
		SPDApiBufferFree(pMatchedAuths);

Error:
	//this particular error is because we don't have any data. Ignore it
	if (HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
		hr = hrOK;

	return hr;
}

HRESULT CSpdInfo::EnumMmSpecificFilters
(
	GUID * pGenFilterGuid, 
	CMmFilterInfoArray * parraySpecificFilters
)
{
	Assert (pGenFilterGuid);
	Assert (parraySpecificFilters);

	HRESULT hr = hrOK;

    DWORD	dwNumFilters = 0;
    DWORD	dwResumeHandle = 0;
	int		i;

	parraySpecificFilters->RemoveAll();
	
	CORg(InternalEnumMmFilters(
					ENUM_SELECT_SPECIFIC_FILTERS,
					*pGenFilterGuid,
					parraySpecificFilters
                    ));

Error:
	//this particular error is because we don't have any MM policies. Ignore it
	if (HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
		hr = hrOK;

	return hr;
}


//Call the SPD to enum policies and put it to our array
HRESULT CSpdInfo::InternalEnumMmPolicies(
						CMmPolicyInfoArray * pArray,
						DWORD dwPreferredNum /* = 0 by default get all entries*/)
{
	Assert(pArray);

	HRESULT		 hr = hrOK;
	PIPSEC_MM_POLICY   pPolicies = NULL;

	DWORD	dwNumPolicies = 0;
	DWORD	dwTemp = 0;
	DWORD	dwResumeHandle = 0;
    DWORD   dwVersion = 0;

	
	FreeItemsAndEmptyArray(*pArray);

	do
	{
		dwTemp = 0;
		CWRg(::EnumMMPolicies(
					(LPTSTR)(LPCTSTR)m_stMachineName,
                    dwVersion,
                    NULL,           // Template.
                    0,              // Flags.
					dwPreferredNum,
					&pPolicies,
                    &dwTemp,
                    &dwResumeHandle,
                    NULL
                    ));
		
		
		pArray->SetSize(dwNumPolicies + dwTemp);
		for (int i = 0; i < (int)dwTemp; i++)
		{
			CMmPolicyInfo * pPol = new CMmPolicyInfo;
			if (NULL == pPol)
			{
				hr = E_OUTOFMEMORY;
				break;
			}

			*pPol = *(pPolicies + i);
			(*pArray)[dwNumPolicies + i] = pPol;
		}
		dwNumPolicies += dwTemp;

		if (pPolicies)
		{
			SPDApiBufferFree(pPolicies);
		}
		
	}while (TRUE);  
	// it will automatically break out from the loop when SPD returns ERROR_NO_DATA

Error:
	//this particular error is because we don't have any data. Ignore it
	if (HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
		hr = hrOK;

	return hr;
	
}

HRESULT CSpdInfo::EnumMmPolicies()
{
	HRESULT hr = hrOK;

	CSingleLock cLock(&m_csData);

	DWORD dwCurrentIndexType;
	DWORD dwCurrentSortOption;
	
	int i;
	
	CMmPolicyInfoArray arrayTemp;


	CORg(InternalEnumMmPolicies(
				&arrayTemp,
				0				//enum all policies
				));

	cLock.Lock();
	FreeItemsAndEmptyArray(m_arrayMmPolicies);
	m_arrayMmPolicies.Copy(arrayTemp);

	//remember the original IndexType and Sort options
	dwCurrentIndexType = m_IndexMgrMmPolicies.GetCurrentIndexType();
	dwCurrentSortOption = m_IndexMgrMmPolicies.GetCurrentSortOption();

	m_IndexMgrMmPolicies.Reset();
	for (i = 0; i < (int)m_arrayMmPolicies.GetSize(); i++)
	{
		m_IndexMgrMmPolicies.AddItem(m_arrayMmPolicies.GetAt(i));
	}
	m_IndexMgrMmPolicies.Sort(dwCurrentIndexType, dwCurrentSortOption);
	
Error:
	//this particular error is because we don't have any MM policies. Ignore it
	if (HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
		hr = hrOK;

	return hr;
}


//Call the SPD to enum policies and put it to our array
HRESULT CSpdInfo::InternalEnumQmPolicies(
						CQmPolicyInfoArray * pArray,
						DWORD dwPreferredNum /* = 0 by default get all entries*/)
{
	Assert(pArray);

	HRESULT		 hr = hrOK;
	PIPSEC_QM_POLICY   pPolicies = NULL;

	DWORD	dwNumPolicies = 0;
	DWORD	dwTemp = 0;
	DWORD	dwResumeHandle = 0;
    DWORD   dwVersion = 0;


	FreeItemsAndEmptyArray(*pArray);

	do
	{
		dwTemp = 0;
		CWRg(::EnumQMPolicies(
					(LPTSTR)(LPCTSTR)m_stMachineName,
                    dwVersion,
                    NULL,           // Template.
                    0,              // Flags.
					dwPreferredNum,
					&pPolicies,
                    &dwTemp,
                    &dwResumeHandle,
                    NULL
                    ));
		
		
		pArray->SetSize(dwNumPolicies + dwTemp);
		for (int i = 0; i < (int)dwTemp; i++)
		{
			CQmPolicyInfo * pPol = new CQmPolicyInfo;
			if (NULL == pPol)
			{
				hr = E_OUTOFMEMORY;
				break;
			}

			*pPol = *(pPolicies + i);
			(*pArray)[dwNumPolicies + i] = pPol;
		}
		dwNumPolicies += dwTemp;

		if (pPolicies)
		{
			SPDApiBufferFree(pPolicies);
		}
		
	}while (TRUE);  
	// it will automatically break out from the loop when SPD returns ERROR_NO_DATA

Error:
	//this particular error is because we don't have any data. Ignore it
	if (HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
		hr = hrOK;

	return hr;
	
}

HRESULT CSpdInfo::EnumQmPolicies()
{
	HRESULT hr = hrOK;

	CSingleLock cLock(&m_csData);

	DWORD dwCurrentIndexType;
	DWORD dwCurrentSortOption;
	
	int i;

	CQmPolicyInfoArray arrayTemp;


	CORg(InternalEnumQmPolicies(
				&arrayTemp
				));

	cLock.Lock();
	FreeItemsAndEmptyArray(m_arrayQmPolicies);
	m_arrayQmPolicies.Copy(arrayTemp);

	//remember the original IndexType and Sort options
	dwCurrentIndexType = m_IndexMgrQmPolicies.GetCurrentIndexType();
	dwCurrentSortOption = m_IndexMgrQmPolicies.GetCurrentSortOption();

	m_IndexMgrQmPolicies.Reset();
	for (i = 0; i < (int)m_arrayQmPolicies.GetSize(); i++)
	{
		m_IndexMgrQmPolicies.AddItem(m_arrayQmPolicies.GetAt(i));
	}
	m_IndexMgrQmPolicies.Sort(dwCurrentIndexType, dwCurrentSortOption);

	
Error:
	//this particular error is because we don't have any QM policies. Ignore it
	if (HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
		hr = hrOK;

	return hr;
}

DWORD CSpdInfo::GetMmAuthMethodsCount()
{
	CSingleLock cLock(&m_csData);
	cLock.Lock();
	
	return (DWORD)m_arrMmAuthMethods.GetSize();
}

DWORD CSpdInfo::GetMmSACount()
{
	CSingleLock cLock(&m_csData);
	cLock.Lock();
	
	return (DWORD)m_arrayMmSAs.GetSize();
}

DWORD CSpdInfo::GetMmPolicyCount()
{
	CSingleLock cLock(&m_csData);
	cLock.Lock();
	
	return (DWORD)m_arrayMmPolicies.GetSize();
}

DWORD CSpdInfo::GetQmSACount()
{
	CSingleLock cLock(&m_csData);
	cLock.Lock();
	
	return (DWORD)m_arrayQmSAs.GetSize();
}

DWORD CSpdInfo::GetQmPolicyCount()
{
	CSingleLock cLock(&m_csData);
	cLock.Lock();
	
	return (DWORD)m_arrayQmPolicies.GetSize();
}


DWORD CSpdInfo::GetQmFilterCountOfCurrentViewType()
{
	CSingleLock cLock(&m_csData);
	cLock.Lock();

	return (DWORD)(m_IndexMgrFilters.GetItemCount());
}

DWORD CSpdInfo::GetQmSpFilterCountOfCurrentViewType()
{
	CSingleLock cLock(&m_csData);
	cLock.Lock();

	return (DWORD)(m_IndexMgrSpecificFilters.GetItemCount());
}

DWORD CSpdInfo::GetMmFilterCount()
{
	CSingleLock cLock(&m_csData);
	cLock.Lock();

	return (DWORD)(m_arrayMmFilters.GetSize());
}

DWORD CSpdInfo::GetMmSpecificFilterCount()
{
	CSingleLock cLock(&m_csData);
	cLock.Lock();

	return (DWORD)(m_arrayMmSpecificFilters.GetSize());
}

HRESULT CSpdInfo::GetFilterInfo(int iIndex, CFilterInfo * pFilter)
{
	HRESULT hr = S_OK;

	Assert(pFilter);
	if (NULL == pFilter)
		return E_INVALIDARG;

	CSingleLock cLock(&m_csData);
	cLock.Lock();

	if (iIndex < m_arrayFilters.GetSize())
	{
		CFilterInfo * pFltrData = (CFilterInfo*)m_IndexMgrFilters.GetItemData(iIndex);
		Assert(pFltrData);
		*pFilter = *pFltrData;
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}

	return hr;
}

HRESULT CSpdInfo::GetSpecificFilterInfo(int iIndex, CFilterInfo * pFilter)
{
	HRESULT hr = S_OK;
	
	Assert(pFilter);
	if (NULL == pFilter)
		return E_INVALIDARG;

	CSingleLock cLock(&m_csData);
	cLock.Lock();

	if (iIndex < m_arraySpecificFilters.GetSize())
	{
		CFilterInfo * pFltrData = (CFilterInfo*)m_IndexMgrSpecificFilters.GetItemData(iIndex);
		Assert(pFltrData);
		*pFilter = *pFltrData;
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}

	return hr;
}

HRESULT CSpdInfo::GetMmFilterInfo(int iIndex, CMmFilterInfo * pFltr)
{
	HRESULT hr = S_OK;

	Assert(pFltr);
	if (NULL == pFltr)
		return E_INVALIDARG;

	CSingleLock cLock(&m_csData);
	cLock.Lock();

	if (iIndex < m_arrayMmFilters.GetSize())
	{
		CMmFilterInfo * pFltrData = (CMmFilterInfo*)m_IndexMgrMmFilters.GetItemData(iIndex);
		Assert(pFltrData);

		*pFltr = *pFltrData;
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}

	return hr;
}

HRESULT CSpdInfo::GetMmSpecificFilterInfo
(
	int iIndex, 
	CMmFilterInfo * pFltr
)
{
	HRESULT hr = S_OK;

	Assert(pFltr);
	if (NULL == pFltr)
		return E_INVALIDARG;

	CSingleLock cLock(&m_csData);
	cLock.Lock();

	if (iIndex < m_arrayMmSpecificFilters.GetSize())
	{
		CMmFilterInfo * pFltrData = (CMmFilterInfo*)m_IndexMgrMmSpecificFilters.GetItemData(iIndex);
		Assert(pFltrData);
		*pFltr = *pFltrData;
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}

	return hr;
}

HRESULT CSpdInfo::GetMmPolicyInfo(int iIndex, CMmPolicyInfo * pMmPolicy)
{
	HRESULT hr = hrOK;

	Assert(pMmPolicy);
	if (NULL == pMmPolicy)
		return E_INVALIDARG;

	CSingleLock cLock(&m_csData);
	cLock.Lock();

	if (iIndex < m_arrayMmPolicies.GetSize())
	{
		CMmPolicyInfo * pPolicy = (CMmPolicyInfo*) m_IndexMgrMmPolicies.GetItemData(iIndex);
		*pMmPolicy = *pPolicy;
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}

	return hr;
}

HRESULT CSpdInfo::GetMmAuthMethodsInfo(int iIndex, CMmAuthMethods * pMmAuth)
{
	HRESULT hr = hrOK;
	CSingleLock cLock(&m_csData);
	cLock.Lock();

	if (iIndex < m_arrMmAuthMethods.GetSize())
	{
		*pMmAuth = *m_arrMmAuthMethods[iIndex];
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}

	return hr;
}

HRESULT CSpdInfo::GetMmSAInfo(int iIndex, CMmSA * pSA)
{
	HRESULT hr = hrOK;
	CSingleLock cLock(&m_csData);
	cLock.Lock();

	Assert(pSA);
	if (NULL == pSA)
		return E_INVALIDARG;

	if (iIndex < m_arrayMmSAs.GetSize())
	{
		CMmSA * pSATemp = (CMmSA*) m_IndexMgrMmSAs.GetItemData(iIndex);
		*pSA = *pSATemp;
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}

	return hr;	
}

HRESULT CSpdInfo::GetQmSAInfo(int iIndex, CQmSA * pSA)
{
	HRESULT hr = hrOK;
	CSingleLock cLock(&m_csData);
	cLock.Lock();

	Assert(pSA);
	if (NULL == pSA)
		return E_INVALIDARG;

	if (iIndex < m_arrayQmSAs.GetSize())
	{
		CQmSA * pSATemp = (CQmSA*) m_IndexMgrQmSAs.GetItemData(iIndex);
		*pSA = *pSATemp;
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}

	return hr;	
}

HRESULT CSpdInfo::GetQmPolicyInfo(int iIndex, CQmPolicyInfo * pQmPolicy)
{
	HRESULT hr = hrOK;
	
	if (NULL == pQmPolicy)
		return E_INVALIDARG;

	CSingleLock cLock(&m_csData);
	cLock.Lock();

	if (iIndex < m_arrayQmPolicies.GetSize())
	{
		CQmPolicyInfo * pPolicy = (CQmPolicyInfo*) m_IndexMgrQmPolicies.GetItemData(iIndex);
		*pQmPolicy = *pPolicy;
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}

	return hr;
}


HRESULT CSpdInfo::GetQmPolicyByGuid(GUID guid, PIPSEC_QM_POLICY *ppPolicy)
{
	HRESULT hr = hrOK;
    DWORD dwVersion = 0;


	
	PIPSEC_QM_POLICY pPolicy = NULL;
	CWRg(::GetQMPolicyByID(
				(LPTSTR)(LPCTSTR) m_stMachineName, 
                dwVersion,
				guid,
                0,
				&pPolicy,
                NULL));
	
	if (pPolicy)
	{
		*ppPolicy = pPolicy;
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}

Error:

	return hr;
}

HRESULT CSpdInfo::GetQmPolicyNameByGuid(GUID guid, CString * pst)
{
	HRESULT hr = hrOK;
    DWORD dwVersion = 0;


	if (NULL == pst)
		return E_INVALIDARG;

	pst->Empty();

	PIPSEC_QM_POLICY pPolicy = NULL;
	CWRg(::GetQMPolicyByID(
				(LPTSTR)(LPCTSTR) m_stMachineName, 
                dwVersion,
				guid,
                0,
				&pPolicy,
                NULL));
	
	if (pPolicy)
	{
		*pst = pPolicy->pszPolicyName;
		SPDApiBufferFree(pPolicy);
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}

Error:

	return hr;
}


HRESULT CSpdInfo::GetMmPolicyNameByGuid(GUID guid, CString * pst)
{
	HRESULT hr = hrOK;
    DWORD dwVersion = 0;


	if (NULL == pst)
		return E_INVALIDARG;

	pst->Empty();

	PIPSEC_MM_POLICY pPolicy = NULL;
	CWRg(::GetMMPolicyByID(
				(LPTSTR)(LPCTSTR) m_stMachineName, 
                dwVersion,
				guid,
				&pPolicy,
                NULL));
	
	if (pPolicy)
	{
		*pst = pPolicy->pszPolicyName;
		SPDApiBufferFree(pPolicy);
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}

Error:

	return hr;
}

HRESULT CSpdInfo::GetMmAuthMethodsInfoByGuid(GUID guid, CMmAuthMethods * pMmAuth)
{
	HRESULT hr = hrOK;
    DWORD dwVersion = 0;
    DWORD dwRet;

	PINT_MM_AUTH_METHODS pIntSpdAuth = NULL;
	PMM_AUTH_METHODS pSpdAuth = NULL;

	CWRg(::GetMMAuthMethods(
				(LPTSTR)(LPCTSTR) m_stMachineName,
                dwVersion,
				guid,
				&pSpdAuth,
                NULL));
	
	if (pSpdAuth)
	{
		dwRet = ConvertExtMMAuthToInt(
			     pSpdAuth,
			     &pIntSpdAuth
			     );

        hr = HRESULT_FROM_WIN32( dwRet );
		if ( FAILED(hr) )
		{
			SPDApiBufferFree(pSpdAuth);			
			goto Error;
		}
	
		*pMmAuth = *pIntSpdAuth;
		FreeIntMMAuthMethods(pIntSpdAuth);
		SPDApiBufferFree(pSpdAuth);
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}

Error:
	return hr;
}

HRESULT CSpdInfo::SortFilters(DWORD dwIndexType, DWORD dwSortOptions)
{
	return m_IndexMgrFilters.SortFilters(dwIndexType, dwSortOptions);
}

HRESULT CSpdInfo::SortSpecificFilters(DWORD dwIndexType, DWORD dwSortOptions)
{
	return m_IndexMgrSpecificFilters.SortFilters(dwIndexType, dwSortOptions);
}

HRESULT CSpdInfo::SortMmFilters(DWORD dwIndexType, DWORD dwSortOptions)
{
	return m_IndexMgrMmFilters.SortMmFilters(dwIndexType, dwSortOptions);
}

HRESULT CSpdInfo::SortMmSpecificFilters(DWORD dwIndexType, DWORD dwSortOptions)
{
	return m_IndexMgrMmSpecificFilters.SortMmFilters(dwIndexType, dwSortOptions);
}

HRESULT CSpdInfo::SortMmPolicies(DWORD dwIndexType, DWORD dwSortOptions)
{
	return m_IndexMgrMmPolicies.Sort(dwIndexType, dwSortOptions);
}

HRESULT CSpdInfo::SortQmPolicies(DWORD dwIndexType, DWORD dwSortOptions)
{
	return m_IndexMgrQmPolicies.Sort(dwIndexType, dwSortOptions);
}

HRESULT CSpdInfo::SortMmSAs(DWORD dwIndexType, DWORD dwSortOptions)
{
	return m_IndexMgrMmSAs.Sort(dwIndexType, dwSortOptions);
}

HRESULT CSpdInfo::SortQmSAs(DWORD dwIndexType, DWORD dwSortOptions)
{
	return m_IndexMgrQmSAs.Sort(dwIndexType, dwSortOptions);
}

HRESULT CSpdInfo::EnumQmSAsFromMmSA(const CMmSA & MmSA, CQmSAArray * parrayQmSAs)
{
	HRESULT hr = hrOK;

	if (NULL == parrayQmSAs)
		return E_INVALIDARG;

	FreeItemsAndEmptyArray(*parrayQmSAs);

	for (int i = 0; i < m_arrayQmSAs.GetSize(); i++)
	{
		if (0 == memcmp(&MmSA.m_MMSpi, &(m_arrayQmSAs[i]->m_MMSpi), sizeof(MmSA.m_MMSpi)))
		{
			CQmSA * pSA = new CQmSA;
			
			if (NULL == pSA)
			{
				FreeItemsAndEmptyArray(*parrayQmSAs);
				hr = E_OUTOFMEMORY;
				break;
			}

			*pSA = *(m_arrayQmSAs[i]);
			parrayQmSAs->Add(pSA);
		}
	}

	return hr;
}

HRESULT CSpdInfo::LoadStatistics()
{
	HRESULT hr;
	PIPSEC_STATISTICS pIpsecStats = NULL;
    DWORD dwVersion = 0;


	IKE_STATISTICS ikeStats;
	ZeroMemory(&ikeStats, sizeof(ikeStats));

	CWRg(::QueryIKEStatistics((LPTSTR)(LPCTSTR)m_stMachineName,
                                dwVersion,
								&ikeStats,
                                NULL));
	m_IkeStats = ikeStats;

	CWRg(::QueryIPSecStatistics((LPTSTR)(LPCTSTR)m_stMachineName,
                                dwVersion,
								&pIpsecStats,
                                NULL));

	Assert(pIpsecStats);
	m_IpsecStats = *pIpsecStats;

	if (pIpsecStats)
	{
		SPDApiBufferFree(pIpsecStats);
	}

Error:
	return hr;
}

// Get the current cached statistics
void CSpdInfo::GetLoadedStatistics(CIkeStatistics * pIkeStats, CIpsecStatistics * pIpsecStats)
{
	if (pIkeStats)
	{
		*pIkeStats = m_IkeStats;
	}

	if (pIpsecStats)
	{
		*pIpsecStats = m_IpsecStats;
	}
}

void CSpdInfo::ChangeQmFilterViewType(FILTER_TYPE FltrType)
{
	CSingleLock cLock(&m_csData);
	cLock.Lock();

	DWORD dwCurrentIndexType = m_IndexMgrFilters.GetCurrentIndexType();
	DWORD dwCurrentSortOption = m_IndexMgrFilters.GetCurrentSortOption();

	m_IndexMgrFilters.Reset();
	for (int i = 0; i < m_arrayFilters.GetSize(); i++)
	{
		if (FILTER_TYPE_ANY == FltrType ||
			FltrType == m_arrayFilters[i]->m_FilterType)
		{
			m_IndexMgrFilters.AddItem(m_arrayFilters.GetAt(i));
		}
	}

	m_IndexMgrFilters.SortFilters(dwCurrentIndexType, dwCurrentSortOption);

}

void CSpdInfo::ChangeQmSpFilterViewType(FILTER_TYPE FltrType)
{
	CSingleLock cLock(&m_csData);
	cLock.Lock();

	DWORD dwCurrentIndexType = m_IndexMgrSpecificFilters.GetCurrentIndexType();
	DWORD dwCurrentSortOption = m_IndexMgrSpecificFilters.GetCurrentSortOption();

	m_IndexMgrSpecificFilters.Reset();
	for (int i = 0; i < m_arraySpecificFilters.GetSize(); i++)
	{
		if (FILTER_TYPE_ANY == FltrType ||
			FltrType == m_arraySpecificFilters[i]->m_FilterType)
		{
			m_IndexMgrSpecificFilters.AddItem(m_arraySpecificFilters.GetAt(i));
		}
	}

	m_IndexMgrSpecificFilters.SortFilters(dwCurrentIndexType, dwCurrentSortOption);

}

HRESULT CSpdInfo::LoadMiscMmSAInfo(CMmSA * pSA)
{
	DWORD dwIndex;
	DWORD dwNumPol = 0;
	HRESULT hr = hrOK;
	Assert(pSA);

	dwNumPol = GetMmPolicyCount();
    
	for ( dwIndex = 0; dwIndex < dwNumPol; dwIndex++)
	{
		CMmPolicyInfo MmPol;
		CORg(GetMmPolicyInfo(dwIndex, &MmPol));
		if( IsEqualGUID(pSA->m_guidPolicy, MmPol.m_guidID) )
		{
			pSA->m_stPolicyName = MmPol.m_stName;
            pSA->m_dwPolFlags = MmPol.m_dwFlags;
			break;
		}
	}
	
Error:
	return hr;
}

HRESULT CSpdInfo::LoadMiscQmSAInfo(CQmSA * pSA)
{
	Assert(pSA);
	//return GetQmPolicyNameByGuid(pSA->m_guidPolicy, &pSA->m_stPolicyName);
	HRESULT hr = hrOK;
	PQMPOLOCYINFO pQmPolInfo = NULL;

	pQmPolInfo = GetQmPolInfoFromTree(pSA->m_guidPolicy);

	if ( pQmPolInfo )
	{
		pSA->m_stPolicyName = pQmPolInfo->szPolicyName;
                pSA->m_dwPolFlags = pQmPolInfo->dwFlags;
	}
	else
	{
		//policy is not in the tree, add to the tree
		PIPSEC_QM_POLICY pPolicy = NULL;
		hr = GetQmPolicyByGuid(pSA->m_guidPolicy, &pPolicy);
		if ( hrOK == hr )
		{
			pSA->m_stPolicyName = pPolicy->pszPolicyName;
                        pSA->m_dwPolFlags = pPolicy->dwFlags;
			hr = InsertQmPolicyToTree(pPolicy);
			SPDApiBufferFree(pPolicy);
		}
	}

	return hr;
}

HRESULT CSpdInfo::LoadMiscFilterInfo(CFilterInfo * pFltr)
{
	HRESULT hr = hrOK;
	PQMPOLOCYINFO pQmPolInfo = NULL;

	pQmPolInfo = GetQmPolInfoFromTree(pFltr->m_guidPolicyID);

	if ( pQmPolInfo )
	{
		pFltr->m_stPolicyName = pQmPolInfo->szPolicyName;
		pFltr->m_dwFlags = pQmPolInfo->dwFlags;
	}
	else
	{
		//policy is not in the tree, add to the tree
		PIPSEC_QM_POLICY pPolicy = NULL;
		hr = GetQmPolicyByGuid(pFltr->m_guidPolicyID, &pPolicy);
		if ( hrOK == hr )
		{
			pFltr->m_stPolicyName = pPolicy->pszPolicyName;
			pFltr->m_dwFlags = pPolicy->dwFlags;
			hr = InsertQmPolicyToTree(pPolicy);
			SPDApiBufferFree(pPolicy);
		}
	}

	return hr;
}

HRESULT CSpdInfo::LoadMiscMmFilterInfo(CMmFilterInfo * pFltr)
{
	Assert(pFltr);
	
	DWORD dwIndex;
	DWORD dwCount = 0;
	HRESULT hr = hrOK;
	
	dwCount = GetMmPolicyCount();

	for ( dwIndex = 0; dwIndex < dwCount; dwIndex++)
	{
		CMmPolicyInfo MmPol;
		
		CORg(GetMmPolicyInfo(dwIndex, &MmPol));

		
		if( IsEqualGUID(pFltr->m_guidPolicyID, MmPol.m_guidID) )
		{
			pFltr->m_stPolicyName = MmPol.m_stName;
			pFltr->m_dwFlags = MmPol.m_dwFlags;
			break;
		}
	}

	dwCount = GetMmAuthMethodsCount();
	for ( dwIndex = 0; dwIndex < dwCount; dwIndex++)
	{
		CMmAuthMethods MmAuth;
		CORg(GetMmAuthMethodsInfo(dwIndex, &MmAuth));
		if ( IsEqualGUID(pFltr->m_guidAuthID, MmAuth.m_guidID) )
		{
			pFltr->m_stAuthDescription = MmAuth.m_stDescription;
			break;
		}
	}
	
Error:
	return hr;
}

STDMETHODIMP
CSpdInfo::Destroy()
{
	//$REVIEW this routine get called when doing auto-refresh
	//We don't need to clean up anything at this time.
	//Each array (Filter, SA, policy...) will get cleaned up when calling the
	//corresponding enum function.

	return S_OK;
}



DWORD
CSpdInfo::GetInitInfo()
{
    CSingleLock cLock(&m_csData);
    cLock.Lock();
        
    return m_Init;
}


void
CSpdInfo::SetInitInfo(DWORD dwInitInfo)
{
    CSingleLock cLock(&m_csData);
    cLock.Lock();
        
    m_Init=dwInitInfo;
}

DWORD
CSpdInfo::GetActiveInfo()
{
    CSingleLock cLock(&m_csData);
    cLock.Lock();
        
    return m_Active;
}


void
CSpdInfo::SetActiveInfo(DWORD dwActiveInfo)
{
    CSingleLock cLock(&m_csData);
    cLock.Lock();
        
    m_Active=dwActiveInfo;
}


/*!--------------------------------------------------------------------------
    CreateSpdInfo
        Helper to create the SpdInfo object.
 ---------------------------------------------------------------------------*/
HRESULT 
CreateSpdInfo(ISpdInfo ** ppSpdInfo)
{
    AFX_MANAGE_STATE(AfxGetModuleState());
    
    SPISpdInfo     spSpdInfo;
    ISpdInfo *     pSpdInfo = NULL;
    HRESULT         hr = hrOK;

    COM_PROTECT_TRY
    {
        pSpdInfo = new CSpdInfo;

        // Do this so that it will get freed on error
        spSpdInfo = pSpdInfo;

        *ppSpdInfo = spSpdInfo.Transfer();

    }
    COM_PROTECT_CATCH

    return hr;
}


//
//  FUNCTIONS: MIDL_user_allocate and MIDL_user_free
//
//  PURPOSE: Used by stubs to allocate and free memory
//           in standard RPC calls. Not used when
//           [enable_allocate] is specified in the .acf.
//
//
//  PARAMETERS:
//    See documentations.
//
//  RETURN VALUE:
//    Exceptions on error.  This is not required,
//    you can use -error allocation on the midl.exe
//    command line instead.
//
//
void * __RPC_USER MIDL_user_allocate(size_t size)
{
    return(HeapAlloc(GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS, size));
}

void __RPC_USER MIDL_user_free( void *pointer)
{
    HeapFree(GetProcessHeap(), 0, pointer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\srchmflt.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    SrchFltr.h   
        Search Filter dialog header file

	FILE HISTORY:
        
*/

#if !defined(AFX_SRCHMMFLTR_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_)
#define AFX_SRCHMMFLTR_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_

#include "mdlsdlg.h"
#include "spddb.h"
#include "ipctrl.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CSearchMMFilters dialog

class CSearchMMFilters : public CModelessDlg
{
// Construction
public:
	CSearchMMFilters(ISpdInfo * pSpdInfo);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSearchMMFilters)
	enum { IDD = IDD_MM_SRCH_FLTRS };
	
	//}}AFX_DATA

    virtual DWORD * GetHelpMap() { return (DWORD *) &g_aHelpIDs_IDD_MM_SRCH_FLTRS[0]; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSearchMMFilters)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSearchMMFilters)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonSearch();
	afx_msg void OnSrcOptionClicked();
	afx_msg void OnDestOptionClicked();
	afx_msg void OnSrcMeOptionClicked();
	afx_msg void OnDstMeOptionClicked();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CListCtrl	m_listResult;
	IPControl	m_ipSrc;
	IPControl   m_ipDest;
private:
	HWND CreateIPControl(UINT uID, UINT uIDIpCtl);
	BOOL LoadConditionInfoFromControls(CMmFilterInfo * pFltr);
	void PopulateFilterListToControl(CMmFilterInfoArray * parrFltrs);
	void AddIpAddrsToCombo();

public:
	SPISpdInfo             m_spSpdInfo;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SRCHMMFLTR_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\spdutil.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    spdutil.h

    FILE HISTORY:
        
*/

#ifndef _HEADER_SPDUTILS_H
#define _HEADER_SPDUTILS_H

enum FILTER_TYPE
{
	FILTER_TYPE_TRANSPORT,
	FILTER_TYPE_TUNNEL,
	FILTER_TYPE_ANY
};

typedef enum {
	QM_ALGO_AUTH = 0,
	QM_ALGO_ESP_CONF,
	QM_ALGO_ESP_INTEG
} QM_ALGO_TYPE;

struct ProtocolStringMap
{
	DWORD dwProtocol;
	UINT nStringID;
};

extern const DWORD IPSM_PROTOCOL_TCP;
extern const DWORD IPSM_PROTOCOL_UDP;

extern const ProtocolStringMap c_ProtocolStringMap[];
extern const int c_nProtocols;

extern const TCHAR c_szSingleAddressMask[];

void 
AddressToString(
	ADDR addr, 
	CString * pst,
	BOOL * pfIsDnsName = NULL
	);

void IpToString(
	ULONG ulIp, 
	CString *pst
	);

void BoolToString(
	BOOL bl, 
	CString * pst
	);

void InterfaceTypeToString(
	IF_TYPE ifType, 
	CString * pst
	);

void ProtocolToString(
	PROTOCOL protocol, 
	CString * pst
	);

void FilterFlagToString(
	FILTER_ACTION FltrFlag, 
	CString * pst
	);

void PortToString(
	PORT port,
	CString * pst
	);

void DirectionToString
(
	DWORD dwDir,
	CString * pst
);

void DoiEspAlgorithmToString
(
	IPSEC_MM_ALGO algo,
	CString * pst
);

void DoiAuthAlgorithmToString
(
	IPSEC_MM_ALGO algo,
	CString * pst
);

void MmAuthToString
(
	MM_AUTH_ENUM auth,
	CString * pst
);

void KeyLifetimeToString
(
	KEY_LIFETIME lifetime, 
	CString * pst
);

void DhGroupToString
(
	DWORD dwGp, 
	CString * pst
);

void IpsecByteBlobToString
(
	const IPSEC_BYTE_BLOB& blob, 
	CString * pst
);

class CQmOffer;

void QmAlgorithmToString
(
	QM_ALGO_TYPE type, 
	CQmOffer * pOffer, 
	CString * pst
);

void TnlEpToString
(
	QM_FILTER_TYPE FltrType,
	ADDR	TnlEp,
	CString * pst
);

void TnlEpToString
(
	FILTER_TYPE FltrType,
	ADDR	TnlEp,
	CString * pst
);

void PFSGroupToString
(
	DWORD dwPFSGroup,
	CString * pst
);

void GetAuthId(PIPSEC_MM_SA pSa, CString * pstAuthId, BOOL bPeer);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\srchfltr.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    edituser.h
        Edit user dialog implementation file

	FILE HISTORY:

*/

#include "stdafx.h"
#include "SrchFltr.h"
#include "spdutil.h"
#include "ncglobal.h"  // network console global defines

const DWORD c_dwOtherProtocol = 0xFFFFFFFF;
const DWORD c_dwMaxProtocolID = 0xFF;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSearchFilters dialog


CSearchFilters::CSearchFilters(ISpdInfo * pSpdInfo)
	: CModelessDlg()
{
	//{{AFX_DATA_INIT(CSearchFilters)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_spSpdInfo.Set(pSpdInfo);
}


void CSearchFilters::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSearchFilters)
	DDX_Control(pDX, IDC_SRCH_LIST, m_listResult);
	DDX_Control(pDX, IDC_SRCH_PROTO, m_cmbProtocol);
	DDX_Control(pDX, IDC_SRCH_PROTO_NUMBER, m_editProtID);
	DDX_Control(pDX, IDC_SRCH_PROTO_SPIN, m_spinProtID);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSearchFilters, CBaseDialog)
	//{{AFX_MSG_MAP(CSearchFilters)
	ON_BN_CLICKED(IDC_SEARCH, OnButtonSearch)
	ON_BN_CLICKED(IDC_SRCH_SRC_ANY, OnSrcOptionClicked)
	ON_BN_CLICKED(IDC_SRCH_SRC_SPEC, OnSrcOptionClicked)
	ON_BN_CLICKED(IDC_SRCH_DEST_ANY, OnDestOptionClicked)
	ON_BN_CLICKED(IDC_SRCH_DEST_SPEC, OnDestOptionClicked)
	ON_BN_CLICKED(IDC_SRCH_SRC_ME, OnSrcMeOptionClicked)
	ON_BN_CLICKED(IDC_SRCH_DST_ME, OnDstMeOptionClicked)
	ON_BN_CLICKED(IDC_SRCH_SRC_ANYPORT, OnSrcPortClicked)
	ON_BN_CLICKED(IDC_SRCH_SRC_SPPORT, OnSrcPortClicked)
	ON_BN_CLICKED(IDC_SRCH_DEST_ANYPORT, OnDestPortClicked)
	ON_BN_CLICKED(IDC_SRCH_DEST_SPPORT, OnDestPortClicked)
	ON_CBN_SELENDOK(IDC_SRCH_PROTO, OnSelEndOkCbprotocoltype)
	ON_EN_CHANGE(IDC_SRCH_PROTO_NUMBER, OnEnChangeProtocolID)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//To manually create the IP control and disable mirroring if the parent dialog is mirrored
//
//Arguments: 
//          uID  [IN]   the control that the new IP control should overwrite
//			uIDIpCtr [IN] the ID of the IP control to create
//
//Note:  $REVIEW (nsun) this should be removed after the snapin is themed since IP controls
//       in comctl v6 will handle the mirroring by itself
//
HWND CSearchFilters::CreateIPControl(UINT uID, UINT uIDIpCtl)
{
	HWND hwndIPControl = NULL;
	RECT rcClient;  // client area of parent window
	CWnd* pWnd = GetDlgItem(uID);
	if (pWnd)
	{
		// get pos info from our template static and then make sure it is hidden
		pWnd->GetWindowRect(&rcClient);
		pWnd->ShowWindow (SW_HIDE);
		ScreenToClient (&rcClient);

		//$REVIEW WS_EX_NOINHERITLAYOUT is to fix the mirroring problem of IP control
		//See WinXP bug 261926. We should remove that we switch the comctl32 v6
		LONG lExStyles = 0;
		LONG lExStyles0 = 0;
		
		if (m_hWnd)
		{
			lExStyles0 = lExStyles = GetWindowLong(m_hWnd, GWL_EXSTYLE);
			if (lExStyles & WS_EX_LAYOUTRTL)
			{
				lExStyles |= WS_EX_NOINHERITLAYOUT;
				SetWindowLong(m_hWnd, GWL_EXSTYLE, lExStyles);
			}
		}

		// create the new edit control
		hwndIPControl = ::CreateWindowEx(WS_EX_NOINHERITLAYOUT, WC_IPADDRESS, NULL, WS_CHILD | WS_VISIBLE | WS_TABSTOP | WS_BORDER,
			rcClient.left,
			rcClient.top,
			rcClient.right - rcClient.left,
			rcClient.bottom - rcClient.top,
			GetSafeHwnd(),
			(HMENU) IntToPtr(uIDIpCtl),
			AfxGetInstanceHandle (), //g_hinst,
			NULL);

		if (lExStyles0 != lExStyles && m_hWnd)
		{
			SetWindowLong(m_hWnd, GWL_EXSTYLE, lExStyles0);
		}
		
		// move the control directly behind the pWnd in the Z order
		if (hwndIPControl)
		{
			::SetWindowPos (hwndIPControl, pWnd->GetSafeHwnd(), 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
		}
		
	}
		
	return hwndIPControl;
}
/////////////////////////////////////////////////////////////////////////////
// CSearchFilters message handlers

BOOL CSearchFilters::OnInitDialog()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	
	HWND hwndIPControl = CreateIPControl(IDC_SRCH_SRC_IP_TEXT, IDC_SRCH_SRC_IP);

	m_ipSrc.Create(hwndIPControl);

	hwndIPControl = CreateIPControl(IDC_SRCH_DEST_IP_TEXT, IDC_SRCH_DEST_IP);
	m_ipDest.Create(hwndIPControl);

	m_ipSrc.SetFieldRange(0, 1, 223);
	
	m_ipDest.SetFieldRange(0, 1, 223);

	CBaseDialog::OnInitDialog();

	CString st;

	CheckDlgButton(IDC_SRCH_SRC_ANY, BST_CHECKED);
	OnSrcOptionClicked();
	CheckDlgButton(IDC_SRCH_DEST_ANY, BST_CHECKED);
	OnDestOptionClicked();

	AddIpAddrsToCombo();

	//disable the two combo boxes
	((CWnd*)GetDlgItem(IDC_SRCH_SRC_ME_COMBO))->EnableWindow(FALSE);
	((CWnd*)GetDlgItem(IDC_SRCH_DST_ME_COMBO))->EnableWindow(FALSE);

	int nIndex;
	for (int i = 0; i < c_nProtocols; i++)
	{
		st.LoadString(c_ProtocolStringMap[i].nStringID);
		nIndex = m_cmbProtocol.AddString(st);

		Assert(CB_ERR != nIndex);

		if (CB_ERR != nIndex)
			m_cmbProtocol.SetItemData(nIndex, c_ProtocolStringMap[i].dwProtocol);
	}

	//Add the other protocol selection
	st.LoadString(IDS_OTHER);
	nIndex = m_cmbProtocol.AddString(st);
	m_cmbProtocol.SetItemData(nIndex, c_dwOtherProtocol);
	

	m_cmbProtocol.SetCurSel(0);

	CheckDlgButton(IDC_SRCH_INBOUND, BST_CHECKED);
	CheckDlgButton(IDC_SRCH_OUTBOUND, BST_CHECKED);

	CheckDlgButton(IDC_SRCH_RADIO_BEST, BST_CHECKED);

	int nWidth;
    nWidth = m_listResult.GetStringWidth(_T("555.555.555.555 - "));
	st.LoadString(IDS_COL_FLTR_SRC);
	m_listResult.InsertColumn(0, st,  LVCFMT_LEFT, nWidth);

	nWidth = m_listResult.GetStringWidth(_T("555.555.555.555 - "));
	st.LoadString(IDS_COL_FLTR_DEST);
	m_listResult.InsertColumn(1, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_COL_FLTR_SRC_PORT);
	nWidth = m_listResult.GetStringWidth((LPCTSTR)st) + 15;
	m_listResult.InsertColumn(2, st, LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_COL_FLTR_DEST_PORT);
	nWidth = m_listResult.GetStringWidth((LPCTSTR)st) + 15;
	m_listResult.InsertColumn(3, st, LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_COL_FLTR_PROT);
	nWidth = m_listResult.GetStringWidth((LPCTSTR)st) + 15;
	m_listResult.InsertColumn(4, st, LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_FLTR_DIR_OUT);
	nWidth = m_listResult.GetStringWidth((LPCTSTR)st) + 20;
	st.LoadString(IDS_FILTER_PP_COL_DIRECTION);
	m_listResult.InsertColumn(5, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_FILTER_PP_COL_FLAG);
	nWidth = m_listResult.GetStringWidth(st) + 40;
	st.LoadString(IDS_FILTER_PP_COL_FLAG);
	m_listResult.InsertColumn(6, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_FILTER_PP_COL_WEIGHT);
	nWidth = m_listResult.GetStringWidth((LPCTSTR)st) + 20;
	m_listResult.InsertColumn(7, st,  LVCFMT_LEFT, nWidth);

	st.LoadString(IDS_FILTER_PP_COL_POLICY);
	nWidth = m_listResult.GetStringWidth((LPCTSTR)st) + 20;
	m_listResult.InsertColumn(8, st,  LVCFMT_LEFT, nWidth);

	st.Format(_T("%u"), c_dwMaxProtocolID);
	m_editProtID.SetLimitText(st.GetLength());

	m_spinProtID.SetRange(0, c_dwMaxProtocolID);

	EnableControls();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSearchFilters::AddIpAddrsToCombo()
{
	PMIB_IPADDRTABLE pIpTable;
	ULONG dwSize=0;
	ULONG index;
	DWORD dwRet;
	CString strIP;

	
    dwRet = GetIpAddrTable(
              NULL,       // buffer for mapping table 
              &dwSize,    // size of buffer 
              FALSE       // sort the table 
              );


	
    if( ERROR_INSUFFICIENT_BUFFER != dwRet && ERROR_SUCCESS != dwRet )	{
        return;
	} else {
		pIpTable = (PMIB_IPADDRTABLE) LocalAlloc(LMEM_ZEROINIT,dwSize);
	}

    dwRet = GetIpAddrTable(
              pIpTable,  // buffer for mapping table 
              &dwSize,                 // size of buffer 
              FALSE                     // sort the table 
              );

	if(ERROR_SUCCESS != dwRet) {
		if(pIpTable)
			LocalFree(pIpTable);
		return;
	}

	CComboBox* pComboSrc = (CComboBox*) GetDlgItem(IDC_SRCH_SRC_ME_COMBO);
	CComboBox* pComboDst = (CComboBox*) GetDlgItem(IDC_SRCH_DST_ME_COMBO);

	for(index=0; index<pIpTable->dwNumEntries; index++)	{
		strIP.Format(_T("%d.%d.%d.%d"),GET_SOCKADDR(pIpTable->table[index].dwAddr));
		if(lstrcmp(strIP, _T("127.0.0.1"))) {
            pComboSrc->AddString(strIP);
			pComboDst->AddString(strIP);
		}
	}

	if(pIpTable)
		LocalFree(pIpTable);
}

void CSearchFilters::EnableControls()
{
	CWnd * pWndSrcPort = NULL;
	CWnd * pWndDestPort = NULL;
	CWnd * pWnd = NULL;
	int nIndex;
	DWORD dwData;

	nIndex = m_cmbProtocol.GetCurSel();
	dwData = (DWORD)m_cmbProtocol.GetItemData(nIndex);

	pWnd = GetDlgItem(IDC_SRCH_PROTO_NUMBER);
	if (pWnd)
		pWnd->EnableWindow(c_dwOtherProtocol == dwData);

	if (c_dwOtherProtocol == dwData)
	{
		dwData = GetDlgItemInt(IDC_SRCH_PROTO_NUMBER);
	}
	else
	{
		CString st;
		st.Format(_T("%u"), dwData);
		m_editProtID.SetWindowText(st);
	}

	//Enable the port selection only when the protocol is TCP or UDP
	BOOL fEnable = IPSM_PROTOCOL_TCP == dwData || IPSM_PROTOCOL_UDP == dwData;

	pWndSrcPort = GetDlgItem(IDC_SRCH_SRC_PORT);
	pWndDestPort = GetDlgItem(IDC_SRCH_DEST_PORT);

	SafeEnableWindow(IDC_SRCH_SRC_ANYPORT, fEnable);
	SafeEnableWindow(IDC_SRCH_SRC_SPPORT, fEnable);
	SafeEnableWindow(IDC_SRCH_DEST_ANYPORT, fEnable);
	SafeEnableWindow(IDC_SRCH_DEST_SPPORT, fEnable);

	if (!fEnable)
	{
		//if port option doesn't apply to the seclect protocol, unselect all port
		//settings 
		CheckDlgButton(IDC_SRCH_SRC_ANYPORT, 0);
		CheckDlgButton(IDC_SRCH_SRC_SPPORT, 0);
		CheckDlgButton(IDC_SRCH_DEST_ANYPORT, 0);
		CheckDlgButton(IDC_SRCH_DEST_SPPORT, 0);
	}
	else
	{
		//if neither any nor specific port is selected, select the "any ports"
		if (!IsDlgButtonChecked(IDC_SRCH_SRC_ANYPORT) &&
		!IsDlgButtonChecked(IDC_SRCH_SRC_SPPORT))
		{
			CheckDlgButton(IDC_SRCH_SRC_ANYPORT, 1);
		}

		if (!IsDlgButtonChecked(IDC_SRCH_DEST_ANYPORT) &&
			!IsDlgButtonChecked(IDC_SRCH_DEST_SPPORT))
		{
			CheckDlgButton(IDC_SRCH_DEST_ANYPORT, 1);
		}
	}

	BOOL fSpSrcPort = fEnable && IsDlgButtonChecked(IDC_SRCH_SRC_SPPORT);
	BOOL fSpDestPort = fEnable && IsDlgButtonChecked(IDC_SRCH_DEST_SPPORT);
	
	if (pWndSrcPort)
	{
		pWndSrcPort->EnableWindow(fSpSrcPort);
		if (!fSpSrcPort)
			pWndSrcPort->SetWindowText(_T(""));
	}

	if (pWndDestPort)
	{
		pWndDestPort->EnableWindow(fSpDestPort);
		if (!fSpDestPort)
			pWndDestPort->SetWindowText(_T(""));
	}
	
}

void CSearchFilters::SafeEnableWindow(int nId, BOOL fEnable)
{
	CWnd * pWnd = GetDlgItem(nId);
	if (pWnd)
	{
		pWnd->EnableWindow(fEnable);
	}
}

void CSearchFilters::OnButtonSearch()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CFilterInfo fltr;
	CFilterInfoArray arrMatchFltrs;

	if (!LoadConditionInfoFromControls(&fltr))
	{
		return;
	}

	DWORD dwNum = 1000; //TODO, should change to 0 to mean search all matches
	if(IsDlgButtonChecked(IDC_SRCH_RADIO_BEST))
	{
		dwNum = 1;
	}

	m_spSpdInfo->GetMatchFilters(&fltr, dwNum, &arrMatchFltrs);

	PopulateFilterListToControl(&arrMatchFltrs);

	FreeItemsAndEmptyArray(arrMatchFltrs);

}


BOOL CSearchFilters::LoadConditionInfoFromControls(CFilterInfo * pFltr)
{
	CString st;

	if (IsDlgButtonChecked(IDC_SRCH_SRC_ANY))
	{
		pFltr->m_SrcAddr.AddrType = IP_ADDR_SUBNET;
		pFltr->m_SrcAddr.uIpAddr = 0;
		pFltr->m_SrcAddr.uSubNetMask = 0;
	}
	else if (IsDlgButtonChecked(IDC_SRCH_SRC_ME))
	{
		USES_CONVERSION;

		pFltr->m_SrcAddr.AddrType = IP_ADDR_UNIQUE;
		CComboBox* pCombo = (CComboBox*) GetDlgItem(IDC_SRCH_SRC_ME_COMBO);
		INT nSelected = pCombo->GetCurSel();
		if( CB_ERR != nSelected)
		{
		    pCombo->GetLBText(nSelected, st);
            try
            {
                pFltr->m_SrcAddr.uIpAddr = inet_addr(T2A((LPCTSTR)st));
            }
            catch(...)
            {
                AfxMessageBox(IDS_ERR_OUTOFMEMORY);
                return FALSE;
            }
		    pFltr->m_SrcAddr.uSubNetMask = 0xFFFFFFFF;
		}
	}
	else
	{
		USES_CONVERSION;

		pFltr->m_SrcAddr.AddrType = IP_ADDR_UNIQUE;
		m_ipSrc.GetAddress(st);
        try
        {
            pFltr->m_SrcAddr.uIpAddr = inet_addr(T2A((LPCTSTR)st));
        }
        catch(...)
        {
            AfxMessageBox(IDS_ERR_OUTOFMEMORY);
            return FALSE;
        }
		pFltr->m_SrcAddr.uSubNetMask = 0xFFFFFFFF;
	}

	if (IsDlgButtonChecked(IDC_SRCH_DEST_ANY))
	{
		pFltr->m_DesAddr.AddrType = IP_ADDR_SUBNET;
		pFltr->m_DesAddr.uIpAddr = 0;
		pFltr->m_DesAddr.uSubNetMask = 0;
	}
	else if (IsDlgButtonChecked(IDC_SRCH_DST_ME))
	{
		USES_CONVERSION;

		pFltr->m_DesAddr.AddrType = IP_ADDR_UNIQUE;
		CComboBox* pCombo = (CComboBox*) GetDlgItem(IDC_SRCH_DST_ME_COMBO);
		INT nSelected = pCombo->GetCurSel();
		if( CB_ERR != nSelected)
		{
		    pCombo->GetLBText(nSelected, st);
		    try
            {
                pFltr->m_DesAddr.uIpAddr = inet_addr(T2A((LPCTSTR)st));
            }
            catch(...)
            {
                AfxMessageBox(IDS_ERR_OUTOFMEMORY);
                return FALSE;
            }
		    pFltr->m_DesAddr.uSubNetMask = 0xFFFFFFFF;
		}
	}
	else
	{
		USES_CONVERSION;

		pFltr->m_DesAddr.AddrType = IP_ADDR_UNIQUE;
		m_ipDest.GetAddress(st);
		try
        {
            pFltr->m_DesAddr.uIpAddr = inet_addr(T2A((LPCTSTR)st));
        }
        catch(...)
        {
            AfxMessageBox(IDS_ERR_OUTOFMEMORY);
            return FALSE;
        }
		pFltr->m_DesAddr.uSubNetMask = 0xFFFFFFFF;
	}

	//Protocol and Port conditions
	int		nIndex = m_cmbProtocol.GetCurSel();
	DWORD	dwData = (DWORD)m_cmbProtocol.GetItemData(nIndex);

	if (c_dwOtherProtocol == dwData)
	{
		dwData = GetDlgItemInt(IDC_SRCH_PROTO_NUMBER);
	}

	if (dwData > c_dwMaxProtocolID)
	{
		st.Format(IDS_ERR_INVALID_PROTOCOLID, c_dwMaxProtocolID);
		::AfxMessageBox(st);
		return FALSE;
	}

	pFltr->m_Protocol.ProtocolType = PROTOCOL_UNIQUE;
	pFltr->m_Protocol.dwProtocol = (DWORD)dwData;
	pFltr->m_SrcPort.PortType = PORT_UNIQUE;
	pFltr->m_DesPort.PortType = PORT_UNIQUE;
	pFltr->m_SrcPort.wPort = 0;
	pFltr->m_DesPort.wPort = 0;


	if (IPSM_PROTOCOL_TCP == dwData || IPSM_PROTOCOL_UDP == dwData)
	{
		BOOL fTrans = FALSE;
		if (IsDlgButtonChecked(IDC_SRCH_SRC_ANYPORT))
		{
			pFltr->m_SrcPort.wPort = 0;
		}
		else
		{
			pFltr->m_SrcPort.wPort = (WORD)GetDlgItemInt(IDC_SRCH_SRC_PORT, &fTrans, FALSE);
			if (!fTrans || 0 == pFltr->m_SrcPort.wPort)
			{
				::AfxMessageBox(IDS_ERR_INVALID_SRC_PORT);
				return FALSE;
			}
				
		}

		if (IsDlgButtonChecked(IDC_SRCH_DEST_ANYPORT))
		{
			pFltr->m_DesPort.wPort = 0;
		}
		else
		{
			pFltr->m_DesPort.wPort = (WORD)GetDlgItemInt(IDC_SRCH_DEST_PORT, &fTrans, FALSE);
			if (!fTrans || 0 == pFltr->m_DesPort.wPort)
			{
				::AfxMessageBox(IDS_ERR_INVALID_DEST_PORT);
				return FALSE;
			}
		}
		
	}

	if (IsDlgButtonChecked(IDC_SRCH_INBOUND))
	{
		//if both inbound and outbound are chosen, then 
		//set the driection valude as 0
		if (IsDlgButtonChecked(IDC_SRCH_OUTBOUND))
		{
			pFltr->m_dwDirection = 0;
		}
		else
		{
			pFltr->m_dwDirection = FILTER_DIRECTION_INBOUND;
		}
	}
	else if (IsDlgButtonChecked(IDC_SRCH_OUTBOUND))
	{
		pFltr->m_dwDirection = FILTER_DIRECTION_OUTBOUND;
	}
	else
	{
		::AfxMessageBox(IDS_ERR_NO_DIRECTION);
		return FALSE;
	}
    
	return TRUE;
}

void CSearchFilters::PopulateFilterListToControl(CFilterInfoArray * parrFltrs)
{
	CString st;
	
	m_listResult.DeleteAllItems();
	int nRows = -1;
	int nCol = 0;
	for (int i = 0; i < parrFltrs->GetSize(); i++)
	{
		nRows++;
		nRows = m_listResult.InsertItem(nRows, _T(""));

		if (-1 != nRows)
		{
			AddressToString((*parrFltrs)[i]->m_SrcAddr, &st);
			m_listResult.SetItemText(nRows, 0, st);

			AddressToString((*parrFltrs)[i]->m_DesAddr, &st);
			m_listResult.SetItemText(nRows, 1, st);

			PortToString((*parrFltrs)[i]->m_SrcPort, &st);
			m_listResult.SetItemText(nRows, 2, st);

			PortToString((*parrFltrs)[i]->m_DesPort, &st);
			m_listResult.SetItemText(nRows, 3, st);

			ProtocolToString((*parrFltrs)[i]->m_Protocol, &st);
			m_listResult.SetItemText(nRows, 4, st);

			DirectionToString((*parrFltrs)[i]->m_dwDirection, &st);
			m_listResult.SetItemText(nRows, 5, st);

			FilterFlagToString((FILTER_DIRECTION_INBOUND == (*parrFltrs)[i]->m_dwDirection) ?
							(*parrFltrs)[i]->m_InboundFilterAction : 
							(*parrFltrs)[i]->m_OutboundFilterAction,
							&st
							);
			m_listResult.SetItemText(nRows, 6, st);

			st.Format(_T("%d"), (*parrFltrs)[i]->m_dwWeight);
			m_listResult.SetItemText(nRows, 7, st);

			st = (*parrFltrs)[i]->m_stPolicyName;
			m_listResult.SetItemText(nRows, 8, st);

			m_listResult.SetItemData(nRows, i);
		}
	}
    
    if ( 0 == parrFltrs->GetSize() )
    {
        AfxMessageBox(IDS_ERROR_NOMATCH_FILTER);
    }

}

void CSearchFilters::OnSrcOptionClicked()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	BOOL fAny = IsDlgButtonChecked(IDC_SRCH_SRC_ANY);

	if (fAny)
	{
		m_ipSrc.ClearAddress();
	}
	
	if (m_ipSrc.m_hIPaddr)
	{
		::EnableWindow(m_ipSrc.m_hIPaddr, !fAny);
	}

	((CWnd*)GetDlgItem(IDC_SRCH_SRC_ME_COMBO))->EnableWindow(FALSE);
	CComboBox* pCombo = (CComboBox*) GetDlgItem(IDC_SRCH_SRC_ME_COMBO);
	pCombo->SetCurSel(-1);
	
}

void CSearchFilters::OnDestOptionClicked()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	BOOL fAny = IsDlgButtonChecked(IDC_SRCH_DEST_ANY);

	if (fAny)
	{
		m_ipDest.ClearAddress();
	}
	
	if (m_ipDest.m_hIPaddr)
	{
		::EnableWindow(m_ipDest.m_hIPaddr, !fAny);
	}

	((CWnd*)GetDlgItem(IDC_SRCH_DST_ME_COMBO))->EnableWindow(FALSE);
	CComboBox* pCombo = (CComboBox*) GetDlgItem(IDC_SRCH_DST_ME_COMBO);
    pCombo->SetCurSel(-1);
}

void CSearchFilters::OnSrcMeOptionClicked()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	
	((CWnd*)GetDlgItem(IDC_SRCH_SRC_ME_COMBO))->EnableWindow(TRUE);

	::EnableWindow(m_ipSrc.m_hIPaddr, FALSE);

	CComboBox* pCombo = (CComboBox*) GetDlgItem(IDC_SRCH_SRC_ME_COMBO);
	int nCount = pCombo->GetCount();
    if (nCount > 0) {
       pCombo->SetCurSel(0);
	}

}

void CSearchFilters::OnDstMeOptionClicked()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	((CWnd*)GetDlgItem(IDC_SRCH_DST_ME_COMBO))->EnableWindow(TRUE);

	::EnableWindow(m_ipDest.m_hIPaddr, FALSE);
	
	CComboBox* pCombo = (CComboBox*) GetDlgItem(IDC_SRCH_DST_ME_COMBO);
    int nCount = pCombo->GetCount();
    if (nCount > 0) {
       pCombo->SetCurSel(0);
	}
}

void CSearchFilters::OnSrcPortClicked()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	BOOL fSpecifc = IsDlgButtonChecked(IDC_SRCH_SRC_SPPORT);

	SafeEnableWindow(IDC_SRCH_SRC_PORT, fSpecifc);

	if (!fSpecifc)
	{
		CWnd * pWnd = GetDlgItem(IDC_SRCH_SRC_PORT);
		if (pWnd)
			pWnd->SetWindowText(_T(""));
	}
}

void CSearchFilters::OnDestPortClicked()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	BOOL fSpecifc = IsDlgButtonChecked(IDC_SRCH_DEST_SPPORT);

	SafeEnableWindow(IDC_SRCH_DEST_PORT, fSpecifc);

	if (!fSpecifc)
	{
		CWnd * pWnd = GetDlgItem(IDC_SRCH_DEST_PORT);
		if (pWnd)
			pWnd->SetWindowText(_T(""));
	}
}

void CSearchFilters::OnOK()
{
}


void CSearchFilters::OnCancel()
{
	DestroyWindow();

	// Explicitly kill this thread.
   AfxPostQuitMessage(0);
}

void CSearchFilters::OnSelEndOkCbprotocoltype() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	EnableControls();
}

void CSearchFilters::OnEnChangeProtocolID()
{
	CWnd * pWnd = NULL;
	pWnd = GetDlgItem(IDC_SRCH_PROTO_NUMBER);

	//only update control state when the edit box is enabled
	//otherwise, there will be a infinite recursive call to OnEnChangeProtocolID()
	//because EnableControls will update the text of the edit box if the protocol
	//is not "Other" (at that time, the edit box is disabled
	if (pWnd && pWnd->IsWindowEnabled())
	{
		EnableControls();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\spdutil.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    spdutil.cpp

    FILE HISTORY:
        
*/
#include "stdafx.h"
#include "winipsec.h"
#include "ipsec.h"
#include "spdutil.h"
#include "objplus.h"
#include "ipaddres.h"
#include "spddb.h"
#include "server.h"

#define MY_ENCODING_TYPE (X509_ASN_ENCODING)

extern CHashTable g_HashTable;

const DWORD IPSM_PROTOCOL_TCP = 6;
const DWORD IPSM_PROTOCOL_UDP = 17;

const TCHAR c_szSingleAddressMask[] = _T("255.255.255.255");

const ProtocolStringMap c_ProtocolStringMap[] = 
{ 
    {0, IDS_PROTOCOL_ANY},
    {1, IDS_PROTOCOL_ICMP},     
    {3, IDS_PROTOCOL_GGP},
    {6, IDS_PROTOCOL_TCP},    
    {8, IDS_PROTOCOL_EGP},    
    {12, IDS_PROTOCOL_PUP},     
    {17, IDS_PROTOCOL_UDP},    
    {20, IDS_PROTOCOL_HMP},    
    {22, IDS_PROTOCOL_XNS_IDP},
    {27, IDS_PROTOCOL_RDP}, 
    {66, IDS_PROTOCOL_RVD}    
};

const int c_nProtocols = DimensionOf(c_ProtocolStringMap);

ULONG RevertDwordBytes(DWORD dw)
{
    ULONG ulRet;
    ulRet = dw >> 24;
    ulRet += (dw & 0xFF0000) >> 8;
    ulRet += (dw & 0x00FF00) << 8;
    ulRet += (dw & 0x0000FF) << 24;

    return ulRet;
}

void PortToString
(
    PORT port,
    CString * pst
)
{
    if (0 == port.wPort)
    {
        pst->LoadString(IDS_PORT_ANY);
    }
    else
    {
        pst->Format(_T("%d"), port.wPort);
    }
}

void FilterFlagToString
(
    FILTER_ACTION FltrFlag, 
    CString * pst
)
{
    pst->Empty();
    switch(FltrFlag)
    {
        case PASS_THRU:
            pst->LoadString(IDS_PASS_THROUGH);
        break;
        case BLOCKING:
            pst->LoadString(IDS_BLOCKING);
        break;
        case NEGOTIATE_SECURITY:
            pst->LoadString(IDS_NEG_SEC);
        break;
    }
}

void ProtocolToString
(
    PROTOCOL protocol, 
    CString * pst
)
{
    BOOL fFound = FALSE;
    for (int i = 0; i < DimensionOf(c_ProtocolStringMap); i++)
    {
        if (c_ProtocolStringMap[i].dwProtocol == protocol.dwProtocol)
        {
            pst->LoadString(c_ProtocolStringMap[i].nStringID);
            fFound = TRUE;
        }
    }

    if (!fFound)
    {
        pst->Format(IDS_OTHER_PROTO, protocol.dwProtocol);
    }
}

void InterfaceTypeToString
(
    IF_TYPE ifType, 
    CString * pst
)
{
    switch (ifType)
    {
        case INTERFACE_TYPE_ALL:
            pst->LoadString (IDS_IF_TYPE_ALL);
        break;
        
        case INTERFACE_TYPE_LAN:
            pst->LoadString (IDS_IF_TYPE_LAN);
        break;
        
        case INTERFACE_TYPE_DIALUP:
            pst->LoadString (IDS_IF_TYPE_RAS);
        break;

        default:
            pst->LoadString (IDS_UNKNOWN);
        break;
    }
}

void BoolToString
(
        BOOL bl,
        CString * pst
)
{
    if (bl)
        pst->LoadString (IDS_YES);
    else
        pst->LoadString (IDS_NO);
}

void DirectionToString
(
    DWORD dwDir,
    CString * pst
)
{
    switch (dwDir)
    {
    case FILTER_DIRECTION_INBOUND:
        pst->LoadString(IDS_FLTR_DIR_IN);
        break;
    case FILTER_DIRECTION_OUTBOUND:
        pst->LoadString(IDS_FLTR_DIR_OUT);
        break;
    default:
        pst->Empty();
        break;
    }
}

void DoiEspAlgorithmToString
(
    IPSEC_MM_ALGO algo,
    CString * pst
)
{
    switch (algo.uAlgoIdentifier)
    {
    case CONF_ALGO_NONE:
        pst->LoadString(IDS_DOI_ESP_NONE);
        break;
    case CONF_ALGO_DES:
        pst->LoadString(IDS_DOI_ESP_DES);
        break;
    case CONF_ALGO_3_DES:
        pst->LoadString(IDS_DOI_ESP_3_DES);
        break;
    default:
        pst->Empty();
        break;
    }
}

void DoiAuthAlgorithmToString
(
    IPSEC_MM_ALGO algo,
    CString * pst
)
{
    switch(algo.uAlgoIdentifier)
    {
    case AUTH_ALGO_NONE:
        pst->LoadString(IDS_DOI_AH_NONE);
        break;
    case AUTH_ALGO_MD5:
        pst->LoadString(IDS_DOI_AH_MD5);
        break;
    case AUTH_ALGO_SHA1:
        pst->LoadString(IDS_DOI_AH_SHA);
        break;
    default:
        pst->Empty();
        break;
    }
}

void DhGroupToString(DWORD dwGp, CString * pst)
{
    switch(dwGp)
    {
    case DH_GROUP_1:
        pst->LoadString(IDS_DHGROUP_LOW);
        break;
    case DH_GROUP_2:
        pst->LoadString(IDS_DHGROUP_MEDIUM);
        break;
    case DH_GROUP_2048:
        pst->LoadString(IDS_DHGROUP_HIGH);
        break;
    default:
        pst->Format(_T("%d"), dwGp);
        break;
    }
}

void MmAuthToString(MM_AUTH_ENUM auth, CString * pst)
{
    switch(auth)
    {
    case IKE_PRESHARED_KEY:
        pst->LoadString(IDS_IKE_PRESHARED_KEY);
        break;
    case IKE_DSS_SIGNATURE:
        pst->LoadString(IDS_IKE_DSS_SIGNATURE);
        break;
    case IKE_RSA_SIGNATURE:
        pst->LoadString(IDS_IKE_RSA_SIGNATURE);
        break;
    case IKE_RSA_ENCRYPTION:
        pst->LoadString(IDS_IKE_RSA_ENCRYPTION);
        break;
    case IKE_SSPI:
        pst->LoadString(IDS_IKE_SSPI);
        break;
    default:
        pst->Empty();
        break;
    }
}

void KeyLifetimeToString(KEY_LIFETIME lifetime, CString * pst)
{
    pst->Format(IDS_KEY_LIFE_TIME, lifetime.uKeyExpirationKBytes, lifetime.uKeyExpirationTime);
}

void IpToString(ULONG ulIp, CString *pst)
{
    ULONG ul;
    CIpAddress ipAddr;
    ul = RevertDwordBytes(ulIp);
    ipAddr = ul;
    *pst = (CString) ipAddr;
}

void AddressToString(ADDR addr, CString * pst, BOOL * pfIsDnsName)
{
    Assert(pst);
    if (NULL == pst)
        return;

    if (pfIsDnsName)
    {
        *pfIsDnsName = FALSE;
    }

    
    ULONG ul;
    CIpAddress ipAddr;
        
    pst->Empty();
    
    switch (addr.AddrType)
    {
    case IP_ADDR_UNIQUE:
        if (IP_ADDRESS_ME == addr.uIpAddr)
        {
            pst->LoadString(IDS_ADDR_ME);
        }
        else
        {
            HashEntry *pHashEntry=NULL;

            if (g_HashTable.GetObject(&pHashEntry,*(in_addr*)&addr.uIpAddr) != ERROR_SUCCESS) {
                ul = RevertDwordBytes(addr.uIpAddr);
                ipAddr = ul;
                *pst = (CString) ipAddr;
            } 
            else 
            {
                *pst=pHashEntry->HostName;
                if (pfIsDnsName)
                {
                    *pfIsDnsName = TRUE;
                }
            }
        }
        break;
    case IP_ADDR_SUBNET:
        if (SUBNET_ADDRESS_ANY == addr.uSubNetMask)
        {
            pst->LoadString(IDS_ADDR_ANY);
        }
        else
        {
            ul = RevertDwordBytes(addr.uIpAddr);
            ipAddr = ul;
            *pst = (CString) ipAddr;
            *pst += _T("(");
            ul = RevertDwordBytes(addr.uSubNetMask);
            ipAddr = ul;
            *pst += (CString) ipAddr;
            *pst += _T(")");
        }
        break;
    case IP_ADDR_DNS_SERVER:
        pst->LoadString(IDS_FILTER_EXT_DNS_SERVER);
        break;
    case IP_ADDR_WINS_SERVER:
        pst->LoadString(IDS_FILTER_EXT_WINS_SERVER);
        break;
    case IP_ADDR_DHCP_SERVER:
        pst->LoadString(IDS_FILTER_EXT_DHCP_SERVER);
        break;
    case IP_ADDR_DEFAULT_GATEWAY:
        pst->LoadString(IDS_FILTER_EXT_DEF_GATEWAY);
        break;
    }
    
}



void IpsecByteBlobToString(const IPSEC_BYTE_BLOB& blob, CString * pst)
{
    Assert(pst);
    if (NULL == pst)
        return;

    pst->Empty();
    //TODO to translate the blob info to readable strings
}

void QmAlgorithmToString
(
    QM_ALGO_TYPE type, 
    CQmOffer * pOffer, 
    CString * pst
)
{
    Assert(pst);
    Assert(pOffer);

    if (NULL == pst || NULL == pOffer)
        return;

    pst->LoadString(IDS_ALGO_NONE);

    for (DWORD i = 0; i < pOffer->m_dwNumAlgos; i++)
    {
        switch(type)
        {
        case QM_ALGO_AUTH:
            if (AUTHENTICATION == pOffer->m_arrAlgos[i].m_Operation)
            {
                switch(pOffer->m_arrAlgos[i].m_ulAlgo)
                {
                case AUTH_ALGO_MD5:
                    pst->LoadString(IDS_DOI_AH_MD5);
                    break;
                case AUTH_ALGO_SHA1:
                    pst->LoadString(IDS_DOI_AH_SHA);
                    break;
                }
            }
            break;
        case QM_ALGO_ESP_CONF:
            if (ENCRYPTION == pOffer->m_arrAlgos[i].m_Operation)
            {
                switch(pOffer->m_arrAlgos[i].m_ulAlgo)
                {
                case CONF_ALGO_DES:
                    pst->LoadString(IDS_DOI_ESP_DES);
                    break;
                case CONF_ALGO_3_DES:
                    pst->LoadString(IDS_DOI_ESP_3_DES);
                    break;
                }
            }
            break;
        case QM_ALGO_ESP_INTEG:
            if (ENCRYPTION == pOffer->m_arrAlgos[i].m_Operation)
            {
                switch(pOffer->m_arrAlgos[i].m_SecAlgo)
                {
                case HMAC_AUTH_ALGO_MD5:
                    pst->LoadString(IDS_HMAC_AH_MD5);
                    break;
                case HMAC_AUTH_ALGO_SHA1:
                    pst->LoadString(IDS_HMAC_AH_SHA);
                    break;
                }
            }
            break;
        }
    }
}

void TnlEpToString
(
    QM_FILTER_TYPE FltrType,
    ADDR    TnlEp,
    CString * pst
)
{
    Assert(pst);

    if (NULL == pst)
        return;

    if (QM_TUNNEL_FILTER == FltrType)
    {
        AddressToString(TnlEp, pst);        
    }
    else
    {
        pst->LoadString(IDS_NOT_AVAILABLE);
    }
}

void TnlEpToString
(
    FILTER_TYPE FltrType,
    ADDR    TnlEp,
    CString * pst
)
{
    Assert(pst);

    if (NULL == pst)
        return;

    if (FILTER_TYPE_TUNNEL == FltrType)
    {
        AddressToString(TnlEp, pst);        
    }
    else
    {
        pst->LoadString(IDS_NOT_AVAILABLE);
    }
}

void IpsecByteBlobToString1(const IPSEC_BYTE_BLOB& blob, CString * pst)
{
    Assert(pst);
    if (NULL == pst)
        return;

    pst->Empty();
 
    WCHAR *pszTemp =  NULL;

    pszTemp = (WCHAR *) LocalAlloc(LMEM_ZEROINIT,blob.dwSize + sizeof(WCHAR));

    memcpy((LPBYTE)pszTemp, blob.pBlob, blob.dwSize);
    
    *pst = pszTemp;

    //bug bug
    LocalFree(pszTemp);
}

BOOL
GetNameAudit(
	IN CRYPT_DATA_BLOB *NameBlob,
	IN OUT LPTSTR Name,
	IN DWORD NameBufferSize
	)
{
	DWORD dwCount=0;
	DWORD dwSize = 0;
    BOOL bRet = TRUE;

	dwSize = CertNameToStr(
					MY_ENCODING_TYPE,     		// Encoding type
					NameBlob,            		// CRYPT_DATA_BLOB
					CERT_X500_NAME_STR, 		// Type
					Name,       				// Place to return string
					NameBufferSize);            // Size of string (chars)
	if(dwSize <= 1)
	{
		dwCount = _tcslen(_TEXT(""))+1;
		_tcsncpy(Name, _TEXT(""), dwCount);
        bRet = FALSE;
	}

    return bRet;
}

VOID
GetCertId(
	IN PIPSEC_BYTE_BLOB pCertificateChain, 
    CString * pstCertId
	)
{
    CRYPT_DATA_BLOB pkcsMsg;
    HANDLE hCertStore = NULL;
    PCCERT_CONTEXT pPrevCertContext = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    _TCHAR pszSubjectName[1024] = {0};
    CRYPT_DATA_BLOB NameBlob;
    BOOL bRet;
    
    pkcsMsg.pbData=pCertificateChain->pBlob;
    pkcsMsg.cbData=pCertificateChain->dwSize;

    hCertStore = CertOpenStore( CERT_STORE_PROV_PKCS7,
                                    MY_ENCODING_TYPE | PKCS_7_ASN_ENCODING,
                                    NULL,
                                    CERT_STORE_READONLY_FLAG,
                                    &pkcsMsg);

    if ( NULL == hCertStore )
    {
        goto error;
    }

    pCertContext = CertEnumCertificatesInStore(  hCertStore,
                                                     pPrevCertContext);
    if ( NULL == pCertContext )
    {
         goto error;
    }

    NameBlob = pCertContext->pCertInfo->Subject;

    *pstCertId = _T("\0");
 
    DWORD dwRet = CertGetNameString(
					pCertContext,
					CERT_NAME_FRIENDLY_DISPLAY_TYPE,
					0,
					NULL,
					pszSubjectName,
					sizeof(pszSubjectName)/sizeof(pszSubjectName[0])
					);
		
    *pstCertId = _T("");

    if ( dwRet > 1 )
    {
        *pstCertId = pszSubjectName;
    }

error:
    if ( hCertStore )
    {
        CertCloseStore(hCertStore, 0 );
    }
}

void PFSGroupToString(
	DWORD dwPFSGroup,
	CString * pst
	)
{
	switch(dwPFSGroup)
	{
	case 1:
		pst->LoadString(IDS_DHGROUP_LOW);
		break;
	case 2:
		pst->LoadString(IDS_DHGROUP_MEDIUM);
		break;
	case PFS_GROUP_2048:
		pst->LoadString(IDS_DHGROUP_HIGH);
		break;
	case PFS_GROUP_MM:
		pst->LoadString(IDS_PFS_GROUP_DERIVED);
		break;
	case 0:
		pst->LoadString(IDS_DHGROUP_UNASSIGNED);
		break;
	default:
		pst->Format(_T("%d"), dwPFSGroup);
		break;
	}
}


void GetAuthId(PIPSEC_MM_SA pSa, CString * pstAuthId, BOOL bPeer)
{
    PIPSEC_BYTE_BLOB pAuthIdBlob = NULL;
    PIPSEC_BYTE_BLOB pCertChainBlob = NULL;

    //assign to NULL
    *pstAuthId = _T("");

    if ( bPeer )
    {
        pAuthIdBlob = (PIPSEC_BYTE_BLOB ) &(pSa->PeerId);
        pCertChainBlob = (PIPSEC_BYTE_BLOB) &(pSa->PeerCertificateChain);
    }
    else
    {
        pAuthIdBlob = (PIPSEC_BYTE_BLOB) &(pSa->MyId);
        pCertChainBlob = (PIPSEC_BYTE_BLOB) &(pSa->MyCertificateChain);
    }

    if ( (pAuthIdBlob->dwSize > 0) && (pAuthIdBlob->pBlob) )
    {
        IpsecByteBlobToString1( *pAuthIdBlob, pstAuthId );
        return;
    }

    switch(pSa->MMAuthEnum)
    {
    case IKE_PRESHARED_KEY:
        {
            ADDR *pAddr;
            ULONG ul;
            CIpAddress ipAddr;
            //should be just a IP address
            if ( bPeer )
            {
                pAddr = &(pSa->Peer);
            }
            else
            {
                pAddr = &(pSa->Me);
            }

            ul = RevertDwordBytes(pAddr->uIpAddr);
            ipAddr = ul;
            *pstAuthId = (CString) ipAddr;
        }
        break;
    case IKE_DSS_SIGNATURE:
    case IKE_RSA_SIGNATURE:
    case IKE_RSA_ENCRYPTION:
        //get the id from the cert chain
        GetCertId( pCertChainBlob, pstAuthId );
        break;
    case IKE_SSPI:
        //dns name
        //not needed to do anything as spd gives the correct id for SSPI case
        break;
    default:
        break; 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\srchfltr.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    SrchFltr.h   
        Search Filter dialog header file

	FILE HISTORY:
        
*/

#if !defined(AFX_SRCHFLTR_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_)
#define AFX_SRCHFLTR_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_

#include "mdlsdlg.h"
#include "spddb.h"
#include "ipctrl.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CSearchFilters dialog

class CSearchFilters : public CModelessDlg
{
// Construction
public:
	CSearchFilters(ISpdInfo * pSpdInfo);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSearchFilters)
	enum { IDD = IDD_SRCH_FLTRS };
	
	//}}AFX_DATA

    virtual DWORD * GetHelpMap() { return (DWORD *) &g_aHelpIDs_IDD_SRCH_FLTRS[0]; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSearchFilters)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSearchFilters)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonSearch();
	afx_msg void OnSrcOptionClicked();
	afx_msg void OnDestOptionClicked();
	afx_msg void OnSrcPortClicked();
	afx_msg void OnDestPortClicked();
	afx_msg void OnSrcMeOptionClicked();
	afx_msg void OnDstMeOptionClicked();
	afx_msg void OnSelEndOkCbprotocoltype();
	afx_msg void OnEnChangeProtocolID();
	virtual void OnOK();
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CListCtrl	m_listResult;
	CComboBox	m_cmbProtocol;
	CEdit       m_editProtID;
	CSpinButtonCtrl m_spinProtID;
	IPControl	m_ipSrc;
	IPControl   m_ipDest;
private:
	HWND CreateIPControl(UINT uID, UINT uIDIpCtl);
	BOOL LoadConditionInfoFromControls(CFilterInfo * pFltr);
	void EnableControls();
	void PopulateFilterListToControl(CFilterInfoArray * parrFltrs);
	void SafeEnableWindow(int nId, BOOL fEnable);
	void AddIpAddrsToCombo();

public:
	SPISpdInfo             m_spSpdInfo;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SRCHFLTR_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\util.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

#ifndef __UTIL
#define __UTIL

//#include <windows.h>


#define ROUNDUP2( x, n ) ((((ULONG)(x)) + (((ULONG)(n)) - 1 )) & ~(((ULONG)(n)) - 1 ))
#define MINIMUM_VM_ALLOCATION 0x10000
#define SUBALLOCATOR_ALIGNMENT 8

#define StrToInt TextToUnsignedNum



struct _SUBALLOCATOR 
{
    PVOID  VirtualListTerminator;
    PVOID *VirtualList;
    PCHAR  NextAvailable;
    PCHAR  LastAvailable;
    ULONG  GrowSize;
};

typedef struct _SUBALLOCATOR SUBALLOCATOR, *PSUBALLOCATOR;


PVOID __fastcall SubAllocate(IN HANDLE hAllocator, IN ULONG  Size);
VOID DestroySubAllocator(IN HANDLE hAllocator);
HANDLE CreateSubAllocator(IN ULONG InitialCommitSize,  IN ULONG GrowthCommitSize);





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\stdafx.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
	stdafx.cpp	
		precompiled header file

	FILE HISTORY:
        
*/

#include "stdafx.h"
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\stats.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
    provider.cpp
        Main Mode Policy node handler

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "server.h"
#include "Stats.h"





UINT QmStatsItems1[] = {
	IDS_STATS_QM_ACTIVE_SA,
	IDS_STATS_QM_OFFLOAD_SA,
	IDS_STATS_QM_PENDING_KEY_OPS,
	IDS_STATS_QM_KEY_ADDITION,
	IDS_STATS_QM_KEY_DELETION,
	IDS_STATS_QM_REKEYS,
	IDS_STATS_QM_ACTIVE_TNL,
	IDS_STATS_QM_BAD_SPI,
	IDS_STATS_QM_PKT_NOT_DECRYPT,
	IDS_STATS_QM_PKT_NOT_AUTH,
	IDS_STATS_QM_PKT_REPLAY,
	IDS_STATS_QM_ESP_BYTE_SENT,
	IDS_STATS_QM_ESP_BYTE_RCV,
	IDS_STATS_QM_AUTH_BYTE_SENT,
	IDS_STATS_QM_ATTH_BYTE_RCV,
	IDS_STATS_QM_XPORT_BYTE_SENT,
	IDS_STATS_QM_XPORT_BYTE_RCV,
	IDS_STATS_QM_TNL_BYTE_SENT,
	IDS_STATS_QM_TNL_BYTE_RCV,
	IDS_STATS_QM_OFFLOAD_BYTE_SENT,
	IDS_STATS_QM_OFFLOAD_BYTE_RCV
};

UINT MmStatsItems1[] = {
	IDS_STATS_MM_ACTIVE_ACQUIRE,
	IDS_STATS_MM_ACTIVE_RCV,
	IDS_STATS_MM_ACQUIRE_FAIL,
	IDS_STATS_MM_RCV_FAIL,
	IDS_STATS_MM_SEND_FAIL,
	IDS_STATS_MM_ACQUIRE_HEAP_SIZE,
	IDS_STATS_MM_RCV_HEAP_SIZE,
    IDS_STATS_MM_ATTH_FAILURE,
	IDS_STATS_MM_NEG_FAIL,
	IDS_STATS_MM_INVALID_COOKIE,
	IDS_STATS_MM_TOTAL_ACQUIRE,
	IDS_STATS_MM_TOTAL_GETSPI,
	IDS_STATS_MM_TOTAL_KEY_ADD,
	IDS_STATS_MM_TOTAL_KEY_UPDATE,
	IDS_STATS_MM_GET_SPI_FAIL,
	IDS_STATS_MM_KEY_ADD_FAIL,
	IDS_STATS_MM_KEY_UPDATE_FAIL,
	IDS_STATS_MM_ISADB_LIST_SIZE,
	IDS_STATS_MM_CONN_LIST_SIZE,
	IDS_STATS_MM_OAKLEY_MM,
	IDS_STATS_MM_OAKLEY_QM,
	IDS_STATS_MM_SOFT_ASSOCIATIONS,
    IDS_STATS_MM_INVALID_PACKETS
};


/*---------------------------------------------------------------------------
    Class CIkeStatsHandler implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    Constructor and destructor
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
CIkeStatsHandler::CIkeStatsHandler
(
    ITFSComponentData * pComponentData
) : CIpsmHandler(pComponentData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
}


CIkeStatsHandler::~CIkeStatsHandler()
{
}

/*!--------------------------------------------------------------------------
    CIkeStatsHandler::InitializeNode
        Initializes node specific data
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIkeStatsHandler::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    CString strTemp;  
	strTemp.LoadString(IDS_STATS_DATA);
    SetDisplayName(strTemp);

    // Make the node immediately visible
    pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
    pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_FOLDER_CLOSED);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_FOLDER_OPEN);
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, IPSECMON_MM_IKESTATS);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

    SetColumnStringIDs(&aColumns[IPSECMON_MM_IKESTATS][0]);
    SetColumnWidths(&aColumnWidths[IPSECMON_MM_IKESTATS][0]);

    return hrOK;
}


/*---------------------------------------------------------------------------
    CIkeStatsHandler::GetImageIndex
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CIkeStatsHandler::GetImageIndex(BOOL bOpenImage) 
{
    int nIndex = -1;

    return nIndex;
}


/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CIkeStatsHandler::OnAddMenuItems
        Adds context menu items for the SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIkeStatsHandler::OnAddMenuItems
(
    ITFSNode *              pNode,
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    LPDATAOBJECT            lpDataObject, 
    DATA_OBJECT_TYPES       type, 
    DWORD                   dwType,
    long *                  pInsertionAllowed
)
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    LONG        fFlags = 0, fLoadingFlags = 0;
    HRESULT     hr = S_OK;
    
    if (type == CCT_SCOPE)
    {
		//load scope node context menu items here
        // these menu items go in the new menu, 
        // only visible from scope pane
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
            
        }

    }

    return hr; 
}

/*!--------------------------------------------------------------------------
    CIkeStatsHandler::AddMenuItems
        Adds context menu items for virtual list box (result pane) items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIkeStatsHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
    MMC_COOKIE              cookie,
    LPDATAOBJECT            pDataObject, 
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    long *                  pInsertionAllowed
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT     hr = hrOK;
    CString     strMenuItem;
    SPINTERNAL  spInternal;
    LONG        fFlags = 0;

    spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or this SA
    // node itself.
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        //load and view menu items here
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CIkeStatsHandler::OnRefresh
        Default implementation for the refresh functionality
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIkeStatsHandler::OnRefresh
(
    ITFSNode *      pNode,
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg,
    LPARAM          param
)
{
	HRESULT hr = S_OK;
    int i = 0; 
    SPIConsole      spConsole;

    CORg(CHandler::OnRefresh(pNode, pDataObject, dwType, arg, param));

	    
	CORg(m_spSpdInfo->LoadStatistics());
	
	m_spSpdInfo->GetLoadedStatistics(&m_IkeStats, NULL);

	
    i = sizeof(MmStatsItems1)/sizeof(UINT);
	    
    // now notify the virtual listbox
    CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE));
    
Error:
	return hr;
}

/*---------------------------------------------------------------------------
    CIkeStatsHandler::OnCommand
        Handles context menu commands for SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIkeStatsHandler::OnCommand
(
    ITFSNode *          pNode, 
    long                nCommandId, 
    DATA_OBJECT_TYPES   type, 
    LPDATAOBJECT        pDataObject, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    return S_OK;
}

/*!--------------------------------------------------------------------------
    CIkeStatsHandler::Command
        Handles context menu commands for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIkeStatsHandler::Command
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    int             nCommandID,
    LPDATAOBJECT    pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    SPITFSNode spNode;

    m_spResultNodeMgr->FindNode(cookie, &spNode);

	// handle result context menu and view menus here	

    return hr;
}

/*!--------------------------------------------------------------------------
    CIkeStatsHandler::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    NOTE: the root node handler has to over-ride this function to 
    handle the snapin manager property page (wizard) case!!!
    
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIkeStatsHandler::HasPropertyPages
(
    ITFSNode *          pNode,
    LPDATAOBJECT        pDataObject, 
    DATA_OBJECT_TYPES   type, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    return hrFalse;
}

/*---------------------------------------------------------------------------
    CIkeStatsHandler::CreatePropertyPages
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIkeStatsHandler::CreatePropertyPages
(
    ITFSNode *              pNode,
    LPPROPERTYSHEETCALLBACK lpSA,
    LPDATAOBJECT            pDataObject, 
    LONG_PTR                handle, 
    DWORD                   dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    return hrFalse;
}

/*---------------------------------------------------------------------------
    CIkeStatsHandler::OnPropertyChange
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIkeStatsHandler::OnPropertyChange
(   
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataobject, 
    DWORD           dwType, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    //CServerProperties * pServerProp = reinterpret_cast<CServerProperties *>(lParam);

    LONG_PTR changeMask = 0;

    // tell the property page to do whatever now that we are back on the
    // main thread
    //pServerProp->OnPropertyChange(TRUE, &changeMask);

    //pServerProp->AcknowledgeNotify();

    if (changeMask)
        pNode->ChangeNode(changeMask);

    return hrOK;
}

/*---------------------------------------------------------------------------
    CIkeStatsHandler::OnExpand
        Handles enumeration of a scope item
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIkeStatsHandler::OnExpand
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    CORg (CIpsmHandler::OnExpand(pNode, pDataObject, dwType, arg, param));

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    CIkeStatsHandler::OnResultSelect
        Handles the MMCN_SELECT notifcation 
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIkeStatsHandler::OnResultSelect
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie,
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    SPINTERNAL      spInternal;
    SPIConsole      spConsole;
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    int             i;
    LONG_PTR        dwNodeType;
    BOOL            fSelect = HIWORD(arg);

	// virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or the active
    // registrations node itself.
    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

	m_verbDefault = MMC_VERB_OPEN;

    if (!fSelect)
	{
        return hr;
	}

    // Get the current count
    i = sizeof(MmStatsItems1)/sizeof(UINT);

    // now notify the virtual listbox
    CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE) ); 

    // now update the verbs...
    spInternal = ExtractInternalFormat(pDataObject);
    Assert(spInternal);


    if (spInternal->HasVirtualIndex())
    {
		//TODO add to here if we want to have some result console verbs
        // we gotta do special stuff for the virtual index items
        dwNodeType = IPSECMON_MM_IKESTATS_ITEM;
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
		
		m_verbDefault = MMC_VERB_PROPERTIES;
    }
    else
    {
        // enable/disable delete depending if the node supports it
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
        dwNodeType = spNode->GetData(TFS_DATA_TYPE);

        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);

        //hide "delete" context menu
        bStates[MMC_VERB_DELETE & 0x000F] = FALSE;
    }

    EnableVerbs(spConsoleVerb, g_ConsoleVerbStates[dwNodeType], bStates);
	
COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*!--------------------------------------------------------------------------
    CIkeStatsHandler::OnDelete
        The base handler calls this when MMC sends a MMCN_DELETE for a 
        scope pane item.  We just call our delete command handler.
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIkeStatsHandler::OnDelete
(
    ITFSNode *  pNode, 
    LPARAM      arg, 
    LPARAM      lParam
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
    CIkeStatsHandler::HasPropertyPages
        Handle the result notification
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIkeStatsHandler::HasPropertyPages(
   ITFSComponent *pComponent,
   MMC_COOKIE cookie,
   LPDATAOBJECT pDataObject)
{
	return hrFalse;
}

/*!--------------------------------------------------------------------------
    CIkeStatsHandler::HasPropertyPages
        Handle the result notification. Create the filter property sheet
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP CIkeStatsHandler::CreatePropertyPages
(
	ITFSComponent * 		pComponent, 
   MMC_COOKIE			   cookie,
   LPPROPERTYSHEETCALLBACK lpProvider, 
   LPDATAOBJECT 		 pDataObject, 
   LONG_PTR 			 handle
)
{
 
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return hrFalse;
}


/*---------------------------------------------------------------------------
    CIkeStatsHandler::OnGetResultViewType
        Return the result view that this node is going to support
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIkeStatsHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE            cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    if (cookie != NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;
    }

    return S_FALSE;
}

/*---------------------------------------------------------------------------
    CIkeStatsHandler::GetVirtualImage
        Returns the image index for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CIkeStatsHandler::GetVirtualImage
(
    int     nIndex
)
{
    return ICON_IDX_POLICY;
}

/*---------------------------------------------------------------------------
    CIkeStatsHandler::GetVirtualString
        returns a pointer to the string for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
LPCWSTR 
CIkeStatsHandler::GetVirtualString
(
    int     nIndex,
    int     nCol
)
{
	HRESULT hr = S_OK;
	static CString strTemp;

	strTemp.Empty();

	if (nCol >= DimensionOf(aColumns[IPSECMON_MM_IKESTATS]))
		return NULL;
	
	

    switch (aColumns[IPSECMON_MM_IKESTATS][nCol])
    {
        case IDS_STATS_NAME:
			strTemp.LoadString(MmStatsItems1[nIndex]);
			return strTemp;
            break;

        case IDS_STATS_DATA:
			switch (MmStatsItems1[nIndex])
			{
		        case IDS_STATS_MM_ACTIVE_ACQUIRE:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwActiveAcquire);
			        break;
		        case IDS_STATS_MM_ACTIVE_RCV:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwActiveReceive);
			        break;
		        case IDS_STATS_MM_ACQUIRE_FAIL:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwAcquireFail);
			        break;
		        case IDS_STATS_MM_RCV_FAIL:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwReceiveFail);
			        break;
		        case IDS_STATS_MM_SEND_FAIL:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwSendFail);
			        break;
		        case IDS_STATS_MM_ACQUIRE_HEAP_SIZE:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwAcquireHeapSize);
			        break;
		        case IDS_STATS_MM_RCV_HEAP_SIZE:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwReceiveHeapSize);
			        break;
		        case IDS_STATS_MM_NEG_FAIL:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwNegotiationFailures);
			        break;
                case IDS_STATS_MM_ATTH_FAILURE:
                    strTemp.Format(_T("%u"), m_IkeStats.m_dwAuthenticationFailures);
                    break;
		        case IDS_STATS_MM_INVALID_COOKIE:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwInvalidCookiesReceived);
			        break;
		        case IDS_STATS_MM_TOTAL_ACQUIRE:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwTotalAcquire);
			        break;
		        case IDS_STATS_MM_TOTAL_GETSPI:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwTotalGetSpi);
			        break;
		        case IDS_STATS_MM_TOTAL_KEY_ADD:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwTotalKeyAdd);
			        break;
		        case IDS_STATS_MM_TOTAL_KEY_UPDATE:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwTotalKeyUpdate);
			        break;
		        case IDS_STATS_MM_GET_SPI_FAIL:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwGetSpiFail);
			        break;
		        case IDS_STATS_MM_KEY_ADD_FAIL:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwKeyAddFail);
			        break;
		        case IDS_STATS_MM_KEY_UPDATE_FAIL:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwKeyUpdateFail);
			        break;
		        case IDS_STATS_MM_ISADB_LIST_SIZE:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwIsadbListSize);
			        break;
		        case IDS_STATS_MM_CONN_LIST_SIZE:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwConnListSize);
			        break;
		        case IDS_STATS_MM_OAKLEY_MM:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwOakleyMainModes);
			        break;
		        case IDS_STATS_MM_OAKLEY_QM:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwOakleyQuickModes);
			        break;
		        case IDS_STATS_MM_SOFT_ASSOCIATIONS:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwSoftAssociations);
			        break;
		        case IDS_STATS_MM_INVALID_PACKETS:
			        strTemp.Format(_T("%u"), m_IkeStats.m_dwInvalidPacketsReceived);
			        break;
			}
			//strTemp.Format(_T("%d"), 10);
			return strTemp;
            break;

        default:
            Panic0("CIkeStatsHandler::GetVirtualString - Unknown column!\n");
            break;
    }


    return NULL;
}

/*---------------------------------------------------------------------------
    CIkeStatsHandler::CacheHint
        MMC tells us which items it will need before it requests things
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIkeStatsHandler::CacheHint
(
    int nStartIndex, 
    int nEndIndex
)
{
    HRESULT hr = hrOK;;

    Trace2("CacheHint - Start %d, End %d\n", nStartIndex, nEndIndex);
    return hr;
}

/*---------------------------------------------------------------------------
    CIkeStatsHandler::SortItems
        We are responsible for sorting of virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
/*STDMETHODIMP 
CIkeStatsHandler::SortItems
(
    int     nColumn, 
    DWORD   dwSortOptions, 
    LPARAM    lUserParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;

	if (nColumn >= DimensionOf(aColumns[IPSECMON_MM_POLICY]))
		return E_INVALIDARG;
	
	BEGIN_WAIT_CURSOR
	
	DWORD dwIndexType = aColumns[IPSECMON_MM_POLICY][nColumn];

	hr = m_spSpdInfo->SortMmPolicies(dwIndexType, dwSortOptions);
	
	END_WAIT_CURSOR
    return hr;
}*/

/*!--------------------------------------------------------------------------
    CIkeStatsHandler::OnResultUpdateView
        Implementation of ITFSResultHandler::OnResultUpdateView
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT CIkeStatsHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM        data, 
    LONG_PTR      hint
)
{
    HRESULT    hr = hrOK;
    SPITFSNode spSelectedNode;

    pComponent->GetSelectedNode(&spSelectedNode);
    if (spSelectedNode == NULL)
        return S_OK; // no selection for our IComponentData

    if ( hint == IPSECMON_UPDATE_STATUS )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);
        SPITFSNode spSelectedNode;

        pComponent->GetSelectedNode(&spSelectedNode);

        if (pNode == spSelectedNode)
        {       
            // if we are the selected node, then we need to update
            SPIResultData spResultData;

            CORg (pComponent->GetResultData(&spResultData));
            CORg (spResultData->SetItemCount((int) data, MMCLV_UPDATE_NOSCROLL));
        }
    }
    else
    {
        // we don't handle this message, let the base class do it.
        return CIpsmHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

COM_PROTECT_ERROR_LABEL;

    return hr;
}



/*!--------------------------------------------------------------------------
    CIkeStatsHandler::LoadColumns
        Set the correct column header and then call the base class
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIkeStatsHandler::LoadColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
	//set column info
    return CIpsmHandler::LoadColumns(pComponent, cookie, arg, lParam);
}

/*---------------------------------------------------------------------------
    Command handlers
 ---------------------------------------------------------------------------*/

 
/*---------------------------------------------------------------------------
    CIkeStatsHandler::OnDelete
        Removes a service SA
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIkeStatsHandler::OnDelete
(
    ITFSNode * pNode
)
{
    HRESULT         hr = S_FALSE;
    return hr;
}


/*---------------------------------------------------------------------------
    CIkeStatsHandler::UpdateStatus
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIkeStatsHandler::UpdateStatus
(
    ITFSNode * pNode
)
{
    HRESULT             hr = hrOK;

    SPIComponentData    spComponentData;
    SPIConsole          spConsole;
    IDataObject *       pDataObject;
    SPIDataObject       spDataObject;
    int                 i = 0;
    
    Trace0("CIkeStatsHandler::UpdateStatus - Updating status for Filter");

    // force the listbox to update.  We do this by setting the count and 
    // telling it to invalidate the data
    CORg(m_spNodeMgr->GetComponentData(&spComponentData));
    CORg(m_spNodeMgr->GetConsole(&spConsole));
    
    // grab a data object to use
    CORg(spComponentData->QueryDataObject((MMC_COOKIE) pNode, CCT_RESULT, &pDataObject) );
    spDataObject = pDataObject;

	
	CORg(m_spSpdInfo->LoadStatistics());
	
	m_spSpdInfo->GetLoadedStatistics(&m_IkeStats, NULL);


	i = sizeof(MmStatsItems1)/sizeof(UINT);

    CORg(spConsole->UpdateAllViews(pDataObject, i, IPSECMON_UPDATE_STATUS));

COM_PROTECT_ERROR_LABEL;

    return hr;
}

/*---------------------------------------------------------------------------
    Misc functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CIkeStatsHandler::InitData
        Initializes data for this node
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIkeStatsHandler::InitData
(
    ISpdInfo *     pSpdInfo
)
{
	HRESULT hr = hrOK;
    m_spSpdInfo.Set(pSpdInfo);

	CORg(m_spSpdInfo->LoadStatistics());
	
	m_spSpdInfo->GetLoadedStatistics(&m_IkeStats, NULL);

    return hr;

Error:
	if (FAILED(hr))
	{
		//TODO bring up a error pop up here
	}
	return hr;
}







/*---------------------------------------------------------------------------
    Class CIpsecStatsHandler implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    Constructor and destructor
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
CIpsecStatsHandler::CIpsecStatsHandler
(
    ITFSComponentData * pComponentData
) : CIpsmHandler(pComponentData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
}


CIpsecStatsHandler::~CIpsecStatsHandler()
{
}

/*!--------------------------------------------------------------------------
    CIpsecStatsHandler::InitializeNode
        Initializes node specific data
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsecStatsHandler::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    CString strTemp;  
	strTemp.LoadString(IDS_STATS_DATA);
    SetDisplayName(strTemp);

    // Make the node immediately visible
    pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
    pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_FOLDER_CLOSED);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_FOLDER_OPEN);
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, IPSECMON_QM_IPSECSTATS);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

    SetColumnStringIDs(&aColumns[IPSECMON_QM_IPSECSTATS][0]);
    SetColumnWidths(&aColumnWidths[IPSECMON_QM_IPSECSTATS][0]);

    return hrOK;
}


/*---------------------------------------------------------------------------
    CIpsecStatsHandler::GetImageIndex
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CIpsecStatsHandler::GetImageIndex(BOOL bOpenImage) 
{
    int nIndex = -1;

    return nIndex;
}


/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CIpsecStatsHandler::OnAddMenuItems
        Adds context menu items for the SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsecStatsHandler::OnAddMenuItems
(
    ITFSNode *              pNode,
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    LPDATAOBJECT            lpDataObject, 
    DATA_OBJECT_TYPES       type, 
    DWORD                   dwType,
    long *                  pInsertionAllowed
)
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    LONG        fFlags = 0, fLoadingFlags = 0;
    HRESULT     hr = S_OK;
    CString     strMenuItem;

    if (type == CCT_SCOPE)
    {
		//load scope node context menu items here
        // these menu items go in the new menu, 
        // only visible from scope pane
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
        }

    }

    return hr; 
}

/*!--------------------------------------------------------------------------
    CIpsecStatsHandler::AddMenuItems
        Adds context menu items for virtual list box (result pane) items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsecStatsHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
    MMC_COOKIE              cookie,
    LPDATAOBJECT            pDataObject, 
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    long *                  pInsertionAllowed
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT     hr = hrOK;
    CString     strMenuItem;
    SPINTERNAL  spInternal;
    LONG        fFlags = 0;

    spInternal = ExtractInternalFormat(pDataObject);

    // virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or this SA
    // node itself.
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        //load and view menu items here
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsecStatsHandler::OnRefresh
        Default implementation for the refresh functionality
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsecStatsHandler::OnRefresh
(
    ITFSNode *      pNode,
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg,
    LPARAM          param
)
{
	HRESULT hr = S_OK;
    int i = 0; 
    SPIConsole      spConsole;

    CORg(CHandler::OnRefresh(pNode, pDataObject, dwType, arg, param));

	    
	CORg(m_spSpdInfo->LoadStatistics());
	
	m_spSpdInfo->GetLoadedStatistics(NULL, &m_IpsecStats);

	
    i = sizeof(QmStatsItems1)/sizeof(UINT);
	    
    // now notify the virtual listbox
    CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE));
    
Error:
	return hr;
}

/*---------------------------------------------------------------------------
    CIpsecStatsHandler::OnCommand
        Handles context menu commands for SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsecStatsHandler::OnCommand
(
    ITFSNode *          pNode, 
    long                nCommandId, 
    DATA_OBJECT_TYPES   type, 
    LPDATAOBJECT        pDataObject, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    return S_OK;
}

/*!--------------------------------------------------------------------------
    CIpsecStatsHandler::Command
        Handles context menu commands for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsecStatsHandler::Command
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    int             nCommandID,
    LPDATAOBJECT    pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    SPITFSNode spNode;

    m_spResultNodeMgr->FindNode(cookie, &spNode);

	// handle result context menu and view menus here	

    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsecStatsHandler::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    NOTE: the root node handler has to over-ride this function to 
    handle the snapin manager property page (wizard) case!!!
    
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsecStatsHandler::HasPropertyPages
(
    ITFSNode *          pNode,
    LPDATAOBJECT        pDataObject, 
    DATA_OBJECT_TYPES   type, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    return hrFalse;
}

/*---------------------------------------------------------------------------
    CIpsecStatsHandler::CreatePropertyPages
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsecStatsHandler::CreatePropertyPages
(
    ITFSNode *              pNode,
    LPPROPERTYSHEETCALLBACK lpSA,
    LPDATAOBJECT            pDataObject, 
    LONG_PTR                handle, 
    DWORD                   dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    return hrFalse;
}

/*---------------------------------------------------------------------------
    CIpsecStatsHandler::OnPropertyChange
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsecStatsHandler::OnPropertyChange
(   
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataobject, 
    DWORD           dwType, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    //CServerProperties * pServerProp = reinterpret_cast<CServerProperties *>(lParam);

    LONG_PTR changeMask = 0;

    // tell the property page to do whatever now that we are back on the
    // main thread
    //pServerProp->OnPropertyChange(TRUE, &changeMask);

    //pServerProp->AcknowledgeNotify();

    if (changeMask)
        pNode->ChangeNode(changeMask);

    return hrOK;
}

/*---------------------------------------------------------------------------
    CIpsecStatsHandler::OnExpand
        Handles enumeration of a scope item
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsecStatsHandler::OnExpand
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    CORg (CIpsmHandler::OnExpand(pNode, pDataObject, dwType, arg, param));

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsecStatsHandler::OnResultSelect
        Handles the MMCN_SELECT notifcation 
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsecStatsHandler::OnResultSelect
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie,
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    SPINTERNAL      spInternal;
    SPIConsole      spConsole;
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    int             i;
    LONG_PTR        dwNodeType;
    BOOL            fSelect = HIWORD(arg);

	// virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or the active
    // registrations node itself.
    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

	m_verbDefault = MMC_VERB_OPEN;

    if (!fSelect)
	{
        return hr;
	}

	
    // Get the current count
    i = sizeof(QmStatsItems1)/sizeof(UINT);

    // now notify the virtual listbox
    CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE) ); 

    // now update the verbs...
    spInternal = ExtractInternalFormat(pDataObject);
    Assert(spInternal);


    if (spInternal->HasVirtualIndex())
    {
		//TODO add to here if we want to have some result console verbs
        // we gotta do special stuff for the virtual index items
        dwNodeType = IPSECMON_QM_IPSECSTATS_ITEM;
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
		
		m_verbDefault = MMC_VERB_PROPERTIES;
    }
    else
    {
        // enable/disable delete depending if the node supports it
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
        dwNodeType = spNode->GetData(TFS_DATA_TYPE);

        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);

        //hide "delete" context menu
        bStates[MMC_VERB_DELETE & 0x000F] = FALSE;
    }

    EnableVerbs(spConsoleVerb, g_ConsoleVerbStates[dwNodeType], bStates);
	
COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsecStatsHandler::OnDelete
        The base handler calls this when MMC sends a MMCN_DELETE for a 
        scope pane item.  We just call our delete command handler.
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsecStatsHandler::OnDelete
(
    ITFSNode *  pNode, 
    LPARAM      arg, 
    LPARAM      lParam
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
    CIpsecStatsHandler::HasPropertyPages
        Handle the result notification
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsecStatsHandler::HasPropertyPages(
   ITFSComponent *pComponent,
   MMC_COOKIE cookie,
   LPDATAOBJECT pDataObject)
{
	return hrFalse;
}

/*!--------------------------------------------------------------------------
    CIpsecStatsHandler::HasPropertyPages
        Handle the result notification. Create the filter property sheet
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP CIpsecStatsHandler::CreatePropertyPages
(
	ITFSComponent * 		pComponent, 
   MMC_COOKIE			   cookie,
   LPPROPERTYSHEETCALLBACK lpProvider, 
   LPDATAOBJECT 		 pDataObject, 
   LONG_PTR 			 handle
)
{
 
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return hrFalse;
}


/*---------------------------------------------------------------------------
    CIpsecStatsHandler::OnGetResultViewType
        Return the result view that this node is going to support
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsecStatsHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE            cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    if (cookie != NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;
    }

    return S_FALSE;
}

/*---------------------------------------------------------------------------
    CIpsecStatsHandler::GetVirtualImage
        Returns the image index for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CIpsecStatsHandler::GetVirtualImage
(
    int     nIndex
)
{
    return ICON_IDX_POLICY;
}

/*---------------------------------------------------------------------------
    CIpsecStatsHandler::GetVirtualString
        returns a pointer to the string for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
LPCWSTR 
CIpsecStatsHandler::GetVirtualString
(
    int     nIndex,
    int     nCol
)
{
	HRESULT hr = S_OK;
	static CString strTemp;

	strTemp.Empty();

	if (nCol >= DimensionOf(aColumns[IPSECMON_QM_IPSECSTATS]))
		return NULL;
	
	

    switch (aColumns[IPSECMON_MM_IKESTATS][nCol])
    {
        case IDS_STATS_NAME:
			strTemp.LoadString(QmStatsItems1[nIndex]);
			return strTemp;
            break;

        case IDS_STATS_DATA:
			switch(QmStatsItems1[nIndex])
			{
		        case IDS_STATS_QM_ACTIVE_SA:
			       strTemp.Format(_T("%u"), m_IpsecStats.m_dwNumActiveAssociations);
			       break;
		        case IDS_STATS_QM_OFFLOAD_SA:
			       strTemp.Format(_T("%u"), m_IpsecStats.m_dwNumOffloadedSAs);
			       break;
		        case IDS_STATS_QM_PENDING_KEY_OPS:
			       strTemp.Format(_T("%u"), m_IpsecStats.m_dwNumPendingKeyOps);
			       break;
		        case IDS_STATS_QM_KEY_ADDITION:
			       strTemp.Format(_T("%u"), m_IpsecStats.m_dwNumKeyAdditions);
			       break;
		        case IDS_STATS_QM_KEY_DELETION:
			       strTemp.Format(_T("%u"), m_IpsecStats.m_dwNumKeyDeletions);
			       break;
		        case IDS_STATS_QM_REKEYS:
			       strTemp.Format(_T("%u"), m_IpsecStats.m_dwNumReKeys);
			       break;
		        case IDS_STATS_QM_ACTIVE_TNL:
			       strTemp.Format(_T("%u"), m_IpsecStats.m_dwNumActiveTunnels);
			       break;
		        case IDS_STATS_QM_BAD_SPI:
			       strTemp.Format(_T("%u"), m_IpsecStats.m_dwNumBadSPIPackets);
			       break;
		        case IDS_STATS_QM_PKT_NOT_DECRYPT:
			       strTemp.Format(_T("%u"), m_IpsecStats.m_dwNumPacketsNotDecrypted);
			       break;
		        case IDS_STATS_QM_PKT_NOT_AUTH:
			       strTemp.Format(_T("%u"), m_IpsecStats.m_dwNumPacketsNotAuthenticated);
			       break;
		        case IDS_STATS_QM_PKT_REPLAY:
			       strTemp.Format(_T("%u"), m_IpsecStats.m_dwNumPacketsWithReplayDetection);
			       break;
		        case IDS_STATS_QM_ESP_BYTE_SENT:
			       strTemp.Format(_T("%I64u"), m_IpsecStats.m_uConfidentialBytesSent);
			       break;
		        case IDS_STATS_QM_ESP_BYTE_RCV:
			       strTemp.Format(_T("%I64u"), m_IpsecStats.m_uConfidentialBytesReceived);
			       break;
		        case IDS_STATS_QM_AUTH_BYTE_SENT:
			       strTemp.Format(_T("%I64u"), m_IpsecStats.m_uAuthenticatedBytesSent);
			       break;
		        case IDS_STATS_QM_ATTH_BYTE_RCV:
			       strTemp.Format(_T("%I64u"), m_IpsecStats.m_uAuthenticatedBytesReceived);
			       break;
		        case IDS_STATS_QM_XPORT_BYTE_SENT:
			       strTemp.Format(_T("%I64u"), m_IpsecStats.m_uTransportBytesSent);
			       break;
		        case IDS_STATS_QM_XPORT_BYTE_RCV:
			       strTemp.Format(_T("%I64u"), m_IpsecStats.m_uTransportBytesReceived);
			       break;
		        case IDS_STATS_QM_TNL_BYTE_SENT:
			       strTemp.Format(_T("%I64u"), m_IpsecStats.m_uBytesSentInTunnels);
			       break;
		        case IDS_STATS_QM_TNL_BYTE_RCV:
			       strTemp.Format(_T("%I64u"), m_IpsecStats.m_uBytesReceivedInTunnels);
			       break;
		        case IDS_STATS_QM_OFFLOAD_BYTE_SENT:
			       strTemp.Format(_T("%I64u"), m_IpsecStats.m_uOffloadedBytesSent);
			       break;
		        case IDS_STATS_QM_OFFLOAD_BYTE_RCV:
			       strTemp.Format(_T("%I64u"), m_IpsecStats.m_uOffloadedBytesReceived);
			       break;
			}
			return strTemp;
            break;

        default:
            Panic0("CIpsecStatsHandler::GetVirtualString - Unknown column!\n");
            break;
    }


    return NULL;
}

/*---------------------------------------------------------------------------
    CIpsecStatsHandler::CacheHint
        MMC tells us which items it will need before it requests things
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsecStatsHandler::CacheHint
(
    int nStartIndex, 
    int nEndIndex
)
{
    HRESULT hr = hrOK;;

    Trace2("CacheHint - Start %d, End %d\n", nStartIndex, nEndIndex);
    return hr;
}

/*---------------------------------------------------------------------------
    CIpsecStatsHandler::SortItems
        We are responsible for sorting of virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
/*STDMETHODIMP 
CIpsecStatsHandler::SortItems
(
    int     nColumn, 
    DWORD   dwSortOptions, 
    LPARAM    lUserParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;

	if (nColumn >= DimensionOf(aColumns[IPSECMON_MM_POLICY]))
		return E_INVALIDARG;
	
	BEGIN_WAIT_CURSOR
	
	DWORD dwIndexType = aColumns[IPSECMON_MM_POLICY][nColumn];

	hr = m_spSpdInfo->SortMmPolicies(dwIndexType, dwSortOptions);
	
	END_WAIT_CURSOR
    return hr;
}*/

/*!--------------------------------------------------------------------------
    CIpsecStatsHandler::OnResultUpdateView
        Implementation of ITFSResultHandler::OnResultUpdateView
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT CIpsecStatsHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM        data, 
    LONG_PTR      hint
)
{
    HRESULT    hr = hrOK;
    SPITFSNode spSelectedNode;

    pComponent->GetSelectedNode(&spSelectedNode);
    if (spSelectedNode == NULL)
        return S_OK; // no selection for our IComponentData

    if ( hint == IPSECMON_UPDATE_STATUS )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);
        SPITFSNode spSelectedNode;

        pComponent->GetSelectedNode(&spSelectedNode);

        if (pNode == spSelectedNode)
        {       
            // if we are the selected node, then we need to update
            SPIResultData spResultData;

            CORg (pComponent->GetResultData(&spResultData));
            CORg (spResultData->SetItemCount((int) data, MMCLV_UPDATE_NOSCROLL));
        }
    }
    else
    {
        // we don't handle this message, let the base class do it.
        return CIpsmHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

COM_PROTECT_ERROR_LABEL;

    return hr;
}



/*!--------------------------------------------------------------------------
    CIpsecStatsHandler::LoadColumns
        Set the correct column header and then call the base class
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsecStatsHandler::LoadColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
	//set column info
    return CIpsmHandler::LoadColumns(pComponent, cookie, arg, lParam);
}

/*---------------------------------------------------------------------------
    Command handlers
 ---------------------------------------------------------------------------*/

 
/*---------------------------------------------------------------------------
    CIpsecStatsHandler::OnDelete
        Removes a service SA
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsecStatsHandler::OnDelete
(
    ITFSNode * pNode
)
{
    HRESULT         hr = S_FALSE;
    return hr;
}


/*---------------------------------------------------------------------------
    CIpsecStatsHandler::UpdateStatus
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsecStatsHandler::UpdateStatus
(
    ITFSNode * pNode
)
{
    HRESULT             hr = hrOK;

    SPIComponentData    spComponentData;
    SPIConsole          spConsole;
    IDataObject *       pDataObject;
    SPIDataObject       spDataObject;
    int                 i = 0;
    
    Trace0("CIpsecStatsHandler::UpdateStatus - Updating status for Filter");

    // force the listbox to update.  We do this by setting the count and 
    // telling it to invalidate the data
    CORg(m_spNodeMgr->GetComponentData(&spComponentData));
    CORg(m_spNodeMgr->GetConsole(&spConsole));
    
    // grab a data object to use
    CORg(spComponentData->QueryDataObject((MMC_COOKIE) pNode, CCT_RESULT, &pDataObject) );
    spDataObject = pDataObject;

	CORg(m_spSpdInfo->LoadStatistics());
	
	m_spSpdInfo->GetLoadedStatistics(NULL, &m_IpsecStats);

	i = sizeof(QmStatsItems1)/sizeof(UINT);

    CORg(spConsole->UpdateAllViews(pDataObject, i, IPSECMON_UPDATE_STATUS));

COM_PROTECT_ERROR_LABEL;

    return hr;
}

/*---------------------------------------------------------------------------
    Misc functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CIpsecStatsHandler::InitData
        Initializes data for this node
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsecStatsHandler::InitData
(
    ISpdInfo *     pSpdInfo
)
{
	HRESULT hr = hrOK;
    m_spSpdInfo.Set(pSpdInfo);

	CORg(m_spSpdInfo->LoadStatistics());
	
	m_spSpdInfo->GetLoadedStatistics(NULL, &m_IpsecStats);

    return hr;

Error:
	if (FAILED(hr))
	{
		//TODO bring up a error pop up here
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\stats.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
	Stats.h

    FILE HISTORY:
        
*/

#ifndef _IKESTATS_H
#define _IKESTATS_H

#ifndef _IPSMHAND_H
#include "ipsmhand.h"
#endif

#ifndef _SPDDB_H
#include "spddb.h"
#endif


/*---------------------------------------------------------------------------
	Class:	CIkeStatsHandler
 ---------------------------------------------------------------------------*/
class CIkeStatsHandler : public CIpsmHandler
{
public:
    CIkeStatsHandler(ITFSComponentData* pTFSComponentData);
	virtual ~CIkeStatsHandler();

// Interface
public:
	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_GetString()
			{ return (nCol == 0) ? GetDisplayName() : NULL; }

	// Base handler notifications we handle
	OVERRIDE_BaseHandlerNotify_OnExpand();
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();    

	// Result handler functionality we override
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();

    OVERRIDE_ResultHandler_OnGetResultViewType();
	OVERRIDE_ResultHandler_GetVirtualString(); 
	OVERRIDE_ResultHandler_GetVirtualImage();
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_HasPropertyPages();
	OVERRIDE_ResultHandler_CreatePropertyPages();

	STDMETHODIMP CacheHint(int nStartIndex, int nEndIndex);
	/*STDMETHODIMP SortItems(int     nColumn, 
						   DWORD   dwSortOptions,    
						   LPARAM  lUserParam);*/

    // base handler overrides
	virtual HRESULT LoadColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

	// CHandler overridden
    virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);
	
    // multi select support
    virtual const GUID * GetVirtualGuid(int nIndex) 
	{ 
		return &GUID_IpsmMmIkeStatsNodeType; 
	}

public:
	// CMTIpsmHandler functionality
	virtual HRESULT  InitializeNode(ITFSNode * pNode);
	virtual int      GetImageIndex(BOOL bOpenImage);
	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

public:
	// implementation specific	
    HRESULT InitData(ISpdInfo * pSpdInfo);
    HRESULT UpdateStatus(ITFSNode * pNode);

	CIkeStatistics m_IkeStats;
    
// Implementation
private:
	// Command handlers
    HRESULT OnDelete(ITFSNode * pNode);

private:
    SPISpdInfo          m_spSpdInfo;
	//CIkeStatistics m_IkeStats;
	//CIpsecStatistics mIpsecStats;
};

/*---------------------------------------------------------------------------
	Class:	CIpsecStatsHandler
 ---------------------------------------------------------------------------*/
class CIpsecStatsHandler : public CIpsmHandler
{
public:
    CIpsecStatsHandler(ITFSComponentData* pTFSComponentData);
	virtual ~CIpsecStatsHandler();

// Interface
public:
	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_GetString()
			{ return (nCol == 0) ? GetDisplayName() : NULL; }

	// Base handler notifications we handle
	OVERRIDE_BaseHandlerNotify_OnExpand();
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();    

	// Result handler functionality we override
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();

    OVERRIDE_ResultHandler_OnGetResultViewType();
	OVERRIDE_ResultHandler_GetVirtualString(); 
	OVERRIDE_ResultHandler_GetVirtualImage();
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_HasPropertyPages();
	OVERRIDE_ResultHandler_CreatePropertyPages();

	STDMETHODIMP CacheHint(int nStartIndex, int nEndIndex);
	/*STDMETHODIMP SortItems(int     nColumn, 
						   DWORD   dwSortOptions,    
						   LPARAM  lUserParam);*/

    // base handler overrides
	virtual HRESULT LoadColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

	// CHandler overridden
    virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);
	
    // multi select support
    virtual const GUID * GetVirtualGuid(int nIndex) 
	{ 
		return &GUID_IpsmMmIpsecStatsNodeType; 
	}

public:
	// CMTIpsmHandler functionality
	virtual HRESULT  InitializeNode(ITFSNode * pNode);
	virtual int      GetImageIndex(BOOL bOpenImage);
	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

public:
	// implementation specific	
    HRESULT InitData(ISpdInfo * pSpdInfo);
    HRESULT UpdateStatus(ITFSNode * pNode);

	CIpsecStatistics m_IpsecStats;
    
// Implementation
private:
	// Command handlers
    HRESULT OnDelete(ITFSNode * pNode);

private:
    SPISpdInfo          m_spSpdInfo;
	//CIkeStatistics m_IkeStats;
	//CIpsecStatistics mIpsecStats;
};


#endif _IKESTATS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\util.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

#include "stdafx.h"
#include "util.h"


PVOID __fastcall MyVirtualAlloc(ULONG Size)    
{
    return VirtualAlloc( NULL, Size, MEM_COMMIT, PAGE_READWRITE );    
}


VOID __fastcall MyVirtualFree(PVOID Allocation)    
{
    VirtualFree( Allocation, 0, MEM_RELEASE );    
}


HANDLE CreateSubAllocator(IN ULONG InitialCommitSize,  IN ULONG GrowthCommitSize)    
{
    PSUBALLOCATOR SubAllocator;
    ULONG InitialSize;
    ULONG GrowthSize;

    InitialSize = ROUNDUP2( InitialCommitSize, MINIMUM_VM_ALLOCATION );
    GrowthSize  = ROUNDUP2( GrowthCommitSize,  MINIMUM_VM_ALLOCATION );

    SubAllocator = (PSUBALLOCATOR)MyVirtualAlloc( InitialSize );

    //
    //  If can't allocate entire initial size, back off to minimum size.
    //  Very large initial requests sometimes cannot be allocated simply
    //  because there is not enough contiguous address space.
    //

    if ( SubAllocator == NULL ) 
    {
         SubAllocator = (PSUBALLOCATOR)MyVirtualAlloc( GrowthSize );
    }

    if ( SubAllocator == NULL ) 
    {
         SubAllocator = (PSUBALLOCATOR)MyVirtualAlloc( MINIMUM_VM_ALLOCATION );
    }

    if ( SubAllocator != NULL ) 
    {
        SubAllocator->NextAvailable = (PCHAR)SubAllocator + ROUNDUP2( sizeof( SUBALLOCATOR ), SUBALLOCATOR_ALIGNMENT );
        SubAllocator->LastAvailable = (PCHAR)SubAllocator + InitialSize;
        SubAllocator->VirtualList   = (PVOID*)SubAllocator;
        SubAllocator->GrowSize      = GrowthSize;
     }

    return (HANDLE) SubAllocator;    
}


PVOID __fastcall SubAllocate(IN HANDLE hAllocator, IN ULONG  Size)
{
    PSUBALLOCATOR SubAllocator = (PSUBALLOCATOR) hAllocator;
    PCHAR NewVirtual;
    PCHAR Allocation;
    ULONG AllocSize;
    ULONG_PTR Available;
    ULONG GrowSize;

    ASSERT( Size < (ULONG)( ~(( SUBALLOCATOR_ALIGNMENT * 2 ) - 1 )));

    AllocSize = ROUNDUP2( Size, SUBALLOCATOR_ALIGNMENT );
    Available = SubAllocator->LastAvailable - SubAllocator->NextAvailable;

    if ( AllocSize <= Available ) 
    {
        Allocation = SubAllocator->NextAvailable;
        SubAllocator->NextAvailable = Allocation + AllocSize;
        return Allocation;
    }

    //
    //  Insufficient VM, so grow it.  Make sure we grow it enough to satisfy
    //  the allocation request in case the request is larger than the grow
    //  size specified in CreateSubAllocator.
    //


    GrowSize = SubAllocator->GrowSize;

    if ( GrowSize < ( AllocSize + SUBALLOCATOR_ALIGNMENT )) 
    {
        GrowSize = ROUNDUP2(( AllocSize + SUBALLOCATOR_ALIGNMENT ), MINIMUM_VM_ALLOCATION );
    }

    NewVirtual = (PCHAR)MyVirtualAlloc( GrowSize );

    //  If failed to alloc GrowSize VM, and the allocation could be satisfied
    //  with a minimum VM allocation, try allocating minimum VM to satisfy
    //  this request.
    //

    if (( NewVirtual == NULL ) && ( AllocSize <= ( MINIMUM_VM_ALLOCATION - SUBALLOCATOR_ALIGNMENT ))) 
    {
        GrowSize = MINIMUM_VM_ALLOCATION;
        NewVirtual = (PCHAR)MyVirtualAlloc( GrowSize );
    }

    if ( NewVirtual != NULL ) 
    {

        //  Set LastAvailable to end of new VM block.
        SubAllocator->LastAvailable = NewVirtual + GrowSize;

        //  Link new VM into list of VM allocations.

        *(PVOID*)NewVirtual = SubAllocator->VirtualList;
        SubAllocator->VirtualList = (PVOID*)NewVirtual;

        //  Requested allocation comes next.
        Allocation = NewVirtual + SUBALLOCATOR_ALIGNMENT;

        //  Then set the NextAvailable for what's remaining.

        SubAllocator->NextAvailable = Allocation + AllocSize;

        //  And return the allocation.

        return Allocation;        
    }

    //  Could not allocate enough VM to satisfy request.
    return NULL;
}


VOID DestroySubAllocator(IN HANDLE hAllocator)    
{
    PSUBALLOCATOR SubAllocator = (PSUBALLOCATOR) hAllocator;
    PVOID VirtualBlock = SubAllocator->VirtualList;
    PVOID NextVirtualBlock;

    do  
    {
        NextVirtualBlock = *(PVOID*)VirtualBlock;
        MyVirtualFree( VirtualBlock );
        VirtualBlock = NextVirtualBlock;

    }while (VirtualBlock != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\globals.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    globals.h
//
// History:
//  Abolade Gbadegesin  Feb-11-1996 Created.
//
// Contains declarations of global constants.
//============================================================================

#ifndef _IPXSNAP_GLOBALS_H
#define _IPXSNAP_GLOBALS_H




//
// Configuration defaults for router components
//

extern BYTE *			g_pIpxRipInterfaceDefault;
extern BYTE *			g_pIpxRipLanInterfaceDefault;
extern BYTE *			g_pIpxSapInterfaceDefault;
extern BYTE *			g_pIpxSapLanInterfaceDefault;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\globals.cpp ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    strings.cpp
//
// History:
//  Abolade Gbadegesin  Feb-11-1996 Created.
//
// Contains definitions of global constants.
//============================================================================


#include "stdafx.h"
#include "mprapi.h"

extern "C"
{
#include <routprot.h>
#include <ipxrtdef.h>
};

#include "globals.h"


//----------------------------------------------------------------------------
// IPX RIP default interface configuration
// (These values also reside in ipxsnap\globals.cpp).
//
//----------------------------------------------------------------------------
//
// Default values for non-LAN interface RIP configuration
//
RIP_IF_CONFIG
g_ipxripInterfaceDefault = {
	{
		ADMIN_STATE_ENABLED,		// Admin state
		IPX_NO_UPDATE,				// Update Mode - RIP update mechanism
		IPX_STANDARD_PACKET_TYPE,	// Packet type - RIP packet type
		ADMIN_STATE_ENABLED,		// Supply - Send RIP updates
		ADMIN_STATE_ENABLED,		// Listen - Listen to RIP updates
		0,                          // Periodic Update interval - in seconds
		0							// AgeIntervalMultiplier
	},
	{
		IPX_SERVICE_FILTER_DENY,	// Supply filter action
		0,							// Supply filter count
		IPX_SERVICE_FILTER_DENY,	// Listen filter action
		0,							// Listen filter count
	}
};

BYTE* g_pIpxRipInterfaceDefault             = (BYTE*)&g_ipxripInterfaceDefault;



//
// Default values for LAN interface RIP configuration
// (These values also reside in ipxsnap\globals.cpp).
//
RIP_IF_CONFIG
g_ipxripLanInterfaceDefault = {
	{
		ADMIN_STATE_ENABLED,		// Admin state
		IPX_STANDARD_UPDATE,		// Update Mode - RIP update mechanism
		IPX_STANDARD_PACKET_TYPE,	// Packet type - RIP packet type
		ADMIN_STATE_ENABLED,		// Supply - Send RIP updates
		ADMIN_STATE_ENABLED,		// Listen - Listen to RIP updates
		IPX_UPDATE_INTERVAL_DEFVAL,	// Periodic Update interval - in seconds
		3							// AgeIntervalMultiplier
	},
	{
		IPX_SERVICE_FILTER_DENY,	// Supply filter action
		0,							// Supply filter count
		IPX_SERVICE_FILTER_DENY,	// Listen filter action
		0,							// Listen filter count
	}
};

BYTE* g_pIpxRipLanInterfaceDefault	= (BYTE*)&g_ipxripLanInterfaceDefault;



//----------------------------------------------------------------------------
// IPX SAP default interface configuration
// (These values also reside in ipxsnap\globals.cpp).
//
//----------------------------------------------------------------------------
//
// Default values for non-LAN interface SAP configuration
//
SAP_IF_CONFIG
g_ipxsapInterfaceDefault = {
	{
		ADMIN_STATE_ENABLED,		// Admin state
		IPX_NO_UPDATE,				// Update Mode - SAP update mechanism
		IPX_STANDARD_PACKET_TYPE,	// Packet type - SAP packet type
		ADMIN_STATE_ENABLED,		// Supply - Send SAP updates
		ADMIN_STATE_ENABLED,		// Listen - Listen to SAP updates
		ADMIN_STATE_ENABLED,		// Reply to GetNearestServer
		0,							// Periodic Update interval - in seconds
		0							// AgeIntervalMultiplier
	},
	{
		IPX_SERVICE_FILTER_DENY,	// Supply filter action
		0,							// Supply filter count
		IPX_SERVICE_FILTER_DENY,	// Listen filter action
		0,							// Listen filter count
	}
};

BYTE* g_pIpxSapInterfaceDefault             = (BYTE*)&g_ipxsapInterfaceDefault;



//
// Default values for LAN interface SAP configuration
// (These values also reside in ipxsnap\globals.cpp).
//
SAP_IF_CONFIG
g_ipxsapLanInterfaceDefault = {
	{
		ADMIN_STATE_ENABLED,		// Admin state
		IPX_STANDARD_UPDATE,		// Update Mode - SAP update mechanism
		IPX_STANDARD_PACKET_TYPE,	// Packet type - SAP packet type
		ADMIN_STATE_ENABLED,		// Supply - Send SAP updates
		ADMIN_STATE_ENABLED,		// Listen - Listen to SAP updates
		ADMIN_STATE_ENABLED,		// Reply to GetNearestServer
		IPX_UPDATE_INTERVAL_DEFVAL,	// Periodic Update interval - in seconds
		3							// AgeIntervalMultiplier
	},
	{
		IPX_SERVICE_FILTER_DENY,	// Supply filter action
		0,							// Supply filter count
		IPX_SERVICE_FILTER_DENY,	// Listen filter action
		0,							// Listen filter count
	}
};

BYTE* g_pIpxSapLanInterfaceDefault	= (BYTE*)&g_ipxsapLanInterfaceDefault;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipsecmon\stdafx.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2002   **/
/**********************************************************************/

/*
	stdafx.h
		include file for standard system include files,
		or project specific include files that are used frequently,
		but are changed infrequently

	FILE HISTORY:
        
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef ASSERT
#undef ASSERT
#endif

#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxtempl.h>
#include <afxcview.h>
#include <afxext.h>
#include <afxmt.h>

#include <atlbase.h>
#include <htmlhelp.h>
#include <shfusion.h>
#include <winldap.h>
#include <userenv.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//#pragma comment(lib, "mmc")
#include <mmc.h>

extern "C"
{
	#include "winsock.h"     //  WinSock definitions
	#include "lmerr.h"

    // for get user stuff
    #include <wtypes.h>
	#include <Iphlpapi.h>
}


#include "resource.h"

// Global defines for IPSecMon snapin
#include "ipsmsnap.h"

// Files from ..\tfscore
#include <dbgutil.h>
#include <std.h>
#include <errutil.h>
#include <register.h>

// Files from ..\common
#include <ccdata.h>
#include <about.h>
#include <dataobj.h>
#include <proppage.h>
#include <ipaddr.hpp>
#include <dialog.h>
#include <objpick.h>

// project specific
#include "ipsmcomp.h"
#include "ipsmhelp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\images.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       images.h
//
//--------------------------------------------------------------------------

#ifndef _IMAGES_H
#define _IMAGES_H

// Note - These are offsets into my image list
typedef enum _IMAGE_INDICIES
{
	IMAGE_IDX_FOLDER_CLOSED = 0,		// typical closed folder image
	IMAGE_IDX_NA1,						// What?
	IMAGE_IDX_NA2,						// What?
	IMAGE_IDX_NA3,						// What?
	IMAGE_IDX_NA4,						// What?
	IMAGE_IDX_FOLDER_OPEN,				// open folder image
	IMAGE_IDX_MACHINE,					// guess what, it's a machine
	IMAGE_IDX_DOMAIN,					// a domain
	IMAGE_IDX_NOINFO,					// we have no info on this machine
	IMAGE_IDX_MACHINE_WAIT,				// waiting for the machine
	IMAGE_IDX_IPX_NODE_GENERAL,			// general IP node
	IMAGE_IDX_INTERFACES,				// routing interfaces
	IMAGE_IDX_LAN_CARD,					// LAN adapter icon
	IMAGE_IDX_WAN_CARD,					// WAN adapter icon
} IMAGE_INDICIES, *LPIMAGE_INDICIES;


// Include the types of all of our nodes
// This corresponds to the node types but is a DWORD that is used
// by the framework

typedef enum
{
	ROUTER_NODE_MACHINE = 0,
	ROUTER_NODE_DOMAIN,
	ROUTER_NODE_ROOT,
} ROUTER_NODE_DESC;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxadmin.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	IPXAdmin
		Interface node information
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "util.h"
#include "reg.h"			// registry utilities
#include "rtrutil.h"
#include "service.h"		// for TFS service APIs
#include "ipxstrm.h"			// for IPXAdminConfigStream
#include "ipxconn.h"
#include "summary.h"
#include "nbview.h"
#include "srview.h"
#include "ssview.h"
#include "snview.h"
#include "rtrui.h"
#include "sumprop.h"	// IP Summary property page
#include "format.h"		// FormatNumber function

DEBUG_DECLARE_INSTANCE_COUNTER(IPXAdminNodeHandler)


STDMETHODIMP IPXAdminNodeHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IRtrAdviseSink)
		*ppv = &m_IRtrAdviseSink;
	else
		return BaseRouterHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;	
}


/*---------------------------------------------------------------------------
	NodeHandler implementation
 ---------------------------------------------------------------------------*/

IPXAdminNodeHandler::IPXAdminNodeHandler(ITFSComponentData *pCompData)
			: BaseRouterHandler(pCompData),
			m_bExpanded(FALSE),
			m_pConfigStream(NULL),
			m_ulStatsConnId(0),
            m_ulConnId(0)
{ 
	DEBUG_INCREMENT_INSTANCE_COUNTER(IPXAdminNodeHandler) 
	m_rgButtonState[MMC_VERB_PROPERTIES_INDEX] = ENABLED;
	m_bState[MMC_VERB_PROPERTIES_INDEX] = TRUE;
};


/*!--------------------------------------------------------------------------
	IPXAdminNodeHandler::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXAdminNodeHandler::Init(IRouterInfo *pRouterInfo, IPXAdminConfigStream *pConfigStream)
{
	HRESULT	hr = hrOK;
	Assert(pRouterInfo);
	SPIRouterRefresh	spRefresh;
	
	m_spRouterInfo.Set(pRouterInfo);

	CORg( m_spRouterInfo->FindRtrMgr(PID_IPX, &m_spRtrMgrInfo) );

    m_pConfigStream = pConfigStream;

	if (m_spRtrMgrInfo == NULL)
        return E_FAIL;

	m_IpxStats.SetConfigInfo(pConfigStream, IPXSTRM_STATS_IPX);
	m_IpxRoutingStats.SetConfigInfo(pConfigStream, IPXSTRM_STATS_ROUTING);
	m_IpxServiceStats.SetConfigInfo(pConfigStream, IPXSTRM_STATS_SERVICE);
	
	m_IpxRoutingStats.SetRouterInfo(m_spRouterInfo);
	m_IpxServiceStats.SetRouterInfo(m_spRouterInfo);
	
	if (m_spRouterInfo)
		m_spRouterInfo->GetRefreshObject(&spRefresh);

    if (m_ulConnId == 0)
        m_spRtrMgrInfo->RtrAdvise(&m_IRtrAdviseSink, &m_ulConnId, 0);

	if (m_ulStatsConnId == 0)
		spRefresh->AdviseRefresh(&m_IRtrAdviseSink, &m_ulStatsConnId, 0);
Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	IPXAdminNodeHandler::DestroyHandler
		Implementation of ITFSNodeHandler::DestroyHandler
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXAdminNodeHandler::DestroyHandler(ITFSNode *pNode)
{
	IPXConnection *	pIPXConn;

	pIPXConn = GET_IPXADMIN_NODEDATA(pNode);
	pIPXConn->Release();

	if (m_ulConnId)
    {
		m_spRtrMgrInfo->RtrUnadvise(m_ulConnId);
    }
    m_ulConnId = 0;
    
	if (m_ulStatsConnId)
	{
		SPIRouterRefresh	spRefresh;
		if (m_spRouterInfo)
			m_spRouterInfo->GetRefreshObject(&spRefresh);
		if (spRefresh)
			spRefresh->UnadviseRefresh(m_ulStatsConnId);		
	}
	m_ulStatsConnId = 0;
	
	WaitForStatisticsWindow(&m_IpxStats);
	WaitForStatisticsWindow(&m_IpxRoutingStats);
	WaitForStatisticsWindow(&m_IpxServiceStats);

	m_spRtrMgrInfo.Release();
	m_spRouterInfo.Release();
	return hrOK;
}


/*!--------------------------------------------------------------------------
	IPXAdminNodeHandler::OnCommand
		Implementation of ITFSNodeHandler::OnCommand
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXAdminNodeHandler::OnCommand(ITFSNode *pNode, long nCommandId, 
										   DATA_OBJECT_TYPES	type, 
										   LPDATAOBJECT pDataObject, 
										   DWORD	dwType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;

	COM_PROTECT_TRY
	{

		switch (nCommandId)
		{
			case IDS_MENU_SYNC:
				RefreshInterfaces(pNode);
				break;

			case IDS_MENU_IPXSUM_NEW_PROTOCOL:
				hr = OnNewProtocol();
				if (!FHrSucceeded(hr))
					DisplayErrorMessage(NULL, hr);
				break;

			case IDS_MENU_IPXSUM_TASK_IPX_INFO:
				CreateNewStatisticsWindow(&m_IpxStats,
										  ::FindMMCMainWindow(),
										  IDD_STATS_NARROW);
				break;
			case IDS_MENU_IPXSUM_TASK_ROUTING_TABLE:
				CreateNewStatisticsWindow(&m_IpxRoutingStats,
										  ::FindMMCMainWindow(),
										  IDD_STATS_NARROW);
				break;
			case IDS_MENU_IPXSUM_TASK_SERVICE_TABLE:
				CreateNewStatisticsWindow(&m_IpxServiceStats,
										  ::FindMMCMainWindow(),
										  IDD_STATS);
			default:
				break;
			
		}
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	IPXAdminNodeHandler::GetString
		Implementation of ITFSNodeHandler::GetString
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) IPXAdminNodeHandler::GetString(ITFSNode *pNode, int nCol)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		if (m_stTitle.IsEmpty())
			m_stTitle.LoadString(IDS_IPXADMIN_TITLE);
	}
	COM_PROTECT_CATCH;

	return m_stTitle;
}


/*!--------------------------------------------------------------------------
	IPXAdminNodeHandler::OnCreateDataObject
		Implementation of ITFSNodeHandler::OnCreateDataObject
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXAdminNodeHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		
		CORg( CreateDataObjectFromRtrMgrInfo(m_spRtrMgrInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject, &m_dynExtensions) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}

/*!--------------------------------------------------------------------------
	IPXAdminNodeHandler::OnExpand
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXAdminNodeHandler::OnExpand(ITFSNode *pNode,
									  LPDATAOBJECT pDataObject,
									  DWORD dwType,
									  LPARAM arg,
									  LPARAM lParam)
{
	HRESULT					hr = hrOK;
	SPITFSNodeHandler		spHandler;
	SPITFSNode				spNode;
	IPXConnection *			pIPXConn;
	IPXSummaryHandler *		pHandler;
	IpxNBHandler *			pNBHandler;
	IpxSRHandler *			pSRHandler;
	IpxSSHandler *			pSSHandler;
	IpxSNHandler *			pSNHandler;
	
	if (m_bExpanded)
		return hrOK;

	pIPXConn = GET_IPXADMIN_NODEDATA(pNode);


	// Add the General node
	pHandler = new IPXSummaryHandler(m_spTFSCompData);
	CORg( pHandler->Init(m_spRtrMgrInfo, m_pConfigStream) );
	spHandler = pHandler;

	CreateContainerTFSNode(&spNode,
						   &GUID_IPXSummaryNodeType,
						   (ITFSNodeHandler *) pHandler,
						   (ITFSResultHandler *) pHandler,
						   m_spNodeMgr);

	// Call to the node handler to init the node data
	pHandler->ConstructNode(spNode, NULL, pIPXConn);
				
	// Make the node immediately visible
	spNode->SetVisibilityState(TFS_VIS_SHOW);
	pNode->AddChild(spNode);

	spHandler.Release();
	spNode.Release();


	// Add the NetBIOS Broadcasts node
	pNBHandler = new IpxNBHandler(m_spTFSCompData);
	CORg( pNBHandler->Init(m_spRtrMgrInfo, m_pConfigStream) );
	spHandler = pNBHandler;

	CreateContainerTFSNode(&spNode,
						   &GUID_IPXSummaryNodeType,
						   (ITFSNodeHandler *) pNBHandler,
						   (ITFSResultHandler *) pNBHandler,
						   m_spNodeMgr);

	// Call to the node handler to init the node data
	pNBHandler->ConstructNode(spNode, NULL, pIPXConn);
				
	// Make the node immediately visible
	spNode->SetVisibilityState(TFS_VIS_SHOW);
	pNode->AddChild(spNode);

	spHandler.Release();
	spNode.Release();

	// Add the Static Routes node
	pSRHandler = new IpxSRHandler(m_spTFSCompData);
	CORg( pSRHandler->Init(m_spRtrMgrInfo, m_pConfigStream) );
	spHandler = pSRHandler;

	CreateContainerTFSNode(&spNode,
						   &GUID_IPXSummaryNodeType,
						   (ITFSNodeHandler *) pSRHandler,
						   (ITFSResultHandler *) pSRHandler,
						   m_spNodeMgr);

	// Call to the node handler to init the node data
	pSRHandler->ConstructNode(spNode, NULL, pIPXConn);
				
	// Make the node immediately visible
	spNode->SetVisibilityState(TFS_VIS_SHOW);
	pNode->AddChild(spNode);

	spHandler.Release();
	spNode.Release();

	
	// Add the Static Services node
	pSSHandler = new IpxSSHandler(m_spTFSCompData);
	CORg( pSSHandler->Init(m_spRtrMgrInfo, m_pConfigStream) );
	spHandler = pSSHandler;

	CreateContainerTFSNode(&spNode,
						   &GUID_IPXSummaryNodeType,
						   (ITFSNodeHandler *) pSSHandler,
						   (ITFSResultHandler *) pSSHandler,
						   m_spNodeMgr);

	// Call to the node handler to init the node data
	pSSHandler->ConstructNode(spNode, NULL, pIPXConn);
				
	// Make the node immediately visible
	spNode->SetVisibilityState(TFS_VIS_SHOW);
	pNode->AddChild(spNode);

	spHandler.Release();
	spNode.Release();

	
	// Add the Static NetBIOS Names node
	pSNHandler = new IpxSNHandler(m_spTFSCompData);
	CORg( pSNHandler->Init(m_spRtrMgrInfo, m_pConfigStream) );
	spHandler = pSNHandler;

	CreateContainerTFSNode(&spNode,
						   &GUID_IPXSummaryNodeType,
						   (ITFSNodeHandler *) pSNHandler,
						   (ITFSResultHandler *) pSNHandler,
						   m_spNodeMgr);

	// Call to the node handler to init the node data
	pSNHandler->ConstructNode(spNode, NULL, pIPXConn);
				
	// Make the node immediately visible
	spNode->SetVisibilityState(TFS_VIS_SHOW);
	pNode->AddChild(spNode);

	spHandler.Release();
	spNode.Release();
	
	m_bExpanded = TRUE;

    AddDynamicNamespaceExtensions(pNode);

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	IPXAdminNodeHandler::ConstructNode
		Initializes the Domain node (sets it up).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXAdminNodeHandler::ConstructNode(ITFSNode *pNode, BOOL fAddedAsLocal)
{
	HRESULT			hr = hrOK;
	IPXConnection *		pIPXConn = NULL;
	
	if (pNode == NULL)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Need to initialize the data for the Domain node
		pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_INTERFACES);
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_INTERFACES);
		pNode->SetData(TFS_DATA_SCOPEID, 0);

		m_cookie = reinterpret_cast<DWORD_PTR>(pNode);
		pNode->SetData(TFS_DATA_COOKIE, m_cookie);

		pNode->SetNodeType(&GUID_IPXNodeType);


		pIPXConn = new IPXConnection;
		pIPXConn->SetMachineName(m_spRouterInfo->GetMachineName());
        pIPXConn->SetComputerAddedAsLocal(fAddedAsLocal);

		SET_IPXADMIN_NODEDATA(pNode, pIPXConn);
		
		m_IpxStats.SetConnectionData(pIPXConn);
		m_IpxRoutingStats.SetConnectionData(pIPXConn);
		m_IpxServiceStats.SetConnectionData(pIPXConn);
	
        EnumDynamicExtensions(pNode);

	}
	COM_PROTECT_CATCH

	if (!FHrSucceeded(hr))
	{
		SET_IPXADMIN_NODEDATA(pNode, NULL);
		if (pIPXConn)
			pIPXConn->Release();
	}

	return hr;
}

/*!--------------------------------------------------------------------------
	IPXAdminNodeHandler::RefreshInterfaces
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXAdminNodeHandler::RefreshInterfaces(ITFSNode *pThisNode)
{
	return hrOK;
}


ImplementEmbeddedUnknown(IPXAdminNodeHandler, IRtrAdviseSink)

STDMETHODIMP IPXAdminNodeHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
	DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
    InitPThis(IPXAdminNodeHandler, IRtrAdviseSink);
    HRESULT	hr = hrOK;
    
    if (dwChangeType == ROUTER_REFRESH)
    {
        if (ulConn == pThis->m_ulStatsConnId)
        {
            pThis->m_IpxStats.PostRefresh();
            pThis->m_IpxRoutingStats.PostRefresh();
            pThis->m_IpxServiceStats.PostRefresh();
        }
    }
    else if (dwChangeType == ROUTER_DO_DISCONNECT)
    {
        SPITFSNode			spThisNode;
        IPXConnection *		pIPXConn = NULL;
        
        pThis->m_spNodeMgr->FindNode(pThis->m_cookie, &spThisNode);       
        pIPXConn = GET_IPXADMIN_NODEDATA(spThisNode);
        pIPXConn->DisconnectAll();
    }
    return hr;
}

/*!--------------------------------------------------------------------------
	CreateDataObjectFromRouterInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CreateDataObjectFromRouterInfo(IRouterInfo *pInfo,
									   DATA_OBJECT_TYPES type,
									   MMC_COOKIE cookie,
									   ITFSComponentData *pTFSCompData,
									   IDataObject **ppDataObject,
                                       CDynamicExtensions * pDynExt)
{
	Assert(ppDataObject);
	CDataObject	*	pdo = NULL;
	HRESULT			hr = hrOK;

	SPIUnknown	spunk;
	SPIDataObject	spDataObject;

	pdo = new CDataObject;
	spDataObject = pdo;

	CORg( CreateRouterInfoAggregation(pInfo, pdo, &spunk) );
	
	pdo->SetInnerIUnknown(spunk);
		
	// Save cookie and type for delayed rendering
	pdo->SetType(type);
	pdo->SetCookie(cookie);
	
	// Store the coclass with the data object
	pdo->SetClsid(*(pTFSCompData->GetCoClassID()));
			
	pdo->SetTFSComponentData(pTFSCompData);
						
    pdo->SetDynExt(pDynExt);

    *ppDataObject = spDataObject.Transfer();

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	CreateDataObjectFromRtrMgrInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CreateDataObjectFromRtrMgrInfo(IRtrMgrInfo *pInfo,
									   DATA_OBJECT_TYPES type,
									   MMC_COOKIE cookie,
									   ITFSComponentData *pTFSCompData,
									   IDataObject **ppDataObject,
                                       CDynamicExtensions * pDynExt)
{
	Assert(ppDataObject);
	CDataObject	*	pdo = NULL;
	HRESULT			hr = hrOK;

	SPIUnknown	spunk;
	SPIDataObject	spDataObject;

	pdo = new CDataObject;
	spDataObject = pdo;

	CORg( CreateRtrMgrInfoAggregation(pInfo, pdo, &spunk) );
	
	pdo->SetInnerIUnknown(spunk);
		
	// Save cookie and type for delayed rendering
	pdo->SetType(type);
	pdo->SetCookie(cookie);
	
	// Store the coclass with the data object
	pdo->SetClsid(*(pTFSCompData->GetCoClassID()));
			
	pdo->SetTFSComponentData(pTFSCompData);

    pdo->SetDynExt(pDynExt);

	*ppDataObject = spDataObject.Transfer();

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	CreateDataObjectFromRtrMgrProtocolInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CreateDataObjectFromRtrMgrProtocolInfo(IRtrMgrProtocolInfo *pInfo,
									   DATA_OBJECT_TYPES type,
									   MMC_COOKIE cookie,
									   ITFSComponentData *pTFSCompData,
									   IDataObject **ppDataObject)
{
	Assert(ppDataObject);
	CDataObject	*	pdo = NULL;
	HRESULT			hr = hrOK;

	SPIUnknown	spunk;
	SPIDataObject	spDataObject;

	pdo = new CDataObject;
	spDataObject = pdo;

	CORg( CreateRtrMgrProtocolInfoAggregation(pInfo, pdo, &spunk) );
	
	pdo->SetInnerIUnknown(spunk);
		
	// Save cookie and type for delayed rendering
	pdo->SetType(type);
	pdo->SetCookie(cookie);
	
	// Store the coclass with the data object
	pdo->SetClsid(*(pTFSCompData->GetCoClassID()));
			
	pdo->SetTFSComponentData(pTFSCompData);
						
	*ppDataObject = spDataObject.Transfer();

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	CreateDataObjectFromInterfaceInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CreateDataObjectFromInterfaceInfo(IInterfaceInfo *pInfo,
									   DATA_OBJECT_TYPES type,
									   MMC_COOKIE cookie,
									   ITFSComponentData *pTFSCompData,
									   IDataObject **ppDataObject)
{
	Assert(ppDataObject);
	CDataObject	*	pdo = NULL;
	HRESULT			hr = hrOK;

	SPIUnknown	spunk;
	SPIDataObject	spDataObject;

	pdo = new CDataObject;
	spDataObject = pdo;

	CORg( CreateInterfaceInfoAggregation(pInfo, pdo, &spunk) );
	
	pdo->SetInnerIUnknown(spunk);
		
	// Save cookie and type for delayed rendering
	pdo->SetType(type);
	pdo->SetCookie(cookie);
	
	// Store the coclass with the data object
	pdo->SetClsid(*(pTFSCompData->GetCoClassID()));
			
	pdo->SetTFSComponentData(pTFSCompData);
						
	*ppDataObject = spDataObject.Transfer();

Error:
	return hr;
}

static const SRouterNodeMenu s_rgIfGeneralMenu[] =
{
	{ IDS_MENU_IPXSUM_NEW_PROTOCOL, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },
        
	{ IDS_MENU_SEPARATOR, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },

	{ IDS_MENU_IPXSUM_TASK_IPX_INFO, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },		
		
	{ IDS_MENU_IPXSUM_TASK_ROUTING_TABLE, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },		
		
	{ IDS_MENU_IPXSUM_TASK_SERVICE_TABLE, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },		
		
	{ IDS_MENU_SEPARATOR, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP }
};
/*!--------------------------------------------------------------------------
	IPXRootHandler::OnAddMenuItems
		Implementation of ITFSNodeHandler::OnAddMenuItems
	Author: DeonB
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXAdminNodeHandler::OnAddMenuItems(
	ITFSNode *pNode,
	LPCONTEXTMENUCALLBACK pContextMenuCallback, 
	LPDATAOBJECT lpDataObject, 
	DATA_OBJECT_TYPES type, 
	DWORD dwType,
	long *pInsertionAllowed)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = S_OK;
    IPXAdminNodeHandler::SMenuData    menuData;
	
	COM_PROTECT_TRY
	{
        menuData.m_spNode.Set(pNode);
        
		hr = AddArrayOfMenuItems(pNode, s_rgIfGeneralMenu,
								 DimensionOf(s_rgIfGeneralMenu),
								 pContextMenuCallback,
								 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
	}
	COM_PROTECT_CATCH;
		
	return hr; 
}


/*!--------------------------------------------------------------------------
	IPXSummaryHandler::OnNewProtocol
      This function will install new protocols.  It will look for
      conflicts with existing protocols (and ask the user if they
      would like to remove the existing protocol).

      We will have to figure out how to get the protocol UI installed
      (this implies that we have to know if the protocol UI is
      installed or not).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXAdminNodeHandler::OnNewProtocol()
{
   HRESULT     hr = hrOK;
   SPIRtrMgrProtocolInfo   spRmProt;

   // Display the protocol prompt
   if (AddProtocolPrompt(m_spRouterInfo, m_spRtrMgrInfo, &spRmProt, NULL)
      != IDOK)
   {
      // The most likely case for this is that the user cancelled
      // out of the dialog, just return hrOK
      return hrOK;
   }

   // At this point, we now have a protocol that can be added (we
   // will also have removed any conflicting protocols, although
   // another user may have added a protocol already).

   // Add the new protocol
   CORg( AddRoutingProtocol(m_spRtrMgrInfo, spRmProt, ::FindMMCMainWindow()) );

   // Ok, at this point we have successfully added the protocol
   // to the router.  Now we need to make sure that we can add
   // the correct admin UI.

   // Have MMC dynamically add the protocol (if necessary)

   ForceGlobalRefresh(m_spRouterInfo);

Error:
   return hr;
}


/*!--------------------------------------------------------------------------
	IPXAdminNodeHandler::HasPropertyPages
		Implementation of ITFSNodeHandler::HasPropertyPages
	NOTE: the root node handler has to over-ride this function to 
	handle the snapin manager property page (wizard) case!!!
	
	Author: DeonB
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
IPXAdminNodeHandler::HasPropertyPages
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IPXAdminNodeHandler::CreatePropertyPages
		-
	Author: DeonB
 ---------------------------------------------------------------------------*/
STDMETHODIMP
IPXAdminNodeHandler::CreatePropertyPages
(
	ITFSNode *				pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject, 
	LONG_PTR				handle, 
	DWORD					dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT		hr = hrOK;
	IPXSummaryProperties *	pProperties = NULL;
	SPIComponentData spComponentData;
	CString		stTitle;

	CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

	stTitle.Format(IDS_IPXSUMMARY_PAGE_TITLE);
	
	pProperties = new IPXSummaryProperties(pNode, spComponentData,
		m_spTFSCompData, stTitle);

	CORg( pProperties->Init(m_spRtrMgrInfo) );

	if (lpProvider)
		hr = pProperties->CreateModelessSheet(lpProvider, handle);
	else
		hr = pProperties->DoModelessSheet();

Error:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxadmin.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ipxadmin.h
		Interface administration
		
    FILE HISTORY:
        
*/

#ifndef _IPXADMIN_H
#define _IPXADMIN_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _RTRUTIL_H
#include "rtrutil.h"
#endif

#ifndef _BASERTR_H
#include "basertr.h"
#endif

#ifndef _IPXSTATS_H
#include "ipxstats.h"		// IPX statistics dialogs
#endif


#define MPR_INTERFACE_NOT_LOADED		0x00010000

// forward declarations
class IPXAdminConfigStream;
interface IRouterInfo;
struct ColumnData;


/*---------------------------------------------------------------------------
	We store a pointer to the IPXConnection object in our node data
 ---------------------------------------------------------------------------*/

#define GET_IPXADMIN_NODEDATA(pNode) \
		(IPXConnection *) pNode->GetData(TFS_DATA_USER)
#define SET_IPXADMIN_NODEDATA(pNode, pData) \
		pNode->SetData(TFS_DATA_USER, (LONG_PTR) pData)


/*---------------------------------------------------------------------------
	Class:	IPXAdminNodeHandler

 ---------------------------------------------------------------------------*/
class IPXAdminNodeHandler :
   public BaseRouterHandler
{
public:
	IPXAdminNodeHandler(ITFSComponentData *pCompData);
	~IPXAdminNodeHandler()
			{ DEBUG_DECREMENT_INSTANCE_COUNTER(IPXAdminNodeHandler) };
	
	HRESULT	Init(IRouterInfo *pInfo, IPXAdminConfigStream *pConfigStream);

	// Override QI to handle embedded interface
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);

	DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)

	// base handler functionality we override
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_GetString();
	OVERRIDE_NodeHandler_OnCreateDataObject();
	OVERRIDE_NodeHandler_DestroyHandler();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	
	OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_HasPropertyPages();

	// override handler notifications
	OVERRIDE_BaseHandlerNotify_OnExpand();

	// Initializes the node
	HRESULT ConstructNode(ITFSNode *pNode, BOOL fAddedAsLocal);

	// User-initiated commands

	// Refresh the data for these nodes
	HRESULT	RefreshInterfaces(ITFSNode *pThisNode);

	
public:
	// Structure used to pass data to callbacks - used as a way of
	// avoiding recomputation
	struct SMenuData
	{
		SPITFSNode			m_spNode;
	};
	
protected:
	SPIRtrMgrInfo	m_spRtrMgrInfo;
	CString			m_stTitle;		// holds the title of the node
	BOOL			m_bExpanded;	// is the node expanded?
	MMC_COOKIE		m_cookie;		// cookie for the node

	LONG_PTR		m_ulStatsConnId;	// notification id for stats refresh
	LONG_PTR		m_ulConnId;	// notification id 
	
	IPXAdminConfigStream *	m_pConfigStream;

	IpxInfoStatistics		m_IpxStats;
	IpxRoutingStatistics	m_IpxRoutingStats;
	IpxServiceStatistics	m_IpxServiceStats;

	HRESULT OnNewProtocol();
};

HRESULT CreateDataObjectFromRouterInfo(IRouterInfo *pInfo,
									   DATA_OBJECT_TYPES type,
									   MMC_COOKIE cookie,
									   ITFSComponentData *pTFSCompData,
									   IDataObject **ppDataObject,
                                       CDynamicExtensions * pDynExt = NULL);
HRESULT CreateDataObjectFromRtrMgrInfo(IRtrMgrInfo *pInfo,
									   DATA_OBJECT_TYPES type,
									   MMC_COOKIE cookie,
									   ITFSComponentData *pTFSCompData,
									   IDataObject **ppDataObject,
                                       CDynamicExtensions * pDynExt = NULL);
HRESULT CreateDataObjectFromRtrMgrProtocolInfo(IRtrMgrProtocolInfo *pInfo,
									   DATA_OBJECT_TYPES type,
									   MMC_COOKIE cookie,
									   ITFSComponentData *pTFSCompData,
									   IDataObject **ppDataObject);
HRESULT CreateDataObjectFromInterfaceInfo(IInterfaceInfo *pInfo,
									   DATA_OBJECT_TYPES type,
									   MMC_COOKIE cookie,
									   ITFSComponentData *pTFSCompData,
									   IDataObject **ppDataObject);


#endif _IPXADMIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxcomp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	csmplsnp.cpp
		This file contains the derived classes for CComponent and 
		CComponentData.  Most of these functions are pure virtual 
		functions that need to be overridden for snapin functionality.
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ipxcomp.h"
#include "ipxroot.h"
#include <atlimpl.cpp>
#include "ipxstrm.h"
#include "summary.h"
#include "nbview.h"
#include "srview.h"
#include "ssview.h"
#include "snview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/*---------------------------------------------------------------------------
	CIPXComponent
 ---------------------------------------------------------------------------*/



/////////////////////////////////////////////////////////////////////////////
// CIPXComponent implementation

CIPXComponent::CIPXComponent()
{
	extern const ContainerColumnInfo	s_rgIfViewColumnInfo[];
	extern const ContainerColumnInfo	s_rgNBViewColumnInfo[];
	extern const ContainerColumnInfo	s_rgSRViewColumnInfo[];
	extern const ContainerColumnInfo	s_rgSSViewColumnInfo[];
	extern const ContainerColumnInfo	s_rgSNViewColumnInfo[];

	m_ComponentConfig.Init(COLUMNS_MAX_COUNT);
	
	m_ComponentConfig.InitViewInfo(COLUMNS_SUMMARY,
                                   FALSE /*fConfigurableColumns*/,
								   IPXSUM_MAX_COLUMNS,
								   TRUE,
								   s_rgIfViewColumnInfo);
	m_ComponentConfig.InitViewInfo(COLUMNS_NBBROADCASTS,
                                   FALSE /*fConfigurableColumns*/,
								   IPXNB_MAX_COLUMNS,
								   TRUE,
								   s_rgNBViewColumnInfo);
	m_ComponentConfig.InitViewInfo(COLUMNS_STATICROUTES,
                                   FALSE /*fConfigurableColumns*/,
								   IPX_SR_MAX_COLUMNS,
								   TRUE,
								   s_rgSRViewColumnInfo);
	m_ComponentConfig.InitViewInfo(COLUMNS_STATICSERVICES,
                                   FALSE /*fConfigurableColumns*/,
								   IPX_SS_MAX_COLUMNS,
								   TRUE,
								   s_rgSSViewColumnInfo);
	m_ComponentConfig.InitViewInfo(COLUMNS_STATICNETBIOSNAMES,
                                   FALSE /*fConfigurableColumns*/,
								   IPX_SN_MAX_COLUMNS,
								   TRUE,
								   s_rgSNViewColumnInfo);
	
	m_ulUserData = reinterpret_cast<LONG_PTR>(&m_ComponentConfig);
}

CIPXComponent::~CIPXComponent()
{
}

STDMETHODIMP_(ULONG) CIPXComponent::AddRef()
{
	return TFSComponent::AddRef();
}

STDMETHODIMP_(ULONG) CIPXComponent::Release()
{
	return TFSComponent::Release();
}

STDMETHODIMP CIPXComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

	if (riid == IID_IPersistStreamInit)
		*ppv = static_cast<IPersistStreamInit *>(this);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
    }
    else
		return TFSComponent::QueryInterface(riid, ppv);
}

STDMETHODIMP CIPXComponent::OnUpdateView(LPDATAOBJECT pDataObject,
										 LPARAM arg, LPARAM param)
{
	
	return TFSComponent::OnUpdateView(pDataObject, arg, param);
}

STDMETHODIMP CIPXComponent::InitializeBitmaps(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(m_spImageList != NULL);

    CBitmap bmp16x16;
    CBitmap bmp32x32;
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		// Load the bitmaps from the dll
		bmp16x16.LoadBitmap(IDB_16x16);
		bmp32x32.LoadBitmap(IDB_32x32);

		// Set the images
		m_spImageList->ImageListSetStrip(
					reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
					reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp32x32)),
                    0, RGB(255,0,255));
	}
	COM_PROTECT_CATCH;

    return hr;
}

/*!--------------------------------------------------------------------------
	CIPXComponent::OnSnapinHelp
		-
	Author: MikeG (a-migall)
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIPXComponent::OnSnapinHelp(
	LPDATAOBJECT	pDataObject,
	LPARAM			arg, 
	LPARAM			param)
{
	UNREFERENCED_PARAMETER(pDataObject);
	UNREFERENCED_PARAMETER(arg);
	UNREFERENCED_PARAMETER(param);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HtmlHelpA(NULL,						// caller
			  c_sazIPXSnapHelpFile,	// help file
			  HH_DISPLAY_TOPIC,			// command
			  0);						// data

	return hrOK;
}

STDMETHODIMP CIPXComponent::QueryDataObject(MMC_COOKIE cookie,
											   DATA_OBJECT_TYPES type,
											   LPDATAOBJECT *ppDataObject)
{
	HRESULT		hr = hrOK;
	SPITFSNode	spNode;
	SPITFSResultHandler	spResultHandler;

	COM_PROTECT_TRY
	{
		CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

		CORg( spNode->GetResultHandler(&spResultHandler) );

		CORg( spResultHandler->OnCreateDataObject(this, cookie,
			type, ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}


STDMETHODIMP CIPXComponent::GetClassID(LPCLSID lpClassID)
{
    ASSERT(lpClassID != NULL);

    // Copy the CLSID for this snapin
    *lpClassID = CLSID_IPXAdminExtension;

    return hrOK;
}
STDMETHODIMP CIPXComponent::IsDirty()
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{		
		hr = m_ComponentConfig.GetDirty() ? hrOK : hrFalse;
	}
	COM_PROTECT_CATCH;
	return hr;
}
STDMETHODIMP CIPXComponent::Load(LPSTREAM pStm)
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{		
	hr = m_ComponentConfig.LoadFrom(pStm);
	}
	COM_PROTECT_CATCH;
	return hr;
}
STDMETHODIMP CIPXComponent::Save(LPSTREAM pStm, BOOL fClearDirty)
{
	HRESULT	hr = hrOK;
	SPITFSResultHandler	spResultHandler;
	COM_PROTECT_TRY
	{
		// Need to see if we can save the selected node
		// -------------------------------------------------------------
		if (m_spSelectedNode)
		{
			m_spSelectedNode->GetResultHandler(&spResultHandler);
			if (spResultHandler)
				spResultHandler->UserResultNotify(m_spSelectedNode,
					RRAS_ON_SAVE, (LPARAM)(ITFSComponent *) this);
		}
		hr = m_ComponentConfig.SaveTo(pStm);
		if (FHrSucceeded(hr) && fClearDirty)
			m_ComponentConfig.SetDirty(FALSE);
	}
	COM_PROTECT_CATCH;
	return hr;
}
STDMETHODIMP CIPXComponent::GetSizeMax(ULARGE_INTEGER FAR *pcbSize)
{
	Assert(pcbSize);
	HRESULT	hr = hrOK;
	ULONG	cbSize = 0;

	COM_PROTECT_TRY
	{
		hr = m_ComponentConfig.GetSize(&cbSize);
		if (FHrSucceeded(hr))
		{
			pcbSize->HighPart = 0;
			pcbSize->LowPart = cbSize;
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}
STDMETHODIMP CIPXComponent::InitNew()
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{		
		hr = m_ComponentConfig.InitNew();
	}
	COM_PROTECT_CATCH;
	return hr;
}






/////////////////////////////////////////////////////////////////////////////
// CIPXComponentData implementation

CIPXComponentData::CIPXComponentData()
{
}

/*!--------------------------------------------------------------------------
	CIPXComponentData::OnInitialize
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CIPXComponentData::OnInitialize(LPIMAGELIST pScopeImage)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	Assert(pScopeImage);

    // add the images for the scope tree
    CBitmap bmp16x16;
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		// Load the bitmaps from the dll
		bmp16x16.LoadBitmap(IDB_16x16);

		// Set the images
		pScopeImage->ImageListSetStrip(
					reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
					reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
					0,
					RGB(255,0,255));
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	CIPXComponentData::OnInitializeNodeMgr
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CIPXComponentData::OnInitializeNodeMgr(ITFSComponentData *pTFSCompData, ITFSNodeMgr *pNodeMgr)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// For now create a new node handler for each new node,
	// this is rather bogus as it can get expensive.  We can
	// consider creating only a single node handler for each
	// node type.
	IPXRootHandler *	pHandler = NULL;
	SPITFSNodeHandler	spHandler;
	SPITFSNode			spNode;
	HRESULT				hr = hrOK;

	COM_PROTECT_TRY
	{
		pHandler = new IPXRootHandler(pTFSCompData);

		// Do this so that it will get released correctly
		spHandler = pHandler;
		pHandler->Init();
	
		// Create the root node for this sick puppy
		CORg( CreateContainerTFSNode(&spNode,
									 &GUID_IPXRootNodeType,
									 pHandler,
									 pHandler /* result handler */,
									 pNodeMgr) );

		// Construct the node
		CORg( pHandler->ConstructNode(spNode) );

		CORg( pNodeMgr->SetRootNode(spNode) );
		
		// Reference the help file name.
		pTFSCompData->SetHTMLHelpFileName(c_szIPXSnapHelpFile);

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	CIPXComponentData::OnCreateComponent
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CIPXComponentData::OnCreateComponent(LPCOMPONENT *ppComponent)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(ppComponent != NULL);
	
	HRESULT		hr = hrOK;
	CIPXComponent *	pComp = NULL;

	COM_PROTECT_TRY
	{
		pComp = new CIPXComponent;

		if (FHrSucceeded(hr))
		{
			pComp->Construct(m_spNodeMgr,
							 static_cast<IComponentData *>(this),
							 m_spTFSComponentData);
			*ppComponent = static_cast<IComponent *>(pComp);
		}
	}
	COM_PROTECT_CATCH;
	
	return hr;
}


STDMETHODIMP CIPXComponentData::OnDestroy()
{
	m_spNodeMgr.Release();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	CIPXComponentData::GetCoClassID
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(const CLSID *) CIPXComponentData::GetCoClassID()
{
	return &CLSID_IPXAdminExtension;
}

/*!--------------------------------------------------------------------------
	CIPXComponentData::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CIPXComponentData::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

	CDataObject *	pObject = NULL;
	SPIDataObject	spDataObject;
	HRESULT			hr = hrOK;
	SPITFSNode		spNode;
	SPITFSNodeHandler	spHandler;

	COM_PROTECT_TRY
	{
		CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

		CORg( spNode->GetHandler(&spHandler) );

		CORg( spHandler->OnCreateDataObject(cookie, type, &spDataObject) );

		*ppDataObject = spDataObject.Transfer();
		
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	return hr;
}


///////////////////////////////////////////////////////////////////////////////
//// IPXersistStream interface members

STDMETHODIMP CIPXComponentData::GetClassID
(
	CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_IPXAdminExtension;

    return hrOK;
}

STDMETHODIMP CIPXComponentData::IsDirty()
{
	SPITFSNode	spNode;
	SPITFSNodeHandler	spHandler;
	SPIPersistStreamInit	spStm;
	
	m_spNodeMgr->GetRootNode(&spNode);
	spNode->GetHandler(&spHandler);
	spStm.Query(spHandler);
	Assert(spStm);
	
	return (spNode->GetData(TFS_DATA_DIRTY) || spStm->IsDirty()) ? hrOK : hrFalse;
}

STDMETHODIMP CIPXComponentData::Load
(
	IStream *pStm
)
{
	SPITFSNode	spNode;
	SPITFSNodeHandler	spHandler;
	SPIPersistStreamInit	spStm;
	
	m_spNodeMgr->GetRootNode(&spNode);
	spNode->GetHandler(&spHandler);
	spStm.Query(spHandler);
	
	Assert(spStm);
	return spStm->Load(pStm);
}


STDMETHODIMP CIPXComponentData::Save
(
	IStream *pStm, 
	BOOL	 fClearDirty
)
{
	SPITFSNode	spNode;
	SPITFSNodeHandler	spHandler;
	SPIPersistStreamInit	spStm;
	
	m_spNodeMgr->GetRootNode(&spNode);
	spNode->GetHandler(&spHandler);
	spStm.Query(spHandler);
	
	Assert(spStm);
	return spStm->Save(pStm, fClearDirty);
}


STDMETHODIMP CIPXComponentData::GetSizeMax
(
	ULARGE_INTEGER *pcbSize
)
{
	SPITFSNode	spNode;
	SPITFSNodeHandler	spHandler;
	SPIPersistStreamInit	spStm;
	
	m_spNodeMgr->GetRootNode(&spNode);
	spNode->GetHandler(&spHandler);
	spStm.Query(spHandler);
	
	Assert(spStm);
	return spStm->GetSizeMax(pcbSize);
}

STDMETHODIMP CIPXComponentData::InitNew()
{
	SPITFSNode	spNode;
	SPITFSNodeHandler	spHandler;
	SPIPersistStreamInit	spStm;
	
	m_spNodeMgr->GetRootNode(&spNode);
	spNode->GetHandler(&spHandler);
	spStm.Query(spHandler);
	
	Assert(spStm);
	return spStm->InitNew();
}



HRESULT CIPXComponentData::FinalConstruct()
{
	HRESULT				hr = hrOK;
	
	hr = CComponentData::FinalConstruct();
	
	if (FHrSucceeded(hr))
	{
		m_spTFSComponentData->GetNodeMgr(&m_spNodeMgr);
	}
	return hr;
}

void CIPXComponentData::FinalRelease()
{
	CComponentData::FinalRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxconn.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ipxconn.cpp
		Commone server handle bookkeeping class.
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "util.h"
#include "rtrutil.h"

#include "ipxconn.h"


DEBUG_DECLARE_INSTANCE_COUNTER(IPXConnection)

IPXConnection::IPXConnection()
	: m_cRefCount(1)
{
	DEBUG_INCREMENT_INSTANCE_COUNTER(IPXConnection);
}

IPXConnection::~IPXConnection()
{
	DEBUG_DECREMENT_INSTANCE_COUNTER(IPXConnection);
}

ULONG IPXConnection::AddRef()
{
	return InterlockedIncrement(&m_cRefCount);
}

ULONG IPXConnection::Release()
{
	if (0 == InterlockedDecrement(&m_cRefCount))
	{
		delete this;
		return 0;
	}
	return m_cRefCount;
}

void IPXConnection::SetMachineName(LPCTSTR pszMachineName)
{
	m_stServerName = pszMachineName;
}

LPCTSTR IPXConnection::GetMachineName()
{
    return (LPCTSTR) m_stServerName;
}

HRESULT IPXConnection::ConnectToMprServer()
{
	Assert(!m_sphMpr);
	DWORD	dwErr;

	dwErr = ::MprAdminServerConnect((LPWSTR) (LPCTSTR)m_stServerName,
									&m_sphMpr);
	return HRESULT_FROM_WIN32(dwErr);
}

HRESULT IPXConnection::ConnectToMibServer()
{
	Assert(!m_sphMib);
	DWORD dwErr;

	dwErr = ::MprAdminMIBServerConnect((LPWSTR) (LPCTSTR) m_stServerName,
									   &m_sphMib);
	return HRESULT_FROM_WIN32(dwErr);
}

HRESULT IPXConnection::ConnectToConfigServer()
{
	Assert(!m_sphConfig);
	DWORD	dwErr;

	dwErr = ::MprConfigServerConnect((LPWSTR)(LPCTSTR)m_stServerName,
									  &m_sphConfig);
	return HRESULT_FROM_WIN32(dwErr);
}


void IPXConnection::DisconnectAll()
{
	DisconnectFromMibServer();
	DisconnectFromMprServer();
	DisconnectFromConfigServer();
}


BOOL IPXConnection::IsComputerAddedAsLocal()
{
    return m_fComputerAddedAsLocal;
}

void IPXConnection::SetComputerAddedAsLocal(BOOL fAddedAsLocal)
{
    m_fComputerAddedAsLocal = fAddedAsLocal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxconn.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ipxconn.h
		Per-instance node data.  This will hold the RPC handles in
		a central place.
		
    FILE HISTORY:
        
*/

#ifndef _IPXCONN_H
#define _IPXCONN_H

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _RTRUTIL_H
#include "rtrutil.h"
#endif

#include "mprapi.h"

class IPXConnection
{
public:
	IPXConnection();
	~IPXConnection();
	
	ULONG	AddRef();
	ULONG	Release();

	void	SetMachineName(LPCTSTR pszMachineName);
    LPCTSTR GetMachineName();

	HRESULT	ConnectToMibServer();
	void	DisconnectFromMibServer();
	
	HRESULT	ConnectToMprServer();
	void	DisconnectFromMprServer();
	
	HRESULT	ConnectToConfigServer();
	void	DisconnectFromConfigServer();

	void	DisconnectAll();


    BOOL    IsComputerAddedAsLocal();
    void    SetComputerAddedAsLocal(BOOL fAddedAsLocal);
	

	MPR_SERVER_HANDLE	GetMprHandle();
	MIB_SERVER_HANDLE	GetMibHandle();
	MPR_CONFIG_HANDLE	GetConfigHandle();

private:
	long				m_cRefCount;
	SPMprServerHandle	m_sphMpr;
	SPMibServerHandle	m_sphMib;
	SPMprConfigHandle	m_sphConfig;
	CString				m_stServerName;

    BOOL                m_fComputerAddedAsLocal;
};

inline void IPXConnection::DisconnectFromMprServer()
{
	m_sphMpr.Release();
}

inline void IPXConnection::DisconnectFromMibServer()
{
	m_sphMib.Release();
}

inline void IPXConnection::DisconnectFromConfigServer()
{
	m_sphConfig.Release();
}

inline MPR_SERVER_HANDLE IPXConnection::GetMprHandle()
{
	if (!m_sphMpr)
		ConnectToMprServer();
	return m_sphMpr;
}

inline MIB_SERVER_HANDLE IPXConnection::GetMibHandle()
{
	if (!m_sphMib)
		ConnectToMibServer();
	return m_sphMib;
}

inline MPR_CONFIG_HANDLE IPXConnection::GetConfigHandle()
{
	if (!m_sphConfig)
		ConnectToConfigServer();
	return m_sphConfig;
}


#endif _IPXCONN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxcomp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ipxcomp.h
		This file contains the prototypes for the derived classes 
		for CComponent and CComponentData.  Most of these functions 
		are pure virtual functions that need to be overridden 
		for snapin functionality.
		
    FILE HISTORY:
        
*/

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

#ifndef _CCDATA_H
#include "ccdata.h"
#endif

#ifndef _COMPONT_H
#include "compont.h"
#endif

#ifndef _COLUMN_H
#include "column.h"
#endif

#ifndef _IPXSTRM_H
#include "ipxstrm.h"
#endif


/*---------------------------------------------------------------------------
	CIPXComponentData

	This is the base implementation of ComponentData.  This will be
	incorporated into the two derived classes.
 ---------------------------------------------------------------------------*/

class CIPXComponentData :
	public CComponentData,
	public CComObjectRoot
{
public:
	
BEGIN_COM_MAP(CIPXComponentData)
	COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()
			
	// These are the interfaces that we MUST implement

	// We will implement our common behavior here, with the derived
	// classes implementing the specific behavior.
	DeclareIPersistStreamInitMembers(IMPL)
	DeclareITFSCompDataCallbackMembers(IMPL)

	CIPXComponentData();

	HRESULT FinalConstruct();
	void FinalRelease();
	
protected:
	SPITFSNodeMgr	m_spNodeMgr;
};



/*---------------------------------------------------------------------------
	This is how the router snapin implements its extension functionality.
	It actually exposes two interfaces that are CoCreate-able.  One is the 
	primary interface, the other the extension interface.
	
	Author: EricDav
 ---------------------------------------------------------------------------*/

class CIPXComponentDataExtension : 
	public CIPXComponentData,
    public CComCoClass<CIPXComponentDataExtension, &CLSID_IPXAdminExtension>
{
public:
	DECLARE_REGISTRY(CIPXComponentDataExtension, 
				 _T("IPXRouterSnapinExtension.IPXRouterSnapinExtension.1"), 
				 _T("IPXRouterSnapinExtension.IPXRouterSnapinExtension"), 
				 IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
    STDMETHOD_(const CLSID *, GetCoClassID)(){ return &CLSID_IPXAdminExtension; }
};



/////////////////////////////////////////////////////////////////////////////
//
// CSampleComponent
//
/////////////////////////////////////////////////////////////////////////////

class CIPXComponent : 
	public TFSComponent,
	public IPersistStreamInit
{
public:
	CIPXComponent();
	~CIPXComponent();

	DeclareIUnknownMembers(IMPL)
	DeclareIPersistStreamInitMembers(IMPL)
	DeclareITFSCompCallbackMembers(IMPL)

	// Override OnQueryDataObject, so that we can forward
	// the calls down to the Result Handlers
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject);

    STDMETHOD(OnSnapinHelp)(LPDATAOBJECT, LPARAM, LPARAM);
	
//Attributes
private:
	IPXComponentConfigStream	m_ComponentConfig;
};



/*---------------------------------------------------------------------------
	This is the derived class for handling the IAbout interface from MMC
	Author: EricDav
 ---------------------------------------------------------------------------*/
class CIPXAbout : 
	public CAbout,
    public CComCoClass<CIPXAbout, &CLSID_IPXAdminAbout>
{
public:
DECLARE_REGISTRY(CIPXAbout, 
				 _T("RouterSnapin.About.1"), 
				 _T("RouterSnapin.About"), 
				 IDS_SNAPIN_DESC, 
				 THREADFLAGS_BOTH)

BEGIN_COM_MAP(CIPXAbout)
    COM_INTERFACE_ENTRY(ISnapinAbout) // Must have one static entry
	COM_INTERFACE_ENTRY_CHAIN(CAbout) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CIPXAbout)

// these must be overridden to provide values to the base class
protected:
	virtual UINT GetAboutDescriptionId() { return IDS_ABOUT_DESCRIPTION; }
	virtual UINT GetAboutProviderId()	 { return IDS_ABOUT_PROVIDER; }
	virtual UINT GetAboutVersionId()	 { return IDS_ABOUT_VERSION; }
	virtual UINT GetAboutIconId()		 { return IDI_IPX_SNAPIN_ICON; }

	virtual UINT GetSmallRootId()		 { return 0; }
	virtual UINT GetSmallOpenRootId()	 { return 0; }
	virtual UINT GetLargeRootId()		 { return 0; }
	virtual COLORREF GetLargeColorMask() { return (COLORREF) 0; } 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxguid.c ===
/*----------------------------------------------------------------------------
	ipxguid.c
		Initialize router IPX node GUIDs.

	Copyright (C) Microsoft Corporation, 1997 - 1997
	All rights reserved.

	Authors:
		KennT	Kenn M. Takara, Microsoft

	History:
		05/27/97	kennt	Created
 ----------------------------------------------------------------------------*/

#include <windows.h>
#include <objbase.h>
#include <initguid.h>
#include "ipxguid.h"
#include "rtrguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxface.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	ipxface
		Base IPX interface node handler
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ipxface.h"
#include "ipxadmin.h"	// for CreateDataObjectFromInterfaceInfo
#include "column.h"		// for ComponentConfigStream
#include "ipxconn.h"		// for IPXConnection
#include "format.h"		// for FormatNumber


BaseIPXResultNodeData::BaseIPXResultNodeData()
{
#ifdef DEBUG
	StrCpy(m_szDebug, _T("BaseIPXResultNodeData"));
#endif
	m_pIPXConnection = NULL;
	m_fClient = FALSE;
}

BaseIPXResultNodeData::~BaseIPXResultNodeData()
{
	if (m_pIPXConnection)
		m_pIPXConnection->Release();
	m_pIPXConnection = NULL;
}

HRESULT BaseIPXResultNodeData::Init(ITFSNode *pNode, IInterfaceInfo *pIf,
								  IPXConnection *pIPXConn)
{
	HRESULT				hr = hrOK;
	BaseIPXResultNodeData *	pData = NULL;
	
	pData = new BaseIPXResultNodeData;
	pData->m_spIf.Set(pIf);
	pData->m_pIPXConnection = pIPXConn;
	pIPXConn->AddRef();

	SET_BASEIPXRESULT_NODEDATA(pNode, pData);
	
	return hr;
}

HRESULT BaseIPXResultNodeData::Free(ITFSNode *pNode)
{	
	BaseIPXResultNodeData *	pData = GET_BASEIPXRESULT_NODEDATA(pNode);
	ASSERT_BASEIPXRESULT_NODEDATA(pData);
	pData->m_spIf.Release();
	delete pData;
	SET_BASEIPXRESULT_NODEDATA(pNode, NULL);
	
	return hrOK;
}


/*---------------------------------------------------------------------------
	BaseIPXResultHandler implementation
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(BaseIPXResultHandler)

IMPLEMENT_ADDREF_RELEASE(BaseIPXResultHandler)

STDMETHODIMP BaseIPXResultHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IRtrAdviseSink)
		*ppv = &m_IRtrAdviseSink;
	else
		return CBaseResultHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;	
}


/*---------------------------------------------------------------------------
	NodeHandler implementation
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	BaseIPXResultHandler::GetString
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) BaseIPXResultHandler::GetString(ITFSComponent * pComponent,
	MMC_COOKIE cookie,
	int nCol)
{
	Assert(m_spNodeMgr);
	
	SPITFSNode		spNode;
	BaseIPXResultNodeData *	pData;
	ConfigStream *	pConfig;

	m_spNodeMgr->FindNode(cookie, &spNode);
	Assert(spNode);

	pData = GET_BASEIPXRESULT_NODEDATA(spNode);
	Assert(pData);
	ASSERT_BASEIPXRESULT_NODEDATA(pData);

	pComponent->GetUserData((LONG_PTR *) &pConfig);
	Assert(pConfig);

	return pData->m_rgData[pConfig->MapColumnToSubitem(m_ulColumnId, nCol)].m_stData;
}

/*!--------------------------------------------------------------------------
	BaseIPXResultHandler::CompareItems
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int) BaseIPXResultHandler::CompareItems(ITFSComponent * pComponent, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int nCol)
{
	ConfigStream *	pConfig;
	pComponent->GetUserData((LONG_PTR *) &pConfig);
	Assert(pConfig);

	int	nSubItem = pConfig->MapColumnToSubitem(m_ulColumnId, nCol);

	if (pConfig->GetSortCriteria(m_ulColumnId, nCol) == CON_SORT_BY_DWORD)
	{
		SPITFSNode	spNodeA, spNodeB;
		BaseIPXResultNodeData *	pNodeDataA, *pNodeDataB;

		m_spNodeMgr->FindNode(cookieA, &spNodeA);
		m_spNodeMgr->FindNode(cookieB, &spNodeB);

		pNodeDataA = GET_BASEIPXRESULT_NODEDATA(spNodeA);
		ASSERT_BASEIPXRESULT_NODEDATA(pNodeDataA);
		
		pNodeDataB = GET_BASEIPXRESULT_NODEDATA(spNodeB);
		ASSERT_BASEIPXRESULT_NODEDATA(pNodeDataB);

		return pNodeDataA->m_rgData[nSubItem].m_dwData -
				pNodeDataB->m_rgData[nSubItem].m_dwData;
		
	}
	else
		return StriCmpW(GetString(pComponent, cookieA, nCol),
						GetString(pComponent, cookieB, nCol));
}

ImplementEmbeddedUnknown(BaseIPXResultHandler, IRtrAdviseSink)

STDMETHODIMP BaseIPXResultHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
	DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
	InitPThis(BaseIPXResultHandler, IRtrAdviseSink);
	HRESULT	hr = hrOK;
	
	Panic0("Should never reach here, interface nodes have no children");
	return hr;
}


HRESULT BaseIPXResultHandler::Init(IInterfaceInfo *pIfInfo, ITFSNode *pParent)
{
	return hrOK;
}

STDMETHODIMP BaseIPXResultHandler::DestroyResultHandler(MMC_COOKIE cookie)
{
	SPITFSNode	spNode;
	
	m_spNodeMgr->FindNode(cookie, &spNode);
	BaseIPXResultNodeData::Free(spNode);
	
	BaseRouterHandler::DestroyResultHandler(cookie);
	return hrOK;
}


/*!--------------------------------------------------------------------------
	FillInNumberData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void FillInNumberData(BaseIPXResultNodeData *pNodeData, UINT iIndex,
					  DWORD dwData)
{
	TCHAR	szNumber[32];

	FormatNumber(dwData, szNumber, DimensionOf(szNumber), FALSE);
	pNodeData->m_rgData[iIndex].m_stData = szNumber;
	pNodeData->m_rgData[iIndex].m_dwData = dwData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxface.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	ipxface.h
		Interface administration
		
    FILE HISTORY:
        
*/

#ifndef _IPXFACE_H
#define _IPXFACE_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _BASERTR_H
#include "basertr.h"
#endif

class IPXConnection;

#define IPXCONTAINER_MAX_COLUMNS	32

struct _BaseIPXResultData
{
	DWORD		m_dwData;
	CString		m_stData;
};

struct BaseIPXResultNodeData
{
	BaseIPXResultNodeData();
	~BaseIPXResultNodeData();
#ifdef DEBUG
	TCHAR	m_szDebug[32];
#endif

	// Each column entry will have a structure that contains
	// (1) a string, (2) a DWORD, (3) a Boolean telling us to
	// sort by the string or the DWORD.  The string is ALWAYS what gets
	// displayed!
	_BaseIPXResultData	m_rgData[IPXCONTAINER_MAX_COLUMNS];

	SPIInterfaceInfo	m_spIf;

	// TRUE if this is a client interface
	BOOL				m_fClient;

	DWORD				m_dwInterfaceIndex;

	// Used by Mark/Release algorithms
	DWORD				m_dwMark;

	IPXConnection *		m_pIPXConnection;

	static HRESULT	Init(ITFSNode *pNode, IInterfaceInfo *pIf,
						IPXConnection *pIPXConn);
	static HRESULT	Free(ITFSNode *pNode);
};

#define GET_BASEIPXRESULT_NODEDATA(pNode) \
					((BaseIPXResultNodeData *) pNode->GetData(TFS_DATA_USER))
#define SET_BASEIPXRESULT_NODEDATA(pNode, pData) \
					pNode->SetData(TFS_DATA_USER, (DWORD_PTR) pData)
#ifdef DEBUG
#define ASSERT_BASEIPXRESULT_NODEDATA(pData) \
		Assert(lstrcmp(pData->m_szDebug, _T("BaseIPXResultNodeData")) == 0);
#else
#define ASSERT_BASEIPXRESULT_NODEDATA(x)
#endif


/*---------------------------------------------------------------------------
	Class:	BaseIPXResultHandler

	This is a base class to be used by the interface result items.  It
	will contain some of the core code needed for basic things (like
	display of data).  It will not do the specifics (like menus/properties).

 ---------------------------------------------------------------------------*/
class BaseIPXResultHandler :
   public BaseRouterHandler
{
public:
	BaseIPXResultHandler(ITFSComponentData *pCompData, ULONG ulId)
			: BaseRouterHandler(pCompData), m_ulColumnId(ulId)
			{ DEBUG_INCREMENT_INSTANCE_COUNTER(BaseIPXResultHandler); };
	~BaseIPXResultHandler()
			{ DEBUG_DECREMENT_INSTANCE_COUNTER(BaseIPXResultHandler); }
	
	DeclareIUnknownMembers(IMPL)
	OVERRIDE_ResultHandler_GetString();
	OVERRIDE_ResultHandler_CompareItems();
	OVERRIDE_ResultHandler_DestroyResultHandler();

	HRESULT	Init(IInterfaceInfo *pInfo, ITFSNode *pParent);
	
protected:
	CString			m_stTitle;	// holds the title of the node

	//
	// This is the id of the column set to use.  This is used when we
	// interact with the ComponentConfigStream.
	//
	ULONG			m_ulColumnId;


	DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)	
};


void FillInNumberData(BaseIPXResultNodeData *pNodeData, UINT iIndex,
					  DWORD dwData);

#endif _IPXFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxguid.h ===
/*----------------------------------------------------------------------------
	ipxguid.h

	Header file for all of the IPX GUIDS.


	Copyright (C) Microsoft Corporation, 1997 - 1997
	All rights reserved.

 ----------------------------------------------------------------------------*/

#ifndef _IPXGUID_H
#define _IPXGUID_H


/*---------------------------------------------------------------------------
	The range for the IPX GUIDs is

	{90810500-38F1-11D1-9345-00C04FC9DA04}
	to
	{908105FF-38F1-11D1-9345-00C04FC9DA04}

	
	// CLSIDs for our objects are in the range of
	{90810500-38F1-11D1-9345-00C04FC9DA04}
	to
	{9081053F-38F1-11D1-9345-00C04FC9DA04}

	
	// Nodetype guids are in the range of
	{90810540-38F1-11D1-9345-00C04FC9DA04}
	to
	{9081057F-38F1-11D1-9345-00C04FC9DA04}
	

	// Unassigned
	{90810580-38F1-11D1-9345-00C04FC9DA04}
	to
	{908105FF-38F1-11D1-9345-00C04FC9DA04}

	
 ---------------------------------------------------------------------------*/


#define DEFINE_IPX_CLSID(name,x) \
	DEFINE_GUID(CLSID_##name, \
	(0x90810500 + x), 0x38F1, 0x11d1, 0x93, 0x45, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4); \

#define DEFINE_IPX_NODETYPE_GUID(name,x) \
	DEFINE_GUID(GUID_##name, \
	(0x90810540 + x), 0x38F1, 0x11d1, 0x93, 0x45, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4); \


// CLSID_IPXAdminExtension
//	{90810500-38F1-11D1-9345-00C04FC9DA04}
DEFINE_IPX_CLSID(IPXAdminExtension, 0)

// CLSID_IPXAdminAbout
//	{90810501-38F1-11D1-9345-00C04FC9DA04}
DEFINE_IPX_CLSID(IPXAdminAbout, 1)

// CLSID_IPXRipExtension
//	{90810504-38F1-11D1-9345-00C04FC9DA04}
DEFINE_IPX_CLSID(IPXRipExtension, 2)

// CLSID_IPXRipExtensionAbout
//	{90810505-38F1-11D1-9345-00C04FC9DA04}
DEFINE_IPX_CLSID(IPXRipExtensionAbout, 3)

// CLSID_IPXSapExtension
//	{90810504-38F1-11D1-9345-00C04FC9DA04}
DEFINE_IPX_CLSID(IPXSapExtension, 4)

// CLSID_IPXSapExtensionAbout
//	{90810505-38F1-11D1-9345-00C04FC9DA04}
DEFINE_IPX_CLSID(IPXSapExtensionAbout, 5)



// GUID_IPXRootNodeType
//	{90810540-38F1-11D1-9345-00C04FC9DA04}
DEFINE_IPX_NODETYPE_GUID(IPXRootNodeType, 0)
//extern const TCHAR g_cszIPXNodeType[];

DEFINE_IPX_NODETYPE_GUID(IPXNodeType, 1)

DEFINE_IPX_NODETYPE_GUID(IPXSummaryNodeType, 2)
DEFINE_IPX_NODETYPE_GUID(IPXSummaryInterfaceNodeType, 3)

DEFINE_IPX_NODETYPE_GUID(IPXNetBIOSBroadcastsNodeType, 4)
DEFINE_IPX_NODETYPE_GUID(IPXNetBIOSBroadcastsInterfaceNodeType, 5)

DEFINE_IPX_NODETYPE_GUID(IPXStaticRoutesNodeType, 6)
DEFINE_IPX_NODETYPE_GUID(IPXStaticRoutesResultNodeType, 7)

DEFINE_IPX_NODETYPE_GUID(IPXStaticServicesNodeType, 8)
DEFINE_IPX_NODETYPE_GUID(IPXStaticServicesResultNodeType, 9)

DEFINE_IPX_NODETYPE_GUID(IPXStaticNetBIOSNamesNodeType, 10)
DEFINE_IPX_NODETYPE_GUID(IPXStaticNetBIOSNamesResultNodeType, 11)

DEFINE_IPX_NODETYPE_GUID(IPXRipRootNodeType, 12)
DEFINE_IPX_NODETYPE_GUID(IPXRipNodeType, 13)
DEFINE_IPX_NODETYPE_GUID(IPXRipInterfaceNodeType, 14)

DEFINE_IPX_NODETYPE_GUID(IPXSapRootNodeType, 15)
DEFINE_IPX_NODETYPE_GUID(IPXSapNodeType, 16)
DEFINE_IPX_NODETYPE_GUID(IPXSapInterfaceNodeType, 17)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxroot.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	root.h
		Root node information (the root node is not displayed
		in the MMC framework but contains information such as 
		all of the subnodes in this snapin).
		
    FILE HISTORY:
        
*/

#ifndef _IPXROOT_H
#define _IPXROOT_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _QUERYOBJ_H
#include "queryobj.h"
#endif

#ifndef _IPXSTRM_H
#include "ipxstrm.h"
#endif

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _ROOT_H
#include "root.h"
#endif


/*---------------------------------------------------------------------------
	Class:	IPXRootHandler

	There should be a IPXRootHandler for every root node created.
	IPXRootHandler's have a 1-to-1 relationship with their node!
	Other parts of the code depend on this.
 ---------------------------------------------------------------------------*/
class IPXRootHandler
	   : public RootHandler
{
public:
	IPXRootHandler(ITFSComponentData *pCompData);
	~IPXRootHandler()
			{ DEBUG_DECREMENT_INSTANCE_COUNTER(IPXRootHandler); };

    HRESULT ConstructNode(ITFSNode * pNode);

    STDMETHOD(GetClassID)(CLSID *pClassId);
	
	// Notification overrides
	OVERRIDE_BaseHandlerNotify_OnExpand();

	// Handler overrides
	OVERRIDE_NodeHandler_OnCreateDataObject();
    OVERRIDE_NodeHandler_DestroyHandler();

	// virtual function to access config stream
	ConfigStream *		GetConfigStream()
			{ return &m_ConfigStream; }

protected:
	IPXAdminConfigStream	m_ConfigStream;

    HRESULT     AddRemoveIPXRootNode(ITFSNode *, IRouterInfo *, BOOL);
    HRESULT     SearchIPXRoutingNodes(ITFSNode *pParent,
                                      LPCTSTR pszMachineName,
                                      BOOL fAddedAsLocal,
                                      ITFSNode **ppChild);

    // Override QI to handle embedded interface
    STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);

    // Embedded interface to deal with refresh callbacks
    DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)
};




#endif _IPXROOT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxroot.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	root.cpp
		Root node information (the root node is not displayed
		in the MMC framework but contains information such as 
		all of the subnodes in this snapin).
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "util.h"
#include "ipxroot.h"
#include "ipxconn.h"
#include "reg.h"
#include "rtrui.h"

#include "ipxstats.h"		// for MVR_IPX_COUNT

/*---------------------------------------------------------------------------
	IPXRootHandler implementation
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(IPXRootHandler)

extern const ContainerColumnInfo s_rgIpxStatsColumnInfo[];
extern const ContainerColumnInfo s_rgIpxRoutingStatsColumnInfo[];
extern const ContainerColumnInfo s_rgIpxServiceStatsColumnInfo[];

struct _ViewInfoColumnEntry
{
	UINT	m_ulId;
	UINT	m_cColumns;
	const ContainerColumnInfo *m_prgColumn;
};

static const struct _ViewInfoColumnEntry	s_rgViewColumnInfo[] =
{
	{ IPXSTRM_STATS_IPX,	MVR_IPX_COUNT,	s_rgIpxStatsColumnInfo },
	{ IPXSTRM_STATS_ROUTING, MVR_IPXROUTING_COUNT, s_rgIpxRoutingStatsColumnInfo },
	{ IPXSTRM_STATS_SERVICE, MVR_IPXSERVICE_COUNT, s_rgIpxServiceStatsColumnInfo },
};

IPXRootHandler::IPXRootHandler(ITFSComponentData *pCompData)
	: RootHandler(pCompData)
{
	DEBUG_INCREMENT_INSTANCE_COUNTER(IPXRootHandler)

	Assert(DimensionOf(s_rgViewColumnInfo) <= IPXSTRM_MAX_COUNT);
			
	m_ConfigStream.Init(DimensionOf(s_rgViewColumnInfo));
    
    // This will initialize the view information for the statistics
    // dialogs.  (which is why the fConfigurableColumns is set to TRUE).
	for (int i=0; i<DimensionOf(s_rgViewColumnInfo); i++)
	{
		m_ConfigStream.InitViewInfo(s_rgViewColumnInfo[i].m_ulId,
                                    TRUE /*fConfigurableColumns*/,
									s_rgViewColumnInfo[i].m_cColumns,
									TRUE,
									s_rgViewColumnInfo[i].m_prgColumn);
	}

}

/*!--------------------------------------------------------------------------
	IPXRootHandler::QueryInterface
        -
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXRootHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IRtrAdviseSink)
		*ppv = &m_IRtrAdviseSink;
	else
		return RootHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;	
}

STDMETHODIMP IPXRootHandler::GetClassID
(
	CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_IPXAdminExtension;

    return hrOK;
}

/*!--------------------------------------------------------------------------
	IPXRootHandler::ConstructNode
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT IPXRootHandler::ConstructNode(ITFSNode *pNode)
{
    HRESULT hr = hrOK;

    EnumDynamicExtensions(pNode);

    CORg (RootHandler::ConstructNode(pNode));

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	IPXRootHandler::OnExpand
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXRootHandler::OnExpand(ITFSNode *pNode,
								 LPDATAOBJECT pDataObject,
								 DWORD dwType,
								 LPARAM arg,
								 LPARAM lParam)
{
	HRESULT	hr = hrOK;
    LONG_PTR    ulConnId;
	SPIRouterInfo		spRouterInfo;
    SPIRouterRefresh    spRefresh;
    BOOL                fAddedAsLocal = FALSE;

	// Grab the router info from the dataobject
	spRouterInfo.Query(pDataObject);
	Assert(spRouterInfo);

    // Register for refresh notifications on the main router info
    // (We do not need to register for IP changes, just the refresh)
    spRouterInfo->GetRefreshObject(&spRefresh);
    Assert(spRefresh);
    
    spRefresh->AdviseRefresh(&m_IRtrAdviseSink,
                             &ulConnId,
                             pNode->GetData(TFS_DATA_COOKIE));

    // Setup the Router to connection id mappings
    // The IID_IRouterRefresh tells the RtrObjMap to use
    // the Refresh advise.
    AddRtrObj(ulConnId, IID_IRouterRefresh, spRouterInfo);

    fAddedAsLocal = ExtractComputerAddedAsLocal(pDataObject);

    SetComputerAddedAsLocal(ulConnId, fAddedAsLocal);

    if (fAddedAsLocal)        
        AddScopeItem(_T(""), (HSCOPEITEM) lParam);
    else
        AddScopeItem(spRouterInfo->GetMachineName(), (HSCOPEITEM) lParam);
   
    // Add the node
    AddRemoveIPXRootNode(pNode, spRouterInfo, fAddedAsLocal);

   return hr;
}

/*!--------------------------------------------------------------------------
	IPXRootHandler::OnCreateDataObject
		Implementation of ITFSNodeHandler::OnCreateDataObject
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXRootHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT		    hr = hrOK;
	SPIRouterInfo   spRouterInfo;

    COM_PROTECT_TRY
	{
        // this will always be NULL
		if (spRouterInfo == NULL)
		{
			// If we haven't created the sub nodes yet, we still have to
			// create a dataobject.
			CDataObject *	pObject = NULL;
			SPIDataObject	spDataObject;
			SPITFSNode		spNode;
			SPITFSNodeHandler	spHandler;
			
			pObject = new CDataObject;
			spDataObject = pObject;	// do this so that it gets released correctly
			Assert(pObject != NULL);
			
			// Save cookie and type for delayed rendering
			pObject->SetType(type);
			pObject->SetCookie(cookie);
			
            // Store the coclass with the data object
			pObject->SetClsid(*(m_spTFSCompData->GetCoClassID()));
			
			pObject->SetTFSComponentData(m_spTFSCompData);
			
            pObject->SetDynExt(&m_dynExtensions);

            hr = pObject->QueryInterface(IID_IDataObject, 
									 reinterpret_cast<void**>(ppDataObject));
			
		}
		else
			hr = CreateDataObjectFromRouterInfo(spRouterInfo,
												type, cookie, m_spTFSCompData,
												ppDataObject, &m_dynExtensions);
	}
	COM_PROTECT_CATCH;
	return hr;
}

/*!--------------------------------------------------------------------------
	IPXRootHandler::SearchIPXRoutingNodes
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXRootHandler::SearchIPXRoutingNodes(ITFSNode *pParent,
                                              LPCTSTR pszMachineName,
                                              BOOL fAddedAsLocal,
                                              ITFSNode **ppChild)
{
    HRESULT     hr = hrFalse;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode  spNode;

    // Enumerate through all of the child nodes and return the
    // first node that matches the GUID and the name.

    CORg( pParent->GetEnum(&spNodeEnum) );

    while ( spNodeEnum->Next(1, &spNode, NULL) == hrOK )
    {
        if (*(spNode->GetNodeType()) == GUID_IPXNodeType)
        {
			// determin if the spChild is the same for the required routerinfo
            // -- compare the names
			IPXConnection *		pIPXConn = GET_IPXADMIN_NODEDATA((ITFSNode*)spNode); 
			Assert(pIPXConn);

			// if the child is not for the same machine --
            // routerinfo, it doesn't count
			if ((0 == StriCmp(pIPXConn->GetMachineName(), pszMachineName)) || 
                (IsLocalMachine(pIPXConn->GetMachineName()) &&
                 IsLocalMachine(pszMachineName)))
            {
                if (pIPXConn->IsComputerAddedAsLocal() == fAddedAsLocal)
                    break;
            }
        }

        spNode.Release();
    }

    if (spNode)
    {
        if (ppChild)
            *ppChild = spNode.Transfer();
        hr = hrOK;
    }


Error:
    return hr;
}


/*!--------------------------------------------------------------------------
	IPXRootHandler::AddRemoveIPXRootNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXRootHandler::AddRemoveIPXRootNode(ITFSNode *pNode,
                                             IRouterInfo *pRouter,
                                             BOOL fAddedAsLocal)
{
	HRESULT		hr = hrOK;
	SPITFSNodeHandler spHandler;
	IPXAdminNodeHandler * pHandler = NULL;
	SPITFSNode	spChild;
	SPITFSNode	spNode;
    RouterVersionInfo   versionInfo;
    HSCOPEITEM  hScopeItem = NULL;

    pRouter->GetRouterVersionInfo(&versionInfo);
    pRouter->FindRtrMgr(PID_IPX, NULL);

	// Search for an already existing node
	// ----------------------------------------------------------------
	SearchIPXRoutingNodes(pNode, pRouter->GetMachineName(), fAddedAsLocal, &spChild);

    if ((versionInfo.dwRouterFlags & RouterSnapin_IsConfigured) &&
        (pRouter->FindRtrMgr(PID_IPX, NULL) == hrOK))
    {
        // Ok, the router is configured, and there is an IPX rtrmgr
        if (spChild == NULL)
        {
			// add the IPX node
			// --------------------------------------------------------
            pHandler = new IPXAdminNodeHandler(m_spTFSCompData);
            spHandler = pHandler;
            CORg( pHandler->Init(pRouter, &m_ConfigStream) );
            
            CreateContainerTFSNode(&spNode,
                                   &GUID_IPXNodeType,
                                   static_cast<ITFSNodeHandler *>(pHandler),
                                   static_cast<ITFSResultHandler *>(pHandler),
                                   m_spNodeMgr);
            
            // Call to the node handler to init the node data
            pHandler->ConstructNode(spNode, fAddedAsLocal);
            
            // Make the node immediately visible
            spNode->SetVisibilityState(TFS_VIS_SHOW);
            if ( FHrOK(pNode->AddChild(spNode)) )
            {
                // Add the cookie to the node map
                if (fAddedAsLocal)
                    GetScopeItem(_T(""), &hScopeItem);
                else
                    GetScopeItem(pRouter->GetMachineName(), &hScopeItem);
                AddCookie(hScopeItem, (MMC_COOKIE)
                          spNode->GetData(TFS_DATA_COOKIE));
            }
            else
            {
                // Remove this node
                // ----------------------------------------------------
                pNode->RemoveChild(spNode);
                spNode->Destroy();
                spNode.Release();            
            }
            
            // I don't think we need this here
            // AddDynamicNamespaceExtensions(pNode);
        }
    }
    else
    {
		if (spChild)
		{
			// Remove this node
			// --------------------------------------------------------
			pNode->RemoveChild(spChild);
			spChild->Destroy();
			spChild.Release();
		}
    }
Error:
    return hr;
}



/*---------------------------------------------------------------------------
	Embedded IRtrAdviseSink
 ---------------------------------------------------------------------------*/
ImplementEmbeddedUnknown(IPXRootHandler, IRtrAdviseSink)



/*!--------------------------------------------------------------------------
	IPXRootHandler::EIRtrAdviseSink::OnChange
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXRootHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
	DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	InitPThis(IPXRootHandler, IRtrAdviseSink);
	SPITFSNode				spThisNode;
    SPIRouterInfo           spRouter;
    HSCOPEITEM          hScopeItem, hOldScopeItem;
	HRESULT	hr = hrOK;
    BOOL        fAddedAsLocal = FALSE;

	COM_PROTECT_TRY
	{
        if ((dwChangeType == ROUTER_REFRESH) ||
            (dwChangeType == ROUTER_CHILD_ADD) ||
            (dwChangeType == ROUTER_CHILD_DELETE))
        {
            pThis->GetRtrObj(ulConn, (IUnknown **) &spRouter);
            Assert(spRouter);
        
            // The lUserParam passed into the refresh is the cookie for
            // this machine node.
            // --------------------------------------------------------
            pThis->m_spNodeMgr->FindNode(lUserParam, &spThisNode);
            
            // Get the proper scope item for this node.
            // If this call fails, then we haven't expanded this node yet,
            // and thus can't add child nodes to it.
            // --------------------------------------------------------
            fAddedAsLocal = pThis->IsComputerAddedAsLocal(ulConn);
            if (fAddedAsLocal)
                hr = pThis->GetScopeItem(_T(""), &hScopeItem);
            else
                hr = pThis->GetScopeItem(spRouter->GetMachineName(), &hScopeItem);
            if (FHrOK(hr))
            {    
                // Get the old one and save it.  place the new one in the node.
                // ----------------------------------------------------
                hOldScopeItem = spThisNode->GetData(TFS_DATA_SCOPEID);
                spThisNode->SetData(TFS_DATA_SCOPEID, hScopeItem);
                
                // Look to see if we need the IPX root node
                // ----------------------------------------------------
                pThis->AddRemoveIPXRootNode(spThisNode, spRouter, fAddedAsLocal);
            }
        }        
    }
	COM_PROTECT_CATCH;
	
    // Restore the scope item
    if (spThisNode)
        spThisNode->SetData(TFS_DATA_SCOPEID, hOldScopeItem);
    
	return hr;
}

STDMETHODIMP IPXRootHandler::DestroyHandler(ITFSNode *pNode)
{
    RemoveAllRtrObj();
	return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxstaticnbname.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999   **/
/**********************************************************************/

//
//	nbprop.cpp
//		IPX summary node property sheet and property pages
//		
//  FILE HISTORY:


#include "stdafx.h"
#include "rtrutil.h"	// smart MPR handle pointers
#include "format.h"		// FormatNumber function
#include "IpxStaticNBName.h"
#include "summary.h"
#include "ipxrtdef.h"
#include "filter.h"
#include "ipxutil.h"

extern "C"
{
#include "routprot.h"
};

// ---------------------------------------------------------------------------
//	IpxStaticNBNamePropertySheet::IpxStaticNBNamePropertySheet
//	Initialize the RtrPropertySheet and only Property Page.
//	Author: Deonb
// ---------------------------------------------------------------------------
IpxStaticNBNamePropertySheet::IpxStaticNBNamePropertySheet(ITFSNode *pNode,
								 IComponentData *pComponentData,
								 ITFSComponentData *pTFSCompData,
								 LPCTSTR pszSheetName,
								 CWnd *pParent,
								 UINT iPage,
								 BOOL fScopePane)
	: RtrPropertySheet(pNode, pComponentData, pTFSCompData, 
					   pszSheetName, pParent, iPage, fScopePane),
		m_pageGeneral(IDD_STATIC_NETBIOS_NAME_PROPERTYPAGE)
{
	m_spNode = pNode;
}

// ---------------------------------------------------------------------------
//	IpxStaticNBNamePropertySheet::Init
//	Initialize the property sheets.  The general action here will be
//		to initialize/add the various pages.
//	Author: Deonb
// ---------------------------------------------------------------------------
HRESULT	IpxStaticNBNamePropertySheet::Init(	
 		 	 BaseIPXResultNodeData  *pNodeData,
			 IInterfaceInfo *  spInterfaceInfo)
{
	HRESULT	hr = hrOK;

	BaseIPXResultNodeData *	pData;

	m_pNodeData = pNodeData;
	m_spInterfaceInfo = spInterfaceInfo;

	pData = GET_BASEIPXRESULT_NODEDATA(m_spNode);
	ASSERT_BASEIPXRESULT_NODEDATA(pData);

	// The pages are embedded members of the class
	// do not delete them.
	m_bAutoDeletePages = FALSE;
	
	m_pageGeneral.Init(pNodeData, this);
	AddPageToList((CPropertyPageBase*) &m_pageGeneral);

	return S_OK;
}

// ---------------------------------------------------------------------------
//	IpxStaticNBNamePropertySheet::SaveSheetData
//	Not sure what this does - this is never called. Kenn had this so I'll just
//		copy this too.
//	Author: Deonb
// ---------------------------------------------------------------------------
BOOL IpxStaticNBNamePropertySheet::SaveSheetData()
{
    SPITFSNodeHandler	spHandler;
    SPITFSNode			spParent;
    
	// By this time each page should have written its information out
	// to the infobase

    // Force the node to do a resync
    m_spNode->GetParent(&spParent);
    spParent->GetHandler(&spHandler);
    spHandler->OnCommand(spParent, IDS_MENU_SYNC, CCT_RESULT,
                         NULL, 0);
		
	return TRUE;
}

// --------------------------------------------------------------------------
//	IpxStaticNBNamePropertySheet::CancelSheetData
//		-
//	Author: Deonb
// ---------------------------------------------------------------------------
void IpxStaticNBNamePropertySheet::CancelSheetData()
{
}

// ***************************************************************************
// ---------------------------------------------------------------------------
//	IpxStaticNBNamePropertyPage
// ---------------------------------------------------------------------------
IpxStaticNBNamePropertyPage::~IpxStaticNBNamePropertyPage()
{
}

BEGIN_MESSAGE_MAP(IpxStaticNBNamePropertyPage, RtrPropertyPage)
    //{{AFX_MSG_MAP(IpxStaticNBNamePropertyPage)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void IpxStaticNBNamePropertyPage::OnChangeButton()
{
	SetDirty(TRUE);
	SetModified();
}

//--------------------------------------------------------------------------
//	IpxStaticNBNamePropertyPage::Init
//		-
//	Author: Deonb
//---------------------------------------------------------------------------
HRESULT	IpxStaticNBNamePropertyPage::Init(BaseIPXResultNodeData  *pNodeData,
				IpxStaticNBNamePropertySheet * pIPXPropSheet)

{
	ATLASSERT(pSREntry);
	ATLASSERT(pIPXPropSheet);
	
	m_pIPXPropSheet = pIPXPropSheet;

	m_SNEntry.LoadFrom(pNodeData);
	m_InitSNEntry = m_SNEntry;
	
	return hrOK;
}

// --------------------------------------------------------------------------
//	IpxStaticNBNamePropertyPage::OnInitDialog
//		-
//	Author: Deonb
// ---------------------------------------------------------------------------
BOOL IpxStaticNBNamePropertyPage::OnInitDialog()
{
	HRESULT	hr = hrOK;
	PBYTE	pData;
	DWORD		dwIfType;
	UINT		iButton;
	TCHAR					szName[32];
	TCHAR					szType[32];
	CString					st;
 	USHORT					uType;

	RtrPropertyPage::OnInitDialog();
	
	((CEdit *) GetDlgItem(IDC_SND_EDIT_NAME))->LimitText(15);
	((CEdit *) GetDlgItem(IDC_SND_EDIT_TYPE))->LimitText(2);

	FormatNetBIOSName(szName, &uType, (LPCSTR) m_SNEntry.m_name.Name);
	st = szName;
	st.TrimRight();
	st.TrimLeft();

	SetDlgItemText(IDC_SND_EDIT_NAME, st);

	wsprintf(szType, _T("%.2x"), uType);
	SetDlgItemText(IDC_SND_EDIT_TYPE, szType);
	
	return TRUE;
}

// --------------------------------------------------------------------------
//	IpxStaticNBNamePropertyPage::DoDataExchange
//		-
//	Author: Deonb
// ---------------------------------------------------------------------------
void IpxStaticNBNamePropertyPage::DoDataExchange(CDataExchange *pDX)
{
	RtrPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(IpxStaticNBNamePropertyPage)
	//}}AFX_DATA_MAP
}

// --------------------------------------------------------------------------
//	IpxStaticNBNamePropertyPage::OnApply
//		-
//	Author: Deonb
// ---------------------------------------------------------------------------
BOOL IpxStaticNBNamePropertyPage::OnApply()
{
    CString		st;
	BOOL	fReturn;
	HRESULT	hr = hrOK;
	USHORT		uType;

    if ( m_pIPXPropSheet->IsCancel() )
	{
		CancelApply();
        return TRUE;
	}

	// Get the rest of the data
	GetDlgItemText(IDC_SND_EDIT_TYPE, st);
	uType = (USHORT) _tcstoul(st, NULL, 16);

	GetDlgItemText(IDC_SND_EDIT_NAME, st);
	st.TrimLeft();
	st.TrimRight();

	if (st.IsEmpty())
	{
		GetDlgItem(IDC_SND_EDIT_NAME)->SetFocus();
		AfxMessageBox(IDS_ERR_INVALID_NETBIOS_NAME);
		return FALSE;
	}

	ConvertToNetBIOSName((LPSTR) m_SNEntry.m_name.Name, st, uType);

	ModifyNameInfo(m_pIPXPropSheet->m_spNode, &m_SNEntry, &m_InitSNEntry);

	// Update the data in the UI
	m_SNEntry.SaveTo(m_pIPXPropSheet->m_pNodeData);
	m_pIPXPropSheet->m_spInterfaceInfo = m_SNEntry.m_spIf;
	
	// Force a refresh
	m_pIPXPropSheet->m_spNode->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);

	fReturn  = RtrPropertyPage::OnApply();
	return fReturn;
}

/*
// --------------------------------------------------------------------------
//	IpxStaticNBNamePropertyPage::RemoveStaticService
//		-
//	Author: KennT
// ---------------------------------------------------------------------------
HRESULT IpxStaticNBNamePropertyPage::RemoveStaticService(SafeIPXSNListEntry *pSSEntry,
										  IInfoBase *pInfoBase)
{
	HRESULT		hr = hrOK;
	InfoBlock *	pBlock;
	PIPX_STATIC_SERVICE_INFO	pRow;
    INT			i;
	
	// Get the IPX_STATIC_SERVICE_INFO block from the interface
	CORg( pInfoBase->GetBlock(IPX_STATIC_SERVICE_INFO_TYPE, &pBlock, 0) );
		
	// Look for the removed route in the IPX_STATIC_SERVICE_INFO
	pRow = (IPX_STATIC_SERVICE_INFO*) pBlock->pData;
	
	for (i = 0; i < (INT)pBlock->dwCount; i++, pRow++)
	{	
		// Compare this route to the removed one
		if (FAreTwoServicesEqual(pRow, &(pSSEntry->m_service)))
		{
			// This is the removed route, so modify this block
			// to exclude the route:
			
			// Decrement the number of Services
			--pBlock->dwCount;
		
			if (pBlock->dwCount && (i < (INT)pBlock->dwCount))
			{				
				// Overwrite this route with the ones which follow it
				::memmove(pRow,
						  pRow + 1,
						  (pBlock->dwCount - i) * sizeof(*pRow));
			}
			
			break;
		}
	}

Error:
	return hr;
}

*/


/*--------------------------------------------------------------------------
	IpxStaticNBNamePropertyPage::ModifyNameInfo
		-
	Author: Deonb
 ---------------------------------------------------------------------------*/
HRESULT IpxStaticNBNamePropertyPage::ModifyNameInfo(ITFSNode *pNode,
										SafeIPXSNListEntry *pSNEntryNew,
										SafeIPXSNListEntry *pSNEntryOld)
{
 	Assert(pSNEntryNew);
	Assert(pSNEntryOld);
	
    INT i;
	HRESULT hr = hrOK;
    InfoBlock* pBlock;
	SPIInfoBase	spInfoBase;
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPITFSNode				spNodeParent;
	IPXConnection *			pIPXConn;
	IPX_STATIC_NETBIOS_NAME_INFO		*psr, *psrOld;
	IPX_STATIC_NETBIOS_NAME_INFO		IpxRow;

    CWaitCursor wait;

	pNode->GetParent(&spNodeParent);
	pIPXConn = GET_IPX_SN_NODEDATA(spNodeParent);
	Assert(pIPXConn);

	// Remove the old name if it is on another interface
	if (lstrcmpi(pSNEntryOld->m_spIf->GetId(), pSNEntryNew->m_spIf->GetId()) != 0)
	{
        // the outgoing interface for a name is to be changed.

		CORg( pSNEntryOld->m_spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) );
		CORg( spRmIf->GetInfoBase(pIPXConn->GetConfigHandle(),
								  NULL,
								  NULL,
								  &spInfoBase));
		
		// Remove the old interface
		CORg( RemoveStaticNetBIOSName(pSNEntryOld, spInfoBase) );

		// Update the interface information
		CORg( spRmIf->Save(pSNEntryOld->m_spIf->GetMachineName(),
						   pIPXConn->GetConfigHandle(),
						   NULL,
						   NULL,
						   spInfoBase,
						   0));	
    }

	spRmIf.Release();
	spInfoBase.Release();


	// Either
	// (a) a name is being modified (on the same interface)
	// (b) a name is being moved from one interface to another.

	// Retrieve the configuration for the interface to which the name
	// is now attached;

	
	CORg( pSNEntryNew->m_spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) );
	CORg( spRmIf->GetInfoBase(pIPXConn->GetConfigHandle(),
							  NULL,
							  NULL,
							  &spInfoBase));

		
	// Get the IPX_STATIC_NETBIOS_NAME_INFO block from the interface
	hr = spInfoBase->GetBlock(IPX_STATIC_NETBIOS_NAME_INFO_TYPE, &pBlock, 0);
	if (!FHrOK(hr))
	{
		//
		// No IPX_STATIC_NETBIOS_NAME_INFO block was found; we create a new block 
		// with the new name, and add that block to the interface-info
		//

		CORg( AddStaticNetBIOSName(pSNEntryNew, spInfoBase, NULL) );
	}
	else
	{
		//
		// An IPX_STATIC_NETBIOS_NAME_INFO block was found.
		//
		// We are modifying an existing name.
		// If the name's interface was not changed when it was modified,
		// look for the existing name in the IPX_STATIC_NETBIOS_NAME_INFO, and then
		// update its parameters.
		// Otherwise, write a completely new name in the IPX_STATIC_NETBIOS_NAME_INFO;
		//

		if (lstrcmpi(pSNEntryOld->m_spIf->GetId(), pSNEntryNew->m_spIf->GetId()) == 0)
		{        
			//
			// The name's interface was not changed when it was modified;
			// We now look for it amongst the existing Names
			// for this interface.
			// The name's original parameters are in 'preOld',
			// so those are the parameters with which we search
			// for a name to modify
			//
			
			psr = (IPX_STATIC_NETBIOS_NAME_INFO*)pBlock->pData;
			
			for (i = 0; i < (INT)pBlock->dwCount; i++, psr++)
			{	
				// Compare this name to the re-configured one
				if (!FAreTwoNamesEqual(&(pSNEntryOld->m_name), psr))
					continue;
				
				// This is the name which was modified;
				// We can now modify the parameters for the name in-place.
				*psr = pSNEntryNew->m_name;
				
				break;
			}
		}
		else
		{
			CORg( AddStaticNetBIOSName(pSNEntryNew, spInfoBase, pBlock) );
		}
		
		// Save the updated information
		CORg( spRmIf->Save(pSNEntryNew->m_spIf->GetMachineName(),
						   pIPXConn->GetConfigHandle(),
						   NULL,
						   NULL,
						   spInfoBase,
						   0));	
		
	}

Error:
	return hr;
	
}

/*!--------------------------------------------------------------------------
	SafeIpxSNListEntry::LoadFrom
		-
	Author: Deonb
 ---------------------------------------------------------------------------*/
void SafeIPXSNListEntry::LoadFrom(BaseIPXResultNodeData *pNodeData)
{
	m_spIf = pNodeData->m_spIf;

	ConvertToNetBIOSName((LPSTR) m_name.Name,
			 pNodeData->m_rgData[IPX_SN_SI_NETBIOS_NAME].m_stData,
			 (USHORT) pNodeData->m_rgData[IPX_SN_SI_NETBIOS_TYPE].m_dwData);
}

/*!--------------------------------------------------------------------------
	SafeIpxSNListEntry::SaveTo
		-
	Author: Deonb
 ---------------------------------------------------------------------------*/
void SafeIPXSNListEntry::SaveTo(BaseIPXResultNodeData *pNodeData)
{
	TCHAR	szName[32];
	TCHAR	szType[32];
	CString	st;
	USHORT	uType;

	FormatNetBIOSName(szName, &uType,
					  (LPCSTR) m_name.Name);
	st = szName;
	st.TrimLeft();
	st.TrimRight();
	
	pNodeData->m_spIf.Set(m_spIf);
	pNodeData->m_rgData[IPX_SN_SI_NAME].m_stData = m_spIf->GetTitle();

	pNodeData->m_rgData[IPX_SN_SI_NETBIOS_NAME].m_stData = st;

	wsprintf(szType, _T("%.2x"), uType);
	pNodeData->m_rgData[IPX_SN_SI_NETBIOS_TYPE].m_stData = szType;
	pNodeData->m_rgData[IPX_SN_SI_NETBIOS_TYPE].m_dwData = uType;

}

/*!--------------------------------------------------------------------------
	IpxStaticNetBIOSNameHandler::RemoveStaticNetBIOSName
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxStaticNBNamePropertyPage::RemoveStaticNetBIOSName(SafeIPXSNListEntry *pSNEntry,
										  IInfoBase *pInfoBase)
{
	HRESULT		hr = hrOK;
	InfoBlock *	pBlock;
	PIPX_STATIC_NETBIOS_NAME_INFO	pRow;
    INT			i;
	
	// Get the IPX_STATIC_NETBIOS_NAME_INFO block from the interface
	CORg( pInfoBase->GetBlock(IPX_STATIC_NETBIOS_NAME_INFO_TYPE, &pBlock, 0) );
		
	// Look for the removed name in the IPX_STATIC_NETBIOS_NAME_INFO
	pRow = (IPX_STATIC_NETBIOS_NAME_INFO*) pBlock->pData;
	
	for (i = 0; i < (INT)pBlock->dwCount; i++, pRow++)
	{	
		// Compare this name to the removed one
		if (FAreTwoNamesEqual(pRow, &(pSNEntry->m_name)))
		{
			// This is the removed name, so modify this block
			// to exclude the name:
			
			// Decrement the number of Names
			--pBlock->dwCount;
		
			if (pBlock->dwCount && (i < (INT)pBlock->dwCount))
			{				
				// Overwrite this name with the ones which follow it
				::memmove(pRow,
						  pRow + 1,
						  (pBlock->dwCount - i) * sizeof(*pRow));
			}
			
			break;
		}
	}

Error:
	return hr;
}

HRESULT AddStaticNetBIOSName(SafeIPXSNListEntry *pSNEntryNew,
									   IInfoBase *pInfoBase,
									   InfoBlock *pBlock)
{
	IPX_STATIC_NETBIOS_NAME_INFO	srRow;
	HRESULT				hr = hrOK;
	
	if (pBlock == NULL)
	{
		//
		// No IPX_STATIC_NETBIOS_NAME_INFO block was found; we create a new block 
		// with the new name, and add that block to the interface-info
		//
		
		CORg( pInfoBase->AddBlock(IPX_STATIC_NETBIOS_NAME_INFO_TYPE,
								  sizeof(IPX_STATIC_NETBIOS_NAME_INFO),
								  (LPBYTE) &(pSNEntryNew->m_name), 1, 0) );
	}
	else
	{
		// Either the name is completely new, or it is a name
		// which was moved from one interface to another.
		// Set a new block as the IPX_STATIC_NETBIOS_NAME_INFO,
		// and include the re-configured name in the new block.
		PIPX_STATIC_NETBIOS_NAME_INFO	psrTable;
			
		psrTable = new IPX_STATIC_NETBIOS_NAME_INFO[pBlock->dwCount + 1];
		Assert(psrTable);
		
		// Copy the original table of Names
		::memcpy(psrTable, pBlock->pData,
				 pBlock->dwCount * sizeof(IPX_STATIC_NETBIOS_NAME_INFO));
		
		// Append the new name
		psrTable[pBlock->dwCount] = pSNEntryNew->m_name;
		
		// Replace the old name-table with the new one
		CORg( pInfoBase->SetData(IPX_STATIC_NETBIOS_NAME_INFO_TYPE,
								 sizeof(IPX_STATIC_NETBIOS_NAME_INFO),
								 (LPBYTE) psrTable, pBlock->dwCount + 1, 0) );
	}
	
Error:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxstaticnbname.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    ipxserviceprop.h
//
// History:
//	12/07/90	Deon Brewis             Created.
//
//	IPX Static Service property sheet and property pages
//
//============================================================================


#ifndef _NBPROP_H
#define _NBPROP_H

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _RTRSHEET_H
#include "rtrsheet.h"
#endif

#ifndef _SRVIEW_H
#include "snview.h"
#endif

// ---------------------------------------------------------------------------
//	Forward declarations
// ---------------------------------------------------------------------------
class IPXConnection;
class IpxStaticNBNamePropertySheet;


// ---------------------------------------------------------------------------
//	class:	SafeIPXSNListEntry
//
//  IpxSSListEntry is not thread safe or something else is wrong with the TFS
//  implementation of smart pointers. Anyway, it does not work in property pages. 
//  Grrr.... Had to change SPInterfaceInfo m_spIf to CComPtr<IInterfaceInfo>. 
//  It seems to work now.
//
//  Author: deonb
// ---------------------------------------------------------------------------
class SafeIPXSNListEntry
{
public:
	CComPtr<IInterfaceInfo>	m_spIf;
	IPX_STATIC_NETBIOS_NAME_INFO	m_name;
	
	void	LoadFrom(BaseIPXResultNodeData *pNodeData);
	void	SaveTo(BaseIPXResultNodeData *pNodeData);
};


// ---------------------------------------------------------------------------
//	class:	IpxStaticNBNamePropertyPage
//	This class handles the IPX Static Route properties
//
//  Author: deonb
// ---------------------------------------------------------------------------
class IpxStaticNBNamePropertyPage :
    public RtrPropertyPage
{
public:
	IpxStaticNBNamePropertyPage(UINT nIDTemplate, UINT nIDCaption = 0)
			: RtrPropertyPage(nIDTemplate, nIDCaption)
	{};

	~IpxStaticNBNamePropertyPage();

	HRESULT	Init(BaseIPXResultNodeData  *pNodeData,
				IpxStaticNBNamePropertySheet * pIPXPropSheet);

	HRESULT RemoveStaticNetBIOSName(SafeIPXSNListEntry *pSNEntry, IInfoBase *pInfo);
	HRESULT	ModifyNameInfo(ITFSNode *pNode,
							SafeIPXSNListEntry *pSNEntry,
							SafeIPXSNListEntry *pSNEntryOld);
protected:

	// Override the OnApply() so that we can grab our data from the
	// controls in the dialog.
	virtual BOOL OnApply();

	SafeIPXSNListEntry m_SNEntry;
	SafeIPXSNListEntry m_InitSNEntry;
	IpxStaticNBNamePropertySheet *m_pIPXPropSheet;

	//{{AFX_VIRTUAL(IpxStaticNBNamePropertyPage)
	protected:
	virtual VOID	DoDataExchange(CDataExchange *pDX);
	//}}AFX_VIRTUAL

	//{{AFX_DATA(IpxStaticNBNamePropertyPage)
	CSpinButtonCtrl		m_spinHopCount;
	//}}AFX_DATA

	//{{AFX_MSG(IpxStaticNBNamePropertyPage)
	virtual BOOL	OnInitDialog();
	//}}AFX_MSG
	
	//{{AFX_MSG(IpxStaticNBNamePropertyPage
	afx_msg	void	OnChangeButton();
	afx_msg void	OnInputFilters();
	afx_msg void	OnOutputFilters();
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};

// ---------------------------------------------------------------------------
//	Class:	IpxStaticNBNamePropertySheet
//
//	This is the property sheet support class for the properties page of
//	IPX Static Route items.
//
//  Author: deonb
//---------------------------------------------------------------------------
class IpxStaticNBNamePropertySheet :
	public RtrPropertySheet
{
public:
	IpxStaticNBNamePropertySheet(ITFSNode *pNode,
								 IComponentData *pComponentData,
								 ITFSComponentData *pTFSCompData,
								 LPCTSTR pszSheetName,
								 CWnd *pParent = NULL,
								 UINT iPage=0,
								 BOOL fScopePane = TRUE);

	HRESULT	Init(BaseIPXResultNodeData * pNodeData,
				 IInterfaceInfo * spInterfaceInfo);

	virtual BOOL SaveSheetData();
	virtual void CancelSheetData();

	BaseIPXResultNodeData *	m_pNodeData;

	CComPtr<IInterfaceInfo> m_spInterfaceInfo;
	CComPtr<ITFSNode>      m_spNode;
	
protected:
	IpxStaticNBNamePropertyPage	m_pageGeneral;
};

// ---------------------------------------------------------------------------
// AddStaticRoute function updated to use a SafeIPXSNListEntry
// ---------------------------------------------------------------------------
HRESULT AddStaticNetBIOSName(SafeIPXSNListEntry *pSNEntryNew,
									   IInfoBase *pInfoBase,
									   InfoBlock *pBlock);
#endif _NBPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxhelp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ipxhelp.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "ipxsnap.hm"
#include "resource.h"


//
// What follows is the data that gets generated from
//		mkdlg.exe -c ipxsnap.rc
//



// "File ipxsnap.rc line 87 : Resource - DIALOG : IDD_GENERIC_PROP_PAGE"
static const DWORD rgdw_IDD_GENERIC_PROP_PAGE[] = 
{
	0,0 
};


// "File ipxsnap.rc line 96 : Resource - DIALOG : IDD_IPX_GLOBAL_GENERAL_PAGE"
static const DWORD rgdw_IDD_IPX_GLOBAL_GENERAL_PAGE[] = 
{
    IDC_IGG_BTN_LOG_NONE, HIDC_IGG_BTN_LOG_NONE,
    IDC_IGG_BTN_LOG_ERRORS, HIDC_IGG_BTN_LOG_ERRORS,
    IDC_IGG_BTN_LOG_WARNINGS, HIDC_IGG_BTN_LOG_WARNINGS,
    IDC_IGG_BTN_LOG_INFO, HIDC_IGG_BTN_LOG_INFO,
	0,0 
};


// "File ipxsnap.rc line 119 : Resource - DIALOG : IDD_IPX_IF_GENERAL_PAGE"
static const DWORD rgdw_IDD_IPX_IF_GENERAL_PAGE[] = 
{
    IDC_IIG_BTN_ADMIN_STATE, HIDC_IIG_BTN_ADMIN_STATE,
    IDC_IIG_GRP_CONTROL_PROTOCOL, HIDC_IIG_GRP_CONTROL_PROTOCOL,
    IDC_IIG_BTN_IPX_CP, HIDC_IIG_BTN_IPX_CP,
    IDC_IIG_BTN_IPX_WAN, HIDC_IIG_BTN_IPX_WAN,
    IDC_IIG_BTN_INPUT_FILTERS, HIDC_IIG_BTN_INPUT_FILTERS,
    IDC_IIG_BTN_OUTPUT_FILTERS, HIDC_IIG_BTN_OUTPUT_FILTERS,
	0,0 
};


// "File ipxsnap.rc line 144 : Resource - DIALOG : IDD_IPX_NB_IF_GENERAL_PAGE"
static const DWORD rgdw_IDD_IPX_NB_IF_GENERAL_PAGE[] = 
{
    IDC_NIG_BTN_ACCEPT, HIDC_NIG_BTN_ACCEPT,
    IDC_NIG_BTN_DELIVER_ALWAYS, HIDC_NIG_BTN_DELIVER_ALWAYS,
    IDC_NIG_BTN_DELIVER_NEVER, HIDC_NIG_BTN_DELIVER_NEVER,
    IDC_NIG_BTN_DELIVER_STATIC, HIDC_NIG_BTN_DELIVER_STATIC,
    IDC_NIG_BTN_DELIVER_WHEN_UP, HIDC_NIG_BTN_DELIVER_WHEN_UP,
	0,0 
};


// "File ipxsnap.rc line 173 : Resource - DIALOG : IDD_STATIC_ROUTE"
static const DWORD rgdw_IDD_STATIC_ROUTE[] = 
{
    IDC_SRD_EDIT_NETWORK_NUMBER, HIDC_SRD_EDIT_NETWORK_NUMBER,
    IDC_SRD_EDIT_NEXT_HOP, HIDC_SRD_EDIT_NEXT_HOP,
    IDC_SRD_EDIT_TICK_COUNT, HIDC_SRD_EDIT_TICK_COUNT,
    IDC_SRD_SPIN_TICK_COUNT, HIDC_SRD_SPIN_TICK_COUNT,
    IDC_SRD_EDIT_HOP_COUNT, HIDC_SRD_EDIT_HOP_COUNT,
    IDC_SRD_SPIN_HOP_COUNT, HIDC_SRD_SPIN_HOP_COUNT,
    IDC_SRD_COMBO_INTERFACE, HIDC_SRD_COMBO_INTERFACE,
	0,0 
};


// "File ipxsnap.rc line 203 : Resource - DIALOG : IDD_STATIC_SERVICE"
static const DWORD rgdw_IDD_STATIC_SERVICE[] = 
{
    IDC_SSD_EDIT_SERVICE_TYPE, HIDC_SSD_EDIT_SERVICE_TYPE,
    IDC_SSD_EDIT_SERVICE_NAME, HIDC_SSD_EDIT_SERVICE_NAME,
    IDC_SSD_EDIT_NETWORK_ADDRESS, HIDC_SSD_EDIT_NETWORK_ADDRESS,
    IDC_SSD_EDIT_NODE_ADDRESS, HIDC_SSD_EDIT_NODE_ADDRESS,
    IDC_SSD_EDIT_SOCKET_ADDRESS, HIDC_SSD_EDIT_SOCKET_ADDRESS,
    IDC_SSD_EDIT_HOP_COUNT, HIDC_SSD_EDIT_HOP_COUNT,
    IDC_SSD_SPIN_HOP_COUNT, HIDC_SSD_SPIN_HOP_COUNT,
    IDC_SSD_COMBO_INTERFACE, HIDC_SSD_COMBO_INTERFACE,
	0,0 
};


// "File ipxsnap.rc line 233 : Resource - DIALOG : IDD_STATIC_NETBIOS_NAME"
static const DWORD rgdw_IDD_STATIC_NETBIOS_NAME[] = 
{
    IDC_SND_EDIT_NAME, HIDC_SND_EDIT_NAME,
    IDC_SND_EDIT_TYPE, HIDC_SND_EDIT_TYPE,
    IDC_SND_COMBO_INTERFACE, HIDC_SND_COMBO_INTERFACE,
	0,0 
};


// "File ipxsnap.rc line 252 : Resource - DIALOG : IDD_RIP_GLOBAL_GENERAL_PAGE"
static const DWORD rgdw_IDD_RIP_GLOBAL_GENERAL_PAGE[] = 
{
    IDC_RGG_BTN_LOG_ERROR, HIDC_RGG_BTN_LOG_ERROR,
    IDC_RGG_BTN_LOG_WARN, HIDC_RGG_BTN_LOG_WARN,
    IDC_RGG_BTN_LOG_INFO, HIDC_RGG_BTN_LOG_INFO,
    IDC_RGG_BTN_LOG_NONE, HIDC_RGG_BTN_LOG_NONE,
	0,0 
};


// "File ipxsnap.rc line 275 : Resource - DIALOG : IDD_RIP_INTERFACE_GENERAL_PAGE"
static const DWORD rgdw_IDD_RIP_INTERFACE_GENERAL_PAGE[] = 
{
    IDC_RIG_BTN_ADMIN_STATE, HIDC_RIG_BTN_ADMIN_STATE,
    IDC_RIG_BTN_ADVERTISE_ROUTES, HIDC_RIG_BTN_ADVERTISE_ROUTES,
    IDC_RIG_BTN_ACCEPT_ROUTE_ADS, HIDC_RIG_BTN_ACCEPT_ROUTE_ADS,
    IDC_RIG_BTN_UPDATE_MODE_STANDARD, HIDC_RIG_BTN_UPDATE_MODE_STANDARD,
    IDC_RIG_BTN_UPDATE_MODE_NONE, HIDC_RIG_BTN_UPDATE_MODE_NONE,
    IDC_RIG_BTN_UPDATE_MODE_AUTOSTATIC, HIDC_RIG_BTN_UPDATE_MODE_AUTOSTATIC,
    IDC_RIG_EDIT_INTERVAL, HIDC_RIG_EDIT_INTERVAL,
    IDC_RIG_SPIN_INTERVAL, HIDC_RIG_SPIN_INTERVAL,
    IDC_RIG_EDIT_MULTIPLIER, HIDC_RIG_EDIT_MULTIPLIER,
    IDC_RIG_SPIN_MULTIPLIER, HIDC_RIG_SPIN_MULTIPLIER,
    IDC_RIG_BTN_INPUT_FILTERS, HIDC_RIG_BTN_INPUT_FILTERS,
    IDC_RIG_BTN_OUTPUT_FILTERS, HIDC_RIG_BTN_OUTPUT_FILTERS,
	0,0 
};


// "File ipxsnap.rc line 319 : Resource - DIALOG : IDD_SAP_GLOBAL_GENERAL_PAGE"
static const DWORD rgdw_IDD_SAP_GLOBAL_GENERAL_PAGE[] = 
{
    IDC_SGG_BTN_LOG_NONE, HIDC_SGG_BTN_LOG_NONE,
    IDC_SGG_BTN_LOG_ERROR, HIDC_SGG_BTN_LOG_ERROR,
    IDC_SGG_BTN_LOG_WARN, HIDC_SGG_BTN_LOG_WARN,
    IDC_SGG_BTN_LOG_INFO, HIDC_SGG_BTN_LOG_INFO,
	0,0 
};


// "File ipxsnap.rc line 341 : Resource - DIALOG : IDD_SAP_INTERFACE_GENERAL_PAGE"
static const DWORD rgdw_IDD_SAP_INTERFACE_GENERAL_PAGE[] = 
{
    IDC_SIG_BTN_ADMIN_STATE, HIDC_SIG_BTN_ADMIN_STATE,
    IDC_SIG_BTN_ADVERTISE_SERVICES, HIDC_SIG_BTN_ADVERTISE_SERVICES,
    IDC_SIG_BTN_ACCEPT_SERVICE_ADS, HIDC_SIG_BTN_ACCEPT_SERVICE_ADS,
    IDC_SIG_BTN_REPLY_GNS_REQUESTS, HIDC_SIG_BTN_REPLY_GNS_REQUESTS,
    IDC_SIG_BTN_UPDATE_MODE_STANDARD, HIDC_SIG_BTN_UPDATE_MODE_STANDARD,
    IDC_SIG_BTN_UPDATE_MODE_NONE, HIDC_SIG_BTN_UPDATE_MODE_NONE,
    IDC_SIG_BTN_UPDATE_MODE_AUTOSTATIC, HIDC_SIG_BTN_UPDATE_MODE_AUTOSTATIC,
    IDC_SIG_EDIT_INTERVAL, HIDC_SIG_EDIT_INTERVAL,
    IDC_SIG_SPIN_INTERVAL, HIDC_SIG_SPIN_INTERVAL,
    IDC_SIG_EDIT_MULTIPLIER, HIDC_SIG_EDIT_MULTIPLIER,
    IDC_SIG_SPIN_MULTIPLIER, HIDC_SIG_SPIN_MULTIPLIER,
    IDC_SIG_BTN_INPUT_FILTERS, HIDC_SIG_BTN_INPUT_FILTERS,
    IDC_SIG_BTN_OUTPUT_FILTERS, HIDC_SIG_BTN_OUTPUT_FILTERS,
	0,0 
};


// "File ipxsnap.rc line 390 : Resource - DIALOG : IDD_IPX_IF_CONFIG_PAGE"
static const DWORD rgdw_IDD_IPX_IF_CONFIG_PAGE[] = 
{
    IDC_IIC_EDIT_NETNUMBER, HIDC_IIC_EDIT_NETNUMBER,
	0,0 
};


// "File ipxsnap.rc line 401 : Resource - DIALOG : IDD_ROUTE_FILTERS_INPUT and IDD_ROUTE_FILTERS_OUTPUT"
static const DWORD rgdw_IDD_ROUTE_FILTERS[] = 
{
    IDC_RFS_BTN_DENY, HIDC_RFS_BTN_DENY,
    IDC_RFS_BTN_PERMIT, HIDC_RFS_BTN_PERMIT,
    IDC_RFS_LIST, HIDC_RFS_LIST,
    IDC_RFS_BTN_ADD, HIDC_RFS_BTN_ADD,
    IDC_RFS_BTN_EDIT, HIDC_RFS_BTN_EDIT,
    IDC_RFS_BTN_DELETE, HIDC_RFS_BTN_DELETE,
	0,0 
};


// "File ipxsnap.rc line 425 : Resource - DIALOG : IDD_ROUTE_FILTER"
static const DWORD rgdw_IDD_ROUTE_FILTER[] = 
{
    IDC_RF_TEXT_INTERFACE, HIDC_RF_TEXT_INTERFACE,
    IDC_RF_EDIT_INTERFACE, HIDC_RF_EDIT_INTERFACE,
    IDC_RF_EDIT_NETWORK, HIDC_RF_EDIT_NETWORK,
    IDC_RF_EDIT_NETMASK, HIDC_RF_EDIT_NETMASK,
	0,0 
};


// "File ipxsnap.rc line 443 : Resource - DIALOG : IDD_SERVICE_FILTER"
static const DWORD rgdw_IDD_SERVICE_FILTER[] = 
{
    IDC_SF_TEXT_INTERFACE, HIDC_SF_TEXT_INTERFACE,
    IDC_SF_EDIT_INTERFACE, HIDC_SF_EDIT_INTERFACE,
    IDC_SF_EDIT_SERVICE_TYPE, HIDC_SF_EDIT_SERVICE_TYPE,
    IDC_SF_EDIT_SERVICE_NAME, HIDC_SF_EDIT_SERVICE_NAME,
	0,0 
};


// "File ipxsnap.rc line 461 : Resource - DIALOG : IDD_SERVICE_FILTERS"
static const DWORD rgdw_IDD_SERVICE_FILTERS[] = 
{
    IDC_SFS_BTN_DENY, HIDC_SFS_BTN_DENY,
    IDC_SFS_BTN_PERMIT, HIDC_SFS_BTN_PERMIT,
    IDC_SFS_LIST, HIDC_SFS_LIST,
    IDC_SFS_BTN_ADD, HIDC_SFS_BTN_ADD,
    IDC_SFS_BTN_EDIT, HIDC_SFS_BTN_EDIT,
    IDC_SFS_BTN_DELETE, HIDC_SFS_BTN_DELETE,
	0,0 
};


//
// End of mkdlg.exe output
//

// This is similar to IDD_STATIC_ROUTE, so I'll use the same helps
static const DWORD rgdw_IDD_STATIC_ROUTE_PROPERTYPAGE[] = 
{
    IDC_SRD_EDIT_NETWORK_NUMBER, HIDC_SRD_EDIT_NETWORK_NUMBER,
    IDC_SRD_EDIT_NEXT_HOP, HIDC_SRD_EDIT_NEXT_HOP,
    IDC_SRD_EDIT_TICK_COUNT, HIDC_SRD_EDIT_TICK_COUNT,
    IDC_SRD_SPIN_TICK_COUNT, HIDC_SRD_SPIN_TICK_COUNT,
    IDC_SRD_EDIT_HOP_COUNT, HIDC_SRD_EDIT_HOP_COUNT,
    IDC_SRD_SPIN_HOP_COUNT, HIDC_SRD_SPIN_HOP_COUNT,
	0,0
};

// This is similar to IDD_STATIC_NETBIOS_NAME, so I'll use the same helps
static const DWORD rgdw_IDD_STATIC_NETBIOS_NAME_PROPERTYPAGE[] = 
{
    IDC_SND_EDIT_NAME, HIDC_SND_EDIT_NAME,
    IDC_SND_EDIT_TYPE, HIDC_SND_EDIT_TYPE,
	0,0
};

// Have to include the dialogs in common
#include "commhelp.cpp"


static BOOL				s_fInitHelpMap = FALSE;
static CMapWordToPtr	s_IDDHelpMap;
void InitHelpMap();

DWORD *	IpxSnapHelpMap(DWORD dwIDD)
{
	LPVOID	pvHelpMap = NULL;
	
	if (!s_fInitHelpMap)
	{
		InitHelpMap();
		s_fInitHelpMap = TRUE;
	}

	// Look in the help map
	s_IDDHelpMap.Lookup((SHORT) dwIDD, pvHelpMap);
	return (DWORD *) pvHelpMap;
}

void InitHelpMap()
{
	s_IDDHelpMap.SetAt(IDD_IPX_GLOBAL_GENERAL_PAGE, (LPVOID) rgdw_IDD_IPX_GLOBAL_GENERAL_PAGE);
	s_IDDHelpMap.SetAt(IDD_IPX_IF_GENERAL_PAGE, (LPVOID) rgdw_IDD_IPX_IF_GENERAL_PAGE);
	s_IDDHelpMap.SetAt(IDD_IPX_NB_IF_GENERAL_PAGE, (LPVOID) rgdw_IDD_IPX_NB_IF_GENERAL_PAGE);
	s_IDDHelpMap.SetAt(IDD_STATIC_ROUTE, (LPVOID) rgdw_IDD_STATIC_ROUTE);
	s_IDDHelpMap.SetAt(IDD_STATIC_SERVICE, (LPVOID) rgdw_IDD_STATIC_SERVICE);
	s_IDDHelpMap.SetAt(IDD_STATIC_NETBIOS_NAME, (LPVOID) rgdw_IDD_STATIC_NETBIOS_NAME);
	s_IDDHelpMap.SetAt(IDD_RIP_GLOBAL_GENERAL_PAGE, (LPVOID) rgdw_IDD_RIP_GLOBAL_GENERAL_PAGE);
	s_IDDHelpMap.SetAt(IDD_RIP_INTERFACE_GENERAL_PAGE, (LPVOID) rgdw_IDD_RIP_INTERFACE_GENERAL_PAGE);
	s_IDDHelpMap.SetAt(IDD_SAP_GLOBAL_GENERAL_PAGE, (LPVOID) rgdw_IDD_SAP_GLOBAL_GENERAL_PAGE);
	s_IDDHelpMap.SetAt(IDD_SAP_INTERFACE_GENERAL_PAGE, (LPVOID) rgdw_IDD_SAP_INTERFACE_GENERAL_PAGE);
	s_IDDHelpMap.SetAt(IDD_IPX_IF_CONFIG_PAGE, (LPVOID) rgdw_IDD_IPX_IF_CONFIG_PAGE);
	
	s_IDDHelpMap.SetAt(IDD_ROUTE_FILTERS_INPUT, (LPVOID) rgdw_IDD_ROUTE_FILTERS);
	s_IDDHelpMap.SetAt(IDD_ROUTE_FILTERS_OUTPUT, (LPVOID) rgdw_IDD_ROUTE_FILTERS);

	s_IDDHelpMap.SetAt(IDD_ROUTE_FILTER, (LPVOID) rgdw_IDD_ROUTE_FILTER);
	s_IDDHelpMap.SetAt(IDD_SERVICE_FILTER, (LPVOID) rgdw_IDD_SERVICE_FILTER);
	s_IDDHelpMap.SetAt(IDD_SERVICE_FILTERS_INPUT, (LPVOID) rgdw_IDD_SERVICE_FILTERS);
	s_IDDHelpMap.SetAt(IDD_SERVICE_FILTERS_OUTPUT, (LPVOID) rgdw_IDD_SERVICE_FILTERS);
	s_IDDHelpMap.SetAt(IDD_STATIC_ROUTE_PROPERTYPAGE, (LPVOID) rgdw_IDD_STATIC_ROUTE_PROPERTYPAGE);
	s_IDDHelpMap.SetAt(IDD_STATIC_NETBIOS_NAME_PROPERTYPAGE, (LPVOID) rgdw_IDD_STATIC_NETBIOS_NAME_PROPERTYPAGE);

    // Include the entries for common
    s_IDDHelpMap.SetAt(IDD_STATS, (LPVOID) rgdw_IDD_STATS);
    s_IDDHelpMap.SetAt(IDD_STATS_NARROW, (LPVOID) rgdw_IDD_STATS_NARROW);
    s_IDDHelpMap.SetAt(IDD_COMMON_SELECT_COLUMNS, (LPVOID) rgdw_IDD_COMMON_SELECT_COLUMNS);
    s_IDDHelpMap.SetAt(IDD_BUSY, (LPVOID) rgdw_IDD_BUSY);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxsnap.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	rtrsnap.cpp
		Snapin entry points/registration functions
		
		Note: Proxy/Stub Information
			To build a separate proxy/stub DLL, 
			run nmake -f Snapinps.mak in the project directory.

	FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ipxcomp.h"
#include "ripcomp.h"
#include "sapcomp.h"
#include "register.h"
#include "ipxguid.h"
#include "dialog.h"


#ifdef _DEBUG
void DbgVerifyInstanceCounts();
#define DEBUG_VERIFY_INSTANCE_COUNTS DbgVerifyInstanceCounts()
#else
#define DEBUG_VERIFY_INSTANCE_COUNTS
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_IPXAdminExtension, CIPXComponentDataExtension)
	OBJECT_ENTRY(CLSID_IPXAdminAbout, CIPXAbout)
	OBJECT_ENTRY(CLSID_IPXRipExtension, CRipComponentData)
	OBJECT_ENTRY(CLSID_IPXRipExtensionAbout, CRipAbout)
	OBJECT_ENTRY(CLSID_IPXSapExtension, CSapComponentData)
	OBJECT_ENTRY(CLSID_IPXSapExtensionAbout, CSapAbout)
END_OBJECT_MAP()


/*---------------------------------------------------------------------------
	This is a list of snapins to be registered into the main snapin list.
 ---------------------------------------------------------------------------*/
struct RegisteredSnapins
{
	const GUID *	m_pGuid;
	const GUID *	m_pGuidAbout;
	UINT			m_uDesc;
	LPCTSTR			m_pszVersion;
};

const static RegisteredSnapins	s_rgRegisteredSnapins[] =
{
	{ &CLSID_IPXAdminExtension, &CLSID_IPXAdminAbout,
			IDS_IPXADMIN_DISPLAY_NAME, _T("1.0") },
	{ &CLSID_IPXRipExtension, &CLSID_IPXRipExtensionAbout,
			IDS_IPXRIP_DISPLAY_NAME, _T("1.0") },
	{ &CLSID_IPXSapExtension, &CLSID_IPXSapExtensionAbout,
			IDS_IPXSAP_DISPLAY_NAME, _T("1.0") },
};
			

/*---------------------------------------------------------------------------
	This is a list of nodetypes that need to be registered.
 ---------------------------------------------------------------------------*/

struct RegisteredNodeTypes
{
	const GUID *m_pGuidSnapin;
	const GUID *m_pGuid;
	LPCTSTR		m_pszName;
};

const static RegisteredNodeTypes s_rgNodeTypes[] =
	{
	{ &CLSID_IPXAdminExtension, &GUID_IPXRootNodeType,
			_T("Root of IPX Admin Snapin") },
	{ &CLSID_IPXAdminExtension, &GUID_IPXNodeType,
			_T("IPX Admin Snapin") },
	{ &CLSID_IPXAdminExtension, &GUID_IPXSummaryNodeType,
			_T("IPX General") },
	{ &CLSID_IPXAdminExtension, &GUID_IPXSummaryInterfaceNodeType,
			_T("IPX Interface General") },
	{ &CLSID_IPXAdminExtension, &GUID_IPXNetBIOSBroadcastsNodeType,
			_T("IPX NetBIOS Broadcasts") },
	{ &CLSID_IPXAdminExtension, &GUID_IPXNetBIOSBroadcastsInterfaceNodeType,
			_T("IPX Interface NetBIOS Broadcasts") },
	{ &CLSID_IPXAdminExtension, &GUID_IPXStaticRoutesNodeType,
			_T("IPX Static Routes") },
	{ &CLSID_IPXAdminExtension, &GUID_IPXStaticRoutesResultNodeType,
			_T("IPX Static Routes result item") },
	{ &CLSID_IPXAdminExtension, &GUID_IPXStaticServicesNodeType,
			_T("IPX Static Services") },
	{ &CLSID_IPXAdminExtension, &GUID_IPXStaticServicesResultNodeType,
			_T("IPX Static Services result item") },
	{ &CLSID_IPXAdminExtension, &GUID_IPXStaticNetBIOSNamesNodeType,
			_T("IPX Static NetBIOS Names") },
	{ &CLSID_IPXAdminExtension, &GUID_IPXStaticNetBIOSNamesResultNodeType,
			_T("IPX Static NetBIOS Names result item") },
	{ &CLSID_IPXRipExtension, &GUID_IPXRipNodeType,
			_T("IPX RIP") },
	{ &CLSID_IPXSapExtension, &GUID_IPXSapNodeType,
			_T("IPX SAP") },
	};

/*---------------------------------------------------------------------------
	This is a list of GUIDs that the IPX admin extension extends.
 ---------------------------------------------------------------------------*/
const static GUID *	s_pExtensionGuids[] =
{
//	&GUID_RouterIfAdminNodeType,
	&GUID_RouterMachineNodeType,
};


/*---------------------------------------------------------------------------
	This is a list of GUIDS that extend the IPX root node
 ---------------------------------------------------------------------------*/


struct RegisteredExtensions
{
	const CLSID *m_pClsid;
	LPCTSTR		m_pszName;
};

const static RegisteredExtensions s_rgIPXExtensions[] =
{
	{ &CLSID_IPXRipExtension, _T("IPX RIP") },
	{ &CLSID_IPXSapExtension, _T("IPX SAP") },
};



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

class CIPXAdminSnapinApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CIPXAdminSnapinApp theApp;

BOOL CIPXAdminSnapinApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);

	// Initialize the error handling system
	InitializeTFSError();
	
	// Create an error object for this thread
	CreateTFSErrorInfo(0);

	// Setup the proper help file
	free((void *) m_pszHelpFilePath);
	m_pszHelpFilePath = _tcsdup(_T("mprsnap.hlp"));
	
	// Setup the global help function
	extern DWORD * IpxSnapHelpMap(DWORD dwIDD);
	SetGlobalHelpMapFunction(IpxSnapHelpMap);
   
	return CWinApp::InitInstance();
}

int CIPXAdminSnapinApp::ExitInstance()
{
	_Module.Term();

	// Destroy the TFS error information for this thread
	DestroyTFSErrorInfo(0);

	// Cleanup the entire error system
	CleanupTFSError();

	DEBUG_VERIFY_INSTANCE_COUNTS;

	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	int			i;
	CString		st;
	CString		stNameStringIndirect;
	
	TCHAR	moduleFileName[MAX_PATH * 2];

   GetModuleFileNameOnly(_Module.GetModuleInstance(), moduleFileName, MAX_PATH * 2);
	// registers object, typelib and all interfaces in typelib
	//
	HRESULT hr = _Module.RegisterServer(/* bRegTypeLib */ FALSE);
	Assert(SUCCEEDED(hr));
	
	if (FAILED(hr))
		return hr;

	// Register he extension snapins into the snapin list.
	for (i=0; i<DimensionOf(s_rgRegisteredSnapins); i++)
	{
		st.LoadString(s_rgRegisteredSnapins[i].m_uDesc);
		stNameStringIndirect.Format(L"@%s,-%-d", moduleFileName, s_rgRegisteredSnapins[i].m_uDesc);

		hr = RegisterSnapinGUID(s_rgRegisteredSnapins[i].m_pGuid,
								NULL,
								s_rgRegisteredSnapins[i].m_pGuidAbout,
								st,
								s_rgRegisteredSnapins[i].m_pszVersion,
								FALSE,
								stNameStringIndirect);
		Assert(SUCCEEDED(hr));

		// It would be REALLY bad if any one of these fails
		if (!FHrSucceeded(hr))
			break;
	}
	
	if (FAILED(hr))
		return hr;

	// register the snapin nodes into the console node list
	//
	for (i=0; i<DimensionOf(s_rgNodeTypes); i++)
	{
		hr = RegisterNodeTypeGUID(s_rgNodeTypes[i].m_pGuidSnapin,
								  s_rgNodeTypes[i].m_pGuid,
								  s_rgNodeTypes[i].m_pszName);
		Assert(SUCCEEDED(hr));
	}
	
	//
	// register as an extension of the router machine node extension
	//
	for (i=0; i<DimensionOf(s_pExtensionGuids); i++)
	{
		hr = RegisterAsRequiredExtensionGUID(s_pExtensionGuids[i],
								 &CLSID_IPXAdminExtension,
								 _T("Routing IPX Admin extension"),
								 EXTENSION_TYPE_NAMESPACE,
								 &CLSID_RouterSnapin);
		Assert(SUCCEEDED(hr));
	}

	for (i=0; i<DimensionOf(s_rgIPXExtensions); i++)
	{
		hr = RegisterAsRequiredExtensionGUID(&GUID_IPXNodeType,
								s_rgIPXExtensions[i].m_pClsid,
								s_rgIPXExtensions[i].m_pszName,
								EXTENSION_TYPE_NAMESPACE,
								&CLSID_IPXAdminExtension);
		Assert(SUCCEEDED(hr));
	}

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	int		i;
	HRESULT hr  = _Module.UnregisterServer();
	Assert(SUCCEEDED(hr));
	
	if (FAILED(hr))
		return hr;
	
	// unregister the snapin nodes 
	//
	for (i=0; i<DimensionOf(s_pExtensionGuids); i++)
	{
		hr = UnregisterAsRequiredExtensionGUID(s_pExtensionGuids[i],
											   &CLSID_IPXAdminExtension, 
											   EXTENSION_TYPE_NAMESPACE,
											   &CLSID_RouterSnapin);
		Assert(SUCCEEDED(hr));
	}
	
	for (i=0; i<DimensionOf(s_rgIPXExtensions); i++)
	{
		hr = UnregisterAsRequiredExtensionGUID(&GUID_IPXNodeType,
								s_rgIPXExtensions[i].m_pClsid,
								EXTENSION_TYPE_NAMESPACE,
								&CLSID_IPXAdminExtension);
		Assert(SUCCEEDED(hr));
	}

	for (i=0; i<DimensionOf(s_rgNodeTypes); i++)
	{
		hr = UnregisterNodeTypeGUID(s_rgNodeTypes[i].m_pGuid);
		Assert(SUCCEEDED(hr));
	}

	// un register the snapin 
	//
	for (i=0; i<DimensionOf(s_rgRegisteredSnapins); i++)
	{
		hr = UnregisterSnapinGUID(s_rgRegisteredSnapins[i].m_pGuid);
		Assert(SUCCEEDED(hr));
	}
	
	return hr;
}

#ifdef _DEBUG
void DbgVerifyInstanceCounts()
{
	DEBUG_VERIFY_INSTANCE_COUNT(BaseIPXResultHandler);
	DEBUG_VERIFY_INSTANCE_COUNT(IPXAdminNodeHandler);
	DEBUG_VERIFY_INSTANCE_COUNT(IPXConnection);
	DEBUG_VERIFY_INSTANCE_COUNT(IpxInfoStatistics);
	DEBUG_VERIFY_INSTANCE_COUNT(IPXRootHandler);
	DEBUG_VERIFY_INSTANCE_COUNT(IpxSRHandler);
	DEBUG_VERIFY_INSTANCE_COUNT(RootHandler);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxstaticroute.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    ipxstaticroute.h
//
// History:
//	12/07/90	Deon Brewis             Created.
//
//	IPX Static Routes property sheet and property pages
//
//============================================================================


#ifndef _NBPROP_H
#define _NBPROP_H

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _RTRSHEET_H
#include "rtrsheet.h"
#endif

#ifndef _SRVIEW_H
#include "srview.h"
#endif

// ---------------------------------------------------------------------------
//	Forward declarations
// ---------------------------------------------------------------------------
class IPXConnection;
class IpxStaticRoutePropertySheet;


// ---------------------------------------------------------------------------
//	class:	SafeIPXSRListEntry
//
//  IpxSRListEntry is not thread safe or something else is wrong with the TFS
//  implementation of smart pointers. Anyway, it does not work in property pages. 
//  Grrr.... Had to change SPInterfaceInfo m_spIf to CComPtr<IInterfaceInfo>. 
//  It seems to work now.
//
//  Author: deonb
// ---------------------------------------------------------------------------
class SafeIPXSRListEntry
{
public:
	CComPtr<IInterfaceInfo>	m_spIf;
	IPX_STATIC_ROUTE_INFO	m_route;
	
	void	LoadFrom(BaseIPXResultNodeData *pNodeData);
	void	SaveTo(BaseIPXResultNodeData *pNodeData);
};

// ---------------------------------------------------------------------------
//	class:	IpxStaticRoutePropertyPage
//	This class handles the IPX Static Route properties
//
//  Author: deonb
// ---------------------------------------------------------------------------
class IpxStaticRoutePropertyPage :
    public RtrPropertyPage
{
public:
	IpxStaticRoutePropertyPage(UINT nIDTemplate, UINT nIDCaption = 0)
			: RtrPropertyPage(nIDTemplate, nIDCaption)
	{};

	~IpxStaticRoutePropertyPage();

	HRESULT	Init(BaseIPXResultNodeData  *pNodeData,
				IpxStaticRoutePropertySheet * pIPXPropSheet);

	HRESULT ModifyRouteInfo(ITFSNode *pNode,
										SafeIPXSRListEntry *pSREntryNew,
										SafeIPXSRListEntry *pSREntryOld);

	HRESULT RemoveStaticRoute(SafeIPXSRListEntry *pSREntry, IInfoBase *pInfoBase);

protected:

	// Override the OnApply() so that we can grab our data from the
	// controls in the dialog.
	virtual BOOL OnApply();

	SafeIPXSRListEntry m_SREntry;
	SafeIPXSRListEntry m_InitSREntry;
	IpxStaticRoutePropertySheet *m_pIPXPropSheet;

	//{{AFX_VIRTUAL(IpxStaticRoutePropertyPage)
	protected:
	virtual VOID	DoDataExchange(CDataExchange *pDX);
	//}}AFX_VIRTUAL

	//{{AFX_DATA(IpxStaticRoutePropertyPage)
	CSpinButtonCtrl		m_spinTickCount;
	CSpinButtonCtrl		m_spinHopCount;
	//}}AFX_DATA

	//{{AFX_MSG(IpxStaticRoutePropertyPage)
	virtual BOOL	OnInitDialog();
	//}}AFX_MSG
	
	//{{AFX_MSG(IpxStaticRoutePropertyPage
	afx_msg	void	OnChangeButton();
	afx_msg void	OnInputFilters();
	afx_msg void	OnOutputFilters();
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};

// ---------------------------------------------------------------------------
//	Class:	IpxStaticRoutePropertySheet
//
//	This is the property sheet support class for the properties page of
//	IPX Static Route items.
//
//  Author: deonb
//---------------------------------------------------------------------------
class IpxStaticRoutePropertySheet :
	public RtrPropertySheet
{
public:
	IpxStaticRoutePropertySheet(ITFSNode *pNode,
								 IComponentData *pComponentData,
								 ITFSComponentData *pTFSCompData,
								 LPCTSTR pszSheetName,
								 CWnd *pParent = NULL,
								 UINT iPage=0,
								 BOOL fScopePane = TRUE);

	HRESULT	Init(BaseIPXResultNodeData * pNodeData,
				 IInterfaceInfo * spInterfaceInfo);

	virtual BOOL SaveSheetData();
	virtual void CancelSheetData();

	BaseIPXResultNodeData *	m_pNodeData;

	CComPtr<IInterfaceInfo> m_spInterfaceInfo;
	CComPtr<ITFSNode>      m_spNode;
	
protected:
	IpxStaticRoutePropertyPage	m_pageGeneral;
};

// ---------------------------------------------------------------------------
// AddStaticRoute function updated to use a SafeIPXSRListEntry
// ---------------------------------------------------------------------------
HRESULT AddStaticRoute(SafeIPXSRListEntry *pSREntryNew,
									   IInfoBase *pInfoBase,
									   InfoBlock *pBlock);	

#endif _NBPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxstaticroute.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999   **/
/**********************************************************************/

//
//	nbprop.cpp
//		IPX summary node property sheet and property pages
//		
//  FILE HISTORY:


#include "stdafx.h"
#include "rtrutil.h"	// smart MPR handle pointers
#include "format.h"		// FormatNumber function
#include "ipxstaticroute.h"
#include "summary.h"
#include "ipxrtdef.h"
#include "filter.h"
#include "ipxutil.h"

extern "C"
{
#include "routprot.h"
};

// ---------------------------------------------------------------------------
//	IpxStaticRoutePropertySheet::IpxStaticRoutePropertySheet
//	Initialize the RtrPropertySheet and only Property Page.
//	Author: Deonb
// ---------------------------------------------------------------------------
IpxStaticRoutePropertySheet::IpxStaticRoutePropertySheet(ITFSNode *pNode,
								 IComponentData *pComponentData,
								 ITFSComponentData *pTFSCompData,
								 LPCTSTR pszSheetName,
								 CWnd *pParent,
								 UINT iPage,
								 BOOL fScopePane)
	: RtrPropertySheet(pNode, pComponentData, pTFSCompData, 
					   pszSheetName, pParent, iPage, fScopePane),
		m_pageGeneral(IDD_STATIC_ROUTE_PROPERTYPAGE)
{
	m_spNode = pNode;
}

// ---------------------------------------------------------------------------
//	IpxStaticRoutePropertySheet::Init
//	Initialize the property sheets.  The general action here will be
//		to initialize/add the various pages.
//	Author: Deonb
// ---------------------------------------------------------------------------
HRESULT	IpxStaticRoutePropertySheet::Init(	
 		 	 BaseIPXResultNodeData  *pNodeData,
			 IInterfaceInfo *  spInterfaceInfo)
{
	HRESULT	hr = hrOK;

	BaseIPXResultNodeData *	pData;

	m_pNodeData = pNodeData;
	m_spInterfaceInfo = spInterfaceInfo;

	pData = GET_BASEIPXRESULT_NODEDATA(m_spNode);
	ASSERT_BASEIPXRESULT_NODEDATA(pData);

	// The pages are embedded members of the class
	// do not delete them.
	m_bAutoDeletePages = FALSE;
	
	m_pageGeneral.Init(pNodeData, this);
	AddPageToList((CPropertyPageBase*) &m_pageGeneral);

	return S_OK;
}

// ---------------------------------------------------------------------------
//	IpxStaticRoutePropertySheet::SaveSheetData
//	Not sure what this does - this is never called. Kenn had this so I'll just
//		copy this too.
//	Author: Deonb
// ---------------------------------------------------------------------------
BOOL IpxStaticRoutePropertySheet::SaveSheetData()
{
    SPITFSNodeHandler	spHandler;
    SPITFSNode			spParent;
    
	// By this time each page should have written its information out
	// to the infobase

    // Force the node to do a resync
    m_spNode->GetParent(&spParent);
    spParent->GetHandler(&spHandler);
    spHandler->OnCommand(spParent, IDS_MENU_SYNC, CCT_RESULT,
                         NULL, 0);
		
	return TRUE;
}

// --------------------------------------------------------------------------
//	IpxStaticRoutePropertySheet::CancelSheetData
//		-
//	Author: Deonb
// ---------------------------------------------------------------------------
void IpxStaticRoutePropertySheet::CancelSheetData()
{
}

// ***************************************************************************
// ---------------------------------------------------------------------------
//	IpxStaticRoutePropertyPage
// ---------------------------------------------------------------------------
IpxStaticRoutePropertyPage::~IpxStaticRoutePropertyPage()
{
}

BEGIN_MESSAGE_MAP(IpxStaticRoutePropertyPage, RtrPropertyPage)
    //{{AFX_MSG_MAP(IpxStaticRoutePropertyPage)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void IpxStaticRoutePropertyPage::OnChangeButton()
{
	SetDirty(TRUE);
	SetModified();
}

//--------------------------------------------------------------------------
//	IpxStaticRoutePropertyPage::Init
//		-
//	Author: Deonb
//---------------------------------------------------------------------------
HRESULT	IpxStaticRoutePropertyPage::Init(BaseIPXResultNodeData  *pNodeData,
				IpxStaticRoutePropertySheet * pIPXPropSheet)

{
	ATLASSERT(pSREntry);
	ATLASSERT(pIPXPropSheet);
	
	m_pIPXPropSheet = pIPXPropSheet;

	m_SREntry.LoadFrom(pNodeData);
	m_InitSREntry = m_SREntry;
	
	return hrOK;
}

// --------------------------------------------------------------------------
//	IpxStaticRoutePropertyPage::OnInitDialog
//		-
//	Author: Deonb
// ---------------------------------------------------------------------------
BOOL IpxStaticRoutePropertyPage::OnInitDialog()
{
	HRESULT	hr = hrOK;
	PBYTE	pData;
	DWORD		dwIfType;
	UINT		iButton;

	RtrPropertyPage::OnInitDialog();
	
	m_spinHopCount.SetRange(0, 15);
	m_spinHopCount.SetBuddy(GetDlgItem(IDC_SRD_EDIT_HOP_COUNT));
	
	m_spinTickCount.SetRange(0, UD_MAXVAL);
	m_spinTickCount.SetBuddy(GetDlgItem(IDC_SRD_EDIT_TICK_COUNT));

	((CEdit *) GetDlgItem(IDC_SRD_EDIT_NETWORK_NUMBER))->LimitText(8);
	((CEdit *) GetDlgItem(IDC_SRD_EDIT_NEXT_HOP))->LimitText(12);

	GetDlgItem(IDC_SRD_EDIT_NETWORK_NUMBER)->EnableWindow(FALSE);
	GetDlgItem(IDC_SRD_EDIT_NEXT_HOP)->EnableWindow(FALSE);

    // A route to be edited was given, so initialize the controls
	TCHAR	szNumber[32];
	FormatIpxNetworkNumber(szNumber,
						   DimensionOf(szNumber),
						   m_SREntry.m_route.Network,
						   sizeof(m_SREntry.m_route.Network));
	SetDlgItemText(IDC_SRD_EDIT_NETWORK_NUMBER, szNumber);

	FormatMACAddress(szNumber,
					 DimensionOf(szNumber),
					 m_SREntry.m_route.NextHopMacAddress,
					 sizeof(m_SREntry.m_route.NextHopMacAddress));
	SetDlgItemText(IDC_SRD_EDIT_NEXT_HOP, szNumber);
	
	m_spinHopCount.SetPos(m_SREntry.m_route.HopCount);
	m_spinTickCount.SetPos(m_SREntry.m_route.TickCount);

	// Disable the network number, next hop, and interface
	GetDlgItem(IDC_SRD_EDIT_NETWORK_NUMBER)->EnableWindow(FALSE);
	GetDlgItem(IDC_SRD_EDIT_NEXT_HOP)->EnableWindow(FALSE);

	SetDirty(FALSE);

	if (!FHrSucceeded(hr))
		Cancel();
	return FHrSucceeded(hr) ? TRUE : FALSE;
}

// --------------------------------------------------------------------------
//	IpxStaticRoutePropertyPage::DoDataExchange
//		-
//	Author: Deonb
// ---------------------------------------------------------------------------
void IpxStaticRoutePropertyPage::DoDataExchange(CDataExchange *pDX)
{
	RtrPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(IpxStaticRoutePropertyPage)
	DDX_Control(pDX, IDC_SRD_SPIN_TICK_COUNT, m_spinTickCount);
	DDX_Control(pDX, IDC_SRD_SPIN_HOP_COUNT, m_spinHopCount);
	//}}AFX_DATA_MAP
}

// --------------------------------------------------------------------------
//	IpxStaticRoutePropertyPage::OnApply
//		-
//	Author: Deonb
// ---------------------------------------------------------------------------
BOOL IpxStaticRoutePropertyPage::OnApply()
{

	BOOL	fReturn;
	HRESULT	hr = hrOK;

    if ( m_pIPXPropSheet->IsCancel() )
	{
		CancelApply();
        return TRUE;
	}

	CString st;
	GetDlgItemText(IDC_SRD_EDIT_NETWORK_NUMBER, st);
	ConvertNetworkNumberToBytes(st,
								m_SREntry.m_route.Network,
								sizeof(m_SREntry.m_route.Network));

	GetDlgItemText(IDC_SRD_EDIT_NEXT_HOP, st);
	ConvertMACAddressToBytes(st,
							 m_SREntry.m_route.NextHopMacAddress,
							 sizeof(m_SREntry.m_route.NextHopMacAddress));

	m_SREntry.m_route.TickCount = (USHORT) m_spinTickCount.GetPos();
	m_SREntry.m_route.HopCount = (USHORT) m_spinHopCount.GetPos();

	ModifyRouteInfo(m_pIPXPropSheet->m_spNode, &m_SREntry, &m_InitSREntry);

	// Update the data in the UI
	m_SREntry.SaveTo(m_pIPXPropSheet->m_pNodeData);
	m_pIPXPropSheet->m_spInterfaceInfo = m_SREntry.m_spIf;
	
	// Force a refresh
	m_pIPXPropSheet->m_spNode->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);

	fReturn  = RtrPropertyPage::OnApply();
	return fReturn;
}


//--------------------------------------------------------------------------
//	IpxRouteHandler::ModifyRouteInfo
//		-
//	Author: KennT
//--------------------------------------------------------------------------
HRESULT IpxStaticRoutePropertyPage::ModifyRouteInfo(ITFSNode *pNode,
										SafeIPXSRListEntry *pSREntryNew,
										SafeIPXSRListEntry *pSREntryOld)
{
 	Assert(pSREntryNew);
	Assert(pSREntryOld);
	
    INT i;
	HRESULT hr = hrOK;
    InfoBlock* pBlock;
	SPIInfoBase	spInfoBase;
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPITFSNode				spNodeParent;
	IPXConnection *			pIPXConn;
	IPX_STATIC_ROUTE_INFO		*psr, *psrOld;
	IPX_STATIC_ROUTE_INFO		IpxRow;

    CWaitCursor wait;

	pNode->GetParent(&spNodeParent);
	pIPXConn = GET_IPX_SR_NODEDATA(spNodeParent);
	Assert(pIPXConn);

	// Remove the old route if it is on another interface
	if (lstrcmpi(pSREntryOld->m_spIf->GetId(), pSREntryNew->m_spIf->GetId()) != 0)
	{
        // the outgoing interface for a route is to be changed.

		CORg( pSREntryOld->m_spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) );
		CORg( spRmIf->GetInfoBase(pIPXConn->GetConfigHandle(),
								  NULL,
								  NULL,
								  &spInfoBase));
		
		// Remove the old interface
		CORg( RemoveStaticRoute(pSREntryOld, spInfoBase) );

		// Update the interface information
		CORg( spRmIf->Save(pSREntryOld->m_spIf->GetMachineName(),
						   pIPXConn->GetConfigHandle(),
						   NULL,
						   NULL,
						   spInfoBase,
						   0));	
    }

	spRmIf.Release();
	spInfoBase.Release();


	// Either
	// (a) a route is being modified (on the same interface)
	// (b) a route is being moved from one interface to another.

	// Retrieve the configuration for the interface to which the route
	// is now attached;

	
	CORg( pSREntryNew->m_spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) );
	CORg( spRmIf->GetInfoBase(pIPXConn->GetConfigHandle(),
							  NULL,
							  NULL,
							  &spInfoBase));

		
	// Get the IPX_STATIC_ROUTE_INFO block from the interface
	hr = spInfoBase->GetBlock(IPX_STATIC_ROUTE_INFO_TYPE, &pBlock, 0);
	if (!FHrOK(hr))
	{
		//
		// No IPX_STATIC_ROUTE_INFO block was found; we create a new block 
		// with the new route, and add that block to the interface-info
		//

		CORg( AddStaticRoute(pSREntryNew, spInfoBase, NULL) );
	}
	else
	{
		//
		// An IPX_STATIC_ROUTE_INFO block was found.
		//
		// We are modifying an existing route.
		// If the route's interface was not changed when it was modified,
		// look for the existing route in the IPX_STATIC_ROUTE_INFO, and then
		// update its parameters.
		// Otherwise, write a completely new route in the IPX_STATIC_ROUTE_INFO;
		//

		if (lstrcmpi(pSREntryOld->m_spIf->GetId(), pSREntryNew->m_spIf->GetId()) == 0)
		{        
			//
			// The route's interface was not changed when it was modified;
			// We now look for it amongst the existing routes
			// for this interface.
			// The route's original parameters are in 'preOld',
			// so those are the parameters with which we search
			// for a route to modify
			//
			
			psr = (IPX_STATIC_ROUTE_INFO*)pBlock->pData;
			
			for (i = 0; i < (INT)pBlock->dwCount; i++, psr++)
			{	
				// Compare this route to the re-configured one
				if (!FAreTwoRoutesEqual(&(pSREntryOld->m_route), psr))
					continue;
				
				// This is the route which was modified;
				// We can now modify the parameters for the route in-place.
				*psr = pSREntryNew->m_route;
				
				break;
			}
		}
		else
		{
			CORg( AddStaticRoute(pSREntryNew, spInfoBase, pBlock) );
		}
		
	}

	// Save the updated information
	CORg( spRmIf->Save(pSREntryNew->m_spIf->GetMachineName(),
					   pIPXConn->GetConfigHandle(),
					   NULL,
					   NULL,
					   spInfoBase,
					   0));	
		
Error:
	return hr;
	
}

HRESULT IpxStaticRoutePropertyPage::RemoveStaticRoute(SafeIPXSRListEntry *pSREntry, IInfoBase *pInfoBase)
{
	HRESULT		hr = hrOK;
	InfoBlock *	pBlock;
	PIPX_STATIC_ROUTE_INFO	pRow;
    INT			i;
	
	// Get the IPX_STATIC_ROUTE_INFO block from the interface
	CORg( pInfoBase->GetBlock(IPX_STATIC_ROUTE_INFO_TYPE, &pBlock, 0) );
		
	// Look for the removed route in the IPX_STATIC_ROUTE_INFO
	pRow = (IPX_STATIC_ROUTE_INFO*) pBlock->pData;
	
	for (i = 0; i < (INT)pBlock->dwCount; i++, pRow++)
	{	
		// Compare this route to the removed one
		if (FAreTwoRoutesEqual(pRow, &(pSREntry->m_route)))
		{
			// This is the removed route, so modify this block
			// to exclude the route:
			
			// Decrement the number of routes
			--pBlock->dwCount;
		
			if (pBlock->dwCount && (i < (INT)pBlock->dwCount))
			{				
				// Overwrite this route with the ones which follow it
				::memmove(pRow,
						  pRow + 1,
						  (pBlock->dwCount - i) * sizeof(*pRow));
			}
			
			break;
		}
	}

Error:
	return hr;
}


// ***************************************************************************
//--------------------------------------------------------------------------
//	SafeIPXSRListEntry::LoadFrom
//		-
//	Author: DeonB
//--------------------------------------------------------------------------
void SafeIPXSRListEntry::LoadFrom(BaseIPXResultNodeData *pNodeData)
{
	m_spIf = pNodeData->m_spIf;

	ConvertNetworkNumberToBytes(pNodeData->m_rgData[IPX_SR_SI_NETWORK].m_stData,
								m_route.Network,
								DimensionOf(m_route.Network));

	// This is not the correct byte order to do comparisons, but it
	// can be used for equality
	memcpy(&pNodeData->m_rgData[IPX_SR_SI_NETWORK].m_dwData,
		   m_route.Network,
		   sizeof(DWORD));
	
	m_route.TickCount = (USHORT) pNodeData->m_rgData[IPX_SR_SI_TICK_COUNT].m_dwData;
	
	m_route.HopCount = (USHORT) pNodeData->m_rgData[IPX_SR_SI_HOP_COUNT].m_dwData;

	// Need to convert the MAC address into a byte array
	ConvertMACAddressToBytes(pNodeData->m_rgData[IPX_SR_SI_NEXT_HOP].m_stData,
							 m_route.NextHopMacAddress,
							 DimensionOf(m_route.NextHopMacAddress));

}

//--------------------------------------------------------------------------
//	SafeIPXSRListEntry::SaveTo
//		-
//	Author: DeonB
//---------------------------------------------------------------------------
void SafeIPXSRListEntry::SaveTo(BaseIPXResultNodeData *pNodeData)
{
	TCHAR	szNumber[32];
	
	pNodeData->m_spIf.Set(m_spIf);
	
	pNodeData->m_rgData[IPX_SR_SI_NAME].m_stData = m_spIf->GetTitle();

	FormatIpxNetworkNumber(szNumber,
						   DimensionOf(szNumber),
						   m_route.Network,
						   DimensionOf(m_route.Network));
	pNodeData->m_rgData[IPX_SR_SI_NETWORK].m_stData = szNumber;
	memcpy(&(pNodeData->m_rgData[IPX_SR_SI_NETWORK].m_dwData),
		   m_route.Network,
		   sizeof(DWORD));

	FormatMACAddress(szNumber,
					 DimensionOf(szNumber),
					 m_route.NextHopMacAddress,
					 DimensionOf(m_route.NextHopMacAddress));
	pNodeData->m_rgData[IPX_SR_SI_NEXT_HOP].m_stData = szNumber;

	FormatNumber(m_route.TickCount,
				 szNumber,
				 DimensionOf(szNumber),
				 FALSE);
	pNodeData->m_rgData[IPX_SR_SI_TICK_COUNT].m_stData = szNumber;
	pNodeData->m_rgData[IPX_SR_SI_TICK_COUNT].m_dwData = m_route.TickCount;

	FormatNumber(m_route.HopCount,
				 szNumber,
				 DimensionOf(szNumber),
				 FALSE);
	pNodeData->m_rgData[IPX_SR_SI_HOP_COUNT].m_stData = szNumber;
	pNodeData->m_rgData[IPX_SR_SI_HOP_COUNT].m_dwData = m_route.HopCount;

}

///--------------------------------------------------------------------------
//	AddStaticRoute
//		This function ASSUMES that the route is NOT in the block.
//	Author: KennT
//---------------------------------------------------------------------------
HRESULT AddStaticRoute(SafeIPXSRListEntry *pSREntryNew,
									   IInfoBase *pInfoBase,
									   InfoBlock *pBlock)
{
	IPX_STATIC_ROUTE_INFO	srRow;
	HRESULT				hr = hrOK;
	
	if (pBlock == NULL)
	{
		//
		// No IPX_STATIC_ROUTE_INFO block was found; we create a new block 
		// with the new route, and add that block to the interface-info
		//
		
		CORg( pInfoBase->AddBlock(IPX_STATIC_ROUTE_INFO_TYPE,
								  sizeof(IPX_STATIC_ROUTE_INFO),
								  (LPBYTE) &(pSREntryNew->m_route), 1, 0) );
	}
	else
	{
		// Either the route is completely new, or it is a route
		// which was moved from one interface to another.
		// Set a new block as the IPX_STATIC_ROUTE_INFO,
		// and include the re-configured route in the new block.
		PIPX_STATIC_ROUTE_INFO	psrTable;
			
		psrTable = new IPX_STATIC_ROUTE_INFO[pBlock->dwCount + 1];
		Assert(psrTable);
		
		// Copy the original table of routes
		::memcpy(psrTable, pBlock->pData,
				 pBlock->dwCount * sizeof(IPX_STATIC_ROUTE_INFO));
		
		// Append the new route
		psrTable[pBlock->dwCount] = pSREntryNew->m_route;
		
		// Replace the old route-table with the new one
		CORg( pInfoBase->SetData(IPX_STATIC_ROUTE_INFO_TYPE,
								 sizeof(IPX_STATIC_ROUTE_INFO),
								 (LPBYTE) psrTable, pBlock->dwCount + 1, 0) );
	}
	
Error:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxstaticsvc.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    ipxserviceprop.h
//
// History:
//	12/07/90	Deon Brewis             Created.
//
//	IPX Static Service property sheet and property pages
//
//============================================================================


#ifndef _NBPROP_H
#define _NBPROP_H

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _RTRSHEET_H
#include "rtrsheet.h"
#endif

#ifndef _SRVIEW_H
#include "ssview.h"
#endif

// ---------------------------------------------------------------------------
//	Forward declarations
// ---------------------------------------------------------------------------
class IPXConnection;
class IpxStaticServicePropertySheet;


// ---------------------------------------------------------------------------
//	class:	SafeIPXSSListEntry
//
//  IpxSSListEntry is not thread safe or something else is wrong with the TFS
//  implementation of smart pointers. Anyway, it does not work in property pages. 
//  Grrr.... Had to change SPInterfaceInfo m_spIf to CComPtr<IInterfaceInfo>. 
//  It seems to work now.
//
//  Author: deonb
// ---------------------------------------------------------------------------
class SafeIPXSSListEntry
{
public:
	CComPtr<IInterfaceInfo>	m_spIf;
	IPX_STATIC_SERVICE_INFO	m_service;
	
	void	LoadFrom(BaseIPXResultNodeData *pNodeData);
	void	SaveTo(BaseIPXResultNodeData *pNodeData);
};

// ---------------------------------------------------------------------------
//	class:	IpxStaticServicePropertyPage
//	This class handles the IPX Static Route properties
//
//  Author: deonb
// ---------------------------------------------------------------------------
class IpxStaticServicePropertyPage :
    public RtrPropertyPage
{
public:
	IpxStaticServicePropertyPage(UINT nIDTemplate, UINT nIDCaption = 0)
			: RtrPropertyPage(nIDTemplate, nIDCaption)
	{};

	~IpxStaticServicePropertyPage();

	HRESULT	Init(BaseIPXResultNodeData  *pNodeData,
				IpxStaticServicePropertySheet * pIPXPropSheet);

	HRESULT ModifyRouteInfo(ITFSNode *pNode,
										SafeIPXSSListEntry *pSSEntryNew,
										SafeIPXSSListEntry *pSSEntryOld);

	HRESULT RemoveStaticService(SafeIPXSSListEntry *pSSEntry,
										  IInfoBase *pInfoBase);

protected:

	// Override the OnApply() so that we can grab our data from the
	// controls in the dialog.
	virtual BOOL OnApply();

	SafeIPXSSListEntry m_SREntry;
	SafeIPXSSListEntry m_InitSREntry;
	IpxStaticServicePropertySheet *m_pIPXPropSheet;

	//{{AFX_VIRTUAL(IpxStaticServicePropertyPage)
	protected:
	virtual VOID	DoDataExchange(CDataExchange *pDX);
	//}}AFX_VIRTUAL

	//{{AFX_DATA(IpxStaticServicePropertyPage)
	CSpinButtonCtrl		m_spinHopCount;
	//}}AFX_DATA

	//{{AFX_MSG(IpxStaticServicePropertyPage)
	virtual BOOL	OnInitDialog();
	//}}AFX_MSG
	
	//{{AFX_MSG(IpxStaticServicePropertyPage
	afx_msg	void	OnChangeButton();
	afx_msg void	OnInputFilters();
	afx_msg void	OnOutputFilters();
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};

// ---------------------------------------------------------------------------
//	Class:	IpxStaticServicePropertySheet
//
//	This is the property sheet support class for the properties page of
//	IPX Static Route items.
//
//  Author: deonb
//---------------------------------------------------------------------------
class IpxStaticServicePropertySheet :
	public RtrPropertySheet
{
public:
	IpxStaticServicePropertySheet(ITFSNode *pNode,
								 IComponentData *pComponentData,
								 ITFSComponentData *pTFSCompData,
								 LPCTSTR pszSheetName,
								 CWnd *pParent = NULL,
								 UINT iPage=0,
								 BOOL fScopePane = TRUE);

	HRESULT	Init(BaseIPXResultNodeData * pNodeData,
				 IInterfaceInfo * spInterfaceInfo);

	virtual BOOL SaveSheetData();
	virtual void CancelSheetData();

	BaseIPXResultNodeData *	m_pNodeData;

	CComPtr<IInterfaceInfo> m_spInterfaceInfo;
	CComPtr<ITFSNode>      m_spNode;
	
protected:
	IpxStaticServicePropertyPage	m_pageGeneral;
};

// ---------------------------------------------------------------------------
// AddStaticRoute function updated to use a SafeIPXSRListEntry
// ---------------------------------------------------------------------------
HRESULT AddStaticService(SafeIPXSSListEntry *pSSEntry,
					   IInfoBase *InfoBase,
					   InfoBlock *pBlock);

#endif _NBPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxstaticsvc.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999   **/
/**********************************************************************/

//
//	nbprop.cpp
//		IPX summary node property sheet and property pages
//		
//  FILE HISTORY:


#include "stdafx.h"
#include "rtrutil.h"	// smart MPR handle pointers
#include "format.h"		// FormatNumber function
#include "IpxStaticSvc.h"
#include "summary.h"
#include "ipxrtdef.h"
#include "filter.h"
#include "ipxutil.h"

extern "C"
{
#include "routprot.h"
};

// ---------------------------------------------------------------------------
//	IpxStaticServicePropertySheet::IpxStaticServicePropertySheet
//	Initialize the RtrPropertySheet and only Property Page.
//	Author: Deonb
// ---------------------------------------------------------------------------
IpxStaticServicePropertySheet::IpxStaticServicePropertySheet(ITFSNode *pNode,
								 IComponentData *pComponentData,
								 ITFSComponentData *pTFSCompData,
								 LPCTSTR pszSheetName,
								 CWnd *pParent,
								 UINT iPage,
								 BOOL fScopePane)
	: RtrPropertySheet(pNode, pComponentData, pTFSCompData, 
					   pszSheetName, pParent, iPage, fScopePane),
		m_pageGeneral(IDD_STATICSERVICESPROPERTIES_GENERAL)
{
	m_spNode = pNode;
}

// ---------------------------------------------------------------------------
//	IpxStaticServicePropertySheet::Init
//	Initialize the property sheets.  The general action here will be
//		to initialize/add the various pages.
//	Author: Deonb
// ---------------------------------------------------------------------------
HRESULT	IpxStaticServicePropertySheet::Init(	
 		 	 BaseIPXResultNodeData  *pNodeData,
			 IInterfaceInfo *  spInterfaceInfo)
{
	HRESULT	hr = hrOK;

	BaseIPXResultNodeData *	pData;

	m_pNodeData = pNodeData;
	m_spInterfaceInfo = spInterfaceInfo;

	pData = GET_BASEIPXRESULT_NODEDATA(m_spNode);
	ASSERT_BASEIPXRESULT_NODEDATA(pData);

	// The pages are embedded members of the class
	// do not delete them.
	m_bAutoDeletePages = FALSE;
	
	m_pageGeneral.Init(pNodeData, this);
	AddPageToList((CPropertyPageBase*) &m_pageGeneral);

	return S_OK;
}

// ---------------------------------------------------------------------------
//	IpxStaticServicePropertySheet::SaveSheetData
//	Not sure what this does - this is never called. Kenn had this so I'll just
//		copy this too.
//	Author: Deonb
// ---------------------------------------------------------------------------
BOOL IpxStaticServicePropertySheet::SaveSheetData()
{
    SPITFSNodeHandler	spHandler;
    SPITFSNode			spParent;
    
	// By this time each page should have written its information out
	// to the infobase

    // Force the node to do a resync
    m_spNode->GetParent(&spParent);
    spParent->GetHandler(&spHandler);
    spHandler->OnCommand(spParent, IDS_MENU_SYNC, CCT_RESULT,
                         NULL, 0);
		
	return TRUE;
}

// --------------------------------------------------------------------------
//	IpxStaticServicePropertySheet::CancelSheetData
//		-
//	Author: Deonb
// ---------------------------------------------------------------------------
void IpxStaticServicePropertySheet::CancelSheetData()
{
}

// ***************************************************************************
// ---------------------------------------------------------------------------
//	IpxStaticServicePropertyPage
// ---------------------------------------------------------------------------
IpxStaticServicePropertyPage::~IpxStaticServicePropertyPage()
{
}

BEGIN_MESSAGE_MAP(IpxStaticServicePropertyPage, RtrPropertyPage)
    //{{AFX_MSG_MAP(IpxStaticServicePropertyPage)
	ON_BN_CLICKED(IDC_NIG_BTN_ACCEPT, OnChangeButton)
	ON_BN_CLICKED(IDC_NIG_BTN_DELIVER_ALWAYS, OnChangeButton)
	ON_BN_CLICKED(IDC_NIG_BTN_DELIVER_NEVER, OnChangeButton)
	ON_BN_CLICKED(IDC_NIG_BTN_DELIVER_STATIC, OnChangeButton)
	ON_BN_CLICKED(IDC_NIG_BTN_DELIVER_WHEN_UP, OnChangeButton)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void IpxStaticServicePropertyPage::OnChangeButton()
{
	SetDirty(TRUE);
	SetModified();
}

//--------------------------------------------------------------------------
//	IpxStaticServicePropertyPage::Init
//		-
//	Author: Deonb
//---------------------------------------------------------------------------
HRESULT	IpxStaticServicePropertyPage::Init(BaseIPXResultNodeData  *pNodeData,
				IpxStaticServicePropertySheet * pIPXPropSheet)

{
	ATLASSERT(pSREntry);
	ATLASSERT(pIPXPropSheet);
	
	m_pIPXPropSheet = pIPXPropSheet;

	m_SREntry.LoadFrom(pNodeData);
	m_InitSREntry = m_SREntry;
	
	return hrOK;
}

// --------------------------------------------------------------------------
//	IpxStaticServicePropertyPage::OnInitDialog
//		-
//	Author: Deonb
// ---------------------------------------------------------------------------
BOOL IpxStaticServicePropertyPage::OnInitDialog()
{
	HRESULT	hr = hrOK;
	PBYTE	pData;
	DWORD		dwIfType;
	UINT		iButton;

	RtrPropertyPage::OnInitDialog();
	
	m_spinHopCount.SetRange(0, 15);
	m_spinHopCount.SetBuddy(GetDlgItem(IDC_SSD_EDIT_HOP_COUNT));

	((CEdit *) GetDlgItem(IDC_SSD_EDIT_SERVICE_TYPE))->LimitText(4);
	((CEdit *) GetDlgItem(IDC_SSD_EDIT_SERVICE_NAME))->LimitText(48);
	((CEdit *) GetDlgItem(IDC_SSD_EDIT_NETWORK_ADDRESS))->LimitText(8);
	((CEdit *) GetDlgItem(IDC_SSD_EDIT_NODE_ADDRESS))->LimitText(12);
	((CEdit *) GetDlgItem(IDC_SSD_EDIT_SOCKET_ADDRESS))->LimitText(4);

	USES_CONVERSION;
	TCHAR	szNumber[32];
	wsprintf(szNumber, _T("%.4x"), m_SREntry.m_service.Type);
	SetDlgItemText(IDC_SSD_EDIT_SERVICE_TYPE, szNumber);

	SetDlgItemText(IDC_SSD_EDIT_SERVICE_NAME, A2CT((LPSTR) m_SREntry.m_service.Name));
	
	FormatIpxNetworkNumber(szNumber,
						   DimensionOf(szNumber),
						   m_SREntry.m_service.Network,
						   sizeof(m_SREntry.m_service.Network));
	SetDlgItemText(IDC_SSD_EDIT_NETWORK_ADDRESS, szNumber);

    // Zero out the address beforehand
	FormatBytes(szNumber, DimensionOf(szNumber),
				(BYTE *) m_SREntry.m_service.Node,
				sizeof(m_SREntry.m_service.Node));
	SetDlgItemText(IDC_SSD_EDIT_NODE_ADDRESS, szNumber);

	FormatBytes(szNumber, DimensionOf(szNumber),
				(BYTE *) m_SREntry.m_service.Socket,
				sizeof(m_SREntry.m_service.Socket));
	SetDlgItemText(IDC_SSD_EDIT_SOCKET_ADDRESS, szNumber);

	m_spinHopCount.SetPos(m_SREntry.m_service.HopCount);
	
	// Disable the network number, next hop
	GetDlgItem(IDC_SSD_EDIT_SERVICE_TYPE)->EnableWindow(FALSE);
	GetDlgItem(IDC_SSD_EDIT_SERVICE_NAME)->EnableWindow(FALSE);

	SetDirty(FALSE);

	if (!FHrSucceeded(hr))
		Cancel();
	return FHrSucceeded(hr) ? TRUE : FALSE;
}

// --------------------------------------------------------------------------
//	IpxStaticServicePropertyPage::DoDataExchange
//		-
//	Author: Deonb
// ---------------------------------------------------------------------------
void IpxStaticServicePropertyPage::DoDataExchange(CDataExchange *pDX)
{
	RtrPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(IpxStaticServicePropertyPage)
	DDX_Control(pDX, IDC_SSD_SPIN_HOP_COUNT, m_spinHopCount);
	//}}AFX_DATA_MAP
}

// --------------------------------------------------------------------------
//	IpxStaticServicePropertyPage::OnApply
//		-
//	Author: Deonb
// ---------------------------------------------------------------------------
BOOL IpxStaticServicePropertyPage::OnApply()
{

	BOOL	fReturn;
	HRESULT	hr = hrOK;

    if ( m_pIPXPropSheet->IsCancel() )
	{
		CancelApply();
        return TRUE;
	}

	CString st;
	GetDlgItemText(IDC_SSD_EDIT_SERVICE_TYPE, st);
	m_SREntry.m_service.Type = (USHORT) _tcstoul(st, NULL, 16);

	GetDlgItemText(IDC_SSD_EDIT_SERVICE_NAME, st);
	st.TrimLeft();
	st.TrimRight();
	if (st.IsEmpty())
	{
		GetDlgItem(IDC_SSD_EDIT_SERVICE_NAME)->SetFocus();
		AfxMessageBox(IDS_ERR_INVALID_SERVICE_NAME);
		return FALSE;
	}
	StrnCpyAFromW((LPSTR) m_SREntry.m_service.Name,
				  st,
				  sizeof(m_SREntry.m_service.Name));
	
	GetDlgItemText(IDC_SSD_EDIT_NETWORK_ADDRESS, st);
	ConvertToBytes(st,
				   m_SREntry.m_service.Network,
				   DimensionOf(m_SREntry.m_service.Network));
	
	GetDlgItemText(IDC_SSD_EDIT_NODE_ADDRESS, st);
	ConvertToBytes(st,
				   m_SREntry.m_service.Node,
				   DimensionOf(m_SREntry.m_service.Node));
	
	GetDlgItemText(IDC_SSD_EDIT_SOCKET_ADDRESS, st);
	ConvertToBytes(st,
				   m_SREntry.m_service.Socket,
				   DimensionOf(m_SREntry.m_service.Socket));

	m_SREntry.m_service.HopCount = (USHORT) m_spinHopCount.GetPos();

	// Updates the route info for this route
	ModifyRouteInfo(m_pIPXPropSheet->m_spNode, &m_SREntry, &m_InitSREntry);

	// Update the data in the UI
	m_SREntry.SaveTo(m_pIPXPropSheet->m_pNodeData);
	m_pIPXPropSheet->m_spInterfaceInfo = m_SREntry.m_spIf;
	
	// Force a refresh
	m_pIPXPropSheet->m_spNode->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);

	fReturn  = RtrPropertyPage::OnApply();
	return fReturn;
}


/*!--------------------------------------------------------------------------
	IpxStaticServicePropertyPage::RemoveStaticService
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxStaticServicePropertyPage::RemoveStaticService(SafeIPXSSListEntry *pSSEntry,
										  IInfoBase *pInfoBase)
{
	HRESULT		hr = hrOK;
	InfoBlock *	pBlock;
	PIPX_STATIC_SERVICE_INFO	pRow;
    INT			i;
	
	// Get the IPX_STATIC_SERVICE_INFO block from the interface
	CORg( pInfoBase->GetBlock(IPX_STATIC_SERVICE_INFO_TYPE, &pBlock, 0) );
		
	// Look for the removed route in the IPX_STATIC_SERVICE_INFO
	pRow = (IPX_STATIC_SERVICE_INFO*) pBlock->pData;
	
	for (i = 0; i < (INT)pBlock->dwCount; i++, pRow++)
	{	
		// Compare this route to the removed one
		if (FAreTwoServicesEqual(pRow, &(pSSEntry->m_service)))
		{
			// This is the removed route, so modify this block
			// to exclude the route:
			
			// Decrement the number of Services
			--pBlock->dwCount;
		
			if (pBlock->dwCount && (i < (INT)pBlock->dwCount))
			{				
				// Overwrite this route with the ones which follow it
				::memmove(pRow,
						  pRow + 1,
						  (pBlock->dwCount - i) * sizeof(*pRow));
			}
			
			break;
		}
	}

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxStaticServicePropertyPage::ModifyRouteInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxStaticServicePropertyPage::ModifyRouteInfo(ITFSNode *pNode,
										SafeIPXSSListEntry *pSSEntryNew,
										SafeIPXSSListEntry *pSSEntryOld)
{
 	Assert(pSSEntryNew);
	Assert(pSSEntryOld);
	
    INT i;
	HRESULT hr = hrOK;
    InfoBlock* pBlock;
	SPIInfoBase	spInfoBase;
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPITFSNode				spNodeParent;
	IPXConnection *			pIPXConn;
	IPX_STATIC_SERVICE_INFO		*psr, *psrOld;
	IPX_STATIC_SERVICE_INFO		IpxRow;

    CWaitCursor wait;

	pNode->GetParent(&spNodeParent);
	pIPXConn = GET_IPX_SS_NODEDATA(spNodeParent);
	Assert(pIPXConn);

	// Remove the old route if it is on another interface
	if (lstrcmpi(pSSEntryOld->m_spIf->GetId(), pSSEntryNew->m_spIf->GetId()) != 0)
	{
        // the outgoing interface for a route is to be changed.

		CORg( pSSEntryOld->m_spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) );
		CORg( spRmIf->GetInfoBase(pIPXConn->GetConfigHandle(),
								  NULL,
								  NULL,
								  &spInfoBase));
		
		// Remove the old interface
		CORg( RemoveStaticService(pSSEntryOld, spInfoBase) );

		// Update the interface information
		CORg( spRmIf->Save(pSSEntryOld->m_spIf->GetMachineName(),
						   pIPXConn->GetConfigHandle(),
						   NULL,
						   NULL,
						   spInfoBase,
						   0));	
    }

	spRmIf.Release();
	spInfoBase.Release();


	// Either
	// (a) a route is being modified (on the same interface)
	// (b) a route is being moved from one interface to another.

	// Retrieve the configuration for the interface to which the route
	// is now attached;

	
	CORg( pSSEntryNew->m_spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) );
	CORg( spRmIf->GetInfoBase(pIPXConn->GetConfigHandle(),
							  NULL,
							  NULL,
							  &spInfoBase));

		
	// Get the IPX_STATIC_SERVICE_INFO block from the interface
	hr = spInfoBase->GetBlock(IPX_STATIC_SERVICE_INFO_TYPE, &pBlock, 0);
	if (!FHrOK(hr))
	{
		//
		// No IPX_STATIC_SERVICE_INFO block was found; we create a new block 
		// with the new route, and add that block to the interface-info
		//

		CORg( AddStaticService(pSSEntryNew, spInfoBase, NULL) );
	}
	else
	{
		//
		// An IPX_STATIC_SERVICE_INFO block was found.
		//
		// We are modifying an existing route.
		// If the route's interface was not changed when it was modified,
		// look for the existing route in the IPX_STATIC_SERVICE_INFO, and then
		// update its parameters.
		// Otherwise, write a completely new route in the IPX_STATIC_SERVICE_INFO;
		//

		if (lstrcmpi(pSSEntryOld->m_spIf->GetId(), pSSEntryNew->m_spIf->GetId()) == 0)
		{        
			//
			// The route's interface was not changed when it was modified;
			// We now look for it amongst the existing Services
			// for this interface.
			// The route's original parameters are in 'preOld',
			// so those are the parameters with which we search
			// for a route to modify
			//
			
			psr = (IPX_STATIC_SERVICE_INFO*)pBlock->pData;
			
			for (i = 0; i < (INT)pBlock->dwCount; i++, psr++)
			{	
				// Compare this route to the re-configured one
				if (!FAreTwoServicesEqual(&(pSSEntryOld->m_service), psr))
					continue;
				
				// This is the route which was modified;
				// We can now modify the parameters for the route in-place.
				*psr = pSSEntryNew->m_service;
				
				break;
			}
		}
		else
		{
			CORg( AddStaticService(pSSEntryNew, spInfoBase, pBlock) );
		}
		
		// Save the updated information
		CORg( spRmIf->Save(pSSEntryNew->m_spIf->GetMachineName(),
						   pIPXConn->GetConfigHandle(),
						   NULL,
						   NULL,
						   spInfoBase,
						   0));	
		
	}

Error:
	return hr;
	
}
// --------------------------------------------------------------------------
//	SafeIPXSSListEntry::LoadFrom
//		-
//	Author: DeonB
// --------------------------------------------------------------------------
void SafeIPXSSListEntry::LoadFrom(BaseIPXResultNodeData *pNodeData)
{
	CString	stFullAddress;
	CString	stNumber;
	
	m_spIf = pNodeData->m_spIf;

	m_service.Type = (USHORT) _tcstoul(
						pNodeData->m_rgData[IPX_SS_SI_SERVICE_TYPE].m_stData,
						NULL, 16);

	StrnCpyAFromW((LPSTR) m_service.Name,
				  pNodeData->m_rgData[IPX_SS_SI_SERVICE_NAME].m_stData,
				  DimensionOf(m_service.Name));

	// Need to break the address up into Network.Node.Socket
	stFullAddress = pNodeData->m_rgData[IPX_SS_SI_SERVICE_ADDRESS].m_stData;
	Assert(StrLen(stFullAddress) == (8 + 1 + 12 + 1 + 4));

	stNumber = stFullAddress.Left(8);
	ConvertToBytes(stNumber,
				   m_service.Network, sizeof(m_service.Network));

	stNumber = stFullAddress.Mid(9, 12);
	ConvertToBytes(stNumber,
				   m_service.Node, sizeof(m_service.Node));

	stNumber = stFullAddress.Mid(22, 4);
	ConvertToBytes(stNumber,
				   m_service.Socket, sizeof(m_service.Socket));	
	
	m_service.HopCount = (USHORT) pNodeData->m_rgData[IPX_SS_SI_HOP_COUNT].m_dwData;
}

// --------------------------------------------------------------------------
//	SafeIPXSSListEntry::SaveTo
//		-
//	Author: DeonB
// --------------------------------------------------------------------------
void SafeIPXSSListEntry::SaveTo(BaseIPXResultNodeData *pNodeData)
{
	TCHAR	szNumber[32];
	CString	st;
	USES_CONVERSION;
	
	pNodeData->m_spIf.Set(m_spIf);

	pNodeData->m_rgData[IPX_SS_SI_NAME].m_stData = m_spIf->GetTitle();

	wsprintf(szNumber, _T("%.4x"), m_service.Type);
	pNodeData->m_rgData[IPX_SS_SI_SERVICE_TYPE].m_stData = szNumber;
    pNodeData->m_rgData[IPX_SS_SI_SERVICE_TYPE].m_dwData = (DWORD) m_service.Type;

	pNodeData->m_rgData[IPX_SS_SI_SERVICE_NAME].m_stData =
		A2CT((LPSTR) m_service.Name);

	FormatBytes(szNumber, DimensionOf(szNumber),
				m_service.Network, sizeof(m_service.Network));
	st = szNumber;
	st += _T(".");
	FormatBytes(szNumber, DimensionOf(szNumber),
				m_service.Node, sizeof(m_service.Node));
	st += szNumber;
	st += _T(".");
	FormatBytes(szNumber, DimensionOf(szNumber),
				m_service.Socket, sizeof(m_service.Socket));
	st += szNumber;

	Assert(st.GetLength() == (8+1+12+1+4));

	pNodeData->m_rgData[IPX_SS_SI_SERVICE_ADDRESS].m_stData = st;

	FormatNumber(m_service.HopCount,
				 szNumber,
				 DimensionOf(szNumber),
				 FALSE);
	pNodeData->m_rgData[IPX_SS_SI_HOP_COUNT].m_stData = szNumber;
	pNodeData->m_rgData[IPX_SS_SI_HOP_COUNT].m_dwData = m_service.HopCount;

}

/*!--------------------------------------------------------------------------
	AddStaticService
		This function ASSUMES that the route is NOT in the block.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AddStaticService(SafeIPXSSListEntry *pSSEntryNew,
									   IInfoBase *pInfoBase,
									   InfoBlock *pBlock)
{
	IPX_STATIC_SERVICE_INFO	srRow;
	HRESULT				hr = hrOK;
	
	if (pBlock == NULL)
	{
		//
		// No IPX_STATIC_SERVICE_INFO block was found; we create a new block 
		// with the new route, and add that block to the interface-info
		//
		
		CORg( pInfoBase->AddBlock(IPX_STATIC_SERVICE_INFO_TYPE,
								  sizeof(IPX_STATIC_SERVICE_INFO),
								  (LPBYTE) &(pSSEntryNew->m_service), 1, 0) );
	}
	else
	{
		// Either the route is completely new, or it is a route
		// which was moved from one interface to another.
		// Set a new block as the IPX_STATIC_SERVICE_INFO,
		// and include the re-configured route in the new block.
		PIPX_STATIC_SERVICE_INFO	psrTable;
			
		psrTable = new IPX_STATIC_SERVICE_INFO[pBlock->dwCount + 1];
		Assert(psrTable);
		
		// Copy the original table of Services
		::memcpy(psrTable, pBlock->pData,
				 pBlock->dwCount * sizeof(IPX_STATIC_SERVICE_INFO));
		
		// Append the new route
		psrTable[pBlock->dwCount] = pSSEntryNew->m_service;
		
		// Replace the old route-table with the new one
		CORg( pInfoBase->SetData(IPX_STATIC_SERVICE_INFO_TYPE,
								 sizeof(IPX_STATIC_SERVICE_INFO),
								 (LPBYTE) psrTable, pBlock->dwCount + 1, 0) );
	}
	
Error:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxstats.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    ipxstats.h
//
// History:
//	07/22/97	Kenn M. Takara			Created.
//
//	IPX Statistics
//
//============================================================================


#ifndef _IPXSTATS_H
#define _IPXSTATS_H

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _STATSDLG_H
#include "statsdlg.h"
#endif

#include "ipxrtdef.h"

class IPXConnection;


// Base class for IPX statistics dialogs

class IPXStatisticsDialog : public StatsDialog
{
public:
	IPXStatisticsDialog(DWORD dwOptions) :
			StatsDialog(dwOptions),
			m_pIPXConn(NULL),
			m_dwSortSubitem(0xFFFFFFFF)
	{};

	~IPXStatisticsDialog()
	{
		SetConnectionData(NULL);
	}
	
    // Override the OnInitDialog so that we can set the caption
    virtual BOOL OnInitDialog();

	// Override the PostNcDestroy to do any cleanup action
	virtual void PostNcDestroy();

	// Override the Sort to provide the ability to do sorting
	virtual void Sort(UINT nColumnId);

	// Derived classes should override this to provide sorting
	// function
	virtual PFNLVCOMPARE GetSortFunction();
	virtual PFNLVCOMPARE GetInverseSortFunction();

	void SetConnectionData(IPXConnection *pIPXConn);

protected:
	DWORD			m_dwSortSubitem;
	IPXConnection *	m_pIPXConn;
};




//----------------------------------------------------------------------------
// Enum:    MV_ROWS
//
// Indices of rows in the 'IPX' view.
// This list MUST be kept in sync with the list in s_rgIpxStatsColumnInfo.
//----------------------------------------------------------------------------

enum
{
	MVR_IPX_STATE				= 0,
	MVR_IPX_NETWORK,
	MVR_IPX_NODE,
	MVR_IPX_INTERFACE_COUNT,
	MVR_IPX_ROUTE_COUNT,
	MVR_IPX_SERVICE_COUNT,
	MVR_IPX_PACKETS_SENT,
	MVR_IPX_PACKETS_RCVD,
	MVR_IPX_PACKETS_FRWD,
    MVR_IPX_COUNT
};


class IpxInfoStatistics : public IPXStatisticsDialog
{
public:
	IpxInfoStatistics();
	~IpxInfoStatistics();

	// Override the OnInitDialog so that we can set the caption
	virtual BOOL OnInitDialog();

	// Override the RefreshData to provide sample data
	virtual HRESULT RefreshData(BOOL fGrabNewData);

	// Override the Sort to provide the ability to do sorting
	// actually we don't do any sorting (this is a vertical format)
	virtual void Sort(UINT nColumnId);

protected:
	void	UpdateIpxData(LPBYTE pData, HRESULT hr);
	
};


enum
{
	MVR_IPXROUTING_NETWORK = 0,
	MVR_IPXROUTING_NEXT_HOP_MAC,
	MVR_IPXROUTING_TICK_COUNT,
	MVR_IPXROUTING_HOP_COUNT,
	MVR_IPXROUTING_IF_NAME,
	MVR_IPXROUTING_PROTOCOL,
	MVR_IPXROUTING_ROUTE_NOTES,
	MVR_IPXROUTING_COUNT,
};

typedef CArray<IPX_ROUTE, IPX_ROUTE&> RouteItemInfoArray;

class IpxRoutingStatistics : public IPXStatisticsDialog
{
	friend int CALLBACK IpxRoutingStatisticsCompareProc(LPARAM, LPARAM, LPARAM);
	
public:
	IpxRoutingStatistics();
	~IpxRoutingStatistics();

	// Override the OnInitDialog so that we can set the caption
	virtual BOOL OnInitDialog();

	// Override the PostNcDestroy to do any cleanup action
	virtual void PostNcDestroy();

	// Override the RefreshData to provide sample data
	virtual HRESULT RefreshData(BOOL fGrabNewData);

	// Override the Sort to provide the ability to do sorting
	virtual void Sort(UINT nColumnId);

	// Override this so that we can free up out item data
	virtual void PreDeleteAllItems();

	void SetRouterInfo(IRouterInfo *pRouterInfo);
	
	void FixColumnAlignment();
protected:
	DWORD			m_dwSortSubitem;
	SPIRouterInfo	m_spRouterInfo;

	// Holds the IPX_ROUTE information
	RouteItemInfoArray	m_Items;

	// Holds the interface title (indexed by interfaceindex)
	CStringArray	m_rgIfTitle;

	HRESULT	GetIpxRoutingData();
	HRESULT FillInterfaceTable();
	afx_msg	void	OnNotifyGetDispInfo(NMHDR *, LRESULT *pResult);

	DECLARE_MESSAGE_MAP();
};



enum
{
	MVR_IPXSERVICE_SERVICE_NAME = 0,
	MVR_IPXSERVICE_SERVICE_TYPE,
	MVR_IPXSERVICE_SERVICE_ADDRESS,
	MVR_IPXSERVICE_HOP_COUNT,
	MVR_IPXSERVICE_IF_NAME,
	MVR_IPXSERVICE_PROTOCOL,
	MVR_IPXSERVICE_COUNT,
};

typedef CArray<IPX_SERVICE, IPX_SERVICE&> ServiceItemInfoArray;

class IpxServiceStatistics : public IPXStatisticsDialog
{
	friend int CALLBACK IpxServiceStatisticsCompareProc(LPARAM, LPARAM, LPARAM);
	
public:
	IpxServiceStatistics();
	~IpxServiceStatistics();

	// Override the OnInitDialog so that we can set the caption
	virtual BOOL OnInitDialog();

	// Override the PostNcDestroy to do any cleanup action
	virtual void PostNcDestroy();

	// Override the RefreshData to provide sample data
	virtual HRESULT RefreshData(BOOL fGrabNewData);

	// Override the Sort to provide the ability to do sorting
	virtual void Sort(UINT nColumnId);

	// Override this so that we can free up out item data
	virtual void PreDeleteAllItems();

	void SetRouterInfo(IRouterInfo *pRouterInfo);
	
protected:
	DWORD			m_dwSortSubitem;
	SPIRouterInfo	m_spRouterInfo;

	// Holds the IPX_SERVICE information
	ServiceItemInfoArray	m_Items;

	// Holds the interface title (indexed by interfaceindex)
	CStringArray	m_rgIfTitle;

	HRESULT	GetIpxServiceData();
	HRESULT FillInterfaceTable();
	afx_msg	void	OnNotifyGetDispInfo(NMHDR *, LRESULT *pResult);

	DECLARE_MESSAGE_MAP();
};




#endif _IPXSTATS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxstrm.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
	ipxstrm.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ipxstrm.h"
#include "xstream.h"

/*!--------------------------------------------------------------------------
	IPXAdminConfigStream::IPXAdminConfigStream
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
IPXAdminConfigStream::IPXAdminConfigStream()
{
	m_nVersionAdmin = 0x00020000;
	m_nVersion = 0x00020000;

}

/*!--------------------------------------------------------------------------
	IPXAdminConfigStream::InitNew
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXAdminConfigStream::InitNew()
{
	// Setup the appropriate defaults
//	m_nVersionAdmin = 0x00020000;
//	m_nVersion = 0x00020000;
//	m_stName.Empty();

	ConfigStream::InitNew();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IPXAdminConfigStream::SaveTo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXAdminConfigStream::SaveTo(IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_WRITE, NULL);
}

/*!--------------------------------------------------------------------------
	IPXAdminConfigStream::SaveAs
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXAdminConfigStream::SaveAs(UINT nVersion, IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_WRITE, NULL);
}

/*!--------------------------------------------------------------------------
	IPXAdminConfigStream::LoadFrom
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXAdminConfigStream::LoadFrom(IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_READ, NULL);
}

/*!--------------------------------------------------------------------------
	IPXAdminConfigStream::GetSize
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXAdminConfigStream::GetSize(ULONG *pcbSize)
{
	return XferVersion0(NULL, XferStream::MODE_SIZE, NULL);
}

/*!--------------------------------------------------------------------------
	IPXAdminConfigStream::GetVersionInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXAdminConfigStream::GetVersionInfo(DWORD *pdwVersion, DWORD *pdwAdminVersion)
{
	if (pdwVersion)
		*pdwVersion = m_nVersion;
	if (pdwAdminVersion)
		*pdwAdminVersion = m_nVersionAdmin;
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IPXAdminConfigStream::XferVersion0
		-
	Author: KennT
 ---------------------------------------------------------------------------*/

struct _ViewInfoEntry
{
	ULONG	m_ulId;
	ULONG	m_idSort;
	ULONG	m_idAscending;
	ULONG	m_idColumns;
	ULONG	m_idPos;
};

static const _ViewInfoEntry	s_rgIPXAdminViewInfo[] =
{
	{ IPXSTRM_STATS_IPX,
		IPXSTRM_TAG_STATS_IPX_SORT,
		IPXSTRM_TAG_STATS_IPX_ASCENDING,
		IPXSTRM_TAG_STATS_IPX_COLUMNS,
		IPXSTRM_TAG_STATS_IPX_POSITION },
		
	{ IPXSTRM_STATS_ROUTING,
		IPXSTRM_TAG_STATS_IPXROUTING_SORT,
		IPXSTRM_TAG_STATS_IPXROUTING_ASCENDING,
		IPXSTRM_TAG_STATS_IPXROUTING_COLUMNS,
		IPXSTRM_TAG_STATS_IPXROUTING_POSITION },
		
	{ IPXSTRM_STATS_SERVICE,
		IPXSTRM_TAG_STATS_IPXSERVICE_SORT,
		IPXSTRM_TAG_STATS_IPXSERVICE_ASCENDING,
		IPXSTRM_TAG_STATS_IPXSERVICE_COLUMNS,
		IPXSTRM_TAG_STATS_IPXSERVICE_POSITION },
};

HRESULT IPXAdminConfigStream::XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize)
{
	XferStream	xstm(pstm, mode);
	HRESULT		hr = hrOK;
	int			i;
	
	CORg( xstm.XferDWORD( IPXSTRM_TAG_VERSION, &m_nVersion ) );
	CORg( xstm.XferDWORD( IPXSTRM_TAG_VERSIONADMIN, &m_nVersionAdmin ) );

	for ( i=0; i<DimensionOf(s_rgIPXAdminViewInfo); i++)
	{
		CORg( m_rgViewInfo[s_rgIPXAdminViewInfo[i].m_ulId].Xfer(&xstm,
			s_rgIPXAdminViewInfo[i].m_idSort,
			s_rgIPXAdminViewInfo[i].m_idAscending,
			s_rgIPXAdminViewInfo[i].m_idColumns) );
		CORg( xstm.XferRect( s_rgIPXAdminViewInfo[i].m_idPos,
							 &m_prgrc[s_rgIPXAdminViewInfo[i].m_ulId]) );
	}
	

	if (pcbSize)
		*pcbSize = xstm.GetSize();

Error:
	return hr;
}



/*---------------------------------------------------------------------------
	IPXComponentConfigStream implementation
 ---------------------------------------------------------------------------*/

enum IPXCOMPSTRM_TAG
{
	IPXCOMPSTRM_TAG_VERSION =		XFER_TAG(1, XFER_DWORD),
	IPXCOMPSTRM_TAG_VERSIONADMIN =	XFER_TAG(2, XFER_DWORD),
	
	IPXCOMPSTRM_TAG_SUMMARY_COLUMNS = XFER_TAG(3, XFER_COLUMNDATA_ARRAY),
	IPXCOMPSTRM_TAG_SUMMARY_SORT_COLUMN = XFER_TAG(4, XFER_DWORD),
	IPXCOMPSTRM_TAG_SUMMARY_SORT_ASCENDING = XFER_TAG(5, XFER_DWORD),
	
	IPXCOMPSTRM_TAG_NB_COLUMNS = XFER_TAG(6, XFER_COLUMNDATA_ARRAY),
	IPXCOMPSTRM_TAG_NB_SORT_COLUMN = XFER_TAG(7, XFER_DWORD),
	IPXCOMPSTRM_TAG_NB_SORT_ASCENDING = XFER_TAG(8, XFER_DWORD),
	
	IPXCOMPSTRM_TAG_SR_COLUMNS = XFER_TAG(9, XFER_COLUMNDATA_ARRAY),
	IPXCOMPSTRM_TAG_SR_SORT_COLUMN = XFER_TAG(10, XFER_DWORD),
	IPXCOMPSTRM_TAG_SR_SORT_ASCENDING = XFER_TAG(11, XFER_DWORD),
	
	IPXCOMPSTRM_TAG_SS_COLUMNS = XFER_TAG(12, XFER_COLUMNDATA_ARRAY),
	IPXCOMPSTRM_TAG_SS_SORT_COLUMN = XFER_TAG(13, XFER_DWORD),
	IPXCOMPSTRM_TAG_SS_SORT_ASCENDING = XFER_TAG(14, XFER_DWORD),
	
	IPXCOMPSTRM_TAG_SN_COLUMNS = XFER_TAG(15, XFER_COLUMNDATA_ARRAY),
	IPXCOMPSTRM_TAG_SN_SORT_COLUMN = XFER_TAG(16, XFER_DWORD),
	IPXCOMPSTRM_TAG_SN_SORT_ASCENDING = XFER_TAG(17, XFER_DWORD),
};



HRESULT IPXComponentConfigStream::XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize)
{
	XferStream	xstm(pstm, mode);
	HRESULT		hr = hrOK;

	CORg( xstm.XferDWORD( IPXCOMPSTRM_TAG_VERSION, &m_nVersion ) );
	CORg( xstm.XferDWORD( IPXCOMPSTRM_TAG_VERSIONADMIN, &m_nVersionAdmin ) );

	CORg( m_rgViewInfo[COLUMNS_SUMMARY].Xfer(&xstm,
										IPXCOMPSTRM_TAG_SUMMARY_SORT_COLUMN,
										IPXCOMPSTRM_TAG_SUMMARY_SORT_ASCENDING,
										IPXCOMPSTRM_TAG_SUMMARY_COLUMNS) );
	
	CORg( m_rgViewInfo[COLUMNS_NBBROADCASTS].Xfer(&xstm,
										IPXCOMPSTRM_TAG_NB_SORT_COLUMN,
										IPXCOMPSTRM_TAG_NB_SORT_ASCENDING,
										IPXCOMPSTRM_TAG_NB_COLUMNS) );
	
	CORg( m_rgViewInfo[COLUMNS_STATICROUTES].Xfer(&xstm,
										IPXCOMPSTRM_TAG_SR_SORT_COLUMN,
										IPXCOMPSTRM_TAG_SR_SORT_ASCENDING,
										IPXCOMPSTRM_TAG_SR_COLUMNS) );
	

	CORg( m_rgViewInfo[COLUMNS_STATICSERVICES].Xfer(&xstm,
										IPXCOMPSTRM_TAG_SS_SORT_COLUMN,
										IPXCOMPSTRM_TAG_SS_SORT_ASCENDING,
										IPXCOMPSTRM_TAG_SS_COLUMNS) );
	

	CORg( m_rgViewInfo[COLUMNS_STATICNETBIOSNAMES].Xfer(&xstm,
										IPXCOMPSTRM_TAG_SN_SORT_COLUMN,
										IPXCOMPSTRM_TAG_SN_SORT_ASCENDING,
										IPXCOMPSTRM_TAG_SN_COLUMNS) );
	

	if (pcbSize)
		*pcbSize = xstm.GetSize();

Error:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxstrm.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	ipxstrm.h
		IPX Root node configuration object.

		Use this to get/set configuration data.  This class will take
		care of versioning of config formats as well as serializing
		of the data.
		
    FILE HISTORY:
        
*/

#ifndef _IPXSTRM_H
#define _IPXSTRM_H

#ifndef _XSTREAM_H
#include "xstream.h"
#endif

#ifndef _IPXADMIN_H
#include "ipxadmin.h"
#endif

#ifndef _COLUMN_H
#include "column.h"
#endif

#ifndef _CONFIG_H
// #include "config.h"
#endif


enum
{
	IPXSTRM_STATS_IPX = 0,
	IPXSTRM_STATS_ROUTING,
	IPXSTRM_STATS_SERVICE,
	IPXSTRM_MAX_COUNT,
};

enum IPSTRM_TAG
{
	IPXSTRM_TAG_VERSION =				XFER_TAG(1, XFER_DWORD),
	IPXSTRM_TAG_VERSIONADMIN =			XFER_TAG(2, XFER_DWORD),

	IPXSTRM_TAG_STATS_IPX_COLUMNS =		XFER_TAG(3, XFER_COLUMNDATA_ARRAY),
	IPXSTRM_TAG_STATS_IPX_SORT =		XFER_TAG(4, XFER_DWORD),
	IPXSTRM_TAG_STATS_IPX_ASCENDING =	XFER_TAG(5, XFER_DWORD),
	IPXSTRM_TAG_STATS_IPX_POSITION =	XFER_TAG(6, XFER_RECT),

	
	IPXSTRM_TAG_STATS_IPXROUTING_COLUMNS =	XFER_TAG(7, XFER_COLUMNDATA_ARRAY),
	IPXSTRM_TAG_STATS_IPXROUTING_SORT =		XFER_TAG(8, XFER_DWORD),
	IPXSTRM_TAG_STATS_IPXROUTING_ASCENDING =	XFER_TAG(9, XFER_DWORD),
	IPXSTRM_TAG_STATS_IPXROUTING_POSITION =	XFER_TAG(10, XFER_RECT),
	
	IPXSTRM_TAG_STATS_IPXSERVICE_COLUMNS =	XFER_TAG(11, XFER_COLUMNDATA_ARRAY),
	IPXSTRM_TAG_STATS_IPXSERVICE_SORT =		XFER_TAG(12, XFER_DWORD),
	IPXSTRM_TAG_STATS_IPXSERVICE_ASCENDING =	XFER_TAG(13, XFER_DWORD),
	IPXSTRM_TAG_STATS_IPXSERVICE_POSITION =	XFER_TAG(14, XFER_RECT),
};

/*---------------------------------------------------------------------------
	Class:	IPXAdminConfigStream

	This holds the configuration information for the IPX administration
	nodes.  This does NOT hold the configuration information for the columns.
	That is stored in the Component Configuration streams.
 ---------------------------------------------------------------------------*/
class IPXAdminConfigStream : public ConfigStream
{
public:
	IPXAdminConfigStream();

	virtual HRESULT	InitNew();				// set defaults
	virtual HRESULT	SaveTo(IStream *pstm);
	virtual HRESULT SaveAs(UINT nVersion, IStream *pstm);
	
	virtual HRESULT LoadFrom(IStream *pstm);

	virtual HRESULT GetSize(ULONG *pcbSize);


	// --------------------------------------------------------
	// Accessors
	// --------------------------------------------------------
	
	virtual HRESULT	GetVersionInfo(DWORD *pnVersion, DWORD *pnAdminVersion);

protected:
	HRESULT XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize);

};


/*---------------------------------------------------------------------------
	These IDs are used by the component config stream.
 ---------------------------------------------------------------------------*/

enum
{
	COLUMNS_SUMMARY = 0,
	COLUMNS_NBBROADCASTS = 1,
	COLUMNS_STATICROUTES = 2,
	COLUMNS_STATICSERVICES = 3,
	COLUMNS_STATICNETBIOSNAMES = 4,
	COLUMNS_MAX_COUNT,
};

class IPXComponentConfigStream : public ConfigStream
{
public:
	virtual HRESULT XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize);
protected:
};


#endif _IPXSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxstats.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ipxstats.cpp
		IPX Statistics implementation.
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "rtrutil.h"	// smart MPR handle pointers
#include "format.h"		// FormatNumber function
#include "column.h"		// containercolumninfo
#include "ipxconn.h"		// IPXConnection
#include "ipxutil.h"
#include "rtrlib.h"		// DWORD_CMP
#include "ipxrtdef.h"
#include "routprot.h"
#include "stm.h"		// for IPX_SERVICE
#include "listctrl.h"

#include "statsdlg.h"
#include "ipxstats.h"
#include "resource.h"



/*---------------------------------------------------------------------------
	IPXStatisticsDialog implementation
 ---------------------------------------------------------------------------*/


BOOL IPXStatisticsDialog::OnInitDialog()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString stType;
    CString stHost;

    GetWindowText(stType);

    stHost.Format((LPCTSTR) stType,
                  m_pIPXConn->GetMachineName());

    SetWindowText(stHost);
    
    return StatsDialog::OnInitDialog();
}

/*!--------------------------------------------------------------------------
	IPXStatisticsDialog::PostNcDestroy
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IPXStatisticsDialog::PostNcDestroy()
{
	StatsDialog::PostNcDestroy();
	m_dwSortSubitem = 0xFFFFFFFF;
}

/*!--------------------------------------------------------------------------
	IPXStatisticsDialog::Sort
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IPXStatisticsDialog::Sort(UINT nColumnId)
{
    DWORD   dwSubitemId;
    
    if (m_pConfig)
        dwSubitemId = m_pConfig->MapColumnToSubitem(m_ulId, nColumnId);
    else
        dwSubitemId = m_viewInfo.MapColumnToSubitem(nColumnId);

	if (m_dwSortSubitem != -1)
	{
		if (dwSubitemId == m_dwSortSubitem)
			m_fSortDirection = !m_fSortDirection;
		else
			m_fSortDirection = 0;
	}

	if (m_fSortDirection && GetInverseSortFunction())
		m_listCtrl.SortItems(GetInverseSortFunction(), dwSubitemId);
	else if (GetSortFunction())
		m_listCtrl.SortItems(GetSortFunction(), dwSubitemId);
	m_dwSortSubitem = dwSubitemId;		
}

/*!--------------------------------------------------------------------------
	IPXStatisticsDialog::SetConnectionData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IPXStatisticsDialog::SetConnectionData(IPXConnection *pIPXConn)
{
	if (m_pIPXConn)
		m_pIPXConn->Release();
	
	m_pIPXConn = pIPXConn;
	
	if (pIPXConn)
		pIPXConn->AddRef();
}

/*!--------------------------------------------------------------------------
	IPXStatisticsDialog::GetSortFunction
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
PFNLVCOMPARE IPXStatisticsDialog::GetSortFunction()
{
	return NULL;
}

/*!--------------------------------------------------------------------------
	IPXStatisticsDialog::GetInverseSortFunction
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
PFNLVCOMPARE IPXStatisticsDialog::GetInverseSortFunction()
{
	return NULL;
}





//
// This list MUST be kept in sync with the enum above.
//
extern const ContainerColumnInfo	s_rgIpxStatsColumnInfo[];
const ContainerColumnInfo	s_rgIpxStatsColumnInfo[] =
{
	{ IDS_STATS_IPX_STATE,				0,		TRUE, COL_STATUS },
	{ IDS_STATS_IPX_NETWORK,			0,		TRUE, COL_IPXNET },
	{ IDS_STATS_IPX_NODE,				0,		TRUE, COL_STRING },
	{ IDS_STATS_IPX_INTERFACE_COUNT,	0,		TRUE, COL_LARGE_NUM },
	{ IDS_STATS_IPX_ROUTE_COUNT,		0,		TRUE, COL_LARGE_NUM },
	{ IDS_STATS_IPX_SERVICE_COUNT,		0,		TRUE, COL_LARGE_NUM },
	{ IDS_STATS_IPX_PACKETS_SENT,		0,		TRUE, COL_LARGE_NUM },
	{ IDS_STATS_IPX_PACKETS_RCVD,		0,		TRUE, COL_LARGE_NUM },
	{ IDS_STATS_IPX_PACKETS_FRWD,		0,		TRUE, COL_LARGE_NUM },
};

DEBUG_DECLARE_INSTANCE_COUNTER(IpxInfoStatistics);

/*!--------------------------------------------------------------------------
	IpxInfoStatistics::IpxInfoStatistics
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
IpxInfoStatistics::IpxInfoStatistics()
	: IPXStatisticsDialog(/*STATSDLG_FULLWINDOW | */
				  STATSDLG_CONTEXTMENU |
				  STATSDLG_SELECT_COLUMNS |
				  STATSDLG_VERTICAL)
{
	SetColumnInfo(s_rgIpxStatsColumnInfo,
				  DimensionOf(s_rgIpxStatsColumnInfo));

	DEBUG_INCREMENT_INSTANCE_COUNTER(IpxInfoStatistics);
}

/*!--------------------------------------------------------------------------
	IpxInfoStatistics::~IpxInfoStatistics
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
IpxInfoStatistics::~IpxInfoStatistics()
{
	SetConnectionData(NULL);

	DEBUG_DECREMENT_INSTANCE_COUNTER(IpxInfoStatistics);
}

/*!--------------------------------------------------------------------------
	IpxInfoStatistics::RefreshData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/

struct SIpxInfoData
{
	IPXMIB_BASE		m_mibBase;

	DWORD			m_cForwarded;
	DWORD			m_cReceived;
	DWORD			m_cSent;
};

HRESULT IpxInfoStatistics::RefreshData(BOOL fGrabNewData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	int						i;
	int						iPos;
	DWORD					dwValue;
	CString					st;
	TCHAR					szNumber[32];
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	PIPXMIB_BASE			pIpxMib = NULL;
	DWORD					cbIpxMib;
	DWORD					dwErr;
	SIpxInfoData			ipxInfo;
	SPMprMibBuffer			spMib;
	PIPX_INTERFACE			pIpxIf = NULL;
	DWORD					cbIpxIf;
	HRESULT					hr = hrOK;

	MibGetInputData.TableId = IPX_BASE_ENTRY;
	dwErr = ::MprAdminMIBEntryGet(m_pIPXConn->GetMibHandle(),
								  PID_IPX,
								  IPX_PROTOCOL_BASE,
								  &MibGetInputData,
								  sizeof(MibGetInputData),
								  (LPVOID *) &pIpxMib,
								  &cbIpxMib);
	hr = HRESULT_FROM_WIN32(dwErr);
	if (FHrSucceeded(hr))
	{
		spMib = (PBYTE) pIpxMib;

		ipxInfo.m_mibBase = *pIpxMib;
	
		// Now loop over the interfaces to grab the aggregate data
		ipxInfo.m_cForwarded = 0;
		ipxInfo.m_cSent = 0;
		ipxInfo.m_cReceived = 0;
		
		MibGetInputData.TableId = IPX_INTERFACE_TABLE;
		dwErr = ::MprAdminMIBEntryGetFirst(m_pIPXConn->GetMibHandle(),
										   PID_IPX,
										   IPX_PROTOCOL_BASE,
										   &MibGetInputData,
										   sizeof(MibGetInputData),
										   (LPVOID *) &pIpxIf,
										   &cbIpxIf);
		hr = HRESULT_FROM_WIN32(dwErr);
		spMib.Free();
		spMib = (PBYTE) pIpxIf;
		
		while (FHrSucceeded(hr))
		{
			if (pIpxIf->InterfaceIndex == 0)
				ipxInfo.m_cForwarded -= pIpxIf->IfStats.InDelivers;
			else
			{
				ipxInfo.m_cReceived += pIpxIf->IfStats.InDelivers;
				ipxInfo.m_cForwarded += pIpxIf->IfStats.OutDelivers;
				ipxInfo.m_cSent += pIpxIf->IfStats.OutDelivers;
			}
			
			MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex =
				pIpxIf->InterfaceIndex;
			
			spMib.Free();
			pIpxIf = NULL;
			
			dwErr = ::MprAdminMIBEntryGetNext(m_pIPXConn->GetMibHandle(),
											  PID_IPX,
											  IPX_PROTOCOL_BASE,
											  &MibGetInputData,
											  sizeof(MibGetInputData),
											  (LPVOID *) &pIpxIf,
											  &cbIpxIf);
			spMib = (PBYTE) pIpxIf;
			hr = HRESULT_FROM_WIN32(dwErr);
		}

		if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
			hr = hrOK;
	}

	for (i=0; i<MVR_IPX_COUNT; i++)
	{
		if (IsSubitemVisible(i))
		{
			if (!FHrSucceeded(hr))
				st.LoadString(IDS_STATS_NA);
			else
			{
				st.Empty();
				dwValue = 0;
				
				switch (i)
				{
					case MVR_IPX_STATE:
						st = IpxOperStateToCString(
								ipxInfo.m_mibBase.OperState);
						break;
					case MVR_IPX_NETWORK:
						FormatIpxNetworkNumber(szNumber,
							DimensionOf(szNumber),
							ipxInfo.m_mibBase.PrimaryNetNumber,
							DimensionOf(ipxInfo.m_mibBase.PrimaryNetNumber));
						st = szNumber;
						break;
					case MVR_IPX_NODE:
						FormatMACAddress(szNumber,
										 DimensionOf(szNumber),
										 ipxInfo.m_mibBase.Node,
										 DimensionOf(ipxInfo.m_mibBase.Node));
						st = szNumber;
						break;
					case MVR_IPX_INTERFACE_COUNT:
						dwValue = ipxInfo.m_mibBase.IfCount;
						break;
					case MVR_IPX_ROUTE_COUNT:
						dwValue = ipxInfo.m_mibBase.DestCount;
						break;
					case MVR_IPX_SERVICE_COUNT:
						dwValue = ipxInfo.m_mibBase.ServCount;
						break;
					case MVR_IPX_PACKETS_SENT:
						dwValue = ipxInfo.m_cSent;
						break;						
					case MVR_IPX_PACKETS_RCVD:
						dwValue = ipxInfo.m_cReceived;
						break;						
					case MVR_IPX_PACKETS_FRWD:
						dwValue = ipxInfo.m_cForwarded;
						break;						
					default:
						Panic1("Unknown IPX statistic id : %d", i);
						st.LoadString(IDS_STATS_NA);
						break;
				}

				if (st.IsEmpty())
				{
					FormatNumber(dwValue, szNumber, DimensionOf(szNumber),
								 FALSE);
					st = szNumber;
				}
			}
			
			iPos = MapSubitemToColumn(i);			
			m_listCtrl.SetItemText(iPos, 1, (LPCTSTR) st);
		}
	}

	return hr;
}


/*!--------------------------------------------------------------------------
	IpxInfoStatistics::OnInitDialog
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL IpxInfoStatistics::OnInitDialog()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CString	st;

	st.LoadString(IDS_STATS_IPX_INFO_TITLE);
	SetWindowText((LPCTSTR) st);
	return IPXStatisticsDialog::OnInitDialog();
}

/*!--------------------------------------------------------------------------
	IpxInfoStatistics::Sort
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxInfoStatistics::Sort(UINT nColumnId)
{
	// Don't do anything, the statistics are displayed in a
	// vertical format
}




/*---------------------------------------------------------------------------
	IpxRoutingStatistics implementation
 ---------------------------------------------------------------------------*/

extern const ContainerColumnInfo	s_rgIpxRoutingStatsColumnInfo[];
const ContainerColumnInfo	s_rgIpxRoutingStatsColumnInfo[] =
{
	{ IDS_STATS_IPXROUTING_NETWORK,			0,		TRUE, COL_IPXNET },
	{ IDS_STATS_IPXROUTING_NEXT_HOP_MAC,	0,		TRUE, COL_IPXNET },
	{ IDS_STATS_IPXROUTING_TICK_COUNT,		0,		TRUE, COL_LARGE_NUM },
	{ IDS_STATS_IPXROUTING_HOP_COUNT,		0,		TRUE, COL_SMALL_NUM },
	{ IDS_STATS_IPXROUTING_IF_NAME,			0,		TRUE, COL_IF_NAME },
	{ IDS_STATS_IPXROUTING_PROTOCOL,		0,		TRUE, COL_STRING },
	{ IDS_STATS_IPXROUTING_ROUTE_NOTES,		0,		TRUE, COL_STRING },
};

BEGIN_MESSAGE_MAP(IpxRoutingStatistics, IPXStatisticsDialog)
	ON_NOTIFY(LVN_GETDISPINFO, IDC_STATSDLG_LIST, OnNotifyGetDispInfo)
END_MESSAGE_MAP()

/*!--------------------------------------------------------------------------
	IpxRoutingStatistics::IpxRoutingStatistics
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
IpxRoutingStatistics::IpxRoutingStatistics()
	: IPXStatisticsDialog(/* STATSDLG_FULLWINDOW |*/
				  STATSDLG_CONTEXTMENU |
				  STATSDLG_SELECT_COLUMNS),
	m_dwSortSubitem(0xFFFFFFFF)
{
	m_ColWidthMultiple = 1;
	m_ColWidthAdder = 15;
    SetColumnInfo(s_rgIpxRoutingStatsColumnInfo, DimensionOf(s_rgIpxRoutingStatsColumnInfo));

	if (m_pConfig)
	{
		ULONG cColumns = m_pConfig->GetColumnCount(m_ulId);
		ColumnData *pColumnData = (ColumnData *) alloca(sizeof(ColumnData) * cColumns);
		m_pConfig->GetColumnData(m_ulId, cColumns, pColumnData);
		pColumnData[3].fmt = LVCFMT_RIGHT;
		pColumnData[4].fmt = LVCFMT_RIGHT;
		m_pConfig->SetColumnData(m_ulId, cColumns, pColumnData);
	}
	else
	{
		ULONG cColumns = m_viewInfo.GetColumnCount();
		ColumnData *pColumnData = (ColumnData *) alloca(sizeof(ColumnData) * cColumns);
		m_viewInfo.GetColumnData(cColumns, pColumnData);
		pColumnData[3].fmt = LVCFMT_RIGHT;
		pColumnData[4].fmt = LVCFMT_RIGHT;
		m_viewInfo.SetColumnData(cColumns, pColumnData);
	}
}

/*!--------------------------------------------------------------------------
	IpxRoutingStatistics::~IpxRoutingStatistics
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
IpxRoutingStatistics::~IpxRoutingStatistics()
{
	SetConnectionData(NULL);
}

/*!--------------------------------------------------------------------------
	IpxRoutingStatistics::SetRouterInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxRoutingStatistics::SetRouterInfo(IRouterInfo *pRouterInfo)
{
	m_spRouterInfo.Set(pRouterInfo);
}

			
/*!--------------------------------------------------------------------------
	IpxRoutingStatistics::RefreshData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxRoutingStatistics::RefreshData(BOOL fGrabNewData)
{
	HRESULT		hr = hrOK;
	int			i, cItems;

	FixColumnAlignment();
	
	CORg( GetIpxRoutingData() );
	
	// Prepare the list control for the large amount of entries
	if (m_listCtrl.GetItemCount() < m_Items.GetSize())
		m_listCtrl.SetItemCount((int) m_Items.GetSize());

	
	// Iterate through the array adding the data to the list control
	cItems = (int) m_Items.GetSize();
	for (i=0; i<cItems; i++)
	{
		// Add the items as callback items
		m_listCtrl.InsertItem(LVIF_TEXT | LVIF_PARAM, i, LPSTR_TEXTCALLBACK,
							  0, 0, 0, (LPARAM) i);
	}
	
Error:
	return hrOK;
}


/*!--------------------------------------------------------------------------
	IpxRoutingStatistics::GetIpxRoutingData
		Grabs the IPX routing table and fills in the m_Items array with
		that data.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxRoutingStatistics::GetIpxRoutingData()
{
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	PIPXMIB_BASE			pIpxMib = NULL;
	DWORD					cbIpxMib;
	DWORD					dwErr;
	HRESULT					hr = hrOK;
	SPMprMibBuffer			spMib;
	PIPX_ROUTE				pRoute = NULL;
	SPMprMibBuffer			spMibRoute;
	DWORD					cbRoute;
	int						cEntries = 0;

	// Load up on the interface titles
	CORg( FillInterfaceTable() );								

	MibGetInputData.TableId = IPX_BASE_ENTRY;
	CWRg( ::MprAdminMIBEntryGet(m_pIPXConn->GetMibHandle(),
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&MibGetInputData,
								sizeof(MibGetInputData),
								(LPVOID *) &pIpxMib,
								&cbIpxMib) );
	if(pIpxMib == NULL)
	{
		hr = E_FAIL;
		goto Error;
	}

	spMib = (PBYTE) pIpxMib;

	// Prepare the data array for the number of items (+ some buffer)
	m_Items.SetSize( pIpxMib->DestCount + 100);

	MibGetInputData.TableId = IPX_DEST_TABLE;
	
	dwErr = ::MprAdminMIBEntryGetFirst(m_pIPXConn->GetMibHandle(),
									   PID_IPX,
									   IPX_PROTOCOL_BASE,
									   &MibGetInputData,
									   sizeof(MibGetInputData),
									   (LPVOID *) &pRoute,
									   &cbRoute);
	hr = HRESULT_FROM_WIN32(dwErr);
	spMibRoute = (PBYTE) pRoute;

	cEntries = 0;

	while (FHrSucceeded(hr))
	{
		Assert(pRoute);
		
		// Add this data at position cEntries
		m_Items.SetAtGrow(cEntries, *pRoute);
		cEntries++;
		
		// Get the next set of data
		MibGetInputData.TableId = IPX_DEST_TABLE;
		memcpy(MibGetInputData.MibIndex.RoutingTableIndex.Network,
			   pRoute->Network,
			   sizeof(MibGetInputData.MibIndex.RoutingTableIndex.Network));
		pRoute = NULL;
		spMibRoute.Free();
			   
		dwErr = ::MprAdminMIBEntryGetNext(m_pIPXConn->GetMibHandle(),
										  PID_IPX,
										  IPX_PROTOCOL_BASE,
										  &MibGetInputData,
										  sizeof(MibGetInputData),
										  (LPVOID *) &pRoute,
										  &cbRoute);
		hr = HRESULT_FROM_WIN32(dwErr);
		spMibRoute = (PBYTE) pRoute;
	}

	// Do this to make sure that we don't have bogus entries at the top
	// of the array and that we can use the GetSize() to get an accurate
	// count of the number of items.
	m_Items.SetSize(cEntries);
	
Error:
	if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
		hr = hrOK;
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxRoutingStatistics::FillInterfaceTable
		Fills m_rgIfTitle with the interface titles.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxRoutingStatistics::FillInterfaceTable()
{
	HRESULT					hr = hrOK;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	PIPX_INTERFACE			pIpxIf = NULL;
	DWORD					cbIfTable;
	SPIInterfaceInfo		spIf;
	SPIEnumInterfaceInfo	spEnumIf;
	LPCOLESTR				poszIfName;
	SPMprMibBuffer			spMib;
	DWORD					dwErr;
	USES_CONVERSION;

	MibGetInputData.TableId = IPX_INTERFACE_TABLE;
	CWRg( ::MprAdminMIBEntryGetFirst(m_pIPXConn->GetMibHandle(),
									 PID_IPX,
									 IPX_PROTOCOL_BASE,
									 &MibGetInputData,
									 sizeof(MibGetInputData),
									 (LPVOID *) &pIpxIf,
									 &cbIfTable));
	spMib = (PBYTE) pIpxIf;

	m_spRouterInfo->EnumInterface(&spEnumIf);
	
	while (FHrSucceeded(hr))
	{
		poszIfName = A2COLE((LPCSTR)(pIpxIf->InterfaceName));
		
		spIf.Release();
		
		spEnumIf->Reset();
		for (; spEnumIf->Next(1, &spIf, NULL) == hrOK; spIf.Release())
		{
			// Look for a match on the interface name
			if (StriCmpOle(poszIfName, spIf->GetId()) == 0)
			{
				m_rgIfTitle.SetAtGrow(pIpxIf->InterfaceIndex,
									  OLE2CT(spIf->GetTitle()));
				break;
			}
		}

		MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex =
			pIpxIf->InterfaceIndex;

		// Get the next name
		spMib.Free();
		pIpxIf = NULL;
		
		dwErr = ::MprAdminMIBEntryGetNext(m_pIPXConn->GetMibHandle(),
										  PID_IPX,
										  IPX_PROTOCOL_BASE,
										  &MibGetInputData,
										  sizeof(MibGetInputData),
										  (LPVOID *) &pIpxIf,
										  &cbIfTable);
		hr = HRESULT_FROM_WIN32(dwErr);
		spMib = (PBYTE) pIpxIf;
	}

Error:
	if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
		hr = hrOK;
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxRoutingStatistics::FixColumnAlignment
		-
	Author: Deonb
    Fixes the column allignment for the Tick & Hop count columns.
 ---------------------------------------------------------------------------*/
void IpxRoutingStatistics::FixColumnAlignment()
{
	ULONG cColumns; 
	ColumnData *pColumnData;

	if (m_pConfig)
	{
		cColumns = m_pConfig->GetColumnCount(m_ulId);
		pColumnData = (ColumnData *) alloca(sizeof(ColumnData) * cColumns);

		m_pConfig->GetColumnData(m_ulId, cColumns, pColumnData);
		for (ULONG i = 0; i < cColumns; i++)
			pColumnData[m_pConfig->MapColumnToSubitem(m_ulId, i)].fmt = LVCFMT_LEFT;
		
		pColumnData[m_pConfig->MapColumnToSubitem(m_ulId, 2)].fmt = LVCFMT_RIGHT;
		pColumnData[m_pConfig->MapColumnToSubitem(m_ulId, 3)].fmt = LVCFMT_RIGHT;
		m_pConfig->SetColumnData(m_ulId, cColumns, pColumnData);
	}
	else
	{
		cColumns = m_viewInfo.GetColumnCount();
		pColumnData = (ColumnData *) alloca(sizeof(ColumnData) * cColumns);

		m_viewInfo.GetColumnData(cColumns, pColumnData);
		
		for (ULONG i = 0; i < cColumns; i++)
			pColumnData[m_viewInfo.MapColumnToSubitem(i)].fmt = LVCFMT_LEFT;
		
		pColumnData[m_viewInfo.MapColumnToSubitem(2)].fmt = LVCFMT_RIGHT;
		pColumnData[m_viewInfo.MapColumnToSubitem(3)].fmt = LVCFMT_RIGHT;
		m_viewInfo.SetColumnData(cColumns, pColumnData);
	}

	for (ULONG i = 0; i < cColumns; i++)
	{
		LVCOLUMN lvc;
		lvc.mask = LVCF_FMT;
		lvc.fmt = pColumnData[i].fmt;
		m_listCtrl.SendMessage(LVM_SETCOLUMN, i, (LPARAM)&lvc);
	}
}

/*!--------------------------------------------------------------------------
	IpxRoutingStatistics::OnInitDialog
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL IpxRoutingStatistics::OnInitDialog()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CString	st;

	st.LoadString(IDS_STATS_IPX_ROUTING_TITLE);
	SetWindowText((LPCTSTR) st);

	FixColumnAlignment();

	return IPXStatisticsDialog::OnInitDialog();
}

/*!--------------------------------------------------------------------------
	IpxRoutingStatistics::PostNcDestroy
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxRoutingStatistics::PostNcDestroy()
{
	IPXStatisticsDialog::PostNcDestroy();
	m_dwSortSubitem = 0xFFFFFFFF;
}



/*!--------------------------------------------------------------------------
	IpxRoutingStatisticsCompareProc
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
struct SIpxRoutingSortInfo
{
	DWORD	m_dwSubitemId;
	IpxRoutingStatistics *	m_pIpx;
};

int CALLBACK IpxRoutingStatisticsCompareProc(LPARAM lParam1, LPARAM lParam2,
									  LPARAM lParamSort)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	int	iReturn = 0;
	SIpxRoutingSortInfo *	pSort = (SIpxRoutingSortInfo *) lParamSort;
	IpxRoutingStatistics *	pIpx;
	PIPX_ROUTE				pRoute1;
	PIPX_ROUTE				pRoute2;

	pIpx = pSort->m_pIpx;
	pRoute1 = &(pIpx->m_Items[(int)lParam1]);
	pRoute2 = &(pIpx->m_Items[(int)lParam2]);
	
	switch (pSort->m_dwSubitemId)
	{
		case MVR_IPXROUTING_NETWORK:
			iReturn = memcmp(pRoute1->Network,
							 pRoute2->Network,
							 sizeof(pRoute1->Network));
			break;
		case MVR_IPXROUTING_NEXT_HOP_MAC:
			iReturn = memcmp(pRoute1->NextHopMacAddress,
							 pRoute2->NextHopMacAddress,
							 sizeof(pRoute1->NextHopMacAddress));
			break;
		case MVR_IPXROUTING_TICK_COUNT:
			iReturn = DWORD_CMP(pRoute1->TickCount,
								pRoute2->TickCount);
			break;
		case MVR_IPXROUTING_HOP_COUNT:
			iReturn = DWORD_CMP(pRoute1->HopCount,
								pRoute2->HopCount);
			break;
		case MVR_IPXROUTING_IF_NAME:
			{
				CString	st1, st2;
				if (pRoute1->InterfaceIndex == GLOBAL_INTERFACE_INDEX)
					st1.LoadString(IDS_IPX_WAN_CLIENT_ROUTE);
				else
					st1 = pIpx->m_rgIfTitle[pRoute1->InterfaceIndex];
			
				if (pRoute2->InterfaceIndex == GLOBAL_INTERFACE_INDEX)
					st2.LoadString(IDS_IPX_WAN_CLIENT_ROUTE);
				else
					st2 = pIpx->m_rgIfTitle[pRoute2->InterfaceIndex];
				iReturn = StriCmp((LPCTSTR) st1, (LPCTSTR) st2);
			}
			break;
		case MVR_IPXROUTING_PROTOCOL:
			{
				CString	st1, st2;
				st1 = IpxProtocolToCString(pRoute1->Protocol);
				st2 = IpxProtocolToCString(pRoute2->Protocol);
				iReturn = StriCmp((LPCTSTR) st1, (LPCTSTR) st2);
			}
			break;
		case MVR_IPXROUTING_ROUTE_NOTES:
			iReturn = DWORD_CMP(pRoute1->Flags,
								pRoute2->Flags);
			break;
	}
	return iReturn;
}


/*!--------------------------------------------------------------------------
	IpxRoutingStatisticsCompareProcMinus
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
int CALLBACK IpxRoutingStatisticsCompareProcMinus(LPARAM lParam1, LPARAM lParam2,
									  LPARAM lParamSort)

{
	return -IpxRoutingStatisticsCompareProc(lParam1, lParam2, lParamSort);
}

/*!--------------------------------------------------------------------------
	IpxRoutingStatistics::Sort
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxRoutingStatistics::Sort(UINT nColumnId)
{
    SIpxRoutingSortInfo		ipxSortInfo;
    DWORD                   dwSubitemId;
    
    if (m_pConfig)
        dwSubitemId = m_pConfig->MapColumnToSubitem(m_ulId, nColumnId);
    else
        dwSubitemId = m_viewInfo.MapColumnToSubitem(nColumnId);

	if (m_dwSortSubitem != -1)
	{
		if (dwSubitemId == m_dwSortSubitem)
			m_fSortDirection = !m_fSortDirection;
		else
			m_fSortDirection = 0;
	}

	ipxSortInfo.m_dwSubitemId = dwSubitemId;
	ipxSortInfo.m_pIpx = this;

	if (m_fSortDirection)
	{
		m_listCtrl.SortItems(IpxRoutingStatisticsCompareProcMinus, (LPARAM) &ipxSortInfo);
	}
	else
	{
		m_listCtrl.SortItems(IpxRoutingStatisticsCompareProc, (LPARAM) &ipxSortInfo);
	}
	m_dwSortSubitem = dwSubitemId;
}

/*!--------------------------------------------------------------------------
	IpxRoutingStatistics::PreDeleteAllItems
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxRoutingStatistics::PreDeleteAllItems()
{
	m_Items.SetSize(0);
}

/*!--------------------------------------------------------------------------
	IpxRoutingStatistics::OnNotifyGetDispInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxRoutingStatistics::OnNotifyGetDispInfo(NMHDR *pNmHdr, LRESULT *pResult)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	LV_DISPINFO *	plvDispInfo = reinterpret_cast<LV_DISPINFO *>(pNmHdr);
	LV_ITEM *		plvItem = &(plvDispInfo->item);
	ULONG			iIndex = (ULONG)plvItem->lParam;
	TCHAR			szNumber[32];
	CString			st;

	if ((plvItem->mask & LVIF_PARAM) == 0)
	{
		// Ok, this lParam is not valid, we will need to request
		// the lParam for this item
		iIndex = (ULONG)m_listCtrl.GetItemData(plvItem->iItem);
	}

	// Ok, we can now get the data for this item
	switch (MapColumnToSubitem(plvItem->iSubItem))
	{
		case MVR_IPXROUTING_NETWORK:
			FormatIpxNetworkNumber(szNumber, DimensionOf(szNumber),
								   m_Items[iIndex].Network,
								   DimensionOf(m_Items[iIndex].Network));
			st = szNumber;
			break;
		case MVR_IPXROUTING_NEXT_HOP_MAC:
			FormatMACAddress(szNumber, DimensionOf(szNumber),
							 m_Items[iIndex].NextHopMacAddress,
							 DimensionOf(m_Items[iIndex].NextHopMacAddress));
			st = szNumber;
			break;
		case MVR_IPXROUTING_TICK_COUNT:
			FormatNumber(m_Items[iIndex].TickCount,
						 szNumber, DimensionOf(szNumber),
						 FALSE);
			st = szNumber;
			break;
		case MVR_IPXROUTING_HOP_COUNT:
			FormatNumber(m_Items[iIndex].HopCount,
						 szNumber, DimensionOf(szNumber),
						 FALSE);
			st = szNumber;
			break;
		case MVR_IPXROUTING_IF_NAME:
			if (m_Items[iIndex].InterfaceIndex == GLOBAL_INTERFACE_INDEX)
				st.LoadString(IDS_IPX_WAN_CLIENT_ROUTE);
			else
				st = m_rgIfTitle[m_Items[iIndex].InterfaceIndex];
			break;
		case MVR_IPXROUTING_PROTOCOL:
			st = IpxProtocolToCString(m_Items[iIndex].Protocol);
			break;
		case MVR_IPXROUTING_ROUTE_NOTES:
			st = IpxRouteNotesToCString(m_Items[iIndex].Flags);
			break;
		default:
			Panic1("Unknown IPX routing id! %d",
				   MapColumnToSubitem(plvItem->iSubItem));
			break;
	}
	lstrcpyn(plvItem->pszText, (LPCTSTR) st, plvItem->cchTextMax);
}


/*---------------------------------------------------------------------------
	IpxServiceStatistics implementation
 ---------------------------------------------------------------------------*/

extern const ContainerColumnInfo	s_rgIpxServiceStatsColumnInfo[];
const ContainerColumnInfo	s_rgIpxServiceStatsColumnInfo[] =
{
	{ IDS_STATS_IPXSERVICE_SERVICE_NAME,	0,		TRUE, COL_STRING },
	{ IDS_STATS_IPXSERVICE_SERVICE_TYPE,	0,		TRUE, COL_STRING },
	{ IDS_STATS_IPXSERVICE_SERVICE_ADDRESS,	0,		TRUE, COL_STRING },
	{ IDS_STATS_IPXSERVICE_HOP_COUNT,		0,		TRUE, COL_SMALL_NUM },
	{ IDS_STATS_IPXSERVICE_IF_NAME,			0,		TRUE, COL_IF_NAME },
	{ IDS_STATS_IPXSERVICE_PROTOCOL,		0,		TRUE, COL_STRING },
};

BEGIN_MESSAGE_MAP(IpxServiceStatistics, IPXStatisticsDialog)
	ON_NOTIFY(LVN_GETDISPINFO, IDC_STATSDLG_LIST, OnNotifyGetDispInfo)
END_MESSAGE_MAP()

/*!--------------------------------------------------------------------------
	IpxServiceStatistics::IpxServiceStatistics
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
IpxServiceStatistics::IpxServiceStatistics()
	: IPXStatisticsDialog(/*STATSDLG_FULLWINDOW |*/
				  STATSDLG_CONTEXTMENU |
				  STATSDLG_SELECT_COLUMNS),
	m_dwSortSubitem(0xFFFFFFFF)
{
	SetColumnInfo(s_rgIpxServiceStatsColumnInfo,
				  DimensionOf(s_rgIpxServiceStatsColumnInfo));
}

/*!--------------------------------------------------------------------------
	IpxServiceStatistics::~IpxServiceStatistics
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
IpxServiceStatistics::~IpxServiceStatistics()
{
	m_Items.SetSize(0);
	SetConnectionData(NULL);
}

/*!--------------------------------------------------------------------------
	IpxServiceStatistics::SetRouterInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxServiceStatistics::SetRouterInfo(IRouterInfo *pRouterInfo)
{
	m_spRouterInfo.Set(pRouterInfo);
}

			
/*!--------------------------------------------------------------------------
	IpxServiceStatistics::RefreshData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxServiceStatistics::RefreshData(BOOL fGrabNewData)
{
	HRESULT		hr = hrOK;
	int			i, cItems;

	if (fGrabNewData)
	{
		m_Items.SetSize(0);
		
		CORg( GetIpxServiceData() );
	
		// Prepare the list control for the large amount of entries
		if (m_listCtrl.GetItemCount() < m_Items.GetSize())
			m_listCtrl.SetItemCount((int) m_Items.GetSize());
	}

	
	// Iterate through the array adding the data to the list control
	cItems = (int) m_Items.GetSize();
	for (i=0; i<cItems; i++)
	{
		// Add the items as callback items
		m_listCtrl.InsertItem(LVIF_TEXT | LVIF_PARAM, i, LPSTR_TEXTCALLBACK,
							  0, 0, 0, (DWORD) i);
	}
	
Error:
	return hrOK;
}


/*!--------------------------------------------------------------------------
	IpxServiceStatistics::GetIpxServiceData
		Grabs the IPX service table and fills in the m_Items array with
		that data.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxServiceStatistics::GetIpxServiceData()
{
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	PIPXMIB_BASE			pIpxMib = NULL;
	DWORD					cbIpxMib;
	DWORD					dwErr;
	HRESULT					hr = hrOK;
	SPMprMibBuffer			spMib;
	PIPX_SERVICE			pService = NULL;
	SPMprMibBuffer			spMibRoute;
	DWORD					cbService;
	int						cEntries = 0;

	// Load up on the interface titles
	CORg( FillInterfaceTable() );								

	MibGetInputData.TableId = IPX_BASE_ENTRY;
	CWRg( ::MprAdminMIBEntryGet(m_pIPXConn->GetMibHandle(),
								PID_IPX,
								IPX_PROTOCOL_BASE,
								&MibGetInputData,
								sizeof(MibGetInputData),
								(LPVOID *) &pIpxMib,
								&cbIpxMib) );
	if(pIpxMib == NULL)
	{
		hr = E_FAIL;
		goto Error;
	}
	
	spMib = (PBYTE) pIpxMib;

	// Prepare the data array for the number of items (+ some buffer)
	m_Items.SetSize( pIpxMib->DestCount + 100);

	MibGetInputData.TableId = IPX_SERV_TABLE;
	
	dwErr = ::MprAdminMIBEntryGetFirst(m_pIPXConn->GetMibHandle(),
									   PID_IPX,
									   IPX_PROTOCOL_BASE,
									   &MibGetInputData,
									   sizeof(MibGetInputData),
									   (LPVOID *) &pService,
									   &cbService);
	hr = HRESULT_FROM_WIN32(dwErr);
	spMibRoute = (PBYTE) pService;

	cEntries = 0;

	while (FHrSucceeded(hr))
	{
		Assert(pService);
		
		// Add this data at position cEntries
		m_Items.SetAtGrow(cEntries, *pService);
		cEntries++;
		
		// Get the next set of data
		MibGetInputData.TableId = IPX_SERV_TABLE;
		MibGetInputData.MibIndex.ServicesTableIndex.ServiceType =
			pService->Server.Type;
		memcpy(MibGetInputData.MibIndex.ServicesTableIndex.ServiceName,
			   pService->Server.Name,
			   sizeof(MibGetInputData.MibIndex.ServicesTableIndex.ServiceName));
		pService = NULL;
		spMibRoute.Free();
			   
		dwErr = ::MprAdminMIBEntryGetNext(m_pIPXConn->GetMibHandle(),
										  PID_IPX,
										  IPX_PROTOCOL_BASE,
										  &MibGetInputData,
										  sizeof(MibGetInputData),
										  (LPVOID *) &pService,
										  &cbService);
		hr = HRESULT_FROM_WIN32(dwErr);
		spMibRoute = (PBYTE) pService;
	}

	// Do this to make sure that we don't have bogus entries at the top
	// of the array and that we can use the GetSize() to get an accurate
	// count of the number of items.
	m_Items.SetSize(cEntries);
	
Error:
	if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
		hr = hrOK;
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxServiceStatistics::FillInterfaceTable
		Fills m_rgIfTitle with the interface titles.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxServiceStatistics::FillInterfaceTable()
{
	HRESULT					hr = hrOK;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	PIPX_INTERFACE			pIpxIf = NULL;
	DWORD					cbIfTable;
	SPIInterfaceInfo		spIf;
	SPIEnumInterfaceInfo	spEnumIf;
	LPCOLESTR				poszIfName;
	SPMprMibBuffer			spMib;
	DWORD					dwErr;
	USES_CONVERSION;

	MibGetInputData.TableId = IPX_INTERFACE_TABLE;
	CWRg( ::MprAdminMIBEntryGetFirst(m_pIPXConn->GetMibHandle(),
									 PID_IPX,
									 IPX_PROTOCOL_BASE,
									 &MibGetInputData,
									 sizeof(MibGetInputData),
									 (LPVOID *) &pIpxIf,
									 &cbIfTable));
	spMib = (PBYTE) pIpxIf;

	m_spRouterInfo->EnumInterface(&spEnumIf);
	
	while (FHrSucceeded(hr))
	{
		poszIfName = A2COLE((LPCSTR)(pIpxIf->InterfaceName));
		
		spIf.Release();
		
		spEnumIf->Reset();
		for (; spEnumIf->Next(1, &spIf, NULL) == hrOK; spIf.Release())
		{
			// Look for a match on the interface name
			if (StriCmpOle(poszIfName, spIf->GetId()) == 0)
			{
				m_rgIfTitle.SetAtGrow(pIpxIf->InterfaceIndex,
									  OLE2CT(spIf->GetTitle()));
				break;
			}
		}

		MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex =
			pIpxIf->InterfaceIndex;

		// Get the next name
		spMib.Free();
		pIpxIf = NULL;
		
		dwErr = ::MprAdminMIBEntryGetNext(m_pIPXConn->GetMibHandle(),
										  PID_IPX,
										  IPX_PROTOCOL_BASE,
										  &MibGetInputData,
										  sizeof(MibGetInputData),
										  (LPVOID *) &pIpxIf,
										  &cbIfTable);
		hr = HRESULT_FROM_WIN32(dwErr);
		spMib = (PBYTE) pIpxIf;
	}

Error:
	if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
		hr = hrOK;
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxServiceStatistics::OnInitDialog
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL IpxServiceStatistics::OnInitDialog()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CString	st;

	st.LoadString(IDS_STATS_IPX_SERVICE_TITLE);
	SetWindowText((LPCTSTR) st);
	return IPXStatisticsDialog::OnInitDialog();
}

/*!--------------------------------------------------------------------------
	IpxServiceStatistics::PostNcDestroy
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxServiceStatistics::PostNcDestroy()
{
	IPXStatisticsDialog::PostNcDestroy();
	m_dwSortSubitem = 0xFFFFFFFF;
}



/*!--------------------------------------------------------------------------
	IpxServiceStatisticsCompareProc
		-
	Author: KennT
 ---------------------------------------------------------------------------*/

struct SIpxServiceSortInfo
{
	DWORD	m_dwSubitemId;
	IpxServiceStatistics *	m_pIpx;
};

int CALLBACK IpxServiceStatisticsCompareProc(LPARAM lParam1, LPARAM lParam2,
									  LPARAM lParamSort)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	int	iReturn = 0;
	SIpxServiceSortInfo *	pSort = (SIpxServiceSortInfo *) lParamSort;
	IpxServiceStatistics *	pIpx;
	PIPX_SERVICE			pService1;
	PIPX_SERVICE			pService2;

	pIpx = pSort->m_pIpx;
	pService1 = &(pIpx->m_Items[(int)lParam1]);
	pService2 = &(pIpx->m_Items[(int)lParam2]);
	
	switch (pSort->m_dwSubitemId)
	{
		case MVR_IPXSERVICE_SERVICE_TYPE:
			iReturn = pService1->Server.Type - pService2->Server.Type;
			break;
		case MVR_IPXSERVICE_SERVICE_NAME:
			iReturn  = StriCmpA((LPCSTR) pService1->Server.Name,
								(LPCSTR) pService2->Server.Name);
			break;
		case MVR_IPXSERVICE_SERVICE_ADDRESS:
			iReturn = memcmp(pService1->Server.Network,
							 pService2->Server.Network,
							 sizeof(pService1->Server.Network));
			if (iReturn == 0)
				iReturn = memcmp(pService1->Server.Node,
								 pService2->Server.Node,
								 sizeof(pService1->Server.Node));
			if (iReturn == 0)
				iReturn = memcmp(pService1->Server.Socket,
								 pService2->Server.Socket,
								 sizeof(pService1->Server.Socket));
			break;
		case MVR_IPXSERVICE_HOP_COUNT:
			iReturn = DWORD_CMP(pService1->Server.HopCount,
								pService2->Server.HopCount);
			break;
		case MVR_IPXSERVICE_IF_NAME:
			{
				CString	st1, st2;
				if (pService1->InterfaceIndex == GLOBAL_INTERFACE_INDEX)
					st1.LoadString(IDS_IPX_WAN_CLIENT_ROUTE);
				else
					st1 = pIpx->m_rgIfTitle[pService1->InterfaceIndex];
				
				if (pService2->InterfaceIndex == GLOBAL_INTERFACE_INDEX)
					st2.LoadString(IDS_IPX_WAN_CLIENT_ROUTE);
				else
					st2 = pIpx->m_rgIfTitle[pService2->InterfaceIndex];
				
				iReturn = StriCmp((LPCTSTR) st1, (LPCTSTR) st2);
			}
			break;
		case MVR_IPXSERVICE_PROTOCOL:
			{
				CString	st1, st2;
				st1 = IpxProtocolToCString(pService1->Protocol);
				st2 = IpxProtocolToCString(pService2->Protocol);
				iReturn = StriCmp((LPCTSTR) st1, (LPCTSTR) st2);
			}
			break;
	}
	return iReturn;
}

/*!--------------------------------------------------------------------------
	IpxServiceStatisticsCompareProcMinus
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
int CALLBACK IpxServiceStatisticsCompareProcMinus(LPARAM lParam1, LPARAM lParam2,
									  LPARAM lParamSort)

{
	return -IpxServiceStatisticsCompareProc(lParam1, lParam2, lParamSort);
}

/*!--------------------------------------------------------------------------
	IpxServiceStatistics::Sort
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxServiceStatistics::Sort(UINT nColumnId)
{
	SIpxServiceSortInfo		ipxSortInfo;
    DWORD                   dwSubitemId;

    if (m_pConfig)
        dwSubitemId = m_pConfig->MapColumnToSubitem(m_ulId, nColumnId);
    else
        dwSubitemId = m_viewInfo.MapColumnToSubitem(nColumnId);

	if (m_dwSortSubitem != -1)
	{
		if (dwSubitemId == m_dwSortSubitem)
			m_fSortDirection = !m_fSortDirection;
		else
			m_fSortDirection = 0;
	}

	ipxSortInfo.m_dwSubitemId = dwSubitemId;
	ipxSortInfo.m_pIpx = this;

	if (m_fSortDirection)
	{
		m_listCtrl.SortItems(IpxServiceStatisticsCompareProcMinus, (LPARAM) &ipxSortInfo);
	}
	else
	{
		m_listCtrl.SortItems(IpxServiceStatisticsCompareProc, (LPARAM) &ipxSortInfo);
	}
	m_dwSortSubitem = dwSubitemId;
}

/*!--------------------------------------------------------------------------
	IpxServiceStatistics::PreDeleteAllItems
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxServiceStatistics::PreDeleteAllItems()
{
}

/*!--------------------------------------------------------------------------
	IpxServiceStatistics::OnNotifyGetDispInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxServiceStatistics::OnNotifyGetDispInfo(NMHDR *pNmHdr, LRESULT *pResult)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	LV_DISPINFO *	plvDispInfo = reinterpret_cast<LV_DISPINFO *>(pNmHdr);
	LV_ITEM *		plvItem = &(plvDispInfo->item);
	ULONG			iIndex = (ULONG)plvItem->lParam;
	TCHAR			szNumber[32];
	CString			st;

	if ((plvItem->mask & LVIF_PARAM) == 0)
	{
		// Ok, this lParam is not valid, we will need to request
		// the lParam for this item
		iIndex = (ULONG)m_listCtrl.GetItemData(plvItem->iItem);
	}

	// Ok, we can now get the data for this item
	switch (MapColumnToSubitem(plvItem->iSubItem))
	{
		case MVR_IPXSERVICE_SERVICE_NAME:
			st.Format(_T("%.48hs"), m_Items[iIndex].Server.Name);
			break;
		case MVR_IPXSERVICE_SERVICE_TYPE:
			st.Format(_T("%.4x"), m_Items[iIndex].Server.Type);
			break;
		case MVR_IPXSERVICE_SERVICE_ADDRESS:
			FormatIpxNetworkNumber(szNumber, DimensionOf(szNumber),
								  m_Items[iIndex].Server.Network,
								  DimensionOf(m_Items[iIndex].Server.Network));
			st = szNumber;
			FormatMACAddress(szNumber, DimensionOf(szNumber),
							 m_Items[iIndex].Server.Node,
							 DimensionOf(m_Items[iIndex].Server.Node));
			st += _T(".");
			st += szNumber;

			wsprintf(szNumber, _T("%.2x%.2x"),
					 m_Items[iIndex].Server.Socket[0],
					 m_Items[iIndex].Server.Socket[1]);
			st += _T(".");
			st += szNumber;
			break;

		case MVR_IPXSERVICE_HOP_COUNT:
			FormatNumber(m_Items[iIndex].Server.HopCount,
						 szNumber, DimensionOf(szNumber),
						 FALSE);
			st = szNumber;
			break;

		case MVR_IPXSERVICE_IF_NAME:
			if (m_Items[iIndex].InterfaceIndex == GLOBAL_INTERFACE_INDEX)
				st.LoadString(IDS_IPX_WAN_CLIENT_ROUTE);
			else
				st = m_rgIfTitle[m_Items[iIndex].InterfaceIndex];
			break;
			
		case MVR_IPXSERVICE_PROTOCOL:
			st = IpxProtocolToCString(m_Items[iIndex].Protocol);
			break;
			
		default:
			Panic1("Unknown IPX service id! %d",
				   MapColumnToSubitem(plvItem->iSubItem));
			break;
	}
	lstrcpyn(plvItem->pszText, (LPCTSTR) st, plvItem->cchTextMax);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxutil.cpp ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    mibutil.cpp
//
// History:
//	7/22/97		Kenn M. Takara			Created.
//
// Implements IPX-related utility functions.
//
//============================================================================


#include "stdafx.h"
#include "ipxutil.h"
#include "tregkey.h"		// RegKey class
#include "reg.h"			// Router registry utility functions
#include "format.h"			// FormatXXX functions
#include "strmap.h"			// MapDWORDToCString
#include "ipxconst.h"		// IPX constants
#include "routprot.h"
#include "ipxrtdef.h"
#include "ctype.h"			// for _totlower

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static CString	s_stIfTypeClient;
static CString	s_stIfTypeHomeRouter;
static CString	s_stIfTypeFullRouter;
static CString	s_stIfTypeDedicated;
static CString	s_stIfTypeInternal;
static CString	s_stIfTypeLoopback;
static CString	s_stIfTypeNotAvailable;

const CStringMapEntry s_IpxTypeMap[] =
	{
	{ ROUTER_IF_TYPE_CLIENT,	&s_stIfTypeClient, IDS_IPXIFTYPE_CLIENT },
	{ ROUTER_IF_TYPE_HOME_ROUTER, &s_stIfTypeHomeRouter, IDS_IPXIFTYPE_HOME_ROUTER },
	{ ROUTER_IF_TYPE_FULL_ROUTER, &s_stIfTypeFullRouter, IDS_IPXIFTYPE_FULL_ROUTER },
	{ ROUTER_IF_TYPE_DEDICATED, &s_stIfTypeDedicated, IDS_IPXIFTYPE_DEDICATED },
	{ ROUTER_IF_TYPE_INTERNAL, &s_stIfTypeInternal, IDS_IPXIFTYPE_INTERNAL },
	{ ROUTER_IF_TYPE_LOOPBACK, &s_stIfTypeLoopback, IDS_IPXIFTYPE_LOOPBACK },
	{ -1, &s_stIfTypeNotAvailable, IDS_IPXIFTYPE_NOTAVAILABLE },
	};

static CString	s_stAdminStateDisabled;
static CString	s_stAdminStateEnabled;
static CString	s_stAdminStateUnknown;

const CStringMapEntry s_IpxAdminStateMap[] =
{
	{ ADMIN_STATE_DISABLED,	&s_stAdminStateDisabled, IDS_IPXADMINSTATE_DISABLED },
	{ ADMIN_STATE_ENABLED, &s_stAdminStateEnabled, IDS_IPXADMINSTATE_ENABLED },
	{ -1, &s_stAdminStateUnknown, IDS_IPXADMINSTATE_UNKNOWN },
};

static CString	s_stOperStateDown;
static CString	s_stOperStateUp;
static CString	s_stOperStateSleeping;
static CString	s_stOperStateUnknown;

const CStringMapEntry s_IpxOperStateMap[] =
{
	{ OPER_STATE_DOWN,	&s_stOperStateDown, IDS_IPXOPERSTATE_DOWN },
	{ OPER_STATE_UP,	&s_stOperStateUp,	IDS_IPXOPERSTATE_UP },
	{ OPER_STATE_SLEEPING, &s_stOperStateSleeping, IDS_IPXOPERSTATE_SLEEPING },
	{ -1,	&s_stOperStateUnknown, IDS_IPXOPERSTATE_UNKNOWN },
};

static CString	s_stProtocolLocal;
static CString	s_stProtocolStatic;
static CString	s_stProtocolRip;
static CString	s_stProtocolSap;
static CString	s_stProtocolUnknown;

const CStringMapEntry s_IpxProtocolMap[] =
{
	{ IPX_PROTOCOL_LOCAL,	&s_stProtocolLocal,	IDS_IPX_PROTOCOL_LOCAL },
	{ IPX_PROTOCOL_STATIC,	&s_stProtocolStatic,IDS_IPX_PROTOCOL_STATIC },
	{ IPX_PROTOCOL_RIP,		&s_stProtocolRip,	IDS_IPX_PROTOCOL_RIP },
	{ IPX_PROTOCOL_SAP,		&s_stProtocolSap,	IDS_IPX_PROTOCOL_SAP },
	{ -1,					&s_stProtocolUnknown, IDS_IPX_PROTOCOL_UNKNOWN },
};

static CString	s_stRouteNotesNone;
static CString	s_stRouteNotesWanRoute;
static CString	s_stRouteNotesAdvertise;

const CStringMapEntry s_IpxRouteNotesMap[] =
{
	{ 0,	&s_stRouteNotesNone,	IDS_IPX_ROUTE_NOTES_NONE },
	{ GLOBAL_WAN_ROUTE,	&s_stRouteNotesWanRoute,	IDS_IPX_ROUTE_NOTES_WAN },
	{ DO_NOT_ADVERTISE_ROUTE, &s_stRouteNotesAdvertise, IDS_IPX_DONT_ADVERTISE_ROUTE },
	{ -1,	&s_stRouteNotesNone,	IDS_IPX_ROUTE_NOTES_NONE },
};

static CString	s_stDeliveredEnabled;
static CString	s_stDeliveredDisabled;
static CString	s_stDeliveredNetBIOSOnly;
static CString	s_stDeliveredOperStateUp;
static CString	s_stDeliveredUnknown;

const CStringMapEntry	s_IpxDeliveredBroadcastsMap[] =
{
	{ ADMIN_STATE_ENABLED,	&s_stDeliveredEnabled,	IDS_DELIVERED_BROADCASTS_ENABLED },
	{ ADMIN_STATE_DISABLED, &s_stDeliveredDisabled, IDS_DELIVERED_BROADCASTS_DISABLED },
	{ ADMIN_STATE_ENABLED_ONLY_FOR_NETBIOS_STATIC_ROUTING, &s_stDeliveredNetBIOSOnly, IDS_DELIVERED_BROADCASTS_NETBIOS_ONLY },
	{ ADMIN_STATE_ENABLED_ONLY_FOR_OPER_STATE_UP, &s_stDeliveredOperStateUp, IDS_DELIVERED_BROADCASTS_OPER_STATE_UP },
	{ -1, &s_stDeliveredUnknown, IDS_DELIVERED_BROADCASTS_UNKNOWN },
};

static CString	s_stStandardUpdate;
static CString	s_stNoUpdate;
static CString	s_stAutoStaticUpdate;
static CString	s_stUnknownUpdate;

const CStringMapEntry	s_IpxRipSapUpdateModeMap[] =
{
	{ IPX_STANDARD_UPDATE,	&s_stStandardUpdate,	IDS_UPDATEMODE_STANDARD },
	{ IPX_NO_UPDATE,		&s_stNoUpdate,			IDS_UPDATEMODE_NONE },
	{ IPX_AUTO_STATIC_UPDATE, &s_stAutoStaticUpdate,IDS_UPDATEMODE_AUTOSTATIC },
	{ -1,					&s_stUnknownUpdate,		IDS_UPDATEMODE_UNKNOWN },
};


static CString	s_stRouteFilterDeny;
static CString	s_stRouteFilterPermit;
static CString	s_stRouteFilterUnknown;

const CStringMapEntry s_IpxRouteFilterMap[] =
{
	{ IPX_ROUTE_FILTER_DENY,	&s_stRouteFilterDeny, IDS_ROUTEFILTER_DENY },
	{ IPX_ROUTE_FILTER_PERMIT,	&s_stRouteFilterPermit, IDS_ROUTEFILTER_PERMIT },
	{ -1,				&s_stRouteFilterUnknown, IDS_ROUTEFILTER_UNKNOWN },
};

static CString	s_stServiceFilterDeny;
static CString	s_stServiceFilterPermit;
static CString	s_stServiceFilterUnknown;

const CStringMapEntry s_IpxServiceFilterMap[] =
{
	{ IPX_SERVICE_FILTER_DENY,	&s_stServiceFilterDeny, IDS_SERVICEFILTER_DENY },
	{ IPX_SERVICE_FILTER_PERMIT,	&s_stServiceFilterPermit, IDS_SERVICEFILTER_PERMIT },
	{ -1,					&s_stServiceFilterUnknown, IDS_SERVICEFILTER_UNKNOWN },
};


/*!--------------------------------------------------------------------------
	IpxDeliveredBroadcastsToCString
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
CString&	IpxDeliveredBroadcastsToCString(DWORD dwDelivered)
{
	return MapDWORDToCString(dwDelivered, s_IpxDeliveredBroadcastsMap);
}


/*!--------------------------------------------------------------------------
	IpxAcceptBroadcastsToCString
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
CString&	IpxAcceptBroadcastsToCString(DWORD dwAccept)
{
	// Uses the same map as the admin state
	return MapDWORDToCString(dwAccept, s_IpxAdminStateMap);
}

/*!--------------------------------------------------------------------------
	IpxTypeToCString
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
CString&	IpxTypeToCString(DWORD dwType)
{
	return	MapDWORDToCString(dwType, s_IpxTypeMap);
}

/*!--------------------------------------------------------------------------
	IpxAdminStateToCString
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
CString&	IpxAdminStateToCString(DWORD dwAdminState)
{
	return	MapDWORDToCString(dwAdminState, s_IpxAdminStateMap);
}

/*!--------------------------------------------------------------------------
	IpxOperStateToCString
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
CString&	IpxOperStateToCString(DWORD dwOperState)
{
	return	MapDWORDToCString(dwOperState, s_IpxOperStateMap);
}

/*!--------------------------------------------------------------------------
	IpxProtocolToCString
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
CString&	IpxProtocolToCString(DWORD dwProtocol)
{
	return	MapDWORDToCString(dwProtocol, s_IpxProtocolMap);
}

/*!--------------------------------------------------------------------------
	IpxRouteNotesToCString
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
CString	IpxRouteNotesToCString(DWORD dwFlags)
{
	return	MapDWORDToCString(dwFlags, s_IpxRouteNotesMap);
}

/*!--------------------------------------------------------------------------
	RipSapUpdateModeToCString
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
CString&	RipSapUpdateModeToCString(DWORD dwUpdateMode)
{
	return MapDWORDToCString(dwUpdateMode, s_IpxRipSapUpdateModeMap);
}

CString&	RouteFilterActionToCString(DWORD dwFilterAction)
{
	return MapDWORDToCString(dwFilterAction, s_IpxRouteFilterMap);
}

CString&	ServiceFilterActionToCString(DWORD dwFilterAction)
{
	return MapDWORDToCString(dwFilterAction, s_IpxServiceFilterMap);
}

/*!--------------------------------------------------------------------------
	FormatBytes
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void	FormatBytes(LPTSTR pszDestBuffer, ULONG cchBuffer,
					UCHAR *pchBytes, ULONG cchBytes)
{
	TCHAR *	psz = pszDestBuffer;
	int		i = 0;
	TCHAR	szTemp[4];
	
	while ((psz < (pszDestBuffer + cchBuffer - 1)) && cchBytes)
	{
		wsprintf(szTemp, _T("%.2x"), pchBytes[i]);
		StrCpy(psz, szTemp);
		i++;
		psz += 2;
		cchBytes--;
	}
	pszDestBuffer[cchBuffer-1] = 0;
}

/*!--------------------------------------------------------------------------
	FormatIpxNetworkNumber
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void	FormatIpxNetworkNumber(LPTSTR pszNetwork, ULONG cchMax,
							   UCHAR *pchNetwork, ULONG cchNetwork)
{
	Assert(cchNetwork == 4);
	FormatBytes(pszNetwork, cchMax, pchNetwork, cchNetwork);
}

/*!--------------------------------------------------------------------------
	FormatMACAddress
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void	FormatMACAddress(LPTSTR pszMacAddress, ULONG cchMax,
						 UCHAR *pchMac, ULONG cchMac)
{
	Assert(cchMac == 6);
	FormatBytes(pszMacAddress, cchMax, pchMac, cchMac);
}

/*!--------------------------------------------------------------------------
	ConvertCharacter
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BYTE	ConvertCharacter(TCHAR ch)
{
	BYTE	value = 0;
	
	switch (_totlower(ch))
	{
		case _T('0'):		value = 0;		break;
		case _T('1'):		value = 1;		break;
		case _T('2'):		value = 2;		break;
		case _T('3'):		value = 3;		break;
		case _T('4'):		value = 4;		break;
		case _T('5'):		value = 5;		break;
		case _T('6'):		value = 6;		break;
		case _T('7'):		value = 7;		break;
		case _T('8'):		value = 8;		break;
		case _T('9'):		value = 9;		break;
		case _T('a'):		value = 10;		break;
		case _T('b'):		value = 11;		break;
		case _T('c'):		value = 12;		break;
		case _T('d'):		value = 13;		break;
		case _T('e'):		value = 14;		break;
		case _T('f'):		value = 15;		break;
	}
	return value;
}

/*!--------------------------------------------------------------------------
	ConvertToBytes
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void	ConvertToBytes(LPCTSTR pszBytes, BYTE *pchDest, UINT cchDest)
{
	const TCHAR *	psz;
	BYTE *	pDest;
	BYTE	chTemp;

    ::ZeroMemory(pchDest, cchDest);

	for (psz=pszBytes,pDest=pchDest; *psz && cchDest; psz++, pDest++, cchDest--)
	{
		// Look at the first character
		*pDest = ConvertCharacter(*psz) << 4;
		if (*(psz+1))
		{
			*pDest |= ConvertCharacter(*(psz+1));
			*psz++;
		}
	}	
}

/*!--------------------------------------------------------------------------
	ConvertMACAddressToBytes
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void	ConvertMACAddressToBytes(LPCTSTR pszMacAddress,
								 BYTE *	pchDest,
								 UINT	cchDest)
{
	Assert(cchDest == 6);
	ConvertToBytes(pszMacAddress, pchDest, cchDest);
}

/*!--------------------------------------------------------------------------
	ConvertNetworkNumberToBytes
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void	ConvertNetworkNumberToBytes(LPCTSTR pszNetwork,
								 BYTE *	pchDest,
								 UINT	cchDest)
{
	Assert(cchDest == 4);
	ConvertToBytes(pszNetwork, pchDest, cchDest);
}

/*!--------------------------------------------------------------------------
	ConvertToNetBIOSName
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void	ConvertToNetBIOSName(LPSTR szNetBIOSName,
							 LPCTSTR pszName,
							 USHORT type)
{
	USES_CONVERSION;
	
	Assert(!IsBadWritePtr(szNetBIOSName, 16*sizeof(BYTE)));

	wsprintfA(szNetBIOSName, "%-15s", T2CA(pszName));	
	szNetBIOSName[15] = (BYTE) type;
}

/*!--------------------------------------------------------------------------
	FormatNetBIOSName
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void	FormatNetBIOSName(LPTSTR pszName,
						  USHORT *puType,
						  LPCSTR szNetBIOSName)
{
	Assert(!IsBadWritePtr(pszName, 16*sizeof(TCHAR)));
	StrnCpyTFromA(pszName, szNetBIOSName, 16);
	pszName[15] = 0;
	*puType = (USHORT) (UCHAR) szNetBIOSName[15];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ipxutil.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    ipxutil.h
//
// History:
//	07/22/97	Kenn M. Takara			Created.
//
// Declarations for IPX-related utilities.
//
//============================================================================

#ifndef _IPXUTIL_H_
#define _IPXUTIL_H_

CString&	IpxTypeToCString(DWORD dwType);
CString&	IpxAdminStateToCString(DWORD dwAdminState);
CString&	IpxOperStateToCString(DWORD dwOper);
CString&	IpxProtocolToCString(DWORD dwProtocol);
CString	IpxRouteNotesToCString(DWORD dwFlags);

CString&	IpxAcceptBroadcastsToCString(DWORD dwAccept);
CString&	IpxDeliveredBroadcastsToCString(DWORD dwDelievered);

CString&	RipSapUpdateModeToCString(DWORD dwUpdateMode);

CString&	RouteFilterActionToCString(DWORD dwFilterAction);
CString&	ServiceFilterActionToCString(DWORD dwFilterAction);

void	FormatIpxNetworkNumber(LPTSTR pszNetwork, ULONG cchMax,
							   UCHAR *pchNetwork, ULONG cchNetwork);

void	FormatMACAddress(LPTSTR pszMacAddress, ULONG cchMax,
						 UCHAR *pchMac, ULONG cchMac);
void	ConvertMACAddressToBytes(LPCTSTR pszMacAddress,
								 BYTE *	pchDest,
								 UINT	cchDest);
void	ConvertNetworkNumberToBytes(LPCTSTR pszNetwork,
									BYTE *pchDest,
									UINT cchDest);

void	FormatBytes(LPTSTR pszDestBuffer, ULONG cchDestBuffer,
					UCHAR *pchBytes, ULONG cchBytes);
void	ConvertToBytes(LPCTSTR pszBytes, BYTE *pchDest, UINT cchDest);


void	ConvertToNetBIOSName(LPSTR szNetBIOSName,
							 LPCTSTR pszName,
							 USHORT type);
void	FormatNetBIOSName(LPTSTR pszName,
						  USHORT *puType,
						  LPCSTR szNetBIOSName);

#endif // _IPXUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ipxsnap.rc
//
#define IDS_SNAPIN_DESC                 1
#define IDS_ROOT_NODE_NAME              2
#define IDS_ABOUT_DESCRIPTION           3
#define IDS_ABOUT_PROVIDER              4
#define IDS_ABOUT_VERSION               5
//efine IDS_SAMPLE_SNAPIN               6
#define IDS_IPXADMIN_TITLE              7
#define IDS_IPXSUMMARY_TITLE            8
#define IDS_IPXSUMMARY_PAGE_TITLE		9
#define IDS_IPXSUMMARY_IF_PAGE_TITLE	10
#define IDS_IPXSUMMARY_CLIENT_IF_PAGE_TITLE 11
#define IDS_STATS_IPX_INFO_TITLE		12
#define IDS_STATS_IPX_ROUTING_TITLE		13
#define IDS_STATS_IPX_SERVICE_TITLE		14
#define IDS_IPXNB_TITLE					15
#define IDS_IPXNB_IF_PAGE_TITLE			16
#define IDS_IPXNB_CLIENT_IF_PAGE_TITLE	17
#define IDS_IPX_SR_TITLE				18
#define IDS_IPX_SS_TITLE				19
#define IDS_IPX_SN_TITLE				20
#define IDS_IPXRIP_SNAPIN_DESC			21
#define IDS_IPXSAP_SNAPIN_DESC			22
#define IDS_IPX_RIP_TITLE				23
#define IDS_IPX_SAP_TITLE				24
#define IDS_STATS_RIPPARAMS_TITLE		25
#define IDS_STATS_SAPPARAMS_TITLE		26
#define IDS_IPXADMIN_DISPLAY_NAME		27
#define IDS_IPXRIP_DISPLAY_NAME			28
#define IDS_IPXSAP_DISPLAY_NAME			29
#define IDS_IPX_INTERFACE_TITLE			30
#define IDS_RRAS_SERVICE_DESC			31

#define IDS_RECEIVE_NO_SAP				63
#define IDS_TRANSMIT_NO_SAP				64
#define IDS_RECEIVE_NO_RIP				65
#define IDS_TRANSMIT_NO_RIP				66

#define IDS_MENU_REFRESH                200
#define IDS_MENU_CONFIGURE_COLUMNS		201
#define IDS_MENU_SYNC					202

#define IDS_MENU_IPXSUM_NEW_INTERFACE	210
#define IDS_MENU_IPXSUM_NEW_PROTOCOL	211
//#define IDS_MENU_IPXSUM_TASK_PING		212
#define IDS_MENU_IPXSUM_TASK_IPX_INFO	213
#define IDS_MENU_IPXSUM_TASK_ROUTING_TABLE 214
#define IDS_MENU_IPXSUM_TASK_SERVICE_TABLE 215
#define IDS_MENU_IPX_SR_NEW_ROUTE		216
#define IDS_MENU_IPX_SR_TASK_ROUTING	217
#define IDS_MENU_IPX_SS_NEW_SERVICE		218
#define IDS_MENU_IPX_SS_TASK_SERVICE	219
#define IDS_MENU_IPX_SN_NEW_NETBIOSNAME	220
#define IDS_MENU_RIP_SHOW_PARAMS		221
#define IDS_MENU_SAP_SHOW_PARAMS		222
#define IDS_MENU_UPDATE_ROUTES			223
#define IDS_MENU_IPX_IF_ENABLE          224
#define IDS_MENU_IPX_IF_DISABLE         225


#define IDB_16x16                       402
#define IDB_32x32                       403

#define IDC_EDIT_SERVER                 500
#define IDC_EDIT_DOMAIN                 501
#define IDC_RAD_SERVER                  502
#define IDC_RAD_DOMAIN                  503

// Controls for the IPX Global General page
#define IDC_IGG_BTN_LOG_NONE			505
#define IDC_IGG_BTN_LOG_ERRORS			506
#define IDC_IGG_BTN_LOG_WARNINGS		507
#define IDC_IGG_BTN_LOG_INFO			508

// Controls for the IPX Interface General page
#define IDC_IIG_BTN_ADMIN_STATE			510
#define IDC_IIG_GRP_CONTROL_PROTOCOL	511
#define IDC_IIG_BTN_IPX_CP				512
#define IDC_IIG_BTN_IPX_WAN				513
#define IDC_IIG_BTN_INPUT_FILTERS		514
#define IDC_IIG_BTN_OUTPUT_FILTERS		515

// Controls for the IPX NB Interface General page
#define IDC_NIG_BTN_ACCEPT				520
#define IDC_NIG_BTN_DELIVER_ALWAYS		521
#define IDC_NIG_BTN_DELIVER_NEVER		522
#define IDC_NIG_BTN_DELIVER_STATIC		523
#define IDC_NIG_BTN_DELIVER_WHEN_UP		524

// Controls for the Static Route dialog
#define IDC_SRD_EDIT_NETWORK_NUMBER		525
#define IDC_SRD_EDIT_NEXT_HOP			526
#define IDC_SRD_EDIT_TICK_COUNT			527
#define IDC_SRD_SPIN_TICK_COUNT			528
#define IDC_SRD_EDIT_HOP_COUNT			529
#define IDC_SRD_SPIN_HOP_COUNT			530
#define IDC_SRD_COMBO_INTERFACE			531

// Controls for the Static Service dialog
#define IDC_SSD_EDIT_SERVICE_TYPE		535
#define IDC_SSD_EDIT_SERVICE_NAME		536
#define IDC_SSD_EDIT_NETWORK_ADDRESS	537
#define IDC_SSD_EDIT_NODE_ADDRESS		538
#define IDC_SSD_EDIT_SOCKET_ADDRESS		539
#define IDC_SSD_EDIT_HOP_COUNT			540
#define IDC_SSD_SPIN_HOP_COUNT			541
#define IDC_SSD_COMBO_INTERFACE			542

// Controls for the Static NetBIOS Name dialog
#define IDC_SND_EDIT_NAME				545
#define IDC_SND_EDIT_TYPE				546
#define IDC_SND_COMBO_INTERFACE			547

// Controls for the RIP Global General dialog
#define IDC_RGG_BTN_LOG_NONE			550
#define IDC_RGG_BTN_LOG_ERROR			551
#define IDC_RGG_BTN_LOG_WARN			552
#define IDC_RGG_BTN_LOG_INFO			553

// Controls for the RIP Interface General page
#define IDC_RIG_BTN_ADMIN_STATE			560
#define IDC_RIG_BTN_ADVERTISE_ROUTES	561
#define IDC_RIG_BTN_ACCEPT_ROUTE_ADS	562
#define IDC_RIG_BTN_UPDATE_MODE_STANDARD 563
#define IDC_RIG_BTN_UPDATE_MODE_NONE	564
#define IDC_RIG_BTN_UPDATE_MODE_AUTOSTATIC 565
#define IDC_RIG_EDIT_INTERVAL			566
#define IDC_RIG_SPIN_INTERVAL			567
#define IDC_RIG_EDIT_MULTIPLIER			568
#define IDC_RIG_SPIN_MULTIPLIER			569
#define IDC_RIG_BTN_INPUT_FILTERS		570
#define IDC_RIG_BTN_OUTPUT_FILTERS		571

// Controls for the SAP Global General dialog
#define IDC_SGG_BTN_LOG_NONE			580
#define IDC_SGG_BTN_LOG_ERROR			581
#define IDC_SGG_BTN_LOG_WARN			582
#define IDC_SGG_BTN_LOG_INFO			583

// Controls for the SAP Interface General page
#define IDC_SIG_BTN_ADMIN_STATE			590
#define IDC_SIG_BTN_ADVERTISE_SERVICES	591
#define IDC_SIG_BTN_ACCEPT_SERVICE_ADS	592
#define IDC_SIG_BTN_REPLY_GNS_REQUESTS	593
#define IDC_SIG_BTN_UPDATE_MODE_STANDARD 594
#define IDC_SIG_BTN_UPDATE_MODE_NONE	595
#define IDC_SIG_BTN_UPDATE_MODE_AUTOSTATIC 596
#define IDC_SIG_EDIT_INTERVAL			597
#define IDC_SIG_SPIN_INTERVAL			598
#define IDC_SIG_EDIT_MULTIPLIER			599
#define IDC_SIG_SPIN_MULTIPLIER			600
#define IDC_SIG_BTN_INPUT_FILTERS		601
#define IDC_SIG_BTN_OUTPUT_FILTERS		602

// Controls fo the IPX Interace Configuration page
#define IDC_IIC_EDIT_NETNUMBER			610

// Controls for the Route filters dialog
#define IDC_RFS_BTN_DENY				620
#define IDC_RFS_BTN_PERMIT				621
#define IDC_RFS_BTN_ADD					622
#define IDC_RFS_BTN_EDIT				623
#define IDC_RFS_BTN_DELETE				624
#define IDC_RFS_LIST					625

// Controls for the Route filter dialog
#define IDC_RF_EDIT_INTERFACE			630
#define IDC_RF_EDIT_NETWORK				631
#define IDC_RF_EDIT_NETMASK				632
#define IDC_RF_TEXT_INTERFACE           633

// Controls for the Service filter dialog
#define IDC_SF_EDIT_INTERFACE			640
#define IDC_SF_EDIT_SERVICE_TYPE		641
#define IDC_SF_EDIT_SERVICE_NAME		642
#define IDC_SF_TEXT_INTERFACE           643

// Controls for the Service filters dialog
#define IDC_SFS_BTN_DENY				650
#define IDC_SFS_BTN_PERMIT				651
#define IDC_SFS_LIST					652
#define IDC_SFS_BTN_ADD					653
#define IDC_SFS_BTN_EDIT				654
#define IDC_SFS_BTN_DELETE				655

// Strings for the IPX general node column headers
#define IDS_IPX_COL_NAME				2000
#define IDS_IPX_COL_TYPE				2001
#define IDS_IPX_COL_ADMINSTATE			2002
#define IDS_IPX_COL_OPERSTATE			2003
#define IDS_IPX_COL_NETWORK				2004
#define IDS_IPX_COL_PACKETS_SENT		2005
#define IDS_IPX_COL_PACKETS_RCVD		2006
#define IDS_IPX_COL_OUT_FILTERED		2007
#define IDS_IPX_COL_OUT_DROPPED			2008
#define IDS_IPX_COL_IN_FILTERED			2009
#define IDS_IPX_COL_IN_NOROUTES			2010
#define IDS_IPX_COL_IN_DROPPED			2011

// Strings for the IPX interface types
#define IDS_IPXIFTYPE_CLIENT			2015
#define IDS_IPXIFTYPE_HOME_ROUTER		2016
#define IDS_IPXIFTYPE_FULL_ROUTER		2017
#define IDS_IPXIFTYPE_DEDICATED			2018
#define IDS_IPXIFTYPE_INTERNAL			2019
#define IDS_IPXIFTYPE_LOOPBACK			2020
#define IDS_IPXIFTYPE_NOTAVAILABLE		2021

// Strings for the IPX Admin state
#define IDS_IPXADMINSTATE_DISABLED		2025
#define IDS_IPXADMINSTATE_ENABLED		2026
#define IDS_IPXADMINSTATE_UNKNOWN		2027

// Strings for the IPX operational state
#define IDS_IPXOPERSTATE_DOWN			2030
#define IDS_IPXOPERSTATE_UP				2031
#define IDS_IPXOPERSTATE_SLEEPING		2032
#define IDS_IPXOPERSTATE_UNKNOWN		2033

// Misc strings
#define IDS_IPX_DIAL_IN_CLIENTS			2035
#define IDS_IPX_NOT_AVAILABLE			2036
#define IDS_STATS_NA					2037
#define IDS_IPX_WAN_CLIENT_ROUTE		2038

// Strings for the IPX Info Statistics dialog
#define IDS_STATS_IPX_STATE				2050
#define IDS_STATS_IPX_NETWORK			2051
#define IDS_STATS_IPX_NODE				2052
#define IDS_STATS_IPX_INTERFACE_COUNT	2053
#define IDS_STATS_IPX_ROUTE_COUNT		2054
#define IDS_STATS_IPX_SERVICE_COUNT		2055
#define IDS_STATS_IPX_PACKETS_SENT		2056
#define IDS_STATS_IPX_PACKETS_RCVD		2057
#define IDS_STATS_IPX_PACKETS_FRWD		2058

// Strings for the IPX routing table statistics
#define IDS_STATS_IPXROUTING_NETWORK		2060
#define IDS_STATS_IPXROUTING_NEXT_HOP_MAC	2061
#define IDS_STATS_IPXROUTING_TICK_COUNT		2062
#define IDS_STATS_IPXROUTING_HOP_COUNT		2063
#define IDS_STATS_IPXROUTING_IF_NAME		2064
#define IDS_STATS_IPXROUTING_PROTOCOL		2065
#define IDS_STATS_IPXROUTING_ROUTE_NOTES	2066

// Strings for the IPX protocols
#define IDS_IPX_PROTOCOL_LOCAL				2070
#define IDS_IPX_PROTOCOL_STATIC				2071
#define IDS_IPX_PROTOCOL_RIP				2072
#define IDS_IPX_PROTOCOL_SAP				2073
#define IDS_IPX_PROTOCOL_UNKNOWN			2074

// Strings for the Route notes
#define IDS_IPX_ROUTE_NOTES_NONE			2075
#define IDS_IPX_ROUTE_NOTES_WAN				2076
#define IDS_IPX_DONT_ADVERTISE_ROUTE		2077

// Strings for the IPX service table columns
#define IDS_STATS_IPXSERVICE_SERVICE_TYPE	2080
#define IDS_STATS_IPXSERVICE_SERVICE_NAME	2081
#define IDS_STATS_IPXSERVICE_SERVICE_ADDRESS	2082
#define IDS_STATS_IPXSERVICE_HOP_COUNT		2083
#define IDS_STATS_IPXSERVICE_IF_NAME		2084
#define IDS_STATS_IPXSERVICE_PROTOCOL		2085

// Strings for the NetBIOS Broadcast columns
#define IDS_IPX_NB_COL_NAME				2090
#define IDS_IPX_NB_COL_TYPE				2091
#define IDS_IPX_NB_COL_ACCEPTED			2092
#define IDS_IPX_NB_COL_DELIVERED		2093
#define IDS_IPX_NB_COL_SENT				2094
#define IDS_IPX_NB_COL_RECEIVED			2095

// Strings for the delivered broadcasts
#define IDS_DELIVERED_BROADCASTS_ENABLED	2100
#define IDS_DELIVERED_BROADCASTS_DISABLED	2101
#define IDS_DELIVERED_BROADCASTS_NETBIOS_ONLY	2102
#define IDS_DELIVERED_BROADCASTS_OPER_STATE_UP	2103
#define IDS_DELIVERED_BROADCASTS_UNKNOWN	2104

// Strings for the Static Routes column headers
#define IDS_IPX_SR_COL_NAME				2105
#define IDS_IPX_SR_COL_NETWORK			2106
#define IDS_IPX_SR_COL_NEXT_HOP			2107
#define IDS_IPX_SR_COL_TICK_COUNT		2108
#define IDS_IPX_SR_COL_HOP_COUNT		2109

// Strings for the Static Services column headers
#define IDS_IPX_SS_COL_NAME				2110
#define IDS_IPX_SS_COL_SERVICE_TYPE		2111
#define IDS_IPX_SS_COL_SERVICE_NAME		2112
#define IDS_IPX_SS_COL_SERVICE_ADDRESS	2113
#define IDS_IPX_SS_COL_HOP_COUNT		2114

// Strings for the Static NetBIOS Names column headers
#define IDS_IPX_SN_COL_NAME				2115
#define IDS_IPX_SN_COL_NETBIOS_NAME		2116
#define IDS_IPX_SN_COL_NETBIOS_TYPE		2117

// Strings for the IPX RIP Node column headers
#define IDS_RIP_COL_INTERFACE			2120
#define IDS_RIP_COL_TYPE				2121
#define IDS_RIP_COL_ACCEPT_ROUTES		2122
#define IDS_RIP_COL_SUPPLY_ROUTES		2123
#define IDS_RIP_COL_UPDATE_MODE			2124
#define IDS_RIP_COL_UPDATE_PERIOD		2125
#define IDS_RIP_COL_AGE_MULTIPLIER		2126
#define IDS_RIP_COL_ADMIN_STATE			2127
#define IDS_RIP_COL_OPER_STATE			2128
#define IDS_RIP_COL_PACKETS_SENT		2129
#define IDS_RIP_COL_PACKETS_RECEIVED	2130

// Strings for the IPX SAP node column headers
#define IDS_SAP_COL_INTERFACE			2135
#define IDS_SAP_COL_TYPE				2136
#define IDS_SAP_COL_ACCEPT_ROUTES		2137
#define IDS_SAP_COL_SUPPLY_ROUTES		2138
#define IDS_SAP_COL_REPLY_GSNR			2139
#define IDS_SAP_COL_UPDATE_MODE			2140
#define IDS_SAP_COL_UPDATE_PERIOD		2141
#define IDS_SAP_COL_AGE_MULTIPLIER		2142
#define IDS_SAP_COL_ADMIN_STATE			2143
#define IDS_SAP_COL_OPER_STATE			2144
#define IDS_SAP_COL_PACKETS_SENT		2145
#define IDS_SAP_COL_PACKETS_RECEIVED	2146

// Strings for the RIP/SAP Update mode
#define IDS_UPDATEMODE_STANDARD			2150
#define IDS_UPDATEMODE_NONE				2151
#define IDS_UPDATEMODE_AUTOSTATIC		2152
#define IDS_UPDATEMODE_UNKNOWN			2153

// Strings for the RIP parameters statistics dialog
#define IDS_STATS_RIPPARAMS_OPER_STATE	2155
#define IDS_STATS_RIPPARAMS_SENT_PACKETS	2156
#define IDS_STATS_RIPPARAMS_RCVD_PACKETS	2157

// Strings for the SAP parameters statistics dialog
#define IDS_STATS_SAPPARAMS_OPER_STATE	2160
#define IDS_STATS_SAPPARAMS_SENT_PACKETS	2161
#define IDS_STATS_SAPPARAMS_RCVD_PACKETS	2162

// Strings for the route filter action
#define IDS_ROUTEFILTER_DENY			2170
#define IDS_ROUTEFILTER_PERMIT			2171
#define IDS_ROUTEFILTER_UNKNOWN			2172
#define IDS_ROUTEFILTER_OUTPUT_CAP		2173
#define IDS_ROUTEFILTER_INPUT_CAP		2174
#define IDS_ROUTEFILTER_NETWORK_HDR		2175
#define IDS_ROUTEFILTER_NETMASK_HDR		2176

// Strings for the service filter action
#define IDS_SERVICEFILTER_DENY			2180
#define IDS_SERVICEFILTER_PERMIT		2181
#define IDS_SERVICEFILTER_UNKNOWN		2182
#define IDS_SERVICEFILTER_OUTPUT_CAP	2183
#define IDS_SERVICEFILTER_INPUT_CAP		2184
#define IDS_SERVICEFILTER_TYPE_HDR		2185
#define IDS_SERVICEFILTER_NAME_HDR		2186
#define IDS_ANY_SERVICE_NAME			2187
#define IDS_ANY_SERVICE_TYPE			2188

// Error strings (3000-3499)
#define IDS_ERR_DELETE_INTERFACE		3000
#define IDS_ERR_NO_IPX_INTERFACES		3001
#define IDS_ERR_INVALID_NETBIOS_NAME	3002
#define IDS_ERR_INVALID_SERVICE_NAME	3003
#define IDS_ERR_INVALID_ROUTE_FILTER	3004
#define IDS_ERR_IPXCONFIG_CANNOT_SHOW	3005
#define IDS_ERR_CANNOT_SAVE_IPXCONFIG	3006

// Prompt strings (3500-3599)
#define IDS_PROMPT_VERIFY_REMOVE_INTERFACE 3500
#define IDS_PROMPT_SERVICESTART			3501


// 4000-4999 reserved for rtrlib
// 5000-5999 reserved for common

#define IDI_IPX_SNAPIN_ICON             11001
#define IDI_PROTOCOL                    11002

// ipxsnap's IDDs are in the range of 13500-13999
#define IDD_GENERIC_PROP_PAGE           13500
#define IDD_IPX_GLOBAL_GENERAL_PAGE		13501
#define IDD_IPX_IF_GENERAL_PAGE			13502
#define IDD_IPX_NB_IF_GENERAL_PAGE		13503
#define IDD_STATIC_ROUTE				13504
#define IDD_STATIC_SERVICE				13505
#define IDD_STATIC_NETBIOS_NAME			13506
#define IDD_RIP_GLOBAL_GENERAL_PAGE		13507
#define IDD_RIP_INTERFACE_GENERAL_PAGE	13508
#define IDD_SAP_GLOBAL_GENERAL_PAGE		13509
#define IDD_SAP_INTERFACE_GENERAL_PAGE	13510
#define IDD_IPX_IF_CONFIG_PAGE			13511
#define IDD_ROUTE_FILTER				13513
#define IDD_SERVICE_FILTER				13515
#define IDD_STATIC_ROUTE_PROPERTYPAGE   13516
#define IDD_STATICSERVICESPROPERTIES_GENERAL 13517
#define IDD_STATIC_NETBIOS_NAME_PROPERTYPAGE  13518

#define IDD_ROUTE_FILTERS_INPUT			13512
#define IDD_SERVICE_FILTERS_INPUT		13514
#define IDD_ROUTE_FILTERS_OUTPUT		13519
#define IDD_SERVICE_FILTERS_OUTPUT		13520
#define IDC_RIG_TEXT_INTERVAL			13521
#define IDC_RIG_TEXT_MULTIPLIER		13522
#define IDC_SIG_TEXT_INTERVAL			13523
#define IDC_SIG_TEXT_MULTIPLIER		13524

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        210
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         225
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\nbview.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    nbview.h
//
// History:
//	10/02/97	Kenn M. Takara			Created.
//
//	IPX NetBIOS Broadcasts view
//
//============================================================================


#ifndef _NBVIEW_H
#define _NBVIEW_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _XSTREAM_H
#include "xstream.h"		// need for ColumnData
#endif

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _IPXFACE_H
#include "ipxface.h"
#endif

#ifndef _BASECON_H
#include "basecon.h"		// BaseContainerHandler
#endif

#ifndef _IPXSTRM_H
#include "ipxstrm.h"
#endif

#ifndef _RTRSHEET_H
#include "rtrsheet.h"
#endif

#ifndef _IPXCONN_H
#include "ipxconn.h"			// IPXConnection
#endif

// forward declarations
class	IPXAdminConfigStream;
struct	SIpxNBNodeMenu;


/*---------------------------------------------------------------------------
	This is the list of columns available for the IPX NetBIOS broadcasts
	node.
		- Interface, "[1] DEC DE500 ..."
		- Type, "Dedicated"
		- Accept Broadcasts, "Enabled"
		- Deliver Broadcasts, "Enabled"
		- Sent Broadcasts
		- Received Broadcasts
 ---------------------------------------------------------------------------*/


//
// If you ADD any columns to this enum, Be sure to update
// the string ids for the column headers in summary.cpp
//
enum
{
	IPXNB_SI_NAME = 0,
	IPXNB_SI_TYPE,
	IPXNB_SI_ACCEPTED,
	IPXNB_SI_DELIVERED,
	IPXNB_SI_SENT,
	IPXNB_SI_RECEIVED,
    IPXNB_MAX_COLUMNS
};


/*---------------------------------------------------------------------------
	We store a pointer to the IPXConnection object in our node data
 ---------------------------------------------------------------------------*/

#define GET_IPXNB_NODEDATA(pNode) \
		(IPXConnection *) pNode->GetData(TFS_DATA_USER)
#define SET_IPXNB_NODEDATA(pNode, pData) \
		pNode->SetData(TFS_DATA_USER, (LONG_PTR) pData)


/*---------------------------------------------------------------------------
	Struct: IpxNBListEntry
 ---------------------------------------------------------------------------*/
struct IpxNBArrayEntry
{
	// Data retrieved from the interface
	TCHAR				m_szId[256];

	BOOL				m_fClient;

	// Data retrieved from the infobase
	DWORD				m_dwAccept;
	DWORD				m_dwDeliver;

	// Data retrieved from the MIBs
	DWORD				m_cSent;
	DWORD				m_cReceived;
};

typedef CArray<IpxNBArrayEntry, IpxNBArrayEntry&> IpxNBArray;



/*---------------------------------------------------------------------------
	Class:	IpxNBHandler
 ---------------------------------------------------------------------------*/



class IpxNBHandler :
		public BaseContainerHandler
{
public:
	IpxNBHandler(ITFSComponentData *pTFSCompData);

	// Override QI to handle embedded interface
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);
	
	DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)

	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_GetString();
	OVERRIDE_NodeHandler_OnCreateDataObject();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_DestroyHandler();

	OVERRIDE_BaseHandlerNotify_OnExpand();

	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_CompareItems();

	OVERRIDE_BaseResultHandlerNotify_OnResultShow();

    OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();
	
	// Initializes the handler
	HRESULT	Init(IRtrMgrInfo *pRtrMgrInfo, IPXAdminConfigStream *pConfigStream);
	
	// Initializes the node
	HRESULT ConstructNode(ITFSNode *pNode, LPCTSTR szName,
						  IPXConnection *pIPXConn);

public:
	// Structure used to pass data to callbacks - used as a way of
	// avoiding recomputation
	struct SMenuData
	{
		SPITFSNode			m_spNode;
	};

protected:
	// Refresh the data for these nodes
	HRESULT	SynchronizeNodeData(ITFSNode *pThisNode);
	HRESULT GetIpxNBData(ITFSNode *pThisNode, IpxNBArray * pIpxNBArray);
	HRESULT	GetClientInterfaceData(IpxNBArrayEntry *pClient, IRtrMgrInfo *pRm);

	// Helper function to add interfaces to the UI
	HRESULT	AddInterfaceNode(ITFSNode *pParent, IInterfaceInfo *pIf, BOOL fClient);

	// Command implementations
	
	LONG_PTR		m_ulConnId;		// notification id for router info
	LONG_PTR		m_ulRefreshConnId;	// notification id for router refresh
	MMC_COOKIE		m_cookie;		// cookie for the node
	SPIRtrMgrInfo	m_spRtrMgrInfo;
	IPXAdminConfigStream *	m_pConfigStream;
	CString			m_stTitle;
};



/*---------------------------------------------------------------------------
	Class:	IpxNBInterfaceHandler

	This is the handler for the interface nodes that appear in the IPXNB
	node.
 ---------------------------------------------------------------------------*/

class IpxNBInterfaceHandler : public BaseIPXResultHandler
{
public:
	IpxNBInterfaceHandler(ITFSComponentData *pCompData);
	
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnCreateDataObject();
	
	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_OnCreateDataObject();
	OVERRIDE_ResultHandler_DestroyResultHandler();
	OVERRIDE_ResultHandler_HasPropertyPages()
			{	return hrOK;	};
	OVERRIDE_ResultHandler_CreatePropertyPages();
	
	// Initializes the node
	HRESULT ConstructNode(ITFSNode *pNode, IInterfaceInfo *pIfInfo,
						 IPXConnection *pIPXConn);
	HRESULT	Init(IRtrMgrInfo *pRm, IInterfaceInfo *pInfo,
				 ITFSNode *pParent);

	// Refresh the data for this node
	void RefreshInterface(MMC_COOKIE cookie);

public:
	// Structure used to pass data to callbacks - used as a way of
	// avoiding recomputation
	struct SMenuData
	{
		ULONG				m_ulMenuId;
		SPITFSNode			m_spNode;
	};
	ULONG	GetSeparatorFlags(SMenuData *pData);
	
protected:
	LONG_PTR			m_ulConnId;
	SPIRtrMgrInfo		m_spRm;
	SPIInterfaceInfo	m_spInterfaceInfo;
};




#endif _NBVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ripcomp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	csmplsnp.cpp
		This file contains the derived classes for CComponent and 
		CComponentData.  Most of these functions are pure virtual 
		functions that need to be overridden for snapin functionality.
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ripcomp.h"
#include "riproot.h"
//nclude <atlimpl.cpp>
#include "ripstrm.h"
#include "ripview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/*---------------------------------------------------------------------------
	CRipComponent
 ---------------------------------------------------------------------------*/



/////////////////////////////////////////////////////////////////////////////
// CRipComponent implementation

CRipComponent::CRipComponent()
{
	extern const ContainerColumnInfo	s_rgRipViewColumnInfo[];

	m_ComponentConfig.Init(RIP_COLUMNS_MAX_COUNT);

	m_ComponentConfig.InitViewInfo(RIP_COLUMNS,
                                   FALSE /*fConfigurableColumns*/,
								   RIP_SI_MAX_COLUMNS,
								   TRUE,
								   s_rgRipViewColumnInfo);
	
	m_ulUserData = reinterpret_cast<LONG_PTR>(&m_ComponentConfig);
}

CRipComponent::~CRipComponent()
{
}

STDMETHODIMP_(ULONG) CRipComponent::AddRef()
{
	return TFSComponent::AddRef();
}

STDMETHODIMP_(ULONG) CRipComponent::Release()
{
	return TFSComponent::Release();
}

STDMETHODIMP CRipComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

	if (riid == IID_IPersistStreamInit)
		*ppv = static_cast<IPersistStreamInit *>(this);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
    }
    else
		return TFSComponent::QueryInterface(riid, ppv);
}

STDMETHODIMP CRipComponent::OnUpdateView(LPDATAOBJECT pDataObject,
										 LPARAM arg,
										 LPARAM param)
{
	
	return TFSComponent::OnUpdateView(pDataObject, arg, param);
}

STDMETHODIMP CRipComponent::InitializeBitmaps(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(m_spImageList != NULL);

    CBitmap bmp16x16;
    CBitmap bmp32x32;
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		// Load the bitmaps from the dll
		bmp16x16.LoadBitmap(IDB_16x16);
		bmp32x32.LoadBitmap(IDB_32x32);

		// Set the images
		m_spImageList->ImageListSetStrip(
					reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
					reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp32x32)),
                    0, RGB(255,0,255));
	}
	COM_PROTECT_CATCH;

    return hr;
}

/*!--------------------------------------------------------------------------
	CRipComponent::OnSnapinHelp
		-
	Author: MikeG (a-migall)
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CRipComponent::OnSnapinHelp(
	LPDATAOBJECT	pDataObject,
	LPARAM			arg, 
	LPARAM			param)
{
	UNREFERENCED_PARAMETER(pDataObject);
	UNREFERENCED_PARAMETER(arg);
	UNREFERENCED_PARAMETER(param);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HtmlHelpA(NULL,						// caller
			  c_sazIPXSnapHelpFile,	// help file
			  HH_DISPLAY_TOPIC,			// command
			  0);						// data

	return hrOK;
}

STDMETHODIMP CRipComponent::QueryDataObject(MMC_COOKIE cookie,
											   DATA_OBJECT_TYPES type,
											   LPDATAOBJECT *ppDataObject)
{
	HRESULT		hr = hrOK;
	SPITFSNode	spNode;
	SPITFSResultHandler	spResultHandler;

	COM_PROTECT_TRY
	{
		CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

		CORg( spNode->GetResultHandler(&spResultHandler) );

		CORg( spResultHandler->OnCreateDataObject(this, cookie,
			type, ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}


STDMETHODIMP CRipComponent::GetClassID(LPCLSID lpClassID)
{
    ASSERT(lpClassID != NULL);

    // Copy the CLSID for this snapin
    *lpClassID = CLSID_IPXRipExtension;

    return hrOK;
}
STDMETHODIMP CRipComponent::IsDirty()
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{		
		hr = m_ComponentConfig.GetDirty() ? hrOK : hrFalse;
	}
	COM_PROTECT_CATCH;
	return hr;
}
STDMETHODIMP CRipComponent::Load(LPSTREAM pStm)
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{		
	hr = m_ComponentConfig.LoadFrom(pStm);
	}
	COM_PROTECT_CATCH;
	return hr;
}
STDMETHODIMP CRipComponent::Save(LPSTREAM pStm, BOOL fClearDirty)
{
	HRESULT	hr = hrOK;
	SPITFSResultHandler	spResultHandler;
	COM_PROTECT_TRY
	{
		// Need to see if we can save the selected node
		// -------------------------------------------------------------
		if (m_spSelectedNode)
		{
			m_spSelectedNode->GetResultHandler(&spResultHandler);
			if (spResultHandler)
				spResultHandler->UserResultNotify(m_spSelectedNode,
					RRAS_ON_SAVE, (LPARAM)(ITFSComponent *) this);
		}
		hr = m_ComponentConfig.SaveTo(pStm);
		if (FHrSucceeded(hr) && fClearDirty)
			m_ComponentConfig.SetDirty(FALSE);
	}
	COM_PROTECT_CATCH;
	return hr;
}
STDMETHODIMP CRipComponent::GetSizeMax(ULARGE_INTEGER FAR *pcbSize)
{
	Assert(pcbSize);
	HRESULT	hr = hrOK;
	ULONG	cbSize = 0;

	COM_PROTECT_TRY
	{
		hr = m_ComponentConfig.GetSize(&cbSize);
		if (FHrSucceeded(hr))
		{
			pcbSize->HighPart = 0;
			pcbSize->LowPart = cbSize;
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}
STDMETHODIMP CRipComponent::InitNew()
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{		
		hr = m_ComponentConfig.InitNew();
	}
	COM_PROTECT_CATCH;
	return hr;
}






/////////////////////////////////////////////////////////////////////////////
// CRipComponentData implementation

CRipComponentData::CRipComponentData()
{
}

/*!--------------------------------------------------------------------------
	CRipComponentData::OnInitialize
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CRipComponentData::OnInitialize(LPIMAGELIST pScopeImage)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	Assert(pScopeImage);

    // add the images for the scope tree
    CBitmap bmp16x16;
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		// Load the bitmaps from the dll
		bmp16x16.LoadBitmap(IDB_16x16);

		// Set the images
		pScopeImage->ImageListSetStrip(
					reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
					reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
					0,
					RGB(255,0,255));
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	CRipComponentData::OnInitializeNodeMgr
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CRipComponentData::OnInitializeNodeMgr(ITFSComponentData *pTFSCompData, ITFSNodeMgr *pNodeMgr)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// For now create a new node handler for each new node,
	// this is rather bogus as it can get expensive.  We can
	// consider creating only a single node handler for each
	// node type.
	RipRootHandler *	pHandler = NULL;
	SPITFSNodeHandler	spHandler;
	SPITFSNode			spNode;
	HRESULT				hr = hrOK;

	COM_PROTECT_TRY
	{
		pHandler = new RipRootHandler(pTFSCompData);

		// Do this so that it will get released correctly
		spHandler = pHandler;
		pHandler->Init();
	
		// Create the root node for this sick puppy
		CORg( CreateContainerTFSNode(&spNode,
									 &GUID_IPXRipRootNodeType,
									 pHandler,
									 pHandler /* result handler */,
									 pNodeMgr) );

		// Construct the node
		CORg( pHandler->ConstructNode(spNode) );

		CORg( pNodeMgr->SetRootNode(spNode) );
		
		// Reference the help file name.
		pTFSCompData->SetHTMLHelpFileName(c_szIPXSnapHelpFile);

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	CRipComponentData::OnCreateComponent
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CRipComponentData::OnCreateComponent(LPCOMPONENT *ppComponent)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(ppComponent != NULL);
	
	HRESULT		hr = hrOK;
	CRipComponent *	pComp = NULL;

	COM_PROTECT_TRY
	{
		pComp = new CRipComponent;

		if (FHrSucceeded(hr))
		{
			pComp->Construct(m_spNodeMgr,
							 static_cast<IComponentData *>(this),
							 m_spTFSComponentData);
			*ppComponent = static_cast<IComponent *>(pComp);
		}
	}
	COM_PROTECT_CATCH;
	
	return hr;
}


STDMETHODIMP CRipComponentData::OnDestroy()
{
	m_spNodeMgr.Release();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	CRipComponentData::GetCoClassID
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(const CLSID *) CRipComponentData::GetCoClassID()
{
	return &CLSID_IPXRipExtension;
}

/*!--------------------------------------------------------------------------
	CRipComponentData::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CRipComponentData::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

	CDataObject *	pObject = NULL;
	SPIDataObject	spDataObject;
	HRESULT			hr = hrOK;
	SPITFSNode		spNode;
	SPITFSNodeHandler	spHandler;

	COM_PROTECT_TRY
	{
		CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

		CORg( spNode->GetHandler(&spHandler) );

		CORg( spHandler->OnCreateDataObject(cookie, type, &spDataObject) );

		*ppDataObject = spDataObject.Transfer();
		
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	return hr;
}


///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members

STDMETHODIMP CRipComponentData::GetClassID
(
	CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_IPXRipExtension;

    return hrOK;
}

STDMETHODIMP CRipComponentData::IsDirty()
{
	SPITFSNode	spNode;
	SPITFSNodeHandler	spHandler;
	SPIPersistStreamInit	spStm;
	
	m_spNodeMgr->GetRootNode(&spNode);
	spNode->GetHandler(&spHandler);
	spStm.Query(spHandler);
	Assert(spStm);
	
	return (spNode->GetData(TFS_DATA_DIRTY) || spStm->IsDirty()) ? hrOK : hrFalse;
}

STDMETHODIMP CRipComponentData::Load
(
	IStream *pStm
)
{
	SPITFSNode	spNode;
	SPITFSNodeHandler	spHandler;
	SPIPersistStreamInit	spStm;
	
	m_spNodeMgr->GetRootNode(&spNode);
	spNode->GetHandler(&spHandler);
	spStm.Query(spHandler);
	
	Assert(spStm);
	return spStm->Load(pStm);
}


STDMETHODIMP CRipComponentData::Save
(
	IStream *pStm, 
	BOOL	 fClearDirty
)
{
	SPITFSNode	spNode;
	SPITFSNodeHandler	spHandler;
	SPIPersistStreamInit	spStm;
	
	m_spNodeMgr->GetRootNode(&spNode);
	spNode->GetHandler(&spHandler);
	spStm.Query(spHandler);
	
	Assert(spStm);
	return spStm->Save(pStm, fClearDirty);
}


STDMETHODIMP CRipComponentData::GetSizeMax
(
	ULARGE_INTEGER *pcbSize
)
{
	SPITFSNode	spNode;
	SPITFSNodeHandler	spHandler;
	SPIPersistStreamInit	spStm;
	
	m_spNodeMgr->GetRootNode(&spNode);
	spNode->GetHandler(&spHandler);
	spStm.Query(spHandler);
	
	Assert(spStm);
	return spStm->GetSizeMax(pcbSize);
}

STDMETHODIMP CRipComponentData::InitNew()
{
	SPITFSNode	spNode;
	SPITFSNodeHandler	spHandler;
	SPIPersistStreamInit	spStm;
	
	m_spNodeMgr->GetRootNode(&spNode);
	spNode->GetHandler(&spHandler);
	spStm.Query(spHandler);
	
	Assert(spStm);
	return spStm->InitNew();
}



HRESULT CRipComponentData::FinalConstruct()
{
	HRESULT				hr = hrOK;
	
	hr = CComponentData::FinalConstruct();
	
	if (FHrSucceeded(hr))
	{
		m_spTFSComponentData->GetNodeMgr(&m_spNodeMgr);
	}
	return hr;
}

void CRipComponentData::FinalRelease()
{
	CComponentData::FinalRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\nbprop.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    nbprop.h
//
// History:
//	07/22/97	Kenn M. Takara			Created.
//
//	IPX NetBIOS Broadcasts property sheet and property pages
//
//============================================================================


#ifndef _NBPROP_H
#define _NBPROP_H

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _RTRSHEET_H
#include "rtrsheet.h"
#endif


/*---------------------------------------------------------------------------
	Forward declarations
 ---------------------------------------------------------------------------*/
class IPXConnection;
class IpxNBInterfaceProperties;
class IpxNBProperties;

/*---------------------------------------------------------------------------
	class:	IpxNBIfPageGeneral
	This class handles the General page for IPX Summary interface prop sheet.
 ---------------------------------------------------------------------------*/

class IpxNBIfPageGeneral :
    public RtrPropertyPage
{
public:
	IpxNBIfPageGeneral(UINT nIDTemplate, UINT nIDCaption = 0)
			: RtrPropertyPage(nIDTemplate, nIDCaption),
			m_pIPXConn(NULL)
	{};

	~IpxNBIfPageGeneral();

	HRESULT	Init(IInterfaceInfo *pIfInfo, IPXConnection *pIpxConn,
				IpxNBInterfaceProperties * pIPXPropSheet);

protected:

	// Override the OnApply() so that we can grab our data from the
	// controls in the dialog.
	virtual BOOL OnApply();

	SPIInterfaceInfo m_spIf;
	IPXConnection *	m_pIPXConn;
	IpxNBInterfaceProperties *	m_pIPXPropSheet;

	//{{AFX_VIRTUAL(IpxNBIfPageGeneral)
	protected:
	virtual VOID	DoDataExchange(CDataExchange *pDX);
	//}}AFX_VIRTUAL

	//{{AFX_MSG(IpxNBIfPageGeneral)
	virtual BOOL	OnInitDialog();
	//}}AFX_MSG
	
	//{{AFX_MSG(IpxNBIfPageGeneral
	afx_msg	void	OnChangeButton();
	afx_msg void	OnInputFilters();
	afx_msg void	OnOutputFilters();
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};


/*---------------------------------------------------------------------------
	Class:	IpxNBInterfaceProperties

	This is the property sheet support class for the properties page of
	the nodes that appear in the IPX summary node.
 ---------------------------------------------------------------------------*/

class IpxNBInterfaceProperties :
	public RtrPropertySheet
{
public:
	IpxNBInterfaceProperties(ITFSNode *pNode,
								 IComponentData *pComponentData,
								 ITFSComponentData *pTFSCompData,
								 LPCTSTR pszSheetName,
								 CWnd *pParent = NULL,
								 UINT iPage=0,
								 BOOL fScopePane = TRUE);

	HRESULT	Init(IRtrMgrInfo *pRm, IInterfaceInfo *pInterfaceInfo);

	virtual BOOL SaveSheetData();
	virtual void CancelSheetData();

	// Loads the infobase for this interface.
	HRESULT	LoadInfoBase(IPXConnection *pIPXConn);
	HRESULT GetInfoBase(IInfoBase **ppInfoBase);
	
protected:
	SPIInterfaceInfo		m_spIf;
	SPIRtrMgrInfo			m_spRm;
	SPIRtrMgrInterfaceInfo	m_spRmIf;
	IpxNBIfPageGeneral		m_pageGeneral;
	SPITFSNode				m_spNode;
	SPIInfoBase				m_spInfoBase;
	BOOL					m_bClientInfoBase;

};


#endif _NBPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\nbprop.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	nbprop.cpp
		IPX summary node property sheet and property pages
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "rtrutil.h"	// smart MPR handle pointers
#include "format.h"		// FormatNumber function
#include "nbprop.h"
#include "summary.h"
#include "ipxrtdef.h"
#include "filter.h"

extern "C"
{
#include "routprot.h"
};


IpxNBInterfaceProperties::IpxNBInterfaceProperties(ITFSNode *pNode,
								 IComponentData *pComponentData,
								 ITFSComponentData *pTFSCompData,
								 LPCTSTR pszSheetName,
								 CWnd *pParent,
								 UINT iPage,
								 BOOL fScopePane)
	: RtrPropertySheet(pNode, pComponentData, pTFSCompData,
					   pszSheetName, pParent, iPage, fScopePane),
		m_pageGeneral(IDD_IPX_NB_IF_GENERAL_PAGE)
{
	m_spNode.Set(pNode);
}

/*!--------------------------------------------------------------------------
	IpxNBInterfaceProperties::Init
		Initialize the property sheets.  The general action here will be
		to initialize/add the various pages.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxNBInterfaceProperties::Init(IRtrMgrInfo *pRm,
											IInterfaceInfo *pIfInfo)
{
	HRESULT	hr = hrOK;
	IPXConnection *	pIPXConn;
	BaseIPXResultNodeData *	pData;

	pData = GET_BASEIPXRESULT_NODEDATA(m_spNode);
	ASSERT_BASEIPXRESULT_NODEDATA(pData);
	pIPXConn = pData->m_pIPXConnection;

	m_spRm.Set(pRm);
	m_spIf.Set(pIfInfo);
	
	// The pages are embedded members of the class
	// do not delete them.
	m_bAutoDeletePages = FALSE;

	// Initialize the infobase
	// Do this here, because the init is called in the context
	// of the main thread
	CORg( LoadInfoBase(pIPXConn) );
	
	m_pageGeneral.Init(m_spIf, pIPXConn, this);
	AddPageToList((CPropertyPageBase*) &m_pageGeneral);

Error:
	return hr;
}




/*!--------------------------------------------------------------------------
	IpxNBInterfaceProperties::LoadInfoBase
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT	IpxNBInterfaceProperties::LoadInfoBase(IPXConnection *pIPXConn)
{
	Assert(pIPXConn);
	
	HRESULT			hr = hrOK;
	SPIRouterInfo	spRouterInfo;
	HANDLE			hTransport= NULL;
	LPCOLESTR		pszInterfaceId = NULL;
	SPIInfoBase		spInfoBase;
	BYTE *			pDefault;
	int				cBlocks = 0;

	// Get the transport handle
	CWRg( ::MprConfigTransportGetHandle(pIPXConn->GetConfigHandle(),
										PID_IPX,
										&hTransport) );
								  
	// If configuring the client-interface, load the client-interface info,
	// otherwise, retrieve the interface being configured and load
	// its info.

	// The client interface doesn't have an ID
	if (m_spIf)
		pszInterfaceId = m_spIf->GetId();


	if ((pszInterfaceId == NULL) || (StrLenW(pszInterfaceId) == 0))
	{
#ifdef DEBUG
		// Check to see that this is really an client node
		{
			BaseIPXResultNodeData *	pResultData = NULL;
			pResultData = GET_BASEIPXRESULT_NODEDATA(m_spNode);
			Assert(pResultData);
			ASSERT_BASEIPXRESULT_NODEDATA(pResultData);

			Assert(pResultData->m_fClient);
		}
#endif

		// Load the client interface info
		CORg( m_spRm->GetInfoBase(pIPXConn->GetConfigHandle(),
								  hTransport,
								  NULL,
								  &spInfoBase) );
		m_bClientInfoBase = TRUE;
	}
	else
	{
		m_spRmIf.Release();
		
		CORg( m_spIf->FindRtrMgrInterface(PID_IPX,
			&m_spRmIf) );

		//
		// Future Opt. This should be made into a sync call rather
		// than a Load.
		
		//
		// Reload the information for this router-manager interface
		//
		CORg( m_spRmIf->Load(m_spIf->GetMachineName(), NULL,
							 NULL, NULL) );

		//
		// The parameters are all NULL so that we can use the
		// default RPC handles.
		//
		CORg( m_spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase) );
		m_bClientInfoBase = FALSE;
	}

	if (!spInfoBase)
	{
		// No info was found for the inteface
		// allocate a new InfoBase instead
		CORg( CreateInfoBase(&spInfoBase) );		
	}

    //
    // Check that there is a block for interface-status in the info,
    // and insert the default block if none is found.
    //
	if (spInfoBase->BlockExists(IPX_INTERFACE_INFO_TYPE) == hrFalse)
	{
		IPX_IF_INFO		ipx;

		ipx.AdminState = ADMIN_STATE_ENABLED;
		ipx.NetbiosAccept = ADMIN_STATE_DISABLED;
		ipx.NetbiosDeliver = ADMIN_STATE_DISABLED;
		CORg( spInfoBase->AddBlock(IPX_INTERFACE_INFO_TYPE,
								   sizeof(ipx),
								   (PBYTE) &ipx,
								   1 /* count */,
								   FALSE /* bRemoveFirst */) );
	}

    //
    // Check that there is a block for WAN interface-status in the info,
    // and insert the default block if none is found.
    //
	if (spInfoBase->BlockExists(IPXWAN_INTERFACE_INFO_TYPE) == hrFalse)
	{
		IPXWAN_IF_INFO		ipxwan;

		ipxwan.AdminState = ADMIN_STATE_DISABLED;
		CORg( spInfoBase->AddBlock(IPXWAN_INTERFACE_INFO_TYPE,
								   sizeof(ipxwan),
								   (PBYTE) &ipxwan,
								   1 /* count */,
								   FALSE /* bRemoveFirst */) );
	}

	m_spInfoBase = spInfoBase.Transfer();
	
Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxNBInterfaceProperties::GetInfoBase
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxNBInterfaceProperties::GetInfoBase(IInfoBase **ppInfoBase)
{
	Assert(ppInfoBase);
	
	*ppInfoBase = m_spInfoBase;
	m_spInfoBase->AddRef();

	return hrOK;
}

BOOL IpxNBInterfaceProperties::SaveSheetData()
{
    SPITFSNodeHandler	spHandler;
    SPITFSNode			spParent;
    
	// By this time each page should have written its information out
	// to the infobase

	if (m_spInfoBase)
	{
		if (m_bClientInfoBase)
		{
			Assert(m_spRm);
			m_spRm->Save(m_spRm->GetMachineName(), 0, 0, NULL,
						 m_spInfoBase, 0);
		}
		else
		{
			Assert(m_spRmIf);
			m_spRmIf->Save(m_spIf->GetMachineName(),
						   NULL, NULL, NULL, m_spInfoBase, 0);
		}
	}

    // Force the node to do a resync
    m_spNode->GetParent(&spParent);
    spParent->GetHandler(&spHandler);
    spHandler->OnCommand(spParent, IDS_MENU_SYNC, CCT_RESULT,
                         NULL, 0);
		
	return TRUE;
}

/*!--------------------------------------------------------------------------
	IpxNBInterfaceProperties::CancelSheetData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxNBInterfaceProperties::CancelSheetData()
{
}



/*---------------------------------------------------------------------------
	IpxNBIfPageGeneral
 ---------------------------------------------------------------------------*/

IpxNBIfPageGeneral::~IpxNBIfPageGeneral()
{
	if (m_pIPXConn)
	{
		m_pIPXConn->Release();
		m_pIPXConn = NULL;
	}
}

BEGIN_MESSAGE_MAP(IpxNBIfPageGeneral, RtrPropertyPage)
    //{{AFX_MSG_MAP(IpxNBIfPageGeneral)
	ON_BN_CLICKED(IDC_NIG_BTN_ACCEPT, OnChangeButton)
	ON_BN_CLICKED(IDC_NIG_BTN_DELIVER_ALWAYS, OnChangeButton)
	ON_BN_CLICKED(IDC_NIG_BTN_DELIVER_NEVER, OnChangeButton)
	ON_BN_CLICKED(IDC_NIG_BTN_DELIVER_STATIC, OnChangeButton)
	ON_BN_CLICKED(IDC_NIG_BTN_DELIVER_WHEN_UP, OnChangeButton)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void IpxNBIfPageGeneral::OnChangeButton()
{
	SetDirty(TRUE);
	SetModified();
}

/*!--------------------------------------------------------------------------
	IpxNBIfPageGeneral::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxNBIfPageGeneral::Init(IInterfaceInfo *pIfInfo,
									  IPXConnection *pIPXConn,
									  IpxNBInterfaceProperties *pPropSheet)
{
	m_spIf.Set(pIfInfo);
	m_pIPXConn = pIPXConn;
	pIPXConn->AddRef();
	m_pIPXPropSheet = pPropSheet;
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IpxNBIfPageGeneral::OnInitDialog
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL IpxNBIfPageGeneral::OnInitDialog()
{
	HRESULT	hr = hrOK;
	PBYTE	pData;
	SPIInfoBase	spInfoBase;
	IPX_IF_INFO	*	pIpxIf = NULL;
	IPXWAN_IF_INFO *pIpxWanIf = NULL;
	DWORD		dwIfType;
	UINT		iButton;

	RtrPropertyPage::OnInitDialog();
	
	//
    // The page is now initialized. Load the current configuration
    // for the interface being configured, and display its settings.
	//
	// Get the infobase from the property sheet.
    //
	CORg( m_pIPXPropSheet->GetInfoBase(&spInfoBase) );
	
    //
    // Retrieve the interface-status block configured
    //
	CORg( spInfoBase->GetData(IPX_INTERFACE_INFO_TYPE, 0, (BYTE **) &pIpxIf) );

	CheckDlgButton(IDC_NIG_BTN_ACCEPT, pIpxIf->NetbiosAccept == ADMIN_STATE_ENABLED);

	switch (pIpxIf->NetbiosDeliver)
	{
		case ADMIN_STATE_ENABLED:
			iButton = IDC_NIG_BTN_DELIVER_ALWAYS;
			break;
		case ADMIN_STATE_DISABLED:
			iButton = IDC_NIG_BTN_DELIVER_NEVER;
			break;
		case ADMIN_STATE_ENABLED_ONLY_FOR_NETBIOS_STATIC_ROUTING:
			iButton = IDC_NIG_BTN_DELIVER_STATIC;
			break;
		case ADMIN_STATE_ENABLED_ONLY_FOR_OPER_STATE_UP:
			iButton = IDC_NIG_BTN_DELIVER_WHEN_UP;
			break;
		default:
			Panic1("Unknown NetbiosDeliver state: %d", pIpxIf->NetbiosDeliver);
			iButton = -1;
			break;
	}

	if (iButton != -1)
		CheckDlgButton(iButton, ENABLED);

	SetDirty(FALSE);

Error:
	if (!FHrSucceeded(hr))
		Cancel();
	return FHrSucceeded(hr) ? TRUE : FALSE;
}

/*!--------------------------------------------------------------------------
	IpxNBIfPageGeneral::DoDataExchange
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxNBIfPageGeneral::DoDataExchange(CDataExchange *pDX)
{
	RtrPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(IpxNBIfPageGeneral)
	//}}AFX_DATA_MAP
	
}

BOOL IpxNBIfPageGeneral::OnApply()
{

    INT i;
	SPIInfoBase	spInfoBase;
	IPX_IF_INFO	*	pIpxIf = NULL;
	IPXWAN_IF_INFO *pIpxWanIf = NULL;
	BOOL	fReturn;
	HRESULT	hr = hrOK;
	DWORD	dwIfType;

    if ( m_pIPXPropSheet->IsCancel() )
	{
		CancelApply();
        return TRUE;
	}

    //
    // Retrieve the interface-status block configured
    //
	m_pIPXPropSheet->GetInfoBase(&spInfoBase);

	CORg( spInfoBase->GetData(IPX_INTERFACE_INFO_TYPE, 0, (BYTE **) &pIpxIf) );

	pIpxIf->NetbiosAccept = IsDlgButtonChecked(IDC_NIG_BTN_ACCEPT) ?
								ADMIN_STATE_ENABLED : ADMIN_STATE_DISABLED;

	if (IsDlgButtonChecked(IDC_NIG_BTN_DELIVER_ALWAYS))
		pIpxIf->NetbiosDeliver = ADMIN_STATE_ENABLED;
	else if (IsDlgButtonChecked(IDC_NIG_BTN_DELIVER_NEVER))
		pIpxIf->NetbiosDeliver = ADMIN_STATE_DISABLED;
	else if (IsDlgButtonChecked(IDC_NIG_BTN_DELIVER_STATIC))
		pIpxIf->NetbiosDeliver = ADMIN_STATE_ENABLED_ONLY_FOR_NETBIOS_STATIC_ROUTING;
	else if (IsDlgButtonChecked(IDC_NIG_BTN_DELIVER_WHEN_UP))
		pIpxIf->NetbiosDeliver = ADMIN_STATE_ENABLED_ONLY_FOR_OPER_STATE_UP;
	else
	{
		Panic0("A radio button in IPX NetBIOS Broadcasts interface config is not checked!");
	}
	
	fReturn  = RtrPropertyPage::OnApply();

Error:
	return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ripcomp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ripcomp.h
		This file contains the prototypes for the derived classes 
		for CComponent and CComponentData.  Most of these functions 
		are pure virtual functions that need to be overridden 
		for snapin functionality.
		
    FILE HISTORY:
        
*/

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

#ifndef _CCDATA_H
#include "ccdata.h"
#endif

#ifndef _COMPONT_H
#include "compont.h"
#endif

#ifndef _COLUMN_H
#include "column.h"
#endif

#ifndef _RIPSTRM_H
#include "ripstrm.h"
#endif


/*---------------------------------------------------------------------------
	CRipComponentData

	This is the base implementation of ComponentData.  This will be
	incorporated into the two derived classes.
 ---------------------------------------------------------------------------*/

class CRipComponentData :
	public CComponentData,
	public CComObjectRoot,
	public CComCoClass<CRipComponentData, &CLSID_IPXRipExtension>
{
public:
	
BEGIN_COM_MAP(CRipComponentData)
	COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

DECLARE_REGISTRY(CRipComponentData,
				 _T("RouterIPXRipExtension.RouterIPXRipExtension.1"),
				 _T("RouterIPXRipExtension.RouterIPXRipExtension"),
				 IDS_IPXRIP_SNAPIN_DESC, THREADFLAGS_APARTMENT);
	
	// These are the interfaces that we MUST implement

	// We will implement our common behavior here, with the derived
	// classes implementing the specific behavior.
	DeclareIPersistStreamInitMembers(IMPL)
	DeclareITFSCompDataCallbackMembers(IMPL)

	CRipComponentData();

	HRESULT FinalConstruct();
	void FinalRelease();
	
protected:
	SPITFSNodeMgr	m_spNodeMgr;
};



/////////////////////////////////////////////////////////////////////////////
//
// CSampleComponent
//
/////////////////////////////////////////////////////////////////////////////

class CRipComponent : 
	public TFSComponent,
	public IPersistStreamInit
{
public:
	CRipComponent();
	~CRipComponent();

	DeclareIUnknownMembers(IMPL)
	DeclareIPersistStreamInitMembers(IMPL)
	DeclareITFSCompCallbackMembers(IMPL)

	// Override OnQueryDataObject, so that we can forward
	// the calls down to the Result Handlers
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject);
	
    STDMETHOD(OnSnapinHelp)(LPDATAOBJECT, LPARAM, LPARAM);
    
//Attributes
private:
	RipComponentConfigStream	m_ComponentConfig;
};



/*---------------------------------------------------------------------------
	This is the derived class for handling the IAbout interface from MMC
	Author: EricDav
 ---------------------------------------------------------------------------*/
class CRipAbout : 
	public CAbout,
    public CComCoClass<CRipAbout, &CLSID_IPXRipExtensionAbout>
{
public:
DECLARE_REGISTRY(CRipAbout, 
				 _T("RouterIPXRipSnapin.About.1"), 
				 _T("RouterIPXRipSnapin.About"), 
				 IDS_IPXRIP_SNAPIN_DESC, 
				 THREADFLAGS_APARTMENT)

BEGIN_COM_MAP(CRipAbout)
    COM_INTERFACE_ENTRY(ISnapinAbout) // Must have one static entry
	COM_INTERFACE_ENTRY_CHAIN(CAbout) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CRipAbout)

// these must be overridden to provide values to the base class
protected:
	virtual UINT GetAboutDescriptionId() { return IDS_ABOUT_DESCRIPTION; }
	virtual UINT GetAboutProviderId()	 { return IDS_ABOUT_PROVIDER; }
	virtual UINT GetAboutVersionId()	 { return IDS_ABOUT_VERSION; }
	virtual UINT GetAboutIconId()		 { return IDI_IPX_SNAPIN_ICON; }

	virtual UINT GetSmallRootId()		 { return 0; }
	virtual UINT GetSmallOpenRootId()	 { return 0; }
	virtual UINT GetLargeRootId()		 { return 0; }
	virtual COLORREF GetLargeColorMask() { return (COLORREF) 0; } 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\nbview.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	summary.cpp
		IPX summary node implementation.
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "util.h"
#include "nbview.h"
#include "reg.h"
#include "ipxadmin.h"
#include "rtrutil.h"	// smart MPR handle pointers
#include "ipxstrm.h"		// IPXAdminConfigStream
#include "strmap.h"		// XXXtoCString functions
#include "service.h"	// TFS service APIs
#include "format.h"		// FormatNumber function
#include "coldlg.h"		// columndlg
#include "column.h"	// ComponentConfigStream
#include "rtrui.h"
#include "nbprop.h"		// NetBIOS broadcast property pages
#include "ipxutil.h"	// IPX formatting helper functions
#include "routprot.h"

#include "ipxrtdef.h"

/*---------------------------------------------------------------------------
	Keep this in sync with the column ids in nbview.h
 ---------------------------------------------------------------------------*/
extern const ContainerColumnInfo	s_rgNBViewColumnInfo[];

const ContainerColumnInfo	s_rgNBViewColumnInfo[] = 
{
	{ IDS_IPX_NB_COL_NAME,			CON_SORT_BY_STRING,	TRUE, COL_IF_NAME },
	{ IDS_IPX_NB_COL_TYPE,			CON_SORT_BY_STRING,	TRUE, COL_IF_DEVICE },
	{ IDS_IPX_NB_COL_ACCEPTED,		CON_SORT_BY_STRING,	TRUE, COL_STRING },
	{ IDS_IPX_NB_COL_DELIVERED,		CON_SORT_BY_STRING,	TRUE, COL_STRING },
	{ IDS_IPX_NB_COL_SENT,			CON_SORT_BY_DWORD,	TRUE, COL_LARGE_NUM },
	{ IDS_IPX_NB_COL_RECEIVED,		CON_SORT_BY_DWORD,	TRUE, COL_LARGE_NUM },
};


/*---------------------------------------------------------------------------
	IpxNBHandler implementation
 ---------------------------------------------------------------------------*/

IpxNBHandler::IpxNBHandler(ITFSComponentData *pCompData)
	: BaseContainerHandler(pCompData, COLUMNS_NBBROADCASTS,
						   s_rgNBViewColumnInfo),
	m_ulConnId(0),
	m_ulRefreshConnId(0)
{
	// Setup the verb states
	m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
	m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;
	
}


STDMETHODIMP IpxNBHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IRtrAdviseSink)
		*ppv = &m_IRtrAdviseSink;
	else
		return BaseContainerHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;	
}



/*!--------------------------------------------------------------------------
	IpxNBHandler::DestroyHandler
		Implementation of ITFSNodeHandler::DestroyHandler
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxNBHandler::DestroyHandler(ITFSNode *pNode)
{
	IPXConnection *	pIpxConn;

	pIpxConn = GET_IPXNB_NODEDATA(pNode);
	pIpxConn->Release();

	if (m_ulRefreshConnId)
	{
		SPIRouterRefresh	spRefresh;
		if (m_spRouterInfo)
			m_spRouterInfo->GetRefreshObject(&spRefresh);
		if (spRefresh)
			spRefresh->UnadviseRefresh(m_ulRefreshConnId);
	}
	m_ulRefreshConnId = 0;

//	if (m_ulStatsConnId)
//	{
//		SPIRouterRefresh	spRefresh;
//		if (m_spRouterInfo)
//			m_spRouterInfo->GetRefreshObject(&spRefresh);
//		if (spRefresh)
//			spRefresh->UnadviseRefresh(m_ulStatsConnId);		
//	}
//	m_ulStatsConnId = 0;
	
	if (m_ulConnId)
		m_spRtrMgrInfo->RtrUnadvise(m_ulConnId);
	m_ulConnId = 0;
	m_spRtrMgrInfo.Release();

//	WaitForStatisticsWindow(&m_IpxStats);

	m_spRouterInfo.Release();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IpxNBHandler::HasPropertyPages
		Implementation of ITFSNodeHandler::HasPropertyPages
	NOTE: the root node handler has to over-ride this function to 
	handle the snapin manager property page (wizard) case!!!
	
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
IpxNBHandler::HasPropertyPages
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	return hrFalse;
}




/*!--------------------------------------------------------------------------
	IpxNBHandler::OnAddMenuItems
		Implementation of ITFSNodeHandler::OnAddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxNBHandler::OnAddMenuItems(
	ITFSNode *pNode,
	LPCONTEXTMENUCALLBACK pContextMenuCallback, 
	LPDATAOBJECT lpDataObject, 
	DATA_OBJECT_TYPES type, 
	DWORD dwType,
	long *pInsertionAllowed)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = S_OK;
	
	COM_PROTECT_TRY
	{
	}
	COM_PROTECT_CATCH;
		
	return hr; 
}

STDMETHODIMP IpxNBHandler::OnCommand(ITFSNode *pNode, long nCommandId, 
										   DATA_OBJECT_TYPES	type, 
										   LPDATAOBJECT pDataObject, 
										   DWORD	dwType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;
	SPITFSNode			spParent;
	SPITFSNodeHandler	spHandler;

	COM_PROTECT_TRY
	{
		switch (nCommandId)
		{
			case IDS_MENU_SYNC:
				SynchronizeNodeData(pNode);
				break;
		}
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	IpxNBHandler::OnExpand
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxNBHandler::OnExpand(ITFSNode *pNode,
							   LPDATAOBJECT pDataObject,
							   DWORD dwType,
							   LPARAM arg,
							   LPARAM lParam)
{
	HRESULT	hr = hrOK;
	SPIEnumInterfaceInfo	spEnumIf;
	SPIInterfaceInfo		spIf;
	SPIRtrMgrInterfaceInfo	spRmIf;
	
    // Windows NT Bug: 288427
    // This flag may also get set inside of the OnChange() call.
    // The OnChange() will enumerate and all interfaces.
    // They may have been added as the result of an OnChange()
    // because they were added before the OnExpand() was called.
    //
    // WARNING!  Be careful about adding anything to this function,
    //  since the m_bExpanded can be set in another function.
    // ----------------------------------------------------------------
	if (m_bExpanded)
		return hrOK;

	COM_PROTECT_TRY
	{
		
		CORg( m_spRouterInfo->EnumInterface(&spEnumIf) );

		while (spEnumIf->Next(1, &spIf, NULL) == hrOK)
		{
			if (spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) == hrOK)
			{
				// Now we create an interface node for this interface
				AddInterfaceNode(pNode, spIf, FALSE);
			}
			spRmIf.Release();
			spIf.Release();
		}

		//$CLIENT: Add the client interface (setup default data)
		// the only thing that we can do in synchronize is to
		// get the Administrative status
		AddInterfaceNode(pNode, NULL, TRUE);

		m_bExpanded = TRUE;

		// Now that we have all of the nodes, update the data for
		// all of the nodes
		SynchronizeNodeData(pNode);

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;



	m_bExpanded = TRUE;

	return hr;
}

/*!--------------------------------------------------------------------------
	IpxNBHandler::GetString
		Implementation of ITFSNodeHandler::GetString
		We don't need to do anything, since our root node is an extension
		only and thus can't do anything to the node text.
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) IpxNBHandler::GetString(ITFSNode *pNode, int nCol)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		if (m_stTitle.IsEmpty())
			m_stTitle.LoadString(IDS_IPXNB_TITLE);
	}
	COM_PROTECT_CATCH;

	return m_stTitle;
}

/*!--------------------------------------------------------------------------
	IpxNBHandler::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxNBHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{

		Assert(m_spRtrMgrInfo);
		
		CORg( CreateDataObjectFromRtrMgrInfo(m_spRtrMgrInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxNBHandler::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxNBHandler::Init(IRtrMgrInfo *pRmInfo, IPXAdminConfigStream *pConfigStream)
{
	m_spRtrMgrInfo.Set(pRmInfo);
	if (pRmInfo)
		pRmInfo->GetParentRouterInfo(&m_spRouterInfo);
	m_pConfigStream = pConfigStream;
	
	// Also need to register for change notifications
	Assert(m_ulConnId == 0);
	m_spRtrMgrInfo->RtrAdvise(&m_IRtrAdviseSink, &m_ulConnId, 0);

//	m_IpxStats.SetConfigInfo(pConfigStream, IPXSTRM_STATS_IPX);

	return hrOK;
}


HRESULT IpxNBHandler::OnResultRefresh(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT  hr = hrOK;
    SPITFSNode spNode, spParent;
    SPITFSResultHandler spParentRH;

    m_spNodeMgr->FindNode(cookie, &spNode);

    // forward this command to the parent to handle
    CORg (spNode->GetParent(&spParent));
    CORg (spParent->GetResultHandler(&spParentRH));

    CORg (spParentRH->Notify(pComponent, spParent->GetData(TFS_DATA_COOKIE), pDataObject, MMCN_REFRESH, arg, lParam));

Error:
    return hrOK;

}

/*!--------------------------------------------------------------------------
	IpxNBHandler::ConstructNode
		Initializes the root node (sets it up).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxNBHandler::ConstructNode(ITFSNode *pNode, LPCTSTR pszName,
										IPXConnection *pIpxConn)
{
	Assert(pIpxConn);
	HRESULT			hr = hrOK;
	
	if (pNode == NULL)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Need to initialize the data for the root node
		pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_IPX_NODE_GENERAL);
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_IPX_NODE_GENERAL);
		pNode->SetData(TFS_DATA_SCOPEID, 0);

        // This is a leaf node in the scope pane
        pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

		m_cookie = reinterpret_cast<DWORD_PTR>(pNode);
		pNode->SetData(TFS_DATA_COOKIE, m_cookie);

		pNode->SetNodeType(&GUID_IPXNetBIOSBroadcastsNodeType);

		// Setup the node data
		pIpxConn->AddRef();
		SET_IPXNB_NODEDATA(pNode, pIpxConn);

//		m_IpxStats.SetConnectionData(pIpxConn);
	}
	COM_PROTECT_CATCH;

	if (!FHrSucceeded(hr))
	{
		SET_IPXNB_NODEDATA(pNode, NULL);
	}

	return hr;
}


/*!--------------------------------------------------------------------------
	IpxNBHandler::AddInterfaceNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT	IpxNBHandler::AddInterfaceNode(ITFSNode *pParent, IInterfaceInfo *pIf, BOOL fClient)
{
	IpxNBInterfaceHandler *	pHandler;
	SPITFSResultHandler		spHandler;
	SPITFSNode				spNode;
	HRESULT					hr = hrOK;
	IPXConnection *			pIPXConn;
	BaseIPXResultNodeData *	pResultData = NULL;
	int						cBlocks = 0;
	SPIInfoBase				spInfoBase;
	SPIRtrMgrInterfaceInfo	spRmIf;

	// Create the handler for this node 
	pHandler = new IpxNBInterfaceHandler(m_spTFSCompData);
	spHandler = pHandler;
	CORg( pHandler->Init(m_spRtrMgrInfo, pIf, pParent) );

	pIPXConn = GET_IPXNB_NODEDATA(pParent);

	// Create a result item node (or a leaf node)
	CORg( CreateLeafTFSNode(&spNode,
							NULL,
							static_cast<ITFSNodeHandler *>(pHandler),
							static_cast<ITFSResultHandler *>(pHandler),
							m_spNodeMgr) );
	CORg( pHandler->ConstructNode(spNode, pIf, pIPXConn) );

	pResultData = GET_BASEIPXRESULT_NODEDATA(spNode);
	Assert(pResultData);
	ASSERT_BASEIPXRESULT_NODEDATA(pResultData);

	pResultData->m_fClient = fClient;

	// Make the node immediately visible
	CORg( spNode->SetVisibilityState(TFS_VIS_SHOW) );
	CORg( spNode->Show() );
	
	CORg( pParent->AddChild(spNode) );

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxNBHandler::SynchronizeNodeData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxNBHandler::SynchronizeNodeData(ITFSNode *pThisNode)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	SPITFSNode				spNode;
	SPITFSNodeEnum			spEnumNode;
	SPIInterfaceInfo		spIf;
	IpxNBArray				ipxNBArray;
	IpxNBArrayEntry			ipxNBEntry;
	IpxNBArrayEntry *		pEntry;
	HRESULT					hr = hrOK;
	int						cEntries;
	BaseIPXResultNodeData *	pData;
	int						cArray, iArray;

	// Get a list of interface ids
	CORg( pThisNode->GetEnum(&spEnumNode) );

	cEntries = 0;
	for (; spEnumNode->Next(1, &spNode, NULL) == hrOK; spNode.Release())
	{
		pData = GET_BASEIPXRESULT_NODEDATA(spNode);
		Assert(pData);
		ASSERT_BASEIPXRESULT_NODEDATA(pData);

		// Fill in the strings with a set of default values
		if (pData->m_fClient)
		{
			pData->m_rgData[IPXNB_SI_NAME].m_stData.LoadString(IDS_IPX_DIAL_IN_CLIENTS);
			pData->m_rgData[IPXNB_SI_TYPE].m_stData =
				IpxTypeToCString(ROUTER_IF_TYPE_CLIENT);
		}
		else
		{
			pData->m_rgData[IPXNB_SI_NAME].m_stData =
				pData->m_spIf->GetTitle();

			pData->m_rgData[IPXNB_SI_TYPE].m_dwData =
				pData->m_spIf->GetInterfaceType();
			pData->m_rgData[IPXNB_SI_TYPE].m_stData =
				InterfaceTypeToCString(pData->m_spIf->GetInterfaceType());
		}


		// Setup some defaults
		::ZeroMemory(&ipxNBEntry, sizeof(ipxNBEntry));
		ipxNBEntry.m_dwAccept = 0xFFFFFFFF;
		ipxNBEntry.m_dwDeliver = 0xFFFFFFFF;
		ipxNBEntry.m_cSent = 0xFFFFFFFF;
		ipxNBEntry.m_cReceived = 0xFFFFFFFF;
		
		ipxNBEntry.m_fClient = pData->m_fClient;

		// If this is not a client, then we should have an m_spIf
		if (!pData->m_fClient)
			StrnCpyTFromOle(ipxNBEntry.m_szId, pData->m_spIf->GetId(),
							DimensionOf(ipxNBEntry.m_szId));
		
		ipxNBArray.SetAtGrow(cEntries, ipxNBEntry);
		cEntries++;
	}
	
	// Gather the data for this set of interface ids, this part
	// could go on a background thread (so that we don't block the
	// main thread). 
	CORg( GetIpxNBData(pThisNode, &ipxNBArray) );

	// Write the data back out to the nodes ( and also fill in
	// some data).
	spEnumNode->Reset();
	for (; spEnumNode->Next(1, &spNode, NULL) == hrOK; spNode.Release())
	{
		pData = GET_BASEIPXRESULT_NODEDATA(spNode);
		Assert(pData);
		ASSERT_BASEIPXRESULT_NODEDATA(pData);

		cArray = (int) ipxNBArray.GetSize();
		for (iArray = 0; iArray < cArray; iArray++)
		{
			pEntry = &ipxNBArray[iArray];
			
			if ((pData->m_fClient && pEntry->m_fClient) ||
				(pData->m_spIf &&
				 (StriCmp(pEntry->m_szId, pData->m_spIf->GetId()) == 0)))
			{
				pData->m_rgData[IPXNB_SI_ACCEPTED].m_stData =
					IpxAcceptBroadcastsToCString(pEntry->m_dwAccept);
				pData->m_rgData[IPXNB_SI_DELIVERED].m_stData =
					IpxDeliveredBroadcastsToCString(pEntry->m_dwDeliver);
				
				if (pEntry->m_cSent == 0xFFFFFFFF)
					pData->m_rgData[IPXNB_SI_SENT].m_stData.LoadString(IDS_STATS_NA);
				else
					FillInNumberData(pData, IPXNB_SI_SENT,
									 pEntry->m_cSent);
				
				if (pEntry->m_cReceived == 0xFFFFFFFF)
					pData->m_rgData[IPXNB_SI_RECEIVED].m_stData.LoadString(IDS_STATS_NA);
				else
					FillInNumberData(pData, IPXNB_SI_RECEIVED,
									 pEntry->m_cReceived);
				break;
			}
		}
		
		// Force MMC to redraw the nodes
		spNode->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);

	}

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxNBHandler::GetClientInterfaceData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxNBHandler::GetClientInterfaceData(IpxNBArrayEntry *pClient,
											 IRtrMgrInfo *pRm)
{
	SPIInfoBase	spInfoBase;
	InfoBlock *	pIpxBlock;
	InfoBlock *	pWanBlock;
	HRESULT		hr = hrOK;
	BOOL		fSave = FALSE;
	IPX_IF_INFO *pIpxInfo;
	
	pRm->GetInfoBase(NULL, NULL, NULL, &spInfoBase);
	if (spInfoBase == NULL)
	{
		CORg( CreateInfoBase(&spInfoBase) );
	}
	
	if (spInfoBase->GetBlock(IPX_INTERFACE_INFO_TYPE, &pIpxBlock, 0) != hrOK)
	{
		// We couldn't find the block, add it in
		IPX_IF_INFO	ipx;

		ipx.AdminState = ADMIN_STATE_ENABLED;
		ipx.NetbiosAccept = ADMIN_STATE_DISABLED;
		ipx.NetbiosDeliver = ADMIN_STATE_DISABLED;

		CORg( spInfoBase->AddBlock(IPX_INTERFACE_INFO_TYPE,
								   sizeof(ipx),
								   (PBYTE) &ipx,
								   1,
								   0) );
		CORg( spInfoBase->GetBlock(IPX_INTERFACE_INFO_TYPE, &pIpxBlock, 0) );
		fSave = TRUE;
	}
	pIpxInfo = (PIPX_IF_INFO) pIpxBlock->pData;

	pClient->m_dwAccept = pIpxInfo->NetbiosAccept;
	pClient->m_dwDeliver = pIpxInfo->NetbiosDeliver;

	
	if (spInfoBase->GetBlock(IPXWAN_INTERFACE_INFO_TYPE, &pWanBlock, 0) != hrOK)
	{
		// We couldn't find the block, add it in
		IPXWAN_IF_INFO	wan;

		wan.AdminState = ADMIN_STATE_ENABLED;

		CORg( spInfoBase->AddBlock(IPXWAN_INTERFACE_INFO_TYPE,
								   sizeof(wan),
								   (PBYTE) &wan,
								   1,
								   0) );
		CORg( spInfoBase->GetBlock(IPXWAN_INTERFACE_INFO_TYPE,
								   &pWanBlock, 0) );
		fSave = TRUE;
	}	

	if (fSave)
	{
		pRm->Save(NULL,			// pszMachine
				  NULL,			// hMachine
				  NULL,			// hTransport
				  NULL,			// pGlobalInfo
				  spInfoBase,	// pClientInfo
				  0);			// dwDeleteProtocolId
	}

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxNBHandler::GetIpxNBData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT	IpxNBHandler::GetIpxNBData(ITFSNode *pThisNode,
								   IpxNBArray *pIpxNBArray)
{
	HRESULT	hr = hrOK;
	IPXConnection *	pIPXConn;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	PIPX_INTERFACE		pIpxIf = NULL;
	DWORD				cbIpxIf;
	SPMprMibBuffer		spMib;
	IpxNBArrayEntry *	pEntry = NULL;
	DWORD				dwErr;
	int					iArray, cArray;
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPIInfoBase			spInfoBase;
	PIPX_IF_INFO		pIfInfo;
	SPITFSNodeEnum		spEnumNode;
	SPITFSNode			spNode;
	BaseIPXResultNodeData *	pData;
	USES_CONVERSION;

	pIPXConn = GET_IPXNB_NODEDATA(pThisNode);

	// Go through the array, filling in all of the interface indices
	MibGetInputData.TableId = IPX_INTERFACE_TABLE;
	dwErr = ::MprAdminMIBEntryGetFirst(pIPXConn->GetMibHandle(),
									   PID_IPX,
									   IPX_PROTOCOL_BASE,
									   &MibGetInputData,
									   sizeof(MibGetInputData),
									   (LPVOID *) &pIpxIf,
									   &cbIpxIf);
	hr = HRESULT_FROM_WIN32(dwErr);
	spMib = (PBYTE) pIpxIf;
	
	while (FHrSucceeded(hr))
	{
		// Now match this up to a name in the array
		cArray = (int) pIpxNBArray->GetSize();
		for (iArray = 0; iArray<cArray; iArray++)
		{
			pEntry = &((*pIpxNBArray)[iArray]);
			if (StriCmp(pEntry->m_szId, A2CT((LPCSTR) pIpxIf->InterfaceName)) == 0)
			{
				// Ok, we found a match
				pEntry->m_cSent = pIpxIf->IfStats.NetbiosSent;
				pEntry->m_cReceived = pIpxIf->IfStats.NetbiosReceived;
				break;
			}
		}

		MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex =
			pIpxIf->InterfaceIndex;

		// Get the next name
		spMib.Free();
		pIpxIf = NULL;
		
		dwErr = ::MprAdminMIBEntryGetNext(pIPXConn->GetMibHandle(),
										  PID_IPX,
										  IPX_PROTOCOL_BASE,
										  &MibGetInputData,
										  sizeof(MibGetInputData),
										  (LPVOID *) &pIpxIf,
										  &cbIpxIf);
		hr = HRESULT_FROM_WIN32(dwErr);
		spMib = (PBYTE) pIpxIf;

	}

	spMib.Free();


	// Now we need to grab the data from the infobase (these access
	// could lead to a MIB access and thus a RPC).  This is why we do
	// it here also.

	// Instead of iterating through the MIBs, iterate through the
	// interfaces that appear in the node.
	
	pThisNode->GetEnum(&spEnumNode);

	for (; spEnumNode->Next(1, &spNode, NULL) == hrOK; spNode.Release())
	{
		pData = GET_BASEIPXRESULT_NODEDATA(spNode);
		Assert(pData);
		ASSERT_BASEIPXRESULT_NODEDATA(pData);

		// Now look for a match in the nodes
		cArray = (int) pIpxNBArray->GetSize();
		for (iArray=0; iArray < cArray; iArray++)
		{
			pEntry = &((*pIpxNBArray)[iArray]);
			if (pEntry->m_fClient && pData->m_fClient)
			{
				GetClientInterfaceData(pEntry, m_spRtrMgrInfo);
				break;
			}
			else if (pData->m_fClient)
				break;

			// No match, continue on
			if (StriCmp(pEntry->m_szId, pData->m_spIf->GetId()))
				continue;

			// Get the data for this node and set it.
			spRmIf.Release();
			hr = pData->m_spIf->FindRtrMgrInterface(PID_IPX, &spRmIf);
			if (hr != hrOK)
				break;

			spInfoBase.Release();
			hr = spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase);
			if (hr != hrOK)
				break;

			spInfoBase->GetData(IPX_INTERFACE_INFO_TYPE, 0, (LPBYTE *) &pIfInfo);
			if (pIfInfo)
			{
				pEntry->m_dwAccept = pIfInfo->NetbiosAccept;
				pEntry->m_dwDeliver = pIfInfo->NetbiosDeliver;
			}
			break;
		}
	}


//Error:
	if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
		hr = hrOK;
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxNBHandler::AddMenuItems
		Implementation of ITFSResultHandler::AddMenuItems
		Use this to add commands to the context menu of the blank areas
		of the result pane.
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxNBHandler::AddMenuItems(ITFSComponent *pComponent,
											  MMC_COOKIE cookie,
											  LPDATAOBJECT pDataObject,
											  LPCONTEXTMENUCALLBACK pCallback,
											  long *pInsertionAllowed)
{
	return hrOK;
}


/*!--------------------------------------------------------------------------
	IpxNBHandler::Command
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxNBHandler::Command(ITFSComponent *pComponent,
									   MMC_COOKIE cookie,
									   int nCommandID,
									   LPDATAOBJECT pDataObject)
{
	return hrOK;
}


ImplementEmbeddedUnknown(IpxNBHandler, IRtrAdviseSink)

STDMETHODIMP IpxNBHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
	DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	InitPThis(IpxNBHandler, IRtrAdviseSink);
	SPITFSNode				spThisNode;
	SPITFSNode				spNode;
	SPITFSNodeEnum			spEnumNode;
	SPIEnumInterfaceInfo	spEnumIf;
	SPIInterfaceInfo		spIf;
	BOOL					fFound;
	BOOL					fPleaseAdd;
	BaseIPXResultNodeData *	pData;
	HRESULT					hr = hrOK;

	pThis->m_spNodeMgr->FindNode(pThis->m_cookie, &spThisNode);
	
	if (dwObjectType == ROUTER_OBJ_RmIf)
	{
		if (dwChangeType == ROUTER_CHILD_ADD)
		{
			// Enumerate through the list of interfaces looking for
			// the interfaces that have this protocol.  If we find
			// one, look for this interface in our list of nodes.
			spThisNode->GetEnum(&spEnumNode);

			CORg( pThis->m_spRouterInfo->EnumInterface(&spEnumIf) );

			spEnumIf->Reset();

			fPleaseAdd = FALSE;

			for (; spEnumIf->Next(1, &spIf, NULL) == hrOK; spIf.Release())
			{
				// Look for this interface in our list of nodes
				// If it's there than continue on
				fFound = FALSE;
				spEnumNode->Reset();
				spNode.Release();

				for (; spEnumNode->Next(1, &spNode, NULL) == hrOK; spNode.Release())
				{
					pData = GET_BASEIPXRESULT_NODEDATA(spNode);
					Assert(pData);
					ASSERT_BASEIPXRESULT_NODEDATA(pData);

					if (!pData->m_fClient && StriCmpW(pData->m_spIf->GetId(), spIf->GetId()) == 0)
					{
						fFound = TRUE;
						break;
					}
				}

				// If the interface was not found in the list of nodes,
				// then it is a candidate.  Now we have to see if the
				// interface supports this transport.
				if (!fFound && (spIf->FindRtrMgrInterface(pThis->m_spRtrMgrInfo->GetTransportId(), NULL) == hrOK))
				{
					// If this interface has this transport, and is NOT in
					// the current list of nodes then add this interface
					// to the UI
					pThis->AddInterfaceNode(spThisNode, spIf, FALSE);
					fPleaseAdd = TRUE;
				}
			}

            // If it's not expanded, then we haven't added
            // the dial-in clients node.    
            if (!pThis->m_bExpanded)
            {
                //$CLIENT: Add the client interface (setup default data)
                // the only thing that we can do in synchronize is to
                // get the Administrative status
                pThis->AddInterfaceNode(spThisNode, NULL, TRUE);

                fPleaseAdd = TRUE;
            }
            
			// Now that we have all of the nodes, update the data for
			// all of the nodes
			if (fPleaseAdd)
				pThis->SynchronizeNodeData(spThisNode);
			
            // Windows NT Bug : 288247
            // Set this here, so that we can avoid the nodes being
            // added in the OnExpand().
            pThis->m_bExpanded = TRUE;
		}
		else if (dwChangeType == ROUTER_CHILD_DELETE)
		{
			// Go through the list of nodes, if we cannot find the
			// node in the list of interfaces, delete the node
			spThisNode->GetEnum(&spEnumNode);
			spEnumNode->Reset();
			while (spEnumNode->Next(1, &spNode, NULL) == hrOK)
			{
				// Get the node data, look for the interface
				pData = GET_BASEIPXRESULT_NODEDATA(spNode);
				ASSERT_BASEIPXRESULT_NODEDATA(pData);
				
				//$CLIENT: if this is a client interface, we can't
				// delete the node
					
				if (!pData->m_fClient &&
					(LookupRtrMgrInterface(pThis->m_spRouterInfo,
										  pData->m_spIf->GetId(),
										  pThis->m_spRtrMgrInfo->GetTransportId(),
										  NULL) != hrOK))
				{
					// cannot find the interface, release this node!
					spThisNode->RemoveChild(spNode);
					spNode->Destroy();
				}
				spNode.Release();
				spIf.Release();
			}
			
		}
	}
	else if (dwChangeType == ROUTER_REFRESH)
	{
		pThis->SynchronizeNodeData(spThisNode);
	}
	
Error:
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IpxNBHandler::OnResultShow
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxNBHandler::OnResultShow(ITFSComponent *pTFSComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	BOOL	bSelect = (BOOL) arg;
	HRESULT	hr = hrOK;
	SPIRouterRefresh	spRefresh;
	SPITFSNode	spNode;

	BaseContainerHandler::OnResultShow(pTFSComponent, cookie, arg, lParam);

	if (bSelect)
	{
		// Call synchronize on this node
		m_spNodeMgr->FindNode(cookie, &spNode);
		if (spNode)
			SynchronizeNodeData(spNode);
	}

	// Un/Register for refresh advises
	if (m_spRouterInfo)
		m_spRouterInfo->GetRefreshObject(&spRefresh);

	if (spRefresh)
	{
		if (bSelect)
		{
			if (m_ulRefreshConnId == 0)
				spRefresh->AdviseRefresh(&m_IRtrAdviseSink, &m_ulRefreshConnId, 0);

//			if (m_ulStatsConnId == 0)
//				spRefresh->AdviseRefresh(&m_IRtrAdviseSink, &m_ulStatsConnId, 0);
		}
		else
		{
			if (m_ulRefreshConnId)
				spRefresh->UnadviseRefresh(m_ulRefreshConnId);
			m_ulRefreshConnId = 0;

			// We do not clean up the stats refresh on not show, since the
			// dialogs may still be up.
		}
	}
	
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxNBHandler::CompareItems
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int) IpxNBHandler::CompareItems(
								ITFSComponent * pComponent,
								MMC_COOKIE cookieA,
								MMC_COOKIE cookieB,
								int nCol)
{
	// Get the strings from the nodes and use that as a basis for
	// comparison.
	SPITFSNode	spNode;
	SPITFSResultHandler	spResult;

	m_spNodeMgr->FindNode(cookieA, &spNode);
	spNode->GetResultHandler(&spResult);
	return spResult->CompareItems(pComponent, cookieA, cookieB, nCol);
}


/*---------------------------------------------------------------------------
	Class: IpxNBInterfaceHandler
 ---------------------------------------------------------------------------*/

IpxNBInterfaceHandler::IpxNBInterfaceHandler(ITFSComponentData *pCompData)
	: BaseIPXResultHandler(pCompData, COLUMNS_NBBROADCASTS),
	m_ulConnId(0)
{
 	m_rgButtonState[MMC_VERB_PROPERTIES_INDEX] = ENABLED;
	m_bState[MMC_VERB_PROPERTIES_INDEX] = TRUE;
	
 	m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
	m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;
	
	m_verbDefault = MMC_VERB_PROPERTIES;
}

static const DWORD s_rgInterfaceImageMap[] =
	 {
	 ROUTER_IF_TYPE_HOME_ROUTER,	IMAGE_IDX_WAN_CARD,
	 ROUTER_IF_TYPE_FULL_ROUTER,	IMAGE_IDX_WAN_CARD,
	 ROUTER_IF_TYPE_CLIENT,			IMAGE_IDX_WAN_CARD,
	 ROUTER_IF_TYPE_DEDICATED,		IMAGE_IDX_LAN_CARD,
	 ROUTER_IF_TYPE_INTERNAL,		IMAGE_IDX_LAN_CARD,
	 ROUTER_IF_TYPE_LOOPBACK,		IMAGE_IDX_LAN_CARD,
	 -1,							IMAGE_IDX_WAN_CARD,	// sentinel value
	 };

/*!--------------------------------------------------------------------------
	IpxNBInterfaceHandler::ConstructNode
		Initializes the Domain node (sets it up).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxNBInterfaceHandler::ConstructNode(ITFSNode *pNode, IInterfaceInfo *pIfInfo, IPXConnection *pIPXConn)
{
	HRESULT			hr = hrOK;
	int				i;
	
	if (pNode == NULL)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Find the right image index for this type of node
		if (pIfInfo)
		{
			for (i=0; i<DimensionOf(s_rgInterfaceImageMap); i+=2)
			{
				if ((pIfInfo->GetInterfaceType() == s_rgInterfaceImageMap[i]) ||
					(-1 == s_rgInterfaceImageMap[i]))
					break;
			}
		}
		else
		{
			i = 2;	// if no interface, assume this is a client interface
		}

		pNode->SetData(TFS_DATA_IMAGEINDEX, s_rgInterfaceImageMap[i+1]);
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, s_rgInterfaceImageMap[i+1]);
		
		pNode->SetData(TFS_DATA_SCOPEID, 0);

		pNode->SetData(TFS_DATA_COOKIE, reinterpret_cast<DWORD_PTR>(pNode));

		//$ Review: kennt, what are the different type of interfaces
		// do we distinguish based on the same list as above? (i.e. the
		// one for image indexes).
		pNode->SetNodeType(&GUID_IPXNetBIOSBroadcastsInterfaceNodeType);

		BaseIPXResultNodeData::Init(pNode, pIfInfo, pIPXConn);
	}
	COM_PROTECT_CATCH
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxNBInterfaceHandler::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxNBInterfaceHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		CORg( CreateDataObjectFromInterfaceInfo(m_spInterfaceInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxNBInterfaceHandler::OnCreateDataObject
		Implementation of ITFSResultHandler::OnCreateDataObject
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxNBInterfaceHandler::OnCreateDataObject(ITFSComponent *pComp, MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		CORg( CreateDataObjectFromInterfaceInfo(m_spInterfaceInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}



/*!--------------------------------------------------------------------------
	IpxNBInterfaceHandler::RefreshInterface
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxNBInterfaceHandler::RefreshInterface(MMC_COOKIE cookie)
{
	SPITFSNode	spNode;
	
	m_spNodeMgr->FindNode(cookie, &spNode);
	ForwardCommandToParent(spNode, IDS_MENU_SYNC,
						   CCT_RESULT, NULL, 0);
}


/*!--------------------------------------------------------------------------
	IpxNBInterfaceHandler::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxNBInterfaceHandler::Init(IRtrMgrInfo *pRm, IInterfaceInfo *pIfInfo, ITFSNode *pParent)
{
	m_spRm.Set(pRm);
    if (pRm)
        pRm->GetParentRouterInfo(&m_spRouterInfo);
	m_spInterfaceInfo.Set(pIfInfo);

	BaseIPXResultHandler::Init(pIfInfo, pParent);
	return hrOK;
}


/*!--------------------------------------------------------------------------
	IpxNBInterfaceHandler::DestroyResultHandler
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxNBInterfaceHandler::DestroyResultHandler(MMC_COOKIE cookie)
{
	m_spInterfaceInfo.Release();
	BaseIPXResultHandler::DestroyResultHandler(cookie);
	return hrOK;
}


/*---------------------------------------------------------------------------
	This is the list of commands that will show up for the result pane
	nodes.
 ---------------------------------------------------------------------------*/
struct SIPXInterfaceNodeMenu
{
	ULONG	m_sidMenu;			// string/command id for this menu item
	ULONG	(IpxNBInterfaceHandler:: *m_pfnGetMenuFlags)(IpxNBInterfaceHandler::SMenuData *);
	ULONG	m_ulPosition;
};

/*!--------------------------------------------------------------------------
	IpxNBInterfaceHandler::AddMenuItems
		Implementation of ITFSResultHandler::AddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxNBInterfaceHandler::AddMenuItems(
	ITFSComponent *pComponent,
	MMC_COOKIE cookie,
	LPDATAOBJECT lpDataObject, 
	LPCONTEXTMENUCALLBACK pContextMenuCallback, 
	long *pInsertionAllowed)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IpxNBInterfaceHandler::Command
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxNBInterfaceHandler::Command(ITFSComponent *pComponent,
									   MMC_COOKIE cookie,
									   int nCommandID,
									   LPDATAOBJECT pDataObject)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IpxNBInterfaceHandler::HasPropertyPages
		- 
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxNBInterfaceHandler::HasPropertyPages 
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	return hrTrue;
}

/*!--------------------------------------------------------------------------
	IpxNBInterfaceHandler::CreatePropertyPages
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxNBInterfaceHandler::CreatePropertyPages
(
	ITFSNode *				pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject, 
	LONG_PTR					handle, 
	DWORD					dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT		hr = hrOK;
	IpxNBInterfaceProperties *	pProperties = NULL;
	SPIComponentData spComponentData;
	CString		stTitle;

	CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

	if (m_spInterfaceInfo)
		stTitle.Format(IDS_IPXNB_IF_PAGE_TITLE,
					   m_spInterfaceInfo->GetTitle());
	else
		stTitle.LoadString(IDS_IPXNB_CLIENT_IF_PAGE_TITLE);
	
	pProperties = new IpxNBInterfaceProperties(pNode, spComponentData,
		m_spTFSCompData, stTitle);

	CORg( pProperties->Init(m_spRm, m_spInterfaceInfo) );

	if (lpProvider)
		hr = pProperties->CreateModelessSheet(lpProvider, handle);
	else
		hr = pProperties->DoModelessSheet();

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxNBInterfaceHandler::CreatePropertyPages
		Implementation of ResultHandler::CreatePropertyPages
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxNBInterfaceHandler::CreatePropertyPages
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPPROPERTYSHEETCALLBACK	lpProvider, 
	LPDATAOBJECT			pDataObject, 
	LONG_PTR					handle
)
{
	// Forward this call onto the NodeHandler::CreatePropertyPages
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT	hr = hrOK;
	SPITFSNode	spNode;

	Assert( m_spNodeMgr );

	CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

	// Call the ITFSNodeHandler::CreatePropertyPages
	hr = CreatePropertyPages(spNode, lpProvider, pDataObject, handle, 0);
	
Error:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ripprop.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ripprop.cpp
		Dhcp Relay node property sheet and property pages
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "rtrutil.h"	// smart MPR handle pointers
#include "format.h"		// FormatNumber function
#include "ripprop.h"
#include "ripview.h"
#include "ipxutil.h"		// RipModeToCString
#include "ipxconn.h"
#include "globals.h"		// IPX defaults
#include "rtfltdlg.h"		// RouteFilterDlg

extern "C"
{
#include "routprot.h"
};



/*---------------------------------------------------------------------------
	RipPageGeneral
 ---------------------------------------------------------------------------*/

BEGIN_MESSAGE_MAP(RipPageGeneral, RtrPropertyPage)
    //{{AFX_MSG_MAP(RipPageGeneral)
    ON_BN_CLICKED(IDC_RGG_BTN_LOG_ERROR, OnButtonClicked)
    ON_BN_CLICKED(IDC_RGG_BTN_LOG_INFO, OnButtonClicked)
    ON_BN_CLICKED(IDC_RGG_BTN_LOG_NONE, OnButtonClicked)
    ON_BN_CLICKED(IDC_RGG_BTN_LOG_WARN, OnButtonClicked)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/*!--------------------------------------------------------------------------
	RipPageGeneral::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipPageGeneral::Init(RipProperties *pPropSheet)
{
	m_pRipPropSheet = pPropSheet;
	return hrOK;
}

/*!--------------------------------------------------------------------------
	RipPageGeneral::OnInitDialog
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL RipPageGeneral::OnInitDialog()
{
	HRESULT		hr= hrOK;
	SPIInfoBase	spInfoBase;
    RIP_GLOBAL_INFO* pGlobal;
	DWORD *		pdw;
	int			i;

	RtrPropertyPage::OnInitDialog();

    //
    // Load the existing global-config
    //
	CORg( m_pRipPropSheet->GetInfoBase(&spInfoBase) );

    //
    // Retrieve the IPRIP block from the global-config
    //
	CORg( spInfoBase->GetData(IPX_PROTOCOL_RIP, 0, (PBYTE *) &pGlobal) );

    //
    // Initialize the error-level buttons
    //
    SetErrorLevelButtons(pGlobal->EventLogMask);


	SetDirty(FALSE);

Error:
	if (!FHrSucceeded(hr))
		Cancel();
	return FHrSucceeded(hr) ? TRUE : FALSE;
}

/*!--------------------------------------------------------------------------
	RipPageGeneral::DoDataExchange
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void RipPageGeneral::DoDataExchange(CDataExchange *pDX)
{
	RtrPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(RipPageGeneral)
	//}}AFX_DATA_MAP
	
}

/*!--------------------------------------------------------------------------
	RipPageGeneral::OnApply
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL RipPageGeneral::OnApply()
{
	BOOL		fReturn;
	HRESULT		hr = hrOK;
	RIP_GLOBAL_INFO	*	prgi;
	SPIInfoBase	spInfoBase;

    if ( m_pRipPropSheet->IsCancel() )
	{
		CancelApply();
        return TRUE;
	}

	m_pRipPropSheet->GetInfoBase(&spInfoBase);

    // Retrieve the existing IPRIP block from the global-config
	CORg( spInfoBase->GetData(IPX_PROTOCOL_RIP, 0, (BYTE **) &prgi) );

	// Save the error level
	prgi->EventLogMask = QueryErrorLevelButtons();

	fReturn = RtrPropertyPage::OnApply();
	
Error:
	if (!FHrSucceeded(hr))
		fReturn = FALSE;
	return fReturn;
}

void RipPageGeneral::SetErrorLevelButtons(DWORD dwErrorLevel)
{
	switch (dwErrorLevel)
	{
		case 0:
			CheckDlgButton(IDC_RGG_BTN_LOG_NONE, TRUE);
			break;
		case EVENTLOG_ERROR_TYPE:
			CheckDlgButton(IDC_RGG_BTN_LOG_ERROR, TRUE);
			break;
		case EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE:
			CheckDlgButton(IDC_RGG_BTN_LOG_WARN, TRUE);
			break;
		case EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE:
		default:
			CheckDlgButton(IDC_RGG_BTN_LOG_INFO, TRUE);
			break;
	}
}

DWORD RipPageGeneral::QueryErrorLevelButtons()
{
	if (IsDlgButtonChecked(IDC_RGG_BTN_LOG_INFO))
		return EVENTLOG_INFORMATION_TYPE |
				EVENTLOG_WARNING_TYPE |
				EVENTLOG_ERROR_TYPE;
	else if (IsDlgButtonChecked(IDC_RGG_BTN_LOG_WARN))
		return 	EVENTLOG_WARNING_TYPE |
				EVENTLOG_ERROR_TYPE;
	else if (IsDlgButtonChecked(IDC_RGG_BTN_LOG_ERROR))
		return 	EVENTLOG_ERROR_TYPE;
	else
		return 0;
}

void RipPageGeneral::OnButtonClicked()
{
	SetDirty(TRUE);
	SetModified();
}


/*---------------------------------------------------------------------------
	RipProperties implementation
 ---------------------------------------------------------------------------*/

RipProperties::RipProperties(ITFSNode *pNode,
								 IComponentData *pComponentData,
								 ITFSComponentData *pTFSCompData,
								 LPCTSTR pszSheetName,
								 CWnd *pParent,
								 UINT iPage,
								 BOOL fScopePane)
	: RtrPropertySheet(pNode, pComponentData, pTFSCompData,
					   pszSheetName, pParent, iPage, fScopePane),
		m_pageGeneral(IDD_RIP_GLOBAL_GENERAL_PAGE)
{
		m_spNode.Set(pNode);
}

/*!--------------------------------------------------------------------------
	RipProperties::Init
		Initialize the property sheets.  The general action here will be
		to initialize/add the various pages.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipProperties::Init(IRtrMgrInfo *pRm)
{
	Assert(pRm);
	HRESULT	hr = hrOK;
	IPXConnection *	pIPXConn;

	m_spRm.Set(pRm);

	pIPXConn = GET_RIP_NODEDATA(m_spNode);

	// The pages are embedded members of the class
	// do not delete them.
	m_bAutoDeletePages = FALSE;


	// Do this here, because the init is called in the context
	// of the main thread
	CORg( LoadInfoBase(pIPXConn) );
	
	m_pageGeneral.Init(this);
	AddPageToList((CPropertyPageBase*) &m_pageGeneral);

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	RipProperties::SaveSheetData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL RipProperties::SaveSheetData()
{
	Assert(m_spRm);

	// Save the global info
	// We don't need to pass in the hMachine, hTransport since they
	// got set up in the Load call.
	m_spRm->Save(m_spRm->GetMachineName(),
				 0, 0, m_spInfoBase, NULL, 0);
	return TRUE;
}

/*!--------------------------------------------------------------------------
	RipProperties::LoadInfoBase
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipProperties::LoadInfoBase(IPXConnection *pIPXConn)
{
	Assert(pIPXConn);
	
	HRESULT			hr = hrOK;
	HANDLE			hTransport = NULL;
	SPIInfoBase		spInfoBase;

	// Get the transport handle
	CWRg( ::MprConfigTransportGetHandle(pIPXConn->GetConfigHandle(),
										PID_IPX,
										&hTransport) );

	CORg( m_spRm->GetInfoBase(pIPXConn->GetConfigHandle(),
							  hTransport, &spInfoBase, NULL) );
								  
	Assert(spInfoBase);

	// Retrieve the current block for IP_RIP
	// Adding the default block if none is found.
	if (!FHrOK(spInfoBase->ProtocolExists(IPX_PROTOCOL_RIP)))
	{
		RIP_GLOBAL_INFO	rgi;

		rgi.EventLogMask = EVENTLOG_ERROR_TYPE;
		CORg( spInfoBase->AddBlock(IPX_PROTOCOL_RIP,
								   sizeof(rgi),
								   (PBYTE) &rgi, 1, TRUE) );
	}

	m_spInfoBase = spInfoBase.Transfer();
	
Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	RipProperties::GetInfoBase
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipProperties::GetInfoBase(IInfoBase **ppGlobalInfo)
{	
	*ppGlobalInfo = m_spInfoBase;
	if (*ppGlobalInfo)
		(*ppGlobalInfo)->AddRef();
	return hrOK;
}



/*---------------------------------------------------------------------------
	RipInterfacePageGeneral
 ---------------------------------------------------------------------------*/

BEGIN_MESSAGE_MAP(RipInterfacePageGeneral, RtrPropertyPage)
    //{{AFX_MSG_MAP(RipInterfacePageGeneral)
	ON_BN_CLICKED(IDC_RIG_BTN_ADMIN_STATE, OnButtonClicked)
	ON_BN_CLICKED(IDC_RIG_BTN_ADVERTISE_ROUTES, OnButtonClicked)
	ON_BN_CLICKED(IDC_RIG_BTN_ACCEPT_ROUTE_ADS, OnButtonClicked)
	ON_BN_CLICKED(IDC_RIG_BTN_UPDATE_MODE_STANDARD, OnUpdateButtonClicked)
	ON_BN_CLICKED(IDC_RIG_BTN_UPDATE_MODE_NONE, OnUpdateButtonClicked)
	ON_BN_CLICKED(IDC_RIG_BTN_UPDATE_MODE_AUTOSTATIC, OnUpdateButtonClicked)

	ON_BN_CLICKED(IDC_RIG_BTN_INPUT_FILTERS, OnInputFilter)
	ON_BN_CLICKED(IDC_RIG_BTN_OUTPUT_FILTERS, OnOutputFilter)

	ON_EN_CHANGE(IDC_RIG_EDIT_INTERVAL, OnChangeEdit)
	ON_EN_CHANGE(IDC_RIG_EDIT_MULTIPLIER, OnChangeEdit)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


void RipInterfacePageGeneral::DoDataExchange(CDataExchange *pDX)
{

	RtrPropertyPage::DoDataExchange(pDX);
	
    //{{AFX_DATA_MAP(RipInterfacePageGeneral)
	DDX_Control(pDX, IDC_RIG_SPIN_INTERVAL, m_spinInterval);
	DDX_Control(pDX, IDC_RIG_SPIN_MULTIPLIER, m_spinMultiplier);
    //}}AFX_DATA_MAP
}

/*!--------------------------------------------------------------------------
	RipInterfacePageGeneral::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipInterfacePageGeneral::Init(RipInterfaceProperties *pPropSheet,
									  IInterfaceInfo *pIf)
{
	m_pRipIfPropSheet = pPropSheet;
	m_spIf.Set(pIf);
	return hrOK;
}


/*!--------------------------------------------------------------------------
	RipInterfacePageGeneral::OnInitDialog
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL RipInterfacePageGeneral::OnInitDialog()
{
	HRESULT		hr= hrOK;
	SPIInfoBase	spInfoBase;
    RIP_IF_CONFIG* pIfConfig;
	int			i, count, item;
	CString		sItem;

	RtrPropertyPage::OnInitDialog();

    //
    // Initialize controls
	//

	m_spinInterval.SetRange(0, 32767);
	m_spinInterval.SetBuddy(GetDlgItem(IDC_RIG_EDIT_INTERVAL));

	m_spinMultiplier.SetRange(0, 32767);
	m_spinMultiplier.SetBuddy(GetDlgItem(IDC_RIG_EDIT_MULTIPLIER));


    //
    // Load the existing global-config
    //
	CORg( m_pRipIfPropSheet->GetInfoBase(&spInfoBase) );

    //
    // Retrieve the IPRIP block from the global-config
    //
	CORg( spInfoBase->GetData(IPX_PROTOCOL_RIP, 0, (PBYTE *) &pIfConfig) );

	
    //
    // Set the spin-controls
    //
	m_spinInterval.SetPos(pIfConfig->RipIfInfo.PeriodicUpdateInterval);
	m_spinMultiplier.SetPos(pIfConfig->RipIfInfo.AgeIntervalMultiplier);

	
	CheckDlgButton(IDC_RIG_BTN_ADMIN_STATE,
				   pIfConfig->RipIfInfo.AdminState == ADMIN_STATE_ENABLED);

	CheckDlgButton(IDC_RIG_BTN_ADVERTISE_ROUTES,
				   pIfConfig->RipIfInfo.Supply == ADMIN_STATE_ENABLED);

	CheckDlgButton(IDC_RIG_BTN_ACCEPT_ROUTE_ADS,
				   pIfConfig->RipIfInfo.Listen == ADMIN_STATE_ENABLED);

	switch (pIfConfig->RipIfInfo.UpdateMode)
	{
		case IPX_STANDARD_UPDATE:
			CheckDlgButton(IDC_RIG_BTN_UPDATE_MODE_STANDARD, TRUE);
			break;
		case IPX_NO_UPDATE:
			CheckDlgButton(IDC_RIG_BTN_UPDATE_MODE_NONE, TRUE);
			break;
		case IPX_AUTO_STATIC_UPDATE:
			CheckDlgButton(IDC_RIG_BTN_UPDATE_MODE_AUTOSTATIC, TRUE);
			break;
		default:
			break;
	}

    OnUpdateButtonClicked();

    
	// If this is a new interface, we need to force the change
	// through if the user hits ok.
	SetDirty(m_pRipIfPropSheet->m_bNewInterface ? TRUE : FALSE);

Error:
	if (!FHrSucceeded(hr))
		Cancel();
	return FHrSucceeded(hr) ? TRUE : FALSE;
}

void RipInterfacePageGeneral::OnButtonClicked()
{
	SetDirty(TRUE);
	SetModified();
}

void RipInterfacePageGeneral::OnUpdateButtonClicked()
{
	BOOL	fStandard = IsDlgButtonChecked(IDC_RIG_BTN_UPDATE_MODE_STANDARD);

    if (fStandard &&
        (m_spinInterval.GetPos() == 0) &&
        (m_spinMultiplier.GetPos() == 0))
    {
        m_spinInterval.SetPos(IPX_UPDATE_INTERVAL_DEFVAL);
        m_spinMultiplier.SetPos(3);
    }
    
    MultiEnableWindow(GetSafeHwnd(),
                      fStandard,
                      IDC_RIG_TEXT_INTERVAL,
                      IDC_RIG_SPIN_INTERVAL,
                      IDC_RIG_EDIT_INTERVAL,
                      IDC_RIG_TEXT_MULTIPLIER,
                      IDC_RIG_SPIN_MULTIPLIER,
                      IDC_RIG_EDIT_MULTIPLIER,
                      0);

	SetDirty(TRUE);
	SetModified();
}

void RipInterfacePageGeneral::OnChangeEdit()
{
	SetDirty(TRUE);
	SetModified();
}

void RipInterfacePageGeneral::ShowFilter(BOOL fOutputFilter)
{	
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	SPIInfoBase	spInfoBase;
	RIP_IF_CONFIG *	pic;
	HRESULT		hr = hrOK;

	m_pRipIfPropSheet->GetInfoBase(&spInfoBase);
    CRouteFltDlg    dlgFlt (fOutputFilter /* bOutputDlg */, spInfoBase, this);

	// Need to grab the Rip IF config struct out of the
	// infobase

	if (m_spIf)
		dlgFlt.m_sIfName = m_spIf->GetTitle();
	else
		dlgFlt.m_sIfName.LoadString(IDS_IPX_DIAL_IN_CLIENTS);
    try 
	{
		if (dlgFlt.DoModal () == IDOK)
		{
			SetDirty(TRUE);
			SetModified();
		}
    }
    catch (CException *ex) {
        ex->ReportError ();
        ex->Delete ();
    }

	return;
}

void RipInterfacePageGeneral::OnInputFilter()
{
	ShowFilter(FALSE);
}

void RipInterfacePageGeneral::OnOutputFilter()
{
	ShowFilter(TRUE);
}


/*!--------------------------------------------------------------------------
	RipInterfacePageGeneral::OnApply
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL RipInterfacePageGeneral::OnApply()
{
	BOOL		fReturn;
	HRESULT		hr = hrOK;
    INT i, item;
	RIP_IF_CONFIG *	pic;
	SPIInfoBase	spInfoBase;

    if ( m_pRipIfPropSheet->IsCancel() )
	{
		CancelApply();
        return TRUE;
	}

	m_pRipIfPropSheet->GetInfoBase(&spInfoBase);

	CORg( spInfoBase->GetData(IPX_PROTOCOL_RIP, 0, (PBYTE *) &pic) );

	// Save the admin state
	pic->RipIfInfo.AdminState = IsDlgButtonChecked(IDC_RIG_BTN_ADMIN_STATE) ?
				ADMIN_STATE_ENABLED : ADMIN_STATE_DISABLED;

	// Save the advertise routes
	pic->RipIfInfo.Supply = IsDlgButtonChecked(IDC_RIG_BTN_ADVERTISE_ROUTES) ?
				ADMIN_STATE_ENABLED : ADMIN_STATE_DISABLED;

	// Save the accept route ads
	pic->RipIfInfo.Listen = IsDlgButtonChecked(IDC_RIG_BTN_ACCEPT_ROUTE_ADS) ?
				ADMIN_STATE_ENABLED : ADMIN_STATE_DISABLED;

	// Save the update mode
	if (IsDlgButtonChecked(IDC_RIG_BTN_UPDATE_MODE_STANDARD))
	{
		pic->RipIfInfo.UpdateMode = IPX_STANDARD_UPDATE;
	}
	else if (IsDlgButtonChecked(IDC_RIG_BTN_UPDATE_MODE_NONE))
	{
		pic->RipIfInfo.UpdateMode = IPX_NO_UPDATE;
	}
	else
		pic->RipIfInfo.UpdateMode = IPX_AUTO_STATIC_UPDATE;

	// Save the interval and multiplier
	pic->RipIfInfo.PeriodicUpdateInterval = m_spinInterval.GetPos();
	pic->RipIfInfo.AgeIntervalMultiplier = m_spinMultiplier.GetPos();

	fReturn = RtrPropertyPage::OnApply();
	
Error:
	if (!FHrSucceeded(hr))
		fReturn = FALSE;
	return fReturn;
}



/*---------------------------------------------------------------------------
	RipInterfaceProperties implementation
 ---------------------------------------------------------------------------*/

RipInterfaceProperties::RipInterfaceProperties(ITFSNode *pNode,
								 IComponentData *pComponentData,
								 ITFSComponentData *pTFSCompData,
								 LPCTSTR pszSheetName,
								 CWnd *pParent,
								 UINT iPage,
								 BOOL fScopePane)
	: RtrPropertySheet(pNode, pComponentData, pTFSCompData,
					   pszSheetName, pParent, iPage, fScopePane),
		m_pageGeneral(IDD_RIP_INTERFACE_GENERAL_PAGE),
		m_bNewInterface(FALSE)
{
		m_spNode.Set(pNode);
}

/*!--------------------------------------------------------------------------
	RipInterfaceProperties::Init
		Initialize the property sheets.  The general action here will be
		to initialize/add the various pages.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipInterfaceProperties::Init(IInterfaceInfo *pIf,
										   IRtrMgrInfo *pRm)
{
	Assert(pRm);
	
	HRESULT	hr = hrOK;
	IPXConnection *	pIPXConn;
	SPITFSNode		spParent;

	m_spRm.Set(pRm);
	m_spIf.Set(pIf);
	if (pIf)
		CORg( pIf->FindRtrMgrInterface(PID_IPX, &m_spRmIf) );
	

	m_spNode->GetParent(&spParent);
	Assert(spParent);

	// The pages are embedded members of the class
	// do not delete them.
	m_bAutoDeletePages = FALSE;


	// Do this here, because the init is called in the context
	// of the main thread
	pIPXConn = GET_RIP_NODEDATA(spParent);
	CORg( LoadInfoBase(pIPXConn) );
	
	m_pageGeneral.Init(this, m_spIf);
	AddPageToList((CPropertyPageBase*) &m_pageGeneral);

Error:
	return hr;
}



/*!--------------------------------------------------------------------------
	RipInterfaceProperties::SaveSheetData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL RipInterfaceProperties::SaveSheetData()
{
    SPITFSNodeHandler	spHandler;
    SPITFSNode			spParent;
		
	Assert(m_spRm);
	BaseIPXResultNodeData *	pNodeData;
	RIP_IF_CONFIG *		pic;

	if (m_spInfoBase)
	{
		if (m_bClientInfoBase)
		{
			Assert(m_spRm);
			m_spRm->Save(m_spRm->GetMachineName(), 0, 0, NULL,
						 m_spInfoBase, 0);
		}
		else
		{
			Assert(m_spRmIf);
			m_spRmIf->Save(m_spIf->GetMachineName(),
						   NULL, NULL, NULL, m_spInfoBase, 0);
		}

	}
	if (m_bNewInterface)
	{
		m_spNode->SetVisibilityState(TFS_VIS_SHOW);
		m_spNode->Show();
    }
		
    // Force the node to do a resync
    m_spNode->GetParent(&spParent);
    spParent->GetHandler(&spHandler);
    spHandler->OnCommand(spParent, IDS_MENU_SYNC, CCT_RESULT,
                         NULL, 0);
    
    // Windows NT Bugs : 133891, we have added this to the UI
    // we no longer consider this a new interface
    m_bNewInterface = FALSE;
	
	return TRUE;
}

/*!--------------------------------------------------------------------------
	RipInterfaceProperties::CancelSheetData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void RipInterfaceProperties::CancelSheetData()
{
	if (m_bNewInterface && m_bClientInfoBase)
	{
		m_spNode->SetVisibilityState(TFS_VIS_DELETE);
		m_spRmIf->DeleteRtrMgrProtocolInterface(IPX_PROTOCOL_RIP, TRUE);
	}
}

/*!--------------------------------------------------------------------------
	RipInterfaceProperties::LoadInfoBase
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipInterfaceProperties::LoadInfoBase(IPXConnection *pIPXConn)
{
	Assert(pIPXConn);
	
	HRESULT			hr = hrOK;
	HANDLE			hTransport = NULL;
	LPCOLESTR		pszInterfaceId = NULL;
	SPIInfoBase		spInfoBase;
	BYTE *			pDefault;


	// If configuring the client-interface, load the client-interface info,
	// otherwise, retrieve the interface being configured and load
	// its info.

	// The client interface doesn't have an ID
	if (m_spIf)
		pszInterfaceId = m_spIf->GetId();


	if (StrLenW(pszInterfaceId) == 0)
	{
		Assert(m_spRm);
		
		// Get the transport handle
		CWRg( ::MprConfigTransportGetHandle(pIPXConn->GetConfigHandle(),
											PID_IPX,
											&hTransport) );
		
		// Load the client interface info
		CORg( m_spRm->GetInfoBase(pIPXConn->GetConfigHandle(),
								  hTransport,
								  NULL,
								  &spInfoBase) );
		m_bClientInfoBase = TRUE;
	}
	else
	{
		Assert(m_spRmIf);
		
		//
		// The parameters are all NULL so that we can use the
		// default RPC handles.
		//
		m_spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase);
		m_bClientInfoBase = FALSE;
	}

	if (!spInfoBase)
	{
		// No info was found for the inteface
		// allocate a new InfoBase instead
		CORg( CreateInfoBase(&spInfoBase) );		
	}

    //
    // Check that there is a block for interface-status in the info,
    // and insert the default block if none is found.
    //
	if (spInfoBase->ProtocolExists(IPX_PROTOCOL_RIP) == hrFalse)
	{
		RIP_IF_CONFIG	ric;

		// Setup the defaults for an interface

		if (m_spIf &&
			(m_spIf->GetInterfaceType() == ROUTER_IF_TYPE_DEDICATED))
			pDefault = g_pIpxRipLanInterfaceDefault;
		else
			pDefault = g_pIpxRipInterfaceDefault;
			
		CORg( spInfoBase->AddBlock(IPX_PROTOCOL_RIP,
								   sizeof(RIP_IF_CONFIG),
								   pDefault,
								   1 /* count */,
								   TRUE /* bRemoveFirst */) );
		m_bNewInterface = TRUE;
	}

	m_spInfoBase.Set(spInfoBase);
	
Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	RipInterfaceProperties::GetInfoBase
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipInterfaceProperties::GetInfoBase(IInfoBase **ppGlobalInfo)
{	
	*ppGlobalInfo = m_spInfoBase;
	if (*ppGlobalInfo)
		(*ppGlobalInfo)->AddRef();
	return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ripstrm.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	ripstrm.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ripstrm.h"
#include "xstream.h"

/*!--------------------------------------------------------------------------
	RipConfigStream::RipConfigStream
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
RipConfigStream::RipConfigStream()
{
	m_nVersionAdmin = 0x00020000;
	m_nVersion = 0x00020000;

}

/*!--------------------------------------------------------------------------
	RipConfigStream::InitNew
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipConfigStream::InitNew()
{
	// Setup the appropriate defaults
//	m_nVersionAdmin = 0x00020000;
//	m_nVersion = 0x00020000;
//	m_stName.Empty();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	RipConfigStream::SaveTo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipConfigStream::SaveTo(IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_WRITE, NULL);
}

/*!--------------------------------------------------------------------------
	RipConfigStream::SaveAs
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipConfigStream::SaveAs(UINT nVersion, IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_WRITE, NULL);
}

/*!--------------------------------------------------------------------------
	RipConfigStream::LoadFrom
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipConfigStream::LoadFrom(IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_READ, NULL);
}

/*!--------------------------------------------------------------------------
	RipConfigStream::GetSize
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipConfigStream::GetSize(ULONG *pcbSize)
{
	return XferVersion0(NULL, XferStream::MODE_SIZE, NULL);
}

/*!--------------------------------------------------------------------------
	RipConfigStream::GetVersionInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipConfigStream::GetVersionInfo(DWORD *pdwVersion, DWORD *pdwAdminVersion)
{
	if (pdwVersion)
		*pdwVersion = m_nVersion;
	if (pdwAdminVersion)
		*pdwAdminVersion = m_nVersionAdmin;
	return hrOK;
}

/*!--------------------------------------------------------------------------
	RipConfigStream::XferVersion0
		-
	Author: KennT
 ---------------------------------------------------------------------------*/


struct _ViewInfoEntry
{
	ULONG	m_ulId;
	ULONG	m_idSort;
	ULONG	m_idAscending;
	ULONG	m_idColumns;
	ULONG	m_idPos;
};

static const _ViewInfoEntry	s_rgRIPAdminViewInfo[] =
{
	{ RIPSTRM_STATS_RIPPARAMS,
		RIPSTRM_TAG_STATS_RIPPARAMS_SORT,
		RIPSTRM_TAG_STATS_RIPPARAMS_ASCENDING,
		RIPSTRM_TAG_STATS_RIPPARAMS_COLUMNS,
		RIPSTRM_TAG_STATS_RIPPARAMS_POSITION },
};		

HRESULT RipConfigStream::XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize)
{
	XferStream	xstm(pstm, mode);
	HRESULT		hr = hrOK;
	int			i;

	CORg( xstm.XferDWORD( RIPSTRM_TAG_VERSION, &m_nVersion ) );
	CORg( xstm.XferDWORD( RIPSTRM_TAG_VERSIONADMIN, &m_nVersionAdmin ) );
	
	for ( i=0; i<DimensionOf(s_rgRIPAdminViewInfo); i++)
	{
		CORg( m_rgViewInfo[s_rgRIPAdminViewInfo[i].m_ulId].Xfer(&xstm,
			s_rgRIPAdminViewInfo[i].m_idSort,
			s_rgRIPAdminViewInfo[i].m_idAscending,
			s_rgRIPAdminViewInfo[i].m_idColumns) );
		CORg( xstm.XferRect( s_rgRIPAdminViewInfo[i].m_idPos,
							 &m_prgrc[s_rgRIPAdminViewInfo[i].m_ulId]) );
	}
	if (pcbSize)
		*pcbSize = xstm.GetSize();

Error:
	return hr;
}



/*---------------------------------------------------------------------------
	RipComponentConfigStream implementation
 ---------------------------------------------------------------------------*/

enum RIPCOMPSTRM_TAG
{
	RIPCOMPSTRM_TAG_VERSION =		XFER_TAG(1, XFER_DWORD),
	RIPCOMPSTRM_TAG_VERSIONADMIN =	XFER_TAG(2, XFER_DWORD),
	RIPCOMPSTRM_TAG_SUMMARY_COLUMNS = XFER_TAG(3, XFER_COLUMNDATA_ARRAY),
	RIPCOMPSTRM_TAG_SUMMARY_SORT_COLUMN = XFER_TAG(4, XFER_DWORD),
	RIPCOMPSTRM_TAG_SUMMARY_SORT_ASCENDING = XFER_TAG(5, XFER_DWORD),
};



HRESULT RipComponentConfigStream::XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize)
{
	XferStream	xstm(pstm, mode);
	HRESULT		hr = hrOK;

	CORg( xstm.XferDWORD( RIPCOMPSTRM_TAG_VERSION, &m_nVersion ) );
	CORg( xstm.XferDWORD( RIPCOMPSTRM_TAG_VERSIONADMIN, &m_nVersionAdmin ) );

	CORg( m_rgViewInfo[RIP_COLUMNS].Xfer(&xstm,
										RIPCOMPSTRM_TAG_SUMMARY_SORT_COLUMN,
										RIPCOMPSTRM_TAG_SUMMARY_SORT_ASCENDING,
										RIPCOMPSTRM_TAG_SUMMARY_COLUMNS) );
	
	if (pcbSize)
		*pcbSize = xstm.GetSize();

Error:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ripstats.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    ripstats.h
//
// History:
//	07/22/97	Kenn M. Takara			Created.
//
//	IP Statistics
//
//============================================================================


#ifndef _RIPSTATS_H_
#define _RIPSTATS_H_

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _STATSDLG_H
#include "statsdlg.h"
#endif

#ifndef _IPXSTATS_H
#include "ipxstats.h"
#endif

enum
{
	MVR_RIPPARAMS_OPER_STATE = 0,
	MVR_RIPPARAMS_SENT_PKTS,
	MVR_RIPPARAMS_RCVD_PKTS,
	MVR_RIPPARAMS_COUNT,
};

class RIPParamsStatistics : public IPXStatisticsDialog
{
public:
	RIPParamsStatistics();

	// Override the OnInitDialog so that we can set the caption
	virtual BOOL OnInitDialog();

	// Override the RefreshData to provide sample data
	virtual HRESULT RefreshData(BOOL fGrabNewData);

	// Override the Sort to provide the ability to do sorting
	// actually we don't do any sorting (this is a vertical format)
	virtual void Sort(UINT nColumnId);

protected:
};



#endif _RIPSTATS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ripstrm.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	ripstrm.h
		RIP node configuration object.

		Use this to get/set configuration data.  This class will take
		care of versioning of config formats as well as serializing
		of the data.
		
    FILE HISTORY:
        
*/

#ifndef _RIPSTRM_H
#define _RIPSTRM_H

#ifndef _XSTREAM_H
#include "xstream.h"
#endif

#ifndef _IPXADMIN_H
#include "ipxadmin.h"
#endif

#ifndef _COLUMN_H
#include "column.h"
#endif

#ifndef _CONFIG_H
// #include "config.h"
#endif

enum
{
	RIP_COLUMNS = 0,
	RIP_COLUMNS_MAX_COUNT = 1,
};

enum
{
	RIPSTRM_STATS_RIPPARAMS = 0,
	RIPSTRM_STATS_COUNT,
};

enum RIPSTRM_TAG
{
	RIPSTRM_TAG_VERSION =		XFER_TAG(1, XFER_DWORD),
	RIPSTRM_TAG_VERSIONADMIN =	XFER_TAG(2, XFER_DWORD),
	
	RIPSTRM_TAG_STATS_RIPPARAMS_COLUMNS =	XFER_TAG(3, XFER_COLUMNDATA_ARRAY),
	RIPSTRM_TAG_STATS_RIPPARAMS_SORT =	XFER_TAG(4, XFER_DWORD),
	RIPSTRM_TAG_STATS_RIPPARAMS_ASCENDING =	XFER_TAG(5, XFER_DWORD),
	RIPSTRM_TAG_STATS_RIPPARAMS_POSITION =	XFER_TAG(6, XFER_RECT),

	
};

/*---------------------------------------------------------------------------
	Class:	RipConfigStream

	This holds the configuration information for the IP administration
	nodes.  This does NOT hold the configuration information for the columns.
	That is stored in the Component Configuration streams.
 ---------------------------------------------------------------------------*/
class RipConfigStream : public ConfigStream
{
public:
	RipConfigStream();

	virtual HRESULT	InitNew();				// set defaults
	virtual HRESULT	SaveTo(IStream *pstm);
	virtual HRESULT SaveAs(UINT nVersion, IStream *pstm);
	
	virtual HRESULT LoadFrom(IStream *pstm);

	virtual HRESULT GetSize(ULONG *pcbSize);

	// --------------------------------------------------------
	// Accessors
	// --------------------------------------------------------
	
	virtual HRESULT	GetVersionInfo(DWORD *pnVersion, DWORD *pnAdminVersion);

private:
	HRESULT XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize);
};



class RipComponentConfigStream : public ConfigStream
{
public:
	virtual HRESULT XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize);
protected:
};


#endif _RIPSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ripview.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ripview.cpp
		IPX RIP node implementation.
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "util.h"
#include "ripview.h"
#include "reg.h"
#include "rtrutil.h"	// smart MPR handle pointers
#include "ripstrm.h"	// IPAdminConfigStream
#include "strmap.h"		// XXXtoCString functions
#include "service.h"	// TFS service APIs
#include "format.h"		// FormatNumber function
#include "coldlg.h"		// columndlg
#include "column.h"		// ComponentConfigStream
#include "rtrui.h"
#include "ripprop.h"	// RIP property pages
#include "routprot.h"	// IP_LOCAL
#include "ipxstrm.h"
#include "ipxutil.h"	// String conversions
#include "globals.h"	// IPX defaults


/*---------------------------------------------------------------------------
	Keep this in sync with the column ids in ripview.h
 ---------------------------------------------------------------------------*/
extern const ContainerColumnInfo	s_rgRipViewColumnInfo[];

const ContainerColumnInfo	s_rgRipViewColumnInfo[] = 
{
	{ IDS_RIP_COL_INTERFACE,		CON_SORT_BY_STRING,	TRUE, COL_IF_NAME },
	{ IDS_RIP_COL_TYPE,				CON_SORT_BY_STRING,	TRUE, COL_IF_DEVICE },
	{ IDS_RIP_COL_ACCEPT_ROUTES,	CON_SORT_BY_STRING,	FALSE, COL_STRING },
	{ IDS_RIP_COL_SUPPLY_ROUTES,	CON_SORT_BY_STRING,	FALSE, COL_STRING },
	{ IDS_RIP_COL_UPDATE_MODE,		CON_SORT_BY_STRING,	TRUE, COL_STRING },
	{ IDS_RIP_COL_UPDATE_PERIOD,	CON_SORT_BY_DWORD,	FALSE, COL_DURATION },
	{ IDS_RIP_COL_AGE_MULTIPLIER,	CON_SORT_BY_DWORD,	FALSE, COL_SMALL_NUM },
	{ IDS_RIP_COL_ADMIN_STATE,		CON_SORT_BY_STRING,	TRUE, COL_STATUS },
	{ IDS_RIP_COL_OPER_STATE,		CON_SORT_BY_STRING,	TRUE, COL_STATUS },
	{ IDS_RIP_COL_PACKETS_SENT,		CON_SORT_BY_DWORD,	TRUE, COL_LARGE_NUM },
	{ IDS_RIP_COL_PACKETS_RECEIVED,	CON_SORT_BY_DWORD,	TRUE, COL_LARGE_NUM },
};


/*---------------------------------------------------------------------------
	RipNodeHandler implementation
 ---------------------------------------------------------------------------*/

RipNodeHandler::RipNodeHandler(ITFSComponentData *pCompData)
	: BaseContainerHandler(pCompData, RIP_COLUMNS,
						   s_rgRipViewColumnInfo),
	m_ulConnId(0),
	m_ulRmConnId(0),
	m_ulRefreshConnId(0),
	m_ulStatsConnId(0)
{
	// Setup the verb states
	m_rgButtonState[MMC_VERB_PROPERTIES_INDEX] = ENABLED;
	m_bState[MMC_VERB_PROPERTIES_INDEX] = TRUE;

	m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
	m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;

}


STDMETHODIMP RipNodeHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IRtrAdviseSink)
		*ppv = &m_IRtrAdviseSink;
	else
		return BaseContainerHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;	
}



/*!--------------------------------------------------------------------------
	RipNodeHandler::DestroyHandler
		Implementation of ITFSNodeHandler::DestroyHandler
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RipNodeHandler::DestroyHandler(ITFSNode *pNode)
{
	IPXConnection *	pIPXConn;

	pIPXConn = GET_RIP_NODEDATA(pNode);
	pIPXConn->Release();

	if (m_ulRefreshConnId)
	{
		SPIRouterRefresh	spRefresh;
		if (m_spRouterInfo)
			m_spRouterInfo->GetRefreshObject(&spRefresh);
		if (spRefresh)
			spRefresh->UnadviseRefresh(m_ulRefreshConnId);
	}
	m_ulRefreshConnId = 0;
	
	if (m_ulStatsConnId)
	{
		SPIRouterRefresh	spRefresh;
		if (m_spRouterInfo)
			m_spRouterInfo->GetRefreshObject(&spRefresh);
		if (spRefresh)
			spRefresh->UnadviseRefresh(m_ulStatsConnId);		
	}
	m_ulStatsConnId = 0;

	
	if (m_ulConnId)
		m_spRmProt->RtrUnadvise(m_ulConnId);
	m_ulConnId = 0;
	m_spRmProt.Release();
	
	if (m_ulRmConnId)
		m_spRm->RtrUnadvise(m_ulRmConnId);
	m_ulRmConnId = 0;
	m_spRm.Release();

	WaitForStatisticsWindow(&m_RIPParamsStats);

	m_spRouterInfo.Release();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	RipNodeHandler::HasPropertyPages
		Implementation of ITFSNodeHandler::HasPropertyPages
	NOTE: the root node handler has to over-ride this function to 
	handle the snapin manager property page (wizard) case!!!
	
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
RipNodeHandler::HasPropertyPages
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	return hrOK;
}


/*!--------------------------------------------------------------------------
	RipNodeHandler::CreatePropertyPages
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP
RipNodeHandler::CreatePropertyPages
(
	ITFSNode *				pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject, 
	LONG_PTR					handle, 
	DWORD					dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT		hr = hrOK;
	RipProperties *	pProperties = NULL;
	SPIComponentData spComponentData;
	CString		stTitle;

	CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

	pProperties = new RipProperties(pNode, spComponentData,
		m_spTFSCompData, stTitle);

	CORg( pProperties->Init(m_spRm) );

	if (lpProvider)
		hr = pProperties->CreateModelessSheet(lpProvider, handle);
	else
		hr = pProperties->DoModelessSheet();

Error:
	return hr;
}


/*---------------------------------------------------------------------------
	Menu data structure for our menus
 ---------------------------------------------------------------------------*/

static const SRouterNodeMenu	s_rgIfNodeMenu[] =
{
	{ IDS_MENU_RIP_SHOW_PARAMS, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },
};



/*!--------------------------------------------------------------------------
	RipNodeHandler::OnAddMenuItems
		Implementation of ITFSNodeHandler::OnAddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RipNodeHandler::OnAddMenuItems(
	ITFSNode *pNode,
	LPCONTEXTMENUCALLBACK pContextMenuCallback, 
	LPDATAOBJECT lpDataObject, 
	DATA_OBJECT_TYPES type, 
	DWORD dwType,
	long *pInsertionAllowed)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = S_OK;
    RipNodeHandler::SMenuData   menuData;
	
	COM_PROTECT_TRY
	{
        menuData.m_spNode.Set(pNode);
        
		hr = AddArrayOfMenuItems(pNode, s_rgIfNodeMenu,
								 DimensionOf(s_rgIfNodeMenu),
								 pContextMenuCallback,
								 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
	}
	COM_PROTECT_CATCH;
		
	return hr; 
}

/*!--------------------------------------------------------------------------
	RipNodeHandler::OnCommand
		Implementation of ITFSNodeHandler::OnCommand
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RipNodeHandler::OnCommand(ITFSNode *pNode, long nCommandId, 
										   DATA_OBJECT_TYPES	type, 
										   LPDATAOBJECT pDataObject, 
										   DWORD	dwType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;

	COM_PROTECT_TRY
	{
		switch (nCommandId)
		{
			case IDS_MENU_RIP_SHOW_PARAMS:
				CreateNewStatisticsWindow(&m_RIPParamsStats,
										  ::FindMMCMainWindow(),
										  IDD_STATS_NARROW);
				break;
			case IDS_MENU_SYNC:
				SynchronizeNodeData(pNode);
				break;
		}
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	RipNodeHandler::OnExpand
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipNodeHandler::OnExpand(ITFSNode *pNode,
								 LPDATAOBJECT pDataObject,
								 DWORD dwType,
								 LPARAM arg,
								 LPARAM lParam)
{
	HRESULT	hr = hrOK;
	SPIEnumInterfaceInfo	spEnumIf;
	SPIInterfaceInfo		spIf;
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPIInfoBase				spInfoBase;
	
	if (m_bExpanded)
		return hrOK;

	COM_PROTECT_TRY
	{
		CORg( m_spRouterInfo->EnumInterface(&spEnumIf) );

		while (spEnumIf->Next(1, &spIf, NULL) == hrOK)
		{
			if (spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) == hrOK)
			{
				if (spRmIf->FindRtrMgrProtocolInterface(IPX_PROTOCOL_RIP, NULL) == hrOK)
				{
					// Now we create an interface node for this interface
					AddInterfaceNode(pNode, spIf, FALSE);
				}

			}
			spRmIf.Release();
			spIf.Release();
		}

		//$CLIENT: Add the client interface (setup default data)
		// the only thing that we can do in synchronize is to
		// get the Administrative status
		AddInterfaceNode(pNode, NULL, TRUE);

		m_bExpanded = TRUE;

		// Now that we have all of the nodes, update the data for
		// all of the nodes
		SynchronizeNodeData(pNode);

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	m_bExpanded = TRUE;

	return hr;
}

/*!--------------------------------------------------------------------------
	RipNodeHandler::GetString
		Implementation of ITFSNodeHandler::GetString
		We don't need to do anything, since our root node is an extension
		only and thus can't do anything to the node text.
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) RipNodeHandler::GetString(ITFSNode *pNode, int nCol)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		if (m_stTitle.IsEmpty())
			m_stTitle.LoadString(IDS_IPX_RIP_TITLE);
	}
	COM_PROTECT_CATCH;

	return m_stTitle;
}

/*!--------------------------------------------------------------------------
	RipNodeHandler::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RipNodeHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{

		Assert(m_spRmProt);
		
		CORg( CreateDataObjectFromRtrMgrProtocolInfo(m_spRmProt,
			type, cookie, m_spTFSCompData,
			ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}


/*!--------------------------------------------------------------------------
	RipNodeHandler::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipNodeHandler::Init(IRouterInfo *pRouter, RipConfigStream *pConfigStream)
{
	m_spRouterInfo.Set(pRouter);
	
	m_spRm.Release();
	pRouter->FindRtrMgr(PID_IPX, &m_spRm);

	m_spRmProt.Release();
	m_spRm->FindRtrMgrProtocol(IPX_PROTOCOL_RIP, &m_spRmProt);
	
	m_pConfigStream = pConfigStream;
	
	// Also need to register for change notifications from IPX_PROTOCOL_RIP
	Assert(m_ulConnId == 0);
	m_spRmProt->RtrAdvise(&m_IRtrAdviseSink, &m_ulConnId, 0);

	// Need to register for change notifications on the Router manager
	// This way we can add the necessary protocols when an interface
	// gets added.
	Assert(m_ulRmConnId == 0);
	m_spRm->RtrAdvise(&m_IRtrAdviseSink, &m_ulRmConnId, 0);

	m_RIPParamsStats.SetConfigInfo(pConfigStream, RIPSTRM_STATS_RIPPARAMS);

	return hrOK;
}


/*!--------------------------------------------------------------------------
	RipNodeHandler::ConstructNode
		Initializes the root node (sets it up).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipNodeHandler::ConstructNode(ITFSNode *pNode)
{
	HRESULT			hr = hrOK;
	IPXConnection *	pIPXConn = NULL;
	
	if (pNode == NULL)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Need to initialize the data for the root node
		pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_IPX_NODE_GENERAL);
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_IPX_NODE_GENERAL);
		pNode->SetData(TFS_DATA_SCOPEID, 0);

        // This is a leaf node in the scope pane
        pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

		m_cookie = reinterpret_cast<DWORD_PTR>(pNode);
		pNode->SetData(TFS_DATA_COOKIE, m_cookie);

		pNode->SetNodeType(&GUID_IPXRipNodeType);

		
		pIPXConn = new IPXConnection;
		pIPXConn->SetMachineName(m_spRouterInfo->GetMachineName());

		SET_RIP_NODEDATA(pNode, pIPXConn);

		m_RIPParamsStats.SetConnectionData(pIPXConn);
	}
	COM_PROTECT_CATCH;

	if (!FHrSucceeded(hr))
	{
		SET_RIP_NODEDATA(pNode, NULL);
		if (pIPXConn)
			pIPXConn->Release();
	}

	return hr;
}


/*!--------------------------------------------------------------------------
	RipNodeHandler::AddInterfaceNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT	RipNodeHandler::AddInterfaceNode(ITFSNode *pParent,
										 IInterfaceInfo *pIf,
										 BOOL fClient)
{
	Assert(pParent);
	
	RipInterfaceHandler *	pHandler;
	SPITFSResultHandler		spHandler;
	SPITFSNode				spNode;
	HRESULT					hr = hrOK;
	BaseIPXResultNodeData *		pData;
	IPXConnection *			pIPXConn;
	SPIInfoBase				spInfoBase;
	PRIP_IF_CONFIG			pric = NULL;
	SPIRtrMgrInterfaceInfo	spRmIf;

	// Create the handler for this node 
	pHandler = new RipInterfaceHandler(m_spTFSCompData);
	spHandler = pHandler;
	CORg( pHandler->Init(pIf, m_spRouterInfo, pParent) );

	pIPXConn = GET_RIP_NODEDATA(pParent);

	// Create a result item node (or a leaf node)
	CORg( CreateLeafTFSNode(&spNode,
							NULL,
							static_cast<ITFSNodeHandler *>(pHandler),
							static_cast<ITFSResultHandler *>(pHandler),
							m_spNodeMgr) );
	CORg( pHandler->ConstructNode(spNode, pIf, pIPXConn) );

	pData = GET_BASEIPXRESULT_NODEDATA(spNode);
	Assert(pData);
	ASSERT_BASEIPXRESULT_NODEDATA(pData);

	pData->m_fClient = fClient;

	// If we don't have an interface, then this is a client node
	if (pIf)
	{
		pIf->FindRtrMgrInterface(PID_IPX, &spRmIf);
		
		if (spRmIf)
			spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase);

		if (spInfoBase)
			spInfoBase->GetData(IPX_PROTOCOL_RIP, 0, (LPBYTE *) &pric);

		Trace1("Adding RIP node : %s\n", pIf->GetTitle());
	}
	else
	{
		// This is a client, make it visible
		pric = (PRIP_IF_CONFIG) ULongToPtr(0xFFFFFFFF);
		
		Trace0("Adding client interface\n");
	}

	// if pric == NULL, then we are adding this protocol to the
	// interface and we need to hide the node.
	if (pric)
	{
		CORg( spNode->SetVisibilityState(TFS_VIS_SHOW) );
		CORg( spNode->Show() );
	}
	else
		CORg( spNode->SetVisibilityState(TFS_VIS_HIDE) );
	CORg( pParent->AddChild(spNode) );

Error:
	return hr;
}

/*---------------------------------------------------------------------------
	This is the set of menus that will appear when a right-click is
	done on the blank area of the result pane.
 ---------------------------------------------------------------------------*/
static const SRouterNodeMenu	s_rgRipResultNodeMenu[] =
{
	{ IDS_MENU_RIP_SHOW_PARAMS, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },
};




/*!--------------------------------------------------------------------------
	RipNodeHandler::AddMenuItems
		Implementation of ITFSResultHandler::AddMenuItems
		Use this to add commands to the context menu of the blank areas
		of the result pane.
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RipNodeHandler::AddMenuItems(ITFSComponent *pComponent,
											  MMC_COOKIE cookie,
											  LPDATAOBJECT pDataObject,
											  LPCONTEXTMENUCALLBACK pCallback,
											  long *pInsertionAllowed)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT	hr = hrOK;
	SPITFSNode	spNode;
    RipNodeHandler::SMenuData   menuData;

	COM_PROTECT_TRY
	{
		m_spNodeMgr->FindNode(cookie, &spNode);
        menuData.m_spNode.Set(spNode);
        
		hr = AddArrayOfMenuItems(spNode,
								 s_rgRipResultNodeMenu,
								 DimensionOf(s_rgRipResultNodeMenu),
								 pCallback,
								 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
	}
	COM_PROTECT_CATCH;

	return hr;
}


/*!--------------------------------------------------------------------------
	RipNodeHandler::Command
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RipNodeHandler::Command(ITFSComponent *pComponent,
									   MMC_COOKIE cookie,
									   int nCommandID,
									   LPDATAOBJECT pDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	SPITFSNode	spNode;
	HRESULT		hr = hrOK;

	switch (nCommandID)
	{
		case IDS_MENU_RIP_SHOW_PARAMS:
			CreateNewStatisticsWindow(&m_RIPParamsStats,
									  ::FindMMCMainWindow(),
									  IDD_STATS_NARROW);
			break;
	}
	return hr;
}



ImplementEmbeddedUnknown(RipNodeHandler, IRtrAdviseSink)

STDMETHODIMP RipNodeHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
	DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
	InitPThis(RipNodeHandler, IRtrAdviseSink);
	SPITFSNode				spThisNode;
	SPITFSNode				spNode;
	SPITFSNodeEnum			spEnumNode;
	SPIEnumInterfaceInfo	spEnumIf;
	SPIInterfaceInfo		spIf;
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPIInfoBase				spInfoBase;
	BOOL					fPleaseAdd;
	BOOL					fFound;
	BaseIPXResultNodeData *	pData;
	HRESULT					hr = hrOK;
	
	pThis->m_spNodeMgr->FindNode(pThis->m_cookie, &spThisNode);

	if (dwObjectType == ROUTER_OBJ_RmIf)
	{
		if (dwChangeType == ROUTER_CHILD_PREADD)
		{
			// Add RIP to the infobase
			pThis->AddProtocolToInfoBase(spThisNode);
		}
		else if (dwChangeType == ROUTER_CHILD_ADD)
		{
			// Add the protocol to the router mgr
			// We need to add the protocol to the interface (use
			// default values).
			pThis->AddProtocolToInterface(spThisNode);
		}
	}

	if (dwObjectType == ROUTER_OBJ_RmProtIf)
	{
		if (dwChangeType == ROUTER_CHILD_ADD)
		{
            // If the node hasn't been expanded yet, then we don't
            // need to do anything yet.
            if (pThis->m_bExpanded)
            {
                // Enumerate through the list of interfaces looking for
                // the interfaces that have this protocol.  If we find
                // one, look for this interface in our list of nodes.
                spThisNode->GetEnum(&spEnumNode);
                
                CORg( pThis->m_spRouterInfo->EnumInterface(&spEnumIf) );
                
                spEnumIf->Reset();
                
                fPleaseAdd = FALSE;
                
                for (; spEnumIf->Next(1, &spIf, NULL) == hrOK; spIf.Release())
                {
                    // Look for this interface in our list of nodes
                    // If it's there than continue on
                    fFound = FALSE;
                    spEnumNode->Reset();
                    spNode.Release();
                    
                    for (; spEnumNode->Next(1, &spNode, NULL) == hrOK; spNode.Release())
                    {
                        pData = GET_BASEIPXRESULT_NODEDATA(spNode);
                        Assert(pData);
                        ASSERT_BASEIPXRESULT_NODEDATA(pData);
                        
                        if (!pData->m_fClient && StriCmpW(pData->m_spIf->GetId(), spIf->GetId()) == 0)
                        {
                            fFound = TRUE;
                            break;
                        }
                    }
                    
                    // If the interface was not found in the list of nodes,
                    // then it is a candidate.  Now we have to see if the
                    // interface supports this transport.
                    if (!fFound && (LookupRtrMgrProtocolInterface(spIf, PID_IPX, IPX_PROTOCOL_RIP, NULL) == hrOK))
                    {
                        // If this interface has this transport, and is NOT in
                        // the current list of nodes then add this interface
                        // to the UI
                        
                        // Grab the infobase
                        // Load the infobase for this interface
                        spRmIf.Release();
                        spInfoBase.Release();
                        hr = spIf->FindRtrMgrInterface(PID_IPX, &spRmIf);
                        
                        if (FHrOK(hr))
                        {
                            spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase);
                            hr  = pThis->AddInterfaceNode(spThisNode, spIf, FALSE);
                        }
                        fPleaseAdd = TRUE;
                    }
                }
            
                // Now that we have all of the nodes, update the data for
                // all of the nodes
                if (fPleaseAdd)
                    pThis->SynchronizeNodeData(spThisNode);                
            }
		}
		else if (dwChangeType == ROUTER_CHILD_DELETE)
		{
			// Go through the list of nodes, if we cannot find the
			// node in the list of interfaces, delete the node
			
			spThisNode->GetEnum(&spEnumNode);
			spEnumNode->Reset();
			while (spEnumNode->Next(1, &spNode, NULL) == hrOK)
			{
				// Get the node data, look for the interface
				pData = GET_BASEIPXRESULT_NODEDATA(spNode);
				ASSERT_BASEIPXRESULT_NODEDATA(pData);

				if (pData->m_spIf &&
					LookupRtrMgrProtocolInterface(pData->m_spIf,
						PID_IPX, IPX_PROTOCOL_RIP, NULL) != hrOK)
				{
					// If this flag is set, then we are in the new
					// interface case, and we do not want to delete
					// this here since it will then deadlock.
					if ((spNode->GetVisibilityState() & TFS_VIS_DELETE) == 0)
					{
						// cannot find the interface, release this node!
						spThisNode->RemoveChild(spNode);
						spNode->Destroy();
					}
				}
				spNode.Release();
				spIf.Release();
			}
			
		}
	}
	else if (dwChangeType == ROUTER_REFRESH)
	{
		if (ulConn == pThis->m_ulStatsConnId)
		{
			pThis->m_RIPParamsStats.PostRefresh();
		}
		else
			pThis->SynchronizeNodeData(spThisNode);
	}
   else if (dwChangeType == ROUTER_DO_DISCONNECT)
   {
	   IPXConnection *		pIPXConn = NULL;
   
	   pIPXConn = GET_RIP_NODEDATA(spThisNode);
	   pIPXConn->DisconnectAll();
   }
Error:
	return hr;
}

HRESULT RipNodeHandler::AddProtocolToInfoBase(ITFSNode *pThisNode)
{
	HRESULT			hr = hrOK;
	SPITFSNodeEnum	spEnumNode;
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPIEnumInterfaceInfo	spEnumIf;
	SPIInterfaceInfo		spIf;
	SPITFSNode		spNode;
	BaseIPXResultNodeData *	pData;

	// Enumerate through the list of interfaces looking for
	// the interfaces that have this protocol.  If we find
	// one, look for this interface in our list of nodes.
	pThisNode->GetEnum(&spEnumNode);
	
	CORg( m_spRouterInfo->EnumInterface(&spEnumIf) );
	
	spEnumIf->Reset();
	
	for (; spEnumIf->Next(1, &spIf, NULL) == hrOK; spIf.Release())
	{
		// Look for this interface in our list of nodes
		// If it's there than continue on
		spEnumNode->Reset();
		spNode.Release();
		spRmIf.Release();
		
		// If this interface has IPX but not RIP, add it
		if ((spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) == hrOK) &&
			(LookupRtrMgrProtocolInterface(spIf, PID_IPX,
										   IPX_PROTOCOL_RIP, NULL) != hrOK))
		{
			// Add RIP to this node
			SPIInfoBase			spInfoBase;
			
			// We need to get the infobase for this and create
			// the RIP blocks (but do NOT save, let the property
			// sheet take care of that).
			spInfoBase.Release();
			if (!FHrOK(spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase)))
            {
                spRmIf->Load(spRmIf->GetMachineName(), NULL, NULL, NULL);
                spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase);
            }
			if (!spInfoBase)
				CreateInfoBase(&spInfoBase);

			if (!FHrOK(spInfoBase->ProtocolExists(IPX_PROTOCOL_RIP)))
			{
				// Add a RIP_IF_CONFIG block
				BYTE *	pDefault;

				if (spIf->GetInterfaceType() == ROUTER_IF_TYPE_DEDICATED)
					pDefault = g_pIpxRipLanInterfaceDefault;
				else
					pDefault = g_pIpxRipInterfaceDefault;
				spInfoBase->AddBlock(IPX_PROTOCOL_RIP,
									 sizeof(RIP_IF_CONFIG),
									 pDefault,
									 1,
									 0);
				
				spRmIf->SetInfoBase(NULL, NULL, NULL, spInfoBase);
			}

		}
	}
	
	// Now that we have all of the nodes, update the data for
	// all of the nodes
//	if (fPleaseAdd)
//		pThis->SynchronizeNodeData(spThisNode);
Error:
	return hr;
}


HRESULT RipNodeHandler::AddProtocolToInterface(ITFSNode *pThisNode)
{
	HRESULT			hr = hrOK;
	SPITFSNodeEnum	spEnumNode;
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPIRtrMgrProtocolInterfaceInfo	spRmProtIf;
	SPIEnumInterfaceInfo	spEnumIf;
	SPIInterfaceInfo		spIf;
	SPITFSNode		spNode;
	BaseIPXResultNodeData *	pData;

	// Enumerate through the list of interfaces looking for
	// the interfaces that have this protocol.  If we find
	// one, look for this interface in our list of nodes.
	pThisNode->GetEnum(&spEnumNode);
	
	CORg( m_spRouterInfo->EnumInterface(&spEnumIf) );
	
	spEnumIf->Reset();
	
	for (; spEnumIf->Next(1, &spIf, NULL) == hrOK; spIf.Release())
	{
		// Look for this interface in our list of nodes
		// If it's there than continue on
		spEnumNode->Reset();
		spNode.Release();
		
		// If this interface has IPX but not RIP, add it
		if ((spIf->FindRtrMgrInterface(PID_IPX, NULL) == hrOK) &&
			(LookupRtrMgrProtocolInterface(spIf, PID_IPX,
										   IPX_PROTOCOL_RIP, NULL) != hrOK))
		{
			// Add RIP to this node
			RtrMgrProtocolCB	RmProtCB;
			RtrMgrProtocolInterfaceCB	RmProtIfCB;
			SPIInfoBase			spInfoBase;
			
			// Need to create an RmProtIf
			m_spRmProt->CopyCB(&RmProtCB);

			spRmProtIf.Release();
			
			RmProtIfCB.dwProtocolId = RmProtCB.dwProtocolId;
			StrnCpyW(RmProtIfCB.szId, RmProtCB.szId, RTR_ID_MAX);
			RmProtIfCB.dwTransportId = RmProtCB.dwTransportId;
			StrnCpyW(RmProtIfCB.szRtrMgrId, RmProtCB.szRtrMgrId, RTR_ID_MAX);
			
			StrnCpyW(RmProtIfCB.szInterfaceId, spIf->GetId(), RTR_ID_MAX);
			RmProtIfCB.dwIfType = spIf->GetInterfaceType();
			RmProtIfCB.szTitle[0] = 0;
			
			CORg( CreateRtrMgrProtocolInterfaceInfo(&spRmProtIf,
				&RmProtIfCB) );
			
			spRmProtIf->SetTitle(spIf->GetTitle());
			
			// Add this to the spRmIf
			spRmIf.Release();
			CORg( spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) );
			Assert(spRmIf);

			// We need to get the infobase for this and create
			// the RIP blocks (but do NOT save, let the property
			// sheet take care of that).
			spInfoBase.Release();
//			spRmIf->Load(spRmIf->GetMachineName(), NULL, NULL, NULL);
			spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase);
			if (!spInfoBase)
				CreateInfoBase(&spInfoBase);

			if (!FHrOK(spInfoBase->ProtocolExists(IPX_PROTOCOL_RIP)))
			{
				// Add a RIP_IF_CONFIG block
				BYTE *	pDefault;

				if (spIf->GetInterfaceType() == ROUTER_IF_TYPE_DEDICATED)
					pDefault = g_pIpxRipLanInterfaceDefault;
				else
					pDefault = g_pIpxRipInterfaceDefault;
				
				spInfoBase->AddBlock(IPX_PROTOCOL_RIP,
									 sizeof(RIP_IF_CONFIG),
									 pDefault,
									 1,
									 0);
			}

			
			CORg(spRmIf->AddRtrMgrProtocolInterface(spRmProtIf,
				spInfoBase /* pInfoBase */));
		}
	}
	
	// Now that we have all of the nodes, update the data for
	// all of the nodes
//	if (fPleaseAdd)
//		pThis->SynchronizeNodeData(spThisNode);
Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	RipNodeHandler::SynchronizeNodeData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipNodeHandler::SynchronizeNodeData(ITFSNode *pThisNode)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT	hr = hrOK;
	SPITFSNodeEnum	spNodeEnum;
	SPITFSNode		spNode;
	CStringList		ifidList;
	BaseIPXResultNodeData *	pNodeData;
	RipList	ripList;
	RipListEntry *	pRipEntry = NULL;
	RipListEntry *	pRipCurrent = NULL;
	int				i;
	CString			stNotAvailable;
	POSITION		pos;

	COM_PROTECT_TRY
	{	
		// Do the data gathering work (separate this from the rest of the
		// code so that we can move this part to a background thread later).

		stNotAvailable.LoadString(IDS_IPX_NOT_AVAILABLE);

		// We need to build up a list of interface ids
		pThisNode->GetEnum(&spNodeEnum);
		for (; spNodeEnum->Next(1, &spNode, NULL) == hrOK; spNode.Release() )
		{
			pNodeData = GET_BASEIPXRESULT_NODEDATA(spNode);
			Assert(pNodeData);
			ASSERT_BASEIPXRESULT_NODEDATA(pNodeData);
			
			pRipEntry = new RipListEntry;
			
			pRipEntry->m_spIf.Set(pNodeData->m_spIf);
			pRipEntry->m_spNode.Set(spNode);

			::ZeroMemory(&(pRipEntry->m_info), sizeof(pRipEntry->m_info));
			::ZeroMemory(&(pRipEntry->m_stats), sizeof(pRipEntry->m_stats));

			pRipEntry->m_fClient = pNodeData->m_fClient;
			pRipEntry->m_fFoundIfIndex = FALSE;
			pRipEntry->m_dwIfIndex = 0;

			// The data in the m_info struct is not up to date
			pRipEntry->m_fInfoUpdated = FALSE;
			
			ripList.AddTail(pRipEntry);
			pRipEntry = NULL;

			// Fill in the result data with '-'
			// This is a little bogus, but it's the easiest way, we
			// don't want to touch interface and relay_mode.
			for (i=RIP_SI_INTERFACE; i<RIP_SI_MAX_COLUMNS; i++)
			{
				pNodeData->m_rgData[i].m_stData = stNotAvailable;
				pNodeData->m_rgData[i].m_dwData = 0xFFFFFFFF;
			}

			// Fill in as much data as we can at this point
			if (pNodeData->m_fClient)
			{
				pNodeData->m_rgData[RIP_SI_INTERFACE].m_stData.LoadString(
					IDS_IPX_DIAL_IN_CLIENTS);
				pNodeData->m_rgData[RIP_SI_TYPE].m_stData =
					IpxTypeToCString(ROUTER_IF_TYPE_CLIENT);
			}
			else
			{
				pNodeData->m_rgData[RIP_SI_INTERFACE].m_stData =
					pNodeData->m_spIf->GetTitle();

				pNodeData->m_rgData[RIP_SI_TYPE].m_stData =
					IpxTypeToCString(pNodeData->m_spIf->GetInterfaceType());
			}

		}
		spNode.Release();


		// We can now use this list of ids, to get the data for each item
		hr = GetRipData(pThisNode, &ripList);

		// Now for each data item, fill in the appropriate data in
		// the node
		pos = ripList.GetHeadPosition();
		while (pos)
		{
			pRipCurrent = ripList.GetNext(pos);

			pNodeData = GET_BASEIPXRESULT_NODEDATA(pRipCurrent->m_spNode);
			Assert(pNodeData);
			ASSERT_BASEIPXRESULT_NODEDATA(pNodeData);

			if (pRipCurrent->m_fInfoUpdated)
			{
				pNodeData->m_rgData[RIP_SI_ACCEPT_ROUTES].m_stData =
					IpxAdminStateToCString(pRipCurrent->m_info.Listen);
				
				pNodeData->m_rgData[RIP_SI_SUPPLY_ROUTES].m_stData =
					IpxAdminStateToCString(pRipCurrent->m_info.Supply);
			
				pNodeData->m_rgData[RIP_SI_UPDATE_MODE].m_stData =
					RipSapUpdateModeToCString(pRipCurrent->m_info.UpdateMode);
				
				FillInNumberData(pNodeData, RIP_SI_UPDATE_PERIOD,
								 pRipCurrent->m_info.PeriodicUpdateInterval);
				
				FillInNumberData(pNodeData, RIP_SI_AGE_MULTIPLIER,
								 pRipCurrent->m_info.AgeIntervalMultiplier);

				pNodeData->m_rgData[RIP_SI_ADMIN_STATE].m_stData =
					IpxAdminStateToCString(pRipCurrent->m_info.AdminState);
			}

			if (FHrSucceeded(hr) && !pRipCurrent->m_fClient)
			{
				pNodeData->m_rgData[RIP_SI_OPER_STATE].m_stData =
					IpxOperStateToCString(pRipCurrent->m_stats.RipIfOperState);

				FillInNumberData(pNodeData, RIP_SI_PACKETS_SENT,
								 pRipCurrent->m_stats.RipIfOutputPackets);
			
				FillInNumberData(pNodeData, RIP_SI_PACKETS_RECEIVED,
								 pRipCurrent->m_stats.RipIfInputPackets);
			}
			
			pRipCurrent->m_spNode->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);
		}
		

	}
	COM_PROTECT_CATCH;

	delete pRipEntry;
	while (!ripList.IsEmpty())
		delete ripList.RemoveTail();
	
	return hr;
}

/*!--------------------------------------------------------------------------
	RipNodeHandler::GetRipData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT	RipNodeHandler::GetRipData(ITFSNode *pThisNode, RipList *pRipList)
{
	HRESULT			hr = hrOK;
	BOOL			fIsServiceRunning;
	IPXConnection *	pIPXConn;
	RIP_MIB_GET_INPUT_DATA	MibGetInputData;
	SPIInfoBase		spInfoBase;
	POSITION		pos;
	RipListEntry *	pRipEntry;
	int				i;
	PRIP_INTERFACE	pRipIf = NULL;
	DWORD			cbRipIf;
	SPMprMibBuffer	spMib;
	DWORD			dwErr;
	SPIRtrMgrInterfaceInfo	spRmIf;
	PRIP_IF_CONFIG	pric;
	HRESULT			hrIndex = hrOK;


	// Retrieve the IP interface table; we will need this in order to
	// map interface-names to interface-indices, and we will need the
	// interface-indices in order to query for RIP MIB information.
	//
	CORg( IsRouterServiceRunning(m_spRouterInfo->GetMachineName(), NULL) );
	fIsServiceRunning = (hr == hrOK);

	// Get the connection data
	pIPXConn = GET_RIP_NODEDATA(pThisNode);

	// Iterate through the list filling in the interface indexes
	hrIndex = FillInInterfaceIndex(pIPXConn, pRipList);

	// Iterate throught the list of entries, gathering data for each
	// interface
	pos = pRipList->GetHeadPosition();
	while (pos)
	{
		pRipEntry = pRipList->GetNext(pos);
		
//		if (!fIsServiceRunning)
//			continue;

		if (pRipEntry->m_fClient)
		{
			// Fill in the client data
			FillClientData(pRipEntry);
			continue;
		}

		// Load the infobase and get the data for this entry
		spRmIf.Release();
		spInfoBase.Release();
		CORg( pRipEntry->m_spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) );
		if (!spRmIf)
			continue;

		CORg( spRmIf->Load(spRmIf->GetMachineName(), NULL, NULL, NULL) );
		CORg( spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase) );
		CORg( spInfoBase->GetData(IPX_PROTOCOL_RIP, 0, (LPBYTE *) &pric) );

		pRipEntry->m_info = pric->RipIfInfo;
		pRipEntry->m_fInfoUpdated = TRUE;

		if (!pRipEntry->m_fFoundIfIndex)
			continue;

		if (!fIsServiceRunning)
			continue;

		if (!FHrSucceeded(hrIndex))
			continue;

		// Now get the dynamic data from the MIBs

		spMib.Free();
		MibGetInputData.InterfaceIndex = pRipEntry->m_dwIfIndex;
		MibGetInputData.TableId = RIP_INTERFACE_TABLE;

		dwErr = ::MprAdminMIBEntryGet(pIPXConn->GetMibHandle(),
									  PID_IPX,
									  IPX_PROTOCOL_RIP,
									  &MibGetInputData,
									  sizeof(MibGetInputData),
									  (LPVOID *) &pRipIf,
									  &cbRipIf);
		spMib = (PBYTE) pRipIf;
		CWRg(dwErr);

		Assert(pRipIf);

		pRipEntry->m_stats = pRipIf->RipIfStats;
	}


	
Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	RipNodeHandler::FillInInterfaceIndex
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipNodeHandler::FillInInterfaceIndex(IPXConnection *pIPXConn, RipList *pRipList)
{
	HRESULT			hr = hrOK;
	POSITION		pos;
	RipListEntry *	pRipEntry;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD			IfSize = sizeof(IPX_INTERFACE);
	PIPX_INTERFACE	pIpxIf;
	DWORD			dwErr;
	SPMprMibBuffer	spMib;
	USES_CONVERSION;

	MibGetInputData.TableId = IPX_INTERFACE_TABLE;
	dwErr = ::MprAdminMIBEntryGetFirst(pIPXConn->GetMibHandle(),
									   PID_IPX,
									   IPX_PROTOCOL_BASE,
									   &MibGetInputData,
									   sizeof(IPX_MIB_GET_INPUT_DATA),
									   (LPVOID *) &pIpxIf,
									   &IfSize);
	hr = HRESULT_FROM_WIN32(dwErr);
	spMib = (LPBYTE) pIpxIf;

	while (FHrSucceeded(hr))
	{
		// go through the list of interfaces looking for a match
		pos = pRipList->GetHeadPosition();
		while (pos)
		{
			pRipEntry = pRipList->GetNext(pos);

			// If this is the client interface, we don't need to
			// look for an interface that matches
			if (pRipEntry->m_fClient)
				continue;

			if (StriCmp(pRipEntry->m_spIf->GetId(),
						A2CT((LPCSTR) pIpxIf->InterfaceName)) == 0)
			{
				Assert(pRipEntry->m_fFoundIfIndex == FALSE);
				
				pRipEntry->m_dwIfIndex = pIpxIf->InterfaceIndex;
				pRipEntry->m_fFoundIfIndex = TRUE;
				break;
			}
			pRipEntry = NULL;
		}

		// Go onto the next interface
		
		MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex =
			pIpxIf->InterfaceIndex;
		spMib.Free();
		pIpxIf = NULL;
		
		dwErr = ::MprAdminMIBEntryGetNext(pIPXConn->GetMibHandle(),
										  PID_IPX,
										  IPX_PROTOCOL_BASE,
										  &MibGetInputData,
										  sizeof(IPX_MIB_GET_INPUT_DATA),
										  (LPVOID *) &pIpxIf,
										  &IfSize);
		hr = HRESULT_FROM_WIN32(dwErr);
		spMib = (LPBYTE) pIpxIf;
	}
	
	
//Error:
	return hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) ? hrOK : hr;
}

/*!--------------------------------------------------------------------------
	RipNodeHandler::FillClientData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipNodeHandler::FillClientData(RipListEntry *pRipEntry)
{
	HRESULT		hr = hrOK;
	SPIInfoBase	spInfoBase;
	PRIP_IF_CONFIG	pric = NULL;

	Assert(pRipEntry->m_fClient == TRUE);
	Assert(pRipEntry->m_fFoundIfIndex == FALSE);

	CORg( m_spRm->GetInfoBase(NULL, NULL, NULL, &spInfoBase) );

	CORg( spInfoBase->GetData(IPX_PROTOCOL_RIP, 0, (LPBYTE *) &pric) );

	pRipEntry->m_info = pric->RipIfInfo;
	pRipEntry->m_fInfoUpdated = TRUE;

	memset(&(pRipEntry->m_stats), 0xFF, sizeof(pRipEntry->m_stats));
	pRipEntry->m_dwIfIndex = 0xFFFFFFFF;
		
Error:
	return hr;
}



/*!--------------------------------------------------------------------------
	RipNodeHandler::OnResultShow
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipNodeHandler::OnResultShow(ITFSComponent *pTFSComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	BOOL	bSelect = (BOOL) arg;
	HRESULT	hr = hrOK;
	SPIRouterRefresh	spRefresh;
	SPITFSNode	spNode;

	BaseContainerHandler::OnResultShow(pTFSComponent, cookie, arg, lParam);

	if (bSelect)
	{
		// Call synchronize on this node
		m_spNodeMgr->FindNode(cookie, &spNode);
		if (spNode)
			SynchronizeNodeData(spNode);
	}

	// Un/Register for refresh advises
	if (m_spRouterInfo)
		m_spRouterInfo->GetRefreshObject(&spRefresh);

	if (spRefresh)
	{
		if (bSelect)
		{
			if (m_ulRefreshConnId == 0)
				spRefresh->AdviseRefresh(&m_IRtrAdviseSink, &m_ulRefreshConnId, 0);
			if (m_ulStatsConnId == 0)
				spRefresh->AdviseRefresh(&m_IRtrAdviseSink, &m_ulStatsConnId, 0);
		}
		else
		{
			if (m_ulRefreshConnId)
				spRefresh->UnadviseRefresh(m_ulRefreshConnId);
			m_ulRefreshConnId = 0;
		}
	}
	
	return hr;
}


/*!--------------------------------------------------------------------------
	RipNodeHandler::CompareItems
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int) RipNodeHandler::CompareItems(
								ITFSComponent * pComponent,
								MMC_COOKIE cookieA,
								MMC_COOKIE cookieB,
								int nCol)
{
	// Get the strings from the nodes and use that as a basis for
	// comparison.
	SPITFSNode	spNode;
	SPITFSResultHandler	spResult;

	m_spNodeMgr->FindNode(cookieA, &spNode);
	spNode->GetResultHandler(&spResult);
	return spResult->CompareItems(pComponent, cookieA, cookieB, nCol);
}


/*---------------------------------------------------------------------------
	Class: RipInterfaceHandler
 ---------------------------------------------------------------------------*/

RipInterfaceHandler::RipInterfaceHandler(ITFSComponentData *pCompData)
	: BaseIPXResultHandler(pCompData, RIP_COLUMNS),
	m_ulConnId(0)
{
 	m_rgButtonState[MMC_VERB_PROPERTIES_INDEX] = ENABLED;
	m_bState[MMC_VERB_PROPERTIES_INDEX] = TRUE;
	
 	m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
	m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;
	
	m_verbDefault = MMC_VERB_PROPERTIES;
}

static const DWORD s_rgInterfaceImageMap[] =
	 {
	 ROUTER_IF_TYPE_HOME_ROUTER,	IMAGE_IDX_WAN_CARD,
	 ROUTER_IF_TYPE_FULL_ROUTER,	IMAGE_IDX_WAN_CARD,
	 ROUTER_IF_TYPE_CLIENT,			IMAGE_IDX_WAN_CARD,
	 ROUTER_IF_TYPE_DEDICATED,		IMAGE_IDX_LAN_CARD,
	 ROUTER_IF_TYPE_INTERNAL,		IMAGE_IDX_LAN_CARD,
	 ROUTER_IF_TYPE_LOOPBACK,		IMAGE_IDX_LAN_CARD,
	 -1,							IMAGE_IDX_WAN_CARD,	// sentinel value
	 };

/*!--------------------------------------------------------------------------
	RipInterfaceHandler::ConstructNode
		Initializes the Domain node (sets it up).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipInterfaceHandler::ConstructNode(ITFSNode *pNode, IInterfaceInfo *pIfInfo, IPXConnection *pIPXConn)
{
	HRESULT			hr = hrOK;
	int				i;
	DWORD			dwIfType;
	
	if (pNode == NULL)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Need to initialize the data for the Domain node

		// Find the right image index for this type of node
		if (pIfInfo)
			dwIfType = pIfInfo->GetInterfaceType();
		else
			dwIfType = ROUTER_IF_TYPE_CLIENT;
		
		for (i=0; i<DimensionOf(s_rgInterfaceImageMap); i+=2)
		{
			if ((dwIfType == s_rgInterfaceImageMap[i]) ||
				(-1 == s_rgInterfaceImageMap[i]))
				break;
		}
		pNode->SetData(TFS_DATA_IMAGEINDEX, s_rgInterfaceImageMap[i+1]);
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, s_rgInterfaceImageMap[i+1]);
		
		pNode->SetData(TFS_DATA_SCOPEID, 0);

		pNode->SetData(TFS_DATA_COOKIE, reinterpret_cast<DWORD_PTR>(pNode));

		//$ Review: kennt, what are the different type of interfaces
		// do we distinguish based on the same list as above? (i.e. the
		// one for image indexes).
		pNode->SetNodeType(&GUID_IPXRipInterfaceNodeType);

		BaseIPXResultNodeData::Init(pNode, pIfInfo, pIPXConn);
	}
	COM_PROTECT_CATCH
	return hr;
}

/*!--------------------------------------------------------------------------
	RipInterfaceHandler::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RipInterfaceHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		CORg( CreateDataObjectFromInterfaceInfo(m_spInterfaceInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}


/*!--------------------------------------------------------------------------
	RipInterfaceHandler::OnCreateDataObject
		Implementation of ITFSResultHandler::OnCreateDataObject
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RipInterfaceHandler::OnCreateDataObject(ITFSComponent *pComp, MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		CORg( CreateDataObjectFromInterfaceInfo(m_spInterfaceInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}



/*!--------------------------------------------------------------------------
	RipInterfaceHandler::RefreshInterface
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void RipInterfaceHandler::RefreshInterface(MMC_COOKIE cookie)
{
	SPITFSNode	spNode;
	
	m_spNodeMgr->FindNode(cookie, &spNode);

	ForwardCommandToParent(spNode, IDS_MENU_SYNC,
						CCT_RESULT, NULL, 0);
}


/*!--------------------------------------------------------------------------
	RipInterfaceHandler::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipInterfaceHandler::Init(IInterfaceInfo *pIfInfo,
								  IRouterInfo *pRouterInfo,
								  ITFSNode *pParent)
{
	m_spInterfaceInfo.Set(pIfInfo);

	BaseIPXResultHandler::Init(pIfInfo, pParent);

	m_spRouterInfo.Set(pRouterInfo);
	return hrOK;
}


/*!--------------------------------------------------------------------------
	RipInterfaceHandler::DestroyResultHandler
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RipInterfaceHandler::DestroyResultHandler(MMC_COOKIE cookie)
{
	m_spInterfaceInfo.Release();
	BaseIPXResultHandler::DestroyResultHandler(cookie);
	return hrOK;
}


/*---------------------------------------------------------------------------
	This is the list of commands that will show up for the result pane
	nodes.
 ---------------------------------------------------------------------------*/
struct SIPInterfaceNodeMenu
{
	ULONG	m_sidMenu;			// string/command id for this menu item
	ULONG	(RipInterfaceHandler:: *m_pfnGetMenuFlags)(RipInterfaceHandler::SMenuData *);
	ULONG	m_ulPosition;
};

/*!--------------------------------------------------------------------------
	RipInterfaceHandler::AddMenuItems
		Implementation of ITFSResultHandler::AddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RipInterfaceHandler::AddMenuItems(
	ITFSComponent *pComponent,
	MMC_COOKIE cookie,
	LPDATAOBJECT lpDataObject, 
	LPCONTEXTMENUCALLBACK pContextMenuCallback, 
	long *pInsertionAllowed)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	RipInterfaceHandler::Command
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RipInterfaceHandler::Command(ITFSComponent *pComponent,
									   MMC_COOKIE cookie,
									   int nCommandID,
									   LPDATAOBJECT pDataObject)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	RipInterfaceHandler::HasPropertyPages
		- 
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RipInterfaceHandler::HasPropertyPages 
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	return hrTrue;
}

/*!--------------------------------------------------------------------------
	RipInterfaceHandler::CreatePropertyPages
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RipInterfaceHandler::CreatePropertyPages
(
	ITFSNode *				pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject, 
	LONG_PTR					handle, 
	DWORD					dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT		hr = hrOK;
	RipInterfaceProperties *	pProperties = NULL;
	SPIComponentData spComponentData;
	CString		stTitle;
	SPIRouterInfo	spRouter;
	SPIRtrMgrInfo	spRm;

	CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

//	stTitle.Format(IDS_RIP_GENERAL_PAGE_TITLE,
//				   m_spInterfaceInfo->GetTitle());
	
	pProperties = new RipInterfaceProperties(pNode, spComponentData,
		m_spTFSCompData, stTitle);

	CORg( m_spRouterInfo->FindRtrMgr(PID_IPX, &spRm) );
	CORg( pProperties->Init(m_spInterfaceInfo, spRm) );

	if (lpProvider)
		hr = pProperties->CreateModelessSheet(lpProvider, handle);
	else
		hr = pProperties->DoModelessSheet();

Error:
	// Is this the right way to destroy the sheet?
	if (!FHrSucceeded(hr))
		delete pProperties;
	return hr;
}

/*!--------------------------------------------------------------------------
	RipInterfaceHandler::CreatePropertyPages
		Implementation of ResultHandler::CreatePropertyPages
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RipInterfaceHandler::CreatePropertyPages
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPPROPERTYSHEETCALLBACK	lpProvider, 
	LPDATAOBJECT			pDataObject, 
	LONG_PTR					handle
)
{
	// Forward this call onto the NodeHandler::CreatePropertyPages
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT	hr = hrOK;
	SPITFSNode	spNode;

	Assert( m_spNodeMgr );

	CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

	// Call the ITFSNodeHandler::CreatePropertyPages
	hr = CreatePropertyPages(spNode, lpProvider, pDataObject, handle, 0);
	
Error:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ripprop.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    ripprop.h
//
// History:
//	07/22/97	Kenn M. Takara			Created.
//
//	IP Summary property sheet and property pages
//
//============================================================================


#ifndef _RIPPROP_H
#define _RIPPROP_H

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _RTRSHEET_H
#include "rtrsheet.h"
#endif

#ifndef __IPCTRL_H
#include "ipctrl.h"
#endif


/*---------------------------------------------------------------------------
	Forward declarations
 ---------------------------------------------------------------------------*/
class IPXConnection;
class RipProperties;
class RipInterfaceProperties;



/*---------------------------------------------------------------------------
	Class:	RipPageGeneral

	This class handles the General page of the Rip sheet.
 ---------------------------------------------------------------------------*/
class RipPageGeneral :
   public RtrPropertyPage
{
public:
	RipPageGeneral(UINT nIDTemplate, UINT nIDCaption = 0)
			: RtrPropertyPage(nIDTemplate, nIDCaption)
	{};

	HRESULT	Init(RipProperties * pIPPropSheet);

protected:
	// Override the OnApply() so that we can grab our data from the
	// controls in the dialog.
	virtual BOOL OnApply();

	RipProperties *	m_pRipPropSheet;

	void			SetErrorLevelButtons(DWORD dwErrorLevel);
	DWORD			QueryErrorLevelButtons();

	//{{AFX_VIRTUAL(RipPageGeneral)
	protected:
	virtual VOID	DoDataExchange(CDataExchange *pDX);
	//}}AFX_VIRTUAL

	//{{AFX_MSG(RipPageGeneral)
	virtual BOOL	OnInitDialog();
	afx_msg void	OnButtonClicked();
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};


/*---------------------------------------------------------------------------
	Class:	RipProperties

	This is the property sheet support class for the properties page of
	the Rip node.
 ---------------------------------------------------------------------------*/

class RipProperties :
	public RtrPropertySheet
{
public:
	RipProperties(ITFSNode *pNode,
						IComponentData *pComponentData,
						ITFSComponentData *pTFSCompData,
						LPCTSTR pszSheetName,
						CWnd *pParent = NULL,
						UINT iPage=0,
						BOOL fScopePane = TRUE);

	HRESULT	Init(IRtrMgrInfo *pRm);

	virtual BOOL SaveSheetData();

	// Loads the infobase for this interface.
	HRESULT	LoadInfoBase(IPXConnection *pIPXConn);
	HRESULT GetInfoBase(IInfoBase **ppInfoBase);
	
protected:
	SPIRtrMgrInfo			m_spRm;
	SPIRtrMgrInterfaceInfo	m_spRmIf;
	SPIInterfaceInfo		m_spIf;
	RipPageGeneral			m_pageGeneral;
	SPITFSNode				m_spNode;
	SPIInfoBase				m_spInfoBase;
};


/*---------------------------------------------------------------------------
	Class:	RipInterfacePageGeneral

	This class handles the General page of the Rip sheet.
 ---------------------------------------------------------------------------*/
class RipInterfacePageGeneral :
   public RtrPropertyPage
{
public:
	RipInterfacePageGeneral(UINT nIDTemplate, UINT nIDCaption = 0)
			: RtrPropertyPage(nIDTemplate, nIDCaption)
	{};

	HRESULT	Init(RipInterfaceProperties * pIPPropSheet,
				 IInterfaceInfo *pIf);

protected:
	// Override the OnApply() so that we can grab our data from the
	// controls in the dialog.
	virtual BOOL OnApply();

	// Brings up either the input or output filters
	void	ShowFilter(BOOL fOutputFilter);

	RipInterfaceProperties *	m_pRipIfPropSheet;
	SPIInterfaceInfo		m_spIf;
	CSpinButtonCtrl			m_spinInterval;
	CSpinButtonCtrl			m_spinMultiplier;

	//{{AFX_VIRTUAL(RipInterfacePageGeneral)
	protected:
	virtual VOID	DoDataExchange(CDataExchange *pDX);
	//}}AFX_VIRTUAL

	//{{AFX_MSG(RipInterfacePageGeneral)
	virtual BOOL	OnInitDialog();
	afx_msg	void	OnButtonClicked();
	afx_msg	void	OnUpdateButtonClicked();
	afx_msg void	OnChangeEdit();
	afx_msg	void	OnInputFilter();
	afx_msg	void	OnOutputFilter();
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};



/*---------------------------------------------------------------------------
	Class:	RipInterfaceProperties

	This is the property sheet support class for the properties page of
	the RIP node.
 ---------------------------------------------------------------------------*/

class RipInterfaceProperties :
	public RtrPropertySheet
{
public:
	RipInterfaceProperties(ITFSNode *pNode,
						IComponentData *pComponentData,
						ITFSComponentData *pTFSCompData,
						LPCTSTR pszSheetName,
						CWnd *pParent = NULL,
						UINT iPage=0,
						BOOL fScopePane = TRUE);

	HRESULT	Init(IInterfaceInfo *pIf, IRtrMgrInfo *pRm);

	virtual BOOL SaveSheetData();
	virtual void CancelSheetData();

	// Loads the infobase for this interface.
	HRESULT	LoadInfoBase(IPXConnection *pIPXConn);
	HRESULT GetInfoBase(IInfoBase **ppInfoBase);
	
	BOOL					m_bNewInterface;

	
protected:
	SPIRtrMgrInfo			m_spRm;
	SPIRtrMgrInterfaceInfo	m_spRmIf;
	SPIInterfaceInfo		m_spIf;
	RipInterfacePageGeneral	m_pageGeneral;
	SPITFSNode				m_spNode;
	SPIInfoBase				m_spInfoBase;
	BOOL					m_bClientInfoBase;
};



#endif _RIPPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\riproot.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	root.h
		Root node information (the root node is not displayed
		in the MMC framework but contains information such as 
		all of the subnodes in this snapin).
		
    FILE HISTORY:
        
*/

#ifndef _RIPROOT_H
#define _RIPROOT_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _QUERYOBJ_H
#include "queryobj.h"
#endif

#ifndef _RIPSTRM_H
#include "ripstrm.h"
#endif

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _ROOT_H
#include "root.h"
#endif


/*---------------------------------------------------------------------------
	Class:	RipRootHandler

	There should be a RipRootHandler for every root node created.
	RipRootHandler's have a 1-to-1 relationship with their node!
	Other parts of the code depend on this.
 ---------------------------------------------------------------------------*/
class RipRootHandler
	   : public RootHandler
{
public:
	RipRootHandler(ITFSComponentData *pCompData);
	~RipRootHandler()
			{ DEBUG_DECREMENT_INSTANCE_COUNTER(RipRootHandler); };

	// Override QI to handle embedded interface
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);

	DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown);

	STDMETHOD(GetClassID)(CLSID *pClassId);

	// Notification overrides
	OVERRIDE_BaseHandlerNotify_OnExpand();

	// Handler overrides
	OVERRIDE_NodeHandler_OnCreateDataObject();
	OVERRIDE_NodeHandler_DestroyHandler();

	// virtual function to access config stream
	ConfigStream *		GetConfigStream()
			{ return &m_ConfigStream; }

protected:
	HRESULT AddProtocolNode(ITFSNode *pNode, IRouterInfo * pRouterInfo);
    HRESULT CompareNodeToMachineName(ITFSNode *pNode, LPCTSTR pszName);

    RipConfigStream		m_ConfigStream;
};




#endif _RIPROOT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ripstats.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ipstats.cpp
		IP Statistics implementation.
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "rtrutil.h"	// smart MPR handle pointers
#include "format.h"		// FormatNumber function
#include "column.h"		// containercolumninfo
#include "ipxconn.h"	// IPXConnection
#include "routprot.h"
#include "ipxutil.h"

#include "statsdlg.h"
#include "ripstats.h"
#include "resource.h"


/*---------------------------------------------------------------------------
	RIPParamsStatistics implementation
 ---------------------------------------------------------------------------*/


extern const ContainerColumnInfo s_rgRIPParamsStatsColumnInfo[];
const ContainerColumnInfo s_rgRIPParamsStatsColumnInfo[] =
{
	{ IDS_STATS_RIPPARAMS_OPER_STATE,	0,		TRUE, COL_STATUS },
	{ IDS_STATS_RIPPARAMS_SENT_PACKETS,	0,		TRUE, COL_LARGE_NUM },
	{ IDS_STATS_RIPPARAMS_RCVD_PACKETS,	0,		TRUE, COL_LARGE_NUM },
};

RIPParamsStatistics::RIPParamsStatistics()
	: IPXStatisticsDialog(STATSDLG_VERTICAL |
						 STATSDLG_FULLWINDOW |
						 STATSDLG_CONTEXTMENU |
						 STATSDLG_SELECT_COLUMNS)
{
	SetColumnInfo(s_rgRIPParamsStatsColumnInfo,
				  DimensionOf(s_rgRIPParamsStatsColumnInfo));
}

			
HRESULT RIPParamsStatistics::RefreshData(BOOL fGrabNewData)
{
	HRESULT	hr = hrOK;
	CString	st;
	ULONG	iPos;
	TCHAR	szNumber[32];
	RIP_MIB_GET_INPUT_DATA	MibGetInputData;
	PRIPMIB_BASE	pRipBase = NULL;
	DWORD			cbRipBase;
	SPMprMibBuffer	spMib;
	PRIP_INTERFACE	pRipIf = NULL;
	DWORD			cbRipIf;
	DWORD			cSent = 0;
	DWORD			cRcvd = 0;
	DWORD			dwErr;

	Assert(m_pIPXConn);

	MibGetInputData.TableId = RIP_BASE_ENTRY;

	dwErr = ::MprAdminMIBEntryGet(m_pIPXConn->GetMibHandle(),
								  PID_IPX,
								  IPX_PROTOCOL_RIP,
								  &MibGetInputData,
								  sizeof(MibGetInputData),
								  (LPVOID *) &pRipBase,
								  &cbRipBase);
	spMib = (LPBYTE) pRipBase;
	hr = HRESULT_FROM_WIN32(dwErr);
	CORg( hr );

	if (IsSubitemVisible(MVR_RIPPARAMS_OPER_STATE))
	{
		st = IpxOperStateToCString(pRipBase->RIPOperState);
		iPos = MapSubitemToColumn(MVR_RIPPARAMS_OPER_STATE);
		m_listCtrl.SetItemText(iPos, 1, (LPCTSTR) st);
	}

	spMib.Free();
	MibGetInputData.TableId = RIP_INTERFACE_TABLE;

	dwErr = MprAdminMIBEntryGetFirst(m_pIPXConn->GetMibHandle(),
									 PID_IPX,
									 IPX_PROTOCOL_RIP,
									 &MibGetInputData,
									 sizeof(MibGetInputData),
									 (LPVOID *) &pRipIf,
									 &cbRipIf);
	hr = HRESULT_FROM_WIN32(dwErr);
	spMib = (LPBYTE) pRipIf;

	while (FHrSucceeded(hr))
	{
		if (pRipIf->InterfaceIndex)
		{
			cSent += pRipIf->RipIfStats.RipIfOutputPackets;
			cRcvd += pRipIf->RipIfStats.RipIfInputPackets;
		}
		
		MibGetInputData.InterfaceIndex = pRipIf->InterfaceIndex;
		spMib.Free();
		pRipIf = NULL;

		dwErr = MprAdminMIBEntryGetNext(m_pIPXConn->GetMibHandle(),
										PID_IPX,
										IPX_PROTOCOL_RIP,
										&MibGetInputData,
										sizeof(MibGetInputData),
										(LPVOID *) &pRipIf,
										&cbRipIf);
		hr = HRESULT_FROM_WIN32(dwErr);
		spMib = (LPBYTE) pRipIf;
	}

	
	if (IsSubitemVisible(MVR_RIPPARAMS_SENT_PKTS))
	{
		FormatNumber(cSent, szNumber, DimensionOf(szNumber), FALSE);
		iPos = MapSubitemToColumn(MVR_RIPPARAMS_SENT_PKTS);
		m_listCtrl.SetItemText(iPos, 1, (LPCTSTR) szNumber);
	}


	if (IsSubitemVisible(MVR_RIPPARAMS_RCVD_PKTS))
	{
		FormatNumber(cRcvd, szNumber, DimensionOf(szNumber), FALSE);
		iPos = MapSubitemToColumn(MVR_RIPPARAMS_RCVD_PKTS);
		m_listCtrl.SetItemText(iPos, 1, (LPCTSTR) szNumber);
	}

Error:
	return hr;
}

BOOL RIPParamsStatistics::OnInitDialog()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CString	st;

	st.LoadString(IDS_STATS_RIPPARAMS_TITLE);
	SetWindowText((LPCTSTR) st);
	return IPXStatisticsDialog::OnInitDialog();
}

void RIPParamsStatistics::Sort(UINT)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\riproot.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	root.cpp
		Root node information (the root node is not displayed
		in the MMC framework but contains information such as 
		all of the subnodes in this snapin).
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "util.h"
#include "riproot.h"
#include "reg.h"
#include "ripview.h"	// RIP handlers
#include "ripstats.h"
#include "routprot.h"	// IP_BOOTP


/*---------------------------------------------------------------------------
	RipRootHandler implementation
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(RipRootHandler)

extern const ContainerColumnInfo s_rgRIPParamsStatsColumnInfo[];

struct _ViewInfoColumnEntry
{
	UINT	m_ulId;
	UINT	m_cColumns;
	const ContainerColumnInfo *m_prgColumn;
};

static const struct _ViewInfoColumnEntry	s_rgViewColumnInfo[] =
{
	{ RIPSTRM_STATS_RIPPARAMS, MVR_RIPPARAMS_COUNT, s_rgRIPParamsStatsColumnInfo },
};

RipRootHandler::RipRootHandler(ITFSComponentData *pCompData)
	: RootHandler(pCompData)
{
	DEBUG_INCREMENT_INSTANCE_COUNTER(RipRootHandler)
			
	m_ConfigStream.Init(DimensionOf(s_rgViewColumnInfo));
	
    // This will initialize the view information for the statistics
    // dialogs.  (which is why the fConfigurableColumns is set to TRUE).
	for (int i=0; i<DimensionOf(s_rgViewColumnInfo); i++)
	{
		m_ConfigStream.InitViewInfo(s_rgViewColumnInfo[i].m_ulId,
                                    TRUE /*fConfigurableColumns*/,
									s_rgViewColumnInfo[i].m_cColumns,
									TRUE,
									s_rgViewColumnInfo[i].m_prgColumn);
	}
}


STDMETHODIMP RipRootHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IRtrAdviseSink)
		*ppv = &m_IRtrAdviseSink;
	else
		return RootHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;	
}


///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members

STDMETHODIMP RipRootHandler::GetClassID
(
	CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_IPXRipExtension;

    return hrOK;
}

/*!--------------------------------------------------------------------------
	RipRootHandler::OnExpand
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipRootHandler::OnExpand(ITFSNode *pNode,
								 LPDATAOBJECT pDataObject,
								 DWORD dwType,
								 LPARAM arg,
								 LPARAM lParam)
{
	HRESULT	                hr = hrOK;
	SPITFSNode			    spNode;
	SPIRtrMgrProtocolInfo	spRmProt;
    SPIRtrMgrInfo           spRm;
    SPIRouterInfo           spRouterInfo;
    LONG_PTR               ulConnId;

	// Grab the router info from the dataobject
	spRm.Query(pDataObject);
	Assert(spRm);

	spRm->GetParentRouterInfo(&spRouterInfo);

	// Setup the advise on the RtrMgr (to see when BootP is added/removed)
	spRm->RtrAdvise(&m_IRtrAdviseSink, &ulConnId, 0);

    // add things to our map for later
    AddRtrObj(ulConnId, IID_IRtrMgrInfo, spRm);
    AddScopeItem(spRm->GetMachineName(), (HSCOPEITEM) lParam);

    hr = spRm->FindRtrMgrProtocol(IPX_PROTOCOL_RIP, &spRmProt);
	if (!FHrOK(hr))
	{
		// Treat this as an already expanded node, we depend on
		// the notification mechanism to let us know if something
		// changes
		goto Error;
	}

	CORg( AddProtocolNode(pNode, spRouterInfo) );

    SetProtocolAdded(ulConnId, TRUE);
	
Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	RipRootHandler::OnCreateDataObject
		Implementation of ITFSNodeHandler::OnCreateDataObject
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RipRootHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT		    hr = hrOK;
    SPIRouterInfo   spRouterInfo;

    COM_PROTECT_TRY
	{
		// this will always be NULL
        if (spRouterInfo == NULL)
		{
			// If we haven't created the sub nodes yet, we still have to
			// create a dataobject.
			CDataObject *	pObject = NULL;
			SPIDataObject	spDataObject;
			SPITFSNode		spNode;
			SPITFSNodeHandler	spHandler;
			
			pObject = new CDataObject;
			spDataObject = pObject;	// do this so that it gets released correctly
			Assert(pObject != NULL);
			
			// Save cookie and type for delayed rendering
			pObject->SetType(type);
			pObject->SetCookie(cookie);
			
			// Store the coclass with the data object
			pObject->SetClsid(*(m_spTFSCompData->GetCoClassID()));
			
			pObject->SetTFSComponentData(m_spTFSCompData);
			
			hr = pObject->QueryInterface(IID_IDataObject, 
									 reinterpret_cast<void**>(ppDataObject));
			
		}
		else
			hr = CreateDataObjectFromRouterInfo(spRouterInfo,
												type, cookie, m_spTFSCompData,
												ppDataObject);
	}
	COM_PROTECT_CATCH;
	return hr;
}



ImplementEmbeddedUnknown(RipRootHandler, IRtrAdviseSink)

STDMETHODIMP RipRootHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
	DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
 	InitPThis(RipRootHandler, IRtrAdviseSink);
	HRESULT		    hr = hrOK;
	SPITFSNode	    spNode;
    SPIRtrMgrInfo   spRm;
    SPIRouterInfo   spRouterInfo;

	if (dwObjectType != ROUTER_OBJ_RmProt)
		return hr;

	COM_PROTECT_TRY
	{
        CORg (pThis->GetRtrObj(ulConn, (IUnknown **) &spRm));

		if (dwChangeType == ROUTER_CHILD_ADD)
		{
			// check to see if BootP is in the current list
			if (spRm->FindRtrMgrProtocol(IPX_PROTOCOL_RIP, NULL) == hrOK)
			{
				// We found Bootp, add our child node if we
				// don't have a child node
				if (!pThis->IsProtocolAdded(ulConn))
				{
                	spRm->GetParentRouterInfo(&spRouterInfo);
					pThis->m_spNodeMgr->GetRootNode(&spNode);
					pThis->AddProtocolNode(spNode, spRouterInfo);
					pThis->SetProtocolAdded(ulConn, TRUE);
				}
			}
		}
		else if (dwChangeType == ROUTER_CHILD_DELETE)
		{
			if (spRm->FindRtrMgrProtocol(IPX_PROTOCOL_RIP, NULL) == hrFalse)
			{
				// couldn't find Bootp, delete all of our child nodes
				pThis->m_spNodeMgr->GetRootNode(&spNode);
				pThis->RemoveNode(spNode, spRm->GetMachineName());
			    pThis->SetProtocolAdded(ulConn, FALSE);
			}
		}
		
        COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	
	return hr;
}

/*!--------------------------------------------------------------------------
	RipRootHandler::DestroyHandler
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP RipRootHandler::DestroyHandler(ITFSNode *pNode)
{
    RemoveAllNodes(pNode);
    RemoveAllRtrObj();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	RipRootHandler::AddProtocolNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipRootHandler::AddProtocolNode(ITFSNode *pNode, IRouterInfo * pRouterInfo)
{
	SPITFSNodeHandler	spHandler;
	RipNodeHandler *    pHandler = NULL;
	HRESULT				hr = hrOK;
	SPITFSNode			spNode;
    HSCOPEITEM          hScopeItem, hOldScopeItem;
    
    // Windows NT Bug : 246822
    // Due to the server list programming model, we need to setup
    // the proper scopeitem (so that MMC adds this to the proper
    // node).

    
    // Get the proper scope item for this node.
    // ----------------------------------------------------------------
    Verify( GetScopeItem(pRouterInfo->GetMachineName(), &hScopeItem) == hrOK);

    
    // Get the old one and save it.  place the new one in the node.
    // ----------------------------------------------------------------
    hOldScopeItem = pNode->GetData(TFS_DATA_SCOPEID);
    pNode->SetData(TFS_DATA_SCOPEID, hScopeItem);

	pHandler = new RipNodeHandler(m_spTFSCompData);
	spHandler = pHandler;
	CORg( pHandler->Init(pRouterInfo, &m_ConfigStream) );

	CreateContainerTFSNode(&spNode,
						   &GUID_IPXRipNodeType,
						   static_cast<ITFSNodeHandler *>(pHandler),
						   static_cast<ITFSResultHandler *>(pHandler),
						   m_spNodeMgr);

	// Call to the node handler to init the node data
	pHandler->ConstructNode(spNode);
				
	// Make the node immediately visible
	spNode->SetVisibilityState(TFS_VIS_SHOW);
	pNode->AddChild(spNode);

Error:
    // Restore the scope item
    pNode->SetData(TFS_DATA_SCOPEID, hOldScopeItem);
	return hr;
}


/*!--------------------------------------------------------------------------
	RipRootHandler::CompareNodeToMachineName
		This function is used by the RemoveNode() function.

        Returns hrOK if this node is a DHCP relay node and corresponds
        to the pszMachineName.
        Returns hrFalse if this is not the indicated node.
        Returns errors otherwise.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RipRootHandler::CompareNodeToMachineName(ITFSNode *pNode,
    LPCTSTR pszMachineName)
{
    HRESULT     hr = hrFalse;

    // Should check that this is a RIP node
    if (*(pNode->GetNodeType()) != GUID_IPXRipNodeType)
        hr = hrFalse;
    else
    {
        IPXConnection *  pIPXConn;
        
        pIPXConn = GET_RIP_NODEDATA(pNode);
        if (StriCmp(pszMachineName, pIPXConn->GetMachineName()) == 0)
            hr = hrOK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ripview.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    ripview.h
//
// History:
//	09/05/97	Kenn M. Takara			Created.
//
//	IPX RIP view
//
//============================================================================


#ifndef _RIPVIEW_H
#define _RIPVIEW_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _XSTREAM_H
#include "xstream.h"		// need for ColumnData
#endif

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _IPXFACE_H
#include "ipxface.h"
#endif

#ifndef _BASECON_H
#include "basecon.h"		// BaseContainerHandler
#endif

#ifndef _RIPSTRM_H
#include "ripstrm.h"
#endif

#ifndef _RTRSHEET_H
#include "rtrsheet.h"
#endif

#ifndef _IPXCONN_H
#include "ipxconn.h"			// IPXConnection
#endif

#ifndef _RIPSTATS_H_
#include "ripstats.h"
#endif

// forward declarations
struct SRipNodeMenu;

/*---------------------------------------------------------------------------
	This is the list of columns available for the IP Static Routes
	node.
		- Interface, e.g. "[1] Foobar nic..."
		- Relay mode, e.g. "Enabled"
		- Requests received
		- Replies received
		- Requests discarded
		- Replies discarded
		- Send failures
		- Receive failres
 ---------------------------------------------------------------------------*/


//
// If you ADD any columns to this enum, Be sure to update
// the string ids for the column headers in srview.cpp
//
enum
{
 	RIP_SI_INTERFACE = 0,
	RIP_SI_TYPE,
	RIP_SI_ACCEPT_ROUTES,
	RIP_SI_SUPPLY_ROUTES,
	RIP_SI_UPDATE_MODE,
	RIP_SI_UPDATE_PERIOD,
	RIP_SI_AGE_MULTIPLIER,
	RIP_SI_ADMIN_STATE,
	RIP_SI_OPER_STATE,
	RIP_SI_PACKETS_SENT,
	RIP_SI_PACKETS_RECEIVED,
	RIP_SI_MAX_COLUMNS,
};


/*---------------------------------------------------------------------------
	We store a pointer to the IPXConnection object in our node data
 ---------------------------------------------------------------------------*/

#define GET_RIP_NODEDATA(pNode) \
		(IPXConnection *) pNode->GetData(TFS_DATA_USER)
#define SET_RIP_NODEDATA(pNode, pData) \
		pNode->SetData(TFS_DATA_USER, (ULONG_PTR) pData)


/*---------------------------------------------------------------------------
	Struct:	RipListEntry
 ---------------------------------------------------------------------------*/
struct RipListEntry
{
	SPIInterfaceInfo	m_spIf;			// ptr to interface
	RIP_IF_INFO			m_info;			
	RIP_IF_STATS		m_stats;
	BOOL				m_fClient;		// TRUE if client interface
	DWORD				m_dwIfIndex;	// interface index
	BOOL				m_fFoundIfIndex;
	SPITFSNode			m_spNode;

	BOOL				m_fInfoUpdated;		// info data has been updated
};

typedef CList<RipListEntry *, RipListEntry *> RipList;



/*---------------------------------------------------------------------------
	Class:	RipNodeHandler
 ---------------------------------------------------------------------------*/

class RipNodeHandler :
		public BaseContainerHandler
{
public:
	RipNodeHandler(ITFSComponentData *pTFSCompData);

	// Override QI to handle embedded interface
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);
	
	DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)

	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_GetString();
	OVERRIDE_NodeHandler_OnCreateDataObject();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_DestroyHandler();

	OVERRIDE_BaseHandlerNotify_OnExpand();

	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_CompareItems();

	OVERRIDE_BaseResultHandlerNotify_OnResultShow();	
	
	
	// Initializes the handler
	HRESULT	Init(IRouterInfo *pRouter, RipConfigStream *pConfigStream);
	
	// Initializes the node
	HRESULT ConstructNode(ITFSNode *pNode);

public:
	// Structure used to pass data to callbacks - used as a way of
	// avoiding recomputation
	struct SMenuData
	{
		SPITFSNode			m_spNode;
	};
	
protected:
	// Refresh the data for these nodes
	HRESULT	SynchronizeNodeData(ITFSNode *pThisNode);
	HRESULT	GetRipData(ITFSNode *pThisNode, RipList *pRipList);
	HRESULT	FillInInterfaceIndex(IPXConnection *pIPXConn, RipList *pRipList);
	HRESULT	FillClientData(RipListEntry *pRipEntry);


	// Helper function to add interfaces to the UI
	HRESULT	AddInterfaceNode(ITFSNode *pParent,
							 IInterfaceInfo *pIf,
							 BOOL fClient);
	HRESULT AddProtocolToInfoBase(ITFSNode *pParent);
	HRESULT	AddProtocolToInterface(ITFSNode *pParent);

	LONG_PTR		m_ulConnId;// notification id for RtrMgrProt
	LONG_PTR		m_ulRmConnId;
	LONG_PTR		m_ulRefreshConnId;	// notification id for Refresh
	LONG_PTR		m_ulStatsConnId;
	MMC_COOKIE		m_cookie;		// cookie for the node
	SPIRtrMgrInfo	m_spRm;
	SPIRtrMgrProtocolInfo	m_spRmProt;
	RipConfigStream *	m_pConfigStream;
	CString			m_stTitle;
	BOOL			m_fProtocolIsRunning;	// TRUE if protocol is running

	RIPParamsStatistics	m_RIPParamsStats;
};





/*---------------------------------------------------------------------------
	Class:	RipInterfaceHandler

	This is the handler for the interface nodes that appear in the Rip
	node.
 ---------------------------------------------------------------------------*/

class RipInterfaceHandler : public BaseIPXResultHandler
{
public:
	RipInterfaceHandler(ITFSComponentData *pCompData);
	
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnCreateDataObject();
	
	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_OnCreateDataObject();
	OVERRIDE_ResultHandler_DestroyResultHandler();
	OVERRIDE_ResultHandler_HasPropertyPages()
			{	return hrOK;	};
	OVERRIDE_ResultHandler_CreatePropertyPages();
	
	// Initializes the node
	HRESULT ConstructNode(ITFSNode *pNode, IInterfaceInfo *pIfInfo,
						 IPXConnection *pIPXConn);
	HRESULT	Init(IInterfaceInfo *pInfo, IRouterInfo *pRouterInfo, ITFSNode *pParent);

	// Refresh the data for this node
	void RefreshInterface(MMC_COOKIE cookie);

public:
	// Structure used to pass data to callbacks - used as a way of
	// avoiding recomputation
	struct SMenuData
	{
		ULONG				m_ulMenuId;
		SPITFSNode			m_spNode;
	};
	
protected:
	LONG_PTR			m_ulConnId;
	SPIInterfaceInfo	m_spInterfaceInfo;
};





#endif _RIPVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\root.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	root.h
		Root node information (the root node is not displayed
		in the MMC framework but contains information such as 
		all of the subnodes in this snapin).
		
    FILE HISTORY:
        
*/

#ifndef _ROOT_H
#define _ROOT_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _QUERYOBJ_H
#include "queryobj.h"
#endif

#ifndef _IPXSTRM_H
#include "ipxstrm.h"
#endif

#ifndef _INFO_H
#include "info.h"
#endif

// The follow two classes are used by the protocol extension root to
// nodes map their connection ID to the appropriate Router Object.
// A Router Object may be an IRouterInfo or an IRtrMgrInfo.

// create this class so that the references get freed up correctly

class RtrObjRecord
{
public:
    RtrObjRecord()
    {
        m_fAddedProtocolNode = FALSE;
        m_fComputerAddedAsLocal = FALSE;
    }
    RtrObjRecord(RtrObjRecord & objRtrObjRecord)
    {
        *this = objRtrObjRecord;
    }

    RtrObjRecord & operator = (const RtrObjRecord & objRtrObjRecord)
    {
        if (this != &objRtrObjRecord)
        {
            m_riid = objRtrObjRecord.m_riid;
            m_spUnk.Set(objRtrObjRecord.m_spUnk.p);
            m_fAddedProtocolNode = objRtrObjRecord.m_fAddedProtocolNode;
            m_fComputerAddedAsLocal = objRtrObjRecord.m_fComputerAddedAsLocal;
        }
        
        return *this;
    }

public:
    // NOTE: the m_riid is NOT the iid of the m_spUnk.  It is used
    // as a flag to indicate the type of action to be performed
    // on the m_spUnk.
    GUID            m_riid;        
    SPIUnknown      m_spUnk;      
    BOOL            m_fAddedProtocolNode;
    BOOL            m_fComputerAddedAsLocal;
};

// hash table for RtrObjRecord records
typedef CMap<LONG_PTR, LONG_PTR, RtrObjRecord, RtrObjRecord&> RtrObjMap;


class RootHandler
		: public BaseRouterHandler, public IPersistStreamInit
{
public:
	RootHandler(ITFSComponentData *pCompData);
	virtual ~RootHandler()
			{ DEBUG_DECREMENT_INSTANCE_COUNTER(RootHandler); };

	DeclareIUnknownMembers(IMPL)
	DeclareIPersistStreamInitMembers(IMPL)

	// Basic initialization
	virtual HRESULT	Init();
			
	virtual HRESULT ConstructNode(ITFSNode *pNode);

	// Notification overrides
	OVERRIDE_BaseHandlerNotify_OnExpand() = 0;
    OVERRIDE_BaseHandlerNotify_OnRemoveChildren();

	// Handler overrides
	OVERRIDE_NodeHandler_OnCreateDataObject() = 0;

	// Access ConfigStream
	virtual ConfigStream *	GetConfigStream() = 0;

    // for RtrObj access
    HRESULT AddRtrObj(LONG_PTR ulConnId, REFIID riid, IUnknown * pUnk);
    HRESULT RemoveRtrObj(LONG_PTR ulConnId);
    HRESULT GetRtrObj(LONG_PTR ulConnId, IUnknown ** ppUnk);
    HRESULT SetProtocolAdded(LONG_PTR ulConnId, BOOL fProtocolAdded);
    BOOL    IsProtocolAdded(LONG_PTR ulConnId);
    HRESULT SetComputerAddedAsLocal(LONG_PTR ulConnId, BOOL fAddedAsLocal);
    BOOL    IsComputerAddedAsLocal(LONG_PTR ulConnId);
    HRESULT RemoveAllRtrObj();

    // For the machine-name to scopeitem map

    HRESULT AddScopeItem(LPCTSTR pszMachineName, HSCOPEITEM hScopeItem);
    HRESULT GetScopeItem(LPCTSTR pszMachineName, HSCOPEITEM *phScopeItem);
    HRESULT RemoveScopeItem(HSCOPEITEM hScopeItem);

    // For the HSCOPEITEM to cookie map
    HRESULT AddCookie(HSCOPEITEM hScopeItem, MMC_COOKIE cookie);
    HRESULT GetCookie(HSCOPEITEM hScopeItem, MMC_COOKIE *pCookie);
    HRESULT RemoveCookie(HSCOPEITEM hScopeItem);

    // Useful function to remove a node.  The CompareNodeToMachineName()
    // function must be implemted in order for this to be used.
    HRESULT RemoveNode(ITFSNode *pNode, LPCTSTR pszMachineName);
    virtual HRESULT CompareNodeToMachineName(ITFSNode *pNode, LPCTSTR pszName);

    // Removes all nodes
    HRESULT RemoveAllNodes(ITFSNode *pNode);
    
protected:
	SPITFSComponentData	m_spTFSCompData;
    
    // maps a refresh connection id to an RtrObj ptr
    // This is needed by the refresh code (it gets a conn id).
    RtrObjMap           m_mapRtrObj;
    
    // maps a machine name to an HSCOPEITEM
    // Needed to differentiate among the various nodes.
    CMapStringToPtr     m_mapScopeItem;
    
    // maps a HSCOPEITEM to a node (or a cookie)
    // This is used by the OnRemoveChildren() code (so that
    // the correct node gets removed).
    CMapPtrToPtr        m_mapNode;
};





#endif _ROOT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\root.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	root.cpp
		Root node information (the root node is not displayed
		in the MMC framework but contains information such as 
		all of the subnodes in this snapin).
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "util.h"
#include "root.h"
#include "reg.h"


/*---------------------------------------------------------------------------
	RootHandler implementation
 ---------------------------------------------------------------------------*/

IMPLEMENT_ADDREF_RELEASE(RootHandler)

DEBUG_DECLARE_INSTANCE_COUNTER(RootHandler)

HRESULT RootHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IPersistStreamInit)
		*ppv = (IPersistStreamInit *) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return BaseRouterHandler::QueryInterface(riid, ppv);
}

RootHandler::RootHandler(ITFSComponentData *pCompData)
	: BaseRouterHandler(pCompData)
{
	m_spTFSCompData.Set(pCompData);
	DEBUG_INCREMENT_INSTANCE_COUNTER(RootHandler)
}

HRESULT RootHandler::Init()
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	RootHandler::ConstructNode
		Initializes the root node (sets it up).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RootHandler::ConstructNode(ITFSNode *pNode)
{
	HRESULT			hr = hrOK;
	
	if (pNode == NULL)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Need to initialize the data for the root node
		pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_FOLDER_CLOSED);
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_FOLDER_OPEN);
		pNode->SetData(TFS_DATA_SCOPEID, 0);

		pNode->SetData(TFS_DATA_COOKIE, 0);
	}
	COM_PROTECT_CATCH

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members

STDMETHODIMP RootHandler::GetClassID
(
	CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_IPXAdminExtension;

    return hrOK;
}

STDMETHODIMP RootHandler::IsDirty()
{
	SPITFSNode	spNode;

	m_spTFSCompData->GetRootNode(&spNode);
	return (spNode->GetData(TFS_DATA_DIRTY) || GetConfigStream()->GetDirty()) ? hrOK : hrFalse;
}

STDMETHODIMP RootHandler::Load
(
	IStream *pStm
)
{
	Assert(pStm);
	HRESULT	hr = hrOK;
	CString	st;
	BOOL	fServer;
	
	COM_PROTECT_TRY
	{
		hr = GetConfigStream()->LoadFrom(pStm);
	}
	COM_PROTECT_CATCH;
	return hr;
}


STDMETHODIMP RootHandler::Save
(
	IStream *pStm, 
	BOOL	 fClearDirty
)
{
	HRESULT hr = S_OK;
	SPITFSNode	spNode;

	Assert(pStm);

	COM_PROTECT_TRY
	{
		if (fClearDirty)
		{
			m_spTFSCompData->GetRootNode(&spNode);
			spNode->SetData(TFS_DATA_DIRTY, FALSE);
		}
		
		hr = GetConfigStream()->SaveTo(pStm);
	}
	COM_PROTECT_CATCH;
	return hr;
}


STDMETHODIMP RootHandler::GetSizeMax
(
	ULARGE_INTEGER *pcbSize
)
{
	ULONG	cbSize;
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{	
		hr = GetConfigStream()->GetSize(&cbSize);
		if (FHrSucceeded(hr))
		{
			pcbSize->HighPart = 0;
			pcbSize->LowPart = cbSize;
		}
	}
	COM_PROTECT_CATCH;
	return hr;

}

STDMETHODIMP RootHandler::InitNew()
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		hr = GetConfigStream()->InitNew();
	}
	COM_PROTECT_CATCH;
	return hr;
}




// for RtrMgrInfo access
HRESULT RootHandler::AddRtrObj(LONG_PTR ulConnId, REFIID riid, IUnknown * pRtrObj)
{
    HRESULT     hr = hrOK;
    RtrObjRecord      rtrObj;

    COM_PROTECT_TRY
    {
        if (m_mapRtrObj.Lookup(ulConnId, rtrObj))
        {
            // connection id already in the list.
            Trace1("RootHandler::AddRtrObj - %lx already in the list!", ulConnId);
            return E_INVALIDARG;
        }

        rtrObj.m_riid = riid;
        rtrObj.m_spUnk.Set(pRtrObj);

        m_mapRtrObj.SetAt(ulConnId, rtrObj);
    }
    COM_PROTECT_CATCH

    return hr;
}

HRESULT RootHandler::RemoveRtrObj(LONG_PTR ulConnId)
{
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {
        if (m_mapRtrObj.RemoveKey(ulConnId) == 0)
        {
            // element not in the list
            Trace1("RootHandler::RemoveRtrObj - %lx not in the list!", ulConnId);
            return E_INVALIDARG;
        }
    }
    COM_PROTECT_CATCH

    return hr;
}

HRESULT RootHandler::GetRtrObj(LONG_PTR ulConnId, IUnknown ** ppRtrObj)
{
    HRESULT     hr = hrOK;
    RtrObjRecord  rtrObj;

    COM_PROTECT_TRY
    {
        if (m_mapRtrObj.Lookup(ulConnId, rtrObj) == 0)
        {
            // entry not in the list
            Trace1("RootHandler::GetRtrObj - %lx not in the list!", ulConnId);
            return E_INVALIDARG;
        }

        if (ppRtrObj)
        {
            *ppRtrObj = rtrObj.m_spUnk;
            (*ppRtrObj)->AddRef();
        }
    }
    COM_PROTECT_CATCH

    return hr;
}


HRESULT RootHandler::SetProtocolAdded(LONG_PTR ulConnId, BOOL fProtocolAdded)
{
    HRESULT     hr = hrOK;
    RtrObjRecord  rtrObj;

    COM_PROTECT_TRY
    {
        if (m_mapRtrObj.Lookup(ulConnId, rtrObj) == 0)
        {
            // entry not in the list
            Trace1("RootHandler::SetProtocolAdded - %lx not in the list!", ulConnId);
            return E_INVALIDARG;
        }

        rtrObj.m_fAddedProtocolNode = fProtocolAdded;

        m_mapRtrObj.SetAt(ulConnId, rtrObj);
    }
    COM_PROTECT_CATCH

    return hr;
}

BOOL RootHandler::IsProtocolAdded(LONG_PTR ulConnId)
{
    HRESULT     hr = hrOK;
    RtrObjRecord  rtrObj;
    BOOL        bAdded = FALSE;

    COM_PROTECT_TRY
    {
        if (m_mapRtrObj.Lookup(ulConnId, rtrObj) == 0)
        {
            // entry not in the list
            Trace1("RootHandler::IsProtocolAdded - %lx not in the list!", ulConnId);
            return bAdded;
        }

        bAdded = rtrObj.m_fAddedProtocolNode;
    }
    COM_PROTECT_CATCH

    return bAdded;
}

HRESULT RootHandler::RemoveAllRtrObj()
{
    HRESULT     hr = hrOK;
    POSITION    pos;
    RtrObjRecord  rtrObj;
	LONG_PTR	ulKey;

    COM_PROTECT_TRY
    {
        pos = m_mapRtrObj.GetStartPosition();
        while (pos)
        {
            m_mapRtrObj.GetNextAssoc(pos, ulKey, rtrObj);

            if (rtrObj.m_riid == IID_IRtrMgrInfo)
            {
                SPIRtrMgrInfo   spRm;
                
                Verify( FHrOK(spRm.HrQuery(rtrObj.m_spUnk)) );
                spRm->RtrUnadvise(ulKey);
            }
            else if (rtrObj.m_riid == IID_IRouterInfo)
            {
                SPIRouterInfo   spRouter;
                Verify( FHrOK(spRouter.HrQuery(rtrObj.m_spUnk)) );
                spRouter->RtrUnadvise(ulKey);
            }
            else if (rtrObj.m_riid == IID_IRouterRefresh)
            {
                SPIRouterInfo   spRouter;
                SPIRouterRefresh    spRefresh;
                
                Verify( FHrOK(spRouter.HrQuery(rtrObj.m_spUnk)) );

                Verify( FHrOK(spRouter->GetRefreshObject(&spRefresh)) );

                if (ulKey)
                    spRefresh->UnadviseRefresh(ulKey);
            }
            else
            {
                Panic0("Unknown type in RtrObjMap!");
            }
        }
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	RootHandler::AddScopeItem
		This will add the hScopeItem into the map (using the pszMachineName
        as the key).
        If the machine name already exists, then the hScopeItem entry is
        overwritten.

        This is added so that we can differentiate between the various
        nodes (in the mulitple instance case).        
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RootHandler::AddScopeItem(LPCTSTR pszMachineName, HSCOPEITEM hScopeItem)
{
    HRESULT     hr = hrOK;

    Assert(pszMachineName);
    
    COM_PROTECT_TRY
    {
        m_mapScopeItem.SetAt(pszMachineName, (LPVOID) hScopeItem);
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
	RootHandler::GetScopeItem
		Looks up the scope item associated with this machine name.

        Returns hrOK if a scope item is found.
        Returns hrFalse if there is no scope item for this name.
        Returns else otherwise.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RootHandler::GetScopeItem(LPCTSTR pszMachineName, HSCOPEITEM *phScopeItem)
{
    HRESULT     hr = hrFalse;
    LPVOID      pv;
    
    Assert(phScopeItem);

    *phScopeItem = NULL;
    
    if (m_mapScopeItem.Lookup(pszMachineName, pv))
    {
        *phScopeItem = (HSCOPEITEM) pv;
        hr = hrOK;
    }
    
    return hr;
}


/*!--------------------------------------------------------------------------
	RootHandler::RemoveScopeItem
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RootHandler::RemoveScopeItem(HSCOPEITEM hScopeItem)
{
    HRESULT     hr = hrFalse;
    CString     stKey;
    POSITION    pos = NULL;
    LPVOID      pv = NULL;

    for (pos = m_mapScopeItem.GetStartPosition(); pos != NULL; )
    {
        stKey.Empty();
        pv = NULL;
        
        m_mapScopeItem.GetNextAssoc(pos, stKey, pv);

        if ((HSCOPEITEM) pv == hScopeItem)
        {
            Trace2("Removing (%s,%x)\n", (LPCTSTR) stKey, hScopeItem);
            m_mapScopeItem.RemoveKey(stKey);
            hr = hrOK;
            break;
        }
    }
    
    return hr;
}


HRESULT RootHandler::SetComputerAddedAsLocal(LONG_PTR ulConnId, BOOL fComputerAddedAsLocal)
{
    HRESULT     hr = hrOK;
    RtrObjRecord  rtrObj;

    COM_PROTECT_TRY
    {
        if (m_mapRtrObj.Lookup(ulConnId, rtrObj) == 0)
        {
            // entry not in the list
            Trace1("RootHandler::SetComputerAddedAsLocal - %lx not in the list!", ulConnId);
            return E_INVALIDARG;
        }

        rtrObj.m_fComputerAddedAsLocal = fComputerAddedAsLocal;

        m_mapRtrObj.SetAt(ulConnId, rtrObj);
    }
    COM_PROTECT_CATCH

    return hr;
}

BOOL RootHandler::IsComputerAddedAsLocal(LONG_PTR ulConnId)
{
    HRESULT     hr = hrOK;
    RtrObjRecord  rtrObj;
    BOOL        bAdded = FALSE;

    COM_PROTECT_TRY
    {
        if (m_mapRtrObj.Lookup(ulConnId, rtrObj) == 0)
        {
            // entry not in the list
            Trace1("RootHandler::IsComputerAddedAsLocal - %lx not in the list!", ulConnId);
            return bAdded;
        }

        bAdded = rtrObj.m_fComputerAddedAsLocal;
    }
    COM_PROTECT_CATCH

    return bAdded;
}


/*!--------------------------------------------------------------------------
	RootHandler::AddCookie
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RootHandler::AddCookie(HSCOPEITEM hScopeItem, MMC_COOKIE cookie)
{
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {
        m_mapNode.SetAt((LPVOID) hScopeItem, (LPVOID) cookie);
    }
    COM_PROTECT_CATCH;
    
    return hr;
}

/*!--------------------------------------------------------------------------
	RootHandler::GetCookie
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RootHandler::GetCookie(HSCOPEITEM hScopeItem, MMC_COOKIE *pCookie)
{
    HRESULT     hr = hrFalse;
    LPVOID      pv;
    
    *pCookie = NULL;
    
    if (m_mapNode.Lookup((LPVOID) hScopeItem, pv))
    {
        *pCookie = (MMC_COOKIE) pv;
        hr = hrOK;
    }
    
    return hr;
}

/*!--------------------------------------------------------------------------
	RootHandler::RemoveCookie
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RootHandler::RemoveCookie(HSCOPEITEM hScopeItem)
{
    HRESULT     hr = hrOK;
    
    if (m_mapNode.RemoveKey((LPVOID) hScopeItem) == 0)
        hr = hrFalse;
    
    return hr;
}



/*!--------------------------------------------------------------------------
	RootHandler::CompareNodeToMachineName
		Dummy function.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RootHandler::CompareNodeToMachineName(ITFSNode *pNode,
                                              LPCTSTR pszMachineName)
{
    Panic0("This should be overriden!");
    return hrFalse;
}

/*!--------------------------------------------------------------------------
	RootHandler::RemoveNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RootHandler::RemoveNode(ITFSNode *pNode,
                                LPCTSTR pszMachineName)
{
	Assert(pNode);

	SPITFSNodeEnum	spNodeEnum;
	SPITFSNode		spNode;
	HRESULT			hr = hrOK;

    // Windows NT Bug : 246822
    // Due to the server list programming model, we need to setup
    // the proper scopeitem (so that MMC adds this to the proper
    // node).    
    // Get the proper scope item for this node.
    // ----------------------------------------------------------------
    HSCOPEITEM      hScopeItem = 0;
    HSCOPEITEM      hOldScopeItem = 0;
    
    Verify( GetScopeItem(pszMachineName, &hScopeItem) == hrOK);

    // Get the old one and save it.  place the new one in the node.
    // ----------------------------------------------------
    hOldScopeItem = pNode->GetData(TFS_DATA_SCOPEID);
    pNode->SetData(TFS_DATA_SCOPEID, hScopeItem);
    
	CORg( pNode->GetEnum(&spNodeEnum) );

    for (; spNodeEnum->Next(1, &spNode, NULL) == hrOK; spNode.Release())
	{
        if (CompareNodeToMachineName(spNode, pszMachineName) == hrOK)
        {
            pNode->RemoveChild(spNode);
            spNode->Destroy();
            break;
        }
	}

Error:
    pNode->SetData(TFS_DATA_SCOPEID, hOldScopeItem);
	return hr;
}

/*!--------------------------------------------------------------------------
	RootHandler::RemoveAllNodes
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RootHandler::RemoveAllNodes(ITFSNode *pNode)
{
	Assert(pNode);

	SPITFSNodeEnum	spNodeEnum;
	SPITFSNode		spNode;
	HRESULT			hr = hrOK;

	CORg( pNode->GetEnum(&spNodeEnum) );

    for (; spNodeEnum->Next(1, &spNode, NULL) == hrOK; spNode.Release())
	{
        pNode->RemoveChild(spNode);
        spNode->Destroy();
	}

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	RootHandler::OnRemoveChildren
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT RootHandler::OnRemoveChildren(ITFSNode *pNode,
                                      LPDATAOBJECT pdo,
                                      LPARAM arg,
                                      LPARAM lParam)
{
    MMC_COOKIE  cookie;
    HRESULT     hr = hrOK;
    SPITFSNode  spChild;
    
    // Map the scopeitem to the cookie
    // ----------------------------------------------------------------
    if ( FHrOK(GetCookie((HSCOPEITEM) arg, &cookie)) )
    {
        // Remove this node
        // --------------------------------------------------------
        m_spNodeMgr->FindNode(cookie, &spChild);

        Assert(spChild);
        if (spChild)
        {
            pNode->RemoveChild(spChild);
            spChild->Destroy();
            spChild.Release();

            RemoveScopeItem((HSCOPEITEM) arg);
            RemoveCookie((HSCOPEITEM) arg);
        }
            
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\rtfltdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       rtfltdlg.h
//
//--------------------------------------------------------------------------

// RtFltDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRouteFltDlg dialog

class CRouteFltDlg : public CBaseDialog
{
// Construction
public:
	CRouteFltDlg(BOOL bOutputDlg, IInfoBase *pInfoBase, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CRouteFltDlg)
	enum { 
			IDD_INPUT = IDD_ROUTE_FILTERS_INPUT,
			IDD_OUTPUT = IDD_ROUTE_FILTERS_OUTPUT 
		};
		
	CListCtrl	m_FilterList;
	BOOL	m_fActionDeny;		// TRUE==deny, FALSE==permit
	//}}AFX_DATA
	SPIInfoBase		m_spInfoBase;
    CString         m_sIfName;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRouteFltDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	static DWORD	m_dwHelpMap[];
    BOOL            m_bOutput;

	// Generated message map functions
	//{{AFX_MSG(CRouteFltDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnAdd();
	afx_msg void OnDelete();
	afx_msg void OnEdit();
	afx_msg void OnOK();
	afx_msg void OnItemchangedFilterList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnListDblClk(NMHDR *pNmHdr, LRESULT *pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CRouteFilter dialog

class CRouteFilter : public CBaseDialog
{
// Construction
public:
	CRouteFilter(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CRouteFilter)
	enum { IDD = IDD_ROUTE_FILTER };
	CString	m_sIfName;
	CString	m_sNetMask;
	CString	m_sNetwork;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRouteFilter)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	static DWORD	m_dwHelpMap[];

	// Generated message map functions
	//{{AFX_MSG(CRouteFilter)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\rtfltdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       rtfltdlg.cpp
//
//--------------------------------------------------------------------------

// RtFltDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ipxadmin.h"
#include "ipxutil.h"
#include "listctrl.h"
#include "RtFltDlg.h"

extern "C"
{
#include "routprot.h"
};
//nclude "rtradmin.hm"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRouteFltDlg dialog


CRouteFltDlg::CRouteFltDlg(BOOL bOutputDlg, IInfoBase *pInfoBase,
						   CWnd* pParent /*=NULL*/)
	: CBaseDialog( (bOutputDlg ? CRouteFltDlg::IDD_OUTPUT : CRouteFltDlg::IDD_INPUT), pParent),
	m_bOutput(bOutputDlg)
{
	//{{AFX_DATA_INIT(CRouteFltDlg)
	m_fActionDeny = FALSE;
	//}}AFX_DATA_INIT
	m_spInfoBase.Set(pInfoBase);

//	SetHelpMap(m_dwHelpMap);
}


void CRouteFltDlg::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRouteFltDlg)
	DDX_Control(pDX, IDC_RFS_LIST, m_FilterList);
	DDX_Radio(pDX, IDC_RFS_BTN_DENY, m_fActionDeny);
	//}}AFX_DATA_MAP
	
	if (pDX->m_bSaveAndValidate)
	{
		PRIP_ROUTE_FILTER_INFO  pFltInfo;
		UINT                    count;
		UINT                    i;
		DWORD					dwSize;
		PRIP_IF_CONFIG	pRipIfCfg = NULL;
		
		// Grab the RIP_IF_CONFIG
		m_spInfoBase->GetData(IPX_PROTOCOL_RIP, 0, (PBYTE *) &pRipIfCfg);
		Assert(pRipIfCfg);
	
		count = m_FilterList.GetItemCount ();
		if (m_bOutput)
		{
			if (count != pRipIfCfg->RipIfFilters.SupplyFilterCount)
			{
				dwSize = FIELD_OFFSET (
							RIP_IF_CONFIG,
							RipIfFilters.RouteFilter[count
								+pRipIfCfg->RipIfFilters.ListenFilterCount]);
				
				PRIP_IF_CONFIG  pNewConfig = 
					(PRIP_IF_CONFIG) new BYTE[dwSize];

				if (pNewConfig==NULL)
					AfxThrowMemoryException();
				
				memcpy (pNewConfig, pRipIfCfg,
						FIELD_OFFSET (RIP_IF_CONFIG, RipIfFilters.RouteFilter));
				memcpy (&pNewConfig->RipIfFilters.RouteFilter[count],
						&pRipIfCfg->RipIfFilters.RouteFilter[
							pRipIfCfg->RipIfFilters.SupplyFilterCount],
						sizeof (RIP_ROUTE_FILTER_INFO)
						*pRipIfCfg->RipIfFilters.ListenFilterCount);
				
				pNewConfig->RipIfFilters.SupplyFilterCount = count;

				m_spInfoBase->SetData(IPX_PROTOCOL_RIP,
									  dwSize,
									  (BYTE *) pNewConfig,
									  1,
									  0
									 );
				pRipIfCfg = pNewConfig;
			}
			pRipIfCfg->RipIfFilters.SupplyFilterAction = m_fActionDeny ?
					IPX_ROUTE_FILTER_DENY : IPX_ROUTE_FILTER_PERMIT;
			pFltInfo = &pRipIfCfg->RipIfFilters.RouteFilter[0];
		}
		else
		{
			if (count != pRipIfCfg->RipIfFilters.ListenFilterCount)
			{
				dwSize = FIELD_OFFSET (
							RIP_IF_CONFIG,
							RipIfFilters.RouteFilter[
								count
								+pRipIfCfg->RipIfFilters.SupplyFilterCount]);
				PRIP_IF_CONFIG  pNewConfig = 
					(PRIP_IF_CONFIG) new BYTE[dwSize];

				if (pNewConfig==NULL)
					AfxThrowMemoryException();
				
				memcpy (pNewConfig, pRipIfCfg,
					FIELD_OFFSET (RIP_IF_CONFIG, RipIfFilters.RouteFilter));
				
				memcpy (&pNewConfig->RipIfFilters.RouteFilter[0],
						&pRipIfCfg->RipIfFilters.RouteFilter[0],
						sizeof (RIP_ROUTE_FILTER_INFO)
						*pRipIfCfg->RipIfFilters.SupplyFilterCount);
				
				pNewConfig->RipIfFilters.ListenFilterCount = count;
				
				m_spInfoBase->SetData(IPX_PROTOCOL_RIP,
									  dwSize,
									  (BYTE *) pNewConfig,
									  1,
									  0
									 );
				pRipIfCfg = pNewConfig;
			}

			pRipIfCfg->RipIfFilters.ListenFilterAction = m_fActionDeny ?
					IPX_ROUTE_FILTER_DENY : IPX_ROUTE_FILTER_PERMIT;
			
			pFltInfo = &pRipIfCfg->RipIfFilters.RouteFilter[
					   pRipIfCfg->RipIfFilters.SupplyFilterCount];
		}
		
		for (i=0; i<count; i++) {
			CString     aStr;
			aStr = m_FilterList.GetItemText (i, 0);

			ConvertNetworkNumberToBytes(aStr,
										pFltInfo[i].Network,
										sizeof(pFltInfo[i].Network));
			aStr = m_FilterList.GetItemText (i, 1);
			ConvertNetworkNumberToBytes(aStr,
										pFltInfo[i].Mask,
										sizeof(pFltInfo[i].Mask));
		}
	}
}


BEGIN_MESSAGE_MAP(CRouteFltDlg, CBaseDialog)
	//{{AFX_MSG_MAP(CRouteFltDlg)
	ON_BN_CLICKED(IDC_RFS_BTN_ADD, OnAdd)
	ON_BN_CLICKED(IDC_RFS_BTN_DELETE, OnDelete)
	ON_BN_CLICKED(IDC_RFS_BTN_EDIT, OnEdit)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_RFS_LIST, OnItemchangedFilterList)
    ON_NOTIFY(NM_DBLCLK, IDC_RFS_LIST, OnListDblClk)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

DWORD CRouteFltDlg::m_dwHelpMap[] =
{
//	IDC_DENY, HIDC_DENY,
//	IDC_PERMIT, HIDC_PERMIT,
//	IDC_FILTER_LIST, HIDC_FILTER_LIST,
//	IDC_ADD, HIDC_ADD,
//	IDC_EDIT, HIDC_EDIT,
//	IDC_DELETE, HIDC_DELETE,
	0,0
};

/////////////////////////////////////////////////////////////////////////////
// CRouteFltDlg message handlers

BOOL CRouteFltDlg::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString     aStr;
	PRIP_IF_CONFIG	pRipIfCfg = NULL;


    CBaseDialog::OnInitDialog();

    if (m_bOutput)
        aStr.FormatMessage (IDS_ROUTEFILTER_OUTPUT_CAP, (LPCTSTR)m_sIfName);
    else
        aStr.FormatMessage (IDS_ROUTEFILTER_INPUT_CAP, (LPCTSTR)m_sIfName);

	SetWindowText (aStr);

	    // Get the current window style. 
    DWORD dwStyle = GetWindowLong(m_FilterList.m_hWnd, GWL_STYLE); 
 
    // Only set the window style if the view bits have changed. 
    if ((dwStyle & LVS_TYPEMASK) != LVS_REPORT) 
        SetWindowLong(m_FilterList.m_hWnd, GWL_STYLE, 
            (dwStyle & ~LVS_TYPEMASK) | LVS_REPORT); 
    ListView_SetExtendedListViewStyle(m_FilterList.m_hWnd,
                            LVS_EX_FULLROWSELECT|LVS_EX_HEADERDRAGDROP);
    VERIFY (aStr.LoadString (IDS_ROUTEFILTER_NETWORK_HDR));
    VERIFY (m_FilterList.InsertColumn (0, aStr)!=-1);
    AdjustColumnWidth (m_FilterList, 0, aStr);
    VERIFY (aStr.LoadString (IDS_ROUTEFILTER_NETMASK_HDR));
    VERIFY (m_FilterList.InsertColumn (1, aStr)!=-1);
    AdjustColumnWidth (m_FilterList, 1, aStr);


    PRIP_ROUTE_FILTER_INFO  pFltInfo;
    UINT                    count;
    UINT                    i, item;

	// Grab the RIP_IF_CONFIG
	m_spInfoBase->GetData(IPX_PROTOCOL_RIP, 0, (PBYTE *) &pRipIfCfg);
	Assert(pRipIfCfg);
	
    if (m_bOutput)
	{
		pFltInfo = &pRipIfCfg->RipIfFilters.RouteFilter[0];
		count = pRipIfCfg->RipIfFilters.SupplyFilterCount;
		if (count>0)
			m_fActionDeny = (pRipIfCfg->RipIfFilters.SupplyFilterAction == IPX_ROUTE_FILTER_DENY);
    }
    else
	{
        pFltInfo = &pRipIfCfg->RipIfFilters.RouteFilter[
                            pRipIfCfg->RipIfFilters.SupplyFilterCount];
        count = pRipIfCfg->RipIfFilters.ListenFilterCount;
        if (count>0)
			m_fActionDeny = (pRipIfCfg->RipIfFilters.ListenFilterAction == IPX_ROUTE_FILTER_DENY);
    }

    for (i=0; i<count; i++) {
		TCHAR	szBuffer[32];
		FormatIpxNetworkNumber(szBuffer, DimensionOf(szBuffer),
						   pFltInfo[i].Network, sizeof(pFltInfo[i].Network));

        VERIFY ((item=m_FilterList.InsertItem (LVIF_TEXT|LVIF_PARAM,
                                i, szBuffer,
                                0, 0, 0,
                                (LPARAM)i))!=-1);
		
		FormatIpxNetworkNumber(szBuffer, DimensionOf(szBuffer),
							   pFltInfo[i].Mask, sizeof(pFltInfo[i].Mask));
        VERIFY (m_FilterList.SetItemText (item, 1, szBuffer));
    }

    OnItemchangedFilterList(NULL, NULL);

    UpdateData (FALSE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
void CRouteFltDlg::OnAdd() 
{
    CRouteFilter    dlgFlt (this);
    dlgFlt.m_sIfName = m_sIfName;
    if (dlgFlt.DoModal ()==IDOK) {
        UINT    item;
   		RIP_ROUTE_FILTER_INFO  FltInfo;

   		// make sure we shoule the right thing
		ConvertNetworkNumberToBytes(dlgFlt.m_sNetwork,
									FltInfo.Network,
									sizeof(FltInfo.Network));
		ConvertNetworkNumberToBytes(dlgFlt.m_sNetMask,
									FltInfo.Mask,
									sizeof(FltInfo.Mask));

        UINT    count = m_FilterList.GetItemCount ();
		TCHAR	szBuffer[32];
		FormatIpxNetworkNumber(szBuffer, DimensionOf(szBuffer),
						   FltInfo.Network, sizeof(FltInfo.Network));

        VERIFY ((item=m_FilterList.InsertItem (LVIF_TEXT|LVIF_PARAM,
                                count, szBuffer,
                                0, 0, 0,
                                (LPARAM)count))!=-1);
		
		FormatIpxNetworkNumber(szBuffer, DimensionOf(szBuffer),
							   FltInfo.Mask, sizeof(FltInfo.Mask));
        VERIFY (m_FilterList.SetItemText (item, 1, szBuffer));
    }

	// Want to keep m_fActionDeny same over update
	m_fActionDeny = (BOOL ) GetDlgItem(IDC_RFS_BTN_PERMIT)->SendMessage(BM_GETCHECK, NULL, NULL);

	UpdateData (FALSE);

    SetFocus();
}

void CRouteFltDlg::OnDelete() 
{
    UINT    item;
    VERIFY ((item=m_FilterList.GetNextItem (-1, LVNI_ALL|LVNI_SELECTED))!=-1);
    VERIFY (m_FilterList.DeleteItem	(item));

	// Want to keep m_fActionDeny same over update
	m_fActionDeny = (BOOL) GetDlgItem(IDC_RFS_BTN_PERMIT)->SendMessage(BM_GETCHECK, NULL, NULL);
    UpdateData (FALSE);

    SetFocus();
}


void CRouteFltDlg::OnListDblClk(NMHDR *pNmHdr, LRESULT *pResult)
{
    if (m_FilterList.GetNextItem(-1, LVNI_SELECTED) == -1)
        return;
    
    OnEdit();
    *pResult = 0;
}

void CRouteFltDlg::OnEdit() 
{
    UINT    item;
    CRouteFilter    dlgFlt (this);
    VERIFY ((item=m_FilterList.GetNextItem (-1, LVNI_ALL|LVNI_SELECTED))!=-1);
    dlgFlt.m_sIfName = m_sIfName;
    dlgFlt.m_sNetwork = m_FilterList.GetItemText (item, 0);
    dlgFlt.m_sNetMask = m_FilterList.GetItemText (item, 1);
    if (dlgFlt.DoModal ()==IDOK) {
        VERIFY (m_FilterList.SetItemText (item, 0, dlgFlt.m_sNetwork));
        VERIFY (m_FilterList.SetItemText (item, 1, dlgFlt.m_sNetMask));

		// Want to keep m_fActionDeny same over update
		m_fActionDeny = (BOOL)GetDlgItem(IDC_RFS_BTN_PERMIT)->SendMessage(BM_GETCHECK, NULL, NULL);
        UpdateData (FALSE);
    }

    SetFocus();
}

void CRouteFltDlg::OnOK()
{
	DWORD	dwCount;
	HRESULT hr = hrOK;

	m_fActionDeny = (BOOL)GetDlgItem(IDC_RFS_BTN_PERMIT)->SendMessage(BM_GETCHECK, NULL, NULL);
	dwCount = (DWORD) m_FilterList.GetItemCount();

	if (!dwCount && m_fActionDeny )
	{
		if (m_bOutput)
			AfxMessageBox(IDS_TRANSMIT_NO_RIP, MB_OK);
		else
			AfxMessageBox(IDS_RECEIVE_NO_RIP, MB_OK);
		return;
	}

	CBaseDialog::OnOK();
}

void CRouteFltDlg::OnItemchangedFilterList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    if (m_FilterList.GetNextItem (-1, LVNI_ALL|LVNI_SELECTED)!=-1) {
        GetDlgItem (IDC_RFS_BTN_EDIT)->EnableWindow (TRUE);
        GetDlgItem (IDC_RFS_BTN_DELETE)->EnableWindow (TRUE);
    }
    else {
        GetDlgItem (IDC_RFS_BTN_EDIT)->EnableWindow (FALSE);
        GetDlgItem (IDC_RFS_BTN_DELETE)->EnableWindow (FALSE);
    }

    if (pResult)
        *pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CRouteFilter dialog


CRouteFilter::CRouteFilter(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CRouteFilter::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRouteFilter)
	m_sIfName = _T("");
	m_sNetMask = _T("");
	m_sNetwork = _T("");
	//}}AFX_DATA_INIT

//	SetHelpMap(m_dwHelpMap);
}


void CRouteFilter::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRouteFilter)
	DDX_Text(pDX, IDC_RF_EDIT_INTERFACE, m_sIfName);
	DDX_Text(pDX, IDC_RF_EDIT_NETMASK, m_sNetMask);
	DDV_MaxChars(pDX, m_sNetMask, 8);
	DDX_Text(pDX, IDC_RF_EDIT_NETWORK, m_sNetwork);
	DDV_MaxChars(pDX, m_sNetwork, 8);
	//}}AFX_DATA_MAP
    if (pDX->m_bSaveAndValidate) {
        try {
            RIP_ROUTE_FILTER_INFO   RtFltInfo;
            pDX->PrepareEditCtrl (IDC_RF_EDIT_NETWORK);
			ConvertNetworkNumberToBytes(m_sNetwork,
										RtFltInfo.Network,
										sizeof(RtFltInfo.Network));
            pDX->PrepareEditCtrl (IDC_RF_EDIT_NETMASK);

			ConvertNetworkNumberToBytes(m_sNetMask,
										RtFltInfo.Mask,
										sizeof(RtFltInfo.Mask));
            if (((*((UNALIGNED ULONG *)RtFltInfo.Network))
                    &(*((UNALIGNED ULONG *)RtFltInfo.Mask)))
                    !=(*((UNALIGNED ULONG *)RtFltInfo.Network))) {
                AfxMessageBox (IDS_ERR_INVALID_ROUTE_FILTER);
                throw (DWORD)ERROR_INVALID_DATA;
            }
        }
        catch (DWORD error) {
            if (error==ERROR_INVALID_DATA)
                pDX->Fail ();
            else
                throw;
        }
    }
}


BEGIN_MESSAGE_MAP(CRouteFilter, CBaseDialog)
	//{{AFX_MSG_MAP(CRouteFilter)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

DWORD CRouteFilter::m_dwHelpMap[] = 
{
//	IDC_INTERFACE, HIDC_INTERFACE,
//	IDC_NETWORK, HIDC_NETWORK,
//	IDC_NETMASK, HIDC_NETMASK,
	0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\sapcomp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	csmplsnp.cpp
		This file contains the derived classes for CComponent and 
		CComponentData.  Most of these functions are pure virtual 
		functions that need to be overridden for snapin functionality.
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "sapcomp.h"
#include "saproot.h"
//nclude <atlimpl.cpp>
#include "sapstrm.h"
#include "sapview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/*---------------------------------------------------------------------------
	CSapComponent
 ---------------------------------------------------------------------------*/



/////////////////////////////////////////////////////////////////////////////
// CSapComponent implementation

CSapComponent::CSapComponent()
{
	extern const ContainerColumnInfo	s_rgSapViewColumnInfo[];

	m_ComponentConfig.Init(SAP_COLUMNS_MAX_COUNT);

	m_ComponentConfig.InitViewInfo(SAP_COLUMNS,
                                   FALSE /*fConfigurableColumns*/,
								   SAP_SI_MAX_COLUMNS,
								   TRUE,
								   s_rgSapViewColumnInfo);
	
	m_ulUserData = reinterpret_cast<LONG_PTR>(&m_ComponentConfig);
}

CSapComponent::~CSapComponent()
{
}

STDMETHODIMP_(ULONG) CSapComponent::AddRef()
{
	return TFSComponent::AddRef();
}

STDMETHODIMP_(ULONG) CSapComponent::Release()
{
	return TFSComponent::Release();
}

STDMETHODIMP CSapComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

	if (riid == IID_IPersistStreamInit)
		*ppv = static_cast<IPersistStreamInit *>(this);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
    }
    else
		return TFSComponent::QueryInterface(riid, ppv);
}

STDMETHODIMP CSapComponent::OnUpdateView(LPDATAOBJECT pDataObject,
										 LPARAM arg,
										 LPARAM param)
{
	
	return TFSComponent::OnUpdateView(pDataObject, arg, param);
}

STDMETHODIMP CSapComponent::InitializeBitmaps(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(m_spImageList != NULL);

    CBitmap bmp16x16;
    CBitmap bmp32x32;
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		// Load the bitmaps from the dll
		bmp16x16.LoadBitmap(IDB_16x16);
		bmp32x32.LoadBitmap(IDB_32x32);

		// Set the images
		m_spImageList->ImageListSetStrip(
					reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
					reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp32x32)),
                    0, RGB(255,0,255));
	}
	COM_PROTECT_CATCH;

    return hr;
}

/*!--------------------------------------------------------------------------
	CSapComponent::OnSnapinHelp
		-
	Author: MikeG (a-migall)
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CSapComponent::OnSnapinHelp(
	LPDATAOBJECT	pDataObject,
	LPARAM			arg, 
	LPARAM			param)
{
	UNREFERENCED_PARAMETER(pDataObject);
	UNREFERENCED_PARAMETER(arg);
	UNREFERENCED_PARAMETER(param);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HtmlHelpA(NULL,						// caller
			  c_sazIPXSnapHelpFile,	// help file
			  HH_DISPLAY_TOPIC,			// command
			  0);						// data

	return hrOK;
}

STDMETHODIMP CSapComponent::QueryDataObject(MMC_COOKIE cookie,
											   DATA_OBJECT_TYPES type,
											   LPDATAOBJECT *ppDataObject)
{
	HRESULT		hr = hrOK;
	SPITFSNode	spNode;
	SPITFSResultHandler	spResultHandler;

	COM_PROTECT_TRY
	{
		CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

		CORg( spNode->GetResultHandler(&spResultHandler) );

		CORg( spResultHandler->OnCreateDataObject(this, cookie,
			type, ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}


STDMETHODIMP CSapComponent::GetClassID(LPCLSID lpClassID)
{
    ASSERT(lpClassID != NULL);

    // Copy the CLSID for this snapin
    *lpClassID = CLSID_IPXSapExtension;

    return hrOK;
}
STDMETHODIMP CSapComponent::IsDirty()
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{		
		hr = m_ComponentConfig.GetDirty() ? hrOK : hrFalse;
	}
	COM_PROTECT_CATCH;
	return hr;
}
STDMETHODIMP CSapComponent::Load(LPSTREAM pStm)
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{		
	hr = m_ComponentConfig.LoadFrom(pStm);
	}
	COM_PROTECT_CATCH;
	return hr;
}
STDMETHODIMP CSapComponent::Save(LPSTREAM pStm, BOOL fClearDirty)
{
	HRESULT	hr = hrOK;
	SPITFSResultHandler	spResultHandler;
	COM_PROTECT_TRY
	{
		// Need to see if we can save the selected node
		// -------------------------------------------------------------
		if (m_spSelectedNode)
		{
			m_spSelectedNode->GetResultHandler(&spResultHandler);
			if (spResultHandler)
				spResultHandler->UserResultNotify(m_spSelectedNode,
					RRAS_ON_SAVE, (LPARAM)(ITFSComponent *) this);
		}
		hr = m_ComponentConfig.SaveTo(pStm);
		if (FHrSucceeded(hr) && fClearDirty)
			m_ComponentConfig.SetDirty(FALSE);
	}
	COM_PROTECT_CATCH;
	return hr;
}
STDMETHODIMP CSapComponent::GetSizeMax(ULARGE_INTEGER FAR *pcbSize)
{
	Assert(pcbSize);
	HRESULT	hr = hrOK;
	ULONG	cbSize = 0;

	COM_PROTECT_TRY
	{
		hr = m_ComponentConfig.GetSize(&cbSize);
		if (FHrSucceeded(hr))
		{
			pcbSize->HighPart = 0;
			pcbSize->LowPart = cbSize;
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}
STDMETHODIMP CSapComponent::InitNew()
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{		
		hr = m_ComponentConfig.InitNew();
	}
	COM_PROTECT_CATCH;
	return hr;
}






/////////////////////////////////////////////////////////////////////////////
// CSapComponentData implementation

CSapComponentData::CSapComponentData()
{
}

/*!--------------------------------------------------------------------------
	CSapComponentData::OnInitialize
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CSapComponentData::OnInitialize(LPIMAGELIST pScopeImage)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	Assert(pScopeImage);

    // add the images for the scope tree
    CBitmap bmp16x16;
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		// Load the bitmaps from the dll
		bmp16x16.LoadBitmap(IDB_16x16);

		// Set the images
		pScopeImage->ImageListSetStrip(
					reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
					reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
					0,
					RGB(255,0,255));
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	CSapComponentData::OnInitializeNodeMgr
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CSapComponentData::OnInitializeNodeMgr(ITFSComponentData *pTFSCompData, ITFSNodeMgr *pNodeMgr)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// For now create a new node handler for each new node,
	// this is rather bogus as it can get expensive.  We can
	// consider creating only a single node handler for each
	// node type.
	SapRootHandler *	pHandler = NULL;
	SPITFSNodeHandler	spHandler;
	SPITFSNode			spNode;
	HRESULT				hr = hrOK;

	COM_PROTECT_TRY
	{
		pHandler = new SapRootHandler(pTFSCompData);

		// Do this so that it will get released correctly
		spHandler = pHandler;
		pHandler->Init();
	
		// Create the root node for this sick puppy
		CORg( CreateContainerTFSNode(&spNode,
									 &GUID_IPXSapRootNodeType,
									 pHandler,
									 pHandler /* result handler */,
									 pNodeMgr) );

		// Construct the node
		CORg( pHandler->ConstructNode(spNode) );

		CORg( pNodeMgr->SetRootNode(spNode) );
		
		// Reference the help file name.
		pTFSCompData->SetHTMLHelpFileName(c_szIPXSnapHelpFile);

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	CSapComponentData::OnCreateComponent
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CSapComponentData::OnCreateComponent(LPCOMPONENT *ppComponent)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(ppComponent != NULL);
	
	HRESULT		hr = hrOK;
	CSapComponent *	pComp = NULL;

	COM_PROTECT_TRY
	{
		pComp = new CSapComponent;

		if (FHrSucceeded(hr))
		{
			pComp->Construct(m_spNodeMgr,
							 static_cast<IComponentData *>(this),
							 m_spTFSComponentData);
			*ppComponent = static_cast<IComponent *>(pComp);
		}
	}
	COM_PROTECT_CATCH;
	
	return hr;
}


STDMETHODIMP CSapComponentData::OnDestroy()
{
	m_spNodeMgr.Release();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	CSapComponentData::GetCoClassID
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(const CLSID *) CSapComponentData::GetCoClassID()
{
	return &CLSID_IPXSapExtension;
}

/*!--------------------------------------------------------------------------
	CSapComponentData::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CSapComponentData::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

	CDataObject *	pObject = NULL;
	SPIDataObject	spDataObject;
	HRESULT			hr = hrOK;
	SPITFSNode		spNode;
	SPITFSNodeHandler	spHandler;

	COM_PROTECT_TRY
	{
		CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

		CORg( spNode->GetHandler(&spHandler) );

		CORg( spHandler->OnCreateDataObject(cookie, type, &spDataObject) );

		*ppDataObject = spDataObject.Transfer();
		
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	return hr;
}


///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members

STDMETHODIMP CSapComponentData::GetClassID
(
	CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_IPXSapExtension;

    return hrOK;
}

STDMETHODIMP CSapComponentData::IsDirty()
{
	SPITFSNode	spNode;
	SPITFSNodeHandler	spHandler;
	SPIPersistStreamInit	spStm;
	
	m_spNodeMgr->GetRootNode(&spNode);
	spNode->GetHandler(&spHandler);
	spStm.Query(spHandler);
	Assert(spStm);
	
	return (spNode->GetData(TFS_DATA_DIRTY) || spStm->IsDirty()) ? hrOK : hrFalse;
}

STDMETHODIMP CSapComponentData::Load
(
	IStream *pStm
)
{
	SPITFSNode	spNode;
	SPITFSNodeHandler	spHandler;
	SPIPersistStreamInit	spStm;
	
	m_spNodeMgr->GetRootNode(&spNode);
	spNode->GetHandler(&spHandler);
	spStm.Query(spHandler);
	
	Assert(spStm);
	return spStm->Load(pStm);
}


STDMETHODIMP CSapComponentData::Save
(
	IStream *pStm, 
	BOOL	 fClearDirty
)
{
	SPITFSNode	spNode;
	SPITFSNodeHandler	spHandler;
	SPIPersistStreamInit	spStm;
	
	m_spNodeMgr->GetRootNode(&spNode);
	spNode->GetHandler(&spHandler);
	spStm.Query(spHandler);
	
	Assert(spStm);
	return spStm->Save(pStm, fClearDirty);
}


STDMETHODIMP CSapComponentData::GetSizeMax
(
	ULARGE_INTEGER *pcbSize
)
{
	SPITFSNode	spNode;
	SPITFSNodeHandler	spHandler;
	SPIPersistStreamInit	spStm;
	
	m_spNodeMgr->GetRootNode(&spNode);
	spNode->GetHandler(&spHandler);
	spStm.Query(spHandler);
	
	Assert(spStm);
	return spStm->GetSizeMax(pcbSize);
}

STDMETHODIMP CSapComponentData::InitNew()
{
	SPITFSNode	spNode;
	SPITFSNodeHandler	spHandler;
	SPIPersistStreamInit	spStm;
	
	m_spNodeMgr->GetRootNode(&spNode);
	spNode->GetHandler(&spHandler);
	spStm.Query(spHandler);
	
	Assert(spStm);
	return spStm->InitNew();
}



HRESULT CSapComponentData::FinalConstruct()
{
	HRESULT				hr = hrOK;
	
	hr = CComponentData::FinalConstruct();
	
	if (FHrSucceeded(hr))
	{
		m_spTFSComponentData->GetNodeMgr(&m_spNodeMgr);
	}
	return hr;
}

void CSapComponentData::FinalRelease()
{
	CComponentData::FinalRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\sapprop.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	sapprop.cpp
		Dhcp Relay node property sheet and property pages
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "rtrutil.h"	// smart MPR handle pointers
#include "format.h"		// FormatNumber function
#include "sapprop.h"
#include "sapview.h"
#include "ipxutil.h"		// SapModeToCString
#include "ipxconn.h"
#include "svfltdlg.h"
#include "globals.h"		// IPX defaults

extern "C"
{
#include "routprot.h"
};



/*---------------------------------------------------------------------------
	SapPageGeneral
 ---------------------------------------------------------------------------*/

BEGIN_MESSAGE_MAP(SapPageGeneral, RtrPropertyPage)
    //{{AFX_MSG_MAP(SapPageGeneral)
    ON_BN_CLICKED(IDC_SGG_BTN_LOG_ERROR, OnButtonClicked)
    ON_BN_CLICKED(IDC_SGG_BTN_LOG_INFO, OnButtonClicked)
    ON_BN_CLICKED(IDC_SGG_BTN_LOG_NONE, OnButtonClicked)
    ON_BN_CLICKED(IDC_SGG_BTN_LOG_WARN, OnButtonClicked)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/*!--------------------------------------------------------------------------
	SapPageGeneral::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapPageGeneral::Init(SapProperties *pPropSheet)
{
	m_pSapPropSheet = pPropSheet;
	return hrOK;
}

/*!--------------------------------------------------------------------------
	SapPageGeneral::OnInitDialog
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL SapPageGeneral::OnInitDialog()
{
	HRESULT		hr= hrOK;
	SPIInfoBase	spInfoBase;
    SAP_GLOBAL_INFO* pGlobal;
	DWORD *		pdw;
	int			i;

	RtrPropertyPage::OnInitDialog();

    //
    // Load the existing global-config
    //
	CORg( m_pSapPropSheet->GetInfoBase(&spInfoBase) );

    //
    // Retrieve the IPSAP block from the global-config
    //
	CORg( spInfoBase->GetData(IPX_PROTOCOL_SAP, 0, (PBYTE *) &pGlobal) );

    //
    // Initialize the error-level buttons
    //
    SetErrorLevelButtons(pGlobal->EventLogMask);


	SetDirty(FALSE);

Error:
	if (!FHrSucceeded(hr))
		Cancel();
	return FHrSucceeded(hr) ? TRUE : FALSE;
}

/*!--------------------------------------------------------------------------
	SapPageGeneral::DoDataExchange
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SapPageGeneral::DoDataExchange(CDataExchange *pDX)
{
	RtrPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(SapPageGeneral)
	//}}AFX_DATA_MAP
	
}

/*!--------------------------------------------------------------------------
	SapPageGeneral::OnApply
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL SapPageGeneral::OnApply()
{
	BOOL		fReturn;
	HRESULT		hr = hrOK;
	SAP_GLOBAL_INFO	*	prgi;
	SPIInfoBase	spInfoBase;

    if ( m_pSapPropSheet->IsCancel() )
	{
		CancelApply();
        return TRUE;
	}

	m_pSapPropSheet->GetInfoBase(&spInfoBase);

    // Retrieve the existing IPSAP block from the global-config
	CORg( spInfoBase->GetData(IPX_PROTOCOL_SAP, 0, (BYTE **) &prgi) );

	// Save the error level
	prgi->EventLogMask = QueryErrorLevelButtons();

	fReturn = RtrPropertyPage::OnApply();
	
Error:
	if (!FHrSucceeded(hr))
		fReturn = FALSE;
	return fReturn;
}

void SapPageGeneral::SetErrorLevelButtons(DWORD dwErrorLevel)
{
	switch (dwErrorLevel)
	{
		case 0:
			CheckDlgButton(IDC_SGG_BTN_LOG_NONE, TRUE);
			break;
		case EVENTLOG_ERROR_TYPE:
			CheckDlgButton(IDC_SGG_BTN_LOG_ERROR, TRUE);
			break;
		case EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE:
			CheckDlgButton(IDC_SGG_BTN_LOG_WARN, TRUE);
			break;
		case EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE:
		default:
			CheckDlgButton(IDC_SGG_BTN_LOG_INFO, TRUE);
			break;
	}
}

DWORD SapPageGeneral::QueryErrorLevelButtons()
{
	if (IsDlgButtonChecked(IDC_SGG_BTN_LOG_INFO))
		return EVENTLOG_INFORMATION_TYPE |
				EVENTLOG_WARNING_TYPE |
				EVENTLOG_ERROR_TYPE;
	else if (IsDlgButtonChecked(IDC_SGG_BTN_LOG_WARN))
		return 	EVENTLOG_WARNING_TYPE |
				EVENTLOG_ERROR_TYPE;
	else if (IsDlgButtonChecked(IDC_SGG_BTN_LOG_ERROR))
		return 	EVENTLOG_ERROR_TYPE;
	else
		return 0;
}

void SapPageGeneral::OnButtonClicked()
{
	SetDirty(TRUE);
	SetModified();
}


/*---------------------------------------------------------------------------
	SapProperties implementation
 ---------------------------------------------------------------------------*/

SapProperties::SapProperties(ITFSNode *pNode,
								 IComponentData *pComponentData,
								 ITFSComponentData *pTFSCompData,
								 LPCTSTR pszSheetName,
								 CWnd *pParent,
								 UINT iPage,
								 BOOL fScopePane)
	: RtrPropertySheet(pNode, pComponentData, pTFSCompData,
					   pszSheetName, pParent, iPage, fScopePane),
		m_pageGeneral(IDD_SAP_GLOBAL_GENERAL_PAGE)
{
		m_spNode.Set(pNode);
}

/*!--------------------------------------------------------------------------
	SapProperties::Init
		Initialize the property sheets.  The general action here will be
		to initialize/add the various pages.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapProperties::Init(IRtrMgrInfo *pRm)
{
	Assert(pRm);
	HRESULT	hr = hrOK;
	IPXConnection *	pIPXConn;

	m_spRm.Set(pRm);

	pIPXConn = GET_SAP_NODEDATA(m_spNode);

	// The pages are embedded members of the class
	// do not delete them.
	m_bAutoDeletePages = FALSE;


	// Do this here, because the init is called in the context
	// of the main thread
	CORg( LoadInfoBase(pIPXConn) );
	
	m_pageGeneral.Init(this);
	AddPageToList((CPropertyPageBase*) &m_pageGeneral);

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	SapProperties::SaveSheetData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL SapProperties::SaveSheetData()
{
	Assert(m_spRm);
    SPITFSNodeHandler   spHandler;
    SPITFSNode          spParent;

	// Save the global info
	// We don't need to pass in the hMachine, hTransport since they
	// got set up in the Load call.
	m_spRm->Save(m_spRm->GetMachineName(),
				 0, 0, m_spInfoBase, NULL, 0);

    // Force the node to do a resync
    m_spNode->GetParent(&spParent);
    spParent->GetHandler(&spHandler);
    spHandler->OnCommand(spParent, IDS_MENU_SYNC, CCT_RESULT,
                         NULL, 0);
	return TRUE;
}

/*!--------------------------------------------------------------------------
	SapProperties::LoadInfoBase
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapProperties::LoadInfoBase(IPXConnection *pIPXConn)
{
	Assert(pIPXConn);
	
	HRESULT			hr = hrOK;
	HANDLE			hTransport = NULL;
	SPIInfoBase		spInfoBase;

	// Get the transport handle
	CWRg( ::MprConfigTransportGetHandle(pIPXConn->GetConfigHandle(),
										PID_IPX,
										&hTransport) );

	CORg( m_spRm->GetInfoBase(pIPXConn->GetConfigHandle(),
							  hTransport, &spInfoBase, NULL) );
								  
	Assert(spInfoBase);

	// Retrieve the current block for IP_SAP
	// Adding the default block if none is found.
	if (!FHrOK(spInfoBase->ProtocolExists(IPX_PROTOCOL_SAP)))
	{
		SAP_GLOBAL_INFO	rgi;

		rgi.EventLogMask = EVENTLOG_ERROR_TYPE;
		CORg( spInfoBase->AddBlock(IPX_PROTOCOL_SAP,
								   sizeof(rgi),
								   (PBYTE) &rgi, 1, TRUE) );
	}

	m_spInfoBase = spInfoBase.Transfer();
	
Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	SapProperties::GetInfoBase
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapProperties::GetInfoBase(IInfoBase **ppGlobalInfo)
{	
	*ppGlobalInfo = m_spInfoBase;
	if (*ppGlobalInfo)
		(*ppGlobalInfo)->AddRef();
	return hrOK;
}



/*---------------------------------------------------------------------------
	SapInterfacePageGeneral
 ---------------------------------------------------------------------------*/

BEGIN_MESSAGE_MAP(SapInterfacePageGeneral, RtrPropertyPage)
    //{{AFX_MSG_MAP(SapInterfacePageGeneral)
	ON_BN_CLICKED(IDC_SIG_BTN_ADMIN_STATE, OnButtonClicked)
	ON_BN_CLICKED(IDC_SIG_BTN_ADVERTISE_SERVICES, OnButtonClicked)
	ON_BN_CLICKED(IDC_SIG_BTN_ACCEPT_SERVICE_ADS, OnButtonClicked)
	ON_BN_CLICKED(IDC_SIG_BTN_REPLY_GNS_REQUESTS, OnButtonClicked)
			
	ON_BN_CLICKED(IDC_SIG_BTN_UPDATE_MODE_STANDARD, OnUpdateButtonClicked)
	ON_BN_CLICKED(IDC_SIG_BTN_UPDATE_MODE_NONE, OnUpdateButtonClicked)
	ON_BN_CLICKED(IDC_SIG_BTN_UPDATE_MODE_AUTOSTATIC, OnUpdateButtonClicked)

	ON_BN_CLICKED(IDC_SIG_BTN_INPUT_FILTERS, OnInputFilter)
	ON_BN_CLICKED(IDC_SIG_BTN_OUTPUT_FILTERS, OnOutputFilter)

	ON_EN_CHANGE(IDC_SIG_EDIT_INTERVAL, OnChangeEdit)
	ON_EN_CHANGE(IDC_SIG_EDIT_MULTIPLIER, OnChangeEdit)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


void SapInterfacePageGeneral::DoDataExchange(CDataExchange *pDX)
{

	RtrPropertyPage::DoDataExchange(pDX);
	
    //{{AFX_DATA_MAP(SapInterfacePageGeneral)
	DDX_Control(pDX, IDC_SIG_SPIN_INTERVAL, m_spinInterval);
	DDX_Control(pDX, IDC_SIG_SPIN_MULTIPLIER, m_spinMultiplier);
    //}}AFX_DATA_MAP
}

/*!--------------------------------------------------------------------------
	SapInterfacePageGeneral::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapInterfacePageGeneral::Init(SapInterfaceProperties *pPropSheet,
									 IInterfaceInfo *pIf)
{
	m_pSapIfPropSheet = pPropSheet;
	m_spIf.Set(pIf);
	return hrOK;
}


/*!--------------------------------------------------------------------------
	SapInterfacePageGeneral::OnInitDialog
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL SapInterfacePageGeneral::OnInitDialog()
{
	HRESULT		hr= hrOK;
	SPIInfoBase	spInfoBase;
    SAP_IF_CONFIG* pIfConfig;
	int			i, count, item;
	CString		sItem;

	RtrPropertyPage::OnInitDialog();

    //
    // Initialize controls
	//

	m_spinInterval.SetRange(0, 32767);
	m_spinInterval.SetBuddy(GetDlgItem(IDC_SIG_EDIT_INTERVAL));

	m_spinMultiplier.SetRange(0, 32767);
	m_spinMultiplier.SetBuddy(GetDlgItem(IDC_SIG_EDIT_MULTIPLIER));


    //
    // Load the existing global-config
    //
	CORg( m_pSapIfPropSheet->GetInfoBase(&spInfoBase) );

    //
    // Retrieve the IPSAP block from the global-config
    //
	CORg( spInfoBase->GetData(IPX_PROTOCOL_SAP, 0, (PBYTE *) &pIfConfig) );

	
    //
    // Set the spin-controls
    //
	m_spinInterval.SetPos(pIfConfig->SapIfInfo.PeriodicUpdateInterval);
	m_spinMultiplier.SetPos(pIfConfig->SapIfInfo.AgeIntervalMultiplier);

	
	CheckDlgButton(IDC_SIG_BTN_ADMIN_STATE,
				   pIfConfig->SapIfInfo.AdminState == ADMIN_STATE_ENABLED);

	CheckDlgButton(IDC_SIG_BTN_ADVERTISE_SERVICES,
				   pIfConfig->SapIfInfo.Supply == ADMIN_STATE_ENABLED);

	CheckDlgButton(IDC_SIG_BTN_ACCEPT_SERVICE_ADS,
				   pIfConfig->SapIfInfo.Listen == ADMIN_STATE_ENABLED);

	CheckDlgButton(IDC_SIG_BTN_REPLY_GNS_REQUESTS,
				   pIfConfig->SapIfInfo.GetNearestServerReply == ADMIN_STATE_ENABLED);

	switch (pIfConfig->SapIfInfo.UpdateMode)
	{
		case IPX_STANDARD_UPDATE:
			CheckDlgButton(IDC_SIG_BTN_UPDATE_MODE_STANDARD, TRUE);
			break;
		case IPX_NO_UPDATE:
			CheckDlgButton(IDC_SIG_BTN_UPDATE_MODE_NONE, TRUE);
			break;
		case IPX_AUTO_STATIC_UPDATE:
			CheckDlgButton(IDC_SIG_BTN_UPDATE_MODE_AUTOSTATIC, TRUE);
			break;
		default:
			break;
	}

    OnUpdateButtonClicked();


	// If this is a new interface, we need to force the change
	// through if the user hits ok.
	SetDirty(m_pSapIfPropSheet->m_bNewInterface ? TRUE : FALSE);

Error:
	if (!FHrSucceeded(hr))
		Cancel();
	return FHrSucceeded(hr) ? TRUE : FALSE;
}

void SapInterfacePageGeneral::OnButtonClicked()
{
	SetDirty(TRUE);
	SetModified();
}

void SapInterfacePageGeneral::OnUpdateButtonClicked()
{
	BOOL	fStandard = IsDlgButtonChecked(IDC_SIG_BTN_UPDATE_MODE_STANDARD);

    if (fStandard &&
        (m_spinInterval.GetPos() == 0) &&
        (m_spinMultiplier.GetPos() == 0))
    {
        m_spinInterval.SetPos(IPX_UPDATE_INTERVAL_DEFVAL);
        m_spinMultiplier.SetPos(3);
    }

    MultiEnableWindow(GetSafeHwnd(),
                      fStandard,
                      IDC_SIG_TEXT_INTERVAL,
                      IDC_SIG_SPIN_INTERVAL,
                      IDC_SIG_EDIT_INTERVAL,
                      IDC_SIG_TEXT_MULTIPLIER,
                      IDC_SIG_SPIN_MULTIPLIER,
                      IDC_SIG_EDIT_MULTIPLIER,
                      0);

	SetDirty(TRUE);
	SetModified();
}

void SapInterfacePageGeneral::OnChangeEdit()
{
	SetDirty(TRUE);
	SetModified();
}

void SapInterfacePageGeneral::ShowFilter(BOOL fOutputFilter)
{	
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	SPIInfoBase	spInfoBase;
	SAP_IF_CONFIG *	pic;
	HRESULT		hr = hrOK;

	m_pSapIfPropSheet->GetInfoBase(&spInfoBase);
    CServiceFltDlg    dlgFlt (fOutputFilter /* bOutputDlg */, spInfoBase, this);

	// Need to grab the Sap IF config struct out of the
	// infobase

	if (m_spIf)
		dlgFlt.m_sIfName = m_spIf->GetTitle();
	else
		dlgFlt.m_sIfName.LoadString(IDS_IPX_DIAL_IN_CLIENTS);
    try {
        if (dlgFlt.DoModal () == IDOK)
		{
			SetDirty(TRUE);
			SetModified();
		}
    }
    catch (CException *ex) {
        ex->ReportError ();
        ex->Delete ();
    }

	return;
}

void SapInterfacePageGeneral::OnInputFilter()
{
	ShowFilter(FALSE);
}

void SapInterfacePageGeneral::OnOutputFilter()
{
	ShowFilter(TRUE);
}


/*!--------------------------------------------------------------------------
	SapInterfacePageGeneral::OnApply
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL SapInterfacePageGeneral::OnApply()
{
	BOOL		fReturn;
	HRESULT		hr = hrOK;
    INT i, item;
	SAP_IF_CONFIG *	pic;
	SPIInfoBase	spInfoBase;

    if ( m_pSapIfPropSheet->IsCancel() )
	{
		CancelApply();
        return TRUE;
	}

	m_pSapIfPropSheet->GetInfoBase(&spInfoBase);

	CORg( spInfoBase->GetData(IPX_PROTOCOL_SAP, 0, (PBYTE *) &pic) );

	// Save the admin state
	pic->SapIfInfo.AdminState = IsDlgButtonChecked(IDC_SIG_BTN_ADMIN_STATE) ?
				ADMIN_STATE_ENABLED : ADMIN_STATE_DISABLED;

	// Save the advertise SERVICEs
	pic->SapIfInfo.Supply = IsDlgButtonChecked(IDC_SIG_BTN_ADVERTISE_SERVICES) ?
				ADMIN_STATE_ENABLED : ADMIN_STATE_DISABLED;

	// Save the accept SERVICE ads
	pic->SapIfInfo.Listen = IsDlgButtonChecked(IDC_SIG_BTN_ACCEPT_SERVICE_ADS) ?
				ADMIN_STATE_ENABLED : ADMIN_STATE_DISABLED;

	// Save the GSNR
	pic->SapIfInfo.GetNearestServerReply = IsDlgButtonChecked(IDC_SIG_BTN_REPLY_GNS_REQUESTS) ?
				ADMIN_STATE_ENABLED : ADMIN_STATE_DISABLED;

	// Save the update mode
	if (IsDlgButtonChecked(IDC_SIG_BTN_UPDATE_MODE_STANDARD))
	{
		pic->SapIfInfo.UpdateMode = IPX_STANDARD_UPDATE;
	}
	else if (IsDlgButtonChecked(IDC_SIG_BTN_UPDATE_MODE_NONE))
	{
		pic->SapIfInfo.UpdateMode = IPX_NO_UPDATE;
	}
	else
		pic->SapIfInfo.UpdateMode = IPX_AUTO_STATIC_UPDATE;

	// Save the interval and multiplier
	pic->SapIfInfo.PeriodicUpdateInterval = m_spinInterval.GetPos();
	pic->SapIfInfo.AgeIntervalMultiplier = m_spinMultiplier.GetPos();

	fReturn = RtrPropertyPage::OnApply();
	
Error:
	if (!FHrSucceeded(hr))
		fReturn = FALSE;
	return fReturn;
}



/*---------------------------------------------------------------------------
	SapInterfaceProperties implementation
 ---------------------------------------------------------------------------*/

SapInterfaceProperties::SapInterfaceProperties(ITFSNode *pNode,
								 IComponentData *pComponentData,
								 ITFSComponentData *pTFSCompData,
								 LPCTSTR pszSheetName,
								 CWnd *pParent,
								 UINT iPage,
								 BOOL fScopePane)
	: RtrPropertySheet(pNode, pComponentData, pTFSCompData,
					   pszSheetName, pParent, iPage, fScopePane),
		m_pageGeneral(IDD_SAP_INTERFACE_GENERAL_PAGE),
		m_bNewInterface(FALSE)
{
		m_spNode.Set(pNode);
}

/*!--------------------------------------------------------------------------
	SapInterfaceProperties::Init
		Initialize the property sheets.  The general action here will be
		to initialize/add the various pages.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapInterfaceProperties::Init(IInterfaceInfo *pIf,
										   IRtrMgrInfo *pRm)
{
	Assert(pRm);
	
	HRESULT	hr = hrOK;
	IPXConnection *	pIPXConn;
	SPITFSNode		spParent;

	m_spRm.Set(pRm);
	m_spIf.Set(pIf);
	if (pIf)
		CORg( pIf->FindRtrMgrInterface(PID_IPX, &m_spRmIf) );
	

	m_spNode->GetParent(&spParent);
	Assert(spParent);

	// The pages are embedded members of the class
	// do not delete them.
	m_bAutoDeletePages = FALSE;


	// Do this here, because the init is called in the context
	// of the main thread
	pIPXConn = GET_SAP_NODEDATA(spParent);
	CORg( LoadInfoBase(pIPXConn) );
	
	m_pageGeneral.Init(this, m_spIf);
	AddPageToList((CPropertyPageBase*) &m_pageGeneral);

Error:
	return hr;
}



/*!--------------------------------------------------------------------------
	SapInterfaceProperties::SaveSheetData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL SapInterfaceProperties::SaveSheetData()
{
	Assert(m_spRm);
	BaseIPXResultNodeData *	pNodeData;
	SAP_IF_CONFIG *		pic;
    SPITFSNodeHandler   spHandler;
    SPITFSNode          spParent;


	if (m_spInfoBase)
	{
		if (m_bClientInfoBase)
		{
			Assert(m_spRm);
			m_spRm->Save(m_spRm->GetMachineName(), 0, 0, NULL,
						 m_spInfoBase, 0);
		}
		else
		{
			Assert(m_spRmIf);
			m_spRmIf->Save(m_spIf->GetMachineName(),
						   NULL, NULL, NULL, m_spInfoBase, 0);
		}

	}
	if (m_bNewInterface)
	{
		m_spNode->SetVisibilityState(TFS_VIS_SHOW);
		m_spNode->Show();
		
		// Windows NT Bugs : 133891, we have added this to the UI
		// we no longer consider this a new interface
		m_bNewInterface = FALSE;
	}
       // Force the node to do a resync
    m_spNode->GetParent(&spParent);
    spParent->GetHandler(&spHandler);
    spHandler->OnCommand(spParent, IDS_MENU_SYNC, CCT_RESULT,
                         NULL, 0);
	
	return TRUE;
}

/*!--------------------------------------------------------------------------
	SapInterfaceProperties::CancelSheetData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SapInterfaceProperties::CancelSheetData()
{
	if (m_bNewInterface && m_bClientInfoBase)
	{
		m_spNode->SetVisibilityState(TFS_VIS_DELETE);
		m_spRmIf->DeleteRtrMgrProtocolInterface(IPX_PROTOCOL_SAP, TRUE);
	}
}

/*!--------------------------------------------------------------------------
	SapInterfaceProperties::LoadInfoBase
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapInterfaceProperties::LoadInfoBase(IPXConnection *pIPXConn)
{
	Assert(pIPXConn);
	
	HRESULT			hr = hrOK;
	HANDLE			hTransport = NULL;
	LPCOLESTR		pszInterfaceId = NULL;
	SPIInfoBase		spInfoBase;
	BYTE *			pDefault;


	// If configuring the client-interface, load the client-interface info,
	// otherwise, retrieve the interface being configured and load
	// its info.

	// The client interface doesn't have an ID
	if (m_spIf)
		pszInterfaceId = m_spIf->GetId();


	if (StrLenW(pszInterfaceId) == 0)
	{
		Assert(m_spRm);
		
		// Get the transport handle
		CWRg( ::MprConfigTransportGetHandle(pIPXConn->GetConfigHandle(),
											PID_IPX,
											&hTransport) );
		
		// Load the client interface info
		CORg( m_spRm->GetInfoBase(pIPXConn->GetConfigHandle(),
								  hTransport,
								  NULL,
								  &spInfoBase) );
		m_bClientInfoBase = TRUE;
	}
	else
	{
		Assert(m_spRmIf);
		
		//
		// The parameters are all NULL so that we can use the
		// default RPC handles.
		//
		m_spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase);
		m_bClientInfoBase = FALSE;
	}

	if (!spInfoBase)
	{
		// No info was found for the inteface
		// allocate a new InfoBase instead
		CORg( CreateInfoBase(&spInfoBase) );		
	}

    //
    // Check that there is a block for interface-status in the info,
    // and insert the default block if none is found.
    //
	if (spInfoBase->ProtocolExists(IPX_PROTOCOL_SAP) == hrFalse)
	{
		SAP_IF_CONFIG	ric;

		// Setup the defaults for an interface

		if (m_spIf &&
			(m_spIf->GetInterfaceType() == ROUTER_IF_TYPE_DEDICATED))
			pDefault = g_pIpxSapLanInterfaceDefault;
		else
			pDefault = g_pIpxSapInterfaceDefault;
			
		CORg( spInfoBase->AddBlock(IPX_PROTOCOL_SAP,
								   sizeof(SAP_IF_CONFIG),
								   pDefault,
								   1 /* count */,
								   TRUE /* bRemoveFirst */) );
		m_bNewInterface = TRUE;
	}

	m_spInfoBase.Set(spInfoBase);
	
Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	SapInterfaceProperties::GetInfoBase
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapInterfaceProperties::GetInfoBase(IInfoBase **ppGlobalInfo)
{	
	*ppGlobalInfo = m_spInfoBase;
	if (*ppGlobalInfo)
		(*ppGlobalInfo)->AddRef();
	return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\sapcomp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	sapcomp.h
		This file contains the prototypes for the derived classes 
		for CComponent and CComponentData.  Most of these functions 
		are pure virtual functions that need to be overridden 
		for snapin functionality.
		
    FILE HISTORY:
        
*/

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

#ifndef _CCDATA_H
#include "ccdata.h"
#endif

#ifndef _COMPONT_H
#include "compont.h"
#endif

#ifndef _COLUMN_H
#include "column.h"
#endif

#ifndef _SAPSTRM_H
#include "sapstrm.h"
#endif


/*---------------------------------------------------------------------------
	CSapComponentData

	This is the base implementation of ComponentData.  This will be
	incorporated into the two derived classes.
 ---------------------------------------------------------------------------*/

class CSapComponentData :
	public CComponentData,
	public CComObjectRoot,
	public CComCoClass<CSapComponentData, &CLSID_IPXSapExtension>
{
public:
	
BEGIN_COM_MAP(CSapComponentData)
	COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

DECLARE_REGISTRY(CSapComponentData,
				 _T("RouterIPXSapExtension.RouterIPXSapExtension.1"),
				 _T("RouterIPXSapExtension.RouterIPXSapExtension"),
				 IDS_IPXSAP_SNAPIN_DESC, THREADFLAGS_APARTMENT);
	
	// These are the interfaces that we MUST implement

	// We will implement our common behavior here, with the derived
	// classes implementing the specific behavior.
	DeclareIPersistStreamInitMembers(IMPL)
	DeclareITFSCompDataCallbackMembers(IMPL)

	CSapComponentData();

	HRESULT FinalConstruct();
	void FinalRelease();
	
protected:
	SPITFSNodeMgr	m_spNodeMgr;
};



/////////////////////////////////////////////////////////////////////////////
//
// CSampleComponent
//
/////////////////////////////////////////////////////////////////////////////

class CSapComponent : 
	public TFSComponent,
	public IPersistStreamInit
{
public:
	CSapComponent();
	~CSapComponent();

	DeclareIUnknownMembers(IMPL)
	DeclareIPersistStreamInitMembers(IMPL)
	DeclareITFSCompCallbackMembers(IMPL)

	// Override OnQueryDataObject, so that we can forward
	// the calls down to the Result Handlers
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject);
	
    STDMETHOD(OnSnapinHelp)(LPDATAOBJECT, LPARAM, LPARAM);
    
//Attributes
private:
	SapComponentConfigStream	m_ComponentConfig;
};



/*---------------------------------------------------------------------------
	This is the derived class for handling the IAbout interface from MMC
	Author: EricDav
 ---------------------------------------------------------------------------*/
class CSapAbout : 
	public CAbout,
    public CComCoClass<CSapAbout, &CLSID_IPXSapExtensionAbout>
{
public:
DECLARE_REGISTRY(CSapAbout, 
				 _T("RouterIPXSapSnapin.About.1"), 
				 _T("RouterIPXSapSnapin.About"), 
				 IDS_IPXSAP_SNAPIN_DESC, 
				 THREADFLAGS_APARTMENT)

BEGIN_COM_MAP(CSapAbout)
    COM_INTERFACE_ENTRY(ISnapinAbout) // Must have one static entry
	COM_INTERFACE_ENTRY_CHAIN(CAbout) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CSapAbout)

// these must be overridden to provide values to the base class
protected:
	virtual UINT GetAboutDescriptionId() { return IDS_ABOUT_DESCRIPTION; }
	virtual UINT GetAboutProviderId()	 { return IDS_ABOUT_PROVIDER; }
	virtual UINT GetAboutVersionId()	 { return IDS_ABOUT_VERSION; }
	virtual UINT GetAboutIconId()		 { return IDI_IPX_SNAPIN_ICON; }

	virtual UINT GetSmallRootId()		 { return 0; }
	virtual UINT GetSmallOpenRootId()	 { return 0; }
	virtual UINT GetLargeRootId()		 { return 0; }
	virtual COLORREF GetLargeColorMask() { return (COLORREF) 0; } 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\saproot.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	root.h
		Root node information (the root node is not displayed
		in the MMC framework but contains information such as 
		all of the subnodes in this snapin).
		
    FILE HISTORY:
        
*/

#ifndef _SAPROOT_H
#define _SAPROOT_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _QUERYOBJ_H
#include "queryobj.h"
#endif

#ifndef _SAPSTRM_H
#include "sapstrm.h"
#endif

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _ROOT_H
#include "root.h"
#endif


/*---------------------------------------------------------------------------
	Class:	SapRootHandler

	There should be a SapRootHandler for every root node created.
	SapRootHandler's have a 1-to-1 relationship with their node!
	Other parts of the code depend on this.
 ---------------------------------------------------------------------------*/
class SapRootHandler
	   : public RootHandler
{
public:
	SapRootHandler(ITFSComponentData *pCompData);
	~SapRootHandler()
			{ DEBUG_DECREMENT_INSTANCE_COUNTER(SapRootHandler); };

	// Override QI to handle embedded interface
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);

	DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown);

	STDMETHOD(GetClassID)(CLSID *pClassId);

	// Notification overrides
	OVERRIDE_BaseHandlerNotify_OnExpand();

	// Handler overrides
	OVERRIDE_NodeHandler_OnCreateDataObject();
	OVERRIDE_NodeHandler_DestroyHandler();

	// virtual function to access config stream
	ConfigStream *		GetConfigStream()
			{ return &m_ConfigStream; }

protected:
	HRESULT AddProtocolNode(ITFSNode *pNode, IRouterInfo * pRouterInfo);
    HRESULT CompareNodeToMachineName(ITFSNode *pNode, LPCTSTR pszName);

    SapConfigStream		m_ConfigStream;
};




#endif _SAPROOT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\sapstats.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ipstats.cpp
		IP Statistics implementation.
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "rtrutil.h"	// smart MPR handle pointers
#include "format.h"		// FormatNumber function
#include "column.h"		// containercolumninfo
#include "ipxconn.h"	// IPXConnection
#include "routprot.h"
#include "ipxutil.h"

#include "statsdlg.h"
#include "sapstats.h"
#include "resource.h"


/*---------------------------------------------------------------------------
	SAPParamsStatistics implementation
 ---------------------------------------------------------------------------*/


extern const ContainerColumnInfo s_rgSAPParamsStatsColumnInfo[];
const ContainerColumnInfo s_rgSAPParamsStatsColumnInfo[] =
{
	{ IDS_STATS_SAPPARAMS_OPER_STATE,	0,		TRUE, COL_STATUS },
	{ IDS_STATS_SAPPARAMS_SENT_PACKETS,	0,		TRUE, COL_LARGE_NUM },
	{ IDS_STATS_SAPPARAMS_RCVD_PACKETS,	0,		TRUE, COL_LARGE_NUM  },
};

SAPParamsStatistics::SAPParamsStatistics()
	: IPXStatisticsDialog(STATSDLG_VERTICAL |
						 STATSDLG_FULLWINDOW |
						 STATSDLG_CONTEXTMENU |
						 STATSDLG_SELECT_COLUMNS)
{
	SetColumnInfo(s_rgSAPParamsStatsColumnInfo,
				  DimensionOf(s_rgSAPParamsStatsColumnInfo));
}

			
HRESULT SAPParamsStatistics::RefreshData(BOOL fGrabNewData)
{
	HRESULT	hr = hrOK;
	CString	st;
	ULONG	iPos;
	TCHAR	szNumber[32];
	SAP_MIB_GET_INPUT_DATA	MibGetInputData;
	PSAP_MIB_BASE	pSapBase = NULL;
	DWORD			cbSapBase;
	SPMprMibBuffer	spMib;
	PSAP_INTERFACE	pSapIf = NULL;
	DWORD			cbSapIf;
	DWORD			cSent = 0;
	DWORD			cRcvd = 0;
	DWORD			dwErr;

	Assert(m_pIPXConn);

	MibGetInputData.TableId = SAP_BASE_ENTRY;

	dwErr = ::MprAdminMIBEntryGet(m_pIPXConn->GetMibHandle(),
								  PID_IPX,
								  IPX_PROTOCOL_SAP,
								  &MibGetInputData,
								  sizeof(MibGetInputData),
								  (LPVOID *) &pSapBase,
								  &cbSapBase);
	spMib = (LPBYTE) pSapBase;
	hr = HRESULT_FROM_WIN32(dwErr);
	CORg( hr );

	if (IsSubitemVisible(MVR_SAPPARAMS_OPER_STATE))
	{
		st = IpxOperStateToCString(pSapBase->SapOperState);
		iPos = MapSubitemToColumn(MVR_SAPPARAMS_OPER_STATE);
		m_listCtrl.SetItemText(iPos, 1, (LPCTSTR) st);
	}

	spMib.Free();
	MibGetInputData.TableId = SAP_INTERFACE_TABLE;

	dwErr = MprAdminMIBEntryGetFirst(m_pIPXConn->GetMibHandle(),
									 PID_IPX,
									 IPX_PROTOCOL_SAP,
									 &MibGetInputData,
									 sizeof(MibGetInputData),
									 (LPVOID *) &pSapIf,
									 &cbSapIf);
	hr = HRESULT_FROM_WIN32(dwErr);
	spMib = (LPBYTE) pSapIf;

	while (FHrSucceeded(hr))
	{
		if (pSapIf->InterfaceIndex)
		{
			cSent += pSapIf->SapIfStats.SapIfOutputPackets;
			cRcvd += pSapIf->SapIfStats.SapIfInputPackets;
		}
		
		MibGetInputData.InterfaceIndex = pSapIf->InterfaceIndex;
		spMib.Free();
		pSapIf = NULL;

		dwErr = MprAdminMIBEntryGetNext(m_pIPXConn->GetMibHandle(),
										PID_IPX,
										IPX_PROTOCOL_SAP,
										&MibGetInputData,
										sizeof(MibGetInputData),
										(LPVOID *) &pSapIf,
										&cbSapIf);
		hr = HRESULT_FROM_WIN32(dwErr);
		spMib = (LPBYTE) pSapIf;
	}

	
	if (IsSubitemVisible(MVR_SAPPARAMS_SENT_PKTS))
	{
		FormatNumber(cSent, szNumber, DimensionOf(szNumber), FALSE);
		iPos = MapSubitemToColumn(MVR_SAPPARAMS_SENT_PKTS);
		m_listCtrl.SetItemText(iPos, 1, (LPCTSTR) szNumber);
	}


	if (IsSubitemVisible(MVR_SAPPARAMS_RCVD_PKTS))
	{
		FormatNumber(cRcvd, szNumber, DimensionOf(szNumber), FALSE);
		iPos = MapSubitemToColumn(MVR_SAPPARAMS_RCVD_PKTS);
		m_listCtrl.SetItemText(iPos, 1, (LPCTSTR) szNumber);
	}

Error:
	return hr;
}

BOOL SAPParamsStatistics::OnInitDialog()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CString	st;

	st.LoadString(IDS_STATS_SAPPARAMS_TITLE);
	SetWindowText((LPCTSTR) st);
	return IPXStatisticsDialog::OnInitDialog();
}

void SAPParamsStatistics::Sort(UINT)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\saproot.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	root.cpp
		Root node information (the root node is not displayed
		in the MMC framework but contains information such as 
		all of the subnodes in this snapin).
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "util.h"
#include "saproot.h"
#include "reg.h"
#include "sapview.h"	// SAP handlers
#include "sapstats.h"
#include "routprot.h"	// IP_BOOTP


/*---------------------------------------------------------------------------
	SapRootHandler implementation
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(SapRootHandler)

extern const ContainerColumnInfo s_rgSAPParamsStatsColumnInfo[];

struct _ViewInfoColumnEntry
{
	UINT	m_ulId;
	UINT	m_cColumns;
	const ContainerColumnInfo *m_prgColumn;
};

static const struct _ViewInfoColumnEntry	s_rgViewColumnInfo[] =
{
	{ SAPSTRM_STATS_SAPPARAMS, MVR_SAPPARAMS_COUNT, s_rgSAPParamsStatsColumnInfo },
};

SapRootHandler::SapRootHandler(ITFSComponentData *pCompData)
	: RootHandler(pCompData)
{
	DEBUG_INCREMENT_INSTANCE_COUNTER(SapRootHandler)
			
	m_ConfigStream.Init(DimensionOf(s_rgViewColumnInfo));
	
    // This will initialize the view information for the statistics
    // dialogs.  (which is why the fConfigurableColumns is set to TRUE).
	for (int i=0; i<DimensionOf(s_rgViewColumnInfo); i++)
	{
		m_ConfigStream.InitViewInfo(s_rgViewColumnInfo[i].m_ulId,
                                    TRUE /*fConfigurableColumns*/,
									s_rgViewColumnInfo[i].m_cColumns,
									TRUE,
									s_rgViewColumnInfo[i].m_prgColumn);
	}
}


STDMETHODIMP SapRootHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IRtrAdviseSink)
		*ppv = &m_IRtrAdviseSink;
	else
		return RootHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;	
}


///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members

STDMETHODIMP SapRootHandler::GetClassID
(
	CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_IPXSapExtension;

    return hrOK;
}

/*!--------------------------------------------------------------------------
	SapRootHandler::OnExpand
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapRootHandler::OnExpand(ITFSNode *pNode,
								 LPDATAOBJECT pDataObject,
								 DWORD dwType,
								 LPARAM arg,
								 LPARAM lParam)
{
	HRESULT	                hr = hrOK;
	SPITFSNode			    spNode;
	SPIRtrMgrProtocolInfo	spRmProt;
    SPIRtrMgrInfo           spRm;
    SPIRouterInfo           spRouterInfo;
    LONG_PTR               ulConnId;

	// Grab the router info from the dataobject
	spRm.Query(pDataObject);
	Assert(spRm);

	spRm->GetParentRouterInfo(&spRouterInfo);

	// Setup the advise on the RtrMgr (to see when BootP is added/removed)
	spRm->RtrAdvise(&m_IRtrAdviseSink, &ulConnId, 0);

    // add things to our map for later
    AddRtrObj(ulConnId, IID_IRtrMgrInfo, spRm);
    AddScopeItem(spRm->GetMachineName(), (HSCOPEITEM) lParam);

    hr = spRm->FindRtrMgrProtocol(IPX_PROTOCOL_SAP, &spRmProt);
	if (!FHrOK(hr))
	{
		// Treat this as an already expanded node, we depend on
		// the notification mechanism to let us know if something
		// changes
		goto Error;
	}

	CORg( AddProtocolNode(pNode, spRouterInfo) );

    SetProtocolAdded(ulConnId, TRUE);

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	SapRootHandler::OnCreateDataObject
		Implementation of ITFSNodeHandler::OnCreateDataObject
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP SapRootHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT		    hr = hrOK;
	SPIRouterInfo   spRouterInfo;
    
    COM_PROTECT_TRY
	{
        // this will always be null
		if (spRouterInfo == NULL)
		{
			// If we haven't created the sub nodes yet, we still have to
			// create a dataobject.
			CDataObject *	pObject = NULL;
			SPIDataObject	spDataObject;
			SPITFSNode		spNode;
			SPITFSNodeHandler	spHandler;
			
			pObject = new CDataObject;
			spDataObject = pObject;	// do this so that it gets released correctly
			Assert(pObject != NULL);
			
			// Save cookie and type for delayed rendering
			pObject->SetType(type);
			pObject->SetCookie(cookie);
			
			// Store the coclass with the data object
			pObject->SetClsid(*(m_spTFSCompData->GetCoClassID()));
			
			pObject->SetTFSComponentData(m_spTFSCompData);
			
			hr = pObject->QueryInterface(IID_IDataObject, 
									 reinterpret_cast<void**>(ppDataObject));
			
		}
		else
			hr = CreateDataObjectFromRouterInfo(spRouterInfo,
												type, cookie, m_spTFSCompData,
												ppDataObject);
	}
	COM_PROTECT_CATCH;
	return hr;
}



ImplementEmbeddedUnknown(SapRootHandler, IRtrAdviseSink)

STDMETHODIMP SapRootHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
	DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
 	InitPThis(SapRootHandler, IRtrAdviseSink);
	HRESULT		    hr = hrOK;
	SPITFSNode	    spNode;
    SPIRtrMgrInfo   spRm;
    SPIRouterInfo   spRouterInfo;

	if (dwObjectType != ROUTER_OBJ_RmProt)
		return hr;

	COM_PROTECT_TRY
	{
        CORg (pThis->GetRtrObj(ulConn, (IUnknown **) &spRm));

		if (dwChangeType == ROUTER_CHILD_ADD)
		{
			// check to see if BootP is in the current list
			if (spRm->FindRtrMgrProtocol(IPX_PROTOCOL_SAP, NULL) == hrOK)
			{
				// We found Bootp, add our child node if we
				// don't have a child node
				if (!pThis->IsProtocolAdded(ulConn))
				{
                	spRm->GetParentRouterInfo(&spRouterInfo);
					pThis->m_spNodeMgr->GetRootNode(&spNode);
					pThis->AddProtocolNode(spNode, spRouterInfo);
					pThis->SetProtocolAdded(ulConn, TRUE);
				}
			}
		}
		else if (dwChangeType == ROUTER_CHILD_DELETE)
		{
			if (spRm->FindRtrMgrProtocol(IPX_PROTOCOL_SAP, NULL) == hrFalse)
			{
				// couldn't find Bootp, delete all of our child nodes
				pThis->m_spNodeMgr->GetRootNode(&spNode);
				pThis->RemoveNode(spNode, spRm->GetMachineName());
			    pThis->SetProtocolAdded(ulConn, FALSE);
			}
		}

        COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	
	return hr;
}

/*!--------------------------------------------------------------------------
	SapRootHandler::DestroyHandler
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP SapRootHandler::DestroyHandler(ITFSNode *pNode)
{
    RemoveAllNodes(pNode);
    RemoveAllRtrObj();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	SapRootHandler::AddProtocolNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapRootHandler::AddProtocolNode(ITFSNode *pNode, IRouterInfo * pRouterInfo)
{
	SPITFSNodeHandler	spHandler;
	SapNodeHandler *    pHandler = NULL;
	HRESULT				hr = hrOK;
	SPITFSNode			spNode;
    HSCOPEITEM          hScopeItem, hOldScopeItem;
    
    // Windows NT Bug : 246822
    // Due to the server list programming model, we need to setup
    // the proper scopeitem (so that MMC adds this to the proper
    // node).
    
    // Get the proper scope item for this node.
    // ----------------------------------------------------------------
    Verify( GetScopeItem(pRouterInfo->GetMachineName(), &hScopeItem) == hrOK);

    
    // Get the old one and save it.  place the new one in the node.
    // ----------------------------------------------------------------
    hOldScopeItem = pNode->GetData(TFS_DATA_SCOPEID);
    pNode->SetData(TFS_DATA_SCOPEID, hScopeItem);

	pHandler = new SapNodeHandler(m_spTFSCompData);
	spHandler = pHandler;
	CORg( pHandler->Init(pRouterInfo, &m_ConfigStream) );

	CreateContainerTFSNode(&spNode,
						   &GUID_IPXSapNodeType,
						   static_cast<ITFSNodeHandler *>(pHandler),
						   static_cast<ITFSResultHandler *>(pHandler),
						   m_spNodeMgr);

	// Call to the node handler to init the node data
	pHandler->ConstructNode(spNode);
				
	// Make the node immediately visible
	spNode->SetVisibilityState(TFS_VIS_SHOW);
	pNode->AddChild(spNode);

Error:
    // Restore the scope item
    pNode->SetData(TFS_DATA_SCOPEID, hOldScopeItem);
	return hr;
}

/*!--------------------------------------------------------------------------
	SapRootHandler::CompareNodeToMachineName
		This function is used by the RemoveNode() function.

        Returns hrOK if this node is a DHCP relay node and corresponds
        to the pszMachineName.
        Returns hrFalse if this is not the indicated node.
        Returns errors otherwise.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapRootHandler::CompareNodeToMachineName(ITFSNode *pNode,
    LPCTSTR pszMachineName)
{
    HRESULT     hr = hrFalse;

    // Should check that this is a SAP node
    if (*(pNode->GetNodeType()) != GUID_IPXSapNodeType)
        hr = hrFalse;
    else
    {
        IPXConnection *  pIPXConn;
        
        pIPXConn = GET_SAP_NODEDATA(pNode);
        if (StriCmp(pszMachineName, pIPXConn->GetMachineName()) == 0)
            hr = hrOK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\sapprop.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    sapprop.h
//
// History:
//	07/22/97	Kenn M. Takara			Created.
//
//	IP Summary property sheet and property pages
//
//============================================================================


#ifndef _SAPPROP_H
#define _SAPPROP_H

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _RTRSHEET_H
#include "rtrsheet.h"
#endif

#ifndef __IPCTRL_H
#include "ipctrl.h"
#endif


/*---------------------------------------------------------------------------
	Forward declarations
 ---------------------------------------------------------------------------*/
class IPXConnection;
class SapProperties;
class SapInterfaceProperties;



/*---------------------------------------------------------------------------
	Class:	SapPageGeneral

	This class handles the General page of the Sap sheet.
 ---------------------------------------------------------------------------*/
class SapPageGeneral :
   public RtrPropertyPage
{
public:
	SapPageGeneral(UINT nIDTemplate, UINT nIDCaption = 0)
			: RtrPropertyPage(nIDTemplate, nIDCaption)
	{};

	HRESULT	Init(SapProperties * pIPPropSheet);

protected:
	// Override the OnApply() so that we can grab our data from the
	// controls in the dialog.
	virtual BOOL OnApply();

	SapProperties *	m_pSapPropSheet;

	void			SetErrorLevelButtons(DWORD dwErrorLevel);
	DWORD			QueryErrorLevelButtons();

	//{{AFX_VIRTUAL(SapPageGeneral)
	protected:
	virtual VOID	DoDataExchange(CDataExchange *pDX);
	//}}AFX_VIRTUAL

	//{{AFX_MSG(SapPageGeneral)
	virtual BOOL	OnInitDialog();
	afx_msg void	OnButtonClicked();
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};


/*---------------------------------------------------------------------------
	Class:	SapProperties

	This is the property sheet support class for the properties page of
	the Sap node.
 ---------------------------------------------------------------------------*/

class SapProperties :
	public RtrPropertySheet
{
public:
	SapProperties(ITFSNode *pNode,
						IComponentData *pComponentData,
						ITFSComponentData *pTFSCompData,
						LPCTSTR pszSheetName,
						CWnd *pParent = NULL,
						UINT iPage=0,
						BOOL fScopePane = TRUE);

	HRESULT	Init(IRtrMgrInfo *pRm);

	virtual BOOL SaveSheetData();

	// Loads the infobase for this interface.
	HRESULT	LoadInfoBase(IPXConnection *pIPXConn);
	HRESULT GetInfoBase(IInfoBase **ppInfoBase);
	
protected:
	SPIRtrMgrInfo			m_spRm;
	SPIRtrMgrInterfaceInfo	m_spRmIf;
	SPIInterfaceInfo		m_spIf;
	SapPageGeneral			m_pageGeneral;
	SPITFSNode				m_spNode;
	SPIInfoBase				m_spInfoBase;
};


/*---------------------------------------------------------------------------
	Class:	SapInterfacePageGeneral

	This class handles the General page of the Sap sheet.
 ---------------------------------------------------------------------------*/
class SapInterfacePageGeneral :
   public RtrPropertyPage
{
public:
	SapInterfacePageGeneral(UINT nIDTemplate, UINT nIDCaption = 0)
			: RtrPropertyPage(nIDTemplate, nIDCaption)
	{};

	HRESULT	Init(SapInterfaceProperties * pIPPropSheet, IInterfaceInfo *pIf);

protected:
	// Override the OnApply() so that we can grab our data from the
	// controls in the dialog.
	virtual BOOL OnApply();

	// Brings up either the input or output filters
	void	ShowFilter(BOOL fOutputFilter);
	
	SapInterfaceProperties *	m_pSapIfPropSheet;
	SPIInterfaceInfo		m_spIf;
	CSpinButtonCtrl			m_spinInterval;
	CSpinButtonCtrl			m_spinMultiplier;

	//{{AFX_VIRTUAL(SapInterfacePageGeneral)
	protected:
	virtual VOID	DoDataExchange(CDataExchange *pDX);
	//}}AFX_VIRTUAL

	//{{AFX_MSG(SapInterfacePageGeneral)
	virtual BOOL	OnInitDialog();
	afx_msg	void	OnButtonClicked();
	afx_msg	void	OnUpdateButtonClicked();
	afx_msg void	OnChangeEdit();
	afx_msg	void	OnInputFilter();
	afx_msg	void	OnOutputFilter();
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};



/*---------------------------------------------------------------------------
	Class:	SapInterfaceProperties

	This is the property sheet support class for the properties page of
	the SAP node.
 ---------------------------------------------------------------------------*/

class SapInterfaceProperties :
	public RtrPropertySheet
{
public:
	SapInterfaceProperties(ITFSNode *pNode,
						IComponentData *pComponentData,
						ITFSComponentData *pTFSCompData,
						LPCTSTR pszSheetName,
						CWnd *pParent = NULL,
						UINT iPage=0,
						BOOL fScopePane = TRUE);

	HRESULT	Init(IInterfaceInfo *pIf, IRtrMgrInfo *pRm);

	virtual BOOL SaveSheetData();
	virtual void CancelSheetData();

	// Loads the infobase for this interface.
	HRESULT	LoadInfoBase(IPXConnection *pIPXConn);
	HRESULT GetInfoBase(IInfoBase **ppInfoBase);
	
	BOOL					m_bNewInterface;

	
protected:
	SPIRtrMgrInfo			m_spRm;
	SPIRtrMgrInterfaceInfo	m_spRmIf;
	SPIInterfaceInfo		m_spIf;
	SapInterfacePageGeneral	m_pageGeneral;
	SPITFSNode				m_spNode;
	SPIInfoBase				m_spInfoBase;
	BOOL					m_bClientInfoBase;
};



#endif _SAPPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\sapstats.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    sapstats.h
//
// History:
//	07/22/97	Kenn M. Takara			Created.
//
//	IP Statistics
//
//============================================================================


#ifndef _SAPSTATS_H_
#define _SAPSTATS_H_

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _STATSDLG_H
#include "statsdlg.h"
#endif

#ifndef _IPXSTATS_H
#include "ipxstats.h"
#endif

enum
{
	MVR_SAPPARAMS_OPER_STATE = 0,
	MVR_SAPPARAMS_SENT_PKTS,
	MVR_SAPPARAMS_RCVD_PKTS,
	MVR_SAPPARAMS_COUNT,
};

class SAPParamsStatistics : public IPXStatisticsDialog
{
public:
	SAPParamsStatistics();

	// Override the OnInitDialog so that we can set the caption
	virtual BOOL OnInitDialog();

	// Override the RefreshData to provide sample data
	virtual HRESULT RefreshData(BOOL fGrabNewData);

	// Override the Sort to provide the ability to do sorting
	// actually we don't do any sorting (this is a vertical format)
	virtual void Sort(UINT nColumnId);

protected:
};



#endif _SAPSTATS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\sapstrm.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	sapstrm.h
		SAP node configuration object.

		Use this to get/set configuration data.  This class will take
		care of versioning of config formats as well as serializing
		of the data.
		
    FILE HISTORY:
        
*/

#ifndef _SAPSTRM_H
#define _SAPSTRM_H

#ifndef _XSTREAM_H
#include "xstream.h"
#endif

#ifndef _IPXADMIN_H
#include "ipxadmin.h"
#endif

#ifndef _COLUMN_H
#include "column.h"
#endif

#ifndef _CONFIG_H
// #include "config.h"
#endif

enum
{
	SAP_COLUMNS = 0,
	SAP_COLUMNS_MAX_COUNT = 1,
};

enum
{
	SAPSTRM_STATS_SAPPARAMS = 0,
	SAPSTRM_STATS_COUNT,
};

enum SAPSTRM_TAG
{
	SAPSTRM_TAG_VERSION =		XFER_TAG(1, XFER_DWORD),
	SAPSTRM_TAG_VERSIONADMIN =	XFER_TAG(2, XFER_DWORD),
	
	SAPSTRM_TAG_STATS_SAPPARAMS_COLUMNS =	XFER_TAG(3, XFER_COLUMNDATA_ARRAY),
	SAPSTRM_TAG_STATS_SAPPARAMS_SORT =	XFER_TAG(4, XFER_DWORD),
	SAPSTRM_TAG_STATS_SAPPARAMS_ASCENDING =	XFER_TAG(5, XFER_DWORD),
	SAPSTRM_TAG_STATS_SAPPARAMS_POSITION =	XFER_TAG(6, XFER_RECT),

	
};

/*---------------------------------------------------------------------------
	Class:	SapConfigStream

	This holds the configuration information for the IP administration
	nodes.  This does NOT hold the configuration information for the columns.
	That is stored in the Component Configuration streams.
 ---------------------------------------------------------------------------*/
class SapConfigStream : public ConfigStream
{
public:
	SapConfigStream();

	virtual HRESULT	InitNew();				// set defaults
	virtual HRESULT	SaveTo(IStream *pstm);
	virtual HRESULT SaveAs(UINT nVersion, IStream *pstm);
	
	virtual HRESULT LoadFrom(IStream *pstm);

	virtual HRESULT GetSize(ULONG *pcbSize);

	// --------------------------------------------------------
	// Accessors
	// --------------------------------------------------------
	
	virtual HRESULT	GetVersionInfo(DWORD *pnVersion, DWORD *pnAdminVersion);

private:
	HRESULT XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize);
};



class SapComponentConfigStream : public ConfigStream
{
public:
	virtual HRESULT XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize);
protected:
};


#endif _SAPSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\sapview.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	sapview.cpp
		IPX SAP node implementation.
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "util.h"
#include "sapview.h"
#include "reg.h"
#include "rtrutil.h"	// smart MPR handle pointers
#include "sapstrm.h"	// IPAdminConfigStream
#include "strmap.h"		// XXXtoCString functions
#include "service.h"	// TFS service APIs
#include "format.h"		// FormatNumber function
#include "coldlg.h"		// columndlg
#include "column.h"		// ComponentConfigStream
#include "rtrui.h"
#include "sapprop.h"	// SAP property pages
#include "routprot.h"	// IP_LOCAL
#include "ipxstrm.h"
#include "ipxutil.h"	// String conversions
#include "globals.h"	// SAP defaults


/*---------------------------------------------------------------------------
	Keep this in sync with the column ids in sapview.h
 ---------------------------------------------------------------------------*/
extern const ContainerColumnInfo	s_rgSapViewColumnInfo[];

const ContainerColumnInfo	s_rgSapViewColumnInfo[] = 
{
	{ IDS_SAP_COL_INTERFACE,		CON_SORT_BY_STRING,	TRUE, COL_IF_NAME },
	{ IDS_SAP_COL_TYPE,				CON_SORT_BY_STRING,	TRUE, COL_STRING },
	{ IDS_SAP_COL_ACCEPT_ROUTES,	CON_SORT_BY_STRING,	FALSE, COL_STRING },
	{ IDS_SAP_COL_SUPPLY_ROUTES,	CON_SORT_BY_STRING,	FALSE, COL_STRING },
	{ IDS_SAP_COL_REPLY_GSNR,		CON_SORT_BY_STRING, FALSE, COL_STRING },
	{ IDS_SAP_COL_UPDATE_MODE,		CON_SORT_BY_STRING,	TRUE, COL_STRING },
	{ IDS_SAP_COL_UPDATE_PERIOD,	CON_SORT_BY_DWORD,	FALSE, COL_DURATION },
	{ IDS_SAP_COL_AGE_MULTIPLIER,	CON_SORT_BY_DWORD,	FALSE, COL_SMALL_NUM },
	{ IDS_SAP_COL_ADMIN_STATE,		CON_SORT_BY_STRING,	TRUE, COL_STATUS },
	{ IDS_SAP_COL_OPER_STATE,		CON_SORT_BY_STRING,	TRUE, COL_STATUS },
	{ IDS_SAP_COL_PACKETS_SENT,		CON_SORT_BY_DWORD,	TRUE, COL_LARGE_NUM },
	{ IDS_SAP_COL_PACKETS_RECEIVED,	CON_SORT_BY_DWORD,	TRUE, COL_LARGE_NUM },
};


/*---------------------------------------------------------------------------
	SapNodeHandler implementation
 ---------------------------------------------------------------------------*/

SapNodeHandler::SapNodeHandler(ITFSComponentData *pCompData)
	: BaseContainerHandler(pCompData, SAP_COLUMNS,
						   s_rgSapViewColumnInfo),
	m_ulConnId(0),
	m_ulRmConnId(0),
	m_ulRefreshConnId(0),
	m_ulStatsConnId(0)
{
	// Setup the verb states
	m_rgButtonState[MMC_VERB_PROPERTIES_INDEX] = ENABLED;
	m_bState[MMC_VERB_PROPERTIES_INDEX] = TRUE;

	m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
	m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;
	
}


STDMETHODIMP SapNodeHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IRtrAdviseSink)
		*ppv = &m_IRtrAdviseSink;
	else
		return BaseContainerHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;	
}



/*!--------------------------------------------------------------------------
	SapNodeHandler::DestroyHandler
		Implementation of ITFSNodeHandler::DestroyHandler
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP SapNodeHandler::DestroyHandler(ITFSNode *pNode)
{
	IPXConnection *	pIPXConn;

	pIPXConn = GET_SAP_NODEDATA(pNode);
	pIPXConn->Release();

	if (m_ulRefreshConnId)
	{
		SPIRouterRefresh	spRefresh;
		if (m_spRouterInfo)
			m_spRouterInfo->GetRefreshObject(&spRefresh);
		if (spRefresh)
			spRefresh->UnadviseRefresh(m_ulRefreshConnId);
	}
	m_ulRefreshConnId = 0;
	
	if (m_ulStatsConnId)
	{
		SPIRouterRefresh	spRefresh;
		if (m_spRouterInfo)
			m_spRouterInfo->GetRefreshObject(&spRefresh);
		if (spRefresh)
			spRefresh->UnadviseRefresh(m_ulStatsConnId);		
	}
	m_ulStatsConnId = 0;

	
	if (m_ulConnId)
		m_spRmProt->RtrUnadvise(m_ulConnId);
	m_ulConnId = 0;
	m_spRmProt.Release();
	
	if (m_ulRmConnId)
		m_spRm->RtrUnadvise(m_ulRmConnId);
	m_ulRmConnId = 0;
	m_spRm.Release();

	WaitForStatisticsWindow(&m_SAPParamsStats);

	m_spRouterInfo.Release();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	SapNodeHandler::HasPropertyPages
		Implementation of ITFSNodeHandler::HasPropertyPages
	NOTE: the root node handler has to over-ride this function to 
	handle the snapin manager property page (wizard) case!!!
	
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
SapNodeHandler::HasPropertyPages
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	return hrOK;
}


/*!--------------------------------------------------------------------------
	SapNodeHandler::CreatePropertyPages
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP
SapNodeHandler::CreatePropertyPages
(
	ITFSNode *				pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject, 
	LONG_PTR					handle, 
	DWORD					dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT		hr = hrOK;
	SapProperties *	pProperties = NULL;
	SPIComponentData spComponentData;
	CString		stTitle;

	CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

	pProperties = new SapProperties(pNode, spComponentData,
		m_spTFSCompData, stTitle);

	CORg( pProperties->Init(m_spRm) );

	if (lpProvider)
		hr = pProperties->CreateModelessSheet(lpProvider, handle);
	else
		hr = pProperties->DoModelessSheet();

Error:
	return hr;
}


/*---------------------------------------------------------------------------
	Menu data structure for our menus
 ---------------------------------------------------------------------------*/

static const SRouterNodeMenu	s_rgIfNodeMenu[] =
{
	{ IDS_MENU_SAP_SHOW_PARAMS, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },
};



/*!--------------------------------------------------------------------------
	SapNodeHandler::OnAddMenuItems
		Implementation of ITFSNodeHandler::OnAddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP SapNodeHandler::OnAddMenuItems(
	ITFSNode *pNode,
	LPCONTEXTMENUCALLBACK pContextMenuCallback, 
	LPDATAOBJECT lpDataObject, 
	DATA_OBJECT_TYPES type, 
	DWORD dwType,
	long *pInsertionAllowed)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = S_OK;
    SapNodeHandler::SMenuData   menuData;
	
	COM_PROTECT_TRY
	{
        menuData.m_spNode.Set(pNode);
        
		hr = AddArrayOfMenuItems(pNode, s_rgIfNodeMenu,
								 DimensionOf(s_rgIfNodeMenu),
								 pContextMenuCallback,
								 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
	}
	COM_PROTECT_CATCH;
		
	return hr; 
}

/*!--------------------------------------------------------------------------
	SapNodeHandler::OnCommand
		Implementation of ITFSNodeHandler::OnCommand
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP SapNodeHandler::OnCommand(ITFSNode *pNode, long nCommandId, 
										   DATA_OBJECT_TYPES	type, 
										   LPDATAOBJECT pDataObject, 
										   DWORD	dwType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;

	COM_PROTECT_TRY
	{
		switch (nCommandId)
		{
			case IDS_MENU_SAP_SHOW_PARAMS:
				CreateNewStatisticsWindow(&m_SAPParamsStats,
										  ::FindMMCMainWindow(),
										  IDD_STATS_NARROW);
				break;
			case IDS_MENU_SYNC:
				SynchronizeNodeData(pNode);
				break;
		}
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	SapNodeHandler::OnExpand
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapNodeHandler::OnExpand(ITFSNode *pNode,
								 LPDATAOBJECT pDataObject,
								 DWORD dwType,
								 LPARAM arg,
								 LPARAM lParam)
{
	HRESULT	hr = hrOK;
	SPIEnumInterfaceInfo	spEnumIf;
	SPIInterfaceInfo		spIf;
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPIInfoBase				spInfoBase;
	
	if (m_bExpanded)
		return hrOK;

	COM_PROTECT_TRY
	{
		CORg( m_spRouterInfo->EnumInterface(&spEnumIf) );

		while (spEnumIf->Next(1, &spIf, NULL) == hrOK)
		{
			if (spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) == hrOK)
			{
				if (spRmIf->FindRtrMgrProtocolInterface(IPX_PROTOCOL_SAP, NULL) == hrOK)
				{
					// Now we create an interface node for this interface
					AddInterfaceNode(pNode, spIf, FALSE);
				}

			}
			spRmIf.Release();
			spIf.Release();
		}

		//$CLIENT: Add the client interface (setup default data)
		// the only thing that we can do in synchronize is to
		// get the Administrative status
		AddInterfaceNode(pNode, NULL, TRUE);

		m_bExpanded = TRUE;

		// Now that we have all of the nodes, update the data for
		// all of the nodes
		SynchronizeNodeData(pNode);

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	m_bExpanded = TRUE;

	return hr;
}

/*!--------------------------------------------------------------------------
	SapNodeHandler::GetString
		Implementation of ITFSNodeHandler::GetString
		We don't need to do anything, since our root node is an extension
		only and thus can't do anything to the node text.
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) SapNodeHandler::GetString(ITFSNode *pNode, int nCol)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		if (m_stTitle.IsEmpty())
			m_stTitle.LoadString(IDS_IPX_SAP_TITLE);
	}
	COM_PROTECT_CATCH;

	return m_stTitle;
}

/*!--------------------------------------------------------------------------
	SapNodeHandler::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP SapNodeHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{

		Assert(m_spRmProt);
		
		CORg( CreateDataObjectFromRtrMgrProtocolInfo(m_spRmProt,
			type, cookie, m_spTFSCompData,
			ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}


/*!--------------------------------------------------------------------------
	SapNodeHandler::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapNodeHandler::Init(IRouterInfo *pRouter, SapConfigStream *pConfigStream)
{
	m_spRouterInfo.Set(pRouter);
	
	m_spRm.Release();
	pRouter->FindRtrMgr(PID_IPX, &m_spRm);

	m_spRmProt.Release();
	m_spRm->FindRtrMgrProtocol(IPX_PROTOCOL_SAP, &m_spRmProt);
	
	m_pConfigStream = pConfigStream;
	
	// Also need to register for change notifications from IPX_PROTOCOL_SAP
	Assert(m_ulConnId == 0);
	m_spRmProt->RtrAdvise(&m_IRtrAdviseSink, &m_ulConnId, 0);

	// Need to register for change notifications on the Router manager
	// This way we can add the necessary protocols when an interface
	// gets added.
	Assert(m_ulRmConnId == 0);
	m_spRm->RtrAdvise(&m_IRtrAdviseSink, &m_ulRmConnId, 0);

	m_SAPParamsStats.SetConfigInfo(pConfigStream, SAPSTRM_STATS_SAPPARAMS);

	return hrOK;
}


/*!--------------------------------------------------------------------------
	SapNodeHandler::ConstructNode
		Initializes the root node (sets it up).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapNodeHandler::ConstructNode(ITFSNode *pNode)
{
	HRESULT			hr = hrOK;
	IPXConnection *	pIPXConn = NULL;
	
	if (pNode == NULL)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Need to initialize the data for the root node
		pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_IPX_NODE_GENERAL);
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_IPX_NODE_GENERAL);
		pNode->SetData(TFS_DATA_SCOPEID, 0);

        // This is a leaf node in the scope pane
        pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

		m_cookie = reinterpret_cast<DWORD_PTR>(pNode);
		pNode->SetData(TFS_DATA_COOKIE, m_cookie);

		pNode->SetNodeType(&GUID_IPXSapNodeType);

		
		pIPXConn = new IPXConnection;
		pIPXConn->SetMachineName(m_spRouterInfo->GetMachineName());

		SET_SAP_NODEDATA(pNode, pIPXConn);

		m_SAPParamsStats.SetConnectionData(pIPXConn);
	}
	COM_PROTECT_CATCH;

	if (!FHrSucceeded(hr))
	{
		SET_SAP_NODEDATA(pNode, NULL);
		if (pIPXConn)
			pIPXConn->Release();
	}

	return hr;
}


/*!--------------------------------------------------------------------------
	SapNodeHandler::AddInterfaceNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT	SapNodeHandler::AddInterfaceNode(ITFSNode *pParent,
										 IInterfaceInfo *pIf,
										 BOOL fClient)
{
	Assert(pParent);
	
	SapInterfaceHandler *	pHandler;
	SPITFSResultHandler		spHandler;
	SPITFSNode				spNode;
	HRESULT					hr = hrOK;
	BaseIPXResultNodeData *		pData;
	IPXConnection *			pIPXConn;
	SPIInfoBase				spInfoBase;
	PSAP_IF_CONFIG			pric = NULL;
	SPIRtrMgrInterfaceInfo	spRmIf;

	// Create the handler for this node 
	pHandler = new SapInterfaceHandler(m_spTFSCompData);
	spHandler = pHandler;
	CORg( pHandler->Init(pIf, m_spRouterInfo, pParent) );

	pIPXConn = GET_SAP_NODEDATA(pParent);

	// Create a result item node (or a leaf node)
	CORg( CreateLeafTFSNode(&spNode,
							NULL,
							static_cast<ITFSNodeHandler *>(pHandler),
							static_cast<ITFSResultHandler *>(pHandler),
							m_spNodeMgr) );
	CORg( pHandler->ConstructNode(spNode, pIf, pIPXConn) );

	pData = GET_BASEIPXRESULT_NODEDATA(spNode);
	Assert(pData);
	ASSERT_BASEIPXRESULT_NODEDATA(pData);

	pData->m_fClient = fClient;

	// If we don't have an interface, then this is a client node
	if (pIf)
	{
		pIf->FindRtrMgrInterface(PID_IPX, &spRmIf);
		
		if (spRmIf)
			spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase);

		if (spInfoBase)
			spInfoBase->GetData(IPX_PROTOCOL_SAP, 0, (LPBYTE *) &pric);

		Trace1("Adding SAP node : %s\n", pIf->GetTitle());
	}
	else
	{
		// This is a client, make it visible
		pric = (PSAP_IF_CONFIG) ULongToPtr(0xFFFFFFFF);
		
		Trace0("Adding client interface\n");
	}

	// if pric == NULL, then we are adding this protocol to the
	// interface and we need to hide the node.
	if (pric)
	{
		CORg( spNode->SetVisibilityState(TFS_VIS_SHOW) );
		CORg( spNode->Show() );
	}
	else
		CORg( spNode->SetVisibilityState(TFS_VIS_HIDE) );
	CORg( pParent->AddChild(spNode) );

Error:
	return hr;
}

/*---------------------------------------------------------------------------
	This is the set of menus that will appear when a right-click is
	done on the blank area of the result pane.
 ---------------------------------------------------------------------------*/
static const SRouterNodeMenu	s_rgSapResultNodeMenu[] =
{
	{ IDS_MENU_SAP_SHOW_PARAMS, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },
};




/*!--------------------------------------------------------------------------
	SapNodeHandler::AddMenuItems
		Implementation of ITFSResultHandler::AddMenuItems
		Use this to add commands to the context menu of the blank areas
		of the result pane.
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP SapNodeHandler::AddMenuItems(ITFSComponent *pComponent,
											  MMC_COOKIE cookie,
											  LPDATAOBJECT pDataObject,
											  LPCONTEXTMENUCALLBACK pCallback,
											  long *pInsertionAllowed)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT	hr = hrOK;
	SPITFSNode	spNode;
    SapNodeHandler::SMenuData   menuData;

	COM_PROTECT_TRY
	{
		m_spNodeMgr->FindNode(cookie, &spNode);
        menuData.m_spNode.Set(spNode);
        
		hr = AddArrayOfMenuItems(spNode,
								 s_rgSapResultNodeMenu,
								 DimensionOf(s_rgSapResultNodeMenu),
								 pCallback,
								 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
	}
	COM_PROTECT_CATCH;

	return hr;
}


/*!--------------------------------------------------------------------------
	SapNodeHandler::Command
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP SapNodeHandler::Command(ITFSComponent *pComponent,
									   MMC_COOKIE cookie,
									   int nCommandID,
									   LPDATAOBJECT pDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT		hr = hrOK;

	switch (nCommandID)
	{
		case IDS_MENU_SAP_SHOW_PARAMS:
			CreateNewStatisticsWindow(&m_SAPParamsStats,
									  ::FindMMCMainWindow(),
									  IDD_STATS_NARROW);
			break;
	}
	return hr;
}



ImplementEmbeddedUnknown(SapNodeHandler, IRtrAdviseSink)

STDMETHODIMP SapNodeHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
	DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
	InitPThis(SapNodeHandler, IRtrAdviseSink);
	SPITFSNode				spThisNode;
	SPITFSNode				spNode;
	SPITFSNodeEnum			spEnumNode;
	SPIEnumInterfaceInfo	spEnumIf;
	SPIInterfaceInfo		spIf;
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPIInfoBase				spInfoBase;
	BOOL					fPleaseAdd;
	BOOL					fFound;
	BaseIPXResultNodeData *	pData;
	HRESULT					hr = hrOK;
	
	pThis->m_spNodeMgr->FindNode(pThis->m_cookie, &spThisNode);

	if (dwObjectType == ROUTER_OBJ_RmIf)
	{
		if (dwChangeType == ROUTER_CHILD_PREADD)
		{
			// Add SAP to the infobase
			pThis->AddProtocolToInfoBase(spThisNode);
		}
		else if (dwChangeType == ROUTER_CHILD_ADD)
		{
			// Add the protocol to the router mgr
			// We need to add the protocol to the interface (use
			// default values).
			pThis->AddProtocolToInterface(spThisNode);
		}
	}

	if (dwObjectType == ROUTER_OBJ_RmProtIf)
	{
		if (dwChangeType == ROUTER_CHILD_ADD)
		{
            // If the node hasn't been expanded yet, then we don't
            // need to do anything yet.
            if (pThis->m_bExpanded)
            {
                // Enumerate through the list of interfaces looking for
                // the interfaces that have this protocol.  If we find
                // one, look for this interface in our list of nodes.
                spThisNode->GetEnum(&spEnumNode);
                
                CORg( pThis->m_spRouterInfo->EnumInterface(&spEnumIf) );
                
                spEnumIf->Reset();
                
                fPleaseAdd = FALSE;
                
                for (; spEnumIf->Next(1, &spIf, NULL) == hrOK; spIf.Release())
                {
                    // Look for this interface in our list of nodes
                    // If it's there than continue on
                    fFound = FALSE;
                    spEnumNode->Reset();
                    spNode.Release();
                    
                    for (; spEnumNode->Next(1, &spNode, NULL) == hrOK; spNode.Release())
                    {
                        pData = GET_BASEIPXRESULT_NODEDATA(spNode);
                        Assert(pData);
                        ASSERT_BASEIPXRESULT_NODEDATA(pData);
                        
                        if (!pData->m_fClient && StriCmpW(pData->m_spIf->GetId(), spIf->GetId()) == 0)
                        {   
                            fFound = TRUE;
                            break;
                        }
                    }
                    
                    // If the interface was not found in the list of nodes,
                    // then it is a candidate.  Now we have to see if the
                    // interface supports this transport.
                    if (!fFound && (LookupRtrMgrProtocolInterface(spIf, PID_IPX, IPX_PROTOCOL_SAP, NULL) == hrOK))
                    {
                        // If this interface has this transport, and is NOT in
                        // the current list of nodes then add this interface
                        // to the UI
                        
                        // Grab the infobase
                        // Load the infobase for this interface
                        spRmIf.Release();
                        spInfoBase.Release();
                        hr = spIf->FindRtrMgrInterface(PID_IPX, &spRmIf);
                        
                        if (FHrOK(hr))
                        {
                            spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase);
                            hr  = pThis->AddInterfaceNode(spThisNode, spIf, FALSE);
                        }
                        fPleaseAdd = TRUE;
                    }
                }
                
                // Now that we have all of the nodes, update the data for
                // all of the nodes
                if (fPleaseAdd)
                    pThis->SynchronizeNodeData(spThisNode);                
            }
		}
		else if (dwChangeType == ROUTER_CHILD_DELETE)
		{
			// Go through the list of nodes, if we cannot find the
			// node in the list of interfaces, delete the node
			
			spThisNode->GetEnum(&spEnumNode);
			spEnumNode->Reset();
			while (spEnumNode->Next(1, &spNode, NULL) == hrOK)
			{
				// Get the node data, look for the interface
				pData = GET_BASEIPXRESULT_NODEDATA(spNode);
				ASSERT_BASEIPXRESULT_NODEDATA(pData);

				if (pData->m_spIf &&
					LookupRtrMgrProtocolInterface(pData->m_spIf,
						PID_IPX, IPX_PROTOCOL_SAP, NULL) != hrOK)
				{
					// If this flag is set, then we are in the new
					// interface case, and we do not want to delete
					// this here since it will then deadlock.
					if ((spNode->GetVisibilityState() & TFS_VIS_DELETE) == 0)
					{
						// cannot find the interface, release this node!
						spThisNode->RemoveChild(spNode);
						spNode->Destroy();
					}
				}
				spNode.Release();
				spIf.Release();
			}
			
		}
	}
	else if (dwChangeType == ROUTER_REFRESH)
	{
		if (ulConn == pThis->m_ulStatsConnId)
		{
			pThis->m_SAPParamsStats.PostRefresh();
		}
		else
			pThis->SynchronizeNodeData(spThisNode);
	}
   else if (dwChangeType == ROUTER_DO_DISCONNECT)
   {
	   IPXConnection *		pIPXConn = NULL;
   
	   pIPXConn = GET_SAP_NODEDATA(spThisNode);
	   pIPXConn->DisconnectAll();
   }
Error:
	return hr;
}

HRESULT SapNodeHandler::AddProtocolToInfoBase(ITFSNode *pThisNode)
{
	HRESULT			hr = hrOK;
	SPITFSNodeEnum	spEnumNode;
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPIRtrMgrProtocolInterfaceInfo	spRmProtIf;
	SPIEnumInterfaceInfo	spEnumIf;
	SPIInterfaceInfo		spIf;
	SPITFSNode		spNode;
	BaseIPXResultNodeData *	pData;

	// Enumerate through the list of interfaces looking for
	// the interfaces that have this protocol.  If we find
	// one, look for this interface in our list of nodes.
	pThisNode->GetEnum(&spEnumNode);
	
	CORg( m_spRouterInfo->EnumInterface(&spEnumIf) );
	
	spEnumIf->Reset();
	
	for (; spEnumIf->Next(1, &spIf, NULL) == hrOK; spIf.Release())
	{
		// Look for this interface in our list of nodes
		// If it's there than continue on
		spEnumNode->Reset();
		spNode.Release();
		spRmIf.Release();
		
		// If this interface has IPX but not SAP, add it
		if ((spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) == hrOK) &&
			(LookupRtrMgrProtocolInterface(spIf, PID_IPX,
										   IPX_PROTOCOL_SAP, NULL) != hrOK))
		{
			// Add SAP to this node
			SAP_IF_CONFIG		sic;
			SPIInfoBase			spInfoBase;
			
			// We need to get the infobase for this and create
			// the SAP blocks (but do NOT save, let the property
			// sheet take care of that).
			spInfoBase.Release();
			if (!FHrOK(spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase)))
            {
                spRmIf->Load(spRmIf->GetMachineName(), NULL, NULL, NULL);
                spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase);
            }
			if (!spInfoBase)
				CreateInfoBase(&spInfoBase);

			if (!FHrOK(spInfoBase->ProtocolExists(IPX_PROTOCOL_SAP)))
			{
				// Add a SAP_IF_CONFIG block
				BYTE *	pDefault;

				if (spIf->GetInterfaceType() == ROUTER_IF_TYPE_DEDICATED)
					pDefault = g_pIpxSapLanInterfaceDefault;
				else
					pDefault = g_pIpxSapInterfaceDefault;
				
				spInfoBase->AddBlock(IPX_PROTOCOL_SAP,
									 sizeof(SAP_IF_CONFIG),
									 pDefault,
									 1,
									 0);
				
				spRmIf->SetInfoBase(NULL, NULL, NULL, spInfoBase);
			}

		}
	}
	
	// Now that we have all of the nodes, update the data for
	// all of the nodes
//	if (fPleaseAdd)
//		pThis->SynchronizeNodeData(spThisNode);
Error:
	return hr;
}


HRESULT SapNodeHandler::AddProtocolToInterface(ITFSNode *pThisNode)
{
	HRESULT			hr = hrOK;
	SPITFSNodeEnum	spEnumNode;
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPIRtrMgrProtocolInterfaceInfo	spRmProtIf;
	SPIEnumInterfaceInfo	spEnumIf;
	SPIInterfaceInfo		spIf;
	SPITFSNode		spNode;
	BaseIPXResultNodeData *	pData;

	// Enumerate through the list of interfaces looking for
	// the interfaces that have this protocol.  If we find
	// one, look for this interface in our list of nodes.
	pThisNode->GetEnum(&spEnumNode);
	
	CORg( m_spRouterInfo->EnumInterface(&spEnumIf) );
	
	spEnumIf->Reset();
	
	for (; spEnumIf->Next(1, &spIf, NULL) == hrOK; spIf.Release())
	{
		// Look for this interface in our list of nodes
		// If it's there than continue on
		spEnumNode->Reset();
		spNode.Release();
		
		// If this interface has IPX but not SAP, add it
		if ((spIf->FindRtrMgrInterface(PID_IPX, NULL) == hrOK) &&
			(LookupRtrMgrProtocolInterface(spIf, PID_IPX,
										   IPX_PROTOCOL_SAP, NULL) != hrOK))
		{
			// Add SAP to this node
			SAP_IF_CONFIG		sic;
			RtrMgrProtocolCB	RmProtCB;
			RtrMgrProtocolInterfaceCB	RmProtIfCB;
			SPIInfoBase			spInfoBase;
			
			// Need to create an RmProtIf
			m_spRmProt->CopyCB(&RmProtCB);

			spRmProtIf.Release();
			
			RmProtIfCB.dwProtocolId = RmProtCB.dwProtocolId;
			StrnCpyW(RmProtIfCB.szId, RmProtCB.szId, RTR_ID_MAX);
			RmProtIfCB.dwTransportId = RmProtCB.dwTransportId;
			StrnCpyW(RmProtIfCB.szRtrMgrId, RmProtCB.szRtrMgrId, RTR_ID_MAX);
			
			StrnCpyW(RmProtIfCB.szInterfaceId, spIf->GetId(), RTR_ID_MAX);
			RmProtIfCB.dwIfType = spIf->GetInterfaceType();
			RmProtIfCB.szTitle[0] = 0;

			CORg( CreateRtrMgrProtocolInterfaceInfo(&spRmProtIf,
				&RmProtIfCB) );

			spRmProtIf->SetTitle(spIf->GetTitle());
			
			// Add this to the spRmIf
			spRmIf.Release();
			CORg( spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) );
			Assert(spRmIf);

			// We need to get the infobase for this and create
			// the SAP blocks (but do NOT save, let the property
			// sheet take care of that).
			spInfoBase.Release();
//			spRmIf->Load(spRmIf->GetMachineName(), NULL, NULL, NULL);
			spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase);
			if (!spInfoBase)
				CreateInfoBase(&spInfoBase);

			if (!FHrOK(spInfoBase->BlockExists(IPX_PROTOCOL_SAP)))
			{
				// Add a SAP_IF_CONFIG block
				BYTE *	pDefault;

				if (spIf->GetInterfaceType() == ROUTER_IF_TYPE_DEDICATED)
					pDefault = g_pIpxSapLanInterfaceDefault;
				else
					pDefault = g_pIpxSapInterfaceDefault;

				spInfoBase->AddBlock(IPX_PROTOCOL_SAP,
									 sizeof(SAP_IF_CONFIG),
									 pDefault,
									 1,
									 0);
			}

			
			CORg(spRmIf->AddRtrMgrProtocolInterface(spRmProtIf,
				spInfoBase /* pInfoBase */));
		}
	}
	
	// Now that we have all of the nodes, update the data for
	// all of the nodes
//	if (fPleaseAdd)
//		pThis->SynchronizeNodeData(spThisNode);
Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	SapNodeHandler::SynchronizeNodeData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapNodeHandler::SynchronizeNodeData(ITFSNode *pThisNode)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT	hr = hrOK;
	SPITFSNodeEnum	spNodeEnum;
	SPITFSNode		spNode;
	CStringList		ifidList;
	BaseIPXResultNodeData *	pNodeData;
	SapList	sapList;
	SapListEntry *	pSapEntry = NULL;
	SapListEntry *	pSapCurrent = NULL;
	int				i;
	CString			stNotAvailable;
	POSITION		pos;

	COM_PROTECT_TRY
	{	
		// Do the data gathering work (separate this from the rest of the
		// code so that we can move this part to a background thread later).

		stNotAvailable.LoadString(IDS_IPX_NOT_AVAILABLE);

		// We need to build up a list of interface ids
		pThisNode->GetEnum(&spNodeEnum);
		for (; spNodeEnum->Next(1, &spNode, NULL) == hrOK; spNode.Release() )
		{
			pNodeData = GET_BASEIPXRESULT_NODEDATA(spNode);
			Assert(pNodeData);
			ASSERT_BASEIPXRESULT_NODEDATA(pNodeData);
			
			pSapEntry = new SapListEntry;
			
			pSapEntry->m_spIf.Set(pNodeData->m_spIf);
			pSapEntry->m_spNode.Set(spNode);

			::ZeroMemory(&(pSapEntry->m_info), sizeof(pSapEntry->m_info));
			::ZeroMemory(&(pSapEntry->m_stats), sizeof(pSapEntry->m_stats));

			pSapEntry->m_fClient = pNodeData->m_fClient;
			pSapEntry->m_fFoundIfIndex = FALSE;
			pSapEntry->m_dwIfIndex = 0;
			
			sapList.AddTail(pSapEntry);
			pSapEntry = NULL;

			// Fill in the result data with '-'
			// This is a little bogus, but it's the easiest way, we
			// don't want to touch interface and relay_mode.
			for (i=SAP_SI_INTERFACE; i<SAP_SI_MAX_COLUMNS; i++)
			{
				pNodeData->m_rgData[i].m_stData = stNotAvailable;
				pNodeData->m_rgData[i].m_dwData = 0xFFFFFFFF;
			}

			// Update the necessary data
			if (pNodeData->m_fClient)
			{
				pNodeData->m_rgData[SAP_SI_INTERFACE].m_stData.LoadString(
					IDS_IPX_DIAL_IN_CLIENTS);
				pNodeData->m_rgData[SAP_SI_TYPE].m_stData =
					IpxTypeToCString(ROUTER_IF_TYPE_CLIENT);
			}
			else
			{
				pNodeData->m_rgData[SAP_SI_INTERFACE].m_stData =
					pNodeData->m_spIf->GetTitle();

				pNodeData->m_rgData[SAP_SI_TYPE].m_stData =
					IpxTypeToCString(pNodeData->m_spIf->GetInterfaceType());
			}
		}
		spNode.Release();


		// We can now use this list of ids, to get the data for each item
		CORg( GetSapData(pThisNode, &sapList) );

		// Now for each data item, fill in the appropriate data in
		// the node
		pos = sapList.GetHeadPosition();
		while (pos)
		{
			pSapCurrent = sapList.GetNext(pos);

			pNodeData = GET_BASEIPXRESULT_NODEDATA(pSapCurrent->m_spNode);
			Assert(pNodeData);
			ASSERT_BASEIPXRESULT_NODEDATA(pNodeData);


			pNodeData->m_rgData[SAP_SI_ACCEPT_ROUTES].m_stData =
					IpxAdminStateToCString(pSapCurrent->m_info.Listen);

			pNodeData->m_rgData[SAP_SI_SUPPLY_ROUTES].m_stData =
				IpxAdminStateToCString(pSapCurrent->m_info.Supply);

			pNodeData->m_rgData[SAP_SI_GSNR].m_stData =
				IpxAdminStateToCString(pSapCurrent->m_info.GetNearestServerReply);
			
			pNodeData->m_rgData[SAP_SI_UPDATE_MODE].m_stData =
				RipSapUpdateModeToCString(pSapCurrent->m_info.UpdateMode);

			FillInNumberData(pNodeData, SAP_SI_UPDATE_PERIOD,
							 pSapCurrent->m_info.PeriodicUpdateInterval);

			FillInNumberData(pNodeData, SAP_SI_AGE_MULTIPLIER,
							 pSapCurrent->m_info.AgeIntervalMultiplier);

			pNodeData->m_rgData[SAP_SI_ADMIN_STATE].m_stData =
				IpxAdminStateToCString(pSapCurrent->m_info.AdminState);

			if (!pSapCurrent->m_fClient)
			{
				pNodeData->m_rgData[SAP_SI_OPER_STATE].m_stData =
					IpxOperStateToCString(pSapCurrent->m_stats.SapIfOperState);

				FillInNumberData(pNodeData, SAP_SI_PACKETS_SENT,
								 pSapCurrent->m_stats.SapIfOutputPackets);
			
				FillInNumberData(pNodeData, SAP_SI_PACKETS_RECEIVED,
								 pSapCurrent->m_stats.SapIfInputPackets);
			}
			
			pSapCurrent->m_spNode->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);
		}
		

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	delete pSapEntry;
	while (!sapList.IsEmpty())
		delete sapList.RemoveTail();
	
	return hr;
}

/*!--------------------------------------------------------------------------
	SapNodeHandler::GetSapData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT	SapNodeHandler::GetSapData(ITFSNode *pThisNode, SapList *pSapList)
{
	HRESULT			hr = hrOK;
	BOOL			fIsServiceRunning;
	IPXConnection *	pIPXConn;
	SAP_MIB_GET_INPUT_DATA	MibGetInputData;
	SPIInfoBase		spInfoBase;
	POSITION		pos;
	SapListEntry *	pSapEntry;
	int				i;
	PSAP_INTERFACE	pSapIf = NULL;
	DWORD			cbSapIf;
	SPMprMibBuffer	spMib;
	DWORD			dwErr;
	SPIRtrMgrInterfaceInfo	spRmIf;
	PSAP_IF_CONFIG	pric;


	// Retrieve the IP interface table; we will need this in order to
	// map interface-names to interface-indices, and we will need the
	// interface-indices in order to query for SAP MIB information.
	//
	CORg( IsRouterServiceRunning(m_spRouterInfo->GetMachineName(), NULL) );
	fIsServiceRunning = (hr == hrOK);

	// Get the connection data
	pIPXConn = GET_SAP_NODEDATA(pThisNode);

	// Iterate through the list filling in the interface indexes
	CORg( FillInInterfaceIndex(pIPXConn, pSapList) );

	// Iterate throught the list of entries, gathering data for each
	// interface
	pos = pSapList->GetHeadPosition();
	while (pos)
	{
		pSapEntry = pSapList->GetNext(pos);
		
		if (!fIsServiceRunning)
			continue;

		if (pSapEntry->m_fClient)
		{
			// Fill in the client data
			FillClientData(pSapEntry);
			continue;
		}

		// Load the infobase and get the data for this entry
		spRmIf.Release();
		spInfoBase.Release();
		CORg( pSapEntry->m_spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) );
		if (!spRmIf)
			continue;

		CORg( spRmIf->Load(spRmIf->GetMachineName(), NULL, NULL, NULL) );
		CORg( spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase) );
		CORg( spInfoBase->GetData(IPX_PROTOCOL_SAP, 0, (LPBYTE *) &pric) );

		pSapEntry->m_info = pric->SapIfInfo;

		if (!pSapEntry->m_fFoundIfIndex)
			continue;

		// Now get the dynamic data from the MIBs

		spMib.Free();
		MibGetInputData.InterfaceIndex = pSapEntry->m_dwIfIndex;
		MibGetInputData.TableId = SAP_INTERFACE_TABLE;

		dwErr = ::MprAdminMIBEntryGet(pIPXConn->GetMibHandle(),
									  PID_IPX,
									  IPX_PROTOCOL_SAP,
									  &MibGetInputData,
									  sizeof(MibGetInputData),
									  (LPVOID *) &pSapIf,
									  &cbSapIf);
		spMib = (PBYTE) pSapIf;
		CWRg(dwErr);

		Assert(pSapIf);
		pSapEntry->m_stats = pSapIf->SapIfStats;
	}


	
Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	SapNodeHandler::FillInInterfaceIndex
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapNodeHandler::FillInInterfaceIndex(IPXConnection *pIPXConn, SapList *pSapList)
{
	HRESULT			hr = hrOK;
	POSITION		pos;
	SapListEntry *	pSapEntry;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD			IfSize = sizeof(IPX_INTERFACE);
	PIPX_INTERFACE	pIpxIf;
	DWORD			dwErr;
	SPMprMibBuffer	spMib;
	USES_CONVERSION;

	MibGetInputData.TableId = IPX_INTERFACE_TABLE;
	dwErr = ::MprAdminMIBEntryGetFirst(pIPXConn->GetMibHandle(),
									   PID_IPX,
									   IPX_PROTOCOL_BASE,
									   &MibGetInputData,
									   sizeof(IPX_MIB_GET_INPUT_DATA),
									   (LPVOID *) &pIpxIf,
									   &IfSize);
	hr = HRESULT_FROM_WIN32(dwErr);
	spMib = (LPBYTE) pIpxIf;

	while (FHrSucceeded(hr))
	{
		// go through the list of interfaces looking for a match
		pos = pSapList->GetHeadPosition();
		while (pos)
		{
			pSapEntry = pSapList->GetNext(pos);

			// If this is the client interface, we don't need to
			// look for an interface that matches
			if (pSapEntry->m_fClient)
				continue;

			if (StriCmp(pSapEntry->m_spIf->GetId(),
						A2CT((LPCSTR) pIpxIf->InterfaceName)) == 0)
			{
				Assert(pSapEntry->m_fFoundIfIndex == FALSE);
				
				pSapEntry->m_dwIfIndex = pIpxIf->InterfaceIndex;
				pSapEntry->m_fFoundIfIndex = TRUE;
				break;
			}
			pSapEntry = NULL;
		}

		// Go onto the next interface
		
		MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex =
			pIpxIf->InterfaceIndex;
		spMib.Free();
		pIpxIf = NULL;
		
		dwErr = ::MprAdminMIBEntryGetNext(pIPXConn->GetMibHandle(),
										  PID_IPX,
										  IPX_PROTOCOL_BASE,
										  &MibGetInputData,
										  sizeof(IPX_MIB_GET_INPUT_DATA),
										  (LPVOID *) &pIpxIf,
										  &IfSize);
		hr = HRESULT_FROM_WIN32(dwErr);
		spMib = (LPBYTE) pIpxIf;
	}
	
	
//Error:
	return hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) ? hrOK : hr;
}

/*!--------------------------------------------------------------------------
	SapNodeHandler::FillClientData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapNodeHandler::FillClientData(SapListEntry *pSapEntry)
{
	HRESULT		hr = hrOK;
	SPIInfoBase	spInfoBase;
	PSAP_IF_CONFIG	pric = NULL;

	Assert(pSapEntry->m_fClient == TRUE);
	Assert(pSapEntry->m_fFoundIfIndex == FALSE);

	CORg( m_spRm->GetInfoBase(NULL, NULL, NULL, &spInfoBase) );

	CORg( spInfoBase->GetData(IPX_PROTOCOL_SAP, 0, (LPBYTE *) &pric) );

	pSapEntry->m_info = pric->SapIfInfo;

	memset(&(pSapEntry->m_stats), 0xFF, sizeof(pSapEntry->m_stats));
	pSapEntry->m_dwIfIndex = 0xFFFFFFFF;
		
Error:
	return hr;
}



/*!--------------------------------------------------------------------------
	SapNodeHandler::OnResultShow
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapNodeHandler::OnResultShow(ITFSComponent *pTFSComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	BOOL	bSelect = (BOOL) arg;
	HRESULT	hr = hrOK;
	SPIRouterRefresh	spRefresh;
	SPITFSNode	spNode;

	BaseContainerHandler::OnResultShow(pTFSComponent, cookie, arg, lParam);

	if (bSelect)
	{
		// Call synchronize on this node
		m_spNodeMgr->FindNode(cookie, &spNode);
		if (spNode)
			SynchronizeNodeData(spNode);
	}

	// Un/Register for refresh advises
	if (m_spRouterInfo)
		m_spRouterInfo->GetRefreshObject(&spRefresh);

	if (spRefresh)
	{
		if (bSelect)
		{
			if (m_ulRefreshConnId == 0)
				spRefresh->AdviseRefresh(&m_IRtrAdviseSink, &m_ulRefreshConnId, 0);
			if (m_ulStatsConnId == 0)
				spRefresh->AdviseRefresh(&m_IRtrAdviseSink, &m_ulStatsConnId, 0);
		}
		else
		{
			if (m_ulRefreshConnId)
				spRefresh->UnadviseRefresh(m_ulRefreshConnId);
			m_ulRefreshConnId = 0;
		}
	}
	
	return hr;
}


/*!--------------------------------------------------------------------------
	SapNodeHandler::CompareItems
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int) SapNodeHandler::CompareItems(
								ITFSComponent * pComponent,
								MMC_COOKIE cookieA,
								MMC_COOKIE cookieB,
								int nCol)
{
	// Get the strings from the nodes and use that as a basis for
	// comparison.
	SPITFSNode	spNode;
	SPITFSResultHandler	spResult;

	m_spNodeMgr->FindNode(cookieA, &spNode);
	spNode->GetResultHandler(&spResult);
	return spResult->CompareItems(pComponent, cookieA, cookieB, nCol);
}


/*---------------------------------------------------------------------------
	Class: SapInterfaceHandler
 ---------------------------------------------------------------------------*/

SapInterfaceHandler::SapInterfaceHandler(ITFSComponentData *pCompData)
	: BaseIPXResultHandler(pCompData, SAP_COLUMNS),
	m_ulConnId(0)
{
 	m_rgButtonState[MMC_VERB_PROPERTIES_INDEX] = ENABLED;
	m_bState[MMC_VERB_PROPERTIES_INDEX] = TRUE;
	
 	m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
	m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;
	
	m_verbDefault = MMC_VERB_PROPERTIES;
}

static const DWORD s_rgInterfaceImageMap[] =
	 {
	 ROUTER_IF_TYPE_HOME_ROUTER,	IMAGE_IDX_WAN_CARD,
	 ROUTER_IF_TYPE_FULL_ROUTER,	IMAGE_IDX_WAN_CARD,
	 ROUTER_IF_TYPE_CLIENT,			IMAGE_IDX_WAN_CARD,
	 ROUTER_IF_TYPE_DEDICATED,		IMAGE_IDX_LAN_CARD,
	 ROUTER_IF_TYPE_INTERNAL,		IMAGE_IDX_LAN_CARD,
	 ROUTER_IF_TYPE_LOOPBACK,		IMAGE_IDX_LAN_CARD,
	 -1,							IMAGE_IDX_WAN_CARD,	// sentinel value
	 };

/*!--------------------------------------------------------------------------
	SapInterfaceHandler::ConstructNode
		Initializes the Domain node (sets it up).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapInterfaceHandler::ConstructNode(ITFSNode *pNode, IInterfaceInfo *pIfInfo, IPXConnection *pIPXConn)
{
	HRESULT			hr = hrOK;
	int				i;
	DWORD			dwIfType;
	
	if (pNode == NULL)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Need to initialize the data for the Domain node

		// Find the right image index for this type of node
		if (pIfInfo)
			dwIfType = pIfInfo->GetInterfaceType();
		else
			dwIfType = ROUTER_IF_TYPE_CLIENT;
		
		for (i=0; i<DimensionOf(s_rgInterfaceImageMap); i+=2)
		{
			if ((dwIfType == s_rgInterfaceImageMap[i]) ||
				(-1 == s_rgInterfaceImageMap[i]))
				break;
		}
		pNode->SetData(TFS_DATA_IMAGEINDEX, s_rgInterfaceImageMap[i+1]);
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, s_rgInterfaceImageMap[i+1]);
		
		pNode->SetData(TFS_DATA_SCOPEID, 0);

		pNode->SetData(TFS_DATA_COOKIE, reinterpret_cast<DWORD_PTR>(pNode));

		//$ Review: kennt, what are the different type of interfaces
		// do we distinguish based on the same list as above? (i.e. the
		// one for image indexes).
		pNode->SetNodeType(&GUID_IPXSapInterfaceNodeType);

		BaseIPXResultNodeData::Init(pNode, pIfInfo, pIPXConn);
	}
	COM_PROTECT_CATCH
	return hr;
}

/*!--------------------------------------------------------------------------
	SapInterfaceHandler::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP SapInterfaceHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		CORg( CreateDataObjectFromInterfaceInfo(m_spInterfaceInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}


/*!--------------------------------------------------------------------------
	SapInterfaceHandler::OnCreateDataObject
		Implementation of ITFSResultHandler::OnCreateDataObject
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP SapInterfaceHandler::OnCreateDataObject(ITFSComponent *pComp, MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		CORg( CreateDataObjectFromInterfaceInfo(m_spInterfaceInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}



/*!--------------------------------------------------------------------------
	SapInterfaceHandler::RefreshInterface
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SapInterfaceHandler::RefreshInterface(MMC_COOKIE cookie)
{
	SPITFSNode	spNode;
	
	m_spNodeMgr->FindNode(cookie, &spNode);

	ForwardCommandToParent(spNode, IDS_MENU_SYNC,
						CCT_RESULT, NULL, 0);
}


/*!--------------------------------------------------------------------------
	SapInterfaceHandler::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapInterfaceHandler::Init(IInterfaceInfo *pIfInfo,
								  IRouterInfo *pRouterInfo,
								  ITFSNode *pParent)
{
	m_spInterfaceInfo.Set(pIfInfo);

	BaseIPXResultHandler::Init(pIfInfo, pParent);

	m_spRouterInfo.Set(pRouterInfo);
	return hrOK;
}


/*!--------------------------------------------------------------------------
	SapInterfaceHandler::DestroyResultHandler
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP SapInterfaceHandler::DestroyResultHandler(MMC_COOKIE cookie)
{
	m_spInterfaceInfo.Release();
	BaseIPXResultHandler::DestroyResultHandler(cookie);
	return hrOK;
}


/*---------------------------------------------------------------------------
	This is the list of commands that will show up for the result pane
	nodes.
 ---------------------------------------------------------------------------*/
struct SIPInterfaceNodeMenu
{
	ULONG	m_sidMenu;			// string/command id for this menu item
	ULONG	(SapInterfaceHandler:: *m_pfnGetMenuFlags)(SapInterfaceHandler::SMenuData *);
	ULONG	m_ulPosition;
};

/*!--------------------------------------------------------------------------
	SapInterfaceHandler::AddMenuItems
		Implementation of ITFSResultHandler::AddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP SapInterfaceHandler::AddMenuItems(
	ITFSComponent *pComponent,
	MMC_COOKIE cookie,
	LPDATAOBJECT lpDataObject, 
	LPCONTEXTMENUCALLBACK pContextMenuCallback, 
	long *pInsertionAllowed)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	SapInterfaceHandler::Command
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP SapInterfaceHandler::Command(ITFSComponent *pComponent,
									   MMC_COOKIE cookie,
									   int nCommandID,
									   LPDATAOBJECT pDataObject)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	SapInterfaceHandler::HasPropertyPages
		- 
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP SapInterfaceHandler::HasPropertyPages 
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	return hrTrue;
}

/*!--------------------------------------------------------------------------
	SapInterfaceHandler::CreatePropertyPages
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP SapInterfaceHandler::CreatePropertyPages
(
	ITFSNode *				pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject, 
	LONG_PTR					handle, 
	DWORD					dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT		hr = hrOK;
	SapInterfaceProperties *	pProperties = NULL;
	SPIComponentData spComponentData;
	CString		stTitle;
	SPIRouterInfo	spRouter;
	SPIRtrMgrInfo	spRm;

	CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

//	stTitle.Format(IDS_IPSUMMARY_INTERFACE_PROPPAGE_TITLE,
//				   m_spInterfaceInfo->GetTitle());
	
	pProperties = new SapInterfaceProperties(pNode, spComponentData,
		m_spTFSCompData, stTitle);

	CORg( m_spRouterInfo->FindRtrMgr(PID_IPX, &spRm) );

	CORg( pProperties->Init(m_spInterfaceInfo, spRm) );

	if (lpProvider)
		hr = pProperties->CreateModelessSheet(lpProvider, handle);
	else
		hr = pProperties->DoModelessSheet();

Error:
	// Is this the right way to destroy the sheet?
	if (!FHrSucceeded(hr))
		delete pProperties;
	return hr;
}

/*!--------------------------------------------------------------------------
	SapInterfaceHandler::CreatePropertyPages
		Implementation of ResultHandler::CreatePropertyPages
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP SapInterfaceHandler::CreatePropertyPages
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPPROPERTYSHEETCALLBACK	lpProvider, 
	LPDATAOBJECT			pDataObject, 
	LONG_PTR					handle
)
{
	// Forward this call onto the NodeHandler::CreatePropertyPages
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT	hr = hrOK;
	SPITFSNode	spNode;

	Assert( m_spNodeMgr );

	CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

	// Call the ITFSNodeHandler::CreatePropertyPages
	hr = CreatePropertyPages(spNode, lpProvider, pDataObject, handle, 0);
	
Error:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\sapstrm.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	sapstrm.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "sapstrm.h"
#include "xstream.h"

/*!--------------------------------------------------------------------------
	SapConfigStream::SapConfigStream
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
SapConfigStream::SapConfigStream()
{
	m_nVersionAdmin = 0x00020000;
	m_nVersion = 0x00020000;

}

/*!--------------------------------------------------------------------------
	SapConfigStream::InitNew
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapConfigStream::InitNew()
{
	// Setup the appropriate defaults
//	m_nVersionAdmin = 0x00020000;
//	m_nVersion = 0x00020000;
//	m_stName.Empty();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	SapConfigStream::SaveTo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapConfigStream::SaveTo(IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_WRITE, NULL);
}

/*!--------------------------------------------------------------------------
	SapConfigStream::SaveAs
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapConfigStream::SaveAs(UINT nVersion, IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_WRITE, NULL);
}

/*!--------------------------------------------------------------------------
	SapConfigStream::LoadFrom
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapConfigStream::LoadFrom(IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_READ, NULL);
}

/*!--------------------------------------------------------------------------
	SapConfigStream::GetSize
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapConfigStream::GetSize(ULONG *pcbSize)
{
	return XferVersion0(NULL, XferStream::MODE_SIZE, NULL);
}

/*!--------------------------------------------------------------------------
	SapConfigStream::GetVersionInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SapConfigStream::GetVersionInfo(DWORD *pdwVersion, DWORD *pdwAdminVersion)
{
	if (pdwVersion)
		*pdwVersion = m_nVersion;
	if (pdwAdminVersion)
		*pdwAdminVersion = m_nVersionAdmin;
	return hrOK;
}

/*!--------------------------------------------------------------------------
	SapConfigStream::XferVersion0
		-
	Author: KennT
 ---------------------------------------------------------------------------*/


struct _ViewInfoEntry
{
	ULONG	m_ulId;
	ULONG	m_idSort;
	ULONG	m_idAscending;
	ULONG	m_idColumns;
	ULONG	m_idPos;
};

static const _ViewInfoEntry	s_rgSAPAdminViewInfo[] =
{
	{ SAPSTRM_STATS_SAPPARAMS,
		SAPSTRM_TAG_STATS_SAPPARAMS_SORT,
		SAPSTRM_TAG_STATS_SAPPARAMS_ASCENDING,
		SAPSTRM_TAG_STATS_SAPPARAMS_COLUMNS,
		SAPSTRM_TAG_STATS_SAPPARAMS_POSITION },
};		

HRESULT SapConfigStream::XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize)
{
	XferStream	xstm(pstm, mode);
	HRESULT		hr = hrOK;
	int			i;

	CORg( xstm.XferDWORD( SAPSTRM_TAG_VERSION, &m_nVersion ) );
	CORg( xstm.XferDWORD( SAPSTRM_TAG_VERSIONADMIN, &m_nVersionAdmin ) );
	
	for ( i=0; i<DimensionOf(s_rgSAPAdminViewInfo); i++)
	{
		CORg( m_rgViewInfo[s_rgSAPAdminViewInfo[i].m_ulId].Xfer(&xstm,
			s_rgSAPAdminViewInfo[i].m_idSort,
			s_rgSAPAdminViewInfo[i].m_idAscending,
			s_rgSAPAdminViewInfo[i].m_idColumns) );
		CORg( xstm.XferRect( s_rgSAPAdminViewInfo[i].m_idPos,
							 &m_prgrc[s_rgSAPAdminViewInfo[i].m_ulId]) );
	}
	if (pcbSize)
		*pcbSize = xstm.GetSize();

Error:
	return hr;
}



/*---------------------------------------------------------------------------
	SapComponentConfigStream implementation
 ---------------------------------------------------------------------------*/

enum SAPCOMPSTRM_TAG
{
	SAPCOMPSTRM_TAG_VERSION =		XFER_TAG(1, XFER_DWORD),
	SAPCOMPSTRM_TAG_VERSIONADMIN =	XFER_TAG(2, XFER_DWORD),
	SAPCOMPSTRM_TAG_SUMMARY_COLUMNS = XFER_TAG(3, XFER_COLUMNDATA_ARRAY),
	SAPCOMPSTRM_TAG_SUMMARY_SORT_COLUMN = XFER_TAG(4, XFER_DWORD),
	SAPCOMPSTRM_TAG_SUMMARY_SORT_ASCENDING = XFER_TAG(5, XFER_DWORD),
};



HRESULT SapComponentConfigStream::XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize)
{
	XferStream	xstm(pstm, mode);
	HRESULT		hr = hrOK;

	CORg( xstm.XferDWORD( SAPCOMPSTRM_TAG_VERSION, &m_nVersion ) );
	CORg( xstm.XferDWORD( SAPCOMPSTRM_TAG_VERSIONADMIN, &m_nVersionAdmin ) );

	CORg( m_rgViewInfo[SAP_COLUMNS].Xfer(&xstm,
										SAPCOMPSTRM_TAG_SUMMARY_SORT_COLUMN,
										SAPCOMPSTRM_TAG_SUMMARY_SORT_ASCENDING,
										SAPCOMPSTRM_TAG_SUMMARY_COLUMNS) );
	
	if (pcbSize)
		*pcbSize = xstm.GetSize();

Error:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\snview.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	summary.cpp
		IPX Static NetBIOS Name implementation.
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "util.h"
#include "snview.h"
#include "reg.h"
#include "ipxadmin.h"
#include "rtrutil.h"	// smart MPR handle pointers
#include "ipxstrm.h"		// IPXAdminConfigStream
#include "strmap.h"		// XXXtoCString functions
#include "service.h"	// TFS service APIs
#include "format.h"		// FormatNumber function
#include "coldlg.h"		// columndlg
#include "ipxutil.h"
#include "column.h"		// ComponentConfigStream
#include "rtrui.h"
#include "routprot.h"	// IP_LOCAL
#include "rtrres.h"
#include "dumbprop.h"

HRESULT SetNameData(BaseIPXResultNodeData *pData,
					 IpxSNListEntry *pName);
HRESULT AddStaticNetBIOSName(IpxSNListEntry *pSNEntry,
					   IInfoBase *InfoBase,
					   InfoBlock *pBlock);
BOOL FAreTwoNamesEqual(IPX_STATIC_NETBIOS_NAME_INFO *pName1,
						IPX_STATIC_NETBIOS_NAME_INFO *pName2);


/*---------------------------------------------------------------------------
	Keep this in sync with the column ids in snview.h
 ---------------------------------------------------------------------------*/
extern const ContainerColumnInfo	s_rgSNViewColumnInfo[];

const ContainerColumnInfo	s_rgSNViewColumnInfo[] = 
{
	{ IDS_IPX_SN_COL_NAME,			CON_SORT_BY_STRING, TRUE, COL_STRING },
	{ IDS_IPX_SN_COL_NETBIOS_NAME,	CON_SORT_BY_STRING,	TRUE, COL_NETBIOS_NAME },
	{ IDS_IPX_SN_COL_NETBIOS_TYPE,	CON_SORT_BY_STRING,	TRUE, COL_STRING },
};


/*---------------------------------------------------------------------------
	IpxSNHandler implementation
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(IpxSNHandler)


IpxSNHandler::IpxSNHandler(ITFSComponentData *pCompData)
	: BaseContainerHandler(pCompData, COLUMNS_STATICNETBIOSNAMES,
						   s_rgSNViewColumnInfo),
	m_ulConnId(0),
	m_ulRefreshConnId(0)
{
	// Setup the verb states
	m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
	m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;

	DEBUG_INCREMENT_INSTANCE_COUNTER(IpxSNHandler)
}

IpxSNHandler::~IpxSNHandler()
{
	DEBUG_DECREMENT_INSTANCE_COUNTER(IpxSNHandler)
}


STDMETHODIMP IpxSNHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IRtrAdviseSink)
		*ppv = &m_IRtrAdviseSink;
	else
		return BaseContainerHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;	
}



/*!--------------------------------------------------------------------------
	IpxSNHandler::DestroyHandler
		Implementation of ITFSNodeHandler::DestroyHandler
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxSNHandler::DestroyHandler(ITFSNode *pNode)
{
	IPXConnection *	pIPXConn;

	pIPXConn = GET_IPX_SN_NODEDATA(pNode);
	pIPXConn->Release();

	if (m_ulRefreshConnId)
	{
		SPIRouterRefresh	spRefresh;
		if (m_spRouterInfo)
			m_spRouterInfo->GetRefreshObject(&spRefresh);
		if (spRefresh)
			spRefresh->UnadviseRefresh(m_ulRefreshConnId);
	}
	m_ulRefreshConnId = 0;
	
	if (m_ulConnId)
		m_spRtrMgrInfo->RtrUnadvise(m_ulConnId);
	m_ulConnId = 0;
	m_spRtrMgrInfo.Release();

	m_spRouterInfo.Release();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IpxSNHandler::HasPropertyPages
		Implementation of ITFSNodeHandler::HasPropertyPages
	NOTE: the root node handler has to over-ride this function to 
	handle the snapin manager property page (wizard) case!!!
	
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
IpxSNHandler::HasPropertyPages
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	return hrFalse;
}


/*---------------------------------------------------------------------------
	Menu data structure for our menus
 ---------------------------------------------------------------------------*/

static const SRouterNodeMenu	s_rgIfNodeMenu[] =
{
	{ IDS_MENU_IPX_SN_NEW_NETBIOSNAME, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },
};



/*!--------------------------------------------------------------------------
	IpxSNHandler::OnAddMenuItems
		Implementation of ITFSNodeHandler::OnAddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxSNHandler::OnAddMenuItems(
	ITFSNode *pNode,
	LPCONTEXTMENUCALLBACK pContextMenuCallback, 
	LPDATAOBJECT lpDataObject, 
	DATA_OBJECT_TYPES type, 
	DWORD dwType,
	long *pInsertionAllowed)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = S_OK;
    IpxSNHandler::SMenuData   menuData;
	
	COM_PROTECT_TRY
	{
        menuData.m_spNode.Set(pNode);
        
		hr = AddArrayOfMenuItems(pNode, s_rgIfNodeMenu,
								 DimensionOf(s_rgIfNodeMenu),
								 pContextMenuCallback,
								 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
	}
	COM_PROTECT_CATCH;
		
	return hr; 
}




HRESULT IpxSNHandler::OnResultRefresh(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT  hr = hrOK;
    SPITFSNode spNode, spParent;
    SPITFSResultHandler spParentRH;

    m_spNodeMgr->FindNode(cookie, &spNode);

    // forward this command to the parent to handle
    CORg (spNode->GetParent(&spParent));
    CORg (spParent->GetResultHandler(&spParentRH));

    CORg (spParentRH->Notify(pComponent, spParent->GetData(TFS_DATA_COOKIE), pDataObject, MMCN_REFRESH, arg, lParam));

Error:
    return hrOK;

}



/*!--------------------------------------------------------------------------
	IpxSNHandler::OnCommand
		Implementation of ITFSNodeHandler::OnCommand
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxSNHandler::OnCommand(ITFSNode *pNode, long nCommandId, 
										   DATA_OBJECT_TYPES	type, 
										   LPDATAOBJECT pDataObject, 
										   DWORD	dwType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;

	COM_PROTECT_TRY
	{
		switch (nCommandId)
		{
			case IDS_MENU_IPX_SN_NEW_NETBIOSNAME:
				hr = OnNewName(pNode);
				if (!FHrSucceeded(hr))
					DisplayErrorMessage(NULL, hr);
 				break;
			case IDS_MENU_SYNC:
				SynchronizeNodeData(pNode);
				break;
		}
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	IpxSNHandler::GenerateListOfNames
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSNHandler::GenerateListOfNames(ITFSNode *pNode, IpxSNList *pSNList)
{
	Assert(pSNList);
	HRESULT	hr = hrOK;
	SPIEnumInterfaceInfo	spEnumIf;
	SPIInterfaceInfo		spIf;
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPIInfoBase				spInfoBase;
	PIPX_STATIC_NETBIOS_NAME_INFO	pName;
	InfoBlock *				pBlock;
	int						i;
	IpxSNListEntry *	pSNEntry;
	
	COM_PROTECT_TRY
	{
		// Ok go through and find all of the static Names

		CORg( m_spRouterInfo->EnumInterface(&spEnumIf) );

		for (; spEnumIf->Next(1, &spIf, NULL) == hrOK; spIf.Release())
		{
			// Get the next interface
			spRmIf.Release();
			if (spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) != hrOK)
				continue;

			// Load IP information for this interface
			spInfoBase.Release();
			if (spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase) != hrOK)
				continue;

			// Retrieve the data for the IPX_STATIC_NETBIOS_NAME_INFO block
			if (spInfoBase->GetBlock(IPX_STATIC_NETBIOS_NAME_INFO_TYPE, &pBlock, 0) != hrOK)
				continue;

			pName = (PIPX_STATIC_NETBIOS_NAME_INFO) pBlock->pData;

			// Update our list of Names with the Names read from this
			// interface

			for (i=0; i<(int) pBlock->dwCount; i++, pName++)
			{
				pSNEntry = new IpxSNListEntry;
				pSNEntry->m_spIf.Set(spIf);
				pSNEntry->m_name = *pName;
				
				pSNList->AddTail(pSNEntry);
			}
			
		}

	}
	COM_PROTECT_CATCH;

	if (!FHrSucceeded(hr))
	{
		// Should make sure that we get the SRList cleaned up
		while (!pSNList->IsEmpty())
			delete pSNList->RemoveHead();
	}

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxSNHandler::OnExpand
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSNHandler::OnExpand(ITFSNode *pNode,LPDATAOBJECT pDataObject,
							   DWORD dwType,
							   LPARAM arg,
							   LPARAM lParam)
{
	HRESULT	hr = hrOK;
	IpxSNList			SRList;
	IpxSNListEntry *	pSNEntry;
	
	if (m_bExpanded)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Ok go through and find all of the static Names
		CORg( GenerateListOfNames(pNode, &SRList) );

		// Now iterate through the list of static Names adding them
		// all in.  Ideally we could merge this into the Refresh code,
		// but the refresh code can't assume a blank slate.
		while (!SRList.IsEmpty())
		{
			pSNEntry = SRList.RemoveHead();
			AddStaticNetBIOSNameNode(pNode, pSNEntry);
			delete pSNEntry;
		}

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	// Should make sure that we get the SRList cleaned up
	while (!SRList.IsEmpty())
		delete SRList.RemoveHead();


	m_bExpanded = TRUE;

	return hr;
}

/*!--------------------------------------------------------------------------
	IpxSNHandler::GetString
		Implementation of ITFSNodeHandler::GetString
		We don't need to do anything, since our root node is an extension
		only and thus can't do anything to the node text.
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) IpxSNHandler::GetString(ITFSNode *pNode, int nCol)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		if (m_stTitle.IsEmpty())
			m_stTitle.LoadString(IDS_IPX_SN_TITLE);
	}
	COM_PROTECT_CATCH;

	return m_stTitle;
}

/*!--------------------------------------------------------------------------
	IpxSNHandler::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxSNHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{

		Assert(m_spRtrMgrInfo);
		
		CORg( CreateDataObjectFromRtrMgrInfo(m_spRtrMgrInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxSNHandler::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSNHandler::Init(IRtrMgrInfo *pRmInfo, IPXAdminConfigStream *pConfigStream)
{
	m_spRtrMgrInfo.Set(pRmInfo);
	if (pRmInfo)
		pRmInfo->GetParentRouterInfo(&m_spRouterInfo);
	m_pConfigStream = pConfigStream;
	
	// Also need to register for change notifications
	Assert(m_ulConnId == 0);
	m_spRtrMgrInfo->RtrAdvise(&m_IRtrAdviseSink, &m_ulConnId, 0);

	return hrOK;
}


/*!--------------------------------------------------------------------------
	IpxSNHandler::ConstructNode
		Initializes the root node (sets it up).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSNHandler::ConstructNode(ITFSNode *pNode, LPCTSTR pszName,
										IPXConnection *pIPXConn)
{
	Assert(pIPXConn);
	HRESULT			hr = hrOK;
	
	if (pNode == NULL)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Need to initialize the data for the root node
		pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_IPX_NODE_GENERAL);
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_IPX_NODE_GENERAL);
		pNode->SetData(TFS_DATA_SCOPEID, 0);

        // This is a leaf node in the scope pane
        pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

		m_cookie = reinterpret_cast<DWORD_PTR>(pNode);
		pNode->SetData(TFS_DATA_COOKIE, m_cookie);

		pNode->SetNodeType(&GUID_IPXStaticNetBIOSNamesNodeType);

		// Setup the node data
		pIPXConn->AddRef();
		SET_IPX_SN_NODEDATA(pNode, pIPXConn);

	}
	COM_PROTECT_CATCH;

	if (!FHrSucceeded(hr))
	{
		SET_IPX_SN_NODEDATA(pNode, NULL);
	}

	return hr;
}

/*!--------------------------------------------------------------------------
	IpxSNHandler::AddStaticNetBIOSNameNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSNHandler::AddStaticNetBIOSNameNode(ITFSNode *pParent, IpxSNListEntry *pName)
{
	IpxStaticNetBIOSNameHandler *	pHandler;
	SPITFSResultHandler		spHandler;
	SPITFSNode				spNode;
	HRESULT					hr = hrOK;
	BaseIPXResultNodeData *	pData;
	IPXConnection *			pIPXConn;

	// Create the handler for this node 
	pHandler = new IpxStaticNetBIOSNameHandler(m_spTFSCompData);
	spHandler = pHandler;
	CORg( pHandler->Init(pName->m_spIf, pParent) );

	pIPXConn = GET_IPX_SN_NODEDATA(pParent);

	// Create a result item node (or a leaf node)
	CORg( CreateLeafTFSNode(&spNode,
							NULL,
							static_cast<ITFSNodeHandler *>(pHandler),
							static_cast<ITFSResultHandler *>(pHandler),
							m_spNodeMgr) );
	CORg( pHandler->ConstructNode(spNode, pName->m_spIf, pIPXConn) );

	pData = GET_BASEIPXRESULT_NODEDATA(spNode);
	Assert(pData);
	ASSERT_BASEIPXRESULT_NODEDATA(pData);

	// Set the data for this node
	SetNameData(pData, pName);
	

	// Make the node immediately visible
	CORg( spNode->SetVisibilityState(TFS_VIS_SHOW) );
	CORg( pParent->AddChild(spNode) );

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxSNHandler::SynchronizeNodeData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSNHandler::SynchronizeNodeData(ITFSNode *pNode)
{
	HRESULT					hr = hrOK;
	BaseIPXResultNodeData *	pNodeData;
	SPITFSNodeEnum			spNodeEnum;
	SPITFSNode				spChildNode;
	BOOL					fFound;
	IpxSNList			SRList;
	IpxSNList			newSRList;
	IpxSNListEntry *	pSNEntry;

	COM_PROTECT_TRY
	{
	
		// Mark all of the nodes
		CORg( pNode->GetEnum(&spNodeEnum) );
		MarkAllNodes(pNode, spNodeEnum);
		
		// Go out and grab the data, merge the new data in with the old data
		// This is the data-gathering code and this is what should go
		// on the background thread for the refresh code.
		CORg( GenerateListOfNames(pNode, &SRList) );

		while (!SRList.IsEmpty())
		{
			pSNEntry = SRList.RemoveHead();
			
			// Look for this entry in our current list of nodes
			spNodeEnum->Reset();
			spChildNode.Release();

			fFound = FALSE;
			
			for (;spNodeEnum->Next(1, &spChildNode, NULL) == hrOK; spChildNode.Release())
			{
				TCHAR	szNumber[32];
				char	szNbName[16];
				
				pNodeData = GET_BASEIPXRESULT_NODEDATA(spChildNode);
				Assert(pNodeData);
				ASSERT_BASEIPXRESULT_NODEDATA(pNodeData);

				ConvertToNetBIOSName(szNbName,
						 pNodeData->m_rgData[IPX_SN_SI_NETBIOS_NAME].m_stData,
						 (USHORT) pNodeData->m_rgData[IPX_SN_SI_NETBIOS_TYPE].m_dwData);

				if (memcmp(szNbName,
						   pSNEntry->m_name.Name,
						   sizeof(pSNEntry->m_name.Name)) == 0)
				{
					// Ok, this name already exists, update the metric
					// and mark it
					Assert(pNodeData->m_dwMark == FALSE);
					pNodeData->m_dwMark = TRUE;
					
					fFound = TRUE;
					
					// Force MMC to redraw the node
					spChildNode->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);
					break;
				}

			}
			
			if (fFound)
				delete pSNEntry;
			else
				newSRList.AddTail(pSNEntry);
		}
		
		// Now remove all nodes that were not marked
		RemoveAllUnmarkedNodes(pNode, spNodeEnum);
		
		
		// Now iterate through the list of static Names adding them
		// all in.  Ideally we could merge this into the Refresh code,
		// but the refresh code can't assume a blank slate.
		POSITION	pos;
		
		while (!newSRList.IsEmpty())
		{
			pSNEntry = newSRList.RemoveHead();
			AddStaticNetBIOSNameNode(pNode, pSNEntry);
			delete pSNEntry;
		}

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	
	while (!SRList.IsEmpty())
		delete SRList.RemoveHead();
	
	while (!newSRList.IsEmpty())
		delete newSRList.RemoveHead();
	
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxSNHandler::MarkAllNodes
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSNHandler::MarkAllNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum)
{
	SPITFSNode	spChildNode;
	BaseIPXResultNodeData *	pNodeData;
	
	pEnum->Reset();
	for ( ;pEnum->Next(1, &spChildNode, NULL) == hrOK; spChildNode.Release())
	{
		pNodeData = GET_BASEIPXRESULT_NODEDATA(spChildNode);
		Assert(pNodeData);
		ASSERT_BASEIPXRESULT_NODEDATA(pNodeData);
		
		pNodeData->m_dwMark = FALSE;			
	}
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IpxSNHandler::RemoveAllUnmarkedNodes
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSNHandler::RemoveAllUnmarkedNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum)
{
	HRESULT		hr = hrOK;
	SPITFSNode	spChildNode;
	BaseIPXResultNodeData *	pNodeData;
	
	pEnum->Reset();
	for ( ;pEnum->Next(1, &spChildNode, NULL) == hrOK; spChildNode.Release())
	{
		pNodeData = GET_BASEIPXRESULT_NODEDATA(spChildNode);
		Assert(pNodeData);
		ASSERT_BASEIPXRESULT_NODEDATA(pNodeData);
		
		if (pNodeData->m_dwMark == FALSE)
		{
			pNode->RemoveChild(spChildNode);
			spChildNode->Destroy();
		}
	}

	return hr;
}


/*---------------------------------------------------------------------------
	This is the set of menus that will appear when a right-click is
	done on the blank area of the result pane.
 ---------------------------------------------------------------------------*/
static const SRouterNodeMenu	s_rgIfResultNodeMenu[] =
{
	{ IDS_MENU_IPX_SN_NEW_NETBIOSNAME, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },
};




/*!--------------------------------------------------------------------------
	IpxSNHandler::AddMenuItems
		Implementation of ITFSResultHandler::AddMenuItems
		Use this to add commands to the context menu of the blank areas
		of the result pane.
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxSNHandler::AddMenuItems(ITFSComponent *pComponent,
											  MMC_COOKIE cookie,
											  LPDATAOBJECT pDataObject,
											  LPCONTEXTMENUCALLBACK pCallback,
											  long *pInsertionAllowed)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT	hr = hrOK;
	SPITFSNode	spNode;
    IpxSNHandler::SMenuData   menuData;

	COM_PROTECT_TRY
	{
		m_spNodeMgr->FindNode(cookie, &spNode);
        menuData.m_spNode.Set(spNode);
        
		hr = AddArrayOfMenuItems(spNode,
								 s_rgIfResultNodeMenu,
								 DimensionOf(s_rgIfResultNodeMenu),
								 pCallback,
								 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
	}
	COM_PROTECT_CATCH;

	return hr;
}


/*!--------------------------------------------------------------------------
	IpxSNHandler::Command
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxSNHandler::Command(ITFSComponent *pComponent,
									   MMC_COOKIE cookie,
									   int nCommandID,
									   LPDATAOBJECT pDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	SPITFSNode	spNode;
	HRESULT		hr = hrOK;

	switch (nCommandID)
	{
		case IDS_MENU_IPX_SN_NEW_NETBIOSNAME:
			{
				m_spNodeMgr->FindNode(cookie, &spNode);
				hr = OnNewName(spNode);
				if (!FHrSucceeded(hr))
					DisplayErrorMessage(NULL, hr);
			}
			break;
	}
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxSNHandler::CompareItems
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int) IpxSNHandler::CompareItems(
								ITFSComponent * pComponent,
								MMC_COOKIE cookieA,
								MMC_COOKIE cookieB,
								int nCol)
{
	// Get the strings from the nodes and use that as a basis for
	// comparison.
	SPITFSNode	spNode;
	SPITFSResultHandler	spResult;

	m_spNodeMgr->FindNode(cookieA, &spNode);
	spNode->GetResultHandler(&spResult);
	return spResult->CompareItems(pComponent, cookieA, cookieB, nCol);
}


/*!--------------------------------------------------------------------------
	IpxSNHandler::OnNewName
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT	IpxSNHandler::OnNewName(ITFSNode *pNode)
{
	HRESULT	hr = hrOK;
	IpxSNListEntry	SNEntry;
	CStaticNetBIOSNameDlg			srdlg(&SNEntry, 0, m_spRouterInfo);
	SPIInfoBase				spInfoBase;
	SPIRtrMgrInterfaceInfo	spRmIf;
	IPXConnection *			pIPXConn;
	InfoBlock *				pBlock;
								
	pIPXConn = GET_IPX_SN_NODEDATA(pNode);
	Assert(pIPXConn);

	::ZeroMemory(&(SNEntry.m_name), sizeof(SNEntry.m_name));

	if (srdlg.DoModal() == IDOK)
	{
		CORg( SNEntry.m_spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) );
		CORg( spRmIf->GetInfoBase(pIPXConn->GetConfigHandle(),
								  NULL,
								  NULL,
								  &spInfoBase));
		
		// Ok, go ahead and add the name
		
		// Get the IPX_STATIC_NETBIOS_NAME_INFO block from the interface
		spInfoBase->GetBlock(IPX_STATIC_NETBIOS_NAME_INFO_TYPE, &pBlock, 0);
		
		CORg( AddStaticNetBIOSName(&SNEntry, spInfoBase, pBlock) );

		// Update the interface information
		CORg( spRmIf->Save(SNEntry.m_spIf->GetMachineName(),
						   pIPXConn->GetConfigHandle(),
						   NULL,
						   NULL,
						   spInfoBase,
						   0));	

		// Refresh the node
		SynchronizeNodeData(pNode);
	}

Error:
	return hr;
}

ImplementEmbeddedUnknown(IpxSNHandler, IRtrAdviseSink)

STDMETHODIMP IpxSNHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
	DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
	InitPThis(IpxSNHandler, IRtrAdviseSink);
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		if (dwChangeType == ROUTER_REFRESH)
		{
			SPITFSNode	spNode;

			Assert(ulConn == pThis->m_ulRefreshConnId);
			
			pThis->m_spNodeMgr->FindNode(pThis->m_cookie, &spNode);
			pThis->SynchronizeNodeData(spNode);
		}
	}
	COM_PROTECT_CATCH;
	
	return hr;
}



/*!--------------------------------------------------------------------------
	IpxSNHandler::OnResultShow
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSNHandler::OnResultShow(ITFSComponent *pTFSComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	BOOL	bSelect = (BOOL) arg;
	HRESULT	hr = hrOK;
	SPIRouterRefresh	spRefresh;
	SPITFSNode	spNode;

	BaseContainerHandler::OnResultShow(pTFSComponent, cookie, arg, lParam);

	if (bSelect)
	{
		// Call synchronize on this node
		m_spNodeMgr->FindNode(cookie, &spNode);
		if (spNode)
			SynchronizeNodeData(spNode);
	}

	// Un/Register for refresh advises
	if (m_spRouterInfo)
		m_spRouterInfo->GetRefreshObject(&spRefresh);

	if (spRefresh)
	{
		if (bSelect)
		{
			if (m_ulRefreshConnId == 0)
				spRefresh->AdviseRefresh(&m_IRtrAdviseSink, &m_ulRefreshConnId, 0);
		}
		else
		{
			if (m_ulRefreshConnId)
				spRefresh->UnadviseRefresh(m_ulRefreshConnId);
			m_ulRefreshConnId = 0;
		}
	}
	
	return hr;
}




/*---------------------------------------------------------------------------
	Class: IpxStaticNetBIOSNameHandler
 ---------------------------------------------------------------------------*/

IpxStaticNetBIOSNameHandler::IpxStaticNetBIOSNameHandler(ITFSComponentData *pCompData)
	: BaseIPXResultHandler(pCompData, COLUMNS_STATICNETBIOSNAMES),
	m_ulConnId(0)
{
 	m_rgButtonState[MMC_VERB_PROPERTIES_INDEX] = ENABLED;
	m_bState[MMC_VERB_PROPERTIES_INDEX] = TRUE;
	
	m_rgButtonState[MMC_VERB_DELETE_INDEX] = ENABLED;
	m_bState[MMC_VERB_DELETE_INDEX] = TRUE;

 	m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
	m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;
	
	m_verbDefault = MMC_VERB_PROPERTIES;
}

/*!--------------------------------------------------------------------------
	IpxStaticNetBIOSNameHandler::ConstructNode
		Initializes the Domain node (sets it up).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxStaticNetBIOSNameHandler::ConstructNode(ITFSNode *pNode, IInterfaceInfo *pIfInfo, IPXConnection *pIPXConn)
{
	HRESULT			hr = hrOK;
	int				i;
	
	if (pNode == NULL)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Need to initialize the data for the Domain node

		pNode->SetData(TFS_DATA_SCOPEID, 0);

		// We don't want icons for these nodes.
		pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_IPX_NODE_GENERAL);
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_IPX_NODE_GENERAL);

		pNode->SetData(TFS_DATA_COOKIE, reinterpret_cast<DWORD_PTR>(pNode));

		//$ Review: kennt, what are the different type of interfaces
		// do we distinguish based on the same list as above? (i.e. the
		// one for image indexes).
		pNode->SetNodeType(&GUID_IPXStaticNetBIOSNamesResultNodeType);

		BaseIPXResultNodeData::Init(pNode, pIfInfo, pIPXConn);
	}
	COM_PROTECT_CATCH
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxStaticNetBIOSNameHandler::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxStaticNetBIOSNameHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		CORg( CreateDataObjectFromInterfaceInfo(m_spInterfaceInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxStaticNetBIOSNameHandler::OnCreateDataObject
		Implementation of ITFSResultHandler::OnCreateDataObject
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxStaticNetBIOSNameHandler::OnCreateDataObject(ITFSComponent *pComp, MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		CORg( CreateDataObjectFromInterfaceInfo(m_spInterfaceInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}



/*!--------------------------------------------------------------------------
	IpxStaticNetBIOSNameHandler::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxStaticNetBIOSNameHandler::Init(IInterfaceInfo *pIfInfo, ITFSNode *pParent)
{
	Assert(pIfInfo);

	m_spInterfaceInfo.Set(pIfInfo);
    pIfInfo->GetParentRouterInfo(&m_spRouterInfo);
	BaseIPXResultHandler::Init(pIfInfo, pParent);
	return hrOK;
}


/*!--------------------------------------------------------------------------
	IpxStaticNetBIOSNameHandler::DestroyResultHandler
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxStaticNetBIOSNameHandler::DestroyResultHandler(MMC_COOKIE cookie)
{
	m_spInterfaceInfo.Release();
	BaseIPXResultHandler::DestroyResultHandler(cookie);
	return hrOK;
}


/*---------------------------------------------------------------------------
	This is the list of commands that will show up for the result pane
	nodes.
 ---------------------------------------------------------------------------*/
struct SIPInterfaceNodeMenu
{
	ULONG	m_sidMenu;			// string/command id for this menu item
	ULONG	(IpxStaticNetBIOSNameHandler:: *m_pfnGetMenuFlags)(IpxStaticNetBIOSNameHandler::SMenuData *);
	ULONG	m_ulPosition;
};

/*!--------------------------------------------------------------------------
	IpxStaticNetBIOSNameHandler::AddMenuItems
		Implementation of ITFSResultHandler::AddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxStaticNetBIOSNameHandler::AddMenuItems(
	ITFSComponent *pComponent,
	MMC_COOKIE cookie,
	LPDATAOBJECT lpDataObject, 
	LPCONTEXTMENUCALLBACK pContextMenuCallback, 
	long *pInsertionAllowed)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IpxStaticNetBIOSNameHandler::Command
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxStaticNetBIOSNameHandler::Command(ITFSComponent *pComponent,
									   MMC_COOKIE cookie,
									   int nCommandID,
									   LPDATAOBJECT pDataObject)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IpxStaticNetBIOSNameHandler::HasPropertyPages
		- 
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxStaticNetBIOSNameHandler::HasPropertyPages 
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	return S_OK;

/*	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// Need to fill in a IpxSNListEntry
	IpxSNListEntry	SNEntry;
	IpxSNListEntry	SNEntryOld;
	SPIRouterInfo			spRouterInfo;
	HRESULT					hr = hrOK;

	CORg( m_spInterfaceInfo->GetParentRouterInfo(&spRouterInfo) );
	
	BaseIPXResultNodeData *	pNodeData;

	pNodeData = GET_BASEIPXRESULT_NODEDATA(pNode);
	Assert(pNodeData);
	ASSERT_BASEIPXRESULT_NODEDATA(pNodeData);

	// Fill in our SNEntry
	SNEntry.LoadFrom(pNodeData);
	SNEntryOld.LoadFrom(pNodeData);
	
	{
		CStaticNetBIOSNameDlg	srdlg(&SNEntry, SR_DLG_MODIFY, spRouterInfo);
		if (srdlg.DoModal() == IDOK)
		{
			// Updates the name info for this name
			ModifyNameInfo(pNode, &SNEntry, &SNEntryOld);

			// Update the data in the UI
			SetNameData(pNodeData, &SNEntry);
			m_spInterfaceInfo.Set(SNEntry.m_spIf);
			
			// Force a refresh
			pNode->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);
		}
	}
Error:
	return hrOK;*/
}

STDMETHODIMP IpxStaticNetBIOSNameHandler::HasPropertyPages(ITFSComponent *pComponent,
											   MMC_COOKIE cookie,
											   LPDATAOBJECT pDataObject)
{
	SPITFSNode	spNode;

	m_spNodeMgr->FindNode(cookie, &spNode);
	return HasPropertyPages(spNode, pDataObject, CCT_RESULT, 0);
}

/*!--------------------------------------------------------------------------
	IpxStaticNetBIOSNameHandler::CreatePropertyPages
		Implementation of ResultHandler::CreatePropertyPages
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxStaticNetBIOSNameHandler::CreatePropertyPages
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPPROPERTYSHEETCALLBACK	lpProvider, 
	LPDATAOBJECT			pDataObject, 
	LONG_PTR				handle
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT	hr = hrOK;
	SPITFSNode	spNode;

	Assert( m_spNodeMgr );

	CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

	// Call the ITFSNodeHandler::CreatePropertyPages
	hr = CreatePropertyPages(spNode, lpProvider, pDataObject, handle, 0);

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxStaticNetBIOSNameHandler::CreatePropertyPages
		Implementation of NodeHandler::CreatePropertyPages
	Author: Deonb
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxStaticNetBIOSNameHandler::CreatePropertyPages
(
	ITFSNode *				pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject, 
	LONG_PTR				handle, 
	DWORD					dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT		hr = hrOK;
	IpxStaticNBNamePropertySheet *pProperties = NULL;
	SPIComponentData spComponentData;
	CString		stTitle;
	
    CComPtr<IInterfaceInfo> spInterfaceInfo;
	BaseIPXResultNodeData *	pNodeData;

	CORg( m_spNodeMgr->GetComponentData(&spComponentData) );
	if (m_spInterfaceInfo)
		stTitle.Format(IDS_IPXSUMMARY_IF_PAGE_TITLE,
					   m_spInterfaceInfo->GetTitle());
	else
		stTitle.LoadString(IDS_IPXSUMMARY_CLIENT_IF_PAGE_TITLE);

	pProperties = new IpxStaticNBNamePropertySheet(pNode, spComponentData, 
		m_spTFSCompData, stTitle);

	pNodeData = GET_BASEIPXRESULT_NODEDATA(pNode);
	Assert(pNodeData);
	ASSERT_BASEIPXRESULT_NODEDATA(pNodeData);

	CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

	spInterfaceInfo = m_spInterfaceInfo;
	CORg( pProperties->Init(pNodeData, spInterfaceInfo) );

	if (lpProvider)
		hr = pProperties->CreateModelessSheet(lpProvider, handle);
	else
		hr = pProperties->DoModelessSheet();

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxStaticNetBIOSNameHandler::OnResultDelete
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxStaticNetBIOSNameHandler::OnResultDelete(ITFSComponent *pComponent,
	LPDATAOBJECT pDataObject,
	MMC_COOKIE cookie,
	LPARAM arg,
	LPARAM param)
{
	SPITFSNode	spNode;

	m_spNodeMgr->FindNode(cookie, &spNode);
	return OnRemoveStaticNetBIOSName(spNode);
}

/*!--------------------------------------------------------------------------
	IpxStaticNetBIOSNameHandler::OnRemoveStaticNetBIOSName
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxStaticNetBIOSNameHandler::OnRemoveStaticNetBIOSName(ITFSNode *pNode)
{
	HRESULT		hr = hrOK;
	SPIInfoBase	spInfoBase;
	SPIRtrMgrInterfaceInfo	spRmIf;
	IPXConnection *pIPXConn;
	SPITFSNode	spNodeParent;
	BaseIPXResultNodeData *	pData;
	IpxSNListEntry	SNEntry;
    CWaitCursor wait;

	pNode->GetParent(&spNodeParent);
	
	pIPXConn = GET_IPX_SN_NODEDATA(spNodeParent);
	Assert(pIPXConn);

	pData = GET_BASEIPXRESULT_NODEDATA(pNode);
	Assert(pData);
	ASSERT_BASEIPXRESULT_NODEDATA(pData);
    
	//
	// Load the old interface's information
	//
	Assert(lstrcmpi(m_spInterfaceInfo->GetId(), pData->m_spIf->GetId()) == 0);
	CORg( m_spInterfaceInfo->FindRtrMgrInterface(PID_IPX, &spRmIf) );

	CORg( spRmIf->GetInfoBase(pIPXConn->GetConfigHandle(),
							  NULL,
							  NULL,
							  &spInfoBase));

	SNEntry.LoadFrom(pData);

	CORg( RemoveStaticNetBIOSName(&SNEntry, spInfoBase) );
		
	// Update the interface information
	CORg( spRmIf->Save(m_spInterfaceInfo->GetMachineName(),
					   pIPXConn->GetConfigHandle(),
					   NULL,
					   NULL,
					   spInfoBase,
					   0));

	// Refresh the node
	ParentRefresh(pNode);

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxStaticNetBIOSNameHandler::RemoveStaticNetBIOSName
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxStaticNetBIOSNameHandler::RemoveStaticNetBIOSName(IpxSNListEntry *pSNEntry,
										  IInfoBase *pInfoBase)
{
	HRESULT		hr = hrOK;
	InfoBlock *	pBlock;
	PIPX_STATIC_NETBIOS_NAME_INFO	pRow;
    INT			i;
	
	// Get the IPX_STATIC_NETBIOS_NAME_INFO block from the interface
	CORg( pInfoBase->GetBlock(IPX_STATIC_NETBIOS_NAME_INFO_TYPE, &pBlock, 0) );
		
	// Look for the removed name in the IPX_STATIC_NETBIOS_NAME_INFO
	pRow = (IPX_STATIC_NETBIOS_NAME_INFO*) pBlock->pData;
	
	for (i = 0; i < (INT)pBlock->dwCount; i++, pRow++)
	{	
		// Compare this name to the removed one
		if (FAreTwoNamesEqual(pRow, &(pSNEntry->m_name)))
		{
			// This is the removed name, so modify this block
			// to exclude the name:
			
			// Decrement the number of Names
			--pBlock->dwCount;
		
			if (pBlock->dwCount && (i < (INT)pBlock->dwCount))
			{				
				// Overwrite this name with the ones which follow it
				::memmove(pRow,
						  pRow + 1,
						  (pBlock->dwCount - i) * sizeof(*pRow));
			}
			
			break;
		}
	}

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxStaticNetBIOSNameHandler::ModifyNameInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxStaticNetBIOSNameHandler::ModifyNameInfo(ITFSNode *pNode,
										IpxSNListEntry *pSNEntryNew,
										IpxSNListEntry *pSNEntryOld)
{
 	Assert(pSNEntryNew);
	Assert(pSNEntryOld);
	
    INT i;
	HRESULT hr = hrOK;
    InfoBlock* pBlock;
	SPIInfoBase	spInfoBase;
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPITFSNode				spNodeParent;
	IPXConnection *			pIPXConn;
	IPX_STATIC_NETBIOS_NAME_INFO		*psr, *psrOld;
	IPX_STATIC_NETBIOS_NAME_INFO		IpxRow;

    CWaitCursor wait;

	pNode->GetParent(&spNodeParent);
	pIPXConn = GET_IPX_SN_NODEDATA(spNodeParent);
	Assert(pIPXConn);

	// Remove the old name if it is on another interface
	if (lstrcmpi(pSNEntryOld->m_spIf->GetId(), pSNEntryNew->m_spIf->GetId()) != 0)
	{
        // the outgoing interface for a name is to be changed.

		CORg( pSNEntryOld->m_spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) );
		CORg( spRmIf->GetInfoBase(pIPXConn->GetConfigHandle(),
								  NULL,
								  NULL,
								  &spInfoBase));
		
		// Remove the old interface
		CORg( RemoveStaticNetBIOSName(pSNEntryOld, spInfoBase) );

		// Update the interface information
		CORg( spRmIf->Save(pSNEntryOld->m_spIf->GetMachineName(),
						   pIPXConn->GetConfigHandle(),
						   NULL,
						   NULL,
						   spInfoBase,
						   0));	
    }

	spRmIf.Release();
	spInfoBase.Release();


	// Either
	// (a) a name is being modified (on the same interface)
	// (b) a name is being moved from one interface to another.

	// Retrieve the configuration for the interface to which the name
	// is now attached;

	
	CORg( pSNEntryNew->m_spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) );
	CORg( spRmIf->GetInfoBase(pIPXConn->GetConfigHandle(),
							  NULL,
							  NULL,
							  &spInfoBase));

		
	// Get the IPX_STATIC_NETBIOS_NAME_INFO block from the interface
	hr = spInfoBase->GetBlock(IPX_STATIC_NETBIOS_NAME_INFO_TYPE, &pBlock, 0);
	if (!FHrOK(hr))
	{
		//
		// No IPX_STATIC_NETBIOS_NAME_INFO block was found; we create a new block 
		// with the new name, and add that block to the interface-info
		//

		CORg( AddStaticNetBIOSName(pSNEntryNew, spInfoBase, NULL) );
	}
	else
	{
		//
		// An IPX_STATIC_NETBIOS_NAME_INFO block was found.
		//
		// We are modifying an existing name.
		// If the name's interface was not changed when it was modified,
		// look for the existing name in the IPX_STATIC_NETBIOS_NAME_INFO, and then
		// update its parameters.
		// Otherwise, write a completely new name in the IPX_STATIC_NETBIOS_NAME_INFO;
		//

		if (lstrcmpi(pSNEntryOld->m_spIf->GetId(), pSNEntryNew->m_spIf->GetId()) == 0)
		{        
			//
			// The name's interface was not changed when it was modified;
			// We now look for it amongst the existing Names
			// for this interface.
			// The name's original parameters are in 'preOld',
			// so those are the parameters with which we search
			// for a name to modify
			//
			
			psr = (IPX_STATIC_NETBIOS_NAME_INFO*)pBlock->pData;
			
			for (i = 0; i < (INT)pBlock->dwCount; i++, psr++)
			{	
				// Compare this name to the re-configured one
				if (!FAreTwoNamesEqual(&(pSNEntryOld->m_name), psr))
					continue;
				
				// This is the name which was modified;
				// We can now modify the parameters for the name in-place.
				*psr = pSNEntryNew->m_name;
				
				break;
			}
		}
		else
		{
			CORg( AddStaticNetBIOSName(pSNEntryNew, spInfoBase, pBlock) );
		}
		
		// Save the updated information
		CORg( spRmIf->Save(pSNEntryNew->m_spIf->GetMachineName(),
						   pIPXConn->GetConfigHandle(),
						   NULL,
						   NULL,
						   spInfoBase,
						   0));	
		
	}

Error:
	return hr;
	
}


/*!--------------------------------------------------------------------------
	IpxStaticNetBIOSNameHandler::ParentRefresh
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxStaticNetBIOSNameHandler::ParentRefresh(ITFSNode *pNode)
{
	return ForwardCommandToParent(pNode, IDS_MENU_SYNC,
								  CCT_RESULT, NULL, 0);
}


//----------------------------------------------------------------------------
// Class:       CStaticNetBIOSNameDlg
//
//----------------------------------------------------------------------------


//----------------------------------------------------------------------------
// Function:    CStaticNetBIOSNameDlg::CStaticNetBIOSNameDlg
//
// Constructor: initialize the base-class and the dialog's data.
//----------------------------------------------------------------------------

CStaticNetBIOSNameDlg::CStaticNetBIOSNameDlg(IpxSNListEntry *	pSNEntry,
								 DWORD dwFlags,
								 IRouterInfo *pRouter,
								 CWnd *pParent)
    : CBaseDialog(IDD_STATIC_NETBIOS_NAME, pParent),
	m_pSNEntry(pSNEntry),
	m_dwFlags(dwFlags)
{

    //{{AFX_DATA_INIT(CStaticNetBIOSNameDlg)
    //}}AFX_DATA_INIT

	m_spRouterInfo.Set(pRouter);

//	SetHelpMap(m_dwHelpMap);
}



//----------------------------------------------------------------------------
// Function:    CStaticNetBIOSNameDlg::DoDataExchange
//----------------------------------------------------------------------------

VOID
CStaticNetBIOSNameDlg::DoDataExchange(
    CDataExchange* pDX
    ) {

    CBaseDialog::DoDataExchange(pDX);
    
    //{{AFX_DATA_MAP(CStaticNetBIOSNameDlg)
    DDX_Control(pDX, IDC_SND_COMBO_INTERFACE, m_cbInterfaces);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CStaticNetBIOSNameDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CStaticNetBIOSNameDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


DWORD CStaticNetBIOSNameDlg::m_dwHelpMap[] =
{
//	IDC_SRD_DESTINATION, HIDC_SRD_DESTINATION,
//	IDC_SRD_NETMASK, HIDC_SRD_NETMASK,
//	IDC_SRD_GATEWAY, HIDC_SRD_GATEWAY,
//	IDC_SRD_METRIC, HIDC_SRD_METRIC,
//	IDC_SRD_SPINMETRIC, HIDC_SRD_SPINMETRIC,
//	IDC_SRD_INTERFACES, HIDC_SRD_INTERFACES,
	0,0
};

//----------------------------------------------------------------------------
// Function:    CStaticNetBIOSNameDlg::OnInitDialog
//
// Handles the 'WM_INITDIALOG' message for the dialog.
//----------------------------------------------------------------------------

BOOL
CStaticNetBIOSNameDlg::OnInitDialog(
    )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	SPIEnumInterfaceInfo	spEnumIf;
	SPIInterfaceInfo		spIf;
	SPIRtrMgrInterfaceInfo	spRmIf;
	TCHAR					szName[32];
	TCHAR					szType[32];
	CString					st;
 	USHORT					uType;

    CBaseDialog::OnInitDialog();

	// initialize the controls
	((CEdit *) GetDlgItem(IDC_SND_EDIT_NAME))->LimitText(15);
	((CEdit *) GetDlgItem(IDC_SND_EDIT_TYPE))->LimitText(2);

    // Get a list of the interfaces enabled for IPX routing.
	m_spRouterInfo->EnumInterface(&spEnumIf);

	for( ; spEnumIf->Next(1, &spIf, NULL) == hrOK; spIf.Release())
	{
		spRmIf.Release();
		
		if (spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) != hrOK)
			continue;

        // Add the interface to the combobox
        INT i = m_cbInterfaces.AddString(spIf->GetTitle());

        m_cbInterfaces.SetItemData(i, (DWORD_PTR)m_ifidList.AddTail(spIf->GetId()));
	}

	if (!m_cbInterfaces.GetCount())
	{
        AfxMessageBox(IDS_ERR_NO_IPX_INTERFACES);
        EndDialog(IDCANCEL);
		return FALSE;
    }

    m_cbInterfaces.SetCurSel(0);

    //
    // If we were given a name to modify, set the dialog up
    // with the parameters in the name
    //
	if ((m_dwFlags & SR_DLG_MODIFY) == 0)
	{
        // No name was given, so leave the controls blank
    }
    else
	{
		FormatNetBIOSName(szName, &uType, (LPCSTR) m_pSNEntry->m_name.Name);
		st = szName;
		st.TrimRight();
		st.TrimLeft();

		SetDlgItemText(IDC_SND_EDIT_NAME, st);

        m_cbInterfaces.SelectString(-1, m_pSNEntry->m_spIf->GetTitle());

		wsprintf(szType, _T("%.2x"), uType);
		SetDlgItemText(IDC_SND_EDIT_TYPE, szType);
		
		// Disable the network number, next hop, and interface
		GetDlgItem(IDC_SND_COMBO_INTERFACE)->EnableWindow(FALSE);		
    }

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    CStaticNetBIOSNameDlg::OnOK
//
// Handles 'BN_CLICKED' notification from the 'OK' button.
//----------------------------------------------------------------------------

VOID
CStaticNetBIOSNameDlg::OnOK(
    ) {
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    CString		st;
	SPIInterfaceInfo	spIf;
	CString		stIf;
	POSITION	pos;
	USHORT		uType;

    do
	{    
        // Get the name's outgoing interface
        INT item = m_cbInterfaces.GetCurSel();
        if (item == CB_ERR)
			break;

        pos = (POSITION)m_cbInterfaces.GetItemData(item);

        stIf = (LPCTSTR)m_ifidList.GetAt(pos);

		m_spRouterInfo->FindInterface(stIf, &spIf);

		m_pSNEntry->m_spIf.Set(spIf);

		// Get the rest of the data
		GetDlgItemText(IDC_SND_EDIT_TYPE, st);
		uType = (USHORT) _tcstoul(st, NULL, 16);

		GetDlgItemText(IDC_SND_EDIT_NAME, st);
		st.TrimLeft();
		st.TrimRight();

		if (st.IsEmpty())
		{
			GetDlgItem(IDC_SND_EDIT_NAME)->SetFocus();
			AfxMessageBox(IDS_ERR_INVALID_NETBIOS_NAME);
			break;
		}

		ConvertToNetBIOSName((LPSTR) m_pSNEntry->m_name.Name, st, uType);

        CBaseDialog::OnOK();
                
    } while(FALSE);

}


/*!--------------------------------------------------------------------------
	IpxSNListEntry::LoadFrom
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxSNListEntry::LoadFrom(BaseIPXResultNodeData *pNodeData)
{
	m_spIf.Set(pNodeData->m_spIf);

	ConvertToNetBIOSName((LPSTR) m_name.Name,
			 pNodeData->m_rgData[IPX_SN_SI_NETBIOS_NAME].m_stData,
			 (USHORT) pNodeData->m_rgData[IPX_SN_SI_NETBIOS_TYPE].m_dwData);
}

/*!--------------------------------------------------------------------------
	IpxSNListEntry::SaveTo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxSNListEntry::SaveTo(BaseIPXResultNodeData *pNodeData)
{
	TCHAR	szName[32];
	TCHAR	szType[32];
	CString	st;
	USHORT	uType;

	FormatNetBIOSName(szName, &uType,
					  (LPCSTR) m_name.Name);
	st = szName;
	st.TrimLeft();
	st.TrimRight();
	
	pNodeData->m_spIf.Set(m_spIf);
	pNodeData->m_rgData[IPX_SN_SI_NAME].m_stData = m_spIf->GetTitle();

	pNodeData->m_rgData[IPX_SN_SI_NETBIOS_NAME].m_stData = st;

	wsprintf(szType, _T("%.2x"), uType);
	pNodeData->m_rgData[IPX_SN_SI_NETBIOS_TYPE].m_stData = szType;
	pNodeData->m_rgData[IPX_SN_SI_NETBIOS_TYPE].m_dwData = uType;

}

/*!--------------------------------------------------------------------------
	SetNameData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SetNameData(BaseIPXResultNodeData *pData,
					 IpxSNListEntry *pName)
{

	pName->SaveTo(pData);
	return hrOK;
}

/*!--------------------------------------------------------------------------
	AddStaticNetBIOSName
		This function ASSUMES that the name is NOT in the block.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AddStaticNetBIOSName(IpxSNListEntry *pSNEntryNew,
									   IInfoBase *pInfoBase,
									   InfoBlock *pBlock)
{
	IPX_STATIC_NETBIOS_NAME_INFO	srRow;
	HRESULT				hr = hrOK;
	
	if (pBlock == NULL)
	{
		//
		// No IPX_STATIC_NETBIOS_NAME_INFO block was found; we create a new block 
		// with the new name, and add that block to the interface-info
		//
		
		CORg( pInfoBase->AddBlock(IPX_STATIC_NETBIOS_NAME_INFO_TYPE,
								  sizeof(IPX_STATIC_NETBIOS_NAME_INFO),
								  (LPBYTE) &(pSNEntryNew->m_name), 1, 0) );
	}
	else
	{
		// Either the name is completely new, or it is a name
		// which was moved from one interface to another.
		// Set a new block as the IPX_STATIC_NETBIOS_NAME_INFO,
		// and include the re-configured name in the new block.
		PIPX_STATIC_NETBIOS_NAME_INFO	psrTable;
			
		psrTable = new IPX_STATIC_NETBIOS_NAME_INFO[pBlock->dwCount + 1];
		Assert(psrTable);
		
		// Copy the original table of Names
		::memcpy(psrTable, pBlock->pData,
				 pBlock->dwCount * sizeof(IPX_STATIC_NETBIOS_NAME_INFO));
		
		// Append the new name
		psrTable[pBlock->dwCount] = pSNEntryNew->m_name;
		
		// Replace the old name-table with the new one
		CORg( pInfoBase->SetData(IPX_STATIC_NETBIOS_NAME_INFO_TYPE,
								 sizeof(IPX_STATIC_NETBIOS_NAME_INFO),
								 (LPBYTE) psrTable, pBlock->dwCount + 1, 0) );
	}
	
Error:
	return hr;
}


BOOL FAreTwoNamesEqual(IPX_STATIC_NETBIOS_NAME_INFO *pName1,
						IPX_STATIC_NETBIOS_NAME_INFO *pName2)
{
	return (memcmp(pName1->Name, pName2->Name, sizeof(pName1->Name)) == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\snview.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    snview.h
//
// History:
//	09/05/97	Kenn M. Takara			Created.
//
//	IPX Static Names view
//
//============================================================================


#ifndef _SNVIEW_H
#define _SNVIEW_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _XSTREAM_H
#include "xstream.h"		// need for ColumnData
#endif

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _IPXFACE_H
#include "ipxface.h"
#endif

#ifndef _BASECON_H
#include "basecon.h"		// BaseContainerHandler
#endif

#ifndef _IPXSTRM_H
#include "ipxstrm.h"
#endif

#ifndef _RTRSHEET_H
#include "rtrsheet.h"
#endif

#ifndef _IPXCONN_H
#include "ipxconn.h"			// IPXConnection
#endif

#include "ipxstats.h"		// IPX statistics dialogs
#include "IpxStaticnbname.h"

// forward declarations
class	IPXAdminConfigStream;
struct	SIpxSNNodeMenu;

/*---------------------------------------------------------------------------
	This is the list of columns available for the IPX Static Names
	node.
		- Name, "[1] DEC DE500 ..."
		- NetBIOS Name, "stuff"
		- NetBIOS Name Type, "fe11"
 ---------------------------------------------------------------------------*/


//
// If you ADD any columns to this enum, Be sure to update
// the string ids for the column headers in snview.cpp
//
enum
{
	IPX_SN_SI_NAME = 0,
	IPX_SN_SI_NETBIOS_NAME,
	IPX_SN_SI_NETBIOS_TYPE,
	IPX_SN_MAX_COLUMNS,
};


/*---------------------------------------------------------------------------
	We store a pointer to the IPConnection object in our node data
 ---------------------------------------------------------------------------*/

#define GET_IPX_SN_NODEDATA(pNode) \
		(IPXConnection *) pNode->GetData(TFS_DATA_USER)
#define SET_IPX_SN_NODEDATA(pNode, pData) \
		pNode->SetData(TFS_DATA_USER, (LONG_PTR) pData)



/*---------------------------------------------------------------------------
	Struct:	IpxSNListEntry

	This is an intermediate data structure.  Our data-gathering routines
	will generate a list of these data items.  We will then use this list
	to populate result pane.  This will (eventually) be generated by the
	Refresh mechanism.  This separation of data gathering and UI code will
	allow us to easily move the data gathering to a background thread.
 ---------------------------------------------------------------------------*/
struct IpxSNListEntry
{
	SPIInterfaceInfo	m_spIf;
	IPX_STATIC_NETBIOS_NAME_INFO	m_name;
	
	void	LoadFrom(BaseIPXResultNodeData *pNodeData);
	void	SaveTo(BaseIPXResultNodeData *pNodeData);
};

typedef CList<IpxSNListEntry *, IpxSNListEntry *> IpxSNList;


/*---------------------------------------------------------------------------
	Class:	IpxSNHandler
 ---------------------------------------------------------------------------*/


class IpxSNHandler :
		public BaseContainerHandler
{
public:
	IpxSNHandler(ITFSComponentData *pTFSCompData);
	~IpxSNHandler();

	// Override QI to handle embedded interface
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);
	
	DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)

	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_GetString();
	OVERRIDE_NodeHandler_OnCreateDataObject();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_DestroyHandler();

	OVERRIDE_BaseHandlerNotify_OnExpand();

	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_CompareItems();

	OVERRIDE_BaseResultHandlerNotify_OnResultShow();	

    OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();
	
	// Initializes the handler
	HRESULT	Init(IRtrMgrInfo *pRtrMgrInfo, IPXAdminConfigStream *pConfigStream);
	
	// Initializes the node
	HRESULT ConstructNode(ITFSNode *pNode, LPCTSTR szName,
						  IPXConnection *pIPXConn);

public:
	// Structure used to pass data to callbacks - used as a way of
	// avoiding recomputation
	struct SMenuData
	{
		SPITFSNode			m_spNode;
	};
	// Function callbacks for menu enabling/disabling

protected:
	// Refresh the data for these nodes
	HRESULT	SynchronizeNodeData(ITFSNode *pThisNode);
	HRESULT	MarkAllNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum);
	HRESULT	RemoveAllUnmarkedNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum);
	HRESULT	GenerateListOfNames(ITFSNode *pNode, IpxSNList *pSNList);


	// Helper function to add interfaces to the UI
	HRESULT AddStaticNetBIOSNameNode(ITFSNode *pParent, IpxSNListEntry *pName);

	// Command implementations
	HRESULT	OnNewName(ITFSNode *pNode);
	
	LONG_PTR		m_ulConnId;		// notification id for namer info
	LONG_PTR		m_ulRefreshConnId; // notification id for router refresh
	MMC_COOKIE		m_cookie;		// cookie for the node
	SPIRtrMgrInfo	m_spRtrMgrInfo;
	IPXAdminConfigStream *	m_pConfigStream;
	CString			m_stTitle;

};


/*---------------------------------------------------------------------------
	Class:	IpxStaticNetBIOSNameHandler

	This is the handler for the interface nodes that appear in the IPStaticNetBIOSNames
	node.
 ---------------------------------------------------------------------------*/

class IpxStaticNetBIOSNameHandler : public BaseIPXResultHandler
{
public:
	IpxStaticNetBIOSNameHandler(ITFSComponentData *pCompData);
	
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnCreateDataObject();
	
	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_OnCreateDataObject();
	OVERRIDE_ResultHandler_DestroyResultHandler();
	OVERRIDE_ResultHandler_HasPropertyPages();
	OVERRIDE_ResultHandler_CreatePropertyPages();
	
	OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
	
	// Initializes the node
	HRESULT ConstructNode(ITFSNode *pNode, IInterfaceInfo *pIfInfo,
						 IPXConnection *pIPXConn);
	HRESULT	Init(IInterfaceInfo *pInfo, ITFSNode *pParent);

	// Refreshes all Names
	HRESULT	ParentRefresh(ITFSNode *pNode);

	// Removes the static name
	HRESULT OnRemoveStaticNetBIOSName(ITFSNode *pNode);

	// Name modification apis
	HRESULT RemoveStaticNetBIOSName(IpxSNListEntry *pSNEntry, IInfoBase *pInfo);
	HRESULT	ModifyNameInfo(ITFSNode *pNode,
							IpxSNListEntry *pSNEntry,
							IpxSNListEntry *pSNEntryOld);
	
public:
	// Structure used to pass data to callbacks - used as a way of
	// avoiding recomputation
	struct SMenuData
	{
		ULONG				m_ulMenuId;
		SPITFSNode			m_spNode;
	};
	ULONG	GetSeparatorFlags(SMenuData *pData);
	
protected:
	LONG_PTR			m_ulConnId;
	SPIInterfaceInfo	m_spInterfaceInfo;
};


//----------------------------------------------------------------------------
// Class:       CStaticNetBIOSNameDlg
//
// Controls the 'Add/Edit Static Name' dialog.
//----------------------------------------------------------------------------

// Set if we are modifying an exising entry (the only change this does
// is that we will fill in the controls with the data in the structure).
#define SR_DLG_MODIFY		0x00000001

class CStaticNetBIOSNameDlg : public CBaseDialog
{    
public:

	CStaticNetBIOSNameDlg(IpxSNListEntry *	pSNEntry,
					DWORD					dwFlags,
					IRouterInfo *			pRouter,
					CWnd*					pParent = NULL );
    
	//{{AFX_DATA(CStaticNetBIOSNameDlg)
	CComboBox           m_cbInterfaces;
	//}}AFX_DATA
	
	
	//{{AFX_VIRTUAL(CStaticNetBIOSNameDlg)
protected:
	virtual void        DoDataExchange(CDataExchange* pDX);
	//}}AFX_VIRTUAL
	
protected:
	static DWORD		m_dwHelpMap[];

	CStringList         m_ifidList;

	DWORD				m_dwFlags;
	SPIRouterInfo		m_spRouterInfo;
	IpxSNListEntry *m_pSNEntry;
	
	//{{AFX_MSG(CStaticNetBIOSNameDlg)
	virtual void        OnOK();
	virtual BOOL        OnInitDialog();
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};

BOOL FAreTwoNamesEqual(IPX_STATIC_NETBIOS_NAME_INFO *pName1,
						IPX_STATIC_NETBIOS_NAME_INFO *pName2);
#endif _SNVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\srview.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    srview.h
//
// History:
//	09/05/97	Kenn M. Takara			Created.
//
//	IPX Static Routes view
//
//============================================================================


#ifndef _SRVIEW_H
#define _SRVIEW_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _XSTREAM_H
#include "xstream.h"		// need for ColumnData
#endif

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _IPXFACE_H
#include "ipxface.h"
#endif

#ifndef _BASECON_H
#include "basecon.h"		// BaseContainerHandler
#endif

#ifndef _IPXSTRM_H
#include "ipxstrm.h"
#endif

#ifndef _RTRSHEET_H
#include "rtrsheet.h"
#endif

#ifndef _IPXCONN_H
#include "ipxconn.h"			// IPXConnection
#endif

#include "ipxstats.h"		// IPX statistics dialogs

// forward declarations
class	IPXAdminConfigStream;
struct	SIpxSRNodeMenu;

/*---------------------------------------------------------------------------
	This is the list of columns available for the IPX Static Routes
	node.
		- Interface, "[1] DEC DE500 ..."
		- Network number
		- Next Hop MAC address
		- Tick Count
		- Hop Count
 ---------------------------------------------------------------------------*/


//
// If you ADD any columns to this enum, Be sure to update
// the string ids for the column headers in srview.cpp
//
enum
{
	IPX_SR_SI_NAME = 0,
	IPX_SR_SI_NETWORK,
	IPX_SR_SI_NEXT_HOP,
	IPX_SR_SI_TICK_COUNT,
	IPX_SR_SI_HOP_COUNT,
	IPX_SR_MAX_COLUMNS,
};


/*---------------------------------------------------------------------------
	We store a pointer to the IPConnection object in our node data
 ---------------------------------------------------------------------------*/

#define GET_IPX_SR_NODEDATA(pNode) \
		(IPXConnection *) pNode->GetData(TFS_DATA_USER)
#define SET_IPX_SR_NODEDATA(pNode, pData) \
		pNode->SetData(TFS_DATA_USER, (LONG_PTR) pData)



/*---------------------------------------------------------------------------
	Struct:	IpxSRListEntry

	This is an intermediate data structure.  Our data-gathering routines
	will generate a list of these data items.  We will then use this list
	to populate result pane.  This will (eventually) be generated by the
	Refresh mechanism.  This separation of data gathering and UI code will
	allow us to easily move the data gathering to a background thread.
 ---------------------------------------------------------------------------*/
struct IpxSRListEntry
{
	SPIInterfaceInfo	m_spIf;
	IPX_STATIC_ROUTE_INFO	m_route;
	
	void	LoadFrom(BaseIPXResultNodeData *pNodeData);
	void	SaveTo(BaseIPXResultNodeData *pNodeData);
};

typedef CList<IpxSRListEntry *, IpxSRListEntry *> IpxSRList;


/*---------------------------------------------------------------------------
	Class:	IpxSRHandler
 ---------------------------------------------------------------------------*/


class IpxSRHandler :
		public BaseContainerHandler
{
public:
	IpxSRHandler(ITFSComponentData *pTFSCompData);
	~IpxSRHandler();

	// Override QI to handle embedded interface
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);
	
	DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)

	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_GetString();
	OVERRIDE_NodeHandler_OnCreateDataObject();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_DestroyHandler();

	OVERRIDE_BaseHandlerNotify_OnExpand();

	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_CompareItems();

	OVERRIDE_BaseResultHandlerNotify_OnResultShow();	

   OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();
	
	// Initializes the handler
	HRESULT	Init(IRtrMgrInfo *pRtrMgrInfo, IPXAdminConfigStream *pConfigStream);
	
	// Initializes the node
	HRESULT ConstructNode(ITFSNode *pNode, LPCTSTR szName,
						  IPXConnection *pIPXConn);

public:
	// Structure used to pass data to callbacks - used as a way of
	// avoiding recomputation
	struct SMenuData
	{
		SPITFSNode			m_spNode;
	};
	// Function callbacks for menu enabling/disabling

protected:
	// Refresh the data for these nodes
	HRESULT	SynchronizeNodeData(ITFSNode *pThisNode);
	HRESULT	MarkAllNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum);
	HRESULT	RemoveAllUnmarkedNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum);
	HRESULT	GenerateListOfRoutes(ITFSNode *pNode, IpxSRList *pSRList);


	// Helper function to add interfaces to the UI
	HRESULT AddStaticRouteNode(ITFSNode *pParent, IpxSRListEntry *pRoute);

	// Command implementations
	HRESULT	OnNewRoute(ITFSNode *pNode);
	
	LONG_PTR		m_ulConnId;		// notification id for router info
	LONG_PTR		m_ulRefreshConnId; // notification id for router refresh
	MMC_COOKIE		m_cookie;		// cookie for the node
	SPIRtrMgrInfo	m_spRtrMgrInfo;
	SPIRouterInfo	m_spRouterInfo;
	IPXAdminConfigStream *	m_pConfigStream;
	CString			m_stTitle;

};


/*---------------------------------------------------------------------------
	Class:	IpxRouteHandler

	This is the handler for the interface nodes that appear in the IPStaticRoutes
	node.
 ---------------------------------------------------------------------------*/

class IpxRouteHandler : public BaseIPXResultHandler
{
public:
	IpxRouteHandler(ITFSComponentData *pCompData);
	
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnCreateDataObject();
	
	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_OnCreateDataObject();
	OVERRIDE_ResultHandler_DestroyResultHandler();
	OVERRIDE_ResultHandler_HasPropertyPages();
	OVERRIDE_ResultHandler_CreatePropertyPages();
	
	OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
	
	// Initializes the node
	HRESULT ConstructNode(ITFSNode *pNode, IInterfaceInfo *pIfInfo,
						 IPXConnection *pIPXConn);
	HRESULT	Init(IInterfaceInfo *pInfo, ITFSNode *pParent);

	// Refreshes all routes
	HRESULT	ParentRefresh(ITFSNode *pNode);

	// Removes the static route
	HRESULT OnRemoveStaticRoute(ITFSNode *pNode);

	// Route modification apis
	HRESULT RemoveStaticRoute(IpxSRListEntry *pSREntry, IInfoBase *pInfo);
	HRESULT	ModifyRouteInfo(ITFSNode *pNode,
							IpxSRListEntry *pSREntry,
							IpxSRListEntry *pSREntryOld);
	
public:
	// Structure used to pass data to callbacks - used as a way of
	// avoiding recomputation
	struct SMenuData
	{
		ULONG				m_ulMenuId;
		SPITFSNode			m_spNode;
	};
	ULONG	GetSeparatorFlags(SMenuData *pData);
	
protected:
	LONG_PTR			m_ulConnId;
	SPIInterfaceInfo	m_spInterfaceInfo;
};


//----------------------------------------------------------------------------
// Class:       CStaticRouteDlg
//
// Controls the 'Add/Edit Static Route' dialog.
//----------------------------------------------------------------------------

// Set if we are modifying an exising entry (the only change this does
// is that we will fill in the controls with the data in the structure).
#define SR_DLG_MODIFY		0x00000001

class CStaticRouteDlg : public CBaseDialog
{    
public:

	CStaticRouteDlg(IpxSRListEntry *	pSREntry,
					DWORD					dwFlags,
					IRouterInfo *			pRouter,
					CWnd*					pParent = NULL );
    
	//{{AFX_DATA(CStaticRouteDlg)
	CComboBox           m_cbInterfaces;
	CSpinButtonCtrl		m_spinTickCount;
	CSpinButtonCtrl		m_spinHopCount;
	//}}AFX_DATA
	
	
	//{{AFX_VIRTUAL(CStaticRouteDlg)
protected:
	virtual void        DoDataExchange(CDataExchange* pDX);
	//}}AFX_VIRTUAL
	
protected:
	static DWORD		m_dwHelpMap[];

	CStringList         m_ifidList;

	DWORD				m_dwFlags;
	SPIRouterInfo		m_spRouterInfo;
	IpxSRListEntry *m_pSREntry;

	//{{AFX_MSG(CStaticRouteDlg)
	virtual void        OnOK();
	virtual BOOL        OnInitDialog();
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};

HRESULT SetRouteData(BaseIPXResultNodeData *pData,
					 IpxSRListEntry *pRoute);
HRESULT AddStaticRoute(IpxSRListEntry *pSREntry,
					   IInfoBase *InfoBase,
					   InfoBlock *pBlock);
BOOL FAreTwoRoutesEqual(IPX_STATIC_ROUTE_INFO *pRoute1,
						IPX_STATIC_ROUTE_INFO *pRoute2);
#endif _SRVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\sapview.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    sapview.h
//
// History:
//	09/05/97	Kenn M. Takara			Created.
//
//	IPX SAP view
//
//============================================================================


#ifndef _SAPVIEW_H
#define _SAPVIEW_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _XSTREAM_H
#include "xstream.h"		// need for ColumnData
#endif

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _IPXFACE_H
#include "ipxface.h"
#endif

#ifndef _BASECON_H
#include "basecon.h"		// BaseContainerHandler
#endif

#ifndef _SAPSTRM_H
#include "sapstrm.h"
#endif

#ifndef _RTRSHEET_H
#include "rtrsheet.h"
#endif

#ifndef _IPXCONN_H
#include "ipxconn.h"			// IPXConnection
#endif

#ifndef _SAPSTATS_H_
#include "sapstats.h"
#endif

// forward declarations
struct SSapNodeMenu;

/*---------------------------------------------------------------------------
	This is the list of columns available for the IP Static Routes
	node.
		- Interface, e.g. "[1] Foobar nic..."
		- Relay mode, e.g. "Enabled"
		- Requests received
		- Replies received
		- Requests discarded
		- Replies discarded
		- Send failures
		- Receive failres
 ---------------------------------------------------------------------------*/


//
// If you ADD any columns to this enum, Be sure to update
// the string ids for the column headers in srview.cpp
//
enum
{
 	SAP_SI_INTERFACE = 0,
	SAP_SI_TYPE,
	SAP_SI_ACCEPT_ROUTES,
	SAP_SI_SUPPLY_ROUTES,
	SAP_SI_GSNR,
	SAP_SI_UPDATE_MODE,
	SAP_SI_UPDATE_PERIOD,
	SAP_SI_AGE_MULTIPLIER,
	SAP_SI_ADMIN_STATE,
	SAP_SI_OPER_STATE,
	SAP_SI_PACKETS_SENT,
	SAP_SI_PACKETS_RECEIVED,
	SAP_SI_MAX_COLUMNS,
};


/*---------------------------------------------------------------------------
	We store a pointer to the IPXConnection object in our node data
 ---------------------------------------------------------------------------*/

#define GET_SAP_NODEDATA(pNode) \
		(IPXConnection *) pNode->GetData(TFS_DATA_USER)
#define SET_SAP_NODEDATA(pNode, pData) \
		pNode->SetData(TFS_DATA_USER, (LONG_PTR) pData)


/*---------------------------------------------------------------------------
	Struct:	SapListEntry
 ---------------------------------------------------------------------------*/
struct SapListEntry
{
	SPIInterfaceInfo	m_spIf;			// ptr to interface
	SAP_IF_INFO			m_info;			
	SAP_IF_STATS		m_stats;
	BOOL				m_fClient;		// TRUE if client interface
	DWORD				m_dwIfIndex;	// interface index
	BOOL				m_fFoundIfIndex;
	SPITFSNode			m_spNode;
};

typedef CList<SapListEntry *, SapListEntry *> SapList;



/*---------------------------------------------------------------------------
	Class:	SapNodeHandler
 ---------------------------------------------------------------------------*/

class SapNodeHandler :
		public BaseContainerHandler
{
public:
	SapNodeHandler(ITFSComponentData *pTFSCompData);

	// Override QI to handle embedded interface
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);
	
	DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)

	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_GetString();
	OVERRIDE_NodeHandler_OnCreateDataObject();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_DestroyHandler();

	OVERRIDE_BaseHandlerNotify_OnExpand();

	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_CompareItems();

	OVERRIDE_BaseResultHandlerNotify_OnResultShow();	
	
	
	// Initializes the handler
	HRESULT	Init(IRouterInfo *pRouter, SapConfigStream *pConfigStream);
	
	// Initializes the node
	HRESULT ConstructNode(ITFSNode *pNode);

public:
	// Structure used to pass data to callbacks - used as a way of
	// avoiding recomputation
	struct SMenuData
	{
		SPITFSNode			m_spNode;
	};
	
protected:
	// Refresh the data for these nodes
	HRESULT	SynchronizeNodeData(ITFSNode *pThisNode);
	HRESULT	GetSapData(ITFSNode *pThisNode, SapList *pSapList);
	HRESULT	FillInInterfaceIndex(IPXConnection *pIPXConn, SapList *pSapList);
	HRESULT	FillClientData(SapListEntry *pSapEntry);


	// Helper function to add interfaces to the UI
	HRESULT	AddInterfaceNode(ITFSNode *pParent,
							 IInterfaceInfo *pIf,
							 BOOL fClient);
	HRESULT AddProtocolToInfoBase(ITFSNode *pParent);
	HRESULT	AddProtocolToInterface(ITFSNode *pParent);

	LONG_PTR			m_ulConnId;// notification id for RtrMgrProt
	LONG_PTR			m_ulRmConnId;
	LONG_PTR			m_ulRefreshConnId;	// notification id for Refresh
	LONG_PTR			m_ulStatsConnId;
	MMC_COOKIE			m_cookie;		// cookie for the node
	SPIRtrMgrInfo	m_spRm;
	SPIRtrMgrProtocolInfo	m_spRmProt;
	SapConfigStream *	m_pConfigStream;
	CString			m_stTitle;
	BOOL			m_fProtocolIsRunning;	// TRUE if protocol is running

	SAPParamsStatistics	m_SAPParamsStats;
};





/*---------------------------------------------------------------------------
	Class:	SapInterfaceHandler

	This is the handler for the interface nodes that appear in the Sap
	node.
 ---------------------------------------------------------------------------*/

class SapInterfaceHandler : public BaseIPXResultHandler
{
public:
	SapInterfaceHandler(ITFSComponentData *pCompData);
	
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnCreateDataObject();
	
	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_OnCreateDataObject();
	OVERRIDE_ResultHandler_DestroyResultHandler();
	OVERRIDE_ResultHandler_HasPropertyPages()
			{	return hrOK;	};
	OVERRIDE_ResultHandler_CreatePropertyPages();
	
	// Initializes the node
	HRESULT ConstructNode(ITFSNode *pNode, IInterfaceInfo *pIfInfo,
						 IPXConnection *pIPXConn);
	HRESULT	Init(IInterfaceInfo *pInfo, IRouterInfo *pRouter, ITFSNode *pParent);

	// Refresh the data for this node
	void RefreshInterface(MMC_COOKIE cookie);

public:
	// Structure used to pass data to callbacks - used as a way of
	// avoiding recomputation
	struct SMenuData
	{
		ULONG				m_ulMenuId;
		SPITFSNode			m_spNode;
	};
	
protected:
	LONG_PTR				m_ulConnId;
	SPIInterfaceInfo	m_spInterfaceInfo;
};





#endif _SAPVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\srview.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	srview.cpp
		Static routes node implementation.
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "util.h"
#include "srview.h"
#include "reg.h"
#include "ipxadmin.h"
#include "rtrutil.h"	// smart MPR handle pointers
#include "ipxstrm.h"		// IPXAdminConfigStream
#include "strmap.h"		// XXXtoCString functions
#include "service.h"	// TFS service APIs
#include "format.h"		// FormatNumber function
#include "coldlg.h"		// columndlg
#include "ipxutil.h"
#include "column.h"		// ComponentConfigStream
#include "rtrui.h"
#include "routprot.h"	// IP_LOCAL
#include "rtrres.h"
#include "dumbprop.h"
#include "IpxStaticRoute.h"


/*---------------------------------------------------------------------------
	Keep this in sync with the column ids in srview.h
 ---------------------------------------------------------------------------*/
extern const ContainerColumnInfo	s_rgSRViewColumnInfo[];

const ContainerColumnInfo	s_rgSRViewColumnInfo[] = 
{
	{ IDS_IPX_SR_COL_NAME,			CON_SORT_BY_STRING, TRUE, COL_IF_NAME },
	{ IDS_IPX_SR_COL_NETWORK,		CON_SORT_BY_STRING,	TRUE, COL_IPXNET },
	{ IDS_IPX_SR_COL_NEXT_HOP,		CON_SORT_BY_STRING,	TRUE, COL_STRING },
	{ IDS_IPX_SR_COL_TICK_COUNT,	CON_SORT_BY_DWORD,	TRUE, COL_SMALL_NUM },
	{ IDS_IPX_SR_COL_HOP_COUNT,		CON_SORT_BY_DWORD,	TRUE, COL_SMALL_NUM },
};


/*---------------------------------------------------------------------------
	IpxSRHandler implementation
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(IpxSRHandler)


IpxSRHandler::IpxSRHandler(ITFSComponentData *pCompData)
	: BaseContainerHandler(pCompData, COLUMNS_STATICROUTES,
						   s_rgSRViewColumnInfo),
	m_ulConnId(0),
	m_ulRefreshConnId(0)
{
	// Setup the verb states
	m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
	m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;

	DEBUG_INCREMENT_INSTANCE_COUNTER(IpxSRHandler)
}

IpxSRHandler::~IpxSRHandler()
{
	DEBUG_DECREMENT_INSTANCE_COUNTER(IpxSRHandler)
}


STDMETHODIMP IpxSRHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IRtrAdviseSink)
		*ppv = &m_IRtrAdviseSink;
	else
		return BaseContainerHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;	
}



/*!--------------------------------------------------------------------------
	IpxSRHandler::DestroyHandler
		Implementation of ITFSNodeHandler::DestroyHandler
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxSRHandler::DestroyHandler(ITFSNode *pNode)
{
	IPXConnection *	pIPXConn;

	pIPXConn = GET_IPX_SR_NODEDATA(pNode);
	pIPXConn->Release();

	if (m_ulRefreshConnId)
	{
		SPIRouterRefresh	spRefresh;
		if (m_spRouterInfo)
			m_spRouterInfo->GetRefreshObject(&spRefresh);
		if (spRefresh)
			spRefresh->UnadviseRefresh(m_ulRefreshConnId);
	}
	m_ulRefreshConnId = 0;
	
	if (m_ulConnId)
		m_spRtrMgrInfo->RtrUnadvise(m_ulConnId);
	m_ulConnId = 0;
	m_spRtrMgrInfo.Release();

	m_spRouterInfo.Release();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IpxSRHandler::HasPropertyPages
		Implementation of ITFSNodeHandler::HasPropertyPages
	NOTE: the root node handler has to over-ride this function to 
	handle the snapin manager property page (wizard) case!!!
	
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
IpxSRHandler::HasPropertyPages
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	return hrFalse;
}

/*---------------------------------------------------------------------------
	Menu data structure for our menus
 ---------------------------------------------------------------------------*/

static const SRouterNodeMenu	s_rgIfNodeMenu[] =
{
	{ IDS_MENU_IPX_SR_NEW_ROUTE, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },

	{ IDS_MENU_SEPARATOR, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },

	{ IDS_MENU_IPX_SR_TASK_ROUTING, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },
};



/*!--------------------------------------------------------------------------
	IpxSRHandler::OnAddMenuItems
		Implementation of ITFSNodeHandler::OnAddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxSRHandler::OnAddMenuItems(
	ITFSNode *pNode,
	LPCONTEXTMENUCALLBACK pContextMenuCallback, 
	LPDATAOBJECT lpDataObject, 
	DATA_OBJECT_TYPES type, 
	DWORD dwType,
	long *pInsertionAllowed)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = S_OK;
    IpxSRHandler::SMenuData menuData;
	
	COM_PROTECT_TRY
	{
        menuData.m_spNode.Set(pNode);
        
		hr = AddArrayOfMenuItems(pNode, s_rgIfNodeMenu,
								 DimensionOf(s_rgIfNodeMenu),
								 pContextMenuCallback,
								 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
	}
	COM_PROTECT_CATCH;
		
	return hr; 
}

/*!--------------------------------------------------------------------------
	IpxSRHandler::OnCommand
		Implementation of ITFSNodeHandler::OnCommand
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxSRHandler::OnCommand(ITFSNode *pNode, long nCommandId, 
										   DATA_OBJECT_TYPES	type, 
										   LPDATAOBJECT pDataObject, 
										   DWORD	dwType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;

	COM_PROTECT_TRY
	{
		switch (nCommandId)
		{
			case IDS_MENU_IPX_SR_NEW_ROUTE:
				hr = OnNewRoute(pNode);
				if (!FHrSucceeded(hr))
					DisplayErrorMessage(NULL, hr);
 				break;
			case IDS_MENU_IPX_SR_TASK_ROUTING:
				hr = ForwardCommandToParent(pNode,
											IDS_MENU_IPXSUM_TASK_ROUTING_TABLE,
											type, pDataObject, dwType);
				break;
			case IDS_MENU_SYNC:
				SynchronizeNodeData(pNode);
				break;
		}
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	IpxSRHandler::GenerateListOfRoutes
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSRHandler::GenerateListOfRoutes(ITFSNode *pNode, IpxSRList *pSRList)
{
	Assert(pSRList);
	HRESULT	hr = hrOK;
	SPIEnumInterfaceInfo	spEnumIf;
	SPIInterfaceInfo		spIf;
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPIInfoBase				spInfoBase;
	PIPX_STATIC_ROUTE_INFO	pRoute;
	InfoBlock *				pBlock;
	int						i;
	IpxSRListEntry *	pSREntry;
	
	COM_PROTECT_TRY
	{
		// Ok go through and find all of the static routes

		CORg( m_spRouterInfo->EnumInterface(&spEnumIf) );

		for (; spEnumIf->Next(1, &spIf, NULL) == hrOK; spIf.Release())
		{
			// Get the next interface
			spRmIf.Release();
			if (spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) != hrOK)
				continue;

			// Load IP information for this interface
			spInfoBase.Release();
			if (spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase) != hrOK)
				continue;

			// Retrieve the data for the IPX_STATIC_ROUTE_INFO block
			if (spInfoBase->GetBlock(IPX_STATIC_ROUTE_INFO_TYPE, &pBlock, 0) != hrOK)
				continue;

			pRoute = (PIPX_STATIC_ROUTE_INFO) pBlock->pData;

			// Update our list of routes with the routes read from this
			// interface

			for (i=0; i<(int) pBlock->dwCount; i++, pRoute++)
			{
				pSREntry = new IpxSRListEntry;
				pSREntry->m_spIf.Set(spIf);
				pSREntry->m_route = *pRoute;
				
				pSRList->AddTail(pSREntry);
			}
			
		}

	}
	COM_PROTECT_CATCH;

	if (!FHrSucceeded(hr))
	{
		// Should make sure that we get the SRList cleaned up
		while (!pSRList->IsEmpty())
			delete pSRList->RemoveHead();
	}

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxSRHandler::OnExpand
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSRHandler::OnExpand(ITFSNode *pNode,LPDATAOBJECT pDataObject, DWORD dwType, LPARAM arg,LPARAM lParam)
{
	HRESULT	hr = hrOK;
	IpxSRList			SRList;
	IpxSRListEntry *	pSREntry;
	
	if (m_bExpanded)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Ok go through and find all of the static routes
		CORg( GenerateListOfRoutes(pNode, &SRList) );

		// Now iterate through the list of static routes adding them
		// all in.  Ideally we could merge this into the Refresh code,
		// but the refresh code can't assume a blank slate.
		while (!SRList.IsEmpty())
		{
			pSREntry = SRList.RemoveHead();
			AddStaticRouteNode(pNode, pSREntry);
			delete pSREntry;
		}

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	// Should make sure that we get the SRList cleaned up
	while (!SRList.IsEmpty())
		delete SRList.RemoveHead();


	m_bExpanded = TRUE;

	return hr;
}

/*!--------------------------------------------------------------------------
	IpxSRHandler::GetString
		Implementation of ITFSNodeHandler::GetString
		We don't need to do anything, since our root node is an extension
		only and thus can't do anything to the node text.
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) IpxSRHandler::GetString(ITFSNode *pNode, int nCol)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		if (m_stTitle.IsEmpty())
			m_stTitle.LoadString(IDS_IPX_SR_TITLE);
	}
	COM_PROTECT_CATCH;

	return m_stTitle;
}

/*!--------------------------------------------------------------------------
	IpxSRHandler::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxSRHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{

		Assert(m_spRtrMgrInfo);
		
		CORg( CreateDataObjectFromRtrMgrInfo(m_spRtrMgrInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxSRHandler::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSRHandler::Init(IRtrMgrInfo *pRmInfo, IPXAdminConfigStream *pConfigStream)
{
	m_spRtrMgrInfo.Set(pRmInfo);
	if (pRmInfo)
		pRmInfo->GetParentRouterInfo(&m_spRouterInfo);
	m_pConfigStream = pConfigStream;
	
	// Also need to register for change notifications
	Assert(m_ulConnId == 0);
	m_spRtrMgrInfo->RtrAdvise(&m_IRtrAdviseSink, &m_ulConnId, 0);

	return hrOK;
}


/*!--------------------------------------------------------------------------
	IpxSRHandler::ConstructNode
		Initializes the root node (sets it up).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSRHandler::ConstructNode(ITFSNode *pNode, LPCTSTR pszName,
										IPXConnection *pIPXConn)
{
	Assert(pIPXConn);
	HRESULT			hr = hrOK;
	
	if (pNode == NULL)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Need to initialize the data for the root node
		pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_IPX_NODE_GENERAL);
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_IPX_NODE_GENERAL);
		pNode->SetData(TFS_DATA_SCOPEID, 0);

        // This is a leaf node in the scope pane
        pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

		m_cookie = reinterpret_cast<DWORD_PTR>(pNode);
		pNode->SetData(TFS_DATA_COOKIE, m_cookie);

		pNode->SetNodeType(&GUID_IPXStaticRoutesNodeType);

		// Setup the node data
		pIPXConn->AddRef();
		SET_IPX_SR_NODEDATA(pNode, pIPXConn);

	}
	COM_PROTECT_CATCH;

	if (!FHrSucceeded(hr))
	{
		SET_IPX_SR_NODEDATA(pNode, NULL);
	}

	return hr;
}

/*!--------------------------------------------------------------------------
	IpxSRHandler::AddStaticRouteNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSRHandler::AddStaticRouteNode(ITFSNode *pParent, IpxSRListEntry *pRoute)
{
	IpxRouteHandler *	pHandler;
	SPITFSResultHandler		spHandler;
	SPITFSNode				spNode;
	HRESULT					hr = hrOK;
	BaseIPXResultNodeData *	pData;
	IPXConnection *			pIPXConn;

	// Create the handler for this node 
	pHandler = new IpxRouteHandler(m_spTFSCompData);
	spHandler = pHandler;
	CORg( pHandler->Init(pRoute->m_spIf, pParent) );

	pIPXConn = GET_IPX_SR_NODEDATA(pParent);

	// Create a result item node (or a leaf node)
	CORg( CreateLeafTFSNode(&spNode,
							NULL,
							static_cast<ITFSNodeHandler *>(pHandler),
							static_cast<ITFSResultHandler *>(pHandler),
							m_spNodeMgr) );
	CORg( pHandler->ConstructNode(spNode, pRoute->m_spIf, pIPXConn) );

	pData = GET_BASEIPXRESULT_NODEDATA(spNode);
	Assert(pData);
	ASSERT_BASEIPXRESULT_NODEDATA(pData);

	// Set the data for this node
	SetRouteData(pData, pRoute);
	

	// Make the node immediately visible
	CORg( spNode->SetVisibilityState(TFS_VIS_SHOW) );
	CORg( pParent->AddChild(spNode) );

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxSRHandler::SynchronizeNodeData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSRHandler::SynchronizeNodeData(ITFSNode *pNode)
{
	HRESULT					hr = hrOK;
	BaseIPXResultNodeData *	pNodeData;
	SPITFSNodeEnum			spNodeEnum;
	SPITFSNode				spChildNode;
	BOOL					fFound;
	IpxSRList			SRList;
	IpxSRList			newSRList;
	IpxSRListEntry *	pSREntry;

	COM_PROTECT_TRY
	{
	
		// Mark all of the nodes
		CORg( pNode->GetEnum(&spNodeEnum) );
		MarkAllNodes(pNode, spNodeEnum);
		
		// Go out and grab the data, merge the new data in with the old data
		// This is the data-gathering code and this is what should go
		// on the background thread for the refresh code.
		CORg( GenerateListOfRoutes(pNode, &SRList) );

		while (!SRList.IsEmpty())
		{
			pSREntry = SRList.RemoveHead();
			
			// Look for this entry in our current list of nodes
			spNodeEnum->Reset();
			spChildNode.Release();

			fFound = FALSE;
			
			for (;spNodeEnum->Next(1, &spChildNode, NULL) == hrOK; spChildNode.Release())
			{
				TCHAR	szNumber[32];
				
				pNodeData = GET_BASEIPXRESULT_NODEDATA(spChildNode);
				Assert(pNodeData);
				ASSERT_BASEIPXRESULT_NODEDATA(pNodeData);

				FormatMACAddress(szNumber,
								 DimensionOf(szNumber),
								 pSREntry->m_route.NextHopMacAddress,
								 DimensionOf(pSREntry->m_route.NextHopMacAddress));

				if ((memcmp(&(pNodeData->m_rgData[IPX_SR_SI_NETWORK].m_dwData),
							pSREntry->m_route.Network,
							sizeof(pSREntry->m_route.Network)) == 0) &&
					(StriCmp(pNodeData->m_spIf->GetId(), pSREntry->m_spIf->GetId()) == 0) &&
					(StriCmp(pNodeData->m_rgData[IPX_SR_SI_NEXT_HOP].m_stData, szNumber) == 0))
				{
					// Ok, this route already exists, update the metric
					// and mark it
					Assert(pNodeData->m_dwMark == FALSE);
					pNodeData->m_dwMark = TRUE;
					
					fFound = TRUE;
					
					SetRouteData(pNodeData, pSREntry);
					
					// Force MMC to redraw the node
					spChildNode->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);
					break;
				}

			}
			
			if (fFound)
				delete pSREntry;
			else
				newSRList.AddTail(pSREntry);
		}
		
		// Now remove all nodes that were not marked
		RemoveAllUnmarkedNodes(pNode, spNodeEnum);
		
		
		// Now iterate through the list of static routes adding them
		// all in.  Ideally we could merge this into the Refresh code,
		// but the refresh code can't assume a blank slate.
		POSITION	pos;
		
		while (!newSRList.IsEmpty())
		{
			pSREntry = newSRList.RemoveHead();
			AddStaticRouteNode(pNode, pSREntry);
			delete pSREntry;
		}

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	
	while (!SRList.IsEmpty())
		delete SRList.RemoveHead();
	
	while (!newSRList.IsEmpty())
		delete newSRList.RemoveHead();
	
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxSRHandler::MarkAllNodes
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSRHandler::MarkAllNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum)
{
	SPITFSNode	spChildNode;
	BaseIPXResultNodeData *	pNodeData;
	
	pEnum->Reset();
	for ( ;pEnum->Next(1, &spChildNode, NULL) == hrOK; spChildNode.Release())
	{
		pNodeData = GET_BASEIPXRESULT_NODEDATA(spChildNode);
		Assert(pNodeData);
		ASSERT_BASEIPXRESULT_NODEDATA(pNodeData);
		
		pNodeData->m_dwMark = FALSE;			
	}
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IpxSRHandler::RemoveAllUnmarkedNodes
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSRHandler::RemoveAllUnmarkedNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum)
{
	HRESULT		hr = hrOK;
	SPITFSNode	spChildNode;
	BaseIPXResultNodeData *	pNodeData;
	
	pEnum->Reset();
	for ( ;pEnum->Next(1, &spChildNode, NULL) == hrOK; spChildNode.Release())
	{
		pNodeData = GET_BASEIPXRESULT_NODEDATA(spChildNode);
		Assert(pNodeData);
		ASSERT_BASEIPXRESULT_NODEDATA(pNodeData);
		
		if (pNodeData->m_dwMark == FALSE)
		{
			pNode->RemoveChild(spChildNode);
			spChildNode->Destroy();
		}
	}

	return hr;
}


/*---------------------------------------------------------------------------
	This is the set of menus that will appear when a right-click is
	done on the blank area of the result pane.
 ---------------------------------------------------------------------------*/
static const SRouterNodeMenu	s_rgIfResultNodeMenu[] =
{
	{ IDS_MENU_IPX_SR_NEW_ROUTE, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },

	{ IDS_MENU_SEPARATOR, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },

	{ IDS_MENU_IPX_SR_TASK_ROUTING, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },			
};




/*!--------------------------------------------------------------------------
	IpxSRHandler::AddMenuItems
		Implementation of ITFSResultHandler::AddMenuItems
		Use this to add commands to the context menu of the blank areas
		of the result pane.
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxSRHandler::AddMenuItems(ITFSComponent *pComponent,
											  MMC_COOKIE cookie,
											  LPDATAOBJECT pDataObject,
											  LPCONTEXTMENUCALLBACK pCallback,
											  long *pInsertionAllowed)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT	hr = hrOK;
	SPITFSNode	spNode;
    IpxSRHandler::SMenuData menuData;

	COM_PROTECT_TRY
	{
		m_spNodeMgr->FindNode(cookie, &spNode);
        menuData.m_spNode.Set(spNode);
        
		hr = AddArrayOfMenuItems(spNode,
								 s_rgIfResultNodeMenu,
								 DimensionOf(s_rgIfResultNodeMenu),
								 pCallback,
								 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
	}
	COM_PROTECT_CATCH;

	return hr;
}


/*!--------------------------------------------------------------------------
	IpxSRHandler::Command
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxSRHandler::Command(ITFSComponent *pComponent,
									   MMC_COOKIE cookie,
									   int nCommandID,
									   LPDATAOBJECT pDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	SPITFSNode	spNode;
	HRESULT		hr = hrOK;

	switch (nCommandID)
	{
		case IDS_MENU_IPX_SR_NEW_ROUTE:
			{
				m_spNodeMgr->FindNode(cookie, &spNode);
				hr = OnNewRoute(spNode);
				if (!FHrSucceeded(hr))
					DisplayErrorMessage(NULL, hr);
			}
			break;
		case IDS_MENU_IPX_SR_TASK_ROUTING:
			{
				m_spNodeMgr->FindNode(cookie, &spNode);
				hr = ForwardCommandToParent(spNode,
											IDS_MENU_IPXSUM_TASK_ROUTING_TABLE,
											CCT_RESULT, NULL, 0
										   );
			}
			break;
	}
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxSRHandler::CompareItems
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int) IpxSRHandler::CompareItems(
								ITFSComponent * pComponent,
								MMC_COOKIE cookieA,
								MMC_COOKIE cookieB,
								int nCol)
{
	// Get the strings from the nodes and use that as a basis for
	// comparison.
	SPITFSNode	spNode;
	SPITFSResultHandler	spResult;

	m_spNodeMgr->FindNode(cookieA, &spNode);
	spNode->GetResultHandler(&spResult);
	return spResult->CompareItems(pComponent, cookieA, cookieB, nCol);
}



/*!--------------------------------------------------------------------------
	IpxSRHandler::OnNewRoute
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT	IpxSRHandler::OnNewRoute(ITFSNode *pNode)
{
	HRESULT	hr = hrOK;
	IpxSRListEntry	SREntry;
	CStaticRouteDlg			srdlg(&SREntry, 0, m_spRouterInfo);
	SPIInfoBase				spInfoBase;
	SPIRtrMgrInterfaceInfo	spRmIf;
	IPXConnection *			pIPXConn;
	InfoBlock *				pBlock;
								
	pIPXConn = GET_IPX_SR_NODEDATA(pNode);
	Assert(pIPXConn);

	::ZeroMemory(&(SREntry.m_route), sizeof(SREntry.m_route));

	if (srdlg.DoModal() == IDOK)
	{
		CORg( SREntry.m_spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) );
		CORg( spRmIf->GetInfoBase(pIPXConn->GetConfigHandle(),
								  NULL,
								  NULL,
								  &spInfoBase));
		
		// Ok, go ahead and add the route
		
		// Get the IPX_STATIC_ROUTE_INFO block from the interface
		spInfoBase->GetBlock(IPX_STATIC_ROUTE_INFO_TYPE, &pBlock, 0);
		
		CORg( AddStaticRoute(&SREntry, spInfoBase, pBlock) );

		// Update the interface information
		CORg( spRmIf->Save(SREntry.m_spIf->GetMachineName(),
						   pIPXConn->GetConfigHandle(),
						   NULL,
						   NULL,
						   spInfoBase,
						   0));	

		// Refresh the node
		SynchronizeNodeData(pNode);
	}

Error:
	return hr;
}

ImplementEmbeddedUnknown(IpxSRHandler, IRtrAdviseSink)

STDMETHODIMP IpxSRHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
	DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
	InitPThis(IpxSRHandler, IRtrAdviseSink);
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		if (dwChangeType == ROUTER_REFRESH)
		{
			SPITFSNode	spNode;

			Assert(ulConn == pThis->m_ulRefreshConnId);
			
			pThis->m_spNodeMgr->FindNode(pThis->m_cookie, &spNode);
			pThis->SynchronizeNodeData(spNode);
		}
	}
	COM_PROTECT_CATCH;
	
	return hr;
}


HRESULT IpxSRHandler::OnResultRefresh(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT  hr = hrOK;
    SPITFSNode spNode, spParent;
    SPITFSResultHandler spParentRH;

    m_spNodeMgr->FindNode(cookie, &spNode);

    // forward this command to the parent to handle
    CORg (spNode->GetParent(&spParent));
    CORg (spParent->GetResultHandler(&spParentRH));

    CORg (spParentRH->Notify(pComponent, spParent->GetData(TFS_DATA_COOKIE), pDataObject, MMCN_REFRESH, arg, lParam));

Error:
    return hrOK;

}


/*!--------------------------------------------------------------------------
	IpxSRHandler::OnResultShow
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSRHandler::OnResultShow(ITFSComponent *pTFSComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	BOOL	bSelect = (BOOL) arg;
	HRESULT	hr = hrOK;
	SPIRouterRefresh	spRefresh;
	SPITFSNode	spNode;

	BaseContainerHandler::OnResultShow(pTFSComponent, cookie, arg, lParam);

	if (bSelect)
	{
		// Call synchronize on this node
		m_spNodeMgr->FindNode(cookie, &spNode);
		if (spNode)
			SynchronizeNodeData(spNode);
	}

	// Un/Register for refresh advises
	if (m_spRouterInfo)
		m_spRouterInfo->GetRefreshObject(&spRefresh);

	if (spRefresh)
	{
		if (bSelect)
		{
			if (m_ulRefreshConnId == 0)
				spRefresh->AdviseRefresh(&m_IRtrAdviseSink, &m_ulRefreshConnId, 0);
		}
		else
		{
			if (m_ulRefreshConnId)
				spRefresh->UnadviseRefresh(m_ulRefreshConnId);
			m_ulRefreshConnId = 0;
		}
	}
	
	return hr;
}


/*---------------------------------------------------------------------------
	Class: IpxRouteHandler
 ---------------------------------------------------------------------------*/

IpxRouteHandler::IpxRouteHandler(ITFSComponentData *pCompData)
	: BaseIPXResultHandler(pCompData, COLUMNS_STATICROUTES),
	m_ulConnId(0)
{
 	m_rgButtonState[MMC_VERB_PROPERTIES_INDEX] = ENABLED;
	m_bState[MMC_VERB_PROPERTIES_INDEX] = TRUE;
	
	m_rgButtonState[MMC_VERB_DELETE_INDEX] = ENABLED;
	m_bState[MMC_VERB_DELETE_INDEX] = TRUE;

 	m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
	m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;
	
	m_verbDefault = MMC_VERB_PROPERTIES;
}

/*!--------------------------------------------------------------------------
	IpxRouteHandler::ConstructNode
		Initializes the Domain node (sets it up).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxRouteHandler::ConstructNode(ITFSNode *pNode, IInterfaceInfo *pIfInfo, IPXConnection *pIPXConn)
{
	HRESULT			hr = hrOK;
	int				i;
	
	if (pNode == NULL)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Need to initialize the data for the Domain node

		pNode->SetData(TFS_DATA_SCOPEID, 0);

		// We don't want icons for these nodes.
		pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_IPX_NODE_GENERAL);
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_IPX_NODE_GENERAL);

		pNode->SetData(TFS_DATA_COOKIE, reinterpret_cast<DWORD_PTR>(pNode));

		//$ Review: kennt, what are the different type of interfaces
		// do we distinguish based on the same list as above? (i.e. the
		// one for image indexes).
		pNode->SetNodeType(&GUID_IPXStaticRoutesResultNodeType);

		BaseIPXResultNodeData::Init(pNode, pIfInfo, pIPXConn);
	}
	COM_PROTECT_CATCH
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxRouteHandler::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxRouteHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		CORg( CreateDataObjectFromInterfaceInfo(m_spInterfaceInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxRouteHandler::OnCreateDataObject
		Implementation of ITFSResultHandler::OnCreateDataObject
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxRouteHandler::OnCreateDataObject(ITFSComponent *pComp, MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		CORg( CreateDataObjectFromInterfaceInfo(m_spInterfaceInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}



/*!--------------------------------------------------------------------------
	IpxRouteHandler::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxRouteHandler::Init(IInterfaceInfo *pIfInfo, ITFSNode *pParent)
{
	Assert(pIfInfo);

	m_spInterfaceInfo.Set(pIfInfo);

    if (pIfInfo)
        pIfInfo->GetParentRouterInfo(&m_spRouterInfo);

	BaseIPXResultHandler::Init(pIfInfo, pParent);
	return hrOK;
}


/*!--------------------------------------------------------------------------
	IpxRouteHandler::DestroyResultHandler
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxRouteHandler::DestroyResultHandler(MMC_COOKIE cookie)
{
	m_spInterfaceInfo.Release();
	BaseIPXResultHandler::DestroyResultHandler(cookie);
	return hrOK;
}


/*!--------------------------------------------------------------------------
	IpxRouteHandler::AddMenuItems
		Implementation of ITFSResultHandler::AddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxRouteHandler::AddMenuItems(
	ITFSComponent *pComponent,
	MMC_COOKIE cookie,
	LPDATAOBJECT lpDataObject, 
	LPCONTEXTMENUCALLBACK pContextMenuCallback, 
	long *pInsertionAllowed)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IpxRouteHandler::Command
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxRouteHandler::Command(ITFSComponent *pComponent,
									   MMC_COOKIE cookie,
									   int nCommandID,
									   LPDATAOBJECT pDataObject)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IpxRouteHandler::HasPropertyPages
		- 
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxRouteHandler::HasPropertyPages 
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	return S_OK;

/*	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// Need to fill in a IpxSRListEntry
	IpxSRListEntry	SREntry;
	IpxSRListEntry	SREntryOld;
	SPIRouterInfo			spRouterInfo;
	HRESULT					hr = hrOK;

	CORg( m_spInterfaceInfo->GetParentRouterInfo(&spRouterInfo) );
	
	BaseIPXResultNodeData *	pNodeData;

	pNodeData = GET_BASEIPXRESULT_NODEDATA(pNode);
	Assert(pNodeData);
	ASSERT_BASEIPXRESULT_NODEDATA(pNodeData);

	// Fill in our SREntry
	SREntry.LoadFrom(pNodeData);
	SREntryOld.LoadFrom(pNodeData);
	
	{
		CStaticRouteDlg	srdlg(&SREntry, SR_DLG_MODIFY, spRouterInfo);
		if (srdlg.DoModal() == IDOK)
		{
			// Updates the route info for this route
			ModifyRouteInfo(pNode, &SREntry, &SREntryOld);

			// Update the data in the UI
			SetRouteData(pNodeData, &SREntry);
			m_spInterfaceInfo.Set(SREntry.m_spIf);
			
			// Force a refresh
			pNode->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);
		}
	}
Error:
	return hrOK;*/
}

STDMETHODIMP IpxRouteHandler::HasPropertyPages(ITFSComponent *pComponent,
											   MMC_COOKIE cookie,
											   LPDATAOBJECT pDataObject)
{
	SPITFSNode	spNode;

	m_spNodeMgr->FindNode(cookie, &spNode);
	return HasPropertyPages(spNode, pDataObject, CCT_RESULT, 0);
}

/*!--------------------------------------------------------------------------
	IpxRouteHandler::CreatePropertyPages
		Implementation of ResultHandler::CreatePropertyPages
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxRouteHandler::CreatePropertyPages
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPPROPERTYSHEETCALLBACK	lpProvider, 
	LPDATAOBJECT			pDataObject, 
	LONG_PTR					handle
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT	hr = hrOK;
	SPITFSNode	spNode;

	Assert( m_spNodeMgr );

	CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

	// Call the ITFSNodeHandler::CreatePropertyPages
	hr = CreatePropertyPages(spNode, lpProvider, pDataObject, handle, 0);

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxRouteHandler::CreatePropertyPages
		Implementation of NodeHandler::CreatePropertyPages
	Author: Deonb
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxRouteHandler::CreatePropertyPages
(
	ITFSNode *				pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject, 
	LONG_PTR				handle, 
	DWORD					dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT		hr = hrOK;
	IpxStaticRoutePropertySheet *pProperties = NULL;
	SPIComponentData spComponentData;
	CString		stTitle;
	
    CComPtr<IInterfaceInfo> spInterfaceInfo;
	BaseIPXResultNodeData *	pNodeData;

	CORg( m_spNodeMgr->GetComponentData(&spComponentData) );
	if (m_spInterfaceInfo)
		stTitle.Format(IDS_IPXSUMMARY_IF_PAGE_TITLE,
					   m_spInterfaceInfo->GetTitle());
	else
		stTitle.LoadString(IDS_IPXSUMMARY_CLIENT_IF_PAGE_TITLE);

	pProperties = new IpxStaticRoutePropertySheet(pNode, spComponentData, 
		m_spTFSCompData, stTitle);

	pNodeData = GET_BASEIPXRESULT_NODEDATA(pNode);
	Assert(pNodeData);
	ASSERT_BASEIPXRESULT_NODEDATA(pNodeData);

	CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

	spInterfaceInfo = m_spInterfaceInfo;
	CORg( pProperties->Init(pNodeData, spInterfaceInfo) );

	if (lpProvider)
		hr = pProperties->CreateModelessSheet(lpProvider, handle);
	else
		hr = pProperties->DoModelessSheet();

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxRouteHandler::OnResultDelete
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxRouteHandler::OnResultDelete(ITFSComponent *pComponent,
	LPDATAOBJECT pDataObject,
	MMC_COOKIE cookie,
	LPARAM arg,
	LPARAM param)
{
	SPITFSNode	spNode;

	m_spNodeMgr->FindNode(cookie, &spNode);
	return OnRemoveStaticRoute(spNode);
}

/*!--------------------------------------------------------------------------
	IpxRouteHandler::OnRemoveStaticRoute
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxRouteHandler::OnRemoveStaticRoute(ITFSNode *pNode)
{
	HRESULT		hr = hrOK;
	SPIInfoBase	spInfoBase;
	SPIRtrMgrInterfaceInfo	spRmIf;
	IPXConnection *pIPXConn;
	SPITFSNode	spNodeParent;
	BaseIPXResultNodeData *	pData;
	IpxSRListEntry	SREntry;
    CWaitCursor wait;

	pNode->GetParent(&spNodeParent);
	
	pIPXConn = GET_IPX_SR_NODEDATA(spNodeParent);
	Assert(pIPXConn);

	pData = GET_BASEIPXRESULT_NODEDATA(pNode);
	Assert(pData);
	ASSERT_BASEIPXRESULT_NODEDATA(pData);
    
	//
	// Load the old interface's information
	//
	Assert(lstrcmpi(m_spInterfaceInfo->GetId(), pData->m_spIf->GetId()) == 0);
	CORg( m_spInterfaceInfo->FindRtrMgrInterface(PID_IPX, &spRmIf) );

	CORg( spRmIf->GetInfoBase(pIPXConn->GetConfigHandle(),
							  NULL,
							  NULL,
							  &spInfoBase));

	SREntry.LoadFrom(pData);

	CORg( RemoveStaticRoute(&SREntry, spInfoBase) );
		
	// Update the interface information
	CORg( spRmIf->Save(m_spInterfaceInfo->GetMachineName(),
					   pIPXConn->GetConfigHandle(),
					   NULL,
					   NULL,
					   spInfoBase,
					   0));

	// Refresh the node
	ParentRefresh(pNode);

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxRouteHandler::RemoveStaticRoute
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxRouteHandler::RemoveStaticRoute(IpxSRListEntry *pSREntry,
										  IInfoBase *pInfoBase)
{
	HRESULT		hr = hrOK;
	InfoBlock *	pBlock;
	PIPX_STATIC_ROUTE_INFO	pRow;
    INT			i;
	
	// Get the IPX_STATIC_ROUTE_INFO block from the interface
	CORg( pInfoBase->GetBlock(IPX_STATIC_ROUTE_INFO_TYPE, &pBlock, 0) );
		
	// Look for the removed route in the IPX_STATIC_ROUTE_INFO
	pRow = (IPX_STATIC_ROUTE_INFO*) pBlock->pData;
	
	for (i = 0; i < (INT)pBlock->dwCount; i++, pRow++)
	{	
		// Compare this route to the removed one
		if (FAreTwoRoutesEqual(pRow, &(pSREntry->m_route)))
		{
			// This is the removed route, so modify this block
			// to exclude the route:
			
			// Decrement the number of routes
			--pBlock->dwCount;
		
			if (pBlock->dwCount && (i < (INT)pBlock->dwCount))
			{				
				// Overwrite this route with the ones which follow it
				::memmove(pRow,
						  pRow + 1,
						  (pBlock->dwCount - i) * sizeof(*pRow));
			}
			
			break;
		}
	}

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxRouteHandler::ModifyRouteInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxRouteHandler::ModifyRouteInfo(ITFSNode *pNode,
										IpxSRListEntry *pSREntryNew,
										IpxSRListEntry *pSREntryOld)
{
 	Assert(pSREntryNew);
	Assert(pSREntryOld);
	
    INT i;
	HRESULT hr = hrOK;
    InfoBlock* pBlock;
	SPIInfoBase	spInfoBase;
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPITFSNode				spNodeParent;
	IPXConnection *			pIPXConn;
	IPX_STATIC_ROUTE_INFO		*psr, *psrOld;
	IPX_STATIC_ROUTE_INFO		IpxRow;

    CWaitCursor wait;

	pNode->GetParent(&spNodeParent);
	pIPXConn = GET_IPX_SR_NODEDATA(spNodeParent);
	Assert(pIPXConn);

	// Remove the old route if it is on another interface
	if (lstrcmpi(pSREntryOld->m_spIf->GetId(), pSREntryNew->m_spIf->GetId()) != 0)
	{
        // the outgoing interface for a route is to be changed.

		CORg( pSREntryOld->m_spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) );
		CORg( spRmIf->GetInfoBase(pIPXConn->GetConfigHandle(),
								  NULL,
								  NULL,
								  &spInfoBase));
		
		// Remove the old interface
		CORg( RemoveStaticRoute(pSREntryOld, spInfoBase) );

		// Update the interface information
		CORg( spRmIf->Save(pSREntryOld->m_spIf->GetMachineName(),
						   pIPXConn->GetConfigHandle(),
						   NULL,
						   NULL,
						   spInfoBase,
						   0));	
    }

	spRmIf.Release();
	spInfoBase.Release();


	// Either
	// (a) a route is being modified (on the same interface)
	// (b) a route is being moved from one interface to another.

	// Retrieve the configuration for the interface to which the route
	// is now attached;

	
	CORg( pSREntryNew->m_spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) );
	CORg( spRmIf->GetInfoBase(pIPXConn->GetConfigHandle(),
							  NULL,
							  NULL,
							  &spInfoBase));

		
	// Get the IPX_STATIC_ROUTE_INFO block from the interface
	hr = spInfoBase->GetBlock(IPX_STATIC_ROUTE_INFO_TYPE, &pBlock, 0);
	if (!FHrOK(hr))
	{
		//
		// No IPX_STATIC_ROUTE_INFO block was found; we create a new block 
		// with the new route, and add that block to the interface-info
		//

		CORg( AddStaticRoute(pSREntryNew, spInfoBase, NULL) );
	}
	else
	{
		//
		// An IPX_STATIC_ROUTE_INFO block was found.
		//
		// We are modifying an existing route.
		// If the route's interface was not changed when it was modified,
		// look for the existing route in the IPX_STATIC_ROUTE_INFO, and then
		// update its parameters.
		// Otherwise, write a completely new route in the IPX_STATIC_ROUTE_INFO;
		//

		if (lstrcmpi(pSREntryOld->m_spIf->GetId(), pSREntryNew->m_spIf->GetId()) == 0)
		{        
			//
			// The route's interface was not changed when it was modified;
			// We now look for it amongst the existing routes
			// for this interface.
			// The route's original parameters are in 'preOld',
			// so those are the parameters with which we search
			// for a route to modify
			//
			
			psr = (IPX_STATIC_ROUTE_INFO*)pBlock->pData;
			
			for (i = 0; i < (INT)pBlock->dwCount; i++, psr++)
			{	
				// Compare this route to the re-configured one
				if (!FAreTwoRoutesEqual(&(pSREntryOld->m_route), psr))
					continue;
				
				// This is the route which was modified;
				// We can now modify the parameters for the route in-place.
				*psr = pSREntryNew->m_route;
				
				break;
			}
		}
		else
		{
			CORg( AddStaticRoute(pSREntryNew, spInfoBase, pBlock) );
		}
		
	}

	// Save the updated information
	CORg( spRmIf->Save(pSREntryNew->m_spIf->GetMachineName(),
					   pIPXConn->GetConfigHandle(),
					   NULL,
					   NULL,
					   spInfoBase,
					   0));	
		
Error:
	return hr;
	
}


/*!--------------------------------------------------------------------------
	IpxRouteHandler::ParentRefresh
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxRouteHandler::ParentRefresh(ITFSNode *pNode)
{
	return ForwardCommandToParent(pNode, IDS_MENU_SYNC,
								  CCT_RESULT, NULL, 0);
}


//----------------------------------------------------------------------------
// Class:       CStaticRouteDlg
//
//----------------------------------------------------------------------------


//----------------------------------------------------------------------------
// Function:    CStaticRouteDlg::CStaticRouteDlg
//
// Constructor: initialize the base-class and the dialog's data.
//----------------------------------------------------------------------------

CStaticRouteDlg::CStaticRouteDlg(IpxSRListEntry *	pSREntry,
								 DWORD dwFlags,
								 IRouterInfo *pRouter,
								 CWnd *pParent)
    : CBaseDialog(IDD_STATIC_ROUTE, pParent),
	m_pSREntry(pSREntry),
	m_dwFlags(dwFlags)
{

    //{{AFX_DATA_INIT(CStaticRouteDlg)
    //}}AFX_DATA_INIT

	m_spRouterInfo.Set(pRouter);

//	SetHelpMap(m_dwHelpMap);
}



//----------------------------------------------------------------------------
// Function:    CStaticRouteDlg::DoDataExchange
//----------------------------------------------------------------------------

VOID
CStaticRouteDlg::DoDataExchange(
    CDataExchange* pDX
    ) {

    CBaseDialog::DoDataExchange(pDX);
    
    //{{AFX_DATA_MAP(CStaticRouteDlg)
    DDX_Control(pDX, IDC_SRD_COMBO_INTERFACE, m_cbInterfaces);
	DDX_Control(pDX, IDC_SRD_SPIN_TICK_COUNT, m_spinTickCount);
	DDX_Control(pDX, IDC_SRD_SPIN_HOP_COUNT, m_spinHopCount);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CStaticRouteDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CStaticRouteDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


DWORD CStaticRouteDlg::m_dwHelpMap[] =
{
//	IDC_SRD_DESTINATION, HIDC_SRD_DESTINATION,
//	IDC_SRD_NETMASK, HIDC_SRD_NETMASK,
//	IDC_SRD_GATEWAY, HIDC_SRD_GATEWAY,
//	IDC_SRD_METRIC, HIDC_SRD_METRIC,
//	IDC_SRD_SPINMETRIC, HIDC_SRD_SPINMETRIC,
//	IDC_SRD_INTERFACES, HIDC_SRD_INTERFACES,
	0,0
};

//----------------------------------------------------------------------------
// Function:    CStaticRouteDlg::OnInitDialog
//
// Handles the 'WM_INITDIALOG' message for the dialog.
//----------------------------------------------------------------------------

BOOL
CStaticRouteDlg::OnInitDialog(
    )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	SPIEnumInterfaceInfo	spEnumIf;
	SPIInterfaceInfo		spIf;
	SPIRtrMgrInterfaceInfo	spRmIf;
	TCHAR					szNumber[32];

    CBaseDialog::OnInitDialog();

	// initialize the controls
	m_spinHopCount.SetRange(0, 15);
	m_spinHopCount.SetBuddy(GetDlgItem(IDC_SRD_EDIT_HOP_COUNT));
	
	m_spinTickCount.SetRange(0, UD_MAXVAL);
	m_spinTickCount.SetBuddy(GetDlgItem(IDC_SRD_EDIT_TICK_COUNT));

	((CEdit *) GetDlgItem(IDC_SRD_EDIT_NETWORK_NUMBER))->LimitText(8);
	((CEdit *) GetDlgItem(IDC_SRD_EDIT_NEXT_HOP))->LimitText(12);

	
    // Get a list of the interfaces enabled for IPX routing.
	m_spRouterInfo->EnumInterface(&spEnumIf);

	for( ; spEnumIf->Next(1, &spIf, NULL) == hrOK; spIf.Release())
	{
		spRmIf.Release();
		
		if (spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) != hrOK)
			continue;

        // Add the interface to the combobox
        INT i = m_cbInterfaces.AddString(spIf->GetTitle());

        m_cbInterfaces.SetItemData(i, (DWORD_PTR)m_ifidList.AddTail(spIf->GetId()));
	}

	if (!m_cbInterfaces.GetCount())
	{
        AfxMessageBox(IDS_ERR_NO_IPX_INTERFACES);
        EndDialog(IDCANCEL);
		return FALSE;
    }

    m_cbInterfaces.SetCurSel(0);

    //
    // If we were given a route to modify, set the dialog up
    // with the parameters in the route
    //
	if ((m_dwFlags & SR_DLG_MODIFY) == 0)
	{
        // No route was given, so leave the controls blank
    }
    else
	{
        // A route to be edited was given, so initialize the controls
		FormatIpxNetworkNumber(szNumber,
							   DimensionOf(szNumber),
							   m_pSREntry->m_route.Network,
							   sizeof(m_pSREntry->m_route.Network));
		SetDlgItemText(IDC_SRD_EDIT_NETWORK_NUMBER, szNumber);

		FormatMACAddress(szNumber,
						 DimensionOf(szNumber),
						 m_pSREntry->m_route.NextHopMacAddress,
						 sizeof(m_pSREntry->m_route.NextHopMacAddress));
		SetDlgItemText(IDC_SRD_EDIT_NEXT_HOP, szNumber);
		
        m_cbInterfaces.SelectString(-1, m_pSREntry->m_spIf->GetTitle());

		m_spinHopCount.SetPos(m_pSREntry->m_route.HopCount);
		m_spinTickCount.SetPos(m_pSREntry->m_route.TickCount);
		
		// Disable the network number, next hop, and interface
		GetDlgItem(IDC_SRD_EDIT_NETWORK_NUMBER)->EnableWindow(FALSE);
		GetDlgItem(IDC_SRD_EDIT_NEXT_HOP)->EnableWindow(FALSE);
		GetDlgItem(IDC_SRD_COMBO_INTERFACE)->EnableWindow(FALSE);
		
    }

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    CStaticRouteDlg::OnOK
//
// Handles 'BN_CLICKED' notification from the 'OK' button.
//----------------------------------------------------------------------------

VOID
CStaticRouteDlg::OnOK(
    ) {
    CString		st;
	SPIInterfaceInfo	spIf;
	CString		stIf;
	POSITION	pos;

    do
	{    
        // Get the route's outgoing interface
        INT item = m_cbInterfaces.GetCurSel();
        if (item == CB_ERR)
			break;

        pos = (POSITION)m_cbInterfaces.GetItemData(item);

        stIf = (LPCTSTR)m_ifidList.GetAt(pos);

		m_spRouterInfo->FindInterface(stIf, &spIf);

		m_pSREntry->m_spIf.Set(spIf);

		// Get the rest of the data
		GetDlgItemText(IDC_SRD_EDIT_NETWORK_NUMBER, st);
		ConvertNetworkNumberToBytes(st,
									m_pSREntry->m_route.Network,
									sizeof(m_pSREntry->m_route.Network));

		GetDlgItemText(IDC_SRD_EDIT_NEXT_HOP, st);
		ConvertMACAddressToBytes(st,
								 m_pSREntry->m_route.NextHopMacAddress,
								 sizeof(m_pSREntry->m_route.NextHopMacAddress));

		m_pSREntry->m_route.TickCount = (USHORT) m_spinTickCount.GetPos();
		m_pSREntry->m_route.HopCount = (USHORT) m_spinHopCount.GetPos();

        CBaseDialog::OnOK();
                
    } while(FALSE);

}


/*!--------------------------------------------------------------------------
	IpxSRListEntry::LoadFrom
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxSRListEntry::LoadFrom(BaseIPXResultNodeData *pNodeData)
{
	m_spIf.Set(pNodeData->m_spIf);

	ConvertNetworkNumberToBytes(pNodeData->m_rgData[IPX_SR_SI_NETWORK].m_stData,
								m_route.Network,
								DimensionOf(m_route.Network));

	// This is not the correct byte order to do comparisons, but it
	// can be used for equality
	memcpy(&pNodeData->m_rgData[IPX_SR_SI_NETWORK].m_dwData,
		   m_route.Network,
		   sizeof(DWORD));
	
	m_route.TickCount = (USHORT) pNodeData->m_rgData[IPX_SR_SI_TICK_COUNT].m_dwData;
	
	m_route.HopCount = (USHORT) pNodeData->m_rgData[IPX_SR_SI_HOP_COUNT].m_dwData;

	// Need to convert the MAC address into a byte array
	ConvertMACAddressToBytes(pNodeData->m_rgData[IPX_SR_SI_NEXT_HOP].m_stData,
							 m_route.NextHopMacAddress,
							 DimensionOf(m_route.NextHopMacAddress));

}

/*!--------------------------------------------------------------------------
	IpxSRListEntry::SaveTo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxSRListEntry::SaveTo(BaseIPXResultNodeData *pNodeData)
{
	TCHAR	szNumber[32];
	
	pNodeData->m_spIf.Set(m_spIf);
	
	pNodeData->m_rgData[IPX_SR_SI_NAME].m_stData = m_spIf->GetTitle();

	FormatIpxNetworkNumber(szNumber,
						   DimensionOf(szNumber),
						   m_route.Network,
						   DimensionOf(m_route.Network));
	pNodeData->m_rgData[IPX_SR_SI_NETWORK].m_stData = szNumber;
	memcpy(&(pNodeData->m_rgData[IPX_SR_SI_NETWORK].m_dwData),
		   m_route.Network,
		   sizeof(DWORD));

	FormatMACAddress(szNumber,
					 DimensionOf(szNumber),
					 m_route.NextHopMacAddress,
					 DimensionOf(m_route.NextHopMacAddress));
	pNodeData->m_rgData[IPX_SR_SI_NEXT_HOP].m_stData = szNumber;

	FormatNumber(m_route.TickCount,
				 szNumber,
				 DimensionOf(szNumber),
				 FALSE);
	pNodeData->m_rgData[IPX_SR_SI_TICK_COUNT].m_stData = szNumber;
	pNodeData->m_rgData[IPX_SR_SI_TICK_COUNT].m_dwData = m_route.TickCount;

	FormatNumber(m_route.HopCount,
				 szNumber,
				 DimensionOf(szNumber),
				 FALSE);
	pNodeData->m_rgData[IPX_SR_SI_HOP_COUNT].m_stData = szNumber;
	pNodeData->m_rgData[IPX_SR_SI_HOP_COUNT].m_dwData = m_route.HopCount;

}

/*!--------------------------------------------------------------------------
	SetRouteData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SetRouteData(BaseIPXResultNodeData *pData,
					 IpxSRListEntry *pRoute)
{

	pRoute->SaveTo(pData);
	return hrOK;
}

/*!--------------------------------------------------------------------------
	AddStaticRoute
		This function ASSUMES that the route is NOT in the block.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AddStaticRoute(IpxSRListEntry *pSREntryNew,
									   IInfoBase *pInfoBase,
									   InfoBlock *pBlock)
{
	IPX_STATIC_ROUTE_INFO	srRow;
	HRESULT				hr = hrOK;
	
	if (pBlock == NULL)
	{
		//
		// No IPX_STATIC_ROUTE_INFO block was found; we create a new block 
		// with the new route, and add that block to the interface-info
		//
		
		CORg( pInfoBase->AddBlock(IPX_STATIC_ROUTE_INFO_TYPE,
								  sizeof(IPX_STATIC_ROUTE_INFO),
								  (LPBYTE) &(pSREntryNew->m_route), 1, 0) );
	}
	else
	{
		// Either the route is completely new, or it is a route
		// which was moved from one interface to another.
		// Set a new block as the IPX_STATIC_ROUTE_INFO,
		// and include the re-configured route in the new block.
		PIPX_STATIC_ROUTE_INFO	psrTable;
			
		psrTable = new IPX_STATIC_ROUTE_INFO[pBlock->dwCount + 1];
		Assert(psrTable);
		
		// Copy the original table of routes
		::memcpy(psrTable, pBlock->pData,
				 pBlock->dwCount * sizeof(IPX_STATIC_ROUTE_INFO));
		
		// Append the new route
		psrTable[pBlock->dwCount] = pSREntryNew->m_route;
		
		// Replace the old route-table with the new one
		CORg( pInfoBase->SetData(IPX_STATIC_ROUTE_INFO_TYPE,
								 sizeof(IPX_STATIC_ROUTE_INFO),
								 (LPBYTE) psrTable, pBlock->dwCount + 1, 0) );
	}
	
Error:
	return hr;
}


BOOL FAreTwoRoutesEqual(IPX_STATIC_ROUTE_INFO *pRoute1,
						IPX_STATIC_ROUTE_INFO *pRoute2)
{
	return (memcmp(pRoute1->Network, pRoute2->Network,
				   sizeof(pRoute1->Network)) == 0) &&
			(memcmp(pRoute1->NextHopMacAddress, pRoute2->NextHopMacAddress,
					sizeof(pRoute1->NextHopMacAddress)) == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\stdafx.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
    stdafx.cpp
		include file for standard system include files,
		or project specific include files that are used frequently,
		but are changed infrequently

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\strings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       strings.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#include "strings.h"
#define _IPXSNAP_STRINGS_DEFINE_STRINGS
#include "strings.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\stdafx.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    stdafx.h
		include file for standard system include files,
		or project specific include files that are used frequently,
		but are changed infrequently

    FILE HISTORY:
        
*/

#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxdlgs.h>
#include <afxtempl.h>

#include <atlbase.h>

//
// You may derive a class from CComModule and use it if you want to override
// something, but do not change the name of _Module
//
extern CComModule _Module;
#include <atlcom.h>

#include <mmc.h>

extern LPCWSTR g_lpszNullString;

#include "ipxguid.h"		// GUIDs/CLSIDs/etc...

//
// New Clipboard format that has the Type and Cookie 
//
extern const wchar_t*   SNAPIN_INTERNAL;

//
// NOTE: Right now all header files are included from here.  It might be a good
// idea to move the snapin specific header files out of the precompiled header.
//
#include "resource.h"
#include "..\common\snapbase.h"

#include "dbgutil.h"
#include "errutil.h"
#include "std.h"

#include <lm.h>

#include "tfsint.h"

#include "mprapi.h"
#include "router.h"		// router.idl - IRouterInfo objects
#include "images.h"
#include "tfschar.h"
#include "strings.h"	// const strings used
#include "rtrguid.h"	// Router guids
#include "info.h"		// smart pointers and such for router info interfaces
#include "infobase.h"

#include "rtinfo.h"


#include "htmlhelp.h"	// HTML help APIs

#include "rtrres.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\strings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       strings.h
//
//--------------------------------------------------------------------------


#undef IPXSNAP_CONST_STRING
#undef IPXSNAP_CONST_STRINGA
#undef IPXSNAP_CONST_STRINGW

#ifdef _IPXSNAP_STRINGS_DEFINE_STRINGS

	#define IPXSNAP_CONST_STRING(rg,s)	const TCHAR rg[] = TEXT(s);
	#define IPXSNAP_CONST_STRINGA(rg,s) const char rg[] = s;
	#define IPXSNAP_CONST_STRINGW(rg,s)	const WCHAR rg[] = s;

#else

	#define IPXSNAP_CONST_STRING(rg,s)	extern const TCHAR rg[];
	#define IPXSNAP_CONST_STRINGA(rg,s) extern const char rg[];
	#define IPXSNAP_CONST_STRINGW(rg,s)	extern const WCHAR rg[];

#endif


IPXSNAP_CONST_STRING(c_szRouter,			"Router")


IPXSNAP_CONST_STRINGA(c_sazIPXSnapHelpFile, "mprsnap.chm")
IPXSNAP_CONST_STRING(c_szIPXSnapHelpFile, "mprsnap.chm")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ssview.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    ssview.h
//
// History:
//	09/05/97	Kenn M. Takara			Created.
//
//	IPX Static Routes view
//
//============================================================================


#ifndef _SSVIEW_H
#define _SSVIEW_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _XSTREAM_H
#include "xstream.h"		// need for ColumnData
#endif

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _IPXFACE_H
#include "ipxface.h"
#endif

#ifndef _BASECON_H
#include "basecon.h"		// BaseContainerHandler
#endif

#ifndef _IPXSTRM_H
#include "ipxstrm.h"
#endif

#ifndef _RTRSHEET_H
#include "rtrsheet.h"
#endif

#ifndef _IPXCONN_H
#include "ipxconn.h"			// IPXConnection
#endif

#include "ipxstats.h"		// IPX statistics dialogs

// forward declarations
class	IPXAdminConfigStream;
struct	SIpxSSNodeMenu;

/*---------------------------------------------------------------------------
	This is the list of columns available for the IPX Static Routes
	node.
		- Name, "[1] DEC DE500 ..."
		- Service Type, 1231
		- Service Name, "foobar"
		- Service Address, "111.111.11"
		- Hop Count
 ---------------------------------------------------------------------------*/


//
// If you ADD any columns to this enum, Be sure to update
// the string ids for the column headers in ssview.cpp
//
enum
{
	IPX_SS_SI_NAME = 0,
	IPX_SS_SI_SERVICE_TYPE,
	IPX_SS_SI_SERVICE_NAME,
	IPX_SS_SI_SERVICE_ADDRESS,
	IPX_SS_SI_HOP_COUNT,
	IPX_SS_MAX_COLUMNS,
};


/*---------------------------------------------------------------------------
	We store a pointer to the IPConnection object in our node data
 ---------------------------------------------------------------------------*/

#define GET_IPX_SS_NODEDATA(pNode) \
		(IPXConnection *) pNode->GetData(TFS_DATA_USER)
#define SET_IPX_SS_NODEDATA(pNode, pData) \
		pNode->SetData(TFS_DATA_USER, (LONG_PTR) pData)



/*---------------------------------------------------------------------------
	Struct:	IpxSSListEntry

	This is an intermediate data structure.  Our data-gathering routines
	will generate a list of these data items.  We will then use this list
	to populate result pane.  This will (eventually) be generated by the
	Refresh mechanism.  This separation of data gathering and UI code will
	allow us to easily move the data gathering to a background thread.
 ---------------------------------------------------------------------------*/
struct IpxSSListEntry
{
	SPIInterfaceInfo	m_spIf;
	IPX_STATIC_SERVICE_INFO	m_service;
	
	void	LoadFrom(BaseIPXResultNodeData *pNodeData);
	void	SaveTo(BaseIPXResultNodeData *pNodeData);
};

typedef CList<IpxSSListEntry *, IpxSSListEntry *> IpxSSList;


/*---------------------------------------------------------------------------
	Class:	IpxSSHandler
 ---------------------------------------------------------------------------*/


class IpxSSHandler :
		public BaseContainerHandler
{
public:
	IpxSSHandler(ITFSComponentData *pTFSCompData);
	~IpxSSHandler();

	// Override QI to handle embedded interface
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);
	
	DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)

	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_GetString();
	OVERRIDE_NodeHandler_OnCreateDataObject();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_DestroyHandler();

	OVERRIDE_BaseHandlerNotify_OnExpand();

	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_CompareItems();

	OVERRIDE_BaseResultHandlerNotify_OnResultShow();	

    OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();
	
	// Initializes the handler
	HRESULT	Init(IRtrMgrInfo *pRtrMgrInfo, IPXAdminConfigStream *pConfigStream);
	
	// Initializes the node
	HRESULT ConstructNode(ITFSNode *pNode, LPCTSTR szName,
						  IPXConnection *pIPXConn);

public:
	// Structure used to pass data to callbacks - used as a way of
	// avoiding recomputation
	struct SMenuData
	{
		SPITFSNode			m_spNode;
	};
	// Function callbacks for menu enabling/disabling

protected:
	// Refresh the data for these nodes
	HRESULT	SynchronizeNodeData(ITFSNode *pThisNode);
	HRESULT	MarkAllNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum);
	HRESULT	RemoveAllUnmarkedNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum);
	HRESULT	GenerateListOfServices(ITFSNode *pNode, IpxSSList *pSSList);


	// Helper function to add interfaces to the UI
	HRESULT AddStaticServiceNode(ITFSNode *pParent, IpxSSListEntry *pRoute);

	// Command implementations
	HRESULT	OnNewService(ITFSNode *pNode);
	
	LONG_PTR		m_ulConnId;		// notification id for router info
	LONG_PTR		m_ulRefreshConnId; // notification id for router refresh
	MMC_COOKIE		m_cookie;		// cookie for the node
	SPIRtrMgrInfo	m_spRtrMgrInfo;
	IPXAdminConfigStream *	m_pConfigStream;
	CString			m_stTitle;

};


/*---------------------------------------------------------------------------
	Class:	IpxServiceHandler

	This is the handler for the interface nodes that appear in the IPStaticServices
	node.
 ---------------------------------------------------------------------------*/

class IpxServiceHandler : public BaseIPXResultHandler
{
public:
	IpxServiceHandler(ITFSComponentData *pCompData);
	
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnCreateDataObject();
	
	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_OnCreateDataObject();
	OVERRIDE_ResultHandler_DestroyResultHandler();
	OVERRIDE_ResultHandler_HasPropertyPages();
	OVERRIDE_ResultHandler_CreatePropertyPages();
	
	OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
	
	// Initializes the node
	HRESULT ConstructNode(ITFSNode *pNode, IInterfaceInfo *pIfInfo,
						 IPXConnection *pIPXConn);
	HRESULT	Init(IInterfaceInfo *pInfo, ITFSNode *pParent);

	// Refreshes all routes
	HRESULT	ParentRefresh(ITFSNode *pNode);

	// Removes the static route
	HRESULT OnRemoveStaticService(ITFSNode *pNode);

	// Route modification apis
	HRESULT RemoveStaticService(IpxSSListEntry *pSSEntry, IInfoBase *pInfo);
	HRESULT	ModifyRouteInfo(ITFSNode *pNode,
							IpxSSListEntry *pSSEntry,
							IpxSSListEntry *pSSEntryOld);
	
public:
	// Structure used to pass data to callbacks - used as a way of
	// avoiding recomputation
	struct SMenuData
	{
		ULONG				m_ulMenuId;
		SPITFSNode			m_spNode;
	};
	ULONG	GetSeparatorFlags(SMenuData *pData);
	
protected:
	LONG_PTR			m_ulConnId;
	SPIInterfaceInfo	m_spInterfaceInfo;
};


//----------------------------------------------------------------------------
// Class:       CStaticServiceDlg
//
// Controls the 'Add/Edit Static Route' dialog.
//----------------------------------------------------------------------------

// Set if we are modifying an exising entry (the only change this does
// is that we will fill in the controls with the data in the structure).
#define SR_DLG_MODIFY		0x00000001

class CStaticServiceDlg : public CBaseDialog
{    
public:

	CStaticServiceDlg(IpxSSListEntry *	pSSEntry,
					DWORD					dwFlags,
					IRouterInfo *			pRouter,
					CWnd*					pParent = NULL );
    
	//{{AFX_DATA(CStaticServiceDlg)
	CComboBox           m_cbInterfaces;
	CSpinButtonCtrl		m_spinHopCount;
	//}}AFX_DATA
	
	
	//{{AFX_VIRTUAL(CStaticServiceDlg)
protected:
	virtual void        DoDataExchange(CDataExchange* pDX);
	//}}AFX_VIRTUAL
	
protected:
	static DWORD		m_dwHelpMap[];

	CStringList         m_ifidList;

	DWORD				m_dwFlags;
	SPIRouterInfo		m_spRouterInfo;
	IpxSSListEntry *m_pSSEntry;
	
	//{{AFX_MSG(CStaticServiceDlg)
	virtual void        OnOK();
	virtual BOOL        OnInitDialog();
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};

HRESULT SetServiceData(BaseIPXResultNodeData *pData,
					 IpxSSListEntry *pService);
HRESULT AddStaticService(IpxSSListEntry *pSSEntry,
					   IInfoBase *InfoBase,
					   InfoBlock *pBlock);
BOOL FAreTwoServicesEqual(IPX_STATIC_SERVICE_INFO *pService1,
						IPX_STATIC_SERVICE_INFO *pService2);


#endif _SSVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\ssview.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ssview.cpp
		IPX Static Services node implementation.
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "util.h"
#include "ssview.h"
#include "reg.h"
#include "ipxadmin.h"
#include "rtrutil.h"	// smart MPR handle pointers
#include "ipxstrm.h"		// IPXAdminConfigStream
#include "strmap.h"		// XXXtoCString functions
#include "service.h"	// TFS service APIs
#include "format.h"		// FormatNumber function
#include "coldlg.h"		// columndlg
#include "ipxutil.h"
#include "column.h"		// ComponentConfigStream
#include "rtrui.h"
#include "routprot.h"	// IP_LOCAL
#include "rtrres.h"
#include "dumbprop.h"
#include "ipxstaticsvc.h"

/*---------------------------------------------------------------------------
	Keep this in sync with the column ids in ssview.h
 ---------------------------------------------------------------------------*/
extern const ContainerColumnInfo	s_rgSSViewColumnInfo[];

const ContainerColumnInfo	s_rgSSViewColumnInfo[] = 
{
	{ IDS_IPX_SS_COL_NAME,			CON_SORT_BY_STRING,	TRUE, COL_IF_NAME },
	{ IDS_IPX_SS_COL_SERVICE_TYPE,	CON_SORT_BY_STRING, TRUE, COL_STRING },
	{ IDS_IPX_SS_COL_SERVICE_NAME,	CON_SORT_BY_STRING,	TRUE, COL_STRING },
	{ IDS_IPX_SS_COL_SERVICE_ADDRESS,CON_SORT_BY_STRING,	TRUE, COL_STRING },
	{ IDS_IPX_SS_COL_HOP_COUNT,		CON_SORT_BY_DWORD,	TRUE, COL_SMALL_NUM},
};


/*---------------------------------------------------------------------------
	IpxSSHandler implementation
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(IpxSSHandler)


IpxSSHandler::IpxSSHandler(ITFSComponentData *pCompData)
	: BaseContainerHandler(pCompData, COLUMNS_STATICSERVICES,
						   s_rgSSViewColumnInfo),
	m_ulConnId(0),
	m_ulRefreshConnId(0)
{
	// Setup the verb states
	m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
	m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;

	DEBUG_INCREMENT_INSTANCE_COUNTER(IpxSSHandler)
}

IpxSSHandler::~IpxSSHandler()
{
	DEBUG_DECREMENT_INSTANCE_COUNTER(IpxSSHandler)
}


STDMETHODIMP IpxSSHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IRtrAdviseSink)
		*ppv = &m_IRtrAdviseSink;
	else
		return BaseContainerHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;	
}



/*!--------------------------------------------------------------------------
	IpxSSHandler::DestroyHandler
		Implementation of ITFSNodeHandler::DestroyHandler
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxSSHandler::DestroyHandler(ITFSNode *pNode)
{
	IPXConnection *	pIPXConn;

	pIPXConn = GET_IPX_SS_NODEDATA(pNode);
	pIPXConn->Release();

	if (m_ulRefreshConnId)
	{
		SPIRouterRefresh	spRefresh;
		if (m_spRouterInfo)
			m_spRouterInfo->GetRefreshObject(&spRefresh);
		if (spRefresh)
			spRefresh->UnadviseRefresh(m_ulRefreshConnId);
	}
	m_ulRefreshConnId = 0;
	
	if (m_ulConnId)
		m_spRtrMgrInfo->RtrUnadvise(m_ulConnId);
	m_ulConnId = 0;
	m_spRtrMgrInfo.Release();

	m_spRouterInfo.Release();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IpxSSHandler::HasPropertyPages
		Implementation of ITFSNodeHandler::HasPropertyPages
	NOTE: the root node handler has to over-ride this function to 
	handle the snapin manager property page (wizard) case!!!
	
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
IpxSSHandler::HasPropertyPages
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	return hrFalse;
}


/*---------------------------------------------------------------------------
	Menu data structure for our menus
 ---------------------------------------------------------------------------*/

static const SRouterNodeMenu	s_rgIfNodeMenu[] =
{
	{ IDS_MENU_IPX_SS_NEW_SERVICE, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },

	{ IDS_MENU_SEPARATOR, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },

	{ IDS_MENU_IPX_SS_TASK_SERVICE, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },
};



/*!--------------------------------------------------------------------------
	IpxSSHandler::OnAddMenuItems
		Implementation of ITFSNodeHandler::OnAddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxSSHandler::OnAddMenuItems(
	ITFSNode *pNode,
	LPCONTEXTMENUCALLBACK pContextMenuCallback, 
	LPDATAOBJECT lpDataObject, 
	DATA_OBJECT_TYPES type, 
	DWORD dwType,
	long *pInsertionAllowed)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = S_OK;
    IpxSSHandler::SMenuData menuData;
	
	COM_PROTECT_TRY
	{
        menuData.m_spNode.Set(pNode);

		hr = AddArrayOfMenuItems(pNode, s_rgIfNodeMenu,
								 DimensionOf(s_rgIfNodeMenu),
								 pContextMenuCallback,
								 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
	}
	COM_PROTECT_CATCH;
		
	return hr; 
}


HRESULT IpxSSHandler::OnResultRefresh(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT  hr = hrOK;
    SPITFSNode spNode, spParent;
    SPITFSResultHandler spParentRH;

    m_spNodeMgr->FindNode(cookie, &spNode);

    // forward this command to the parent to handle
    CORg (spNode->GetParent(&spParent));
    CORg (spParent->GetResultHandler(&spParentRH));

    CORg (spParentRH->Notify(pComponent, spParent->GetData(TFS_DATA_COOKIE), pDataObject, MMCN_REFRESH, arg, lParam));

Error:
    return hrOK;

}



/*!--------------------------------------------------------------------------
	IpxSSHandler::OnCommand
		Implementation of ITFSNodeHandler::OnCommand
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxSSHandler::OnCommand(ITFSNode *pNode, long nCommandId, 
										   DATA_OBJECT_TYPES	type, 
										   LPDATAOBJECT pDataObject, 
										   DWORD	dwType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;

	COM_PROTECT_TRY
	{
		switch (nCommandId)
		{
			case IDS_MENU_IPX_SS_NEW_SERVICE:
				hr = OnNewService(pNode);
				if (!FHrSucceeded(hr))
					DisplayErrorMessage(NULL, hr);
 				break;
			case IDS_MENU_IPX_SS_TASK_SERVICE:
				hr = ForwardCommandToParent(pNode,
											IDS_MENU_IPXSUM_TASK_SERVICE_TABLE,
											type, pDataObject, dwType);
				break;
			case IDS_MENU_SYNC:
				SynchronizeNodeData(pNode);
				break;
		}
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	IpxSSHandler::GenerateListOfServices
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSSHandler::GenerateListOfServices(ITFSNode *pNode, IpxSSList *pSSList)
{
	Assert(pSSList);
	HRESULT	hr = hrOK;
	SPIEnumInterfaceInfo	spEnumIf;
	SPIInterfaceInfo		spIf;
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPIInfoBase				spInfoBase;
	PIPX_STATIC_SERVICE_INFO	pService;
	InfoBlock *				pBlock;
	int						i;
	IpxSSListEntry *	pSSEntry;
	
	COM_PROTECT_TRY
	{
		// Ok go through and find all of the static Services

		CORg( m_spRouterInfo->EnumInterface(&spEnumIf) );

		for (; spEnumIf->Next(1, &spIf, NULL) == hrOK; spIf.Release())
		{
			// Get the next interface
			spRmIf.Release();
			if (spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) != hrOK)
				continue;

			// Load IP information for this interface
			spInfoBase.Release();
			if (spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase) != hrOK)
				continue;

			// Retrieve the data for the IPX_STATIC_SERVICE_INFO block
			if (spInfoBase->GetBlock(IPX_STATIC_SERVICE_INFO_TYPE, &pBlock, 0) != hrOK)
				continue;

			pService = (PIPX_STATIC_SERVICE_INFO) pBlock->pData;

			// Update our list of Services with the Services read from this
			// interface

			for (i=0; i<(int) pBlock->dwCount; i++, pService++)
			{
				pSSEntry = new IpxSSListEntry;
				pSSEntry->m_spIf.Set(spIf);
				pSSEntry->m_service = *pService;
				
				pSSList->AddTail(pSSEntry);
			}
			
		}

	}
	COM_PROTECT_CATCH;

	if (!FHrSucceeded(hr))
	{
		// Should make sure that we get the SSList cleaned up
		while (!pSSList->IsEmpty())
			delete pSSList->RemoveHead();
	}

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxSSHandler::OnExpand
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSSHandler::OnExpand(ITFSNode *pNode,
							   LPDATAOBJECT pDataObject,
							   DWORD dwType,
							   LPARAM arg,
							   LPARAM lParam)
{
	HRESULT	hr = hrOK;
	IpxSSList			SSList;
	IpxSSListEntry *	pSSEntry;
	
	if (m_bExpanded)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Ok go through and find all of the static Services
		CORg( GenerateListOfServices(pNode, &SSList) );

		// Now iterate through the list of static Services adding them
		// all in.  Ideally we could merge this into the Refresh code,
		// but the refresh code can't assume a blank slate.
		while (!SSList.IsEmpty())
		{
			pSSEntry = SSList.RemoveHead();
			AddStaticServiceNode(pNode, pSSEntry);
			delete pSSEntry;
		}

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	// Should make sure that we get the SSList cleaned up
	while (!SSList.IsEmpty())
		delete SSList.RemoveHead();


	m_bExpanded = TRUE;

	return hr;
}

/*!--------------------------------------------------------------------------
	IpxSSHandler::GetString
		Implementation of ITFSNodeHandler::GetString
		We don't need to do anything, since our root node is an extension
		only and thus can't do anything to the node text.
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) IpxSSHandler::GetString(ITFSNode *pNode, int nCol)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		if (m_stTitle.IsEmpty())
			m_stTitle.LoadString(IDS_IPX_SS_TITLE);
	}
	COM_PROTECT_CATCH;

	return m_stTitle;
}

/*!--------------------------------------------------------------------------
	IpxSSHandler::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxSSHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{

		Assert(m_spRtrMgrInfo);
		
		CORg( CreateDataObjectFromRtrMgrInfo(m_spRtrMgrInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxSSHandler::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSSHandler::Init(IRtrMgrInfo *pRmInfo, IPXAdminConfigStream *pConfigStream)
{
	m_spRtrMgrInfo.Set(pRmInfo);
	if (pRmInfo)
		pRmInfo->GetParentRouterInfo(&m_spRouterInfo);
	m_pConfigStream = pConfigStream;
	
	// Also need to register for change notifications
	Assert(m_ulConnId == 0);
	m_spRtrMgrInfo->RtrAdvise(&m_IRtrAdviseSink, &m_ulConnId, 0);

	return hrOK;
}


/*!--------------------------------------------------------------------------
	IpxSSHandler::ConstructNode
		Initializes the root node (sets it up).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSSHandler::ConstructNode(ITFSNode *pNode, LPCTSTR pszName,
										IPXConnection *pIPXConn)
{
	Assert(pIPXConn);
	HRESULT			hr = hrOK;
	
	if (pNode == NULL)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Need to initialize the data for the root node
		pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_IPX_NODE_GENERAL);
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_IPX_NODE_GENERAL);
		pNode->SetData(TFS_DATA_SCOPEID, 0);

        // This is a leaf node in the scope pane
        pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

		m_cookie = reinterpret_cast<DWORD_PTR>(pNode);
		pNode->SetData(TFS_DATA_COOKIE, m_cookie);

		pNode->SetNodeType(&GUID_IPXStaticServicesNodeType);

		// Setup the node data
		pIPXConn->AddRef();
		SET_IPX_SS_NODEDATA(pNode, pIPXConn);

	}
	COM_PROTECT_CATCH;

	if (!FHrSucceeded(hr))
	{
		SET_IPX_SS_NODEDATA(pNode, NULL);
	}

	return hr;
}

/*!--------------------------------------------------------------------------
	IpxSSHandler::AddStaticServiceNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSSHandler::AddStaticServiceNode(ITFSNode *pParent, IpxSSListEntry *pService)
{
	IpxServiceHandler *	pHandler;
	SPITFSResultHandler		spHandler;
	SPITFSNode				spNode;
	HRESULT					hr = hrOK;
	BaseIPXResultNodeData *	pData;
	IPXConnection *			pIPXConn;

	// Create the handler for this node 
	pHandler = new IpxServiceHandler(m_spTFSCompData);
	spHandler = pHandler;
	CORg( pHandler->Init(pService->m_spIf, pParent) );

	pIPXConn = GET_IPX_SS_NODEDATA(pParent);

	// Create a result item node (or a leaf node)
	CORg( CreateLeafTFSNode(&spNode,
							NULL,
							static_cast<ITFSNodeHandler *>(pHandler),
							static_cast<ITFSResultHandler *>(pHandler),
							m_spNodeMgr) );
	CORg( pHandler->ConstructNode(spNode, pService->m_spIf, pIPXConn) );

	pData = GET_BASEIPXRESULT_NODEDATA(spNode);
	Assert(pData);
	ASSERT_BASEIPXRESULT_NODEDATA(pData);

	// Set the data for this node
	SetServiceData(pData, pService);
	

	// Make the node immediately visible
	CORg( spNode->SetVisibilityState(TFS_VIS_SHOW) );
	CORg( pParent->AddChild(spNode) );

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxSSHandler::SynchronizeNodeData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSSHandler::SynchronizeNodeData(ITFSNode *pNode)
{
	HRESULT					hr = hrOK;
	BaseIPXResultNodeData *	pNodeData;
	SPITFSNodeEnum			spNodeEnum;
	SPITFSNode				spChildNode;
	BOOL					fFound;
	IpxSSList			SSList;
	IpxSSList			newSSList;
	IpxSSListEntry *	pSSEntry;
	USES_CONVERSION;

	COM_PROTECT_TRY
	{
	
		// Mark all of the nodes
		CORg( pNode->GetEnum(&spNodeEnum) );
		MarkAllNodes(pNode, spNodeEnum);
		
		// Go out and grab the data, merge the new data in with the old data
		// This is the data-gathering code and this is what should go
		// on the background thread for the refresh code.
		CORg( GenerateListOfServices(pNode, &SSList) );

		while (!SSList.IsEmpty())
		{
			pSSEntry = SSList.RemoveHead();
			
			// Look for this entry in our current list of nodes
			spNodeEnum->Reset();
			spChildNode.Release();

			fFound = FALSE;
			
			for (;spNodeEnum->Next(1, &spChildNode, NULL) == hrOK; spChildNode.Release())
			{
				TCHAR	szNumber[32];
				
				pNodeData = GET_BASEIPXRESULT_NODEDATA(spChildNode);
				Assert(pNodeData);
				ASSERT_BASEIPXRESULT_NODEDATA(pNodeData);


				if ((pNodeData->m_rgData[IPX_SS_SI_SERVICE_TYPE].m_dwData ==
						 pSSEntry->m_service.Type) &&
					(StriCmp(pNodeData->m_rgData[IPX_SS_SI_SERVICE_NAME].m_stData,
							 A2CT((LPSTR) pSSEntry->m_service.Name)) == 0) &&
					(StriCmp(pNodeData->m_spIf->GetId(), pSSEntry->m_spIf->GetId()) == 0))
				{
					// Ok, this route already exists, update the metric
					// and mark it
					Assert(pNodeData->m_dwMark == FALSE);
					pNodeData->m_dwMark = TRUE;
					
					fFound = TRUE;
					
					SetServiceData(pNodeData, pSSEntry);
					
					// Force MMC to redraw the node
					spChildNode->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);
					break;
				}

			}
			
			if (fFound)
				delete pSSEntry;
			else
				newSSList.AddTail(pSSEntry);
		}
		
		// Now remove all nodes that were not marked
		RemoveAllUnmarkedNodes(pNode, spNodeEnum);
		
		
		// Now iterate through the list of static Services adding them
		// all in.  Ideally we could merge this into the Refresh code,
		// but the refresh code can't assume a blank slate.
		POSITION	pos;
		
		while (!newSSList.IsEmpty())
		{
			pSSEntry = newSSList.RemoveHead();
			AddStaticServiceNode(pNode, pSSEntry);
			delete pSSEntry;
		}

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	
	while (!SSList.IsEmpty())
		delete SSList.RemoveHead();
	
	while (!newSSList.IsEmpty())
		delete newSSList.RemoveHead();
	
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxSSHandler::MarkAllNodes
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSSHandler::MarkAllNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum)
{
	SPITFSNode	spChildNode;
	BaseIPXResultNodeData *	pNodeData;
	
	pEnum->Reset();
	for ( ;pEnum->Next(1, &spChildNode, NULL) == hrOK; spChildNode.Release())
	{
		pNodeData = GET_BASEIPXRESULT_NODEDATA(spChildNode);
		Assert(pNodeData);
		ASSERT_BASEIPXRESULT_NODEDATA(pNodeData);
		
		pNodeData->m_dwMark = FALSE;			
	}
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IpxSSHandler::RemoveAllUnmarkedNodes
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSSHandler::RemoveAllUnmarkedNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum)
{
	HRESULT		hr = hrOK;
	SPITFSNode	spChildNode;
	BaseIPXResultNodeData *	pNodeData;
	
	pEnum->Reset();
	for ( ;pEnum->Next(1, &spChildNode, NULL) == hrOK; spChildNode.Release())
	{
		pNodeData = GET_BASEIPXRESULT_NODEDATA(spChildNode);
		Assert(pNodeData);
		ASSERT_BASEIPXRESULT_NODEDATA(pNodeData);
		
		if (pNodeData->m_dwMark == FALSE)
		{
			pNode->RemoveChild(spChildNode);
			spChildNode->Destroy();
		}
	}

	return hr;
}


/*---------------------------------------------------------------------------
	This is the set of menus that will appear when a right-click is
	done on the blank area of the result pane.
 ---------------------------------------------------------------------------*/
static const SRouterNodeMenu	s_rgIfResultNodeMenu[] =
{
	{ IDS_MENU_IPX_SS_NEW_SERVICE, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },

	{ IDS_MENU_SEPARATOR, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },

	{ IDS_MENU_IPX_SS_TASK_SERVICE, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },			
};




/*!--------------------------------------------------------------------------
	IpxSSHandler::AddMenuItems
		Implementation of ITFSResultHandler::AddMenuItems
		Use this to add commands to the context menu of the blank areas
		of the result pane.
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxSSHandler::AddMenuItems(ITFSComponent *pComponent,
											  MMC_COOKIE cookie,
											  LPDATAOBJECT pDataObject,
											  LPCONTEXTMENUCALLBACK pCallback,
											  long *pInsertionAllowed)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT	hr = hrOK;
	SPITFSNode	spNode;
    IpxSSHandler::SMenuData menuData;

	COM_PROTECT_TRY
	{
		m_spNodeMgr->FindNode(cookie, &spNode);
        menuData.m_spNode.Set(spNode);
        
		hr = AddArrayOfMenuItems(spNode,
								 s_rgIfResultNodeMenu,
								 DimensionOf(s_rgIfResultNodeMenu),
								 pCallback,
								 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
	}
	COM_PROTECT_CATCH;

	return hr;
}


/*!--------------------------------------------------------------------------
	IpxSSHandler::Command
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxSSHandler::Command(ITFSComponent *pComponent,
									   MMC_COOKIE cookie,
									   int nCommandID,
									   LPDATAOBJECT pDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	SPITFSNode	spNode;
	HRESULT		hr = hrOK;

	switch (nCommandID)
	{
		case IDS_MENU_IPX_SS_NEW_SERVICE:
			{
				m_spNodeMgr->FindNode(cookie, &spNode);
				hr = OnNewService(spNode);
				if (!FHrSucceeded(hr))
					DisplayErrorMessage(NULL, hr);
			}
			break;
		case IDS_MENU_IPX_SS_TASK_SERVICE:
			{
				m_spNodeMgr->FindNode(cookie, &spNode);
				hr = ForwardCommandToParent(spNode,
											IDS_MENU_IPXSUM_TASK_SERVICE_TABLE,
											CCT_RESULT, NULL, 0
										   );
			}
			break;
	}
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxSSHandler::CompareItems
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int) IpxSSHandler::CompareItems(
								ITFSComponent * pComponent,
								MMC_COOKIE cookieA,
								MMC_COOKIE cookieB,
								int nCol)
{
	// Get the strings from the nodes and use that as a basis for
	// comparison.
	SPITFSNode	spNode;
	SPITFSResultHandler	spResult;

	m_spNodeMgr->FindNode(cookieA, &spNode);
	spNode->GetResultHandler(&spResult);
	return spResult->CompareItems(pComponent, cookieA, cookieB, nCol);
}


/*!--------------------------------------------------------------------------
	IpxSSHandler::OnNewService
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT	IpxSSHandler::OnNewService(ITFSNode *pNode)
{
	HRESULT	hr = hrOK;
	IpxSSListEntry	SREntry;
	CStaticServiceDlg			srdlg(&SREntry, 0, m_spRouterInfo);
	SPIInfoBase				spInfoBase;
	SPIRtrMgrInterfaceInfo	spRmIf;
	IPXConnection *			pIPXConn;
	InfoBlock *				pBlock;
								
	pIPXConn = GET_IPX_SS_NODEDATA(pNode);
	Assert(pIPXConn);

	::ZeroMemory(&(SREntry.m_service), sizeof(SREntry.m_service));

	if (srdlg.DoModal() == IDOK)
	{
		CORg( SREntry.m_spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) );
		CORg( spRmIf->GetInfoBase(pIPXConn->GetConfigHandle(),
								  NULL,
								  NULL,
								  &spInfoBase));
		
		// Ok, go ahead and add the route
		
		// Get the IPX_STATIC_SERVICE_INFO block from the interface
		spInfoBase->GetBlock(IPX_STATIC_SERVICE_INFO_TYPE, &pBlock, 0);
		
		CORg( AddStaticService(&SREntry, spInfoBase, pBlock) );

		// Update the interface information
		CORg( spRmIf->Save(SREntry.m_spIf->GetMachineName(),
						   pIPXConn->GetConfigHandle(),
						   NULL,
						   NULL,
						   spInfoBase,
						   0));	

		// Refresh the node
		SynchronizeNodeData(pNode);
	}

Error:
	return hr;
}

ImplementEmbeddedUnknown(IpxSSHandler, IRtrAdviseSink)

STDMETHODIMP IpxSSHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
	DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
	InitPThis(IpxSSHandler, IRtrAdviseSink);
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		if (dwChangeType == ROUTER_REFRESH)
		{
			SPITFSNode	spNode;

			Assert(ulConn == pThis->m_ulRefreshConnId);
			
			pThis->m_spNodeMgr->FindNode(pThis->m_cookie, &spNode);
			pThis->SynchronizeNodeData(spNode);
		}
	}
	COM_PROTECT_CATCH;
	
	return hr;
}



/*!--------------------------------------------------------------------------
	IpxSSHandler::OnResultShow
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxSSHandler::OnResultShow(ITFSComponent *pTFSComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	BOOL	bSelect = (BOOL) arg;
	HRESULT	hr = hrOK;
	SPIRouterRefresh	spRefresh;
	SPITFSNode	spNode;

	BaseContainerHandler::OnResultShow(pTFSComponent, cookie, arg, lParam);

	if (bSelect)
	{
		// Call synchronize on this node
		m_spNodeMgr->FindNode(cookie, &spNode);
		if (spNode)
			SynchronizeNodeData(spNode);
	}

	// Un/Register for refresh advises
	if (m_spRouterInfo)
		m_spRouterInfo->GetRefreshObject(&spRefresh);

	if (spRefresh)
	{
		if (bSelect)
		{
			if (m_ulRefreshConnId == 0)
				spRefresh->AdviseRefresh(&m_IRtrAdviseSink, &m_ulRefreshConnId, 0);
		}
		else
		{
			if (m_ulRefreshConnId)
				spRefresh->UnadviseRefresh(m_ulRefreshConnId);
			m_ulRefreshConnId = 0;
		}
	}
	
	return hr;
}




/*---------------------------------------------------------------------------
	Class: IpxServiceHandler
 ---------------------------------------------------------------------------*/

IpxServiceHandler::IpxServiceHandler(ITFSComponentData *pCompData)
	: BaseIPXResultHandler(pCompData, COLUMNS_STATICSERVICES),
	m_ulConnId(0)
{
 	m_rgButtonState[MMC_VERB_PROPERTIES_INDEX] = ENABLED;
	m_bState[MMC_VERB_PROPERTIES_INDEX] = TRUE;
	
	m_rgButtonState[MMC_VERB_DELETE_INDEX] = ENABLED;
	m_bState[MMC_VERB_DELETE_INDEX] = TRUE;

 	m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
	m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;
	
	m_verbDefault = MMC_VERB_PROPERTIES;
}

/*!--------------------------------------------------------------------------
	IpxServiceHandler::ConstructNode
		Initializes the Domain node (sets it up).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxServiceHandler::ConstructNode(ITFSNode *pNode, IInterfaceInfo *pIfInfo, IPXConnection *pIPXConn)
{
	HRESULT			hr = hrOK;
	int				i;
	
	if (pNode == NULL)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Need to initialize the data for the Domain node

		pNode->SetData(TFS_DATA_SCOPEID, 0);

		// We don't want icons for these nodes.
		pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_IPX_NODE_GENERAL);
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_IPX_NODE_GENERAL);

		pNode->SetData(TFS_DATA_COOKIE, reinterpret_cast<DWORD_PTR>(pNode));

		//$ Review: kennt, what are the different type of interfaces
		// do we distinguish based on the same list as above? (i.e. the
		// one for image indexes).
		pNode->SetNodeType(&GUID_IPXStaticServicesResultNodeType);

		BaseIPXResultNodeData::Init(pNode, pIfInfo, pIPXConn);
	}
	COM_PROTECT_CATCH
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxServiceHandler::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxServiceHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		CORg( CreateDataObjectFromInterfaceInfo(m_spInterfaceInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxServiceHandler::OnCreateDataObject
		Implementation of ITFSResultHandler::OnCreateDataObject
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxServiceHandler::OnCreateDataObject(ITFSComponent *pComp, MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		CORg( CreateDataObjectFromInterfaceInfo(m_spInterfaceInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}



/*!--------------------------------------------------------------------------
	IpxServiceHandler::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxServiceHandler::Init(IInterfaceInfo *pIfInfo, ITFSNode *pParent)
{
	Assert(pIfInfo);

	m_spInterfaceInfo.Set(pIfInfo);

    pIfInfo->GetParentRouterInfo(&m_spRouterInfo);


	BaseIPXResultHandler::Init(pIfInfo, pParent);
	return hrOK;
}


/*!--------------------------------------------------------------------------
	IpxServiceHandler::DestroyResultHandler
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxServiceHandler::DestroyResultHandler(MMC_COOKIE cookie)
{
	m_spInterfaceInfo.Release();
	BaseIPXResultHandler::DestroyResultHandler(cookie);
	return hrOK;
}


/*!--------------------------------------------------------------------------
	IpxServiceHandler::AddMenuItems
		Implementation of ITFSResultHandler::AddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxServiceHandler::AddMenuItems(
	ITFSComponent *pComponent,
	MMC_COOKIE cookie,
	LPDATAOBJECT lpDataObject, 
	LPCONTEXTMENUCALLBACK pContextMenuCallback, 
	long *pInsertionAllowed)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IpxServiceHandler::Command
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxServiceHandler::Command(ITFSComponent *pComponent,
									   MMC_COOKIE cookie,
									   int nCommandID,
									   LPDATAOBJECT pDataObject)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IpxServiceHandler::HasPropertyPages
		- 
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxServiceHandler::HasPropertyPages 
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	return S_OK;

/*	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// Need to fill in a IpxSSListEntry
	IpxSSListEntry	SREntry;
	IpxSSListEntry	SREntryOld;
	SPIRouterInfo			spRouterInfo;
	HRESULT					hr = hrOK;

	CORg( m_spInterfaceInfo->GetParentRouterInfo(&spRouterInfo) );
	
	BaseIPXResultNodeData *	pNodeData;

	pNodeData = GET_BASEIPXRESULT_NODEDATA(pNode);
	Assert(pNodeData);
	ASSERT_BASEIPXRESULT_NODEDATA(pNodeData);

	// Fill in our SREntry
	SREntry.LoadFrom(pNodeData);
	SREntryOld.LoadFrom(pNodeData);
	
	{
		CStaticServiceDlg	srdlg(&SREntry, SR_DLG_MODIFY, spRouterInfo);
		if (srdlg.DoModal() == IDOK)
		{
			// Updates the route info for this route
			ModifyRouteInfo(pNode, &SREntry, &SREntryOld);

			// Update the data in the UI
			SetServiceData(pNodeData, &SREntry);
			m_spInterfaceInfo.Set(SREntry.m_spIf);
			
			// Force a refresh
			pNode->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);
		}
	}
Error:
	return hrOK;*/
}

STDMETHODIMP IpxServiceHandler::HasPropertyPages(ITFSComponent *pComponent,
											   MMC_COOKIE cookie,
											   LPDATAOBJECT pDataObject)
{
	SPITFSNode	spNode;

	m_spNodeMgr->FindNode(cookie, &spNode);
	return HasPropertyPages(spNode, pDataObject, CCT_RESULT, 0);
}

/*!--------------------------------------------------------------------------
	IpxServiceHandler::CreatePropertyPages
		Implementation of ResultHandler::CreatePropertyPages
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxServiceHandler::CreatePropertyPages
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPPROPERTYSHEETCALLBACK	lpProvider, 
	LPDATAOBJECT			pDataObject, 
	LONG_PTR					handle
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT	hr = hrOK;
	SPITFSNode	spNode;

	Assert( m_spNodeMgr );

	CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

	// Call the ITFSNodeHandler::CreatePropertyPages
	hr = CreatePropertyPages(spNode, lpProvider, pDataObject, handle, 0);
	
Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	IpxServiceHandler::CreatePropertyPages
		Implementation of NodeHandler::CreatePropertyPages
	Author: Deonb
 ---------------------------------------------------------------------------*/
STDMETHODIMP IpxServiceHandler::CreatePropertyPages
(
	ITFSNode *				pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject, 
	LONG_PTR				handle, 
	DWORD					dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT		hr = hrOK;
	IpxStaticServicePropertySheet *pProperties = NULL;
	SPIComponentData spComponentData;
	CString		stTitle;
	
    CComPtr<IInterfaceInfo> spInterfaceInfo;
	BaseIPXResultNodeData *	pNodeData;

	CORg( m_spNodeMgr->GetComponentData(&spComponentData) );
	if (m_spInterfaceInfo)
		stTitle.Format(IDS_IPXSUMMARY_IF_PAGE_TITLE, m_spInterfaceInfo->GetTitle());
	else
		stTitle.LoadString(IDS_IPXSUMMARY_CLIENT_IF_PAGE_TITLE);

	pProperties = new IpxStaticServicePropertySheet(pNode, spComponentData, m_spTFSCompData, stTitle);

	pNodeData = GET_BASEIPXRESULT_NODEDATA(pNode);
	Assert(pNodeData);
	ASSERT_BASEIPXRESULT_NODEDATA(pNodeData);

	CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

	spInterfaceInfo = m_spInterfaceInfo;
	CORg( pProperties->Init(pNodeData, spInterfaceInfo) );

	if (lpProvider)
		hr = pProperties->CreateModelessSheet(lpProvider, handle);
	else
		hr = pProperties->DoModelessSheet();

Error:
	return hr;
}
/*!--------------------------------------------------------------------------
	IpxServiceHandler::OnResultDelete
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxServiceHandler::OnResultDelete(ITFSComponent *pComponent,
	LPDATAOBJECT pDataObject,
	MMC_COOKIE cookie,
	LPARAM arg,
	LPARAM param)
{
	SPITFSNode	spNode;

	m_spNodeMgr->FindNode(cookie, &spNode);
	return OnRemoveStaticService(spNode);
}

/*!--------------------------------------------------------------------------
	IpxServiceHandler::OnRemoveStaticService
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxServiceHandler::OnRemoveStaticService(ITFSNode *pNode)
{
	HRESULT		hr = hrOK;
	SPIInfoBase	spInfoBase;
	SPIRtrMgrInterfaceInfo	spRmIf;
	IPXConnection *pIPXConn;
	SPITFSNode	spNodeParent;
	BaseIPXResultNodeData *	pData;
	IpxSSListEntry	SREntry;
    CWaitCursor wait;

	pNode->GetParent(&spNodeParent);
	
	pIPXConn = GET_IPX_SS_NODEDATA(spNodeParent);
	Assert(pIPXConn);

	pData = GET_BASEIPXRESULT_NODEDATA(pNode);
	Assert(pData);
	ASSERT_BASEIPXRESULT_NODEDATA(pData);
    
	//
	// Load the old interface's information
	//
	Assert(lstrcmpi(m_spInterfaceInfo->GetId(), pData->m_spIf->GetId()) == 0);
	CORg( m_spInterfaceInfo->FindRtrMgrInterface(PID_IPX, &spRmIf) );

	CORg( spRmIf->GetInfoBase(pIPXConn->GetConfigHandle(),
							  NULL,
							  NULL,
							  &spInfoBase));

	SREntry.LoadFrom(pData);

	CORg( RemoveStaticService(&SREntry, spInfoBase) );
		
	// Update the interface information
	CORg( spRmIf->Save(m_spInterfaceInfo->GetMachineName(),
					   pIPXConn->GetConfigHandle(),
					   NULL,
					   NULL,
					   spInfoBase,
					   0));

	// Refresh the node
	ParentRefresh(pNode);

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxServiceHandler::RemoveStaticService
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxServiceHandler::RemoveStaticService(IpxSSListEntry *pSSEntry,
										  IInfoBase *pInfoBase)
{
	HRESULT		hr = hrOK;
	InfoBlock *	pBlock;
	PIPX_STATIC_SERVICE_INFO	pRow;
    INT			i;
	
	// Get the IPX_STATIC_SERVICE_INFO block from the interface
	CORg( pInfoBase->GetBlock(IPX_STATIC_SERVICE_INFO_TYPE, &pBlock, 0) );
		
	// Look for the removed route in the IPX_STATIC_SERVICE_INFO
	pRow = (IPX_STATIC_SERVICE_INFO*) pBlock->pData;
	
	for (i = 0; i < (INT)pBlock->dwCount; i++, pRow++)
	{	
		// Compare this route to the removed one
		if (FAreTwoServicesEqual(pRow, &(pSSEntry->m_service)))
		{
			// This is the removed route, so modify this block
			// to exclude the route:
			
			// Decrement the number of Services
			--pBlock->dwCount;
		
			if (pBlock->dwCount && (i < (INT)pBlock->dwCount))
			{				
				// Overwrite this route with the ones which follow it
				::memmove(pRow,
						  pRow + 1,
						  (pBlock->dwCount - i) * sizeof(*pRow));
			}
			
			break;
		}
	}

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	IpxServiceHandler::ModifyRouteInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxServiceHandler::ModifyRouteInfo(ITFSNode *pNode,
										IpxSSListEntry *pSSEntryNew,
										IpxSSListEntry *pSSEntryOld)
{
 	Assert(pSSEntryNew);
	Assert(pSSEntryOld);
	
    INT i;
	HRESULT hr = hrOK;
    InfoBlock* pBlock;
	SPIInfoBase	spInfoBase;
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPITFSNode				spNodeParent;
	IPXConnection *			pIPXConn;
	IPX_STATIC_SERVICE_INFO		*psr, *psrOld;
	IPX_STATIC_SERVICE_INFO		IpxRow;

    CWaitCursor wait;

	pNode->GetParent(&spNodeParent);
	pIPXConn = GET_IPX_SS_NODEDATA(spNodeParent);
	Assert(pIPXConn);

	// Remove the old route if it is on another interface
	if (lstrcmpi(pSSEntryOld->m_spIf->GetId(), pSSEntryNew->m_spIf->GetId()) != 0)
	{
        // the outgoing interface for a route is to be changed.

		CORg( pSSEntryOld->m_spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) );
		CORg( spRmIf->GetInfoBase(pIPXConn->GetConfigHandle(),
								  NULL,
								  NULL,
								  &spInfoBase));
		
		// Remove the old interface
		CORg( RemoveStaticService(pSSEntryOld, spInfoBase) );

		// Update the interface information
		CORg( spRmIf->Save(pSSEntryOld->m_spIf->GetMachineName(),
						   pIPXConn->GetConfigHandle(),
						   NULL,
						   NULL,
						   spInfoBase,
						   0));	
    }

	spRmIf.Release();
	spInfoBase.Release();


	// Either
	// (a) a route is being modified (on the same interface)
	// (b) a route is being moved from one interface to another.

	// Retrieve the configuration for the interface to which the route
	// is now attached;

	
	CORg( pSSEntryNew->m_spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) );
	CORg( spRmIf->GetInfoBase(pIPXConn->GetConfigHandle(),
							  NULL,
							  NULL,
							  &spInfoBase));

		
	// Get the IPX_STATIC_SERVICE_INFO block from the interface
	hr = spInfoBase->GetBlock(IPX_STATIC_SERVICE_INFO_TYPE, &pBlock, 0);
	if (!FHrOK(hr))
	{
		//
		// No IPX_STATIC_SERVICE_INFO block was found; we create a new block 
		// with the new route, and add that block to the interface-info
		//

		CORg( AddStaticService(pSSEntryNew, spInfoBase, NULL) );
	}
	else
	{
		//
		// An IPX_STATIC_SERVICE_INFO block was found.
		//
		// We are modifying an existing route.
		// If the route's interface was not changed when it was modified,
		// look for the existing route in the IPX_STATIC_SERVICE_INFO, and then
		// update its parameters.
		// Otherwise, write a completely new route in the IPX_STATIC_SERVICE_INFO;
		//

		if (lstrcmpi(pSSEntryOld->m_spIf->GetId(), pSSEntryNew->m_spIf->GetId()) == 0)
		{        
			//
			// The route's interface was not changed when it was modified;
			// We now look for it amongst the existing Services
			// for this interface.
			// The route's original parameters are in 'preOld',
			// so those are the parameters with which we search
			// for a route to modify
			//
			
			psr = (IPX_STATIC_SERVICE_INFO*)pBlock->pData;
			
			for (i = 0; i < (INT)pBlock->dwCount; i++, psr++)
			{	
				// Compare this route to the re-configured one
				if (!FAreTwoServicesEqual(&(pSSEntryOld->m_service), psr))
					continue;
				
				// This is the route which was modified;
				// We can now modify the parameters for the route in-place.
				*psr = pSSEntryNew->m_service;
				
				break;
			}
		}
		else
		{
			CORg( AddStaticService(pSSEntryNew, spInfoBase, pBlock) );
		}
		
		// Save the updated information
		CORg( spRmIf->Save(pSSEntryNew->m_spIf->GetMachineName(),
						   pIPXConn->GetConfigHandle(),
						   NULL,
						   NULL,
						   spInfoBase,
						   0));	
		
	}

Error:
	return hr;
	
}


/*!--------------------------------------------------------------------------
	IpxServiceHandler::ParentRefresh
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IpxServiceHandler::ParentRefresh(ITFSNode *pNode)
{
	return ForwardCommandToParent(pNode, IDS_MENU_SYNC,
								  CCT_RESULT, NULL, 0);
}


//----------------------------------------------------------------------------
// Class:       CStaticServiceDlg
//
//----------------------------------------------------------------------------


//----------------------------------------------------------------------------
// Function:    CStaticServiceDlg::CStaticServiceDlg
//
// Constructor: initialize the base-class and the dialog's data.
//----------------------------------------------------------------------------

CStaticServiceDlg::CStaticServiceDlg(IpxSSListEntry *	pSSEntry,
								 DWORD dwFlags,
								 IRouterInfo *pRouter,
								 CWnd *pParent)
    : CBaseDialog(IDD_STATIC_SERVICE, pParent),
	m_pSSEntry(pSSEntry),
	m_dwFlags(dwFlags)
{

    //{{AFX_DATA_INIT(CStaticServiceDlg)
    //}}AFX_DATA_INIT

	m_spRouterInfo.Set(pRouter);

//	SetHelpMap(m_dwHelpMap);
}



//----------------------------------------------------------------------------
// Function:    CStaticServiceDlg::DoDataExchange
//----------------------------------------------------------------------------

VOID
CStaticServiceDlg::DoDataExchange(
    CDataExchange* pDX
    ) {

    CBaseDialog::DoDataExchange(pDX);
    
    //{{AFX_DATA_MAP(CStaticServiceDlg)
    DDX_Control(pDX, IDC_SSD_COMBO_INTERFACE, m_cbInterfaces);
	DDX_Control(pDX, IDC_SSD_SPIN_HOP_COUNT, m_spinHopCount);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CStaticServiceDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CStaticServiceDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


DWORD CStaticServiceDlg::m_dwHelpMap[] =
{
//	IDC_SRD_DESTINATION, HIDC_SRD_DESTINATION,
//	IDC_SRD_NETMASK, HIDC_SRD_NETMASK,
//	IDC_SRD_GATEWAY, HIDC_SRD_GATEWAY,
//	IDC_SRD_METRIC, HIDC_SRD_METRIC,
//	IDC_SRD_SPINMETRIC, HIDC_SRD_SPINMETRIC,
//	IDC_SRD_INTERFACES, HIDC_SRD_INTERFACES,
	0,0
};

//----------------------------------------------------------------------------
// Function:    CStaticServiceDlg::OnInitDialog
//
// Handles the 'WM_INITDIALOG' message for the dialog.
//----------------------------------------------------------------------------

BOOL
CStaticServiceDlg::OnInitDialog(
    )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	SPIEnumInterfaceInfo	spEnumIf;
	SPIInterfaceInfo		spIf;
	SPIRtrMgrInterfaceInfo	spRmIf;
	TCHAR					szNumber[32];
	USES_CONVERSION;

    CBaseDialog::OnInitDialog();

	// initialize the controls
	m_spinHopCount.SetRange(0, 15);
	m_spinHopCount.SetBuddy(GetDlgItem(IDC_SSD_EDIT_HOP_COUNT));

	((CEdit *) GetDlgItem(IDC_SSD_EDIT_SERVICE_TYPE))->LimitText(4);
	((CEdit *) GetDlgItem(IDC_SSD_EDIT_SERVICE_NAME))->LimitText(48);
	((CEdit *) GetDlgItem(IDC_SSD_EDIT_NETWORK_ADDRESS))->LimitText(8);
	((CEdit *) GetDlgItem(IDC_SSD_EDIT_NODE_ADDRESS))->LimitText(12);
	((CEdit *) GetDlgItem(IDC_SSD_EDIT_SOCKET_ADDRESS))->LimitText(4);

	
    // Get a list of the interfaces enabled for IPX routing.
	m_spRouterInfo->EnumInterface(&spEnumIf);

	for( ; spEnumIf->Next(1, &spIf, NULL) == hrOK; spIf.Release())
	{
		spRmIf.Release();
		
		if (spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) != hrOK)
			continue;

        // Add the interface to the combobox
        INT i = m_cbInterfaces.AddString(spIf->GetTitle());

        m_cbInterfaces.SetItemData(i, (DWORD_PTR)m_ifidList.AddTail(spIf->GetId()));
	}

	if (!m_cbInterfaces.GetCount())
	{
        AfxMessageBox(IDS_ERR_NO_IPX_INTERFACES);
        EndDialog(IDCANCEL);
		return FALSE;
    }

    m_cbInterfaces.SetCurSel(0);

    //
    // If we were given a route to modify, set the dialog up
    // with the parameters in the route
    //
	if ((m_dwFlags & SR_DLG_MODIFY) == 0)
	{
        // No route was given, so leave the controls blank
    }
    else
	{
        // A route to be edited was given, so initialize the controls
		wsprintf(szNumber, _T("%.4x"), m_pSSEntry->m_service.Type);
		SetDlgItemText(IDC_SSD_EDIT_SERVICE_TYPE, szNumber);

		SetDlgItemText(IDC_SSD_EDIT_SERVICE_NAME, A2CT((LPSTR) m_pSSEntry->m_service.Name));
		
		FormatIpxNetworkNumber(szNumber,
							   DimensionOf(szNumber),
							   m_pSSEntry->m_service.Network,
							   sizeof(m_pSSEntry->m_service.Network));
		SetDlgItemText(IDC_SSD_EDIT_NETWORK_ADDRESS, szNumber);

        // Zero out the address beforehand
		FormatBytes(szNumber, DimensionOf(szNumber),
					(BYTE *) m_pSSEntry->m_service.Node,
					sizeof(m_pSSEntry->m_service.Node));
		SetDlgItemText(IDC_SSD_EDIT_NODE_ADDRESS, szNumber);

		FormatBytes(szNumber, DimensionOf(szNumber),
					(BYTE *) m_pSSEntry->m_service.Socket,
					sizeof(m_pSSEntry->m_service.Socket));
		SetDlgItemText(IDC_SSD_EDIT_SOCKET_ADDRESS, szNumber);

		
        m_cbInterfaces.SelectString(-1, m_pSSEntry->m_spIf->GetTitle());

		m_spinHopCount.SetPos(m_pSSEntry->m_service.HopCount);
		
		// Disable the network number, next hop, and interface
		GetDlgItem(IDC_SSD_EDIT_SERVICE_TYPE)->EnableWindow(FALSE);
		GetDlgItem(IDC_SSD_EDIT_SERVICE_NAME)->EnableWindow(FALSE);
		GetDlgItem(IDC_SSD_COMBO_INTERFACE)->EnableWindow(FALSE);
		
    }

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    CStaticServiceDlg::OnOK
//
// Handles 'BN_CLICKED' notification from the 'OK' button.
//----------------------------------------------------------------------------

VOID
CStaticServiceDlg::OnOK(
    ) {
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    CString		st;
	SPIInterfaceInfo	spIf;
	CString		stIf;
	POSITION	pos;

    do
	{    
        // Get the route's outgoing interface
        INT item = m_cbInterfaces.GetCurSel();
        if (item == CB_ERR)
			break;

        pos = (POSITION)m_cbInterfaces.GetItemData(item);

        stIf = (LPCTSTR)m_ifidList.GetAt(pos);

		m_spRouterInfo->FindInterface(stIf, &spIf);

		m_pSSEntry->m_spIf.Set(spIf);

		// Get the rest of the data
		GetDlgItemText(IDC_SSD_EDIT_SERVICE_TYPE, st);
		m_pSSEntry->m_service.Type = (USHORT) _tcstoul(st, NULL, 16);

		GetDlgItemText(IDC_SSD_EDIT_SERVICE_NAME, st);
		st.TrimLeft();
		st.TrimRight();
		if (st.IsEmpty())
		{
			GetDlgItem(IDC_SSD_EDIT_SERVICE_NAME)->SetFocus();
			AfxMessageBox(IDS_ERR_INVALID_SERVICE_NAME);
			break;
		}
		StrnCpyAFromW((LPSTR) m_pSSEntry->m_service.Name,
					  st,
					  sizeof(m_pSSEntry->m_service.Name));
		
		GetDlgItemText(IDC_SSD_EDIT_NETWORK_ADDRESS, st);
		ConvertToBytes(st,
					   m_pSSEntry->m_service.Network,
					   DimensionOf(m_pSSEntry->m_service.Network));
		
		GetDlgItemText(IDC_SSD_EDIT_NODE_ADDRESS, st);
		ConvertToBytes(st,
					   m_pSSEntry->m_service.Node,
					   DimensionOf(m_pSSEntry->m_service.Node));
		
		GetDlgItemText(IDC_SSD_EDIT_SOCKET_ADDRESS, st);
		ConvertToBytes(st,
					   m_pSSEntry->m_service.Socket,
					   DimensionOf(m_pSSEntry->m_service.Socket));

		m_pSSEntry->m_service.HopCount = (USHORT) m_spinHopCount.GetPos();
		
        CBaseDialog::OnOK();
                
    } while(FALSE);
}


/*!--------------------------------------------------------------------------
	IpxSSListEntry::LoadFrom
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxSSListEntry::LoadFrom(BaseIPXResultNodeData *pNodeData)
{
	CString	stFullAddress;
	CString	stNumber;
	
	m_spIf.Set(pNodeData->m_spIf);

	m_service.Type = (USHORT) _tcstoul(
						pNodeData->m_rgData[IPX_SS_SI_SERVICE_TYPE].m_stData,
						NULL, 16);

	StrnCpyAFromW((LPSTR) m_service.Name,
				  pNodeData->m_rgData[IPX_SS_SI_SERVICE_NAME].m_stData,
				  DimensionOf(m_service.Name));

	// Need to break the address up into Network.Node.Socket
	stFullAddress = pNodeData->m_rgData[IPX_SS_SI_SERVICE_ADDRESS].m_stData;
	Assert(StrLen(stFullAddress) == (8 + 1 + 12 + 1 + 4));

	stNumber = stFullAddress.Left(8);
	ConvertToBytes(stNumber,
				   m_service.Network, sizeof(m_service.Network));

	stNumber = stFullAddress.Mid(9, 12);
	ConvertToBytes(stNumber,
				   m_service.Node, sizeof(m_service.Node));

	stNumber = stFullAddress.Mid(22, 4);
	ConvertToBytes(stNumber,
				   m_service.Socket, sizeof(m_service.Socket));	
	
	m_service.HopCount = (USHORT) pNodeData->m_rgData[IPX_SS_SI_HOP_COUNT].m_dwData;
}

/*!--------------------------------------------------------------------------
	IpxSSListEntry::SaveTo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxSSListEntry::SaveTo(BaseIPXResultNodeData *pNodeData)
{
	TCHAR	szNumber[32];
	CString	st;
	USES_CONVERSION;
	
	pNodeData->m_spIf.Set(m_spIf);

	pNodeData->m_rgData[IPX_SS_SI_NAME].m_stData = m_spIf->GetTitle();

	wsprintf(szNumber, _T("%.4x"), m_service.Type);
	pNodeData->m_rgData[IPX_SS_SI_SERVICE_TYPE].m_stData = szNumber;
    pNodeData->m_rgData[IPX_SS_SI_SERVICE_TYPE].m_dwData = (DWORD) m_service.Type;

	pNodeData->m_rgData[IPX_SS_SI_SERVICE_NAME].m_stData =
		A2CT((LPSTR) m_service.Name);

	FormatBytes(szNumber, DimensionOf(szNumber),
				m_service.Network, sizeof(m_service.Network));
	st = szNumber;
	st += _T(".");
	FormatBytes(szNumber, DimensionOf(szNumber),
				m_service.Node, sizeof(m_service.Node));
	st += szNumber;
	st += _T(".");
	FormatBytes(szNumber, DimensionOf(szNumber),
				m_service.Socket, sizeof(m_service.Socket));
	st += szNumber;

	Assert(st.GetLength() == (8+1+12+1+4));

	pNodeData->m_rgData[IPX_SS_SI_SERVICE_ADDRESS].m_stData = st;

	FormatNumber(m_service.HopCount,
				 szNumber,
				 DimensionOf(szNumber),
				 FALSE);
	pNodeData->m_rgData[IPX_SS_SI_HOP_COUNT].m_stData = szNumber;
	pNodeData->m_rgData[IPX_SS_SI_HOP_COUNT].m_dwData = m_service.HopCount;

}

/*!--------------------------------------------------------------------------
	SetServiceData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SetServiceData(BaseIPXResultNodeData *pData,
					 IpxSSListEntry *pService)
{

	pService->SaveTo(pData);
	return hrOK;
}

/*!--------------------------------------------------------------------------
	AddStaticService
		This function ASSUMES that the route is NOT in the block.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AddStaticService(IpxSSListEntry *pSSEntryNew,
									   IInfoBase *pInfoBase,
									   InfoBlock *pBlock)
{
	IPX_STATIC_SERVICE_INFO	srRow;
	HRESULT				hr = hrOK;
	
	if (pBlock == NULL)
	{
		//
		// No IPX_STATIC_SERVICE_INFO block was found; we create a new block 
		// with the new route, and add that block to the interface-info
		//
		
		CORg( pInfoBase->AddBlock(IPX_STATIC_SERVICE_INFO_TYPE,
								  sizeof(IPX_STATIC_SERVICE_INFO),
								  (LPBYTE) &(pSSEntryNew->m_service), 1, 0) );
	}
	else
	{
		// Either the route is completely new, or it is a route
		// which was moved from one interface to another.
		// Set a new block as the IPX_STATIC_SERVICE_INFO,
		// and include the re-configured route in the new block.
		PIPX_STATIC_SERVICE_INFO	psrTable;
			
		psrTable = new IPX_STATIC_SERVICE_INFO[pBlock->dwCount + 1];
		Assert(psrTable);
		
		// Copy the original table of Services
		::memcpy(psrTable, pBlock->pData,
				 pBlock->dwCount * sizeof(IPX_STATIC_SERVICE_INFO));
		
		// Append the new route
		psrTable[pBlock->dwCount] = pSSEntryNew->m_service;
		
		// Replace the old route-table with the new one
		CORg( pInfoBase->SetData(IPX_STATIC_SERVICE_INFO_TYPE,
								 sizeof(IPX_STATIC_SERVICE_INFO),
								 (LPBYTE) psrTable, pBlock->dwCount + 1, 0) );
	}
	
Error:
	return hr;
}


BOOL FAreTwoServicesEqual(IPX_STATIC_SERVICE_INFO *pService1,
						IPX_STATIC_SERVICE_INFO *pService2)
{
	return (pService1->Type == pService2->Type) &&
			(StrnCmpA((LPCSTR) pService1->Name, (LPCSTR) pService2->Name, DimensionOf(pService1->Name)) == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\summary.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    summary.h
//
// History:
//	07/22/97	Kenn M. Takara			Created.
//
//	IPX interfaces summary view.
//
//============================================================================


#ifndef _SUMMARY_H
#define _SUMMARY_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _XSTREAM_H
#include "xstream.h"		// need for ColumnData
#endif

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _IPXFACE_H
#include "ipxface.h"
#endif

#ifndef _BASECON_H
#include "basecon.h"		// BaseContainerHandler
#endif

#ifndef _IPXSTRM_H
#include "ipxstrm.h"
#endif

#ifndef _RTRSHEET_H
#include "rtrsheet.h"
#endif

#ifndef _IPXCONN_H
#include "ipxconn.h"			// IPXConnection
#endif

// forward declarations
class	IPXAdminConfigStream;
struct	SIPXSummaryNodeMenu;


/*---------------------------------------------------------------------------
	This is the list of columns available for the IPX Summary interfaces
	node.
		- Name, "[1] DEC DE500 ..."
		- Type, "Dedicated"
		- Adminstrative status, "Up"
		- Operational status, "Operational"
		- Packets sent
		- Packets received
		- Out filtered packets
		- Out dropped packets
		- In filtered packets
		- In No-routes packets
		- In Dropped packets
 ---------------------------------------------------------------------------*/


//
// If you ADD any columns to this enum, Be sure to update
// the string ids for the column headers in summary.cpp
//
enum
{
	IPXSUM_SI_NAME = 0,
	IPXSUM_SI_TYPE,
	IPXSUM_SI_ADMINSTATE,
	IPXSUM_SI_OPERSTATE,
	IPXSUM_SI_NETWORK,
	IPXSUM_SI_PACKETS_SENT,
	IPXSUM_SI_PACKETS_RCVD,
	IPXSUM_SI_OUT_FILTERED,
	IPXSUM_SI_OUT_DROPPED,
	IPXSUM_SI_IN_FILTERED,
	IPXSUM_SI_IN_NOROUTES,
	IPXSUM_SI_IN_DROPPED,
    IPXSUM_MAX_COLUMNS
};


/*---------------------------------------------------------------------------
	We store a pointer to the IPXConnection object in our node data
 ---------------------------------------------------------------------------*/

#define GET_IPXSUMMARY_NODEDATA(pNode) \
		(IPXConnection *) pNode->GetData(TFS_DATA_USER)
#define SET_IPXSUMMARY_NODEDATA(pNode, pData) \
		pNode->SetData(TFS_DATA_USER, (LONG_PTR) pData)


/*---------------------------------------------------------------------------
	Struct: IPXSummaryListEntry
 ---------------------------------------------------------------------------*/
struct IPXSummaryListEntry
{
	CString				m_stId;
	CString				m_stTitle;

	UCHAR				m_network[4];

	DWORD				m_dwAdminState;
	DWORD				m_dwIfType;

	DWORD				m_dwOperState;
	DWORD				m_dwSent;
	DWORD				m_dwRcvd;
	DWORD				m_dwOutFiltered;
	DWORD				m_dwOutDropped;
	DWORD				m_dwInFiltered;
	DWORD				m_dwInNoRoutes;
	DWORD				m_dwInDropped;
};

typedef CList<IPXSummaryListEntry *, IPXSummaryListEntry *> IPXSummaryList;



/*---------------------------------------------------------------------------
	Class:	IPXSummaryHandler
 ---------------------------------------------------------------------------*/



class IPXSummaryHandler :
		public BaseContainerHandler
{
public:
	IPXSummaryHandler(ITFSComponentData *pTFSCompData);

	// Override QI to handle embedded interface
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);
	
	DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)

	// base handler functionality we override
	OVERRIDE_NodeHandler_GetString();
	OVERRIDE_NodeHandler_OnCreateDataObject();
    OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_DestroyHandler();

	OVERRIDE_BaseHandlerNotify_OnExpand();

	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_CompareItems();

	OVERRIDE_BaseResultHandlerNotify_OnResultShow();

    OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();

	
	// Initializes the handler
	HRESULT	Init(IRtrMgrInfo *pRtrMgrInfo, IPXAdminConfigStream *pConfigStream);
	
	// Initializes the node
	HRESULT ConstructNode(ITFSNode *pNode, LPCTSTR szName,
						  IPXConnection *pIPXConn);

public:
	// Structure used to pass data to callbacks - used as a way of
	// avoiding recomputation
	struct SMenuData
	{
		SPITFSNode			m_spNode;
	};
	// Function callbacks for menu enabling/disabling

protected:
	// Refresh the data for these nodes
	HRESULT	SynchronizeNodeData(ITFSNode *pThisNode);
	HRESULT GetIPXSummaryData(ITFSNode *pThisNode, IPXSummaryList * pIPXSumList);
	HRESULT	GetClientInterfaceData(IPXSummaryListEntry *pClient, IRtrMgrInfo *pRm);


	// Helper function to add interfaces to the UI
	HRESULT	AddInterfaceNode(ITFSNode *pParent,
							 IInterfaceInfo *pIf,
							 BOOL fClient,
							 ITFSNode **ppNewNode);

	// Command implementations
	HRESULT	OnNewInterface();
	
	LONG_PTR		m_ulConnId;		// notification id for router info
	LONG_PTR		m_ulRefreshConnId;	// notification id for router refresh
	LONG_PTR		m_ulStatsConnId;	// notification for stats refresh
	MMC_COOKIE		m_cookie;		// cookie for the node
	SPIRtrMgrInfo	m_spRtrMgrInfo;
	IPXAdminConfigStream *	m_pConfigStream;
	CString			m_stTitle;
};



/*---------------------------------------------------------------------------
	Class:	IPXSummaryInterfaceHandler

	This is the handler for the interface nodes that appear in the IPXSummary
	node.
 ---------------------------------------------------------------------------*/

class IPXSummaryInterfaceHandler : public BaseIPXResultHandler
{
public:
	IPXSummaryInterfaceHandler(ITFSComponentData *pCompData);
	
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnCreateDataObject();
	
	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_OnCreateDataObject();
	OVERRIDE_ResultHandler_DestroyResultHandler();
	OVERRIDE_ResultHandler_HasPropertyPages()
			{	return hrOK;	};
	OVERRIDE_ResultHandler_CreatePropertyPages();
	
	OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
	
	// Initializes the node
	HRESULT ConstructNode(ITFSNode *pNode, IInterfaceInfo *pIfInfo,
						 IPXConnection *pIPXConn);
	HRESULT	Init(IRtrMgrInfo *pRm, IInterfaceInfo *pInfo,
				 ITFSNode *pParent);

	// Removes IPX from this interface
	HRESULT OnRemoveInterface();

	// Refresh the data for this node
	void RefreshInterface(MMC_COOKIE cookie);

    //sets the IPX enable/disable flag for the interface
    HRESULT OnEnableDisableIPX(BOOL fEnable, MMC_COOKIE cookie );
    void SetInfoBase(SPIInfoBase  & spInfoBase )
    {
        m_spInfoBase = spInfoBase.Transfer();
    };
private:
	HRESULT LoadInfoBase( IPXConnection *pIPXConn);
	HRESULT SaveChanges();
public:
	// Structure used to pass data to callbacks - used as a way of
	// avoiding recomputation
	struct SMenuData
	{
		SPITFSNode					m_spNode;
        SPIInterfaceInfo			m_spInterfaceInfo;
		SPIInfoBase					m_spInfoBaseCopy;
	};
	static ULONG	GetUpdateRoutesFlags(const SRouterNodeMenu *, INT_PTR);
	static ULONG	GetEnableFlags(const SRouterNodeMenu *, INT_PTR);
	static ULONG	GetDisableFlags(const SRouterNodeMenu *, INT_PTR);
	
	HRESULT	OnUpdateRoutes(MMC_COOKIE cookie);
	
protected:
	LONG_PTR			m_ulConnId;
	SPIRtrMgrInfo		m_spRm;
	SPIInterfaceInfo	m_spInterfaceInfo;
    SPIInfoBase         m_spInfoBase;
    SPIRtrMgrInterfaceInfo  m_spRmIf;
	BOOL				m_bClientInfoBase;
	IPXConnection	*	m_pIPXConn;
};

#endif _SUMMARY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\summary.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	summary.cpp
		IPX summary node implementation.
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "util.h"
#include "summary.h"
#include "reg.h"
#include "ipxadmin.h"
#include "rtrutil.h"	// smart MPR handle pointers
#include "ipxstrm.h"		// IPXAdminConfigStream
#include "strmap.h"		// XXXtoCString functions
#include "service.h"	// TFS service APIs
#include "format.h"		// FormatNumber function
#include "coldlg.h"		// columndlg
#include "column.h"	// ComponentConfigStream
#include "rtrui.h"
#include "sumprop.h"	// IP Summary property page
#include "ipxutil.h"	// IPX formatting helper functions
#include "routprot.h"
#include "ipxrtdef.h"
#include "rtrerr.h"     // FormatRasErrorMessage


/*---------------------------------------------------------------------------
	Keep this in sync with the column ids in summary.h
 ---------------------------------------------------------------------------*/
extern const ContainerColumnInfo	s_rgIfViewColumnInfo[];

const ContainerColumnInfo	s_rgIfViewColumnInfo[] = 
{
	{ IDS_IPX_COL_NAME,				CON_SORT_BY_STRING,	TRUE, COL_IF_NAME },
	{ IDS_IPX_COL_TYPE,				CON_SORT_BY_STRING, TRUE, COL_STRING },
	{ IDS_IPX_COL_ADMINSTATE,		CON_SORT_BY_STRING, TRUE, COL_STATUS },
	{ IDS_IPX_COL_OPERSTATE,		CON_SORT_BY_STRING, TRUE, COL_STATUS },
	{ IDS_IPX_COL_NETWORK,			CON_SORT_BY_STRING,	TRUE, COL_IPXNET },
	{ IDS_IPX_COL_PACKETS_SENT,		CON_SORT_BY_DWORD,	TRUE, COL_LARGE_NUM },
	{ IDS_IPX_COL_PACKETS_RCVD,		CON_SORT_BY_DWORD,	TRUE, COL_LARGE_NUM },
	{ IDS_IPX_COL_OUT_FILTERED,		CON_SORT_BY_DWORD,	FALSE, COL_LARGE_NUM },
	{ IDS_IPX_COL_OUT_DROPPED,		CON_SORT_BY_DWORD,	FALSE, COL_LARGE_NUM },
	{ IDS_IPX_COL_IN_FILTERED,		CON_SORT_BY_DWORD,	FALSE, COL_LARGE_NUM },
	{ IDS_IPX_COL_IN_NOROUTES,		CON_SORT_BY_DWORD,	FALSE, COL_LARGE_NUM },
	{ IDS_IPX_COL_IN_DROPPED,		CON_SORT_BY_DWORD,	FALSE, COL_LARGE_NUM },
};


/*---------------------------------------------------------------------------
	IPXSummaryHandler implementation
 ---------------------------------------------------------------------------*/

IPXSummaryHandler::IPXSummaryHandler(ITFSComponentData *pCompData)
	: BaseContainerHandler(pCompData, COLUMNS_SUMMARY,
						   s_rgIfViewColumnInfo),
	m_ulConnId(0),
	m_ulRefreshConnId(0),
	m_ulStatsConnId(0)
{

	// Setup the verb states

	m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
	m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;
	
}


STDMETHODIMP IPXSummaryHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IRtrAdviseSink)
		*ppv = &m_IRtrAdviseSink;
	else
		return BaseContainerHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;	
}



/*!--------------------------------------------------------------------------
	IPXSummaryHandler::DestroyHandler
		Implementation of ITFSNodeHandler::DestroyHandler
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXSummaryHandler::DestroyHandler(ITFSNode *pNode)
{
	IPXConnection *	pIpxConn;

	pIpxConn = GET_IPXSUMMARY_NODEDATA(pNode);
	pIpxConn->Release();

	if (m_ulRefreshConnId)
	{
		SPIRouterRefresh	spRefresh;
		if (m_spRouterInfo)
			m_spRouterInfo->GetRefreshObject(&spRefresh);
		if (spRefresh)
			spRefresh->UnadviseRefresh(m_ulRefreshConnId);
	}
	m_ulRefreshConnId = 0;

	if (m_ulStatsConnId)
	{
		SPIRouterRefresh	spRefresh;
		if (m_spRouterInfo)
			m_spRouterInfo->GetRefreshObject(&spRefresh);
		if (spRefresh)
			spRefresh->UnadviseRefresh(m_ulStatsConnId);		
	}
	m_ulStatsConnId = 0;
	
	if (m_ulConnId)
		m_spRtrMgrInfo->RtrUnadvise(m_ulConnId);
	m_ulConnId = 0;
	m_spRtrMgrInfo.Release();

//	WaitForStatisticsWindow(&m_IpxStats);

	m_spRouterInfo.Release();
	return hrOK;
}

/*---------------------------------------------------------------------------
	Menu data structure for our menus
 ---------------------------------------------------------------------------*/

static const SRouterNodeMenu s_rgIfNodeMenu[] =
{
	{ IDS_MENU_IPXSUM_NEW_INTERFACE, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },

	{ IDS_MENU_SEPARATOR, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },
};

/*!--------------------------------------------------------------------------
	IPXSummaryHandler::OnAddMenuItems
		Implementation of ITFSNodeHandler::OnAddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXSummaryHandler::OnAddMenuItems(
	ITFSNode *pNode,
	LPCONTEXTMENUCALLBACK pContextMenuCallback, 
	LPDATAOBJECT lpDataObject, 
	DATA_OBJECT_TYPES type, 
	DWORD dwType,
	long *pInsertionAllowed)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = S_OK;
    IPXSummaryHandler::SMenuData    menuData;
	
	COM_PROTECT_TRY
	{
        menuData.m_spNode.Set(pNode);
        
		hr = AddArrayOfMenuItems(pNode, s_rgIfNodeMenu,
								 DimensionOf(s_rgIfNodeMenu),
								 pContextMenuCallback,
								 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
	}
	COM_PROTECT_CATCH;
		
	return hr; 
}

/*!--------------------------------------------------------------------------
	IPXSummaryHandler::OnCommand
		Implementation of ITFSNodeHandler::OnCommand
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXSummaryHandler::OnCommand(ITFSNode *pNode, long nCommandId, 
										   DATA_OBJECT_TYPES	type, 
										   LPDATAOBJECT pDataObject, 
										   DWORD	dwType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;

	COM_PROTECT_TRY
	{
		switch (nCommandId)
		{
			case IDS_MENU_IPXSUM_NEW_INTERFACE:
				hr = OnNewInterface();
				if (!FHrSucceeded(hr))
					DisplayErrorMessage(NULL, hr);
 				break;

			case IDS_MENU_SYNC:
				SynchronizeNodeData(pNode);
				break;
		}
	}
	COM_PROTECT_CATCH;

	return hrOK;
}

/*!--------------------------------------------------------------------------
	IPXSummaryHandler::OnExpand
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXSummaryHandler::OnExpand(ITFSNode *pNode,
									LPDATAOBJECT pDataObject,
									DWORD dwType,
									LPARAM arg,
									LPARAM lParam)
{
	HRESULT	hr = hrOK;
	SPIEnumInterfaceInfo	spEnumIf;
	SPIInterfaceInfo		spIf;
	SPIRtrMgrInterfaceInfo	spRmIf;
	
    // Windows NT Bug: 288427
    // This flag may also get set inside of the OnChange() call.
    // The OnChange() will enumerate and all interfaces.
    // They may have been added as the result of an OnChange()
    // because they were added before the OnExpand() was called.
    //
    // WARNING!  Be careful about adding anything to this function,
    //  since the m_bExpanded can be set in another function.
    // ----------------------------------------------------------------
	if (m_bExpanded)
		return hrOK;

	COM_PROTECT_TRY
	{
		
		CORg( m_spRouterInfo->EnumInterface(&spEnumIf) );

		while (spEnumIf->Next(1, &spIf, NULL) == hrOK)
		{
			if (spIf->FindRtrMgrInterface(PID_IPX, &spRmIf) == hrOK)
			{
				// Now we create an interface node for this interface
				AddInterfaceNode(pNode, spIf, FALSE, NULL);
			}
			spRmIf.Release();
			spIf.Release();
		}

		//$CLIENT: Add the client interface (setup default data)
		// the only thing that we can do in synchronize is to
		// get the Administrative status
		AddInterfaceNode(pNode, NULL, TRUE, NULL);

		m_bExpanded = TRUE;

		// Now that we have all of the nodes, update the data for
		// all of the nodes
		SynchronizeNodeData(pNode);

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;



	m_bExpanded = TRUE;

	return hr;
}

/*!--------------------------------------------------------------------------
	IPXSummaryHandler::GetString
		Implementation of ITFSNodeHandler::GetString
		We don't need to do anything, since our root node is an extension
		only and thus can't do anything to the node text.
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) IPXSummaryHandler::GetString(ITFSNode *pNode, int nCol)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		if (m_stTitle.IsEmpty())
			m_stTitle.LoadString(IDS_IPXSUMMARY_TITLE);
	}
	COM_PROTECT_CATCH;

	return m_stTitle;
}

/*!--------------------------------------------------------------------------
	IPXSummaryHandler::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXSummaryHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{

		Assert(m_spRtrMgrInfo);
		
		CORg( CreateDataObjectFromRtrMgrInfo(m_spRtrMgrInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}


/*!--------------------------------------------------------------------------
	IPXSummaryHandler::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXSummaryHandler::Init(IRtrMgrInfo *pRmInfo, IPXAdminConfigStream *pConfigStream)
{
    

	m_spRtrMgrInfo.Set(pRmInfo);
	if (pRmInfo)
		pRmInfo->GetParentRouterInfo(&m_spRouterInfo);
	m_pConfigStream = pConfigStream;
	
	// Also need to register for change notifications
	Assert(m_ulConnId == 0);
	m_spRtrMgrInfo->RtrAdvise(&m_IRtrAdviseSink, &m_ulConnId, 0);


//	m_IpxStats.SetConfigInfo(pConfigStream, IPXSTRM_STATS_IPX);

	return hrOK;
}

HRESULT IPXSummaryHandler::OnResultRefresh(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	HRESULT  hr = hrOK;
	SPITFSNode spNode, spParent;
    SPITFSResultHandler spParentRH;

	m_spNodeMgr->FindNode(cookie, &spNode);

    // forward this command to the parent to handle
    CORg (spNode->GetParent(&spParent));
	CORg (spParent->GetResultHandler(&spParentRH));

	CORg (spParentRH->Notify(pComponent, spParent->GetData(TFS_DATA_COOKIE), pDataObject, MMCN_REFRESH, arg, lParam));

Error:
    return hrOK;

}


/*!--------------------------------------------------------------------------
	IPXSummaryHandler::ConstructNode
		Initializes the root node (sets it up).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXSummaryHandler::ConstructNode(ITFSNode *pNode, LPCTSTR pszName,
										IPXConnection *pIpxConn)
{
	Assert(pIpxConn);
	HRESULT			hr = hrOK;
	
	if (pNode == NULL)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Need to initialize the data for the root node
		pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_IPX_NODE_GENERAL);
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_IPX_NODE_GENERAL);
		pNode->SetData(TFS_DATA_SCOPEID, 0);

        // This is a leaf node in the scope pane
        pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

		m_cookie = reinterpret_cast<DWORD_PTR>(pNode);
		pNode->SetData(TFS_DATA_COOKIE, m_cookie);

		pNode->SetNodeType(&GUID_IPXSummaryNodeType);

		// Setup the node data
		pIpxConn->AddRef();
		SET_IPXSUMMARY_NODEDATA(pNode, pIpxConn);

//		m_IpxStats.SetConnectionData(pIpxConn);
	}
	COM_PROTECT_CATCH;

	if (!FHrSucceeded(hr))
	{
		SET_IPXSUMMARY_NODEDATA(pNode, NULL);
	}

	return hr;
}


/*!--------------------------------------------------------------------------
	IPXSummaryHandler::AddInterfaceNode
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT	IPXSummaryHandler::AddInterfaceNode(ITFSNode *pParent, IInterfaceInfo *pIf, BOOL fClient, ITFSNode **ppNewNode)
{
	IPXSummaryInterfaceHandler *	pHandler;
	SPITFSResultHandler		spHandler;
	SPITFSNode				spNode;
	HRESULT					hr = hrOK;
	IPXConnection *			pIPXConn;
	BaseIPXResultNodeData *	pResultData = NULL;
	int						cBlocks = 0;
	SPIInfoBase				spInfoBase;
	SPIRtrMgrInterfaceInfo	spRmIf;

	// Create the handler for this node 
	pHandler = new IPXSummaryInterfaceHandler(m_spTFSCompData);
	spHandler = pHandler;
	CORg( pHandler->Init(m_spRtrMgrInfo, pIf, pParent) );
		
	pIPXConn = GET_IPXSUMMARY_NODEDATA(pParent);

	// Create a result item node (or a leaf node)
	CORg( CreateLeafTFSNode(&spNode,
							NULL,
							static_cast<ITFSNodeHandler *>(pHandler),
							static_cast<ITFSResultHandler *>(pHandler),
							m_spNodeMgr) );
	CORg( pHandler->ConstructNode(spNode, pIf, pIPXConn) );

	pResultData = GET_BASEIPXRESULT_NODEDATA(spNode);
	Assert(pResultData);
	ASSERT_BASEIPXRESULT_NODEDATA(pResultData);

	pResultData->m_fClient = fClient;

	if (pIf)
	{
		pIf->FindRtrMgrInterface(PID_IPX, &spRmIf);
		
		if (spRmIf)
			spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase);
		
		if (spInfoBase)
			spInfoBase->GetInfo(NULL, &cBlocks);
	}
	else
	{
		// This is a client, make it visible
		cBlocks = 1;
	}
	//Set the infobase here
	if ( !pResultData->m_fClient )
        pHandler->SetInfoBase (spInfoBase );
	// Make the node immediately visible
	if (cBlocks)
	{
		CORg( spNode->SetVisibilityState(TFS_VIS_SHOW) );
		CORg( spNode->Show() );
	}
	else
		CORg( spNode->SetVisibilityState(TFS_VIS_HIDE) );
	CORg( pParent->AddChild(spNode) );

	if (ppNewNode)
		*ppNewNode = spNode.Transfer();

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	IPXSummaryHandler::SynchronizeNodeData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXSummaryHandler::SynchronizeNodeData(ITFSNode *pThisNode)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT				hr = hrOK;
	BOOL				fIsServiceRunning;
	SPITFSNodeEnum		spEnum;
	SPITFSNode			spNode;
	BaseIPXResultNodeData *	pResultData = NULL;
	IPXSummaryList		IPXSumList;
	IPXSummaryListEntry *pIPXSum = NULL;
	POSITION			pos;
	CString				st;
	SPIInterfaceInfo	spIf;
	int					i;
	SPIInfoBase			spInfoBase;
	SPIRtrMgrInterfaceInfo	spRmIf;
	InfoBlock *			pBlock;
	IPXSummaryListEntry	clientIPX;
	TCHAR				szNumber[32];
	CString				stNotAvailable;

	COM_PROTECT_TRY
	{
		//
		// If the service is started, retrieve the IP interface-stats table
		// and update the stats for each node.
		//
		CORg( IsRouterServiceRunning(m_spRouterInfo->GetMachineName(), NULL) );
		
		fIsServiceRunning = (hr == hrOK);

		// Gather all of the data
		GetIPXSummaryData(pThisNode, &IPXSumList);

		stNotAvailable.LoadString(IDS_IPX_NOT_AVAILABLE);
		
		// Now match the data up to the nodes
		pThisNode->GetEnum(&spEnum);
		spEnum->Reset();
		
		for ( ; spEnum->Next(1, &spNode, NULL) == hrOK; spNode.Release())
		{
			pResultData = GET_BASEIPXRESULT_NODEDATA(spNode);
			Assert(pResultData);
			ASSERT_BASEIPXRESULT_NODEDATA(pResultData);
			
			spIf.Release();
			spIf.Set(pResultData->m_spIf);
			spRmIf.Release();
			spInfoBase.Release();

			// If we don't have an spIf, then this HAS to be the
			// client interface
			if (pResultData->m_fClient)
			{
				GetClientInterfaceData(&clientIPX, m_spRtrMgrInfo);
				pIPXSum = &clientIPX;
			}
			else
			{
				// Look for this interface in the IPXSummaryList
				pIPXSum = NULL;
				pos = IPXSumList.GetHeadPosition();
				while (pos)
				{
					pIPXSum = IPXSumList.GetNext(pos);
					
					if (StriCmp(pIPXSum->m_stId, spIf->GetId()) == 0)
						break;
					pIPXSum = NULL;
				}
				
				// Update the interface type and administrative state
				spIf->FindRtrMgrInterface(PID_IPX, &spRmIf);
				spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase);

				pBlock = NULL;
				if (spInfoBase)
					spInfoBase->GetBlock(IPX_INTERFACE_INFO_TYPE, &pBlock, 0);

				if (pIPXSum)
				{
					if (pBlock)
						pIPXSum->m_dwAdminState =
							((PIPX_IF_INFO)pBlock->pData)->AdminState;

					pIPXSum->m_dwIfType = spIf->GetInterfaceType();
					pIPXSum->m_stTitle = spIf->GetTitle();
				}

			}

			// As a default fill in all of the strings with a '-'
			for (i=0; i<IPXSUM_MAX_COLUMNS; i++)
			{
				pResultData->m_rgData[i].m_stData = stNotAvailable;
				pResultData->m_rgData[i].m_dwData = 0;
			}

			if (spIf)
			{
				pResultData->m_rgData[IPXSUM_SI_NAME].m_stData = spIf->GetTitle();
				pResultData->m_rgData[IPXSUM_SI_TYPE].m_stData =
					IpxTypeToCString(spIf->GetInterfaceType());
			}
			else if (pIPXSum)
			{
				pResultData->m_rgData[IPXSUM_SI_NAME].m_stData = pIPXSum->m_stTitle;
			
				pResultData->m_rgData[IPXSUM_SI_TYPE].m_stData =
					IpxTypeToCString(pIPXSum->m_dwIfType);
			}
				
			// Did we find an entry for this interface?
			if (pIPXSum)
			{
				pResultData->m_rgData[IPXSUM_SI_ADMINSTATE].m_stData =
					IpxAdminStateToCString(pIPXSum->m_dwAdminState);
				pResultData->m_rgData[IPXSUM_SI_ADMINSTATE].m_dwData =
					pIPXSum->m_dwAdminState;
				
				pResultData->m_rgData[IPXSUM_SI_OPERSTATE].m_stData =
					IpxOperStateToCString(pIPXSum->m_dwOperState);

				if (!pResultData->m_fClient)
				{
					FormatIpxNetworkNumber(szNumber,
										   DimensionOf(szNumber),
										   pIPXSum->m_network,
										   DimensionOf(pIPXSum->m_network));
					st = szNumber;

					pResultData->m_rgData[IPXSUM_SI_NETWORK].m_stData = st;
					memcpy(&pResultData->m_rgData[IPXSUM_SI_NETWORK].m_dwData,
						   pIPXSum->m_network, sizeof(DWORD));
					FillInNumberData(pResultData, IPXSUM_SI_PACKETS_SENT,
									 pIPXSum->m_dwSent);
					FillInNumberData(pResultData, IPXSUM_SI_PACKETS_RCVD,
									 pIPXSum->m_dwRcvd);
					FillInNumberData(pResultData, IPXSUM_SI_OUT_FILTERED,
									 pIPXSum->m_dwOutFiltered);
					FillInNumberData(pResultData, IPXSUM_SI_OUT_DROPPED,
									 pIPXSum->m_dwOutDropped);
					FillInNumberData(pResultData, IPXSUM_SI_IN_FILTERED,
									 pIPXSum->m_dwInFiltered);
					FillInNumberData(pResultData, IPXSUM_SI_IN_NOROUTES,
									 pIPXSum->m_dwInNoRoutes);
					FillInNumberData(pResultData, IPXSUM_SI_IN_DROPPED,
									 pIPXSum->m_dwInDropped);
				}
				else
					pResultData->m_rgData[IPXSUM_SI_NETWORK].m_dwData = (DWORD) -1;

				
			}
			
			// Force MMC to redraw the nodes
			spNode->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);

		}

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
		
	while (!IPXSumList.IsEmpty())
		delete IPXSumList.RemoveHead();
	return hr;
}

/*!--------------------------------------------------------------------------
	IPXSummaryHandler::GetClientInterfaceData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXSummaryHandler::GetClientInterfaceData(IPXSummaryListEntry *pClient,
											   IRtrMgrInfo *pRm)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	SPIInfoBase	spInfoBase;
	InfoBlock *	pIpxBlock;
	InfoBlock *	pWanBlock;
	HRESULT		hr = hrOK;
	BOOL		fSave = FALSE;
	
	pRm->GetInfoBase(NULL, NULL, NULL, &spInfoBase);
	if (spInfoBase == NULL)
	{
		CORg( CreateInfoBase(&spInfoBase) );
	}
	
	if (spInfoBase->GetBlock(IPX_INTERFACE_INFO_TYPE, &pIpxBlock, 0) != hrOK)
	{
		// We couldn't find the block, add it in
		IPX_IF_INFO	ipx;

		ipx.AdminState = ADMIN_STATE_ENABLED;
		ipx.NetbiosAccept = ADMIN_STATE_DISABLED;
		ipx.NetbiosDeliver = ADMIN_STATE_DISABLED;

		CORg( spInfoBase->AddBlock(IPX_INTERFACE_INFO_TYPE,
								   sizeof(ipx),
								   (PBYTE) &ipx,
								   1,
								   0) );
		CORg( spInfoBase->GetBlock(IPX_INTERFACE_INFO_TYPE,
								   &pIpxBlock, 0) );
		fSave = TRUE;
	}

	
	if (spInfoBase->GetBlock(IPXWAN_INTERFACE_INFO_TYPE, &pWanBlock, 0) != hrOK)
	{
		// We couldn't find the block, add it in
		IPXWAN_IF_INFO	wan;

		wan.AdminState = ADMIN_STATE_ENABLED;

		CORg( spInfoBase->AddBlock(IPXWAN_INTERFACE_INFO_TYPE,
								   sizeof(wan),
								   (PBYTE) &wan,
								   1,
								   0) );
		CORg( spInfoBase->GetBlock(IPXWAN_INTERFACE_INFO_TYPE,
								   &pWanBlock, 0) );
		fSave = TRUE;
	}	

	pClient->m_stTitle.LoadString(IDS_IPX_DIAL_IN_CLIENTS);
	pClient->m_dwAdminState = ((PIPX_IF_INFO)pIpxBlock->pData)->AdminState;
	pClient->m_dwIfType = ROUTER_IF_TYPE_CLIENT;
	pClient->m_dwOperState = (DWORD) -1;
	pClient->m_dwSent = (DWORD) -1;
	pClient->m_dwRcvd = (DWORD) -1;
	pClient->m_dwOutFiltered = (DWORD) -1;
	pClient->m_dwOutDropped = (DWORD) -1;
	pClient->m_dwInFiltered = (DWORD) -1;
	pClient->m_dwInNoRoutes = (DWORD) -1;
	pClient->m_dwInDropped = (DWORD) -1;

	if (fSave)
	{
		pRm->Save(NULL,			// pszMachine
				  NULL,			// hMachine
				  NULL,			// hTransport
				  NULL,			// pGlobalInfo
				  spInfoBase,	// pClientInfo
				  0);			// dwDeleteProtocolId
	}

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	IPXSummaryHandler::GetIPXSummaryData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT	IPXSummaryHandler::GetIPXSummaryData(ITFSNode *pThisNode,
											 IPXSummaryList *pIpxSumList)
{
	HRESULT	hr = hrOK;
	IPXConnection *	pIPXConn;
	IPX_MIB_GET_INPUT_DATA	MibGetInputData;
	DWORD				IfSize = sizeof(IPX_INTERFACE);
	PIPX_INTERFACE		pIpxIf = NULL;
	SPMprMibBuffer		spMib;
	IPXSummaryListEntry *pEntry = NULL;
	DWORD				dwErr;

	pIPXConn = GET_IPXSUMMARY_NODEDATA(pThisNode);

	// Enumerate through all of the interfaces and grab the data
	// Get the interface table
	MibGetInputData.TableId = IPX_INTERFACE_TABLE;
	dwErr = ::MprAdminMIBEntryGetFirst(pIPXConn->GetMibHandle(),
									   PID_IPX,
									   IPX_PROTOCOL_BASE,
									   &MibGetInputData,
									   sizeof(IPX_MIB_GET_INPUT_DATA),
									   (LPVOID *) &pIpxIf,
									   &IfSize);
	hr = HRESULT_FROM_WIN32(dwErr);
	spMib = (LPBYTE) pIpxIf;

	while (FHrSucceeded(hr))
	{
		pEntry = new IPXSummaryListEntry;

		pEntry->m_stId = pIpxIf->InterfaceName;

		memcpy(pEntry->m_network, pIpxIf->NetNumber,
			   sizeof(pEntry->m_network));
		
		pEntry->m_dwOperState = pIpxIf->IfStats.IfOperState;
		pEntry->m_dwSent = pIpxIf->IfStats.OutDelivers;
		pEntry->m_dwRcvd = pIpxIf->IfStats.InDelivers;
		pEntry->m_dwOutFiltered = pIpxIf->IfStats.OutFiltered;
		pEntry->m_dwOutDropped = pIpxIf->IfStats.OutDiscards;
		pEntry->m_dwInFiltered = pIpxIf->IfStats.InFiltered;
		pEntry->m_dwInNoRoutes = pIpxIf->IfStats.InNoRoutes;
		pEntry->m_dwInDropped = pIpxIf->IfStats.InDiscards;

		pIpxSumList->AddTail(pEntry);
		pEntry = NULL;

		// Get the next data set
		MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex =
			pIpxIf->InterfaceIndex;
		spMib.Free();
		pIpxIf = NULL;

		dwErr = ::MprAdminMIBEntryGetNext(pIPXConn->GetMibHandle(),
										  PID_IPX,
										  IPX_PROTOCOL_BASE,
										  &MibGetInputData,
										  sizeof(IPX_MIB_GET_INPUT_DATA),
										  (LPVOID *) &pIpxIf,
										  &IfSize);
		hr = HRESULT_FROM_WIN32(dwErr);
		spMib = (PBYTE) pIpxIf;
	}

//Error:
	if (pEntry)
		delete pEntry;

	if (!FHrSucceeded(hr) && (hr != HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)))
	{
		// clean out the list
		while (!pIpxSumList->IsEmpty())
			delete pIpxSumList->RemoveHead();
	}
	return hr;
}


/*!--------------------------------------------------------------------------
	IPXSummaryHandler::AddMenuItems
		Implementation of ITFSResultHandler::AddMenuItems
		Use this to add commands to the context menu of the blank areas
		of the result pane.
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXSummaryHandler::AddMenuItems(ITFSComponent *pComponent,
											  MMC_COOKIE cookie,
											  LPDATAOBJECT pDataObject,
											  LPCONTEXTMENUCALLBACK pCallback,
											  long *pInsertionAllowed)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT     hr = hrOK;
    SPITFSNode  spNode;

    m_spNodeMgr->FindNode(cookie, &spNode);
    
    // Call through to the regular OnAddMenuItems
    hr = OnAddMenuItems(spNode,
                        pCallback,
                        pDataObject,
                        CCT_RESULT,
                        TFS_COMPDATA_CHILD_CONTEXTMENU,
                        pInsertionAllowed);
    return hr;
}

/*!--------------------------------------------------------------------------
	IPXSummaryHandler::Command
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXSummaryHandler::Command(ITFSComponent *pComponent,
									   MMC_COOKIE cookie,
									   int nCommandID,
									   LPDATAOBJECT pDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	SPITFSNode	spNode;
	HRESULT		hr = hrOK;

    m_spNodeMgr->FindNode(cookie, &spNode);
    hr = OnCommand(spNode,
                   nCommandID,
                   CCT_RESULT,
                   pDataObject,
                   TFS_COMPDATA_CHILD_CONTEXTMENU);
	return hr;
}



/*!--------------------------------------------------------------------------
	IPXSummaryHandler::OnNewInterface
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXSummaryHandler::OnNewInterface()
{
	SPIRtrMgrInterfaceInfo	spRmIf;
	SPIInterfaceInfo		spIf;
	SPITFSNode				spNode;
	SPITFSNode				spSummaryNode;
	SPITFSNode				spNewNode;
	SPIComponentData		spComponentData;
	HRESULT					hr = hrOK;
	SPITFSNodeEnum			spEnumNode;
	BaseIPXResultNodeData *		pData;
	CWnd *					pWnd;
	CString					stIfTitle;

	m_spNodeMgr->FindNode(m_cookie, &spSummaryNode);
	spSummaryNode->Notify(TFS_NOTIFY_REMOVE_DELETED_NODES, 0);

	//
	// Retrieve the IPX router-manager info object
	// We already have this in m_spRtrMgrInfo
	//
	Assert(m_spRtrMgrInfo);

	// Display the UI for adding interfaces
	pWnd = CWnd::FromHandle(::FindMMCMainWindow());
	if (!AddRmInterfacePrompt(m_spRouterInfo, m_spRtrMgrInfo, &spRmIf, pWnd))
		return hrOK;

	//
	// Get the interface which we are adding IPX to.
	//
	CORg( m_spRouterInfo->FindInterface(spRmIf->GetInterfaceId(),
										&spIf) );
	Assert(spIf);

	//
	// Add the interface to the IPX router-manager
	//
	CORg( spIf->AddRtrMgrInterface(spRmIf, NULL /* pInfoBase */) );

	// We need to add an interface node (do it manually rather
	// than through the refresh mechanism).
	CORg( AddInterfaceNode(spSummaryNode, spIf, FALSE, &spNewNode) );

	// Show IPX interface configuration
	spComponentData.HrQuery(m_spTFSCompData);
	stIfTitle.Format(IDS_IPX_INTERFACE_TITLE, spIf->GetTitle());
	DoPropertiesOurselvesSinceMMCSucks(spNewNode,
									   spComponentData,
									   stIfTitle);

	
Error:
	return hr;
}
ImplementEmbeddedUnknown(IPXSummaryHandler, IRtrAdviseSink)

STDMETHODIMP IPXSummaryHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
	DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	InitPThis(IPXSummaryHandler, IRtrAdviseSink);
	SPITFSNode				spThisNode;
	SPITFSNode				spNode;
	SPITFSNodeEnum			spEnumNode;
	SPIEnumInterfaceInfo	spEnumIf;
	SPIInterfaceInfo		spIf;
	BOOL					fFound;
	BOOL					fPleaseAdd;
	BaseIPXResultNodeData *	pData;
	HRESULT					hr = hrOK;
	

	pThis->m_spNodeMgr->FindNode(pThis->m_cookie, &spThisNode);
	
	if (dwObjectType == ROUTER_OBJ_RmIf)
	{
		if (dwChangeType == ROUTER_CHILD_ADD)
		{
			// Enumerate through the list of interfaces looking for
			// the interfaces that have this protocol.  If we find
			// one, look for this interface in our list of nodes.
			spThisNode->GetEnum(&spEnumNode);

			CORg( pThis->m_spRouterInfo->EnumInterface(&spEnumIf) );

			spEnumIf->Reset();

			fPleaseAdd = FALSE;

			for (; spEnumIf->Next(1, &spIf, NULL) == hrOK; spIf.Release())
			{
				// Look for this interface in our list of nodes
				// If it's there than continue on
				fFound = FALSE;
				spEnumNode->Reset();
				spNode.Release();

				for (; spEnumNode->Next(1, &spNode, NULL) == hrOK; spNode.Release())
				{
					pData = GET_BASEIPXRESULT_NODEDATA(spNode);
					Assert(pData);
					ASSERT_BASEIPXRESULT_NODEDATA(pData);

					if (!pData->m_fClient && StriCmpW(pData->m_spIf->GetId(), spIf->GetId()) == 0)
					{
						fFound = TRUE;
						break;
					}
				}

				// If the interface was not found in the list of nodes,
				// then it is a candidate.  Now we have to see if the
				// interface supports this transport.
				if (!fFound && (spIf->FindRtrMgrInterface(pThis->m_spRtrMgrInfo->GetTransportId(), NULL) == hrOK))
				{
					// If this interface has this transport, and is NOT in
					// the current list of nodes then add this interface
					// to the UI
					pThis->AddInterfaceNode(spThisNode, spIf, FALSE, NULL);
					fPleaseAdd = TRUE;
				}
			}

            // If it's not expanded, then we haven't added
            // the dial-in clients node.    
            if (!pThis->m_bExpanded)
            {
                //$CLIENT: Add the client interface (setup default data)
                // the only thing that we can do in synchronize is to
                // get the Administrative status
                pThis->AddInterfaceNode(spThisNode, NULL, TRUE, NULL);

                fPleaseAdd = TRUE;
            }

			// Now that we have all of the nodes, update the data for
			// all of the nodes
			if (fPleaseAdd)
				pThis->SynchronizeNodeData(spThisNode);
			
            // Windows NT Bug : 288247
            // Set this here, so that we can avoid the nodes being
            // added in the OnExpand().
            pThis->m_bExpanded = TRUE;
		}
		else if (dwChangeType == ROUTER_CHILD_DELETE)
		{
			// Go through the list of nodes, if we cannot find the
			// node in the list of interfaces, delete the node
			spThisNode->GetEnum(&spEnumNode);
			spEnumNode->Reset();
			while (spEnumNode->Next(1, &spNode, NULL) == hrOK)
			{
				// Get the node data, look for the interface
				pData = GET_BASEIPXRESULT_NODEDATA(spNode);
				ASSERT_BASEIPXRESULT_NODEDATA(pData);
				
				//$CLIENT: if this is a client interface, we can't
				// delete the node
					
				if (!pData->m_fClient &&
					(LookupRtrMgrInterface(pThis->m_spRouterInfo,
										  pData->m_spIf->GetId(),
										  pThis->m_spRtrMgrInfo->GetTransportId(),
										  NULL) != hrOK))
				{
					// cannot find the interface, release this node!
					spThisNode->RemoveChild(spNode);
					spNode->Destroy();
				}
				spNode.Release();
				spIf.Release();
			}
			
		}
	}
	else if (dwChangeType == ROUTER_REFRESH)
	{
		if (ulConn == pThis->m_ulStatsConnId)
		{
//			pThis->m_IpxStats.PostRefresh();
		}
		else
		{
			pThis->SynchronizeNodeData(spThisNode);
		}
	}
	
Error:
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IPXSummaryHandler::OnResultShow
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXSummaryHandler::OnResultShow(ITFSComponent *pTFSComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	BOOL	bSelect = (BOOL) arg;
	HRESULT	hr = hrOK;
	SPIRouterRefresh	spRefresh;
	SPITFSNode	spNode;

	BaseContainerHandler::OnResultShow(pTFSComponent, cookie, arg, lParam);

	if (bSelect)
	{
		// Call synchronize on this node
		m_spNodeMgr->FindNode(cookie, &spNode);
		if (spNode)
			SynchronizeNodeData(spNode);
	}

	// Un/Register for refresh advises
	if (m_spRouterInfo)
		m_spRouterInfo->GetRefreshObject(&spRefresh);

	if (spRefresh)
	{
		if (bSelect)
		{
			if (m_ulRefreshConnId == 0)
				spRefresh->AdviseRefresh(&m_IRtrAdviseSink, &m_ulRefreshConnId, 0);

			if (m_ulStatsConnId == 0)
				spRefresh->AdviseRefresh(&m_IRtrAdviseSink, &m_ulStatsConnId, 0);

		}
		else
		{
			if (m_ulRefreshConnId)
				spRefresh->UnadviseRefresh(m_ulRefreshConnId);
			m_ulRefreshConnId = 0;

			// We do not clean up the stats refresh on not show, since the
			// dialogs may still be up.
		}
	}
	
	return hr;
}

/*!--------------------------------------------------------------------------
	IPXSummaryHandler::CompareItems
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int) IPXSummaryHandler::CompareItems(
								ITFSComponent * pComponent,
								MMC_COOKIE cookieA,
								MMC_COOKIE cookieB,
								int nCol)
{
	// Get the strings from the nodes and use that as a basis for
	// comparison.
	SPITFSNode	spNode;
	SPITFSResultHandler	spResult;

	m_spNodeMgr->FindNode(cookieA, &spNode);
	spNode->GetResultHandler(&spResult);
	return spResult->CompareItems(pComponent, cookieA, cookieB, nCol);
}


/*---------------------------------------------------------------------------
	Class: IPXSummaryInterfaceHandler
 ---------------------------------------------------------------------------*/

IPXSummaryInterfaceHandler::IPXSummaryInterfaceHandler(ITFSComponentData *pCompData)
	: BaseIPXResultHandler(pCompData, COLUMNS_SUMMARY),
	m_ulConnId(0)
{
 	m_rgButtonState[MMC_VERB_PROPERTIES_INDEX] = ENABLED;
	m_bState[MMC_VERB_PROPERTIES_INDEX] = TRUE;
	
 	m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
	m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;
	
	m_verbDefault = MMC_VERB_PROPERTIES;
}

static const DWORD s_rgInterfaceImageMap[] =
	 {
	 ROUTER_IF_TYPE_HOME_ROUTER,	IMAGE_IDX_WAN_CARD,
	 ROUTER_IF_TYPE_FULL_ROUTER,	IMAGE_IDX_WAN_CARD,
	 ROUTER_IF_TYPE_CLIENT,			IMAGE_IDX_WAN_CARD,
	 ROUTER_IF_TYPE_DEDICATED,		IMAGE_IDX_LAN_CARD,
	 ROUTER_IF_TYPE_INTERNAL,		IMAGE_IDX_LAN_CARD,
	 ROUTER_IF_TYPE_LOOPBACK,		IMAGE_IDX_LAN_CARD,
	 -1,							IMAGE_IDX_WAN_CARD,	// sentinel value
	 };

/*!--------------------------------------------------------------------------
	IPXSummaryInterfaceHandler::ConstructNode
		Initializes the Domain node (sets it up).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXSummaryInterfaceHandler::ConstructNode(ITFSNode *pNode, IInterfaceInfo *pIfInfo, IPXConnection *pIPXConn)
{
	HRESULT			hr = hrOK;
	int				i;
	
	if (pNode == NULL)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Find the right image index for this type of node
		if (pIfInfo)
		{
			for (i=0; i<DimensionOf(s_rgInterfaceImageMap); i+=2)
			{
				if ((pIfInfo->GetInterfaceType() == s_rgInterfaceImageMap[i]) ||
					(-1 == s_rgInterfaceImageMap[i]))
					break;
			}
		}
		else
		{
			i = 2;	// if no interface, assume this is a client interface
		}

		// We allow deleting of demand-dial nodes only (not on
		// interfaces or the client node).
		if (pIfInfo &&
			(pIfInfo->GetInterfaceType() == ROUTER_IF_TYPE_FULL_ROUTER))
		{
			m_rgButtonState[MMC_VERB_DELETE_INDEX] = ENABLED;
			m_bState[MMC_VERB_DELETE_INDEX] = TRUE;
		}
		
		pNode->SetData(TFS_DATA_IMAGEINDEX, s_rgInterfaceImageMap[i+1]);
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, s_rgInterfaceImageMap[i+1]);
		
		pNode->SetData(TFS_DATA_SCOPEID, 0);

		pNode->SetData(TFS_DATA_COOKIE, reinterpret_cast<DWORD_PTR>(pNode));

		//$ Review: kennt, what are the different type of interfaces
		// do we distinguish based on the same list as above? (i.e. the
		// one for image indexes).
		pNode->SetNodeType(&GUID_IPXSummaryInterfaceNodeType);

		BaseIPXResultNodeData::Init(pNode, pIfInfo, pIPXConn);
		//now load the info base for this object
		hr = LoadInfoBase(pIPXConn);
	}
	COM_PROTECT_CATCH
	return hr;
}

/*!--------------------------------------------------------------------------
	IPXSummaryInterfaceHandler::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXSummaryInterfaceHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		CORg( CreateDataObjectFromInterfaceInfo(m_spInterfaceInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}


/*!--------------------------------------------------------------------------
	IPXSummaryInterfaceHandler::OnCreateDataObject
		Implementation of ITFSResultHandler::OnCreateDataObject
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXSummaryInterfaceHandler::OnCreateDataObject(ITFSComponent *pComp, MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		CORg( CreateDataObjectFromInterfaceInfo(m_spInterfaceInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}



/*!--------------------------------------------------------------------------
	IPXSummaryInterfaceHandler::RefreshInterface
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IPXSummaryInterfaceHandler::RefreshInterface(MMC_COOKIE cookie)
{
	SPITFSNode	spNode;

	m_spNodeMgr->FindNode(cookie, &spNode);
	
	// Can't do it for a single node at this time, just refresh the
	// whole thing.
	ForwardCommandToParent(spNode, IDS_MENU_SYNC,
						   CCT_RESULT, NULL, 0);
}


/*!--------------------------------------------------------------------------
	IPXSummaryInterfaceHandler::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXSummaryInterfaceHandler::Init(IRtrMgrInfo *pRm, IInterfaceInfo *pIfInfo, ITFSNode *pParent)
{
	m_spRm.Set(pRm);
	m_spInterfaceInfo.Set(pIfInfo);
	if (pRm)
		pRm->GetParentRouterInfo(&m_spRouterInfo);


	BaseIPXResultHandler::Init(pIfInfo, pParent);
	return hrOK;
}


/*!--------------------------------------------------------------------------
	IPXSummaryInterfaceHandler::DestroyResultHandler
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXSummaryInterfaceHandler::DestroyResultHandler(MMC_COOKIE cookie)
{
	m_spInterfaceInfo.Release();
	m_spRouterInfo.Release();
	BaseIPXResultHandler::DestroyResultHandler(cookie);
	return hrOK;
}


/*---------------------------------------------------------------------------
	This is the list of commands that will show up for the result pane
	nodes.
 ---------------------------------------------------------------------------*/
static const SRouterNodeMenu	s_rgIfMenu[] =
{
	// Add items that go at the top here
	{ IDS_MENU_IPX_IF_ENABLE, IPXSummaryInterfaceHandler::GetEnableFlags,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },

	{ IDS_MENU_IPX_IF_DISABLE, IPXSummaryInterfaceHandler::GetDisableFlags,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },

	{ IDS_MENU_SEPARATOR, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },

	{ IDS_MENU_UPDATE_ROUTES, IPXSummaryInterfaceHandler::GetUpdateRoutesFlags,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },

};

/*!--------------------------------------------------------------------------
	IPXSummaryInterfaceHandler::AddMenuItems
		Implementation of ITFSResultHandler::AddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXSummaryInterfaceHandler::AddMenuItems(
	ITFSComponent *pComponent,
	MMC_COOKIE cookie,
	LPDATAOBJECT lpDataObject, 
	LPCONTEXTMENUCALLBACK pContextMenuCallback, 
	long *pInsertionAllowed)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = S_OK;
	ULONG	ulFlags;
	UINT			i;
	CString		stMenu;
	SPITFSNode	spNode;
	IPXSummaryInterfaceHandler::SMenuData * pmenuData = new IPXSummaryInterfaceHandler::SMenuData;
		
	COM_PROTECT_TRY
	{
		m_spNodeMgr->FindNode(cookie, &spNode);
		
		// Now go through and add our menu items
		pmenuData->m_spNode.Set(spNode);
        pmenuData->m_spInterfaceInfo.Set(m_spInterfaceInfo);
        //Reload the infobase in case it has changed
        LoadInfoBase(NULL);
		pmenuData->m_spInfoBaseCopy = m_spInfoBase;
		hr = AddArrayOfMenuItems(spNode, s_rgIfMenu,
								 DimensionOf(s_rgIfMenu),
								 pContextMenuCallback,
								 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(pmenuData));
        
	}
	COM_PROTECT_CATCH;
	
	return hr;
}

ULONG IPXSummaryInterfaceHandler::GetUpdateRoutesFlags(const SRouterNodeMenu *pMenuData, INT_PTR pUserData)
{
   DWORD dwIfType;
   SMenuData *  pData = reinterpret_cast<SMenuData *>(pUserData);

   if (pData->m_spInterfaceInfo)
	   dwIfType = pData->m_spInterfaceInfo->GetInterfaceType();
   else
	   dwIfType = ROUTER_IF_TYPE_INTERNAL;

   if ((dwIfType == ROUTER_IF_TYPE_LOOPBACK) ||
      (dwIfType == ROUTER_IF_TYPE_INTERNAL))
      return 0xFFFFFFFF;
   else
      return 0;
}


ULONG IPXSummaryInterfaceHandler::GetEnableFlags(const SRouterNodeMenu *pMenuData, INT_PTR pUserData)
{
	SMenuData *  pData = reinterpret_cast<SMenuData *>(pUserData);
	//BOOL bInterfaceIsEnabled = pData->m_spInterfaceInfo->IsInterfaceEnabled();


    IPX_IF_INFO *   pIpxIf = NULL;

    (pData->m_spInfoBaseCopy)->GetData(IPX_INTERFACE_INFO_TYPE, 0, (BYTE **) &pIpxIf);

	if ( pIpxIf )
		return (pIpxIf->AdminState == ADMIN_STATE_DISABLED ? 0: 0xFFFFFFFF );
	else
		return 0xFFFFFFFF;

    //if the interface is enabled then dont add the enable menu item
	//if (pData->m_spInterfaceInfo)
	   //return pData->m_spInterfaceInfo->IsInterfaceEnabled() ? 0xFFFFFFFF : 0;
	//else
	   //return 0xFFFFFFFF;
}

ULONG IPXSummaryInterfaceHandler::GetDisableFlags(const SRouterNodeMenu *pMenuData, INT_PTR pUserData)
{
	SMenuData *  pData = reinterpret_cast<SMenuData *>(pUserData);
    IPX_IF_INFO *   pIpxIf = NULL;

    (pData->m_spInfoBaseCopy)->GetData(IPX_INTERFACE_INFO_TYPE, 0, (BYTE **) &pIpxIf);

	if ( pIpxIf )
		return (pIpxIf->AdminState == ADMIN_STATE_ENABLED ? 0: 0xFFFFFFFF );
	else
		return 0xFFFFFFFF;

/*
	SMenuData *  pData = reinterpret_cast<SMenuData *>(pUserData);
	BOOL bInterfaceIsEnabled = pData->m_spInterfaceInfo->IsInterfaceEnabled();

	ATLASSERT("This is wrong!");
      
	if (pData->m_spInterfaceInfo)
		return pData->m_spInterfaceInfo->IsInterfaceEnabled() ? 0: 0xFFFFFFFF;
	else
		return 0xFFFFFFFF;
*/
}

/*!--------------------------------------------------------------------------
	IPXSummaryInterfaceHandler::Command
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXSummaryInterfaceHandler::Command(ITFSComponent *pComponent,
									   MMC_COOKIE cookie,
									   int nCommandID,
									   LPDATAOBJECT pDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT		hr = hrOK;

	switch (nCommandID)
	{
		case IDS_MENU_UPDATE_ROUTES:
			hr = OnUpdateRoutes(cookie);
			break;
        case IDS_MENU_IPX_IF_ENABLE:
            hr = OnEnableDisableIPX ( TRUE, cookie );
            break;
        case IDS_MENU_IPX_IF_DISABLE:
            hr = OnEnableDisableIPX ( FALSE, cookie );
            break;
        
	}

	if (!FHrSucceeded(hr))
		DisplayTFSErrorMessage(NULL);
    else
        RefreshInterface(cookie);
	return hr;
}




HRESULT IPXSummaryInterfaceHandler::SaveChanges()
{
    HRESULT     hr = hrOK;
    HANDLE      hTransport = NULL, hInterface = NULL;
    DWORD       dwErr = NO_ERROR;

    // By this time each page should have written its information out
    // to the infobase

    if (m_spInfoBase)
    {
        if (m_bClientInfoBase)
        {
            Assert(m_spRm);
            CORg( m_spRm->Save(m_spRm->GetMachineName(), 0, 0, NULL,
                         m_spInfoBase, 0));
        }
        else
        {
            // For IPX, we need to have the protocol information in the
            // infobase, BEFORE we add the interface to the running router.

            Assert(m_spRmIf);

            //
            // Need to set the infobase back to the registry
            //
            m_pIPXConn->DisconnectFromConfigServer();

            CWRg( ::MprConfigInterfaceGetHandle(
                                                m_pIPXConn->GetConfigHandle(),
                                                (LPTSTR) m_spRmIf->GetInterfaceId(),
                                                &hInterface) );

            // Get the transport handle
            dwErr = ::MprConfigInterfaceTransportGetHandle(
                m_pIPXConn->GetConfigHandle(),
                hInterface,// need hInterface
                PID_IPX,
                &hTransport);
            if (dwErr != ERROR_SUCCESS)
            {
                RtrMgrInterfaceCB   rmIfCB;

                m_spRmIf->CopyCB(&rmIfCB);

                dwErr = ::MprConfigInterfaceTransportAdd(
                    m_pIPXConn->GetConfigHandle(),
                    hInterface,
                    m_spRmIf->GetTransportId(),
                    rmIfCB.szId,
                    NULL, 0, &hTransport);
            }
            CWRg( dwErr );

            m_spRmIf->SetInfoBase(NULL, hInterface, hTransport, m_spInfoBase);


            //
            // Reload the infobase (to get the new data before calling
            // the final save).
            //
            m_spInfoBase.Release();
            m_spRmIf->GetInfoBase(NULL, hInterface, hTransport, &m_spInfoBase);

            //
            // Perform the final save (since we are passing in a non-NULL
            // infobase pointer) this will commit the information back
            // to the running router.
            //
            CORg( m_spRmIf->Save(m_spInterfaceInfo->GetMachineName(),
                           NULL, hInterface, hTransport, m_spInfoBase, 0));
        }

    }


Error:
	return hr;

}

HRESULT IPXSummaryInterfaceHandler::LoadInfoBase( IPXConnection *pIPXConn)
{
    Assert(pIPXConn);

    HRESULT         hr = hrOK;
    HANDLE          hTransport = NULL;
    LPCOLESTR       pszInterfaceId = NULL;
    SPIInfoBase     spInfoBase;
    BYTE *          pDefault;
    int             cBlocks = 0;
    if ( pIPXConn )
    {
        m_pIPXConn = pIPXConn;
        pIPXConn->AddRef();
    }

    // If configuring the client-interface, load the client-interface info,
    // otherwise, retrieve the interface being configured and load
    // its info.

    // The client interface doesn't have an ID
    if (m_spInterfaceInfo)
        pszInterfaceId = m_spInterfaceInfo->GetId();


    if ((pszInterfaceId == NULL) || (StrLenW(pszInterfaceId) == 0))
    {
        // Get the transport handle
        CWRg( ::MprConfigTransportGetHandle(m_pIPXConn->GetConfigHandle(),
                                            PID_IPX,
                                            &hTransport) );

        // Load the client interface info
        CORg( m_spRm->GetInfoBase(m_pIPXConn->GetConfigHandle(),
                                  hTransport,
                                  NULL,
                                  &spInfoBase) );
        m_bClientInfoBase = TRUE;
    }
    else
    {
        m_spRmIf.Release();

        CORg( m_spInterfaceInfo->FindRtrMgrInterface(PID_IPX,
            &m_spRmIf) );

        //
        //$ Opt: This should be made into a sync call rather
        // than a Load.

        //
        // Reload the information for this router-manager interface
        // This call could fail for valid reasons (if we are creating
        // a new interface, for example).
        //
        m_spRmIf->Load(m_spInterfaceInfo->GetMachineName(), NULL, NULL, NULL);

        //
        // The parameters are all NULL so that we can use the
        // default RPC handles.
        //
        m_spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase);
        m_bClientInfoBase = FALSE;
    }

    if (!spInfoBase)
    {
        // No info was found for the inteface
        // allocate a new InfoBase instead
        CORg( CreateInfoBase(&spInfoBase) );
    }

	m_spInfoBase.Release();
    CORg( AddIpxPerInterfaceBlocks(m_spInterfaceInfo, spInfoBase) );

    m_spInfoBase = spInfoBase.Transfer();

Error:
    return hr;
}

HRESULT IPXSummaryInterfaceHandler::OnEnableDisableIPX(BOOL fEnable, 
                                                        MMC_COOKIE cookie)
{	
    HRESULT hr = hrOK;
    IPX_IF_INFO *   pIpxIf = NULL;
    CORg( m_spInfoBase->GetData(IPX_INTERFACE_INFO_TYPE, 0, (BYTE **) &pIpxIf) );	
    pIpxIf->AdminState = (fEnable ? ADMIN_STATE_ENABLED: ADMIN_STATE_DISABLED);
	//now save the change here
	hr = SaveChanges();
	
Error:
    return hr;

}
/*!--------------------------------------------------------------------------
	IPXSummaryInterfaceHandler::HasPropertyPages
		- 
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXSummaryInterfaceHandler::HasPropertyPages 
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	return hrTrue;
}

/*!--------------------------------------------------------------------------
	IPXSummaryInterfaceHandler::CreatePropertyPages
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXSummaryInterfaceHandler::CreatePropertyPages
(
	ITFSNode *				pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject, 
	LONG_PTR					handle, 
	DWORD					dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT		hr = hrOK;
	IPXSummaryInterfaceProperties *	pProperties = NULL;
	SPIComponentData spComponentData;
	CString		stTitle;

	CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

	if (m_spInterfaceInfo)
		stTitle.Format(IDS_IPXSUMMARY_IF_PAGE_TITLE,
					   m_spInterfaceInfo->GetTitle());
	else
		stTitle.LoadString(IDS_IPXSUMMARY_CLIENT_IF_PAGE_TITLE);
	
	pProperties = new IPXSummaryInterfaceProperties(pNode, spComponentData,
		m_spTFSCompData, stTitle);

	CORg( pProperties->Init(m_spRm, m_spInterfaceInfo) );

	if (lpProvider)
		hr = pProperties->CreateModelessSheet(lpProvider, handle);
	else
		hr = pProperties->DoModelessSheet();

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	IPXSummaryInterfaceHandler::CreatePropertyPages
		Implementation of ResultHandler::CreatePropertyPages
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IPXSummaryInterfaceHandler::CreatePropertyPages
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPPROPERTYSHEETCALLBACK	lpProvider, 
	LPDATAOBJECT			pDataObject, 
	LONG_PTR					handle
)
{
	// Forward this call onto the NodeHandler::CreatePropertyPages
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT	hr = hrOK;
	SPITFSNode	spNode;

	Assert( m_spNodeMgr );

	CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

	// Call the ITFSNodeHandler::CreatePropertyPages
	hr = CreatePropertyPages(spNode, lpProvider, pDataObject, handle, 0);
	
Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	IPXSummaryInterfaceHandler::OnResultDelete
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXSummaryInterfaceHandler::OnResultDelete(ITFSComponent *pComponent,
	LPDATAOBJECT pDataObject,
	MMC_COOKIE cookie,
	LPARAM arg,
	LPARAM param)
{
	return OnRemoveInterface();
}

/*!--------------------------------------------------------------------------
	IPXSummaryInterfaceHandler::OnRemoveInterface
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXSummaryInterfaceHandler::OnRemoveInterface()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	// Prompt the user to make certain that IPX should be removed
	// from this interface

	SPIRouterInfo	spRouterInfo;
	HRESULT			hr = hrOK;
	SPITFSNodeHandler	spHandler;

	// Addref this node so that it won't get deleted before we're out
	// of this function
	spHandler.Set(this);
	
	if (AfxMessageBox(IDS_PROMPT_VERIFY_REMOVE_INTERFACE, MB_YESNO|MB_DEFBUTTON2) == IDNO)
		return HRESULT_FROM_WIN32(ERROR_CANCELLED);

	// Remove IPX from the interface
	hr = m_spInterfaceInfo->DeleteRtrMgrInterface(PID_IPX, TRUE);

	if (!FHrSucceeded(hr))
	{
		AfxMessageBox(IDS_ERR_DELETE_INTERFACE);
	}
	return hr;

}

HRESULT IPXSummaryInterfaceHandler::OnUpdateRoutes(MMC_COOKIE cookie)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   BaseIPXResultNodeData *  pData;
   SPITFSNode     spNode;
   DWORD		dwErr = ERROR_SUCCESS;
   HRESULT        hr = hrOK;
   CString        stServiceDesc;

   m_spNodeMgr->FindNode(cookie, &spNode);

   pData = GET_BASEIPXRESULT_NODEDATA(spNode);
   ASSERT_BASEIPXRESULT_NODEDATA(pData);
   
   // Check to see if the service is started, if it isn't
   // start it

   CORg( IsRouterServiceRunning(m_spInterfaceInfo->GetMachineName(), NULL) );

   if (hr != hrOK)
   {
      // Ask the user if they want to start the service
      if (AfxMessageBox(IDS_PROMPT_SERVICESTART, MB_YESNO) != IDYES)
         CWRg( ERROR_CANCELLED );

      // Else start the service
      stServiceDesc.LoadString(IDS_RRAS_SERVICE_DESC);
      dwErr = TFSStartService(m_spInterfaceInfo->GetMachineName(), c_szRouter, stServiceDesc);
      if (dwErr != NO_ERROR)
      {
         CWRg( dwErr );
      }
   }


   // Update the routes

   CWRg( UpdateRoutes(m_spInterfaceInfo->GetMachineName(),
					  m_spInterfaceInfo->GetId(),
					  PID_IPX,
					  NULL) );

Error:
	AddRasErrorMessage(hr);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\sumprop.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    sumprop.h
//
// History:
//	07/22/97	Kenn M. Takara			Created.
//
//	IPX Summary property sheet and property pages
//
//============================================================================


#ifndef _SUMPROP_H
#define _SUMPROP_H

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _RTRSHEET_H
#include "rtrsheet.h"
#endif

#include "remras.h"
#include "rrasutil.h"


/*---------------------------------------------------------------------------
	Forward declarations
 ---------------------------------------------------------------------------*/
class IPXConnection;
class IPXSummaryInterfaceProperties;
class IPXSummaryProperties;

/*---------------------------------------------------------------------------
	class:	IPXSummaryIfPageGeneral
	This class handles the General page for IPX Summary interface prop sheet.
 ---------------------------------------------------------------------------*/

class IPXSummaryIfPageGeneral :
    public RtrPropertyPage
{
public:
	IPXSummaryIfPageGeneral(UINT nIDTemplate, UINT nIDCaption = 0)
			: RtrPropertyPage(nIDTemplate, nIDCaption),
			m_pIPXConn(NULL)
	{};

	~IPXSummaryIfPageGeneral();

	HRESULT	Init(IInterfaceInfo *pIfInfo, IPXConnection *pIpxConn,
				IPXSummaryInterfaceProperties * pIPXPropSheet);

protected:

	// Override the OnApply() so that we can grab our data from the
	// controls in the dialog.
	virtual BOOL OnApply();

	void OnFiltersConfig(DWORD dwFilterDirection);

	SPIInterfaceInfo m_spIf;
	IPXConnection *	m_pIPXConn;
	IPXSummaryInterfaceProperties *	m_pIPXPropSheet;

	//{{AFX_VIRTUAL(IPXSummaryIfPageGeneral)
	protected:
	virtual VOID	DoDataExchange(CDataExchange *pDX);
	//}}AFX_VIRTUAL

	//{{AFX_MSG(IPXSummaryIfPageGeneral)
	virtual BOOL	OnInitDialog();
	//}}AFX_MSG
	
	//{{AFX_MSG(IPXSummaryIfPageGeneral
	afx_msg	void	OnChangeButton();
	afx_msg void    OnChangeAdminButton();
	afx_msg void	OnInputFilters();
	afx_msg void	OnOutputFilters();
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};

/*---------------------------------------------------------------------------
	class:	IPXSummaryIfPageConfig
	This class handles the General page for IPX Summary interface prop sheet.
 ---------------------------------------------------------------------------*/

class IPXSummaryIfPageConfig :
    public RtrPropertyPage
{
public:
	IPXSummaryIfPageConfig(UINT nIDTemplate, UINT nIDCaption = 0)
			: RtrPropertyPage(nIDTemplate, nIDCaption),
			m_pIPXConn(NULL)
	{};

	~IPXSummaryIfPageConfig();

	HRESULT	Init(IInterfaceInfo *pIfInfo, IPXConnection *pIpxConn,
				IPXSummaryInterfaceProperties * pIPXPropSheet);

	virtual BOOL OnPropertyChange(BOOL bScopePane, LONG_PTR* pChangeMask); // execute from main thread
	
protected:

	// Override the OnApply() so that we can grab our data from the
	// controls in the dialog.
	virtual BOOL OnApply();

	SPIInterfaceInfo m_spIf;
	IPXConnection *	m_pIPXConn;
	IPXSummaryInterfaceProperties *	m_pIPXPropSheet;

	DWORD					m_dwNetNumber;
	BOOL					m_fNetNumberChanged;
	SPIRemoteRouterConfig	m_spRemote;
	HRESULT					m_hrRemote;		// error code of remote call

	//{{AFX_VIRTUAL(IPXSummaryIfPageConfig)
	protected:
	virtual VOID	DoDataExchange(CDataExchange *pDX);
	virtual VOID	OnChangeEdit();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(IPXSummaryIfPageConfig)
	virtual BOOL	OnInitDialog();
	//}}AFX_MSG
	
	//{{AFX_MSG(IPXSummaryIfPageConfig
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};



/*---------------------------------------------------------------------------
	Class:	IPXSummaryInterfaceProperties

	This is the property sheet support class for the properties page of
	the nodes that appear in the IPX summary node.
 ---------------------------------------------------------------------------*/

class IPXSummaryInterfaceProperties :
	public RtrPropertySheet
{
public:
	IPXSummaryInterfaceProperties(ITFSNode *pNode,
								 IComponentData *pComponentData,
								 ITFSComponentData *pTFSCompData,
								 LPCTSTR pszSheetName,
								 CWnd *pParent = NULL,
								 UINT iPage=0,
								 BOOL fScopePane = TRUE);
	~IPXSummaryInterfaceProperties();

	HRESULT	Init(IRtrMgrInfo *pRm, IInterfaceInfo *pInterfaceInfo);

	virtual BOOL SaveSheetData();
	virtual void CancelSheetData();

	// Loads the infobase for this interface.
	HRESULT	LoadInfoBase(IPXConnection *pIPXConn);
	HRESULT GetInfoBase(IInfoBase **ppInfoBase);

	BOOL	m_bNewInterface;
	
protected:
	SPIInterfaceInfo		m_spIf;
	SPIRtrMgrInfo			m_spRm;
	SPIRtrMgrInterfaceInfo	m_spRmIf;
	IPXSummaryIfPageGeneral	m_pageGeneral;
	IPXSummaryIfPageConfig	m_pageConfig;
	SPITFSNode				m_spNode;
	SPIInfoBase				m_spInfoBase;
	BOOL					m_bClientInfoBase;

	IPXConnection *			m_pIPXConn;
};


/*---------------------------------------------------------------------------
	Class:	IPXSummaryPageGeneral

	This class handles the General page of the IPX Summary prop sheet.
 ---------------------------------------------------------------------------*/
class IPXSummaryPageGeneral :
   public RtrPropertyPage
{
public:
	IPXSummaryPageGeneral(UINT nIDTemplate, UINT nIDCaption = 0)
			: RtrPropertyPage(nIDTemplate, nIDCaption)
	{};

	HRESULT	Init(IPXSummaryProperties * pIPXPropSheet);

protected:
	void SetLogLevelButtons(DWORD dwLogLevel);
	DWORD QueryLogLevelButtons();

	// Override the OnApply() so that we can grab our data from the
	// controls in the dialog.
	virtual BOOL OnApply();

	IPXSummaryProperties *	m_pIPXPropSheet;

	//{{AFX_VIRTUAL(IPXSummaryPageGeneral)
	protected:
	virtual VOID	DoDataExchange(CDataExchange *pDX);
	//}}AFX_VIRTUAL

	//{{AFX_MSG(IPXSummaryPageGeneral)
	virtual BOOL	OnInitDialog();
	//}}AFX_MSG
	
	//{{AFX_MSG(IPXSummaryPageGeneral
	afx_msg	void	OnButtonClicked();
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};


/*---------------------------------------------------------------------------
	Class:	IPXSummaryProperties

	This is the property sheet support class for the properties page of
	the IPX Summary node.
 ---------------------------------------------------------------------------*/

class IPXSummaryProperties :
	public RtrPropertySheet
{
public:
	IPXSummaryProperties(ITFSNode *pNode,
								 IComponentData *pComponentData,
								 ITFSComponentData *pTFSCompData,
								 LPCTSTR pszSheetName,
								 CWnd *pParent = NULL,
								 UINT iPage=0,
								 BOOL fScopePane = TRUE);

	HRESULT	Init(IRtrMgrInfo *pRm);

	virtual BOOL SaveSheetData();

	// Loads the infobase for this interface.
	HRESULT	LoadInfoBase(IPXConnection *pIPXConn);
	HRESULT GetInfoBase(IInfoBase **ppInfoBase);
	
protected:
	SPIRtrMgrInfo			m_spRm;
	IPXSummaryPageGeneral	m_pageGeneral;
	SPITFSNode				m_spNode;
	SPIInfoBase				m_spInfoBase;
	BOOL					m_bClientInfoBase;
};



#endif _SUMPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprinc\filter.h ===
#ifndef _FILTER_H_
#define _FILTER_H_

#define FILTER_INBOUND  0
#define FILTER_OUTBOUND 1

DWORD APIENTRY
MprUIFilterConfig(
    IN  CWnd*       pParent,
    IN  LPCWSTR     pwsMachineName,
    IN  LPCWSTR     pwsInterfaceName,
    IN  DWORD       dwTransportId,
    IN  DWORD       dwFilterType    // FILTER_INBOUND, FILTER_OUTBOUND
    ); 

#endif // _FILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprinc\info.h ===
#ifndef _INFO_H_
#define _INFO_H_

#include "router.h"

/*!--------------------------------------------------------------------------
	Smart pointers for the various control blocks.
 ---------------------------------------------------------------------------*/
DeclareSP(RouterCB, RouterCB)
DeclareSP(RtrMgrCB, RtrMgrCB)
DeclareSP(RtrMgrProtocolCB, RtrMgrProtocolCB)
DeclareSP(InterfaceCB, InterfaceCB)
DeclareSP(RtrMgrInterfaceCB, RtrMgrInterfaceCB)
DeclareSP(RtrMgrProtocolInterfaceCB, RtrMgrProtocolInterfaceCB)

/*---------------------------------------------------------------------------
	Smart pointers for the set of enumerations and objects
 ---------------------------------------------------------------------------*/
typedef ComSmartPointer<IEnumRtrMgrCB, &IID_IEnumRtrMgrCB> SPIEnumRtrMgrCB;

typedef ComSmartPointer<IEnumRtrMgrProtocolCB, &IID_IEnumRtrMgrProtocolCB> SPIEnumRtrMgrProtocolCB;

typedef ComSmartPointer<IEnumInterfaceCB, &IID_IEnumInterfaceCB> SPIEnumInterfaceCB;

typedef ComSmartPointer<IEnumRtrMgrInterfaceCB, &IID_IEnumRtrMgrInterfaceCB> SPIEnumRtrMgrInterfaceCB;

typedef ComSmartPointer<IEnumRtrMgrProtocolInterfaceCB, &IID_IEnumRtrMgrProtocolInterfaceCB> SPIEnumRtrMgrProtocolInterfaceCB;

typedef ComSmartPointer<IRtrMgrProtocolInfo, &IID_IRtrMgrProtocolInfo> SPIRtrMgrProtocolInfo;

typedef ComSmartPointer<IEnumRtrMgrProtocolInfo, &IID_IEnumRtrMgrProtocolInfo> SPIEnumRtrMgrProtocolInfo;

typedef ComSmartPointer<IRtrMgrInfo, &IID_IRtrMgrInfo> SPIRtrMgrInfo;

typedef ComSmartPointer<IEnumRtrMgrInfo, &IID_IEnumRtrMgrInfo> SPIEnumRtrMgrInfo;

typedef ComSmartPointer<IRtrMgrProtocolInterfaceInfo, &IID_IRtrMgrProtocolInterfaceInfo> SPIRtrMgrProtocolInterfaceInfo;

typedef ComSmartPointer<IEnumRtrMgrProtocolInterfaceInfo, &IID_IEnumRtrMgrProtocolInterfaceInfo> SPIEnumRtrMgrProtocolInterfaceInfo;

typedef ComSmartPointer<IRtrMgrInterfaceInfo, &IID_IRtrMgrInterfaceInfo> SPIRtrMgrInterfaceInfo;

typedef ComSmartPointer<IEnumRtrMgrInterfaceInfo, &IID_IEnumRtrMgrInterfaceInfo> SPIEnumRtrMgrInterfaceInfo;

typedef ComSmartPointer<IInterfaceInfo, &IID_IInterfaceInfo> SPIInterfaceInfo;

typedef ComSmartPointer<IEnumInterfaceInfo, &IID_IEnumInterfaceInfo> SPIEnumInterfaceInfo;

typedef ComSmartPointer<IRouterInfo, &IID_IRouterInfo> SPIRouterInfo;
typedef ComSmartPointer<IRouterRefresh, &IID_IRouterRefresh> SPIRouterRefresh;
typedef ComSmartPointer<IRouterRefreshModify, &IID_IRouterRefreshModify> SPIRouterRefreshModify;


/*---------------------------------------------------------------------------
	Creation APIs
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT)	CreateRouterInfo(IRouterInfo **ppRouterInfo, HWND hWndSync, LPCWSTR szMachine);
TFSCORE_API(HRESULT)	CreateInterfaceInfo(IInterfaceInfo **ppInterfaceInfo,
											LPCWSTR pszInterfaceId,
											DWORD dwInterfaceType);
TFSCORE_API(HRESULT)	CreateRtrMgrInterfaceInfo(
							IRtrMgrInterfaceInfo **ppRmIfInfo,
							LPCWSTR pszId,
							DWORD dwTransportId,
							LPCWSTR pszInterfaceId,
							DWORD dwInterfaceType);
TFSCORE_API(HRESULT)	CreateRtrMgrProtocolInterfaceInfo(
							IRtrMgrProtocolInterfaceInfo **ppRmProtIfInfo,
							const RtrMgrProtocolInterfaceCB *pRmProtIfCB);
TFSCORE_API(HRESULT)	CreateRtrMgrProtocolInfo(
							IRtrMgrProtocolInfo **ppRmProtInfo,
							const RtrMgrProtocolCB *pRmProtCB);
							

/*---------------------------------------------------------------------------
	Aggregation helpers
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT)	CreateRouterInfoAggregation(IRouterInfo *pInfo,
	IUnknown *punkOuter, IUnknown **ppNonDelgatingIUnknown);

TFSCORE_API(HRESULT)	CreateInterfaceInfoAggregation(IInterfaceInfo *pInfo,
	IUnknown *punkOuter, IUnknown **ppNonDelgatingIUnknown);

TFSCORE_API(HRESULT)	CreateRtrMgrInfoAggregation(IRtrMgrInfo *pRmInfo,
	IUnknown *punkOuter, IUnknown **ppNonDelegatingIUnknown);

TFSCORE_API(HRESULT)	CreateRtrMgrProtocolInfoAggregation(IRtrMgrProtocolInfo *pRmProtInfo,
	IUnknown *punkOuter, IUnknown **ppNonDelegatingIUnknown);

TFSCORE_API(HRESULT)	CreateRtrMgrInterfaceInfoAggregation(IRtrMgrInterfaceInfo *pRmIfInfo,
	IUnknown *punkOuter, IUnknown **ppNonDelegatingIUnknown);

TFSCORE_API(HRESULT)	CreateRtrMgrProtocolInterfaceInfoAggregation(IRtrMgrProtocolInterfaceInfo *pRmProtIfInfo,
	IUnknown *punkOuter, IUnknown **ppNonDelegatingIUnknown);


/*---------------------------------------------------------------------------
	Useful utilities
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) LookupRtrMgr(IRouterInfo *pRouter,
								  DWORD dwTransportId,
								  IRtrMgrInfo **ppRm);
TFSCORE_API(HRESULT) LookupRtrMgrProtocol(IRouterInfo *pRouter,
										  DWORD dwTransportId,
										  DWORD dwProtocolId,
										  IRtrMgrProtocolInfo **ppRmProt);

TFSCORE_API(HRESULT) LookupRtrMgrInterface(IRouterInfo *pRouter,
										   LPCOLESTR pszInterfaceId,
										   DWORD dwTransportId,
										   IRtrMgrInterfaceInfo **ppRmIf);

TFSCORE_API(HRESULT) LookupRtrMgrProtocolInterface(IInterfaceInfo *pIf,
	DWORD dwTransportId, DWORD dwProtocolId,
	IRtrMgrProtocolInterfaceInfo **pRmProtIf);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\sumprop.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	sumprop.cpp
		IPX summary node property sheet and property pages
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "rtrutil.h"	// smart MPR handle pointers
#include "format.h"		// FormatNumber function
#include "sumprop.h"
#include "summary.h"
#include "ipxrtdef.h"
#include "mprerror.h"
#include "mprfltr.h"
#include "rtrerr.h"

#include "remras.h"
#include "rrasutil.h"
#include "ipxutil.h"

#include "rtrcomn.h"

extern "C"
{
#include "routprot.h"
};


IPXSummaryInterfaceProperties::IPXSummaryInterfaceProperties(ITFSNode *pNode,
								 IComponentData *pComponentData,
								 ITFSComponentData *pTFSCompData,
								 LPCTSTR pszSheetName,
								 CWnd *pParent,
								 UINT iPage,
								 BOOL fScopePane)
	: RtrPropertySheet(pNode, pComponentData, pTFSCompData,
					   pszSheetName, pParent, iPage, fScopePane),
		m_pageConfig(IDD_IPX_IF_CONFIG_PAGE),
		m_pageGeneral(IDD_IPX_IF_GENERAL_PAGE),
		m_bNewInterface(FALSE),
		m_pIPXConn(NULL)
{
	m_spNode.Set(pNode);
}

/*!--------------------------------------------------------------------------
	IPXSummaryInterfaceProperties::Init
		Initialize the property sheets.  The general action here will be
		to initialize/add the various pages.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXSummaryInterfaceProperties::Init(IRtrMgrInfo *pRm,
											IInterfaceInfo *pIfInfo)
{
	HRESULT	hr = hrOK;
	IPXConnection *	pIPXConn;
	BaseIPXResultNodeData *	pData;
	SPIRouterInfo	spRouter;
	RouterVersionInfo	routerVersion;

	pData = GET_BASEIPXRESULT_NODEDATA(m_spNode);
	ASSERT_BASEIPXRESULT_NODEDATA(pData);
	pIPXConn = pData->m_pIPXConnection;

	m_spRm.Set(pRm);
	m_spIf.Set(pIfInfo);
	m_spRm->GetParentRouterInfo(&spRouter);	
	
	// The pages are embedded members of the class
	// do not delete them.
	m_bAutoDeletePages = FALSE;

	// Initialize the infobase
	// Do this here, because the init is called in the context
	// of the main thread
	CORg( LoadInfoBase(pIPXConn) );
	
	m_pageGeneral.Init(m_spIf, pIPXConn, this);
	AddPageToList((CPropertyPageBase*) &m_pageGeneral);

	// Windows NT Bug : 208724
	// Only show the IPX configuration page for the internal interface
	if (m_spIf && (m_spIf->GetInterfaceType() == ROUTER_IF_TYPE_INTERNAL))
	{
		// Only allow config page for NT5 and up (there is no
		// configuration object for NT4).
		spRouter->GetRouterVersionInfo(&routerVersion);
		
		if (routerVersion.dwRouterVersion >= 5)
		{
			HRESULT	hrPage;
			
			hrPage = m_pageConfig.Init(m_spIf, pIPXConn, this);
			if (FHrOK(hrPage))
				AddPageToList((CPropertyPageBase*) &m_pageConfig);
			else if (!FHrSucceeded(hrPage))
				DisplayTFSErrorMessage(NULL);
		}
	}

Error:
	return hr;
}

IPXSummaryInterfaceProperties::~IPXSummaryInterfaceProperties()
{
	if (m_pIPXConn)
	{
		m_pIPXConn->Release();
		m_pIPXConn = NULL;
	}
}





/*!--------------------------------------------------------------------------
	IPXSummaryInterfaceProperties::LoadInfoBase
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT	IPXSummaryInterfaceProperties::LoadInfoBase(IPXConnection *pIPXConn)
{
	Assert(pIPXConn);
	
	HRESULT			hr = hrOK;
	HANDLE			hTransport = NULL;
	LPCOLESTR		pszInterfaceId = NULL;
	SPIInfoBase		spInfoBase;
	BYTE *			pDefault;
	int				cBlocks = 0;

	m_pIPXConn = pIPXConn;
	pIPXConn->AddRef();
	
	// If configuring the client-interface, load the client-interface info,
	// otherwise, retrieve the interface being configured and load
	// its info.

	// The client interface doesn't have an ID
	if (m_spIf)
		pszInterfaceId = m_spIf->GetId();


	if ((pszInterfaceId == NULL) || (StrLenW(pszInterfaceId) == 0))
	{
#ifdef DEBUG
		// Check to see that this is really an client node
		{
			BaseIPXResultNodeData *	pResultData = NULL;
			pResultData = GET_BASEIPXRESULT_NODEDATA(m_spNode);
			Assert(pResultData);
			ASSERT_BASEIPXRESULT_NODEDATA(pResultData);

			Assert(pResultData->m_fClient);
		}
#endif

		// Get the transport handle
		CWRg( ::MprConfigTransportGetHandle(pIPXConn->GetConfigHandle(),
											PID_IPX,
											&hTransport) );
								  
		// Load the client interface info
		CORg( m_spRm->GetInfoBase(pIPXConn->GetConfigHandle(),
								  hTransport,
								  NULL,
								  &spInfoBase) );
		m_bClientInfoBase = TRUE;
	}
	else
	{
		m_spRmIf.Release();
		
		CORg( m_spIf->FindRtrMgrInterface(PID_IPX,
			&m_spRmIf) );

		//
		//$ Opt: This should be made into a sync call rather
		// than a Load.
		
		//
		// Reload the information for this router-manager interface
		// This call could fail for valid reasons (if we are creating
		// a new interface, for example).
		//
		m_spRmIf->Load(m_spIf->GetMachineName(), NULL, NULL, NULL);

		//
		// The parameters are all NULL so that we can use the
		// default RPC handles.
		//
		m_spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase);
		m_bClientInfoBase = FALSE;
	}

	if (!spInfoBase)
	{
		// No info was found for the inteface
		// allocate a new InfoBase instead
		CORg( CreateInfoBase(&spInfoBase) );		
	}

    //
    // Check that there is a block for interface-status in the info,
    // and insert the default block if none is found.
    //
	if (spInfoBase->BlockExists(IPX_INTERFACE_INFO_TYPE) == hrFalse)
	{
		// If it didn't have the general interface info, assume that
		// we're adding IPX to this interface
		m_bNewInterface = TRUE;
	}

	CORg( AddIpxPerInterfaceBlocks(m_spIf, spInfoBase) );

	m_spInfoBase = spInfoBase.Transfer();
	
Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	IPXSummaryInterfaceProperties::GetInfoBase
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXSummaryInterfaceProperties::GetInfoBase(IInfoBase **ppInfoBase)
{
	Assert(ppInfoBase);
	
	*ppInfoBase = m_spInfoBase;
	m_spInfoBase->AddRef();

	return hrOK;
}

/*!--------------------------------------------------------------------------
	IPXSummaryInterfaceProperties::SaveSheetData
		This is performed on the main thread.  This will save sheet-wide
		data (rather than page data).
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL IPXSummaryInterfaceProperties::SaveSheetData()
{
	HRESULT		hr = hrOK;
	SPITFSNodeHandler   spHandler;
	HANDLE		hTransport = NULL, hInterface = NULL;
	DWORD		dwErr;
    SPITFSNode          spParent;			
	// By this time each page should have written its information out
	// to the infobase

	if (m_spInfoBase)
	{
		if (m_bClientInfoBase)
		{
			Assert(m_spRm);
			CORg( m_spRm->Save(m_spRm->GetMachineName(), 0, 0, NULL,
						 m_spInfoBase, 0));
		}
		else
		{
			// For IPX, we need to have the protocol information in the
			// infobase, BEFORE we add the interface to the running router.
		
			Assert(m_spRmIf);

			//
			// Need to set the infobase back to the registry
			//
			m_pIPXConn->DisconnectFromConfigServer();

			CWRg( ::MprConfigInterfaceGetHandle(
												m_pIPXConn->GetConfigHandle(),
												(LPTSTR) m_spRmIf->GetInterfaceId(),
												&hInterface) );

			// Get the transport handle
			dwErr = ::MprConfigInterfaceTransportGetHandle(
				m_pIPXConn->GetConfigHandle(),
				hInterface,// need hInterface
				PID_IPX,
				&hTransport);
			if (dwErr != ERROR_SUCCESS)
			{
				RtrMgrInterfaceCB	rmIfCB;

				m_spRmIf->CopyCB(&rmIfCB);
				
				dwErr = ::MprConfigInterfaceTransportAdd(
					m_pIPXConn->GetConfigHandle(),
					hInterface,
					m_spRmIf->GetTransportId(),
					rmIfCB.szId,
					NULL, 0, &hTransport);
			}
			CWRg( dwErr );
								  
			m_spRmIf->SetInfoBase(NULL, hInterface, hTransport, m_spInfoBase);

			//
			// Now, we notify that the interface is being added
			// This gives the protocols a chance to add on their information
			//
			if (m_bNewInterface)
				m_spRm->RtrNotify(ROUTER_CHILD_PREADD, ROUTER_OBJ_RmIf, 0);

			//
			// Reload the infobase (to get the new data before calling
			// the final save).
			//
			m_spInfoBase.Release();
			m_spRmIf->GetInfoBase(NULL, hInterface, hTransport, &m_spInfoBase);

			//
			// Perform the final save (since we are passing in a non-NULL
			// infobase pointer) this will commit the information back
			// to the running router.
			//
			CORg( m_spRmIf->Save(m_spIf->GetMachineName(),
						   NULL, hInterface, hTransport, m_spInfoBase, 0));
		}

		if (m_bNewInterface)
			m_spRm->RtrNotify(ROUTER_CHILD_ADD, ROUTER_OBJ_RmIf, 0);
	}

	if (m_bNewInterface)
	{
		SPITFSNodeHandler	spHandler;
		SPITFSNode			spParent;
		
		m_spNode->SetVisibilityState(TFS_VIS_SHOW);
		m_spNode->Show();
		
		// Force the node to do a resync
		m_spNode->GetParent(&spParent);
		spParent->GetHandler(&spHandler);
		spHandler->OnCommand(spParent, IDS_MENU_SYNC, CCT_RESULT,
							 NULL, 0);
		
		// Windows NT Bugs : 133891, we have added this to the UI
		// we no longer consider this a new interface
		m_bNewInterface = FALSE;
	}
Error:
	if (!FHrSucceeded(hr))
	{
//		Panic1("The Save failed %08lx", hr);
		CancelSheetData();
		return FALSE;
	}
    // Force the node to do a resync
    m_spNode->GetParent(&spParent);
    spParent->GetHandler(&spHandler);
    spHandler->OnCommand(spParent, IDS_MENU_SYNC, CCT_RESULT,
                         NULL, 0);
	return TRUE;
}

/*!--------------------------------------------------------------------------
	IPXSummaryInterfaceProperties::CancelSheetData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IPXSummaryInterfaceProperties::CancelSheetData()
{
	if (m_bNewInterface)
	{
		m_spNode->SetVisibilityState(TFS_VIS_DELETE);
		if (m_spIf)
			m_spIf->DeleteRtrMgrInterface(PID_IPX, TRUE);
		else
		{
			// This was the client interface, just don't save the
			// infobase back
		}
	}
}



/*---------------------------------------------------------------------------
	IPXSummaryIfPageGeneral
 ---------------------------------------------------------------------------*/

IPXSummaryIfPageGeneral::~IPXSummaryIfPageGeneral()
{
	if (m_pIPXConn)
	{
		m_pIPXConn->Release();
		m_pIPXConn = NULL;
	}
}

BEGIN_MESSAGE_MAP(IPXSummaryIfPageGeneral, RtrPropertyPage)
    //{{AFX_MSG_MAP(IPXSummaryIfPageGeneral)
	ON_BN_CLICKED(IDC_IIG_BTN_INPUT_FILTERS, OnInputFilters)
	ON_BN_CLICKED(IDC_IIG_BTN_OUTPUT_FILTERS, OnOutputFilters)
	ON_BN_CLICKED(IDC_IIG_BTN_ADMIN_STATE, OnChangeAdminButton)
	ON_BN_CLICKED(IDC_IIG_BTN_IPX_CP, OnChangeButton)
	ON_BN_CLICKED(IDC_IIG_BTN_IPX_WAN, OnChangeButton)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void IPXSummaryIfPageGeneral::OnChangeAdminButton()
{
	BOOL bSelected = IsDlgButtonChecked(IDC_IIG_BTN_ADMIN_STATE);

	DWORD dwIfType = m_spIf ? m_spIf->GetInterfaceType() : ROUTER_IF_TYPE_CLIENT;

	if (ROUTER_IF_TYPE_CLIENT != dwIfType)
	{
		GetDlgItem(IDC_IIG_BTN_INPUT_FILTERS)->EnableWindow(bSelected);
		GetDlgItem(IDC_IIG_BTN_OUTPUT_FILTERS)->EnableWindow(bSelected);
	}

	// Only if dwIfType == ROUTER_IF_TYPE_FULL_ROUTER can IDC_IIG_BTN_IPX_CP || IDC_IIG_BTN_IPX_WAN be changed
	if (ROUTER_IF_TYPE_FULL_ROUTER == dwIfType)
	{
		GetDlgItem(IDC_IIG_GRP_CONTROL_PROTOCOL)->EnableWindow(bSelected);
		GetDlgItem(IDC_IIG_BTN_IPX_CP)->EnableWindow(bSelected);
		GetDlgItem(IDC_IIG_BTN_IPX_WAN)->EnableWindow(bSelected);
	}
	
	OnChangeButton();
}

void IPXSummaryIfPageGeneral::OnChangeButton()
{
	SetDirty(TRUE);
	SetModified();
}

void IPXSummaryIfPageGeneral::OnInputFilters()
{
	OnFiltersConfig(FILTER_INBOUND);
}

void IPXSummaryIfPageGeneral::OnOutputFilters()
{
	OnFiltersConfig(FILTER_OUTBOUND);
}


/*!--------------------------------------------------------------------------
	IPXSummaryIfPageGeneral::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXSummaryIfPageGeneral::Init(IInterfaceInfo *pIfInfo,
									  IPXConnection *pIPXConn,
									  IPXSummaryInterfaceProperties *pPropSheet)
{
	m_spIf.Set(pIfInfo);
	m_pIPXConn = pIPXConn;
	pIPXConn->AddRef();
	m_pIPXPropSheet = pPropSheet;
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IPXSummaryIfPageGeneral::OnInitDialog
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL IPXSummaryIfPageGeneral::OnInitDialog()
{
	HRESULT	hr = hrOK;
	PBYTE	pData;
	SPIInfoBase	spInfoBase;
	IPX_IF_INFO	*	pIpxIf = NULL;
	IPXWAN_IF_INFO *pIpxWanIf = NULL;
	DWORD		dwIfType;
	BOOL	fEnable;

	// create the error info object
	CreateTFSErrorInfo(0);
	
	RtrPropertyPage::OnInitDialog();
	
	//
    // The page is now initialized. Load the current configuration
    // for the interface being configured, and display its settings.
	//
	// Get the infobase from the property sheet.
    //
	CORg( m_pIPXPropSheet->GetInfoBase(&spInfoBase) );
	
    //
    // Retrieve the interface-status block configured
    //
	CORg( spInfoBase->GetData(IPX_INTERFACE_INFO_TYPE, 0, (BYTE **) &pIpxIf) );

	CheckDlgButton(IDC_IIG_BTN_ADMIN_STATE, pIpxIf->AdminState == ADMIN_STATE_ENABLED);

	GetDlgItem(IDC_IIG_GRP_CONTROL_PROTOCOL)->EnableWindow(pIpxIf->AdminState == ADMIN_STATE_ENABLED);
	GetDlgItem(IDC_IIG_BTN_INPUT_FILTERS)->EnableWindow(pIpxIf->AdminState == ADMIN_STATE_ENABLED);
	GetDlgItem(IDC_IIG_BTN_OUTPUT_FILTERS)->EnableWindow(pIpxIf->AdminState == ADMIN_STATE_ENABLED);

	dwIfType = m_spIf ? m_spIf->GetInterfaceType() : ROUTER_IF_TYPE_CLIENT;
	
	if (dwIfType == ROUTER_IF_TYPE_FULL_ROUTER)
	{
		CORg( spInfoBase->GetData(IPXWAN_INTERFACE_INFO_TYPE, 0,
								  (LPBYTE *) &pIpxWanIf) );
		if (pIpxWanIf->AdminState == ADMIN_STATE_ENABLED)
			CheckDlgButton(IDC_IIG_BTN_IPX_WAN, ENABLED);
		else
			CheckDlgButton(IDC_IIG_BTN_IPX_CP, ENABLED);
		fEnable = TRUE;
	}
	else if (dwIfType == ROUTER_IF_TYPE_CLIENT)
	{
		CheckDlgButton(IDC_IIG_BTN_IPX_CP, ENABLED);
		fEnable = FALSE;
	}
	else
	{
		fEnable = FALSE;
	}

	// by default the controls are enabled, so do this call only
	// if we need to disable them
	if (fEnable == FALSE)
	{
		GetDlgItem(IDC_IIG_GRP_CONTROL_PROTOCOL)->EnableWindow(FALSE);
		GetDlgItem(IDC_IIG_BTN_IPX_CP)->EnableWindow(FALSE);
		GetDlgItem(IDC_IIG_BTN_IPX_WAN)->EnableWindow(FALSE);
	}

	if (dwIfType == ROUTER_IF_TYPE_CLIENT)
	{
		GetDlgItem(IDC_IIG_BTN_INPUT_FILTERS)->EnableWindow(FALSE);
		GetDlgItem(IDC_IIG_BTN_OUTPUT_FILTERS)->EnableWindow(FALSE);
	}

	SetDirty(m_pIPXPropSheet->m_bNewInterface ? TRUE : FALSE);

Error:
	if (!FHrSucceeded(hr))
		Cancel();
	return FHrSucceeded(hr) ? TRUE : FALSE;
}

/*!--------------------------------------------------------------------------
	IPXSummaryIfPageGeneral::DoDataExchange
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IPXSummaryIfPageGeneral::DoDataExchange(CDataExchange *pDX)
{
	RtrPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(IPXSummaryIfPageGeneral)
	//}}AFX_DATA_MAP
	
}

BOOL IPXSummaryIfPageGeneral::OnApply()
{

    INT i;
	SPIInfoBase	spInfoBase;
	IPX_IF_INFO	*	pIpxIf = NULL;
	IPXWAN_IF_INFO *pIpxWanIf = NULL;
	BOOL	fReturn;
	HRESULT	hr = hrOK;
	DWORD	dwIfType;

    if ( m_pIPXPropSheet->IsCancel() )
	{
		CancelApply();
        return TRUE;
	}

    //
    // Retrieve the interface-status block configured
    //
	m_pIPXPropSheet->GetInfoBase(&spInfoBase);

	CORg( spInfoBase->GetData(IPX_INTERFACE_INFO_TYPE, 0, (BYTE **) &pIpxIf) );

	pIpxIf->AdminState = IsDlgButtonChecked(IDC_IIG_BTN_ADMIN_STATE) ?
								ADMIN_STATE_ENABLED : ADMIN_STATE_DISABLED;

	dwIfType = m_spIf ? m_spIf->GetInterfaceType() : ROUTER_IF_TYPE_CLIENT;

	if ((dwIfType == ROUTER_IF_TYPE_FULL_ROUTER) ||
		(dwIfType == ROUTER_IF_TYPE_CLIENT))
	{
		CORg( spInfoBase->GetData(IPXWAN_INTERFACE_INFO_TYPE, 0, (LPBYTE *) &pIpxWanIf) );
		

		pIpxWanIf->AdminState = IsDlgButtonChecked(IDC_IIG_BTN_IPX_WAN) ?
							ADMIN_STATE_ENABLED : ADMIN_STATE_DISABLED;
	}
	
	fReturn  = RtrPropertyPage::OnApply();

Error:
	return fReturn;
}


//----------------------------------------------------------------------------
// Function:    CIpxIfGeneral::OnFiltersConfig
//
// does the actual call to MprUIFilterConfig for filter configuration. 
//----------------------------------------------------------------------------

void IPXSummaryIfPageGeneral::OnFiltersConfig(
											 DWORD dwFilterDirection
											)
{
    CWaitCursor wait;
	SPIInfoBase	spInfoBase;

	m_pIPXPropSheet->GetInfoBase(&spInfoBase);

	if (FHrOK(MprUIFilterConfigInfoBase(this->GetSafeHwnd(),
										spInfoBase,
										NULL,
										PID_IPX,
										dwFilterDirection)))
	{
		SetDirty(TRUE);
		SetModified();
	}
}


/*---------------------------------------------------------------------------
	IPXSummaryIfPageConfig
 ---------------------------------------------------------------------------*/

IPXSummaryIfPageConfig::~IPXSummaryIfPageConfig()
{
	if (m_pIPXConn)
	{
		m_pIPXConn->Release();
		m_pIPXConn = NULL;
	}
}

BEGIN_MESSAGE_MAP(IPXSummaryIfPageConfig, RtrPropertyPage)
    //{{AFX_MSG_MAP(IPXSummaryIfPageConfig)
	ON_EN_CHANGE(IDC_IIC_EDIT_NETNUMBER, OnChangeEdit)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/*!--------------------------------------------------------------------------
	IPXSummaryIfPageConfig::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXSummaryIfPageConfig::Init(IInterfaceInfo *pIfInfo,
									  IPXConnection *pIPXConn,
									  IPXSummaryInterfaceProperties *pPropSheet)
{
	// create the error info object
	CreateTFSErrorInfo(0);
	
	m_spIf.Set(pIfInfo);
	m_pIPXConn = pIPXConn;
	pIPXConn->AddRef();
	m_pIPXPropSheet = pPropSheet;

	m_fNetNumberChanged = FALSE;

	HRESULT					hr = hrOK;
	SPIRemoteRouterConfig	spRemote;
    SPIRouterInfo           spRouter;
    COSERVERINFO            csi;
    COAUTHINFO              cai;
    COAUTHIDENTITY          caid;

    ZeroMemory(&csi, sizeof(csi));
    ZeroMemory(&cai, sizeof(cai));
    ZeroMemory(&caid, sizeof(caid));
    
    csi.pAuthInfo = &cai;
    cai.pAuthIdentityData = &caid;
    
    
	// If there's no interface (such as for dial-in clients) don't
	// add the config page
	if (!m_spIf)
		return S_FALSE;

    m_spIf->GetParentRouterInfo(&spRouter);

	// Now try to cocreate the object
	if (m_spRemote == NULL)
	{
		LPCOLESTR	pszMachine = m_spIf->GetMachineName();
		IUnknown *				punk = NULL;

		hr = CoCreateRouterConfig(pszMachine,
                                  spRouter,
                                  &csi,
								  IID_IRemoteRouterConfig,
								  &punk);
		spRemote = (IRemoteRouterConfig *) punk;
	}
	
	if (FHrSucceeded(hr))
	{
		DWORD		dwNet;

		m_spRemote = spRemote.Transfer();
		hr = m_spRemote->GetIpxVirtualNetworkNumber(&dwNet);
		m_dwNetNumber = dwNet;		
	}

	if (!HandleIRemoteRouterConfigErrors(hr, m_spIf->GetMachineName()))
	{
		// other misc errors
		AddSystemErrorMessage(hr);

		AddHighLevelErrorStringId(IDS_ERR_IPXCONFIG_CANNOT_SHOW);
	}

    if (csi.pAuthInfo)
        delete csi.pAuthInfo->pAuthIdentityData->Password;
    
	return hr;
}

BOOL IPXSummaryIfPageConfig::OnPropertyChange(BOOL bScopePane, LONG_PTR *pChangeMask)
{
	BOOL	fReturn = TRUE;
	
	m_hrRemote = hrOK;
	
    if ( m_pIPXPropSheet->IsCancel() )
	{
		RtrPropertyPage::OnPropertyChange(bScopePane, pChangeMask);
		return FALSE;
	}
	
	if (m_fNetNumberChanged)
	{
		Assert(m_spRemote);
			
		m_hrRemote = m_spRemote->SetIpxVirtualNetworkNumber(m_dwNetNumber);

		fReturn = FHrSucceeded(m_hrRemote);
	}

	BOOL fPageReturn = RtrPropertyPage::OnPropertyChange(bScopePane, pChangeMask);

	// Only if both calls succeeded, do we return TRUE
	return fPageReturn && fReturn;
}

/*!--------------------------------------------------------------------------
	IPXSummaryIfPageConfig::OnInitDialog
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL IPXSummaryIfPageConfig::OnInitDialog()
{
	HRESULT	hr = hrOK;
	TCHAR	szNetNumber[64];

	RtrPropertyPage::OnInitDialog();

	wsprintf(szNetNumber, _T("%08lx"), m_dwNetNumber);
	SetDlgItemText(IDC_IIC_EDIT_NETNUMBER, szNetNumber);
	
	SetDirty(m_pIPXPropSheet->m_bNewInterface ? TRUE : FALSE);

//Error:
	if (!FHrSucceeded(hr))
		Cancel();
	return FHrSucceeded(hr) ? TRUE : FALSE;
}

/*!--------------------------------------------------------------------------
	IPXSummaryIfPageConfig::DoDataExchange
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IPXSummaryIfPageConfig::DoDataExchange(CDataExchange *pDX)
{
	RtrPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(IPXSummaryIfPageConfig)
	//}}AFX_DATA_MAP
	
}

/*!--------------------------------------------------------------------------
	IPXSummaryIfPageConfig::OnApply
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL IPXSummaryIfPageConfig::OnApply()
{

	BOOL	fReturn;
	DWORD	dwNetNumber;
	CString	stNetNumber;
	HRESULT					hr = hrOK;

    if ( m_pIPXPropSheet->IsCancel() )
	{
		CancelApply();
        return TRUE;
	}

	// Get the value from the edit control
	// ----------------------------------------------------------------
	GetDlgItemText(IDC_IIC_EDIT_NETNUMBER, stNetNumber);

	
	// Convert this text string into a hex number
	// ----------------------------------------------------------------
	dwNetNumber = _tcstoul(stNetNumber, NULL, 16);

	
	// Only attempt to write if the value actually changd.
	// ----------------------------------------------------------------
	if (m_spRemote && (dwNetNumber != m_dwNetNumber))
	{
		m_dwNetNumber = dwNetNumber;
		m_fNetNumberChanged = TRUE;
	}

	
		
	fReturn  = RtrPropertyPage::OnApply();

	
	// If this fails warn the user
	// ----------------------------------------------------------------
	if (!FHrSucceeded(hr))
	{
		DisplayErrorMessage(GetSafeHwnd(), hr);
	}
	else if (!FHrSucceeded(m_hrRemote))
	{
		// Return to this page
		// ------------------------------------------------------------
		GetParent()->PostMessage(PSM_SETCURSEL, 0, (LPARAM) GetSafeHwnd());
		
		AddHighLevelErrorStringId(IDS_ERR_CANNOT_SAVE_IPXCONFIG);
		AddSystemErrorMessage(m_hrRemote);
		DisplayTFSErrorMessage(NULL);
		
		fReturn = FALSE;
	}
	
	return fReturn;
}

void IPXSummaryIfPageConfig::OnChangeEdit()
{
	SetDirty(TRUE);
	SetModified();
}


/*---------------------------------------------------------------------------
	IPXSummaryPageGeneral
 ---------------------------------------------------------------------------*/

BEGIN_MESSAGE_MAP(IPXSummaryPageGeneral, RtrPropertyPage)
    //{{AFX_MSG_MAP(IPXSummaryPageGeneral)
	ON_BN_CLICKED(IDC_IGG_BTN_LOG_ERRORS, OnButtonClicked)
	ON_BN_CLICKED(IDC_IGG_BTN_LOG_INFO, OnButtonClicked)
	ON_BN_CLICKED(IDC_IGG_BTN_LOG_NONE, OnButtonClicked)
	ON_BN_CLICKED(IDC_IGG_BTN_LOG_WARNINGS, OnButtonClicked)	
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void IPXSummaryPageGeneral::OnButtonClicked()
{
	SetDirty(TRUE);
	SetModified();
}


/*!--------------------------------------------------------------------------
	IPXSummaryPageGeneral::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXSummaryPageGeneral::Init(IPXSummaryProperties *pPropSheet)
{
	m_pIPXPropSheet = pPropSheet;
	return hrOK;
}

/*!--------------------------------------------------------------------------
	IPXSummaryPageGeneral::OnInitDialog
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL IPXSummaryPageGeneral::OnInitDialog()
{
	HRESULT	hr= hrOK;
	SPIInfoBase	spInfoBase;
	PIPX_GLOBAL_INFO	pGlobalInfo = NULL;
	

	RtrPropertyPage::OnInitDialog();

	//
    // Load the existing global-config
    //
	CORg( m_pIPXPropSheet->GetInfoBase(&spInfoBase) );

    //
    // Retrieve the global-info, to set the 'Enable filtering' checkbox
    // and the logging levels.
    //
	CORg( spInfoBase->GetData(IPX_GLOBAL_INFO_TYPE,
							  0,
							  (BYTE **) &pGlobalInfo) );


    // Initialize the logging-level buttons
    //
	SetLogLevelButtons(pGlobalInfo->EventLogMask);

	SetDirty(FALSE);

Error:
	if (!FHrSucceeded(hr))
		Cancel();
	return FHrSucceeded(hr) ? TRUE : FALSE;
}

/*!--------------------------------------------------------------------------
	IPXSummaryPageGeneral::DoDataExchange
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IPXSummaryPageGeneral::DoDataExchange(CDataExchange *pDX)
{
	RtrPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(IPXSummaryPageGeneral)
	//}}AFX_DATA_MAP
	
}

BOOL IPXSummaryPageGeneral::OnApply()
{
	SPIInfoBase	spInfoBase;
	BOOL		fReturn;
	HRESULT		hr = hrOK;
    PIPX_GLOBAL_INFO pgi;
	
    if ( m_pIPXPropSheet->IsCancel() )
	{
		CancelApply();
        return TRUE;
	}

    //
    // Save the 'Enable filtering' setting
    //
	CORg( m_pIPXPropSheet->GetInfoBase(&spInfoBase) );
	
	CORg( spInfoBase->GetData(IPX_GLOBAL_INFO_TYPE, 0, (BYTE **) &pgi) );

    pgi->EventLogMask = QueryLogLevelButtons();

	fReturn = RtrPropertyPage::OnApply();
	
Error:
	if (!FHrSucceeded(hr))
		fReturn = FALSE;
	return fReturn;
}


/*!--------------------------------------------------------------------------
	IPXSummaryPageGeneral::SetLogLevelButtons
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IPXSummaryPageGeneral::SetLogLevelButtons(DWORD dwLogLevel)
{
	switch (dwLogLevel)
	{
		case 0:
			CheckDlgButton(IDC_IGG_BTN_LOG_NONE, TRUE);
			break;
		case EVENTLOG_ERROR_TYPE:
			CheckDlgButton(IDC_IGG_BTN_LOG_ERRORS, TRUE);
			break;
		case EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE:
			CheckDlgButton(IDC_IGG_BTN_LOG_WARNINGS, TRUE);
			break;
		case EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE:
		default:
			CheckDlgButton(IDC_IGG_BTN_LOG_INFO, TRUE);
			break;
	}
}



/*!--------------------------------------------------------------------------
	IPXSummaryPageGeneral::QueryLogLevelButtons
		Called to get the value set by the 'Logging level' radio-buttons.		
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD IPXSummaryPageGeneral::QueryLogLevelButtons()
{
	if (IsDlgButtonChecked(IDC_IGG_BTN_LOG_INFO))
		return EVENTLOG_INFORMATION_TYPE |
				EVENTLOG_WARNING_TYPE |
				EVENTLOG_ERROR_TYPE;
	else if (IsDlgButtonChecked(IDC_IGG_BTN_LOG_WARNINGS))
		return 	EVENTLOG_WARNING_TYPE |
				EVENTLOG_ERROR_TYPE;
	else if (IsDlgButtonChecked(IDC_IGG_BTN_LOG_ERRORS))
		return 	EVENTLOG_ERROR_TYPE;
	else
		return 0;
}



/*---------------------------------------------------------------------------
	IPXSummaryProperties implementation
 ---------------------------------------------------------------------------*/

IPXSummaryProperties::IPXSummaryProperties(ITFSNode *pNode,
								 IComponentData *pComponentData,
								 ITFSComponentData *pTFSCompData,
								 LPCTSTR pszSheetName,
								 CWnd *pParent,
								 UINT iPage,
								 BOOL fScopePane)
	: RtrPropertySheet(pNode, pComponentData, pTFSCompData,
					   pszSheetName, pParent, iPage, fScopePane),
		m_pageGeneral(IDD_IPX_GLOBAL_GENERAL_PAGE)
{
		m_spNode.Set(pNode);
}

/*!--------------------------------------------------------------------------
	IPXSummaryProperties::Init
		Initialize the property sheets.  The general action here will be
		to initialize/add the various pages.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXSummaryProperties::Init(IRtrMgrInfo *pRm)
{
	HRESULT	hr = hrOK;
	IPXConnection *	pIPXConn;
	BaseIPXResultNodeData *	pData;
	SPIRouterInfo	spRouter;

	m_spRm.Set(pRm);

	pIPXConn = GET_IPXSUMMARY_NODEDATA(m_spNode);

	// The pages are embedded members of the class
	// do not delete them.
	m_bAutoDeletePages = FALSE;

	// Get the router info
	CORg( pRm->GetParentRouterInfo(&spRouter) );

	// Initialize the infobase
	// Do this here, because the init is called in the context
	// of the main thread
	CORg( LoadInfoBase(pIPXConn) );
	
	m_pageGeneral.Init(this);
	AddPageToList((CPropertyPageBase*) &m_pageGeneral);

Error:
	return hr;
}




/*!--------------------------------------------------------------------------
	IPXSummaryProperties::LoadInfoBase
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT	IPXSummaryProperties::LoadInfoBase(IPXConnection *pIPXConn)
{
	Assert(pIPXConn);
	
	HRESULT			hr = hrOK;
	HANDLE			hTransport = NULL;
	LPCOLESTR		pszInterfaceId;
	SPIInfoBase		spInfoBase;
	BYTE *			pDefault;

	Assert(m_spRm);

	// Get the transport handle
	CWRg( ::MprConfigTransportGetHandle(pIPXConn->GetConfigHandle(),
										PID_IPX,
										&hTransport) );

	// Load the current IPX global info
	CORg( m_spRm->GetInfoBase(pIPXConn->GetConfigHandle(),
							  hTransport,
							  &spInfoBase,
							  NULL) );

	// Ensure that the global info block for IPX exists, adding
	// the default block if none is found.
	if (!FHrOK(spInfoBase->BlockExists(IPX_GLOBAL_INFO_TYPE)))
	{
		IPX_GLOBAL_INFO	ipxgl;

		ipxgl.RoutingTableHashSize = IPX_MEDIUM_ROUTING_TABLE_HASH_SIZE;
		ipxgl.EventLogMask = EVENTLOG_ERROR_TYPE |
							 EVENTLOG_WARNING_TYPE;
		CORg( spInfoBase->AddBlock(IPX_GLOBAL_INFO_TYPE,
								   sizeof(ipxgl),
								   (PBYTE) &ipxgl,
								   1 /* dwCount */,
								   0 /* bRemoveFirst */) );
	}

Error:
	if (!FHrSucceeded(hr))
		spInfoBase.Release();
	m_spInfoBase.Release();
	m_spInfoBase = spInfoBase.Transfer();
	
	return hr;
}

/*!--------------------------------------------------------------------------
	IPXSummaryProperties::GetInfoBase
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IPXSummaryProperties::GetInfoBase(IInfoBase **ppInfoBase)
{
	Assert(ppInfoBase);
	
	*ppInfoBase = m_spInfoBase;
	m_spInfoBase->AddRef();

	return hrOK;
}

BOOL IPXSummaryProperties::SaveSheetData()
{
	Assert(m_spRm);

	// Save the global info
	// We don't need to pass in the hMachine, hTransport since they
	// got set up in the Load call.
	m_spRm->Save(m_spRm->GetMachineName(),	// pszMachine
				 0,					// hMachine
				 0,					// hTransport
				 m_spInfoBase,		// pGlobalInfo
				 NULL,				// pClientInfo
				 0);				// dwDeleteProtocolId
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\svfltdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       svfltdlg.cpp
//
//--------------------------------------------------------------------------

// SvFltDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ipxadmin.h"
#include "ipxutil.h"
#include "listctrl.h"
#include "SvFltDlg.h"

extern "C"
{
#include "routprot.h"
};
//nclude "rtradmin.hm"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CServiceFltDlg dialog


CServiceFltDlg::CServiceFltDlg(BOOL bOutputDlg, IInfoBase *pInfoBase, CWnd* pParent /*=NULL*/)
	: CBaseDialog( (bOutputDlg ? CServiceFltDlg::IDD_OUTPUT : CServiceFltDlg::IDD_INPUT), pParent)
{
	//{{AFX_DATA_INIT(CServiceFltDlg)
	m_fActionDeny = FALSE;
	//}}AFX_DATA_INIT

	m_bOutput = bOutputDlg;
	m_spInfoBase.Set(pInfoBase);
	
//	SetHelpMap(m_dwHelpMap);
}


void CServiceFltDlg::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServiceFltDlg)
	DDX_Control(pDX, IDC_SFS_LIST, m_FilterList);
	DDX_Radio(pDX, IDC_SFS_BTN_DENY, m_fActionDeny);
	//}}AFX_DATA_MAP
	
    if (pDX->m_bSaveAndValidate)
	{		
        PSAP_SERVICE_FILTER_INFO    pFltInfo;
        UINT                        count;
        UINT                        i;
		DWORD						dwSize;
		PSAP_IF_CONFIG				pSapIfCfg = NULL;

		// Get the SAP_IF_CONFIG
		m_spInfoBase->GetData(IPX_PROTOCOL_SAP, 0, (PBYTE *) &pSapIfCfg);
		Assert(pSapIfCfg);
				
        count = m_FilterList.GetItemCount ();
        if (m_bOutput)
		{
            if (count != pSapIfCfg->SapIfFilters.SupplyFilterCount)
			{
				dwSize = FIELD_OFFSET (
							SAP_IF_CONFIG,
							SapIfFilters.ServiceFilter[
							   count
							   +pSapIfCfg->SapIfFilters.ListenFilterCount]);
				
                PSAP_IF_CONFIG  pNewConfig = (PSAP_IF_CONFIG) new BYTE[dwSize];
                if (pNewConfig==NULL)
                    AfxThrowMemoryException();
				
                memcpy (pNewConfig, pSapIfCfg,
                            FIELD_OFFSET (SAP_IF_CONFIG, SapIfFilters.ServiceFilter));
                memcpy (&pNewConfig->SapIfFilters.ServiceFilter[count],
                      &pSapIfCfg->SapIfFilters.ServiceFilter[
                           pSapIfCfg->SapIfFilters.SupplyFilterCount],
                      sizeof (SAP_SERVICE_FILTER_INFO)
                           *pSapIfCfg->SapIfFilters.ListenFilterCount);
				
                pNewConfig->SapIfFilters.SupplyFilterCount = count;

				m_spInfoBase->SetData(IPX_PROTOCOL_SAP,
									  dwSize,
									  (BYTE *) pNewConfig,
									  1, 0);
				pSapIfCfg = pNewConfig;
            }
			pSapIfCfg->SapIfFilters.SupplyFilterAction = m_fActionDeny ?
				IPX_SERVICE_FILTER_PERMIT : IPX_SERVICE_FILTER_DENY;
            pFltInfo = &pSapIfCfg->SapIfFilters.ServiceFilter[0];
        }
        else {
            if (count!=pSapIfCfg->SapIfFilters.ListenFilterCount)
			{
				dwSize = FIELD_OFFSET (
							SAP_IF_CONFIG,
							SapIfFilters.ServiceFilter[
							  count
							  +pSapIfCfg->SapIfFilters.SupplyFilterCount]);
				
                PSAP_IF_CONFIG  pNewConfig = (PSAP_IF_CONFIG) new BYTE[dwSize];
                if (pNewConfig==NULL)
                    AfxThrowMemoryException();
				
                memcpy (pNewConfig, pSapIfCfg,
                            FIELD_OFFSET (SAP_IF_CONFIG, SapIfFilters.ServiceFilter));
                memcpy (&pNewConfig->SapIfFilters.ServiceFilter[0],
                      &pSapIfCfg->SapIfFilters.ServiceFilter[0],
                      sizeof (SAP_SERVICE_FILTER_INFO)
                           *pSapIfCfg->SapIfFilters.SupplyFilterCount);
				
                pNewConfig->SapIfFilters.ListenFilterCount = count;
				
				m_spInfoBase->SetData(IPX_PROTOCOL_SAP,
									  dwSize,
									  (BYTE *) pNewConfig,
									  1, 0);
				pSapIfCfg = pNewConfig;
            }
			
			pSapIfCfg->SapIfFilters.ListenFilterAction = m_fActionDeny ?
				IPX_SERVICE_FILTER_PERMIT : IPX_SERVICE_FILTER_DENY;

            pFltInfo = &pSapIfCfg->SapIfFilters.ServiceFilter[
                                pSapIfCfg->SapIfFilters.SupplyFilterCount];
        }
        CString sAnyName, sAnyType;
        VERIFY (sAnyName.LoadString (IDS_ANY_SERVICE_NAME));
        VERIFY (sAnyType.LoadString (IDS_ANY_SERVICE_TYPE));
		
        for (i=0; i<count; i++)
		{
            CString     aStr;
            aStr = m_FilterList.GetItemText (i, 0);
            if (aStr.CompareNoCase (sAnyType)!=0)
			{
                pFltInfo[i].ServiceType = (SHORT) _tcstoul((LPCTSTR) aStr, NULL, 16);
			}
            else
                pFltInfo[i].ServiceType = 0xFFFF;

            aStr = m_FilterList.GetItemText (i, 1);
            if (aStr.CompareNoCase (sAnyType)!=0)
			{
				StrnCpyAFromT((char *) pFltInfo[i].ServiceName,
							  aStr,
							  DimensionOf(pFltInfo[i].ServiceName));
			}
            else
                pFltInfo[i].ServiceName[0] = 0;
        }
    }
}


BEGIN_MESSAGE_MAP(CServiceFltDlg, CBaseDialog)
	//{{AFX_MSG_MAP(CServiceFltDlg)
	ON_BN_CLICKED(IDC_SFS_BTN_ADD, OnAdd)
	ON_BN_CLICKED(IDC_SFS_BTN_DELETE, OnDelete)
	ON_BN_CLICKED(IDC_SFS_BTN_EDIT, OnEdit)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_SFS_LIST, OnItemchangedFilterList)
    ON_NOTIFY(NM_DBLCLK, IDC_SFS_LIST, OnListDblClk)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

DWORD CServiceFltDlg::m_dwHelpMap[] = 
{
//	IDC_DENY, HIDC_DENY,
//	IDC_PERMIT, HIDC_PERMIT,
//	IDC_FILTER_LIST, HIDC_FILTER_LIST,
//	IDC_ADD, HIDC_ADD,
//	IDC_EDIT, HIDC_EDIT,
//	IDC_DELETE, HIDC_DELETE,
	0,0
};

/////////////////////////////////////////////////////////////////////////////
// CServiceFltDlg message handlers

BOOL CServiceFltDlg::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString     aStr;


    CBaseDialog::OnInitDialog();

    if (m_bOutput)
        aStr.FormatMessage (IDS_SERVICEFILTER_OUTPUT_CAP, (LPCTSTR)m_sIfName);
    else
        aStr.FormatMessage (IDS_SERVICEFILTER_INPUT_CAP, (LPCTSTR)m_sIfName);

	SetWindowText (aStr);

	    // Get the current window style. 
    DWORD dwStyle = GetWindowLong(m_FilterList.m_hWnd, GWL_STYLE); 
 
    // Only set the window style if the view bits have changed. 
    if ((dwStyle & LVS_TYPEMASK) != LVS_REPORT) 
        SetWindowLong(m_FilterList.m_hWnd, GWL_STYLE, 
            (dwStyle & ~LVS_TYPEMASK) | LVS_REPORT); 
    ListView_SetExtendedListViewStyle(m_FilterList.m_hWnd,
                            LVS_EX_FULLROWSELECT|LVS_EX_HEADERDRAGDROP);
    VERIFY (aStr.LoadString (IDS_SERVICEFILTER_TYPE_HDR));
    VERIFY (m_FilterList.InsertColumn (0, aStr)!=-1);
    AdjustColumnWidth (m_FilterList, 0, aStr);
    VERIFY (aStr.LoadString (IDS_SERVICEFILTER_NAME_HDR));
    VERIFY (m_FilterList.InsertColumn (1, aStr)!=-1);
    AdjustColumnWidth (m_FilterList, 1, aStr);


    PSAP_SERVICE_FILTER_INFO  pFltInfo;
    UINT                    count;
    UINT                    i, item;
	PSAP_IF_CONFIG			pSapIfCfg;

	m_spInfoBase->GetData(IPX_PROTOCOL_SAP, 0, (PBYTE *) &pSapIfCfg);
	Assert(pSapIfCfg);
	
    if (m_bOutput) {
        pFltInfo = &pSapIfCfg->SapIfFilters.ServiceFilter[0];
        count = pSapIfCfg->SapIfFilters.SupplyFilterCount;
        if (count>0)
		{
			m_fActionDeny = (pSapIfCfg->SapIfFilters.SupplyFilterAction == IPX_SERVICE_FILTER_PERMIT);
		}
    }
    else {
        pFltInfo = &pSapIfCfg->SapIfFilters.ServiceFilter[
                            pSapIfCfg->SapIfFilters.SupplyFilterCount];
        count = pSapIfCfg->SapIfFilters.ListenFilterCount;
        if (count>0)
		{
			m_fActionDeny = (pSapIfCfg->SapIfFilters.ListenFilterAction == IPX_SERVICE_FILTER_PERMIT);
		}
    }

    for (i=0; i<count; i++) {
        CString aStr;
        if (pFltInfo[i].ServiceType!=0xFFFF)
		{
            aStr.Format(_T("%hx"), pFltInfo[i].ServiceType);
		}
        else
            VERIFY (aStr.LoadString (IDS_ANY_SERVICE_TYPE));

        VERIFY ((item=m_FilterList.InsertItem (LVIF_TEXT|LVIF_PARAM,
                                i, aStr,
                                0, 0, 0,
                                (LPARAM)i))!=-1);
        if (pFltInfo[i].ServiceName[0]!=0)
		{
			aStr.Format(_T("%.48hs"), pFltInfo[i].ServiceName);
		}
        else
            VERIFY (aStr.LoadString (IDS_ANY_SERVICE_NAME));
        VERIFY (m_FilterList.SetItemText (item, 1, aStr));
    }

    UpdateData (FALSE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
void CServiceFltDlg::OnAdd() 
{
    CServiceFilter    dlgFlt (this);
    dlgFlt.m_sIfName = m_sIfName;
    if (dlgFlt.DoModal ()==IDOK) {
        UINT    item;
        UINT    count = m_FilterList.GetItemCount ();

        if(dlgFlt.m_sType.IsEmpty())
            dlgFlt.m_sType = L'0';

        if (dlgFlt.m_sName.IsEmpty())
			dlgFlt.m_sName.LoadString (IDS_ANY_SERVICE_NAME);

        
        VERIFY ((item=m_FilterList.InsertItem (LVIF_TEXT|LVIF_PARAM,
                                count, dlgFlt.m_sType,
                                0, 0, 0,
                                (LPARAM)count))!=-1);
        VERIFY (m_FilterList.SetItemText (item, 1, dlgFlt.m_sName));
    }

	// Want to keep m_fActionDeny same over update
	m_fActionDeny = (BOOL) GetDlgItem(IDC_SFS_BTN_PERMIT)->SendMessage(BM_GETCHECK, NULL, NULL);
    UpdateData (FALSE);
    SetFocus();
}

void CServiceFltDlg::OnDelete() 
{
    UINT    item;
    VERIFY ((item=m_FilterList.GetNextItem (-1, LVNI_ALL|LVNI_SELECTED))!=-1);
    VERIFY (m_FilterList.DeleteItem	(item));

	// Want to keep m_fActionDeny same over update
	m_fActionDeny = (BOOL)GetDlgItem(IDC_SFS_BTN_PERMIT)->SendMessage(BM_GETCHECK, NULL, NULL);
    UpdateData (FALSE);
    SetFocus();
}

void CServiceFltDlg::OnListDblClk(NMHDR *pNmHdr, LRESULT *pResult)
{
    if (m_FilterList.GetNextItem(-1, LVNI_SELECTED) == -1)
        return;
    
    OnEdit();
    *pResult = 0;
}

void CServiceFltDlg::OnEdit() 
{
    UINT    item;
    CServiceFilter    dlgFlt (this);
    VERIFY ((item=m_FilterList.GetNextItem (-1, LVNI_ALL|LVNI_SELECTED))!=-1);
    dlgFlt.m_sIfName = m_sIfName;
    dlgFlt.m_sType = m_FilterList.GetItemText (item, 0);
    dlgFlt.m_sName = m_FilterList.GetItemText (item, 1);
    if (dlgFlt.DoModal ()==IDOK) {
        VERIFY (m_FilterList.SetItemText (item, 0, dlgFlt.m_sType));
        VERIFY (m_FilterList.SetItemText (item, 1, dlgFlt.m_sName));

		// Want to keep m_fActionDeny same over update
		m_fActionDeny = (BOOL)GetDlgItem(IDC_SFS_BTN_PERMIT)->SendMessage(BM_GETCHECK, NULL, NULL);
        UpdateData (FALSE);
    }
    SetFocus();
}

void CServiceFltDlg::OnOK()
{
	DWORD	dwCount;
	HRESULT 	hr = hrOK;

	m_fActionDeny = (BOOL)GetDlgItem(IDC_SFS_BTN_PERMIT)->SendMessage(BM_GETCHECK, NULL, NULL);
	dwCount = (DWORD) m_FilterList.GetItemCount();

	if (!dwCount && m_fActionDeny )
	{
		if (m_bOutput)
			AfxMessageBox(IDS_TRANSMIT_NO_SAP, MB_OK);
		else
			AfxMessageBox(IDS_RECEIVE_NO_SAP, MB_OK);
		return;
	}

	CBaseDialog::OnOK();
}

void CServiceFltDlg::OnItemchangedFilterList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	BOOL	fEnable;
	
	fEnable = (m_FilterList.GetNextItem (-1, LVNI_ALL|LVNI_SELECTED)!=-1);

	MultiEnableWindow(GetSafeHwnd(),
					  fEnable,
					  IDC_SFS_BTN_EDIT,
					  IDC_SFS_BTN_DELETE,
					  0);
	*pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CServiceFilter dialog


CServiceFilter::CServiceFilter(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CServiceFilter::IDD, pParent)
{
	//{{AFX_DATA_INIT(CServiceFilter)
	m_sIfName = _T("");
	m_sName = _T("");
	m_sType = _T("");
	//}}AFX_DATA_INIT

//	SetHelpMap(m_dwHelpMap);
}


void CServiceFilter::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServiceFilter)
	DDX_Text(pDX, IDC_SF_EDIT_INTERFACE, m_sIfName);
	DDX_Text(pDX, IDC_SF_EDIT_SERVICE_NAME, m_sName);
	DDV_MaxChars(pDX, m_sName, 48);
	DDX_Text(pDX, IDC_SF_EDIT_SERVICE_TYPE, m_sType);
	DDV_MaxChars(pDX, m_sType, 4);
	//}}AFX_DATA_MAP
    if (pDX->m_bSaveAndValidate) {
        try {
            SAP_SERVICE_FILTER_INFO   SvFltInfo;
            CString sAnyName, sAnyType;
            VERIFY (sAnyName.LoadString (IDS_ANY_SERVICE_NAME));
            VERIFY (sAnyType.LoadString (IDS_ANY_SERVICE_TYPE));

            pDX->PrepareEditCtrl (IDC_SF_EDIT_SERVICE_TYPE);
            if (m_sType.CompareNoCase (sAnyType)!=0)
			{
                SvFltInfo.ServiceType = (SHORT) _tcstoul((LPCTSTR) m_sType, NULL, 16);
//                m_sType >> CIPX_SERVICE_TYPE (&SvFltInfo.ServiceType);
			}
            pDX->PrepareEditCtrl (IDC_SF_EDIT_SERVICE_NAME);
            if (m_sName.CompareNoCase (sAnyType)!=0)
			{
				StrnCpyAFromT((char *) SvFltInfo.ServiceName,
							  m_sName,
							  DimensionOf(SvFltInfo.ServiceName));
//                m_sName >> CIPX_SERVICE_NAME (SvFltInfo.ServiceName);
			}
        }
        catch (DWORD error) {
            if (error==ERROR_INVALID_DATA)
                pDX->Fail ();
            else
                throw;
        }
    }
}


BEGIN_MESSAGE_MAP(CServiceFilter, CBaseDialog)
	//{{AFX_MSG_MAP(CServiceFilter)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

DWORD CServiceFilter::m_dwHelpMap[] =
{
//	IDC_INTERFACE, HIDC_INTERFACE,
//	IDC_SERVICE_TYPE, HIDC_SERVICE_TYPE,
//	IDC_SERVICE_NAME, HIDC_SERVICE_NAME,
	0,0,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\ipxsnap\svfltdlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       svfltdlg.h
//
//--------------------------------------------------------------------------

// SvFltDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CServiceFltDlg dialog

class CServiceFltDlg : public CBaseDialog
{
// Construction
public:
	CServiceFltDlg(BOOL bOutputDlg, IInfoBase *pInfoBase, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CServiceFltDlg)
	enum { 
		IDD_INPUT  = IDD_SERVICE_FILTERS_INPUT,
		IDD_OUTPUT = IDD_SERVICE_FILTERS_OUTPUT};
	CListCtrl	m_FilterList;
	BOOL	m_fActionDeny;		// TRUE == deny, FALSE == permit
	//}}AFX_DATA
	SPIInfoBase		m_spInfoBase;
    CString         m_sIfName;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServiceFltDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	static DWORD	m_dwHelpMap[];
    BOOL            m_bOutput;

	// Generated message map functions
	//{{AFX_MSG(CServiceFltDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnAdd();
	afx_msg void OnDelete();
	afx_msg void OnEdit();
	virtual void OnOK();
	afx_msg void OnItemchangedFilterList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnListDblClk(NMHDR *pNmHdr, LRESULT *pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CServiceFilter dialog

class CServiceFilter : public CBaseDialog
{
// Construction
public:
	CServiceFilter(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CServiceFilter)
	enum { IDD = IDD_SERVICE_FILTER };
	CString	m_sIfName;
	CString	m_sType;
	CString	m_sName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServiceFilter)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	static DWORD	m_dwHelpMap[];

	// Generated message map functions
	//{{AFX_MSG(CServiceFilter)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprinc\mprfltr.h ===
#ifndef _MPRFLTR_H_
#define _MPRFLTR_H_

#ifdef _cplusplus
extern "C" {
#endif

#define FILTER_INBOUND			0
#define FILTER_OUTBOUND			1
#define FILTER_DEMAND_DIAL		2
#define FILTER_PERUSER_IN		3
#define FILTER_PERUSER_OUT		4
// to make them easier to understand, define the alias for IN, OUT filters
#define FILTER_TO_USER          FILTER_PERUSER_IN
#define FILTER_FROM_USER        FILTER_PERUSER_OUT
	

HRESULT APIENTRY
MprUIFilterConfigInfoBase(
	IN	HWND		hwndParent,
	IN	IInfoBase *	pInfoBase,
	IN	IRtrMgrInterfaceInfo *pRmIf,
    IN  DWORD       dwTransportId,
    IN  DWORD       dwFilterType	// see above
    ); 

#ifdef _cplusplus
};
#endif
	
#endif // _MPRFLTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprinc\infobase.h ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    infoi.h
//
// History:
//  Abolade Gbadegesin      Feb. 10, 1996   Created.
//
// This file contains declarations for InfoBase parsing code.
// Also including are classes for loading and saving the Router's
// configuration tree (CRouterInfo, CRmInfo, etc.)
//
// The classes are as follows
// (in the diagrams, d => derives, c => contains-list-of):
//
//
//  CInfoBase
//     |
//     c---SInfoBlock
//
//
//  CInfoBase               holds block of data broken up into a list
//                          of SInfoBlock structures using RTR_INFO_BLOCK_HEADER
//                          as a template (see rtinfo.h).
//
//  CRouterInfo                                     // router info
//      |
//      c---CRmInfo                                 // router-manager info
//      |    |
//      |    c---CRmProtInfo                        // protocol info
//      |
//      c---CInterfaceInfo                          // router interface info
//           |
//           c---CRmInterfaceInfo                   // router-manager interface
//                |
//                c---CRmProtInterfaceInfo          // protocol info
//
//  CRouterInfo             top-level container for Router registry info.
//                          holds list of router-managers and interfaces.
//
//  CRmInfo                 global information for a router-manager,
//                          holds list of routing-protocols.
//
//  CRmProtInfo             global information for a routing-protocol.
//
//  CInterfaceInfo          global information for a router-interface.
//                          holds list of CRmInterfaceInfo structures,
//                          which hold per-interface info for router-managers.
//
//  CRmInterfaceInfo        per-interface info for a router-manager.
//                          holds list of CRmProtInterfaceInfo structures,
//                          which hold per-interface info for protocols.
//
//  CRmProtInterfaceInfo    per-interface info for a routing-protocol.
//
//============================================================================


#ifndef _INFOBASE_H_
#define _INFOBASE_H_

#include "mprsnap.h"

TFSCORE_API(HRESULT) CreateInfoBase(IInfoBase **ppIInfoBase);

TFSCORE_API(HRESULT) LoadInfoBase(HANDLE hConfigMachine, HANDLE hTransport,
						  IInfoBase **ppGlobalInfo, IInfoBase **ppClientInfo);

typedef ComSmartPointer<IInfoBase, &IID_IInfoBase> SPIInfoBase;
typedef ComSmartPointer<IEnumInfoBlock, &IID_IEnumInfoBlock> SPIEnumInfoBlock;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprinc\rtrlist.h ===
#ifndef _RTRLIST_H_
#define _RTRLIST_H_

interface	IInterfaceInfo;
interface	IRtrMgrInfo;
interface	IRtrMgrProtocolInfo;
interface	IRtrMgrInterfaceInfo;
interface	IRtrMgrProtocolInterfaceInfo;

/*---------------------------------------------------------------------------
	Clist classes for the various interfaces
 ---------------------------------------------------------------------------*/
typedef CList<IInterfaceInfo *, IInterfaceInfo *> PInterfaceInfoList;
typedef CList<IRtrMgrInfo *, IRtrMgrInfo *> PRtrMgrInfoList;
typedef CList<IRtrMgrProtocolInfo *, IRtrMgrProtocolInfo *> PRtrMgrProtocolInfoList;
typedef CList<IRtrMgrInterfaceInfo *, IRtrMgrInterfaceInfo *> PRtrMgrInterfaceInfoList;
typedef CList<IRtrMgrProtocolInterfaceInfo *, IRtrMgrProtocolInterfaceInfo *> PRtrMgrProtocolInterfaceInfoList;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprinc\rtrguid.h ===
/*----------------------------------------------------------------------------
   rtrguid.h

   Header file for all of the routing GUIDS.


   Copyright (C) 1997 Microsoft Corporation
   All rights reserved.

 ----------------------------------------------------------------------------*/

#ifndef _RTRGUID_H
#define _RTRGUID_H


/*---------------------------------------------------------------------------
	CLSIDs for the router snapins
	The range for the CLSIDs are
		{1AA7F839-C7F5-11d0-A376-00C04FC9DA04}
		to
		{1AA7F87F-C7F5-11d0-A376-00C04FC9DA04}		
 ---------------------------------------------------------------------------*/

#define DEFINE_ROUTER_CLSID(name,x) \
   DEFINE_GUID(CLSID_##name, \
   (0x1aa7f830 + (x)), 0xc7f5, 0x11d0, 0xa3, 0x76, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4);


// CLSID_RouterSnapin
// {1AA7F839-C7F5-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_CLSID(RouterSnapin, 9)

// CLSID_RouterSnapinExtension
// {1AA7F83A-C7F5-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_CLSID(RouterSnapinExtension, 0xA)

// CLSID_RouterSnapinAbout
// {1AA7F83B-C7F5-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_CLSID(RouterSnapinAbout, 0xB)

// CLSID_ATLKAdminExtension
// {1AA7F83C-C7F5-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_CLSID(ATLKAdminExtension, 0xC)

// CLSID_ATLKAdminAbout
// {1AA7F83D-C7F5-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_CLSID(ATLKAdminAbout, 0xD)

//  CLSID_RouterAuthNT5DS
// {1AA7F83E-C7F5-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_CLSID(RouterAuthNT5DS, 0xE)

// CLSID_RouterAuthRADIUS
// {1AA7F83F-C7F5-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_CLSID(RouterAuthRADIUS, 0xF)

// CLSID_RouterAcctRADIUS
// {1AA7F840-C7F5-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_CLSID(RouterAcctRADIUS, 0x10)

// CLSID_RouterAuthNT
// {1AA7F841-C7F5-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_CLSID(RouterAuthNT, 0x11)

//	CLSID_DomainViewSnapin
// {1AA7F842-C7F5-11d0-A376-00C04FC9DA04}
//FINE_ROUTER_CLSID(DomainViewSnapin, 0x12)

//	CLSID_DomainViewSnapinAbout
// {1AA7F843-C7F5-11d0-A376-00C04FC9DA04}
//FINE_ROUTER_CLSID(DomainViewSnapinAbout, 0x13)

//	CLSID_RemoteRouterConfig
// {1AA7F844-C7F5-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_CLSID(RemoteRouterConfig, 0x14)

//	CLSID_DomainViewSnapinExtension
// {1AA7F845-C7F5-11d0-A376-00C04FC9DA04}
//FINE_ROUTER_CLSID(DomainViewSnapinExtension, 0x15)

// CLSID_RouterAcctNT
// {1AA7F846-C7F5-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_CLSID(RouterAcctNT, 0x16)


// Use up to 0x7F




/*---------------------------------------------------------------------------
   Nodetype GUIDs

	The range for our nodetype guids are
	
		{276B4E00-C7F7-11d0-A376-00C04FC9DA04}
		to
		{276B4EFF-C7F7-11d0-A376-00C04FC9DA04}

	I assume that 256 nodetypes is enough.
 ---------------------------------------------------------------------------*/


// GUIDs for the node types
#define DEFINE_ROUTER_NODETYPE_GUID(name,x) \
   DEFINE_GUID(GUID_##name, \
   (0x276b4e00 + x), 0xc7f7, 0x11d0, 0xa3, 0x76, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4); \


// Domain nodetype
// {276B4E00-C7F7-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_NODETYPE_GUID(RouterDomainNodeType, 0)

// GUID_RouterIfAdminNodeType
// {276B4E01-C7F7-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_NODETYPE_GUID(RouterIfAdminNodeType, 1)

// GUID_RouterLanInterfaceNodeType
// {276B4E02-C7F7-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_NODETYPE_GUID(RouterLanInterfaceNodeType, 2)

// GUID_RouterDialInNodeType
// {276B4E03-C7F7-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_NODETYPE_GUID(RouterDialInNodeType, 3)

// GUID_RouterDialInResultNodeType
// {276B4E04-C7F7-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_NODETYPE_GUID(RouterDialInResultNodeType, 4)

// GUID_RouterPortsNodeType
// {276B4E05-C7F7-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_NODETYPE_GUID(RouterPortsNodeType, 5)

// GUID_RouterPortsResultNodeType
// {276B4E06-C7F7-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_NODETYPE_GUID(RouterPortsResultNodeType, 6)

// GUID_ATLKRootNodeType
// {276B4E07-C7F7-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_NODETYPE_GUID(ATLKRootNodeType, 7)

// GUID_ATLKNodeType
// {276B4E08-C7F7-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_NODETYPE_GUID(ATLKNodeType, 8)

// GUID_ATLKInterfaceNodeType
// {276B4E09-C7F7-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_NODETYPE_GUID(ATLKInterfaceNodeType, 9)

// GUID_DomainStatusNodeType
// {276B4E0A-C7F7-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_NODETYPE_GUID(DomainStatusNodeType, 0x0a)

// GUID_DVSServerNodeType
// {276B4E0B-C7F7-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_NODETYPE_GUID(DVSServerNodeType, 0x0b)

// Machine nodetype - Error nodetype (router_type=0)
// {276B4E80-C7F7-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_NODETYPE_GUID(RouterMachineErrorNodeType, 0x80)

// Machine nodetype - RAS, WAN, LAN (router_type = 7)
// {276B4E81-C7F7-11d0-A376-00C04FC9DA04}
DEFINE_ROUTER_NODETYPE_GUID(RouterMachineNodeType, 0x81)






/*---------------------------------------------------------------------------
	Other random GUIDs

	use the range
	{66A2DB00-D706-11d0-A37B-00C04FC9DA04}
	to
	{66A2DBFF-D706-11d0-A37B-00C04FC9DA04}

	IIDs can be in the range from
	{66A2DB00-D706-11d0-A37B-00C04FC9DA04}
	to
	{66A2DB7F-D706-11d0-A37B-00C04FC9DA04}

	Misc GUIDs are in the range
	{66A2DB80-D706-11d0-A37B-00C04FC9DA04}
	to
	{66A2DBFF-D706-11d0-A37B-00C04FC9DA04}
	
 ---------------------------------------------------------------------------*/

#define DEFINE_ROUTER_IID(name,x) \
   DEFINE_GUID(IID_##name, \
   (0x66a2db00 + (x)), 0xd706, 0x11d0, 0xa3, 0x7b, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4);


#define DEFINE_ROUTER_MISCGUID(name,x) \
	DEFINE_GUID(name, \
	(0x66a2db00 + (x)), 0xd706, 0x11d0, 0xa3, 0x7b, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4);


//	IID_IInfoBase
// {66A2DB00-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IInfoBase, 0)

// IID_IEnumInfoBlock
// {66A2DB01-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IEnumInfoBlock, 1)

// IID_IRouterInfo
// {66A2DB02-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IRouterInfo, 2)

//	IID_IEnumRouterInfo
// {66A2DB03-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IEnumRouterInfo, 3)

//	IID_IRtrMgrInfo
// {66A2DB04-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IRtrMgrInfo, 4)

//	IID_IEnumRtrMgrInfo
// {66A2DB05-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IEnumRtrMgrInfo, 5)

//	IID_IRtrMgrProtocolInfo
// {66A2DB06-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IRtrMgrProtocolInfo, 6)

//	IID_IEnumRtrMgrProtocolInfo
// {66A2DB07-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IEnumRtrMgrProtocolInfo, 7)

//	IID_IInterfaceInfo
// {66A2DB08-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IInterfaceInfo, 8)

//	IID_IEnumInterfaceInfo
// {66A2DB09-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IEnumInterfaceInfo, 9)

//	IID_IRtrMgrInterfaceInfo
// {66A2DB0a-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IRtrMgrInterfaceInfo, 0xa)

//	IID_IEnumRtrMgrInterfaceInfo
// {66A2DB0b-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IEnumRtrMgrInterfaceInfo, 0xb)

//	IID_IRtrMgrProtocolInterfaceInfo
// {66A2DB0c-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IRtrMgrProtocolInterfaceInfo, 0xc)

//	IID_IEnumRtrMgrProtocolInterfaceInfo
// {66A2DB0d-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IEnumRtrMgrProtocolInterfaceInfo, 0xd)

//	IID_IEnumRouterCB
// {66A2DB0e-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IEnumRouterCB, 0xe)

//	IID_IEnumRtrMgrCB
// {66A2DB0f-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IEnumRtrMgrCB, 0xf)

//	IID_IEnumRtrMgrProtocolCB
// {66A2DB10-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IEnumRtrMgrProtocolCB, 0x10)

//	IID_IEnumInterfaceCB
// {66A2DB11-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IEnumInterfaceCB, 0x11)

//	IID_IEnumRtrMgrInterfaceCB
// {66A2DB12-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IEnumRtrMgrInterfaceCB, 0x12)

//	IID_IEnumRtrMgrProtocolInterfaceCB
// {66A2DB13-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IEnumRtrMgrProtocolInterfaceCB, 0x13)

//	IID_IRtrAdviseSink
// {66A2DB14-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IRtrAdviseSink, 0x14)

//	IID_IRouterRefresh
// {66A2DB15-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IRouterRefresh, 0x15)

//	IID_IRouterProtocolConfig
// {66A2DB16-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IRouterProtocolConfig, 0x16)

//	IID_IAuthenticationProviderConfig
// {66A2DB17-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IAuthenticationProviderConfig, 0x17)

//	IID_IAccountingProviderConfig
// {66A2DB18-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IAccountingProviderConfig, 0x18)

//	IID_IEAPProviderConfig
// {66A2DB19-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IEAPProviderConfig, 0x19)

//	IID_IRemoteRouterConfig
// {66A2DB1a-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IRemoteRouterConfig, 0x1a)

//	IID_IRemoteNetworkConfig
// {66A2DB1b-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IRemoteNetworkConfig, 0x1b)

//	IID_IRouterRefreshAccess
// {66A2DB1c-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IRouterRefreshAccess, 0x1c)

//	IID_IRouterRefreshModify
// {66A2DB1d-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IRouterRefreshModify, 0x1d)

//	IID_IRemoteTCPIPChangeNotify
// {66A2DB1e-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IRemoteTCPIPChangeNotify, 0x1e)

//	IID_IRouterAdminAccess
// {66A2DB1f-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IRouterAdminAccess, 0x1f)

//	IID_IRemoteRouterRestart
// {66A2DB20-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IRemoteRouterRestart, 0x20)

//	IID_IRemoteSetDnsConfig
// {66A2DB21-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IRemoteSetDnsConfig, 0x21)

//	IID_IRemoteICFICSConfig
// {66A2DB21-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_IID(IRemoteICFICSConfig, 0x22)



// Miscellaneous GUIDS

//	GUID_RemoteRouterConfigTLB
// {66A2DB80-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_MISCGUID(GUID_RemoteRouterConfigTLB, 0x80)

//	GUID_RemoteRouterConfigAppId
// {66A2DB81-D706-11d0-A37B-00C04FC9DA04}
DEFINE_ROUTER_MISCGUID(GUID_RemoteRouterConfigAppId, 0x81)



// specialized GUIDS - used for speicalized router cases
DEFINE_GUID(GUID_RouterError, 0xFFFFFFFF, 0xFFFF, 0xFFFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF);
DEFINE_GUID(GUID_RouterNull, 0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

// {E8EEDC94-8C6B-11d1-856C-00C04FC31FD3}
DEFINE_GUID(CLSID_OldRouterSnapin, 
0xe8eedc94, 0x8c6b, 0x11d1, 0x85, 0x6c, 0x0, 0xc0, 0x4f, 0xc3, 0x1f, 0xd3);

// {E8EEDC95-8C6B-11d1-856C-00C04FC31FD3}
DEFINE_GUID(CLSID_OldRouterSnapinAbout, 
0xe8eedc95, 0x8c6b, 0x11d1, 0x85, 0x6c, 0x0, 0xc0, 0x4f, 0xc3, 0x1f, 0xd3);

// Query
DEFINE_GUID(CLSID_RRASQueryForm, 
0x6B91AFEF, 0x9472, 0x11D1, 0x85, 0x74, 0x00,0xC0, 0x4F, 0xC3, 0x1F, 0xD3);


// Need to add IP configuration GUID here
DEFINE_GUID(CLSID_IPRouterConfiguration,
0xc2fe450A, 0xd6c2, 0x11d0, 0xa3, 0x7b, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4);


#define DEFINE_ROUTER_CLSID(name,x) \
   DEFINE_GUID(CLSID_##name, \
   (0x1aa7f830 + (x)), 0xc7f5, 0x11d0, 0xa3, 0x76, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4);



/*---------------------------------------------------------------------------
	Authentication provider GUIDS

	From
		{76560D00-2BFD-11d2-9539-3078302C2030}
	to
		{76560D7F-2BFD-11d2-9539-3078302C2030}

	Used to identify the class of the authentication providers.

	Current GUIDS are:

		GUID_AUTHPROV_RADIUS
		GUID_AUTHPROV_NATIVENT
 ---------------------------------------------------------------------------*/
#define DEFINE_AUTH_PROVIDER_GUID(name,x) \
	DEFINE_GUID(GUID_AUTHPROV_##name, \
	(0x76560d00+(x)), 0x2bfd, 0x11d2, 0x95, 0x39, 0x30, 0x78, 0x30, 0x2c, 0x20, 0x30);

// GUID_AUTHPROV_RADIUS
// {76560D00-2BFD-11d2-9539-3078302C2030}
DEFINE_AUTH_PROVIDER_GUID(RADIUS, 0x00);

// GUID_AUTHPROV_NativeNT
// {76560D01-2BFD-11d2-9539-3078302C2030}
DEFINE_AUTH_PROVIDER_GUID(NativeNT, 0x01);


/*---------------------------------------------------------------------------
	Accounting provider GUIDS

	From
		{76560D80-2BFD-11d2-9539-3078302C2030}
	to
		{76560DFF-2BFD-11d2-9539-3078302C2030}

	Used to identify the class of the authentication providers.

	Current GUIDS are:

		GUID_ACCTPROV_RADIUS
		GUID_ACCTPROV_NativeNT
 ---------------------------------------------------------------------------*/
#define DEFINE_ACCT_PROVIDER_GUID(name,x) \
	DEFINE_GUID(GUID_ACCTPROV_##name, \
	(0x76560d00+(x)), 0x2bfd, 0x11d2, 0x95, 0x39, 0x30, 0x78, 0x30, 0x2c, 0x20, 0x30);

// GUID_ACCTPROV_RADIUS
// {76560D80-2BFD-11d2-9539-3078302C2030}
DEFINE_ACCT_PROVIDER_GUID(RADIUS, 0x80);

// GUID_ACCTPROV_NativeNT
// {76560D81-2BFD-11d2-9539-3078302C2030}
DEFINE_ACCT_PROVIDER_GUID(NativeNT, 0x81);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprinc\reg.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
	reg.h
		
    FILE HISTORY:
        
*/

#ifndef _REG_H
#define _REG_H

//----------------------------------------------------------------------------
// Function:    ConnectRegistry
//
// Connects to HKEY_LOCAL_MACHINE on machine 'pszMachine', which is expected
// to be of the form "\\MACHINE", and saves the key in 'phkeyMachine'.
// If 'pszMachine' is NULL or empty, saves HKEY_LOCAL_MACHINE in 'phkeyMachine'
//
// If you are connecting to the server for the very FIRST time, use the
// InitiateServerConnection() call instead.  This does the exact same
// thing as this call (except that it brings up UI and prompts for
// username/password if needed).
//
//----------------------------------------------------------------------------
TFSCORE_API(DWORD) ConnectRegistry(LPCTSTR pszMachine, HKEY *phkeyMachine);


//----------------------------------------------------------------------------
// Function:    DisconnectRegistry
//
// Disconnects from the registry connected to be 'ConnectRegistry'.
//----------------------------------------------------------------------------
TFSCORE_API(VOID) DisconnectRegistry(HKEY hkeyMachine);


//----------------------------------------------------------------------------
// Function:	QueryRouterType
//
// Retrieves the value of HKLM\Software\Microsoft\RAS\Protocols\RouterType
// This is used by the individual UIConfigDlls to determine if they should
// load or not.
//
//	If the pVerInfo parameter is NULL, then the QueryRouterType() function
// wil gather that information itself.
//----------------------------------------------------------------------------

enum {
	ROUTER_TYPE_RAS = 1,
	ROUTER_TYPE_LAN = 2,
	ROUTER_TYPE_WAN = 4
};

TFSCORE_API(HRESULT) QueryRouterType(HKEY hkMachine, DWORD *pdwRouterType,
									 RouterVersionInfo *pVerInfo);

TFSCORE_API(HRESULT)	QueryRouterVersionInfo(HKEY hkeyMachine,
											   RouterVersionInfo *pVerInfo);


//----------------------------------------------------------------------------
// Function:    QueryLinkageList
//
// Loads a list of strings with the adapters to which 'pszService' is bound;
// the list is built by examining the 'Linkage' and 'Disabled' subkeys
// of the service under HKLM\System\CurrentControlSet\Services.
//----------------------------------------------------------------------------

HRESULT LoadLinkageList(LPCTSTR         pszMachine,
						HKEY			hkeyMachine,
						LPCTSTR         pszService,
						CStringList*    pLinkageList);


TFSCORE_API(DWORD)	GetNTVersion(HKEY hkeyMachine, DWORD *pdwMajor, DWORD *pdwMinor, DWORD* pdwCurrentBuildNumber);
TFSCORE_API(DWORD)	IsNT4Machine(HKEY hkeyMachine, BOOL *pfNt4);

//----------------------------------------------------------------------------
// Function:    FindRmSoftwareKey
//
// Finds the key for a router-manager in the Software section of the registry.
//----------------------------------------------------------------------------

HRESULT FindRmSoftwareKey(
						HKEY        hkeyMachine,
						DWORD       dwTransportId,
						HKEY*       phkrm,
						LPTSTR*     lplpszRm
					   );


//----------------------------------------------------------------------------
// Function:    RegFindInterfaceTitle
//				RegFindRtrMgrTitle
//				RegFindRtrMgrProtocolTitle
//
// These functions read the key HKLM\Software\Router to load the title of
// a given interface, RtrMgr, and RtrMgrProtocol respectively.  The string
// will be allocated using 'new' and returned as an out parameter.  Free
// up the memory using 'delete'.
//
// Function:    SetupFindInterfaceTitle
// This is similar to the RegFindInterfaceTitle, however this uses
// the setup APIs.
//----------------------------------------------------------------------------
HRESULT RegFindInterfaceTitle(LPCTSTR pszMachine, LPCTSTR pszInterface,
							  LPTSTR *ppszTitle);
HRESULT SetupFindInterfaceTitle(LPCTSTR pszMachine, LPCTSTR pszInterface,
							  LPTSTR *ppszTitle);

HRESULT RegFindRtrMgrTitle(LPCTSTR pszMachine, DWORD dwProtocolId,
						   LPTSTR *ppszTitle);

HRESULT RegFindRtrMgrProtocolTitle(LPCTSTR pszMachine, DWORD dwTransportId,
								   DWORD dwProtocolId, LPTSTR *ppszTitle);


#ifdef _DEBUG
	#define CheckRegOpenError(d,p1,p2) CheckRegOpenErrorEx(d,p1,p2,_T(__FILE__), __LINE__)
	#define CheckRegQueryValueError(d,p1,p2,p3) CheckRegQueryValueErrorEx(d,p1,p2,p3,_T(__FILE__), __LINE__)

	void	CheckRegOpenErrorEx(DWORD dwError, LPCTSTR pszSubKey,
							  LPCTSTR pszDesc, LPCTSTR szFile, int iLineNo);
	void	CheckRegQueryValueErrorEx(DWORD dwError, LPCTSTR pszSubKey,
									LPCTSTR pszValue, LPCTSTR pszDesc,
								   LPCTSTR szFile, int iLineNo);
#else
	#define CheckRegOpenError(d,p1,p2)
	#define CheckRegQueryValueError(d,p1,p2,p3)
#endif


#endif _REG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprinc\rtrutil.h ===
#ifndef _RTRUTIL_H_
#define _RTRUTIL_H_

interface	IInterfaceInfo;

#include "mprapi.h"
#include "rtrguid.h"
#include "rrascfg.h"

typedef HANDLE	MPR_CONFIG_HANDLE;

// since all of the handles typdef out to a HANDLE, we need to have different
// explicit classes to make sure they get freed up correctly.
class SPMprServerHandle
{
public:
	SPMprServerHandle()		                { m_h = NULL; }
	SPMprServerHandle(MPR_SERVER_HANDLE h)	{ m_h = h; }
	~SPMprServerHandle()		            { Release(); }

	operator MPR_SERVER_HANDLE() const	    { return m_h; }
	MPR_SERVER_HANDLE *operator &()	        { Assert(!m_h); return &m_h; }
	MPR_SERVER_HANDLE operator=(MPR_SERVER_HANDLE h)    { Assert(!m_h); m_h = h; return m_h; }

	inline void Attach(MPR_SERVER_HANDLE hT)		    { Release(); m_h = hT; }
	inline MPR_SERVER_HANDLE Detach()			        { MPR_SERVER_HANDLE hT; hT = m_h; m_h = NULL; return hT; }

	inline void Release()		        { MPR_SERVER_HANDLE hT; hT = Detach(); ReleaseSmartHandle(hT); }

    inline void ReleaseSmartHandle(MPR_SERVER_HANDLE h)
    {
	    ::MprAdminServerDisconnect(h);
    }

protected:
	MPR_SERVER_HANDLE	m_h;
};


class SPMibServerHandle
{
public:
	SPMibServerHandle()		                { m_h = NULL; }
	SPMibServerHandle(MIB_SERVER_HANDLE h)	{ m_h = h; }
	~SPMibServerHandle()		            { Release(); }

	operator MIB_SERVER_HANDLE() const	    { return m_h; }
	MIB_SERVER_HANDLE *operator &()	        { Assert(!m_h); return &m_h; }
	MIB_SERVER_HANDLE operator=(MIB_SERVER_HANDLE h)    { Assert(!m_h); m_h = h; return m_h; }

	inline void Attach(MIB_SERVER_HANDLE hT)		    { Release(); m_h = hT; }
	inline MIB_SERVER_HANDLE Detach()			        { MIB_SERVER_HANDLE hT; hT = m_h; m_h = NULL; return hT; }

	inline void Release()		        { MIB_SERVER_HANDLE hT; hT = Detach(); ReleaseSmartHandle(hT); }

    inline void ReleaseSmartHandle(MIB_SERVER_HANDLE h)
    {
    	::MprAdminMIBServerDisconnect(h);
    }

protected:
	MIB_SERVER_HANDLE	m_h;
};


class SPMprConfigHandle
{
public:
	SPMprConfigHandle()		                { m_h = NULL; }
	SPMprConfigHandle(MPR_CONFIG_HANDLE h)	{ m_h = h; }
	~SPMprConfigHandle()		            { Release(); }

	operator MPR_CONFIG_HANDLE() const	    { return m_h; }
	MPR_CONFIG_HANDLE *operator &()	        { Assert(!m_h); return &m_h; }
	MPR_CONFIG_HANDLE operator=(MPR_CONFIG_HANDLE h)    { Assert(!m_h); m_h = h; return m_h; }

	inline void Attach(MPR_CONFIG_HANDLE hT)		    { Release(); m_h = hT; }
	inline MPR_CONFIG_HANDLE Detach()			        { MPR_CONFIG_HANDLE hT; hT = m_h; m_h = NULL; return hT; }

	inline void Release()		        { MPR_CONFIG_HANDLE hT; hT = Detach(); ReleaseSmartHandle(hT); }

    inline void ReleaseSmartHandle(MPR_CONFIG_HANDLE h)
    {
    	if(h != NULL)
	    	::MprConfigServerDisconnect(h);
    }

protected:
	MPR_CONFIG_HANDLE	m_h;
};


//----------------------------------------------------------------------------
// Function:    ConnectRouter
//
// Connects to the router on the specified machine.  Returns the RPC handle
// for that router.
//----------------------------------------------------------------------------
TFSCORE_API(DWORD)	ConnectRouter(LPCTSTR pszMachine, MPR_SERVER_HANDLE *phMachine);

//----------------------------------------------------------------------------
// Function:    GetRouterUpTime
//
// Get the router up time
//----------------------------------------------------------------------------
TFSCORE_API(DWORD)  GetRouterUpTime(IN LPCTSTR pszMachine, OUT DWORD * pdwUpTime);

//----------------------------------------------------------------------------
// Function:    GetRouterPhonebookPath
//
// Constructs the path to the router-phonebook file on the given machine.
//----------------------------------------------------------------------------

HRESULT
GetRouterPhonebookPath(
    IN  LPCTSTR     pszMachine,
    IN  CString *   pstPath );

HRESULT DeleteRouterPhonebook(IN LPCTSTR pszMachine);



CString GetLocalMachineName();



DeclareSPPrivateBasic(SPMprAdminBuffer, BYTE, if (m_p) ::MprAdminBufferFree(m_p));
DeclareSPPrivateBasic(SPMprMibBuffer, BYTE, if (m_p) ::MprAdminMIBBufferFree(m_p));
DeclareSPPrivateBasic(SPMprConfigBuffer, BYTE, if(m_p) ::MprConfigBufferFree(m_p));



/*---------------------------------------------------------------------------
	Function:	ConnectInterface

	Called to connet/disconnect a demand-dial interface.  Displays a dialog
	showing elasped time, allowing the user to cancel the connection.
 ---------------------------------------------------------------------------*/
TFSCORE_API(DWORD)	ConnectInterface(LPCTSTR	pszMachine,
									 LPCTSTR	pszInterface,
									 BOOL		bConnect,
									 HWND		hwndParent);

TFSCORE_API(DWORD) ConnectInterfaceEx(MPR_SERVER_HANDLE hRouter,
									HANDLE hInterface,
									BOOL bConnect,
									HWND hwndParent,
									LPCTSTR pszParent);

/*!--------------------------------------------------------------------------
	PromptForCredentials
		Brings up the Credentials dialog.
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(DWORD)  PromptForCredentials(LPCTSTR pszMachine,
										 LPCTSTR pszInterface,
										 BOOL fNT4,
										 BOOL fNewInterface,
										 HWND hwndParent);

/*!--------------------------------------------------------------------------
	UpdateDDM
		Updates changes to the phonebook entry in the DDM.  Invoke this
		to cause DDM to pick up changes to the phonebook entry
		dynamically.
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(DWORD)	UpdateDDM(IInterfaceInfo *pInterfaceInfo);


/*!--------------------------------------------------------------------------
	UpdateRoutes
	
	Performs an autostatic update on the given machine's interface,
	for a specific transport.

	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(DWORD) UpdateRoutesEx(IN MPR_SERVER_HANDLE hRouter,
								IN HANDLE hInterface,
								IN DWORD dwTransportId,
								IN HWND hwndParent,
							    IN LPCTSTR pszInterface);

TFSCORE_API(DWORD) UpdateRoutes(IN LPCTSTR pszMachine,
								  IN LPCTSTR pszInterface,
								  IN DWORD dwTransportId,
								  IN HWND hwndParent);


/*---------------------------------------------------------------------------
	IsRouterServiceRunning

	Returns S_OK if the service is running.
	Returns S_FALSE if the service is not running.
	Returns an error code otherwise.

	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) IsRouterServiceRunning(IN LPCWSTR pszMachine,
                                            OUT DWORD *pdwErrorCode);
TFSCORE_API(HRESULT) GetRouterServiceStatus(IN LPCWSTR pszMachine,
											OUT DWORD *pdwStatus,
                                            OUT DWORD *pdwErrorCode);
TFSCORE_API(HRESULT) GetRouterServiceStartType(IN LPCWSTR pszMachine,
											   OUT DWORD *pdwStartType);
TFSCORE_API(HRESULT) SetRouterServiceStartType(IN LPCWSTR pszMachine,
											   DWORD dwStartType);

TFSCORE_API(HRESULT) StartRouterService(IN LPCWSTR pszMachine);
TFSCORE_API(HRESULT) StopRouterService(IN LPCWSTR pszMachine);

TFSCORE_API(HRESULT) PauseRouterService(IN LPCWSTR pszMachine);
TFSCORE_API(HRESULT) ResumeRouterService(IN LPCWSTR pszMachine);



TFSCORE_API(HRESULT) ForceGlobalRefresh(IRouterInfo *pRouter);


typedef ComSmartPointer<IRouterProtocolConfig, &IID_IRouterProtocolConfig> SPIRouterProtocolConfig;


typedef ComSmartPointer<IAuthenticationProviderConfig, &IID_IAuthenticationProviderConfig> SPIAuthenticationProviderConfig;


typedef ComSmartPointer<IAccountingProviderConfig, &IID_IAccountingProviderConfig> SPIAccountingProviderConfig;


typedef ComSmartPointer<IEAPProviderConfig, &IID_IEAPProviderConfig> SPIEAPProviderConfig;

typedef ComSmartPointer<IRouterAdminAccess, &IID_IRouterAdminAccess> SPIRouterAdminAccess;


// Some helper functions for IP/IPX
TFSCORE_API(HRESULT)	AddIpPerInterfaceBlocks(IInterfaceInfo *pIf,
												IInfoBase *pInfoBase);
TFSCORE_API(HRESULT)	AddIpxPerInterfaceBlocks(IInterfaceInfo *pIf,
												IInfoBase *pInfoBase);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\addrpool.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999   **/
/**********************************************************************/

#include "stdafx.h"
#include "addrpool.h"
#include "rraswiz.h"
#include "rtrres.h"
#include "rtrcomn.h"


// This is the build where Static Address pools are enabled.
#define STATIC_ADDRESSPOOL_BUILDNO      (2076)


// This function is used to convert numbers in the presence of
// separators.
BOOL ConvertStringToNumber(LPCTSTR pszString, DWORD * pdwRet);
void FilterBadChars (LPCTSTR pszEvilString, CString & stGood);
// This array must match the column indices in the addrpool.h enum.
INT s_rgIPPoolColumnHeadersLong[] =
{
    IDS_IPPOOL_COL_START,
    IDS_IPPOOL_COL_END,
    IDS_IPPOOL_COL_RANGE,
    IDS_IPPOOL_COL_IPADDRESS,
    IDS_IPPOOL_COL_MASK,
    0   // sentinel
};

INT s_rgIPPoolColumnHeadersShort[] =
{
    IDS_IPPOOL_COL_START,
    IDS_IPPOOL_COL_END,
    IDS_IPPOOL_COL_RANGE,
    0   // sentinel
};



/*!--------------------------------------------------------------------------
	InitializeAddressPoolListControl
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InitializeAddressPoolListControl(CListCtrl *pListCtrl,
                                         LPARAM flags,
                                         AddressPoolList *pList)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    HRESULT     hr = hrOK;
	LV_COLUMN   lvCol;  // list view column struct for radius servers
	RECT        rect;
	CString     stColCaption;
    int         nColWidth;
    POSITION    pos;
    AddressPoolInfo pool;
    INT         iPos;
    LV_ITEM     lvItem;
    CString     st, stStart;
    TCHAR       szBuffer[64];
    INT *       prgColumnHeaders = NULL;
    int         cColumns = 0;
    
    ListView_SetExtendedListViewStyle(pListCtrl->GetSafeHwnd(),
                                      LVS_EX_FULLROWSELECT);
    
    // Show a different set of columns depending on the flag
    if (flags & ADDRPOOL_LONG)
    {
        // Subtract one for the sentinel
        cColumns = DimensionOf(s_rgIPPoolColumnHeadersLong) - 1;
        prgColumnHeaders = s_rgIPPoolColumnHeadersLong;
    }
    else
    {
        // Subtract one for the sentinel
        cColumns = DimensionOf(s_rgIPPoolColumnHeadersShort) - 1;
        prgColumnHeaders = s_rgIPPoolColumnHeadersShort;
    }

    // Add the columns to the list control
    
  	pListCtrl->GetClientRect(&rect);
    
    nColWidth = rect.right / cColumns;
    
	lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
	lvCol.fmt = LVCFMT_LEFT;
	lvCol.cx = nColWidth;

    // Insert the columns until we hit the sentinel value.
    for (INT index=0; *prgColumnHeaders; index++,prgColumnHeaders++)
    {
        stColCaption.LoadString( *prgColumnHeaders );
		lvCol.pszText = (LPTSTR)((LPCTSTR) stColCaption);
		pListCtrl->InsertColumn(index, &lvCol);
	}

    // Now we go in and add the data
    if (pList)
    {
        pos = pList->GetHeadPosition();

        lvItem.mask = LVIF_TEXT | LVIF_PARAM;
        lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
        lvItem.state = 0;
        
        while (pos)
        {
            // Break out of the loop if we do not support
            // multiple address pools.
            if (!pList->FUsesMultipleAddressPools() &&
                (pListCtrl->GetItemCount() > 1))
            {
                break;
            }
            
            pool = pList->GetNext(pos);
            
            stStart = INET_NTOA(pool.m_netStart);
            
            lvItem.iItem = pList->GetCount() + 1;
            lvItem.iSubItem = 0;
            lvItem.pszText = (LPTSTR)(LPCTSTR) stStart;
            
            // We use the pool key as a way of finding the item in the
            // list
            lvItem.lParam = pool.m_dwKey;
        
            iPos = pListCtrl->InsertItem(&lvItem);
            if (iPos != -1)
            {
                pListCtrl->SetItemText(iPos, IPPOOLCOL_START, stStart);
                
                st = INET_NTOA(pool.m_netEnd);
                pListCtrl->SetItemText(iPos, IPPOOLCOL_END, st);

                FormatNumber(pool.GetNumberOfAddresses(),
                             szBuffer,
                             DimensionOf(szBuffer),
                             FALSE);
                pListCtrl->SetItemText(iPos, IPPOOLCOL_RANGE, szBuffer);

                if (flags & ADDRPOOL_LONG)
                {
                    st = INET_NTOA(pool.m_netAddress);
                    pListCtrl->SetItemText(iPos, IPPOOLCOL_IPADDRESS, st);
                    
                    st = INET_NTOA(pool.m_netMask);
                    pListCtrl->SetItemText(iPos, IPPOOLCOL_MASK, st);
                }
            }
        }
    }
        
    return hr;
}


/*!--------------------------------------------------------------------------
	OnNewAddressPool
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void OnNewAddressPool(HWND hWnd, CListCtrl *pList, LPARAM flags, AddressPoolList *pPoolList)
{
    LV_ITEM     lvItem;
    CString     st, stStart;
    INT         iPos;
    TCHAR       szBuffer[64];
    AddressPoolInfo   poolInfo;
    
    CAddressPoolDialog dlg(&poolInfo,
                           pPoolList,
                           TRUE);

    if (dlg.DoModal() == IDOK)
    {
        poolInfo.GetNewKey();
        
        // Add this to the list.  
        pPoolList->AddTail(poolInfo);
        
        
        // Add this to the UI        
        stStart = INET_NTOA(poolInfo.m_netStart);
        
        lvItem.mask = LVIF_TEXT | LVIF_PARAM;
        lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
        lvItem.state = 0;
        
        lvItem.iItem = pPoolList->GetCount() + 1;
        lvItem.iSubItem = 0;
        lvItem.pszText = (LPTSTR)(LPCTSTR) stStart;
        
        // We use the pool key as a way of finding the item in the
        // list
        lvItem.lParam = poolInfo.m_dwKey;
        
        iPos = pList->InsertItem(&lvItem);
        if (iPos != -1)
        {
            pList->SetItemText(iPos, IPPOOLCOL_START, stStart);
            
            st = INET_NTOA(poolInfo.m_netEnd);
            pList->SetItemText(iPos, IPPOOLCOL_END, st);
            
            FormatNumber(poolInfo.GetNumberOfAddresses(),
                         szBuffer,
                         DimensionOf(szBuffer),
                         FALSE);
            pList->SetItemText(iPos, IPPOOLCOL_RANGE, szBuffer);

            if (flags & ADDRPOOL_LONG)
            {
                st = INET_NTOA(poolInfo.m_netAddress);
                pList->SetItemText(iPos, IPPOOLCOL_IPADDRESS, st);
                
                st = INET_NTOA(poolInfo.m_netMask);
                pList->SetItemText(iPos, IPPOOLCOL_MASK, st);
            }
        }
    }
}

void OnEditAddressPool(HWND hWnd, CListCtrl *pList, LPARAM flags, AddressPoolList *pPoolList)
{
    INT         iPos;
    DWORD       dwKey = 0;
    POSITION    pos, posT;
    AddressPoolInfo poolInfo;
    TCHAR       szBuffer[64];
    CString     st;
    
    // Is there a selected item?
    if ((iPos = pList->GetNextItem(-1, LVNI_SELECTED)) == -1)
        return;

    dwKey = pList->GetItemData(iPos);

    // Given the key, find it in our list of items
    pos = pPoolList->GetHeadPosition();
    while (pos)
    {
        posT = pos;

        poolInfo = pPoolList->GetNext(pos);

        if (poolInfo.m_dwKey == dwKey)
            break;
    }

    // Did we find a match?
    if (dwKey)
    {
        Assert(posT);
        poolInfo = pPoolList->GetAt(posT);

        CAddressPoolDialog  dlg(&poolInfo,
                                pPoolList,
                                FALSE);

        if (dlg.DoModal() == IDOK)
        {
            // set it back
            st = INET_NTOA(poolInfo.m_netStart);
            pList->SetItemText(iPos, IPPOOLCOL_START, st);
        
            st = INET_NTOA(poolInfo.m_netEnd);
            pList->SetItemText(iPos, IPPOOLCOL_END, st);
            
            FormatNumber(poolInfo.GetNumberOfAddresses(),
                         szBuffer,
                         DimensionOf(szBuffer),
                         FALSE);
            pList->SetItemText(iPos, IPPOOLCOL_RANGE, szBuffer);

            if (flags & ADDRPOOL_LONG)
            {
                st = INET_NTOA(poolInfo.m_netAddress);
                pList->SetItemText(iPos, IPPOOLCOL_IPADDRESS, st);
                
                st = INET_NTOA(poolInfo.m_netMask);
                pList->SetItemText(iPos, IPPOOLCOL_MASK, st);
            }
            
            pPoolList->SetAt(posT, poolInfo);
        }
    }

}


void OnDeleteAddressPool(HWND hWnd, CListCtrl *pList, LPARAM flags, AddressPoolList *pPoolList)
{
    INT         iPos;
    DWORD       dwKey = 0;
    POSITION    pos, posT;
    AddressPoolInfo poolInfo;
    
    // Ok, need to remove the selected item from the list and from the UI

    // Is there a selected item?
    if ((iPos = pList->GetNextItem(-1, LVNI_SELECTED)) == -1)
        return;

    dwKey = pList->GetItemData(iPos);

    // Given the key, find it in our list of items
    pos = pPoolList->GetHeadPosition();
    while (pos)
    {
        posT = pos;

        poolInfo = pPoolList->GetNext(pos);

        if (poolInfo.m_dwKey == dwKey)
            break;
    }

    // Did we find a match?
    if (dwKey)
    {
        INT     nCount;
        
        Assert(posT);
        pPoolList->RemoveAt(posT);
        pList->DeleteItem(iPos);

        // Ok, update the selected state to point at the next item
        nCount = pList->GetItemCount();
        if (nCount > 0)
        {
            iPos = min(nCount-1, iPos);
            pList->SetItemState(iPos, LVIS_SELECTED, LVIS_SELECTED);
        }
    }
        
}


/*!--------------------------------------------------------------------------
	AddressPoolInfo::GetNewKey
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD AddressPoolInfo::GetNewKey()
{
    static  DWORD   s_dwAddressPoolKey = 1;

    m_dwKey = s_dwAddressPoolKey;
    ++s_dwAddressPoolKey;
    return m_dwKey;
}

/*!--------------------------------------------------------------------------
	AddressPoolInfo::SetAddressAndMask
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void AddressPoolInfo::SetAddressAndMask(DWORD netAddress, DWORD netMask)
{
    // Ok, need to determine the start and end address
    DWORD   netStart, netEnd;

    m_netStart = netAddress & netMask;
    m_netEnd = netAddress | ~netMask;
    m_netAddress = netAddress;
    m_netMask = netMask;
}

/*!--------------------------------------------------------------------------
	AddressPoolInfo::SetStartAndEnd
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void AddressPoolInfo::SetStartAndEnd(DWORD netStart, DWORD netEnd)
{
    DWORD   dwAddress, dwMask, dwTemp, dwMaskTemp;
    DWORD   dwStart, dwEnd;
    // Given the start and the end, figure out the address and mask

    // Save the start/end addresses before they get converted to host form.
    m_netStart = netStart;
    m_netEnd = netEnd;
    
    dwStart = ntohl(netStart);
    dwEnd = ntohl(netEnd);

    // This will put 1's where the bits have the same value
    dwTemp = ~(dwStart ^ dwEnd);

    // Now we look for the first 0 bit (looking from high bit to low bit)
    // This will give us our mask
    dwMask = 0;
    dwMaskTemp = 0;
    for (int i=0; i<sizeof(DWORD)*8; i++)
    {
        dwMaskTemp >>= 1;
        dwMaskTemp |= 0x80000000;

        // Is there a zero bit?
        if ((dwMaskTemp & dwTemp) != dwMaskTemp)
        {
            // There is a zero, so we break out.
            break;
        }

        // If not, continue
        dwMask = dwMaskTemp;
    }

    m_netMask = htonl(dwMask);
    m_netAddress = htonl(dwMask & dwStart);
}


/*!--------------------------------------------------------------------------
	AddressPoolList::HrIsValidAddressPool
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AddressPoolList::HrIsValidAddressPool(AddressPoolInfo *pInfo)
{
    DWORD   dwStart, dwEnd; // in host order

    dwStart = ntohl(pInfo->m_netStart);
    dwEnd = ntohl(pInfo->m_netEnd);
    
    // Verify that this is a valid address pool entry.

    // First, check to see that the end is greater than the start
    // We add one to the start address, to include the RAS adapter
    // ----------------------------------------------------------------
    if (dwStart >= dwEnd)
    {
        return IDS_ERR_IP_ADDRESS_POOL_RANGE_TOO_SMALL;
    }

    // Now check to see that the 127 range is not included
    // ----------------------------------------------------------------
    if ((dwEnd >= MAKEIPADDRESS(127,0,0,0)) &&
        (dwStart <= MAKEIPADDRESS(127,255,255,255)))
    {
        return IDS_ERR_IP_ADDRESS_POOL_RANGE_OVERLAPS_127;
    }

    // Check to see that the addresses are in the normal range
    // 1.0.0.0 <= address < 224.0.0.0
    // ----------------------------------------------------------------
    if ((dwStart < MAKEIPADDRESS(1,0,0,0)) ||
        (dwEnd > MAKEIPADDRESS(223,255,255,255)))
    {
        return IDS_ERR_IP_ADDRESS_POOL_RANGE_NOT_NORMAL;
    }

    Assert(pInfo->GetNumberOfAddresses() > 0);

    //$ TODO : Need to check that we don't have overlaps
    if (GetCount())
    {
        POSITION        pos;
        AddressPoolInfo poolInfo;
        DWORD           dwPoolStart, dwPoolEnd;

        pos = GetHeadPosition();

        while (pos)
        {
            poolInfo = GetNext(pos);

            if (poolInfo.m_dwKey == pInfo->m_dwKey)
                continue;

            dwPoolStart = ntohl(poolInfo.m_netStart);
            dwPoolEnd = ntohl(poolInfo.m_netEnd);

            // do we overlap?
            if ((dwEnd >= dwPoolStart) && (dwStart <= dwPoolEnd))
            {
                return IDS_ERR_IP_ADDRESS_POOL_OVERLAP;
            }
        }
    }
    
    return hrOK;
}

BOOL AddressPoolList::FUsesMultipleAddressPools()
{
    return m_fMultipleAddressPools;
}


HRESULT AddressPoolList::LoadFromReg(HKEY hkeyRasIp, DWORD dwBuildNo)
{
    HRESULT     hr = hrOK;
    RegKey      regkeyRasIp;
    RegKey      regkeyPool;
    RegKey      regkeyRange;
    CString     stIpAddr, stIpMask;
    AddressPoolInfo poolInfo;
    DWORD       dwIpAddr, dwMask;
    DWORD       dwFrom, dwTo;
    RegKeyIterator  regkeyIter;
    HRESULT     hrIter;
    CString     stKey;

    m_fMultipleAddressPools = FALSE;

    regkeyRasIp.Attach(hkeyRasIp);

    COM_PROTECT_TRY
    {        
        // Remove all of the old addresses
        RemoveAll();

        // Support multiple address pools only if we are on newer builds.
        // ------------------------------------------------------------
        m_fMultipleAddressPools = (dwBuildNo >= STATIC_ADDRESSPOOL_BUILDNO);

        
        // Check to see if the StaticAddressPool key exists, if so
        // then we use that, otherwise use the ip addr and mask
        // entries
        // Check out RemoteAccess\Parameters\Ip\StaticAddressPool
        // ------------------------------------------------------------
        if ( ERROR_SUCCESS == regkeyPool.Open(regkeyRasIp,
                                              c_szRegValStaticAddressPool))
        {
            TCHAR   szKeyName[32];
            INT     iCount = 0;
            
            // Instead of enumerating we open up the keys one-by-one
            // (to maintain the order of the keys).
            // --------------------------------------------------------
            while (TRUE)
            {
                // Cleanup from previous loop
                // ----------------------------------------------------
                regkeyRange.Close();

                // Setup for this loop
                // ----------------------------------------------------
                wsprintf(szKeyName, _T("%d"), iCount);

                // Try to open the key
                // If we fail, bail out of the loop.
                // ----------------------------------------------------
                if (ERROR_SUCCESS != regkeyRange.Open(regkeyPool, szKeyName))
                    break;

                regkeyRange.QueryValue(c_szRegValFrom, dwFrom);
                regkeyRange.QueryValue(c_szRegValTo, dwTo);

                poolInfo.SetStartAndEnd(htonl(dwFrom), htonl(dwTo));
                poolInfo.GetNewKey();

                // Ok, add this to the list of address ranges
                // ----------------------------------------------------
                AddTail(poolInfo);
                iCount++;
            }
            
        }
        else
        {
            // We can't find the StaticAddressPool key, so use the
            // data in the address/mask entries.
            // --------------------------------------------------------
            regkeyRasIp.QueryValue(c_szRegValIpAddr, stIpAddr);
            regkeyRasIp.QueryValue(c_szRegValIpMask, stIpMask);

            if (!stIpAddr.IsEmpty() && !stIpMask.IsEmpty())
            {
                dwIpAddr = INET_ADDR((LPTSTR) (LPCTSTR) stIpAddr);
                dwMask = INET_ADDR((LPTSTR) (LPCTSTR) stIpMask);
                
                poolInfo.SetAddressAndMask(dwIpAddr, dwMask);
                poolInfo.GetNewKey();

                // Add this to the head of the list
                AddHead(poolInfo);            
            }
        }
    }
    COM_PROTECT_CATCH;

    regkeyRasIp.Detach();
            
    return hr;
}


/*!--------------------------------------------------------------------------
	AddressPoolList::SaveToReg
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AddressPoolList::SaveToReg(HKEY hkeyRasIp, DWORD dwBuildNo)
{
    HRESULT             hr = hrOK;
    AddressPoolInfo     poolInfo;
    CString             stAddress, stMask;
    CString             stRange;
    POSITION            pos;
    RegKey              regkeyRasIp;
    RegKey              regkeyPool;
    RegKey              regkeyRange;
    DWORD               dwCount;
    DWORD               dwErr, dwData;

    regkeyRasIp.Attach(hkeyRasIp);

    COM_PROTECT_TRY
    {
        // Reset the m_fMultipleAddressPools
        m_fMultipleAddressPools = (dwBuildNo >= STATIC_ADDRESSPOOL_BUILDNO);

        // If this is a newer build, use the StaticAddressPoolKey,
        // otherwise use the old keys.
        // ------------------------------------------------------------
        if (m_fMultipleAddressPools)
        {
            // Open RemoteAccess\Parameters\Ip\StaticAddressPool
            // --------------------------------------------------------
            CWRg( regkeyPool.Create(regkeyRasIp,
                                    c_szRegValStaticAddressPool) );

            // Delete all of the current keys in the list
            // ------------------------------------------------------------
            regkeyPool.RecurseDeleteSubKeys();

            // Delete any of the older keys
            // --------------------------------------------------------
            regkeyRasIp.DeleteValue(c_szRegValIpAddr);
            regkeyRasIp.DeleteValue(c_szRegValIpMask);
            
            // Now enumerate through the address pool list and
            // add all of those keys.
            // ------------------------------------------------------------
            if (GetCount())
            {
                pos = GetHeadPosition();
                dwCount = 0;

                while (pos)
                {
                    poolInfo = GetNext(pos);

                    regkeyRange.Close();

                    // This is the title for the key
                    // ------------------------------------------------
                    stRange.Format(_T("%d"), dwCount);

                    CWRg( regkeyRange.Create(regkeyPool, stRange) );

                    dwData = ntohl(poolInfo.m_netStart);
                    CWRg( regkeyRange.SetValue(c_szRegValFrom, dwData) );
                    
                    dwData = ntohl(poolInfo.m_netEnd);
                    CWRg( regkeyRange.SetValue(c_szRegValTo, dwData) );

                    dwCount++;
                }
            }
        }
        else
        {
            // Just write out the first address we find, if there are none then
            // write out blanks (to erase any previous values).
            if (GetCount())
            {
                // Get the first address info
                Assert(GetCount() == 1);
                
                poolInfo = GetHead();
                
                stAddress = INET_NTOA(poolInfo.m_netAddress);
                stMask = INET_NTOA(poolInfo.m_netMask);
                
                CWRg( regkeyRasIp.SetValue( c_szRegValIpAddr, (LPCTSTR) stAddress) );
                CWRg( regkeyRasIp.SetValue( c_szRegValIpMask, (LPCTSTR) stMask) );
            }
            else
            {
                CWRg( regkeyRasIp.SetValue( c_szRegValIpAddr, (LPCTSTR) _T("")) );
                CWRg( regkeyRasIp.SetValue( c_szRegValIpMask, (LPCTSTR) _T("")) );
            }
        }
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    regkeyRasIp.Detach();
        
    return hr;
}


/*---------------------------------------------------------------------------
	CAddressPoolDialog implementation
 ---------------------------------------------------------------------------*/
CAddressPoolDialog::CAddressPoolDialog(
    AddressPoolInfo *pPool,
    AddressPoolList *pPoolList,
    BOOL fCreate)
    : CBaseDialog(IDD_IPPOOL),
    m_pPool(pPool),
    m_fCreate(fCreate),
    m_fReady(FALSE),
    m_pPoolList(pPoolList)
{
}

void CAddressPoolDialog::DoDataExchange(CDataExchange *pDX)
{
    CBaseDialog::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAddressPoolDialog, CBaseDialog)
ON_EN_CHANGE(IDC_IPPOOL_IP_START, OnChangeStartAddress)
ON_EN_CHANGE(IDC_IPPOOL_IP_END, OnChangeEndAddress)
ON_EN_CHANGE(IDC_IPPOOL_EDIT_RANGE, OnChangeRange)
ON_EN_KILLFOCUS(IDC_IPPOOL_IP_START, OnKillFocusStartAddress)
ON_EN_KILLFOCUS(IDC_IPPOOL_IP_END, OnKillFocusEndAddress)
END_MESSAGE_MAP()


BOOL CAddressPoolDialog::OnInitDialog()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    CString     st;
    TCHAR       szBuffer[64];
    
    CBaseDialog::OnInitDialog();

    st.LoadString(m_fCreate ? IDS_ADD_IPPOOL_TITLE : IDS_EDIT_IPPOOL_TITLE);
    SetWindowText((LPCTSTR) st);

    m_ipStartAddress.Create(GetSafeHwnd(), IDC_IPPOOL_IP_START);
    st = INET_NTOA(m_pPool->m_netStart);
    m_ipStartAddress.SetAddress((LPCTSTR) st);
    
    m_ipEndAddress.Create(GetSafeHwnd(), IDC_IPPOOL_IP_END);
    st = INET_NTOA(m_pPool->m_netEnd);
    m_ipEndAddress.SetAddress((LPCTSTR) st);

    GenerateRange();

    m_fReady = TRUE;

    return TRUE;
}

void CAddressPoolDialog::OnOK()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    CString st;
    DWORD   netStart, netEnd;
    HRESULT hr = hrOK;
    UINT    ids = 0;
    
    // Ok, check the validity of the addresses
    // Are all of the fields there?
    if (m_ipStartAddress.IsBlank())
    {
        AfxMessageBox(IDS_ERR_ADDRESS_POOL_NO_START_ADDRESS);
        return;
    }
    if (m_ipEndAddress.IsBlank())
    {
        AfxMessageBox(IDS_ERR_ADDRESS_POOL_NO_END_ADDRESS);
        return;
    }

    m_ipStartAddress.GetAddress(st);
    netStart = INET_ADDR((LPTSTR)(LPCTSTR)st);
    if ((netStart == 0) || (netStart == 0xFFFFFFFF))
    {
        AfxMessageBox(IDS_ERR_ADDRESS_POOL_NO_START_ADDRESS);
        return;
    }
    
    m_ipEndAddress.GetAddress(st);
    netEnd = INET_ADDR((LPTSTR)(LPCTSTR)st);
    if ((netEnd == 0) || (netEnd == 0xFFFFFFFF))
    {
        AfxMessageBox(IDS_ERR_ADDRESS_POOL_NO_END_ADDRESS);
        return;
    }

    m_pPool->SetStartAndEnd(netStart, netEnd);

    if (!FHrOK(hr = m_pPoolList->HrIsValidAddressPool(m_pPool)))
    {
        if (FHrSucceeded(hr))
        {
            // If it is not hrOK and is not an error code,
            // the success code can be interpreted as a string id
            AfxMessageBox(hr);
        }
        return;
    }
    

    CBaseDialog::OnOK();
}

void CAddressPoolDialog::OnChangeStartAddress()
{
    if (m_fReady)
        GenerateRange();
}

void CAddressPoolDialog::OnChangeEndAddress()
{
    if (m_fReady)
        GenerateRange();
}

void CAddressPoolDialog::OnChangeRange()
{
    if (m_fReady)
    {
        CString st;
        DWORD   dwAddr, dwSize;
        DWORD   netAddr;
		DWORD   dwRange;

        m_fReady = FALSE;
    
        // Get the start address and update the end address
        m_ipStartAddress.GetAddress(st);
        dwAddr = ntohl(INET_ADDR(st));

        // Have to read in the text, but strip out the
        // commas in the range, sigh.
        GetDlgItemText(IDC_IPPOOL_EDIT_RANGE, st);
		
		if  ( ConvertStringToNumber(st, &dwRange) )
		{
			dwAddr += dwRange;
			// Subtract 1 since this is an inclusive range
			// i.e.  0..(n-1) is n addresses.
			dwAddr -= 1;			
			netAddr = htonl(dwAddr);
			st = INET_NTOA(netAddr);
			m_ipEndAddress.SetAddress(st);

		}
        else
		{
			CString stGood;
			//Filter the bad chars out of the box
			FilterBadChars (st, stGood);
			SetDlgItemText (IDC_IPPOOL_EDIT_RANGE, stGood );
			AfxMessageBox (IDS_ILLEGAL_CHARACTER, MB_ICONERROR | MB_OK );
		}


        m_fReady = TRUE;
    }
}

void CAddressPoolDialog::OnKillFocusStartAddress()
{
    GenerateRange();

    if (m_ipEndAddress.IsBlank())
    {
        CString st;
        m_ipStartAddress.GetAddress(st);
        m_ipEndAddress.SetAddress(st);
    }
}

void CAddressPoolDialog::OnKillFocusEndAddress()
{
    GenerateRange();
}


void CAddressPoolDialog::GenerateRange()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    DWORD   dwStart, dwEnd;
    TCHAR   szBuffer[64];
    CString st;

    m_ipStartAddress.GetAddress(st);
    dwStart = ntohl(INET_ADDR(st));
    
    m_ipEndAddress.GetAddress(st);
    dwEnd = ntohl(INET_ADDR(st));

    m_fReady = FALSE;

    // Display the range.
    if (dwStart >= dwEnd)
    {
        SetDlgItemInt(IDC_IPPOOL_EDIT_RANGE, 0);
    }
    else
    {
        FormatNumber(dwEnd - dwStart + 1,
                     szBuffer,
                     DimensionOf(szBuffer),
                     FALSE);
        SetDlgItemText(IDC_IPPOOL_EDIT_RANGE, szBuffer);
    }
    m_fReady = TRUE;
}

void FilterBadChars (LPCTSTR pszEvilString, CString & stGood) 
{
    static TCHAR s_szThousandsSeparator[5] = TEXT("");
    static int   s_cchThousands;
	stGood.Empty();
    
    if (s_szThousandsSeparator[0] == TEXT('\0'))
	{
        ::GetLocaleInfo(
                        LOCALE_USER_DEFAULT,
                        LOCALE_STHOUSAND,
                        s_szThousandsSeparator,
                        4
                       );
        s_cchThousands = StrLen(s_szThousandsSeparator);
    }
	while (*pszEvilString )
	{
		if (_istdigit(*pszEvilString))
            stGood += *pszEvilString++;
        else
        {
            // It's not a digit, we need to check to see if this
            // is a separator
            if (StrnCmp(pszEvilString, s_szThousandsSeparator, s_cchThousands) == 0)
            {
                // This is a separtor, skip over the string                
                pszEvilString += s_cchThousands;
            }            
            else
			{
				// skip this character, we're at a character we don't understand
				pszEvilString ++;
			}
		}
	}
}

/*!--------------------------------------------------------------------------
	ConvertStringToNumber
		This will convert the string into a number (even in the presence
        of thousands separtors).
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL ConvertStringToNumber(LPCTSTR pszString, DWORD * pdwRet)
{
    static TCHAR s_szThousandsSeparator[5] = TEXT("");
    static int   s_cchThousands;
    
    if (s_szThousandsSeparator[0] == TEXT('\0'))
	{
        ::GetLocaleInfo(
                        LOCALE_USER_DEFAULT,
                        LOCALE_STHOUSAND,
                        s_szThousandsSeparator,
                        4
                       );
        s_cchThousands = StrLen(s_szThousandsSeparator);
    }


    
    // Make a copy of the string
    TCHAR * psz = (TCHAR *) _alloca((StrLen(pszString) + 1) * sizeof(WCHAR));
    TCHAR * pszCur = psz;

    // Now copy over the characters from pszString to psz, skipping
    // the numeric separators
    int     cLen = StrLen(pszString);
    while (*pszString)
    {
        if (_istdigit(*pszString))
            *pszCur++ = *pszString++;
        else
        {
            // It's not a digit, we need to check to see if this
            // is a separator
            if (StrnCmp(pszString, s_szThousandsSeparator, s_cchThousands) == 0)
            {
                // This is a separtor, skip over the string                
                pszString += s_cchThousands;
            }
            // Else we're done, we're at a character we don't understand
            else
			{
				//this is an error case
				return FALSE;
                break;
			}
        }
    }

    *pdwRet = _tcstoul(psz, NULL, 10);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\addrpool.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999   **/
/**********************************************************************/

/*
   addrpool.h

   FILE HISTORY:
        
*/

#if !defined _ADDRPOOL_H_
#define _ADDRPOOL_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "listctrl.h"
#include "dialog.h"
#include "ipctrl.h"

/*---------------------------------------------------------------------------
	Class:  AddressPoolInfo

    This class holds the information pertaining to the address pool.

    Basically, it holds the start and end addresses (in NETWORK order).
 ---------------------------------------------------------------------------*/
class AddressPoolInfo
{
public:
    AddressPoolInfo() :
            m_netStart(0),
            m_netEnd(0),
            m_netAddress(0),
            m_netMask(0),
            m_dwKey(0) {};
    
    DWORD   m_netStart;
    DWORD   m_netEnd;

    DWORD   m_netAddress;
    DWORD   m_netMask;

    DWORD   m_dwKey;

    DWORD   GetNumberOfAddresses()
            { return ntohl(m_netEnd) - ntohl(m_netStart) + 1; }

    // Calculate the address and the mask from the start/end address
    BOOL    Calc(DWORD *pdwAddress, DWORD *pdwMask);
    DWORD   GetNewKey();

    // This is the back door provided for compatibility until the
    // service is fixed.  You can set the address and mask and
    // add an entry (I will backfill the start/end address).
    // dwAddress and dwMask are in NETWORK order.
    void    SetAddressAndMask(DWORD dwAddress, DWORD dwMask);
    void    SetStartAndEnd(DWORD dwStart, DWORD dwEnd);
};

typedef CList<AddressPoolInfo, AddressPoolInfo &> AddressPoolListBase;


class AddressPoolList : public AddressPoolListBase
{
public:
    AddressPoolList()
            : m_fMultipleAddressPools(FALSE)
        {
        }
    
    // This function checks to see if there are any conflicts
    // with any other address pools (we don't allow overlaps).
    // Returns S_OK if it is ok.
    // Else if is a success code, it is a string id of an error
    // Else if is a failure code, it is an error code
    HRESULT HrIsValidAddressPool(AddressPoolInfo *pInfo);


    // This will return TRUE if address pools are supported.
    // This will return FALSE if the old style, single address
    // pools are used.
    // This will not be set correctly until LoadFromReg() is called.
    BOOL    FUsesMultipleAddressPools();


    // Load the information from the regsitry.  If the StaticAddressPool
    // key does not exist, read from the old address/mask keys.
    HRESULT LoadFromReg(HKEY hkeyRasIP, DWORD dwBuildNo);

    // Save the information to the registry.  If the StaticAddressPool
    // key does not exist, write out the first address in the address pool
    // to the old address/mask keys.
    HRESULT SaveToReg(HKEY hkeyRasIP, DWORD dwBuildNo);

protected:
    BOOL    m_fMultipleAddressPools;
};



// Displays the long version of the address pool control.  This
// will show the start/stop/count/address/mask columns.
// The short version shows the start/stop/count columns.  The short
// version is intended for the wizard pages.
#define ADDRPOOL_LONG  0x01

HRESULT InitializeAddressPoolListControl(CListCtrl *pListCtrl,
                                         LPARAM flags,
                                         AddressPoolList *pList);
void    OnNewAddressPool(HWND hWnd,
                         CListCtrl *pList,
                         LPARAM flags,
                         AddressPoolList *pPoolList);
void    OnEditAddressPool(HWND hWnd,
                          CListCtrl *pList,
                          LPARAM flags,
                          AddressPoolList *pPoolList);
void    OnDeleteAddressPool(HWND hWnd,
                            CListCtrl *pList,
                            LPARAM flags,
                            AddressPoolList *pPoolList);


class CAddressPoolDialog : public CBaseDialog
{
public:
    CAddressPoolDialog(AddressPoolInfo *pPool,
                       AddressPoolList *pPoolList,
                       BOOL fCreate);

protected:
	virtual VOID DoDataExchange(CDataExchange *pDX);
	virtual BOOL OnInitDialog();
    virtual void OnOK();

	afx_msg void OnChangeStartAddress();
    afx_msg void OnChangeEndAddress();
    afx_msg void OnChangeRange();
    afx_msg void OnKillFocusStartAddress();
    afx_msg void OnKillFocusEndAddress();

    void GenerateRange();

    BOOL                m_fCreate;
    BOOL                m_fReady;
    AddressPoolInfo *   m_pPool;
    AddressPoolList *   m_pPoolList;

    IPControl   m_ipStartAddress;
    IPControl   m_ipEndAddress;
    
	DECLARE_MESSAGE_MAP()
};


/*---------------------------------------------------------------------------
	This enum defines the columns for Address pool controls.
 ---------------------------------------------------------------------------*/
enum
{
    IPPOOLCOL_START = 0,
    IPPOOLCOL_END,
    IPPOOLCOL_RANGE,
    IPPOOLCOL_IPADDRESS,
    IPPOOLCOL_MASK,
    IPPOOLCOL_COUNT,
};

#endif // !defined _ADDRPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\atlkcomp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	atlkcomp.cpp
		This file contains the derived classes for CComponent and 
		CComponentData.  Most of these functions are pure virtual 
		functions that need to be overridden for snapin functionality.
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "atlkcomp.h"
#include "atlkroot.h"
#include "atlkstrm.h"
#include "atlkview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// This is dmvcomp.cpp
extern UINT g_uIconMap[][2];


/*---------------------------------------------------------------------------
	CatlkComponent
 ---------------------------------------------------------------------------*/



/////////////////////////////////////////////////////////////////////////////
// CATLKComponent implementation

CATLKComponent::CATLKComponent()
{
	extern const ContainerColumnInfo	s_rgATLKViewColumnInfo[];

	m_ComponentConfig.Init(ATLK_COLUMNS_MAX_COUNT);

	m_ComponentConfig.InitViewInfo(ATLK_COLUMNS,
                                   FALSE /* configurable columns */,
								   ATLK_SI_MAX_COLUMNS,
								   TRUE,
								   s_rgATLKViewColumnInfo);
	
	m_ulUserData = reinterpret_cast<LONG_PTR>(&m_ComponentConfig);
}

CATLKComponent::~CATLKComponent()
{
}

STDMETHODIMP_(ULONG) CATLKComponent::AddRef()
{
	return TFSComponent::AddRef();
}

STDMETHODIMP_(ULONG) CATLKComponent::Release()
{
	return TFSComponent::Release();
}

STDMETHODIMP CATLKComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

	if (riid == IID_IPersistStreamInit)
		*ppv = static_cast<IPersistStreamInit *>(this);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
    }
    else
		return TFSComponent::QueryInterface(riid, ppv);
}

STDMETHODIMP CATLKComponent::OnUpdateView(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param)
{
	
	return TFSComponent::OnUpdateView(pDataObject, arg, param);
}

STDMETHODIMP CATLKComponent::InitializeBitmaps(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(m_spImageList != NULL);

	HICON	hIcon;
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		for (int i = 0; i < IMAGE_IDX_MAX; i++)
		{
			hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
			if (hIcon)
			{
				// call mmc
				m_spImageList->ImageListSetIcon(reinterpret_cast<LONG_PTR*>(hIcon), g_uIconMap[i][1]);
			}
		}
	}
	COM_PROTECT_CATCH;

    return hr;
}

STDMETHODIMP CATLKComponent::QueryDataObject(MMC_COOKIE cookie,
											   DATA_OBJECT_TYPES type,
											   LPDATAOBJECT *ppDataObject)
{
	HRESULT		hr = hrOK;
	SPITFSNode	spNode;
	SPITFSResultHandler	spResultHandler;

	COM_PROTECT_TRY
	{
		CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

		CORg( spNode->GetResultHandler(&spResultHandler) );

		CORg( spResultHandler->OnCreateDataObject(this, cookie,
			type, ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}


STDMETHODIMP CATLKComponent::GetClassID(LPCLSID lpClassID)
{
    ASSERT(lpClassID != NULL);

    // Copy the CLSID for this snapin
    *lpClassID = CLSID_ATLKAdminExtension;

    return hrOK;
}
STDMETHODIMP CATLKComponent::IsDirty()
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{		
		hr = m_ComponentConfig.GetDirty() ? hrOK : hrFalse;
	}
	COM_PROTECT_CATCH;
	return hr;
}
STDMETHODIMP CATLKComponent::Load(LPSTREAM pStm)
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{		
	hr = m_ComponentConfig.LoadFrom(pStm);
	}
	COM_PROTECT_CATCH;
	return hr;
}
STDMETHODIMP CATLKComponent::Save(LPSTREAM pStm, BOOL fClearDirty)
{
	HRESULT	hr = hrOK;
	SPITFSResultHandler	spResultHandler;
	COM_PROTECT_TRY
	{
	   // Need to see if we can save the selected node
	   // -------------------------------------------------------------
	   if (m_spSelectedNode)
	   {
		   m_spSelectedNode->GetResultHandler(&spResultHandler);
		   if (spResultHandler)
			   spResultHandler->UserResultNotify(m_spSelectedNode,
				   RRAS_ON_SAVE, (LPARAM)(ITFSComponent *) this);
	   }
	   
	   hr = m_ComponentConfig.SaveTo(pStm);
	   if (FHrSucceeded(hr) && fClearDirty)
		   m_ComponentConfig.SetDirty(FALSE);
	}
	COM_PROTECT_CATCH;
	return hr;
}
STDMETHODIMP CATLKComponent::GetSizeMax(ULARGE_INTEGER FAR *pcbSize)
{
	Assert(pcbSize);
	HRESULT	hr = hrOK;
	ULONG	cbSize = 0;

	COM_PROTECT_TRY
	{
		hr = m_ComponentConfig.GetSize(&cbSize);
		if (FHrSucceeded(hr))
		{
			pcbSize->HighPart = 0;
			pcbSize->LowPart = cbSize;
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}
STDMETHODIMP CATLKComponent::InitNew()
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{		
		hr = m_ComponentConfig.InitNew();
	}
	COM_PROTECT_CATCH;
	return hr;
}






/////////////////////////////////////////////////////////////////////////////
// CATLKComponentData implementation

CATLKComponentData::CATLKComponentData()
{
}

/*!--------------------------------------------------------------------------
	CATLKComponentData::OnInitialize
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CATLKComponentData::OnInitialize(LPIMAGELIST pScopeImage)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	Assert(pScopeImage);

    // add the images for the scope tree
	HICON	hIcon;
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		for (int i = 0; i < IMAGE_IDX_MAX; i++)
		{
			hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
			if (hIcon)
			{
				// call mmc
				VERIFY(SUCCEEDED(pScopeImage->ImageListSetIcon(reinterpret_cast<LONG_PTR*>(hIcon), g_uIconMap[i][1])));
			}
		}
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	CATLKComponentData::OnInitializeNodeMgr
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CATLKComponentData::OnInitializeNodeMgr(ITFSComponentData *pTFSCompData, ITFSNodeMgr *pNodeMgr)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// For now create a new node handler for each new node,
	// this is rather bogus as it can get expensive.  We can
	// consider creating only a single node handler for each
	// node type.
	ATLKRootHandler *	pHandler = NULL;
	SPITFSNodeHandler	spHandler;
	SPITFSNode			spNode;
	HRESULT				hr = hrOK;

	COM_PROTECT_TRY
	{
		pHandler = new ATLKRootHandler(pTFSCompData);

		// Do this so that it will get released correctly
		spHandler = pHandler;
		pHandler->Init();
	
		// Create the root node for this sick puppy
		CORg( CreateContainerTFSNode(&spNode,
									 &GUID_ATLKRootNodeType,
									 pHandler,
									 pHandler /* result handler */,
									 pNodeMgr) );

		// Construct the node
		CORg( pHandler->ConstructNode(spNode) );

		CORg( pNodeMgr->SetRootNode(spNode) );
		
		// Reference the help file name.
		pTFSCompData->SetHTMLHelpFileName(_T("mprsnap.chm"));

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	CATLKComponentData::OnCreateComponent
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CATLKComponentData::OnCreateComponent(LPCOMPONENT *ppComponent)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(ppComponent != NULL);
	
	HRESULT		hr = hrOK;
	CATLKComponent *	pComp = NULL;

	COM_PROTECT_TRY
	{
		pComp = new CATLKComponent;

		if (FHrSucceeded(hr))
		{
			pComp->Construct(m_spNodeMgr,
							 static_cast<IComponentData *>(this),
							 m_spTFSComponentData);
			*ppComponent = static_cast<IComponent *>(pComp);
		}
	}
	COM_PROTECT_CATCH;
	
	return hr;
}


STDMETHODIMP CATLKComponentData::OnDestroy()
{
	m_spNodeMgr.Release();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	CATLKComponentData::GetCoClassID
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(const CLSID *) CATLKComponentData::GetCoClassID()
{
	return &CLSID_ATLKAdminExtension;
}

/*!--------------------------------------------------------------------------
	CATLKComponentData::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CATLKComponentData::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

	CDataObject *	pObject = NULL;
	SPIDataObject	spDataObject;
	HRESULT			hr = hrOK;
	SPITFSNode		spNode;
	SPITFSNodeHandler	spHandler;

	COM_PROTECT_TRY
	{
		CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

		CORg( spNode->GetHandler(&spHandler) );

		CORg( spHandler->OnCreateDataObject(cookie, type, &spDataObject) );

		*ppDataObject = spDataObject.Transfer();
		
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;

	return hr;
}


///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members

STDMETHODIMP CATLKComponentData::GetClassID
(
	CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_ATLKAdminExtension;

    return hrOK;
}

STDMETHODIMP CATLKComponentData::IsDirty()
{
	SPITFSNode	spNode;
	SPITFSNodeHandler	spHandler;
	SPIPersistStreamInit	spStm;
	
	m_spNodeMgr->GetRootNode(&spNode);
	spNode->GetHandler(&spHandler);
	spStm.Query(spHandler);
	Assert(spStm);
	
	return (spNode->GetData(TFS_DATA_DIRTY) || spStm->IsDirty()) ? hrOK : hrFalse;
}

STDMETHODIMP CATLKComponentData::Load
(
	IStream *pStm
)
{
	SPITFSNode	spNode;
	SPITFSNodeHandler	spHandler;
	SPIPersistStreamInit	spStm;
	
	m_spNodeMgr->GetRootNode(&spNode);
	spNode->GetHandler(&spHandler);
	spStm.Query(spHandler);
	
	Assert(spStm);
	return spStm->Load(pStm);
}


STDMETHODIMP CATLKComponentData::Save
(
	IStream *pStm, 
	BOOL	 fClearDirty
)
{
	SPITFSNode	spNode;
	SPITFSNodeHandler	spHandler;
	SPIPersistStreamInit	spStm;
	
	m_spNodeMgr->GetRootNode(&spNode);
	spNode->GetHandler(&spHandler);
	spStm.Query(spHandler);
	
	Assert(spStm);
	return spStm->Save(pStm, fClearDirty);
}


STDMETHODIMP CATLKComponentData::GetSizeMax
(
	ULARGE_INTEGER *pcbSize
)
{
	SPITFSNode	spNode;
	SPITFSNodeHandler	spHandler;
	SPIPersistStreamInit	spStm;
	
	m_spNodeMgr->GetRootNode(&spNode);
	spNode->GetHandler(&spHandler);
	spStm.Query(spHandler);
	
	Assert(spStm);
	return spStm->GetSizeMax(pcbSize);
}

STDMETHODIMP CATLKComponentData::InitNew()
{
	SPITFSNode	spNode;
	SPITFSNodeHandler	spHandler;
	SPIPersistStreamInit	spStm;
	
	m_spNodeMgr->GetRootNode(&spNode);
	spNode->GetHandler(&spHandler);
	spStm.Query(spHandler);
	
	Assert(spStm);
	return spStm->InitNew();
}



HRESULT CATLKComponentData::FinalConstruct()
{
	HRESULT				hr = hrOK;
	
	hr = CComponentData::FinalConstruct();
	
	if (FHrSucceeded(hr))
	{
		m_spTFSComponentData->GetNodeMgr(&m_spNodeMgr);
	}
	return hr;
}

void CATLKComponentData::FinalRelease()
{
	CComponentData::FinalRelease();
}


/*!--------------------------------------------------------------------------
	CATLKComponent::OnSnapinHelp
		-
	Author: MikeG (a-migall)
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CATLKComponent::OnSnapinHelp(
	LPDATAOBJECT	pDataObject,
	LPARAM			arg, 
	LPARAM			param)
{
	UNREFERENCED_PARAMETER(pDataObject);
	UNREFERENCED_PARAMETER(arg);
	UNREFERENCED_PARAMETER(param);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HtmlHelpA(NULL,					// caller
			  "mprsnap.chm",		// help file
			  HH_DISPLAY_TOPIC,		// command
			  0);					// data

	return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\aggwrap.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	aggwrap.cpp

	Router aggregation wrappers.
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "infoi.h"


/*---------------------------------------------------------------------------
	RouterInfoAggregationWrapper
		This class is provided to use in an aggregation.
 ---------------------------------------------------------------------------*/
class RouterInfoAggregationWrapper :
   public IRouterInfo,
   public IRouterAdminAccess
{
public:
	RouterInfoAggregationWrapper(IRouterInfo *pInfo, IUnknown *punkOuter);
	virtual ~RouterInfoAggregationWrapper()
		{ DEBUG_DECREMENT_INSTANCE_COUNTER(RouterInfoAggregationWrapper); };

	// override the QI, we will use the AddRef/Release implementation
	// in the CDataObject
	DeclareIUnknownMembers(IMPL)
    DeclareIRouterRefreshAccessMembers(IMPL)
	DeclareIRouterInfoMembers(IMPL)
    DeclareIRouterAdminAccessMembers(IMPL)

	IUnknown * GetNonDelegatingIUnknown() { return &m_ENonDelegatingIUnknown; }

protected:
	LONG			m_cRef;
	SPIRouterInfo	m_spRouterInfo;

	DECLARE_AGGREGATION_NONDELEGATING_IUNKNOWN(RouterInfoAggregationWrapper)

};

IMPLEMENT_AGGREGATION_IUNKNOWN(RouterInfoAggregationWrapper)

IMPLEMENT_AGGREGATION_NONDELEGATING_ADDREFRELEASE(RouterInfoAggregationWrapper, IRouterInfo)

STDMETHODIMP RouterInfoAggregationWrapper::ENonDelegatingIUnknown::QueryInterface(REFIID riid, LPVOID *ppv)
{
	InitPThis(RouterInfoAggregationWrapper, ENonDelegatingIUnknown);
	if (ppv == NULL) 
		return E_INVALIDARG; 
	*ppv = NULL; 
	if (riid == IID_IUnknown) 
		*ppv = (IUnknown *) this; 
	else if (riid == IID_IRouterInfo) 
		*ppv = (IRouterInfo *) pThis;
    else if (riid == IID_IRouterRefreshAccess)
        *ppv = (IRouterRefreshAccess *) pThis;
    else if (riid == IID_IRouterAdminAccess)
        *ppv = (IRouterAdminAccess *) pThis;
	else 
		return E_NOINTERFACE; 
	((IUnknown *)*ppv)->AddRef(); 
	return hrOK; 
} 

DEBUG_DECLARE_INSTANCE_COUNTER(RouterInfoAggregationWrapper);

RouterInfoAggregationWrapper::RouterInfoAggregationWrapper(IRouterInfo *pInfo, IUnknown *punkOuter)
	: m_cRef(1)
{
	m_spRouterInfo.Set(pInfo);

	DEBUG_INCREMENT_INSTANCE_COUNTER(RouterInfoAggregationWrapper);
	
	if (punkOuter)
		m_pUnknownOuter = punkOuter;
	else
		m_pUnknownOuter = &m_ENonDelegatingIUnknown;
}


STDMETHODIMP_(DWORD) RouterInfoAggregationWrapper::GetFlags()
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->GetFlags();
}

STDMETHODIMP RouterInfoAggregationWrapper::SetFlags(DWORD dwFlags)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->SetFlags(dwFlags);
}

HRESULT	RouterInfoAggregationWrapper::Load(LPCOLESTR   pszMachine,
								   HANDLE      hMachine)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->Load(pszMachine, hMachine);
}
				 
HRESULT	RouterInfoAggregationWrapper::Save(LPCOLESTR     pszMachine,
								   HANDLE      hMachine )
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->Save(pszMachine, hMachine);
}
	
HRESULT	RouterInfoAggregationWrapper::Unload( )
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->Unload();
}
	
	
HRESULT RouterInfoAggregationWrapper::Merge(IRouterInfo *pNewRouterInfo)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->Merge(pNewRouterInfo);
}

HRESULT RouterInfoAggregationWrapper::GetRefreshObject(IRouterRefresh **ppRefresh)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->GetRefreshObject(ppRefresh);
}
	
HRESULT RouterInfoAggregationWrapper::SetExternalRefreshObject(IRouterRefresh *pRefresh)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->SetExternalRefreshObject(pRefresh);
}
	
	
HRESULT	RouterInfoAggregationWrapper::CopyCB(RouterCB *pRouterCB)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->CopyCB(pRouterCB);
}
	
LPCOLESTR RouterInfoAggregationWrapper::GetMachineName()
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->GetMachineName();
}

HRESULT RouterInfoAggregationWrapper::SetMachineName(LPCOLESTR pszMachine)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->SetMachineName(pszMachine);
}


DWORD RouterInfoAggregationWrapper::GetRouterType()
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->GetRouterType();
}

HRESULT RouterInfoAggregationWrapper::GetRouterVersionInfo(RouterVersionInfo *pVerInfo)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->GetRouterVersionInfo(pVerInfo);
}

HRESULT	RouterInfoAggregationWrapper::EnumRtrMgrCB( IEnumRtrMgrCB **ppEnumRtrMgrCB)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->EnumRtrMgrCB(ppEnumRtrMgrCB);
}

HRESULT RouterInfoAggregationWrapper::EnumInterfaceCB( IEnumInterfaceCB **ppEnumInterfaceCB)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->EnumInterfaceCB(ppEnumInterfaceCB);
}

HRESULT RouterInfoAggregationWrapper::EnumRtrMgrProtocolCB( IEnumRtrMgrProtocolCB **ppEnumRmProtCB)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->EnumRtrMgrProtocolCB(ppEnumRmProtCB);
}

HRESULT RouterInfoAggregationWrapper::EnumRtrMgrInterfaceCB( IEnumRtrMgrInterfaceCB **ppEnumRmIfCB)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->EnumRtrMgrInterfaceCB(ppEnumRmIfCB);
}

HRESULT RouterInfoAggregationWrapper::EnumRtrMgrProtocolInterfaceCB( IEnumRtrMgrProtocolInterfaceCB **ppEnumRmProtIfCB)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->EnumRtrMgrProtocolInterfaceCB(ppEnumRmProtIfCB);
}
	
HRESULT	RouterInfoAggregationWrapper::EnumRtrMgr( IEnumRtrMgrInfo **ppEnumRtrMgr)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->EnumRtrMgr(ppEnumRtrMgr);
}

HRESULT RouterInfoAggregationWrapper::FindRtrMgr( DWORD dwTransportId,
					    IRtrMgrInfo **ppInfo)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->FindRtrMgr(dwTransportId, ppInfo);
}

HRESULT RouterInfoAggregationWrapper::AddRtrMgr( IRtrMgrInfo *pInfo,
					   IInfoBase *pGlobalInfo,
					   IInfoBase *pClientInfo)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->AddRtrMgr(pInfo, pGlobalInfo, pClientInfo);
}

HRESULT	RouterInfoAggregationWrapper::DeleteRtrMgr( DWORD dwTransportId, BOOL fRemove)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->DeleteRtrMgr(dwTransportId, fRemove);
}

HRESULT	RouterInfoAggregationWrapper::ReleaseRtrMgr( DWORD dwTransportId)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->ReleaseRtrMgr(dwTransportId);
}

HRESULT RouterInfoAggregationWrapper::EnumInterface( IEnumInterfaceInfo **ppEnumInterface)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->EnumInterface(ppEnumInterface);
}

HRESULT RouterInfoAggregationWrapper::FindInterface( LPCOLESTR pszInterface,
						   IInterfaceInfo **ppInfo)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->FindInterface(pszInterface, ppInfo);
}

HRESULT	RouterInfoAggregationWrapper::AddInterface( IInterfaceInfo *pInfo)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->AddInterface(pInfo);
}

HRESULT	RouterInfoAggregationWrapper::DeleteInterface( LPCOLESTR pszInterface, BOOL fRemove)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->DeleteInterface(pszInterface, fRemove);
}

HRESULT	RouterInfoAggregationWrapper::ReleaseInterface( LPCOLESTR pszInterface)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->ReleaseInterface(pszInterface);
}

HRESULT	RouterInfoAggregationWrapper::RtrAdvise( IRtrAdviseSink *pRtrAdviseSink,
 					   LONG_PTR *pulConnection, LPARAM lUserParam)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->RtrAdvise(pRtrAdviseSink, pulConnection, lUserParam);
}

HRESULT RouterInfoAggregationWrapper::RtrNotify(DWORD dwChangeType, DWORD dwObjectType, LPARAM lParam)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->RtrNotify(dwChangeType, dwObjectType, lParam);
}

HRESULT RouterInfoAggregationWrapper::RtrUnadvise( LONG_PTR ulConnection)
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->RtrUnadvise(ulConnection);
}


HRESULT	RouterInfoAggregationWrapper::DoDisconnect()
{
	Assert(m_spRouterInfo);
	return m_spRouterInfo->DoDisconnect();
}

HRESULT	RouterInfoAggregationWrapper::AddWeakRef()
{
	Panic0("Should not be calling AddWeakRef from the Data object!");
	return E_FAIL;
}

HRESULT	RouterInfoAggregationWrapper::ReleaseWeakRef()
{
	Panic0("Should not be calling ReleaseWeakRef from the Data object!");
	return E_FAIL;
}

HRESULT	RouterInfoAggregationWrapper::Destruct()
{
	Panic0("Should not be calling Destruct from the Data object!");
	return E_FAIL;
}

BOOL RouterInfoAggregationWrapper::IsAdminInfoSet()
{
	Assert(m_spRouterInfo);
    SPIRouterAdminAccess    spAdmin;

    spAdmin.HrQuery(m_spRouterInfo);
    Assert(spAdmin);
	return spAdmin->IsAdminInfoSet();
}

LPCOLESTR RouterInfoAggregationWrapper::GetUserName()
{
	Assert(m_spRouterInfo);
    SPIRouterAdminAccess    spAdmin;

    spAdmin.HrQuery(m_spRouterInfo);
    Assert(spAdmin);
	return spAdmin->GetUserName();
}

LPCOLESTR RouterInfoAggregationWrapper::GetDomainName()
{
	Assert(m_spRouterInfo);
    SPIRouterAdminAccess    spAdmin;

    spAdmin.HrQuery(m_spRouterInfo);
    Assert(spAdmin);
	return spAdmin->GetUserName();
}

HRESULT RouterInfoAggregationWrapper::GetUserPassword(BYTE *pByte,
    int *pcPassword)
{
	Assert(m_spRouterInfo);
    SPIRouterAdminAccess    spAdmin;

    spAdmin.HrQuery(m_spRouterInfo);
    Assert(spAdmin);
	return spAdmin->GetUserPassword(pByte, pcPassword);
}

HRESULT RouterInfoAggregationWrapper::SetInfo(LPCOLESTR pszName,
                                              LPCOLESTR pszDomain,
                                              BYTE *pPassword,
                                              int cPassword)
{
	Assert(m_spRouterInfo);
    SPIRouterAdminAccess    spAdmin;

    spAdmin.HrQuery(m_spRouterInfo);
    Assert(spAdmin);
	return spAdmin->SetInfo(pszName, pszDomain, pPassword,
                            cPassword);
}


/*!--------------------------------------------------------------------------
	CreateRouterInfoAggregation
		Takes an existing IRouterInfo and aggregates that with the
		passed-in object.  It returns a pointer to the non-delegating
		IUnknown on the IRouterInfo.  This pointer is held by the
		controlling IUnknown.
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) CreateRouterInfoAggregation(IRouterInfo *pInfo,
	IUnknown *punk, IUnknown **ppNonDelegatingIUnknown)
{
	RouterInfoAggregationWrapper *	pAgg = NULL;
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		pAgg = new RouterInfoAggregationWrapper(pInfo, punk);
		*ppNonDelegatingIUnknown = pAgg->GetNonDelegatingIUnknown();
	}
	COM_PROTECT_CATCH;
	return hr;
}


/*---------------------------------------------------------------------------
	InterfaceInfoAggregationWrapper implementation
 ---------------------------------------------------------------------------*/
class InterfaceInfoAggregationWrapper :
   public IInterfaceInfo
{
public:
	InterfaceInfoAggregationWrapper(IInterfaceInfo *pInfo, IUnknown *punkOuter);
	virtual ~InterfaceInfoAggregationWrapper()
		{ DEBUG_DECREMENT_INSTANCE_COUNTER(InterfaceInfoAggregationWrapper); };

	// override the QI, we will use the AddRef/Release implementation
	// in the CDataObject
	DeclareIUnknownMembers(IMPL)
	DeclareIInterfaceInfoMembers(IMPL)

	IUnknown * GetNonDelegatingIUnknown() { return &m_ENonDelegatingIUnknown; }
	
protected:
	LONG			m_cRef;
	SPIInterfaceInfo	m_spInterfaceInfo;

	DECLARE_AGGREGATION_NONDELEGATING_IUNKNOWN(InterfaceInfoAggregationWrapper)
};

IMPLEMENT_AGGREGATION_IUNKNOWN(InterfaceInfoAggregationWrapper)

IMPLEMENT_AGGREGATION_NONDELEGATING_IUNKNOWN(InterfaceInfoAggregationWrapper, IInterfaceInfo)

DEBUG_DECLARE_INSTANCE_COUNTER(InterfaceInfoAggregationWrapper);

InterfaceInfoAggregationWrapper::InterfaceInfoAggregationWrapper(IInterfaceInfo *pInfo, IUnknown *punkOuter)
	: m_cRef(1)
{
	m_spInterfaceInfo.Set(pInfo);

	DEBUG_INCREMENT_INSTANCE_COUNTER(InterfaceInfoAggregationWrapper);
	
	if (punkOuter)
		m_pUnknownOuter = punkOuter;
	else
		m_pUnknownOuter = &m_ENonDelegatingIUnknown;
}


STDMETHODIMP_(DWORD) InterfaceInfoAggregationWrapper::GetFlags()
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->GetFlags();
}

STDMETHODIMP InterfaceInfoAggregationWrapper::SetFlags(DWORD dwFlags)
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->SetFlags(dwFlags);
}

STDMETHODIMP InterfaceInfoAggregationWrapper::Load(LPCOLESTR   pszMachine,
										   HANDLE      hMachine,
										   HANDLE hInterface)
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->Load(pszMachine, hMachine, hInterface);
}
				 
STDMETHODIMP InterfaceInfoAggregationWrapper::Save(LPCOLESTR     pszMachine,
										   HANDLE      hMachine,
										   HANDLE hInterface)
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->Save(pszMachine, hMachine, hInterface);
}

STDMETHODIMP InterfaceInfoAggregationWrapper::Delete(LPCOLESTR pszMachine,
											 HANDLE hMachine)
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->Delete(pszMachine, hMachine);
}
	
STDMETHODIMP InterfaceInfoAggregationWrapper::Unload( )
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->Unload();
}
	
STDMETHODIMP InterfaceInfoAggregationWrapper::Merge(IInterfaceInfo *pIf)
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->Merge(pIf);
}

STDMETHODIMP_(LPCOLESTR) InterfaceInfoAggregationWrapper::GetId()
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->GetId();
}

STDMETHODIMP_(DWORD) InterfaceInfoAggregationWrapper::GetInterfaceType()
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->GetInterfaceType();
}

STDMETHODIMP_(LPCOLESTR) InterfaceInfoAggregationWrapper::GetDeviceName()
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->GetDeviceName();
}

	
STDMETHODIMP_(LPCOLESTR) InterfaceInfoAggregationWrapper::GetTitle()
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->GetTitle();
}

STDMETHODIMP InterfaceInfoAggregationWrapper::SetTitle( LPCOLESTR pszTitle)
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->SetTitle(pszTitle);
}

	
STDMETHODIMP_(BOOL)	InterfaceInfoAggregationWrapper::IsInterfaceEnabled()
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->IsInterfaceEnabled();
}

STDMETHODIMP InterfaceInfoAggregationWrapper::SetInterfaceEnabledState( BOOL bEnabled)
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->SetInterfaceEnabledState(bEnabled);
}

	
STDMETHODIMP InterfaceInfoAggregationWrapper::CopyCB(InterfaceCB *pifcb)
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->CopyCB(pifcb);
}

	
STDMETHODIMP_(LPCOLESTR) InterfaceInfoAggregationWrapper::GetMachineName()
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->GetMachineName();
}

STDMETHODIMP InterfaceInfoAggregationWrapper::SetMachineName( LPCOLESTR pszMachine)
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->SetMachineName(pszMachine);
}


STDMETHODIMP InterfaceInfoAggregationWrapper::EnumRtrMgrInterface( IEnumRtrMgrInterfaceInfo **ppEnumRMIf)
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->EnumRtrMgrInterface(ppEnumRMIf);
}

STDMETHODIMP InterfaceInfoAggregationWrapper::AddRtrMgrInterface( IRtrMgrInterfaceInfo *pInfo,
								    IInfoBase *pInterfaceInfo)
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->AddRtrMgrInterface(pInfo, pInterfaceInfo);
}

STDMETHODIMP InterfaceInfoAggregationWrapper::DeleteRtrMgrInterface( DWORD dwTransportId, BOOL fRemove)
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->DeleteRtrMgrInterface(dwTransportId, fRemove);
}

STDMETHODIMP InterfaceInfoAggregationWrapper::ReleaseRtrMgrInterface( DWORD dwTransportId)
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->ReleaseRtrMgrInterface(dwTransportId);
}

STDMETHODIMP InterfaceInfoAggregationWrapper::FindRtrMgrInterface( DWORD dwTransportId,
								    IRtrMgrInterfaceInfo **ppInfo)
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->FindRtrMgrInterface(dwTransportId, ppInfo);
}

	
STDMETHODIMP InterfaceInfoAggregationWrapper::RtrAdvise( IRtrAdviseSink *pRtrAdviseSink,
					   LONG_PTR *pulConnection, LPARAM lUserParam)
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->RtrAdvise(pRtrAdviseSink, pulConnection, lUserParam);
}

STDMETHODIMP InterfaceInfoAggregationWrapper::RtrNotify(DWORD dwChangeType,
	DWORD dwObjectType, LPARAM lParam)
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->RtrNotify(dwChangeType, dwObjectType, lParam);
}

STDMETHODIMP InterfaceInfoAggregationWrapper::RtrUnadvise( LONG_PTR ulConnection)
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->RtrUnadvise(ulConnection);
}


STDMETHODIMP InterfaceInfoAggregationWrapper::GetParentRouterInfo( IRouterInfo **ppRouterInfo)
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->GetParentRouterInfo(ppRouterInfo);
}

STDMETHODIMP InterfaceInfoAggregationWrapper::SetParentRouterInfo( IRouterInfo *pRouterInfo)
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->SetParentRouterInfo(pRouterInfo);
}


HRESULT	InterfaceInfoAggregationWrapper::DoDisconnect()
{
	Assert(m_spInterfaceInfo);
	return m_spInterfaceInfo->DoDisconnect();
}

HRESULT	InterfaceInfoAggregationWrapper::AddWeakRef()
{
	Panic0("Should not be calling AddWeakRef from the Data object!");
	return E_FAIL;
}

HRESULT	InterfaceInfoAggregationWrapper::ReleaseWeakRef()
{
	Panic0("Should not be calling ReleaseWeakRef from the Data object!");
	return E_FAIL;
}

HRESULT	InterfaceInfoAggregationWrapper::Destruct()
{
	Panic0("Should not be calling Destruct from the Data object!");
	return E_FAIL;
}

/*!--------------------------------------------------------------------------
	CreateInterfaceInfoAggregation
		Takes an existing IInterfaceInfo and aggregates that with the
		passed-in object.  It returns a pointer to the non-delegating
		IUnknown on the IInterfaceInfo.  This pointer is held by the
		controlling IUnknown.
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) CreateInterfaceInfoAggregation(IInterfaceInfo *pInfo,
	IUnknown *punk, IUnknown **ppNonDelegatingIUnknown)
{
	InterfaceInfoAggregationWrapper *	pAgg = NULL;
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		pAgg = new InterfaceInfoAggregationWrapper(pInfo, punk);
		*ppNonDelegatingIUnknown = pAgg->GetNonDelegatingIUnknown();
	}
	COM_PROTECT_CATCH;
	return hr;
}



/*---------------------------------------------------------------------------
	RtrMgrInfoAggregationWrapper
		This class is provided to use in an aggregation.
 ---------------------------------------------------------------------------*/
class RtrMgrInfoAggregationWrapper :
   public IRtrMgrInfo
{
public:
	RtrMgrInfoAggregationWrapper(IRtrMgrInfo *pInfo, IUnknown *punkOuter);
	virtual ~RtrMgrInfoAggregationWrapper()
		{ DEBUG_DECREMENT_INSTANCE_COUNTER(RtrMgrInfoAggregationWrapper); };

	// override the QI, we will use the AddRef/Release implementation
	// in the CDataObject
	DeclareIUnknownMembers(IMPL)
	DeclareIRtrMgrInfoMembers(IMPL)

	IUnknown * GetNonDelegatingIUnknown() { return &m_ENonDelegatingIUnknown; }

protected:
	LONG			m_cRef;
	SPIRtrMgrInfo	m_spRtrMgrInfo;

	DECLARE_AGGREGATION_NONDELEGATING_IUNKNOWN(RtrMgrInfoAggregationWrapper)

};

IMPLEMENT_AGGREGATION_IUNKNOWN(RtrMgrInfoAggregationWrapper)

IMPLEMENT_AGGREGATION_NONDELEGATING_IUNKNOWN(RtrMgrInfoAggregationWrapper, IRtrMgrInfo)

DEBUG_DECLARE_INSTANCE_COUNTER(RtrMgrInfoAggregationWrapper);

RtrMgrInfoAggregationWrapper::RtrMgrInfoAggregationWrapper(IRtrMgrInfo *pInfo, IUnknown *punkOuter)
	: m_cRef(1)
{
	m_spRtrMgrInfo.Set(pInfo);

	DEBUG_INCREMENT_INSTANCE_COUNTER(RtrMgrInfoAggregationWrapper);
	
	if (punkOuter)
		m_pUnknownOuter = punkOuter;
	else
		m_pUnknownOuter = &m_ENonDelegatingIUnknown;
}


STDMETHODIMP_(DWORD) RtrMgrInfoAggregationWrapper::GetFlags()
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->GetFlags();
}

STDMETHODIMP RtrMgrInfoAggregationWrapper::SetFlags(DWORD dwFlags)
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->SetFlags(dwFlags);
}

STDMETHODIMP RtrMgrInfoAggregationWrapper::Load(LPCOLESTR   pszMachine,
										   HANDLE      hMachine,
										   HANDLE hTransport)
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->Load(pszMachine, hMachine, hTransport);
}
				 
STDMETHODIMP	RtrMgrInfoAggregationWrapper::Save(LPCOLESTR     pszMachine,
										   HANDLE      hMachine,
										   HANDLE hTransport,
										   IInfoBase *pGlobal,
										   IInfoBase *pClient,
										   DWORD dwDeleteProtocolId)
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->Save(pszMachine, hMachine, hTransport,
							   pGlobal, pClient, dwDeleteProtocolId);
}
	
STDMETHODIMP	RtrMgrInfoAggregationWrapper::Unload( )
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->Unload();
}

STDMETHODIMP RtrMgrInfoAggregationWrapper::Delete(LPCOLESTR pszMachine,
	HANDLE hMachine)
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->Delete(pszMachine, hMachine);
}

STDMETHODIMP RtrMgrInfoAggregationWrapper::Merge(IRtrMgrInfo *pNewRm)
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->Merge(pNewRm);
}
	

STDMETHODIMP RtrMgrInfoAggregationWrapper::SetInfoBase(IInfoBase *pGlobal,
	IInfoBase *pClient)
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->SetInfoBase(pGlobal, pClient);
}

STDMETHODIMP RtrMgrInfoAggregationWrapper::GetInfoBase(HANDLE hMachine,
	HANDLE hTransport, IInfoBase **ppGlobal, IInfoBase **ppClient)
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->GetInfoBase(hMachine, hTransport, ppGlobal, ppClient);
}

STDMETHODIMP_(LPCOLESTR) RtrMgrInfoAggregationWrapper::GetId()
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->GetId();
}

STDMETHODIMP RtrMgrInfoAggregationWrapper::SetId(LPCOLESTR pszId)
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->SetId(pszId);
}

STDMETHODIMP_(DWORD) RtrMgrInfoAggregationWrapper::GetTransportId()
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->GetTransportId();
}

STDMETHODIMP_(LPCOLESTR) RtrMgrInfoAggregationWrapper::GetTitle()
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->GetTitle();
}
	
STDMETHODIMP RtrMgrInfoAggregationWrapper::CopyRtrMgrCB(RtrMgrCB *pRtrMgrCB)
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->CopyRtrMgrCB(pRtrMgrCB);
}
	
LPCOLESTR RtrMgrInfoAggregationWrapper::GetMachineName()
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->GetMachineName();
}

STDMETHODIMP RtrMgrInfoAggregationWrapper::EnumRtrMgrProtocol( IEnumRtrMgrProtocolInfo **ppEnumRtrMgrProtocol)
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->EnumRtrMgrProtocol(ppEnumRtrMgrProtocol);
}

STDMETHODIMP RtrMgrInfoAggregationWrapper::FindRtrMgrProtocol(DWORD dwProtocolId,
					    IRtrMgrProtocolInfo **ppInfo)
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->FindRtrMgrProtocol(dwProtocolId, ppInfo);
}

STDMETHODIMP RtrMgrInfoAggregationWrapper::AddRtrMgrProtocol(IRtrMgrProtocolInfo *pInfo,
					   IInfoBase *pGlobalInfo,
					   IInfoBase *pClientInfo)
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->AddRtrMgrProtocol(pInfo, pGlobalInfo, pClientInfo);
}

STDMETHODIMP RtrMgrInfoAggregationWrapper::SetParentRouterInfo(IRouterInfo *pRouterInfo)
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->SetParentRouterInfo(pRouterInfo);
}


STDMETHODIMP RtrMgrInfoAggregationWrapper::GetParentRouterInfo(IRouterInfo **ppRouterInfo)
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->GetParentRouterInfo(ppRouterInfo);
}

STDMETHODIMP	RtrMgrInfoAggregationWrapper::DeleteRtrMgrProtocol( DWORD dwProtocolId, BOOL fRemove)
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->DeleteRtrMgrProtocol(dwProtocolId, fRemove);
}

STDMETHODIMP	RtrMgrInfoAggregationWrapper::ReleaseRtrMgrProtocol( DWORD dwProtocolId)
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->ReleaseRtrMgrProtocol(dwProtocolId);
}

STDMETHODIMP	RtrMgrInfoAggregationWrapper::RtrAdvise( IRtrAdviseSink *pRtrAdviseSink,
					   LONG_PTR *pulConnection, LPARAM lUserParam)
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->RtrAdvise(pRtrAdviseSink, pulConnection, lUserParam);
}

STDMETHODIMP RtrMgrInfoAggregationWrapper::RtrNotify(DWORD dwChangeType, DWORD dwObjectType, LPARAM lParam)
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->RtrNotify(dwChangeType, dwObjectType, lParam);
}

STDMETHODIMP RtrMgrInfoAggregationWrapper::RtrUnadvise( LONG_PTR ulConnection)
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->RtrUnadvise(ulConnection);
}


HRESULT	RtrMgrInfoAggregationWrapper::DoDisconnect()
{
	Assert(m_spRtrMgrInfo);
	return m_spRtrMgrInfo->DoDisconnect();
}

STDMETHODIMP	RtrMgrInfoAggregationWrapper::AddWeakRef()
{
	Panic0("Should not be calling AddWeakRef from the Data object!");
	return E_FAIL;
}

STDMETHODIMP	RtrMgrInfoAggregationWrapper::ReleaseWeakRef()
{
	Panic0("Should not be calling ReleaseWeakRef from the Data object!");
	return E_FAIL;
}

STDMETHODIMP	RtrMgrInfoAggregationWrapper::Destruct()
{
	Panic0("Should not be calling Destruct from the Data object!");
	return E_FAIL;
}

/*!--------------------------------------------------------------------------
	CreateRtrMgrInfoAggregation
		Takes an existing IRtrMgrInfo and aggregates that with the
		passed-in object.  It returns a pointer to the non-delegating
		IUnknown on the IRtrMgrInfo.  This pointer is held by the
		controlling IUnknown.
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) CreateRtrMgrInfoAggregation(IRtrMgrInfo *pInfo,
	IUnknown *punk, IUnknown **ppNonDelegatingIUnknown)
{
	RtrMgrInfoAggregationWrapper *	pAgg = NULL;
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		pAgg = new RtrMgrInfoAggregationWrapper(pInfo, punk);
		*ppNonDelegatingIUnknown = pAgg->GetNonDelegatingIUnknown();
	}
	COM_PROTECT_CATCH;
	return hr;
}



/*---------------------------------------------------------------------------
	RtrMgrProtocolInfoAggregationWrapper
		This class is provided to use in an aggregation.
 ---------------------------------------------------------------------------*/
class RtrMgrProtocolInfoAggregationWrapper :
   public IRtrMgrProtocolInfo
{
public:
	RtrMgrProtocolInfoAggregationWrapper(IRtrMgrProtocolInfo *pInfo, IUnknown *punkOuter);
	virtual ~RtrMgrProtocolInfoAggregationWrapper()
		{ DEBUG_DECREMENT_INSTANCE_COUNTER(RtrMgrProtocolInfoAggregationWrapper); };

	// override the QI, we will use the AddRef/Release implementation
	// in the CDataObject
	DeclareIUnknownMembers(IMPL)
	DeclareIRtrMgrProtocolInfoMembers(IMPL)

	IUnknown * GetNonDelegatingIUnknown() { return &m_ENonDelegatingIUnknown; }

protected:
	LONG			m_cRef;
	SPIRtrMgrProtocolInfo	m_spRtrMgrProtocolInfo;

	DECLARE_AGGREGATION_NONDELEGATING_IUNKNOWN(RtrMgrProtocolInfoAggregationWrapper)

};

IMPLEMENT_AGGREGATION_IUNKNOWN(RtrMgrProtocolInfoAggregationWrapper)

IMPLEMENT_AGGREGATION_NONDELEGATING_IUNKNOWN(RtrMgrProtocolInfoAggregationWrapper, IRtrMgrProtocolInfo)

DEBUG_DECLARE_INSTANCE_COUNTER(RtrMgrProtocolInfoAggregationWrapper);

RtrMgrProtocolInfoAggregationWrapper::RtrMgrProtocolInfoAggregationWrapper(IRtrMgrProtocolInfo *pInfo, IUnknown *punkOuter)
	: m_cRef(1)
{
	m_spRtrMgrProtocolInfo.Set(pInfo);

	DEBUG_INCREMENT_INSTANCE_COUNTER(RtrMgrProtocolInfoAggregationWrapper);
	
	if (punkOuter)
		m_pUnknownOuter = punkOuter;
	else
		m_pUnknownOuter = &m_ENonDelegatingIUnknown;
}


STDMETHODIMP_(DWORD) RtrMgrProtocolInfoAggregationWrapper::GetFlags()
{
	Assert(m_spRtrMgrProtocolInfo);
	return m_spRtrMgrProtocolInfo->GetFlags();
}

STDMETHODIMP RtrMgrProtocolInfoAggregationWrapper::SetFlags(DWORD dwFlags)
{
	Assert(m_spRtrMgrProtocolInfo);
	return m_spRtrMgrProtocolInfo->SetFlags(dwFlags);
}

STDMETHODIMP_(DWORD) RtrMgrProtocolInfoAggregationWrapper::GetProtocolId()
{
	Assert(m_spRtrMgrProtocolInfo);
	return m_spRtrMgrProtocolInfo->GetProtocolId();
}

STDMETHODIMP_(DWORD) RtrMgrProtocolInfoAggregationWrapper::GetTransportId()
{
	Assert(m_spRtrMgrProtocolInfo);
	return m_spRtrMgrProtocolInfo->GetTransportId();
}

STDMETHODIMP_(LPCOLESTR) RtrMgrProtocolInfoAggregationWrapper::GetTitle()
{
	Assert(m_spRtrMgrProtocolInfo);
	return m_spRtrMgrProtocolInfo->GetTitle();
}

STDMETHODIMP RtrMgrProtocolInfoAggregationWrapper::CopyCB(RtrMgrProtocolCB *pRtrMgrProtCB)
{
	Assert(m_spRtrMgrProtocolInfo);
	return m_spRtrMgrProtocolInfo->CopyCB(pRtrMgrProtCB);
}

	
STDMETHODIMP	RtrMgrProtocolInfoAggregationWrapper::RtrAdvise( IRtrAdviseSink *pRtrAdviseSink,
					   LONG_PTR *pulConnection, LPARAM lUserParam)
{
	Assert(m_spRtrMgrProtocolInfo);
	return m_spRtrMgrProtocolInfo->RtrAdvise(pRtrAdviseSink, pulConnection, lUserParam);
}

STDMETHODIMP RtrMgrProtocolInfoAggregationWrapper::RtrNotify(DWORD dwChangeType, DWORD dwObjectType, LPARAM lParam)
{
	Assert(m_spRtrMgrProtocolInfo);
	return m_spRtrMgrProtocolInfo->RtrNotify(dwChangeType, dwObjectType, lParam);
}

STDMETHODIMP RtrMgrProtocolInfoAggregationWrapper::RtrUnadvise( LONG_PTR ulConnection)
{
	Assert(m_spRtrMgrProtocolInfo);
	return m_spRtrMgrProtocolInfo->RtrUnadvise(ulConnection);
}

STDMETHODIMP RtrMgrProtocolInfoAggregationWrapper::GetParentRtrMgrInfo(IRtrMgrInfo **ppRm)
{
	Assert(m_spRtrMgrProtocolInfo);
	return m_spRtrMgrProtocolInfo->GetParentRtrMgrInfo(ppRm);
}

STDMETHODIMP RtrMgrProtocolInfoAggregationWrapper::SetParentRtrMgrInfo(IRtrMgrInfo *pRm)
{
	Assert(m_spRtrMgrProtocolInfo);
	return m_spRtrMgrProtocolInfo->SetParentRtrMgrInfo(pRm);
}


HRESULT	RtrMgrProtocolInfoAggregationWrapper::DoDisconnect()
{
	Assert(m_spRtrMgrProtocolInfo);
	return m_spRtrMgrProtocolInfo->DoDisconnect();
}

STDMETHODIMP	RtrMgrProtocolInfoAggregationWrapper::AddWeakRef()
{
	Panic0("Should not be calling AddWeakRef from the Data object!");
	return E_FAIL;
}

STDMETHODIMP	RtrMgrProtocolInfoAggregationWrapper::ReleaseWeakRef()
{
	Panic0("Should not be calling ReleaseWeakRef from the Data object!");
	return E_FAIL;
}

STDMETHODIMP	RtrMgrProtocolInfoAggregationWrapper::Destruct()
{
	Panic0("Should not be calling Destruct from the Data object!");
	return E_FAIL;
}

/*!--------------------------------------------------------------------------
	CreateRtrMgrProtocolInfoAggregation
		Takes an existing IRtrMgrProtocolInfo and aggregates that with the
		passed-in object.  It returns a pointer to the non-delegating
		IUnknown on the IRtrMgrProtocolInfo.  This pointer is held by the
		controlling IUnknown.
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) CreateRtrMgrProtocolInfoAggregation(IRtrMgrProtocolInfo *pInfo,
	IUnknown *punk, IUnknown **ppNonDelegatingIUnknown)
{
	RtrMgrProtocolInfoAggregationWrapper *	pAgg = NULL;
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		pAgg = new RtrMgrProtocolInfoAggregationWrapper(pInfo, punk);
		*ppNonDelegatingIUnknown = pAgg->GetNonDelegatingIUnknown();
	}
	COM_PROTECT_CATCH;
	return hr;
}



/*---------------------------------------------------------------------------
	RtrMgrInterfaceInfoAggregationWrapper
		This class is provided to use in an aggregation.
 ---------------------------------------------------------------------------*/
class RtrMgrInterfaceInfoAggregationWrapper :
   public IRtrMgrInterfaceInfo
{
public:
	RtrMgrInterfaceInfoAggregationWrapper(IRtrMgrInterfaceInfo *pInfo, IUnknown *punkOuter);
	virtual ~RtrMgrInterfaceInfoAggregationWrapper()
		{ DEBUG_DECREMENT_INSTANCE_COUNTER(RtrMgrInterfaceInfoAggregationWrapper); };

	// override the QI, we will use the AddRef/Release implementation
	// in the CDataObject
	DeclareIUnknownMembers(IMPL)
	DeclareIRtrMgrInterfaceInfoMembers(IMPL)

	IUnknown * GetNonDelegatingIUnknown() { return &m_ENonDelegatingIUnknown; }

protected:
	LONG			m_cRef;
	SPIRtrMgrInterfaceInfo	m_spRtrMgrInterfaceInfo;

	DECLARE_AGGREGATION_NONDELEGATING_IUNKNOWN(RtrMgrInterfaceInfoAggregationWrapper)

};

IMPLEMENT_AGGREGATION_IUNKNOWN(RtrMgrInterfaceInfoAggregationWrapper)

IMPLEMENT_AGGREGATION_NONDELEGATING_IUNKNOWN(RtrMgrInterfaceInfoAggregationWrapper, IRtrMgrInterfaceInfo)

DEBUG_DECLARE_INSTANCE_COUNTER(RtrMgrInterfaceInfoAggregationWrapper);

RtrMgrInterfaceInfoAggregationWrapper::RtrMgrInterfaceInfoAggregationWrapper(IRtrMgrInterfaceInfo *pInfo, IUnknown *punkOuter)
	: m_cRef(1)
{
	m_spRtrMgrInterfaceInfo.Set(pInfo);

	DEBUG_INCREMENT_INSTANCE_COUNTER(RtrMgrInterfaceInfoAggregationWrapper);
	
	if (punkOuter)
		m_pUnknownOuter = punkOuter;
	else
		m_pUnknownOuter = &m_ENonDelegatingIUnknown;
}


STDMETHODIMP RtrMgrInterfaceInfoAggregationWrapper::Load(LPCOLESTR   pszMachine,
										   HANDLE      hMachine,
											HANDLE hInterface,
										   HANDLE hTransport)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->Load(pszMachine, hMachine, hInterface, hTransport);
}
				 
STDMETHODIMP	RtrMgrInterfaceInfoAggregationWrapper::Save(LPCOLESTR pszMachine,
										   HANDLE      hMachine,
										   HANDLE hInterface,
										   HANDLE hTransport,
										   IInfoBase *pInterface,
										   DWORD dwDeleteProtocolId)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->Save(pszMachine, hMachine, hInterface,
										 hTransport, pInterface,
										 dwDeleteProtocolId);
}
	
STDMETHODIMP	RtrMgrInterfaceInfoAggregationWrapper::Unload( )
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->Unload();
}

STDMETHODIMP RtrMgrInterfaceInfoAggregationWrapper::Delete(LPCOLESTR pszMachine,
	HANDLE hMachine,
	HANDLE hInterface)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->Delete(pszMachine, hMachine, hInterface);
}
	

STDMETHODIMP RtrMgrInterfaceInfoAggregationWrapper::SetInfo(DWORD dwSize,
	PBYTE pbData)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->SetInfo(dwSize, pbData);
}

STDMETHODIMP RtrMgrInterfaceInfoAggregationWrapper::GetInfoBase(HANDLE hMachine,
	HANDLE hInterface, HANDLE hTransport, IInfoBase **ppInterface)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->GetInfoBase(hMachine, hInterface, hTransport, ppInterface);
}

STDMETHODIMP RtrMgrInterfaceInfoAggregationWrapper::SetInfoBase(HANDLE hMachine,
	HANDLE hInterface, HANDLE hTransport, IInfoBase *pInterface)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->SetInfoBase(hMachine, hInterface, hTransport, pInterface);
}

STDMETHODIMP RtrMgrInterfaceInfoAggregationWrapper::Merge(IRtrMgrInterfaceInfo *pNewRmIf)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->Merge(pNewRmIf);
}

STDMETHODIMP_(LPCOLESTR) RtrMgrInterfaceInfoAggregationWrapper::GetId()
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->GetId();
}

STDMETHODIMP RtrMgrInterfaceInfoAggregationWrapper::SetId(LPCOLESTR pszId)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->SetId(pszId);
}

STDMETHODIMP_(DWORD) RtrMgrInterfaceInfoAggregationWrapper::GetTransportId()
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->GetTransportId();
}

STDMETHODIMP_(LPCOLESTR) RtrMgrInterfaceInfoAggregationWrapper::GetInterfaceId()
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->GetInterfaceId();
}

STDMETHODIMP_(DWORD) RtrMgrInterfaceInfoAggregationWrapper::GetInterfaceType()
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->GetInterfaceType();
}

STDMETHODIMP_(LPCOLESTR) RtrMgrInterfaceInfoAggregationWrapper::GetTitle()
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->GetTitle();
}

STDMETHODIMP RtrMgrInterfaceInfoAggregationWrapper::SetTitle(LPCOLESTR pszTitle)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->SetTitle(pszTitle);
}
	
STDMETHODIMP RtrMgrInterfaceInfoAggregationWrapper::CopyCB(RtrMgrInterfaceCB *pRtrMgrIfCB)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->CopyCB(pRtrMgrIfCB);
}
	
STDMETHODIMP_(LPCOLESTR) RtrMgrInterfaceInfoAggregationWrapper::GetMachineName()
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->GetMachineName();
}

STDMETHODIMP RtrMgrInterfaceInfoAggregationWrapper::SetMachineName(LPCOLESTR pszMachineName)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->SetMachineName(pszMachineName);
}

STDMETHODIMP_(DWORD) RtrMgrInterfaceInfoAggregationWrapper::GetFlags()
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->GetFlags();
}

STDMETHODIMP RtrMgrInterfaceInfoAggregationWrapper::SetFlags(DWORD dwFlags)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->SetFlags(dwFlags);
}

STDMETHODIMP RtrMgrInterfaceInfoAggregationWrapper::EnumRtrMgrProtocolInterface( IEnumRtrMgrProtocolInterfaceInfo **ppEnumRmProtIf)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->EnumRtrMgrProtocolInterface(ppEnumRmProtIf);
}

STDMETHODIMP RtrMgrInterfaceInfoAggregationWrapper::FindRtrMgrProtocolInterface(DWORD dwProtocolId,
					    IRtrMgrProtocolInterfaceInfo **ppInfo)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->FindRtrMgrProtocolInterface(dwProtocolId, ppInfo);
}

STDMETHODIMP RtrMgrInterfaceInfoAggregationWrapper::AddRtrMgrProtocolInterface(IRtrMgrProtocolInterfaceInfo *pInfo,
					   IInfoBase *pInterfaceInfo)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->AddRtrMgrProtocolInterface(pInfo, pInterfaceInfo);
}

STDMETHODIMP	RtrMgrInterfaceInfoAggregationWrapper::DeleteRtrMgrProtocolInterface( DWORD dwProtocolId, BOOL fRemove)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->DeleteRtrMgrProtocolInterface(dwProtocolId, fRemove);
}

STDMETHODIMP	RtrMgrInterfaceInfoAggregationWrapper::ReleaseRtrMgrProtocolInterface( DWORD dwProtocolId)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->ReleaseRtrMgrProtocolInterface(dwProtocolId);
}


STDMETHODIMP RtrMgrInterfaceInfoAggregationWrapper::SetParentInterfaceInfo(IInterfaceInfo *pInterfaceInfo)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->SetParentInterfaceInfo(pInterfaceInfo);
}


STDMETHODIMP RtrMgrInterfaceInfoAggregationWrapper::GetParentInterfaceInfo(IInterfaceInfo **ppInterfaceInfo)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->GetParentInterfaceInfo(ppInterfaceInfo);
}

STDMETHODIMP	RtrMgrInterfaceInfoAggregationWrapper::RtrAdvise( IRtrAdviseSink *pRtrAdviseSink,
					   LONG_PTR *pulConnection, LPARAM lUserParam)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->RtrAdvise(pRtrAdviseSink, pulConnection, lUserParam);
}

STDMETHODIMP RtrMgrInterfaceInfoAggregationWrapper::RtrNotify(DWORD dwChangeType, DWORD dwObjectType, LPARAM lParam)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->RtrNotify(dwChangeType, dwObjectType, lParam);
}

STDMETHODIMP RtrMgrInterfaceInfoAggregationWrapper::RtrUnadvise( LONG_PTR ulConnection)
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->RtrUnadvise(ulConnection);
}


HRESULT	RtrMgrInterfaceInfoAggregationWrapper::DoDisconnect()
{
	Assert(m_spRtrMgrInterfaceInfo);
	return m_spRtrMgrInterfaceInfo->DoDisconnect();
}

STDMETHODIMP	RtrMgrInterfaceInfoAggregationWrapper::AddWeakRef()
{
	Panic0("Should not be calling AddWeakRef from the Data object!");
	return E_FAIL;
}

STDMETHODIMP	RtrMgrInterfaceInfoAggregationWrapper::ReleaseWeakRef()
{
	Panic0("Should not be calling ReleaseWeakRef from the Data object!");
	return E_FAIL;
}

STDMETHODIMP	RtrMgrInterfaceInfoAggregationWrapper::Destruct()
{
	Panic0("Should not be calling Destruct from the Data object!");
	return E_FAIL;
}

/*!--------------------------------------------------------------------------
	CreateRtrMgrInterfaceInfoAggregation
		Takes an existing IRtrMgrInterfaceInfo and aggregates that with the
		passed-in object.  It returns a pointer to the non-delegating
		IUnknown on the IRtrMgrInterfaceInfo.  This pointer is held by the
		controlling IUnknown.
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) CreateRtrMgrInterfaceInfoAggregation(IRtrMgrInterfaceInfo *pInfo,
	IUnknown *punk, IUnknown **ppNonDelegatingIUnknown)
{
	RtrMgrInterfaceInfoAggregationWrapper *	pAgg = NULL;
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		pAgg = new RtrMgrInterfaceInfoAggregationWrapper(pInfo, punk);
		*ppNonDelegatingIUnknown = pAgg->GetNonDelegatingIUnknown();
	}
	COM_PROTECT_CATCH;
	return hr;
}


/*---------------------------------------------------------------------------
	RtrMgrProtocolInterfaceInfoAggregationWrapper
		This class is provided to use in an aggregation.
 ---------------------------------------------------------------------------*/
class RtrMgrProtocolInterfaceInfoAggregationWrapper :
   public IRtrMgrProtocolInterfaceInfo
{
public:
	RtrMgrProtocolInterfaceInfoAggregationWrapper(IRtrMgrProtocolInterfaceInfo *pInfo, IUnknown *punkOuter);
	virtual ~RtrMgrProtocolInterfaceInfoAggregationWrapper()
		{ DEBUG_DECREMENT_INSTANCE_COUNTER(RtrMgrProtocolInterfaceInfoAggregationWrapper); };

	// override the QI, we will use the AddRef/Release implementation
	// in the CDataObject
	DeclareIUnknownMembers(IMPL)
	DeclareIRtrMgrProtocolInterfaceInfoMembers(IMPL)

	IUnknown * GetNonDelegatingIUnknown() { return &m_ENonDelegatingIUnknown; }

protected:
	LONG			m_cRef;
	SPIRtrMgrProtocolInterfaceInfo	m_spRtrMgrProtocolInterfaceInfo;

	DECLARE_AGGREGATION_NONDELEGATING_IUNKNOWN(RtrMgrProtocolInterfaceInfoAggregationWrapper)

};

IMPLEMENT_AGGREGATION_IUNKNOWN(RtrMgrProtocolInterfaceInfoAggregationWrapper)

IMPLEMENT_AGGREGATION_NONDELEGATING_IUNKNOWN(RtrMgrProtocolInterfaceInfoAggregationWrapper, IRtrMgrProtocolInterfaceInfo)

DEBUG_DECLARE_INSTANCE_COUNTER(RtrMgrProtocolInterfaceInfoAggregationWrapper);

RtrMgrProtocolInterfaceInfoAggregationWrapper::RtrMgrProtocolInterfaceInfoAggregationWrapper(IRtrMgrProtocolInterfaceInfo *pInfo, IUnknown *punkOuter)
	: m_cRef(1)
{
	m_spRtrMgrProtocolInterfaceInfo.Set(pInfo);

	DEBUG_INCREMENT_INSTANCE_COUNTER(RtrMgrProtocolInterfaceInfoAggregationWrapper);
	
	if (punkOuter)
		m_pUnknownOuter = punkOuter;
	else
		m_pUnknownOuter = &m_ENonDelegatingIUnknown;
}


STDMETHODIMP_(DWORD) RtrMgrProtocolInterfaceInfoAggregationWrapper::GetFlags()
{
	Assert(m_spRtrMgrProtocolInterfaceInfo);
	return m_spRtrMgrProtocolInterfaceInfo->GetFlags();
}

STDMETHODIMP RtrMgrProtocolInterfaceInfoAggregationWrapper::SetFlags(DWORD dwFlags)
{
	Assert(m_spRtrMgrProtocolInterfaceInfo);
	return m_spRtrMgrProtocolInterfaceInfo->SetFlags(dwFlags);
}

STDMETHODIMP_(DWORD) RtrMgrProtocolInterfaceInfoAggregationWrapper::GetProtocolId()
{
	Assert(m_spRtrMgrProtocolInterfaceInfo);
	return m_spRtrMgrProtocolInterfaceInfo->GetProtocolId();
}

STDMETHODIMP_(DWORD) RtrMgrProtocolInterfaceInfoAggregationWrapper::GetTransportId()
{
	Assert(m_spRtrMgrProtocolInterfaceInfo);
	return m_spRtrMgrProtocolInterfaceInfo->GetTransportId();
}

STDMETHODIMP_(LPCOLESTR) RtrMgrProtocolInterfaceInfoAggregationWrapper::GetTitle()
{
	Assert(m_spRtrMgrProtocolInterfaceInfo);
	return m_spRtrMgrProtocolInterfaceInfo->GetTitle();
}
	
STDMETHODIMP RtrMgrProtocolInterfaceInfoAggregationWrapper::SetTitle(LPCOLESTR pszTitle)
{
	Assert(m_spRtrMgrProtocolInterfaceInfo);
	return m_spRtrMgrProtocolInterfaceInfo->SetTitle(pszTitle);
}
	
STDMETHODIMP_(LPCOLESTR) RtrMgrProtocolInterfaceInfoAggregationWrapper::GetInterfaceId()
{
	Assert(m_spRtrMgrProtocolInterfaceInfo);
	return m_spRtrMgrProtocolInterfaceInfo->GetInterfaceId();
}
	
STDMETHODIMP_(DWORD) RtrMgrProtocolInterfaceInfoAggregationWrapper::GetInterfaceType()
{
	Assert(m_spRtrMgrProtocolInterfaceInfo);
	return m_spRtrMgrProtocolInterfaceInfo->GetInterfaceType();
}
	
STDMETHODIMP RtrMgrProtocolInterfaceInfoAggregationWrapper::CopyCB(RtrMgrProtocolInterfaceCB *pRtrMgrProtIfCB)
{
	Assert(m_spRtrMgrProtocolInterfaceInfo);
	return m_spRtrMgrProtocolInterfaceInfo->CopyCB(pRtrMgrProtIfCB);
}

	
STDMETHODIMP	RtrMgrProtocolInterfaceInfoAggregationWrapper::RtrAdvise( IRtrAdviseSink *pRtrAdviseSink,
					   LONG_PTR *pulConnection, LPARAM lUserParam)
{
	Assert(m_spRtrMgrProtocolInterfaceInfo);
	return m_spRtrMgrProtocolInterfaceInfo->RtrAdvise(pRtrAdviseSink, pulConnection, lUserParam);
}

STDMETHODIMP RtrMgrProtocolInterfaceInfoAggregationWrapper::RtrNotify(DWORD dwChangeType, DWORD dwObjectType, LPARAM lParam)
{
	Assert(m_spRtrMgrProtocolInterfaceInfo);
	return m_spRtrMgrProtocolInterfaceInfo->RtrNotify(dwChangeType, dwObjectType, lParam);
}

STDMETHODIMP RtrMgrProtocolInterfaceInfoAggregationWrapper::RtrUnadvise( LONG_PTR ulConnection)
{
	Assert(m_spRtrMgrProtocolInterfaceInfo);
	return m_spRtrMgrProtocolInterfaceInfo->RtrUnadvise(ulConnection);
}

STDMETHODIMP RtrMgrProtocolInterfaceInfoAggregationWrapper::GetParentRtrMgrInterfaceInfo(IRtrMgrInterfaceInfo **ppRm)
{
	Assert(m_spRtrMgrProtocolInterfaceInfo);
	return m_spRtrMgrProtocolInterfaceInfo->GetParentRtrMgrInterfaceInfo(ppRm);
}

STDMETHODIMP RtrMgrProtocolInterfaceInfoAggregationWrapper::SetParentRtrMgrInterfaceInfo(IRtrMgrInterfaceInfo *pRm)
{
	Assert(m_spRtrMgrProtocolInterfaceInfo);
	return m_spRtrMgrProtocolInterfaceInfo->SetParentRtrMgrInterfaceInfo(pRm);
}


HRESULT	RtrMgrProtocolInterfaceInfoAggregationWrapper::DoDisconnect()
{
	Assert(m_spRtrMgrProtocolInterfaceInfo);
	return m_spRtrMgrProtocolInterfaceInfo->DoDisconnect();
}

STDMETHODIMP	RtrMgrProtocolInterfaceInfoAggregationWrapper::AddWeakRef()
{
	Panic0("Should not be calling AddWeakRef from the Data object!");
	return E_FAIL;
}

STDMETHODIMP	RtrMgrProtocolInterfaceInfoAggregationWrapper::ReleaseWeakRef()
{
	Panic0("Should not be calling ReleaseWeakRef from the Data object!");
	return E_FAIL;
}

STDMETHODIMP	RtrMgrProtocolInterfaceInfoAggregationWrapper::Destruct()
{
	Panic0("Should not be calling Destruct from the Data object!");
	return E_FAIL;
}

/*!--------------------------------------------------------------------------
	CreateRtrMgrProtocolInterfaceInfoAggregation
		Takes an existing IRtrMgrProtocolInterfaceInfo and aggregates that with the
		passed-in object.  It returns a pointer to the non-delegating
		IUnknown on the IRtrMgrProtocolInterfaceInfo.  This pointer is held by the
		controlling IUnknown.
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(HRESULT) CreateRtrMgrProtocolInterfaceInfoAggregation(IRtrMgrProtocolInterfaceInfo *pInfo,
	IUnknown *punk, IUnknown **ppNonDelegatingIUnknown)
{
	RtrMgrProtocolInterfaceInfoAggregationWrapper *	pAgg = NULL;
	HRESULT	hr = hrOK;

	COM_PROTECT_TRY
	{
		pAgg = new RtrMgrProtocolInterfaceInfoAggregationWrapper(pInfo, punk);
		*ppNonDelegatingIUnknown = pAgg->GetNonDelegatingIUnknown();
	}
	COM_PROTECT_CATCH;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\atlkenv.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    atlkenv.cpp
        
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include <netcfgx.h>
#include <atalkwsh.h>
#include "atlkenv.h"
#include "ndisutil.h"

//****************************************************************
//
//****************************************************************
CATLKEnv::~CATLKEnv()
{
    for ( AI p=m_adapterinfolist.begin(); p!= m_adapterinfolist.end() ; p++ )
    {
        delete *p;
    }
}

HRESULT CATLKEnv::FetchRegInit()
{
    RegKey regkey;
    RegKey regkeyA;
    RegKeyIterator regIter;
    CString szDefAdapter;
    CString szKey;
    CAdapterInfo* pAdapInfo;

    if ( ERROR_SUCCESS == regkey.Open(HKEY_LOCAL_MACHINE,c_szAppleTalkService,KEY_READ,m_szServerName) )
    {
        regkey.QueryValue( c_szRegValDefaultPort, szDefAdapter);
    }

    if ( (ERROR_SUCCESS == regkey.Open(HKEY_LOCAL_MACHINE,c_szRegKeyAppletalkAdapter,KEY_READ,  m_szServerName)) )
    {
        m_adapterinfolist.clear();
        regIter.Init(&regkey);
        while ( regIter.Next(&szKey, NULL)==hrOK )
        {
            if ( szKey.Find( (TCHAR) '{') == -1 )   //not an adapter interface
                continue;

            pAdapInfo = new CAdapterInfo;
            Assert(pAdapInfo);

            pAdapInfo->m_fNotifyPnP=false;
            pAdapInfo->m_fModified=false;
            pAdapInfo->m_fReloadDyn=true;
            pAdapInfo->m_fReloadReg=true;

            if ( FHrSucceeded(regkeyA.Open(regkey, szKey)) )
            {
                regkeyA.QueryValue( c_szDefaultZone, pAdapInfo->m_regInfo.m_szDefaultZone);
                regkeyA.QueryValue( c_szRegValNetRangeLower, pAdapInfo->m_regInfo.m_dwRangeLower);
                regkeyA.QueryValue( c_szRegValNetRangeUpper, pAdapInfo->m_regInfo.m_dwRangeUpper);
                regkeyA.QueryValue( c_szPortName, pAdapInfo->m_regInfo.m_szPortName);
                regkeyA.QueryValue( c_szSeedingNetwork, pAdapInfo->m_regInfo.m_dwSeedingNetwork);
                regkeyA.QueryValue( c_szZoneList, pAdapInfo->m_regInfo.m_listZones);

				// optional value
                if(ERROR_SUCCESS != regkeyA.QueryValue( c_szMediaType, pAdapInfo->m_regInfo.m_dwMediaType))
	                pAdapInfo->m_regInfo.m_dwMediaType = MEDIATYPE_ETHERNET;
			}

            pAdapInfo->m_dynInfo.m_dwRangeLower=0;
            pAdapInfo->m_dynInfo.m_dwRangeUpper=0;

            pAdapInfo->m_regInfo.m_szAdapter = szKey;
            pAdapInfo->m_regInfo.m_szDevAdapter = c_szDevice;
            pAdapInfo->m_regInfo.m_szDevAdapter += szKey;
            pAdapInfo->m_regInfo.m_fDefAdapter= (szDefAdapter==pAdapInfo->m_regInfo.m_szDevAdapter);
            m_adapterinfolist.push_back(pAdapInfo);
        }
    }

    return hrOK;
}

extern BOOL FIsAppletalkBoundToAdapter(INetCfg * pnc, LPWSTR pszwInstanceGuid);
extern HRESULT HrReleaseINetCfg(BOOL fHasWriteLock, INetCfg* pnc);
extern HRESULT HrGetINetCfg(IN BOOL fGetWriteLock, INetCfg** ppnc);


HRESULT	CATLKEnv::IsAdapterBoundToAtlk(LPWSTR szAdapter, BOOL* pbBound)
{
	INetCfg* pnc;
	HRESULT hr = HrGetINetCfg(FALSE, &pnc);
	if(FAILED(hr))
		return hr;
		
	*pbBound = FIsAppletalkBoundToAdapter(pnc, szAdapter);

	hr = HrReleaseINetCfg(FALSE, pnc);
	
	return hr;
}

CAdapterInfo* CATLKEnv::FindAdapter(CString& szAdapter)
{
    CAdapterInfo* pA=NULL;

    for ( AI p=m_adapterinfolist.begin(); p!= m_adapterinfolist.end() ; p++ )
    {
        if ( (*p)->m_regInfo.m_szAdapter==szAdapter )
        {
            pA=*p;
            break;
        }
    }
    return pA;
}

HRESULT CATLKEnv::SetAdapterInfo()
{
    RegKey regkey;
    RegKey regkeyA;
    RegKeyIterator regIter;
    CString szDefAdapter;
    CString szKey;
    CAdapterInfo* pAdapInfo;
    bool fATLKChanged=false;
    HRESULT hr=S_OK;

    if ( (ERROR_SUCCESS == regkey.Open(HKEY_LOCAL_MACHINE,c_szRegKeyAppletalkAdapter,KEY_READ,  m_szServerName)) )
    {
        regIter.Init(&regkey);
        while ( regIter.Next(&szKey, NULL)==hrOK )
        {
            if ( szKey.Find( (TCHAR) '{') == -1 )   //not an adapter interface
                continue;

            CAdapterInfo* pAdapInfo=NULL;
            if ( (pAdapInfo=FindAdapter(szKey))==NULL )
                continue;

            if ( pAdapInfo->m_fModified && FHrSucceeded(regkeyA.Open(regkey, szKey)) )
            {
                regkeyA.SetValue( c_szDefaultZone, pAdapInfo->m_regInfo.m_szDefaultZone);
                regkeyA.SetValue( c_szRegValNetRangeLower, pAdapInfo->m_regInfo.m_dwRangeLower);
                regkeyA.SetValue( c_szRegValNetRangeUpper, pAdapInfo->m_regInfo.m_dwRangeUpper);
                regkeyA.SetValue( c_szPortName, pAdapInfo->m_regInfo.m_szPortName);
                regkeyA.SetValue( c_szSeedingNetwork, pAdapInfo->m_regInfo.m_dwSeedingNetwork);
                regkeyA.SetValue( c_szZoneList, pAdapInfo->m_regInfo.m_listZones);
                pAdapInfo->m_fModified=false;
                pAdapInfo->m_fNotifyPnP=true;
                fATLKChanged=true;
            }
        }
                
        if (fATLKChanged)
        {
            CStop_StartAppleTalkPrint	MacPrint;

            hr=HrAtlkPnPReconfigParams();
        }
    }

    return hr;
}


HRESULT CATLKEnv::GetAdapterInfo(bool fReloadReg/*=true*/)
{
    SOCKADDR_AT    address;
    SOCKET         mysocket = INVALID_SOCKET;
    WSADATA        wsadata;
    BOOL           fWSInitialized = FALSE;
    HRESULT hr= S_OK;
    DWORD          wsaerr = 0;
    bool fWSInit = false;
    CString        szPortName;
    BOOL            fSucceeded = FALSE;
    AI p;

    if (fReloadReg)
    {  //load container of adapters & registry information
        if ( FHrFailed( hr=FetchRegInit()) )
           return hr;
    }
    
    // Create the socket/bind
    wsaerr = WSAStartup(0x0101, &wsadata);
    if ( 0 != wsaerr )
        goto Error;

    // Winsock successfully initialized
    fWSInitialized = TRUE;

    mysocket = socket(AF_APPLETALK, SOCK_DGRAM, DDPPROTO_ZIP);
    if ( mysocket == INVALID_SOCKET )
        goto Error;

    address.sat_family = AF_APPLETALK;
    address.sat_net = 0;
    address.sat_node = 0;
    address.sat_socket = 0;

    wsaerr = bind(mysocket, (struct sockaddr *)&address, sizeof(address));
    if ( wsaerr != 0 )
        goto Error;

    for ( p=m_adapterinfolist.begin(); p!= m_adapterinfolist.end() ; p++ )
    {
        // Failures from query the zone list for a given adapter can be from
        // the adapter not connected to the network, zone seeder not running, etc.
        // Because we want to process all the adapters, we ignore these errors.
        if ( (*p)->m_fReloadDyn )
        {
           hr=_HrGetAndSetNetworkInformation( mysocket, *p );
           if (FHrSucceeded(hr))
               fSucceeded = TRUE;
        }
    }

Done:
    if ( INVALID_SOCKET != mysocket )
        closesocket(mysocket);
    if ( fWSInitialized )
        WSACleanup();

    return fSucceeded ? hrOK : hr;

Error:
    wsaerr = ::WSAGetLastError();
    hr= HRESULT_FROM_WIN32(wsaerr);
    goto Done;
}

/*	// new registry key "MediaType" created to show the media type, so the code is not necessary
//----------------------------------------------------------------------------
// Data used for finding the other components we have to deal with.
//
static const GUID* c_guidAtlkComponentClasses [1] =
{
    &GUID_DEVCLASS_NETTRANS        // Atalk
};

static const LPCTSTR c_apszAtlkComponentIds [1] =
{
    c_szInfId_MS_AppleTalk	//NETCFG_TRANS_CID_MS_APPLETALK
};


HRESULT CATLKEnv::IsLocalTalkAdaptor(CAdapterInfo* pAdapterInfo, BOOL* pbIsLocalTalk)
   // S_OK: LOCALTALK
   // S_FALSE: Not
   // ERRORs
{
	HRESULT	hr = S_OK;
	CComPtr<INetCfg> 	spINetCfg;
	INetCfgComponent*		apINetCfgComponent[1];
	apINetCfgComponent[0] = NULL;
	BOOL				bInitCom = FALSE;
	CComPtr<INetCfgComponentBindings> spBindings;
	LPCTSTR pszInterface = TEXT("localtalk");

	
	*pbLocalTalk = FALSE;
	
	CHECK_HR(hr = HrCreateAndInitializeINetCfg(
												&bInitCom, 
												(INetCfg**)&spINetCfg, 
												FALSE, // not to write
												0,	// only for write
												NULL, // only for write
												NULL));

	ASSERT(spINetCfg.p);	

	CHECK_HR(hr = HrFindComponents (
												spINetCfg, 
												1, // # of components
												c_guidAtlkComponentClasses, 
												c_apszAtlkComponentIds,
												(INetCfgComponent**)apINetCfgComponent));

	ASSERT(apINetCfgComponent[0]);

	CHECK_HR(hr = apINetCfgComponent[0]->QueryInterface(IID_INetCfgComponentBindings,  reinterpret_cast<void**>(&spBindings)));

	ASSERT(spBindings.p);
												
	hr = pnccBindings->SupportsBindingInterface( NCF_LOWER, pszInterface);
	
	if (S_OK == hr)
	{
		*pbIsLocalTalk = TRUE;
	}

	// ignore other values except errors
	if(!FAILED(hr))
		hr = S_OK;

L_ERR:	
	if(apINetCfgComponent[0])
	{
		apINetCfgComponent[0]->Release();
		apINetCfgComponent[0] = NULL;
	}

	return hr;
}

*/
HRESULT CATLKEnv::ReloadAdapter(CAdapterInfo* pAdapInfo, bool fOnlyDyn /*=false*/)
{
    SOCKADDR_AT    address;
    SOCKET         mysocket = INVALID_SOCKET;
    WSADATA        wsadata;
    BOOL           fWSInitialized = FALSE;
    HRESULT hr= hrOK;
    DWORD          wsaerr = 0;
    bool fWSInit = false;
    CString        szPortName;
    AI p;
    CWaitCursor wait;


    Assert(pAdapInfo);

    pAdapInfo->m_dynInfo.m_listZones.RemoveAll();

    if (!fOnlyDyn)
    {  //reload registry zone & default zone
        RegKey regkey;
        CString sz=c_szRegKeyAppletalkAdapter;
        sz+=pAdapInfo->m_regInfo.m_szAdapter;
        if (ERROR_SUCCESS == regkey.Open(HKEY_LOCAL_MACHINE,
              sz, KEY_READ,NULL) )
        {
            pAdapInfo->m_regInfo.m_listZones.RemoveAll();     
            regkey.QueryValue( c_szZoneList, pAdapInfo->m_regInfo.m_listZones);
            regkey.QueryValue( c_szDefaultZone, pAdapInfo->m_regInfo.m_szDefaultZone);
        }
    }

    // Create the socket/bind
    wsaerr = WSAStartup(0x0101, &wsadata);
    if ( 0 != wsaerr )
        goto Error;

    // Winsock successfully initialized
    fWSInitialized = TRUE;

    mysocket = socket(AF_APPLETALK, SOCK_DGRAM, DDPPROTO_ZIP);
    if ( mysocket == INVALID_SOCKET )
    {
    	AddHighLevelErrorStringId(IDS_ERR_FAILED_CONNECT_NETWORK);
        goto Error;
    }

    address.sat_family = AF_APPLETALK;
    address.sat_net = 0;
    address.sat_node = 0;
    address.sat_socket = 0;

    wsaerr = bind(mysocket, (struct sockaddr *)&address, sizeof(address));
    if ( wsaerr != 0 )
    {
    	AddHighLevelErrorStringId(IDS_ERR_FAILED_CONNECT_NETWORK);
        goto Error;
    }

    hr=_HrGetAndSetNetworkInformation( mysocket, pAdapInfo );

    Done:
    if ( INVALID_SOCKET != mysocket )
        closesocket(mysocket);
    if ( fWSInitialized )
        WSACleanup();

    return hr;

Error:
    wsaerr = ::WSAGetLastError();
    hr= HRESULT_FROM_WIN32(wsaerr);
	AddSystemErrorMessage(hr);

    goto Done;
}


HRESULT CATLKEnv::_HrGetAndSetNetworkInformation(SOCKET socket, CAdapterInfo* pAdapInfo)
{
    HRESULT      hr = FALSE;
    CHAR         *pZoneBuffer = NULL;
    CHAR         *pDefParmsBuffer = NULL;
    CHAR         *pZoneListStart = NULL;
    INT          BytesNeeded ;
    WCHAR        *pwDefZone = NULL;
    INT          ZoneLen = 0;
    DWORD        wsaerr = 0;
    CHAR         *pDefZone = NULL;

    Assert(pAdapInfo);

    LPCTSTR      szDevName=pAdapInfo->m_regInfo.m_szDevAdapter;

    PWSH_LOOKUP_ZONES                pGetNetZones;
    PWSH_LOOKUP_NETDEF_ON_ADAPTER    pGetNetDefaults;

    Assert(NULL != szDevName);

    pZoneBuffer = new CHAR [ZONEBUFFER_LEN + sizeof(WSH_LOOKUP_ZONES)];
    Assert(NULL != pZoneBuffer);

    pGetNetZones = (PWSH_LOOKUP_ZONES)pZoneBuffer;

    wcscpy((WCHAR *)(pGetNetZones+1),szDevName);

    BytesNeeded = ZONEBUFFER_LEN;

    if (m_dwF & ATLK_ONLY_ONADAPTER)
        wsaerr = getsockopt(socket, SOL_APPLETALK, SO_LOOKUP_ZONES_ON_ADAPTER,
                        (char *)pZoneBuffer, &BytesNeeded);
    else
        wsaerr = getsockopt(socket, SOL_APPLETALK, SO_LOOKUP_ZONES,
                        (char *)pZoneBuffer, &BytesNeeded);

    if ( 0 != wsaerr )
    {
    	int	err = WSAGetLastError();
        Panic1("WSAGetLastError is %08lx", err);
        hr = HRESULT_FROM_WIN32(err);
        goto Error;
    }

    pZoneListStart = pZoneBuffer + sizeof(WSH_LOOKUP_ZONES);
    if ( !lstrcmpA(pZoneListStart, "*" ) )
    {
        goto Done;
    }

    _AddZones(pZoneListStart,((PWSH_LOOKUP_ZONES)pZoneBuffer)->NoZones,pAdapInfo);

    // Get the DefaultZone/NetworkRange Information
    pDefParmsBuffer = new CHAR[PARM_BUF_LEN+sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER)];
    Assert(NULL != pDefParmsBuffer);

    pGetNetDefaults = (PWSH_LOOKUP_NETDEF_ON_ADAPTER)pDefParmsBuffer;
    BytesNeeded = PARM_BUF_LEN + sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER);

    wcscpy((WCHAR*)(pGetNetDefaults+1), szDevName);
    pGetNetDefaults->NetworkRangeLowerEnd = pGetNetDefaults->NetworkRangeUpperEnd = 0;

    wsaerr = getsockopt(socket, SOL_APPLETALK, SO_LOOKUP_NETDEF_ON_ADAPTER,
                        (char*)pDefParmsBuffer, &BytesNeeded);
    if ( 0 != wsaerr )
    {
    	int	err = WSAGetLastError();
        Panic1("WSAGetLastError is %08lx", err);
        hr = HRESULT_FROM_WIN32(err);
        goto Error;
    }

    pAdapInfo->m_dynInfo.m_dwRangeUpper=pGetNetDefaults->NetworkRangeUpperEnd;
    pAdapInfo->m_dynInfo.m_dwRangeLower=pGetNetDefaults->NetworkRangeLowerEnd;

    pDefZone  = pDefParmsBuffer + sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER);
    ZoneLen = lstrlenA(pDefZone) + 1;
    pwDefZone = new WCHAR [sizeof(WCHAR) * ZoneLen];
    Assert(NULL != pwDefZone);

    // mbstowcs does not work well on FE platforms
    // mbstowcs(pwDefZone, pDefZone, ZoneLen);
    MultiByteToWideChar(CP_ACP, 0, pDefZone, -1, pwDefZone, ZoneLen);

    pAdapInfo->m_dynInfo.m_szDefaultZone=pwDefZone;

Done:
    if ( pZoneBuffer != NULL )
        delete [] pZoneBuffer;
    if ( pwDefZone != NULL )
        delete [] pwDefZone;
    if ( pDefParmsBuffer != NULL )
        delete [] pDefParmsBuffer;

Error:
    return hr;
}


void CATLKEnv::_AddZones(
                        CHAR * szZoneList,
                        ULONG NumZones,
                        CAdapterInfo* pAdapterinfo)
{
    INT      cbAscii = 0;
    WCHAR    *pszZone = NULL;
    CString  sz;

    Assert(NULL != szZoneList);
    Assert(pAdapterinfo);

    while ( NumZones-- )
    {
        cbAscii = lstrlenA(szZoneList) + 1;

        pszZone = new WCHAR [sizeof(WCHAR) * cbAscii];
        Assert(NULL != pszZone);

        // mbstowcs does not work well on FE platforms
        // mbstowcs(pszZone, szZoneList, cbAscii);
        MultiByteToWideChar(CP_ACP, 0, szZoneList, -1, pszZone, cbAscii);

        sz=pszZone;

        pAdapterinfo->m_dynInfo.m_listZones.AddTail(sz);

        szZoneList += cbAscii;

        delete [] pszZone;
    }
}
           
HRESULT CATLKEnv::HrAtlkPnPSwithRouting()
{
    HRESULT hr=S_OK;
    CServiceManager csm;
    CService svr;
    ATALK_PNP_EVENT Config;
    bool fStartMacPrint = false;
    bool fStopMacPrint = false;

    memset(&Config, 0, sizeof(ATALK_PNP_EVENT));

    CWaitCursor wait;

    // notify atlk
    Config.PnpMessage = AT_PNP_SWITCH_ROUTING;
    if (FAILED(hr=HrSendNdisHandlePnpEvent(NDIS, RECONFIGURE, c_szAtlk, c_szBlank, c_szBlank,
                                     &Config, sizeof(ATALK_PNP_EVENT))))
    {
        return hr;
    }

    return hr;
}


HRESULT CATLKEnv::HrAtlkPnPReconfigParams(BOOL bForcePnPOnDefault)
{
    HRESULT hr=S_OK;
    CServiceManager csm;
    CService svr;
    ATALK_PNP_EVENT Config;
    bool fStartMacPrint = false;
    bool fStopMacPrint = false;
    AI p;
    CAdapterInfo* pAI=NULL;


    memset(&Config, 0, sizeof(ATALK_PNP_EVENT));

    if ( m_adapterinfolist.empty())
        return hr;
        
       //find the default adapter
    for ( p=m_adapterinfolist.begin(); p!= m_adapterinfolist.end() ; p++ )
    {
        pAI = *p;
        if (pAI->m_regInfo.m_fDefAdapter)
        {
           break;
        }
    }

	if(bForcePnPOnDefault && pAI)
	{
	    Config.PnpMessage = AT_PNP_RECONFIGURE_PARMS;
	    CWaitCursor wait;

        // Now submit the reconfig notification
        if (FAILED(hr=HrSendNdisHandlePnpEvent(NDIS, RECONFIGURE, c_szAtlk, pAI->m_regInfo.m_szDevAdapter,
                   c_szBlank,&Config, sizeof(ATALK_PNP_EVENT))))
            {
                return hr;
            }
	}

    //reconfigure adapters
    Config.PnpMessage = AT_PNP_RECONFIGURE_PARMS;
    for ( p=m_adapterinfolist.begin(); p!= m_adapterinfolist.end() ; p++ )
    {
        pAI = *p;

        if (pAI->m_fNotifyPnP)
        {
            // Now submit the reconfig notification
            if (FAILED(hr=HrSendNdisHandlePnpEvent(NDIS, RECONFIGURE, c_szAtlk, pAI->m_regInfo.m_szDevAdapter,
                   c_szBlank,&Config, sizeof(ATALK_PNP_EVENT))))
            {
                return hr;
            }

            // Clear the dirty state
            pAI->m_fNotifyPnP=false;
        }
    }

    Trace1("CATLKEnv::HrAtlkReconfig",hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\atlkenv.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    rtrcfg.h
//
// Router configuration property pages
//
//============================================================================

#ifndef _ATLKENV_H
#define _ATLKENV_H

#ifndef _LIST_
#include <list>
using namespace std;
#endif

#ifndef __WINCRYPT_H__
#include "wincrypt.h"
#endif
                 
#ifndef __SCLOGON_H__
#include "sclogon.h"
#endif

#ifndef _NDISPNP_
#include "ndispnp.h"
#endif

#ifndef _CSERVICE_H_
#include "cservice.h"
#endif

#ifndef _CSERVICE_H_
#include "cservice.h"
#endif

//TODO;  remove these two typdefs in favor of private\inc\???.h include (check w/ shirish)
typedef enum
{
    AT_PNP_SWITCH_ROUTING = 0,
    AT_PNP_SWITCH_DEFAULT_ADAPTER,
    AT_PNP_RECONFIGURE_PARMS
} ATALK_PNP_MSGTYPE;

typedef struct _ATALK_PNP_EVENT
{
    ATALK_PNP_MSGTYPE   PnpMessage;
} ATALK_PNP_EVENT, *PATALK_PNP_EVENT;

               
// Appletalk constants/boundary values
const DWORD MAX_RANGE_ALLOWED= 65279;
const DWORD MIN_RANGE_ALLOWED= 1;
const DWORD MAX_ZONES= 255;
const DWORD ZONELISTSIZE= 2048;
const DWORD MAX_ZONE_NAME_LEN=32;
const DWORD ZONEBUFFER_LEN=32*255;
const DWORD PARM_BUF_LEN=512;

// this definition is copied from c
#define MEDIATYPE_ETHERNET      1
#define MEDIATYPE_TOKENRING     2
#define MEDIATYPE_FDDI          3
#define MEDIATYPE_WAN           4
#define MEDIATYPE_LOCALTALK     5

// Define a structure for reading/writing all information necessary about an adapter
typedef struct
{
    DWORD  m_dwRangeLower;
    DWORD  m_dwRangeUpper;
    DWORD  m_dwSeedingNetwork;
    DWORD	m_dwMediaType;
    CString m_szDefaultZone;
    CString m_szAdapter;
    CString m_szDevAdapter;
    CString m_szPortName;
    CStringList m_listZones;
    bool  m_fDefAdapter;
} ATLK_REG_ADAPTER;

typedef struct
{
    DWORD  m_dwRangeLower;
    DWORD  m_dwRangeUpper;
    CString m_szDefaultZone;
    CStringList m_listZones;
} ATLK_DYN_ADAPTER;

struct CStop_StartAppleTalkPrint
{
	CStop_StartAppleTalkPrint()
	{
		bStopedByMe = FALSE;

		if (SUCCEEDED( csm.HrOpen(SC_MANAGER_CONNECT, NULL, NULL)))
		{

		    if (SUCCEEDED(csm.HrOpenService(&svr, c_szMacPrint)))
		    {
		        if (SUCCEEDED(svr.HrControl(SERVICE_CONTROL_STOP)))
    		    {
    			    bStopedByMe = TRUE;
		        }
		    }
        }
	/*	change to use exisiting functions
		DWORD dwErr = 0;
		hScManager = NULL;
		hService = NULL;
		bStopedByMe = FALSE;
		bUsedToBePaused = FALSE;
		
		hScManager = OpenSCManager( NULL, NULL, SC_MANAGER_CONNECT );

		if(hScManager != NULL)
			hService = OpenService(hScManager, L"MacPrint", SERVICE_ALL_ACCESS);
		else
			dwErr = GetLastError();

		if(hService != NULL)
		{
			SERVICE_STATUS	ss;
			if(QueryServiceStatus(hService, &ss) != 0)	// SUCC
			{
				if(ss.dwCurrentState == SERVICE_RUNNING || ss.dwCurrentState == SERVICE_PAUSED)
				{
					SERVICE_STATUS	ss1;
					if(ControlService(hService, SERVICE_CONTROL_STOP, &ss1) == 0)	// FAILED
						dwErr = GetLastError();
					else
					{
						bStopedByMe = TRUE;
	
						if( ss.dwCurrentState == SERVICE_PAUSED )
							bUsedToBePaused = TRUE;
					}
				}

				// not doing anything if not running
			}
			else
				dwErr = GetLastError();
		}
		else
		{
			dwErr = GetLastError();
			if(dwErr == ERROR_SERVICE_DOES_NOT_EXIST)
				dwErr = 0;
		}

		if(dwErr != 0)	// something was wrong
			DisplayErrorMessage(NULL, HRESULT_FROM_WIN32(dwErr));
*/			
	};

	~CStop_StartAppleTalkPrint()
	{
		if(bStopedByMe)	// start it 
		{
			svr.HrStart ();

		/* change to use existing function
			ASSERT(hService != NULL);
			if(0 == StartService(hService, 0, NULL))	// FAILED
			{
				DisplayErrorMessage(NULL, HRESULT_FROM_WIN32(GetLastError()));
			}
			else 
			{
				if(bUsedToBePaused == TRUE)
 				{
					// if it was paused
					SERVICE_STATUS	ss;
			
					if(ControlService(hService, SERVICE_CONTROL_PAUSE, &ss) == 0)	// FAILED
						DisplayErrorMessage(NULL, HRESULT_FROM_WIN32(GetLastError()));
		
				}
			}
			
		}

		// close the handles
		if(hService != NULL)
			CloseServiceHandle(hService);
		if(hScManager != NULL)
			CloseServiceHandle(hScManager);
		hService = NULL;
		hScManager = NULL;
		*/
		}
	}
protected:
/* change to use existing functions
	SC_HANDLE	hScManager;
	SC_HANDLE	hService;
	BOOL	bUsedToBePaused;
*/	
    CServiceManager csm;
    CService svr;
	BOOL	bStopedByMe;
};

// Define a structure for reading/writing AppleTalk\Parameters values
typedef struct
{
    DWORD  dwEnableRouter;
    TCHAR* szDefaultPort;
    TCHAR* szDesiredZone;
} ATLK_PARAMS;

class CAdapterInfo
{
public:
   CAdapterInfo() {m_fAlreadyShown = false;};
   ~CAdapterInfo() {};

    // m_AdapterInfo is the collection of values found under
    // AppleTalk\Parameters\Adapters\<adapter>
   ATLK_REG_ADAPTER      m_regInfo;

    // fetched via sockets
   ATLK_DYN_ADAPTER      m_dynInfo;

   bool m_fNotifyPnP;   //need to notify PnP?
   bool m_fModified;    //been modified?
   bool m_fReloadReg;   //reload registry?  
   bool m_fReloadDyn;   //reload network values?

   bool m_fAlreadyShown;    // is this adapter already in the UI?

   friend class CATLKEnv;
};


//*****************************************************************
// 
//*****************************************************************
class CATLKEnv
{
public:

   CATLKEnv() : m_dwF(0) {};
   ~CATLKEnv();

   enum {ATLK_ONLY_DEFADAPTER=0x1, ATLK_ONLY_ONADAPTER=0x2};

   list<CAdapterInfo* > m_adapterinfolist;
   typedef list<CAdapterInfo* > AL;
   typedef list<CAdapterInfo* >::iterator AI;

   void SetServerName(CString& szServerName)
       { m_szServerName = szServerName; }

      //this reloads registry (optional) and network values
   HRESULT GetAdapterInfo(bool fReloadReg=true);
   
      //for each adapter, loads values to registry
   HRESULT SetAdapterInfo();
      
      //this method is called for non-adapter (global) appletalk changes
   static HRESULT HrAtlkPnPSwithRouting();
      
      //this method is called for adapter specific PnP notifications
   HRESULT HrAtlkPnPReconfigParams(BOOL bForcePnP = FALSE);
   
      //find a specific adapter info
   CAdapterInfo* FindAdapter(CString& szAdapter);

   static HRESULT	IsAdapterBoundToAtlk(LPWSTR szAdapter, BOOL* bBound);

// registry value "MediaType" is added, so this function is not necessary.
//   HRESULT IsLocalTalkAdaptor(CAdapterInfo* pAdapterInfo, BOOL* pbIsLocalTalk);
   // S_OK: LOCALTALK
   // S_FALSE: Not
   // ERRORs
      
      //reloads reg and dynamic info for an adapterinfo
   HRESULT ReloadAdapter(CAdapterInfo* pAdapterInfo, bool fOnlyDyn =false);
   
      //set specific flags for loading (not multithread safe!)
   void SetFlags(DWORD dwF) {m_dwF=dwF;}
   
      //load adapter info
   HRESULT FetchRegInit();

protected:
 
   CString     m_szServerName;
   bool        m_fATrunning;
   DWORD       m_dwDefaultAdaptersMediaType;
   ATLK_PARAMS m_Params;
   DWORD       m_dwF;

   HRESULT _HrGetAndSetNetworkInformation(SOCKET socket, CAdapterInfo* pAdapInfo);
   void _AddZones(CHAR * szZoneList, ULONG NumZones, CAdapterInfo* pAdapterinfo);
};
  
                 
#endif _ATLKENV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\atlkcomp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	atlkcomp.h
		This file contains the prototypes for the derived classes 
		for CComponent and CComponentData.  Most of these functions 
		are pure virtual functions that need to be overridden 
		for snapin functionality.
		
    FILE HISTORY:
        
*/

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

#ifndef _CCDATA_H
#include "ccdata.h"
#endif

#ifndef _COMPONT_H
#include "compont.h"
#endif

#ifndef _COLUMN_H
#include "column.h"
#endif

#ifndef _atlkSTRM_H
#include "atlkstrm.h"
#endif


/*---------------------------------------------------------------------------
	CATLKComponentData

	This is the base implementation of ComponentData.  This will be
	incorporated into the two derived classes.
 ---------------------------------------------------------------------------*/

class CATLKComponentData :
	public CComponentData,
	public CComObjectRoot,
	public CComCoClass<CATLKComponentData, &CLSID_ATLKAdminExtension>
{
public:
	
BEGIN_COM_MAP(CATLKComponentData)
	COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

DECLARE_REGISTRY(CATLKComponentData,
				 _T("RouterATLKAdminExtension.RouterATLKAdminExtension.1"),
				 _T("RouterATLKAdminExtension.RouterATLKAdminExtension"),
				 IDS_ATLK_DESC, THREADFLAGS_APARTMENT);
	
	// These are the interfaces that we MUST implement

	// We will implement our common behavior here, with the derived
	// classes implementing the specific behavior.
	DeclareIPersistStreamInitMembers(IMPL)
	DeclareITFSCompDataCallbackMembers(IMPL)

	CATLKComponentData();

	HRESULT FinalConstruct();
	void FinalRelease();
	
protected:
	SPITFSNodeMgr	m_spNodeMgr;
};



/////////////////////////////////////////////////////////////////////////////
//
// CSampleComponent
//
/////////////////////////////////////////////////////////////////////////////

class CATLKComponent : 
	public TFSComponent,
	public IPersistStreamInit
{
public:
	CATLKComponent();
	~CATLKComponent();

	DeclareIUnknownMembers(IMPL)
	DeclareIPersistStreamInitMembers(IMPL)
	DeclareITFSCompCallbackMembers(IMPL)

	// Override OnQueryDataObject, so that we can forward
	// the calls down to the Result Handlers
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject);
	STDMETHOD(OnSnapinHelp)(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);
	
//Attributes
private:
	ATLKComponentConfigStream	m_ComponentConfig;
};



/*---------------------------------------------------------------------------
	This is the derived class for handling the IAbout interface from MMC
	Author: EricDav
 ---------------------------------------------------------------------------*/
class CATLKAbout : 
	public CAbout,
    public CComCoClass<CATLKAbout, &CLSID_ATLKAdminAbout>
{
public:
DECLARE_REGISTRY(CATLKAbout, 
				 _T("RouterATLKSnapin.About.1"), 
				 _T("RouterATLKSnapin.About"), 
				 IDS_ATLK_DESC, 
				 THREADFLAGS_APARTMENT)

BEGIN_COM_MAP(CATLKAbout)
    COM_INTERFACE_ENTRY(ISnapinAbout) // Must have one static entry
	COM_INTERFACE_ENTRY_CHAIN(CAbout) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CATLKAbout)

// these must be overridden to provide values to the base class
protected:
	virtual UINT GetAboutDescriptionId() { return IDS_ABOUT_ATLKDESC; }
	virtual UINT GetAboutProviderId()	 { return IDS_ABOUT_ATLKPROVIDER; }
	virtual UINT GetAboutVersionId()	 { return IDS_ABOUT_ATLKVERSION; }
	virtual UINT GetAboutIconId()		 { return IDI_ATLK_ICON; }

	virtual UINT GetSmallRootId()		 { return 0; }
	virtual UINT GetSmallOpenRootId()	 { return 0; }
	virtual UINT GetLargeRootId()		 { return 0; }
	virtual COLORREF GetLargeColorMask() { return (COLORREF) 0; } 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\atlkroot.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	root.h
		Root node information (the root node is not displayed
		in the MMC framework but contains information such as 
		all of the subnodes in this snapin).
		
    FILE HISTORY:
        
*/

#ifndef _ATLKROOT_H
#define _ATLKROOT_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _QUERYOBJ_H
#include "queryobj.h"
#endif

#ifndef _ATLKSTRM_H
#include "ATLKstrm.h"
#endif

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _ROOT_H
#include "root.h"
#endif


/*---------------------------------------------------------------------------
	Class:	ATLKRootHandler

	There should be a ATLKRootHandler for every root node created.
	ATLKRootHandler's have a 1-to-1 relationship with their node!
	Other parts of the code depend on this.
 ---------------------------------------------------------------------------*/
class ATLKRootHandler
	   : public RootHandler
{
public:
	ATLKRootHandler(ITFSComponentData *pCompData);
	~ATLKRootHandler()
			{ DEBUG_DECREMENT_INSTANCE_COUNTER(ATLKRootHandler); };

	// Override QI to handle embedded interface
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);

	DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown);

	STDMETHOD(GetClassID)(CLSID *pClassId);

	// Notification overrides
	HRESULT OnExpand(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);

	// Handler overrides
	OVERRIDE_NodeHandler_OnCreateDataObject();
	OVERRIDE_NodeHandler_DestroyHandler();

	// virtual function to access config stream
	ConfigStream *		GetConfigStream()
			{ return &m_ConfigStream; }

protected:
	HRESULT AddProtocolNode(ITFSNode *pNode, IRouterInfo * pRouterInfo);
	HRESULT RemoveProtocolNode(ITFSNode *pNode);
	HRESULT IsATLKValid(IRouterInfo *pRouter);

	ATLKConfigStream 	m_ConfigStream;
};




#endif _ATLKROOT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\atlkprop.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:	atlkprop.h
//
// History:
//
// IP Summary property sheet and property pages
//
//============================================================================


#ifndef _ATLKPROP_H
	#define _ATLKPROP_H

	#ifndef _INFO_H
		#include "info.h"
	#endif

	#ifndef _RTRSHEET_H
		#include "rtrsheet.h"
	#endif

	#ifndef _ATLKENV_H
		#include "atlkenv.h"
	#endif

class CATLKPropertySheet;
/////////////////////////////////////////////////////////////////////////////
// CATLKGeneralPage dialog

class CATLKGeneralPage :
public RtrPropertyPage
{
public:
	CATLKGeneralPage(UINT nIDTemplate, UINT nIDCaption = 0)
	: RtrPropertyPage(nIDTemplate, nIDCaption)
	{};

	~CATLKGeneralPage();

   //{{AFX_DATA(CATLKGeneralPage)
	enum { IDD = IDD_RTR_ATLK };
	//}}AFX_DATA

	HRESULT Init(CATLKPropertySheet * pIPPropSheet, CAdapterInfo* pAdapterInfo);

	// Override the OnApply() so that we can grab our data from the
	// controls in the dialog.
	virtual BOOL OnApply();

	//{{AFX_VIRTUAL(CATLKGeneralPage)
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

	afx_msg void OnSeedNetwork();
	afx_msg void OnZoneAdd();
	afx_msg void OnZoneRemove();
	afx_msg void OnZoneGetZones();
	afx_msg void OnZoneDef();
	void EnableSeedCtrls(bool f);
	afx_msg void OnRangeLowerChange();
	afx_msg void OnRangeUpperChange();
	afx_msg void OnSelchangeCmbAtlkZonedef();
	afx_msg void OnSetAsDefault();
	afx_msg void OnSelChangeZones();

	HRESULT LoadDynForAdapter(bool fForce=false);							
						   
// Implementation
protected:
	DWORD		m_dwDefID;
	CAdapterInfo* m_pAdapterInfo;
	CEdit		m_RangeLower;
	CEdit		m_RangeUpper;
	int 		m_iRangeLower;
	int 		m_iRangeUpper;
	CListBox	m_zones;
	bool		m_fDynFetch;
	CString     m_szZoneDef;
//	CComboBox	m_cmbZoneDef;
	CSpinButtonCtrl m_spinFrom;
	CSpinButtonCtrl m_spinTo;

	virtual BOOL	OnInitDialog();

	CATLKPropertySheet *	m_pATLKPropSheet;

	void SetZones(bool fForceDyn=false);
	void EnableZoneCtrls();
	BOOL ValidateNetworkRange();

	//{{AFX_MSG(CATLKGeneralPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};



class CATLKPropertySheet :
public RtrPropertySheet
{
public:
	CATLKPropertySheet(ITFSNode *pNode,
					   IComponentData *pComponentData,
					   ITFSComponentData *pTFSCompData,
					   LPCTSTR pszSheetName,
					   CWnd *pParent = NULL,
					   UINT iPage=0,
					   BOOL fScopePane = TRUE);

	HRESULT Init(IInterfaceInfo *pIf);

	virtual BOOL SaveSheetData();

	BOOL IsCancel() {return m_fCancel;};

	CATLKEnv				m_atlkEnv;

protected:
	SPIInterfaceInfo		m_spIf;
	CATLKGeneralPage		m_pageGeneral;
	SPITFSNode				m_spNode;
};


/////////////////////////////////////////////////////////////////////////////
// CEditNewZoneDialog dialog

class CEditNewZoneDialog : public CDialog
{
// Construction
public:
	CEditNewZoneDialog(CWnd* pParent = NULL);	// standard constructor

	void GetZone(OUT CString& stZone);

// Dialog Data
	//{{AFX_DATA(CEditNewZoneDialog)
	enum { IDD = IDD_RTR_ATLK_NEWZONE };
	CEdit	m_editZone;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditNewZoneDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	CString m_stZone;

	// Generated message map functions
	//{{AFX_MSG(CEditNewZoneDialog)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif _ATLKPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\atlkprop.cpp ===
/**********************************************************************/
/** 					  Microsoft Windows/NT						 **/
/** 			   Copyright(c) Microsoft Corporation, 1997 - 1999 				 **/
/**********************************************************************/

/*
	atlkprop.cpp
		
	FILE HISTORY:
		
*/

#include "stdafx.h"
#include "atlkprop.h"
#include "atlkview.h"
#include "globals.h"

BEGIN_MESSAGE_MAP(CATLKGeneralPage, RtrPropertyPage)
	//{{AFX_MSG_MAP(CATLKGeneralPage)
ON_BN_CLICKED(IDC_RTR_ATLK_SEEDNETWORK, OnSeedNetwork) // Checkbox

ON_BN_CLICKED(IDC_BTN_ATLK_ZONEADD, OnZoneAdd)
ON_BN_CLICKED(IDC_BTN_ATLK_ZONEREMOVE, OnZoneRemove)
ON_BN_CLICKED(IDC_BTN_ATLK_GETZONES, OnZoneGetZones)
ON_BN_CLICKED(IDC_ATLK_BTN_SET_DEFAULT, OnSetAsDefault)

ON_EN_CHANGE(IDC_RTR_ATLK_FROM, OnRangeLowerChange)
ON_EN_CHANGE(IDC_RTR_ATLK_TO, OnRangeUpperChange)

ON_CBN_SELCHANGE(IDC_RTR_ATLK_LB_DEFZONES, OnSelChangeZones)
// ON_CBN_SELCHANGE(IDC_CMB_ATLK_ZONEDEF, OnSelchangeCmbAtlkZonedef)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
													 

HRESULT CATLKGeneralPage::Init(CATLKPropertySheet *pPropSheet, CAdapterInfo* pAdapterInfo)
{
	m_pAdapterInfo=pAdapterInfo;
	m_pATLKPropSheet = pPropSheet;
	m_fDynFetch=false;
	return hrOK;
}

CATLKGeneralPage::~CATLKGeneralPage()
{
}

void CATLKGeneralPage::DoDataExchange(CDataExchange* pDX)
{
	RtrPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CATLKGeneralPage)
//	DDX_Control(pDX, IDC_CMB_ATLK_ZONEDEF, m_cmbZoneDef);
	DDX_Text(pDX, IDC_RTR_ATLK_DEFAULTZONE_DISPLAY, m_szZoneDef);
	DDX_Control(pDX, IDC_RTR_ATLK_FROM, m_RangeLower);
	DDX_Text(pDX, IDC_RTR_ATLK_FROM, m_iRangeLower);
	DDX_Control(pDX, IDC_RTR_ATLK_TO, m_RangeUpper);
	DDX_Text(pDX, IDC_RTR_ATLK_TO, m_iRangeUpper);
	DDX_Control(pDX, IDC_RTR_ATLK_LB_DEFZONES, m_zones);

	DDX_Control(pDX, IDC_ATLK_SPIN_FROM, m_spinFrom);
	DDX_Control(pDX, IDC_ATLK_SPIN_TO, m_spinTo);	
	//}}AFX_DATA_MAP
}


BOOL CATLKGeneralPage::OnInitDialog()
{
	HRESULT 	hr= hrOK;
	DWORD * 	pdw;
	int 		i;

	// check if router is enabled, if not then disable all the controls on the page
	if(!IfATLKRoutingEnabled())
		EnableChildControls(GetSafeHwnd(), PROPPAGE_CHILD_DISABLE);

	Assert(m_pAdapterInfo);

	RtrPropertyPage::OnInitDialog();

	CheckDlgButton(IDC_RTR_ATLK_SEEDNETWORK, m_pAdapterInfo->m_regInfo.m_dwSeedingNetwork );

	if (m_pAdapterInfo->m_regInfo.m_dwSeedingNetwork)
	{
		TCHAR buf[11];
		m_RangeLower.SetWindowText( _ltot(m_pAdapterInfo->m_regInfo.m_dwRangeLower,buf,10)	);
		m_RangeUpper.SetWindowText( _ltot(m_pAdapterInfo->m_regInfo.m_dwRangeUpper,buf,10)	);
	}
	else
	{	//non-seeded
		
		TCHAR buf[11];
		m_RangeLower.SetWindowText( _ltot(1,buf,10)  );
		m_RangeUpper.SetWindowText( _ltot(1,buf,10)  );

		hr = LoadDynForAdapter();	

		if(!FAILED(hr))
		{
			m_RangeLower.SetWindowText( _ltot(m_pAdapterInfo->m_dynInfo.m_dwRangeLower,buf,10)	);
			m_RangeUpper.SetWindowText( _ltot(m_pAdapterInfo->m_dynInfo.m_dwRangeUpper,buf,10)	);
		}
	}

	SetZones();

	if(IfATLKRoutingEnabled())
		EnableSeedCtrls ( m_pAdapterInfo->m_regInfo.m_dwSeedingNetwork!=0 );

	m_spinFrom.SetRange(0, 8192);
	m_spinTo.SetRange(0, 8192);

	m_spinFrom.SetBuddy(GetDlgItem(IDC_RTR_ATLK_FROM));
	m_spinTo.SetBuddy(GetDlgItem(IDC_RTR_ATLK_TO));

	// disable upper range on local talk
	if(m_pAdapterInfo->m_regInfo.m_dwMediaType == MEDIATYPE_LOCALTALK)
		m_RangeUpper.EnableWindow(FALSE);

	m_dwDefID=GetDefID();  
	  
	SetDirty(FALSE);
	SetModified();

	return TRUE;
}

HRESULT CATLKGeneralPage::LoadDynForAdapter(bool fForce/*=false*/) 
{
	CWaitCursor wait;
	HRESULT 	hr = S_OK;
	if (fForce || !m_fDynFetch)
	{
	   if ( !FHrSucceeded(hr = m_pATLKPropSheet->m_atlkEnv.ReloadAdapter(m_pAdapterInfo, true)) )
	   {
		  DisplayIdErrorMessage2(NULL, IDS_ERR_ARAP_NOADAPTINFO, hr);
		  return hr;
	   }
		  
	   m_fDynFetch=true;
	}
	return hr;
}

void CATLKGeneralPage::OnZoneGetZones() 
{
	CWaitCursor wait;
	Assert(m_pATLKPropSheet);
		
		//forced fetch on dynamic zones for this adapter
	HRESULT hr = LoadDynForAdapter(true);
	if(FAILED(hr))
	{	
//XX		EnableWindow(FALSE);
        return;
	}

	   //load the controls with dynamic zones
	SetZones(true);
	
	   //load new winsock netranges also
	TCHAR buf[11];
	m_RangeLower.SetWindowText( _ltot(m_pAdapterInfo->m_dynInfo.m_dwRangeLower,buf,10)	);
	m_RangeUpper.SetWindowText( _ltot(m_pAdapterInfo->m_dynInfo.m_dwRangeUpper,buf,10)	);

	if (m_pAdapterInfo->m_dynInfo.m_listZones.GetCount()==0)
	{
		AfxMessageBox(IDS_ATLK_NOZONES);
	}

	SetDirty(TRUE);
	SetModified();
    
}

void CATLKGeneralPage::OnRangeLowerChange()
{
	// update upper range automaticcaly on local talk
	if(m_pAdapterInfo->m_regInfo.m_dwMediaType == MEDIATYPE_LOCALTALK)
	{
		CString str;
		m_RangeLower.GetWindowText(str);
		m_RangeUpper.SetWindowText(str);
		m_RangeUpper.UpdateWindow();
	}

	SetDirty(TRUE);
	SetModified();
}

void CATLKGeneralPage::OnRangeUpperChange()
{

	SetDirty(TRUE);
	SetModified();
}

void CATLKGeneralPage::OnSetAsDefault()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	UpdateData(TRUE);

	int i;

	if ( (i = m_zones.GetCurSel()) == LB_ERR )
		return;

	CString sz;
	m_zones.GetText(i, sz);

	m_szZoneDef = sz;

	SetDirty(TRUE);
	SetModified();
	
	GetDlgItem(IDC_ATLK_BTN_SET_DEFAULT)->EnableWindow(false);

	UpdateData(FALSE);
}

void CATLKGeneralPage::SetZones(bool fForceDyn/*=false*/)
{
	POSITION pos;
	Assert(m_pAdapterInfo);
	HRESULT hr = S_OK;
	CString stDefZone;
	int iCmb;

	UpdateData(TRUE);

	Assert(m_zones.GetSafeHwnd());
	m_zones.ResetContent();
//	m_cmbZoneDef.ResetContent();

	CStringList* psl=NULL;

	if (fForceDyn || m_pAdapterInfo->m_regInfo.m_dwSeedingNetwork==0)
	{ //non-seeded or forced uses network zones only 
		hr = LoadDynForAdapter();
		if(FAILED(hr))
		{
//XX			EnableWindow(FALSE);
			goto Error;
		}
	
		stDefZone = m_pAdapterInfo->m_dynInfo.m_szDefaultZone;
		
		psl= &(m_pAdapterInfo->m_dynInfo.m_listZones);
	}
	else
	{ //seeded uses registry settings
		if (m_pAdapterInfo->m_regInfo.m_szDefaultZone.IsEmpty())
		{
			hr = LoadDynForAdapter();
			if(FAILED(hr))
			{
//XX				EnableWindow(FALSE);
				goto Error;
			}
			stDefZone = m_pAdapterInfo->m_dynInfo.m_szDefaultZone;
		}
		else
		{
			stDefZone = m_pAdapterInfo->m_regInfo.m_szDefaultZone;
		}

		//seed rtr--fetch from reg if present; otherwize get winsock ones.	 
		if (m_pAdapterInfo->m_regInfo.m_listZones.GetCount()>0)
		   psl= &(m_pAdapterInfo->m_regInfo.m_listZones);
		else
		{
		   hr = LoadDynForAdapter();
			if(FAILED(hr))
			{
//XX				EnableWindow(FALSE);
				goto Error;
			}
		   psl= &(m_pAdapterInfo->m_dynInfo.m_listZones);
		}
	}
	
	Assert(psl);

	pos = psl->GetHeadPosition();
	while ( pos )
	{
		CString& sz = psl->GetNext(pos);
		if ( sz!=_T("") )
		{
			m_zones.AddString(sz);
//			m_cmbZoneDef.AddString((LPCTSTR)sz);
		}
	}

	if ( m_zones.GetCount()>=1 )
	{
		m_zones.SetCurSel(0);
		OnSelChangeZones();
	}


//	if((iCmb = m_cmbZoneDef.FindStringExact(-1, (LPCTSTR)stDefZone)) != CB_ERR)
//	    m_cmbZoneDef.SetCurSel( iCmb );
	m_szZoneDef = stDefZone;

	UpdateData(FALSE);

	if(IfATLKRoutingEnabled())
		EnableZoneCtrls();	 
Error:	  
;
}

void CATLKGeneralPage::EnableZoneCtrls()
{
	bool f= (m_zones.GetCount()>=1);
	GetDlgItem(IDC_BTN_ATLK_ZONEREMOVE)->EnableWindow(f);

	// Wei Jiang, BUG # 145767
	if(!f && (GetFocus() == GetDlgItem(IDC_BTN_ATLK_ZONEREMOVE)))
		GetDlgItem(IDC_RTR_ATLK_SEEDNETWORK)->SetFocus();


	DWORD i;
	if ( (i = m_zones.GetCurSel()) == LB_ERR )
		return;

	CString sz;
	m_zones.GetText(i, sz);

	if (sz == m_szZoneDef)
		GetDlgItem(IDC_ATLK_BTN_SET_DEFAULT)->EnableWindow(false);
	else
		GetDlgItem(IDC_ATLK_BTN_SET_DEFAULT)->EnableWindow(true);
}

BOOL CATLKGeneralPage::OnApply()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	BOOL		fReturn;
	HRESULT 	hr = hrOK;
	CString sz;
	int 		iCmb;
	Assert(m_pAdapterInfo);

	
	m_pAdapterInfo->m_fModified= !m_pATLKPropSheet->IsCancel();

	if ( m_pAdapterInfo->m_fModified )
	{
		m_pAdapterInfo->m_regInfo.m_dwSeedingNetwork = IsDlgButtonChecked(IDC_RTR_ATLK_SEEDNETWORK);  

		if ( m_pAdapterInfo->m_regInfo.m_dwSeedingNetwork )
		{
			sz = m_szZoneDef;
			BOOL bDefaultZoneInZoneList = FALSE;
			CString szZoneString;
			for (int n = 0;  n < m_zones.GetCount(); n++)
			{
				m_zones.GetText(n, szZoneString);
				if ( sz.CompareNoCase(szZoneString) == 0 )
				{
					bDefaultZoneInZoneList = TRUE;
					break;
				}
			}

			if ( sz.GetLength()>0 )
			{
				if (!bDefaultZoneInZoneList)
				{
					AfxMessageBox(IDS_WRN_ATLK_DELDEFZONE);
					return FALSE;
				}
				m_pAdapterInfo->m_regInfo.m_szDefaultZone=sz;
			}
			else
			{
				AfxMessageBox(IDS_WRN_ATLK_SEEDDEFZONE);
				return FALSE;
			}

			if ( !ValidateNetworkRange() )
			{
				return FALSE;
			}

			m_RangeLower.GetWindowText(sz);
			m_pAdapterInfo->m_regInfo.m_dwRangeLower = _ttol(sz);
			m_RangeUpper.GetWindowText(sz);
			m_pAdapterInfo->m_regInfo.m_dwRangeUpper = _ttol(sz);

			m_pAdapterInfo->m_regInfo.m_listZones.RemoveAll();
			for ( int i=0, c=m_zones.GetCount(); i<c ; i++ )
			{
				m_zones.GetText(i,sz);
				m_pAdapterInfo->m_regInfo.m_listZones.AddTail(sz);						   
			}
			m_pAdapterInfo->m_regInfo.m_listZones.AddTail( _T("") );						 
		}
		else
		{	  //for non-seeded network, remove all seeded values
			m_pAdapterInfo->m_regInfo.m_szDefaultZone=_T("");
			m_pAdapterInfo->m_regInfo.m_dwRangeLower=0;
			m_pAdapterInfo->m_regInfo.m_dwRangeUpper=0;
			m_pAdapterInfo->m_regInfo.m_listZones.RemoveAll();
		}
	}

	fReturn = RtrPropertyPage::OnApply();

	if ( !FHrSucceeded(hr) )
		fReturn = FALSE;
	return fReturn;
}


BOOL CATLKGeneralPage::ValidateNetworkRange() 
{
	CWaitCursor wait;
	CString szLower, szUpper;
	CATLKEnv::AI iter;
	Assert(m_pATLKPropSheet);
	Assert(m_pAdapterInfo);

	
	static bool fLoaded=false;
	
	if (!fLoaded)
	{ //fetch all adapter's dynamic zone & range
	
		if (m_pATLKPropSheet->m_atlkEnv.m_adapterinfolist.size() <= 1)
		{
			if(FAILED(LoadDynForAdapter()))
			{
//XX				EnableWindow(FALSE);
				return FALSE;
			}
		}
		else
		{
			m_pATLKPropSheet->m_atlkEnv.GetAdapterInfo(false);	  
		}	 
		
		fLoaded=true;
	}

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CATLKEnv::AL& list = m_pATLKPropSheet->m_atlkEnv.m_adapterinfolist;

	m_RangeLower.GetWindowText(szLower);
	m_RangeUpper.GetWindowText(szUpper);
	DWORD dwValueLower = _ttol(szLower);
	DWORD dwValueUpper = _ttol(szUpper);

	BOOL bRetVal = TRUE;

	if ( (dwValueLower < MIN_RANGE_ALLOWED) || (dwValueLower > MAX_RANGE_ALLOWED) )
	{
		CString st;
		st.Format(IDS_ERR_ARAP_LOWERRANGE, MIN_RANGE_ALLOWED, MAX_RANGE_ALLOWED);
		AfxMessageBox((LPCTSTR)st);
		m_RangeLower.SetFocus();
		m_RangeLower.SetSel(0,-1);
		bRetVal = FALSE;
		goto END;
	}
		
	if ( (dwValueUpper < MIN_RANGE_ALLOWED) || (dwValueUpper > MAX_RANGE_ALLOWED) )
	{
		CString st;
		st.Format(IDS_ERR_ARAP_UPPERRANGE, MIN_RANGE_ALLOWED, MAX_RANGE_ALLOWED);
		AfxMessageBox((LPCTSTR)st);
		m_RangeUpper.SetFocus();
		m_RangeUpper.SetSel(0,-1);
		bRetVal = FALSE;
		goto END;
	}

	if ( dwValueLower > dwValueUpper )
	{
		AfxMessageBox(IDS_ERR_ARAP_RANGE);
		m_RangeLower.SetFocus();
		m_RangeLower.SetSel(0,-1);
		bRetVal = FALSE;
		goto END;
	}
		

	for ( iter = list.begin();iter != list.end(); iter++ )
	{
		ATLK_DYN_ADAPTER& adapt =(*iter)->m_dynInfo;

		if ( adapt.m_dwRangeLower==0 && adapt.m_dwRangeUpper==0 )
			continue;

		if ( (*iter)->m_regInfo.m_szAdapter==m_pAdapterInfo->m_regInfo.m_szAdapter )
			continue;

		if ( (dwValueLower >= adapt.m_dwRangeLower) && (dwValueLower <= adapt.m_dwRangeUpper) )
		{
			AfxMessageBox(IDS_ERR_ARAP_LOWERRANGE_OVERLAP);
			m_RangeLower.SetFocus();
			m_RangeLower.SetSel(0,-1);
			bRetVal = FALSE;
			goto END;
		}

		if ( (dwValueUpper >= adapt.m_dwRangeLower) && (dwValueUpper <= adapt.m_dwRangeUpper) )
		{
			AfxMessageBox(IDS_ERR_ARAP_UPPERRANGE_OVERLAP);
			m_RangeUpper.SetFocus();
			m_RangeUpper.SetSel(0,-1);
			bRetVal = FALSE;
			goto END;
		}

		if ( (dwValueLower <= adapt.m_dwRangeLower) && (dwValueUpper >= adapt.m_dwRangeUpper) )
		{
			AfxMessageBox(IDS_ERR_ARAP_RANGE_OVERLAP);
			m_RangeLower.SetFocus();
			m_RangeLower.SetSel(0,-1);
			bRetVal = FALSE;
			goto END;
		}
			
	}

END:
	return bRetVal;
}


void CATLKGeneralPage::OnSeedNetwork() 
{
	EnableSeedCtrls(IsDlgButtonChecked(IDC_RTR_ATLK_SEEDNETWORK)!=0);

	SetDirty(TRUE);
	SetModified();
}

BOOL	IsValidZoneName(CString& str)
{
	if(str.GetLength() > 31 || str.GetLength() <= 0)
		return FALSE;
	
	if(str.FindOneOf(_T("*:=@")) != -1)
		return FALSE;

	int n = str.GetLength();

	while(--n)
	{
		int c = str.GetAt(n);
		if(c >= 128 || !_istprint((wint_t) c))
			return FALSE;
	}

	return TRUE;
}

void CATLKGeneralPage::OnZoneAdd() 
{
	CEditNewZoneDialog	editNewZone(this);

	if( editNewZone.DoModal() == IDOK )
	{
		CString sz;

		editNewZone.GetZone(sz);
		if( sz.GetLength() <= 0 ) 
			return;
	

		sz.TrimLeft();
		sz.TrimRight();
		
		if (!IsValidZoneName(sz))
		{
			AfxMessageBox(IDS_ERR_ATLK_ZONE_NAME);
			return;
		}
		// Validate if the Zone name is valid

		if( LB_ERR	!= m_zones.FindStringExact(-1, (LPCTSTR)sz))
		{
			CString stDupZoneMsg;
			stDupZoneMsg.Format(IDS_ERR_ATLK_DUP_ZONE_NAME, (LPCTSTR)sz);
			AfxMessageBox(stDupZoneMsg);
			return;
		}

		m_zones.AddString(sz);
		m_zones.SelectString(-1,sz);

//		m_cmbZoneDef.AddString((LPCTSTR)sz);
		if (m_szZoneDef.IsEmpty())
			OnSetAsDefault();
		
		EnableZoneCtrls();

		SetDirty(TRUE);
		SetModified();
	}
}

void CATLKGeneralPage::OnZoneRemove() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	int i;

	if ( (i = m_zones.GetCurSel()) == LB_ERR )
		return;

	CString sz;
	m_zones.GetText(i, sz);
	m_zones.DeleteString(i);


	EnableZoneCtrls();	 

	if ( sz.CompareNoCase(m_szZoneDef)==0 )
	{
		m_szZoneDef = _T("");
		AfxMessageBox(IDS_WRN_ATLK_DELDEFZONE);
	}

	m_zones.SetCurSel( (m_zones.GetCount() == i) ? i-1 : i );
	OnSelChangeZones();

	SetDirty(TRUE);
	SetModified();
}


void CATLKGeneralPage::OnSelChangeZones()
{
	int i;
	
	if ( (i = m_zones.GetCurSel()) == LB_ERR )
		return;

	CString sz;
	m_zones.GetText(i, sz);

	if (sz == m_szZoneDef)
		GetDlgItem(IDC_ATLK_BTN_SET_DEFAULT)->EnableWindow(false);
	else
		if(IfATLKRoutingEnabled())
			GetDlgItem(IDC_ATLK_BTN_SET_DEFAULT)->EnableWindow(true);

	SetDirty(TRUE);
	SetModified();
}

void CATLKGeneralPage::OnSelchangeCmbAtlkZonedef() 
{
	SetDirty(TRUE);
	SetModified();
}


void CATLKGeneralPage::EnableSeedCtrls(bool fEnable) 
{
	GetDlgItem(IDC_RTR_ATLK_S_RANGE)->EnableWindow(fEnable);
	GetDlgItem(IDC_RTR_ATLK_S_LOWER)->EnableWindow(fEnable);

	GetDlgItem(IDC_RTR_ATLK_DEFAULTZONE_PROMPT)->EnableWindow(fEnable);
	GetDlgItem(IDC_RTR_ATLK_DEFAULTZONE_DISPLAY)->EnableWindow(fEnable);
	GetDlgItem(IDC_ATLK_SPIN_FROM)->EnableWindow(fEnable);
	GetDlgItem(IDC_ATLK_SPIN_TO)->EnableWindow(fEnable);

	m_RangeLower.EnableWindow(fEnable);
	GetDlgItem(IDC_RTR_ATLK_S_UPPER)->EnableWindow(fEnable);
	m_RangeUpper.EnableWindow(fEnable);

    // Windows NT Bug : 354771
	// disable upper range on local talk
	
	if(m_pAdapterInfo->m_regInfo.m_dwMediaType == MEDIATYPE_LOCALTALK)
		m_RangeUpper.EnableWindow(FALSE);

	m_zones.EnableWindow(fEnable);
//	m_cmbZoneDef.EnableWindow(fEnable);
	
	GetDlgItem(IDC_ATLK_BTN_SET_DEFAULT)->EnableWindow(fEnable);
	GetDlgItem(IDC_RTR_ATLK_S_DEF)->EnableWindow(fEnable);
	GetDlgItem(IDC_BTN_ATLK_ZONEADD)->EnableWindow(fEnable);
	GetDlgItem(IDC_BTN_ATLK_GETZONES)->EnableWindow(fEnable);

	if ( fEnable )
		EnableZoneCtrls();
	else
	{
		GetDlgItem(IDC_BTN_ATLK_ZONEREMOVE)->EnableWindow(false);
	}

}



//***********************************************************************
//	Apple talk property sheet
//***********************************************************************
CATLKPropertySheet::CATLKPropertySheet(ITFSNode *pNode,
									   IComponentData *pComponentData,
									   ITFSComponentData *pTFSCompData,
									   LPCTSTR pszSheetName,
									   CWnd *pParent,
									   UINT iPage,
									   BOOL fScopePane)
: RtrPropertySheet(pNode, pComponentData, pTFSCompData,
				   pszSheetName, pParent, iPage, fScopePane),
m_pageGeneral(IDD_RTR_ATLK)
{
	m_spNode.Set(pNode);
}

/*!--------------------------------------------------------------------------
	CATLKPropertySheet::Init
		Initialize the property sheets.  The general action here will be
		to initialize/add the various pages.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CATLKPropertySheet::Init(IInterfaceInfo *pIf)
{
	Assert(pIf);
	HRESULT hr = hrOK;

	m_spIf.Set(pIf);

	// The pages are embedded members of the class
	// do not delete them.
	m_bAutoDeletePages = FALSE;

	   //winsock on adapter only
	m_atlkEnv.SetFlags(CATLKEnv::ATLK_ONLY_ONADAPTER);
	   
	   //load up container of adapters names
	m_atlkEnv.FetchRegInit();
	   
	   //find this adapterinfo in the container
	CString sz=m_spIf->GetId(); 
	CAdapterInfo* p = m_atlkEnv.FindAdapter(sz);
	Assert(p);
	if (p==NULL)
	{
	   TRACE1("The adapter GUID %s was not found in appletalk\\parameters\\adapters key", sz);
	   goto Error;
	}
	
	   //add general appletalk page
	m_pageGeneral.Init(this, p);
	AddPageToList((CPropertyPageBase*) &m_pageGeneral);

Error:
	return hr;
}


/*!--------------------------------------------------------------------------
	CATLKPropertySheet::SaveSheetData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CATLKPropertySheet::SaveSheetData()
{
	Assert(m_spIf);

	HRESULT	hr = m_atlkEnv.SetAdapterInfo();

	if ( FHrFailed(hr) )
	{
		DisplayIdErrorMessage2(NULL, IDS_ERR_ATLK_CONFIG, hr);
	}

   SPITFSNode  spParent;
	SPITFSNodeHandler	spHandler;

	m_spNode->GetParent(&spParent);
	spParent->GetHandler(&spHandler);

	spHandler->OnCommand(spParent,
						 IDS_MENU_REFRESH,
						 CCT_RESULT, NULL, 0);

	return TRUE;	return TRUE;
}




/////////////////////////////////////////////////////////////////////////////
// CEditNewZoneDialog dialog
//
// Author: NSun

CEditNewZoneDialog::CEditNewZoneDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CEditNewZoneDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEditNewZoneDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CEditNewZoneDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEditNewZoneDialog)
	DDX_Control(pDX, IDC_RTR_ATLK_NEWZONE_EDIT, m_editZone);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEditNewZoneDialog, CDialog)
	//{{AFX_MSG_MAP(CEditNewZoneDialog)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/*!----------------------------------------------------------------------------
	CEditNewZoneDialog::GetZone
		-
	Author: NSun
 ------------------------------------------------------------------------------*/
void CEditNewZoneDialog::GetZone(OUT CString& stZone)
{
	stZone = m_stZone;
}

BOOL CEditNewZoneDialog::OnInitDialog()
{
	CDialog::OnInitDialog();
	m_editZone.SetFocus();

	return FALSE;
}

void CEditNewZoneDialog::OnOK()
{
	CString st;
	m_editZone.GetWindowText(st);
	
	if(st.IsEmpty())
	{
		AfxMessageBox(IDS_ERR_ATLK_EMPTY_ZONE);
		return;
	}

	m_stZone = st;
	CDialog::OnOK();
}

void CEditNewZoneDialog::OnCancel() 
{
	CDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\atlkstat.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	ipstats.cpp
		IP Statistics implementation.
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "column.h"		// containercolumninfo
#include "ipconn.h"		// IPConnection
#include "igmprm.h"
#include "rtrlib.h"		// DWORD_CMP
#include "ipctrl.h"		// INET_CMP

#include "statsdlg.h"
#include "IGMPstat.h"
#include "resource.h"


/*---------------------------------------------------------------------------
	IGMPGroupStatistics implementation
 ---------------------------------------------------------------------------*/
extern const ContainerColumnInfo s_rgIGMPGroupStatsColumnInfo[];
const ContainerColumnInfo s_rgIGMPGroupStatsColumnInfo[] =
{
	{ IDS_STATS_IGMPGROUPTBL_INTERFACE,		0, TRUE, COL_IF_NAME },
	{ IDS_STATS_IGMPGROUPTBL_GROUPADDR,		0, TRUE, COL_IPADDR },,
	{ IDS_STATS_IGMPGROUPTBL_LASTREPORTER,	0, TRUE, COL_STRING },
	{ IDS_STATS_IGMPGROUPTBL_EXPIRYTIME,	0, TRUE, COL_DATE },
};

IGMPGroupStatistics::IGMPGroupStatistics()
	: IPStatisticsDialog(STATSDLG_FULLWINDOW |
				  STATSDLG_CONTEXTMENU |
				  STATSDLG_SELECT_COLUMNS)
{
	SetColumnInfo(s_rgIGMPGroupStatsColumnInfo,
				  DimensionOf(s_rgIGMPGroupStatsColumnInfo));
}

struct IGMPGroupData
{
	DWORD		IpAddr;
	DWORD		GrpAddr;
	DWORD		LastReporter;
	DWORD		GroupExpiryTime;
};

			
HRESULT IGMPGroupStatistics::RefreshData(BOOL fGrabNewData)
{
	DWORD	dwIndex = 0;
	HRESULT	hr;
	LPBYTE	pData = NULL;
	LPBYTE	ptr;
	SPBYTE	spMibData;
	int		cRows = 0;
	CString	st;
	ULONG	iPos;
	int		i;
	TCHAR	szNumber[32];
	PIGMP_MIB_GET_OUTPUT_DATA pimgod;
	PIGMP_MIB_GROUP_IFS_LIST pGroupIfsList;
    PIGMP_MIB_GROUP_INFO pGrpInfo;
	
	IGMPGroupData *	pIGMPData;

	Assert(m_pIPConn);

	pData = NULL;
	hr = MibGetIgmp(m_pIPConn->GetMibHandle(),
				   IGMP_GROUP_IFS_LIST_ID,
				   dwIndex,
				   &pData,
				   QUERYMODE_GETFIRST);
	spMibData = pData;

	while (hr == hrOK)
	{
     	pimgod=(PIGMP_MIB_GET_OUTPUT_DATA) pData;
		ptr=pimgod->Buffer;
        
            //for each imgid.Count number of groups
        for (UINT z=0; z < pimgod->Count; z++)
        { 
		    Assert(pData);

		    pGroupIfsList = (PIGMP_MIB_GROUP_IFS_LIST) ptr;
            pGrpInfo= (PIGMP_MIB_GROUP_INFO)pGroupIfsList->Buffer;

                //iterate interfaces attached to this group  
            for (UINT y=0; y < pGroupIfsList->NumInterfaces ; y++, pGrpInfo++)
			{
		       // fill in row of group membership statistics (per interface)
               pIGMPData = new IGMPGroupData;
	           pIGMPData->GrpAddr=pGroupIfsList->GroupAddr;
	           pIGMPData->IpAddr=pGrpInfo->IpAddr;
	           pIGMPData->LastReporter=pGrpInfo->LastReporter;
	           pIGMPData->GroupExpiryTime=pGrpInfo->GroupExpiryTime;
				
	           m_listCtrl.InsertItem(cRows, _T(""));
		       m_listCtrl.SetItemData(cRows, reinterpret_cast<DWORD>(pIGMPData));
				
               //for each statistic column
               for (i=0; i<MVR_IGMPGROUP_COUNT; i++)
	           {
		  	      if (IsSubitemVisible(i))
		          {
		               switch (i)
			           {
			     	       case MVR_IGMPGROUP_INTERFACE:
				   	          st = INET_NTOA(pIGMPData->IpAddr);
					          break;
				           case MVR_IGMPGROUP_GROUPADDR:
				   	          st = INET_NTOA(pIGMPData->GrpAddr);
					          break;
			     	       case MVR_IGMPGROUP_LASTREPORTER:
				   	          st = INET_NTOA(pIGMPData->LastReporter);
					          break;
				           case MVR_IGMPGROUP_EXPIRYTIME:
					          FormatNumber( pIGMPData->GroupExpiryTime,szNumber, DimensionOf(szNumber), FALSE);
					          st = szNumber;
					          break;
					
			       	       default:
				              Panic1("Unknown IGMPGroup info id : %d", i);
				              break;
			           }
				   
			           iPos = MapSubitemToColumn(i);
			           m_listCtrl.SetItemText(cRows, iPos, (LPCTSTR) st);
		            }
		        }
     	     	cRows++;
			}
			pData=(PBYTE) pGrpInfo;
        }	

        //Set index to current		
	    dwIndex = pGroupIfsList->GroupAddr;
			
        // Get the next row
	    pData = NULL;
	    hr = MibGetIgmp(m_pIPConn->GetMibHandle(),
	 			   IGMP_GROUP_IFS_LIST_ID,
	 			   dwIndex,
	 			   &pData,
	 			   QUERYMODE_GETNEXT);
		if (hr == hrOK)
		{
		   spMibData.Free();
		       spMibData = pData;
        }
		
	}
	return hrOK;
}

BOOL IGMPGroupStatistics::OnInitDialog()
{
	CString	st;

	st.LoadString(IDS_STATS_IGMPGROUPTBL_TITLE);
	SetWindowText((LPCTSTR) st);
	return IPStatisticsDialog::OnInitDialog();
}

int CALLBACK IGMPGroupStatisticsCompareProc(LPARAM lParam1, LPARAM lParam2,
									  LPARAM lParamSort)
{
	int	iReturn = 0;

	IGMPGroupData *	pIGMPData1 = (IGMPGroupData *) lParam1;
	IGMPGroupData *	pIGMPData2 = (IGMPGroupData *) lParam2;
	
	switch (lParamSort)
	{
		case MVR_IGMPGROUP_INTERFACE:
			iReturn = INET_CMP(pIGMPData1->IpAddr, pIGMPData2->IpAddr);
			break;
		case MVR_IGMPGROUP_GROUPADDR:
			iReturn = INET_CMP(pIGMPData1->GrpAddr, pIGMPData2->GrpAddr);
			break;
		case MVR_IGMPGROUP_LASTREPORTER:
			iReturn = DWORD_CMP(pIGMPData1->LastReporter,pIGMPData2->LastReporter);
			break;
		case MVR_IGMPGROUP_EXPIRYTIME:
			iReturn = DWORD_CMP(pIGMPData1->GroupExpiryTime,pIGMPData2->GroupExpiryTime);
			break;

		default:
			Panic1("Unknown IGMPGroup info id : %d", lParamSort);
			break;
	}
	return iReturn;
}

int CALLBACK IGMPGroupStatisticsCompareProcMinus(LPARAM lParam1, LPARAM lParam2,
									  LPARAM lParamSort)
{
	return -IGMPGroupStatisticsCompareProc(lParam1, lParam2, lParamSort);
}

PFNLVCOMPARE IGMPGroupStatistics::GetSortFunction()
{
	return IGMPGroupStatisticsCompareProc;
}

PFNLVCOMPARE IGMPGroupStatistics::GetInverseSortFunction()
{
	return IGMPGroupStatisticsCompareProcMinus;
}

void IGMPGroupStatistics::PreDeleteAllItems()
{
	IGMPGroupData *	pIGMPData;
	for (int i=0; i<m_listCtrl.GetItemCount(); i++)
	{
		pIGMPData = (IGMPGroupData *) m_listCtrl.GetItemData(i);
		delete pIGMPData;
	}
}




/*---------------------------------------------------------------------------
	IGMPInterfaceStatistics implementation
 ---------------------------------------------------------------------------*/
extern const ContainerColumnInfo s_rgIGMPInterfaceStatsColumnInfo[];
const ContainerColumnInfo s_rgIGMPInterfaceStatsColumnInfo[] =
{
	{ IDS_STATS_IGMPGROUPTBL_GROUPADDR,		0, TRUE, COL_IPADDR },
	{ IDS_STATS_IGMPGROUPTBL_LASTREPORTER,	0, TRUE, COL_STRING },
	{ IDS_STATS_IGMPGROUPTBL_EXPIRYTIME,	0, TRUE, COL_DATE },
};

IGMPInterfaceStatistics::IGMPInterfaceStatistics()
	: IPStatisticsDialog(STATSDLG_FULLWINDOW |
				  STATSDLG_CONTEXTMENU |
				  STATSDLG_SELECT_COLUMNS)
{
	SetColumnInfo(s_rgIGMPInterfaceStatsColumnInfo,
				  DimensionOf(s_rgIGMPInterfaceStatsColumnInfo));
}

struct IGMPInterfaceData
{
	DWORD		GrpAddr;
	DWORD		LastReporter;
	DWORD		GroupExpiryTime;
};

			
HRESULT IGMPInterfaceStatistics::RefreshData(BOOL fGrabNewData)
{
	DWORD	dwIndex = 0;
	HRESULT	hr;
	LPBYTE	pData = NULL;
	SPBYTE	spMibData;
	int		cRows = 0;
	CString	st;
	ULONG	iPos;
	int		i;
	LPBYTE	ptr;
	TCHAR	szNumber[32];
	PIGMP_MIB_GET_OUTPUT_DATA pimgod;
	PIGMP_MIB_IF_GROUPS_LIST pIfGroupList;
    PIGMP_MIB_GROUP_INFO pGrpInfo;
	DWORD	dwQuery = QUERYMODE_GETFIRST;
	
	IGMPInterfaceData *	pIGMPData;

	Assert(m_pIPConn);

	pData = NULL;
	hr = MibGetIgmp(m_pIPConn->GetMibHandle(),
				   IGMP_IF_GROUPS_LIST_ID,
				   dwIndex,
				   &pData,
				   QUERYMODE_GETFIRST);
	spMibData = pData;
	dwQuery = QUERYMODE_GETNEXT;

    pimgod=(PIGMP_MIB_GET_OUTPUT_DATA) pData;
	ptr=pimgod->Buffer;

	// for each imgid.Count number of groups
    for (UINT z=0; z < pimgod->Count; z++)
    { 
	    Assert(pData);

	    pIfGroupList = (PIGMP_MIB_IF_GROUPS_LIST) ptr;
        pGrpInfo= (PIGMP_MIB_GROUP_INFO)pIfGroupList->Buffer;

		// iterate interfaces attached to this group  
        for (UINT y=0; y < pIfGroupList->NumGroups ; y++, pGrpInfo++)
		{
	       // fill in row of group membership statistics (per interface)
           pIGMPData = new IGMPInterfaceData;
	       pIGMPData->GrpAddr=pGrpInfo->GroupAddr;
	       pIGMPData->LastReporter=pGrpInfo->LastReporter;
	       pIGMPData->GroupExpiryTime=pGrpInfo->GroupExpiryTime;
			
	       m_listCtrl.InsertItem(cRows, _T(""));
	       m_listCtrl.SetItemData(cRows, reinterpret_cast<DWORD>(pIGMPData));

           //for each statistic column
           for (i=0; i<MVR_IGMPGROUP_COUNT; i++)
	       {
	  	      if (IsSubitemVisible(i))
	          {
	               switch (i)
		           {
			           case MVR_IGMPINTERFACE_GROUPADDR:
			   	          st = INET_NTOA(pIGMPData->GrpAddr);
				          break;
		     	       case MVR_IGMPINTERFACE_LASTREPORTER:
			   	          st = INET_NTOA(pIGMPData->LastReporter);
				          break;
			           case MVR_IGMPINTERFACE_EXPIRYTIME:
				          FormatNumber( pIGMPData->GroupExpiryTime,szNumber, DimensionOf(szNumber), FALSE);
				          st = szNumber;
				          break;
				
		       	       default:
			              Panic1("Unknown IGMPGroup info id : %d", i);
			              break;
		           }
			   
		           iPos = MapSubitemToColumn(i);
		           m_listCtrl.SetItemText(cRows, iPos, (LPCTSTR) st);
	            }
	        }
         	cRows++;
		}
		pData=(PBYTE) pGrpInfo;
    }	
	
	return hrOK;
}

BOOL IGMPInterfaceStatistics::OnInitDialog()
{
	CString	st;

	st.LoadString(IDS_STATS_IGMPINTERFACETBL_TITLE);
	SetWindowText((LPCTSTR) st);
	return IPStatisticsDialog::OnInitDialog();
}

int CALLBACK IGMPInterfaceStatisticsCompareProc(LPARAM lParam1, LPARAM lParam2,
									  LPARAM lParamSort)
{
	int	iReturn = 0;

	IGMPInterfaceData *	pIGMPData1 = (IGMPInterfaceData *) lParam1;
	IGMPInterfaceData *	pIGMPData2 = (IGMPInterfaceData *) lParam2;
	
	switch (lParamSort)
	{
		case MVR_IGMPINTERFACE_GROUPADDR:
			iReturn = INET_CMP(pIGMPData1->GrpAddr, pIGMPData2->GrpAddr);
			break;
		case MVR_IGMPINTERFACE_LASTREPORTER:
			iReturn = DWORD_CMP(pIGMPData1->LastReporter,pIGMPData2->LastReporter);
			break;
		case MVR_IGMPINTERFACE_EXPIRYTIME:
			iReturn = DWORD_CMP(pIGMPData1->GroupExpiryTime,pIGMPData2->GroupExpiryTime);
			break;

		default:
			Panic1("Unknown IGMPINTERFACE info id : %d", lParamSort);
			break;
	}
	return iReturn;
}

int CALLBACK IGMPInterfaceStatisticsCompareProcMinus(LPARAM lParam1, LPARAM lParam2,
									  LPARAM lParamSort)
{
	return -IGMPInterfaceStatisticsCompareProc(lParam1, lParam2, lParamSort);
}

PFNLVCOMPARE IGMPInterfaceStatistics::GetSortFunction()
{
	return IGMPInterfaceStatisticsCompareProc;
}

PFNLVCOMPARE IGMPInterfaceStatistics::GetInverseSortFunction()
{
	return IGMPInterfaceStatisticsCompareProcMinus;
}

void IGMPInterfaceStatistics::PreDeleteAllItems()
{
	IGMPInterfaceData *	pIGMPData;
	for (int i=0; i<m_listCtrl.GetItemCount(); i++)
	{
		pIGMPData = (IGMPInterfaceData *) m_listCtrl.GetItemData(i);
		delete pIGMPData;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\atlkroot.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    root.cpp
        Root node information (the root node is not displayed
        in the MMC framework but contains information such as 
        all of the subnodes in this snapin).
        
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ATLKROOT.h"
#include "ATLKVIEW.h"   // ATLK handlers
#include "rtrcfg.h"

/*---------------------------------------------------------------------------
    RipRootHandler implementation
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(ATLKRootHandler)

extern const ContainerColumnInfo s_rgATLKInterfaceStatsColumnInfo[];

extern const ContainerColumnInfo s_rgATLKGroupStatsColumnInfo[];

struct _ViewInfoColumnEntry
{
    UINT    m_ulId;
    UINT    m_cColumns;
    const ContainerColumnInfo *m_prgColumn;
};

//static const struct _ViewInfoColumnEntry   s_rgViewColumnInfo[] =
//{
// { ATLKSTRM_STATS_ATLKNBR, MVR_ATLKGROUP_COUNT, s_rgATLKGroupStatsColumnInfo },
// { ATLKSTRM_IFSTATS_ATLKNBR, MVR_ATLKINTERFACE_COUNT, s_rgATLKInterfaceStatsColumnInfo },
//};



ATLKRootHandler::ATLKRootHandler(ITFSComponentData *pCompData)
    : RootHandler(pCompData)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(ATLKRootHandler)

// m_ConfigStream.Init(DimensionOf(s_rgViewColumnInfo));

// for (int i=0; i<DimensionOf(s_rgViewColumnInfo); i++)
// {
//    m_ConfigStream.InitViewInfo(s_rgViewColumnInfo[i].m_ulId,
//                         s_rgViewColumnInfo[i].m_cColumns,
//                         s_rgViewColumnInfo[i].m_prgColumn);
// }
}


STDMETHODIMP ATLKRootHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if ( ppv == NULL )
        return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if ( riid == IID_IUnknown )
        *ppv = (LPVOID) this;
    else if ( riid == IID_IRtrAdviseSink )
        *ppv = &m_IRtrAdviseSink;
    else
        return RootHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if ( *ppv )
    {
        ((LPUNKNOWN) *ppv)->AddRef();
        return hrOK;
    }
    else
        return E_NOINTERFACE;   
}


///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members

STDMETHODIMP ATLKRootHandler::GetClassID
(
CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_ATLKAdminExtension;

    return hrOK;
}

/*!--------------------------------------------------------------------------
    ATLKRootHandler::OnExpand
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKRootHandler::OnExpand(ITFSNode *pNode,LPDATAOBJECT pDataObject, DWORD dwType, LPARAM arg,LPARAM lParam)
{
    HRESULT hr = hrOK;

    SPITFSNode              spNode;
    SPIRtrMgrProtocolInfo   spRmProt;
    SPIRouterInfo           spRouterInfo;

    // Grab the router info from the dataobject
    spRouterInfo.Query(pDataObject);
    Assert(spRouterInfo);

    // dont expand AppleTalk node if remote or
    // appletalk isnt installed
	if ( !IsLocalMachine(spRouterInfo->GetMachineName()) ||
		 FHrFailed(IsATLKValid(spRouterInfo)) )
    {
        hr=hrFail;
        goto Error;
    }

    CORg( AddProtocolNode(pNode, spRouterInfo) );

    Error:
    return hr;
}


HRESULT ATLKRootHandler::IsATLKValid(IRouterInfo *pRouter)
{
    RegKey regkey;
    DWORD dwRtrType=0;
    HRESULT hr = hrOK;

    if ( ERROR_SUCCESS != regkey.Open(HKEY_LOCAL_MACHINE, c_szRegKeyAppletalk) )
    {
        return hrFail;
    }

	// If the Router is not a RAS router, then don't show AppleTalk
	// ----------------------------------------------------------------
    if ( ! (pRouter->GetRouterType() & (ROUTER_TYPE_RAS | ROUTER_TYPE_LAN)) )
    {
        return hrFail;
    }

    return hr;
}


/*!--------------------------------------------------------------------------
    ATLKRootHandler::OnCreateDataObject
        Implementation of ITFSNodeHandler::OnCreateDataObject
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP ATLKRootHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
    HRESULT             hr = hrOK;
    CDataObject *       pObject = NULL;
    SPIDataObject       spDataObject;
    SPITFSNode          spNode;
    SPITFSNodeHandler   spHandler;
    SPIRouterInfo       spRouterInfo;

    COM_PROTECT_TRY
    {
        //if ( m_spRouterInfo == NULL )
        if (TRUE) 
        {
            // If we haven't created the sub nodes yet, we still have to
            // create a dataobject.
            pObject = new CDataObject;
            spDataObject = pObject; // do this so that it gets released correctly
            Assert(pObject != NULL);

            // Save cookie and type for delayed rendering
            pObject->SetType(type);
            pObject->SetCookie(cookie);

            // Store the coclass with the data object
            pObject->SetClsid(*(m_spTFSCompData->GetCoClassID()));

            pObject->SetTFSComponentData(m_spTFSCompData);

            hr = pObject->QueryInterface(IID_IDataObject, 
                                         reinterpret_cast<void**>(ppDataObject));

        }
        else
            hr = CreateDataObjectFromRouterInfo(spRouterInfo,
												spRouterInfo->GetMachineName(),
                                                type, cookie, m_spTFSCompData,
                                                ppDataObject, NULL, FALSE);
    }
    COM_PROTECT_CATCH;
    return hr;
}



ImplementEmbeddedUnknown(ATLKRootHandler, IRtrAdviseSink)

STDMETHODIMP ATLKRootHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
	DWORD dwChangeType,
	DWORD dwObjectType,
	LPARAM lUserParam,
	LPARAM lParam)
{
    InitPThis(ATLKRootHandler, IRtrAdviseSink);
    HRESULT     hr = hrOK;
    SPITFSNode  spNode;

    if ( dwObjectType != ROUTER_OBJ_RmProt )
        return hr;

    COM_PROTECT_TRY
    {
        if ( dwChangeType == ROUTER_CHILD_ADD )
        {
        }
        else if ( dwChangeType == ROUTER_CHILD_DELETE )
        {
        }

    }
    COM_PROTECT_CATCH;

    return hr;
}

/*!--------------------------------------------------------------------------
    ATLKRootHandler::DestroyHandler
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP ATLKRootHandler::DestroyHandler(ITFSNode *pNode)
{
    return hrOK;
}

/*!--------------------------------------------------------------------------
    ATLKRootHandler::AddProtocolNode
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKRootHandler::AddProtocolNode(ITFSNode *pNode, IRouterInfo * pRouterInfo)
{
    SPITFSNodeHandler   spHandler;
    ATLKNodeHandler *   pHandler = NULL;
    HRESULT             hr = hrOK;
    SPITFSNode          spNode;

    pHandler = new ATLKNodeHandler(m_spTFSCompData);
    spHandler = pHandler;
    CORg( pHandler->Init(pRouterInfo, &m_ConfigStream) );

    CreateContainerTFSNode(&spNode,
                           &GUID_ATLKNodeType,
                           static_cast<ITFSNodeHandler *>(pHandler),
                           static_cast<ITFSResultHandler *>(pHandler),
                           m_spNodeMgr);

    // Call to the node handler to init the node data
    pHandler->ConstructNode(spNode);

    // Make the node immediately visible
    spNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->AddChild(spNode);

    Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    ATLKRootHandler::RemoveProtocolNode
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKRootHandler::RemoveProtocolNode(ITFSNode *pNode)
{
    Assert(pNode);

    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spNode;
    HRESULT         hr = hrOK;

    CORg( pNode->GetEnum(&spNodeEnum) );

    while ( spNodeEnum->Next(1, &spNode, NULL) == hrOK )
    {
        pNode->RemoveChild(spNode);
        spNode->Destroy();
        spNode.Release();
    }

    Error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\atlkstrm.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	ATLKSTRM.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ATLKstrm.h"
#include "xstream.h"

/*!--------------------------------------------------------------------------
	ATLKConfigStream::ATLKConfigStream
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
ATLKConfigStream::ATLKConfigStream()
{
	m_nVersionAdmin = 0x00020000;
	m_nVersion = 0x00020000;

}

/*!--------------------------------------------------------------------------
	ATLKConfigStream::InitNew
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKConfigStream::InitNew()
{
	// Setup the appropriate defaults
//	m_nVersionAdmin = 0x00020000;
//	m_nVersion = 0x00020000;
//	m_stName.Empty();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	ATLKConfigStream::SaveTo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKConfigStream::SaveTo(IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_WRITE, NULL);
}

/*!--------------------------------------------------------------------------
	ATLKConfigStream::SaveAs
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKConfigStream::SaveAs(UINT nVersion, IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_WRITE, NULL);
}

/*!--------------------------------------------------------------------------
	ATLKConfigStream::LoadFrom
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKConfigStream::LoadFrom(IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_READ, NULL);
}

/*!--------------------------------------------------------------------------
	ATLKConfigStream::GetSize
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKConfigStream::GetSize(ULONG *pcbSize)
{
	return XferVersion0(NULL, XferStream::MODE_SIZE, NULL);
}

/*!--------------------------------------------------------------------------
	ATLKConfigStream::GetVersionInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKConfigStream::GetVersionInfo(DWORD *pdwVersion, DWORD *pdwAdminVersion)
{
	if (pdwVersion)
		*pdwVersion = m_nVersion;
	if (pdwAdminVersion)
		*pdwAdminVersion = m_nVersionAdmin;
	return hrOK;
}

/*!--------------------------------------------------------------------------
	ATLKConfigStream::XferVersion0
		-
	Author: KennT
 ---------------------------------------------------------------------------*/


struct _ViewInfoEntry
{
	ULONG	m_ulId;
	ULONG	m_idSort;
	ULONG	m_idAscending;
	ULONG	m_idColumns;
	ULONG	m_idPos;
};

//static const _ViewInfoEntry	s_rgATLKAdminViewInfo[]
//={
//	{ ATLKSTRM_STATS_ATLKNBR,
//		ATLKSTRM_TAG_STATS_ATLKNBR_SORT, ATLKSTRM_TAG_STATS_ATLKNBR_ASCENDING,
//		ATLKSTRM_TAG_STATS_ATLKNBR_COLUMNS, ATLKSTRM_TAG_STATS_ATLKNBR_POSITION },
//	{ ATLKSTRM_IFSTATS_ATLKNBR,
//		ATLKSTRM_TAG_IFSTATS_ATLKNBR_SORT, ATLKSTRM_TAG_IFSTATS_ATLKNBR_ASCENDING,
//		ATLKSTRM_TAG_IFSTATS_ATLKNBR_COLUMNS, ATLKSTRM_TAG_IFSTATS_ATLKNBR_POSITION },
//};		

HRESULT ATLKConfigStream::XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize)
{
	/*
	XferStream	xstm(pstm, mode);
	HRESULT		hr = hrOK;
	int			i;

	CORg( xstm.XferDWORD( ATLKSTRM_TAG_VERSION, &m_nVersion ) );
	CORg( xstm.XferDWORD( ATLKSTRM_TAG_VERSIONADMIN, &m_nVersionAdmin ) );
	
	for ( i=0; i<DimensionOf(s_rgATLKAdminViewInfo); i++)
	{
		CORg( m_rgViewInfo[s_rgATLKAdminViewInfo[i].m_ulId].Xfer(&xstm,
			s_rgATLKAdminViewInfo[i].m_idSort,
			s_rgATLKAdminViewInfo[i].m_idAscending,
			s_rgATLKAdminViewInfo[i].m_idColumns) );
		CORg( xstm.XferRect( s_rgATLKAdminViewInfo[i].m_idPos,
							 &m_prgrc[s_rgATLKAdminViewInfo[i].m_ulId]) );
	}
	if (pcbSize)
		*pcbSize = xstm.GetSize();


Error:
*/
	return hrOK;
}



/*---------------------------------------------------------------------------
	ATLKComponentConfigStream implementation
 ---------------------------------------------------------------------------*/

enum ATLKCOMPSTRM_TAG
{
	ATLKCOMPSTRM_TAG_VERSION =		XFER_TAG(1, XFER_DWORD),
	ATLKCOMPSTRM_TAG_VERSIONADMIN =	XFER_TAG(2, XFER_DWORD),
	ATLKCOMPSTRM_TAG_SUMMARY_COLUMNS = XFER_TAG(3, XFER_COLUMNDATA_ARRAY),
	ATLKCOMPSTRM_TAG_SUMMARY_SORT_COLUMN = XFER_TAG(4, XFER_DWORD),
	ATLKCOMPSTRM_TAG_SUMMARY_SORT_ASCENDING = XFER_TAG(5, XFER_DWORD),
};



HRESULT ATLKComponentConfigStream::XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize)
{
	XferStream	xstm(pstm, mode);
	HRESULT		hr = hrOK;

	CORg( xstm.XferDWORD( ATLKCOMPSTRM_TAG_VERSION, &m_nVersion ) );
	CORg( xstm.XferDWORD( ATLKCOMPSTRM_TAG_VERSIONADMIN, &m_nVersionAdmin ) );

	CORg( m_rgViewInfo[ATLK_COLUMNS].Xfer(&xstm,
										ATLKCOMPSTRM_TAG_SUMMARY_SORT_COLUMN,
										ATLKCOMPSTRM_TAG_SUMMARY_SORT_ASCENDING,
										ATLKCOMPSTRM_TAG_SUMMARY_COLUMNS) );
	
	if (pcbSize)
		*pcbSize = xstm.GetSize();

Error:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\atlkstrm.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	ATLKstrm.h
		ATLK node configuration object.

		Use this to get/set configuration data.  This class will take
		care of versioning of config formats as well as serializing
		of the data.
		
    FILE HISTORY:
        
*/

#ifndef _ATLKSTRM_H
#define _ATLKSTRM_H

#ifndef _XSTREAM_H
#include "xstream.h"
#endif

#ifndef _COLUMN_H
#include "column.h"
#endif

enum
{
	ATLK_COLUMNS = 0,
	ATLK_COLUMNS_MAX_COUNT = 1,
};

enum
{
	ATLKSTRM_STATS_ATLKNBR = 0,
	ATLKSTRM_IFSTATS_ATLKNBR,
	ATLKSTRM_STATS_COUNT,
};

enum ATLKSTRM_TAG
{
	ATLKSTRM_TAG_VERSION =		XFER_TAG(1, XFER_DWORD),
	ATLKSTRM_TAG_VERSIONADMIN =	XFER_TAG(2, XFER_DWORD),
	
	ATLKSTRM_TAG_STATS_ATLKNBR_COLUMNS =	XFER_TAG(3, XFER_COLUMNDATA_ARRAY),
	ATLKSTRM_TAG_STATS_ATLKNBR_SORT =	XFER_TAG(4, XFER_DWORD),
	ATLKSTRM_TAG_STATS_ATLKNBR_ASCENDING =	XFER_TAG(5, XFER_DWORD),
	ATLKSTRM_TAG_STATS_ATLKNBR_POSITION =	XFER_TAG(6, XFER_RECT),

	ATLKSTRM_TAG_IFSTATS_ATLKNBR_COLUMNS =	XFER_TAG(7, XFER_COLUMNDATA_ARRAY),
	ATLKSTRM_TAG_IFSTATS_ATLKNBR_SORT =	XFER_TAG(8, XFER_DWORD),
	ATLKSTRM_TAG_IFSTATS_ATLKNBR_ASCENDING =	XFER_TAG(9, XFER_DWORD),
	ATLKSTRM_TAG_IFSTATS_ATLKNBR_POSITION =	XFER_TAG(10, XFER_RECT),
	
};

/*---------------------------------------------------------------------------
	Class:	ATLKConfigStream

	This holds the configuration information for the IP administration
	nodes.  This does NOT hold the configuration information for the columns.
	That is stored in the Component Configuration streams.
 ---------------------------------------------------------------------------*/
class ATLKConfigStream : public ConfigStream
{
public:
	ATLKConfigStream();

	virtual HRESULT	InitNew();				// set defaults
	virtual HRESULT	SaveTo(IStream *pstm);
	virtual HRESULT SaveAs(UINT nVersion, IStream *pstm);
	
	virtual HRESULT LoadFrom(IStream *pstm);

	virtual HRESULT GetSize(ULONG *pcbSize);

	// --------------------------------------------------------
	// Accessors
	// --------------------------------------------------------
	
	virtual HRESULT	GetVersionInfo(DWORD *pnVersion, DWORD *pnAdminVersion);

private:
	HRESULT XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize);
};



class ATLKComponentConfigStream : public ConfigStream
{
public:
	virtual HRESULT XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize);
protected:
};


#endif _ATLKSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\atlkstat.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    IGMPstats.h
//
// History:
//	07/22/97	Kenn M. Takara			Created.
//
//	IP Statistics
//
//============================================================================


#ifndef _IGMPSTATS_H_
#define _IGMPSTATS_H_

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _STATSDLG_H
#include "statsdlg.h"
#endif

#ifndef _IPSTATS_H
#include "ipstats.h"
#endif

enum
{
	MVR_IGMPGROUP_INTERFACE	= 0,
	MVR_IGMPGROUP_GROUPADDR,
	MVR_IGMPGROUP_LASTREPORTER,
	MVR_IGMPGROUP_EXPIRYTIME,
	MVR_IGMPGROUP_COUNT,
};

enum
{
	MVR_IGMPINTERFACE_GROUPADDR=0,
	MVR_IGMPINTERFACE_LASTREPORTER,
	MVR_IGMPINTERFACE_EXPIRYTIME,
	MVR_IGMPINTERFACE_COUNT,
};


class IGMPGroupStatistics : public IPStatisticsDialog
{
public:
	IGMPGroupStatistics();

	// Override the OnInitDialog so that we can set the caption
	virtual BOOL OnInitDialog();

	// Override the RefreshData to provide sample data
	virtual HRESULT RefreshData(BOOL fGrabNewData);

	// Override this so that we can free up out item data
	virtual void PreDeleteAllItems();

	// Override these to provide sorting
	virtual PFNLVCOMPARE GetSortFunction();
	virtual PFNLVCOMPARE GetInverseSortFunction();
	
protected:
};



class IGMPInterfaceStatistics : public IPStatisticsDialog
{
public:
	IGMPInterfaceStatistics();

	// Override the OnInitDialog so that we can set the caption
	virtual BOOL OnInitDialog();

	// Override the RefreshData to provide sample data
	virtual HRESULT RefreshData(BOOL fGrabNewData);

	// Override this so that we can free up out item data
	virtual void PreDeleteAllItems();

	// Override these to provide sorting
	virtual PFNLVCOMPARE GetSortFunction();
	virtual PFNLVCOMPARE GetInverseSortFunction();
	
protected:
};



#endif _IGMPSTATS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\atlkview.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    ATLKview.cpp
        
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "atlkprop.h"
#include "atlkview.h"
#include "atlkstrm.h"   // 
#include "atlkenv.h"
#include "coldlg.h"     // columndlg
#include "column.h"     // ComponentConfigStream
#include "rtrui.h"
#include "globals.h" // IP CB defaults
#include "infoi.h"      // InterfaceInfo
#include "cfgmgr32.h"   // for CM_ calls


static const GUID GUID_DevClass_Net = {0x4D36E972,0xE325,0x11CE,{0xBF,0xC1,0x08,0x00,0x2B,0xE1,0x03,0x18}};



/*---------------------------------------------------------------------------
    Keep this in sync with the column ids in ATLKview.h
 ---------------------------------------------------------------------------*/
extern const ContainerColumnInfo    s_rgATLKViewColumnInfo[];

const ContainerColumnInfo   s_rgATLKViewColumnInfo[] = 
{
    { IDS_ATLK_COL_ADAPTERS, CON_SORT_BY_STRING, TRUE, COL_IF_NAME },
    { IDS_ATLK_COL_STATUS, CON_SORT_BY_STRING, TRUE,    COL_STATUS },
    { IDS_ATLK_COL_NETRANGE, CON_SORT_BY_STRING, TRUE,  COL_SMALL_NUM},
};


/*---------------------------------------------------------------------------
    ATLKNodeHandler implementation
 ---------------------------------------------------------------------------*/

ATLKNodeHandler::ATLKNodeHandler(ITFSComponentData *pCompData)
    : BaseContainerHandler(pCompData, ATLK_COLUMNS, s_rgATLKViewColumnInfo),
    m_ulConnId(0),
    m_ulRefreshConnId(0),
    m_ulStatsConnId(0),
    m_hDevInfo(INVALID_HANDLE_VALUE)
{
    // Setup the verb states
    m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
    m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;

	m_nTaskPadDisplayNameId = IDS_ATLK_DISPLAY_NAME;
}


ATLKNodeHandler::~ATLKNodeHandler()
{
	if (m_hDevInfo != INVALID_HANDLE_VALUE)
	{
		SetupDiDestroyDeviceInfoList(m_hDevInfo);
		m_hDevInfo = INVALID_HANDLE_VALUE;
	}
}


STDMETHODIMP ATLKNodeHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if ( ppv == NULL )
        return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if ( riid == IID_IUnknown )
        *ppv = (LPVOID) this;
    else if ( riid == IID_IRtrAdviseSink )
        *ppv = &m_IRtrAdviseSink;
    else
        return BaseContainerHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if ( *ppv )
    {
        ((LPUNKNOWN) *ppv)->AddRef();
        return hrOK;
    }
    else
        return E_NOINTERFACE;   
}



/*!--------------------------------------------------------------------------
    ATLKNodeHandler::DestroyHandler
        Implementation of ITFSNodeHandler::DestroyHandler
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP ATLKNodeHandler::DestroyHandler(ITFSNode *pNode)
{
    if ( m_ulRefreshConnId )
    {
        SPIRouterRefresh    spRefresh;
        if ( m_spRouterInfo )
            m_spRouterInfo->GetRefreshObject(&spRefresh);
        if ( spRefresh )
            spRefresh->UnadviseRefresh(m_ulRefreshConnId);
    }
    m_ulRefreshConnId = 0;

    if ( m_ulStatsConnId )
    {
        SPIRouterRefresh    spRefresh;
        if ( m_spRouterInfo )
            m_spRouterInfo->GetRefreshObject(&spRefresh);
        if ( spRefresh )
            spRefresh->UnadviseRefresh(m_ulStatsConnId);
    }
    m_ulStatsConnId = 0;


    if ( m_ulConnId )
        m_spRmProt->RtrUnadvise(m_ulConnId);
    m_ulConnId = 0;
    m_spRmProt.Release();

    m_spRm.Release();

    m_spRouterInfo.Release();
    
	if (m_hDevInfo != INVALID_HANDLE_VALUE)
	{
		SetupDiDestroyDeviceInfoList(m_hDevInfo);
		m_hDevInfo = INVALID_HANDLE_VALUE;
	}
    return hrOK;
}

/*!--------------------------------------------------------------------------
    ATLKNodeHandler::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    NOTE: the root node handler has to over-ride this function to 
    handle the snapin manager property page (wizard) case!!!
    
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
ATLKNodeHandler::HasPropertyPages
(
ITFSNode *          pNode,
LPDATAOBJECT        pDataObject, 
DATA_OBJECT_TYPES   type, 
DWORD               dwType
)
{
    return hrOK;
}


/*!--------------------------------------------------------------------------
    ATLKNodeHandler::CreatePropertyPages
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP
ATLKNodeHandler::CreatePropertyPages
(
ITFSNode *              pNode,
LPPROPERTYSHEETCALLBACK lpProvider,
LPDATAOBJECT            pDataObject, 
LONG_PTR                    handle, 
DWORD                   dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT     hr = hrOK;
    return hr;
}


/*---------------------------------------------------------------------------
    Menu data structure for our menus
 ---------------------------------------------------------------------------*/

static const SRouterNodeMenu  s_rgIfNodeMenu[] =
{
    // Add items that go on the top menu here
    { IDS_MENU_ATLK_ENABLE, ATLKNodeHandler::ATLKEnableFlags,
        CCM_INSERTIONPOINTID_PRIMARY_TOP},
    {IDS_MENU_ATLK_DISABLE, ATLKNodeHandler::ATLKEnableFlags,
        CCM_INSERTIONPOINTID_PRIMARY_TOP},
};

bool IfATLKRoutingEnabled()
{
    RegKey regkey;
    DWORD dw=0;

    if ( ERROR_SUCCESS == regkey.Open(HKEY_LOCAL_MACHINE,c_szAppleTalkService) )
        regkey.QueryValue(c_szEnableRouter, dw);
    
    return (dw!=0) ? true : false;

};

ULONG ATLKNodeHandler::ATLKEnableFlags(const SRouterNodeMenu *pMenuData,
                                       INT_PTR pUserData)
{
    ULONG uStatus = MF_GRAYED;
    BOOL fATLKEnabled = ::IfATLKRoutingEnabled();
    
    if(IDS_MENU_ATLK_ENABLE == pMenuData->m_sidMenu)
        uStatus = fATLKEnabled ? MF_GRAYED : MF_ENABLED;
    else if(IDS_MENU_ATLK_DISABLE == pMenuData->m_sidMenu)
        uStatus = fATLKEnabled ? MF_ENABLED : MF_GRAYED;

    return uStatus;
}


/*!--------------------------------------------------------------------------
    ATLKNodeHandler::OnAddMenuItems
        Implementation of ITFSNodeHandler::OnAddMenuItems
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP ATLKNodeHandler::OnAddMenuItems(
                                            ITFSNode *pNode,
                                            LPCONTEXTMENUCALLBACK pContextMenuCallback, 
                                            LPDATAOBJECT lpDataObject, 
                                            DATA_OBJECT_TYPES type, 
                                            DWORD dwType,
                                            long *pInsertionAllowed)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    ATLKNodeHandler::SMenuData  menuData;

    COM_PROTECT_TRY
    {
        menuData.m_spNode.Set(pNode);
        
        hr = AddArrayOfMenuItems(pNode, s_rgIfNodeMenu,
                                 DimensionOf(s_rgIfNodeMenu),
                                 pContextMenuCallback,
                                 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
    }
    COM_PROTECT_CATCH;

    return hr; 
}

/*!--------------------------------------------------------------------------
    ATLKNodeHandler::OnCommand
        Implementation of ITFSNodeHandler::OnCommand
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP ATLKNodeHandler::OnCommand(ITFSNode *pNode, long nCommandId, 
                                        DATA_OBJECT_TYPES    type, 
                                        LPDATAOBJECT pDataObject, 
                                        DWORD    dwType)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    RegKey regkey;

    COM_PROTECT_TRY
    {
        switch ( nCommandId )
        {
        case IDS_MENU_ATLK_ENABLE:
        case IDS_MENU_ATLK_DISABLE:

            if ( ERROR_SUCCESS == regkey.Open(HKEY_LOCAL_MACHINE,c_szAppleTalkService) )
            {
                CStop_StartAppleTalkPrint	MacPrint;

                DWORD dw = (IDS_MENU_ATLK_ENABLE == nCommandId) ? 1 : 0;
                regkey.SetValue(c_szEnableRouter, dw);

                if (FHrFailed(CATLKEnv::HrAtlkPnPSwithRouting()))
                {
                    AfxMessageBox(IDS_ERR_ATLK_CONFIG);
                }
                
                SynchronizeNodeData(pNode);
            }

            break;

        case IDS_MENU_REFRESH:
			hr = ForceGlobalRefresh(m_spRouterInfo);
            break;
        }
    }
    COM_PROTECT_CATCH;

    return hr;
}

HRESULT ATLKNodeHandler::OnVerbRefresh(ITFSNode *pNode,LPARAM arg,LPARAM lParam)
{
    // Now that we have all of the nodes, update the data for
    // all of the nodes
    return ForceGlobalRefresh(m_spRouterInfo);
}

HRESULT ATLKNodeHandler::OnResultRefresh(ITFSComponent * pComponent,
                                         LPDATAOBJECT pDataObject,
                                         MMC_COOKIE cookie,
                                         LPARAM arg,
                                         LPARAM lParam)
{
	return ForceGlobalRefresh(m_spRouterInfo);
}

/*!--------------------------------------------------------------------------
    ATLKNodeHandler::OnExpand
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKNodeHandler::OnExpand(ITFSNode *pNode,
                                  LPDATAOBJECT pDataObject,
                                  DWORD dwType,
                                  LPARAM arg,
                                  LPARAM lParam)
{
    HRESULT         hr = hrOK;
    SPIInterfaceInfo        spIf;
    ATLKList        adapterList;
    ATLKListEntry * pAtlkEntry = NULL;
    
    if ( m_bExpanded )
        return hrOK;
        
    COM_PROTECT_TRY
    {
        SynchronizeNodeData(pNode);
    }
    COM_PROTECT_CATCH;

    // cleanup
    // ----------------------------------------------------------------
    while (!adapterList.IsEmpty())
        delete adapterList.RemoveHead();

    m_bExpanded = TRUE;

    return hr;
}


/*!--------------------------------------------------------------------------
    ATLKNodeHandler::GetString
        Implementation of ITFSNodeHandler::GetString
        We don't need to do anything, since our root node is an extension
        only and thus can't do anything to the node text.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) ATLKNodeHandler::GetString(ITFSNode *pNode, int nCol)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
        if ( m_stTitle.IsEmpty() )
            m_stTitle.LoadString(IDS_ATLK_TITLE);
    }
    COM_PROTECT_CATCH;

    return m_stTitle;
}

/*!--------------------------------------------------------------------------
    ATLKNodeHandler::OnCreateDataObject
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP ATLKNodeHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
        SPIDataObject  spdo;
        CDataObject*   pdo = NULL;

        pdo= new CDataObject;
        spdo = pdo;

        // Save cookie and type for delayed rendering
        pdo->SetType(type);
        pdo->SetCookie(cookie);

            // Store the coclass with the data object
        pdo->SetClsid(*(m_spTFSCompData->GetCoClassID()));

        pdo->SetTFSComponentData(m_spTFSCompData);

        *ppDataObject = spdo.Transfer();
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    ATLKNodeHandler::Init
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKNodeHandler::Init(IRouterInfo *pRouter, ATLKConfigStream *pConfigStream)
{
    HRESULT hr=S_OK;
    RegKey regkey;

    m_spRouterInfo.Set(pRouter);

    m_pConfigStream = pConfigStream;

    return hrOK;
}


/*!--------------------------------------------------------------------------
    ATLKNodeHandler::ConstructNode
        Initializes the root node (sets it up).
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKNodeHandler::ConstructNode(ITFSNode *pNode)
{
    HRESULT         hr = hrOK;

    if ( pNode == NULL )
        return hrOK;

    COM_PROTECT_TRY
    {
        // Need to initialize the data for the root node
        pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_INTERFACES);
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_INTERFACES);
        pNode->SetData(TFS_DATA_SCOPEID, 0);

        // This is a leaf node in the scope pane
        pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

        m_cookie = reinterpret_cast<MMC_COOKIE>(pNode);
        pNode->SetData(TFS_DATA_COOKIE, m_cookie);

        pNode->SetNodeType(&GUID_ATLKNodeType);

    }
    COM_PROTECT_CATCH;

    return hr;
}



/*!--------------------------------------------------------------------------
    ATLKNodeHandler::AddInterfaceNode
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKNodeHandler::AddInterfaceNode(ITFSNode *pParent, IInterfaceInfo *pIf, IInfoBase *pInfoBase, ITFSNode **ppNewNode)
{
    HRESULT                 hr = hrOK;
    Assert(pParent);
    Assert(pIf);

    ATLKInterfaceHandler *  pHandler;
    SPITFSResultHandler     spHandler;
    SPITFSNode              spNode;
    InterfaceNodeData*      pData;

    // Create the handler for this node 
    pHandler = new ATLKInterfaceHandler(m_spTFSCompData);
    spHandler = pHandler;
    CORg( pHandler->Init(pIf, pParent, m_pConfigStream) );

    // Create a result item node (or a leaf node)
    CORg( CreateLeafTFSNode(&spNode,
                            NULL,
                            static_cast<ITFSNodeHandler *>(pHandler),
                            static_cast<ITFSResultHandler *>(pHandler),
                            m_spNodeMgr) );
    CORg( pHandler->ConstructNode(spNode, pIf) );

    pData = GET_INTERFACENODEDATA(spNode);
    Assert(pData);

    pData->m_rgData[ATLK_SI_ADAPTER].m_stData = pIf->GetTitle();

    // If we don't have a pic, it means that we have just added
    // the protocol to the interface (and am not picking up a refresh).
    // The properties dialog will make the node visible.
    // Make the node immediately visible
    CORg( spNode->SetVisibilityState(TFS_VIS_SHOW) );
    CORg( spNode->Show() );
    CORg( pParent->AddChild(spNode) );

    if (ppNewNode)
        *ppNewNode = spNode.Transfer();

    Error:
    return hr;
}


/*!--------------------------------------------------------------------------
    ATLKNodeHandler::AddMenuItems
        Implementation of ITFSResultHandler::AddMenuItems
        Use this to add commands to the context menu of the blank areas
        of the result pane.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP ATLKNodeHandler::AddMenuItems(ITFSComponent *pComponent,
                                           MMC_COOKIE cookie,
                                           LPDATAOBJECT pDataObject,
                                           LPCONTEXTMENUCALLBACK pCallback,
                                           long *pInsertionAllowed)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    ATLKNodeHandler::SMenuData  menuData;
    SPITFSNode      spNode;

    COM_PROTECT_TRY
    {
        m_spNodeMgr->FindNode(cookie, &spNode);
        menuData.m_spNode.Set(spNode);
        
        hr = AddArrayOfMenuItems(spNode, s_rgIfNodeMenu,
                                 DimensionOf(s_rgIfNodeMenu),
                                 pCallback,
                                 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
    }
    COM_PROTECT_CATCH;

    return hr; 
}


/*!--------------------------------------------------------------------------
    ATLKNodeHandler::Command
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP ATLKNodeHandler::Command(ITFSComponent *pComponent,
                                      MMC_COOKIE cookie,
                                      int nCommandID,
                                      LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = hrOK;
    SPITFSNode  spNode;

    Assert( m_spNodeMgr );

    CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

    hr = OnCommand(spNode, nCommandID, CCT_RESULT,
                  pDataObject, 0);

    Error:
    return hr;
}


ImplementEmbeddedUnknown(ATLKNodeHandler, IRtrAdviseSink)

STDMETHODIMP ATLKNodeHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
    DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
    InitPThis(ATLKNodeHandler, IRtrAdviseSink);
    SPITFSNode              spThisNode;
    SPITFSNode              spNode;
    SPITFSNodeEnum          spEnumNode;
    SPIEnumInterfaceInfo    spEnumIf;
    SPIInterfaceInfo        spIf;
    SPIRtrMgrInterfaceInfo  spRmIf;
    SPIInfoBase             spInfoBase;
    BOOL                    fPleaseAdd;
    BOOL                    fFound;
    InterfaceNodeData * pData;
    HRESULT                 hr = hrOK;

    pThis->m_spNodeMgr->FindNode(pThis->m_cookie, &spThisNode);

    if ( dwObjectType == ROUTER_OBJ_RmProtIf )
    {
    }
    else if ( dwChangeType == ROUTER_REFRESH )
    {
        if (ulConn == pThis->m_ulRefreshConnId)
            pThis->SynchronizeNodeData(spThisNode);
    }
    return hr;
}


/*!--------------------------------------------------------------------------
    ATLKNodeHandler::SynchronizeNodeData
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKNodeHandler::SynchronizeNodeData(ITFSNode *pThisNode)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = hrOK;

    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spNode;
    CStringList     ifidList;
    InterfaceNodeData * pNodeData;
    int             i;
    POSITION        pos;
    CString szBuf;
    BOOL            bBoundToAtlk;
    
    // prepare AppleTalk Env information
    CATLKEnv        atlkEnv;

    // find the AppleTalk interface object
    RegKey regkey;
    DWORD dwEnableAtlkRouting =0;


    COM_PROTECT_TRY
    {   
        if ( ERROR_SUCCESS == regkey.Open(HKEY_LOCAL_MACHINE,
                                          c_szAppleTalkService) )
            regkey.QueryValue(c_szEnableRouter, dwEnableAtlkRouting);

        // winsock on adapter only
        atlkEnv.SetFlags(CATLKEnv::ATLK_ONLY_ONADAPTER);
        
        // load up container of adapters names
        atlkEnv.FetchRegInit();


        // Mark all of the nodes
        pThisNode->GetEnum(&spNodeEnum);

        UnmarkAllNodes(pThisNode, spNodeEnum);

        
        // Iterate through the nodes, looking for the
        // data associated with the node

        spNodeEnum->Reset();
        for ( ; spNodeEnum->Next(1, &spNode, NULL) == hrOK; spNode.Release() )
        {
            CAdapterInfo *  pAdapterInfo = NULL;
            CString         stIfName;
            
            pNodeData = GET_INTERFACENODEDATA(spNode);
            Assert(pNodeData);

            stIfName = pNodeData->spIf->GetId();

            bBoundToAtlk = FALSE;
            
            // Check to see that the adapter is bound to Appletalk.
            // ----------------------------------------------------
            if (!FHrOK(CATLKEnv::IsAdapterBoundToAtlk((LPWSTR) (LPCWSTR) stIfName, &bBoundToAtlk)))
                continue;
            
            // If it's not bound to Appletalk, we're not interested
            // in the adapter.
            // ----------------------------------------------------
            if (!bBoundToAtlk)
                continue;
            
            // Need to check to see if this is a valid
            // netcard.  We may have a GUID, but it may not
            // be working.
            // ----------------------------------------------------
            if (!FIsFunctioningNetcard(stIfName))
                continue;
                    
            // Search for this ID in the atlkEnv
            pAdapterInfo = atlkEnv.FindAdapter(stIfName);
          
            // Initialize the strings for this node.
//            pNodeData->m_rgData[ATLK_SI_ADAPTER].m_stData = stIfName;

            pNodeData->m_rgData[ATLK_SI_STATUS].m_stData = _T("-");
            pNodeData->m_rgData[ATLK_SI_STATUS].m_dwData = 0;

            pNodeData->m_rgData[ATLK_SI_NETRANGE].m_stData = _T("-"); 
            pNodeData->m_rgData[ATLK_SI_NETRANGE].m_dwData = 0;

              
            // If we can't find the adapter, skip it, it will get
            // removed.
            if (pAdapterInfo == NULL)
            {
                TRACE1("The adapter GUID %s was not found in appletalk\\parameters\\adapters key", stIfName);
                continue;
            }

            
            // Ok, this node exists, mark the node
            pNodeData->dwMark = TRUE;
            pAdapterInfo->m_fAlreadyShown = true;
                        


            // Reload some of the adapter-specific information
            {
                CWaitCursor wait;
                hr = atlkEnv.ReloadAdapter(pAdapterInfo, false);
            }

            if(hr != S_OK)
            {
				DisplayTFSErrorMessage(NULL);

				// we are not removing it, since a later refresh
                // may have the information avaible
                
				// remove the adaptor from the list				
                // pThisNode->RemoveChild(spNode);
                continue;
            }
    
            SetAdapterData(spNode, pAdapterInfo, dwEnableAtlkRouting);

            // Redraw the node
            spNode->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);
        }
        
        spNode.Release();

        // Now remove all unmarked nodes
        RemoveAllUnmarkedNodes(pThisNode, spNodeEnum);


        // Now go through the list of adapters and find the ones
        // that need to be added into the list.
        // ------------------------------------------------------------

        CATLKEnv::AI p;
        CAdapterInfo* pAI=NULL;
        
        for ( p= atlkEnv.m_adapterinfolist.begin();
              p!= atlkEnv.m_adapterinfolist.end() ;
              p++ )
        {
            pAI = *p;

            if (!pAI->m_fAlreadyShown)
            {
                SPIInterfaceInfo    spIf;
                CString stKey(pAI->m_regInfo.m_szAdapter);
                SPITFSNode      spNewNode;
                SPSZ			spszTitle;

                bBoundToAtlk = FALSE;

                // Check to see that the adapter is bound to Appletalk.
                // ----------------------------------------------------
                if (!FHrOK(CATLKEnv::IsAdapterBoundToAtlk((LPWSTR) (LPCWSTR) stKey, &bBoundToAtlk)))
                    continue;

                // If it's not bound to Appletalk, we're not interested
                // in the adapter.
                // ----------------------------------------------------
                if (!bBoundToAtlk)
                    continue;
                
                // Need to check to see if this is a valid
                // netcard.  We may have a GUID, but it may not
                // be working.
                // ----------------------------------------------------
                if (!FIsFunctioningNetcard(stKey))
                    continue;
                    
                if (!FHrOK(m_spRouterInfo->FindInterface(stKey, &spIf)))
                {
                    // We didn't find the IInterfaceInfo, we will
                    // have to create one ourselves.
                    // ------------------------------------------------
                    CreateInterfaceInfo(&spIf,
                                        stKey,
                                        ROUTER_IF_TYPE_DEDICATED);

                    if (FHrOK(InterfaceInfo::FindInterfaceTitle(NULL,
                                        stKey,
                                        &spszTitle)))
                        spIf->SetTitle(spszTitle);
                    else
                        spIf->SetTitle(spIf->GetId());
                }
                AddInterfaceNode(pThisNode, spIf, NULL, &spNewNode);
                
                {
                    CWaitCursor wait;
                    hr = atlkEnv.ReloadAdapter(pAI, false);
                }

                SetAdapterData(spNewNode, pAI, dwEnableAtlkRouting);
                
                // Redraw the node
                spNewNode->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);
            }
        }
        
    }
    COM_PROTECT_CATCH;

    return hr;
}


/*!--------------------------------------------------------------------------
    ATLKNodeHandler::OnResultShow
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKNodeHandler::OnResultShow(ITFSComponent *pTFSComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    BOOL    bSelect = (BOOL) arg;
    HRESULT hr = hrOK;
    SPIRouterRefresh    spRefresh;
    SPITFSNode  spNode;

    BaseContainerHandler::OnResultShow(pTFSComponent, cookie, arg, lParam);

/* WeiJiang : only do reload data on Expand and Refresh
    if ( bSelect )
    {
        // Call synchronize on this node
        m_spNodeMgr->FindNode(cookie, &spNode);
        if ( spNode )
            SynchronizeNodeData(spNode);
    }
*/

    // Un/Register for refresh advises
    if ( m_spRouterInfo )
        m_spRouterInfo->GetRefreshObject(&spRefresh);

    if ( spRefresh )
    {
        if ( bSelect )
        {
            if ( m_ulRefreshConnId == 0 )
                spRefresh->AdviseRefresh(&m_IRtrAdviseSink, &m_ulRefreshConnId, 0);
            if ( m_ulStatsConnId == 0 )
                spRefresh->AdviseRefresh(&m_IRtrAdviseSink, &m_ulStatsConnId, 0);
        }
        else
        {
            if ( m_ulRefreshConnId )
                spRefresh->UnadviseRefresh(m_ulRefreshConnId);
            m_ulRefreshConnId = 0;
        }
    }

    return hr;
}


/*!--------------------------------------------------------------------------
    ATLKNodeHandler::CompareItems
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int) ATLKNodeHandler::CompareItems(
                                                ITFSComponent * pComponent,
                                                MMC_COOKIE cookieA,
                                                MMC_COOKIE cookieB,
                                                int nCol)
{
    // Get the strings from the nodes and use that as a basis for
    // comparison.
    SPITFSNode  spNode;
    SPITFSResultHandler spResult;

    m_spNodeMgr->FindNode(cookieA, &spNode);
    spNode->GetResultHandler(&spResult);
    return spResult->CompareItems(pComponent, cookieA, cookieB, nCol);
}


/*!--------------------------------------------------------------------------
	ATLKNodeHandler::FIsFunctioningNetcard
		Takes a GUID and checks to see if the netcard is functioning.

        By default, we return FALSE if any call in this fails.

        This code is modeled off of the netcfg code.
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL ATLKNodeHandler::FIsFunctioningNetcard(LPCTSTR pszGuid)
{
    CString         stMachine;
    CONFIGRET       cfgRet;
    SP_DEVINFO_DATA DevInfo;
    RegKey          rkNet;
    RegKey          rkNetcard;
    HRESULT         hr = hrOK;
    BOOL            fReturn = FALSE;
    CString         stPnpInstanceId;
    ULONG           ulProblem, ulStatus;
    DWORD           dwErr = ERROR_SUCCESS;

    Assert(IsLocalMachine(m_spRouterInfo->GetMachineName()));


    if (m_hDevInfo == INVALID_HANDLE_VALUE)
    {
        stMachine = m_spRouterInfo->GetMachineName();
        if (IsLocalMachine(stMachine))
            {
            m_hDevInfo = SetupDiCreateDeviceInfoList(
                (LPGUID) &GUID_DevClass_Net,
                NULL);
            }
        else
        {
            // Append on the "\\\\" if needed
			if (StrniCmp((LPCTSTR) stMachine, _T("\\\\"), 2) != 0)
			{
				stMachine = _T("\\\\");
				stMachine += m_spRouterInfo->GetMachineName();
            }
			
			m_hDevInfo = SetupDiCreateDeviceInfoListEx(
				(LPGUID) &GUID_DevClass_Net,
				NULL,
				(LPCTSTR) stMachine,
				0);
        }
    }

    Assert(m_hDevInfo != INVALID_HANDLE_VALUE);

    // If m_hDevInfo is still invalid, then return a
    // functioning device.
    // ----------------------------------------------------------------
    if (m_hDevInfo == INVALID_HANDLE_VALUE)
        return fReturn;

    // Get the PnpInstanceID
    // ----------------------------------------------------------------
    CWRg( rkNet.Open(HKEY_LOCAL_MACHINE, c_szNetworkCardsNT5Key, KEY_READ,
                     m_spRouterInfo->GetMachineName()) );

    CWRg( rkNetcard.Open(rkNet, pszGuid, KEY_READ) );

    dwErr = rkNetcard.QueryValue(c_szPnpInstanceID, stPnpInstanceId);

    // Windows NT Bug : 273284
    // This is a result of the new Bindings Engine
    // some of the registry keys were moved around
    // ----------------------------------------------------------------
    if (dwErr != ERROR_SUCCESS)
    {
        RegKey  rkConnection;
        
        // Need to open another key to get this info.
        CWRg( rkConnection.Open(rkNetcard, c_szRegKeyConnection, KEY_READ) );

        CWRg( rkConnection.QueryValue(c_szPnpInstanceID, stPnpInstanceId) );
    }

    // Now get the info for this device
    // ----------------------------------------------------------------
    ::ZeroMemory(&DevInfo, sizeof(DevInfo));
    DevInfo.cbSize = sizeof(DevInfo);

    if (!SetupDiOpenDeviceInfo(m_hDevInfo,
                               (LPCTSTR) stPnpInstanceId,
                               NULL,
                               0,
                               &DevInfo))
    {
        CWRg( GetLastError() );
    }
        

    cfgRet = CM_Get_DevNode_Status_Ex(&ulStatus, &ulProblem,
                                      DevInfo.DevInst, 0, NULL);;
    if (CR_SUCCESS == cfgRet)
    {
        // ulProblem is returned by calling CM_Get_DevNode_Status_Ex
        //
        // "Functioning" means the device is enabled and started
        // with no problem codes, or it is disabled and stopped with
        // no problem codes.

        fReturn = ( (ulProblem == 0) || (ulProblem == CM_PROB_DISABLED));
    }

Error:
    return fReturn;
}



/*!--------------------------------------------------------------------------
	ATLKNodeHandler::UnmarkAllNodes
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKNodeHandler::UnmarkAllNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum)
{
	SPITFSNode	spChildNode;
	InterfaceNodeData * pNodeData;
	
	pEnum->Reset();
	for ( ;pEnum->Next(1, &spChildNode, NULL) == hrOK; spChildNode.Release())
	{
		pNodeData = GET_INTERFACENODEDATA(spChildNode);
		Assert(pNodeData);
		
		pNodeData->dwMark = FALSE;			
	}
	return hrOK;
}

/*!--------------------------------------------------------------------------
	ATLKNodeHandler::RemoveAllUnmarkedNodes
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKNodeHandler::RemoveAllUnmarkedNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum)
{
	HRESULT 	hr = hrOK;
	SPITFSNode	spChildNode;
	InterfaceNodeData * pNodeData;
	
	pEnum->Reset();
	for ( ;pEnum->Next(1, &spChildNode, NULL) == hrOK; spChildNode.Release())
	{
		pNodeData = GET_INTERFACENODEDATA(spChildNode);
		Assert(pNodeData);
		
		if (pNodeData->dwMark == FALSE)
		{
			pNode->RemoveChild(spChildNode);
			spChildNode->Destroy();
		}
	}

	return hr;
}

/*!--------------------------------------------------------------------------
	ATLKNodeHandler::SetAdapterData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKNodeHandler::SetAdapterData(ITFSNode *pNode,
                                        CAdapterInfo *pAdapter,
                                        DWORD dwEnableAtlkRouting)
{
    InterfaceNodeData * pNodeData;
    
    pNodeData = GET_INTERFACENODEDATA(pNode);
    Assert(pNodeData);

    // if the adapter is the default
    UINT    ids = 0;
    INT     lRange, uRange;
    
    if(pAdapter->m_regInfo.m_fDefAdapter)
    {
        if (dwEnableAtlkRouting)
        {
            if (pAdapter->m_regInfo.m_dwSeedingNetwork)
                ids = IDS_ATLK_COL_STATUS_SEEDROUTING_DEF;
            else
                ids = IDS_ATLK_COL_STATUS_ROUTING_DEF;
        }
        else
            ids = IDS_ATLK_COL_STATUS_NONROUTING_DEF;
    }
    else
    {
        if (dwEnableAtlkRouting)
        {
            if (pAdapter->m_regInfo.m_dwSeedingNetwork)
                ids = IDS_ATLK_COL_STATUS_SEEDROUTING;
            else
                ids = IDS_ATLK_COL_STATUS_ROUTING;
        }
        else
            ids = IDS_ATLK_COL_STATUS_NONROUTING;
    }
    
    
    // range column
    if (pAdapter->m_regInfo.m_dwSeedingNetwork)
    {
        lRange = pAdapter->m_regInfo.m_dwRangeLower;
        uRange = pAdapter->m_regInfo.m_dwRangeUpper;
    }
    else
    {
        lRange = pAdapter->m_dynInfo.m_dwRangeLower;
        uRange = pAdapter->m_dynInfo.m_dwRangeUpper;
    }
    
    // write data
    if(uRange == 0 && lRange == 0 && 
       !dwEnableAtlkRouting && 
       !pAdapter->m_regInfo.m_dwSeedingNetwork)
        ids = IDS_ATLK_COL_STATUS_NETWORKNOTSEEDED;
    
    pNodeData->m_rgData[ATLK_SI_STATUS].m_stData.LoadString(ids);
    pNodeData->m_rgData[ATLK_SI_STATUS].m_dwData = 0;
    
    if(uRange == 0 && lRange == 0)
        pNodeData->m_rgData[ATLK_SI_NETRANGE].m_stData.Format(_T("-")); 
    else
        pNodeData->m_rgData[ATLK_SI_NETRANGE].m_stData.Format(_T("%-d-%-d"), 
            lRange, uRange);
    pNodeData->m_rgData[ATLK_SI_NETRANGE].m_dwData = 0;
    

    return hrOK;
}




/*---------------------------------------------------------------------------
    Class: ATLKInterfaceHandler
 ---------------------------------------------------------------------------*/

ATLKInterfaceHandler::ATLKInterfaceHandler(ITFSComponentData *pCompData)
: BaseResultHandler(pCompData, ATLK_COLUMNS)
{
    m_rgButtonState[MMC_VERB_PROPERTIES_INDEX] = ENABLED;
    m_bState[MMC_VERB_PROPERTIES_INDEX] = TRUE;

    m_verbDefault = MMC_VERB_PROPERTIES;
}

static const DWORD s_rgInterfaceImageMap[] =
{
    ROUTER_IF_TYPE_HOME_ROUTER,    IMAGE_IDX_WAN_CARD,
    ROUTER_IF_TYPE_FULL_ROUTER,    IMAGE_IDX_WAN_CARD,
    ROUTER_IF_TYPE_CLIENT,         IMAGE_IDX_WAN_CARD,
    ROUTER_IF_TYPE_DEDICATED,      IMAGE_IDX_LAN_CARD,
    ROUTER_IF_TYPE_INTERNAL,       IMAGE_IDX_LAN_CARD,
    ROUTER_IF_TYPE_LOOPBACK,       IMAGE_IDX_LAN_CARD,
    -1,                            IMAGE_IDX_WAN_CARD, // sentinel value
};

/*!--------------------------------------------------------------------------
    ATLKInterfaceHandler::ConstructNode
        Initializes the Domain node (sets it up).
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKInterfaceHandler::ConstructNode(ITFSNode *pNode, IInterfaceInfo *pIfInfo)
{
    HRESULT         hr = hrOK;
    int             i;

    if ( pNode == NULL )
        return hrOK;

    COM_PROTECT_TRY
    {
        // Need to initialize the data for the Domain node

        // Find the right image index for this type of node
        for ( i=0; i<DimensionOf(s_rgInterfaceImageMap); i+=2 )
        {
            if ( (pIfInfo->GetInterfaceType() == s_rgInterfaceImageMap[i]) ||
                 (-1 == s_rgInterfaceImageMap[i]) )
                break;
        }

        if ( pIfInfo->GetInterfaceType() == ROUTER_IF_TYPE_INTERNAL ||
             pIfInfo->GetInterfaceType() == ROUTER_IF_TYPE_HOME_ROUTER )
        {
            m_rgButtonState[MMC_VERB_PROPERTIES_INDEX] = HIDDEN;
            m_bState[MMC_VERB_PROPERTIES_INDEX] = FALSE;

            m_rgButtonState[MMC_VERB_DELETE_INDEX] = HIDDEN;
            m_bState[MMC_VERB_DELETE_INDEX] = FALSE;
        }

        pNode->SetData(TFS_DATA_IMAGEINDEX, s_rgInterfaceImageMap[i+1]);
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, s_rgInterfaceImageMap[i+1]);

        pNode->SetData(TFS_DATA_SCOPEID, 0);

        pNode->SetData(TFS_DATA_COOKIE, reinterpret_cast<ULONG_PTR>(pNode));

        //$ Review: kennt, what are the different type of interfaces
        // do we distinguish based on the same list as above? (i.e. the
        // one for image indexes).
        pNode->SetNodeType(&GUID_ATLKInterfaceNodeType);

//    m_ATLKInterfaceStats.SetConnectionData(pIPConn);

        InterfaceNodeData::Init(pNode, pIfInfo);
    }
    COM_PROTECT_CATCH
    return hr;
}

/*!--------------------------------------------------------------------------
    ATLKInterfaceHandler::OnCreateDataObject
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP ATLKInterfaceHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
        CORg( CreateDataObjectFromInterfaceInfo(m_spInterfaceInfo,
                                                type, cookie, m_spTFSCompData,
                                                ppDataObject) );

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    ATLKInterfaceHandler::OnCreateDataObject
        Implementation of ITFSResultHandler::OnCreateDataObject
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP ATLKInterfaceHandler::OnCreateDataObject(ITFSComponent *pComp, MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
        CORg( CreateDataObjectFromInterfaceInfo(m_spInterfaceInfo,
                                                type, cookie, m_spTFSCompData,
                                                ppDataObject) );

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}



/*!--------------------------------------------------------------------------
    ATLKInterfaceHandler::RefreshInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void ATLKInterfaceHandler::RefreshInterface(MMC_COOKIE cookie)
{
    SPITFSNode  spNode;
    SPITFSNode  spParent;
    SPITFSNodeHandler   spHandler;

    m_spNodeMgr->FindNode(cookie, &spNode);

    // Can't do it for a single node at this time, just refresh the
    // whole thing.
    spNode->GetParent(&spParent);
    spParent->GetHandler(&spHandler);

    spHandler->OnCommand(spParent,
                         IDS_MENU_REFRESH,
                         CCT_RESULT, NULL, 0);
}


/*!--------------------------------------------------------------------------
    ATLKInterfaceHandler::Init
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKInterfaceHandler::Init(IInterfaceInfo *pIfInfo, ITFSNode *pParent, ATLKConfigStream *pConfigStream)
{
    Assert(pIfInfo);

    m_spInterfaceInfo.Set(pIfInfo);

// m_ATLKInterfaceStats.SetConfigInfo(pConfigStream, ATLKSTRM_IFSTATS_ATLKNBR);

    BaseResultHandler::Init(pIfInfo, pParent);

    return hrOK;
}


/*!--------------------------------------------------------------------------
    ATLKInterfaceHandler::DestroyResultHandler
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP ATLKInterfaceHandler::DestroyResultHandler(MMC_COOKIE cookie)
{
// WaitForStatisticsWindow(&m_ATLKInterfaceStats);

    m_spInterfaceInfo.Release();
    BaseResultHandler::DestroyResultHandler(cookie);
    return hrOK;
}


/*---------------------------------------------------------------------------
    This is the list of commands that will show up for the result pane
    nodes.
 ---------------------------------------------------------------------------*/
struct SIPInterfaceNodeMenu
{
    ULONG   m_sidMenu;          // string/command id for this menu item
    ULONG   (ATLKInterfaceHandler:: *m_pfnGetMenuFlags)(ATLKInterfaceHandler::SMenuData *);
    ULONG   m_ulPosition;
};

/*!--------------------------------------------------------------------------
    ATLKInterfaceHandler::AddMenuItems
        Implementation of ITFSResultHandler::AddMenuItems
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP ATLKInterfaceHandler::AddMenuItems(
                                               ITFSComponent *pComponent,
                                               MMC_COOKIE cookie,
                                               LPDATAOBJECT lpDataObject, 
                                               LPCONTEXTMENUCALLBACK pContextMenuCallback, 
                                               long *pInsertionAllowed)
{
    return hrOK;
}

/*!--------------------------------------------------------------------------
    ATLKInterfaceHandler::Command
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP ATLKInterfaceHandler::Command(ITFSComponent *pComponent,
                                           MMC_COOKIE cookie,
                                           int nCommandID,
                                           LPDATAOBJECT pDataObject)
{
    return hrOK;
}

/*!--------------------------------------------------------------------------
    ATLKInterfaceHandler::HasPropertyPages
        - 
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP ATLKInterfaceHandler::HasPropertyPages 
(
ITFSNode *          pNode,
LPDATAOBJECT        pDataObject, 
DATA_OBJECT_TYPES   type, 
DWORD               dwType
)
{
    return hrTrue;
}

/*!--------------------------------------------------------------------------
    ATLKInterfaceHandler::CreatePropertyPages
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP ATLKInterfaceHandler::CreatePropertyPages
(
ITFSNode *              pNode,
LPPROPERTYSHEETCALLBACK lpProvider,
LPDATAOBJECT            pDataObject, 
LONG_PTR                    handle, 
DWORD                   dwType)
{
    HRESULT     hr = hrOK;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CATLKPropertySheet *    pProperties = NULL;
    SPIComponentData spComponentData;
    CString     stTitle;
    SPIRouterInfo   spRouter;
    SPIRtrMgrInfo   spRm;

    CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

    stTitle.Format(IDS_ATLK_PROPPAGE_TITLE,
                   m_spInterfaceInfo->GetTitle());

    pProperties = new CATLKPropertySheet (pNode, spComponentData,
                                          m_spTFSCompData, stTitle);

// CORg( m_spInterfaceInfo->GetParentRouterInfo(&spRouter) );
// CORg( spRouter->FindRtrMgr(PID_IP, &spRm) );

    CORg( pProperties->Init(m_spInterfaceInfo) );

    if ( lpProvider )
        hr = pProperties->CreateModelessSheet(lpProvider, handle);
    else
        hr = pProperties->DoModelessSheet();

    Error:
    // Is this the right way to destroy the sheet?
    if ( !FHrSucceeded(hr) )
        delete pProperties;

    return hr;
}

/*!--------------------------------------------------------------------------
    ATLKInterfaceHandler::CreatePropertyPages
        Implementation of ResultHandler::CreatePropertyPages
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP ATLKInterfaceHandler::CreatePropertyPages
(
ITFSComponent *         pComponent, 
MMC_COOKIE                    cookie,
LPPROPERTYSHEETCALLBACK lpProvider, 
LPDATAOBJECT            pDataObject, 
LONG_PTR                    handle
)
{
    // Forward this call onto the NodeHandler::CreatePropertyPages
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = hrOK;
    SPITFSNode  spNode;

    Assert( m_spNodeMgr );

    CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

    // Call the ITFSNodeHandler::CreatePropertyPages
    hr = CreatePropertyPages(spNode, lpProvider, pDataObject, handle, 0);

    Error:
    return hr;
}



/*!--------------------------------------------------------------------------
    ATLKInterfaceHandler::OnResultDelete
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKInterfaceHandler::OnResultDelete(ITFSComponent *pComponent,
                                             LPDATAOBJECT pDataObject,
                                             MMC_COOKIE cookie,
                                             LPARAM arg,
                                             LPARAM param)
{
    SPITFSNode  spNode;
    m_spNodeMgr->FindNode(cookie, &spNode);
    return OnRemoveInterface(spNode);
}


/*!--------------------------------------------------------------------------
    ATLKInterfaceHandler::OnRemoveInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ATLKInterfaceHandler::OnRemoveInterface(ITFSNode *pNode)
{

    return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\atlkview.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    srview.h
//
// History:
// 09/05/97 Kenn M. Takara       Created.
//
//
//============================================================================


#ifndef _ATLKVIEW_H
#define _ATLKVIEW_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _XSTREAM_H
#include "xstream.h"    // need for ColumnData
#endif

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _IFACE_H
#include "iface.h"
#endif

#ifndef _BASECON_H
#include "basecon.h"    // BaseContainerHandler
#endif

#ifndef _ATLKSTRM_H
#include "ATLKstrm.h"
#endif

#ifndef _RTRSHEET_H
#include "rtrsheet.h"
#endif


// forward declarations
struct SATLKNodeMenu;
class CAdapterInfo;


//
// If you ADD any columns to this enum, Be sure to update
// the string ids for the column headers in srview.cpp
//
enum
{
   ATLK_SI_ADAPTER = 0,
   ATLK_SI_STATUS,
   ATLK_SI_NETRANGE,
   ATLK_SI_MAX_COLUMNS,
};


/*---------------------------------------------------------------------------
   We store a pointer to the IPConnection object in our node data
 ---------------------------------------------------------------------------*/
//
//#define GET_ATLK_NODEDATA(pNode) \
//    (IPConnection *) pNode->GetData(TFS_DATA_USER)
//#define SET_ATLK_NODEDATA(pNode, pData) \
//    pNode->SetData(TFS_DATA_USER, (ULONG) pData)


/*---------------------------------------------------------------------------
   Struct:  ATLKListEntry

   This is an intermediate data structure.
 ---------------------------------------------------------------------------*/
struct ATLKListEntry
{
   SPIInterfaceInfo m_spIf;
};

typedef CList<ATLKListEntry *, ATLKListEntry *> ATLKList;


/*---------------------------------------------------------------------------
   Class:   ATLKNodeHandler
 ---------------------------------------------------------------------------*/

class ATLKNodeHandler :
      public BaseContainerHandler
{
public:
   ATLKNodeHandler(ITFSComponentData *pTFSCompData);
   ~ATLKNodeHandler();

   // Override QI to handle embedded interface
   STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);
   
   DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)

   // base handler functionality we override
   OVERRIDE_NodeHandler_HasPropertyPages();
   OVERRIDE_NodeHandler_CreatePropertyPages();
   OVERRIDE_NodeHandler_GetString();
   OVERRIDE_NodeHandler_OnCreateDataObject();
   OVERRIDE_NodeHandler_OnAddMenuItems();
   OVERRIDE_NodeHandler_OnCommand();
   OVERRIDE_NodeHandler_DestroyHandler();

   OVERRIDE_BaseHandlerNotify_OnExpand();
   OVERRIDE_BaseHandlerNotify_OnVerbRefresh();
	OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();

   OVERRIDE_ResultHandler_AddMenuItems();
   OVERRIDE_ResultHandler_Command();
   OVERRIDE_ResultHandler_CompareItems();

   OVERRIDE_BaseResultHandlerNotify_OnResultShow();   
   
   // Initializes the handler
   HRESULT  Init(IRouterInfo *pRouter, ATLKConfigStream *pConfigStream);
   
   // Initializes the node
   HRESULT ConstructNode(ITFSNode *pNode);

public:
    // Structure used to pass data to callbacks - used as a way of
    // avoiding recomputation
    struct SMenuData
    {
        SPITFSNode        m_spNode;
    };

    static ULONG ATLKEnableFlags(const SRouterNodeMenu *pMenuData,
                                 INT_PTR pUserData);
   
protected:
   // Refresh the data for these nodes
   HRESULT  SynchronizeNodeData(ITFSNode *pThisNode);
   HRESULT	UnmarkAllNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum);
   HRESULT	RemoveAllUnmarkedNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum);

   HRESULT  SetAdapterData(ITFSNode *pNode,
                           CAdapterInfo *pAdapter,
                           DWORD dwEnableAtlkRouting);


   // Helper function to add interfaces to the UI
   HRESULT  AddInterfaceNode(ITFSNode *pParent, IInterfaceInfo *pIf,
                      IInfoBase *pInfoBase, ITFSNode **ppNewNode);

   // Functions to help determine if a netcard is ok
   BOOL     FIsFunctioningNetcard(LPCTSTR pszId);

   // Command implementations
   HRESULT  OnNewInterface();
   
   LONG_PTR		m_ulConnId;// notification id for RtrMgrProt
   LONG_PTR		m_ulRefreshConnId;   // notification id for Refresh
   LONG_PTR		m_ulStatsConnId;
   MMC_COOKIE        m_cookie;      // cookie for the node
   SPIRtrMgrInfo  m_spRm;
   SPIRtrMgrProtocolInfo   m_spRmProt;
   ATLKConfigStream *   m_pConfigStream;
   CString        m_stTitle;
   BOOL        m_fProtocolIsRunning;   // TRUE if protocol is running

   // Members used by netcard detection routines
   HDEVINFO     m_hDevInfo;
   
   // strings used in interface column descriptions
   CString        m_szProxy;
   CString        m_szRouterQuerier;
   CString        m_szRouterSilent;

// ATLKGroupStatistics  m_ATLKGroupStats;
};



/*---------------------------------------------------------------------------
   Class:   ATLKInterfaceHandler

   This is the handler for the interface nodes that appear in the ATLK
   node.
 ---------------------------------------------------------------------------*/

class ATLKInterfaceHandler : public BaseResultHandler
{
public:
   ATLKInterfaceHandler(ITFSComponentData *pCompData);
   
   OVERRIDE_NodeHandler_HasPropertyPages();
   OVERRIDE_NodeHandler_CreatePropertyPages();
   OVERRIDE_NodeHandler_OnCreateDataObject();
   
   OVERRIDE_ResultHandler_AddMenuItems();
   OVERRIDE_ResultHandler_Command();
   OVERRIDE_ResultHandler_OnCreateDataObject();
   OVERRIDE_ResultHandler_DestroyResultHandler();
   OVERRIDE_ResultHandler_HasPropertyPages()
         {  return hrOK;   };
   OVERRIDE_ResultHandler_CreatePropertyPages();

   OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
   
   // Initializes the node
   HRESULT ConstructNode(ITFSNode *pNode, IInterfaceInfo *pIfInfo);
   HRESULT  Init(IInterfaceInfo *pInfo, ITFSNode *pParent, ATLKConfigStream *pConfigStream);

   HRESULT OnRemoveInterface(ITFSNode *pNode);

   // Refresh the data for this node
   void RefreshInterface(MMC_COOKIE cookie);

public:
   // Structure used to pass data to callbacks - used as a way of
   // avoiding recomputation
   struct SMenuData
   {
      ULONG          m_ulMenuId;
      SPITFSNode        m_spNode;
   };



protected:
   SPIInterfaceInfo  m_spInterfaceInfo;

// ATLKInterfaceStatistics m_ATLKInterfaceStats;
};


bool IfATLKRoutingEnabled();


#endif _ATLKVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\cncting.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cncting.cpp
//
//--------------------------------------------------------------------------

// cncting.cpp : implementation file
//

#include "stdafx.h"
#include "cncting.h"
#include "rtrutilp.h"
#include "rtrstr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Windows NT Bugs : 82409
// Something is sending a WM_USER message through when we click on the
// edit control.  To avoid that conflict, renumber the request complete
// message.
#define WM_RTR_REQUEST_COMPLETED		(WM_USER+0x0100)

/////////////////////////////////////////////////////////////////////////////
// CConnectRequest

UINT ConnectThread(LPVOID pParam)
{
	CConnectData *pData = (CConnectData*)pParam;

    pData->m_pfnConnect(pData);
	
	if (!::IsWindow(pData->m_hwndMsg))
	{
		delete pData;
	}
	else
	{
		::PostMessage(pData->m_hwndMsg, WM_RTR_REQUEST_COMPLETED, (WPARAM)pData, NULL);
	}

	return 0;
}

void ConnectToMachine(CConnectData* pParam)
{
    pParam->m_dwr = ValidateUserPermissions(pParam->m_sName,
                                            &pParam->m_routerVersion,
                                            &pParam->m_hkMachine);

}

void ConnectToDomain(CConnectData* pParam)
{
	DWORD dwTotal;
	PWSTR pszDomain;

	ASSERT(!pParam->m_sName.IsEmpty());
	// Although the API excepts TCHAR it is exclusively UNICODE
	pszDomain = new WCHAR[pParam->m_sName.GetLength() + 1];
	wcscpy(pszDomain, pParam->m_sName);

	pParam->m_pSvInfo100 = NULL;
	pParam->m_dwr = (DWORD)::NetServerEnum(NULL, 100, 
	  (LPBYTE*)&pParam->m_pSvInfo100, 0xffffffff,
    &pParam->m_dwSvInfoRead, &dwTotal, SV_TYPE_DIALIN_SERVER,
	  (PTSTR)pszDomain, NULL);
	delete [] pszDomain;
}

/////////////////////////////////////////////////////////////////////////////
// CConnectingDlg dialog

CConnectingDlg::CConnectingDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CConnectingDlg::IDD, pParent)
{
	m_bRouter = TRUE;
	//{{AFX_DATA_INIT(CConnectingDlg)
	m_sName = _T("");
	//}}AFX_DATA_INIT
}

void CConnectingDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConnectingDlg)
	DDX_Text(pDX, IDC_EDIT_MACHINENAME, m_sName);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CConnectingDlg, CDialog)
	//{{AFX_MSG_MAP(CConnectingDlg)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_RTR_REQUEST_COMPLETED, OnRequestComplete)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConnectingDlg message handlers

BOOL CConnectingDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	CConnectData *pData = new CConnectData;
	pData->m_sName = m_sName;
	pData->m_hwndMsg = m_hWnd;

	if (m_bRouter)
	{
		pData->m_pfnConnect = ConnectToMachine;
	}
	else
	{
		pData->m_pfnConnect = ConnectToDomain;
	}

	m_pThread = AfxBeginThread((AFX_THREADPROC)ConnectThread, (LPVOID)pData);
	if (!m_pThread) EndDialog(IDCANCEL);
	
	return TRUE;
}

LRESULT CConnectingDlg::OnRequestComplete(WPARAM wParam, LPARAM lParam)
{
	CConnectData *pData = (CConnectData*)wParam;
    if (!pData) { EndDialog(IDCANCEL); return 0; }

	m_dwr = pData->m_dwr;
	if (m_dwr != ERROR_SUCCESS)
	{
		EndDialog(m_dwr);
		delete pData;
		return 0L;
	}

	if (m_bRouter)
		m_hkMachine = pData->m_hkMachine;
	else
	{
		m_pSvInfo100 = pData->m_pSvInfo100;
		m_dwSvInfoRead = pData->m_dwSvInfoRead;
	}
	delete pData;
	
	EndDialog(IDOK);
	return 0L;
}

BOOL CConnectingDlg::Connect()
{
	CConnectData Data;
	Data.m_sName = m_sName;
	Data.m_hwndMsg = m_hWnd;

	if (m_bRouter)
	{
		Data.m_pfnConnect = ConnectToMachine;
	}
	else
	{
		Data.m_pfnConnect = ConnectToDomain;
	}

	CWaitCursor wc;

	Data.m_pfnConnect(&Data);
	
	// setup all of the data from the connection
	m_dwr = Data.m_dwr;
	if (m_dwr != ERROR_SUCCESS)
	{
		return FALSE;
	}

	if (m_bRouter)
		m_hkMachine = Data.m_hkMachine;
	else
	{
		m_pSvInfo100 = Data.m_pSvInfo100;
		m_dwSvInfoRead = Data.m_dwSvInfoRead;
	}

	return TRUE;
}




/*!--------------------------------------------------------------------------
	ValidateUserPermissions
		Check to see if we can access the places we need to access

        Returns HRESULT_OK if the user has the proper access.
        Returns E_ACCESSDENIED if the user does not have proper access.

        Returns error otherwise.
        
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD ValidateUserPermissions(LPCTSTR pszServer,
                              RouterVersionInfo *pVersion,
                              HKEY *phkeyMachine)
{
	HKEY	hkMachine = NULL;
	RegKey	regkey;
    RouterVersionInfo   routerVersion;
    HRESULT hr = hrOK;
    DWORD   dwErr = ERROR_SUCCESS;

	dwErr = ValidateMachine(pszServer);
	if (dwErr != ERROR_SUCCESS)
		goto Error;

	// connect to the machine's registry
	dwErr = ConnectRegistry((LPTSTR) pszServer,
                                    &hkMachine);
	if(dwErr != ERROR_SUCCESS)
		goto Error;

    // There are three cases to consider here:
    // (1) NT4 RAS server (no router keys)
    // (2) NT4 RRAS (NT4+Steelhead)
    // (3) NT5
    // ----------------------------------------------------------------

    
    // Get the version information
    // ----------------------------------------------------------------
    hr = QueryRouterVersionInfo(hkMachine, &routerVersion);
    if (!FHrOK(hr))
    {
        dwErr = (hr & 0x0000FFFF);
        goto Error;
    }

    // Copy the version info over.
    // ----------------------------------------------------------------
    if (pVersion)
        *pVersion = routerVersion;
    else
        pVersion = &routerVersion;

    // This test is intended for the RAS server case.
    // ----------------------------------------------------------------
    if (routerVersion.dwOsMajorVersion <= 4)
    {
        // If we can't find the router key, we can skip the rest of the
        // tests.  We do assume that everything succeeded however.
        // ----------------------------------------------------------------
        dwErr = regkey.Open(hkMachine, c_szRegKeyRouter, KEY_READ);
        if (dwErr == ERROR_FILE_NOT_FOUND)
        {
            // Could not find the router key, however this may
            // be a NT4 RAS server (no Steelhead), so return success
            // --------------------------------------------------------
            goto Done;
        }
        else if (dwErr != ERROR_SUCCESS)
            goto Error;

        // If we could find the router key, then we can continue with
        // the other registry tests.
        // ------------------------------------------------------------
        regkey.Close();
    }

    
    // open HKLM\Software\Microsoft\Router\CurrentVersion\RouterManagers
	// ----------------------------------------------------------------
	dwErr = regkey.Open(hkMachine, c_szRouterManagersKey, KEY_ALL_ACCESS);
	if(dwErr != ERROR_SUCCESS)
		goto Error;
	regkey.Close();

	// open c_szSystemCCSServices HKLM\System\\CurrentControlSet\\Services
	// ----------------------------------------------------------------
	{
		RegKey	regFolder;

		dwErr = regFolder.Open(hkMachine, c_szSystemCCSServices, KEY_READ);
		if(dwErr != ERROR_SUCCESS)
			goto Error;

		// sub keys under Services -- remoteAccess, RW
		dwErr = regkey.Open(regFolder, c_szRemoteAccess, KEY_ALL_ACCESS);
		if(dwErr != ERROR_SUCCESS)
			goto Error;
		regkey.Close();

		// sub keys under Services -- rasman, RW
		dwErr = regkey.Open(regFolder, c_szSvcRasMan, KEY_ALL_ACCESS);
		if(dwErr != ERROR_SUCCESS)
			goto Error;
		regkey.Close();

		// sub keys under Services -- TcpIp, RW
		dwErr = regkey.Open(regFolder, c_szTcpip, KEY_ALL_ACCESS);
		if(dwErr != ERROR_SUCCESS)
			goto Error;
		regkey.Close();
        
		regFolder.Close();
	}
	
Done:
    if (phkeyMachine)
    {
        *phkeyMachine = hkMachine;
        hkMachine = NULL;
    }

Error:
	if(hkMachine != NULL)
		DisconnectRegistry( hkMachine );

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\cncting.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cncting.h
//
//--------------------------------------------------------------------------

// cncting.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CConnectData

struct CConnectData;

typedef void (*PCONNECTFUNC)(CConnectData *pData);

struct CConnectData
{
	PCONNECTFUNC m_pfnConnect;
	HWND m_hwndMsg;
	DWORD m_dwr;
	CString m_sName;
    RouterVersionInfo   m_routerVersion;
	union
	{
		HKEY m_hkMachine;
		PSERVER_INFO_100 m_pSvInfo100;
	};
	DWORD m_dwSvInfoRead;
};

void ConnectToMachine(CConnectData* pParam);
void ConnectToDomain(CConnectData* pParam);
DWORD ValidateUserPermissions(LPCTSTR pszServer,
                              RouterVersionInfo *pVersion,
                              HKEY *phkeyMachine);

/////////////////////////////////////////////////////////////////////////////
// CConnectingDlg dialog

class CConnectingDlg : public CDialog
{
// Construction
public:
	CConnectingDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	PCONNECTFUNC m_pfnConnect;
	union
	{
		HKEY m_hkMachine;
		PSERVER_INFO_100 m_pSvInfo100;
	};
	DWORD m_dwSvInfoRead;
	BOOL m_bRouter;
	DWORD m_dwr;
	//{{AFX_DATA(CConnectingDlg)
	enum { IDD = IDD_CONNECTREG };
	CString	m_sName;
	//}}AFX_DATA

	BOOL Connect();  // for connecting w/ no UI

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConnectingDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CWinThread *m_pThread;

	// Generated message map functions
	//{{AFX_MSG(CConnectingDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	LRESULT OnRequestComplete(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\cnctdlg.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    CnctDlg.h
//
// History:
//  05/24/96    Michael Clark      Created.
//
// Implements the Router Connection dialog
// Implements the Router Connect As dialog
//============================================================================
//

#ifndef _DIALOG_H
#include "dialog.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// CConnectAs dialog

class CConnectAsDlg : public CBaseDialog
{
// Construction
public:
	CConnectAsDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CConnectDlg)
	enum { IDD = IDD_CONNECT_AS };
	CString	m_sUserName;
	CString m_sPassword;
	CString	m_stTempPassword;
	CString m_sRouterName;
	//}}AFX_DATA

	UCHAR	m_ucSeed;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConnectAsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	static DWORD	m_dwHelpMap[];
	
	// Generated message map functions
	//{{AFX_MSG(CConnectAsDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
    BOOL    OnInitDialog();
};

// This is used as the seed value for the RtlRunEncodeUnicodeString
// and RtlRunDecodeUnicodeString functions.
#define CONNECTAS_ENCRYPT_SEED		(0xB7)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\cnctdlg.cpp ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    CnctDlg.cpp
//
// History:
//  05/24/96    Michael Clark      Created.
//
// Implements the Router Connection dialog
//============================================================================
//

#include "stdafx.h"
#include "CnctDlg.h"
#include "lsa.h"			// RtlEncodeW/RtlDecodeW

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// CConnectAsDlg dialog
//
/////////////////////////////////////////////////////////////////////////////


CConnectAsDlg::CConnectAsDlg(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CConnectAsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CConnectAsDlg)
	m_sUserName = _T("");
	m_sPassword = _T("");
	m_stTempPassword = m_sPassword;
    m_sRouterName= _T("");
	//}}AFX_DATA_INIT

//	SetHelpMap(m_dwHelpMap);
}


void CConnectAsDlg::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConnectAsDlg)
	DDX_Text(pDX, IDC_EDIT_USERNAME, m_sUserName);
	DDX_Text(pDX, IDC_EDIT_USER_PASSWORD, m_stTempPassword);
	//}}AFX_DATA_MAP

	if (pDX->m_bSaveAndValidate)
	{
		// Copy the data into the new buffer
		// ------------------------------------------------------------
		m_sPassword = m_stTempPassword;

		// Clear out the temp password, by copying 0's
		// into its buffer
		// ------------------------------------------------------------
		int		cPassword = m_stTempPassword.GetLength();
		::SecureZeroMemory(m_stTempPassword.GetBuffer(0),
					 cPassword * sizeof(TCHAR));
		m_stTempPassword.ReleaseBuffer();
		
		// Encode the password into the real password buffer
		// ------------------------------------------------------------
		m_ucSeed = CONNECTAS_ENCRYPT_SEED;
		RtlEncodeW(&m_ucSeed, m_sPassword.GetBuffer(0));
		m_sPassword.ReleaseBuffer();
	}
}

BEGIN_MESSAGE_MAP(CConnectAsDlg, CBaseDialog)
	//{{AFX_MSG_MAP(CConnectAsDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

DWORD	CConnectAsDlg::m_dwHelpMap[] =
{
//	IDC_USER_NAME, HIDC_USER_NAME,
//	IDC_USER, HIDC_USER,
//	IDC_USER_PASSWORD, HIDC_USER_PASSWORD,
//	IDC_PASSWORD, HIDC_PASSWORD,
//	IDC_INACCESSIBLE_RESOURCE, HIDC_INACCESSIBLE_RESOURCE,
//	IDC_MACHINE_NAME, HIDC_MACHINE_NAME,
	0,0
};

BOOL CConnectAsDlg::OnInitDialog()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    BOOL    fReturn;
    CString st;  
    
    fReturn = CBaseDialog::OnInitDialog();

    st.Format(IDS_CONNECT_AS_TEXT, (LPCTSTR) m_sRouterName);
    SetDlgItemText(IDC_TEXT_INACCESSIBLE_RESOURCE, st);

    // Bring this window to the top
    BringWindowToTop();
    
    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\conndlg.cpp ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    conndlg.cpp
//
// History:
//  09/22/96    Abolade Gbadegesin  Created.
//
// Implementation of the connection-status dialog.
//============================================================================


#include "stdafx.h"
#include "dialog.h"
#include "rtrutilp.h"
//nclude "ddmadmin.h"
//nclude "ddmroot.h"
extern "C" {
//nclude "dim.h"
#include "ras.h"
}

#include "conndlg.h"
#include "rtrstr.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



//----------------------------------------------------------------------------
// Class:       CConnDlg
//
//----------------------------------------------------------------------------


//----------------------------------------------------------------------------
// Function:    CConnDlg::CConnDlg
//
// Constructor: initialize the base-class and the dialog's data.
//----------------------------------------------------------------------------

CConnDlg::CConnDlg(
	CString strMachineName,
    HANDLE          hConnection,
    ITFSNode*       pDialInNode,
    CWnd*           pParent
    ) : CBaseDialog(IDD_DDM_CONN, pParent)
{
    m_strMachineName = strMachineName;
    m_hConnection = hConnection;
//    m_spDialInNode = pDialInNode;

    m_bChanged = FALSE;
}


//----------------------------------------------------------------------------
// Function:    CConnDlg::DoDataExchange
//
// DDX handler.
//----------------------------------------------------------------------------

VOID
CConnDlg::DoDataExchange(
    CDataExchange*  pDX
    ) {

    CBaseDialog::DoDataExchange(pDX);

    DDX_Control(pDX, IDC_DC_COMBO_CONNLIST, m_cbConnections);
}



BEGIN_MESSAGE_MAP(CConnDlg, CBaseDialog)
    ON_COMMAND(IDC_DC_BTN_RESET, OnReset)
    ON_COMMAND(IDC_DC_BTN_HANGUP, OnHangUp)
    ON_COMMAND(IDC_DC_BTN_REFRESH, OnRefresh)
    ON_CBN_SELENDOK(IDC_DC_COMBO_CONNLIST, OnSelendokConnList)
END_MESSAGE_MAP()




BOOL
CConnDlg::OnInitDialog(
    ) {

    CBaseDialog::OnInitDialog();

    ::MprAdminServerConnect((LPWSTR)(LPCTSTR)m_strMachineName, &m_hServer);

    RefreshItem(m_hConnection);

    return FALSE;
}


void 
CConnDlg::OnCancel()
{
	//Extra clean up
	::MprAdminServerDisconnect(m_hServer);

	CDialog::OnCancel();
}

BOOL
CConnDlg::RefreshItem(
    HANDLE  hConnection,
    BOOL bDisconnected
    ) {

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    DWORD dwErr, dwTotal;
    DWORD rp0Count, rc0Count;
    BYTE* rp0Table, *rc0Table;
    BOOL  bChanged = FALSE;


    rp0Table = rc0Table = 0;
    rp0Count = 0;

    do {
    
        //
        // Retrieve an array of ports
        //
        /*--ft: actually this is never needed in this context    
        dwErr = ::MprAdminPortEnum(
                    m_hServer,
                    0,
                    INVALID_HANDLE_VALUE,
                    (BYTE**)&rp0Table,
                    (DWORD)-1,
                    &rp0Count,
                    &dwTotal,
                    NULL
                    );
    
        if (dwErr != NO_ERROR) { break; }
        */

        //
        // Retrieve an array of connections
        //

        dwErr = ::MprAdminConnectionEnum(
                    m_hServer,
                    0,
                    (BYTE**)&rc0Table,
                    (DWORD)-1,
                    &rc0Count,
                    &dwTotal,
                    NULL
                    );

        if (dwErr != NO_ERROR) { break; }

        // if the caller signals this connection to be terminated, we remove its record from the
        // array returned by MprAdminConnectionEnum().
        if (bDisconnected)
        {
            INT i;
            RAS_CONNECTION_0* prc0;

            for (i = 0, prc0 = (RAS_CONNECTION_0*)rc0Table; i < (INT)rc0Count; i++, prc0++)
            {
                // if the record to delete was found, just move the memory over it and update rc0Count.
                // the memory will still be freed by MprAdminBufferFree().
                if (prc0->hConnection == hConnection)
                {
                    if (i != (INT)(rc0Count - 1))
                    {
                        // MoveMemory(dest, src, size)
                        MoveMemory(prc0, prc0+1, (rc0Count - (i + 1))*sizeof(RAS_CONNECTION_0));
                    }
                    rc0Count--;
                    break;
                }
            }
        }


        //
        // Do the refresh of the display,
        // selecting the item specified by the caller.
        //

        bChanged = Refresh(rp0Table, rp0Count, rc0Table, rc0Count, hConnection);
        dwErr = NO_ERROR;

    } while (FALSE);


    if (rc0Table) { ::MprAdminBufferFree(rc0Table); }
    if (rp0Table) { ::MprAdminBufferFree(rp0Table); }


    if (dwErr != NO_ERROR) {

		TCHAR	szText[1024];

		FormatSystemError(HRESULT_FROM_WIN32(dwErr),
						  szText, DimensionOf(szText),
						  IDS_ERR_INITDLGERROR, FSEFLAG_ANYMESSAGE);
        AfxMessageBox(szText);

        EndDialog(IDCANCEL);
    }

    return bChanged;
}



VOID
CConnDlg::OnHangUp(
    ) {

    INT iSel;
    DWORD dwErr;
    HANDLE hConnection;
    RAS_CONNECTION_0* prc0;
	CWaitCursor		wait;

    iSel = m_cbConnections.GetCurSel();

    if (iSel == CB_ERR) { return; }


    //
    // Get the connection to be hung up
    //

    hConnection = (HANDLE)m_cbConnections.GetItemData(iSel);


    //
    // Retrieve the interface for this connection;
    // we then hang up the connection by disconnecting its interface
    //

    dwErr = ::MprAdminConnectionGetInfo(
                m_hServer,
                0,
                hConnection,
                (BYTE**)&prc0
                );

    if (dwErr == NO_ERROR && prc0) {

        //
        // Disconnect the connections interface
        //

        dwErr = ::MprAdminInterfaceDisconnect(
			m_hServer,
            prc0->hInterface
            );

        ::MprAdminBufferFree(prc0);

        m_bChanged |= RefreshItem(hConnection, dwErr == NO_ERROR);
    }
}



VOID
CConnDlg::OnReset(
    ) {

    INT iSel;
    HANDLE hConnection;

    iSel = m_cbConnections.GetCurSel();

    if (iSel == CB_ERR) { return; }

    hConnection = (HANDLE)m_cbConnections.GetItemData(iSel);

    ::MprAdminConnectionClearStats(
        m_hServer,
        hConnection
        );

    m_bChanged |= RefreshItem(INVALID_HANDLE_VALUE);
}



VOID
CConnDlg::OnSelendokConnList(
    ) {

    m_bChanged |= RefreshItem(INVALID_HANDLE_VALUE);
}


VOID
CConnDlg::OnRefresh(
    ) {

    m_bChanged |= RefreshItem(INVALID_HANDLE_VALUE);
}



BOOL
CConnDlg::Refresh(
    BYTE*   rp0Table,
    DWORD   rp0Count,
    BYTE*   rc0Table,
    DWORD   rc0Count,
    VOID*   pParam
    ) {

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    DWORD dwErr;
    CString sItem;
    RAS_PORT_0* prp0;
    RAS_PORT_1* prp1;
    RAS_CONNECTION_0* prc0;
    RAS_CONNECTION_1* prc1;
    INT i, j, iSel, count;
    HANDLE hConnection, hConnSel = NULL, *pConnTable;
	TCHAR	szNumber[32];
    BOOL    bChanged = FALSE;

    hConnSel = (HANDLE)pParam;


    //
    // Fill an array of connection-handles with the connections which are
    // already in the combobox.
    //

    count = m_cbConnections.GetCount();

    if (count) {

        pConnTable = new HANDLE[count];
    }

    for (i = 0; i < count; i++) {

        pConnTable[i] = (HANDLE)m_cbConnections.GetItemData(i);
    }



    //
    // Refresh the combobox with connection-names;
    // We do this in two passes, first adding the names of connections
    // which aren't already in the combobox,
    // and then removing the names of connections which aren't
    // in the table of connections ('rc0Table').
    //

    for (i = 0, prc0 = (RAS_CONNECTION_0*)rc0Table; i < (INT)rc0Count;
         i++, prc0++) {

        //
        // See if connection 'i' is already in the combobox.
        //

        for (j = 0; j < count; j++) {

            if (pConnTable[j] == prc0->hConnection) { break; }
        }

        if (j < count) { continue; }


        //
        // Connection 'i' isn't already in the combobox, so add it.
        //

        sItem.Format(TEXT("%ls"), prc0->wszInterfaceName);

        iSel = m_cbConnections.AddString(sItem);

        if (iSel >= 0) {

            m_cbConnections.SetItemData(iSel, reinterpret_cast<ULONG_PTR>(prc0->hConnection));

            if (prc0->hConnection == hConnSel) {

                m_cbConnections.SetCurSel(iSel);
            }

            bChanged = TRUE;
        }
    }

    if (count) { delete [] pConnTable; }


    //
    // Second stage: remove all connections which aren't in 'rc0Table'.
    // This is only necessary if there were any connections in the combobox
    // before.
    //

    if (count > 0) {

        count = m_cbConnections.GetCount();

        for (i = 0; i < count; i++) {

            hConnection = (HANDLE)m_cbConnections.GetItemData(i);

            //
            // See if the connection is in 'rc0Table'.
            //

            for (j = 0, prc0 = (RAS_CONNECTION_0*)rc0Table; j < (INT)rc0Count;
                 j++, prc0++) {

                if (prc0->hConnection == hConnection) { break; }
            }

            if (j < (INT)rc0Count) {

                if (prc0->hConnection == hConnSel) {

                    m_cbConnections.SetCurSel(i);
                }

                continue;
            }


            //
            // The connection wasn't found in 'rc0Table',
            // so remove it from the combobox,
            // and adjust the enumeration indices.
            //

            m_cbConnections.DeleteString(i);
            --i; --count;

            bChanged = TRUE;
        }
    }


	// Clear out the address fields
	SetDlgItemText(IDC_DC_TEXT_IPADDRESS, c_szEmpty);
	SetDlgItemText(IDC_DC_TEXT_IPXADDRESS, c_szEmpty);
	SetDlgItemText(IDC_DC_TEXT_NBFADDRESS, c_szEmpty);
	SetDlgItemText(IDC_DC_TEXT_ATLKADDRESS, c_szEmpty);

	// Clear out the line bps field
    SetDlgItemText(IDC_DC_TEXT_DURATION, c_szEmpty);
	SetDlgItemText(IDC_DC_TEXT_BYTESIN, c_szEmpty);	
	SetDlgItemText(IDC_DC_TEXT_BYTESOUT, c_szEmpty);
	SetDlgItemText(IDC_DC_TEXT_FRAMESIN, c_szEmpty);	
	SetDlgItemText(IDC_DC_TEXT_FRAMESOUT, c_szEmpty);
	SetDlgItemText(IDC_DC_TEXT_COMPIN, c_szEmpty);	
	SetDlgItemText(IDC_DC_TEXT_COMPOUT, c_szEmpty);
	SetDlgItemText(IDC_DC_TEXT_TIMEOUT, c_szEmpty);
	SetDlgItemText(IDC_DC_TEXT_ALIGNMENT, c_szEmpty);
	SetDlgItemText(IDC_DC_TEXT_FRAMING, c_szEmpty);
	SetDlgItemText(IDC_DC_TEXT_HWOVERRUN, c_szEmpty);
	SetDlgItemText(IDC_DC_TEXT_BUFOVERRUN, c_szEmpty);
	SetDlgItemText(IDC_DC_TEXT_CRC, c_szEmpty);
			
    //
    // If there is no selection select the first item
    //

    if ((iSel = m_cbConnections.GetCurSel()) == CB_ERR) {

        iSel = m_cbConnections.SetCurSel(0);
    }

    if (iSel == CB_ERR)
	{
		if (GetFocus() == GetDlgItem(IDC_DC_BTN_HANGUP))
			GetDlgItem(IDC_DC_BTN_RESET)->SetFocus();
		GetDlgItem(IDC_DC_BTN_HANGUP)->EnableWindow(FALSE);
		return bChanged;
	}


    //
    // Update the display with information for the selected item
    //

    hConnection = (HANDLE)m_cbConnections.GetItemData(iSel);

    for (i = 0, prc0 = (RAS_CONNECTION_0*)rc0Table; i < (INT)rc0Count;
         i++, prc0++) {

        if (prc0->hConnection == hConnection) { break; }
    }

    if (i >= (INT)rc0Count) { return bChanged; }


    //
    // First update the RAS_CONNECTION_0-based information
    //

    FormatDuration(prc0->dwConnectDuration, sItem, UNIT_SECONDS);
    SetDlgItemText(IDC_DC_TEXT_DURATION, sItem);


    do {
    
        //
        // Now retrieve the RAS_CONNECTION_1 information for this connection.
        //
    
        dwErr = ::MprAdminConnectionGetInfo(
                    m_hServer,
                    1,
                    prc0->hConnection,
                    (BYTE**)&prc1
                    );
    
        if (dwErr != NO_ERROR || !prc1) { break; }
    
    
        //
        // Set the information in the dialog text-controls
        //
    
        FormatNumber(prc1->dwBytesRcved, szNumber, DimensionOf(szNumber), FALSE);
        SetDlgItemText(IDC_DC_TEXT_BYTESIN, szNumber);
    
        FormatNumber(prc1->dwBytesXmited, szNumber, DimensionOf(szNumber), FALSE);
        SetDlgItemText(IDC_DC_TEXT_BYTESOUT, szNumber);

        FormatNumber(prc1->dwFramesRcved, szNumber, DimensionOf(szNumber), FALSE);
        SetDlgItemText(IDC_DC_TEXT_FRAMESIN, szNumber);
    
        FormatNumber(prc1->dwFramesXmited, szNumber, DimensionOf(szNumber), FALSE);
        SetDlgItemText(IDC_DC_TEXT_FRAMESOUT, szNumber);

        FormatNumber(prc1->dwCompressionRatioIn, szNumber, DimensionOf(szNumber), FALSE);
		sItem = szNumber;
        sItem += TEXT( "%" );
        SetDlgItemText(IDC_DC_TEXT_COMPIN, sItem);

        FormatNumber(prc1->dwCompressionRatioOut, szNumber, DimensionOf(szNumber), FALSE);
		sItem = szNumber;
        sItem += TEXT( "%" );
        SetDlgItemText(IDC_DC_TEXT_COMPOUT, sItem);
    
        FormatNumber(prc1->dwCrcErr, szNumber, DimensionOf(szNumber), FALSE);
        SetDlgItemText(IDC_DC_TEXT_CRC, szNumber);
    
        FormatNumber(prc1->dwTimeoutErr, szNumber, DimensionOf(szNumber), FALSE);
        SetDlgItemText(IDC_DC_TEXT_TIMEOUT, szNumber);
    
        FormatNumber(prc1->dwAlignmentErr, szNumber, DimensionOf(szNumber), FALSE);
        SetDlgItemText(IDC_DC_TEXT_ALIGNMENT, szNumber);
    
        FormatNumber(prc1->dwFramingErr, szNumber, DimensionOf(szNumber), FALSE);
        SetDlgItemText(IDC_DC_TEXT_FRAMING, szNumber);
    
        FormatNumber(prc1->dwHardwareOverrunErr, szNumber, DimensionOf(szNumber), FALSE);
        SetDlgItemText(IDC_DC_TEXT_HWOVERRUN, szNumber);
    
        FormatNumber(prc1->dwBufferOverrunErr, szNumber, DimensionOf(szNumber), FALSE);
        SetDlgItemText(IDC_DC_TEXT_BUFOVERRUN, szNumber);
    
    
        //
        // Fill in the network registration info for projected networks.
        //

        if (prc1->PppInfo.ip.dwError == NO_ERROR) {

            SetDlgItemTextW(IDC_DC_TEXT_IPADDRESS, prc1->PppInfo.ip.wszRemoteAddress);
        }

        if (prc1->PppInfo.ipx.dwError == NO_ERROR) {

            SetDlgItemTextW(IDC_DC_TEXT_IPXADDRESS, prc1->PppInfo.ipx.wszAddress);
        }

        if (prc1->PppInfo.nbf.dwError == NO_ERROR) {

            SetDlgItemTextW(IDC_DC_TEXT_NBFADDRESS, prc1->PppInfo.nbf.wszWksta);
        }

        if (prc1->PppInfo.at.dwError == NO_ERROR) {

            SetDlgItemTextW(IDC_DC_TEXT_ATLKADDRESS, prc1->PppInfo.at.wszAddress);
        }

        ::MprAdminBufferFree(prc1);

    } while (FALSE);

    if (dwErr != NO_ERROR) {

		TCHAR	szText[1024];

		FormatSystemError(HRESULT_FROM_WIN32(dwErr),
						  szText, DimensionOf(szText),
						  IDS_ERR_INITDLGERROR, FSEFLAG_ANYMESSAGE);
        AfxMessageBox(szText);

        EndDialog(IDCANCEL);
    }

    return bChanged;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\conndlg.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    conndlg.h
//
// History:
//  09/21/96    Abolade Gbadegesin  Created.
//
// Contains declarations for the connection-status dialog.
//============================================================================


#ifndef _CONNDLG_H_
#define _CONNDLG_H_


//----------------------------------------------------------------------------
// Class:   CConnDlg
//
// Controls the Port-status dialog for DDMADMIN.
//----------------------------------------------------------------------------

class CConnDlg : public CBaseDialog {

    public:

        CConnDlg(
			CString strMachineName,
            HANDLE              hConnection,  
            ITFSNode*           pDialInNode = NULL,
            CWnd*               pParent = NULL );

        virtual BOOL
        Refresh(
            BYTE*               rp0Table,
            DWORD               rp0Count,
            BYTE*               rc0Table,
            DWORD               rc0Count,
            VOID*               pParam  = NULL );

        CComboBox               m_cbConnections;
        BOOL                    m_bChanged;

    protected:
//		static DWORD			m_dwHelpMap[];

        virtual VOID
        DoDataExchange(
            CDataExchange*      pDX );

        virtual BOOL
        OnInitDialog( );

        void OnCancel();

        afx_msg VOID
        OnHangUp( );

        afx_msg VOID
        OnReset( );

        afx_msg VOID
        OnSelendokConnList( );

        afx_msg VOID
        OnRefresh( );

        BOOL
        RefreshItem(
            HANDLE              hConnection,
            BOOL                bDisconnected = FALSE
            );

		MPR_SERVER_HANDLE		m_hServer;
		CString m_strMachineName;
        HANDLE                  m_hConnection;
        SPITFSNode              m_spDialInNode;

        DECLARE_MESSAGE_MAP()
};


#endif // _CONNDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\cservice.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       C S E R V I C E . C P P
//
//  Contents:   Implementation of non-inline CService and CServiceManager
//              methods.
//
//  Notes:
//
//  Author:     mikemi      6 Mar 1997
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "cservice.h"

size_t CchMsz(const TCHAR * msz)
{
    TCHAR * pch= (TCHAR *) msz;

    while (*pch)
    {
        pch += lstrlen(pch)+1;
    }

    return (size_t) (pch-msz+1);
}

BOOL FIsSzInMultiSzSafe(LPCTSTR sz, LPCTSTR szMultiSz)
{
    ULONG   ulLen;

    if (!szMultiSz || !sz)
        return FALSE;

    while (*szMultiSz)
    {
        ulLen = lstrlen(szMultiSz);
        if (lstrcmpi(szMultiSz, sz)==0)
            return TRUE;
        szMultiSz += (ulLen + 1);
    }

    return FALSE;
}


HRESULT HrAddSzToMultiSz(LPCTSTR sz, 
                         LPCTSTR mszIn, 
                         LPTSTR * pmszOut)
{
    HRESULT hr = S_OK;
    Assert(pmszOut);
    
    if (!FIsSzInMultiSzSafe(sz, mszIn)) // We need to add the string
    {
        size_t cchMszIn = CchMsz(mszIn);
        size_t cchMszOut = cchMszIn + lstrlen(sz) + 1;

        TCHAR * mszOut = new TCHAR[(int)cchMszOut];
       
        ZeroMemory(mszOut,  cchMszOut  * sizeof(TCHAR));

        // Copy the existing string
        CopyMemory(mszOut, mszIn, (cchMszIn-1) * sizeof(TCHAR) );

        // Add the new string
        TCHAR * pchOut = mszOut;
        pchOut += cchMszIn -1;
        lstrcpy(pchOut, sz);

        // Add the last '\0' for the output multisz
        pchOut += lstrlen(sz) + 1;
        *pchOut = '\0';

        *pmszOut = mszOut;
    }
    else // We just make a copy of the input string
    {
        size_t cchMszOut = CchMsz(mszIn);
        TCHAR * mszOut = new TCHAR[(int)cchMszOut];
        
        // Copy the existing string
        CopyMemory(mszOut, mszIn, cchMszOut*sizeof(TCHAR) );
        *pmszOut = mszOut;
    }

    Trace1("HrAddSzToMultiSz %08lx", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveSzFromMultiSz
//
//  Purpose:    Remove a NULL terminated sz to a double NULL terminated Multi_Sz
//
//  Arguments:
//      sz [in]         The string to remove
//      mszIn [in]      The Multi_Sz to remove from
//      mszOut [out]    The result Multi_Sz
//
//  Returns:    Always return S_OK for now
//              Only possible failure is out of memory, which will throw exception
//
//  Author:     tongl   17 June 1997
//
//  Notes:  1) This function only removes the first occurrance of the sz
//          2) The result multi_sz should be released using delete  
//
HRESULT HrRemoveSzFromMultiSz(LPCTSTR sz, 
                              LPCTSTR mszIn, 
                              LPTSTR * pmszOut)
{
    HRESULT hr = S_OK;
    Assert(pmszOut);

    if(FIsSzInMultiSzSafe(sz, mszIn)) // We need to remove the string
    {
        size_t cchIn = CchMsz(mszIn);
        size_t cchOut = cchIn - lstrlen(sz)-1; // we assume the can string only appeared once

        // Construct the output multi-sz
        TCHAR * mszOut = new TCHAR[(int)cchOut];
        ZeroMemory(mszOut, cchOut*sizeof(TCHAR));

        TCHAR * pchIn = (TCHAR*) mszIn;
        TCHAR * pchOut = mszOut;

        while(*pchIn) // for each substring in mszIn
        {
            if(lstrcmpi(pchIn, sz) != 0) // if not the same as the string we are removing
            {
                lstrcpy(pchOut, pchIn);
                pchIn += lstrlen(pchIn) + 1;
                pchOut += lstrlen(pchOut) + 1;
            }
            else // skip the string we are deleting
            {
                pchIn += lstrlen(pchIn) + 1;
            }
        }

        // Add the last '\0' of the multi-sz
        *pchOut = '\0';

        *pmszOut = mszOut;
    }
    else // We simply make a copy of the input string
    {
        size_t cchMszOut = CchMsz(mszIn);
        TCHAR * mszOut = new TCHAR[(int)cchMszOut];
        
        // Copy the existing string
        CopyMemory(mszOut, mszIn, cchMszOut*sizeof(TCHAR));
        *pmszOut = mszOut;
    }

    Trace1("HrRemoveSzFromMultiSz %08lx", hr);
    return hr;
}



//-------------------------------------------------------------------
HRESULT CService::HrMoveOutOfState(DWORD dwState)
{
    HRESULT         hr          = S_OK;
    SERVICE_STATUS  sStatus;

    // Give the service a maximum of 30 seconds to start
    UINT            cTimeout    = 30;

    AssertSz((NULL != _schandle), "We don't have a service handle");

    do
    {
        DWORD   dwWait = 0;

        // Get the status of the service
        if (!::QueryServiceStatus(_schandle, &sStatus))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        // We are not longer in the state we were waiting for
        if (sStatus.dwCurrentState != dwState)
        {
            hr = S_OK;
            break;
        }

        // Wait a second and or less for the service to start
        dwWait = min((sStatus.dwWaitHint / 10), 1*(1000));

        ::Sleep(dwWait);
    }
    while(cTimeout--);  // Make sure we don't get in an endless loop.

    // Return an error if we timeout
    if (0 == cTimeout)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_READY);

        AssertSz(FALSE,
                "We timed out on waiting for a service.  This is bad.");
    }

    Trace1("CService::HrMoveOutOfState", hr);
    return hr;
}



//-------------------------------------------------------------------
HRESULT CService::HrQueryState( DWORD* pdwState )
{
    SERVICE_STATUS sStatus;

    Assert(_schandle != NULL );
    Assert(pdwState != NULL );

    if (!::QueryServiceStatus( _schandle, &sStatus ))
    {
        *pdwState = 0;
        return HRESULT_FROM_WIN32(GetLastError());
    }
    *pdwState = sStatus.dwCurrentState;
    return S_OK;
}

//-------------------------------------------------------------------
HRESULT CService::HrQueryStartType( DWORD* pdwStartType )
{
    LPQUERY_SERVICE_CONFIG pqsConfig = NULL;
    DWORD   cbNeeded = sizeof( QUERY_SERVICE_CONFIG );
    DWORD   cbSize;
    BOOL    frt;

    Assert(_schandle != NULL );
    Assert(pdwStartType != NULL );

    *pdwStartType = 0;
    // loop, allocating the needed size
    do
    {
        delete [] (PBYTE)pqsConfig;

        pqsConfig = (LPQUERY_SERVICE_CONFIG) new BYTE[cbNeeded];
        if (pqsConfig == NULL)
        {
            return E_OUTOFMEMORY;
        }
        cbSize = cbNeeded;

        frt = ::QueryServiceConfig( _schandle,
                pqsConfig,
                cbSize,
                &cbNeeded );
        *pdwStartType = pqsConfig->dwStartType;
        delete [] (PBYTE)pqsConfig;
        pqsConfig = NULL;

        if (!frt && (cbNeeded == cbSize))
        {
            // error
            *pdwStartType = 0;
            return HRESULT_FROM_WIN32(GetLastError());
        }

    } while (!frt && (cbNeeded != cbSize));

    return S_OK;
}


//-------------------------------------------------------------------
HRESULT CService::HrQueryDependencies(OUT LPTSTR * pmszDependencyList)
{
    HRESULT hr = S_OK;

    LPQUERY_SERVICE_CONFIG pqsConfig = NULL;
    DWORD   cbNeeded = sizeof( QUERY_SERVICE_CONFIG );
    DWORD   cbSize;
    BOOL    frt;

    Assert(_schandle != NULL );
    Assert(pmszDependencyList);

    // loop, allocating the needed size
    do
    {
        delete [] (PBYTE)pqsConfig;

        pqsConfig = (LPQUERY_SERVICE_CONFIG) new BYTE[cbNeeded];
        if (pqsConfig == NULL)
        {
            hr = E_OUTOFMEMORY;

            Trace1("CService::HrQueryDependencies", hr);
            return hr;
        }
        cbSize = cbNeeded;

        frt = ::QueryServiceConfig( _schandle,
                pqsConfig,
                cbSize,
                &cbNeeded );

        if (!frt && (cbNeeded == cbSize)) // error
        {
            delete [] (PBYTE)pqsConfig;
            pqsConfig = NULL;

            pmszDependencyList = NULL;

            hr = HRESULT_FROM_WIN32(GetLastError());

            Trace1("CService::HrQueryDependencies", hr);
            return hr;
        }
        else if (frt && (cbNeeded != cbSize)) // We just need more space
        {
            delete [] (PBYTE)pqsConfig;
            pqsConfig = NULL;
        }

    } while (!frt && (cbNeeded != cbSize));

    // Copy pqsConfig->lpDependencies to *pmszDependencyList
    // Allocating space
    // int cch = CchMsz(pqsConfig->lpDependencies);
    size_t cch=0;
    TCHAR * pch= pqsConfig->lpDependencies;
    while (*pch)
    {
        pch += lstrlen(pch)+1;
    }
    cch = (size_t)(pch - pqsConfig->lpDependencies +1);

    TCHAR * mszOut;
    mszOut = new TCHAR[(int)cch];

    if (mszOut == NULL)
    {
        hr = E_OUTOFMEMORY;

        Trace1("CService::HrQueryDependencies", hr);
        return hr;
    }
    else
    {
        ZeroMemory(mszOut, cch * sizeof(TCHAR));

        // Copy dependency list to mszOut
        *pmszDependencyList = mszOut;
        pch = pqsConfig->lpDependencies;

        while (*pch)
        {
            lstrcpy(mszOut, pch);
            mszOut += lstrlen(pch)+1;
            pch += lstrlen(pch)+1;
        }
        mszOut = '\0';
    }
    delete [] (PBYTE)pqsConfig;

    Trace1("CService::HrQueryDependencies", hr);
    return hr;
}

//-------------------------------------------------------------------
HRESULT CServiceManager::HrQueryLocked(BOOL *pfLocked)
{
    LPQUERY_SERVICE_LOCK_STATUS pqslStatus = NULL;
    DWORD   cbNeeded = sizeof( QUERY_SERVICE_LOCK_STATUS );
    DWORD   cbSize;
    BOOL    frt;

    Assert(_schandle != NULL );
    Assert(pfLocked != NULL);

    *pfLocked = FALSE;

    // loop, allocating the needed size
    do
    {
        pqslStatus = (LPQUERY_SERVICE_LOCK_STATUS) new BYTE[cbNeeded];
        if (pqslStatus == NULL)
        {
            return E_OUTOFMEMORY;
        }
        cbSize = cbNeeded;

        frt = ::QueryServiceLockStatus( _schandle,
                pqslStatus,
                cbSize,
                &cbNeeded );
        *pfLocked = pqslStatus->fIsLocked;
        delete [] (PBYTE)pqslStatus;
        pqslStatus = NULL;
        if (!frt && (cbNeeded == cbSize))
        {
            // if an error, treat this as a lock
            return HRESULT_FROM_WIN32(GetLastError());
        }

    } while (!frt && (cbNeeded != cbSize));

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServiceManager::HrStartServiceHelper
//
//  Purpose:    Starts the given service
//
//  Arguments:
//      szService  [in]  Name of service to start.
//      eCriteria  [in]  if SERVICE_ONLY_AUTO_START, the service is only
//                           started if it is configured as auto-start
//
//  Returns:    S_OK if success, Win32 HRESULT otherwise.
//
//  Author:     danielwe   13 Jun 1997
//
//  Notes:
//
HRESULT
CServiceManager::HrStartServiceHelper(LPCTSTR szService,
                                      SERVICE_START_CRITERIA eCriteria)
{
    HRESULT             hr = S_OK;
    CService            service;

    hr = HrOpenService(&service, szService);
    if (SUCCEEDED(hr))
    {
        BOOL fStart = TRUE;

        if (SERVICE_ONLY_AUTO_START == eCriteria)
        {
            DWORD dwStartType;

            // only start services that are not disabled and not manual
            hr = service.HrQueryStartType(&dwStartType);
            if (FAILED(hr) ||
                (SERVICE_DEMAND_START == dwStartType) ||
                (SERVICE_DISABLED == dwStartType))
            {
                fStart = FALSE;
            }
        }

        // If everything is okay to start then start it!
        if (fStart)
        {
            hr = service.HrStart();
            if (SUCCEEDED(hr))
            {
                // Make sure the service has started.
                hr = service.HrMoveOutOfState(SERVICE_START_PENDING);

                // Normalize result
                if (SUCCEEDED(hr))
                {
                    hr = S_OK;
                }
            }
            else if (HRESULT_FROM_WIN32(ERROR_SERVICE_ALREADY_RUNNING) == hr)
            {
                // Ignore error if service is already running
                hr = S_OK;
            }
        }
        service.Close();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServiceManager::HrStopService
//
//  Purpose:    Stops the given service.
//
//  Arguments:
//      szService [in]  Name of service to stop.
//
//  Returns:    S_OK if success, Win32 HRESULT otherwise.
//
//  Author:     danielwe   17 Jun 1997
//
//  Notes:      If service is not running, this returns S_OK.
//
HRESULT CServiceManager::HrStopService(LPCTSTR szService)
{
    HRESULT     hr = S_OK;
    CService    service;

    hr = HrOpenService(&service, szService);
    if (SUCCEEDED(hr))
    {
        hr = service.HrControl(SERVICE_CONTROL_STOP);
        if (HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE) == hr)
        {
            // ignore error if the service is not running
            hr = S_OK;
        }

        service.Close();
    }

    Trace1("CServiceManager::HrStopService", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServiceManager::HrAddRemoveServiceDependency
//
//  Purpose:    Add/remove dependency to a service
//
//  Arguments:
//      szService [in]      Name of service
//      szDependency [in]   Dependency to add
//      enumFlag [in]       Indicates add or remove
//
//  Returns:    S_OK if success, Win32 HRESULT otherwise.
//
//  Author:     tongl   17 Jun 1997
//
//  Notes: this function is not for adding/removing group dependency
//
HRESULT CServiceManager::HrAddRemoveServiceDependency(LPCTSTR szServiceName,
                                                      LPCTSTR szDependency,
                                                      DEPENDENCY_ADDREMOVE enumFlag)
{
    HRESULT     hr = S_OK;

    Assert(szServiceName);
    Assert(szDependency);
    Assert((enumFlag == DEPENDENCY_ADD) || (enumFlag == DEPENDENCY_REMOVE));

    // If either string is empty, do nothing
    if ((lstrlen(szDependency)>0) && (lstrlen(szServiceName)>0))
    {
        hr = HrLock();
        if (SUCCEEDED(hr))
        {
            LPCTSTR szSrv = szDependency;

            CService    svc;
            // Check if the dependency service exists
            hr = HrOpenService(&svc, szDependency);

            if SUCCEEDED(hr)
            {
                svc.Close();

                // Open the service we are changing dependency on
                szSrv = szServiceName;
                hr = HrOpenService(&svc, szServiceName);
                if (SUCCEEDED(hr))
                {
                    LPTSTR mszDependencies;

                    hr = svc.HrQueryDependencies(&mszDependencies);
                    if(SUCCEEDED(hr) && mszDependencies)
                    {
                        TCHAR * mszNewDependencies;

                        if (enumFlag == DEPENDENCY_ADD)
                        {
                            hr = HrAddSzToMultiSz(szDependency, mszDependencies,
                                                  &mszNewDependencies);
                        }
                        else if (enumFlag == DEPENDENCY_REMOVE)
                        {
                            hr = HrRemoveSzFromMultiSz(szDependency, mszDependencies,
                                                       &mszNewDependencies);
                        }

                        if (SUCCEEDED(hr))
                        {
                            // Now set the new dependency
                            hr = svc.HrSetDependencies(const_cast<LPCTSTR>(mszNewDependencies));
                            delete [] mszNewDependencies;
                        }
                    }
                    delete [] mszDependencies;
                    svc.Close();
                }
            }

            if (HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) == hr) // If either services do not exist
            {

#ifdef DEBUG
                Trace1("CServiceManager::HrAddServiceDependency, Service %s does not exist.", szSrv);
#endif
                hr = S_OK;
            }
        }

        Unlock();

    } // if szDependency is not empty string

    Trace1("CServiceManager::HrAddServiceDependency", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\dialin.cpp ===
/**********************************************************************/
/** 					  Microsoft Windows/NT						 **/
/** 			   Copyright(c) Microsoft Corporation, 1997 - 1999 				 **/
/**********************************************************************/

/*
	DialIn
		Interface node information
		
	FILE HISTORY:
		
*/

#include "stdafx.h"
#include "dialin.h"
#include "ifadmin.h"
#include "rtrstrm.h"		// for RouterAdminConfigStream
#include "rtrlib.h" 		// ContainerColumnInfo
#include "coldlg.h" 		// ColumnDlg
#include "column.h" 	// ComponentConfigStream
#include "refresh.h"		// IRouterRefresh
#include "iface.h"		// for interfacenode data
#include "conndlg.h"		// CConnDlg - connection dialog
#include "msgdlg.h" 		// CMessageDlg
#include "dmvcomp.h"

DialInNodeData::DialInNodeData()
{
#ifdef DEBUG
	StrCpyA(m_szDebug, "DialInNodeData");
#endif
}

DialInNodeData::~DialInNodeData()
{
}

/*!--------------------------------------------------------------------------
	DialInNodeData::InitAdminNodeData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DialInNodeData::InitAdminNodeData(ITFSNode *pNode, RouterAdminConfigStream *pConfigStream)
{
	HRESULT 			hr = hrOK;
	DialInNodeData *	pData = NULL;
	
	pData = new DialInNodeData;

	SET_DIALINNODEDATA(pNode, pData);

	// Need to connect to the router to get this data
	
	return hr;
}

/*!--------------------------------------------------------------------------
	DialInNodeData::FreeAdminNodeData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DialInNodeData::FreeAdminNodeData(ITFSNode *pNode)
{	
	DialInNodeData *	pData = GET_DIALINNODEDATA(pNode);
	delete pData;
	SET_DIALINNODEDATA(pNode, NULL);
	
	return hrOK;
}

HRESULT DialInNodeData::LoadHandle(LPCTSTR pszMachineName)
{
    m_stMachineName = pszMachineName;
    return HResultFromWin32(::MprAdminServerConnect((LPTSTR) pszMachineName,
        &m_sphDdmHandle));
    
}

HANDLE DialInNodeData::GetHandle()
{
    if (!m_sphDdmHandle)
    {
        LoadHandle(m_stMachineName);
    }
    return m_sphDdmHandle;
}

void DialInNodeData::ReleaseHandles()
{
    m_sphDdmHandle.Release();
}


STDMETHODIMP DialInNodeHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
	// Is the pointer bad?
	if (ppv == NULL)
		return E_INVALIDARG;

	//	Place NULL in *ppv in case of failure
	*ppv = NULL;

	//	This is the non-delegating IUnknown implementation
	if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IRtrAdviseSink)
		*ppv = &m_IRtrAdviseSink;
	else
		return CHandler::QueryInterface(riid, ppv);

	//	If we're going to return an interface, AddRef it first
	if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
	else
		return E_NOINTERFACE;	
}


/*---------------------------------------------------------------------------
	NodeHandler implementation
 ---------------------------------------------------------------------------*/

extern const ContainerColumnInfo	s_rgDialInColumnInfo[];

const ContainerColumnInfo s_rgDialInColumnInfo[] =
{
	{ IDS_DIALIN_COL_USERNAME,	CON_SORT_BY_STRING, TRUE, COL_STRING},
	{ IDS_DIALIN_COL_DURATION,	CON_SORT_BY_DWORD,	TRUE, COL_DURATION},
	{ IDS_DIALIN_COL_NUMBEROFPORTS, CON_SORT_BY_DWORD, TRUE, COL_SMALL_NUM},
};
											
#define NUM_FOLDERS 1

DialInNodeHandler::DialInNodeHandler(ITFSComponentData *pCompData)
	: BaseContainerHandler(pCompData, DM_COLUMNS_DIALIN, s_rgDialInColumnInfo),
	m_bExpanded(FALSE),
	m_pConfigStream(NULL),
	m_ulConnId(0),
	m_ulRefreshConnId(0),
	m_ulPartialRefreshConnId(0)
{

	// Setup the verb states for this node
	m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
	m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;
}

/*!--------------------------------------------------------------------------
	DialInNodeHandler::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DialInNodeHandler::Init(IRouterInfo *pRouterInfo, RouterAdminConfigStream *pConfigStream)
{
	HRESULT hr = hrOK;
	SPIRouterRefresh	spRefresh;

	// If we don't have a router info then we probably failed to load
	// or failed to connect.  Bail out of this.
	if (!pRouterInfo)
		CORg( E_FAIL );
	
	m_spRouterInfo.Set(pRouterInfo);

	// Also need to register for change notifications
	m_spRouterInfo->RtrAdvise(&m_IRtrAdviseSink, &m_ulConnId, 0);

	m_pConfigStream = pConfigStream;

	// register the partial refhersh notifications
	if( 0 == m_ulPartialRefreshConnId )
	{
		m_spRouterInfo->GetRefreshObject(&spRefresh);
		if(spRefresh)
			spRefresh->AdviseRefresh(&m_IRtrAdviseSink, &m_ulPartialRefreshConnId, 0);
	}

Error:
	return hrOK;
}

/*!--------------------------------------------------------------------------
	DialInNodeHandler::DestroyHandler
		Implementation of ITFSNodeHandler::DestroyHandler
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DialInNodeHandler::DestroyHandler(ITFSNode *pNode)
{
	DialInNodeData::FreeAdminNodeData(pNode);

	m_spDataObject.Release();
	
	if (m_ulRefreshConnId || m_ulPartialRefreshConnId)
	{
		SPIRouterRefresh	spRefresh;
		if (m_spRouterInfo)
			m_spRouterInfo->GetRefreshObject(&spRefresh);
		if (spRefresh)
		{
			if(m_ulRefreshConnId)
				spRefresh->UnadviseRefresh(m_ulRefreshConnId);
			if(m_ulPartialRefreshConnId)
				spRefresh->UnadviseRefresh(m_ulPartialRefreshConnId);
		}
	}
	m_ulRefreshConnId = 0;
	m_ulPartialRefreshConnId = 0;
	
	if (m_spRouterInfo)
	{
		m_spRouterInfo->RtrUnadvise(m_ulConnId);
		m_spRouterInfo.Release();
	}
	return hrOK;
}

/*!--------------------------------------------------------------------------
	DialInNodeHandler::HasPropertyPages
		Implementation of ITFSNodeHandler::HasPropertyPages

 ---------------------------------------------------------------------------*/
STDMETHODIMP 
DialInNodeHandler::HasPropertyPages
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES	type, 
	DWORD				dwType
)
{
	// we have no property pages in the normal case
	return hrFalse;
}


/*---------------------------------------------------------------------------
	Menu data structure for our menus
 ---------------------------------------------------------------------------*/

static const SRouterNodeMenu	s_rgDialInNodeMenu[] =
{
	// Add items that are primary go here
	{ IDS_MENU_DIALIN_SENDALL, DialInNodeHandler::GetSendAllMenuFlags,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },
		
	// Add items that go on the "Create new" menu here
	// Add items that go on the "Task" menu here
};

ULONG	DialInNodeHandler::GetSendAllMenuFlags(const SRouterNodeMenu *pMenuData,
                                               INT_PTR pUserData)
{
	ULONG	ulFlags = 0;
    SMenuData * pData = reinterpret_cast<SMenuData *>(pUserData);

	if (pData)
	{
		int iVis, iTotal;
		pData->m_spNode->GetChildCount(&iVis, &iTotal);
		if (iTotal == 0)
			ulFlags = MF_GRAYED;
	}

	return ulFlags;
}

/*!--------------------------------------------------------------------------
	DialInNodeHandler::OnAddMenuItems
		Implementation of ITFSNodeHandler::OnAddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DialInNodeHandler::OnAddMenuItems(
												ITFSNode *pNode,
												LPCONTEXTMENUCALLBACK pContextMenuCallback, 
												LPDATAOBJECT lpDataObject, 
												DATA_OBJECT_TYPES type, 
												DWORD dwType,
												long *pInsertionAllowed)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = S_OK;
    DialInNodeHandler::SMenuData    menuData;
	
	COM_PROTECT_TRY
	{
        menuData.m_spNode.Set(pNode);
        
		hr = AddArrayOfMenuItems(pNode, s_rgDialInNodeMenu,
								 DimensionOf(s_rgDialInNodeMenu),
								 pContextMenuCallback,
								 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
	}
	COM_PROTECT_CATCH;
		
	return hr; 
}

/*!--------------------------------------------------------------------------
	DialInNodeHandler::OnCommand
		Implementation of ITFSNodeHandler::OnCommand
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DialInNodeHandler::OnCommand(ITFSNode *pNode, long nCommandId, 
										   DATA_OBJECT_TYPES	type, 
										   LPDATAOBJECT pDataObject, 
										   DWORD	dwType)
{	
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	if (nCommandId == IDS_MENU_DIALIN_SENDALL)
	{
		WCHAR * pswzComputerName;
		// Get the machine name out of the data object
		pswzComputerName = ExtractComputerName(pDataObject);

		CMessageDlg dlg(m_spRouterInfo->GetMachineName(), W2CT(pswzComputerName), NULL);
		dlg.DoModal();
	}
	return hrOK;
}

/*!--------------------------------------------------------------------------
	DialInNodeHandler::GetString
		Implementation of ITFSNodeHandler::GetString
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) DialInNodeHandler::GetString(ITFSNode *pNode, int nCol)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = hrOK;

	COM_PROTECT_TRY
	{
		if (m_stTitle.IsEmpty())
			m_stTitle.LoadString(IDS_DIALIN_USERS);
	}
	COM_PROTECT_CATCH;

	return m_stTitle;
}


/*!--------------------------------------------------------------------------
	DialInNodeHandler::OnCreateDataObject
		Implementation of ITFSNodeHandler::OnCreateDataObject
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DialInNodeHandler::OnCreateDataObject(MMC_COOKIE cookie,
	DATA_OBJECT_TYPES type,
	IDataObject **ppDataObject)
{
	HRESULT hr = hrOK;
	
	COM_PROTECT_TRY
	{
		if (!m_spDataObject)
		{
			CORg( CreateDataObjectFromRouterInfo(m_spRouterInfo,
				m_spRouterInfo->GetMachineName(),
				type, cookie, m_spTFSCompData,
				&m_spDataObject, NULL, FALSE) );
			Assert(m_spDataObject);
		}
		
		*ppDataObject = m_spDataObject;
		(*ppDataObject)->AddRef();
			
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}

/*!--------------------------------------------------------------------------
	DialInNodeHandler::OnExpand
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DialInNodeHandler::OnExpand(ITFSNode *pNode,
									LPDATAOBJECT pDataObject,
									DWORD dwType,
									LPARAM arg,
									LPARAM lParam)
{
	HRESULT 				hr = hrOK;
	SPIEnumInterfaceInfo	spEnumIf;
	SPIInterfaceInfo		spIf;

	// If we don't have a router object, then we don't have any info, don't
	// try to expand.
	if (!m_spRouterInfo)
		return hrOK;
	
	if (m_bExpanded)
		return hrOK;

	COM_PROTECT_TRY
	{
		SynchronizeNodeData(pNode);

		m_bExpanded = TRUE;

	}
	COM_PROTECT_CATCH;

	return hr;
}


/*!--------------------------------------------------------------------------
	DialInNodeHandler::OnResultShow
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DialInNodeHandler::OnResultShow(ITFSComponent *pTFSComponent,
										MMC_COOKIE cookie,
										LPARAM arg,
										LPARAM lParam)
{
	BOOL	bSelect = (BOOL) arg;
	HRESULT hr = hrOK;
	SPIRouterRefresh	spRefresh;
	SPITFSNode	spNode;

	BaseContainerHandler::OnResultShow(pTFSComponent, cookie, arg, lParam);

	if (bSelect)
	{
		// Call synchronize on this node
		m_spNodeMgr->FindNode(cookie, &spNode);
		if (spNode)
			SynchronizeNodeData(spNode);
	}

	// Un/Register for refresh advises
	if (m_spRouterInfo)
		m_spRouterInfo->GetRefreshObject(&spRefresh);

	if (spRefresh)
	{
		if (bSelect)
		{
			if (m_ulRefreshConnId == 0)
				spRefresh->AdviseRefresh(&m_IRtrAdviseSink, &m_ulRefreshConnId, 0);
			
			if (m_ulPartialRefreshConnId)
			{
				spRefresh->UnadviseRefresh(m_ulPartialRefreshConnId);
				m_ulPartialRefreshConnId = 0;
			}
		}
		else
		{
			if (m_ulRefreshConnId)
				spRefresh->UnadviseRefresh(m_ulRefreshConnId);
			m_ulRefreshConnId = 0;

			if (m_ulPartialRefreshConnId == 0)
				spRefresh->AdviseRefresh(&m_IRtrAdviseSink, &m_ulPartialRefreshConnId, 0);
		}
	}
	
	return hr;
}

/*!--------------------------------------------------------------------------
	DialInNodeHandler::ConstructNode
		Initializes the Domain node (sets it up).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DialInNodeHandler::ConstructNode(ITFSNode *pNode)
{
	HRESULT 		hr = hrOK;
	DialInNodeData *	pNodeData;
	
	if (pNode == NULL)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Need to initialize the data for the Domain node
		pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_INTERFACES);
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_INTERFACES);
		pNode->SetData(TFS_DATA_SCOPEID, 0);

        // This is a leaf node in the scope pane
        pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

		m_cookie = reinterpret_cast<MMC_COOKIE>(pNode);
		pNode->SetData(TFS_DATA_COOKIE, m_cookie);

		pNode->SetNodeType(&GUID_RouterDialInNodeType);
		
		DialInNodeData::InitAdminNodeData(pNode, m_pConfigStream);

		pNodeData = GET_DIALINNODEDATA(pNode);
		Assert(pNodeData);

		// Ignore the error, we should be able to deal with the
		// case of a stopped router.
        pNodeData->LoadHandle(m_spRouterInfo->GetMachineName());

		PartialSynchronizeNodeData(pNode);

	}
	COM_PROTECT_CATCH

	return hr;
}


/*!--------------------------------------------------------------------------
	DialInNodeHandler::SynchronizeNodeData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DialInNodeHandler::SynchronizeNodeData(ITFSNode *pThisNode)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	Assert(pThisNode);
	
	SPITFSNodeEnum	spEnum;
	int 			i;
	
	HRESULT hr = hrOK;
	DWORD				dwTotalCount = 0;
	DialInNodeData *	pNodeData;
	DialInList			dialinList;
	DialInList			newDialInList;
	DialInListEntry *	pDialIn;
	BOOL				fFound;
	POSITION			pos;
	SPITFSNode			spChildNode;
	InterfaceNodeData * pChildData;
	int 				nChildCount;

	COM_PROTECT_TRY
	{

		// Get the status data from the running router
		pNodeData = GET_DIALINNODEDATA(pThisNode);
		if (pNodeData == NULL)
		{
			// Remove all of the nodes, we can't connect so we can't
			// get any running data.
			UnmarkAllNodes(pThisNode, spEnum);
			RemoveAllUnmarkedNodes(pThisNode, spEnum);

			m_stTitle.LoadString(IDS_DIALIN_USERS);
			pThisNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM_DATA);

			return hrOK;
		}
		
		// Unmark all of the nodes	
		pThisNode->GetEnum(&spEnum);
		UnmarkAllNodes(pThisNode, spEnum);
		
		// Go out and grab the data, merge the the new data in with
		// the old data.
		CORg( GenerateListOfUsers(pThisNode, &dialinList, &dwTotalCount) );
		
		
		pos = dialinList.GetHeadPosition();
		
		while (pos)
		{
			pDialIn = & dialinList.GetNext(pos);
			
			// Look for this entry in our current list of nodes
			spEnum->Reset();
			spChildNode.Release();
			
			fFound = FALSE;
			
			for (;spEnum->Next(1, &spChildNode, NULL) == hrOK; spChildNode.Release())
			{
				pChildData = GET_INTERFACENODEDATA(spChildNode);
				Assert(pChildData);
				
				if (pChildData->m_rgData[DIALIN_SI_CONNECTION].m_ulData ==
					reinterpret_cast<LONG_PTR>(pDialIn->m_rc0.hConnection))
				{
					// Ok, this user already exists, update the metric
					// and mark it
					Assert(pChildData->dwMark == FALSE);
					pChildData->dwMark = TRUE;
					
					fFound = TRUE;
					
					SetUserData(spChildNode, *pDialIn);
					
					// Force MMC to redraw the node
					spChildNode->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);
					break;
				}
			}
			
			if (!fFound)
				newDialInList.AddTail(*pDialIn);
			
		}

		// In case of an error (such as we cannot contact the server)
		// we want to remove the unmarked nodes.
		COM_PROTECT_ERROR_LABEL;
		
		// Remove all nodes that were not marked
		RemoveAllUnmarkedNodes(pThisNode, spEnum);

		// Now iterate through the list of new users, adding them all in.

		pos = newDialInList.GetHeadPosition();
		while (pos)
		{
			pDialIn = & newDialInList.GetNext(pos);

			AddDialInUserNode(pThisNode, *pDialIn);
		}

		// NT BUG #163162, put the connected client count into the
		// title of the node
		if (FHrSucceeded(hr))
			m_stTitle.Format(IDS_DIALIN_USERS_NUM, dwTotalCount);
		else
			m_stTitle.Format(IDS_DIALIN_USERS);
			
		pThisNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM_DATA);
	}
	COM_PROTECT_CATCH;
		
	return hr;
}


/*!--------------------------------------------------------------------------
	DialInNodeHandler::PartialSynchronizeNodeData
		-
	Description: For Bug #163162 Only refresh dialin user count on the the node title

	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT DialInNodeHandler::PartialSynchronizeNodeData(ITFSNode *pThisNode)
{
	Assert(pThisNode);
	
	SPITFSNodeEnum	spEnum;
	int 			i;
	
	HRESULT hr = hrOK;
	DWORD	dwCount = 0;
	DialInNodeData *	pNodeData;
	int		iFormat;


	COM_PROTECT_TRY
	{

		// Get the status data from the running router
		pNodeData = GET_DIALINNODEDATA(pThisNode);
		if (pNodeData == NULL)
		{
			// Remove all of the nodes, we can't connect so we can't
			// get any running data.
			iFormat = IDS_DIALIN_USERS;
		}
		else
		{		
			// Get the count of dial-in clients and put the number
			// in the node title
			hr = GenerateListOfUsers(pThisNode, NULL, &dwCount);
			if (FHrSucceeded(hr))
				iFormat = IDS_DIALIN_USERS_NUM;
			else
				iFormat = IDS_DIALIN_USERS;
		}
		
		m_stTitle.Format(iFormat, dwCount);
		pThisNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM_DATA);
	}
	COM_PROTECT_CATCH;
		
	return hr;
}

/*!--------------------------------------------------------------------------
	DialInNodeHandler::SetUserData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DialInNodeHandler::SetUserData(ITFSNode *pNode, const DialInListEntry& entry)
{
	HRESULT 	hr = hrOK;
	InterfaceNodeData * pData;
	TCHAR		szNumber[32];
	CString 	st;

	pData = GET_INTERFACENODEDATA(pNode);
	Assert(pData);

	if (entry.m_rc0.dwInterfaceType != ROUTER_IF_TYPE_CLIENT)
	{
		pData->m_rgData[DIALIN_SI_USERNAME].m_stData =
			entry.m_rc0.wszInterfaceName;
	}
	else
	{
		if (StrLenW(entry.m_rc0.wszLogonDomain))
        {
            if (StrLenW(entry.m_rc0.wszUserName))
                st.Format(IDS_DIALINUSR_DOMAIN_AND_NAME,
                          entry.m_rc0.wszLogonDomain,
                          entry.m_rc0.wszUserName);
            else
                st.Format(IDS_DIALINUSR_DOMAIN_ONLY,
                          entry.m_rc0.wszLogonDomain);
        }
		else
			st = entry.m_rc0.wszUserName;
		pData->m_rgData[DIALIN_SI_USERNAME].m_stData = st;
	}


	pData->m_rgData[DIALIN_SI_DOMAIN].m_stData = entry.m_rc0.wszLogonDomain;

	pData->m_rgData[DIALIN_SI_CONNECTION].m_ulData = reinterpret_cast<LONG_PTR>(entry.m_rc0.hConnection);

	FormatDuration(entry.m_rc0.dwConnectDuration,
				   pData->m_rgData[DIALIN_SI_DURATION].m_stData, UNIT_SECONDS);
	pData->m_rgData[DIALIN_SI_DURATION].m_dwData = entry.m_rc0.dwConnectDuration;

	FormatNumber(entry.m_cPorts, szNumber, DimensionOf(szNumber), FALSE);
	pData->m_rgData[DIALIN_SI_NUMBEROFPORTS].m_dwData = entry.m_cPorts;
	pData->m_rgData[DIALIN_SI_NUMBEROFPORTS].m_stData = szNumber;

	return hr;
}

/*!--------------------------------------------------------------------------
	DialInNodeHandler::GenerateListOfUsers
		-
	Author: KennT
	Note:   If pList is NULL, then only the count of items is returned
 ---------------------------------------------------------------------------*/
HRESULT DialInNodeHandler::GenerateListOfUsers(ITFSNode *pNode, DialInList *pList, DWORD *pdwCount)
{
	DialInListEntry entry;
	DialInNodeData *	pDialInData;
	DWORD			dwTotal;
	DWORD			rc0Count;
	RAS_CONNECTION_0 *rc0Table;
	HRESULT 		hr = hrOK;
	DWORD			i;
	RAS_PORT_0 *	rp0Table;
	DWORD			rp0Count;
	SPMprAdminBuffer	spMpr;
	POSITION		pos;
	DialInListEntry *	pEntry;
	DWORD			dwClientCount;

	pDialInData = GET_DIALINNODEDATA(pNode);
	Assert(pDialInData);

	// Fill in the list with all of the current connections
	CWRg( ::MprAdminConnectionEnum(pDialInData->GetHandle(),
								   0,
								   (BYTE **) &rc0Table,
								   (DWORD) -1,
								   &rc0Count,
								   &dwTotal,
								   NULL
								  ));

	Assert(rc0Table);
	spMpr = (LPBYTE) rc0Table;

	dwClientCount = 0;

	// Add a new DialInListEntry for each connection
	for (i=0; i<rc0Count; i++)
	{
		// Windows NT Bug : 124371
		// Need to filter out non-client connections
		// ------------------------------------------------------------
		if (rc0Table[i].dwInterfaceType != ROUTER_IF_TYPE_CLIENT)
			continue;

		dwClientCount++;

		if( pList != NULL )
		{
			::ZeroMemory(&entry, sizeof(entry));
			entry.m_rc0 = rc0Table[i];
			entry.m_cPorts = 0;
		
			pList->AddTail(entry);
		}
	}

	spMpr.Free();

	if( pdwCount != NULL )
		*pdwCount = dwClientCount;

	//if pList is NULL, we are only intereted in the count
	if( NULL == pList )
		goto Error;

	// If the list is empty, there is no need to enumerate the ports
	// to match them up to the connections.
	// ----------------------------------------------------------------
	if (!pList->IsEmpty())
	{
		// Now go through the ports, matching them up against the connections
		CWRg( ::MprAdminPortEnum( pDialInData->GetHandle(),
								  0,
								  INVALID_HANDLE_VALUE,
								  (BYTE **) &rp0Table,
								  (DWORD) -1,
								  &rp0Count,
								  &dwTotal,
								  NULL) );
		spMpr = (LPBYTE) rp0Table;
		
		for (i=0; i<rp0Count; i++)
		{
			// Look through the list of connections for one that
			// matches
			pos = pList->GetHeadPosition();
			
			while (pos)
			{
				pEntry = & pList->GetNext(pos);
				
				if (pEntry->m_rc0.hConnection == rp0Table[i].hConnection)
				{
					pEntry->m_cPorts++;
					break;
				}
			}
		}
	}

Error:
	return hr;
}


ImplementEmbeddedUnknown(DialInNodeHandler, IRtrAdviseSink)

STDMETHODIMP DialInNodeHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
	DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
	InitPThis(DialInNodeHandler, IRtrAdviseSink);
	SPITFSNode				spThisNode;
	HRESULT hr = hrOK;

	COM_PROTECT_TRY
	{

		pThis->m_spNodeMgr->FindNode(pThis->m_cookie, &spThisNode);
	
		if (dwChangeType == ROUTER_REFRESH)
		{
			//(nsun) Bug 163162, We have two Refresh Connection ID for this node and we only 
			// partially refresh (just refresh the node title) if this node is not at focus
			if( ulConn == pThis->m_ulRefreshConnId )
			{
				// Ok, just call the synchronize on this node
				pThis->SynchronizeNodeData(spThisNode);
			}
			else if( ulConn == pThis->m_ulPartialRefreshConnId )
			{
				pThis->PartialSynchronizeNodeData(spThisNode);
			}
		}
        else if (dwChangeType == ROUTER_DO_DISCONNECT)
        {
            DialInNodeData *    pNodeData;
            pNodeData = GET_DIALINNODEDATA(spThisNode);
            Assert(pNodeData);

            // Release the handle
            pNodeData->ReleaseHandles();
        }
	}
	COM_PROTECT_CATCH;
	
	return hr;
}

/*!--------------------------------------------------------------------------
	DialInNodeHandler::CompareItems
		Implementation of ITFSResultHandler::CompareItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int) DialInNodeHandler::CompareItems(
								ITFSComponent * pComponent,
								MMC_COOKIE cookieA,
								MMC_COOKIE cookieB,
								int nCol)
{
	// Get the strings from the nodes and use that as a basis for
	// comparison.
	SPITFSNode	spNode;
	SPITFSResultHandler spResult;

	m_spNodeMgr->FindNode(cookieA, &spNode);
	spNode->GetResultHandler(&spResult);
	return spResult->CompareItems(pComponent, cookieA, cookieB, nCol);
}

/*---------------------------------------------------------------------------
	This is the set of menus that will appear when a right-click is
	done on the blank area of the result pane.
 ---------------------------------------------------------------------------*/
static const SRouterNodeMenu	s_rgDialInResultNodeMenu[] =
{
	// Add items that go on the "Create New" menu here
	{ IDS_MENU_DIALIN_SENDALL, DialInNodeHandler::GetSendAllMenuFlags,
		CCM_INSERTIONPOINTID_PRIMARY_TOP },
};

/*!--------------------------------------------------------------------------
	DialInNodeHandler::AddMenuItems
		Implementation of ITFSResultHandler::AddMenuItems
		Use this to add commands to the context menu of the blank areas
		of the result pane.
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DialInNodeHandler::AddMenuItems(ITFSComponent *pComponent,
											  MMC_COOKIE cookie,
											  LPDATAOBJECT pDataObject,
											  LPCONTEXTMENUCALLBACK pCallback,
											  long *pInsertionAllowed)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = hrOK;
	SPITFSNode	spNode;
    DialInNodeHandler::SMenuData    menuData;

	COM_PROTECT_TRY
	{
		m_spNodeMgr->FindNode(cookie, &spNode);
        menuData.m_spNode.Set(spNode);
        
		hr = AddArrayOfMenuItems(spNode,
								 s_rgDialInResultNodeMenu,
								 DimensionOf(s_rgDialInResultNodeMenu),
								 pCallback,
								 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
	}
	COM_PROTECT_CATCH;

	return hr;
}

/*!--------------------------------------------------------------------------
	DialInNodeHandler::Command
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DialInNodeHandler::Command(ITFSComponent *pComponent,
										   MMC_COOKIE cookie,
										   int nCommandID,
										   LPDATAOBJECT pDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	SPITFSNode	spNode;
	HRESULT 	hr = hrOK;

    m_spNodeMgr->FindNode(cookie, &spNode);
    hr = OnCommand(spNode,
                   nCommandID,
                   CCT_RESULT,
                   pDataObject,
                   TFS_COMPDATA_CHILD_CONTEXTMENU);
	return hr;
}





/*!--------------------------------------------------------------------------
	DialInNodeHandler::AddDialInUserNode
		Adds a user to the UI.	This will create a new result item
		node for each interface.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DialInNodeHandler::AddDialInUserNode(ITFSNode *pParent, const DialInListEntry& dialinEntry)
{
	DialInUserHandler * pHandler;
	SPITFSResultHandler 	spHandler;
	SPITFSNode				spNode;
	HRESULT 				hr = hrOK;

	pHandler = new DialInUserHandler(m_spTFSCompData);
	spHandler = pHandler;
	CORg( pHandler->Init(m_spRouterInfo, pParent) );
	
	CORg( CreateLeafTFSNode(&spNode,
							NULL,
							static_cast<ITFSNodeHandler *>(pHandler),
							static_cast<ITFSResultHandler *>(pHandler),
							m_spNodeMgr) );
	CORg( pHandler->ConstructNode(spNode, NULL, &dialinEntry) );

	SetUserData(spNode, dialinEntry);
	
	// Make the node immediately visible
	CORg( spNode->SetVisibilityState(TFS_VIS_SHOW) );
	CORg( pParent->AddChild(spNode) );
Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	DialInNodeHandler::UnmarkAllNodes
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DialInNodeHandler::UnmarkAllNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum)
{
	SPITFSNode	spChildNode;
	InterfaceNodeData * pNodeData;
	
	pEnum->Reset();
	for ( ;pEnum->Next(1, &spChildNode, NULL) == hrOK; spChildNode.Release())
	{
		pNodeData = GET_INTERFACENODEDATA(spChildNode);
		Assert(pNodeData);
		
		pNodeData->dwMark = FALSE;			
	}
	return hrOK;
}

/*!--------------------------------------------------------------------------
	DialInNodeHandler::RemoveAllUnmarkedNodes
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DialInNodeHandler::RemoveAllUnmarkedNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum)
{
	HRESULT 	hr = hrOK;
	SPITFSNode	spChildNode;
	InterfaceNodeData * pNodeData;
	
	pEnum->Reset();
	for ( ;pEnum->Next(1, &spChildNode, NULL) == hrOK; spChildNode.Release())
	{
		pNodeData = GET_INTERFACENODEDATA(spChildNode);
		Assert(pNodeData);
		
		if (pNodeData->dwMark == FALSE)
		{
			pNode->RemoveChild(spChildNode);
			spChildNode->Destroy();
		}
	}

	return hr;
}




/*---------------------------------------------------------------------------
	DialInUserHandler implementation
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(DialInUserHandler)

IMPLEMENT_ADDREF_RELEASE(DialInUserHandler)

STDMETHODIMP DialInUserHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
	// Is the pointer bad?
	if (ppv == NULL)
		return E_INVALIDARG;

	//	Place NULL in *ppv in case of failure
	*ppv = NULL;

	//	This is the non-delegating IUnknown implementation
	if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IRtrAdviseSink)
		*ppv = &m_IRtrAdviseSink;
	else
		return CBaseResultHandler::QueryInterface(riid, ppv);

	//	If we're going to return an interface, AddRef it first
	if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
	else
		return E_NOINTERFACE;	
}


/*---------------------------------------------------------------------------
	NodeHandler implementation
 ---------------------------------------------------------------------------*/


DialInUserHandler::DialInUserHandler(ITFSComponentData *pCompData)
	: BaseRouterHandler(pCompData),
	m_ulConnId(0)
					
{
	DEBUG_INCREMENT_INSTANCE_COUNTER(DialInUserHandler);
	
	// Setup the verb states for this node
	// ----------------------------------------------------------------
	m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
	m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;
}


/*!--------------------------------------------------------------------------
	DialInUserHandler::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DialInUserHandler::Init(IRouterInfo *pInfo, ITFSNode *pParent)
{
	m_spRouterInfo.Set(pInfo);
	return hrOK;
}


/*!--------------------------------------------------------------------------
	DialInUserHandler::DestroyResultHandler
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DialInUserHandler::DestroyResultHandler(MMC_COOKIE cookie)
{
	SPITFSNode	spNode;
	
	m_spNodeMgr->FindNode(cookie, &spNode);
	InterfaceNodeData::Free(spNode);
	
	CHandler::DestroyResultHandler(cookie);
	return hrOK;
}


static DWORD	s_rgInterfaceImageMap[] =
	 {
	 ROUTER_IF_TYPE_HOME_ROUTER,	IMAGE_IDX_WAN_CARD,
	 ROUTER_IF_TYPE_FULL_ROUTER,	IMAGE_IDX_WAN_CARD,
	 ROUTER_IF_TYPE_CLIENT, 		IMAGE_IDX_WAN_CARD,
	 ROUTER_IF_TYPE_DEDICATED,		IMAGE_IDX_LAN_CARD,
	 ROUTER_IF_TYPE_INTERNAL,		IMAGE_IDX_LAN_CARD,
	 ROUTER_IF_TYPE_LOOPBACK,		IMAGE_IDX_LAN_CARD,
	 -1,							IMAGE_IDX_WAN_CARD, // sentinel value
	 };

/*!--------------------------------------------------------------------------
	DialInUserHandler::ConstructNode
		Initializes the Domain node (sets it up).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DialInUserHandler::ConstructNode(ITFSNode *pNode,
										 IInterfaceInfo *pIfInfo,
										 const DialInListEntry *pEntry)
{
	HRESULT 		hr = hrOK;
	int 			i;

	Assert(pEntry);
	
	if (pNode == NULL)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Need to initialize the data for the Domain node
		pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_INTERFACES);
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_INTERFACES);
		
		pNode->SetData(TFS_DATA_SCOPEID, 0);

		pNode->SetData(TFS_DATA_COOKIE, reinterpret_cast<LONG_PTR>(pNode));

		//$ Review: kennt, what are the different type of interfaces
		// do we distinguish based on the same list as above? (i.e. the
		// one for image indexes).
		pNode->SetNodeType(&GUID_RouterDialInResultNodeType);

		m_entry = *pEntry;

		InterfaceNodeData::Init(pNode, pIfInfo);
	}
	COM_PROTECT_CATCH
	return hr;
}

/*!--------------------------------------------------------------------------
	DialInUserHandler::GetString
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) DialInUserHandler::GetString(ITFSComponent * pComponent,
	MMC_COOKIE cookie,
	int nCol)
{
	Assert(m_spNodeMgr);
	
	SPITFSNode		spNode;
	InterfaceNodeData * pData;
	ConfigStream *	pConfig;

	m_spNodeMgr->FindNode(cookie, &spNode);
	Assert(spNode);

	pData = GET_INTERFACENODEDATA(spNode);
	Assert(pData);

	pComponent->GetUserData((LONG_PTR *) &pConfig);
	Assert(pConfig);

	return pData->m_rgData[pConfig->MapColumnToSubitem(DM_COLUMNS_DIALIN, nCol)].m_stData;
}

/*!--------------------------------------------------------------------------
	DialInUserHandler::CompareItems
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int) DialInUserHandler::CompareItems(ITFSComponent * pComponent,
	MMC_COOKIE cookieA,
	MMC_COOKIE cookieB,
	int nCol)
{
	ConfigStream *	pConfig;
	pComponent->GetUserData((LONG_PTR *) &pConfig);
	Assert(pConfig);

	int	nSubItem = pConfig->MapColumnToSubitem(DM_COLUMNS_DIALIN, nCol);

	if (pConfig->GetSortCriteria(DM_COLUMNS_DIALIN, nCol) == CON_SORT_BY_DWORD)
	{
		SPITFSNode	spNodeA, spNodeB;
        InterfaceNodeData * pNodeDataA = NULL;
        InterfaceNodeData * pNodeDataB = NULL;

		m_spNodeMgr->FindNode(cookieA, &spNodeA);
		m_spNodeMgr->FindNode(cookieB, &spNodeB);

		pNodeDataA = GET_INTERFACENODEDATA(spNodeA);
        Assert(pNodeDataA);
		
		pNodeDataB = GET_INTERFACENODEDATA(spNodeB);
        Assert(pNodeDataB);

        // Note: if the values are both zero, we need to do
        // a string comparison (to distinuguish true zero
        // from a NULL data).
        // e.g. "0" vs. "-"
        
        if ((pNodeDataA->m_rgData[nSubItem].m_dwData == 0 ) &&
            (pNodeDataB->m_rgData[nSubItem].m_dwData == 0))
        {
            return StriCmpW(GetString(pComponent, cookieA, nCol),
                            GetString(pComponent, cookieB, nCol));
        }
        else
            return pNodeDataA->m_rgData[nSubItem].m_dwData -
                    pNodeDataB->m_rgData[nSubItem].m_dwData;
		
	}
	else
		return StriCmpW(GetString(pComponent, cookieA, nCol),
						GetString(pComponent, cookieB, nCol));
}

static const SRouterNodeMenu s_rgIfNodeMenu[] =
{
	{ IDS_MENU_DIALIN_STATUS, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP},
	
	{ IDS_MENU_DIALIN_DISCONNECT, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP},
	
	{ IDS_MENU_DIALIN_SENDMSG, DialInUserHandler::GetSendMsgMenuFlags,
		CCM_INSERTIONPOINTID_PRIMARY_TOP},
	
	{ IDS_MENU_DIALIN_SENDALL, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP},
	
};

ULONG DialInUserHandler::GetSendMsgMenuFlags(const SRouterNodeMenu *,
                                             INT_PTR pUserData)
{
    SMenuData * pData = reinterpret_cast<SMenuData *>(pUserData);
	if (pData->m_pDialin->m_entry.m_rc0.dwInterfaceType == ROUTER_IF_TYPE_CLIENT)
		return 0;
	else
		return MF_GRAYED;
}


/*!--------------------------------------------------------------------------
	DialInUserHandler::AddMenuItems
		Implementation of ITFSResultHandler::OnAddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DialInUserHandler::AddMenuItems(ITFSComponent *pComponent,
												MMC_COOKIE cookie,
												LPDATAOBJECT lpDataObject, 
												LPCONTEXTMENUCALLBACK pContextMenuCallback,
	long *pInsertionAllowed)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = S_OK;
	SPITFSNode	spNode;
	DialInUserHandler::SMenuData	menuData;

	COM_PROTECT_TRY
	{
		m_spNodeMgr->FindNode(cookie, &spNode);

		// Now go through and add our menu items
		menuData.m_spNode.Set(spNode);
        menuData.m_pDialin = this;

        hr = AddArrayOfMenuItems(spNode, s_rgIfNodeMenu,
                                 DimensionOf(s_rgIfNodeMenu),
                                 pContextMenuCallback,
                                 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
	}
	COM_PROTECT_CATCH;
		
	return hr; 
}

/*!--------------------------------------------------------------------------
	DialInUserHandler::Command
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DialInUserHandler::Command(ITFSComponent *pComponent,
										   MMC_COOKIE cookie,
										   int nCommandId,
										   LPDATAOBJECT pDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;
	SPITFSNode	spNode;
	SPITFSNode	spNodeParent;
	SPITFSNodeHandler	spParentHandler;
	DialInNodeData *	pData;
	LPCWSTR 	pswzComputerName;
	USES_CONVERSION;

	COM_PROTECT_TRY
	{

		switch (nCommandId)
		{
			case IDS_MENU_DIALIN_STATUS:
				{
					// Get the hServer and hPort
					m_spNodeMgr->FindNode(cookie, &spNode);
					spNode->GetParent(&spNodeParent);

					pData = GET_DIALINNODEDATA(spNodeParent);

					//kmurthy: Bug 461554: sending in the name of the machine instead of an existing handle
					CConnDlg	conndlg(pData->m_stMachineName,
										m_entry.m_rc0.hConnection,
                                        spNodeParent);

					conndlg.DoModal();

//                  if (conndlg.m_bChanged)
                        RefreshInterface(cookie);
				}
				break;
			case IDS_MENU_DIALIN_DISCONNECT:
				{
					// Get the hServer and hPort
					m_spNodeMgr->FindNode(cookie, &spNode);
					spNode->GetParent(&spNodeParent);

					pData = GET_DIALINNODEDATA(spNodeParent);
						
					::MprAdminInterfaceDisconnect(
						pData->GetHandle(),
						m_entry.m_rc0.hInterface);

					// Refresh this node
					RefreshInterface(cookie);
				}
				break;
			case IDS_MENU_DIALIN_SENDMSG:
				{
					// If this is a client inteface, don't allow sending
					// to this.
					if (m_entry.m_rc0.dwInterfaceType != ROUTER_IF_TYPE_CLIENT)
						break;

					// If the messenger flags are set, then don't bother
					// trying to send the message to this client
					if (!(m_entry.m_rc0.dwConnectionFlags & RAS_FLAGS_MESSENGER_PRESENT))
					{
						AfxMessageBox(IDS_ERR_NO_MESSENGER, MB_OK | MB_ICONINFORMATION);
						break;
					}

					// Send a message to a single user
					// ------------------------------------------------
					CMessageDlg dlg(m_spRouterInfo->GetMachineName(),
									W2CT(m_entry.m_rc0.wszUserName),
									W2CT(m_entry.m_rc0.wszRemoteComputer),
									m_entry.m_rc0.hConnection,
									NULL);

					dlg.DoModal();
				}
				break;
			case IDS_MENU_DIALIN_SENDALL:
				{
					// Get the hServer and hPort
					m_spNodeMgr->FindNode(cookie, &spNode);

					ForwardCommandToParent(spNode,
										   IDS_MENU_DIALIN_SENDALL,
										   CCT_RESULT, pDataObject, 0);
				}
				break;
			default:
				Panic0("DialInUserHandler: Unknown menu command!");
				break;
			
		}
	}
	COM_PROTECT_CATCH;

	return hr;
}


ImplementEmbeddedUnknown(DialInUserHandler, IRtrAdviseSink)

STDMETHODIMP DialInUserHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
	DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
	InitPThis(DialInUserHandler, IRtrAdviseSink);
	HRESULT hr = hrOK;
	
	return hr;
}


/*!--------------------------------------------------------------------------
	DialInUserHandler::OnCreateDataObject
		Implementation of ITFSResultHandler::OnCreateDataObject
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DialInUserHandler::OnCreateDataObject(ITFSComponent *pComp,
	MMC_COOKIE cookie,
	DATA_OBJECT_TYPES type,
	IDataObject **ppDataObject)
{
	HRESULT hr = hrOK;
	
	COM_PROTECT_TRY
	{
		CORg( CreateDataObjectFromRouterInfo(m_spRouterInfo,
											 m_spRouterInfo->GetMachineName(),
											 type, cookie, m_spTFSCompData,
											 ppDataObject, NULL, FALSE) );
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}

STDMETHODIMP DialInUserHandler::HasPropertyPages (
	ITFSComponent *pComp,
	MMC_COOKIE cookie,
	LPDATAOBJECT pDataObject)
{
	return hrFalse;
}


/*!--------------------------------------------------------------------------
	DialInUserHandler::RefreshInterface
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void DialInUserHandler::RefreshInterface(MMC_COOKIE cookie)
{
	ForceGlobalRefresh(m_spRouterInfo);
}

/*!--------------------------------------------------------------------------
	DialInUserHandler::OnResultItemClkOrDblClk
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DialInUserHandler::OnResultItemClkOrDblClk(ITFSComponent *pComponent,
	MMC_COOKIE cookie,
	LPARAM arg,
	LPARAM lParam,
	BOOL bDoubleClick)
{
	HRESULT 	hr = hrOK;
	
	if (bDoubleClick)
	{
		// Bring up the status dialog on this port
		CORg( Command(pComponent, cookie, IDS_MENU_DIALIN_STATUS,
					  NULL) );
	}

Error:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\dialin.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	dialin.h
		Interface administration
		
    FILE HISTORY:
        
*/

#ifndef _DIALIN_H
#define _DIALIN_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H_
#include "handlers.h"
#endif

#ifndef _ROUTER_H
#include "router.h"
#endif

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _BASECON_H
#include "basecon.h"
#endif

#ifndef _RTRUTIL_H_
#include "rtrutil.h"
#endif

#include "rasdlg.h"



#define MPR_INTERFACE_NOT_LOADED		0x00010000

// forward declarations
class RouterAdminConfigStream;
interface IRouterInfo;
struct ColumnData;
struct SDialInNodeMenu;


/*---------------------------------------------------------------------------
	Struct:	DialInNodeData
	This is information related to the set of interfaces (not per-interface),
	this is intended for SHARED data.

	Put data in here that needs to be accessed by the child nodes.  All other
	private data should go in the handler.
 ---------------------------------------------------------------------------*/

struct DialInNodeData
{
	DialInNodeData();
	~DialInNodeData();
#ifdef DEBUG
	char	m_szDebug[32];	// for iding structures
#endif

	static	HRESULT InitAdminNodeData(ITFSNode *pNode, RouterAdminConfigStream *pConfigStream);
	static	HRESULT	FreeAdminNodeData(ITFSNode *pNode);

    HRESULT LoadHandle(LPCTSTR pszMachineName);
    HANDLE  GetHandle();
    void    ReleaseHandles();
    
    CString             m_stMachineName;

protected:
	SPMprServerHandle	m_sphDdmHandle;
};

#define GET_DIALINNODEDATA(pNode) \
						((DialInNodeData *) pNode->GetData(TFS_DATA_USER))
#define SET_DIALINNODEDATA(pNode, pData) \
						pNode->SetData(TFS_DATA_USER, (LONG_PTR) pData)


/*---------------------------------------------------------------------------
	This is the list of columns available for the Interfaces node
		- User name, "foo"
		- Duration "01:44:22"
		- Number of ports
 ---------------------------------------------------------------------------*/
enum
{
	DIALIN_SI_USERNAME = 0,
	DIALIN_SI_DURATION = 1,
	DIALIN_SI_NUMBEROFPORTS = 2,

	DIALIN_MAX_COLUMNS,

	// Entries after this are not visible to the end-user
	DIALIN_SI_DOMAIN = DIALIN_MAX_COLUMNS,
	DIALIN_SI_CONNECTION,

	DIALIN_SI_MAX,
};


/*---------------------------------------------------------------------------
	Struct:	DialinListEntry
 ---------------------------------------------------------------------------*/
struct DialInListEntry
{
	RAS_CONNECTION_0	m_rc0;
	DWORD				m_cPorts;
};

typedef CList<DialInListEntry, DialInListEntry &> DialInList;



/*---------------------------------------------------------------------------
	Class:	DialInNodeHandler

 ---------------------------------------------------------------------------*/
class DialInNodeHandler :
   public BaseContainerHandler
{
public:
	DialInNodeHandler(ITFSComponentData *pCompData);

	HRESULT	Init(IRouterInfo *pInfo, RouterAdminConfigStream *pConfigStream);

	// Override QI to handle embedded interface
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);
	

	DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)

	// base handler functionality we override
	OVERRIDE_NodeHandler_DestroyHandler();
	OVERRIDE_NodeHandler_GetString();
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_OnCreateDataObject();

	OVERRIDE_ResultHandler_CompareItems();
	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();

	// override handler notifications
	OVERRIDE_BaseHandlerNotify_OnExpand();
	OVERRIDE_BaseResultHandlerNotify_OnResultShow();

	// Initializes the node
	HRESULT ConstructNode(ITFSNode *pNode);

	// User-initiated commands

	// Helper function to add interfaces to the UI
	HRESULT AddDialInUserNode(ITFSNode *pParent, const DialInListEntry &dialinEntry);

	// Causes a sync action (synchronizes data not the structure)
	HRESULT SynchronizeNodeData(ITFSNode *pNode);
	HRESULT PartialSynchronizeNodeData(ITFSNode *pNode);
	HRESULT UnmarkAllNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum);
	HRESULT RemoveAllUnmarkedNodes(ITFSNode *pNode, ITFSNodeEnum *pEnum);
	HRESULT GenerateListOfUsers(ITFSNode *pNode, DialInList *pList, DWORD *pdwCount);

	HRESULT	SetUserData(ITFSNode *pNode, const DialInListEntry& dialin);
	

	// Structure used to pass data to callbacks - used as a way of
	// avoiding recomputation
	struct SMenuData
	{
		SPITFSNode			m_spNode;
	};
    static ULONG	GetSendAllMenuFlags(const SRouterNodeMenu *pMenuData,
                                        INT_PTR pUserData);

	
protected:
	SPIDataObject	m_spDataObject;	// cachecd data object
	CString			m_stTitle;		// holds the title of the node
	LONG_PTR		m_ulConnId;		// notification id for router info
	LONG_PTR		m_ulRefreshConnId; // id for refresh notifications
	LONG_PTR		m_ulPartialRefreshConnId; // id for partial refresh notifications
	BOOL			m_bExpanded;	// is the node expanded?
	MMC_COOKIE			m_cookie;		// cookie for the node

	RouterAdminConfigStream *	m_pConfigStream;

};



/*---------------------------------------------------------------------------
	Class:	DialInUserHandler

 ---------------------------------------------------------------------------*/
class DialInUserHandler :
   public BaseRouterHandler
{
public:
	DialInUserHandler(ITFSComponentData *pCompData);
	~DialInUserHandler()
			{ DEBUG_DECREMENT_INSTANCE_COUNTER(DialInUserHandler); }
	
	HRESULT	Init(IRouterInfo *pInfo, ITFSNode *pParent);

	// Override QI to handle embedded interface
	DeclareIUnknownMembers(IMPL)
//	STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);
	OVERRIDE_ResultHandler_GetString();

	OVERRIDE_ResultHandler_HasPropertyPages();
	OVERRIDE_ResultHandler_CompareItems();
	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_OnCreateDataObject();
	OVERRIDE_ResultHandler_DestroyResultHandler();

	OVERRIDE_BaseResultHandlerNotify_OnResultItemClkOrDblClk();

	// Initializes the node
	HRESULT ConstructNode(ITFSNode *pNode,
						  IInterfaceInfo *pIfInfo,
						  const DialInListEntry *pEntry);

	// Refresh the data for this node
	void RefreshInterface(MMC_COOKIE cookie);

public:
	// Structure used to pass data to callbacks - used as a way of
	// avoiding recomputation
	struct SMenuData
	{
		SPITFSNode			m_spNode;
        DialInUserHandler * m_pDialin;  // non-AddRef'd
	};

	static ULONG	GetSendMsgMenuFlags(const SRouterNodeMenu *, INT_PTR);
	
protected:
	CString			m_stTitle;	// holds the title of the node
	DWORD			m_ulConnId;
	DialInListEntry	m_entry;

	// It is assumed that this will be valid for the lifetime of this node!

	DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)	
};


#endif _DIALIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\dlgadv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dlgadv.cpp
//
//--------------------------------------------------------------------------

// DlgAdv.cpp : implementation file
//

#include "stdafx.h"
#include "DlgAdv.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgAdvanced dialog


CDlgAdvanced::CDlgAdvanced(CWnd* pParent /*=NULL*/)
	: CQryDialog(CDlgAdvanced::IDD, pParent)
{
	Init();
}


void CDlgAdvanced::Init()
{
	//{{AFX_DATA_INIT(CDlgAdvanced)
	//}}AFX_DATA_INIT

	m_bDlgInited = FALSE;
}

CDlgAdvanced::~CDlgAdvanced()
{
	m_strArrayValue.DeleteAll();
}


void CDlgAdvanced::DoDataExchange(CDataExchange* pDX)
{
	CQryDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgAdvanced)
	DDX_Control(pDX, IDC_QRY_LIST_VALUES, m_listCtrl);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgAdvanced, CQryDialog)
	//{{AFX_MSG_MAP(CDlgAdvanced)
	ON_BN_CLICKED(IDC_QRY_BUTTON_CLEARALL, OnButtonClearall)
	ON_BN_CLICKED(IDC_QRY_BUTTON_SELECTALL, OnButtonSelectall)
	ON_WM_WINDOWPOSCHANGING()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgAdvanced message handlers

void CDlgAdvanced::OnButtonClearall() 
{
	int	count = m_listCtrl.GetItemCount();

	while(count-- > 0)
	{
		m_listCtrl.SetCheck(count, FALSE);
	}
}

void CDlgAdvanced::OnButtonSelectall() 
{
	int	count = m_listCtrl.GetItemCount();

	while(count-- > 0)
	{
		m_listCtrl.SetCheck(count, TRUE);
	}
}

void CDlgAdvanced::OnWindowPosChanging( WINDOWPOS* lpwndpos )
{
	if ( lpwndpos->flags & SWP_SHOWWINDOW )
	{
		if(!m_bDlgInited)
			InitDialog();
	}

	CQryDialog::OnWindowPosChanging(lpwndpos);
}


// Query handle will call these functions through page proc
HRESULT CDlgAdvanced::GetQueryParams(LPDSQUERYPARAMS* ppDsQueryParams)
{
	HRESULT	hr = S_OK;
	int	count = m_listCtrl.GetItemCount();
	int	index, j;
	CString	str;
	CString	*pStr;
	CString	subFilters;
	int	subCount = 0;
	CString	filter;
	LPWSTR	pQuery;

	USES_CONVERSION;
	
	try{
		while(count-- > 0)
		{
			if(m_listCtrl.GetCheck(count))
			{
				int	nData = m_listCtrl.GetItemData(count);

				j = HIWORD(nData);
				index = LOWORD(nData);

				pStr = m_strArrayValue.GetAt(index);

				str = pStr->Left(j - 1);

				subFilters += FILTER_PREFIX;
				subFilters += ATTR_NAME_RRASATTRIBUTE;
				subFilters += _T("=");
				subFilters += str;
				subFilters += FILTER_POSTFIX;

				subCount ++;
			}
		}

		if(subCount)	// any 
		{
			if(subCount > 1)
			{
				filter = FILTER_PREFIX;
				filter += _T("|");
				filter += subFilters;
				filter += FILTER_POSTFIX;
				pQuery = T2W((LPTSTR)(LPCTSTR)filter);
			}
			else
				pQuery = T2W((LPTSTR)(LPCTSTR)subFilters);

			hr = ::BuildQueryParams(ppDsQueryParams, pQuery);
		}
	}
	catch(CMemoryException* pException)
	{
		pException->Delete();
		hr = E_OUTOFMEMORY;
	}
	return hr;
}

BOOL CDlgAdvanced::InitDialog() 
{
	if(m_bDlgInited)	return TRUE;
	
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	VARIANT	var;
	CString*	pStr;

	// get the list from dictionary
    VariantInit(&var);

	HRESULT hr = ::QueryRRASAdminDictionary(&var);
	if(hr == S_OK)
	{
    	m_strArrayValue = (SAFEARRAY*)V_ARRAY(&var);
	}
    else
    {
      ReportError(hr, IDS_QRY_ERR_RRASADMINDIC, GetSafeHwnd());
    }
    VariantClear(&var);

	// remove the items that is already availabe in general page
	CStrArray	genPageAttrs;

	hr = GetGeneralPageAttributes(genPageAttrs);

	if(hr == S_OK)
	{
		for(int i = 0; i < genPageAttrs.GetSize(); i++)
		// find the items in the list and remove it
		{
    		for(int j = 0; j < m_strArrayValue.GetSize(); j++)
    		{
    			CString*	pGen = NULL;
    			CString*	pAdv = NULL;

    			pGen = genPageAttrs.GetAt(i);
    			pAdv = m_strArrayValue.GetAt(j);

				ASSERT(pGen && pAdv);
				
    			if(pAdv->Find(*pGen) == 0)	// found
    			{
					m_strArrayValue.RemoveAt(j);
					delete pAdv;
					break;	// for(int j = )
    			}
    		}	// for(int j = )
    	}	// for (int i = )

		// releases the memory
    	genPageAttrs.DeleteAll();
	}
    else
    {
		ReportError(hr, IDS_QRY_ERR_RRASADMINDIC, GetSafeHwnd());
    }
		
	
	
	ListView_SetExtendedListViewStyle(m_listCtrl.GetSafeHwnd(),
										  LVS_EX_FULLROWSELECT);
	
	// Initialize checkbox handling in the list control
	m_listCtrl.InstallChecks();

	RECT	rect;
	m_listCtrl.GetClientRect(&rect);
	m_listCtrl.InsertColumn(0, _T("Desc"), LVCFMT_LEFT, (rect.right - rect.left - 4));

	
	int	cRow = 0;
	for(int i = 0; i < m_strArrayValue.GetSize(); i++)
	{

		// the format:    "311:6:601:Description"
		// put the discription field on the list control

		int	cc = 0, j = 0;
		pStr = m_strArrayValue.GetAt(i);

		ASSERT(pStr);

		int	length = pStr->GetLength();

		while(j < length && cc < 3)
		{
			if(pStr->GetAt(j++) == _T(':'))
				++cc;
		}

		if(cc != 3)	continue;
		
		cRow = m_listCtrl.InsertItem(0, pStr->Mid(j));

		// put index as low word, and the offset as hight word and put the long as data
		m_listCtrl.SetItemData(cRow, MAKELONG(i, j));
		m_listCtrl.SetCheck(cRow, FALSE);
	}

	m_bDlgInited = TRUE;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CDlgAdvanced::OnInitDialog() 
{
	CQryDialog::OnInitDialog();

#if 0	// move the code to positionchanging message handler
	return InitDialog();
#else
	return TRUE;
#endif	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\cservice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       C S E R V I C E . H
//
//  Contents:   This file contains CService and CServiceManager, wrapper
//              classes to the Win32 Service APIs.
//
//  Notes:      Note that not all functionallity is currently extended through
//              these classes.
//              Note that most functionality is inline in this file. What is
//              not inline is in cservice.cpp
//
//  Author:     mikemi   6 Mar 1997
//
//----------------------------------------------------------------------------

#ifndef _CSERVICE_H_
#define _CSERVICE_H_

//#include "debugx.h"
//#include "ncbase.h"

//-------------------------------------------------------------------
//
//
//-------------------------------------------------------------------

size_t CchMsz(const TCHAR * msz);


class CService
{
    friend class CServiceManager;

public:
    CService()
    {
        _schandle = NULL;
    };

    ~CService()
    {
        Close();
    };

    VOID Close()
    {
        BOOL frt;

        if (_schandle)
        {
            frt = ::CloseServiceHandle( _schandle );
	        AssertSz(frt, "CloseServiceHandle failed!");
            _schandle = NULL;
        }
    }

    HRESULT HrDelete()
    {
        Assert(_schandle != NULL );

        if (::DeleteService( _schandle ))
            return S_OK;
        else
            return HRESULT_FROM_WIN32(GetLastError());
    }
    HRESULT HrStart( DWORD cNumServiceArgs = 0,
                LPCTSTR* papServiceArgs = NULL)
    {
        Assert(_schandle != NULL );

        if (::StartService( _schandle, cNumServiceArgs, papServiceArgs ))
            return S_OK;
        else
            return HRESULT_FROM_WIN32(GetLastError());
    }

    HRESULT HrControl( DWORD dwControl )
    {
        SERVICE_STATUS sStatus;

        Assert(_schandle != NULL );
        AssertSz((dwControl != SERVICE_CONTROL_INTERROGATE),
                    "CService::HrControl does not support the SERVICE_CONTROL_INTERROGATE flag");

        if ( ::ControlService( _schandle, dwControl, &sStatus ))
            return S_OK;
        else
            return HRESULT_FROM_WIN32(GetLastError());
    }

    HRESULT HrMoveOutOfState( DWORD dwState );
    HRESULT HrQueryState( DWORD* pdwState );
    HRESULT HrQueryStartType( DWORD* pdwStartType );
    HRESULT HrSetStartType( DWORD dwStartType )
    {
        Assert(_schandle != NULL );

        if (::ChangeServiceConfig( _schandle,
                    SERVICE_NO_CHANGE,
                    dwStartType,
                    SERVICE_NO_CHANGE,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL))
            return S_OK;
        else
            return HRESULT_FROM_WIN32(GetLastError());
    }

    HRESULT HrQueryDependencies(OUT LPTSTR * pmszDependencyList);
    HRESULT HrSetDependencies(IN LPCTSTR mszDependencyList)
    {
        Assert(_schandle != NULL );

        if (::ChangeServiceConfig( _schandle,
                                   SERVICE_NO_CHANGE,  // ServiceType
                                   SERVICE_NO_CHANGE,  // StartType
                                   SERVICE_NO_CHANGE,  // ErrorControl
                                   NULL,               // BinaryPathName
                                   NULL,               // LoadOredrGroup
                                   NULL,               // TagId
                                   mszDependencyList,  // Dependencies
                                   NULL,               // ServiceStartName
                                   NULL,               // Password
                                   NULL))              // DisplayName
            return S_OK;
        else
            return HRESULT_FROM_WIN32(GetLastError());
    }

    HRESULT HrSetDisplayName(IN LPCTSTR mszDisplayName)
    {
        Assert(_schandle != NULL );

        if (::ChangeServiceConfig( _schandle,
                                   SERVICE_NO_CHANGE,  // ServiceType
                                   SERVICE_NO_CHANGE,  // StartType
                                   SERVICE_NO_CHANGE,  // ErrorControl
                                   NULL,               // BinaryPathName
                                   NULL,               // LoadOredrGroup
                                   NULL,               // TagId
                                   NULL,               // Dependencies
                                   NULL,               // ServiceStartName
                                   NULL,               // Password
                                   mszDisplayName))    // DisplayName
        {
            return S_OK;
        }
        else
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }

    HRESULT HrSetServiceObjectSecurity(
        SECURITY_INFORMATION    dwSecurityInformation,
        PSECURITY_DESCRIPTOR    lpSecurityDescriptor)
    {
        Assert(_schandle != NULL );

        if (::SetServiceObjectSecurity( _schandle,
                dwSecurityInformation, lpSecurityDescriptor))
        {
            return S_OK;
        }
        else
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }


private:
    SC_HANDLE _schandle;
};

//-------------------------------------------------------------------
//
//
//-------------------------------------------------------------------

class CServiceManager
{
public:
    CServiceManager()
    {
        _schandle = NULL;
        _sclock = NULL;
    };

    ~CServiceManager()
    {
        if (_sclock)
        {
            Unlock();
        }
        if (_schandle)
        {
            Close();
        }
    };

    HRESULT HrOpen( DWORD dwDesiredAccess = SC_MANAGER_ALL_ACCESS,
                    LPCTSTR pszMachineName = NULL,
                    LPCTSTR pszDatabaseName = NULL )
    {
        if (_schandle != NULL)
        {
            Close();
        }
        _schandle = ::OpenSCManager( pszMachineName,
                pszDatabaseName,
                dwDesiredAccess );
        if ( _schandle != NULL )
            return S_OK;
        else
            return HRESULT_FROM_WIN32(GetLastError());
    }

    VOID Close()
    {
           BOOL frt;

        Assert(_schandle != NULL );

        frt = ::CloseServiceHandle( _schandle );
        _schandle = NULL;
        AssertSz(frt, "CloseServiceHandle failed!");
    }

    HRESULT HrLock()
    {
        INT                 cRetries = 3;
        static const INT    c_secWait = 30;
        static const INT    c_msecWait = (c_secWait / (cRetries - 1)) * 1000;

        Assert(_schandle != NULL );
        Assert(_sclock == NULL );

        while (cRetries--)
        {
            _sclock = ::LockServiceDatabase( _schandle );
            if (_sclock != NULL)
                return S_OK;
            else
            {
                if (GetLastError() != ERROR_SERVICE_DATABASE_LOCKED ||
                    !cRetries)
                {
                    return HRESULT_FROM_WIN32(GetLastError());
                }

                Trace1("SCM is locked, waiting for %d seconds before retrying...", c_msecWait / 1000);
                // wait for a bit to see if the database unlocks in that
                Sleep(c_msecWait);
            }
        }

        AssertSz(FALSE, "HrLock error");
        return S_OK;
    }

    VOID Unlock()
    {
        BOOL frt;
        Assert(_schandle != NULL );
        Assert(_sclock != NULL );

        frt = ::UnlockServiceDatabase( _sclock );
        _sclock = NULL;
        AssertSz(frt, "UnlockServiceDatabase failed!");
    }

    HRESULT HrQueryLocked(BOOL *pfLocked);

    HRESULT HrOpenService( CService* pcsService,
            LPCTSTR pszServiceName,
            DWORD dwDesiredAccess = SERVICE_ALL_ACCESS )
    {
        // make sure the service is not in use
        if (pcsService->_schandle != NULL)
        {
            pcsService->Close();
        }
        pcsService->_schandle = ::OpenService( _schandle, pszServiceName, dwDesiredAccess );
        if ( pcsService->_schandle != NULL )
            return S_OK;
        else
      {
          DWORD dw=GetLastError();
            return HRESULT_FROM_WIN32(dw);
      }
    }


    HRESULT HrCreateService( CService* pcsService,
            LPCTSTR pszServiceName,
            LPCTSTR pszDisplayName,
            DWORD dwServiceType,
            DWORD dwStartType,
            DWORD dwErrorControl,
            LPCTSTR pszBinaryPathName,
            LPCTSTR pslzDependencies = NULL,
            LPCTSTR pszLoadOrderGroup = NULL,
            PDWORD pdwTagId = NULL,
            DWORD dwDesiredAccess = SERVICE_ALL_ACCESS,
            LPCTSTR pszServiceStartName = NULL,
            LPCTSTR pszPassword = NULL )
    {
        // make sure the service is not in use
        if (pcsService->_schandle != NULL)
        {
            pcsService->Close();
        }
        pcsService->_schandle = ::CreateService( _schandle,
                pszServiceName,
                pszDisplayName,
                dwDesiredAccess,
                dwServiceType,
                dwStartType,
                dwErrorControl,
                pszBinaryPathName,
                pszLoadOrderGroup,
                pdwTagId,
                pslzDependencies,
                pszServiceStartName,
                pszPassword );

        if ( pcsService->_schandle != NULL )
            return S_OK;
        else
            return HRESULT_FROM_WIN32(GetLastError());
    }

    enum SERVICE_START_CRITERIA
    {
        SERVICE_NO_CRITERIA,    // Start the service regardless
        SERVICE_ONLY_AUTO_START // Only start the service if it is of type
                                // Auto-Start
    };

    HRESULT HrStartService(LPCTSTR szService)
    {
        return (HrStartServiceHelper(szService, SERVICE_NO_CRITERIA));
    }

    HRESULT HrStartAutoStartService(LPCTSTR szService)
    {
        return (HrStartServiceHelper(szService, SERVICE_ONLY_AUTO_START));
    }

    HRESULT HrStartServiceHelper(LPCTSTR szService,
                                 SERVICE_START_CRITERIA eCriteria);
    HRESULT HrStopService(LPCTSTR szService);

    enum DEPENDENCY_ADDREMOVE
    {
        DEPENDENCY_ADD,
        DEPENDENCY_REMOVE
    };

    HRESULT HrAddServiceDependency(LPCTSTR szServiceName, LPCTSTR szDependency)
    {
        return HrAddRemoveServiceDependency(szServiceName,
                                            szDependency,
                                            DEPENDENCY_ADD);
    }

    HRESULT HrRemoveServiceDependency(LPCTSTR szServiceName, LPCTSTR szDependency)
    {
        return HrAddRemoveServiceDependency(szServiceName,
                                            szDependency,
                                            DEPENDENCY_REMOVE);
    }

    HRESULT HrAddRemoveServiceDependency(LPCTSTR szServiceName,
                                         LPCTSTR szDependency,
                                         DEPENDENCY_ADDREMOVE enumFlag);

private:
    SC_HANDLE _schandle;
    SC_LOCK   _sclock;
};

#endif // _CSERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\dlgadv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dlgadv.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_DLGADV_H__6B91AFF9_9472_11D1_8574_00C04FC31FD3__INCLUDED_)
#define AFX_DLGADV_H__6B91AFF9_9472_11D1_8574_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgAdv.h : header file
//

#include "helper.h"
#include "qryfrm.h"

#include "listctrl.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgAdvanced dialog
#include "resource.h"
class CDlgAdvanced : public CQryDialog
{
// Construction
public:
	CDlgAdvanced(CWnd* pParent = NULL);   // standard constructor
	virtual void	Init();
	~CDlgAdvanced();

	// Query handle will call these functions through page proc
	virtual HRESULT GetQueryParams(LPDSQUERYPARAMS* ppDsQueryParams);

// Dialog Data
	//{{AFX_DATA(CDlgAdvanced)
	enum { IDD = IDD_QRY_ADVANCED };
	CListCtrlEx		m_listCtrl;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgAdvanced)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgAdvanced)
	afx_msg void OnButtonClearall();
	afx_msg void OnButtonSelectall();
	virtual BOOL OnInitDialog();
	afx_msg void OnWindowPosChanging( WINDOWPOS* lpwndpos );
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	BOOL InitDialog();

	BOOL				m_bDlgInited;
	
	CStrArray			m_strArrayValue;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGADV_H__6B91AFF9_9472_11D1_8574_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\dlggen.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dlggen.cpp
//
//--------------------------------------------------------------------------

// DlgGen.cpp : implementation file
//

#include "stdafx.h"
#include "DlgGen.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgGeneral dialog


CDlgGeneral::CDlgGeneral(CWnd* pParent /*=NULL*/)
	: CQryDialog(CDlgGeneral::IDD, pParent)
{
	Init();
}


void CDlgGeneral::Init()
{
	//{{AFX_DATA_INIT(CDlgGeneral)
	m_bRAS = FALSE;
	m_bLANtoLAN = FALSE;
	m_bDemandDial = FALSE;
	//}}AFX_DATA_INIT
}

void CDlgGeneral::DoDataExchange(CDataExchange* pDX)
{
	CQryDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgGeneral)
	DDX_Check(pDX, IDC_QRY_CHECK_RAS, m_bRAS);
	DDX_Check(pDX, IDC_QRY_CHECK_LANTOLAN, m_bLANtoLAN);
	DDX_Check(pDX, IDC_QRY_CHECK_DEMANDDIAL, m_bDemandDial);
	//}}AFX_DATA_MAP
}




BEGIN_MESSAGE_MAP(CDlgGeneral, CQryDialog)
	//{{AFX_MSG_MAP(CDlgGeneral)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgGeneral message handlers


// Query handle will call these functions through page proc
HRESULT CDlgGeneral::GetQueryParams(LPDSQUERYPARAMS* ppDsQueryParams)
{
	HRESULT	hr = S_OK;
	
	UpdateData(TRUE);

	CString	filter;
	CString	subFilter;

	try
	{
		filter = FILTER_PREFIX;

#if 0	// name field is removed
		// Name Field
		if(m_strName.GetLength() != 0)
		{
			subFilter += FILTER_PREFIX;
			subFilter += ATTR_NAME_DN;
			subFilter += _T("=");
			subFilter += DNPREFIX_ROUTERID;
			subFilter += m_strName;
			subFilter += _T(",*");
			subFilter += FILTER_POSTFIX;
		}

#endif
		if(m_bRAS)
		{
			subFilter += FILTER_PREFIX;
			subFilter += ATTR_NAME_RRASATTRIBUTE;
			subFilter += _T("=");
			subFilter += ATTR_VAL_RAS;
			subFilter += FILTER_POSTFIX;
		}

		if(m_bLANtoLAN)
		{
			subFilter += FILTER_PREFIX;
			subFilter += ATTR_NAME_RRASATTRIBUTE;
			subFilter += _T("=");
			subFilter += ATTR_VAL_LANtoLAN;
			subFilter += FILTER_POSTFIX;
		}

		if(m_bDemandDial)
		{
			subFilter += FILTER_PREFIX;
			subFilter += ATTR_NAME_RRASATTRIBUTE;
			subFilter += _T("=");
			subFilter += ATTR_VAL_DEMANDDIAL;
			subFilter += FILTER_POSTFIX;
		}

		if(subFilter.GetLength())
		{
			filter += _T("&");
			filter += FILTER_PREFIX;
			filter += ATTR_NAME_OBJECTCLASS;
			filter += _T("=");
			filter += ATTR_CLASS_RRASID;
			filter += FILTER_POSTFIX;

			filter += FILTER_PREFIX;
			filter += _T("|");
			filter += subFilter;
			filter += FILTER_POSTFIX;
		}
		else
		{
			filter += ATTR_NAME_OBJECTCLASS;
			filter += _T("=");
			filter += ATTR_CLASS_RRASID;
		}
	
		filter += FILTER_POSTFIX;

		USES_CONVERSION;
		LPWSTR	pQuery = T2W((LPTSTR)(LPCTSTR)filter);

		hr = ::BuildQueryParams(ppDsQueryParams, pQuery);
	}
	catch(CMemoryException* pException)
	{
		pException->Delete();
		hr = E_OUTOFMEMORY;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\dlggen.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dlggen.h
//
//--------------------------------------------------------------------------

#if !defined(AFX_DLGGEN_H__6B91AFFA_9472_11D1_8574_00C04FC31FD3__INCLUDED_)
#define AFX_DLGGEN_H__6B91AFFA_9472_11D1_8574_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgGen.h : header file
//
#include "helper.h"
#include "qryfrm.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgGeneral dialog
#include "resource.h"
class CDlgGeneral : public CQryDialog
{
// Construction
public:
	CDlgGeneral(CWnd* pParent = NULL);   // standard constructor
	virtual void	Init();

	// Query handle will call these functions through page proc
	virtual HRESULT GetQueryParams(LPDSQUERYPARAMS* ppDsQueryParams);

// Dialog Data
	//{{AFX_DATA(CDlgGeneral)
	enum { IDD = IDD_QRY_GENERAL };
	BOOL	m_bRAS;
	BOOL	m_bLANtoLAN;
	BOOL	m_bDemandDial;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgGeneral)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgGeneral)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGGEN_H__6B91AFFA_9472_11D1_8574_00C04FC31FD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\dmvcomp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
*/

#ifndef _DMVCOMP_H
#define _DMVCOMP_H

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

#ifndef _CCDATA_H
#include "ccdata.h"
#endif

#ifndef _COMPONT_H
#include "compont.h"
#endif

#ifndef _RTRSTRM_H
#include "rtrstrm.h"
#endif

#ifndef _COLUMN_H
#include "column.h"
#endif

#ifndef _DMVSTRM_H
#include "dmvstrm.h"
#endif

enum
{
   DM_COLUMNS_DVSUM = 0,
   DM_COLUMNS_IFADMIN=1,
   DM_COLUMNS_DIALIN=2,
   DM_COLUMNS_PORTS = 3,
   DM_COLUMNS_MAX_COUNT,
};

#define COLORREF_PINK	0x00FF00FF

/*---------------------------------------------------------------------------
   CDMVComponentData

   This is the base implementation of ComponentData.  This will be
   incorporated into the two derived classes.
 ---------------------------------------------------------------------------*/

class CDMVComponentData :
   public CComponentData,
   public CComObjectRoot
{
public:
   
BEGIN_COM_MAP(CDMVComponentData)
   COM_INTERFACE_ENTRY(IComponentData)
   COM_INTERFACE_ENTRY(IExtendPropertySheet)
   COM_INTERFACE_ENTRY(IExtendContextMenu)
   COM_INTERFACE_ENTRY(IPersistStreamInit)
   COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

public:        
   // These are the interfaces that we MUST implement

   // We will implement our common behavior here, with the derived
   // classes implementing the specific behavior.
   DeclareIPersistStreamInitMembers(IMPL)
   DeclareITFSCompDataCallbackMembers(IMPL)

   CDMVComponentData();
   ~CDMVComponentData();

   HRESULT FinalConstruct();
   void FinalRelease();
protected:
   SPITFSNodeMgr  m_spNodeMgr;
   
private:
    WATERMARKINFO   m_WatermarkInfo;
};

/////////////////////////////////////////////////////////////////////////////
//
// CDMVComponent
//
/////////////////////////////////////////////////////////////////////////////

class CDMVComponent : 
   public TFSComponent,
   public IPersistStreamInit
{
public:
   CDMVComponent();
   ~CDMVComponent();

   DeclareIUnknownMembers(IMPL)
   DeclareIPersistStreamInitMembers(IMPL)
   DeclareITFSCompCallbackMembers(IMPL)

   // Override OnQueryDataObject, so that we can forward
   // the calls down to the Result Handlers
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject);
   
	STDMETHOD(OnSnapinHelp)(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);
	
//Attributes
protected:
   // This is used to store view information.  A pointer to this
   // object is used as the GetString() lParam.
   DVComponentConfigStream m_ComponentConfig;
};

/////////////////////////////////////////////////////////////////////////////
// Domain View Snapin
class CDomainViewSnap : 
   public CDMVComponentData,
   public CComCoClass<CDomainViewSnap, &CLSID_RouterSnapin>
{
public:
   DECLARE_REGISTRY(CDMVComponentData, 
                _T("DomainViewSnapin.DomainViewSnapin.1"), 
                _T("DomainViewSnapin.DomainViewSnapin"), 
                IDS_DMV_DESC, THREADFLAGS_APARTMENT)
    STDMETHOD_(const CLSID *,GetCoClassID()){ return &CLSID_RouterSnapin; }
};

class CDomainViewSnapExtension : 
    public CDMVComponentData,
    public CComCoClass<CDomainViewSnapExtension, &CLSID_RouterSnapinExtension>
{
public:
   DECLARE_REGISTRY(CDomainViewSnapExtension, 
                _T("CDomainViewSnapExtension.CDomainViewSnapExtension.1"), 
                _T("CDomainViewSnapExtension.CDomainViewSnapExtension"), 
                IDS_DMV_DESC, THREADFLAGS_APARTMENT)
    STDMETHODIMP_(const CLSID *)GetCoClassID() { return &CLSID_RouterSnapinExtension; }
};

/*---------------------------------------------------------------------------
   This is the derived class for handling the IAbout interface from MMC
   Author: EricDav
 ---------------------------------------------------------------------------*/
class CDomainViewSnapAbout : 
   public CAbout,
    public CComCoClass<CDomainViewSnapAbout, &CLSID_RouterSnapinAbout>
{
public:
DECLARE_REGISTRY(CDomainViewSnapAbout, 
             _T("DomainViewSnapin.About.1"), 
             _T("DomainViewSnapin.About"), 
             IDS_SNAPIN_DESC, 
             THREADFLAGS_BOTH)

BEGIN_COM_MAP(CDomainViewSnapAbout)
    COM_INTERFACE_ENTRY(ISnapinAbout) // Must have one static entry
   COM_INTERFACE_ENTRY_CHAIN(CAbout) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CDomainViewSnapAbout)

// these must be overridden to provide values to the base class

//???? need to change to doamin
protected:
   virtual UINT GetAboutDescriptionId() { return IDS_DMV_ABOUT_DESCRIPTION; }
   virtual UINT GetAboutProviderId()    { return IDS_ABOUT_PROVIDER; }
   virtual UINT GetAboutVersionId()     { return IDS_ABOUT_VERSION; }
   virtual UINT GetAboutIconId()        { return IDI_SNAPIN_ICON; }

   virtual UINT GetSmallRootId()        { return IDB_ROOT_SMALL; }
   virtual UINT GetSmallOpenRootId()    { return IDB_ROOT_SMALL; }
   virtual UINT GetLargeRootId()        { return IDB_ROOT_LARGE; }
   virtual COLORREF GetLargeColorMask() { return (COLORREF) COLORREF_PINK; } 
};


#endif _DMVCOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\dmvroot.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
   root.h
      Root node information (the root node is not displayed
      in the MMC framework but contains information such as 
      all of the subnodes in this snapin).
      
    FILE HISTORY:
        
*/

#ifndef _DMVROOT_H
#define _DMVROOT_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _QUERYOBJ_H
#include "queryobj.h"
#endif

#ifndef _ATLKSTRM_H
#include "ATLKstrm.h"
#endif

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _ROOT_H
#include "root.h"
#endif

#ifndef _MACHINE_H
#include "machine.h"
#endif

#ifndef AFX_DLGSVR_H__19556672_96AB_11D1_8575_00C04FC31FD3__INCLUDED_
#include "rrasqry.h"
#endif

#ifndef _DMVSTRM_H
#include "dmvstrm.h"
#endif
   
#include "refresh.h"

#define COMPUTERNAME_LEN_MAX        255

// forward declarations
struct SDMVNodeMenu;
class RouterRefreshObject;


// container for domain view's servers
// and lists to facilitate lazy expansion of nodes
class CServerList
{
public:

	CServerList() {};
   
	~CServerList() 
	{
		removeall();
	}
	
	//add a server to this container; adds to lazy containers
	HRESULT AddServer(const CString& servername);

    // removes a aserver from this container, removes from lazy also
    HRESULT RemoveServer(LPCTSTR pszServerName);
	
	//empty all containers
	HRESULT	RemoveAllServerNodes();
	HRESULT	RemoveAllServerHandlers();
	HRESULT removeall();
	
private:
	
	list<MachineNodeData *> m_listServerNodesToExpand;
	list<MachineNodeData *> m_listServerHandlersToExpand;

	friend class DMVRootHandler;
	friend class DomainStatusHandler;
};


// Class:   DMVRootHandler
//
// There should be a DMVRootHandler for every root node created.
// DMVRootHandler's have a 1-to-1 relationship with their node!
// Other parts of the code depend on this.


// These are the valid values for the DMVRootHandler UserNotify()
#define DMV_DELETE_SERVER_ENTRY (100)

class DMVRootHandler
      : public RootHandler
{
public:
   DMVRootHandler(ITFSComponentData *pCompData);
   ~DMVRootHandler();

   // Override QI to handle embedded interface
   STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);

   OVERRIDE_NodeHandler_HasPropertyPages();
   OVERRIDE_NodeHandler_CreatePropertyPages();
   OVERRIDE_NodeHandler_GetString();

   STDMETHOD(GetClassID)(CLSID *pClassId);

   // Notification overrides
   OVERRIDE_BaseHandlerNotify_OnExpand();

   HRESULT	LoadPersistedServerList();
   HRESULT	LoadPersistedServerListFromNode();

	// this needs the full function of RouterRefreshObject, so use RouterRefreshObject directly
   HRESULT	GetSummaryNodeRefreshObject(RouterRefreshObject** ppRefresh);
   
   HRESULT	GetServerNodesRefreshObject(IRouterRefresh** ppRefresh);

	static HRESULT	UpdateAllMachineIcons(ITFSNode* pRootNode);
	
    // Structure used to pass data to callbacks - used as a way of
    // avoiding recomputation
    struct SMenuData
    {
        SPITFSNode     m_spNode;
        DMVRootHandler *m_pDMVRootHandler;        // non-AddRef'd
    };

   // Handler overrides
   OVERRIDE_NodeHandler_OnCreateDataObject();
   OVERRIDE_NodeHandler_DestroyHandler();
   OVERRIDE_NodeHandler_OnAddMenuItems();
   OVERRIDE_NodeHandler_OnCommand();
   OVERRIDE_NodeHandler_UserNotify();

    // result handler overrides -- result pane message
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();

    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
    OVERRIDE_ResultHandler_OnGetResultViewType();

	// Help support
	OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp();

   HRESULT  Init(ITFSNode* pNode);
   
   // virtual function to access config stream
   ConfigStream *    GetConfigStream()
         { return &m_ConfigStream; }
	static ULONG GetAutoRefreshFlags(const SRouterNodeMenu *pMenuData,
                                     INT_PTR pUserData);
         
    // result message view helper
    void    UpdateResultMessage(ITFSNode * pNode);

protected:

   bool               m_bExpanded;
   
   CServerList        m_serverlist;           
   
   SPIRtrMgrInfo      m_spRm;
   LONG_PTR			  m_ulConnId; // connection id for RtrMgr
   BOOL               m_fAddedProtocolNode;
   CString            m_strDomainName;

   DMVConfigStream     m_ConfigStream;
   

   HRESULT QryAddServer(ITFSNode *pNode);
   HRESULT AddServersToList(const CStringArray& sa, ITFSNode *pNode);
   
   HRESULT ExecServerQry(ITFSNode* pNode);
   
   DomainStatusHandler* m_pStatusHandler;
   SPITFSNode m_spStatusNode;
   SPIRouterRefresh m_spServerNodesRefreshObject;
   SPRouterRefreshObject m_spSummaryModeRefreshObject;
   RouterRefreshObjectGroup	m_RefreshGroup;
};




#endif _DMVROOT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\dmvstrm.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
   DVSumSTRM.cpp
      
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "dmvstrm.h"
#include "dmvcomp.h"
#include "xstream.h"
#include "dmvroot.h"
#include "refresh.h"

#define CURRENT_DMVCONFIGSTREAM_VERSION   0x00020000

/*!--------------------------------------------------------------------------
   DMVConfigStream::DMVConfigStream
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
DMVConfigStream::DMVConfigStream()
{
   m_nVersionAdmin = 0x00010000;
   m_nVersion = CURRENT_DMVCONFIGSTREAM_VERSION;
   m_bAutoRefresh = FALSE;
   m_dwRefreshInterval = DEFAULT_REFRESH_INTERVAL;
}

/*!--------------------------------------------------------------------------
   DMVConfigStream::InitNew
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DMVConfigStream::InitNew()
{
   // Setup the appropriate defaults
// m_nVersionAdmin = 0x00020000;
// m_nVersion = 0x00020000;
// m_stName.Empty();
   return hrOK;
}

HRESULT DMVConfigStream::PrepareAutoRefreshDataForSave()
{
	SPIRouterRefresh	spRefresh;

	ASSERT(m_pDMVRootHandler);
	if (!m_pDMVRootHandler)
		return S_OK;
		
	HRESULT hr = m_pDMVRootHandler->GetServerNodesRefreshObject(&spRefresh);

	if(FAILED(hr) || !spRefresh)
		return S_OK;

	if(spRefresh->IsRefreshStarted() == hrOK)
		m_bAutoRefresh =  TRUE;
	return spRefresh->GetRefreshInterval(&m_dwRefreshInterval);
}

/*!--------------------------------------------------------------------------
   DMVConfigStream::SaveTo
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DMVConfigStream::SaveTo(IStream *pstm)
{
   return XferVersion0(pstm, XferStream::MODE_WRITE, NULL);
}

/*!--------------------------------------------------------------------------
   DMVConfigStream::SaveAs
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DMVConfigStream::SaveAs(UINT nVersion, IStream *pstm)
{
   return XferVersion0(pstm, XferStream::MODE_WRITE, NULL);
}

/*!--------------------------------------------------------------------------
   DMVConfigStream::LoadFrom
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DMVConfigStream::LoadFrom(IStream *pstm)
{
   return XferVersion0(pstm, XferStream::MODE_READ, NULL);
}

/*!--------------------------------------------------------------------------
   DMVConfigStream::GetSize
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DMVConfigStream::GetSize(ULONG *pcbSize)
{
   return XferVersion0(NULL, XferStream::MODE_SIZE, NULL);
}

/*!--------------------------------------------------------------------------
   DMVConfigStream::GetVersionInfo
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DMVConfigStream::GetVersionInfo(DWORD *pdwVersion, DWORD *pdwAdminVersion)
{
   if (pdwVersion)
      *pdwVersion = m_nVersion;
   if (pdwAdminVersion)
      *pdwAdminVersion = m_nVersionAdmin;
   return hrOK;
}

/*!--------------------------------------------------------------------------
   DMVConfigStream::XferVersion0
      -
   Author: KennT
 ---------------------------------------------------------------------------*/


struct _ViewInfoEntry
{
   ULONG m_ulId;
   ULONG m_idSort;
   ULONG m_idAscending;
   ULONG m_idColumns;
   ULONG m_idPos;
};

/*static const _ViewInfoEntry s_rgDVSumAdminViewInfo[]
{
 { DVSumSTRM_STATS_DVSumNBR,
    DVSumSTRM_TAG_STATS_DVSumNBR_SORT, DVSumSTRM_TAG_STATS_DVSumNBR_ASCENDING,
    DVSumSTRM_TAG_STATS_DVSumNBR_COLUMNS, DVSumSTRM_TAG_STATS_DVSumNBR_POSITION },
 { DVSumSTRM_IFSTATS_DVSumNBR,
    DVSumSTRM_TAG_IFSTATS_DVSumNBR_SORT, DVSumSTRM_TAG_IFSTATS_DVSumNBR_ASCENDING,
    DVSumSTRM_TAG_IFSTATS_DVSumNBR_COLUMNS, DVSumSTRM_TAG_IFSTATS_DVSumNBR_POSITION },
};
*/     

HRESULT DMVConfigStream::XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize)
{
	XferStream  xstm(pstm, mode);
	HRESULT     hr = hrOK;
	DWORD dwNum1;
	DWORD dwNum2;
	int i;
	
	if (mode==XferStream::MODE_WRITE)
	{
		// If we are writing the data, reload the current set of server names
		// (get it from the real list of nodes)
		// -------------------------------------------------------------
		Assert(m_pDMVRootHandler);
		m_pDMVRootHandler->LoadPersistedServerListFromNode();
	};
	
	CORg( xstm.XferDWORD( DMVSTRM_TAG_VERSION, &m_nVersion ) );
	CORg( xstm.XferDWORD( DMVSTRM_TAG_VERSIONADMIN, &m_nVersionAdmin ) );
	
	if (m_nVersion != CURRENT_DMVCONFIGSTREAM_VERSION)
		return E_FAIL;
	
/*   
   for ( i=0; i<DimensionOf(s_rgDVSumAdminViewInfo); i++)
   {
      CORg( m_rgViewInfo[s_rgDVSumAdminViewInfo[i].m_ulId].Xfer(&xstm,
         s_rgDVSumAdminViewInfo[i].m_idSort,
         s_rgDVSumAdminViewInfo[i].m_idAscending,
         s_rgDVSumAdminViewInfo[i].m_idColumns) );
      CORg( xstm.XferRect( s_rgDVSumAdminViewInfo[i].m_idPos,
                      &m_prgrc[s_rgDVSumAdminViewInfo[i].m_ulId]) );
   }
*/
	
	CORg( xstm.XferDWORD( DMVSTRM_TAG_SIZEQRY, &(m_RQPersist.m_dwSizeQry) ) );
	
	if (mode==XferStream::MODE_READ)
	{
		CORg( xstm.XferDWORD( DMVSTRM_TAG_NUMQRY, &(dwNum1) ) );
		m_RQPersist.createQry(dwNum1);
		CORg( xstm.XferDWORD( DMVSTRM_TAG_NUMSRV, &(dwNum2) ) );
		m_RQPersist.createSrv(dwNum2);
	}
	else
	{
		CORg( xstm.XferDWORD( DMVSTRM_TAG_NUMQRY, &(m_RQPersist.m_dwNumQry) ) );
		CORg( xstm.XferDWORD( DMVSTRM_TAG_NUMSRV, &(m_RQPersist.m_dwNumSrv) ) );
	}
	
	Assert(m_RQPersist.m_v_pQData.size()==m_RQPersist.m_dwNumQry);
	Assert(m_RQPersist.m_v_pSData.size()==m_RQPersist.m_dwNumSrv);
	
	//persist the query list
	for (i=0; i < m_RQPersist.m_dwNumQry;i++)
	{
		CORg( xstm.XferDWORD( DMVSTRM_TAG_CATFLAG, &(m_RQPersist.m_v_pQData[i]->dwCatFlag) ) );
		CORg( xstm.XferCString( DMVSTRM_TAG_SCOPE, &(m_RQPersist.m_v_pQData[i]->strScope) ) );
		CORg( xstm.XferCString( DMVSTRM_TAG_FILTER, &(m_RQPersist.m_v_pQData[i]->strFilter) ) );
	}   
	
	//persist the servername list
	for (i=0; i < m_RQPersist.m_dwNumSrv;i++)
	{
		CORg( xstm.XferCString(DMVSTRM_TAG_SERVERNAME, m_RQPersist.m_v_pSData[i]) );
	}   
	
	if (mode==XferStream::MODE_READ)
	{
		// Load the list of persisted servers (add them to the list of
		// servers to be added into the UI).
		Assert(m_pDMVRootHandler);
		m_pDMVRootHandler->LoadPersistedServerList();
	}

	// refresh settings
	if (mode==XferStream::MODE_WRITE)
	{
		PrepareAutoRefreshDataForSave();
	}
	CORg( xstm.XferDWORD( DMVSTRM_TAG_IFAUTOREFRESHISON, &m_bAutoRefresh ) );
	CORg( xstm.XferDWORD( DMVSTRM_TAG_AUTOREFRESHINTERVAL, &m_dwRefreshInterval ) );
	
	if (pcbSize)
		*pcbSize = xstm.GetSize();
	
Error:
	return hr;
}



/*---------------------------------------------------------------------------
   DVSumComponentConfigStream implementation
 ---------------------------------------------------------------------------*/

enum DVSCOMPSTRM_TAG
{
   DVSCOMPSTRM_TAG_VERSION =     XFER_TAG(1, XFER_DWORD),
   DVSCOMPSTRM_TAG_VERSIONADMIN =   XFER_TAG(2, XFER_DWORD),
   
   DVSCOMPSTRM_TAG_SUMMARY_COLUMNS = XFER_TAG(3, XFER_COLUMNDATA_ARRAY),
   DVSCOMPSTRM_TAG_SUMMARY_SORT_COLUMN = XFER_TAG(4, XFER_DWORD),
   DVSCOMPSTRM_TAG_SUMMARY_SORT_ASCENDING = XFER_TAG(5, XFER_DWORD),

   DVSCOMPSTRM_TAG_IFADMIN_COLUMNS = XFER_TAG(6, XFER_COLUMNDATA_ARRAY),
   DVSCOMPSTRM_TAG_IFADMIN_SORT_COLUMN = XFER_TAG(7, XFER_DWORD),
   DVSCOMPSTRM_TAG_IFADMIN_SORT_ASCENDING = XFER_TAG(8, XFER_DWORD),

   DVSCOMPSTRM_TAG_DIALIN_COLUMNS = XFER_TAG(9, XFER_COLUMNDATA_ARRAY),
   DVSCOMPSTRM_TAG_DIALIN_SORT_COLUMN = XFER_TAG(10, XFER_DWORD),
   DVSCOMPSTRM_TAG_DIALIN_SORT_ASCENDING = XFER_TAG(11, XFER_DWORD),

   DVSCOMPSTRM_TAG_PORTS_COLUMNS = XFER_TAG(12, XFER_COLUMNDATA_ARRAY),
   DVSCOMPSTRM_TAG_PORTS_SORT_COLUMN = XFER_TAG(13, XFER_DWORD),
   DVSCOMPSTRM_TAG_PORTS_SORT_ASCENDING = XFER_TAG(14, XFER_DWORD),

};



HRESULT DVComponentConfigStream::XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize)
{
   XferStream  xstm(pstm, mode);
   HRESULT     hr = hrOK;

   CORg( xstm.XferDWORD( DVSCOMPSTRM_TAG_VERSION, &m_nVersion ) );
   CORg( xstm.XferDWORD( DVSCOMPSTRM_TAG_VERSIONADMIN, &m_nVersionAdmin ) );

   CORg( m_rgViewInfo[DM_COLUMNS_DVSUM].Xfer(&xstm,
                              DVSCOMPSTRM_TAG_SUMMARY_SORT_COLUMN,
                              DVSCOMPSTRM_TAG_SUMMARY_SORT_ASCENDING,
                              DVSCOMPSTRM_TAG_SUMMARY_COLUMNS) );
   CORg( m_rgViewInfo[DM_COLUMNS_IFADMIN].Xfer(&xstm,
                              DVSCOMPSTRM_TAG_IFADMIN_SORT_COLUMN,
                              DVSCOMPSTRM_TAG_IFADMIN_SORT_ASCENDING,
                              DVSCOMPSTRM_TAG_IFADMIN_COLUMNS) );
   CORg( m_rgViewInfo[DM_COLUMNS_DIALIN].Xfer(&xstm,
                              DVSCOMPSTRM_TAG_DIALIN_SORT_COLUMN,
                              DVSCOMPSTRM_TAG_DIALIN_SORT_ASCENDING,
                              DVSCOMPSTRM_TAG_DIALIN_COLUMNS) );
   CORg( m_rgViewInfo[DM_COLUMNS_PORTS].Xfer(&xstm,
                              DVSCOMPSTRM_TAG_PORTS_SORT_COLUMN,
                              DVSCOMPSTRM_TAG_PORTS_SORT_ASCENDING,
                              DVSCOMPSTRM_TAG_PORTS_COLUMNS) );
   
   if (pcbSize)
      *pcbSize = xstm.GetSize();

Error:
   return hr;
}


//---------------------------------------------------------------
// RRASQryPersist implementation
//---------------------------------------------------------------
HRESULT RRASQryPersist::createQry(DWORD dwNum)
{
    HRESULT hr=S_OK;
    try
    {
       removeAllQry();
     
       m_dwNumQry=dwNum;  
                   
       for (int i=0;i<m_dwNumQry;i++)
       {
          RRASQryData* p = new  RRASQryData;
          p->dwCatFlag=RRAS_QRY_CAT_NONE;
          p->strScope=_T("");
          p->strFilter=_T("");
          m_v_pQData.push_back(p);
       }
    }
    catch(...)
    {
       hr=E_FAIL;
    }
    return hr;
}

HRESULT RRASQryPersist::createSrv(DWORD dwNum)
{
    HRESULT hr=S_OK;
    try
    {
       removeAllSrv();
     
       m_dwNumSrv=dwNum;  
                   
       for (int i=0;i<m_dwNumSrv;i++)
          m_v_pSData.push_back(new CString);
    }
    catch(...)
    {
       hr=E_FAIL;
    }
    return hr;
}

HRESULT RRASQryPersist::add_Qry(const RRASQryData& qd)
{
    HRESULT hr=S_OK;
    try
    {
       for (int i=0;i<m_v_pQData.size(); i++ )
       {
           RRASQryData& qd0 = *(m_v_pQData[i]);
           if ( (qd0.dwCatFlag==qd.dwCatFlag) &&
                (qd0.strScope==qd.strScope) &&                    
                (qd0.strFilter==qd.strFilter) )
           return S_FALSE;
       }
    
       RRASQryData *pqd= new RRASQryData ;
       pqd->dwCatFlag=qd.dwCatFlag;
       pqd->strScope=qd.strScope;
       pqd->strFilter=qd.strFilter;
       m_v_pQData.push_back(pqd);
       m_dwNumQry++;
    }
    catch(...)
    {
       hr=E_FAIL;
    }
    return hr;
}

HRESULT RRASQryPersist::add_Srv(const CString& szServer)
{
    HRESULT hr=S_OK;
    
    try
    {
       for (int i=0;i<m_v_pSData.size(); i++ )
       {
           if ( szServer==*(m_v_pSData[i]) )
              return S_FALSE;
       }
    
       CString* psz= new CString(szServer) ;
       m_v_pSData.push_back(psz);
       m_dwNumSrv++;
    }
    catch(...)
    {
       hr=E_FAIL;
    }
    return hr;
}

HRESULT RRASQryPersist::removeAllSrv()
{
    HRESULT hr=S_OK;
    try
    {
       for (int i=0;i<m_v_pSData.size(); i++ )
          delete m_v_pSData[i];
       m_v_pSData.clear();          
    }
    catch(...)
    {
       hr=E_FAIL;
    }
    m_dwNumSrv=0;
    return hr;
}

HRESULT RRASQryPersist::removeAllQry()
{
    HRESULT hr=S_OK;
    try
    {
       for (int i=0;i<m_v_pQData.size(); i++ )
          delete m_v_pQData[i];
       m_v_pQData.clear();          
    }
    catch(...)
    {
       TRACE0("RRASQryPersist::remove error\n");
       hr=E_FAIL;
    }
    m_dwNumQry=0;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\dmvcomp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
*/

#include "stdafx.h"
//nclude "rtrcomp.h"    // columns information
#include "htmlhelp.h"
#include "dmvstrm.h"
#include "dmvcomp.h"
#include "dmvroot.h"
#include "dvsview.h"

#include "statreg.h"
#include "statreg.cpp"
#include "atlimpl.cpp"

#include "ifadmin.h"
#include "dialin.h"
#include "ports.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/*---------------------------------------------------------------------------
	Icon list

	This is used to initialize the image list.
 ---------------------------------------------------------------------------*/
UINT g_uIconMap[IMAGE_IDX_MAX + 1][2] = 
{
	{ IDI_FOLDER_OPEN,				IMAGE_IDX_FOLDER_OPEN },
	{ IDI_FOLDER_CLOSED ,			IMAGE_IDX_FOLDER_CLOSED},
	{ IDI_MACHINE,					IMAGE_IDX_MACHINE },
	{ IDI_MACHINE_ERROR,			IMAGE_IDX_MACHINE_ERROR },
	{ IDI_MACHINE_ACCESS_DENIED,	IMAGE_IDX_MACHINE_ACCESS_DENIED },
	{ IDI_MACHINE_STARTED,			IMAGE_IDX_MACHINE_STARTED },
	{ IDI_MACHINE_STOPPED,			IMAGE_IDX_MACHINE_STOPPED },
	{ IDI_MACHINE_WAIT,				IMAGE_IDX_MACHINE_WAIT },
	{ IDI_DOMAIN,					IMAGE_IDX_DOMAIN },
	{ IDI_NET_INTERFACES,			IMAGE_IDX_INTERFACES },
	{ IDI_NET_LAN_CARD,				IMAGE_IDX_LAN_CARD },
	{ IDI_NET_WAN_CARD,				IMAGE_IDX_WAN_CARD },
    {0, 0}
};




/*---------------------------------------------------------------------------
   CDomainComponent
 ---------------------------------------------------------------------------*/



/////////////////////////////////////////////////////////////////////////////
// CDomainComponent implementation

CDMVComponent::CDMVComponent()
{
   extern const ContainerColumnInfo s_rgDVSViewColumnInfo[];
   extern const ContainerColumnInfo s_rgIfAdminColumnInfo[];
   extern const ContainerColumnInfo s_rgDialInColumnInfo[];
   extern const ContainerColumnInfo s_rgPortsColumnInfo[];

   m_ComponentConfig.Init(DM_COLUMNS_MAX_COUNT);
   
   m_ComponentConfig.InitViewInfo(DM_COLUMNS_DVSUM,
                                  FALSE /* configurable columns */,
                                  DVS_SI_MAX_COLUMNS,
								  TRUE, 
								  s_rgDVSViewColumnInfo);

   m_ComponentConfig.InitViewInfo(DM_COLUMNS_IFADMIN,
                                  FALSE /* configurable columns */,
                                  IFADMIN_MAX_COLUMNS,
								  TRUE,
								  s_rgIfAdminColumnInfo);

   m_ComponentConfig.InitViewInfo(DM_COLUMNS_DIALIN,
                                  FALSE /* configurable columns */,
                                  DIALIN_MAX_COLUMNS,
								  TRUE,
								  s_rgDialInColumnInfo);

   m_ComponentConfig.InitViewInfo(DM_COLUMNS_PORTS,
                                  FALSE /* configurable columns */,
                                  PORTS_MAX_COLUMNS,
								  TRUE,
								  s_rgPortsColumnInfo);

   m_ulUserData = reinterpret_cast<LONG_PTR>(&m_ComponentConfig);
}

CDMVComponent::~CDMVComponent()
{
}

STDMETHODIMP_(ULONG) CDMVComponent::AddRef()
{
   return TFSComponent::AddRef();
}

STDMETHODIMP_(ULONG) CDMVComponent::Release()
{
   return TFSComponent::Release();
}

STDMETHODIMP CDMVComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
    // Is the pointer bad?
    if (ppv == NULL)
      return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

   if (riid == IID_IPersistStreamInit)
      *ppv = static_cast<IPersistStreamInit *>(this);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN) *ppv)->AddRef();
      return hrOK;
    }
    else
      return TFSComponent::QueryInterface(riid, ppv);
}



STDMETHODIMP CDMVComponent::OnUpdateView(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param)
{
   
   return TFSComponent::OnUpdateView(pDataObject, arg, param);
}

STDMETHODIMP CDMVComponent::InitializeBitmaps(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(m_spImageList != NULL);

	HRESULT  hr = hrOK;

	COM_PROTECT_TRY
	{
		// Set the images
		HICON   hIcon;
		
		for (int i = 0; i < IMAGE_IDX_MAX; i++)
		{
			hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
			if (hIcon)
			{
				// call mmc
				m_spImageList->ImageListSetIcon(reinterpret_cast<LONG_PTR*>(hIcon), g_uIconMap[i][1]);
			}
		}
		
	}
	COM_PROTECT_CATCH;

    return hr;
}

STDMETHODIMP CDMVComponent::QueryDataObject(MMC_COOKIE cookie,
                                    DATA_OBJECT_TYPES type,
                                    LPDATAOBJECT *ppDataObject)
{
   HRESULT     hr = hrOK;
   SPITFSNode  spNode;
   SPITFSResultHandler  spResultHandler;

   COM_PROTECT_TRY
   {
      CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

      CORg( spNode->GetResultHandler(&spResultHandler) );

      CORg( spResultHandler->OnCreateDataObject(this, cookie,
         type, ppDataObject) );

      COM_PROTECT_ERROR_LABEL;
   }
   COM_PROTECT_CATCH;
   return hr;
}


/*!--------------------------------------------------------------------------
    CDMVComponent::OnSnapinHelp
        -
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CDMVComponent::OnSnapinHelp
(
    LPDATAOBJECT    pDataObject,
    LPARAM            arg,
    LPARAM            param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	SPIConsole	spConsole;
	HWND		hwndMain;

    HRESULT hr = hrOK;

	GetConsole(&spConsole);
	spConsole->GetMainWindow(&hwndMain);
	HtmlHelpA(hwndMain, "mprsnap.chm", HH_DISPLAY_TOPIC, 0);

    return hr;
}


STDMETHODIMP CDMVComponent::GetClassID(LPCLSID lpClassID)
{
    ASSERT(lpClassID != NULL);

    // Copy the CLSID for this snapin
    *lpClassID = CLSID_RouterSnapin;

    return hrOK;
}

STDMETHODIMP CDMVComponent::IsDirty()
{
   HRESULT  hr = hrOK;
   COM_PROTECT_TRY
   {     
      hr = m_ComponentConfig.GetDirty() ? hrOK : hrFalse;
   }
   COM_PROTECT_CATCH;
   return hr;
}
STDMETHODIMP CDMVComponent::Load(LPSTREAM pStm)
{
   HRESULT  hr = hrOK;
   COM_PROTECT_TRY
   {     
   hr = m_ComponentConfig.LoadFrom(pStm);
   }
   COM_PROTECT_CATCH;
   return hr;
}
STDMETHODIMP CDMVComponent::Save(LPSTREAM pStm, BOOL fClearDirty)
{
	HRESULT  hr = hrOK;
	SPITFSResultHandler	spResultHandler;
	COM_PROTECT_TRY
	{
		// Need to see if we can save the selected node
		// -------------------------------------------------------------
		if (m_spSelectedNode)
		{
			m_spSelectedNode->GetResultHandler(&spResultHandler);
			if (spResultHandler)
				spResultHandler->UserResultNotify(m_spSelectedNode,
					RRAS_ON_SAVE, (LPARAM)(ITFSComponent *) this);
		}
		hr = m_ComponentConfig.SaveTo(pStm);
		if (FHrSucceeded(hr) && fClearDirty)
			m_ComponentConfig.SetDirty(FALSE);
	}
	COM_PROTECT_CATCH;
	return hr;
}
STDMETHODIMP CDMVComponent::GetSizeMax(ULARGE_INTEGER FAR *pcbSize)
{
   Assert(pcbSize);
   HRESULT  hr = hrOK;
   ULONG cbSize = 0;

   COM_PROTECT_TRY
   {
      hr = m_ComponentConfig.GetSize(&cbSize);
      if (FHrSucceeded(hr))
      {
         pcbSize->HighPart = 0;
         pcbSize->LowPart = cbSize;
      }
   }
   COM_PROTECT_CATCH;
   return hr;
}
STDMETHODIMP CDMVComponent::InitNew()
{
   HRESULT  hr = hrOK;
   COM_PROTECT_TRY
   {     
      hr = m_ComponentConfig.InitNew();
   }
   COM_PROTECT_CATCH;
   return hr;
}






/////////////////////////////////////////////////////////////////////////////
// CDomainComponentData implementation

CDMVComponentData::CDMVComponentData()
{
}

/*!--------------------------------------------------------------------------
   CDomainComponentData::OnInitialize
      -
   Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CDMVComponentData::OnInitialize(LPIMAGELIST pScopeImage)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Set the images
	HICON   hIcon;
		
	Assert(pScopeImage);

	// add the images for the scope tree

	HRESULT  hr = hrOK;

	COM_PROTECT_TRY
	{
		for (int i = 0; i < IMAGE_IDX_MAX; i++)
		{
			hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
			if (hIcon)
			{
				// call mmc
				VERIFY(SUCCEEDED(pScopeImage->ImageListSetIcon(reinterpret_cast<LONG_PTR*>(hIcon), g_uIconMap[i][1])));
			}
		}
	}
	COM_PROTECT_CATCH;

	return hr;
}


/*!--------------------------------------------------------------------------
   CDomainComponentData::OnInitializeNodeMgr
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CDMVComponentData::OnInitializeNodeMgr(ITFSComponentData *pTFSCompData, ITFSNodeMgr *pNodeMgr)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
   // For now create a new node handler for each new node,
   // this is rather bogus as it can get expensive.  We can
   // consider creating only a single node handler for each
   // node type.
   DMVRootHandler *  pHandler = NULL;
   SPITFSNodeHandler spHandler;
   SPITFSNode        spNode;
   HRESULT           hr = hrOK;

   COM_PROTECT_TRY
   {
      pHandler = new DMVRootHandler(pTFSCompData);

      // Do this so that it will get released correctly
      spHandler = pHandler;
   
      // Create the root node for this sick puppy
      CORg( CreateContainerTFSNode(&spNode,
                            &GUID_RouterDomainNodeType,
                            pHandler,
                            pHandler /* result handler */,
                            pNodeMgr) );

      // Construct the node
      CORg( pHandler->ConstructNode(spNode) );
      
      CORg( pHandler->Init(spNode) );

      CORg( pNodeMgr->SetRootNode(spNode) );
      
	  // setup watermark info
      /*
	  InitWatermarkInfo(AfxGetInstanceHandle(),
						&m_WatermarkInfo,      
						IDB_WIZBANNER,        // Header ID
						IDB_WIZWATERMARK,     // Watermark ID
						NULL,                 // hPalette
						FALSE);                // bStretch
	  
	  pTFSCompData->SetWatermarkInfo(&m_WatermarkInfo);
	  */
	  // Reference the help file name.
		pTFSCompData->SetHTMLHelpFileName(_T("mprsnap.chm"));

      COM_PROTECT_ERROR_LABEL;
   }
   COM_PROTECT_CATCH;

   return hr;
}

CDMVComponentData::~CDMVComponentData()
{
	//ResetWatermarkInfo(&m_WatermarkInfo);
}

/*!--------------------------------------------------------------------------
   CDomainComponentData::OnCreateComponent
      -
   Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CDMVComponentData::OnCreateComponent(LPCOMPONENT *ppComponent)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(ppComponent != NULL);
   
   HRESULT     hr = hrOK;
   CDMVComponent *   pComp = NULL;

   COM_PROTECT_TRY
   {
      pComp = new CDMVComponent;

      if (FHrSucceeded(hr))
      {
         pComp->Construct(m_spNodeMgr,
                      static_cast<IComponentData *>(this),
                      m_spTFSComponentData);
         *ppComponent = static_cast<IComponent *>(pComp);
      }
   }
   COM_PROTECT_CATCH;
   
   return hr;
}


STDMETHODIMP CDMVComponentData::OnDestroy()
{
   m_spNodeMgr.Release();
   return hrOK;
}

/*!--------------------------------------------------------------------------
   CDomainComponentData::GetCoClassID
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(const CLSID *) CDMVComponentData::GetCoClassID()
{
   return &CLSID_RouterSnapin;
}

/*!--------------------------------------------------------------------------
   CDomainComponentData::OnCreateDataObject
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CDMVComponentData::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   Assert(ppDataObject != NULL);

   CDataObject *  pObject = NULL;
   SPIDataObject  spDataObject;
   HRESULT        hr = hrOK;
   SPITFSNode     spNode;
   SPITFSNodeHandler spHandler;

   if ( IS_SPECIAL_COOKIE(cookie) )
   {
       CDataObject * pObject = NULL;
       SPIDataObject spDataObject;
   
       pObject = new CDataObject;
       spDataObject = pObject;   // do this so that it gets released correctly
                  
       Assert(pObject != NULL);

       // Save cookie and type for delayed rendering
       pObject->SetType(type);
       pObject->SetCookie(cookie);

       // Store the coclass with the data object
       pObject->SetClsid(CLSID_RouterSnapin);

       pObject->SetTFSComponentData(m_spTFSComponentData);

       hr = pObject->QueryInterface(IID_IDataObject, reinterpret_cast<void**>(ppDataObject));
   }
   else
   {
	   COM_PROTECT_TRY
	   {
		  CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

		  CORg( spNode->GetHandler(&spHandler) );

		  CORg( spHandler->OnCreateDataObject(cookie, type, &spDataObject) );

		  *ppDataObject = spDataObject.Transfer();
      
		  COM_PROTECT_ERROR_LABEL;
	   }
	   COM_PROTECT_CATCH;
   }

   return hr;
}


///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members

STDMETHODIMP CDMVComponentData::GetClassID
(
   CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_RouterSnapin;

    return hrOK;
}

STDMETHODIMP CDMVComponentData::IsDirty()
{
   SPITFSNode  spNode;
   SPITFSNodeHandler spHandler;
   SPIPersistStreamInit spStm;
   
   m_spNodeMgr->GetRootNode(&spNode);
   spNode->GetHandler(&spHandler);
   spStm.Query(spHandler);
   Assert(spStm);
   
   return (spNode->GetData(TFS_DATA_DIRTY) || spStm->IsDirty()) ? hrOK : hrFalse;
}

STDMETHODIMP CDMVComponentData::Load
(
   IStream *pStm
)
{
   SPITFSNode  spNode;
   SPITFSNodeHandler spHandler;
   SPIPersistStreamInit spStm;
   
   m_spNodeMgr->GetRootNode(&spNode);
   spNode->GetHandler(&spHandler);
   spStm.Query(spHandler);
   
   Assert(spStm);
   return spStm->Load(pStm);
}


STDMETHODIMP CDMVComponentData::Save
(
   IStream *pStm, 
   BOOL   fClearDirty
)
{
   SPITFSNode  spNode;
   SPITFSNodeHandler spHandler;
   SPIPersistStreamInit spStm;
   
   m_spNodeMgr->GetRootNode(&spNode);
   spNode->GetHandler(&spHandler);
   spStm.Query(spHandler);
   
   Assert(spStm);
   return spStm->Save(pStm, fClearDirty);
}


STDMETHODIMP CDMVComponentData::GetSizeMax
(
   ULARGE_INTEGER *pcbSize
)
{
   SPITFSNode  spNode;
   SPITFSNodeHandler spHandler;
   SPIPersistStreamInit spStm;
   
   m_spNodeMgr->GetRootNode(&spNode);
   spNode->GetHandler(&spHandler);
   spStm.Query(spHandler);
   
   Assert(spStm);
   return spStm->GetSizeMax(pcbSize);
}

STDMETHODIMP CDMVComponentData::InitNew()
{
   SPITFSNode  spNode;
   SPITFSNodeHandler spHandler;
   SPIPersistStreamInit spStm;
   
   m_spNodeMgr->GetRootNode(&spNode);
   spNode->GetHandler(&spHandler);
   spStm.Query(spHandler);
   
   Assert(spStm);
   return spStm->InitNew();
}



HRESULT CDMVComponentData::FinalConstruct()
{
   HRESULT           hr = hrOK;
   
   hr = CComponentData::FinalConstruct();
   
   if (FHrSucceeded(hr))
   {
      m_spTFSComponentData->GetNodeMgr(&m_spNodeMgr);
   }
   return hr;
}

void CDMVComponentData::FinalRelease()
{
   CComponentData::FinalRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\dvsview.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997 - 1999 
//
// File:    dvsview.h
//
// History:
//
//============================================================================


#ifndef _DVSVIEW_H
#define _DVSVIEW_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _XSTREAM_H
#include "xstream.h"    // need for ColumnData
#endif

#ifndef _INFO_H
#include "info.h"
#endif

#ifndef _IFACE_H
#include "iface.h"
#endif

#ifndef _BASECON_H
#include "basecon.h"    // BaseContainerHandler
#endif

#ifndef _DMVCOMP_H
#include "dmvcomp.h"
#endif

#ifndef _DMVCOMP_H
#include "dmvcomp.h"
#endif

#ifndef _DMVROOT_H
#include "dmvroot.h"
#endif

#ifndef _LIST_
#include <list>
using namespace std;
#endif

#ifndef AFX_DLGSVR_H__19556672_96AB_11D1_8575_00C04FC31FD3__INCLUDED_
#include "rrasqry.h"
#endif


enum
{
   DVS_SI_SERVERNAME = 0,
   DVS_SI_SERVERTYPE,
   DVS_SI_BUILDNO,
   DVS_SI_STATE,
   DVS_SI_PORTSINUSE,
   DVS_SI_PORTSTOTAL,
   DVS_SI_UPTIME,
   DVS_SI_MAX_COLUMNS,
};
             
struct _BaseServerData
{
   DWORD       m_dwData;
   CString     m_stData;
};

struct DMVNodeData
{
   DMVNodeData();
   ~DMVNodeData();

   HRESULT	MergeMachineNodeData(MachineNodeData* pData);
   

#ifdef DEBUG
   char  m_szDebug[32]; // for iding structures
#endif

   _BaseServerData m_rgData[DVS_SI_MAX_COLUMNS];

   SPMachineNodeData	m_spMachineData;

   static   HRESULT  InitDMVNodeData(ITFSNode *pNode, MachineNodeData *pData);
   static   HRESULT  FreeDMVNodeData(ITFSNode *pNode);
};

#define GET_DMVNODEDATA(pNode) \
                  ((DMVNodeData *) pNode->GetData(TFS_DATA_USER))
#define SET_DMVNODEDATA(pNode, pData) \
                  pNode->SetData(TFS_DATA_USER, (LONG_PTR) pData)


// forward declarations
class RouterRefreshObject;

/*---------------------------------------------------------------------------
   Class:   DomainStatusHandler
 ---------------------------------------------------------------------------*/

class DomainStatusHandler :
      public BaseContainerHandler
{
public:
	DomainStatusHandler(ITFSComponentData *pTFSCompData);
	~DomainStatusHandler();
	
	// Override QI to handle embedded interface
	STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);
	
	DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)
			
	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_GetString();
	OVERRIDE_NodeHandler_OnCreateDataObject();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_DestroyHandler();
	
	OVERRIDE_BaseHandlerNotify_OnExpand();
	
	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_CompareItems();
	
	OVERRIDE_BaseResultHandlerNotify_OnResultShow();   
	OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();
	
	// Initializes the handler
	HRESULT  Init(DMVConfigStream *pConfigStream, CServerList* pSList);
	
	// Initializes the node
	HRESULT ConstructNode(ITFSNode *pNode);
	
public:
	// Structure used to pass data to callbacks - used as a way of
	// avoiding recomputation
	struct SMenuData
	{
		SPITFSNode     m_spNode;
        
        DMVConfigStream* m_pConfigStream;
	};
	
	static ULONG RebuildServerFlags(const SRouterNodeMenu *pMenuData,
                                    INT_PTR pUserData);

	// assign auto refresh object from root handler
	HRESULT	SetExternalRefreshObject(RouterRefreshObject *pRefresh);
	HRESULT UpdateUIItems(ITFSNode *pThisNode);	
public:
    // for subnodes of status node
	static HRESULT UpdateSubItemUI(ITFSNode *pNode);	// not reload, only update UI
	static HRESULT SynchronizeSubItem(ITFSNode *pNode);	// reload and update UI
protected:
    static HRESULT GetServerInfo(ITFSNode *pNode);
    static HRESULT SynchronizeData(ITFSNode *pNode);
    static HRESULT SynchronizeIcon(ITFSNode *pNode);

protected:    
	// Refresh the data for these nodes
    HRESULT  SynchronizeNode(ITFSNode *pThisNode);

	HRESULT  GetDVServerData(ITFSNode *pThisNode);
	
	// Helper function to add interfaces to the UI
	HRESULT  AddServerNode(ITFSNode *pParent, MachineNodeData *pMachineData);
	
	// auto refresh	
	SPRouterRefreshObject		m_spRefreshObject;
	

	// Command implementations
	HRESULT  OnNewInterface();
	
	LONG_PTR			m_ulRefreshConnId;   // notification id for Refresh
	LONG_PTR			m_ulStatsConnId;
	MMC_COOKIE			m_cookie;      // cookie for the node
	DMVConfigStream*	m_pConfigStream;
	CString				m_stTitle;
	RRASQryData*		m_pQData;
	CServerList*		m_pServerList;

	// Cache commonly loaded strings here.
	CString				m_szStatAccessDenied;
	CString				m_szStatUnavail;
	CString				m_szStatStart;
	CString				m_szStatStop;
	CString				m_szStatNotConfig;
};

/*---------------------------------------------------------------------------
   Class:   DomainStatusServerHandler

   This is the handler for the interface nodes that appear in the ATLK
   node.
 ---------------------------------------------------------------------------*/

class DomainStatusServerHandler : public BaseResultHandler
{
public:
   DomainStatusServerHandler(ITFSComponentData *pCompData);
   ~DomainStatusServerHandler();
   
   OVERRIDE_NodeHandler_HasPropertyPages();
   OVERRIDE_NodeHandler_CreatePropertyPages();
   OVERRIDE_NodeHandler_OnCreateDataObject();
   
   OVERRIDE_ResultHandler_AddMenuItems();
   OVERRIDE_ResultHandler_Command();
   OVERRIDE_ResultHandler_OnCreateDataObject();
   OVERRIDE_ResultHandler_DestroyResultHandler();
   OVERRIDE_ResultHandler_HasPropertyPages()
         {  return hrOK;   };
   OVERRIDE_ResultHandler_CreatePropertyPages();
   OVERRIDE_ResultHandler_GetString();
   OVERRIDE_ResultHandler_CompareItems();
   OVERRIDE_BaseResultHandlerNotify_OnResultDelete();

   // Initializes the node
   HRESULT ConstructNode(ITFSNode *pNode, MachineNodeData *pMachineData);
   HRESULT Init(ITFSNode *pParent, DMVConfigStream *pConfigStream);

   HRESULT OnRemoveServer(ITFSNode *pNode);

   // Refresh the data for this node
   void RefreshInterface(MMC_COOKIE cookie);
   
public:
   // Structure used to pass data to callbacks - used as a way of
   // avoiding recomputation
   struct SMenuData : public MachineHandler::SMenuData
   {
   };

   static ULONG QueryService(const SRouterNodeMenu *pMenu, INT_PTR pData);
   static ULONG GetPauseFlags(const SRouterNodeMenu *pMenu, INT_PTR pData);
   
	// assign auto refresh object from root handler
	HRESULT	SetExternalRefreshObject(RouterRefreshObject *pRefresh);
protected:
   SPIDataObject  m_spDataObject;   // cachecd data object
   
	// auto refresh	
	SPRouterRefreshObject		m_spRefreshObject;
};





#endif _DVSVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\dmvstrm.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
   DMVumstrm.h
      DMVum node configuration object.

      Use this to get/set configuration data.  This class will take
      care of versioning of config formats as well as serializing
      of the data.
      
    FILE HISTORY:
        
*/

#ifndef _DMVSTRM_H
#define _DMVSTRM_H

#ifndef _XSTREAM_H
#include "xstream.h"
#endif

#ifndef _COLUMN_H
#include "column.h"
#endif

#ifndef AFX_DLGSVR_H__19556672_96AB_11D1_8575_00C04FC31FD3__INCLUDED_
#include "rrasqry.h"
#endif

#ifndef _VECTOR_
#include <vector>
using namespace std;
#endif

//forwards                     
class DMVRootHandler;

enum
{
   DMVSTRM_STATS_DMVNBR = 0,
   DMVSTRM_IFSTATS_DMVNBR,
   DMVSTRM_STATS_COUNT,
};

enum DMVSTRM_TAG
{
   DMVSTRM_TAG_VERSION =      XFER_TAG(1, XFER_DWORD),
   DMVSTRM_TAG_VERSIONADMIN = XFER_TAG(2, XFER_DWORD),
   
   DMVSTRM_TAG_SIZEQRY = XFER_TAG(3, XFER_DWORD),
   DMVSTRM_TAG_NUMQRY   = XFER_TAG(4, XFER_DWORD),
   DMVSTRM_TAG_NUMSRV   = XFER_TAG(5, XFER_DWORD),
   DMVSTRM_TAG_CATFLAG  = XFER_TAG(6, XFER_DWORD),
   DMVSTRM_TAG_SCOPE    = XFER_TAG(7, XFER_STRING),
   DMVSTRM_TAG_FILTER   = XFER_TAG(8, XFER_STRING),
   DMVSTRM_TAG_SERVERNAME = XFER_TAG(9, XFER_STRING),

   DMVSTRM_TAG_IFAUTOREFRESHISON = XFER_TAG(10, XFER_DWORD),
   DMVSTRM_TAG_AUTOREFRESHINTERVAL = XFER_TAG(11, XFER_DWORD),

};

  
//
// This class is the container of persisted domain queries
//
class RRASQryPersist
{
friend class DomainStatusHandler;
public:
   RRASQryPersist()
   {
      m_dwSizeQry=0;
      m_dwNumQry=0;
      m_dwNumSrv=0;
   }
   
   ~RRASQryPersist()
   {
      removeAllSrv();
      removeAllQry();
   }
 
      //create dwNum empty queries  
   HRESULT createQry(DWORD dwNum);

      //create dwNum empty servers
   HRESULT createSrv(DWORD dwNum);
   
      //push query data into container 
   HRESULT add_Qry(const RRASQryData& qd);

      //push server into container 
   HRESULT add_Srv(const CString& szServer);
   
      //remove all servernames
   HRESULT removeAllSrv();

      //remove all queries
   HRESULT removeAllQry();
  
private:   
   DWORD m_dwSizeQry;
   DWORD m_dwNumQry;
   DWORD m_dwNumSrv;
   
   //position [0] is the general (many machine) singleton query.
   //positions[1] .. n are the specific machine queries.
   vector<RRASQryData*> m_v_pQData;
   
   //persisted server names                               
   vector<CString*> m_v_pSData;
   
   friend class DMVRootHandler;
   friend class DMVConfigStream;
};


/*---------------------------------------------------------------------------
   Class:   DMVConfigStream

   This holds the configuration information for the IP administration
   nodes.  This does NOT hold the configuration information for the columns.
   That is stored in the Component Configuration streams.
 ---------------------------------------------------------------------------*/
class DMVConfigStream : public ConfigStream
{
public:
   DMVConfigStream();

   virtual HRESULT InitNew();           // set defaults
   virtual HRESULT SaveTo(IStream *pstm);
   virtual HRESULT SaveAs(UINT nVersion, IStream *pstm);
   
   virtual HRESULT LoadFrom(IStream *pstm);

   virtual HRESULT GetSize(ULONG *pcbSize);

   // --------------------------------------------------------
   // Accessors
   // --------------------------------------------------------
   
   virtual HRESULT   GetVersionInfo(DWORD *pnVersion, DWORD *pnAdminVersion);

	DWORD	m_bAutoRefresh;
	DWORD	m_dwRefreshInterval;
	
     //persist the domain view query
   RRASQryPersist m_RQPersist;
   
   void Init(DMVRootHandler* dmvroot, ITFSNode *pNode )
   {
     m_pDMVRootHandler=dmvroot;
     m_pDMVRootNode=pNode;
   }

private:
	HRESULT	PrepareAutoRefreshDataForSave();
   HRESULT XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize);
   DMVRootHandler* m_pDMVRootHandler;
   ITFSNode* m_pDMVRootNode;
};



class DVComponentConfigStream : public ConfigStream
{
public:
   virtual HRESULT XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize);
protected:
};


#endif _DMVSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\dmvroot.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
   root.cpp
      Root node information (the root node is not displayed
      in the MMC framework but contains information such as 
      all of the subnodes in this snapin).
      
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "machine.h"
#include "rtrcfg.h"
#include "resource.h"
#include "ncglobal.h"  // network console global defines
#include "htmlhelp.h"
#include "dmvstrm.h"
#include "dmvroot.h"
#include "dvsview.h"
#include "refresh.h"
#include "refrate.h"
#include "rtrres.h"

unsigned int g_cfMachineName = RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");

// result message view stuff
#define ROOT_MESSAGE_MAX_STRING  5

typedef enum _ROOT_MESSAGES
{
    ROOT_MESSAGE_MAIN,
    ROOT_MESSAGE_MAX
};

UINT g_uRootMessages[ROOT_MESSAGE_MAX][ROOT_MESSAGE_MAX_STRING] =
{
    {IDS_ROOT_MESSAGE_TITLE, Icon_Information, IDS_ROOT_MESSAGE_BODY1, IDS_ROOT_MESSAGE_BODY2, 0},
};


DEBUG_DECLARE_INSTANCE_COUNTER(DMVRootHandler)

// DMVRootHandler implementation
/*
extern const ContainerColumnInfo s_rgATLKInterfaceStatsColumnInfo[];

extern const ContainerColumnInfo s_rgATLKGroupStatsColumnInfo[];

struct _ViewInfoColumnEntry
{
   UINT  m_ulId;
   UINT  m_cColumns;
   const ContainerColumnInfo *m_prgColumn;
};
*/

DMVRootHandler::DMVRootHandler(ITFSComponentData *pCompData)
   : RootHandler(pCompData),
     m_ulConnId(0),
     m_fAddedProtocolNode(FALSE)
//     m_dwRefreshInterval(DEFAULT_REFRESH_INTERVAL)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    DEBUG_INCREMENT_INSTANCE_COUNTER(DMVRootHandler)

    //create one qeneral query placeholder
    m_ConfigStream.m_RQPersist.createQry(1);  
    
    m_bExpanded=false;
}

DMVRootHandler::~DMVRootHandler()
{ 
   m_spServerNodesRefreshObject.Release();
   m_spSummaryModeRefreshObject.Free();

	DEBUG_DECREMENT_INSTANCE_COUNTER(DMVRootHandler); 
};


STDMETHODIMP DMVRootHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if ( ppv == NULL )
        return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if ( riid == IID_IUnknown )
        *ppv = (LPVOID) this;
    else
        return RootHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if ( *ppv )
    {
        ((LPUNKNOWN) *ppv)->AddRef();
        return hrOK;
    }
    else
        return E_NOINTERFACE;   
}


///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members
STDMETHODIMP DMVRootHandler::GetClassID
(
CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

      // Copy the CLSID for this snapin
    *pClassID = CLSID_RouterSnapin;

    return hrOK;
}

// Global refresh is to be shareed by multiple machine nodes and status node
// in case of this snapin is created as extension, it not being used
HRESULT	DMVRootHandler::GetSummaryNodeRefreshObject(RouterRefreshObject** ppRefresh)
{
	HRESULT	hr = hrOK;
	HWND	hWndSync = m_spTFSCompData->GetHiddenWnd();

	COM_PROTECT_TRY
	{
		// If there is no sync window, then there is no refresh object
		// ------------------------------------------------------------
		if (hWndSync
			|| m_spSummaryModeRefreshObject)	// added by WeiJiang 10/29/98 to allow external RefreshObject
		{
			if (!m_spSummaryModeRefreshObject)
			{
				try{
					RouterRefreshObject* pRefresh = new RouterRefreshObject(hWndSync); 
					m_spSummaryModeRefreshObject = pRefresh;
					m_RefreshGroup.Join(pRefresh);
				}catch(...)
				{

				}
				
				if(m_spSummaryModeRefreshObject)
				{
					if(m_ConfigStream.m_dwRefreshInterval)
					{
						if(m_ConfigStream.m_bAutoRefresh)
							m_spSummaryModeRefreshObject->Start(m_ConfigStream.m_dwRefreshInterval);
						else
							m_spSummaryModeRefreshObject->SetRefreshInterval(m_ConfigStream.m_dwRefreshInterval);
					}
				}
			}
			if (ppRefresh)
			{
				*ppRefresh = m_spSummaryModeRefreshObject;
				(*ppRefresh)->AddRef();
			}
		}
		else
		{
			if (ppRefresh)
				*ppRefresh = NULL;
			hr = E_FAIL;
		}
	}
	COM_PROTECT_CATCH;

	return hr;
}

// Global refresh is to be shareed by multiple machine nodes and status node
// in case of this snapin is created as extension, it not being used
HRESULT	DMVRootHandler::GetServerNodesRefreshObject(IRouterRefresh** ppRefresh)
{
	
	HRESULT	hr = hrOK;
	HWND	hWndSync = m_spTFSCompData->GetHiddenWnd();

	COM_PROTECT_TRY
	{
		// If there is no sync window, then there is no refresh object
		// ------------------------------------------------------------
		if (hWndSync
			|| (IRouterRefresh*)m_spServerNodesRefreshObject)	// added by WeiJiang 10/29/98 to allow external RefreshObject
		{
			if ((IRouterRefresh*)m_spServerNodesRefreshObject == NULL)
			{
				RouterRefreshObject* pRefresh = new RouterRefreshObject(hWndSync); 
				if(pRefresh)
				{
					m_spServerNodesRefreshObject = pRefresh;
					m_RefreshGroup.Join(pRefresh);
					if(m_ConfigStream.m_dwRefreshInterval)
					{
						if(m_ConfigStream.m_bAutoRefresh)
							m_spServerNodesRefreshObject->Start(m_ConfigStream.m_dwRefreshInterval);
						else
							m_spServerNodesRefreshObject->SetRefreshInterval(m_ConfigStream.m_dwRefreshInterval);
					}
				}
			}
			if (ppRefresh)
			{
				*ppRefresh = m_spServerNodesRefreshObject;
				(*ppRefresh)->AddRef();
			}
		}
		else
		{
			if (ppRefresh)
				*ppRefresh = NULL;
			hr = E_FAIL;
		}
	}
	COM_PROTECT_CATCH;

	return hr;
}


/*!--------------------------------------------------------------------------
   DMVRootHandler::Init
 ---------------------------------------------------------------------------*/
HRESULT DMVRootHandler::Init(ITFSNode* pNode)
{
    m_ConfigStream.Init(this, pNode);

	return hrOK;
}

/*!--------------------------------------------------------------------------
   DMVRootHandler::OnExpand
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DMVRootHandler::OnExpand(ITFSNode *pNode,LPDATAOBJECT pDataObject, DWORD dwType, LPARAM arg,LPARAM lParam)
{
	HRESULT  hr = hrOK;
	
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// For now create a new node handler for each new node,
	// this is rather bogus as it can get expensive.  We can
	// consider creating only a single node handler for each
	// node type.
	MachineHandler *  pHandler = NULL;
	SPITFSNodeHandler spHandler;
	SPITFSNodeHandler spStatusHandler;
	SPITFSNode        spNodeS;
	SPITFSNode        spNodeM;

	DomainStatusHandler *  pStatusHandler = NULL;
	DWORD dw;
	int i;
	list<MachineNodeData *>::iterator itor;
	SPMachineNodeData	spMachineData;
	MachineNodeData	*	pMachineData;
	SPIRouterRefresh	spServerNodesRefresh;
	SPRouterRefreshObject	spSummaryNodeRefresh;
	CString             stMachineName;
	
	COM_PROTECT_TRY
	{
		if (dwType & TFS_COMPDATA_EXTENSION)
		{
			// we are extending the network management snapin.
			// Add a node for the machine 
			// specified in the data object.
			stMachineName = Extract<TCHAR>(pDataObject, (CLIPFORMAT) g_cfMachineName, COMPUTERNAME_LEN_MAX);
			
			//create a machine handler
			pHandler = new MachineHandler(m_spTFSCompData);

			// Create a new machine data
			spMachineData = new MachineNodeData;
			spMachineData->Init(stMachineName);
			
			// Do this so that it will get released correctly
			spHandler = pHandler;
			pHandler->Init(stMachineName, NULL, NULL, NULL);
			
			if(!spServerNodesRefresh)
				GetServerNodesRefreshObject(&spServerNodesRefresh);

			if((IRouterRefresh*)spServerNodesRefresh)
				CORg(pHandler->SetExternalRefreshObject(spServerNodesRefresh));
				
			if(stMachineName.GetLength() == 0)
				stMachineName = GetLocalMachineName();
			
			// Create the root node for this sick puppy
			CORg( CreateContainerTFSNode(&spNodeM,
										 &GUID_RouterMachineNodeType,
										 pHandler,
										 pHandler /* result handler */,
										 m_spNodeMgr) );
			Assert(spNodeM);
			
			spNodeM->SetData(TFS_DATA_COOKIE, (LONG_PTR)(ITFSNode*)spNodeM);
			
			CORg(pHandler->ConstructNode(spNodeM, stMachineName, spMachineData) );
			
			pHandler->SetExtensionStatus(spNodeM, TRUE);

			// Make the node immediately visible
			spNodeM->SetVisibilityState(TFS_VIS_SHOW);
			pNode->AddChild(spNodeM);
			
		}
		else
		{
			//create a summary node
			if (!m_spStatusNode)	// changed by Wei Jiang !m_bExpanded)
			{
				pStatusHandler = new DomainStatusHandler(m_spTFSCompData);
				Assert(pStatusHandler);
				m_pStatusHandler = pStatusHandler;
				spStatusHandler.Set(spHandler);
				
				CORg( pStatusHandler->Init(&m_ConfigStream, &m_serverlist) );
				
				if(!spSummaryNodeRefresh)
					GetSummaryNodeRefreshObject(&spSummaryNodeRefresh);

				if((RouterRefreshObject*)spSummaryNodeRefresh)
					CORg(pStatusHandler->SetExternalRefreshObject(spSummaryNodeRefresh));
				
				spHandler = pStatusHandler;
				
				CORg( CreateContainerTFSNode(&spNodeS,
											 &GUID_DVSServerNodeType,
											 static_cast<ITFSNodeHandler *>(pStatusHandler),
											 static_cast<ITFSResultHandler *>(pStatusHandler),
											 m_spNodeMgr) );
				
				Assert(spNodeS);
				m_spStatusNode.Set(spNodeS);
				
				// Call to the node handler to init the node data
				pStatusHandler->ConstructNode(spNodeS);
				// Make the node immediately visible
				spNodeS->SetVisibilityState(TFS_VIS_SHOW);
				pNode->AddChild(spNodeS);
				spHandler.Release();
			}
			else
			{
				spNodeS.Set(m_spStatusNode);
				spNodeS->GetHandler(&spStatusHandler);
			}
			
			// iterate the lazy list looking for machine nodes to create    
			for (itor = m_serverlist.m_listServerNodesToExpand.begin();
				 itor != m_serverlist.m_listServerNodesToExpand.end() ;
				 itor++ )
			{
				pMachineData = *itor;
				
				//create a machine handler
				pHandler = new MachineHandler(m_spTFSCompData);
				
				// Do this so that it will get released correctly
				spHandler.Release();
				spHandler = pHandler;
				
				CORg(pHandler->Init(pMachineData->m_stMachineName,
									NULL, spStatusHandler, spNodeS));
				if(!(IRouterRefresh*)spServerNodesRefresh)
					GetServerNodesRefreshObject(&spServerNodesRefresh);

				if((IRouterRefresh*)spServerNodesRefresh)
					CORg(pHandler->SetExternalRefreshObject(spServerNodesRefresh));
				
				// Create the root node for this sick puppy
				CORg( CreateContainerTFSNode(&spNodeM,
											 &GUID_RouterMachineNodeType,
											 pHandler,
											 pHandler /* result handler */,
											 m_spNodeMgr) );
				Assert(spNodeM);
				spNodeM->SetData(TFS_DATA_COOKIE, (LONG_PTR)(ITFSNode*)spNodeM);
				
				// if the machine is local, then find the name,
				// but not change the name on the list
				// so, when persist the list, empty string will be persisted
				//
				// This is incorrect.  For the local machine case, we
				// expect the NULL string to be passed down.  It should
				// be transparent to this layer whether the machine is
				// local or not.
				// ----------------------------------------------------

				if (pMachineData && pMachineData->m_stMachineName.GetLength() != 0)
					stMachineName = pMachineData->m_stMachineName;
				else
					stMachineName.Empty();
				
				CORg( pHandler->ConstructNode(spNodeM, stMachineName, pMachineData) );
				
				// Make the node immediately visible
				spNodeM->SetVisibilityState(TFS_VIS_SHOW);
				pNode->AddChild(spNodeM);
				spNodeM.Release();
			}      

			// Now that we've gone through the entire list, we have
			// to release the objects.
			m_serverlist.RemoveAllServerNodes();
			
			Assert(m_serverlist.m_listServerNodesToExpand.size() == 0);
		}
		
		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	
	m_bExpanded = true;
	
	return hr;
}

/*!--------------------------------------------------------------------------
   DMVRootHandler::OnCreateDataObject
      Implementation of ITFSNodeHandler::OnCreateDataObject
   Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DMVRootHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {
      // If we haven't created the sub nodes yet, we still have to
      // create a dataobject.
        CDataObject *  pObject = NULL;
        SPIDataObject  spDataObject;
        SPITFSNode     spNode;
        SPITFSNodeHandler spHandler;

        pObject = new CDataObject;
        spDataObject = pObject; // do this so that it gets released correctly
        Assert(pObject != NULL);

      // Save cookie and type for delayed rendering
        pObject->SetType(type);
        pObject->SetCookie(cookie);

      // Store the coclass with the data object
        pObject->SetClsid(*(m_spTFSCompData->GetCoClassID()));

        pObject->SetTFSComponentData(m_spTFSCompData);

        hr = pObject->QueryInterface(IID_IDataObject, 
                                     reinterpret_cast<void**>(ppDataObject));

    }
    COM_PROTECT_CATCH;
    return hr;
}



// ImplementEmbeddedUnknown(ATLKRootHandler, IRtrAdviseSink)


/*!--------------------------------------------------------------------------
   DMVRootHandler::DestroyHandler
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DMVRootHandler::DestroyHandler(ITFSNode *pNode)
{
    m_ulConnId = 0;

    return hrOK;
}


/*!--------------------------------------------------------------------------
   DMVRootHandler::HasPropertyPages
      Implementation of ITFSNodeHandler::HasPropertyPages
   NOTE: the root node handler has to over-ride this function to 
   handle the snapin manager property page (wizard) case!!! 
   Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
DMVRootHandler::HasPropertyPages
(
ITFSNode *        pNode,
LPDATAOBJECT      pDataObject, 
DATA_OBJECT_TYPES   type, 
DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    return S_FALSE;

    HRESULT hr = hrOK;

    if ( dwType & TFS_COMPDATA_CREATE )
    {
      // This is the case where we are asked to bring up property
      // pages when the user is adding a new snapin.  These calls
      // are forwarded to the root node to handle.
      //
      // We do have a property page on startup.
        hr = hrOK;
    }
    else
    {
        hr = S_FALSE;
    }
    return hr;
}


/*!--------------------------------------------------------------------------
   DMVRootHandler::CreatePropertyPages
      Implementation of ITFSNodeHandler::CreatePropertyPages
   Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP
DMVRootHandler::CreatePropertyPages(
									ITFSNode *          pNode,
									LPPROPERTYSHEETCALLBACK lpProvider,
									LPDATAOBJECT        pDataObject, 
									LONG_PTR            handle, 
									DWORD				dwType
								   )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT  hr = hrOK;
    HPROPSHEETPAGE hPage;

    Assert(pNode->GetData(TFS_DATA_COOKIE) == 0);    
    return hr;
}

/*!--------------------------------------------------------------------------
   DMVRootHandler::GetString
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) DMVRootHandler::GetString(ITFSNode *pNode, int nCol)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    static   CString  str;

    if ( m_strDomainName.GetLength() == 0 )
    {
        if ( str.GetLength() == 0 )
            str.LoadString(IDS_DMV_NODENAME_ROOT);

        return (LPCTSTR)str; 

    }
    else
        return (LPCTSTR) m_strDomainName;
}



/*---------------------------------------------------------------------------
    Menu data structure for our menus
 ---------------------------------------------------------------------------*/

static const SRouterNodeMenu  s_rgDMVNodeMenu[] =
{
  // Add items that go on the top menu here
    { IDS_DMV_MENU_ADDSVR, 0,
        CCM_INSERTIONPOINTID_PRIMARY_TOP},
        
    { IDS_MENU_SEPARATOR, 0,
	CCM_INSERTIONPOINTID_PRIMARY_TOP },
	
	{ IDS_MENU_AUTO_REFRESH, DMVRootHandler::GetAutoRefreshFlags,
	CCM_INSERTIONPOINTID_PRIMARY_TOP },
	
	{ IDS_MENU_REFRESH_RATE, DMVRootHandler::GetAutoRefreshFlags,
	CCM_INSERTIONPOINTID_PRIMARY_TOP },	
        
};

ULONG DMVRootHandler::GetAutoRefreshFlags(const SRouterNodeMenu *pMenuData,
                                          INT_PTR pUserData)
{
    SMenuData * pData = reinterpret_cast<SMenuData *>(pUserData);
    Assert(pData);
    
	ULONG	uStatus = MF_GRAYED;
	
	SPIRouterRefresh	spRefresh;

	pData->m_pDMVRootHandler->GetServerNodesRefreshObject(&spRefresh);
	if ((IRouterRefresh*)spRefresh)
	{
		uStatus = MF_ENABLED;
		if (pMenuData->m_sidMenu == IDS_MENU_AUTO_REFRESH && (spRefresh->IsRefreshStarted() == hrOK))
		{
			uStatus |= MF_CHECKED;
		}
	}

	return uStatus;
}


/*!--------------------------------------------------------------------------
    DomainStatusHandler::OnAddMenuItems
        Implementation of ITFSNodeHandler::OnAddMenuItems
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DMVRootHandler::OnAddMenuItems(
                                           ITFSNode *pNode,
                                           LPCONTEXTMENUCALLBACK pContextMenuCallback, 
                                           LPDATAOBJECT lpDataObject, 
                                           DATA_OBJECT_TYPES type, 
                                           DWORD dwType,
                                           long *pInsertionAllowed)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    DMVRootHandler::SMenuData   menuData;

    COM_PROTECT_TRY
    {
        menuData.m_spNode.Set(pNode);
        menuData.m_pDMVRootHandler = this;  // non-AddRef'd !
        
        // Uncomment if you have items to add
        hr = AddArrayOfMenuItems(pNode, s_rgDMVNodeMenu,
                                 DimensionOf(s_rgDMVNodeMenu),
                                 pContextMenuCallback,
                                 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
    }
    COM_PROTECT_CATCH;

    return hr; 
}


/*!--------------------------------------------------------------------------
   DMVRootHandler::QryAddServer
 ---------------------------------------------------------------------------*/
HRESULT DMVRootHandler::QryAddServer(ITFSNode *pNode)
{
    HRESULT hr = S_OK;
    DWORD dw=0;
    POSITION pos;
    CString szServer;

    RRASQryData qd;
    qd.dwCatFlag=RRAS_QRY_CAT_NONE;
    
    CWaitCursor wait;
    
    COM_PROTECT_TRY
    {
      if ( FHrSucceeded(hr=::RRASOpenQryDlg(NULL,qd)) )
      {
         if ( (hr!=S_OK) || (qd.dwCatFlag==RRAS_QRY_CAT_NONE) )
            return hr;
         
         if (qd.dwCatFlag==RRAS_QRY_CAT_MACHINE || qd.dwCatFlag == RRAS_QRY_CAT_THIS  )
         {  //specific machine query;  add to array
			m_ConfigStream.m_RQPersist.add_Qry(qd);
         }
         else
         {  //position 0 is the non-machine singleton query
            RRASQryData& qdGen=*(m_ConfigStream.m_RQPersist.m_v_pQData[0]);
            if (!( (qdGen.dwCatFlag==qd.dwCatFlag) &&
                  (qdGen.strScope=qd.strScope) &&
                  (qdGen.strFilter=qd.strFilter) ))
            {
               qdGen.dwCatFlag=qd.dwCatFlag;
               qdGen.strScope=qd.strScope;
               qdGen.strFilter=qd.strFilter;
            }
         }
         
         CStringArray sa;
		 ::RRASExecQry(qd, dw, sa);
		 //if there is only one server selected, select it
         hr = AddServersToList(sa,pNode);
		 if ( S_OK == hr && (qd.dwCatFlag==RRAS_QRY_CAT_MACHINE || qd.dwCatFlag == RRAS_QRY_CAT_THIS ))
		 {

			//select the scope item...
			 //create a background thread to select the current node?
			 //this sucks...
			 //it really does...
		 }
      }
      else
      {
         AfxMessageBox(IDS_DVS_DOMAINVIEWQRY);
      }
   }
   COM_PROTECT_CATCH;
   
   return hr; 
}


HRESULT DMVRootHandler::ExecServerQry(ITFSNode* pNode)
{
    HRESULT hr = S_OK;
    DWORD dw=0;
    CString szServer;
    SPITFSNode  spParent;
    CStringArray sa;

    COM_PROTECT_TRY
    {
       for (int i=0;i<m_ConfigStream.m_RQPersist.m_v_pQData.size(); i++ )
       {
           RRASQryData& QData=*(m_ConfigStream.m_RQPersist.m_v_pQData[i]);
        
           if (QData.dwCatFlag==RRAS_QRY_CAT_NONE)
               continue;

           sa.RemoveAll();

           hr=::RRASExecQry(QData, dw, sa);
           
           if (!FHrSucceeded(hr))
           {
               TRACE0("RRASExexQry failed for this query\n");
               continue;
           }
           
           hr = AddServersToList(sa, pNode);
           
           if (! FHrSucceeded(hr) )
               AfxMessageBox(IDS_DVS_DOMAINVIEWQRY);
       }
    }
    COM_PROTECT_CATCH;

    return hr; 
}
#define ___CAN_NOT_PUT_LOCAL_MACHINE_BY_NAME_AFTER_PUT_IN_LOCAL_
/*!--------------------------------------------------------------------------
	DMVRootHandler::AddServersToList
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DMVRootHandler::AddServersToList(const CStringArray& sa, ITFSNode *pNode)
{
	HRESULT hr = S_OK;
	bool found;
	SPITFSNodeEnum	spNodeEnum;
	SPITFSNode		spNode;
	MachineNodeData *pMachineData = NULL;

	// check for duplicate servernames
	for (int j = 0; j < sa.GetSize(); j++)
	{
		found=false;
		
		// Go through the list of nodes and check for nodes with
		// the same server name.
		spNodeEnum.Release();
		CORg( pNode->GetEnum(&spNodeEnum) );
		
		while ( spNodeEnum->Next(1, &spNode, NULL) == hrOK)
		{
			// Now get the data for this node (need to see if this is
			// a machine node).
			if (*(spNode->GetNodeType()) == GUID_DVSServerNodeType || *(spNode->GetNodeType()) == GUID_RouterMachineNodeType )
			{
/*
				DMVNodeData *	pData = GET_DMVNODEDATA( spNode );
				Assert(pData);
				pMachineData = pData->m_spMachineData;
*/
				pMachineData = GET_MACHINENODEDATA(spNode);
				Assert(pMachineData);

#ifdef	___CAN_NOT_PUT_LOCAL_MACHINE_BY_NAME_AFTER_PUT_IN_LOCAL_
				if (pMachineData->m_stMachineName.CompareNoCase(sa[j]) == 0 || (pMachineData->m_fLocalMachine && sa[j].IsEmpty()))
#else
				if ((pMachineData->m_stMachineName.CompareNoCase(sa[j]) == 0 && !pMachineData->m_fAddedAsLocal)
					|| (pMachineData->m_fAddedAsLocal && sa[j].IsEmpty()))
#endif
				{
					found = true;
					break;
				}
			}
			spNode.Release();
		}
	
		if (!found) 
		{
			// add to working serverlist
			m_serverlist.AddServer(sa[j]);
		}
	}

Error:
 	// this causes the unexpanded server lists to be processed
	hr = OnExpand(pNode, NULL, 0, 0, 0 );
	if (hr == S_OK && m_spStatusNode && m_pStatusHandler)
		hr = m_pStatusHandler->OnExpand(m_spStatusNode, NULL, 0, 0, 0 );
	
	return hr;
}    
        
 
/*!--------------------------------------------------------------------------
	DMVRootHandler::LoadPeristedServerList
		Adds the list of persisted servers to the list of
		servers to be added to the UI.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DMVRootHandler::LoadPersistedServerList()
{
    HRESULT hr = S_OK;
    
    COM_PROTECT_TRY
    {
		if ( m_ConfigStream.m_RQPersist.m_v_pSData.size() > 0 )
			m_serverlist.removeall();
		
		for (int i=0;i<m_ConfigStream.m_RQPersist.m_v_pSData.size(); i++ )
		{
			m_serverlist.AddServer( *(m_ConfigStream.m_RQPersist.m_v_pSData[i]) );
		}
	}
    
    COM_PROTECT_CATCH;

    return hr; 
}


/*!--------------------------------------------------------------------------
	DMVRootHandler::LoadPersistedServerListFromNode
		Reloads the persisted server list.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DMVRootHandler::LoadPersistedServerListFromNode()
{
    HRESULT hr = S_OK;
	SPITFSNodeEnum	spNodeEnum;
	SPITFSNode		spNode;
	SPITFSNode		spRootNode;
	MachineNodeData *pMachineData = NULL;

    COM_PROTECT_TRY
    {
		// Remove all servers from the of persisted list of servers
		m_ConfigStream.m_RQPersist.removeAllSrv();

		CORg(m_spNodeMgr->GetRootNode(&spRootNode));
		// replace with above (weijiang) -- using NodeMgr
		//CORg( m_spStatusNode->GetParent(&spRootNode) );
		
		// Go through the list of nodes and check for nodes with
		// the same server name.
		CORg( spRootNode->GetEnum(&spNodeEnum) );

		
		while ( spNodeEnum->Next(1, &spNode, NULL) == hrOK)
		{
			// Now get the data for this node (need to see if this is
			// a machine node).
			if (*(spNode->GetNodeType()) == GUID_RouterMachineNodeType)
			{
				//DMVNodeData *	pData = GET_DMVNODEDATA( spNode );
				//Assert(pData);
				//pMachineData = pData->m_spMachineData;
				pMachineData = GET_MACHINENODEDATA(spNode);
				Assert(pMachineData);
				
				CString	str;
				if(!pMachineData->m_fAddedAsLocal)
					str = pMachineData->m_stMachineName;
				m_ConfigStream.m_RQPersist.add_Srv( str );
			}
			spNode.Release();
		}

		COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    return hr; 
}

 

/*!--------------------------------------------------------------------------
    DMVRootHandler::OnCommand
 ---------------------------------------------------------------------------*/
STDMETHODIMP DMVRootHandler::OnCommand(ITFSNode *pNode, long nCommandId, 
                                       DATA_OBJECT_TYPES    type, 
                                       LPDATAOBJECT pDataObject, 
                                       DWORD    dwType)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    RegKey regkey;

    COM_PROTECT_TRY
    {
        switch ( nCommandId )
        {
            case IDS_DMV_MENU_ADDSVR:
               Assert( pNode);
               QryAddServer( pNode );
               break;
            case IDS_DMV_MENU_REBUILDSVRLIST:
               m_serverlist.removeall();
			   m_spStatusNode.Release();	// wei Jiang

               // delete all the other nodes
			   CORg(pNode->DeleteAllChildren(TRUE));
			   
               ExecServerQry( pNode);
               GetConfigStream()->SetDirty(TRUE);
               break;
			case IDS_MENU_REFRESH_RATE:
				{
					CRefRateDlg	refrate;
					SPIRouterRefresh				spServerRefresh;
					SPRouterRefreshObject			spStatusRefresh;
					DWORD		rate;

					if(FAILED(GetServerNodesRefreshObject(&spServerRefresh)))
						break;

					if(!spServerRefresh)
						break;

					spServerRefresh->GetRefreshInterval(&rate);
					refrate.m_cRefRate = rate;
					if (refrate.DoModal() == IDOK)
					{
						spServerRefresh->SetRefreshInterval(refrate.m_cRefRate);
						// Summary Node

						if(FAILED(GetSummaryNodeRefreshObject(&spStatusRefresh)))
							break;
						if(!spStatusRefresh)
							break;
						spStatusRefresh->SetRefreshInterval(refrate.m_cRefRate);
					}
					GetConfigStream()->SetDirty(TRUE);

				}
				break;
			case IDS_MENU_AUTO_REFRESH:
				{
					SPIRouterRefresh				spServerRefresh;
					SPRouterRefreshObject			spStatusRefresh;

					if(FAILED(GetServerNodesRefreshObject(&spServerRefresh)))
						break;

					if(!spServerRefresh)
						break;

						

					if (spServerRefresh->IsRefreshStarted() == hrOK)
						spServerRefresh->Stop();
					else
					{
						DWORD				rate;
						spServerRefresh->GetRefreshInterval(&rate);
						spServerRefresh->Start(rate);
					}

					// Summary Node
					if(FAILED(GetSummaryNodeRefreshObject(&spStatusRefresh)))
						break;

					if(!spStatusRefresh)
						break;

					if (spStatusRefresh->IsRefreshStarted() == hrOK)
						spStatusRefresh->Stop();
					else
					{
						DWORD				rate;
						spStatusRefresh->GetRefreshInterval(&rate);
						spStatusRefresh->Start(rate);
					}
					GetConfigStream()->SetDirty(TRUE);


				}
				break;

             
        }    
		COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    return hr;
}

STDMETHODIMP DMVRootHandler::UserNotify(ITFSNode *pNode, LPARAM lParam, LPARAM lParam2)
{
    HRESULT     hr = hrOK;
    
    COM_PROTECT_TRY
    {
        switch (lParam)
        {
            case DMV_DELETE_SERVER_ENTRY:
                {
                    LPCTSTR pszServer = (LPCTSTR) lParam2;
                    m_serverlist.RemoveServer(pszServer);
                }
                break;
            default:
                hr = RootHandler::UserNotify(pNode, lParam, lParam2);
                break;                
        }
    }
    COM_PROTECT_CATCH;

    return hr;                     
}


HRESULT	DMVRootHandler::UpdateAllMachineIcons(ITFSNode* pRootNode)
{
 	SPITFSNodeEnum		spMachineEnum;
	SPITFSNode			spMachineNode;
    SPITFSNodeHandler   spNodeHandler;
    HRESULT				hr = S_OK;

	pRootNode->GetEnum(&spMachineEnum);
	while(hr == hrOK && spMachineEnum->Next(1, &spMachineNode, NULL) == hrOK)
	{
		if ((*spMachineNode->GetNodeType()) == GUID_RouterMachineNodeType)
        {
            spNodeHandler.Release();
            spMachineNode->GetHandler(&spNodeHandler);
            hr = spNodeHandler->UserNotify(spMachineNode, MACHINE_SYNCHRONIZE_ICON, NULL);
        }
		spMachineNode.Release();
	}
	return hr;
}

/*!--------------------------------------------------------------------------
	BaseRouterHandler::OnResultContextHelp
		-
	Author: MikeG (a-migall)
 ---------------------------------------------------------------------------*/
HRESULT DMVRootHandler::OnResultContextHelp(ITFSComponent * pComponent, 
											   LPDATAOBJECT    pDataObject, 
											   MMC_COOKIE      cookie, 
											   LPARAM          arg, 
											   LPARAM          lParam)
{
	// Not used...
	UNREFERENCED_PARAMETER(pDataObject);
	UNREFERENCED_PARAMETER(cookie);
	UNREFERENCED_PARAMETER(arg);
	UNREFERENCED_PARAMETER(lParam);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
	return HrDisplayHelp(pComponent,
						 m_spTFSCompData->GetHTMLHelpFileName(),
						 _T("\\help\\rrasconcepts.chm::/sag_RRAStopnode.htm"));
}

/*!--------------------------------------------------------------------------
   DMVRootHandler::AddMenuItems
      Over-ride this to add our view menu item
   Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
DMVRootHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
   MMC_COOKIE              cookie,
   LPDATAOBJECT         pDataObject, 
   LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
   long *               pInsertionAllowed
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    SPITFSNode  spNode;
    
    m_spNodeMgr->FindNode(cookie, &spNode);
    
    // Call through to the regular OnAddMenuItems
    hr = OnAddMenuItems(spNode,
                        pContextMenuCallback,
                        pDataObject,
                        CCT_RESULT,
                        TFS_COMPDATA_CHILD_CONTEXTMENU,
                        pInsertionAllowed);
    
    return hr;
}

/*!--------------------------------------------------------------------------
   DMVRootHandler::Command
      Handles commands for the current view
   Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
DMVRootHandler::Command
(
    ITFSComponent * pComponent, 
   MMC_COOKIE        cookie, 
   int            nCommandID,
   LPDATAOBJECT   pDataObject
)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   HRESULT hr = S_OK;

   switch (nCommandID)
   {
        case MMCC_STANDARD_VIEW_SELECT:
            break;

        default:
            {
            SPITFSNode	spNode;
            
            m_spNodeMgr->FindNode(cookie, &spNode);
            hr = OnCommand(spNode,
                           nCommandID,
                           CCT_RESULT,
                           pDataObject,
                           TFS_COMPDATA_CHILD_CONTEXTMENU);
            }
            break;
    }

    return hr;
}

/*---------------------------------------------------------------------------
   DMVRootHandler::OnGetResultViewType
      Return the result view that this node is going to support
   Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
DMVRootHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE            cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
	LPWSTR		lpwszFormat = L"res://%s\\mprsnap.dll/welcome.htm";
	LPWSTR		lpwszURL = NULL;
	WCHAR		wszSystemDirectory[MAX_PATH+1] = {0};

	GetSystemDirectoryW ( wszSystemDirectory, MAX_PATH);
	//we will have a few extra bytes allocated.  But that's fine
	lpwszURL = (LPWSTR)CoTaskMemAlloc( ( ::lstrlen(wszSystemDirectory) + ::lstrlen(lpwszFormat) ) * sizeof(WCHAR) );
	if ( lpwszURL )
	{
		wsprintf( lpwszURL, lpwszFormat, wszSystemDirectory );
		*pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;
		*ppViewType = lpwszURL;
		return S_OK;
	}
	else
	{
		return E_OUTOFMEMORY;
	}
    //return BaseRouterHandler::OnGetResultViewType(pComponent, cookie, ppViewType, pViewOptions);
}

/*!--------------------------------------------------------------------------
   DMVRootHandler::OnResultSelect
        Update the result message here.
   Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT DMVRootHandler::OnResultSelect(ITFSComponent *pComponent,
									   LPDATAOBJECT pDataObject,
									   MMC_COOKIE cookie,
									   LPARAM arg,
									   LPARAM lParam)
{
    HRESULT hr = hrOK;
    SPITFSNode spRootNode;

    CORg(RootHandler::OnResultSelect(pComponent, pDataObject, cookie, arg, lParam));

    CORg(m_spNodeMgr->GetRootNode(&spRootNode));

    UpdateResultMessage(spRootNode);

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
   DMVRootHandler::UpdateResultMessage
        Determines what (if anything) to put in the result pane message
   Author: EricDav
 ---------------------------------------------------------------------------*/
void DMVRootHandler::UpdateResultMessage(ITFSNode * pNode)
{
    HRESULT hr = hrOK;
    int nMessage = ROOT_MESSAGE_MAIN;   // default
    int i;
    CString strTitle, strBody, strTemp;

	// now build the text strings
	// first entry is the title
	strTitle.LoadString(g_uRootMessages[nMessage][0]);

	// second entry is the icon
	// third ... n entries are the body strings

	for (i = 2; g_uRootMessages[nMessage][i] != 0; i++)
	{
		strTemp.LoadString(g_uRootMessages[nMessage][i]);
		strBody += strTemp;
	}

	ShowMessage(pNode, strTitle, strBody, (IconIdentifier) g_uRootMessages[nMessage][1]);
}
                                  
//------------------------------------------------------------------------
//   implementation of CServerList
//------------------------------------------------------------------------

HRESULT CServerList::AddServer(const CString& servername)
{
    HRESULT hr=S_OK;

    COM_PROTECT_TRY
    {
		SPMachineNodeData	spMachineData;

		spMachineData = new MachineNodeData;

		spMachineData->Init(servername);
		m_listServerNodesToExpand.push_back(spMachineData);
		spMachineData->AddRef();
		
		m_listServerHandlersToExpand.push_back(spMachineData);
		spMachineData->AddRef();
    }
    COM_PROTECT_CATCH;

    return hr;
}


HRESULT CServerList::RemoveServer(LPCTSTR pszServerName)
{
    HRESULT hr = hrOK;
    COM_PROTECT_TRY
    {
		list< MachineNodeData * >::iterator it;
        MachineNodeData *   pData = NULL;
		
        for (it= m_listServerHandlersToExpand.begin();
			 it!= m_listServerHandlersToExpand.end() ; it++ )
        {
            pData = *it;
        }

        if (pData)
        {
            pData->Release();
            m_listServerHandlersToExpand.remove(pData);
        }

        pData = NULL;
        
        for (it= m_listServerNodesToExpand.begin();
			 it!= m_listServerNodesToExpand.end() ; it++ )
        {
            pData = *it;
        }

        if (pData)
        {
            pData->Release();
            m_listServerNodesToExpand.remove(pData);
        }

    }
    COM_PROTECT_CATCH;
    return hr;
}


HRESULT CServerList::RemoveAllServerNodes()
{
	while (!m_listServerNodesToExpand.empty())
	{
		m_listServerNodesToExpand.front()->Release();
		m_listServerNodesToExpand.pop_front();
	}
	return hrOK;
}

HRESULT CServerList::RemoveAllServerHandlers()
{
	while (!m_listServerHandlersToExpand.empty())
	{
		m_listServerHandlersToExpand.front()->Release();
		m_listServerHandlersToExpand.pop_front();
	}
	return hrOK;
}

HRESULT CServerList::removeall()
{
    HRESULT hr=S_OK;
    
    COM_PROTECT_TRY
    {
		RemoveAllServerNodes();
		RemoveAllServerHandlers();
	}
    COM_PROTECT_CATCH;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\dvsview.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    ATLKview.cpp
        
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "coldlg.h"     // columndlg
#include "column.h"     // ComponentConfigStream
#include "rtrui.h"
#include "globals.h"    // IP CB defaults
#include "resource.h"
#include "machine.h"
#include "mstatus.h"
#include "rrasqry.h"
#include "dvsview.h"
#include "cservice.h"
#include "rrasqry.h"
#include "rtrres.h"
#include "rtrutilp.h"
#include "refresh.h"


/*---------------------------------------------------------------------------
    Keep this in sync with the column ids in ATLKview.h
 ---------------------------------------------------------------------------*/
extern const ContainerColumnInfo    s_rgDVSViewColumnInfo[];

const ContainerColumnInfo   s_rgDVSViewColumnInfo[] = 
{
    { IDS_DMV_COL_SERVERNAME, CON_SORT_BY_STRING, TRUE, COL_MACHINE_NAME},
	{ IDS_DMV_COL_SERVERTYPE, CON_SORT_BY_STRING, TRUE, COL_BIG_STRING},
	{ IDS_DMV_COL_BUILDNO,	  CON_SORT_BY_STRING, FALSE, COL_SMALL_NUM },
    { IDS_DMV_COL_STATE,      CON_SORT_BY_STRING, TRUE, COL_STRING },
    { IDS_DMV_COL_PORTSINUSE, CON_SORT_BY_DWORD,  TRUE, COL_SMALL_NUM},
    { IDS_DMV_COL_PORTSTOTAL, CON_SORT_BY_DWORD,  TRUE, COL_SMALL_NUM},
    { IDS_DMV_COL_UPTIME,     CON_SORT_BY_DWORD,  TRUE, COL_DURATION },
};



DMVNodeData::DMVNodeData()
{
#ifdef DEBUG
   StrCpyA(m_szDebug, "DMVNodeData");
#endif
}

DMVNodeData::~DMVNodeData()
{
	// This will actually call Release();
	m_spMachineData.Free();
}

HRESULT	DMVNodeData::MergeMachineNodeData(MachineNodeData* pData)
{
	if((MachineNodeData*)m_spMachineData)
		m_spMachineData->Merge(*pData);
	return S_OK;
}


void FillInNumberData(DMVNodeData *pNodeData, UINT iIndex,DWORD dwData)
{
   TCHAR szNumber[32];

   FormatNumber(dwData, szNumber, DimensionOf(szNumber), FALSE);
   pNodeData->m_rgData[iIndex].m_stData = szNumber;
   pNodeData->m_rgData[iIndex].m_dwData = dwData;
}
                         

/*!--------------------------------------------------------------------------
   DMVNodeData::InitNodeData
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DMVNodeData::InitDMVNodeData(ITFSNode *pNode, MachineNodeData *pMachineData)
{
   HRESULT           hr = hrOK;
   DMVNodeData *  pData = NULL;
   
   pData = new DMVNodeData;
   Assert(pData);

   pData->m_spMachineData.Free();
   pData->m_spMachineData = pMachineData;
   pMachineData->AddRef();

   SET_DMVNODEDATA(pNode, pData);

   return hr;
}

/*!--------------------------------------------------------------------------
   DMVNodeData::FreeAdminNodeData
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DMVNodeData::FreeDMVNodeData(ITFSNode *pNode)
{  
   DMVNodeData *  pData = GET_DMVNODEDATA(pNode);
   delete pData;
   
   SET_DMVNODEDATA(pNode, NULL);
   
   return hrOK;
}



/*---------------------------------------------------------------------------
    DomainStatusHandler implementation
 ---------------------------------------------------------------------------*/

DomainStatusHandler::DomainStatusHandler(ITFSComponentData *pCompData)
: BaseContainerHandler(pCompData, DM_COLUMNS_DVSUM,s_rgDVSViewColumnInfo),
//        m_ulConnId(0),
        m_ulRefreshConnId(0),
        m_ulStatsConnId(0)
{
    m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
    m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;
    m_pQData=NULL;
}

DomainStatusHandler::~DomainStatusHandler()
{
}


STDMETHODIMP DomainStatusHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if ( ppv == NULL )
        return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if ( riid == IID_IUnknown )
        *ppv = (LPVOID) this;
    else if ( riid == IID_IRtrAdviseSink )
        *ppv = &m_IRtrAdviseSink;
    else
        return BaseContainerHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if ( *ppv )
    {
        ((LPUNKNOWN) *ppv)->AddRef();
        return hrOK;
    }
    else
        return E_NOINTERFACE;   
}



// assign auto refresh object from root handler
HRESULT	DomainStatusHandler::SetExternalRefreshObject(RouterRefreshObject *pRefresh)
{
	Assert(!m_spRefreshObject);
	
	m_spRefreshObject = pRefresh;
	if(pRefresh)
		pRefresh->AddRef();
	return S_OK;
};
/*!--------------------------------------------------------------------------
    DomainStatusHandler::DestroyHandler
        Implementation of ITFSNodeHandler::DestroyHandler
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DomainStatusHandler::DestroyHandler(ITFSNode *pNode)
{
    if ( m_ulRefreshConnId )
    {
        if ( (RouterRefreshObject*)m_spRefreshObject )
            m_spRefreshObject->UnadviseRefresh(m_ulRefreshConnId);
    }
    m_ulRefreshConnId = 0;

    if ( m_ulStatsConnId )
    {
        if ( (RouterRefreshObject*)m_spRefreshObject )
            m_spRefreshObject->UnadviseRefresh(m_ulStatsConnId);
    }
    m_ulStatsConnId = 0;

    return hrOK;
}

/*!--------------------------------------------------------------------------
    DomainStatusHandler::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    NOTE: the root node handler has to over-ride this function to 
    handle the snapin manager property page (wizard) case!!!
    
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
DomainStatusHandler::HasPropertyPages
(
ITFSNode *          pNode,
LPDATAOBJECT        pDataObject, 
DATA_OBJECT_TYPES   type, 
DWORD               dwType
)
{
    return hrOK;
}


/*!--------------------------------------------------------------------------
    DomainStatusHandler::CreatePropertyPages
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP
DomainStatusHandler::CreatePropertyPages
(
   ITFSNode *              pNode,
   LPPROPERTYSHEETCALLBACK lpProvider,
   LPDATAOBJECT            pDataObject, 
   LONG_PTR                    handle, 
   DWORD                   dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT     hr = hrOK;

    return hr;
}


/*---------------------------------------------------------------------------
    Menu data structure for our menus
 ---------------------------------------------------------------------------*/

ULONG DomainStatusHandler::RebuildServerFlags(const SRouterNodeMenu *pMenuData,
                                              INT_PTR pUserData)
{
    SMenuData * pData = reinterpret_cast<SMenuData *>(pUserData);
    Assert(pData);
    DWORD dw = pData->m_pConfigStream->m_RQPersist.m_v_pQData.size();
	
    return (dw > 1) ? MF_ENABLED : MF_GRAYED;
}


static const SRouterNodeMenu  s_rgDVSNodeMenu[] =
{
  // Add items that go on the top menu here
    { IDS_DMV_MENU_ADDSVR, 0,
        CCM_INSERTIONPOINTID_PRIMARY_TOP},
        
    { IDS_DMV_MENU_REBUILDSVRLIST, DomainStatusHandler::RebuildServerFlags,
        CCM_INSERTIONPOINTID_PRIMARY_TOP},
};


/*!--------------------------------------------------------------------------
    DomainStatusHandler::OnAddMenuItems
        Implementation of ITFSNodeHandler::OnAddMenuItems
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DomainStatusHandler::OnAddMenuItems(
                                            ITFSNode *pNode,
                                            LPCONTEXTMENUCALLBACK pContextMenuCallback, 
                                            LPDATAOBJECT lpDataObject, 
                                            DATA_OBJECT_TYPES type, 
                                            DWORD dwType,
                                            long *pInsertionAllowed)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
    HRESULT hr = S_OK;
    DomainStatusHandler::SMenuData menuData;
    
    COM_PROTECT_TRY
    {
        menuData.m_spNode.Set(pNode);
        menuData.m_pConfigStream = m_pConfigStream;
        
        hr = AddArrayOfMenuItems(pNode, s_rgDVSNodeMenu,
                                 DimensionOf(s_rgDVSNodeMenu),
                                 pContextMenuCallback,
                                 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
    }
    COM_PROTECT_CATCH;
      
    return hr; 
}

/*!--------------------------------------------------------------------------
    DomainStatusHandler::OnCommand
        Implementation of ITFSNodeHandler::OnCommand
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DomainStatusHandler::OnCommand(ITFSNode *pNode, long nCommandId, 
                                        DATA_OBJECT_TYPES    type, 
                                        LPDATAOBJECT pDataObject, 
                                        DWORD    dwType)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    RegKey regkey;
    SPITFSNode  spParent;
    SPITFSNodeHandler   spHandler;
    
    Assert(pNode);

    COM_PROTECT_TRY
    {
       switch ( nCommandId )
       {
       case IDS_DMV_MENU_ADDSVR:
       case IDS_DMV_MENU_REBUILDSVRLIST:
             pNode->GetParent(&spParent);
             spParent->GetHandler(&spHandler);
             spHandler->OnCommand(spParent,nCommandId,CCT_RESULT, NULL, 0);
             break;

       case IDS_MENU_REFRESH:
           // do it in background thread
           if ((RouterRefreshObject*)m_spRefreshObject )
               m_spRefreshObject->Refresh();
           
           break;                
       }
    }
    COM_PROTECT_CATCH;

    return hr;
}

/*!--------------------------------------------------------------------------
    DomainStatusHandler::OnExpand
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DomainStatusHandler::OnExpand(ITFSNode *pNode,LPDATAOBJECT pDataObject, DWORD dwType, LPARAM arg,LPARAM lParam)
{
    HRESULT hr = hrOK;
    SPIEnumInterfaceInfo    spEnumIf;
    SPIInterfaceInfo        spIf;
    SPIRtrMgrInterfaceInfo  spRmIf;
    SPIInfoBase             spInfoBase;

    Assert(m_pServerList);

    COM_PROTECT_TRY
    {
		list< MachineNodeData * >::iterator it;
		
		//iterate the lazy list for server nodes to add server handlers
        for (it=m_pServerList->m_listServerHandlersToExpand.begin();
			 it!= m_pServerList->m_listServerHandlersToExpand.end() ; it++ )
        {
            AddServerNode(pNode, *it);			
            m_bExpanded=false;
        }

		// Refresh the entire status node in background thread 
		if((RouterRefreshObject*)m_spRefreshObject)
		{	
			UpdateUIItems(pNode);
			m_spRefreshObject->Refresh();
		}
		else	// if no refresh object, refresh it in main thread
			SynchronizeNode(pNode);

		// clear the lazy list
		m_pServerList->RemoveAllServerHandlers();     

    }
    COM_PROTECT_CATCH;

    m_bExpanded = TRUE;

    return hr;
}


/*!--------------------------------------------------------------------------
    DomainStatusHandler::GetString
        Implementation of ITFSNodeHandler::GetString
        We don't need to do anything, since our root node is an extension
        only and thus can't do anything to the node text.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) DomainStatusHandler::GetString(ITFSNode *pNode, int nCol)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
        if ( m_stTitle.IsEmpty() )
            m_stTitle.LoadString(IDS_DVS_SUMMARYNODE);
    }
    COM_PROTECT_CATCH;

    return m_stTitle;
}

/*!--------------------------------------------------------------------------
    DomainStatusHandler::OnCreateDataObject
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DomainStatusHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
        SPIDataObject  spdo;
        CDataObject*   pdo = NULL;

        pdo= new CDataObject;
        spdo = pdo;

            // Save cookie and type for delayed rendering
        pdo->SetType(type);
        pdo->SetCookie(cookie);

            // Store the coclass with the data object
        pdo->SetClsid(*(m_spTFSCompData->GetCoClassID()));

        pdo->SetTFSComponentData(m_spTFSCompData);

        *ppDataObject = spdo.Transfer();
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    DomainStatusHandler::Init
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DomainStatusHandler::Init(DMVConfigStream *pConfigStream, CServerList* pSList)
{
    HRESULT hr=S_OK;

    m_pConfigStream = pConfigStream;
    
    Assert(pSList);
    m_pServerList=pSList;
    
    m_bExpanded=FALSE;
    
    return hrOK;
}

/*!--------------------------------------------------------------------------
    DomainStatusHandler::ConstructNode
        Initializes the root node (sets it up).
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DomainStatusHandler::ConstructNode(ITFSNode *pNode)
{
    HRESULT         hr = hrOK;

    if ( pNode == NULL )
        return hrOK;

    COM_PROTECT_TRY
    {
        // Need to initialize the data for the root node
        pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_DOMAIN);
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_DOMAIN);
        pNode->SetData(TFS_DATA_SCOPEID, 0);

        // This is a leaf node in the scope pane
        pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

        m_cookie = reinterpret_cast<LONG_PTR>(pNode);
        pNode->SetData(TFS_DATA_COOKIE, m_cookie);

        pNode->SetNodeType(&GUID_DomainStatusNodeType);
    }
    COM_PROTECT_CATCH;

    return hr;
}



/*!--------------------------------------------------------------------------
    DomainStatusHandler::AddServerNode
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DomainStatusHandler::AddServerNode(ITFSNode *pParent, MachineNodeData* pMachineData)
{
    HRESULT                 hr = hrOK;
    Assert(pParent);
	Assert(pMachineData);

    DomainStatusServerHandler *      pHandler;
    SPITFSResultHandler     spHandler;
    SPITFSNode              spNode;

    // Create the handler for this node 
    pHandler = new DomainStatusServerHandler(m_spTFSCompData);
    spHandler = pHandler;
    CORg( pHandler->Init(pParent, m_pConfigStream) );

    // Create a result item node (or a leaf node)
    CORg( CreateLeafTFSNode(&spNode,
                            NULL,
                            static_cast<ITFSNodeHandler *>(pHandler),
                            static_cast<ITFSResultHandler *>(pHandler),
                            m_spNodeMgr) );
    CORg( pHandler->ConstructNode(spNode, pMachineData) );

	// set information for auto refresh
	if(m_spRefreshObject)
	{
	    pHandler->SetExternalRefreshObject(m_spRefreshObject);
		m_spRefreshObject->AddStatusNode(this, spNode);
	}
		
	// The data for this node will be set by the SynchronizeNode() call
	// in the code that calls this function.

    CORg( spNode->SetVisibilityState(TFS_VIS_SHOW) );
    CORg( spNode->Show() );
    CORg( pParent->AddChild(spNode) );

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    DomainStatusHandler::AddMenuItems
        Implementation of ITFSResultHandler::AddMenuItems
        Use this to add commands to the context menu of the blank areas
        of the result pane.
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DomainStatusHandler::AddMenuItems(ITFSComponent *pComponent,
                                           MMC_COOKIE cookie,
                                           LPDATAOBJECT pDataObject,
                                           LPCONTEXTMENUCALLBACK pCallback,
                                           long *pInsertionAllowed)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT     hr = hrOK;
    SPITFSNode  spNode;

    m_spNodeMgr->FindNode(cookie, &spNode);
    
    // Call through to the regular OnAddMenuItems
    hr = OnAddMenuItems(spNode,
                        pCallback,
                        pDataObject,
                        CCT_RESULT,
                        TFS_COMPDATA_CHILD_CONTEXTMENU,
                        pInsertionAllowed);
    return hr;
}


/*!--------------------------------------------------------------------------
    DomainStatusHandler::Command
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DomainStatusHandler::Command(ITFSComponent *pComponent,
                                      MMC_COOKIE cookie,
                                      int nCommandID,
                                      LPDATAOBJECT pDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	SPITFSNode	spNode;
	HRESULT		hr = hrOK;

    m_spNodeMgr->FindNode(cookie, &spNode);
    hr = OnCommand(spNode,
                   nCommandID,
                   CCT_RESULT,
                   pDataObject,
                   TFS_COMPDATA_CHILD_CONTEXTMENU);
	return hr;
}



ImplementEmbeddedUnknown(DomainStatusHandler, IRtrAdviseSink)

STDMETHODIMP DomainStatusHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
	DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
    InitPThis(DomainStatusHandler, IRtrAdviseSink);
    SPITFSNode              spThisNode;
    SPITFSNode              spRootNode;
    SPITFSNodeEnum          spEnumNode;
    SPIEnumInterfaceInfo    spEnumIf;
    SPIInterfaceInfo        spIf;
    SPIRtrMgrInterfaceInfo  spRmIf;
    SPIInfoBase             spInfoBase;
    BOOL                    fPleaseAdd;
    BOOL                    fFound;
    InterfaceNodeData * pData;
    HRESULT                 hr = hrOK;

    pThis->m_spNodeMgr->FindNode(pThis->m_cookie, &spThisNode);

    if ( dwObjectType == ROUTER_OBJ_RmProtIf )
    {
    }
    else
        if ( dwChangeType == ROUTER_REFRESH )
    {
        if ( ulConn == pThis->m_ulStatsConnId )
        {
//       pThis->m_ATLKGroupStats.PostRefresh();
        }
        else
//            pThis->SynchronizeNode(spThisNode);
            ;
    }

    // update all the machine node icons
	spThisNode->GetParent(&spRootNode);
	hr = DMVRootHandler::UpdateAllMachineIcons(spRootNode);
	
    
//Error:
    return hr;
}


/*!--------------------------------------------------------------------------
	DomainStatusHandler::GetServerInfo
		Gets the information for the specified summary node.
	Author: FlorinT
 ---------------------------------------------------------------------------*/
HRESULT DomainStatusHandler::GetServerInfo(ITFSNode *pNode)
{
    HRESULT         hr=S_OK;
    DMVNodeData     *pData;
    MachineNodeData *pMachineData;
    
    pData = GET_DMVNODEDATA(pNode);
    Assert(pData);
	pMachineData = pData->m_spMachineData;
	Assert(pMachineData);

	// Do a refresh of the data in the machine node data.
	pMachineData->Load();
	
	return hrOK;
}

/*!--------------------------------------------------------------------------
    DomainStatusHandler::SynchronizeIcon
        -
    Author: FlorinT
----------------------------------------------------------------------------*/
HRESULT DomainStatusHandler::SynchronizeIcon(ITFSNode *pNode)
{
    HRESULT                              hr = hrOK;
    DMVNodeData                          *pData;
    MachineNodeData                      *pMachineData;
    DomainStatusServerHandler::SMenuData menuData;
	LPARAM								imageIndex;

    pData = GET_DMVNODEDATA(pNode);
    Assert(pData);
    pMachineData = pData->m_spMachineData;
    Assert(pMachineData);
	
	imageIndex = pMachineData->GetServiceImageIndex();
	pNode->SetData(TFS_DATA_IMAGEINDEX, imageIndex);
	pNode->SetData(TFS_DATA_OPENIMAGEINDEX, imageIndex);
    return hr;
}

/*!--------------------------------------------------------------------------
    DomainStatusHandler::SynchronizeData
        -
    Author: FlorinT
----------------------------------------------------------------------------*/
HRESULT DomainStatusHandler::SynchronizeData(ITFSNode *pNode)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT         hr = hrOK;
    DMVNodeData     *pData;
    MachineNodeData *pMachineData;
    
    pData = GET_DMVNODEDATA(pNode);
    Assert(pData);
    pMachineData = pData->m_spMachineData;
    Assert(pMachineData);

    if(pMachineData->m_stMachineName.GetLength() == 0)
	    pData->m_rgData[DVS_SI_SERVERNAME].m_stData = GetLocalMachineName(); 
    else
	    pData->m_rgData[DVS_SI_SERVERNAME].m_stData = pMachineData->m_stMachineName;

    pData->m_rgData[DVS_SI_SERVERTYPE].m_stData = pMachineData->m_stServerType;
    pData->m_rgData[DVS_SI_BUILDNO].m_stData = pMachineData->m_stBuildNo;

    pData->m_rgData[DVS_SI_STATE].m_stData = pMachineData->m_stState; 
    if (pMachineData->m_fStatsRetrieved)
    {
       FillInNumberData(pData, DVS_SI_PORTSINUSE, pMachineData->m_dwPortsInUse);
       FillInNumberData(pData, DVS_SI_PORTSTOTAL, pMachineData->m_dwPortsTotal);

       if (pMachineData->m_routerType == ServerType_Rras)
       {
	       FormatDuration(pMachineData->m_dwUpTime,
					      pData->m_rgData[DVS_SI_UPTIME].m_stData,
					      1,
					      FDFLAG_DAYS | FDFLAG_HOURS | FDFLAG_MINUTES);
           pData->m_rgData[DVS_SI_UPTIME].m_dwData = pMachineData->m_dwUpTime;
       }
       else
       {
	       // This is a non-steelhead RAS server, so we don't
	       // have the uptime information.
	       pData->m_rgData[DVS_SI_UPTIME].m_stData.LoadString(IDS_NOT_AVAILABLE);
	       pData->m_rgData[DVS_SI_UPTIME].m_dwData = 0;
       }
    }
    else
    {
       pData->m_rgData[DVS_SI_PORTSINUSE].m_stData = c_szDash;
       pData->m_rgData[DVS_SI_PORTSINUSE].m_dwData = 0;
       pData->m_rgData[DVS_SI_PORTSTOTAL].m_stData = c_szDash;
       pData->m_rgData[DVS_SI_PORTSTOTAL].m_dwData = 0;
       pData->m_rgData[DVS_SI_UPTIME].m_stData = c_szDash;
       pData->m_rgData[DVS_SI_UPTIME].m_dwData = 0;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    DomainStatusHandler::UpdateSubItemUI
        -
    Author: WeiJiang
 ---------------------------------------------------------------------------*/
HRESULT DomainStatusHandler::SynchronizeSubItem(ITFSNode *pNode)
{
    HRESULT hr = hrOK;

	hr = GetServerInfo(pNode);
	if (hr == hrOK)
		hr = UpdateSubItemUI(pNode);
            
    return hr;
}

/*!--------------------------------------------------------------------------
    DomainStatusHandler::UpdateSubItemUI
        -
    Author: WeiJiang
 ---------------------------------------------------------------------------*/
HRESULT DomainStatusHandler::UpdateSubItemUI(ITFSNode *pNode)
{
    HRESULT hr = hrOK;

    hr = SynchronizeData(pNode);
	if (hr == hrOK)
		hr = SynchronizeIcon(pNode);
	{// update the corresponding machine node




	}
            
	pNode->ChangeNode(RESULT_PANE_CHANGE_ITEM);
    return hr;
}

/*!--------------------------------------------------------------------------
    DomainStatusHandler::UpdateUIItems
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DomainStatusHandler::UpdateUIItems(ITFSNode *pThisNode)
{
    HRESULT hr = hrOK;

    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spNode;
   	CWaitCursor		cw;

    COM_PROTECT_TRY
    {
        pThisNode->GetEnum(&spNodeEnum);
        while(spNodeEnum->Next(1, &spNode, NULL) == hrOK)
        {
			hr = UpdateSubItemUI(spNode);            
            spNode.Release();
        }
    }
    COM_PROTECT_CATCH;

    return hr;
}


/*!--------------------------------------------------------------------------
    DomainStatusHandler::SynchronizeNode
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DomainStatusHandler::SynchronizeNode(ITFSNode *pThisNode)
{
    HRESULT hr = hrOK;

    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spNode;
   	CWaitCursor		cw;

    COM_PROTECT_TRY
    {
        pThisNode->GetEnum(&spNodeEnum);
        while(spNodeEnum->Next(1, &spNode, NULL) == hrOK)
        {

	        hr = SynchronizeSubItem(spNode);
            if (hr == hrOK)
	            spNode->ChangeNode(RESULT_PANE_CHANGE_ITEM);

            spNode.Release();
        }
    }
    COM_PROTECT_CATCH;

    return hr;
}

/*!--------------------------------------------------------------------------
    DomainStatusHandler::GetDVSData
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DomainStatusHandler::GetDVServerData(ITFSNode *pThisNode)
{
    return hrOK;
}



/*!--------------------------------------------------------------------------
    DomainStatusHandler::OnResultShow
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DomainStatusHandler::OnResultShow(ITFSComponent *pTFSComponent,
									   MMC_COOKIE cookie,
									   LPARAM arg,
									   LPARAM lParam)
{
    BOOL    bSelect = (BOOL) arg;
    HRESULT hr = hrOK;
    SPIRouterRefresh    spRefresh;
    SPITFSNode  spNode;

    BaseContainerHandler::OnResultShow(pTFSComponent, cookie, arg, lParam);

    if ( bSelect )
    {
        hr = OnResultRefresh(pTFSComponent, NULL, cookie, arg, lParam);
    }

	// Un/Register for refresh advises
    if ((RouterRefreshObject*)m_spRefreshObject )
    {
        if ( bSelect )
        {
            if ( m_ulRefreshConnId == 0 )
                m_spRefreshObject->AdviseRefresh(&m_IRtrAdviseSink, &m_ulRefreshConnId, 0);
            if ( m_ulStatsConnId == 0 )
                m_spRefreshObject->AdviseRefresh(&m_IRtrAdviseSink, &m_ulStatsConnId, 0);
        }
        else
        {
            if ( m_ulRefreshConnId )
                m_spRefreshObject->UnadviseRefresh(m_ulRefreshConnId);
            m_ulRefreshConnId = 0;
       }
    }

    return hr;
}


/*!--------------------------------------------------------------------------
	DomainStatusHandler::OnResultRefresh
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DomainStatusHandler::OnResultRefresh(ITFSComponent * pComponent,
										  LPDATAOBJECT pDataObject,
										  MMC_COOKIE cookie,
										  LPARAM arg,
										  LPARAM lParam)
{
    SPITFSNode	    spThisNode;
   	CWaitCursor		cw;

    m_spResultNodeMgr->FindNode(cookie, &spThisNode);

	return OnCommand(spThisNode, IDS_MENU_REFRESH, CCT_RESULT, NULL, 0);
}


/*!--------------------------------------------------------------------------
    DomainStatusHandler::CompareItems
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int) DomainStatusHandler::CompareItems(
                                                ITFSComponent * pComponent,
                                                MMC_COOKIE cookieA,
                                                MMC_COOKIE cookieB,
                                                int nCol)
{
    // Get the strings from the nodes and use that as a basis for
    // comparison.
    SPITFSNode  spNode;
    SPITFSResultHandler spResult;

    m_spNodeMgr->FindNode(cookieA, &spNode);
    spNode->GetResultHandler(&spResult);
    return spResult->CompareItems(pComponent, cookieA, cookieB, nCol);
}


/*---------------------------------------------------------------------------
    Class: DomainStatusServerHandler
 ---------------------------------------------------------------------------*/

DomainStatusServerHandler::DomainStatusServerHandler(ITFSComponentData *pCompData)
: BaseResultHandler(pCompData, DM_COLUMNS_DVSUM)
{
   m_rgButtonState[MMC_VERB_DELETE_INDEX] = ENABLED;
   m_bState[MMC_VERB_DELETE_INDEX] = TRUE;

//    m_verbDefault = MMC_VERB_PROPERTIES;
}

DomainStatusServerHandler::~DomainStatusServerHandler()
{
}

/*!--------------------------------------------------------------------------
    DomainStatusServerHandler::ConstructNode
        Initializes the Domain node (sets it up).
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DomainStatusServerHandler::ConstructNode(ITFSNode *pNode, MachineNodeData *pMachineData)
{
    HRESULT         hr = hrOK;
    int             i;

    if ( pNode == NULL )
        return hrOK;

    COM_PROTECT_TRY
    {
        pNode->SetData(TFS_DATA_SCOPEID, 0);

        pNode->SetData(TFS_DATA_COOKIE, reinterpret_cast<LONG_PTR>(pNode));

        pNode->SetNodeType(&GUID_DVSServerNodeType);

        DMVNodeData::InitDMVNodeData(pNode, pMachineData);
    }
    COM_PROTECT_CATCH
    return hr;
}

HRESULT	DomainStatusServerHandler::SetExternalRefreshObject(RouterRefreshObject *pRefresh)
{
	Assert(!m_spRefreshObject);	// set twice is not allowed
	Assert(pRefresh);
	m_spRefreshObject = pRefresh;
	if(m_spRefreshObject)
		m_spRefreshObject->AddRef();

	return S_OK;
};

/*!--------------------------------------------------------------------------
    DomainStatusServerHandler::GetString
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) DomainStatusServerHandler::GetString(ITFSComponent * pComponent,
	MMC_COOKIE cookie,
	int nCol)
{
   Assert(m_spNodeMgr);
   
   SPITFSNode     spNode;
   DMVNodeData *pData;
   ConfigStream * pConfig;

   m_spNodeMgr->FindNode(cookie, &spNode);
   Assert(spNode);

   pData = GET_DMVNODEDATA(spNode);
   Assert(pData);

   pComponent->GetUserData((LONG_PTR *) &pConfig);
   Assert(pConfig);

   return pData->m_rgData[pConfig->MapColumnToSubitem(DM_COLUMNS_DVSUM, nCol)].m_stData;
}

/*!--------------------------------------------------------------------------
    DomainStatusServerHandler::OnCreateDataObject
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DomainStatusServerHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
        SPIDataObject  spdo;
        CDataObject*   pdo = NULL;

        pdo= new CDataObject;
        spdo = pdo;

            // Save cookie and type for delayed rendering
        pdo->SetType(type);
        pdo->SetCookie(cookie);

            // Store the coclass with the data object
        pdo->SetClsid(*(m_spTFSCompData->GetCoClassID()));

        pdo->SetTFSComponentData(m_spTFSCompData);

        *ppDataObject = spdo.Transfer();
    }
    COM_PROTECT_CATCH;
    return hr;
}


/*!--------------------------------------------------------------------------
    DomainStatusServerHandler::OnCreateDataObject
        Implementation of ITFSResultHandler::OnCreateDataObject
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DomainStatusServerHandler::OnCreateDataObject(ITFSComponent *pComp,
	MMC_COOKIE cookie,
	DATA_OBJECT_TYPES type,
	IDataObject **ppDataObject)
{
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
        SPIDataObject  spdo;
        CDataObject*   pdo = NULL;

        pdo= new CDataObject;
        spdo = pdo;

            // Save cookie and type for delayed rendering
        pdo->SetType(type);
        pdo->SetCookie(cookie);

            // Store the coclass with the data object
        pdo->SetClsid(*(m_spTFSCompData->GetCoClassID()));

        pdo->SetTFSComponentData(m_spTFSCompData);

        *ppDataObject = spdo.Transfer();
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    DomainStatusServerHandler::RefreshInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void DomainStatusServerHandler::RefreshInterface(MMC_COOKIE cookie)
{
    SPITFSNode  spNode;
    SPITFSNode  spParent;
    SPITFSNodeHandler   spHandler;

    m_spNodeMgr->FindNode(cookie, &spNode);

    // Can't do it for a single node at this time, just refresh the
    // whole thing.
    spNode->GetParent(&spParent);
    spParent->GetHandler(&spHandler);

    spHandler->OnCommand(spParent,
                         IDS_MENU_REFRESH,
                         CCT_RESULT, NULL, 0);
}


/*!--------------------------------------------------------------------------
    DomainStatusServerHandler::Init
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DomainStatusServerHandler::Init(ITFSNode *pParent, DMVConfigStream *pConfigStream)
{
    BaseResultHandler::Init(NULL, pParent);

    return hrOK;
}


/*!--------------------------------------------------------------------------
    DomainStatusServerHandler::DestroyResultHandler
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DomainStatusServerHandler::DestroyResultHandler(MMC_COOKIE cookie)
{
   SPITFSNode  spNode;

   m_spNodeMgr->FindNode(cookie, &spNode);
   
   if((RouterRefreshObject*)m_spRefreshObject)
   {
   		m_spRefreshObject->RemoveStatusNode(spNode);
   }
   		
   DMVNodeData::FreeDMVNodeData(spNode);
   
   CHandler::DestroyResultHandler(cookie);
   return hrOK;
}


/*---------------------------------------------------------------------------
    This is the list of commands that will show up for the result pane
    nodes.
 ---------------------------------------------------------------------------*/
struct SIPServerNodeMenu
{
    ULONG   m_sidMenu;          // string/command id for this menu item
    ULONG   (DomainStatusServerHandler:: *m_pfnGetMenuFlags)(DomainStatusServerHandler::SMenuData *);
    ULONG   m_ulPosition;
};

static const SRouterNodeMenu   s_rgServerMenu[] =
{
    // Add items that go at the top here
    { IDS_MENU_RTRWIZ, DomainStatusServerHandler::QueryService,
        CCM_INSERTIONPOINTID_PRIMARY_TOP},
    { IDS_DMV_MENU_REMOVESERVICE, DomainStatusServerHandler::QueryService,
        CCM_INSERTIONPOINTID_PRIMARY_TOP},
    { IDS_DMV_MENU_REFRESH, 0,
        CCM_INSERTIONPOINTID_PRIMARY_TOP},
    { IDS_DMV_MENU_REBUILDSVRLIST, 0,
        CCM_INSERTIONPOINTID_PRIMARY_TOP},
    { IDS_DMV_MENU_REMOVEFROMDIR, 0,
        CCM_INSERTIONPOINTID_PRIMARY_TOP},
        
    { IDS_DMV_MENU_START, DomainStatusServerHandler::QueryService,
        CCM_INSERTIONPOINTID_PRIMARY_TASK},
    { IDS_DMV_MENU_STOP, DomainStatusServerHandler::QueryService,
        CCM_INSERTIONPOINTID_PRIMARY_TASK},        
    { IDS_MENU_PAUSE_SERVICE, MachineHandler::GetPauseFlags,
        CCM_INSERTIONPOINTID_PRIMARY_TASK },
    
    { IDS_MENU_RESUME_SERVICE, MachineHandler::GetPauseFlags,
        CCM_INSERTIONPOINTID_PRIMARY_TASK },

    { IDS_MENU_RESTART_SERVICE, MachineHandler::QueryService,
        CCM_INSERTIONPOINTID_PRIMARY_TASK }
};

   
/*---------------------------------------------------------------------------
	Use this menu for servers which we cannot connect to.
 ---------------------------------------------------------------------------*/
static const SRouterNodeMenu   s_rgBadConnectionServerMenu[] =
{
    // Add items that go at the top here
    { IDS_DMV_MENU_REFRESH, 0,
        CCM_INSERTIONPOINTID_PRIMARY_TOP},
    { IDS_DMV_MENU_REBUILDSVRLIST, 0,
        CCM_INSERTIONPOINTID_PRIMARY_TOP},
};

   
ULONG DomainStatusServerHandler::QueryService(const SRouterNodeMenu *pMenuData,
                                              INT_PTR pUserData)
{
    // This relies on the fact that the DomainStatusServerHandler::SMenuData
    // is derived from the MachineHandler::SMenuData
    return MachineHandler::GetServiceFlags(pMenuData, pUserData);
}


ULONG DomainStatusServerHandler::GetPauseFlags(const SRouterNodeMenu *pMenuData,
                                               INT_PTR pUserData)
{
    // This relies on the fact that the DomainStatusServerHandler::SMenuData
    // is derived from the MachineHandler::SMenuData
    return MachineHandler::GetPauseFlags(pMenuData, pUserData);
}


/*!--------------------------------------------------------------------------
    DomainStatusServerHandler::AddMenuItems
        Implementation of ITFSResultHandler::AddMenuItems
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DomainStatusServerHandler::AddMenuItems(
                                               ITFSComponent *pComponent,
                                               MMC_COOKIE cookie,
                                               LPDATAOBJECT lpDataObject, 
                                               LPCONTEXTMENUCALLBACK pContextMenuCallback, 
                                               long *pInsertionAllowed)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    SPITFSNode  spNode;
    DomainStatusServerHandler::SMenuData menuData;
    DMVNodeData *pData;
	MachineNodeData * pMachineData;
    SRouterNodeMenu * prgMenu;
    DWORD       cMenu;

    COM_PROTECT_TRY
    {
        m_spNodeMgr->FindNode(cookie, &spNode);

        pData = GET_DMVNODEDATA(spNode);
		Assert(pData);
		
		pMachineData = pData->m_spMachineData;
		Assert(pMachineData);

        if (pMachineData->m_machineState != machine_connected)
        {
            prgMenu = (SRouterNodeMenu *) s_rgBadConnectionServerMenu;
            cMenu = DimensionOf(s_rgBadConnectionServerMenu);
        }
        else
        {
            prgMenu = (SRouterNodeMenu *) s_rgServerMenu;
            cMenu = DimensionOf(s_rgServerMenu);
        }
		
        // Now go through and add our menu items
        menuData.m_spNode.Set(spNode);
        menuData.m_pMachineConfig = &(pMachineData->m_MachineConfig);

        hr = AddArrayOfMenuItems(spNode,
                                 prgMenu,
                                 cMenu,
                                 pContextMenuCallback,
                                 *pInsertionAllowed,
                                 (INT_PTR) &menuData);

    }
    COM_PROTECT_CATCH;

    return hr;
}

/*!--------------------------------------------------------------------------
    DomainStatusServerHandler::Command
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DomainStatusServerHandler::Command(ITFSComponent *pComponent,
                                           MMC_COOKIE cookie,
                                           int nCommandID,
                                           LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    SPITFSNode  spNode;
    SPITFSNode  spNodeMach;
    SPITFSNode  spParent;
    SPITFSResultHandler spResult;
    SPITFSNodeHandler   spHandler;
    HRESULT     hr = hrOK;
    DMVNodeData *pData;
	MachineNodeData * pMachineData;
    
    m_spNodeMgr->FindNode(cookie, &spNode);

    switch ( nCommandID )
    {
    case IDS_DMV_MENU_REFRESH:
 	    hr = DomainStatusHandler::SynchronizeSubItem(spNode);

    case IDS_MENU_RTRWIZ:
    case IDS_DMV_MENU_START:
    case IDS_DMV_MENU_STOP:
    case IDS_DMV_MENU_REMOVESERVICE:
    case IDS_MENU_PAUSE_SERVICE:
    case IDS_MENU_RESUME_SERVICE:
    case IDS_MENU_RESTART_SERVICE:
        pData = GET_DMVNODEDATA(spNode);
		Assert(pData);
		
		pMachineData = pData->m_spMachineData;
		Assert(pMachineData);
		
		m_spNodeMgr->FindNode(pMachineData->m_cookie, &spNodeMach);
		spNodeMach->GetHandler(&spHandler);

		hr = spHandler->OnCommand(spNodeMach,nCommandID,CCT_RESULT,NULL, 0);

        break;

    case IDS_DMV_MENU_REBUILDSVRLIST:
		// Forward the refresh request to the parent node
		//$ todo : is this really needed?  This should check to see what
		// node has the selection.
		spParent.Release();
		spHandler.Release();
		
        spNode->GetParent(&spParent);
        spParent->GetHandler(&spHandler);
        spHandler->OnCommand(spParent,nCommandID,CCT_RESULT, NULL, 0);
        break;
		
    case IDS_DMV_MENU_REMOVEFROMDIR:
        pData = GET_DMVNODEDATA(spNode);
		Assert(pData);
		
		pMachineData = pData->m_spMachineData;
		Assert(pMachineData);
		
		hr = RRASDelRouterIdObj(  pMachineData->m_stMachineName );
        break;
	default:
		break;
    }
    return hr;
}

/*!--------------------------------------------------------------------------
    DomainStatusServerHandler::HasPropertyPages
        - 
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DomainStatusServerHandler::HasPropertyPages 
(
ITFSNode *          pNode,
LPDATAOBJECT        pDataObject, 
DATA_OBJECT_TYPES   type, 
DWORD               dwType
)
{
    return hrFalse;
}

/*!--------------------------------------------------------------------------
    DomainStatusServerHandler::CreatePropertyPages
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DomainStatusServerHandler::CreatePropertyPages
(
ITFSNode *              pNode,
LPPROPERTYSHEETCALLBACK lpProvider,
LPDATAOBJECT            pDataObject, 
LONG_PTR                    handle, 
DWORD                   dwType)
{
    HRESULT     hr = hrOK;

    return hr;
}

/*!--------------------------------------------------------------------------
    DomainStatusServerHandler::CreatePropertyPages
        Implementation of ResultHandler::CreatePropertyPages
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP DomainStatusServerHandler::CreatePropertyPages
(
    ITFSComponent *         pComponent, 
    MMC_COOKIE                    cookie,
    LPPROPERTYSHEETCALLBACK lpProvider, 
    LPDATAOBJECT            pDataObject, 
    LONG_PTR                    handle
)
{
    // Forward this call onto the NodeHandler::CreatePropertyPages
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = hrOK;
    SPITFSNode  spNode;

    Assert( m_spNodeMgr );

    CORg( m_spNodeMgr->FindNode(cookie, &spNode) );

    // Call the ITFSNodeHandler::CreatePropertyPages
    hr = CreatePropertyPages(spNode, lpProvider, pDataObject, handle, 0);

    Error:
    return hr;
}



/*!--------------------------------------------------------------------------
    DomainStatusServerHandler::OnResultDelete
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DomainStatusServerHandler::OnResultDelete(ITFSComponent *pComponent,
										 LPDATAOBJECT pDataObject,
										 MMC_COOKIE cookie,
										 LPARAM arg,
										 LPARAM param)
{
    SPITFSNode  spNode;
    m_spNodeMgr->FindNode(cookie, &spNode);
    return OnRemoveServer(spNode);
}


/*!--------------------------------------------------------------------------
    DomainStatusServerHandler::OnRemoveServer
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT DomainStatusServerHandler::OnRemoveServer(ITFSNode *pNode)
{
	SPITFSNodeHandler spHoldHandler;
	SPITFSNode  spParent;
	SPITFSNode  spGrandParent;
	SPITFSNode  spthis;
	SPITFSNode  spMachineNode;
	DMVNodeData* pData;
	MachineNodeData *	pMachineData;
	
	Assert(pNode);
	
	pNode->GetParent( &spParent );
	Assert( spParent );
	
	// Addref this node so that it won't get deleted before we're out
	// of this function
	spHoldHandler.Set( this );
	spthis.Set( pNode );

	// Look for the machine node
	pData = GET_DMVNODEDATA( pNode );
	Assert( pData );
	pMachineData = pData->m_spMachineData;
	m_spNodeMgr->FindNode(pMachineData->m_cookie, &spMachineNode);
	
	// delete the machine node (the node in the scope pane)
	spParent->GetParent( &spGrandParent );
	Assert( spGrandParent );
	spGrandParent->RemoveChild( spMachineNode );
	
	// fetch & delete server node (the node in the result pane)
	spParent->RemoveChild( pNode );
	
	return hrOK;
}


STDMETHODIMP_(int) DomainStatusServerHandler::CompareItems(ITFSComponent * pComponent,
	MMC_COOKIE cookieA,
	MMC_COOKIE cookieB,
	int nCol)
{
	ConfigStream *	pConfig;
	pComponent->GetUserData((LONG_PTR *) &pConfig);
	Assert(pConfig);

	int	nSubItem = pConfig->MapColumnToSubitem(m_ulColumnId, nCol);


	if (pConfig->GetSortCriteria(m_ulColumnId, nCol) == CON_SORT_BY_DWORD)
	{
		SPITFSNode	spNodeA, spNodeB;
        DMVNodeData *  pNodeDataA = NULL;
        DMVNodeData *  pNodeDataB = NULL;

		m_spNodeMgr->FindNode(cookieA, &spNodeA);
		m_spNodeMgr->FindNode(cookieB, &spNodeB);

		pNodeDataA = GET_DMVNODEDATA(spNodeA);
        Assert(pNodeDataA);
		
		pNodeDataB = GET_DMVNODEDATA(spNodeB);
        Assert(pNodeDataB);

        // Note: if the values are both zero, we need to do
        // a string comparison (to distinuguish true zero
        // from a NULL data).
        // e.g. "0" vs. "-"
        
        if ((pNodeDataA->m_rgData[nSubItem].m_dwData == 0 ) &&
            (pNodeDataB->m_rgData[nSubItem].m_dwData == 0))
        {
            return StriCmpW(GetString(pComponent, cookieA, nCol),
                            GetString(pComponent, cookieB, nCol));
        }
        else
            return pNodeDataA->m_rgData[nSubItem].m_dwData -
                    pNodeDataB->m_rgData[nSubItem].m_dwData;
		
	}
	else
		return StriCmpW(GetString(pComponent, cookieA, nCol),
						GetString(pComponent, cookieB, nCol));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\enum.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	info.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "infoi.h"

/*---------------------------------------------------------------------------
	Class:	EnumRtrMgrCB

	Definition and implementation
 ---------------------------------------------------------------------------*/
class EnumRtrMgrCB
		: public IEnumRtrMgrCB
{
public:
 	DeclareIUnknownMembers(IMPL)
	DeclareIEnumRtrMgrCBMembers(IMPL)

	EnumRtrMgrCB() : m_cRef(1)
	{
		DEBUG_INCREMENT_INSTANCE_COUNTER(EnumRtrMgrCB);
	}

#ifdef DEBUG
	~EnumRtrMgrCB()
	{
		DEBUG_DECREMENT_INSTANCE_COUNTER(EnumRtrMgrCB);
	}
#endif
	
	HRESULT Init(SRtrMgrCBList *pRmCBList);
	
protected:
	LONG			m_cRef;
	POSITION		m_pos;
	SRtrMgrCBList *	m_pRmCBList;
};

IMPLEMENT_ADDREF_RELEASE(EnumRtrMgrCB);

IMPLEMENT_SIMPLE_QUERYINTERFACE(EnumRtrMgrCB, IEnumRtrMgrCB)

DEBUG_DECLARE_INSTANCE_COUNTER(EnumRtrMgrCB)

HRESULT EnumRtrMgrCB::Init(SRtrMgrCBList *pRmCBList)
{
	m_pRmCBList = pRmCBList;
	Reset();
	return hrOK;
}

HRESULT EnumRtrMgrCB::Next(ULONG uNum, RtrMgrCB *pRmCB, ULONG *pNumReturned)
{
	Assert(uNum == 1);
	Assert(pRmCB);
	
	HRESULT	hr = hrOK;
	SRtrMgrCB	*pSRmCB;
	
	COM_PROTECT_TRY
	{
		if (m_pos)
		{
			pSRmCB = m_pRmCBList->GetNext(m_pos);
			Assert(pSRmCB);

			pSRmCB->SaveTo(pRmCB);

			if (pNumReturned)
				*pNumReturned = 1;
			hr = hrOK;
		}
		else
		{
			if (pNumReturned)
				*pNumReturned = 0;
			hr = hrFalse;
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrCB::Skip(ULONG uNum)
{
	Assert(uNum == 1);
	
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		if (m_pos)
		{
			m_pRmCBList->GetNext(m_pos);
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrCB::Reset()
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		m_pos = m_pRmCBList->GetHeadPosition();
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrCB::Clone(IEnumRtrMgrCB **ppBlockEnum)
{
	return E_NOTIMPL;
}


/*---------------------------------------------------------------------------
	Class:	EnumRtrMgrProtocolCB
 ---------------------------------------------------------------------------*/
class EnumRtrMgrProtocolCB
		: public IEnumRtrMgrProtocolCB
{
public:
 	DeclareIUnknownMembers(IMPL)
	DeclareIEnumRtrMgrProtocolCBMembers(IMPL)
			
	EnumRtrMgrProtocolCB() : m_cRef(1)
	{
		DEBUG_INCREMENT_INSTANCE_COUNTER(EnumRtrMgrProtocolCB);
	}
#ifdef DEBUG
	~EnumRtrMgrProtocolCB()
	{
		DEBUG_DECREMENT_INSTANCE_COUNTER(EnumRtrMgrProtocolCB);
	}
#endif
	
	HRESULT Init(SRtrMgrProtocolCBList *pRmProtCBList);
	
protected:
	LONG			m_cRef;
	POSITION		m_pos;
	SRtrMgrProtocolCBList *	m_pRmProtCBList;
};

IMPLEMENT_ADDREF_RELEASE(EnumRtrMgrProtocolCB);

IMPLEMENT_SIMPLE_QUERYINTERFACE(EnumRtrMgrProtocolCB, IEnumRtrMgrProtocolCB)

DEBUG_DECLARE_INSTANCE_COUNTER(EnumRtrMgrProtocolCB)

HRESULT EnumRtrMgrProtocolCB::Init(SRtrMgrProtocolCBList *pRmProtCBList)
{
	m_pRmProtCBList = pRmProtCBList;
	Reset();
	return hrOK;
}

HRESULT EnumRtrMgrProtocolCB::Next(ULONG uNum, RtrMgrProtocolCB *pRmProtCB, ULONG *pNumReturned)
{
	Assert(uNum == 1);
	Assert(pRmProtCB);
	
	HRESULT	hr = hrOK;
	SRtrMgrProtocolCB	*pSRmProtCB;
	
	COM_PROTECT_TRY
	{
		if (m_pos)
		{
			pSRmProtCB = m_pRmProtCBList->GetNext(m_pos);
			Assert(pSRmProtCB);

			pSRmProtCB->SaveTo(pRmProtCB);

			if (pNumReturned)
				*pNumReturned = 1;
			hr = hrOK;
		}
		else
		{
			if (pNumReturned)
				*pNumReturned = 0;
			hr = hrFalse;
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrProtocolCB::Skip(ULONG uNum)
{
	Assert(uNum == 1);
	
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		if (m_pos)
		{
			m_pRmProtCBList->GetNext(m_pos);
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrProtocolCB::Reset()
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		m_pos = m_pRmProtCBList->GetHeadPosition();
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrProtocolCB::Clone(IEnumRtrMgrProtocolCB **ppBlockEnum)
{
	return E_NOTIMPL;
}



/*---------------------------------------------------------------------------
	Class:	EnumInterfaceCB
 ---------------------------------------------------------------------------*/
class EnumInterfaceCB
		: public IEnumInterfaceCB
{
public:
 	DeclareIUnknownMembers(IMPL)
	DeclareIEnumInterfaceCBMembers(IMPL)
			
	EnumInterfaceCB() : m_cRef(1)
	{
		DEBUG_INCREMENT_INSTANCE_COUNTER(EnumInterfaceCB);
	}
#ifdef DEBUG
	~EnumInterfaceCB()
	{
		DEBUG_DECREMENT_INSTANCE_COUNTER(EnumInterfaceCB);
	}
#endif
		
	
	HRESULT Init(SInterfaceCBList *pIfCBList);
	
protected:
	LONG			m_cRef;
	POSITION		m_pos;
	SInterfaceCBList *	m_pIfCBList;
};

IMPLEMENT_ADDREF_RELEASE(EnumInterfaceCB);

IMPLEMENT_SIMPLE_QUERYINTERFACE(EnumInterfaceCB, IEnumInterfaceCB)

DEBUG_DECLARE_INSTANCE_COUNTER(EnumInterfaceCB)

HRESULT EnumInterfaceCB::Init(SInterfaceCBList *pIfCBList)
{
	m_pIfCBList = pIfCBList;
	Reset();
	return hrOK;
}

HRESULT EnumInterfaceCB::Next(ULONG uNum, InterfaceCB *pIfCB, ULONG *pNumReturned)
{
	Assert(uNum == 1);
	Assert(pIfCB);
	
	HRESULT	hr = hrOK;
	SInterfaceCB	*pSIfCB;
	
	COM_PROTECT_TRY
	{
		if (m_pos)
		{
			pSIfCB = m_pIfCBList->GetNext(m_pos);
			Assert(pSIfCB);

			pSIfCB->SaveTo(pIfCB);

			if (pNumReturned)
				*pNumReturned = 1;
			hr = hrOK;
		}
		else
		{
			if (pNumReturned)
				*pNumReturned = 0;
			hr = hrFalse;
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumInterfaceCB::Skip(ULONG uNum)
{
	Assert(uNum == 1);
	
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		if (m_pos)
		{
			m_pIfCBList->GetNext(m_pos);
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumInterfaceCB::Reset()
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		m_pos = m_pIfCBList->GetHeadPosition();
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumInterfaceCB::Clone(IEnumInterfaceCB **ppBlockEnum)
{
	return E_NOTIMPL;
}


/*---------------------------------------------------------------------------
	Class:	EnumRtrMgrInterfaceCB
 ---------------------------------------------------------------------------*/
class EnumRtrMgrInterfaceCB
		: public IEnumRtrMgrInterfaceCB
{
public:
 	DeclareIUnknownMembers(IMPL)
	DeclareIEnumRtrMgrInterfaceCBMembers(IMPL)
			
	EnumRtrMgrInterfaceCB() : m_cRef(1)
	{
		DEBUG_INCREMENT_INSTANCE_COUNTER(EnumRtrMgrInterfaceCB);
	}
	
#ifdef DEBUG
	~EnumRtrMgrInterfaceCB()
	{
		DEBUG_DECREMENT_INSTANCE_COUNTER(EnumRtrMgrInterfaceCB);
	}
#endif
	
	HRESULT Init(SRtrMgrInterfaceCBList *pRmIfCBList);
	
protected:
	LONG			m_cRef;
	POSITION		m_pos;
	SRtrMgrInterfaceCBList *	m_pRmIfCBList;
};

IMPLEMENT_ADDREF_RELEASE(EnumRtrMgrInterfaceCB);

IMPLEMENT_SIMPLE_QUERYINTERFACE(EnumRtrMgrInterfaceCB, IEnumRtrMgrInterfaceCB)

DEBUG_DECLARE_INSTANCE_COUNTER(EnumRtrMgrInterfaceCB)

HRESULT EnumRtrMgrInterfaceCB::Init(SRtrMgrInterfaceCBList *pRmIfCBList)
{
	m_pRmIfCBList = pRmIfCBList;
	Reset();
	return hrOK;
}

HRESULT EnumRtrMgrInterfaceCB::Next(ULONG uNum, RtrMgrInterfaceCB *pRmIfCB, ULONG *pNumReturned)
{
	Assert(uNum == 1);
	Assert(pRmIfCB);
	
	HRESULT	hr = hrOK;
	SRtrMgrInterfaceCB	*pSRmIfCB;
	
	COM_PROTECT_TRY
	{
		if (m_pos)
		{
			pSRmIfCB = m_pRmIfCBList->GetNext(m_pos);
			Assert(pSRmIfCB);

			pSRmIfCB->SaveTo(pRmIfCB);

			if (pNumReturned)
				*pNumReturned = 1;
			hr = hrOK;
		}
		else
		{
			if (pNumReturned)
				*pNumReturned = 0;
			hr = hrFalse;
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrInterfaceCB::Skip(ULONG uNum)
{
	Assert(uNum == 1);
	
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		if (m_pos)
		{
			m_pRmIfCBList->GetNext(m_pos);
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrInterfaceCB::Reset()
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		m_pos = m_pRmIfCBList->GetHeadPosition();
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrInterfaceCB::Clone(IEnumRtrMgrInterfaceCB **ppBlockEnum)
{
	return E_NOTIMPL;
}


/*---------------------------------------------------------------------------
	Class:	EnumRtrMgrInterfaceProtocolCB
 ---------------------------------------------------------------------------*/

class EnumRtrMgrProtocolInterfaceCB
		: public IEnumRtrMgrProtocolInterfaceCB
{
public:
 	DeclareIUnknownMembers(IMPL)
	DeclareIEnumRtrMgrProtocolInterfaceCBMembers(IMPL)
			
	EnumRtrMgrProtocolInterfaceCB() : m_cRef(1)
	{
		DEBUG_INCREMENT_INSTANCE_COUNTER(EnumRtrMgrProtocolInterfaceCB);
	}
	
#ifdef DEBUG
	~EnumRtrMgrProtocolInterfaceCB()
	{
		DEBUG_DECREMENT_INSTANCE_COUNTER(EnumRtrMgrProtocolInterfaceCB);
	}
#endif
	
	HRESULT Init(SRtrMgrProtocolInterfaceCBList *pRmProtIfCBList);
	
protected:
	LONG			m_cRef;
	POSITION		m_pos;
	SRtrMgrProtocolInterfaceCBList *	m_pRmProtIfCBList;
};

IMPLEMENT_ADDREF_RELEASE(EnumRtrMgrProtocolInterfaceCB);

IMPLEMENT_SIMPLE_QUERYINTERFACE(EnumRtrMgrProtocolInterfaceCB, IEnumRtrMgrProtocolInterfaceCB)

DEBUG_DECLARE_INSTANCE_COUNTER(EnumRtrMgrProtocolInterfaceCB)

HRESULT EnumRtrMgrProtocolInterfaceCB::Init(SRtrMgrProtocolInterfaceCBList *pRmProtIfCBList)
{
	m_pRmProtIfCBList = pRmProtIfCBList;
	Reset();
	return hrOK;
}

HRESULT EnumRtrMgrProtocolInterfaceCB::Next(ULONG uNum, RtrMgrProtocolInterfaceCB *pRmProtIfCB, ULONG *pNumReturned)
{
	Assert(uNum == 1);
	Assert(pRmProtIfCB);
	
	HRESULT	hr = hrOK;
	SRtrMgrProtocolInterfaceCB	*pSRmProtIfCB;
	
	COM_PROTECT_TRY
	{
		if (m_pos)
		{
			pSRmProtIfCB = m_pRmProtIfCBList->GetNext(m_pos);
			Assert(pSRmProtIfCB);

			pSRmProtIfCB->SaveTo(pRmProtIfCB);

			if (pNumReturned)
				*pNumReturned = 1;
			hr = hrOK;
		}
		else
		{
			if (pNumReturned)
				*pNumReturned = 0;
			hr = hrFalse;
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrProtocolInterfaceCB::Skip(ULONG uNum)
{
	Assert(uNum == 1);
	
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		if (m_pos)
		{
			m_pRmProtIfCBList->GetNext(m_pos);
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrProtocolInterfaceCB::Reset()
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		m_pos = m_pRmProtIfCBList->GetHeadPosition();
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrProtocolInterfaceCB::Clone(IEnumRtrMgrProtocolInterfaceCB **ppBlockEnum)
{
	return E_NOTIMPL;
}



/*!--------------------------------------------------------------------------
	CreateEnumFromSRmCBList
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CreateEnumFromSRmCBList(SRtrMgrCBList *pRmCBList,
								IEnumRtrMgrCB **ppEnum)
{
  	Assert(pRmCBList);
	Assert(ppEnum);
	
	HRESULT		hr = hrOK;
	EnumRtrMgrCB *	pEnum;

	pEnum = new EnumRtrMgrCB;
	hr = pEnum->Init(pRmCBList);
	if (!FHrSucceeded(hr))
	{
		pEnum->Release();
		pEnum = NULL;
	}

	*ppEnum = pEnum;
	return hr;
}

/*!--------------------------------------------------------------------------
	CreateEnumFromSRmProtCBList
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CreateEnumFromSRmProtCBList(SRtrMgrProtocolCBList *pRmProtCBList,
									IEnumRtrMgrProtocolCB **ppEnum)
{
  	Assert(pRmProtCBList);
	Assert(ppEnum);
	
	HRESULT		hr = hrOK;
	EnumRtrMgrProtocolCB *	pEnum;

	pEnum = new EnumRtrMgrProtocolCB;
	hr = pEnum->Init(pRmProtCBList);
	if (!FHrSucceeded(hr))
	{
		pEnum->Release();
		pEnum = NULL;
	}

	*ppEnum = pEnum;
	return hr;
}

/*!--------------------------------------------------------------------------
	CreateEnumFromSIfCBList
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CreateEnumFromSIfCBList(SInterfaceCBList *pIfCBList,
								IEnumInterfaceCB **ppEnum)
{
  	Assert(pIfCBList);
	Assert(ppEnum);
	
	HRESULT		hr = hrOK;
	EnumInterfaceCB *	pEnum;

	pEnum = new EnumInterfaceCB;
	hr = pEnum->Init(pIfCBList);
	if (!FHrSucceeded(hr))
	{
		pEnum->Release();
		pEnum = NULL;
	}

	*ppEnum = pEnum;
	return hr;
}

/*!--------------------------------------------------------------------------
	CreateEnumFromSRmIfCBList
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CreateEnumFromSRmIfCBList(SRtrMgrInterfaceCBList *pRmIfCBList,
								  IEnumRtrMgrInterfaceCB **ppEnum)
{
  	Assert(pRmIfCBList);
	Assert(ppEnum);
	
	HRESULT		hr = hrOK;
	EnumRtrMgrInterfaceCB *	pEnum;

	pEnum = new EnumRtrMgrInterfaceCB;
	hr = pEnum->Init(pRmIfCBList);
	if (!FHrSucceeded(hr))
	{
		pEnum->Release();
		pEnum = NULL;
	}

	*ppEnum = pEnum;
	return hr;
}

/*!--------------------------------------------------------------------------
	CreateEnumFromSRmProtIfCBList
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CreateEnumFromSRmProtIfCBList(SRtrMgrProtocolInterfaceCBList *pRmProtIfCBList,
									  IEnumRtrMgrProtocolInterfaceCB **ppEnum)
{
  	Assert(pRmProtIfCBList);
	Assert(ppEnum);
	
	HRESULT		hr = hrOK;
	EnumRtrMgrProtocolInterfaceCB *	pEnum;

	pEnum = new EnumRtrMgrProtocolInterfaceCB;
	hr = pEnum->Init(pRmProtIfCBList);
	if (!FHrSucceeded(hr))
	{
		pEnum->Release();
		pEnum = NULL;
	}

	*ppEnum = pEnum;
	return hr;
}



/*---------------------------------------------------------------------------
	Class:	EnumRtrMgrList

	Definition and implementation
 ---------------------------------------------------------------------------*/
class EnumRtrMgrList
		: public IEnumRtrMgrInfo
{
public:
 	DeclareIUnknownMembers(IMPL)
	DeclareIEnumRtrMgrInfoMembers(IMPL)

	EnumRtrMgrList() : m_cRef(1)
	{
		DEBUG_INCREMENT_INSTANCE_COUNTER(EnumRtrMgrList);
	}

#ifdef DEBUG
	~EnumRtrMgrList()
	{
		DEBUG_DECREMENT_INSTANCE_COUNTER(EnumRtrMgrList);
	}
#endif

	HRESULT	Init(RmDataList *pRmList);
	
protected:
	LONG			m_cRef;
	POSITION		m_pos;
	RmDataList *	m_pRmList;
};

IMPLEMENT_ADDREF_RELEASE(EnumRtrMgrList);

IMPLEMENT_SIMPLE_QUERYINTERFACE(EnumRtrMgrList, IEnumRtrMgrInfo)

DEBUG_DECLARE_INSTANCE_COUNTER(EnumRtrMgrList)

HRESULT EnumRtrMgrList::Init(RmDataList *pRmList)
{
	m_pRmList = pRmList;
	Reset();
	return hrOK;
}

HRESULT EnumRtrMgrList::Next(ULONG uNum, IRtrMgrInfo **ppRm, ULONG *pNumReturned)
{
	Assert(uNum == 1);
	Assert(ppRm);
	
	HRESULT	hr = hrOK;
	SRmData	rmData;
	
	COM_PROTECT_TRY
	{
		if (m_pos)
		{
			rmData = m_pRmList->GetNext(m_pos);
			*ppRm = rmData.m_pRmInfo;
			(*ppRm)->AddRef();

			if (pNumReturned)
				*pNumReturned = 1;
			hr = hrOK;
		}
		else
		{
			if (pNumReturned)
				*pNumReturned = 0;
			hr = hrFalse;
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrList::Skip(ULONG uNum)
{
	Assert(uNum == 1);
	
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		if (m_pos)
		{
			m_pRmList->GetNext(m_pos);
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrList::Reset()
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		m_pos = m_pRmList->GetHeadPosition();
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrList::Clone(IEnumRtrMgrInfo **ppBlockEnum)
{
	return E_NOTIMPL;
}


/*---------------------------------------------------------------------------
	Class:	EnumRtrMgrProtocolList

	Definition and implementation
 ---------------------------------------------------------------------------*/
class EnumRtrMgrProtocolList
		: public IEnumRtrMgrProtocolInfo
{
public:
 	DeclareIUnknownMembers(IMPL)
	DeclareIEnumRtrMgrProtocolInfoMembers(IMPL)

	EnumRtrMgrProtocolList() : m_cRef(1)
	{
		DEBUG_INCREMENT_INSTANCE_COUNTER(EnumRtrMgrProtocolList);
	}

#ifdef DEBUG
	~EnumRtrMgrProtocolList()
	{
		DEBUG_DECREMENT_INSTANCE_COUNTER(EnumRtrMgrProtocolList);
	}
#endif

	HRESULT	Init(PRtrMgrProtocolInfoList *pRmProtList);
	
protected:
	LONG			m_cRef;
	POSITION		m_pos;
	PRtrMgrProtocolInfoList *	m_pRmProtList;
};

IMPLEMENT_ADDREF_RELEASE(EnumRtrMgrProtocolList);

IMPLEMENT_SIMPLE_QUERYINTERFACE(EnumRtrMgrProtocolList, IEnumRtrMgrProtocolInfo)

DEBUG_DECLARE_INSTANCE_COUNTER(EnumRtrMgrProtocolList)

HRESULT EnumRtrMgrProtocolList::Init(PRtrMgrProtocolInfoList *pRmProtList)
{
	m_pRmProtList = pRmProtList;
	Reset();
	return hrOK;
}

HRESULT EnumRtrMgrProtocolList::Next(ULONG uNum, IRtrMgrProtocolInfo **ppRm, ULONG *pNumReturned)
{
	Assert(uNum == 1);
	Assert(ppRm);
	
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		if (m_pos)
		{
			*ppRm = m_pRmProtList->GetNext(m_pos);
			(*ppRm)->AddRef();

			if (pNumReturned)
				*pNumReturned = 1;
			hr = hrOK;
		}
		else
		{
			if (pNumReturned)
				*pNumReturned = 0;
			hr = hrFalse;
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrProtocolList::Skip(ULONG uNum)
{
	Assert(uNum == 1);
	
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		if (m_pos)
		{
			m_pRmProtList->GetNext(m_pos);
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrProtocolList::Reset()
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		m_pos = m_pRmProtList->GetHeadPosition();
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrProtocolList::Clone(IEnumRtrMgrProtocolInfo **ppBlockEnum)
{
	return E_NOTIMPL;
}



/*---------------------------------------------------------------------------
	Class:	EnumInterfaceList

	Definition and implementation
 ---------------------------------------------------------------------------*/
class EnumInterfaceList
		: public IEnumInterfaceInfo
{
public:
 	DeclareIUnknownMembers(IMPL)
	DeclareIEnumInterfaceInfoMembers(IMPL)

	EnumInterfaceList() : m_cRef(1)
	{
		DEBUG_INCREMENT_INSTANCE_COUNTER(EnumInterfaceList);
	}

#ifdef DEBUG
	~EnumInterfaceList()
	{
		DEBUG_DECREMENT_INSTANCE_COUNTER(EnumInterfaceList);
	}
#endif

	HRESULT	Init(PInterfaceInfoList *pIfList);
	
protected:
	LONG			m_cRef;
	POSITION		m_pos;
	PInterfaceInfoList *	m_pIfList;
};

IMPLEMENT_ADDREF_RELEASE(EnumInterfaceList);

IMPLEMENT_SIMPLE_QUERYINTERFACE(EnumInterfaceList, IEnumInterfaceInfo)

DEBUG_DECLARE_INSTANCE_COUNTER(EnumInterfaceList)

HRESULT EnumInterfaceList::Init(PInterfaceInfoList *pIfList)
{
	m_pIfList = pIfList;
	Reset();
	return hrOK;
}

HRESULT EnumInterfaceList::Next(ULONG uNum, IInterfaceInfo **ppRm, ULONG *pNumReturned)
{
	Assert(uNum == 1);
	Assert(ppRm);
	
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		if (m_pos)
		{
			*ppRm = m_pIfList->GetNext(m_pos);
			(*ppRm)->AddRef();

			if (pNumReturned)
				*pNumReturned = 1;
			hr = hrOK;
		}
		else
		{
			if (pNumReturned)
				*pNumReturned = 0;
			hr = hrFalse;
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumInterfaceList::Skip(ULONG uNum)
{
	Assert(uNum == 1);
	
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		if (m_pos)
		{
			m_pIfList->GetNext(m_pos);
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumInterfaceList::Reset()
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		m_pos = m_pIfList->GetHeadPosition();
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumInterfaceList::Clone(IEnumInterfaceInfo **ppBlockEnum)
{
	return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
	Class:	EnumRtrMgrInterfaceList

	Definition and implementation
 ---------------------------------------------------------------------------*/
class EnumRtrMgrInterfaceList
		: public IEnumRtrMgrInterfaceInfo
{
public:
 	DeclareIUnknownMembers(IMPL)
	DeclareIEnumRtrMgrInterfaceInfoMembers(IMPL)

	EnumRtrMgrInterfaceList() : m_cRef(1)
	{
		DEBUG_INCREMENT_INSTANCE_COUNTER(EnumRtrMgrInterfaceList);
	}

#ifdef DEBUG
	~EnumRtrMgrInterfaceList()
	{
		DEBUG_DECREMENT_INSTANCE_COUNTER(EnumRtrMgrInterfaceList);
	}
#endif

	HRESULT	Init(PRtrMgrInterfaceInfoList *pRmIfList);
	
protected:
	LONG			m_cRef;
	POSITION		m_pos;
	PRtrMgrInterfaceInfoList *	m_pRmIfList;
};

IMPLEMENT_ADDREF_RELEASE(EnumRtrMgrInterfaceList);

IMPLEMENT_SIMPLE_QUERYINTERFACE(EnumRtrMgrInterfaceList, IEnumRtrMgrInterfaceInfo)

DEBUG_DECLARE_INSTANCE_COUNTER(EnumRtrMgrInterfaceList)

HRESULT EnumRtrMgrInterfaceList::Init(PRtrMgrInterfaceInfoList *pRmIfList)
{
	m_pRmIfList = pRmIfList;
	Reset();
	return hrOK;
}

HRESULT EnumRtrMgrInterfaceList::Next(ULONG uNum, IRtrMgrInterfaceInfo **ppRm, ULONG *pNumReturned)
{
	Assert(uNum == 1);
	Assert(ppRm);
	
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		if (m_pos)
		{
			*ppRm = m_pRmIfList->GetNext(m_pos);
			(*ppRm)->AddRef();

			if (pNumReturned)
				*pNumReturned = 1;
			hr = hrOK;
		}
		else
		{
			if (pNumReturned)
				*pNumReturned = 0;
			hr = hrFalse;
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrInterfaceList::Skip(ULONG uNum)
{
	Assert(uNum == 1);
	
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		if (m_pos)
		{
			m_pRmIfList->GetNext(m_pos);
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrInterfaceList::Reset()
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		m_pos = m_pRmIfList->GetHeadPosition();
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrInterfaceList::Clone(IEnumRtrMgrInterfaceInfo **ppBlockEnum)
{
	return E_NOTIMPL;
}

/*---------------------------------------------------------------------------
	Class:	EnumRtrMgrProtocolInterfaceList

	Definition and implementation
 ---------------------------------------------------------------------------*/
class EnumRtrMgrProtocolInterfaceList
		: public IEnumRtrMgrProtocolInterfaceInfo
{
public:
 	DeclareIUnknownMembers(IMPL)
	DeclareIEnumRtrMgrProtocolInterfaceInfoMembers(IMPL)

	EnumRtrMgrProtocolInterfaceList() : m_cRef(1)
	{
		DEBUG_INCREMENT_INSTANCE_COUNTER(EnumRtrMgrProtocolInterfaceList);
	}

#ifdef DEBUG
	~EnumRtrMgrProtocolInterfaceList()
	{
		DEBUG_DECREMENT_INSTANCE_COUNTER(EnumRtrMgrProtocolInterfaceList);
	}
#endif

	HRESULT	Init(PRtrMgrProtocolInterfaceInfoList *pRmProtIfList);
	
protected:
	LONG			m_cRef;
	POSITION		m_pos;
	PRtrMgrProtocolInterfaceInfoList *	m_pRmProtIfList;
};

IMPLEMENT_ADDREF_RELEASE(EnumRtrMgrProtocolInterfaceList);

IMPLEMENT_SIMPLE_QUERYINTERFACE(EnumRtrMgrProtocolInterfaceList, IEnumRtrMgrProtocolInterfaceInfo)

DEBUG_DECLARE_INSTANCE_COUNTER(EnumRtrMgrProtocolInterfaceList)

HRESULT EnumRtrMgrProtocolInterfaceList::Init(PRtrMgrProtocolInterfaceInfoList *pRmProtIfList)
{
	m_pRmProtIfList = pRmProtIfList;
	Reset();
	return hrOK;
}

HRESULT EnumRtrMgrProtocolInterfaceList::Next(ULONG uNum, IRtrMgrProtocolInterfaceInfo **ppRm, ULONG *pNumReturned)
{
	Assert(uNum == 1);
	Assert(ppRm);
	
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		if (m_pos)
		{
			*ppRm = m_pRmProtIfList->GetNext(m_pos);
			(*ppRm)->AddRef();

			if (pNumReturned)
				*pNumReturned = 1;
			hr = hrOK;
		}
		else
		{
			if (pNumReturned)
				*pNumReturned = 0;
			hr = hrFalse;
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrProtocolInterfaceList::Skip(ULONG uNum)
{
	Assert(uNum == 1);
	
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		if (m_pos)
		{
			m_pRmProtIfList->GetNext(m_pos);
		}
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrProtocolInterfaceList::Reset()
{
	HRESULT	hr = hrOK;
	COM_PROTECT_TRY
	{
		m_pos = m_pRmProtIfList->GetHeadPosition();
	}
	COM_PROTECT_CATCH;
	return hr;
}

HRESULT EnumRtrMgrProtocolInterfaceList::Clone(IEnumRtrMgrProtocolInterfaceInfo **ppBlockEnum)
{
	return E_NOTIMPL;
}


/*!--------------------------------------------------------------------------
	CreateEnumFromRmList
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CreateEnumFromRmList(RmDataList *pRmList, IEnumRtrMgrInfo **ppEnum)
{
  	Assert(pRmList);
	Assert(ppEnum);
	
	HRESULT		hr = hrOK;
	EnumRtrMgrList *	pEnum;

	pEnum = new EnumRtrMgrList;
	hr = pEnum->Init(pRmList);
	if (!FHrSucceeded(hr))
	{
		pEnum->Release();
		pEnum = NULL;
	}

	*ppEnum = pEnum;
	return hr;
}



/*!--------------------------------------------------------------------------
	CreateEnumFromRtrMgrProtocolList
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CreateEnumFromRtrMgrProtocolList(PRtrMgrProtocolInfoList *pList, IEnumRtrMgrProtocolInfo **ppEnum)
{
  	Assert(pList);
	Assert(ppEnum);
	
	HRESULT		hr = hrOK;
	EnumRtrMgrProtocolList *	pEnum;

	pEnum = new EnumRtrMgrProtocolList;
	hr = pEnum->Init(pList);
	if (!FHrSucceeded(hr))
	{
		pEnum->Release();
		pEnum = NULL;
	}

	*ppEnum = pEnum;
	return hr;
}


/*!--------------------------------------------------------------------------
	CreateEnumFromInterfaceList
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CreateEnumFromInterfaceList(PInterfaceInfoList *pList, IEnumInterfaceInfo **ppEnum)
{
  	Assert(pList);
	Assert(ppEnum);
	
	HRESULT		hr = hrOK;
	EnumInterfaceList *	pEnum;

	pEnum = new EnumInterfaceList;
	hr = pEnum->Init(pList);
	if (!FHrSucceeded(hr))
	{
		pEnum->Release();
		pEnum = NULL;
	}

	*ppEnum = pEnum;
	return hr;
}


/*!--------------------------------------------------------------------------
	CreateEnumFromRtrMgrInterfaceList
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CreateEnumFromRtrMgrInterfaceList(PRtrMgrInterfaceInfoList *pList, IEnumRtrMgrInterfaceInfo **ppEnum)
{
  	Assert(pList);
	Assert(ppEnum);
	
	HRESULT		hr = hrOK;
	EnumRtrMgrInterfaceList *	pEnum;

	pEnum = new EnumRtrMgrInterfaceList;
	hr = pEnum->Init(pList);
	if (!FHrSucceeded(hr))
	{
		pEnum->Release();
		pEnum = NULL;
	}

	*ppEnum = pEnum;
	return hr;
}


/*!--------------------------------------------------------------------------
	CreateEnumFromRtrMgrProtocolInterfaceList
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CreateEnumFromRtrMgrProtocolInterfaceList(PRtrMgrProtocolInterfaceInfoList *pList, IEnumRtrMgrProtocolInterfaceInfo **ppEnum)
{
  	Assert(pList);
	Assert(ppEnum);
	
	HRESULT		hr = hrOK;
	EnumRtrMgrProtocolInterfaceList *	pEnum;

	pEnum = new EnumRtrMgrProtocolInterfaceList;
	hr = pEnum->Init(pList);
	if (!FHrSucceeded(hr))
	{
		pEnum->Release();
		pEnum = NULL;
	}

	*ppEnum = pEnum;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\globals.cpp ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:    globals.cpp
//
// History:
//  Abolade Gbadegesin  Feb-11-1996 Created.
//
// Contains definitions of global constants.
//============================================================================
#include "stdafx.h"

// Include headers needed for IP-specific infobase stuff
#include <fltdefs.h>
#include <ipinfoid.h>
#include <iprtrmib.h>
#include "iprtinfo.h"

// Include headers for IPX-specific stuff
#include <ipxrtdef.h>

// Include headers for IP-specific stuff
extern "C"
{
#include <ipnat.h>
#include <ipnathlp.h>
#include <sainfo.h>
};


#include "globals.h"



//----------------------------------------------------------------------------
// IP interface-status default configuration.
//
//----------------------------------------------------------------------------

INTERFACE_STATUS_INFO
g_ipIfStatusDefault = {
    MIB_IF_ADMIN_STATUS_UP              // Admin-status setting
};

BYTE* g_pIpIfStatusDefault              = (BYTE*)&g_ipIfStatusDefault;


//----------------------------------------------------------------------------
// Router-discovery default configuration
//
//----------------------------------------------------------------------------
//
// Default values for LAN-interface router-discovery
//

RTR_DISC_INFO
g_rtrDiscLanDefault = {
    DEFAULT_MAX_ADVT_INTERVAL,          // Max advertisement interval
    (WORD)(DEFAULT_MIN_ADVT_INTERVAL_RATIO * DEFAULT_MAX_ADVT_INTERVAL),
                                        // Min advertisement interval
    (WORD)(DEFAULT_ADVT_LIFETIME_RATIO * DEFAULT_MAX_ADVT_INTERVAL),
                                        // Advertisement lifetime
    FALSE,                              // Enable/disable advertisements
    DEFAULT_PREF_LEVEL                  // Preference level
};

BYTE* g_pRtrDiscLanDefault              = (BYTE*)&g_rtrDiscLanDefault;


//
// Default values for WAN-interface router-discovery
//

RTR_DISC_INFO
g_rtrDiscWanDefault = {
    DEFAULT_MAX_ADVT_INTERVAL,          // Max advertisement interval
    (WORD)(DEFAULT_MIN_ADVT_INTERVAL_RATIO * DEFAULT_MAX_ADVT_INTERVAL),
                                        // Min advertisement interval
    (WORD)(DEFAULT_ADVT_LIFETIME_RATIO * DEFAULT_MAX_ADVT_INTERVAL),
                                        // Advertisement lifetime
    FALSE,                              // Enable/disable advertisements
    DEFAULT_PREF_LEVEL                  // Preference level
};

BYTE* g_pRtrDiscWanDefault              = (BYTE*)&g_rtrDiscWanDefault;

//----------------------------------------------------------------------------
// IP multicast default configuration.
//
//----------------------------------------------------------------------------

MCAST_HBEAT_INFO
g_ipIfMulticastHeartbeatDefault = {
    _T(""),      //group name
    0,           //bActive
    10,          //ulDeadInterval
    0,           //byProtocol
    0            //wPort
};

BYTE* g_pIpIfMulticastHeartbeatDefault = (BYTE*)&g_ipIfMulticastHeartbeatDefault;


//----------------------------------------------------------------------------
// IPX RIP default interface configuration
// (These values also reside in ipxsnap\globals.cpp).
//
//----------------------------------------------------------------------------
//
// Default values for non-LAN interface RIP configuration
//
RIP_IF_CONFIG
g_ipxripInterfaceDefault = {
	{
		ADMIN_STATE_ENABLED,		// Admin state
		IPX_NO_UPDATE,				// Update Mode - RIP update mechanism
		IPX_STANDARD_PACKET_TYPE,	// Packet type - RIP packet type
		ADMIN_STATE_ENABLED,		// Supply - Send RIP updates
		ADMIN_STATE_ENABLED,		// Listen - Listen to RIP updates
		0,							// Periodic Update interval - in seconds
		0							// AgeIntervalMultiplier
	},
	{
		IPX_SERVICE_FILTER_DENY,	// Supply filter action
		0,							// Supply filter count
		IPX_SERVICE_FILTER_DENY,	// Listen filter action
		0,							// Listen filter count
	}
};

BYTE* g_pIpxRipInterfaceDefault             = (BYTE*)&g_ipxripInterfaceDefault;



//
// Default values for LAN interface RIP configuration
// (These values also reside in ipxsnap\globals.cpp).
//
RIP_IF_CONFIG
g_ipxripLanInterfaceDefault = {
	{
		ADMIN_STATE_ENABLED,		// Admin state
		IPX_STANDARD_UPDATE,		// Update Mode - RIP update mechanism
		IPX_STANDARD_PACKET_TYPE,	// Packet type - RIP packet type
		ADMIN_STATE_ENABLED,		// Supply - Send RIP updates
		ADMIN_STATE_ENABLED,		// Listen - Listen to RIP updates
		IPX_UPDATE_INTERVAL_DEFVAL,	// Periodic Update interval - in seconds
		3							// AgeIntervalMultiplier
	},
	{
		IPX_SERVICE_FILTER_DENY,	// Supply filter action
		0,							// Supply filter count
		IPX_SERVICE_FILTER_DENY,	// Listen filter action
		0,							// Listen filter count
	}
};

BYTE* g_pIpxRipLanInterfaceDefault	= (BYTE*)&g_ipxripLanInterfaceDefault;



//----------------------------------------------------------------------------
// IPX SAP default interface configuration
// (These values also reside in ipxsnap\globals.cpp).
//
//----------------------------------------------------------------------------
//
// Default values for non-LAN interface SAP configuration
//
SAP_IF_CONFIG
g_ipxsapInterfaceDefault = {
	{
		ADMIN_STATE_ENABLED,		// Admin state
		IPX_NO_UPDATE,				// Update Mode - SAP update mechanism
		IPX_STANDARD_PACKET_TYPE,	// Packet type - SAP packet type
		ADMIN_STATE_ENABLED,		// Supply - Send SAP updates
		ADMIN_STATE_ENABLED,		// Listen - Listen to SAP updates
		ADMIN_STATE_ENABLED,		// Reply to GetNearestServer
		0,							// Periodic Update interval - in seconds
		0							// AgeIntervalMultiplier
	},
	{
		IPX_SERVICE_FILTER_DENY,	// Supply filter action
		0,							// Supply filter count
		IPX_SERVICE_FILTER_DENY,	// Listen filter action
		0,							// Listen filter count
	}
};

BYTE* g_pIpxSapInterfaceDefault             = (BYTE*)&g_ipxsapInterfaceDefault;



//
// Default values for LAN interface SAP configuration
// (These values also reside in ipxsnap\globals.cpp).
//
SAP_IF_CONFIG
g_ipxsapLanInterfaceDefault = {
	{
		ADMIN_STATE_ENABLED,		// Admin state
		IPX_STANDARD_UPDATE,		// Update Mode - SAP update mechanism
		IPX_STANDARD_PACKET_TYPE,	// Packet type - SAP packet type
		ADMIN_STATE_ENABLED,		// Supply - Send SAP updates
		ADMIN_STATE_ENABLED,		// Listen - Listen to SAP updates
		ADMIN_STATE_ENABLED,		// Reply to GetNearestServer
		IPX_UPDATE_INTERVAL_DEFVAL,	// Periodic Update interval - in seconds
		3							// AgeIntervalMultiplier
	},
	{
		IPX_SERVICE_FILTER_DENY,	// Supply filter action
		0,							// Supply filter count
		IPX_SERVICE_FILTER_DENY,	// Listen filter action
		0,							// Listen filter count
	}
};

BYTE* g_pIpxSapLanInterfaceDefault	= (BYTE*)&g_ipxsapLanInterfaceDefault;


//----------------------------------------------------------------------------
// DHCP allocator default configuration
// (These values also reside in ipsnap\globals.cpp).
//
//----------------------------------------------------------------------------
//
// Default values for global DHCP allocator configuration
//
IP_AUTO_DHCP_GLOBAL_INFO
g_autoDhcpGlobalDefault = {
    IPNATHLP_LOGGING_ERROR,
    0,
    7 * 24 * 60,
    DEFAULT_SCOPE_ADDRESS & DEFAULT_SCOPE_MASK,
    DEFAULT_SCOPE_MASK,
    0
};
BYTE* g_pAutoDhcpGlobalDefault          = (BYTE*)&g_autoDhcpGlobalDefault;

//----------------------------------------------------------------------------
// DNS proxy default configuration
// (These values also reside in ipsnap\globals.cpp).
//
//----------------------------------------------------------------------------
//
// Default values for global DNS proxy configuration
//
IP_DNS_PROXY_GLOBAL_INFO
g_dnsProxyGlobalDefault = {
    IPNATHLP_LOGGING_ERROR,
    IP_DNS_PROXY_FLAG_ENABLE_DNS,
    3
};
BYTE* g_pDnsProxyGlobalDefault          = (BYTE*)&g_dnsProxyGlobalDefault;

//----------------------------------------------------------------------------
// ALG default configuration
//
//----------------------------------------------------------------------------
//
// Default values for global DirectPlay proxy configuration
//
IP_ALG_GLOBAL_INFO
g_algGlobalDefault = {
    IPNATHLP_LOGGING_ERROR,
    0
};
BYTE* g_pAlgGlobalDefault               = (BYTE*)&g_algGlobalDefault;

//----------------------------------------------------------------------------
// H.323 proxy default configuration
//
//----------------------------------------------------------------------------
//
// Default values for global H.323 proxy configuration
//
IP_H323_GLOBAL_INFO
g_h323GlobalDefault = {
    IPNATHLP_LOGGING_ERROR,
    0
};
BYTE* g_pH323GlobalDefault              = (BYTE*)&g_h323GlobalDefault;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\globals.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:    globals.h
//
// History:
//  Abolade Gbadegesin  Feb-11-1996 Created.
//
// Contains declarations of global constants.
//============================================================================




//
// Global strings defined in globals.cpp
//


extern const TCHAR      c_szConfigDLL[];
extern const TCHAR      c_szCurrentVersion[];
extern const TCHAR      c_szDLLName[];
extern const TCHAR      c_szDLLPath[];
extern const TCHAR		c_szNetworkCardsKey[];
extern const TCHAR      c_szProtocolId[];
extern const TCHAR		c_szRouterManagersKey[];
extern const TCHAR      c_szRouterPbk[];
extern const TCHAR      c_szServiceName[];


extern BYTE *		g_pIpIfStatusDefault;
extern BYTE *		g_pRtrDiscLanDefault;
extern BYTE *		g_pRtrDiscWanDefault;
extern BYTE *		g_pIpIfMulticastHeartbeatDefault;
extern BYTE *		g_pIpxRipInterfaceDefault;
extern BYTE *		g_pIpxRipLanInterfaceDefault;
extern BYTE *		g_pIpxSapInterfaceDefault;
extern BYTE *		g_pIpxSapLanInterfaceDefault;
extern BYTE *       g_pAutoDhcpGlobalDefault;
extern BYTE *       g_pDnsProxyGlobalDefault;
extern BYTE*        g_pH323GlobalDefault;
extern BYTE*        g_pAlgGlobalDefault;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\iface.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	IFadmin
		Interface node information
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ifadmin.h"	// need to use node data
#include "iface.h"
#include "raserror.h"
#include "rtrres.h"		// common router resources
#include "column.h"		// ComponentConfigStream
#include "mprfltr.h"
#include "rtrutilp.h"
#include "rtrui.h"		// for IsWanInterface
#include "dmvcomp.h"	

#include "timeofday.h"  // for timeofday dialog
#include "dumbprop.h"	// dummy property page

InterfaceNodeData::InterfaceNodeData()
    : lParamPrivate(0)
{
#ifdef DEBUG
	StrCpyA(m_szDebug, "InterfaceNodeData");
#endif
}

InterfaceNodeData::~InterfaceNodeData()
{
}

HRESULT InterfaceNodeData::Init(ITFSNode *pNode, IInterfaceInfo *pIf)
{
	HRESULT				hr = hrOK;
	InterfaceNodeData *	pData = NULL;
	
	pData = new InterfaceNodeData;
	pData->spIf.Set(pIf);

	SET_INTERFACENODEDATA(pNode, pData);
	
	return hr;
}

HRESULT InterfaceNodeData::Free(ITFSNode *pNode)
{	
	InterfaceNodeData *	pData = GET_INTERFACENODEDATA(pNode);
	pData->spIf.Release();
	delete pData;
	SET_INTERFACENODEDATA(pNode, NULL);
	
	return hrOK;
}


/*---------------------------------------------------------------------------
	InterfaceNodeHandler implementation
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(InterfaceNodeHandler)

IMPLEMENT_ADDREF_RELEASE(InterfaceNodeHandler)

STDMETHODIMP InterfaceNodeHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IRtrAdviseSink)
		*ppv = &m_IRtrAdviseSink;
	else
		return CBaseResultHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;	
}


/*---------------------------------------------------------------------------
	NodeHandler implementation
 ---------------------------------------------------------------------------*/


InterfaceNodeHandler::InterfaceNodeHandler(ITFSComponentData *pCompData)
			: BaseRouterHandler(pCompData),
			m_ulConnId(0)
{
	DEBUG_INCREMENT_INSTANCE_COUNTER(InterfaceNodeHandler);
}


/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InterfaceNodeHandler::Init(IInterfaceInfo *pIfInfo, ITFSNode *pParent)
{
	SPIRouterInfo		spRouter;
    SRouterNodeMenu     menuData;
	
	Assert(pIfInfo);

	m_spInterfaceInfo.Set(pIfInfo);

	
	pIfInfo->GetParentRouterInfo(&spRouter);
	m_spRouterInfo.Set(spRouter);


	// Also need to register for change notifications
	// ----------------------------------------------------------------
	m_spInterfaceInfo->RtrAdvise(&m_IRtrAdviseSink, &m_ulConnId, 0);

	m_pIfAdminData = GET_IFADMINNODEDATA(pParent);


	// Setup the verb states
	// ----------------------------------------------------------------

	// Always enable refresh
	// ----------------------------------------------------------------
	m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
	m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;


	// Need to enable properties only for certain cases
	// ----------------------------------------------------------------
    if (IsWanInterface(m_spInterfaceInfo->GetInterfaceType()))
	{
		m_rgButtonState[MMC_VERB_DELETE_INDEX] = ENABLED;
		m_bState[MMC_VERB_DELETE_INDEX] = TRUE;
		
		m_rgButtonState[MMC_VERB_PROPERTIES_INDEX] = ENABLED;
		m_bState[MMC_VERB_PROPERTIES_INDEX] = TRUE;
		
		m_verbDefault = MMC_VERB_PROPERTIES;
	}
	else
	{
#ifdef KSL_IPINIP	
		// Windows NT Bugs : 206524
		// Need to add a special case for IP-in-IP tunnel
		// Enable DELETE for the tunnel
		if (m_spInterfaceInfo->GetInterfaceType() == ROUTER_IF_TYPE_TUNNEL1)
		{
			m_rgButtonState[MMC_VERB_DELETE_INDEX] = ENABLED;
			m_bState[MMC_VERB_DELETE_INDEX] = TRUE;
		}
#endif //KSL_IPINIP


		m_rgButtonState[MMC_VERB_PROPERTIES_INDEX] = ENABLED;
		m_bState[MMC_VERB_PROPERTIES_INDEX] = FALSE;
	}

	
	return hrOK;
}


/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::DestroyResultHandler
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceNodeHandler::DestroyResultHandler(MMC_COOKIE cookie)
{
	SPITFSNode	spNode;
	
	m_spNodeMgr->FindNode(cookie, &spNode);
	InterfaceNodeData::Free(spNode);
	
	m_pIfAdminData = NULL;
	m_spInterfaceInfo->RtrUnadvise(m_ulConnId);
	m_spInterfaceInfo.Release();
	CHandler::DestroyResultHandler(cookie);
	return hrOK;
}


static DWORD	s_rgInterfaceImageMap[] =
	 {
	 ROUTER_IF_TYPE_HOME_ROUTER,	IMAGE_IDX_WAN_CARD,
	 ROUTER_IF_TYPE_FULL_ROUTER,	IMAGE_IDX_WAN_CARD,
	 ROUTER_IF_TYPE_CLIENT,			IMAGE_IDX_WAN_CARD,
	 ROUTER_IF_TYPE_DEDICATED,		IMAGE_IDX_LAN_CARD,
	 ROUTER_IF_TYPE_INTERNAL,		IMAGE_IDX_LAN_CARD,
	 ROUTER_IF_TYPE_LOOPBACK,		IMAGE_IDX_LAN_CARD,
	 -1,							IMAGE_IDX_WAN_CARD,	// sentinel value
	 };

/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::ConstructNode
		Initializes the Domain node (sets it up).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InterfaceNodeHandler::ConstructNode(ITFSNode *pNode, IInterfaceInfo *pIfInfo)
{
	HRESULT			hr = hrOK;
	int				i;
	
	if (pNode == NULL)
		return hrOK;

	COM_PROTECT_TRY
	{
		// Need to initialize the data for the Domain node

		// Find the right image index for this type of node
		for (i=0; i<DimensionOf(s_rgInterfaceImageMap); i+=2)
		{
			if ((pIfInfo->GetInterfaceType() == s_rgInterfaceImageMap[i]) ||
				(-1 == s_rgInterfaceImageMap[i]))
				break;
		}
		pNode->SetData(TFS_DATA_IMAGEINDEX, s_rgInterfaceImageMap[i+1]);
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, s_rgInterfaceImageMap[i+1]);
		
		pNode->SetData(TFS_DATA_SCOPEID, 0);

		pNode->SetData(TFS_DATA_COOKIE, reinterpret_cast<LONG_PTR>(pNode));

		//$ Review: kennt, what are the different type of interfaces
		// do we distinguish based on the same list as above? (i.e. the
		// one for image indexes).
		pNode->SetNodeType(&GUID_RouterLanInterfaceNodeType);

		InterfaceNodeData::Init(pNode, pIfInfo);
	}
	COM_PROTECT_CATCH
	return hr;
}

/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::GetString
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) InterfaceNodeHandler::GetString(ITFSComponent * pComponent,
	MMC_COOKIE cookie,
	int nCol)
{
	Assert(m_spNodeMgr);
	Assert(m_pIfAdminData);
	
	SPITFSNode		spNode;
	InterfaceNodeData *	pData;
	ConfigStream *	pConfig;

	m_spNodeMgr->FindNode(cookie, &spNode);
	Assert(spNode);

	pData = GET_INTERFACENODEDATA(spNode);
	Assert(pData);

	pComponent->GetUserData((LONG_PTR *) &pConfig);
	Assert(pConfig);

	return pData->m_rgData[pConfig->MapColumnToSubitem(DM_COLUMNS_IFADMIN, nCol)].m_stData;
}

/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::CompareItems
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int) InterfaceNodeHandler::CompareItems(ITFSComponent * pComponent,
	MMC_COOKIE cookieA,
	MMC_COOKIE cookieB,
	int nCol)
{
	return StriCmpW(GetString(pComponent, cookieA, nCol),
					GetString(pComponent, cookieB, nCol));
}

static const SRouterNodeMenu	s_rgIfNodeMenu[] =
{
	{ IDS_MENU_SET_CREDENTIALS, InterfaceNodeHandler::GetRemoveIfMenuFlags,
		CCM_INSERTIONPOINTID_PRIMARY_TOP},
		
	{ IDS_MENU_SEPARATOR, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP},
	
	{ IDS_MENU_CONNECT,			InterfaceNodeHandler::GetConnectMenuFlags,
		CCM_INSERTIONPOINTID_PRIMARY_TOP},
		
	{ IDS_MENU_DISCONNECT,		InterfaceNodeHandler::GetConnectMenuFlags,
		CCM_INSERTIONPOINTID_PRIMARY_TOP},
		
	{ IDS_MENU_SEPARATOR, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP},
	
	{ IDS_MENU_ENABLE, InterfaceNodeHandler::GetEnableMenuFlags,
		CCM_INSERTIONPOINTID_PRIMARY_TOP},
		
	{ IDS_MENU_DISABLE,	InterfaceNodeHandler::GetEnableMenuFlags,
		CCM_INSERTIONPOINTID_PRIMARY_TOP},
		
	{ IDS_MENU_SEPARATOR, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP},
	
	{ IDS_MENU_UNREACHABILITY_REASON, InterfaceNodeHandler::GetUnreachMenuFlags,
		CCM_INSERTIONPOINTID_PRIMARY_TOP},

	{ IDS_MENU_SEPARATOR, 0,
		CCM_INSERTIONPOINTID_PRIMARY_TOP},
		
	{ IDS_MENU_DEMAND_DIAL_FILTERS, InterfaceNodeHandler::GetDDFiltersFlag,
		CCM_INSERTIONPOINTID_PRIMARY_TOP},
		
	{ IDS_MENU_DIALIN_HOURS, InterfaceNodeHandler::GetDDFiltersFlag,
		CCM_INSERTIONPOINTID_PRIMARY_TOP},

};


/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::AddMenuItems
		Implementation of ITFSNodeHandler::OnAddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceNodeHandler::AddMenuItems(ITFSComponent *pComponent,
												MMC_COOKIE cookie,
												LPDATAOBJECT lpDataObject, 
												LPCONTEXTMENUCALLBACK pContextMenuCallback,
	long *pInsertionAllowed)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = S_OK;
	SPITFSNode	spNode;
	InterfaceNodeHandler::SMenuData	menuData;

	COM_PROTECT_TRY
	{
		m_spNodeMgr->FindNode(cookie, &spNode);

		// Now go through and add our menu items
		menuData.m_spNode.Set(spNode);
        menuData.m_fRouterIsRunning = (IsRouterServiceRunning(
            m_spInterfaceInfo->GetMachineName(),
            NULL) == hrOK);
		
        hr = AddArrayOfMenuItems(spNode, s_rgIfNodeMenu,
                                 DimensionOf(s_rgIfNodeMenu),
                                 pContextMenuCallback,
                                 *pInsertionAllowed,
                                 reinterpret_cast<INT_PTR>(&menuData));
	}
	COM_PROTECT_CATCH;
		
	return hr; 
}

/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::Command
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceNodeHandler::Command(ITFSComponent *pComponent,
										   MMC_COOKIE cookie,
										   int nCommandId,
										   LPDATAOBJECT pDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;
	SPITFSNode	spNode;
	SPITFSNode	spNodeParent;
	SPITFSNodeHandler	spParentHandler;

	COM_PROTECT_TRY
	{

		switch (nCommandId)
		{
			case IDS_MENU_SET_CREDENTIALS:
				hr = OnSetCredentials();
				break;
				
			case IDS_MENU_CONNECT:
			case IDS_MENU_DISCONNECT:
				hr = OnConnectDisconnect(cookie,nCommandId);
				break;
				
			case IDS_MENU_ENABLE:
			case IDS_MENU_DISABLE:
				hr = OnEnableDisable(cookie, nCommandId);
				break;
				
			case IDS_MENU_UNREACHABILITY_REASON:
				hr = OnUnreachabilityReason(cookie);
				break;

			case IDS_MENU_DEMAND_DIAL_FILTERS:
				hr = OnDemandDialFilters(cookie);
				break;

			case IDS_MENU_DIALIN_HOURS:
				hr = OnDialinHours(pComponent, cookie);
				break;
				
			default:
				Panic0("InterfaceNodeHandler: Unknown menu command!");
				break;
			
		}

        if (!FHrSucceeded(hr))
        {
            DisplayErrorMessage(NULL, hr);
        }
	}
	COM_PROTECT_CATCH;

	return hr;
}


ImplementEmbeddedUnknown(InterfaceNodeHandler, IRtrAdviseSink)

STDMETHODIMP InterfaceNodeHandler::EIRtrAdviseSink::OnChange(LONG_PTR ulConn,
	DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
	InitPThis(InterfaceNodeHandler, IRtrAdviseSink);
	HRESULT	hr = hrOK;
	
	return hr;
}


/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::GetRemoveIfMenuFlags
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
ULONG InterfaceNodeHandler::GetRemoveIfMenuFlags(const SRouterNodeMenu *pMenuData,
    INT_PTR pUserData)
{
	InterfaceNodeData *	pNodeData;
    SMenuData *         pData = reinterpret_cast<SMenuData *>(pUserData);
	
	pNodeData = GET_INTERFACENODEDATA(pData->m_spNode);
	Assert(pNodeData);
    
	ULONG	ulType = pNodeData->spIf->GetInterfaceType();
	if (!IsWanInterface(ulType) || (!pData->m_fRouterIsRunning))
		return MF_GRAYED;
	else
		return 0;
}

ULONG InterfaceNodeHandler::GetEnableMenuFlags(const SRouterNodeMenu *pMenuData,
                                               INT_PTR pUserData)
{
	ULONG	ulFlags;
	InterfaceNodeData *	pNodeData;
    SMenuData *         pData = reinterpret_cast<SMenuData *>(pUserData);
	
	pNodeData = GET_INTERFACENODEDATA(pData->m_spNode);
	Assert(pNodeData);
    
	ulFlags = GetRemoveIfMenuFlags(pMenuData, pUserData);

	if (pNodeData->spIf->IsInterfaceEnabled())
		ulFlags |= pMenuData->m_sidMenu == IDS_MENU_ENABLE ? MF_GRAYED : 0;
	else
		ulFlags |= pMenuData->m_sidMenu == IDS_MENU_ENABLE ? 0 : MF_GRAYED;
	return ulFlags;
}


ULONG InterfaceNodeHandler::GetConnectMenuFlags(const SRouterNodeMenu *pMenuData, INT_PTR pUserData)
{
	ULONG	ulFlags;
	InterfaceNodeData *	pNodeData;
    SMenuData *         pData = reinterpret_cast<SMenuData *>(pUserData);
	
	ulFlags = GetRemoveIfMenuFlags(pMenuData, pUserData);

	pNodeData = GET_INTERFACENODEDATA(pData->m_spNode);
	Assert(pNodeData);

	if ((pNodeData->dwConnectionState == ROUTER_IF_STATE_DISCONNECTED) ||
		(pNodeData->dwConnectionState == ROUTER_IF_STATE_UNREACHABLE))
	{
		ulFlags |= (pMenuData->m_sidMenu == IDS_MENU_CONNECT ? 0 : MF_GRAYED);
	}
	else
	{
		ulFlags |= (pMenuData->m_sidMenu == IDS_MENU_CONNECT ? MF_GRAYED : 0);
	}
	return ulFlags;
}

ULONG InterfaceNodeHandler::GetUnreachMenuFlags(const SRouterNodeMenu *pMenuData, INT_PTR pUserData)
{
	ULONG	ulFlags;
	InterfaceNodeData *	pNodeData;
    SMenuData *         pData = reinterpret_cast<SMenuData *>(pUserData);
	
	pNodeData = GET_INTERFACENODEDATA(pData->m_spNode);
	Assert(pNodeData);

	return pNodeData->dwConnectionState == ROUTER_IF_STATE_UNREACHABLE ?
				0 : MF_GRAYED;
}


ULONG InterfaceNodeHandler::GetDDFiltersFlag(const SRouterNodeMenu *pMenuData, INT_PTR pUserData)
{
	InterfaceNodeData *	pNodeData;
	DWORD				dwIfType;
	SPIRouterInfo		spRouter;
    SMenuData *         pData = reinterpret_cast<SMenuData *>(pUserData);
	
	pNodeData = GET_INTERFACENODEDATA(pData->m_spNode);
	Assert(pNodeData);

	// For NT4 and NT5 Beta1, we didn't have DD filters
	pNodeData->spIf->GetParentRouterInfo(&spRouter);
	if (spRouter)
	{
		RouterVersionInfo	routerVer;
		spRouter->GetRouterVersionInfo(&routerVer);
		if (routerVer.dwOsBuildNo <= 1717)
		{
			return 0xFFFFFFFF;
		}
	}

	dwIfType = pNodeData->spIf->GetInterfaceType();

	if (!IsWanInterface(dwIfType))
		return 0xFFFFFFFF;
	else
		return 0;
}



/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::OnCreateDataObject
		Implementation of ITFSResultHandler::OnCreateDataObject
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceNodeHandler::OnCreateDataObject(ITFSComponent *pComp,
	MMC_COOKIE cookie,
	DATA_OBJECT_TYPES type,
	IDataObject **ppDataObject)
{
	HRESULT	hr = hrOK;
	
	COM_PROTECT_TRY
	{
		CORg( CreateDataObjectFromInterfaceInfo(m_spInterfaceInfo,
											 type, cookie, m_spTFSCompData,
											 ppDataObject) );

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH;
	return hr;
}

/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::CreatePropertyPages
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP InterfaceNodeHandler::CreatePropertyPages(
									ITFSComponent * pComponent,
									MMC_COOKIE cookie,
									LPPROPERTYSHEETCALLBACK lpProvider,
									LPDATAOBJECT			pDataObject,
									LONG_PTR handle)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT		hr = hrOK;
	BOOL		fIsServiceRunning;
	DWORD		dwErr;
	IfAdminNodeData *	pAdminData;
	SPITFSNode	spParent;
	SPITFSNode	spNode;
	SPIConsole	spConsole;
	HWND		hwndMain;
	DWORD		dwIfType;
	CString		stServiceDesc;
	SPIComponentData spComponentData;
	CDummyProperties * pProp;

	// Bring up the RASDLG instead

	// Start the service if the service is stopped
	CORg( IsRouterServiceRunning(m_spInterfaceInfo->GetMachineName(), NULL) );

	fIsServiceRunning = (hr == hrOK);

	if (!fIsServiceRunning)
	{
		// Ask the user if they want to start the service
		if (AfxMessageBox(IDS_PROMPT_SERVICESTART, MB_YESNO) != IDYES)
			CWRg( ERROR_CANCELLED );

		// Else start the service
		stServiceDesc.LoadString(IDS_RRAS_SERVICE_DESC);
		dwErr = TFSStartService(m_spInterfaceInfo->GetMachineName(),
								c_szRemoteAccess,
								stServiceDesc);
		if (dwErr != NO_ERROR)
		{
			CWRg( dwErr );
		}
	}

	m_spNodeMgr->FindNode(cookie, &spNode);
	spNode->GetParent(&spParent);
	pAdminData = GET_IFADMINNODEDATA(spParent);

	if (pAdminData->m_hInstRasDlg == NULL)
	{
		AfxMessageBox(IDS_ERR_EDITPBKLOCAL);
	}
	else
	{
		// First edit the phone book entry.
		//  Only for wan interfaces.
		dwIfType = m_spInterfaceInfo->GetInterfaceType();
		if (IsWanInterface(dwIfType))
		{
			pComponent->GetConsole(&spConsole);
			spConsole->GetMainWindow(&hwndMain);
			
			// First create the phone book entry.
			RASENTRYDLG info;
			CString sPhoneBook;
					CString sRouter;
			ZeroMemory( &info, sizeof(info) );
			info.dwSize = sizeof(info);
			info.hwndOwner = hwndMain;
			info.dwFlags |= RASEDFLAG_NoRename;
			
			TRACE0("RouterEntryDlg\n");
			Assert(pAdminData->m_pfnRouterEntryDlg);
			
			sRouter = m_spInterfaceInfo->GetMachineName();

			IfAdminNodeHandler::GetPhoneBookPath(sRouter, &sPhoneBook);

			BOOL bStatus = pAdminData->m_pfnRouterEntryDlg(
							(LPTSTR)(LPCTSTR)sRouter,
							(LPTSTR)(LPCTSTR)sPhoneBook,
							(LPTSTR)(LPCTSTR)m_spInterfaceInfo->GetTitle(),
							&info);
			TRACE2("RouterEntryDlg=%f,e=%d\n", bStatus, info.dwError);
			if (!bStatus)
			{
				if (info.dwError != NO_ERROR)
				{
					AfxMessageBox(IDS_ERR_UNABLETOCONFIGPBK);
				}
			}

			else
			{

			    //
			    // Inform DDM about changes to phonebook entry.
			    //
			    
			    UpdateDDM( m_spInterfaceInfo );
			}

		}
	}

Error:
	CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

	pProp = new CDummyProperties(spNode, spComponentData, NULL);
	hr = pProp->CreateModelessSheet(lpProvider, handle);

	return hr;
}


STDMETHODIMP InterfaceNodeHandler::HasPropertyPages (
	ITFSComponent *pComp,
	MMC_COOKIE cookie,
	LPDATAOBJECT pDataObject)
{
	// Only provide "property pages" for WAN entries
	// First edit the phone book entry.
	//  Only for wan interfaces.
	DWORD dwIfType = m_spInterfaceInfo->GetInterfaceType();
	if (IsWanInterface(dwIfType))
		return hrOK;
	else
		return hrFalse;
}


/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::OnRemoveInterface
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InterfaceNodeHandler::OnRemoveInterface(MMC_COOKIE cookie)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    SPITFSNode          spNode;
    InterfaceNodeData *	pNodeData = NULL;
	SPIRouterInfo       spRouterInfo;
	HRESULT             hr = hrOK;
	SPITFSNodeHandler	spHandler;
	DWORD               dwErr;
	BOOL                fIsServiceRunning;
	CString             stServiceDesc;

	RefreshInterface(cookie); // Find out whether the interface is connected to
	
    m_spNodeMgr->FindNode(cookie, &spNode);
	
	pNodeData = GET_INTERFACENODEDATA(spNode);
	Assert(pNodeData);

	BOOL	bNotConnected = ((pNodeData->dwConnectionState == ROUTER_IF_STATE_DISCONNECTED) 
					|| (pNodeData->dwConnectionState == ROUTER_IF_STATE_UNREACHABLE));


	m_spInterfaceInfo->GetParentRouterInfo(&spRouterInfo);
    
    // Windows NT Bug : 208471
    // Do NOT check for the running router if we are deleting a
    // DD interface and we are in LAN-only mode.

    // We can also skip this if we are a tunnel.

    if ((!IsWanInterface(m_spInterfaceInfo->GetInterfaceType()) ||
         (m_spRouterInfo->GetRouterType() != ROUTER_TYPE_LAN)) &&
        (m_spInterfaceInfo->GetInterfaceType() != ROUTER_IF_TYPE_TUNNEL1))
    {
        // Start the service if the service is stopped
        CORg( IsRouterServiceRunning(m_spInterfaceInfo->GetMachineName(), NULL));

        fIsServiceRunning = (hr == hrOK);
        
        if (!fIsServiceRunning)
        {
            // Ask the user if they want to start the service
            if (AfxMessageBox(IDS_PROMPT_SERVICESTART, MB_YESNO) != IDYES)
                CWRg( ERROR_CANCELLED );
            
            // Else start the service
            stServiceDesc.LoadString(IDS_RRAS_SERVICE_DESC);
            dwErr = TFSStartService(m_spInterfaceInfo->GetMachineName(), c_szRemoteAccess, stServiceDesc);
            if (dwErr != NO_ERROR)
            {
                CWRg( dwErr );
            }
        }
    }
        
    // Addref this node so that it won't get deleted before we're out
	// of this function
	spHandler.Set(this);

	// if connected, disconnect first
	if(!bNotConnected && ROUTER_IF_TYPE_FULL_ROUTER == m_spInterfaceInfo->GetInterfaceType())
	{
		if (AfxMessageBox(IDS_PROMPT_VERIFY_DISCONNECT_INTERFACE, MB_YESNO|MB_DEFBUTTON2) == IDNO)
			return HRESULT_FROM_WIN32(ERROR_CANCELLED);

		// Disconnect
		hr = OnConnectDisconnect(cookie, IDS_MENU_DISCONNECT);
		if(FAILED(hr))
			return hr;

		SPMprServerHandle   sphRouter;
		MPR_SERVER_HANDLE   hRouter = NULL;
		dwErr = ConnectRouter(m_spInterfaceInfo->GetMachineName(), &hRouter);
		if (dwErr != NO_ERROR)
		{
			AfxMessageBox(IDS_ERR_DELETE_INTERFACE);
		    return HRESULT_FROM_WIN32(dwErr);
		}

		sphRouter.Attach(hRouter);  // so that it gets released
		WCHAR wszInterface[MAX_INTERFACE_NAME_LEN+1];
		StrCpyWFromT(wszInterface, m_spInterfaceInfo->GetId());

		HANDLE              hInterface;
		dwErr = ::MprAdminInterfaceGetHandle(
		                                 hRouter,
		                                 wszInterface,
		                                 &hInterface,
		                                 FALSE
		                                );
		if (dwErr != NO_ERROR)
		{
			AfxMessageBox(IDS_ERR_DELETE_INTERFACE);
		    return HRESULT_FROM_WIN32(dwErr);
		}
		
		SPMprAdminBuffer    spMprBuffer;
		DWORD dwConnectionState = 0;
		do
		{
			dwErr = ::MprAdminInterfaceGetInfo(
                    hRouter,
                    hInterface,
                    0,
                    (LPBYTE*)&spMprBuffer
                    );

			if (dwErr != NO_ERROR || !spMprBuffer)
			{
				AfxMessageBox(IDS_ERR_DELETE_INTERFACE);
				return HRESULT_FROM_WIN32(dwErr);
			}

			MPR_INTERFACE_0 *pInfo = (MPR_INTERFACE_0 *) (LPBYTE) spMprBuffer;
			dwConnectionState = pInfo->dwConnectionState;

			if (dwConnectionState != ROUTER_IF_STATE_DISCONNECTED)
				Sleep(0);
			
		} while (dwConnectionState != ROUTER_IF_STATE_DISCONNECTED);
	}
	else
	{
		if (AfxMessageBox(IDS_PROMPT_VERIFY_REMOVE_INTERFACE, MB_YESNO|MB_DEFBUTTON2) == IDNO)
			return HRESULT_FROM_WIN32(ERROR_CANCELLED);
	}

	if (spRouterInfo)
	{
		hr = spRouterInfo->DeleteInterface(m_spInterfaceInfo->GetId(), TRUE);
		if (!FHrSucceeded(hr))
		{
			AfxMessageBox(IDS_ERR_DELETE_INTERFACE);
		}
	}
Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::OnUnreachabilityReason
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InterfaceNodeHandler::OnUnreachabilityReason(MMC_COOKIE cookie)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	CString		stReason;
	SPITFSNode	spNode;
	InterfaceNodeData *	pNodeData;
	DWORD		dwUnreach;
	LPWSTR		lpwErr;
	SPMprAdminBuffer	spMprBuffer;

	m_spNodeMgr->FindNode(cookie, &spNode);
	Assert(spNode);

	pNodeData = GET_INTERFACENODEDATA(spNode);
	Assert(pNodeData);

	dwUnreach = pNodeData->dwUnReachabilityReason;

	if (dwUnreach == MPR_INTERFACE_NOT_LOADED)
	{
		if (pNodeData->fIsRunning)
			stReason += GetUnreachReasonCString(IDS_ERR_UNREACH_NOT_LOADED);
		else
			stReason += GetUnreachReasonCString(IDS_ERR_UNREACH_NOT_RUNNING);
	}

    if (dwUnreach & MPR_INTERFACE_DIALOUT_HOURS_RESTRICTION)
        stReason += GetUnreachReasonCString(IDS_ERR_UNREACH_DIALOUT_HOURS_RESTRICTION);
    
    if (dwUnreach & MPR_INTERFACE_NO_MEDIA_SENSE)
        stReason += GetUnreachReasonCString(IDS_ERR_UNREACH_NO_MEDIA_SENSE);

	if (dwUnreach & MPR_INTERFACE_ADMIN_DISABLED)
		stReason += GetUnreachReasonCString(IDS_ERR_UNREACH_ADMIN_DISABLED);

	if (dwUnreach & MPR_INTERFACE_SERVICE_PAUSED)
		stReason += GetUnreachReasonCString(IDS_ERR_UNREACH_SERVICE_PAUSED);

	if (dwUnreach & MPR_INTERFACE_OUT_OF_RESOURCES)
		stReason += GetUnreachReasonCString(IDS_ERR_UNREACH_NO_PORTS);
	else if ( dwUnreach & MPR_INTERFACE_CONNECTION_FAILURE )
	{
		stReason += GetUnreachReasonCString(IDS_ERR_UNREACH_CONNECT_FAILURE);
        //Workaround for bugid: 96347.  Change this once
        //schannel has an alert for SEC_E_MULTIPLE_ACCOUNTS

        if ( pNodeData->dwLastError == SEC_E_CERT_UNKNOWN )
        {
            pNodeData->dwLastError = SEC_E_MULTIPLE_ACCOUNTS;
        }

		if (::MprAdminGetErrorString(pNodeData->dwLastError, &lpwErr) == NO_ERROR )
		{
			spMprBuffer = (BYTE *) lpwErr;
			stReason += (LPCTSTR) lpwErr;
		}
	}

	AfxMessageBox(stReason);
	
	return hrOK;
}

/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::OnEnableDisable
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InterfaceNodeHandler::OnEnableDisable(MMC_COOKIE cookie, int nCommandID)
{
	HRESULT	hr = hrOK;
	m_spInterfaceInfo->SetInterfaceEnabledState(nCommandID == IDS_MENU_ENABLE);

	{
		CWaitCursor	waitcursor;
		hr = m_spInterfaceInfo->Save(NULL, NULL, NULL);
	}
	
	// Actually the above call should trigger an event that causes a
	// refresh, the explicit RefreshInterface() should not be necessary.
	RefreshInterface(cookie);
	return hrOK;
}

/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::OnConnectDisconnect
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InterfaceNodeHandler::OnConnectDisconnect(MMC_COOKIE cookie, int nCommandID)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT		hr = hrOK;
	DWORD		dwErr;
    InterfaceNodeData * pData;
    SPITFSNode  spNode;
	dwErr = ::ConnectInterface(m_spInterfaceInfo->GetMachineName(),
							   m_spInterfaceInfo->GetId(),
							   nCommandID == IDS_MENU_CONNECT /* bConnect */,
							   NULL /*hwndParent*/);
	
 	RefreshInterface(cookie);
/* 	
    m_spNodeMgr->FindNode(cookie, &spNode);
    pData = GET_INTERFACENODEDATA(spNode);
    Assert(pData);
	if (dwErr != NO_ERROR && dwErr != PENDING)
	{
		TCHAR	szErr[1024];
		FormatSystemError(pData->dwLastError, szErr, 1024, IDS_ERR_ERROR_OCCURRED, 0xFFFFFFFF);
		AfxMessageBox(szErr);
	}
*/
   if (dwErr != NO_ERROR && dwErr != PENDING)
   {
       TCHAR   szErr[1024];
       FormatSystemError(dwErr, szErr, 1024, IDS_ERR_ERROR_OCCURRED, 0xFFFFFFFF);
       AfxMessageBox(szErr);
   }

	return hrOK;
}

/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::OnSetCredentials
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InterfaceNodeHandler::OnSetCredentials()
{
	SPIRouterInfo		spRouter;
	BOOL                fNT4        = FALSE;
	DWORD               dwErr;

	m_spInterfaceInfo->GetParentRouterInfo(&spRouter);
	if (spRouter)
	{
		RouterVersionInfo	routerVer;
		spRouter->GetRouterVersionInfo(&routerVer);
		if (routerVer.dwOsBuildNo <= 1877)
		{
			fNT4 = TRUE;
		}
	}

	dwErr = PromptForCredentials(m_spInterfaceInfo->GetMachineName(),
									   m_spInterfaceInfo->GetId(),
									   fNT4,
									   FALSE /* fNewInterface */,
									   NULL /* hwndParent */
									  );
	return HRESULT_FROM_WIN32(dwErr);
}

/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::OnDemandDialFilters
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InterfaceNodeHandler::OnDemandDialFilters(MMC_COOKIE cookie)
{
	HRESULT		hr = hrOK;
    CWaitCursor wait;
	SPIInfoBase	spInfoBase;
	SPIRtrMgrInterfaceInfo	spRmIf;

	CORg( m_spInterfaceInfo->FindRtrMgrInterface(PID_IP, &spRmIf) );

	if (spRmIf == NULL)
	{
		//$ TODO : need to bring up an error message, about requiring
		// that IP be added to this interface
		AfxMessageBox(IDS_ERR_DDFILTERS_REQUIRE_IP);
		goto Error;
	}

	CORg( spRmIf->GetInfoBase(NULL, NULL, NULL, &spInfoBase) );
	
	CORg( MprUIFilterConfigInfoBase(NULL,
									spInfoBase,
									NULL,
									PID_IP,
									FILTER_DEMAND_DIAL) );
	if (hr == hrOK)
	{
		CORg( spRmIf->Save(m_spInterfaceInfo->GetMachineName(),
                           NULL, NULL, NULL, spInfoBase, 0) );
	}

Error:
	if (!FHrSucceeded(hr))
	{
		DisplayErrorMessage(NULL, hr);
	}
	return hr;
}

/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::LoadDialOutHours
		-
	Author: WeiJiang
 ---------------------------------------------------------------------------*/
	// if the service is not running, return S_FALSE, 
	// otherwise, using MprAdminInterfaceSetInfo to notify the service of dialin hours changes
HRESULT	InterfaceNodeHandler::LoadDialOutHours(CStringList&	strList)
{
	HANDLE	hMachine = INVALID_HANDLE_VALUE;
	HANDLE	hInterface = INVALID_HANDLE_VALUE;
	BOOL	bLoaded = FALSE;
	HRESULT	hr = S_OK;
	MPR_INTERFACE_1* pmprif1 = NULL;
	DWORD	dwErr = 0;
	DWORD	size;

	// Try to connect to the mpradmin service
	// Note: this may fail but the service queries down below may
	// succeed, so we should setup the states as well as we can here.
	// ----------------------------------------------------------------
	CORg( IsRouterServiceRunning(m_spInterfaceInfo->GetMachineName(), NULL));

	
	while(hr == S_OK /*running*/ && !bLoaded)	// FALSE loop, if runing, load from Service
	{
		dwErr = ::MprAdminServerConnect((LPWSTR)m_spInterfaceInfo->GetMachineName(), &hMachine);

		if(dwErr != NOERROR || hMachine == INVALID_HANDLE_VALUE)
			break;

		dwErr = ::MprAdminInterfaceGetHandle(hMachine,
									   (LPWSTR) m_spInterfaceInfo->GetId(),
									   &hInterface,
									   FALSE );
		if(dwErr != NOERROR || hInterface == INVALID_HANDLE_VALUE)
			break;

		
		// See if the interface is connected
		dwErr = ::MprAdminInterfaceGetInfo(hMachine,
										   hInterface,
										   1,
										   (LPBYTE*)&pmprif1);		

		if(dwErr != NOERROR || pmprif1 == NULL)
			break;

		// get the dialin out information
		dwErr = MULTI_SZ2StrList(pmprif1->lpwsDialoutHoursRestriction, strList);

        // Windows NT Bug : 317146
        // Add on an emptry string to the string list
        // This signifies that we have no data (as opposed to the NULL data)
        if (pmprif1->lpwsDialoutHoursRestriction)
            strList.AddTail(_T(""));

		bLoaded = TRUE;
		// free the buffer
		::MprAdminBufferFree(pmprif1);
		pmprif1 = NULL;
	
		break;		
	};

	// disconnect it
	if(hMachine != INVALID_HANDLE_VALUE)
	{
		::MprAdminServerDisconnect(hMachine);
		hMachine = INVALID_HANDLE_VALUE;
	}
		
	// if not loaded, try MprConfig APIs
	while(!bLoaded)
	{
		dwErr = ::MprConfigServerConnect((LPWSTR)m_spInterfaceInfo->GetMachineName(), &hMachine);

		if(dwErr != NOERROR || hMachine == INVALID_HANDLE_VALUE)
			break;

		dwErr = ::MprConfigInterfaceGetHandle(hMachine,
									   (LPWSTR) m_spInterfaceInfo->GetId(),
									   &hInterface);
									   
		if(dwErr != NOERROR || hInterface == INVALID_HANDLE_VALUE)
			break;

		
		// See if the interface is connected
		dwErr = ::MprConfigInterfaceGetInfo(hMachine,
										   hInterface,
										   1,
										   (LPBYTE*)&pmprif1, 
										   &size);		

		if(dwErr != NOERROR || pmprif1 == NULL)
			break;

		// get the dialin out information
		dwErr = MULTI_SZ2StrList(pmprif1->lpwsDialoutHoursRestriction, strList);
        // Windows NT Bug : 317146
        // Add on an emptry string to the string list
        // This signifies that we have no data (as opposed to the NULL data)
        if (pmprif1->lpwsDialoutHoursRestriction)
            strList.AddTail(_T(""));
        
		bLoaded = TRUE;
		// free the buffer
		::MprConfigBufferFree(pmprif1);
		pmprif1 = NULL;
		break;
	}

	// disconnect it
	if(hMachine != INVALID_HANDLE_VALUE)
	{
		::MprConfigServerDisconnect(hMachine);
		hMachine = INVALID_HANDLE_VALUE;
	}


	if(!bLoaded)
	{
		HKEY		hkeyMachine = NULL;
		HKEY		hkeyIf;
		RegKey		regkeyIf;

		// last chance if to connect to registry directly
		// Load up the information (from the registry) for the dialin hours
		CWRg( ConnectRegistry(m_spInterfaceInfo->GetMachineName(), &hkeyMachine) );

		CORg( RegFindInterfaceKey(m_spInterfaceInfo->GetId(), hkeyMachine,
							  KEY_ALL_ACCESS, &hkeyIf));
		regkeyIf.Attach(hkeyIf);

		// Now grab the data
	
		dwErr = regkeyIf.QueryValue(c_szDialOutHours, strList);
		
		if (dwErr == NOERROR)
			bLoaded = TRUE;

		if(hkeyMachine != NULL)
		{
			DisconnectRegistry(hkeyMachine);
			hkeyMachine = NULL;
		}
	}
		
Error:
	if(dwErr != NOERROR)
		hr = HRESULT_FROM_WIN32(dwErr);
		
	return hr;
}



/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::SaveDialOutHours
		-
	Author: WeiJiang
 ---------------------------------------------------------------------------*/
	// if the service is not running, return S_FALSE, 
	// otherwise, using MprAdminInterfaceSetInfo to notify the service of dialin hours changes
HRESULT	InterfaceNodeHandler::SaveDialOutHours(CStringList&	strList)
{
	HANDLE	hMachine = INVALID_HANDLE_VALUE;
	HANDLE	hInterface = INVALID_HANDLE_VALUE;
	HRESULT	hr = S_OK;
	MPR_INTERFACE_1*	pmprif1 = NULL;
	MPR_INTERFACE_1		mprif1;
	DWORD	dwErr = 0;
	BYTE*	pbData = NULL;
	DWORD	size;
	BOOL	bSaved = FALSE;

	dwErr = StrList2MULTI_SZ(strList, &size, &pbData);

	if(dwErr != NOERROR)
	{
		goto Error;
	}
	
	//try MprConfig APIs
	while(!bSaved)
	{
		dwErr = ::MprConfigServerConnect((LPWSTR)m_spInterfaceInfo->GetMachineName(), &hMachine);

		if(dwErr != NOERROR || hMachine == INVALID_HANDLE_VALUE)
			break;

		dwErr = ::MprConfigInterfaceGetHandle(hMachine,
									   (LPWSTR) m_spInterfaceInfo->GetId(),
									   &hInterface);
									   
		if(dwErr != NOERROR || hInterface == INVALID_HANDLE_VALUE)
			break;

		
		// See if the interface is connected
		dwErr = ::MprConfigInterfaceGetInfo(hMachine,
										   hInterface,
										   1,
										   (LPBYTE*)&pmprif1,
										   &size);		

		if(dwErr != NOERROR || pmprif1 == NULL)
			break;

		memcpy(&mprif1, pmprif1, sizeof(MPR_INTERFACE_1));
		mprif1.lpwsDialoutHoursRestriction = (LPWSTR)pbData;

		// See if the interface is connected
		dwErr = ::MprConfigInterfaceSetInfo(hMachine,
										   hInterface,
										   1,
										   (LPBYTE)&mprif1);		
		if(dwErr == NOERROR)
			bSaved = TRUE;
			
		// free the buffer
		::MprConfigBufferFree(pmprif1);
		pmprif1 = NULL;

		break;
	}

	// disconnect it
	if(hMachine != INVALID_HANDLE_VALUE)
	{
		::MprConfigServerDisconnect(hMachine);
		hMachine = INVALID_HANDLE_VALUE;
	}


	if(dwErr != NOERROR)
		hr = HRESULT_FROM_WIN32(dwErr);
		

	// Try to connect to the mpradmin service
	// Note: this may fail but the service queries down below may
	// succeed, so we should setup the states as well as we can here.
	// ----------------------------------------------------------------
	CORg( IsRouterServiceRunning(m_spInterfaceInfo->GetMachineName(), NULL));

	

	while(hr == S_OK)	// FALSE loop, if runing, save to Service
	{
		DWORD dwErr1 = ::MprAdminServerConnect((LPWSTR)m_spInterfaceInfo->GetMachineName(), &hMachine);

		if(dwErr1 != NOERROR || hMachine == INVALID_HANDLE_VALUE)
			break;

		dwErr1 = ::MprAdminInterfaceGetHandle(hMachine,
									   (LPWSTR) m_spInterfaceInfo->GetId(),
									   &hInterface,
									   FALSE );
		if(dwErr1 != NOERROR || hInterface == INVALID_HANDLE_VALUE)
			break;

		
		// See if the interface is connected
		dwErr1 = ::MprAdminInterfaceGetInfo(hMachine,
										   hInterface,
										   1,
										   (LPBYTE*)&pmprif1);		

		if(dwErr1 != NOERROR || pmprif1 == NULL)
			break;

		memcpy(&mprif1, pmprif1, sizeof(MPR_INTERFACE_1));
		mprif1.lpwsDialoutHoursRestriction = (LPWSTR)pbData;

		dwErr1 = ::MprAdminInterfaceSetInfo(hMachine,
										   hInterface,
										   1,
										   (LPBYTE)&mprif1);		
		// free the buffer
		::MprAdminBufferFree(pmprif1);
		pmprif1 = NULL;
	
		break;
	};

	// disconnect it
	if(hMachine != INVALID_HANDLE_VALUE)
	{
		::MprAdminServerDisconnect(hMachine);
		hMachine = INVALID_HANDLE_VALUE;
	}
		
	if (!bSaved)
	{
		HKEY		hkeyMachine = NULL;
		HKEY		hkeyIf;
		RegKey		regkeyIf;

		// last chance if to connect to registry directly
		// Load up the information (from the registry) for the dialin hours
		CWRg( ConnectRegistry(m_spInterfaceInfo->GetMachineName(), &hkeyMachine) );

		CORg( RegFindInterfaceKey(m_spInterfaceInfo->GetId(), hkeyMachine,
							  KEY_ALL_ACCESS, &hkeyIf));
		regkeyIf.Attach(hkeyIf);

		// Now grab the data
	
		dwErr = regkeyIf.SetValue(c_szDialOutHours, strList);
		if(dwErr == NOERROR)
			bSaved = TRUE;

		if(hkeyMachine != NULL)
			DisconnectRegistry(hkeyMachine);
	}
		
		
Error:
	if(pbData)
		delete pbData;
		
	if(dwErr != NOERROR)
		hr = HRESULT_FROM_WIN32(dwErr);
		
	return hr;
}


/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::OnDialinHours
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InterfaceNodeHandler::OnDialinHours(ITFSComponent *pComponent, MMC_COOKIE cookie)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT		hr = hrOK;
	BYTE		rgbDialinHoursMap[21];
	CString		stDialogTitle;
	HWND		hWnd;
	SPIConsole	spConsole;
	HKEY		hkeyMachine = NULL;
	HKEY		hkeyIf;
	RegKey		regkeyIf;
	CStringList	rgstList;
	BYTE *		pMap = &(rgbDialinHoursMap[0]);

	// Get various MMC information
	CORg( pComponent->GetConsole(&spConsole) );
	CORg( spConsole->GetMainWindow(&hWnd) );

	// If the key doesn't exist then we should set the entire thing to FF
	memset(rgbDialinHoursMap, 0xFF, sizeof(rgbDialinHoursMap));

	CORg(LoadDialOutHours(rgstList));

	// Convert this string list into the binary data
	if(rgstList.GetCount())
		StrListToHourMap(rgstList, pMap);

	stDialogTitle.LoadString(IDS_TITLE_DIALINHOURS);
	if (OpenTimeOfDayDlgEx(hWnd, (BYTE **) &pMap, stDialogTitle, SCHED_FLAG_INPUT_LOCAL_TIME) == S_OK)
	{
		
		rgstList.RemoveAll();
		
		// Write the information back out to the registry
		HourMapToStrList(pMap, rgstList);

		CORg(SaveDialOutHours(rgstList));
	}

Error:
	if (!FHrSucceeded(hr))
		DisplayErrorMessage(NULL, hr);
	return hr;
}


/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::RefreshInterface
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void InterfaceNodeHandler::RefreshInterface(MMC_COOKIE cookie)
{
	SPITFSNode	spNode;
	SPITFSNode	spParent;
	SPITFSNodeHandler	spHandler;
	
	m_spNodeMgr->FindNode(cookie, &spNode);
	
	// Can't do it for a single node at this time, just refresh the
	// whole thing.
	spNode->GetParent(&spParent);
	spParent->GetHandler(&spHandler);

	spHandler->OnCommand(spParent,
						IDS_MENU_REFRESH,
						CCT_RESULT, NULL, 0);
}

/*!--------------------------------------------------------------------------
	InterfaceNodeHandler::OnResultDelete
		This notification is received for the delete key from the toolbar
		or from the 'delete' key.  Forward this to the RemoveInterface
		operation.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT InterfaceNodeHandler::OnResultDelete(ITFSComponent *pComponent,
											 LPDATAOBJECT pDataObject,
											 MMC_COOKIE cookie,
											 LPARAM arg,
											 LPARAM param)
{
    return OnRemoveInterface(cookie);
// add new parameter to provide interface data -- bug 166461
//	return OnRemoveInterface();
}




/*---------------------------------------------------------------------------
	BaseResultHandler implementation
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(BaseResultHandler)

IMPLEMENT_ADDREF_RELEASE(BaseResultHandler)

STDMETHODIMP BaseResultHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IRtrAdviseSink)
		*ppv = &m_IRtrAdviseSink;
	else
		return CBaseResultHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;	
}


/*---------------------------------------------------------------------------
	NodeHandler implementation
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	BaseResultHandler::GetString
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) BaseResultHandler::GetString(ITFSComponent * pComponent,
	MMC_COOKIE cookie,
	int nCol)
{
	Assert(m_spNodeMgr);
	
	SPITFSNode		spNode;
	InterfaceNodeData *	pData;
	ConfigStream *	pConfig;

	m_spNodeMgr->FindNode(cookie, &spNode);
	Assert(spNode);

	pData = GET_INTERFACENODEDATA(spNode);
	Assert(pData);

	pComponent->GetUserData((LONG_PTR *) &pConfig);
	Assert(pConfig);

	return pData->m_rgData[pConfig->MapColumnToSubitem(m_ulColumnId, nCol)].m_stData;
}

/*!--------------------------------------------------------------------------
	BaseResultHandler::CompareItems
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int) BaseResultHandler::CompareItems(ITFSComponent * pComponent,
	MMC_COOKIE cookieA,
	MMC_COOKIE cookieB,
	int nCol)
{
	ConfigStream *	pConfig;
	pComponent->GetUserData((LONG_PTR *) &pConfig);
	Assert(pConfig);

	int	nSubItem = pConfig->MapColumnToSubitem(m_ulColumnId, nCol);

	if (pConfig->GetSortCriteria(m_ulColumnId, nCol) == CON_SORT_BY_DWORD)
	{
		SPITFSNode	spNodeA, spNodeB;
		InterfaceNodeData *	pNodeDataA, *pNodeDataB;

		m_spNodeMgr->FindNode(cookieA, &spNodeA);
		m_spNodeMgr->FindNode(cookieB, &spNodeB);

		pNodeDataA = GET_INTERFACENODEDATA(spNodeA);
        Assert(pNodeDataA);
		
		pNodeDataB = GET_INTERFACENODEDATA(spNodeB);
        Assert(pNodeDataB);

		return pNodeDataA->m_rgData[nSubItem].m_dwData -
				pNodeDataB->m_rgData[nSubItem].m_dwData;
		
	}
	else
		return StriCmpW(GetString(pComponent, cookieA, nCol),
						GetString(pComponent, cookieB, nCol));
}

ImplementEmbeddedUnknown(BaseResultHandler, IRtrAdviseSink)

STDMETHODIMP BaseResultHandler::EIRtrAdviseSink::OnChange(LONG_PTR dwConn,
	DWORD dwChangeType, DWORD dwObjectType, LPARAM lUserParam, LPARAM lParam)
{
	InitPThis(BaseResultHandler, IRtrAdviseSink);
	HRESULT	hr = hrOK;
	
	Panic0("Should never reach here, interface nodes have no children");
	return hr;
}


HRESULT BaseResultHandler::Init(IInterfaceInfo *pIfInfo, ITFSNode *pParent)
{
	return hrOK;
}

STDMETHODIMP BaseResultHandler::DestroyResultHandler(MMC_COOKIE cookie)
{
	SPITFSNode	spNode;
	
	m_spNodeMgr->FindNode(cookie, &spNode);
	InterfaceNodeData::Free(spNode);
	
	BaseRouterHandler::DestroyResultHandler(cookie);
	return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\iface.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	iface.h
		Interface administration
		
    FILE HISTORY:
        
*/

#ifndef _IFACE_H
#define _IFACE_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _HANDLERS_H
#include "handlers.h"
#endif

#ifndef _BASERTR_H
#include "basertr.h"
#endif

// Forward declarations
struct	IfAdminNodeData;

struct _BaseInterfaceData
{
	ULONG_PTR	m_ulData;	// use for additional pointers/handles
	DWORD		m_dwData;
	CString		m_stData;
};

#define INTERFACE_MAX_COLUMNS		16

struct InterfaceNodeData
{
	InterfaceNodeData();
	~InterfaceNodeData();
#ifdef DEBUG
	char	m_szDebug[32];
#endif

	// We will have an array of CStrings, one for each subitem column
	_BaseInterfaceData	m_rgData[INTERFACE_MAX_COLUMNS];

	DWORD		dwUnReachabilityReason;
	DWORD		dwConnectionState;
	BOOL		fIsRunning;
	DWORD		dwLastError;
	SPIInterfaceInfo	spIf;
	DWORD		dwMark;
    LRESULT     lParamPrivate;

	static HRESULT	Init(ITFSNode *pNode, IInterfaceInfo *pIf);
	static HRESULT	Free(ITFSNode *pNode);
};

#define GET_INTERFACENODEDATA(pNode) \
						((InterfaceNodeData *) pNode->GetData(TFS_DATA_USER))
#define SET_INTERFACENODEDATA(pNode, pData) \
						pNode->SetData(TFS_DATA_USER, (LONG_PTR) pData)



/*---------------------------------------------------------------------------
	Class:	InterfaceNodeHandler

 ---------------------------------------------------------------------------*/
class InterfaceNodeHandler :
   public BaseRouterHandler
{
public:
	InterfaceNodeHandler(ITFSComponentData *pCompData);
	~InterfaceNodeHandler()
			{ DEBUG_DECREMENT_INSTANCE_COUNTER(InterfaceNodeHandler); }
	
	HRESULT	Init(IInterfaceInfo *pInfo, ITFSNode *pParent);

	// Override QI to handle embedded interface
	DeclareIUnknownMembers(IMPL)
//	STDMETHOD(QueryInterface)(REFIID iid, LPVOID *ppv);
	OVERRIDE_ResultHandler_GetString();

	OVERRIDE_ResultHandler_CreatePropertyPages();
	OVERRIDE_ResultHandler_HasPropertyPages();
	OVERRIDE_ResultHandler_CompareItems();
	OVERRIDE_ResultHandler_AddMenuItems();
	OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_OnCreateDataObject();
	OVERRIDE_ResultHandler_DestroyResultHandler();

	// Override the various notifications
	OVERRIDE_BaseResultHandlerNotify_OnResultDelete();

	// The various commands that this node implements
//	HRESULT	OnRemoveInterface();
// add new parameter to allow the function retrive information of interface data -- bug 166461
	HRESULT OnRemoveInterface(MMC_COOKIE cookie);
	HRESULT OnUnreachabilityReason(MMC_COOKIE cookie);
	HRESULT	OnEnableDisable(MMC_COOKIE cookie, int nCommandID);
	HRESULT	OnConnectDisconnect(MMC_COOKIE cookie, int nCommandID);
	HRESULT	OnSetCredentials();
	HRESULT	OnDemandDialFilters(MMC_COOKIE cookie);
	HRESULT	OnDialinHours(ITFSComponent *pComponent, MMC_COOKIE cookie);

	// if the service is not running, return S_FALSE, 
	// otherwise, using MprAdminInterfaceSetInfo to notify the service of dialin hours changes
	HRESULT	LoadDialOutHours(CStringList& strList);
	HRESULT	SaveDialOutHours(CStringList& strList);


	// Initializes the node
	HRESULT ConstructNode(ITFSNode *pNode, IInterfaceInfo *pIfInfo);

	// Refresh the data for this node
	void RefreshInterface(MMC_COOKIE cookie);

public:
	// Structure used to pass data to callbacks - used as a way of
	// avoiding recomputation
	struct SMenuData
	{
		SPITFSNode			m_spNode;
        BOOL                m_fRouterIsRunning;
	};
	// Function callbacks for menu enabling/disabling
	static ULONG	GetRemoveIfMenuFlags(const SRouterNodeMenu *pData, INT_PTR pUser);
	static ULONG	GetEnableMenuFlags(const SRouterNodeMenu *pData, INT_PTR pUser);
	static ULONG	GetConnectMenuFlags(const SRouterNodeMenu *pData, INT_PTR pUser);
	static ULONG	GetUnreachMenuFlags(const SRouterNodeMenu *pData, INT_PTR pUser);
	static ULONG	GetDDFiltersFlag(const SRouterNodeMenu *pData, INT_PTR pUser);
	
protected:
	SPIInterfaceInfo	m_spInterfaceInfo;
	CString			m_stTitle;	// holds the title of the node
	LONG_PTR		m_ulConnId;

	// It is assumed that this will be valid for the lifetime of this node!
	IfAdminNodeData *	m_pIfAdminData;
	
	DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)	
};




/*---------------------------------------------------------------------------
	Class:	BaseResultHandler

	This is a base class to be used by the interface result items.  It
	will contain some of the core code needed for basic things (like
	display of data).  It will not do the specifics (like menus/properties).

 ---------------------------------------------------------------------------*/
class BaseResultHandler :
   public BaseRouterHandler
{
public:
	BaseResultHandler(ITFSComponentData *pCompData, ULONG ulId)
			: BaseRouterHandler(pCompData), m_ulColumnId(ulId)
			{ DEBUG_INCREMENT_INSTANCE_COUNTER(BaseResultHandler); };
	~BaseResultHandler()
			{ DEBUG_DECREMENT_INSTANCE_COUNTER(BaseResultHandler); }
	
	DeclareIUnknownMembers(IMPL)
	OVERRIDE_ResultHandler_GetString();
	OVERRIDE_ResultHandler_CompareItems();
	OVERRIDE_ResultHandler_DestroyResultHandler();

	HRESULT	Init(IInterfaceInfo *pInfo, ITFSNode *pParent);
	
protected:
	CString			m_stTitle;	// holds the title of the node

	//
	// This is the id of the column set to use.  This is used when we
	// interact with the ComponentConfigStream.
	//
	ULONG			m_ulColumnId;


	DeclareEmbeddedInterface(IRtrAdviseSink, IUnknown)	
};




#endif _IFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\helper.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	helper.cpp
		Implementation of the following helper classes:
		
		CDlgHelper -- enable, check, getcheck of dialog items
		CStrArray -- manages an array of CString*
			It doesn't duplicate the string when add
			It deletes the pointers during destruction
			It imports and exports SAFEARRAY of BSTRs
			It has copy operatators
		CManagedPage -- provide a middle layer between CpropertyPage and
			real property page class to manage: readonly, set modify, and 
			context help info.

		CHelpDialog -- implments context help
		
		And global functions:
			BOOL CheckADsError() -- check error code from ADSI
			void DecorateName() -- make new name to "CN=name" for LDAP
			
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include <afxtempl.h>
#include <shlobj.h>
#include <dsclient.h>
#include <winldap.h>
#include <dsgetdc.h>
#include <mmc.h>
#include "helper.h"
#include "resource.h"
#include <dsrole.h>
#include <lm.h>
#include <lmserver.h>

// helper function -- enable a dialog button
void CDlgHelper::EnableDlgItem(CDialog* pDialog, int id, bool bEnable)
{
	CWnd*	 pWnd = pDialog->GetDlgItem(id);
	ASSERT(pWnd);
	pWnd->EnableWindow(bEnable);
}

// helper function -- set check status of a dialog button
void CDlgHelper::SetDlgItemCheck(CDialog* pDialog, int id, int nCheck)
{
	CButton*	 pButton = (CButton*)pDialog->GetDlgItem(id);
	ASSERT(pButton);
	pButton->SetCheck(nCheck);
}

// helper function -- get check status of a dialog button
int CDlgHelper::GetDlgItemCheck(CDialog* pDialog, int id)
{
	CButton*	 pButton = (CButton*)(pDialog->GetDlgItem(id));
	ASSERT(pButton);
	return pButton->GetCheck();
}

CStrArray& CStrArray::operator = (const CStrArray& sarray)
{
	int	count = GetSize();
	CString*	pString;

	// remove existing members
	while(count --)
	{
		pString = GetAt(0);
		RemoveAt(0);
		delete pString;
	}

	// copy new
	count = sarray.GetSize();

	for(int i = 0; i < count; i++)
	{
		pString = new CString(*sarray[i]);
		Add(pString);
	}

	return *this;
}

// convert an array of CString to SAFEARRAY
CStrArray::operator SAFEARRAY*()
{
	USES_CONVERSION;
	int			count = GetSize();
	if(count == 0) return NULL;

	SAFEARRAYBOUND	bound[1];
	SAFEARRAY*		pSA = NULL;
	CString*		pStr = NULL;
	long			l[2];
	VARIANT	v;
	VariantInit(&v);

	bound[0].cElements = count;
	bound[0].lLbound = 0;
	try{
		// creat empty right size array
		pSA = SafeArrayCreate(VT_VARIANT, 1, bound);
		if(NULL == pSA)	return NULL;

		// put in each element
		for (long i = 0; i < count; i++)
		{
			pStr = GetAt(i);
			V_VT(&v) = VT_BSTR;
			V_BSTR(&v) = T2BSTR((LPTSTR)(LPCTSTR)(*pStr));	
			l[0] = i;
			SafeArrayPutElement(pSA, l, &v);
			VariantClear(&v);
		}
	}
	catch(CMemoryException*)
	{
		SafeArrayDestroy(pSA);
		pSA = NULL;
		VariantClear(&v);
		throw;
	}

	return pSA;
}

//build a StrArray from another array
CStrArray::CStrArray(const CStrArray& sarray)
{
	int	count = sarray.GetSize();
	CString*	pString = NULL;

	for(int i = 0; i < count; i++)
	{
		try{
			pString = new CString(*sarray[i]);
			Add(pString);
		}
		catch(CMemoryException*)
		{
			delete pString;
			throw;
		}
	}
}


//build a StrArray from a safe array
CStrArray::CStrArray(SAFEARRAY* pSA)
{
	if(pSA)	AppendSA(pSA);
}

//remove the elements from the array and delete them
int CStrArray::DeleteAll()
{
	int			ret, count;
	CString*	pStr;

	ret = count	= GetSize();

	while(count--)
	{
		pStr = GetAt(0);
		RemoveAt(0);
		delete pStr;
	}

	return ret;
}

CString*	CStrArray::AddByRID(UINT id)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CString*	pStr = NULL;
	try
	{
		pStr = new CString();
		pStr->LoadString(id);
		Add(pStr);
	}
	catch(CMemoryException* pException)
	{
		pException->Delete();
		delete pStr;
		pStr = NULL;
	}
	return pStr;
}

//build a StrArray from a safe array
bool CStrArray::AppendSA(SAFEARRAY* pSA)
{
	if(!pSA)	return false;

	CString*		pString = NULL;
	long			lIter;
	long			lBound, uBound;
	VARIANT			v;
	bool			bSuc = true;	// ser return value to true;

	USES_CONVERSION;
	VariantInit(&v);

	try{

		SafeArrayGetLBound(pSA, 1, &lBound);
		SafeArrayGetUBound(pSA, 1, &uBound);
		for(lIter = lBound; lIter <= uBound; lIter++)
		{
			if(SUCCEEDED(SafeArrayGetElement(pSA, &lIter, &v)))
			{
				if(V_VT(&v) == VT_BSTR)
				{
					pString = new CString;
					(*pString) = (LPCTSTR)W2T(V_BSTR(&v));
					Add(pString);
				}
			}
		}
	}
	catch(CMemoryException*)
	{
		delete pString;
		VariantClear(&v);
		bSuc = false;
		throw;
	}

	return bSuc;
}

//build a StrArray from a safe array
CStrArray::~CStrArray()
{
	DeleteAll();
}

// return index if found, otherwise -1;
int CStrArray::Find(const CString& Str) const
{
	int	count = GetSize();

	while(count--)
	{
		if(*GetAt(count) == Str) break;
	}
	return count;
}

//build a DWArray from another array
CDWArray::CDWArray(const CDWArray& dwarray)
{
	int	count = dwarray.GetSize();

	for(int i = 0; i < count; i++)
	{
		try{
			Add(dwarray[i]);
		}
		catch(CMemoryException*)
		{
			throw;
		}
	}
}

// return index if found, otherwise -1;
int CDWArray::Find(const DWORD dw) const
{
	int	count = GetSize();

	while(count--)
	{
		if(GetAt(count) == dw) break;
	}
	return count;
}

CDWArray& CDWArray::operator = (const CDWArray& dwarray)
{
	int	count;

	RemoveAll();

	// copy new
	count = dwarray.GetSize();

	for(int i = 0; i < count; i++)
	{
		Add(dwarray[i]);
	}

	return *this;
}

/////////////////////////////////////////////////////////////////////////////
// CManagedPage property page

IMPLEMENT_DYNCREATE(CManagedPage, CPropertyPage)

BEGIN_MESSAGE_MAP(CManagedPage, CPropertyPage)
	//{{AFX_MSG_MAP(CManagedPage)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CManagedPage::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    if (m_pHelpTable)
		::WinHelp (pWnd->m_hWnd, AfxGetApp()->m_pszHelpFilePath,
               HELP_CONTEXTMENU, (LPARAM)(LPVOID)m_pHelpTable);
}

BOOL CManagedPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW && m_pHelpTable)
	{
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
		           AfxGetApp()->m_pszHelpFilePath,
		           HELP_WM_HELP,
		           (LPARAM)(LPVOID)m_pHelpTable);
	}
    return TRUE;	
}


//---------------------------------------------------------------------------
//  This is our self deleting callback function.  If you have more than a 
//  a few property sheets, it might be a good idea to implement this in a
//  base class and derive your MFC property sheets from the base class
//
UINT CALLBACK  CManagedPage::PropSheetPageProc
(
  HWND hWnd,		             // [in] Window handle - always null
  UINT uMsg,                 // [in,out] Either the create or delete message		
  LPPROPSHEETPAGE pPsp		   // [in,out] Pointer to the property sheet struct
)
{
  ASSERT( NULL != pPsp );

  // We need to recover a pointer to the current instance.  We can't just use
  // "this" because we are in a static function
  CManagedPage* pMe   = reinterpret_cast<CManagedPage*>(pPsp->lParam);           
  ASSERT( NULL != pMe );

  switch( uMsg )
  {
    case PSPCB_CREATE:                  
      break;

    case PSPCB_RELEASE:  
      // Since we are deleting ourselves, save a callback on the stack
      // so we can callback the base class
      LPFNPSPCALLBACK pfnOrig = pMe->m_pfnOriginalCallback;
      delete pMe;      
      return 1; //(pfnOrig)(hWnd, uMsg, pPsp);
  }
  // Must call the base class callback function or none of the MFC
  // message map stuff will work
  return (pMe->m_pfnOriginalCallback)(hWnd, uMsg, pPsp); 

} // end PropSheetPageProc()



//+----------------------------------------------------------------------------
//
//  Function:   CheckADsError
//
//  Sysnopsis:  Checks the result code from an ADSI call.
//
//  Returns:    TRUE if no error.
//
//-----------------------------------------------------------------------------
BOOL CheckADsError(HRESULT hr, BOOL fIgnoreAttrNotFound, PSTR file,
                   int line)
{
    if (SUCCEEDED(hr))
        return TRUE;


	if( hr == E_ADS_PROPERTY_NOT_FOUND && fIgnoreAttrNotFound)
		return TRUE;

    if (hr == HRESULT_FROM_WIN32(ERROR_EXTENDED_ERROR))
    {
        DWORD dwErr;
        WCHAR wszErrBuf[MAX_PATH+1];
        WCHAR wszNameBuf[MAX_PATH+1];
        ADsGetLastError(&dwErr, wszErrBuf, MAX_PATH, wszNameBuf, MAX_PATH);
        if ((LDAP_RETCODE)dwErr == LDAP_NO_SUCH_ATTRIBUTE && fIgnoreAttrNotFound)
        {
            return TRUE;
        }
        TRACE(_T("Extended Error 0x%x: %ws %ws (%s @line %d).\n"), dwErr,
                     wszErrBuf, wszNameBuf, file, line);
    }
    else
        TRACE(_T("Error %08lx (%s @line %d)\n"), hr, file, line);

    return FALSE;
}

void DecorateName(LPWSTR outString, LPCWSTR inString)
{
  wcscpy (outString, L"CN=");
  wcscat(outString, inString);
}

void FindNameByDN(LPWSTR outString, LPCWSTR inString)
{

	LPWSTR	p = wcsstr(inString, L"CN=");
	if(!p)
		p = wcsstr(inString, L"cn=");

	if(!p)	
		wcscpy(outString, inString);
	else
	{
		p+=3;
		LPWSTR	p1 = outString;
		while(*p == L' ')	p++;
		while(*p != L',')
			*p1++ = *p++;
		*p1 = L'\0';
	}
}
#ifdef	___DS
static	CString	__DSRoot;

HRESULT GetDSRoot(CString& RootString)
{
if(__DSRoot.GetLength() == 0)
{
	CString		sADsPath;
	BSTR		bstrDomainFolder = NULL;
	HRESULT		hr;
	IADs*		pDomainObject = NULL;

	DOMAIN_CONTROLLER_INFO	*pInfo = NULL;
	// get the name of the Domain Controller
	DsGetDcName(NULL, NULL, NULL, NULL, 0, &pInfo);
	ASSERT(pInfo->DomainControllerName);

	// strip off any backslashes or slashes
	CString sDCName = pInfo->DomainControllerName;
	while(!sDCName.IsEmpty())
	{
		if ('\\' == sDCName.GetAt(0) || '/' == sDCName.GetAt(0))
			sDCName = sDCName.Mid(1);
		else
			break;
	}

	int	index = sDCName.Find(_T('.'));
	if(-1 != index)
		sDCName = sDCName.Left(index);

	sADsPath = _T("LDAP://") + sDCName;

	// Get the DC root DS object
	hr = ADsGetObject(T2W((LPTSTR)(LPCTSTR)sADsPath), IID_IADs, (void**)&pDomainObject);
	
	if(FAILED(hr))
		return hr;

	// find the ADsPath of the DC root
	hr = pDomainObject->get_ADsPath(&bstrDomainFolder);

	if(FAILED(hr))
		return hr;

	pDomainObject->Release();
	pDomainObject = NULL;

	// construct the DN for the object where to put the registration information
	__DSRoot = W2T(bstrDomainFolder);
	
	SysFreeString(bstrDomainFolder);
	
	index = __DSRoot.ReverseFind(_T('/'));
	__DSRoot = __DSRoot.Mid(index + 1);	// strip  off the ADsPath prefix to get the X500 DN
}
	
	RootString = __DSRoot;
	return S_OK;
}

#endif	//___DS
/////////////////////////////////////////////////////////////////////////////
// Min Chars Dialog Data Validation

void AFXAPI DDV_MinChars(CDataExchange* pDX, CString const& value, int nChars)
{
    ASSERT(nChars >= 1);        // allow them something
    if (pDX->m_bSaveAndValidate && value.GetLength() < nChars)
    {
        TCHAR szT[32];
        wsprintf(szT, _T("%d"), nChars);
        CString prompt;
        AfxFormatString1(prompt, IDS_MIN_CHARS, szT);
        AfxMessageBox(prompt, MB_ICONEXCLAMATION, IDS_MIN_CHARS);
        prompt.Empty(); // exception prep
        pDX->Fail();
    }
}

#define MAX_STRING 1024

//+----------------------------------------------------------------------------
//
//  Function:   ReportError
//
//  Sysnopsis:  Attempts to get a user-friendly error message from the system.
//
//-----------------------------------------------------------------------------
void ReportError(HRESULT hr, int nStr, HWND hWnd)
{
	PTSTR	ptzSysMsg;
	int		cch;
	CString	AppStr;
	CString	SysStr;
	CString	ErrTitle;
	CString ErrMsg;

	TRACE (_T("*+*+* ReportError called with hr = %lx"), hr);
	if (!hWnd)
	{
		hWnd = GetDesktopWindow();
	}

	try{
		if (nStr)
		{
			AppStr.LoadString(nStr);
		}

		cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
						NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
						(PTSTR)&ptzSysMsg, 0, NULL);

		if (!cch) { //try ads errors
			HMODULE		adsMod;
			adsMod = GetModuleHandle(_T("activeds.dll"));
			cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE, 
						adsMod, hr,	MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
						(PTSTR)&ptzSysMsg, 0, NULL);
		}
		if (!cch)
	    {
    		CString	str;
    		str.LoadString(IDS_ERR_ERRORCODE);
	    	SysStr.Format(str, hr);
		}
		else
		{
			SysStr = ptzSysMsg;
			LocalFree(ptzSysMsg);
		}

		ErrTitle.LoadString(IDS_ERR_TITLE);
	
		if(!AppStr.IsEmpty())
		{
			ErrMsg.Format(AppStr, (LPCTSTR)SysStr);
		}
		else
		{
			ErrMsg = SysStr;
		}

		MessageBox(hWnd, (LPCTSTR)ErrMsg, (LPCTSTR)ErrTitle, MB_OK | MB_ICONINFORMATION);
	}catch(CMemoryException* pException)
	{
		pException->Delete();
		MessageBox(hWnd, _T("No enought memory, please close other applications and try again."), _T("ACS Snapin Error"), MB_OK | MB_ICONINFORMATION);
	}
}


BOOL CPageManager::OnApply()
{
	if (!GetModified())	return FALSE;

	SetModified(FALSE);	// prevent from doing this more than once

	std::list<CManagedPage*>::iterator	i;
	for(i = m_listPages.begin(); i != m_listPages.end(); i++)
	{
		if ((*i)->GetModified())
			(*i)->OnApply();
	}
	return TRUE;
}

void CPageManager::AddPage(CManagedPage* pPage)
{
	m_listPages.push_back(pPage);
	pPage->SetManager(this);
}


/*!--------------------------------------------------------------------------
	HrIsStandaloneServer
		Returns S_OK if the machine name passed in is a standalone server,
		or if pszMachineName is S_FALSE.

		Returns FALSE otherwise.
	Author: WeiJiang
 ---------------------------------------------------------------------------*/
HRESULT	HrIsStandaloneServer(LPCWSTR pMachineName)
{
    DWORD		netRet = 0;
    HRESULT		hr = S_OK;
	DSROLE_PRIMARY_DOMAIN_INFO_BASIC* pdsRole = NULL;

	netRet = DsRoleGetPrimaryDomainInformation(pMachineName, DsRolePrimaryDomainInfoBasic, (LPBYTE*)&pdsRole);

	if(netRet != 0)
	{
		hr = HRESULT_FROM_WIN32(netRet);
		goto L_ERR;
	}

	ASSERT(pdsRole);
	
	// if the machine is not a standalone server
	if(pdsRole->MachineRole != DsRole_RoleStandaloneServer)
    {
		hr = S_FALSE;
    }
    
L_ERR:    	
	if(pdsRole)
		DsRoleFreeMemory(pdsRole);

    return hr;
}

/*!--------------------------------------------------------------------------
    	HrIsNTServer
    Author:
 ---------------------------------------------------------------------------*/
HRESULT	HrIsNTServer(LPCWSTR pMachineName, DWORD* pMajorVersion)
{
    HRESULT        hr = S_OK;
    SERVER_INFO_102*	pServerInfo102 = NULL;
    NET_API_STATUS	netRet = 0;

	netRet = NetServerGetInfo((LPWSTR)pMachineName, 102, (LPBYTE*)&pServerInfo102);

	if(netRet != 0)
	{
		hr = HRESULT_FROM_WIN32(netRet);
		goto L_ERR;
	}

	ASSERT(pServerInfo102);

    // check if the machine focused on is a standalone server
    //
    *pMajorVersion = (pServerInfo102->sv102_version_major & MAJOR_VERSION_MASK);

    if (!(pServerInfo102->sv102_type & SV_TYPE_SERVER_NT))
    {
       	hr = S_FALSE;
    }

L_ERR:

	if(pServerInfo102)
		NetApiBufferFree(pServerInfo102);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\helper.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
   helper.h
      This file defines the following macros helper classes and functions:

      Macros to check HRESULT
      CDlgHelper -- helper class to Enable/Check dialog Item, 
      CMangedPage -- helper class for PropertyPage, 
         It manages ReadOnly, SetModified, and ContextHelp

      CStrArray -- an array of pointer to CString
         It does NOT duplicate the string upon Add
         and It deletes the pointer during destruction
         It imports and exports SAFEARRAY
      
      CReadWriteLock -- class for share read or exclusive write lock
      
      CStrBox -- wrapper class for CListBox and CComboBox
      
      CIPAddress -- wrapper for IPAddress
      
      CFramedRoute -- Wrapper for FramedRoute
      CStrParse -- parses string for TimeOfDay


    FILE HISTORY:
        
*/
// helper functions for dialog and dialog items
#ifndef _DLGHELPER_
#define _DLGHELPER_

#ifndef _LIST_
#include <list>
using namespace std;
#endif

#include <afxcmn.h>
#include <afxmt.h>
#include <afxdlgs.h>
#include <afxtempl.h>


#ifdef NOIMP
#undef NOIMP
#endif
#define NOIMP  {return E_NOTIMPL;}

#ifdef SAYOK
#undef SAYOK
#endif
#define SAYOK  {return S_OK;}
   
/*-----------------------------------------------------------------------------
/ Exit macros for macro
/   - these assume that a label "exit_gracefully:" prefixes the prolog
/     to your function
/----------------------------------------------------------------------------*/

#if !DSUI_DEBUG

#define ExitGracefully(hr, result, text)            \
            {  hr = result; goto exit_gracefully; }

#define FailGracefully(hr, text)                    \
       { if ( FAILED(hr) ) { goto exit_gracefully; } }

#else

#define ExitGracefully(hr, result, text)            \
            { OutputDebugString(TEXT(text)); hr = result; goto exit_gracefully; }

#define FailGracefully(hr, text)                    \
       { if ( FAILED(hr) ) { OutputDebugString(TEXT(text)); goto exit_gracefully; } }

#endif

/*-----------------------------------------------------------------------------
/ Interface helper macros
/----------------------------------------------------------------------------*/
#define DoRelease(pInterface)                       \
        { if ( pInterface ) { pInterface->Release(); pInterface = NULL; } }


/*-----------------------------------------------------------------------------
/ String/byte helper macros
/----------------------------------------------------------------------------*/

#define StringByteSizeA(sz)         ((lstrlenA(sz)+1)*sizeof(CHAR))
#define StringByteSizeW(sz)         ((lstrlenW(sz)+1)*sizeof(WCHAR))

#define StringByteCopyA(pDest, iOffset, sz)         \
        { CopyMemory(&(((LPBYTE)pDest)[iOffset]), sz, StringByteSizeA(sz)); }

#define StringByteCopyW(pDest, iOffset, sz)         \
        { CopyMemory(&(((LPBYTE)pDest)[iOffset]), sz, StringByteSizeW(sz)); }

#ifndef UNICODE
#define StringByteSize              StringByteSizeA
#define StringByteCopy              StringByteCopyA
#else
#define StringByteSize              StringByteSizeW
#define StringByteCopy              StringByteCopyW
#endif

#define ByteOffset(base, offset)   (((LPBYTE)base)+offset)

// to reduce the step to set VARIANT
#define  V__BOOL(v, v1)\
   V_VT(v) = VT_BOOL,   V_BOOL(v) = (v1)

#define  V__I4(v, v1)\
   V_VT(v) = VT_I4,  V_I4(v) = (v1)

#define  V__I2(v, v1)\
   V_VT(v) = VT_I2,  V_I2(v) = (v1)

#define  V__UI1(v, v1)\
   V_VT(v) = VT_UI1, V_UI1(v) = (v1)

#define  V__BSTR(v, v1)\
   V_VT(v) = VT_BSTR,   V_BSTR(v) = (v1)

#define  V__ARRAY(v, v1)\
   V_VT(v) = VT_ARRAY,  V_ARRAY(v) = (v1)

//#define REPORT_ERROR(hr) \
//    TRACE(_T("**** ERROR RETURN <%s @line %d> -> %08lx\n"), \
//                 __FILE__, __LINE__, hr)); \
//    ReportError(hr, 0, 0);

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif

#ifdef   _DEBUG
#define  CHECK_HR(hr)\
   {if(!CheckADsError(hr, FALSE, __FILE__, __LINE__)){goto L_ERR;}}
#else
#define  CHECK_HR(hr)\
   if FAILED(hr)  goto L_ERR
#endif

#ifdef   _DEBUG
#define  NOTINCACHE(hr)\
   (CheckADsError(hr, TRUE, __FILE__, __LINE__))
#else
#define  NOTINCACHE(hr)\
   (E_ADS_PROPERTY_NOT_FOUND == (hr))
#endif

BOOL CheckADsError(HRESULT hr, BOOL fIgnoreAttrNotFound, PSTR file, int line);


#ifdef   _DEBUG
#define TRACEAfxMessageBox(id) {\
   TRACE(_T("AfxMessageBox <%s @line %d> ID: %d\n"), \
                 __FILE__, __LINE__, id); \
    AfxMessageBox(id);}\

#else
#define TRACEAfxMessageBox(id) AfxMessageBox(id)
#endif

// change string Name to CN=Name
void DecorateName(LPWSTR outString, LPCWSTR inString);

// change string Name to CN=Name
HRESULT GetDSRoot(CString& RootString);

// find name from DN for example LDAP://CN=userA,CN=users...  returns userA
void FindNameByDN(LPWSTR outString, LPCWSTR inString);

class CDlgHelper
{
public:
   static void EnableDlgItem(CDialog* pDialog, int id, bool bEnable = true);
   static int  GetDlgItemCheck(CDialog* pDialog, int id);
   static void SetDlgItemCheck(CDialog* pDialog, int id, int nCheck);
};

class CManagedPage;
// class CPageManager and CManagedPage together handle the situation when
// the property sheet need to do some processing when OnApply function is called
// on some of the pages
class ATL_NO_VTABLE CPageManager : 
   public CComObjectRootEx<CComSingleThreadModel>,
   public IUnknown
{
BEGIN_COM_MAP(CPageManager)
   COM_INTERFACE_ENTRY(IUnknown)
END_COM_MAP()

public:

   CPageManager(){ m_bModified = FALSE; m_bReadOnly = FALSE; m_dwFlags = 0;};
   BOOL  GetModified(){ return m_bModified;};
   void  SetModified(BOOL bModified){ m_bModified = bModified;};
   void  SetReadOnly(BOOL bReadOnly){ m_bReadOnly = bReadOnly;};
   BOOL  GetReadOnly(){ return m_bReadOnly;};
   virtual BOOL   OnApply();
   void AddPage(CManagedPage* pPage);

   void AddFlags(DWORD flags) { m_dwFlags |= flags;};
   DWORD GetFlags() { return m_dwFlags;};
   void ClearFlags() { m_dwFlags = 0;};
   
protected:
   BOOL                 m_bModified;
   BOOL                 m_bReadOnly;
   std::list<CManagedPage*>   m_listPages;
   DWORD                m_dwFlags;
};

//=============================================================================
// Global Help Table for many Dialog IDs
//
struct CGlobalHelpTable{
   UINT  nIDD;
   const DWORD*   pdwTable;
};

//=============================================================================
// Page that handles Context Help, and talk with CPageManager to do
// OnApply together
//
class CManagedPage : public CPropertyPage // talk back to property sheet
{
   DECLARE_DYNCREATE(CManagedPage)

// Implementation
protected:
   // Generated message map functions
   //{{AFX_MSG(CManagedPage)
   afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
   afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()
protected:
   CManagedPage() : CPropertyPage(){
      // Need to save the original callback pointer because we are replacing
      // it with our own 
      m_pfnOriginalCallback = m_psp.pfnCallback;
   };
   
public:  
   CManagedPage(UINT nIDTemplate) : CPropertyPage(nIDTemplate)
   {
      m_bModified = FALSE; 
      m_pManager = NULL;
      m_pHelpTable = NULL;
      m_nIDD = nIDTemplate;

      // Need to save the original callback pointer because we are replacing
      // it with our own 
      m_pfnOriginalCallback = m_psp.pfnCallback;
   };

   void SetModified( BOOL bModified = TRUE ) 
   { 
      if(m_pManager && !m_pManager->GetReadOnly()) // if NOT readonly
      {
         m_bModified = bModified; 
         CPropertyPage::SetModified(bModified); 

         // only set change
         if(bModified) m_pManager->SetModified(TRUE);
      }
      else
      {
         m_bModified = bModified; 
         CPropertyPage::SetModified(bModified); 
      }
   };

   BOOL GetModified() { return m_bModified;};

   virtual BOOL OnApply() 
   { 
      m_bModified = FALSE;
      if(m_pManager && m_pManager->GetModified())  // prevent from entering more than once
         m_pManager->OnApply();
      return CPropertyPage::OnApply();
   };

   void SetManager(CPageManager* pManager) { m_pManager = pManager; if(pManager) pManager->AddRef();};
   void AddFlags(DWORD  flags) { if(m_pManager) m_pManager->AddFlags(flags);};

protected:

   // set help table: either call SetGHelpTable or call setHelpTable 
   void SetGlobalHelpTable(CGlobalHelpTable** pGTable) 
   {
      if(pGTable)
      {
         while((*pGTable)->nIDD && (*pGTable)->nIDD != m_nIDD)
            pGTable++;
         if((*pGTable)->nIDD)
            m_pHelpTable = (*pGTable)->pdwTable;
      }
   };
   
   void SetHelpTable(DWORD* pTable){m_pHelpTable = pTable;};

#ifdef   _DEBUG
   virtual void Dump( CDumpContext& dc ) const
   {
      dc << _T("CManagedPage");
   };

#endif

protected:
   CPageManager*     m_pManager;
   BOOL           m_bModified;

   UINT           m_nIDD;
   const DWORD*            m_pHelpTable;


public:    
    static UINT CALLBACK PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    void SetSelfDeleteCallback()
    {

       // tell MMC to hook the proc because we are running on a separate, 
      // non MFC thread.
      m_psp.pfnCallback = PropSheetPageProc; 
  
      // We also need to save a self-reference so that the static callback
      // function can recover a "this" pointer
      m_psp.lParam = (LPARAM)this;

    };

protected:
    LPFNPSPCALLBACK      m_pfnOriginalCallback;

};

#include <afxtempl.h>
class CStrArray :  public CArray< CString*, CString* >
{
public:
   CStrArray(SAFEARRAY* pSA = NULL);
   CStrArray(const CStrArray& sarray);
   CString* AddByRID(UINT  rID);
   int   Find(const CString& Str) const;
   int   DeleteAll();
   virtual ~CStrArray();
   operator SAFEARRAY*();
   CStrArray& operator = (const CStrArray& sarray);
   bool AppendSA(SAFEARRAY* pSA);
};

class CDWArray :  public CArray< DWORD, DWORD >
{
public:
   CDWArray(){};
   CDWArray(const CDWArray& dwarray);
   int   Find(const DWORD dw) const;
   int   DeleteAll(){ RemoveAll(); return 0;};
   virtual ~CDWArray(){RemoveAll();};
   CDWArray& operator = (const CDWArray& dwarray);
};

// a lock to allow multiple read access exclusive or only one write access
class CReadWriteLock    // sharable read, exclusive write
{
public:
   CReadWriteLock() : m_nRead(0)
   {
#ifdef   _DEBUG
      d_bWrite = false;
#endif
   };
   void EnterRead()
   { 
      TRACE(_T("Entering Read Lock ..."));
      m_csRead.Lock(); 
      if (!m_nRead++) 
         m_csWrite.Lock();
      m_csRead.Unlock();
      TRACE(_T("Entered Read Lock\n"));
   };

   void LeaveRead() 
   { 
      TRACE(_T("Leaving Read Lock ..."));
      m_csRead.Lock(); 
      ASSERT(m_nRead > 0);
      if (!--m_nRead)
         m_csWrite.Unlock();
      m_csRead.Unlock();
      TRACE(_T("Left Read Lock\n"));
   };

   void EnterWrite()
   { 
      TRACE(_T("Entering Write Lock ..."));
      m_csWrite.Lock();
      TRACE(_T("Entered Write Lock\n")); 
#ifdef   _DEBUG
      d_bWrite = true;
#endif
   };
   void LeaveWrite()
   { 
#ifdef   _DEBUG
      d_bWrite = false;
#endif
      m_csWrite.Unlock();  
      TRACE(_T("Left Write Lock\n"));
   };
public:
#ifdef   _DEBUG
   bool  d_bWrite;
#endif
   
protected:
   CCriticalSection  m_csRead;
   CCriticalSection  m_csWrite;
   int               m_nRead;
};

// to manage a list box/ combo box
template <class CBox> 
class CStrBox
{
public:
   CStrBox(CDialog* pDialog, int id, CStrArray& Strings)
      : m_Strings(Strings), m_id(id)
   { 
      m_pDialog = pDialog;
      m_pBox = NULL;
   };

   int Fill()
   {
      m_pBox = (CBox*)m_pDialog->GetDlgItem(m_id); 
      ASSERT(m_pBox);
      m_pBox->ResetContent();

      int count = m_Strings.GetSize();
      int   index;
      for(int i = 0; i < count; i++)
      {
         index = m_pBox->AddString(*m_Strings[i]);
         m_pBox->SetItemDataPtr(index, m_Strings[i]);
      }
      return count;
   };

   int DeleteSelected()
   {
      int   index;
      ASSERT(m_pBox);
      index = m_pBox->GetCurSel();

      // if there is any selected
      if( index != LB_ERR )
      {
         CString* pStr;
         pStr = (CString*)m_pBox->GetItemDataPtr(index);
         // remove the entry from the box
         m_pBox->DeleteString(index);

         // find the string in the String array
         int count = m_Strings.GetSize();
         for(int i = 0; i < count; i++)
         {
            if (m_Strings[i] == pStr)
               break;
         }
         ASSERT(i < count);
         // remove the string from the string array
         m_Strings.RemoveAt(i);
         index = i;
         delete pStr;
      }
      return index;
   };

   int AddString(CString* pStr)     // the pStr needs to dynamically allocated
   {
      int index;
      ASSERT(m_pBox && pStr);
      index = m_pBox->AddString(*pStr);
      m_pBox->SetItemDataPtr(index, pStr);
      return m_Strings.Add(pStr);
   };

   int Select(int arrayindex)    // the pStr needs to dynamically allocated
   {
      ASSERT(arrayindex < m_Strings.GetSize());
      return m_pBox->SelectString(0, *m_Strings[arrayindex]);
   };

   void Enable(BOOL b)     // the pStr needs to dynamically allocated
   {
      ASSERT(m_pBox);
      m_pBox->EnableWindow(b);
   };

   int GetSelected()    // it returns the index where the
   {
      int   index;
      ASSERT(m_pBox);
      index = m_pBox->GetCurSel();

      // if there is any selected
      if( index != LB_ERR )
      {
         CString* pStr;
         pStr = (CString*)m_pBox->GetItemDataPtr(index);

         // find the string in the String array
         int count = m_Strings.GetSize();
         for(int i = 0; i < count; i++)
         {
            if (m_Strings[i] == pStr)
               break;
         }
         ASSERT(i < count);
         index = i;
      }
      return index;
   };

   CBox*    m_pBox;
protected:
   int         m_id;
   CStrArray&  m_Strings;
   CDialog* m_pDialog;
};

// class to take care of ip address
class CIPAddress  
{
public:
   CIPAddress(DWORD address = 0)
   {
      m_dwAddress = address;
   };
   
// CIPAddress(const CString& strAddress){};

   operator DWORD() { return m_dwAddress;};
   operator CString()
   {
      CString  str;

      WORD  hi = HIWORD(m_dwAddress);
      WORD  lo = LOWORD(m_dwAddress);
      str.Format(_T("%-d.%-d.%-d.%d"), HIBYTE(hi), LOBYTE(hi), HIBYTE(lo), LOBYTE(lo));
      return str;
   };

   DWORD m_dwAddress;
};

// format of framedroute:  mask dest metric ; mask and dest in dot format
class CFramedRoute
{
public:
   void SetRoute(CString* pRoute)
   {
      m_pStrRoute = pRoute;
      m_pStrRoute->TrimLeft();
      m_pStrRoute->TrimRight();
      m_iFirstSpace = m_pStrRoute->Find(_T(' '))   ;
      m_iLastSpace = m_pStrRoute->ReverseFind(_T(' '))   ;
   };

   CString& GetDest(CString& dest) const
   { 
      int      i = m_pStrRoute->Find(_T('/'));
      if(i == -1)
         i = m_iFirstSpace;

      dest = m_pStrRoute->Left(i);
      return dest;
   };

   CString& GetNextStop(CString& nextStop) const
   { 
      nextStop = m_pStrRoute->Mid(m_iFirstSpace + 1, m_iLastSpace - m_iFirstSpace -1 );
      return nextStop;
   };

   CString& GetPrefixLength(CString& prefixLength) const
   { 
      int      i = m_pStrRoute->Find(_T('/'));

      if( i != -1)
      {
         prefixLength = m_pStrRoute->Mid(i + 1, m_iFirstSpace - i - 1);
      }
      else
         prefixLength = _T("");

      return prefixLength;
   };

   CString& GetMetric(CString& metric) const
   {
      metric = m_pStrRoute->Mid(m_iLastSpace + 1); 
      return metric;
   };

protected:

   // WARNING: the string is not copied, so user need to make sure the origin is valid
   CString* m_pStrRoute;
   int         m_iFirstSpace;
   int         m_iLastSpace;
};

class CStrParser
{
public:
   CStrParser(LPCTSTR pStr = NULL) : m_pStr(pStr) { }

   // get the current string position
   LPCTSTR  GetStr() const { return m_pStr;};

   void  SetStr(LPCTSTR pStr) { m_pStr = pStr;};

   // find a unsigned interger and return it, -1 == not found
   int GetUINT()
   {
      UINT  ret = 0;
      while((*m_pStr < _T('0') || *m_pStr > _T('9')) && *m_pStr != _T('\0'))
         m_pStr++;

      if(*m_pStr == _T('\0')) return -1;

      while(*m_pStr >= _T('0') && *m_pStr <= _T('9'))
      {
         ret = ret * 10 + *m_pStr - _T('0');
         m_pStr++;
      }

      return ret;
   };

   // find c and skip it
   int   GotoAfter(TCHAR c)
   {
      int   ret = 0;
      // go until find c or end of string
      while(*m_pStr != c && *m_pStr != _T('\0'))
         m_pStr++, ret++;

      // if found
      if(*m_pStr == c)  
         m_pStr++, ret++;
      else  
         ret = -1;
      return ret;
   };

   // skip blank characters space tab
   void  SkipBlank()
   {
      while((*m_pStr == _T(' ') || *m_pStr == _T('\t')) && *m_pStr != _T('\0'))
         m_pStr++;
   };

   // check to see if the first character is '0'-'6' for Monday(0) to Sunday(6)
   int DayOfWeek() {
      SkipBlank();
      if(*m_pStr >= _T('0') && *m_pStr <= _T('6'))
         return (*m_pStr++ - _T('0'));
      else
         return -1;  // not day of week
   };


protected:
   LPCTSTR  m_pStr;
private:
   CString  _strTemp;
};

void ReportError(HRESULT hr, int nStr, HWND hWnd);

// number of characters
void AFXAPI DDV_MinChars(CDataExchange* pDX, CString const& value, int nChars);


/*!--------------------------------------------------------------------------
	IsStandaloneServer
		Returns S_OK if the machine name passed in is a standalone server,
		or if pszMachineName is S_FALSE.

		Returns S_FALSE otherwise.
	Author: WeiJiang
 ---------------------------------------------------------------------------*/
HRESULT	HrIsStandaloneServer(LPCTSTR pszMachineName);


HRESULT	HrIsNTServer(LPCWSTR pMachineName, DWORD* pMajorVersion);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\images.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       images.h
//
//--------------------------------------------------------------------------

#ifndef _IMAGES_H
#define _IMAGES_H

// Note - These are offsets into my image list
typedef enum _IMAGE_INDICIES
{
	IMAGE_IDX_FOLDER_OPEN = 0,			// open folder image
	IMAGE_IDX_FOLDER_CLOSED,			// typical closed folder image
	IMAGE_IDX_MACHINE,					// a machine
	IMAGE_IDX_MACHINE_ERROR,			// generic can't connect to machine
	IMAGE_IDX_MACHINE_ACCESS_DENIED,	// access denied
	IMAGE_IDX_MACHINE_STARTED,			// Router service is started
	IMAGE_IDX_MACHINE_STOPPED,			// Router service is stopped
	IMAGE_IDX_MACHINE_WAIT,				// waiting for the machine
	IMAGE_IDX_DOMAIN,					// domain (or multiple machines)
	IMAGE_IDX_INTERFACES,				// routing interfaces
	IMAGE_IDX_LAN_CARD,					// LAN adapter icon
	IMAGE_IDX_WAN_CARD,					// WAN adapter icon

	// Add all indexes BEFORE this.  This is the end of the list
	IMAGE_IDX_MAX
} IMAGE_INDICIES, *LPIMAGE_INDICIES;


// Include the types of all of our nodes
// This corresponds to the node types but is a DWORD that is used
// by the framework

typedef enum
{
	ROUTER_NODE_MACHINE = 0,
	ROUTER_NODE_DOMAIN,
	ROUTER_NODE_ROOT,
} ROUTER_NODE_DESC;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\mprsnap\ifadmin.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    IFadmin
        Interface node information
        
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ifadmin.h"
#include "iface.h"            // to get InterfaceNodeHandler class
#include "rtrstrm.h"        // for RouterAdminConfigStream
#include "rtrlib.h"            // ContainerColumnInfo
#include "coldlg.h"            // ColumnDlg
#include "column.h"        // ComponentConfigStream
#include "refresh.h"        // IRouterRefresh
#include "refrate.h"        // CRefRate dialog
#include "machine.h"
#include "dmvcomp.h"
#include "rtrerr.h"            // FormatRasError

#include "ports.h"            // for PortsDataEntry

extern "C" {
#define _NOUIUTIL_H_
#include "dtl.h"
#include "pbuser.h"
};






/*!--------------------------------------------------------------------------
	AddStaticRoute -- Collapse this later into common module
		This function ASSUMES that the route is NOT in the block.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT AddStaticRoute(MIB_IPFORWARDROW * pNewForwardRow,
									   IInfoBase *pInfoBase,
									   InfoBlock *pBlock,
                                       DWORD      dwCount)
{
	MIB_IPFORWARDROW	IPRow;
	HRESULT				hr = hrOK;
	
	if (pBlock == NULL)
	{
		//
		// No IP_ROUTE_INFO block was found; we create a new block 
		// with the new route, and add that block to the interface-info
		//
		
		CORg( pInfoBase->AddBlock(IP_ROUTE_INFO, sizeof(MIB_IPFORWARDROW),
								  (LPBYTE) pNewForwardRow, dwCount, 0) );
	}
	else
	{
		// Either the route is completely new, or it is a route
		// which was moved from one interface to another.
		// Set a new block as the IP_ROUTE_INFO,
		// and include the re-configured route in the new block.
			
		MIB_IPFORWARDROW* prdTable;
			
		prdTable = new MIB_IPFORWARDROW[pBlock->dwCount + 1];
		Assert(prdTable);
		
		// Copy the original table of routes
		::memcpy(prdTable, pBlock->pData,
				 pBlock->dwCount * sizeof(MIB_IPFORWARDROW));
		
		// Append the new route
		prdTable[pBlock->dwCount] = *pNewForwardRow;
		
		// Replace the old route-table with the new one
		CORg( pInfoBase->SetData(IP_ROUTE_INFO, sizeof(MIB_IPFORWARDROW),
								 (LPBYTE) prdTable, pBlock->dwCount + 1, 0) );
	}
	
Error:
	return hr;
}




IfAdminNodeData::IfAdminNodeData()
{
#ifdef DEBUG
    StrCpyA(m_szDebug, "IfAdminNodeData");
#endif

}

IfAdminNodeData::~IfAdminNodeData()
{
}

/*!--------------------------------------------------------------------------
    IfAdminNodeData::InitAdminNodeData
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IfAdminNodeData::InitAdminNodeData(ITFSNode *pNode, RouterAdminConfigStream *pConfigStream)
{
    HRESULT                hr = hrOK;
    IfAdminNodeData *    pData = NULL;
    
    pData = new IfAdminNodeData;

    SET_IFADMINNODEDATA(pNode, pData);
    
    return hr;
}

/*!--------------------------------------------------------------------------
    IfAdminNodeData::FreeAdminNodeData
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IfAdminNodeData::FreeAdminNodeData(ITFSNode *pNode)
{    
    IfAdminNodeData *    pData = GET_IFADMINNODEDATA(pNode);
    delete pData;
    SET_IFADMINNODEDATA(pNode, NULL);
    
    return hrOK;
}


STDMETHODIMP IfAdminNodeHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Is the pointer bad?
    if (ppv == NULL)
        return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
        *ppv = (LPVOID) this;
    else if (riid == IID_IRtrAdviseSink)
        *ppv = &m_IRtrAdviseSink;
    else
        return CHandler::QueryInterface(riid, ppv);

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
    ((LPUNKNOWN) *ppv)->AddRef();
        return hrOK;
    }
    else
        return E_NOINTERFACE;    
}


/*---------------------------------------------------------------------------
    NodeHandler implementation
 ---------------------------------------------------------------------------*/

extern const ContainerColumnInfo    s_rgIfAdminColumnInfo[];

const ContainerColumnInfo s_rgIfAdminColumnInfo[] =
{
    { IDS_COL_INTERFACES,    CON_SORT_BY_STRING, TRUE, COL_IF_NAME },
    { IDS_COL_TYPE,            CON_SORT_BY_STRING, TRUE, COL_STRING },
    { IDS_COL_STATUS,        CON_SORT_BY_STRING, TRUE, COL_STATUS },
    { IDS_COL_CONNECTION_STATE, CON_SORT_BY_STRING, TRUE, COL_STRING},
    { IDS_COL_DEVICE_NAME,    CON_SORT_BY_STRING, TRUE, COL_IF_DEVICE},
};
                                            
IfAdminNodeHandler::IfAdminNodeHandler(ITFSComponentData *pCompData)
    : BaseContainerHandler(pCompData, DM_COLUMNS_IFADMIN, s_rgIfAdminColumnInfo),
    m_bExpanded(FALSE),
    m_hInstRasDlg(NULL),
    m_pfnRouterEntryDlg(NULL),
    m_pConfigStream(NULL),
    m_ulConnId(0),
    m_ulRefreshConnId(0)
{
    // Setup the verb states for this node
    m_rgButtonState[MMC_VERB_REFRESH_INDEX] = ENABLED;
    m_bState[MMC_VERB_REFRESH_INDEX] = TRUE;
}

/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::Init
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IfAdminNodeHandler::Init(IRouterInfo *pRouterInfo, RouterAdminConfigStream *pConfigStream)
{
    HRESULT    hr = hrOK;
    HKEY hkeyMachine;
    DWORD dwErr;

    // If we don't have a router info then we probably failed to load
    // or failed to connect.  Bail out of this.
    if (!pRouterInfo)
        CORg( E_FAIL );
    
    m_spRouterInfo.Set(pRouterInfo);

    // Also need to register for change notifications
    m_spRouterInfo->RtrAdvise(&m_IRtrAdviseSink, &m_ulConnId, 0);

    if (m_hInstRasDlg == NULL)
        m_hInstRasDlg = LoadLibrary(_T("rasdlg.dll"));
    if (m_hInstRasDlg)
    {
        m_pfnRouterEntryDlg= (PROUTERENTRYDLG)::GetProcAddress(m_hInstRasDlg,
            SZROUTERENTRYDLG);
        if (m_pfnRouterEntryDlg == NULL)
        {
            Trace0("MPRSNAP - Could not find function: RouterEntryDlg\n");
        }
    }
    else
    {
        dwErr = GetLastError();
        Trace0("MPRSNAP - failed to load rasdlg.dll\n");
    }

    m_pConfigStream = pConfigStream;

Error:
    return hrOK;
}

/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::DestroyHandler
        Implementation of ITFSNodeHandler::DestroyHandler
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IfAdminNodeHandler::DestroyHandler(ITFSNode *pNode)
{
    IfAdminNodeData::FreeAdminNodeData(pNode);

    m_spDataObject.Release();

    if (m_hInstRasDlg)
    {
        FreeLibrary(m_hInstRasDlg);
        m_hInstRasDlg = NULL;
    }
    
    if (m_ulRefreshConnId)
    {
        SPIRouterRefresh    spRefresh;
        if (m_spRouterInfo)
            m_spRouterInfo->GetRefreshObject(&spRefresh);
        if (spRefresh)
            spRefresh->UnadviseRefresh(m_ulRefreshConnId);
    }
    m_ulRefreshConnId = 0;
    
    if (m_spRouterInfo)
    {
        m_spRouterInfo->RtrUnadvise(m_ulConnId);
        m_spRouterInfo.Release();
    }
    return hrOK;
}

/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
IfAdminNodeHandler::HasPropertyPages
(
    ITFSNode *            pNode,
    LPDATAOBJECT        pDataObject, 
    DATA_OBJECT_TYPES   type, 
    DWORD               dwType
)
{
       return hrOK;
}




/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::OnAddMenuItems
        Implementation of ITFSNodeHandler::OnAddMenuItems
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IfAdminNodeHandler::OnAddMenuItems(
                                                ITFSNode *pNode,
                                                LPCONTEXTMENUCALLBACK pContextMenuCallback, 
                                                LPDATAOBJECT lpDataObject, 
                                                DATA_OBJECT_TYPES type, 
                                                DWORD dwType,
                                                long *pInsertionAllowed)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    HRESULT hr = S_OK;
    CString    stMenuItem;
    DWORD    dwWiz;
    ULONG    ulFlags;
    SPIRouterRefresh    spRefresh;
    RouterVersionInfo    routerVer;
    BOOL    fNt4;

    COM_PROTECT_TRY
    {
        m_spRouterInfo->GetRouterVersionInfo(&routerVer);
        fNt4 = (routerVer.dwRouterVersion == 4);
        
        
        if ((type == CCT_SCOPE) || (dwType == TFS_COMPDATA_CHILD_CONTEXTMENU))
        {
            long lMenuText;

            //
            // If any more menus are added to this section, then the
            // code for the InterfaceNodeHandler needs to be updated also.
            //

            // Add these menus at the top of the context menu

            if (!fNt4)
            {
                if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
                {
                    lMenuText = IDS_MENU_NEW_DEMAND_DIAL_INTERFACE;
                    stMenuItem.LoadString( lMenuText );
                    hr = LoadAndAddMenuItem( pContextMenuCallback,
                                             stMenuItem,
                                             lMenuText,
                                             CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                             EnableAddInterface() ? 0 : MF_GRAYED);
                    
#ifdef KSL_IPINIP
                    lMenuText = IDS_MENU_ADD_TUNNEL;
                    stMenuItem.LoadString( lMenuText );
                    hr = LoadAndAddMenuItem( pContextMenuCallback,
                                             stMenuItem,
                                             lMenuText,
                                             CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                             EnableAddInterface() ? 0 : MF_GRAYED);
#endif //KSL_IPINIP
                }
                
            }
            
            // For NT4, we add the option to disable the wizard
            // interface.
            // --------------------------------------------------------
            if (fNt4)
            {
                if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
                {
                    lMenuText = IDS_MENU_ADD_INTERFACE;
                    stMenuItem.LoadString(lMenuText);
                    hr = LoadAndAddMenuItem( pContextMenuCallback,
                                             stMenuItem,
                                             lMenuText,
                                             CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                             EnableAddInterface() ? 0 : MF_GRAYED);
                }                
                
                hr = GetDemandDialWizardRegKey(OLE2CT(m_spRouterInfo->GetMachineName()),
                                               &dwWiz);
                
                if (!FHrSucceeded(hr))
                    dwWiz = TRUE;
                
                ulFlags = dwWiz ? MF_CHECKED : MF_UNCHECKED;
                
                if (!FHrSucceeded(hr))
                    ulFlags |= MF_GRAYED;
                
                if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
                {
                    lMenuText = IDS_MENU_USE_DEMANDDIALWIZARD;
                    stMenuItem.LoadString(lMenuText);
                    hr = LoadAndAddMenuItem( pContextMenuCallback,
                                             stMenuItem,
                                             lMenuText,
                                             CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                             ulFlags );
                    ASSERT( SUCCEEDED(hr) );
                }
            }
                
        }
    }
    COM_PROTECT_CATCH;
        
    return hr; 
}

/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::OnCommand
        Implementation of ITFSNodeHandler::OnCommand
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IfAdminNodeHandler::OnCommand(ITFSNode *pNode, long nCommandId, 
                                           DATA_OBJECT_TYPES    type, 
                                           LPDATAOBJECT pDataObject, 
                                           DWORD    dwType)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;

    COM_PROTECT_TRY
    {

        switch (nCommandId)
        {
            case IDS_MENU_NEW_DEMAND_DIAL_INTERFACE:
            case IDS_MENU_ADD_INTERFACE:
                OnAddInterface();
                break;
#ifdef KSL_IPINIP
            case IDS_MENU_ADD_TUNNEL:
                OnNewTunnel();
                break;
#endif //KSL_IPINIP

            case IDS_MENU_USE_DEMANDDIALWIZARD:
                OnUseDemandDialWizard();
                break;
             case IDS_MENU_REFRESH:
                SynchronizeNodeData(pNode);
                break;

            default:
                break;
            
        }
    }
    COM_PROTECT_CATCH;

    return hr;
}

/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::GetString
        Implementation of ITFSNodeHandler::GetString
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) IfAdminNodeHandler::GetString(ITFSNode *pNode, int nCol)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT    hr = hrOK;

    COM_PROTECT_TRY
    {
        if (m_stTitle.IsEmpty())
            m_stTitle.LoadString(IDS_ROUTING_INTERFACES);
    }
    COM_PROTECT_CATCH;

    return m_stTitle;
}


/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::OnCreateDataObject
        Implementation of ITFSNodeHandler::OnCreateDataObject
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP IfAdminNodeHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
    HRESULT    hr = hrOK;
    
    COM_PROTECT_TRY
    {
        if (!m_spDataObject)
        {
            CORg( CreateDataObjectFromRouterInfo(m_spRouterInfo,
                m_spRouterInfo->GetMachineName(),
                type, cookie, m_spTFSCompData,
                &m_spDataObject, NULL, FALSE) );
            Assert(m_spDataObject);
        }
        
        *ppDataObject = m_spDataObject;
        (*ppDataObject)->AddRef();
            
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;
    return hr;
}

/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::OnExpand
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IfAdminNodeHandler::OnExpand(ITFSNode *pNode,
                                     LPDATAOBJECT pDataObject,
                                     DWORD dwType,
                                     LPARAM arg,
                                     LPARAM lParam)
{
    HRESULT                    hr = hrOK;
    SPIEnumInterfaceInfo    spEnumIf;
    SPIInterfaceInfo        spIf;

    // If we don't have a router object, then we don't have any info, don't
    // try to expand.
    if (!m_spRouterInfo)
        return hrOK;

    // Windows NT Bug: 288427
    // This flag may also get set inside of the OnChange() call.
    // The OnChange() will enumerate and all interfaces.
    // They may have been added as the result of an OnChange()
    // because they were added before the OnExpand() was called.
    //
    // WARNING!  Be careful about adding anything to this function,
    //  since the m_bExpanded can be set in another function.
    // ----------------------------------------------------------------
    if (m_bExpanded)
    {
        return hrOK;
    }

    COM_PROTECT_TRY
    {
        CORg( m_spRouterInfo->EnumInterface(&spEnumIf) );

        while (spEnumIf->Next(1, &spIf, NULL) == hrOK)
        {
            AddInterfaceNode(pNode, spIf);
            spIf.Release();
        }

        m_bExpanded = TRUE;

        // Now that we have all of the nodes, update the data for
        // all of the nodes
        SynchronizeNodeData(pNode);

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH;

    return hr;
}


/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::OnResultShow
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IfAdminNodeHandler::OnResultShow(ITFSComponent *pTFSComponent,
                                         MMC_COOKIE cookie,
                                         LPARAM arg,
                                         LPARAM lParam)
{
    BOOL    bSelect = (BOOL) arg;
    HRESULT    hr = hrOK;
    SPIRouterRefresh    spRefresh;
    SPITFSNode    spNode;

    BaseContainerHandler::OnResultShow(pTFSComponent, cookie, arg, lParam);

    if (bSelect)
    {
        // Call synchronize on this node
        m_spNodeMgr->FindNode(cookie, &spNode);
        if (spNode)
            SynchronizeNodeData(spNode);
    }

    // Un/Register for refresh advises
    if (m_spRouterInfo)
        m_spRouterInfo->GetRefreshObject(&spRefresh);

    if (spRefresh)
    {
        if (bSelect)
        {
            if (m_ulRefreshConnId == 0)
                spRefresh->AdviseRefresh(&m_IRtrAdviseSink, &m_ulRefreshConnId, 0);
        }
        else
        {
            if (m_ulRefreshConnId)
                spRefresh->UnadviseRefresh(m_ulRefreshConnId);
            m_ulRefreshConnId = 0;
        }
    }
    
    return hr;
}

/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::ConstructNode
        Initializes the Domain node (sets it up).
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IfAdminNodeHandler::ConstructNode(ITFSNode *pNode)
{
    HRESULT            hr = hrOK;
    IfAdminNodeData *    pNodeData;
    
    if (pNode == NULL)
        return hrOK;

    COM_PROTECT_TRY
    {
        // Need to initialize the data for the Domain node
        pNode->SetData(TFS_DATA_IMAGEINDEX, IMAGE_IDX_INTERFACES);
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, IMAGE_IDX_INTERFACES);
        pNode->SetData(TFS_DATA_SCOPEID, 0);

        // This is a leaf node in the scope pane
        pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

        m_cookie = reinterpret_cast<LONG_PTR>(pNode);
        pNode->SetData(TFS_DATA_COOKIE, m_cookie);

        pNode->SetNodeType(&GUID_RouterIfAdminNodeType);
        
        IfAdminNodeData::InitAdminNodeData(pNode, m_pConfigStream);

        pNodeData = GET_IFADMINNODEDATA(pNode);
        Assert(pNodeData);

        // Copy over this data so that the Interface node can access
        // this and use this to configure its interface.
        pNodeData->m_hInstRasDlg = m_hInstRasDlg;
        pNodeData->m_pfnRouterEntryDlg = m_pfnRouterEntryDlg;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    IfAdminNodeHandler::OnAddInterface
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT IfAdminNodeHandler::OnAddInterface()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    HRESULT        hr = hrOK;
    CString        stPhoneBook;
    CString        stRouter;
    DWORD        dwErr = NO_ERROR;
    SPIConsole    spConsole;
    SPIInterfaceInfo    spIfInfo;
    
    BOOL        bStatus;
    MachineNodeData    *pData;
    SPITFSNode    spNode, spParent;
    DWORD        dwRouterType;
    CString        stServiceDesc;
    RouterVersionInfo    routerVersion;

    if (!EnableAddInterface())
    {
        AddHighLevelErrorStringId(IDS_ERR_TEMPNOADD);
        CORg( E_FAIL );
    }


    m_spNodeMgr->FindNode(m_cookie, &spNode);
    spNode->GetParent(&spParent);
    pData = GET_MACHINENODEDATA(spParent);

    // Get the router type,  if WAN routing is not-enabled
    // then we don't need to create demand-dial interfaces.
    // ----------------------------------------------------------------
    Assert(m_spRouterInfo);
    dwRouterType = m_spRouterInfo->GetRouterType();
    Trace1("Routertype is %d\n", dwRouterType);
    if ((dwRouterType & ROUTER_TYPE_WAN) == 0)
    {
        //
        //Show warning message box.  This is not an error anymore  
        //
        AfxMessageBox ( IDS_ERR_NEEDS_WAN, MB_OK|MB_ICONINFORMATION );
        hr = E_FAIL;
        return hr;
    /*
        AddHighLevelErrorStringId(IDS_ERR_NEEDS_WAN);
        CORg( E_FAIL );
    */
    }

    // Get the version info.  Needed later on.
    // ----------------------------------------------------------------
    m_spRouterInfo->GetRouterVersionInfo(&routerVersion);


    // Check to see if the router service is running, before
    // continuing on.
    // ----------------------------------------------------------------
    hr = IsRouterServiceRunning(m_spRouterInfo->GetMachineName(), NULL);
    if (hr == hrFalse)
    {
        // Ask the user if they want to start the service
        // ------------------------------------------------------------
        if (AfxMessageBox(IDS_PROMPT_SERVICESTART, MB_YESNO) != IDYES)
            CWRg( ERROR_CANCELLED );

        // Else start the service
        // ------------------------------------------------------------
        stServiceDesc.LoadString(IDS_RRAS_SERVICE_DESC);
        dwErr = TFSStartService(m_spRouterInfo->GetMachineName(), c_szRemoteAccess, stServiceDesc);
        if (dwErr != NO_ERROR)
        {
            AddHighLevelErrorStringId(IDS_ERR_IFASERVICESTOPPED);
            CWRg( dwErr );
        }

        //$todo: what to do about forcing a refresh through?
        // ForceGlobalRefresh();
    }

    
    // Now we need to check to see if there are any routing-enabled ports
    // (Here we can assume that rasman is running).  We can make this
    // check only for >= NT5, since this is when we got Rao's API.
    // ----------------------------------------------------------------
    if ((routerVersion.dwRouterVersion >= 5) &&
        !FLookForRoutingEnabledPorts(m_spRouterInfo->GetMachineName()))
    {
        AfxMessageBox(IDS_ERR_NO_ROUTING_ENABLED_PORTS);
        CWRg( ERROR_CANCELLED );
    }
    

    m_spTFSCompData->GetConsole(&spConsole);
    

    // First create the phone book entry.
    RASENTRYDLG info;
    HWND hwnd;
    ZeroMemory( &info, sizeof(info) );
    info.dwSize = sizeof(info);
    hwnd = NULL;
    
    spConsole->GetMainWindow(&hwnd);
    info.hwndOwner = hwnd;
    //info.hwndOwner = IFGetApp()->m_hWndHost;
    
    info.dwFlags |= RASEDFLAG_NewEntry;
    
    TRACE0("RouterEntryDlg\n");
    ASSERT(m_pfnRouterEntryDlg);

    stRouter = m_spRouterInfo->GetMachineName();
    GetPhoneBookPath(stRouter, &stPhoneBook);

    if (stRouter.GetLength() == 0)
    {
        stRouter = CString(_T("\\\\")) + GetLocalMachineName();
    }
    
    bStatus = m_pfnRouterEntryDlg(
        (LPTSTR)(LPCTSTR)stRouter, (LPTSTR)(LPCTSTR)stPhoneBook, NULL, &info);
    Trace2("RouterEntryDlg=%f,e=%d\n", bStatus, info.dwError);
    
    if (!bStatus)
    {
        if (info.dwError != NO_ERROR)
        {
            AddHighLevelErrorStringId(IDS_ERR_UNABLETOCONFIGPBK);
            CWRg( info.dwError );
        }
        CWRg( ERROR_CANCELLED );
    }
    //
    

    CORg( CreateInterfaceInfo(&spIfInfo,
                              info.szEntry,
                              ROUTER_IF_TYPE_FULL_ROUTER) );


    CORg( spIfInfo->SetTitle(spIfInfo->GetId()) );
    CORg( spIfInfo->SetMachineName(m_spRouterInfo->GetMachineName()) );

    CORg( m_spRouterInfo->AddInterface(spIfInfo) );

    // Ok, we've added the interfaces, we now need to add in
    // the appropriate defaults for the router managers

    if (info.reserved2 & RASNP_Ip)
    {
        CORg( AddRouterManagerToInterface(spIfInfo,
                                          m_spRouterInfo,
                                          PID_IP) );
    }

    if (info.reserved2 & RASNP_Ipx)
    {
        CORg( AddRouterManagerToInterface(spIfInfo,
                                          m_spRouterInfo,
                                          PID_IPX) );
        
    }

    
    HANDLE              hMachine = INVALID_HANDLE_VALUE;

    dwErr = ::MprConfigServerConnect((LPWSTR)m_spRouterInfo->GetMachineName(), &hMachine);

    if(dwErr != NOERROR || hMachine == INVALID_HANDLE_VALUE)
       goto Error;

    //
    //Add static routes here if any
    //
    SROUTEINFOLIST * pSRouteList = (SROUTEINFOLIST * )info.reserved;
    while ( pSRouteList )
    {
        MIB_IPFORWARDROW	route;
        SPIInfoBase			spInfoBase;
        SPIRtrMgrInterfaceInfo	spRmIf;
        InfoBlock *				pBlock;
        SROUTEINFOLIST * pTemp; 

        ZeroMemory(&route, sizeof(route) );
        route.dwForwardDest = INET_ADDR(pSRouteList->RouteInfo.pszDestIP);
        route.dwForwardMask = INET_ADDR(pSRouteList->RouteInfo.pszNetworkMask);
        route.dwForwardMetric1 = _ttol(pSRouteList->RouteInfo.pszMetric );
        route.dwForwardMetric5 = RTM_VIEW_MASK_UCAST | RTM_VIEW_MASK_MCAST;
        route.dwForwardNextHop = 0;


		if (routerVersion.dwRouterVersion < 5)
			route.dwForwardProto = PROTO_IP_LOCAL;
		else
			route.dwForwardProto = PROTO_IP_NT_STATIC;

        CORg( spIfInfo->FindRtrMgrInterface(PID_IP, &spRmIf) );


        CORg( spRmIf->GetInfoBase(  hMachine,
						            NULL,
						            NULL,
						            &spInfoBase));

        // Ok, go ahead and add the route
        
        // Get the IP_ROUTE_INFO block from the interface
        spInfoBase->GetBlock(IP_ROUTE_INFO, &pBlock, 0);

        CORg( AddStaticRoute(&route, spInfoBase, pBlock, 1) );

        // Update the interface information
        CORg( spRmIf->Save(m_spRouterInfo->GetMachineName(),
				           hMachine,
				           NULL,
				           NULL,
				           spInfoBase,
				           0));	

        //Free all the entry items
        pTemp = pSRouteList->pNext;
        GlobalFree(pSRouteList->RouteInfo.pszDestIP);
        GlobalFree(pSRouteList->RouteInfo.pszNetworkMask);
        GlobalFree(pSRouteList->RouteInfo.pszMetric);
        GlobalFree(pSRouteList);
        pSRouteList = pTemp;

    }
    
    // disconnect it
    if(hMachine != INVALID_HANDLE_VALUE)
    {
        ::MprAdminServerDisconnect(hMachine);        
    }
Error:
    if (!FHrSucceeded(hr) && (hr != HRESULT_FROM_WIN32(ERROR_CANCELLED)))
    {
        TCHAR    szErr[2048] = _T(" ");

        if (hr != E_FAIL)    // E_FAIL doesn't give user an