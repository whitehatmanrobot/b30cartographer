       {
    case ANGLE_DEG:
        if ( rat_gt( *pa, rat_180 ) )
            {
            PRAT ptmp=NULL;
            DUPRAT(ptmp,rat_360);
            subrat(&ptmp,*pa);
            destroyrat(*pa);
            *pa=ptmp;
            }
        divrat( pa, rat_180 );
        mulrat( pa, pi );
        break;
    case ANGLE_GRAD:
        if ( rat_gt( *pa, rat_200 ) )
            {
            PRAT ptmp=NULL;
            DUPRAT(ptmp,rat_400);
            subrat(&ptmp,*pa);
            destroyrat(*pa);
            *pa=ptmp;
            }
        divrat( pa, rat_200 );
        mulrat( pa, pi );
        break;
        }
    _cosrat( pa );
}

//-----------------------------------------------------------------------------
//
//  FUNCTION: tanrat, _tanrat
//
//  ARGUMENTS:  x PRAT representation of number to take the tangent of
//
//  RETURN: tan     of x in PRAT form.
//
//  EXPLANATION: This uses sinrat and cosrat
//
//-----------------------------------------------------------------------------


void _tanrat( PRAT *px )

{
    PRAT ptmp=NULL;

    DUPRAT(ptmp,*px);
    _sinrat(px);
    _cosrat(&ptmp);
    if ( zerrat( ptmp ) )
        {
    	destroyrat(ptmp);
        throw( CALC_E_DOMAIN );
        }
    divrat(px,ptmp);

    destroyrat(ptmp);

}

void tanrat( PRAT *px )
{
    scale2pi(px); 
    _tanrat(px); 
}

void tananglerat( IN OUT PRAT *pa, IN ANGLE_TYPE angletype )

{
    scalerat( pa, angletype );
    switch ( angletype )
        {
    case ANGLE_DEG:
        if ( rat_gt( *pa, rat_180 ) )
            {
            subrat(pa,rat_180);
            }
        divrat( pa, rat_180 );
        mulrat( pa, pi );
        break;
    case ANGLE_GRAD:
        if ( rat_gt( *pa, rat_200 ) )
            {
            subrat(pa,rat_200);
            }
        divrat( pa, rat_200 );
        mulrat( pa, pi );
        break;
        }
    _tanrat( pa );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\ratpak\support.c ===
//----------------------------------------------------------------------------
//  Package Title  ratpak
//  File           support.c
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-96 Microsoft
//  Date           10-21-96
//
//
//  Description
//
//     Contains support functions for rationals and numbers.
//
//  Special Information
//
//
//
//----------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <ratpak.h>



BOOL fhalt;

LINKEDLIST gllfact;

void _readconstants( void );

#if defined( GEN_CONST )
void _dumprawrat( TCHAR *varname, PRAT rat );
void _dumprawnum( PNUMBER num );

static cbitsofprecision = 0;
#define READRAWRAT(v)
#define READRAWNUM(v)
#define DUMPRAWRAT(v) _dumprawrat(#v,v)
#define DUMPRAWNUM(v) fprintf( stderr, \
"// Autogenerated by _dumprawrat in support.c\n" ); \
    fprintf( stderr, "NUMBER init_" #v "= {\n" ); \
    _dumprawnum(v); \
    fprintf( stderr, "};\n" )


#else

#define DUMPRAWRAT(v)
#define DUMPRAWNUM(v)
#define READRAWRAT(v) createrat(v); DUPNUM(v->pp,(&(init_p_##v))); \
DUPNUM(v->pq,(&(init_q_##v)));
#define READRAWNUM(v) DUPNUM(v,(&(init_##v)))

#define RATIO_FOR_DECIMAL 9
#define DECIMAL 10
#define CALC_DECIMAL_DIGITS_DEFAULT 32

static cbitsofprecision = RATIO_FOR_DECIMAL * DECIMAL * 
                            CALC_DECIMAL_DIGITS_DEFAULT;

#include <ratconst.h>

#endif

unsigned char ftrueinfinite = FALSE;    // Set to true if you don't want 
                                        // chopping internally
long maxout;                            // precision used internally

PNUMBER num_one=NULL;
PNUMBER num_two=NULL;
PNUMBER num_five=NULL;
PNUMBER num_six=NULL;
PNUMBER num_ten=NULL;
PNUMBER num_nRadix=NULL;


PRAT ln_ten=NULL;
PRAT ln_two=NULL;
PRAT rat_zero=NULL;
PRAT rat_one=NULL;
PRAT rat_neg_one=NULL;
PRAT rat_two=NULL;
PRAT rat_six=NULL;
PRAT rat_half=NULL;
PRAT rat_ten=NULL;
PRAT pt_eight_five=NULL;
PRAT pi=NULL;
PRAT pi_over_two=NULL;
PRAT two_pi=NULL;
PRAT one_pt_five_pi=NULL;
PRAT e_to_one_half=NULL;
PRAT rat_exp=NULL;
PRAT rad_to_deg=NULL;
PRAT rad_to_grad=NULL;
PRAT rat_qword=NULL;
PRAT rat_dword=NULL;
PRAT rat_word=NULL;
PRAT rat_byte=NULL;
PRAT rat_360=NULL;
PRAT rat_400=NULL;
PRAT rat_180=NULL;
PRAT rat_200=NULL;
PRAT rat_nRadix=NULL;
PRAT rat_smallest=NULL;
PRAT rat_negsmallest=NULL;
PRAT rat_max_exp=NULL;
PRAT rat_min_exp=NULL;
PRAT rat_min_long=NULL;


//----------------------------------------------------------------------------
//
//  FUNCTION: ChangeRadix
//
//  ARGUMENTS:  base changing to, and precision to use.
//
//  RETURN: None
//
//  SIDE EFFECTS: sets a mess of constants.
//
//
//----------------------------------------------------------------------------

void changeRadix( long nRadix )

{
    ChangeConstants( nRadix, maxout );
}


//----------------------------------------------------------------------------
//
//  FUNCTION: changePrecision
//
//  ARGUMENTS:  Precision to use
//
//  RETURN: None
//
//  SIDE EFFECTS: sets a mess of constants.
//
//
//----------------------------------------------------------------------------

void changePrecision( long nPrecision )

{
    ChangeConstants( nRadix, nPrecision );
}

//----------------------------------------------------------------------------
//
//  FUNCTION: ChangeConstants
//
//  ARGUMENTS:  base changing to, and precision to use.
//
//  RETURN: None
//
//  SIDE EFFECTS: sets a mess of constants.
//
//
//----------------------------------------------------------------------------

void ChangeConstants( long nRadix, long nPrecision )

{
    long digit;
    DWORD dwLim;

    maxout = nPrecision;          
    fhalt = FALSE;
    
    
    // ratio is set to the number of digits in the current nRadix, you can get 
    // in the internal BASEX nRadix, this is important for length calculations 
    // in translating from nRadix to BASEX and back.                           

    dwLim = (DWORD)BASEX / (DWORD)nRadix;

    for ( digit = 1, ratio = 0; (DWORD)digit < dwLim; digit *= nRadix )
        {
        ratio++;
        }
    ratio += !ratio;

    destroynum(num_nRadix);
    num_nRadix=longtonum( nRadix, BASEX );
   
    destroyrat(rat_nRadix);
    rat_nRadix=longtorat( nRadix );
    
    // Check to see what we have to recalculate and what we don't
    if ( cbitsofprecision < ( ratio * nRadix * nPrecision ) )
        {
        ftrueinfinite=FALSE;
        num_one=longtonum( 1L, BASEX );
        DUMPRAWNUM(num_one);
        num_two=longtonum( 2L, BASEX );
        DUMPRAWNUM(num_two);
        num_five=longtonum( 5L, BASEX );
        DUMPRAWNUM(num_five);
        num_six=longtonum( 6L, BASEX );
        DUMPRAWNUM(num_six);
        num_ten=longtonum( 10L, BASEX );
        DUMPRAWNUM(num_ten);

        DUPRAT(rat_smallest,rat_nRadix);
        ratpowlong(&rat_smallest,-nPrecision);
        DUPRAT(rat_negsmallest,rat_smallest);
        rat_negsmallest->pp->sign = -1;
        DUMPRAWRAT(rat_smallest);
        DUMPRAWRAT(rat_negsmallest);
        createrat( rat_half );

        createrat( pt_eight_five );

        pt_eight_five->pp=longtonum( 85L, BASEX );
        pt_eight_five->pq=longtonum( 100L, BASEX );
        DUMPRAWRAT(pt_eight_five);

        rat_six = longtorat( 6L );
        DUMPRAWRAT(rat_six);

        rat_two=longtorat( 2L );
        DUMPRAWRAT(rat_two);

        rat_zero=longtorat( 0L );
        DUMPRAWRAT(rat_zero);

        rat_one=longtorat( 1L );
        DUMPRAWRAT(rat_one);

        rat_neg_one=longtorat( -1L );
        DUMPRAWRAT(rat_neg_one);

        DUPNUM(rat_half->pp,num_one);
        DUPNUM(rat_half->pq,num_two);
        DUMPRAWRAT(rat_half);

        rat_ten=longtorat( 10L );
        DUMPRAWRAT(rat_ten);
        
        // Apparently when dividing 180 by pi, another (internal) digit of 
        // precision is needed.
        maxout += ratio;
        DUPRAT(pi,rat_half);
        asinrat( &pi );
        mulrat( &pi, rat_six );
        DUMPRAWRAT(pi);
    
        DUPRAT(two_pi,pi);
        DUPRAT(pi_over_two,pi);
        DUPRAT(one_pt_five_pi,pi);
        addrat(&two_pi,pi);
        DUMPRAWRAT(two_pi);
    
        divrat(&pi_over_two,rat_two);
        DUMPRAWRAT(pi_over_two);
    
        addrat(&one_pt_five_pi,pi_over_two);
        DUMPRAWRAT(one_pt_five_pi);
    
        DUPRAT(e_to_one_half,rat_half);
        _exprat(&e_to_one_half);
        DUMPRAWRAT(e_to_one_half);

        DUPRAT(rat_exp,rat_one);
        _exprat(&rat_exp);
        DUMPRAWRAT(rat_exp);
        
        // WARNING: remember lograt uses exponent constants calculated above...

        DUPRAT(ln_ten,rat_ten);
        lograt( &ln_ten );
        DUMPRAWRAT(ln_ten);

        DUPRAT(ln_two,rat_two);
        lograt(&ln_two);
        DUMPRAWRAT(ln_two);
    
    
        destroyrat(rad_to_deg);
        rad_to_deg=longtorat(180L);
        divrat(&rad_to_deg,pi);
        DUMPRAWRAT(rad_to_deg);
    
        destroyrat(rad_to_grad);
        rad_to_grad=longtorat(200L);
        divrat(&rad_to_grad,pi);
        DUMPRAWRAT(rad_to_grad);
        maxout -= ratio;

        DUPRAT(rat_qword,rat_two);
        numpowlong( &(rat_qword->pp), 64, BASEX );
        subrat( &rat_qword, rat_one );
        DUMPRAWRAT(rat_qword);

        DUPRAT(rat_dword,rat_two);
        numpowlong( &(rat_dword->pp), 32, BASEX );
        subrat( &rat_dword, rat_one );
        DUMPRAWRAT(rat_dword);
        DUPRAT(rat_min_long,rat_dword);
        rat_min_long->pp->sign *= -1;
        DUMPRAWRAT(rat_min_long);

        rat_word = longtorat( 0xffff );
        DUMPRAWRAT(rat_word);
        rat_byte = longtorat( 0xff );
        DUMPRAWRAT(rat_byte);

        rat_400 = longtorat( 400 );
        DUMPRAWRAT(rat_400);

        rat_360 = longtorat( 360 );
        DUMPRAWRAT(rat_360);

        rat_200 = longtorat( 200 );
        DUMPRAWRAT(rat_200);

        rat_180 = longtorat( 180 );
        DUMPRAWRAT(rat_180);

        rat_max_exp = longtorat( 100000 );
        DUPRAT(rat_min_exp,rat_max_exp);
        rat_min_exp->pp->sign *= -1;
        DUMPRAWRAT(rat_max_exp);
        DUMPRAWRAT(rat_min_exp);

        cbitsofprecision = ratio * nRadix * nPrecision;
        }
    else
        {
        _readconstants();

        DUPRAT(rat_smallest,rat_nRadix);
        ratpowlong(&rat_smallest,-nPrecision);
        DUPRAT(rat_negsmallest,rat_smallest);
        rat_negsmallest->pp->sign = -1;
        }

}

//----------------------------------------------------------------------------
//
//  FUNCTION: intrat
//
//  ARGUMENTS:  pointer to x PRAT representation of number
//
//  RETURN: no return value x PRAT is smashed with integral number
//
//
//----------------------------------------------------------------------------

void intrat( PRAT *px)

{
    PRAT pret=NULL;
    PNUMBER pnum=NULL;
    TCHAR *psz;
    // Only do the intrat operation if number is nonzero.
    // and only if the bottom part is not one.
    if ( !zernum( (*px)->pp ) && !equnum( (*px)->pq, num_one ) )
        {
        psz=putrat( NULL, px, nRadix, FMT_FLOAT );
        pnum = innum( psz );
        zfree( psz );

        destroyrat( *px );
        *px = numtorat( pnum, nRadix );
        destroynum( pnum );

        DUPRAT(pret,*px);
        modrat( &pret, rat_one );
        
        subrat( px, pret );
        destroyrat( pret );
        }
}

//---------------------------------------------------------------------------
//
//  FUNCTION: rat_equ
//
//  ARGUMENTS:  PRAT a and PRAT b
//
//  RETURN: TRUE if equal FALSE otherwise.
//
//
//---------------------------------------------------------------------------

BOOL rat_equ( PRAT a, PRAT b )

{
    PRAT rattmp=NULL;
    BOOL bret;
    DUPRAT(rattmp,a);
    rattmp->pp->sign *= -1;
    addrat( &rattmp, b );
    bret = zernum( rattmp->pp );
    destroyrat( rattmp );
    return( bret );
}

//---------------------------------------------------------------------------
//
//  FUNCTION: rat_ge
//
//  ARGUMENTS:  PRAT a and PRAT b
//
//  RETURN: TRUE if a is greater than or equal to b
//
//
//---------------------------------------------------------------------------

BOOL rat_ge( PRAT a, PRAT b )

{
    PRAT rattmp=NULL;
    BOOL bret;
    DUPRAT(rattmp,a);
    b->pp->sign *= -1;
    addrat( &rattmp, b );
    b->pp->sign *= -1;
    bret = ( zernum( rattmp->pp ) || 
        rattmp->pp->sign * rattmp->pq->sign == 1 );
    destroyrat( rattmp );
    return( bret );
}


//---------------------------------------------------------------------------
//
//  FUNCTION: rat_gt
//
//  ARGUMENTS:  PRAT a and PRAT b
//
//  RETURN: TRUE if a is greater than b
//
//
//---------------------------------------------------------------------------

BOOL rat_gt( PRAT a, PRAT b )

{
    PRAT rattmp=NULL;
    BOOL bret;
    DUPRAT(rattmp,a);
    b->pp->sign *= -1;
    addrat( &rattmp, b );
    b->pp->sign *= -1;
    bret = ( !zernum( rattmp->pp ) && 
        rattmp->pp->sign * rattmp->pq->sign == 1 );
    destroyrat( rattmp );
    return( bret );
}

//---------------------------------------------------------------------------
//
//  FUNCTION: rat_le
//
//  ARGUMENTS:  PRAT a and PRAT b
//
//  RETURN: TRUE if a is less than or equal to b
//
//
//---------------------------------------------------------------------------

BOOL rat_le( PRAT a, PRAT b )

{

    PRAT rattmp=NULL;
    BOOL bret;
    DUPRAT(rattmp,a);
    b->pp->sign *= -1;
    addrat( &rattmp, b );
    b->pp->sign *= -1;
    bret = ( zernum( rattmp->pp ) || 
        rattmp->pp->sign * rattmp->pq->sign == -1 );
    destroyrat( rattmp );
    return( bret );
}


//---------------------------------------------------------------------------
//
//  FUNCTION: rat_lt
//
//  ARGUMENTS:  PRAT a and PRAT b
//
//  RETURN: TRUE if a is less than b
//
//
//---------------------------------------------------------------------------

BOOL rat_lt( PRAT a, PRAT b )

{
    PRAT rattmp=NULL;
    BOOL bret;
    DUPRAT(rattmp,a);
    b->pp->sign *= -1;
    addrat( &rattmp, b );
    b->pp->sign *= -1;
    bret = ( !zernum( rattmp->pp ) && 
        rattmp->pp->sign * rattmp->pq->sign == -1 );
    destroyrat( rattmp );
    return( bret );
}


//---------------------------------------------------------------------------
//
//  FUNCTION: rat_neq
//
//  ARGUMENTS:  PRAT a and PRAT b
//
//  RETURN: TRUE if a is not equal to b
//
//
//---------------------------------------------------------------------------


BOOL rat_neq( PRAT a, PRAT b )

{
    PRAT rattmp=NULL;
    BOOL bret;
    DUPRAT(rattmp,a);
    rattmp->pp->sign *= -1;
    addrat( &rattmp, b );
    bret = !( zernum( rattmp->pp ) );
    destroyrat( rattmp );
    return( bret );
}

//---------------------------------------------------------------------------
//
//  function: scale
//
//  ARGUMENTS:  pointer to x PRAT representation of number, and scaling factor
//
//  RETURN: no return, value x PRAT is smashed with a scaled number in the
//          range of the scalefact.
//
//---------------------------------------------------------------------------

void scale( PRAT *px, PRAT scalefact )

{
    long logscale;
    PRAT pret=NULL;
    DUPRAT(pret,*px);
    
    // Logscale is a quick way to tell how much extra precision is needed for 
    // scaleing by scalefact.
    logscale = ratio * ( (pret->pp->cdigit+pret->pp->exp) - 
            (pret->pq->cdigit+pret->pq->exp) );
    if ( logscale > 0 )
        {
        maxout += logscale;
        }
    else
        {
        logscale = 0;
        }

    divrat( &pret, scalefact);
    intrat(&pret);
    mulrat( &pret, scalefact);
    pret->pp->sign *= -1;
    addrat( px, pret);

    maxout -= logscale;
    destroyrat( pret );
}

//---------------------------------------------------------------------------
//
//  function: scale2pi
//
//  ARGUMENTS:  pointer to x PRAT representation of number
//
//  RETURN: no return, value x PRAT is smashed with a scaled number in the
//          range of 0..2pi
//
//---------------------------------------------------------------------------

void scale2pi( PRAT *px )

{
    long logscale;
    PRAT pret=NULL;
    PRAT my_two_pi=NULL;
    DUPRAT(pret,*px);
    
    // Logscale is a quick way to tell how much extra precision is needed for 
    // scaleing by 2 pi.
    logscale = ratio * ( (pret->pp->cdigit+pret->pp->exp) - 
            (pret->pq->cdigit+pret->pq->exp) );
    if ( logscale > 0 )
        {
        maxout += logscale;
        DUPRAT(my_two_pi,rat_half);
        asinrat( &my_two_pi );
        mulrat( &my_two_pi, rat_six );
        mulrat( &my_two_pi, rat_two );
        }
    else
        {
        DUPRAT(my_two_pi,two_pi);
        logscale = 0;
        }

    divrat( &pret, my_two_pi);
    intrat(&pret);
    mulrat( &pret, my_two_pi);
    pret->pp->sign *= -1;
    addrat( px, pret);

    maxout -= logscale;
    destroyrat( my_two_pi );
    destroyrat( pret );
}

//---------------------------------------------------------------------------
//
//  FUNCTION: inbetween
//
//  ARGUMENTS:  PRAT *px, and PRAT range.
//
//  RETURN: none, changes *px to -/+range, if px is outside -range..+range
//
//---------------------------------------------------------------------------

void inbetween( PRAT *px, PRAT range )

{
    if ( rat_gt(*px,range) )
        {
        DUPRAT(*px,range);
        }
    else
        {
        range->pp->sign *= -1;
        if ( rat_lt(*px,range) )
            {
            DUPRAT(*px,range);
            }
        range->pp->sign *= -1;
        }
}

#if defined( GEN_CONST )

//---------------------------------------------------------------------------
//
//  FUNCTION: _dumprawrat
//
//  ARGUMENTS:  char *name of variable, PRAT x
//
//  RETURN: none, prints the results of a dump of the internal structures
//          of a PRAT, suitable for READRAWRAT to stderr.
//
//---------------------------------------------------------------------------

void _dumprawrat( TCHAR *varname, PRAT rat )

{
    fprintf( stderr, "// Autogenerated by _dumprawrat in support.c\n" );
    fprintf( stderr, "NUMBER init_p_%s = {\n", varname );
    _dumprawnum( rat->pp );
    fprintf( stderr, "};\n" );
    fprintf( stderr, "NUMBER init_q_%s = {\n", varname );
    _dumprawnum( rat->pq );
    fprintf( stderr, "};\n" );
}

//---------------------------------------------------------------------------
//
//  FUNCTION: _dumprawnum
//
//  ARGUMENTS:  PNUMBER num
//
//  RETURN: none, prints the results of a dump of the internal structures
//          of a PNUMBER, suitable for READRAWNUM to stderr.
//
//---------------------------------------------------------------------------

void _dumprawnum( PNUMBER num )

{
    int i;

    fprintf( stderr, "\t%d,\n", num->sign );
    fprintf( stderr, "\t%d,\n", num->cdigit );
    fprintf( stderr, "\t%d,\n", num->exp );
    fprintf( stderr, "\t{ " );

    for ( i = 0; i < num->cdigit; i++ )
        {
        fprintf( stderr, " %d,", num->mant[i] );
        }
    fprintf( stderr, "}\n" );
}
#endif
void _readconstants( void )

{
    READRAWNUM(num_one);
    READRAWNUM(num_two);
    READRAWNUM(num_five);
    READRAWNUM(num_six);
    READRAWNUM(num_ten);
    READRAWRAT(pt_eight_five);
    READRAWRAT(rat_six);
    READRAWRAT(rat_two);
    READRAWRAT(rat_zero);
    READRAWRAT(rat_one);
    READRAWRAT(rat_neg_one);
    READRAWRAT(rat_half);
    READRAWRAT(rat_ten);
    READRAWRAT(pi);
    READRAWRAT(two_pi);
    READRAWRAT(pi_over_two);
    READRAWRAT(one_pt_five_pi);
    READRAWRAT(e_to_one_half);
    READRAWRAT(rat_exp);
    READRAWRAT(ln_ten);
    READRAWRAT(ln_two);
    READRAWRAT(rad_to_deg);
    READRAWRAT(rad_to_grad);
    READRAWRAT(rat_qword);
    READRAWRAT(rat_dword);
    READRAWRAT(rat_word);
    READRAWRAT(rat_byte);
    READRAWRAT(rat_360);
    READRAWRAT(rat_400);
    READRAWRAT(rat_180);
    READRAWRAT(rat_200);
    READRAWRAT(rat_smallest);
    READRAWRAT(rat_negsmallest);
    READRAWRAT(rat_max_exp);
    READRAWRAT(rat_min_exp);
    READRAWRAT(rat_min_long);
    DUPNUM(gllfact.pnum,num_one);
    gllfact.llprev = NULL;
    gllfact.llnext = NULL;
}

void factnum( IN OUT PLINKEDLIST *ppllfact, PNUMBER pnum )

{
    PNUMBER thisnum=NULL;
    PLINKEDLIST pllfact = *ppllfact;

    if ( pllfact->llnext == NULL ) 
        {
        // This factorial hasn't happened yet, lets compute it.
        DUPNUM(thisnum,pllfact->pnum);
        mulnumx(&thisnum,pnum);
        pllfact->llnext = (PLINKEDLIST)zmalloc( sizeof( LINKEDLIST ) );
        if (pllfact->llnext)
            {
            pllfact->llnext->pnum = thisnum;
            pllfact->llnext->llprev = pllfact;
            pllfact->llnext->llnext = NULL;
            }
        }
    *ppllfact = pllfact->llnext;
}


//---------------------------------------------------------------------------
//
//  FUNCTION: trimit
//
//  ARGUMENTS:  PRAT *px
//
//
//  DESCRIPTION: Chops off digits from rational numbers to avoid time 
//  explosions in calculations of functions using series.  
//  Gregory Stepanets proved it was enough to only keep the first n digits 
//  of the largest of p or q in the rational p over q form, and of course 
//  scale the smaller by the same number of digits.  This will give you 
//  n-1 digits of accuracy.  This dramatically speeds up calculations 
//  involving hundreds of digits or more.
//  The last part of this trim dealing with exponents never affects accuracy
//
//  RETURN: none, modifies the pointed to PRAT 
//
//---------------------------------------------------------------------------

void trimit( PRAT *px ) 

{
    if ( !ftrueinfinite )
        { 
        long trim;
        PNUMBER pp=(*px)->pp;
        PNUMBER pq=(*px)->pq;
        trim = ratio * (min((pp->cdigit+pp->exp),(pq->cdigit+pq->exp))-1) - maxout;
        if ( trim > ratio )
            {
            trim /= ratio;

            if ( trim <= pp->exp )
                {
                pp->exp -= trim;
                }
            else
                {
                memmove( MANT(pp), &(MANT(pp)[trim-pp->exp]), sizeof(MANTTYPE)*(pp->cdigit-trim+pp->exp) );
                pp->cdigit -= trim-pp->exp;
                pp->exp = 0;
                }

            if ( trim <= pq->exp )
                {
                pq->exp -= trim;
                }
            else
                {
                memmove( MANT(pq), &(MANT(pq)[trim-pq->exp]), sizeof(MANTTYPE)*(pq->cdigit-trim+pq->exp) );
                pq->cdigit -= trim-pq->exp;
                pq->exp = 0;
                }
            }
        trim = min(pp->exp,pq->exp);
        pp->exp -= trim;
        pq->exp -= trim;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\inc\uceshare.h ===
/*++

Copyright (c) 2000-2001,  Microsoft Corporation  All rights reserved.

Module Name:

    uceshare.h

Abstract:

    This file defines the header information used by both the
    getuname (getuname.dll) and uce (charmap.exe) directories.

Revision History:

    27-Nov-2000    JulieB      Created

--*/



#ifndef UCESHARE_H
#define UCESHARE_H

#ifdef __cplusplus
extern "C" {
#endif




//
//  External Functions.
//

int APIENTRY
GetUName(
    WCHAR wcCodeValue,
    LPWSTR lpBuffer);



#ifdef __cplusplus
}
#endif

#endif // UCESHARE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\getuname\getuname.c ===
/*++

Copyright (c) 1997-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    getuname.c

Abstract:

    The CharMap accessory uses this DLL to obtain the Unicode name
    associated with each 16-bit code value.  The names are Win32 string
    resources and are localized for some languages.  The precomposed
    Korean syllables (Hangul) get special treatment to reduce the size
    of the string table.

    The module contains two external entry points:
        GetUName - Called by CharMap to get a name
        DLLMain  - Invoked by the system when the DLL is loaded and unloaded.


    BUGBUGS:
    (1) This module does not support UTF-16 (Unicode surrogate) names.
        To fix this would require changes to CharMap to pass pairs of code
        values.

    (2) The HangulName code assumes that the name parts are in the same order
        as in English instead of:
          "HANGUL SYLLABLE"+leading consonant+medial vowel+trailing consonant
        This is a localization sin since it does not work for all languages.

Revision History:

    15-Sep-2000    JohnMcCo    Added support for Unicode 3.0
    17-Oct-2000    JulieB      Code cleanup

--*/



//
//  Include Files.
//

#include <windows.h>
#include <uceshare.h>
#include "getuname.h"




//
//  Global Variables.
//

static HINSTANCE g_hInstance = NULL;





////////////////////////////////////////////////////////////////////////////
//
//  CopyUName
//
//  Copies the Unicode name of a code value into the buffer.
//
////////////////////////////////////////////////////////////////////////////

static int CopyUName(
    WCHAR wcCodeValue,                 // Unicode code value
    LPWSTR lpBuffer)                   // pointer to the caller's buffer
{
    //
    //  Attempt to load the string resource with the ID equal to the code
    //  value.
    //
    int nLen = LoadString(g_hInstance, wcCodeValue, lpBuffer, MAX_NAME_LEN);

    //
    //  If no such string, return the undefined code value string.
    //
    if (nLen == 0)
    {
        nLen = LoadString(g_hInstance, IDS_UNDEFINED, lpBuffer, MAX_NAME_LEN);
    }

    //
    //  Return the length of the string copied to the buffer.
    //
    return (nLen);
}


////////////////////////////////////////////////////////////////////////////
//
//  MakeHangulName
//
//  Copy the Unicode name of the Hangul syllable code value into the buffer.
//  The Hangul syllable names are composed from the code value.  Each name
//  consists of three parts:
//      leading consonant
//      medial vowel
//      trailing consonant (which may be null)
//  The algorithm is explained in Unicode 3.0 Chapter 3.11
//  "Conjoining Jamo Behavior".
//
////////////////////////////////////////////////////////////////////////////

static int MakeHangulName(
    WCHAR wcCodeValue,                 // Unicode code value
    LPWSTR lpBuffer)                   // pointer to the caller's buffer
{
    const int nVowels = 21;            // number of medial vowel jamos
    const int nTrailing = 28;          // number of trailing consonant jamos

    //
    //  Copy the constant part of the name into the buffer.
    //
    int nLen = LoadString( g_hInstance,
                           IDS_HANGUL_SYLLABLE,
                           lpBuffer,
                           MAX_NAME_LEN );

    //
    //  Turn the code value into an index into the Hangul syllable block.
    //
    wcCodeValue -= FIRST_HANGUL;

    //
    //  Append the name of the leading consonant.
    //
    nLen += LoadString( g_hInstance,
                        IDS_HANGUL_LEADING + wcCodeValue / (nVowels * nTrailing),
                        &lpBuffer[nLen],
                        MAX_NAME_LEN );
    wcCodeValue %= (nVowels * nTrailing);

    //
    //  Append the name of the medial vowel.
    //
    nLen += LoadString( g_hInstance,
                        IDS_HANGUL_MEDIAL + wcCodeValue / nTrailing,
                        &lpBuffer[nLen],
                        MAX_NAME_LEN );
    wcCodeValue %= nTrailing;

    //
    //  Append the name of the trailing consonant.
    //
    nLen += LoadString( g_hInstance,
                        IDS_HANGUL_TRAILING + wcCodeValue,
                        &lpBuffer[nLen],
                        MAX_NAME_LEN );

    //
    //  Return the total length.
    //
    return (nLen);
}


////////////////////////////////////////////////////////////////////////////
//
//  DllMain
//
//  This is the DLL init routine.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI DllMain(
    HINSTANCE hInstance,               // handle of this DLL
    DWORD fdwReason,                   // reason we are here
    LPVOID lpReserved)                 // reserved and unused
{
    //
    //  If the DLL has just been loaded into memory, save the instance
    //  handle.
    //
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hInstance;
    }

    return (TRUE);

    UNREFERENCED_PARAMETER(lpReserved);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetUName
//
//  Copies the name of the Unicode character code value into the caller's
//  buffer.  The function value is the length of the name if it was found
//  and zero if not.
//
////////////////////////////////////////////////////////////////////////////

int APIENTRY GetUName(
    WCHAR wcCodeValue,                 // Unicode code value
    LPWSTR lpBuffer)                   // pointer to the caller's buffer
{
    //
    //  Perform a series of comparisons to determine in which range the code
    //  value lies.  If there were more ranges, it would be efficient to use
    //  a binary search.  However, with just a few ranges, the overhead is
    //  greater than the savings, especially since the first comparison
    //  usually succeeds.
    //

    //
    //  MOST SCRIPTS.
    //
    if (wcCodeValue < FIRST_EXTENSION_A)
    {
        return (CopyUName(wcCodeValue, lpBuffer));
    }

    //
    //  CJK EXTENSION A.
    //
    else if (wcCodeValue <= LAST_EXTENSION_A)
    {
         return (LoadString(g_hInstance, IDS_CJK_EXTA, lpBuffer, MAX_NAME_LEN));
    }

    //
    //  UNDEFINED.
    //
    else if (wcCodeValue < FIRST_CJK)
    {
        return (LoadString(g_hInstance, IDS_UNDEFINED, lpBuffer, MAX_NAME_LEN));
    }

    //
    //  CJK.
    //
    else if (wcCodeValue <= LAST_CJK)
    {
        return (LoadString(g_hInstance, IDS_CJK, lpBuffer, MAX_NAME_LEN));
    }

    //
    //  UNDEFINED.
    //
    else if (wcCodeValue < FIRST_YI)
    {
        return (LoadString(g_hInstance, IDS_UNDEFINED, lpBuffer, MAX_NAME_LEN));
    }

    //
    //  YI.
    //
    else if (wcCodeValue < FIRST_HANGUL)
    {
        return (CopyUName(wcCodeValue, lpBuffer));
    }

    //
    //  HANGUL SYLLABLE.
    //
    else if (wcCodeValue <= LAST_HANGUL)
    {
        return (MakeHangulName(wcCodeValue, lpBuffer));
    }

    //
    //  UNDEFINED.
    //
    else if (wcCodeValue < FIRST_HIGH_SURROGATE)
    {
        return (LoadString(g_hInstance, IDS_UNDEFINED, lpBuffer, MAX_NAME_LEN));
    }

    //
    //  NON PRIVATE USE HIGH SURROGATE.
    //
    else if (wcCodeValue < FIRST_PRIVATE_SURROGATE)
    {
        return (LoadString(g_hInstance, IDS_HIGH_SURROGATE, lpBuffer, MAX_NAME_LEN));
    }

    //
    //  PRIVATE USE HIGH SURROGATE.
    //
    else if (wcCodeValue < FIRST_LOW_SURROGATE)
    {
        return (LoadString(g_hInstance, IDS_PRIVATE_SURROGATE, lpBuffer, MAX_NAME_LEN));
    }

    //
    //  LOW SURROGATE.
    //
    else if (wcCodeValue < FIRST_PRIVATE_USE)
    {
        return (LoadString(g_hInstance, IDS_LOW_SURROGATE, lpBuffer, MAX_NAME_LEN));
    }

    //
    //  PRIVATE USE.
    //
    else if (wcCodeValue < FIRST_COMPATIBILITY)
    {
        return (LoadString(g_hInstance, IDS_PRIVATE_USE, lpBuffer, MAX_NAME_LEN));
    }

    //
    //  COMPATIBILITY REGION.
    //
    else
    {
        return (CopyUName(wcCodeValue, lpBuffer));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\getuname\getuname.h ===
/*++

Copyright (c) 1997-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    getuname.h

Abstract:

    This file defines the string resource identifiers used by GetUName.dll.

Revision History:

    15-Sep-2000    JohnMcCo    Added support for Unicode 3.0
    17-Oct-2000    JulieB      Code cleanup

--*/



#ifndef GETUNAME_H
#define GETUNAME_H

#ifdef __cplusplus
extern "C" {
#endif




//
//  Constant Declarations.
//

//
//  Mnemonic for the longest possible name.
//  Must be as long as the longest (possibly localized) name.
//
#define MAX_NAME_LEN 256

//
//  Mnenonics for important code values in each range.
//
#define FIRST_EXTENSION_A         0x3400
#define LAST_EXTENSION_A          0x4db5
#define FIRST_CJK                 0x4e00
#define LAST_CJK                  0x9fa5
#define FIRST_YI                  0xa000
#define FIRST_HANGUL              0xac00
#define LAST_HANGUL               0xd7a3
#define FIRST_HIGH_SURROGATE      0xd800
#define FIRST_PRIVATE_SURROGATE   0xdb80
#define FIRST_LOW_SURROGATE       0xdc00
#define FIRST_PRIVATE_USE         0xe000
#define FIRST_COMPATIBILITY       0xf900

//
//  Mnemonics for the range name string ids.
//
#define IDS_UNAME                 0x0000
#define IDS_CJK_EXTA              FIRST_EXTENSION_A
#define IDS_CJK                   FIRST_CJK
#define IDS_HIGH_SURROGATE        FIRST_HIGH_SURROGATE
#define IDS_PRIVATE_SURROGATE     FIRST_PRIVATE_SURROGATE
#define IDS_LOW_SURROGATE         FIRST_LOW_SURROGATE
#define IDS_PRIVATE_USE           FIRST_PRIVATE_USE
#define IDS_UNDEFINED             0xFFFE                 // guaranteed to be not a character

//
//  Mnemonics for the Hangul syllable parts string ids.
//  Use the Hangul syllable range since we know that is unused.
//
#define IDS_HANGUL_SYLLABLE       FIRST_HANGUL
#define IDS_HANGUL_LEADING        (FIRST_HANGUL + 1)
#define IDS_HANGUL_MEDIAL         (FIRST_HANGUL + 0x100)
#define IDS_HANGUL_TRAILING       (FIRST_HANGUL + 0x200)



#ifdef __cplusplus
}
#endif

#endif // GETUNAME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\ratpak\transh.c ===
//-----------------------------------------------------------------------------
//  Package Title  ratpak
//  File           transh.c
//  Author         Timothy David Corrie Jr. (timc@microsoft.com)
//  Copyright      (C) 1995-96 Microsoft
//  Date           01-16-95
//
//
//  Description
//
//     Contains hyperbolic sin, cos, and tan for rationals.
//
//
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if defined( DOS )
#include <dosstub.h>
#else
#include <windows.h>
#endif
#include <ratpak.h>

//-----------------------------------------------------------------------------
//
//  FUNCTION: sinhrat, _sinhrat
//
//  ARGUMENTS:  x PRAT representation of number to take the sine hyperbolic
//    of
//  RETURN: sinh of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//    n
//   ___    2j+1
//   \  ]  X
//    \   ---------
//    /    (2j+1)!
//   /__]
//   j=0
//          or,
//    n
//   ___                                                 2
//   \  ]                                               X
//    \   thisterm  ; where thisterm   = thisterm  * ---------
//    /           j                 j+1          j   (2j)*(2j+1)
//   /__]
//   j=0
//
//   thisterm  = X ;  and stop when thisterm < precision used.
//           0                              n
//
//   if x is bigger than 1.0 (e^x-e^-x)/2 is used.
//
//-----------------------------------------------------------------------------


void _sinhrat( PRAT *px )

{
    CREATETAYLOR();

    DUPRAT(pret,*px); 
    DUPRAT(thisterm,pret);

    DUPNUM(n2,num_one);

    do    {
        NEXTTERM(xx,INC(n2) DIVNUM(n2) INC(n2) DIVNUM(n2));
        } while ( !SMALL_ENOUGH_RAT( thisterm ) );

    DESTROYTAYLOR();
}

void sinhrat( PRAT *px )

{
    PRAT pret=NULL;
    PRAT tmpx=NULL;

    if ( rat_ge( *px, rat_one ) )
        {
        DUPRAT(tmpx,*px);
        exprat(px);
        tmpx->pp->sign *= -1;
        exprat(&tmpx);
        subrat( px, tmpx );
        divrat( px, rat_two );
        destroyrat( tmpx );
        }
    else
        {
        _sinhrat( px );
        }
}

//-----------------------------------------------------------------------------
//
//  FUNCTION: coshrat
//
//  ARGUMENTS:  x PRAT representation of number to take the cosine
//              hyperbolic of
//
//  RETURN: cosh  of x in PRAT form.
//
//  EXPLANATION: This uses Taylor series
//
//    n
//   ___    2j
//   \  ]  X
//    \   ---------
//    /    (2j)!
//   /__]
//   j=0
//          or,
//    n
//   ___                                                 2
//   \  ]                                               X
//    \   thisterm  ; where thisterm   = thisterm  * ---------
//    /           j                 j+1          j   (2j)*(2j+1)
//   /__]
//   j=0
//
//   thisterm  = 1 ;  and stop when thisterm < precision used.
//           0                              n
//
//   if x is bigger than 1.0 (e^x+e^-x)/2 is used.
//
//-----------------------------------------------------------------------------


void _coshrat( PRAT *px )

{
    CREATETAYLOR();

    pret->pp=longtonum( 1L, nRadix );
    pret->pq=longtonum( 1L, nRadix );

    DUPRAT(thisterm,pret)

    n2=longtonum(0L, nRadix);

    do    {
        NEXTTERM(xx,INC(n2) DIVNUM(n2) INC(n2) DIVNUM(n2));
        } while ( !SMALL_ENOUGH_RAT( thisterm ) );

    DESTROYTAYLOR();
}

void coshrat( PRAT *px )

{
    PRAT tmpx=NULL;

    (*px)->pp->sign = 1;
    (*px)->pq->sign = 1;
    if ( rat_ge( *px, rat_one ) )
        {
        DUPRAT(tmpx,*px);
        exprat(px);
        tmpx->pp->sign *= -1;
        exprat(&tmpx);
        addrat( px, tmpx );
        divrat( px, rat_two );
        destroyrat( tmpx );
        }
    else
        {
        _coshrat( px );
        }
    // Since *px might be epsilon below 1 due to TRIMIT 
    // we need this trick here.
    if ( rat_lt(*px,rat_one) )
        {
        DUPRAT(*px,rat_one);
        }
}

//-----------------------------------------------------------------------------
//
//  FUNCTION: tanhrat
//
//  ARGUMENTS:  x PRAT representation of number to take the tangent
//              hyperbolic of
//
//  RETURN: tanh    of x in PRAT form.
//
//  EXPLANATION: This uses sinhrat and coshrat
//
//-----------------------------------------------------------------------------

void tanhrat( PRAT *px )

{
    PRAT ptmp=NULL;

    DUPRAT(ptmp,*px);
    sinhrat(px);
    coshrat(&ptmp);
    mulnumx(&((*px)->pp),ptmp->pq);
    mulnumx(&((*px)->pq),ptmp->pp);

    destroyrat(ptmp);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\oldchar\ucharma2\dummy.c ===
/* Dummy file to force the linker to output $(TARGETNAME).exe
 * when we're just linking existing objects.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\oldchar\spechars\charmap.c ===
/*++

Copyright (c) 1991-1997,  Microsoft Corporation  All rights reserved.

Module Name:

    charmap.c

Abstract:

    This module contains the main routines for the Charmap utility, an
    interface for selecting special characters.

Revision History:

--*/



//
//  Include Files.
//

#define WIN31
#include "windows.h"
#include <port1632.h>
#include "charmap.h"
#include "stdlib.h"
#include "tchar.h"
#ifdef UNICODE
  #include "wchar.h"
#else
  #include "stdio.h"
#endif
#include "commctrl.h"
#include <htmlhelp.h>


#pragma warning( disable : 4242)
//
//  Macros.
//

#define FMagData(psycm)      ((psycm)->xpMagCurr != 0)
#define abs(x)               (((x) >= 0) ? (x) : (-(x)))




//
//  Constant Declarations.
//

#define STATUSPOINTSIZE      8              // point size of status bar font
#define FE_STATUSPOINTSIZE   10             // FE point size of status bar font
#define DX_BITMAP            20             // width of TT bitmap
#define DY_BITMAP            12             // height of TT bitmap
#define BACKGROUND           0x000000FF     // bright blue
#define BACKGROUNDSEL        0x00FF00FF     // bright purple
#define BUTTONFACE           0x00C0C0C0     // bright grey
#define BUTTONSHADOW         0x00808080     // dark grey
#define TOOLBARPOINTSIZE     21             // height of toolbar in points



// Font types
#define PS_OPENTYPE_FONT    0x0001
#define TT_OPENTYPE_FONT    0x0002
#define TRUETYPE_FONT       0x0004
#define TYPE1_FONT          0x0008

//
//  Debug Print Code.
//

#if 0
  TCHAR szDOUT[3] = TEXT("A\n");
  TCHAR szDbgBuf[256];
  #define DOUTL(p)     OutputDebugString(TEXT(p))
  #define DOUTCHN(ch)  if(0){}else {szDOUT[0] = ch; OutputDebugString(szDOUT);}
  #define DPRINT(p)    if(0){}else {wsprintf p; OutputDebugString(szDbgBuf);}
#else
  #define DOUTL(p)
  #define DOUTCHN(ch)
  #define DPRINT(p)
#endif




//
//  Global Variables.
//

HANDLE hInst;

INT cchSymRow = 32;               // number of characters across the character grid
INT cchSymCol = 8;                // number of rows in the character grid
UTCHAR chSymFirst   = 32;
UTCHAR chSymLast    = 255;
UTCHAR chRangeFirst = 32;
UTCHAR chRangeLast  = 255;
SYCM sycm;                        // tons of data need to do char grid painting
WORD wCFRichText = 0;             // private clipboard format, rich text format
HFONT hFontClipboard = NULL;      // tells us which font is in the clipboard
HANDLE hstrClipboard = NULL;      // contains the string which is in the clipboard
BOOL fDelClipboardFont = FALSE;   // the clipboard font needs to be deleted
INT iControl = ID_CHARGRID;       // index indicating which control has focus
HBITMAP hbmFont = NULL;           // TT bitmap drawn before font facenames in combo
LONG lEditSel = 0;                // contains the selection range of the EC
HBRUSH hStaticBrush;              // used for static controls during WM_CTLCOLOR

//
//  Currently there is no defined interface for querying what character
//  ranges a Unicode font supports.  For now, this table only has the subsets
//  that contain characters supported by the Lucida Sans Unicode font
//  uncommented.  When we get an API that allows querying the font driver for
//  ranges of Unicode characters supported (and whether or not a font is a
//  Unicode font!) then all entries can be uncommented.
//
USUBSET aSubsetData[] =
{
    { 0x0020, 0x00ff, IDS_WINDOWS },
    { 0x0020, 0x00ff, IDS_LATIN1 },
    { 0x0100, 0x017f, IDS_LATINEXA },
    { 0x0180, 0x024f, IDS_LATINEXB },
    { 0x0250, 0x02af, IDS_IPAEX },
    { 0x02b0, 0x02ff, IDS_SPACINGMODIFIERS },
    { 0x0300, 0x036f, IDS_COMBININGDIACRITICS },
    { 0x0370, 0x03cf, IDS_BASICGREEK },
    { 0x03d0, 0x03ff, IDS_GREEKSYMBOLS },
    { 0x0400, 0x04ff, IDS_CYRILLIC },
    { 0x0530, 0x058f, IDS_ARMENIAN },
    { 0x0590, 0x05ff, IDS_HEBREW },
    { 0x0600, 0x0652, IDS_BASICARABIC },
    { 0x0653, 0x06ff, IDS_ARABICEX },
    { 0x0900, 0x097f, IDS_DEVANAGARI },
    { 0x0980, 0x09ff, IDS_BENGALI },
    { 0x0a00, 0x0a7f, IDS_GURMUKHI },
    { 0x0a80, 0x0aff, IDS_GUJARATI },
    { 0x0b00, 0x0b7f, IDS_ORIYA },
    { 0x0b80, 0x0bff, IDS_TAMIL },
    { 0x0c00, 0x0c7f, IDS_TELUGU },
    { 0x0c80, 0x0cff, IDS_KANNADA },
    { 0x0d00, 0x0d7f, IDS_MALAYALAM },
    { 0x0e00, 0x0e7f, IDS_THAI },
    { 0x0e80, 0x0eff, IDS_LAO },
    { 0x10d0, 0x10ff, IDS_BASICGEORGIAN },
    { 0x10a0, 0x10cf, IDS_GEORGIANEX },
    { 0x1100, 0x11ff, IDS_HANGULJAMO },
    { 0x1e00, 0x1eff, IDS_LATINEXADDITIONAL },
    { 0x1f00, 0x1fff, IDS_GREEKEX },
    { 0x2000, 0x206f, IDS_GENERALPUNCTUATION },
    { 0x2070, 0x209f, IDS_SUPERANDSUBSCRIPTS },
    { 0x20a0, 0x20cf, IDS_CURRENCYSYMBOLS },
    { 0x20d0, 0x20ff, IDS_COMBININGDIACRITICSFORSYMBOLS },
    { 0x2100, 0x214f, IDS_LETTERLIKESYMBOLS },
    { 0x2150, 0x218f, IDS_NUMBERFORMS },
    { 0x2190, 0x21ff, IDS_ARROWS },
    { 0x2200, 0x22ff, IDS_MATHEMATICALOPS },
    { 0x2300, 0x23ff, IDS_MISCTECHNICAL },
    { 0x2400, 0x243f, IDS_CONTROLPICTURES },
    { 0x2440, 0x245f, IDS_OPTICALCHAR },
    { 0x2460, 0x24ff, IDS_ENCLOSEDALPHANUM },
    { 0x2500, 0x257f, IDS_BOXDRAWING },
    { 0x2580, 0x259f, IDS_BLOCKELEMENTS },
    { 0x25a0, 0x25ff, IDS_GEOMETRICSHAPES },
    { 0x2600, 0x26ff, IDS_MISCDINGBATS },
    { 0x2700, 0x27bf, IDS_DINGBATS },
    { 0x3000, 0x303f, IDS_CJKSYMBOLSANDPUNC },
    { 0x3040, 0x309f, IDS_HIRAGANA },
    { 0x30a0, 0x30ff, IDS_KATAKANA },
    { 0x3100, 0x312f, IDS_BOPOMOFO },
    { 0x3130, 0x318f, IDS_HANGULCOMPATIBILITYJAMO },
    { 0x3190, 0x319f, IDS_CJKMISC },
    { 0x3200, 0x32ff, IDS_ENCLOSEDCJKLETTERSANDMONTHS },
    { 0x3300, 0x33ff, IDS_CJKCOMPATIBILITY },
    { 0x4e00, 0x9fff, IDS_CJKUNIFIEDIDEOGRAPHS },
    { 0xac00, 0xd7a3, IDS_HANGUL },
    { 0xe000, 0xf8ff, IDS_PRIVATEUSEAREA },
    { 0xf900, 0xfaff, IDS_CJKCOMPATIBILITYIDEOGRAPHS },
    { 0xfb00, 0xfb4f, IDS_ALPAHPRESENTATIONFORMS },
    { 0xfb50, 0xfdff, IDS_ARABICPRESENTATIONFORMSA },
    { 0xfe30, 0xfe4f, IDS_CJKCOMPFORMS },
    { 0xfe50, 0xfe6f, IDS_SMALLFORMVARIANTS },
    { 0xfe70, 0xfefe, IDS_ARABICPRESENTATIONFORMSB },
    { 0xff00, 0xffef, IDS_HALFANDFULLWIDTHFORMS },
    { 0xfff0, 0xfffd, IDS_SPECIALS }
};
INT cSubsets = sizeof(aSubsetData) / sizeof(USUBSET);
INT iCurSubset = 0;     // index of current Unicode subset - default to Latin-1

//
//  Useful window handles.
//
HWND hwndDialog;
HWND hwndCharGrid;

//
//  Data used to draw the status bar.
//
RECT rcStatusLine;                // bounding rect for status bar
RECT rcToolbar[2];                // bounding rects for toolbars
INT dyStatus;                     // height of status bar
INT dyToolbar[2];                 // height of tool bars
INT dxHelpField;                  // width of help window
INT dxKeystrokeField;             // width of keystroke window
TCHAR szKeystrokeText[MAX_PATH];  // buffer for keystroke text
TCHAR szKeystrokeLabel[30];       // buffer for keystroke label
TCHAR szSpace[15];                // strings for keystroke description
TCHAR szCtrl[15];
TCHAR szCtrlAlt[25];
TCHAR szShiftCtrlAlt[25];
TCHAR szAlt[15];
TCHAR szUnicodeLabel[23];         // buffer for Unicode label
INT iKeystrokeTextStart;          // place to start appending text to above
INT iUnicodeLabelStart;           // place to start appending text to above
HFONT hfontStatus;                // font used for text of status bar





////////////////////////////////////////////////////////////////////////////
//
//  WinMain
//
//  Calls initialization function, processes message loop, cleanup.
//
////////////////////////////////////////////////////////////////////////////

INT WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    MSG msg;

    if (!InitApplication(hInstance))
    {
        return (FALSE);
    }

    //
    //  Perform initialization for this instance.
    //
    if (!InitInstance(hInstance, nCmdShow))
    {
        return (FALSE);
    }

    while (GetMessage(&msg, NULL, 0, 0))
    {
        //
        //  Filter for possible tabs now to implement context sensitive help.
        //
        if (msg.message == WM_KEYDOWN)
        {
            if (!UpdateHelpText(&msg, NULL))
            {
                continue;
            }
        }

        //
        //  Main message loop.
        //
        if (!IsDialogMessage(hwndDialog, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    //
    //  Free up some stuff.
    //
    if (hfontStatus)
    {
        DeleteObject(hfontStatus);
    }
    if (hbmFont)
    {
        DeleteObject(hbmFont);
    }

    return (msg.wParam);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitApplication
//
//  Initializes window data and registers window class.
//
////////////////////////////////////////////////////////////////////////////

BOOL InitApplication(
    HANDLE hInstance)
{
    WNDCLASS wc;

    //
    //  Register a window class that we will use to draw the character
    //  grid into.
    //
    wc.style = CS_DBLCLKS;
    wc.lpfnWndProc = CharGridWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("CharGridWClass");

    if (!RegisterClass(&wc))
    {
        return (FALSE);
    }

    wc.style = 0;
    wc.lpfnWndProc = DefDlgProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = DLGWINDOWEXTRA;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDIC_CHARMAP));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("MyDlgClass");

    if (!RegisterClass(&wc))
    {
        return (FALSE);
    }

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  InitInstance
//
//  Does some initialization and creates main window which is a dialog.
//
////////////////////////////////////////////////////////////////////////////

BOOL InitInstance(
    HANDLE hInstance,
    INT nCmdShow)
{
    INT i;
    CHARSETINFO csi;
    DWORD dw = GetACP();
    LANGID PrimaryLangId = (PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())));
    BOOL bFE = ((PrimaryLangId == LANG_JAPANESE) ||
                (PrimaryLangId == LANG_KOREAN)   ||
                (PrimaryLangId == LANG_CHINESE));

    //
    //  Save the instance handle in a global variable.
    //
    hInst = hInstance;

    //
    //  This font will be used to paint the status line.
    //
    if (!TranslateCharsetInfo((DWORD*)dw, &csi, TCI_SRCCODEPAGE))
    {
        csi.ciCharset = ANSI_CHARSET;
    }
    hfontStatus = CreateFont( -PointsToHeight(bFE
                                                ? FE_STATUSPOINTSIZE
                                                : STATUSPOINTSIZE),
                              0, 0, 0, 400, 0, 0, 0,
                              csi.ciCharset,
                              OUT_DEFAULT_PRECIS,
                              CLIP_DEFAULT_PRECIS,
                              DEFAULT_QUALITY,
                              VARIABLE_PITCH,
                              TEXT("MS Shell Dlg") );

    dyStatus = 2 * PointsToHeight(STATUSPOINTSIZE);
    dyToolbar[0] = PointsToHeight(TOOLBARPOINTSIZE);
    dyToolbar[1] = PointsToHeight(TOOLBARPOINTSIZE);

    //
    //  Load the Unicode subset names before initializing the main window.
    //
    for (i = 0; i < cSubsets; i++)
    {
        if (!LoadString( hInst,
                         aSubsetData[i].StringResId,
                         (LPTSTR)aSubsetData[i].Name,
                         LF_SUBSETSIZE))
        {
            return (FALSE);
        }
    }

    //
    //  Create a main window for this application instance.
    //
    if (!(hwndDialog = CreateDialog( hInstance,
                                     TEXT("CharMap"),
                                     NULL,
                                     CharMapDlgProc )))
    {
        return (FALSE);
    }

    //
    //  Initialize some strings used for the Keystroke status bar field.
    //  For international purposes, this string could be length 0.
    //
    LoadString( hInst,
                IDS_KEYSTROKE,
                (LPTSTR)szKeystrokeLabel,
                BTOC(sizeof(szKeystrokeLabel)) );
    if (!LoadString( hInst,
                     IDS_UNICODELABEL,
                     (LPTSTR)szUnicodeLabel,
                     BTOC(sizeof(szUnicodeLabel)) ))
    {
        if (!LoadString( hInst,
                         IDS_SPACE,
                         (LPTSTR)szSpace,
                         BTOC(sizeof(szSpace)) ))
        {
            return (FALSE);
        }
    }
    if (!LoadString( hInst,
                     IDS_CTRL,
                     (LPTSTR)szCtrl,
                     BTOC(sizeof(szCtrl)) ))
    {
        return (FALSE);
    }
    if (!LoadString( hInst,
                     IDS_CTRLALT,
                     (LPTSTR)szCtrlAlt,
                     BTOC(sizeof(szCtrlAlt)) ))
    {
        return (FALSE);
    }
    if (!LoadString( hInst,
                     IDS_SHIFTCTRLALT,
                     (LPTSTR)szShiftCtrlAlt,
                     BTOC(sizeof(szShiftCtrlAlt)) ))
    {
        return (FALSE);
    }
    if (!LoadString( hInst,
                     IDS_ALT,
                     (LPTSTR)szAlt,
                     BTOC(sizeof(szAlt)) ))
    {
        return (FALSE);
    }

    //
    //  Store the index to where we start adding status line text changes.
    //
    iKeystrokeTextStart = lstrlen(szKeystrokeLabel);
    iUnicodeLabelStart = lstrlen(szUnicodeLabel);

    //
    //  Initialize keystroke text, make the window visible,
    //  update its client area, and return "success".
    //
    UpdateKeystrokeText(NULL, sycm.fAnsiFont, sycm.chCurr, FALSE);
    ShowWindow(hwndDialog, nCmdShow);
    UpdateWindow(hwndDialog);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ConvertANSIFontToUnicode
//
////////////////////////////////////////////////////////////////////////////

WCHAR ConvertANSIFontToUnicode(
    HWND hwnd,
    HFONT hFont,
    CHAR ch)
{
    WORD cp = CP_ACP;
    WCHAR wch;
    HDC hdc;

    hdc = GetDC(hwnd);
    if (hdc != NULL)
    {
        HFONT hfOld;
        TEXTMETRIC tm;
        CHARSETINFO csi;
        DWORD cs;

        hfOld = SelectObject(hdc, hFont);

        if (GetTextMetrics(hdc, &tm))
        {
            cs = MAKELONG(tm.tmCharSet, 0);

            if (TranslateCharsetInfo((DWORD *)cs, &csi, TCI_SRCCHARSET))
            {
                cp = csi.ciACP;
            }
            else
            {
                DPRINT(( szDbgBuf,
                         TEXT("CvtAtoW: TranslateCharsetInfo(cset=%d) returned 0! (GetLastErr=%d), using CP_ACP\n"),
                         cs,
                         GetLastError() ));
            }
        }
        SelectObject(hdc, hfOld);
        ReleaseDC(hwnd, hdc);
    }

    if (MultiByteToWideChar(cp, 0, &ch, 1, &wch, 1) != 1)
    {
        if (MultiByteToWideChar(CP_ACP, 0, &ch, 1, &wch, 1) != 1)
        {
            wch = (WCHAR)(BYTE)ch;
        }
    }

    DPRINT(( szDbgBuf,
             TEXT("CvtAtoW: 0x%02x '%c' (CP:%d) -> U'%04X'\n"),
             (DWORD)(BYTE)ch,
             ch,
             cp,
             (DWORD)wch ));

    return (wch);
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumChildProc
//
//  Gets called during init for each child window.
//
////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK EnumChildProc(
    HWND hwnd,
    LPARAM lParam)
{
    LONG st;
    TCHAR szClass[MAX_PATH];

    //
    //  Get control class.
    //
    GetClassName(hwnd, szClass, MAX_PATH);
    if (lstrcmpi(szClass, TEXT("button")) == 0 )
    {
        //
        //  If it is a button, set the ex style to NOTIFYPARENT.
        //
        st = GetWindowLong(hwnd, GWL_EXSTYLE);
        st = st & ~WS_EX_NOPARENTNOTIFY;
        SetWindowLong(hwnd, GWL_EXSTYLE, st);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CharMapDlgProc
//
//  Processes messages for the main window.  This window is a dialog box.
//
////////////////////////////////////////////////////////////////////////////

INT_PTR APIENTRY CharMapDlgProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message)
    {
        case ( WM_CTLCOLORSTATIC ) :
        {
            POINT point;

            SetBkColor((HDC)wParam, GetSysColor(COLOR_BTNFACE));
            UnrealizeObject(hStaticBrush);
            point.x = point.y = 0;
            ClientToScreen(hWnd, &point);

            return ((INT_PTR)hStaticBrush);
            break;
        }
        case ( WM_INITDIALOG ) :
        {
            RECT rectParent, rectTopRightControl, rect;
            POINT pt;
            INT iSubset;
            HWND hwndCMSB;

            //
            //  Set buttons to send WM_PARENTNOTIFY.
            //
            EnumChildWindows(hWnd, EnumChildProc, (LPARAM)NULL );

            //
            //  Create the character grid with dimensions which just fit
            //  inside the space allowed in the dialog.  When it processes
            //  the WM_CREATE message it will be sized and centered more
            //  accurately.
            //
            GetClientRect(hWnd, &rectParent);
            GetWindowRect(GetDlgItem(hWnd, ID_CLOSE), &rectTopRightControl);
            ScreenToClient(hWnd, (LPPOINT)&(rectTopRightControl.left));
            ScreenToClient(hWnd, (LPPOINT)&(rectTopRightControl.right));

            if (!(hwndCharGrid =
                  CreateWindow( TEXT("CharGridWClass"),
                                NULL,
                                WS_CHILD | WS_VISIBLE | WS_TABSTOP,
                                1,
                                rectParent.top + dyToolbar[0] + dyToolbar[1],
                                rectParent.right - 1,
                                rectParent.bottom - rectParent.top -
                                  dyStatus - dyToolbar[0] - dyToolbar[1] - 1,
                                hWnd,
                                (HMENU)ID_CHARGRID,
                                hInst,
                                NULL )))
            {
                DestroyWindow(hWnd);
                break;
            }

            GetWindowRect(hwndCharGrid, &rect);
            pt.x = rect.right;
            pt.y = rect.top;

            ScreenToClient(hWnd, &pt);

            hwndCMSB = CreateWindowEx( 0L,
                                       TEXT("SCROLLBAR"),
                                       NULL,
                                       WS_CHILD | SBS_VERT | WS_VISIBLE |
                                         WS_TABSTOP,
                                       pt.x + 1,
                                       pt.y + 1,
                                       sycm.dxpBox,
                                       sycm.dypCM,
                                       hWnd,
                                       (HMENU)ID_MAPSCROLL,
                                       hInst,
                                       NULL );

            hStaticBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));

            //
            //  Initialize the status line data.
            //
            dxHelpField = 21 * rectParent.right / 32;
            dxKeystrokeField = 9 * rectParent.right / 32;
            rcStatusLine = rectParent;
            rcStatusLine.top = rcStatusLine.bottom - dyStatus;

            //
            //  Initialize the toolbars.
            //
            rcToolbar[0] = rectParent;
            rcToolbar[0].bottom = rcToolbar[0].top + dyToolbar[0];

            rcToolbar[1] = rcToolbar[0];
            rcToolbar[1].top = rcToolbar[0].bottom + GetSystemMetrics(SM_CYBORDER);
            rcToolbar[1].bottom = rcToolbar[1].top + dyToolbar[1];

            //
            //  Disable Copy button.
            //
            EnableWindow(GetDlgItem(hWnd, ID_COPY), FALSE);

            //
            //  Fill "Subset" list box.
            //
            for (iSubset = 0; iSubset < cSubsets; iSubset++)
            {
                SendDlgItemMessage( hWnd,
                                    ID_UNICODESUBSET,
                                    CB_ADDSTRING,
                                    0,
                                    (DWORD)aSubsetData[iSubset].Name );
            }
            iCurSubset = SelectInitialSubset(hWnd);

            //
            //  Fall through to WM_FONTCHANGE...
            //
        }
        case ( WM_FONTCHANGE ) :
        {
            HDC hdc = GetDC(hWnd);

            //
            //  Get the fonts from the system and put them in the font
            //  selection combo box.
            //
            if (message == WM_FONTCHANGE)
            {
                SaveCurrentFont(hWnd);
                SendDlgItemMessage(hWnd, ID_FONT, CB_RESETCONTENT, 0, 0L);
            }

            EnumFontFamilies(hdc, NULL, (FONTENUMPROC)FontLoadProc, (LPARAM)hWnd);

            ReleaseDC(hWnd, hdc);

            //
            //  Setup character dimensions and select this font.
            //
            RecalcCharMap( hWnd,
                           &sycm,
                           SelectInitialFont(hWnd),
                           (message == WM_FONTCHANGE) );
            SetEditCtlFont(hWnd, ID_STRING, sycm.hFont);

            if (message == WM_INITDIALOG)
            {
                SetFocus(hwndCharGrid);

                //
                //  Fall through to WM_SYSCOLORCHANGE...
                //
            }
            else
            {
                break;
            }
        }
        case ( WM_SYSCOLORCHANGE ) :
        {
            if (hbmFont)
            {
                DeleteObject(hbmFont);
            }
            hbmFont = LoadBitmaps(IDBM_TT);
            DeleteObject(hStaticBrush);
            hStaticBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
            break;
        }
        case ( WM_PARENTNOTIFY ) :
        {
            POINTS points;
            DWORD dwMsgPos;
            POINT point;

            DPRINT(( szDbgBuf,
                     TEXT("WM_PARENTNOTIFY: lParam:0x%08lX, wParam:0x%08lX\n"),
                     (DWORD)lParam,
                     (DWORD)wParam ));

            //
            //  We process this message to implement the context sensitive
            //  help.  Downclicks to controls are found here, the help
            //  message is updated in the status bar.
            //
            //  The parameters with this message are unreliable!
            //
            if (LOWORD(wParam) == WM_LBUTTONDOWN)
            {
                dwMsgPos = GetMessagePos();
                points = MAKEPOINTS(dwMsgPos);
                point.x = points.x;
                point.y = points.y;
                UpdateHelpText(NULL, WindowFromPoint(point));
            }

            break;
        }
        case ( WM_VSCROLL ) :
        {
            ProcessScrollMsg(hWnd, LOWORD(wParam), HIWORD(wParam));
            break;
        }
        case ( WM_PAINT ) :
        {
            HBRUSH hBrush;
            RECT rcTemp, rectNextButton;
            INT dyBorder, dxBorder;
            PAINTSTRUCT ps;
            HDC hdc;

            //
            //  This code implements painting of the status bar.
            //
            hdc = BeginPaint(hWnd, &ps);

            rcTemp = rcStatusLine;

            dyBorder = GetSystemMetrics(SM_CYBORDER);
            dxBorder = GetSystemMetrics(SM_CXBORDER);

            //
            //  Make the whole thing grey.
            //
            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE)))
            {
                FillRect(hdc, &rcTemp, hBrush);
                rcTemp.left = rcToolbar[0].left;
                rcTemp.top = rcToolbar[0].top;
                rcTemp.right = rcToolbar[1].right;
                rcTemp.bottom = rcToolbar[1].bottom;
                FillRect(hdc, &rcTemp, hBrush);
                DeleteObject(hBrush);
            }

            GetWindowRect(GetDlgItem(hWnd, ID_TOPLEFT), &rectNextButton);
            ScreenToClient(hWnd, (LPPOINT)&(rectNextButton.left));
            ScreenToClient(hWnd, (LPPOINT)&(rectNextButton.right));
            //
            //  Solid black line across bottom of toolbar.
            //
            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOWFRAME)))
            {
#ifdef USE_MIRRORING
                DWORD dwLayout;
                GetProcessDefaultLayout(&dwLayout);
                if(dwLayout & LAYOUT_RTL)
                { 
                    //
                    // Interchange the right and left values.
                    //
                    int tmp = rectNextButton.left;
                    rectNextButton.left = rectNextButton.right;
                    rectNextButton.right = tmp;
                }
#endif
                rcTemp = rcToolbar[0];
                rcTemp.top = rcTemp.bottom;
                rcTemp.bottom += dyBorder;
                rcTemp.left = rectNextButton.left - 2 - dxBorder;
                FillRect(hdc, &rcTemp, hBrush);
                rcTemp = rcToolbar[1];
                rcTemp.top = rcTemp.bottom;
                rcTemp.bottom += dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                //
                //  Vertical line.
                //
                rcTemp.top = rcToolbar[0].top;
                rcTemp.bottom = rcToolbar[1].bottom;
                rcTemp.left = rectNextButton.left - 2 - dxBorder;
                rcTemp.right = rectNextButton.left - 2;
                FillRect(hdc, &rcTemp, hBrush);
                DeleteObject(hBrush);
            }

            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW)))
            {
                //
                //  Status line top.
                //
                rcTemp.left   = 8 * dyBorder;
                rcTemp.right  = rcTemp.left + dxHelpField;
                rcTemp.top    = rcStatusLine.top + dyBorder * 2;
                rcTemp.bottom = rcTemp.top + dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                //
                //  Keystroke line top.
                //
                rcTemp.right = rcStatusLine.right - 8 * dyBorder;
                rcTemp.left = rcTemp.right - dxKeystrokeField;
                FillRect(hdc, &rcTemp, hBrush);

                //
                //  Status line left side.
                //
                rcTemp = rcStatusLine;
                rcTemp.left = 8 * dyBorder;
                rcTemp.right = rcTemp.left + dyBorder;
                rcTemp.top += dyBorder * 2;
                rcTemp.bottom -= dyBorder * 2;
                FillRect(hdc, &rcTemp, hBrush);

                //
                //  Keystroke line left side.
                //
                rcTemp.left = rcStatusLine.right - 9 * dyBorder - dxKeystrokeField;
                rcTemp.right = rcTemp.left + dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                DeleteObject(hBrush);
            }

            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNHIGHLIGHT)))
            {
                //
                //  Status line bottom.
                //
                rcTemp.left   = 8 * dyBorder;
                rcTemp.right  = rcTemp.left + dxHelpField;
                rcTemp.top    = rcStatusLine.bottom - 3 * dyBorder;
                rcTemp.bottom = rcTemp.top + dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                //
                //  Keystroke line bottom.
                //
                rcTemp.right = rcStatusLine.right - 8 * dyBorder;
                rcTemp.left = rcTemp.right - dxKeystrokeField;
                FillRect(hdc, &rcTemp, hBrush);

                //
                //  Status line right side.
                //
                rcTemp = rcStatusLine;
                rcTemp.left = 8 * dyBorder + dxHelpField;
                rcTemp.right = rcTemp.left + dyBorder;
                rcTemp.top += dyBorder * 2;
                rcTemp.bottom -= dyBorder * 2;
                FillRect(hdc, &rcTemp, hBrush);

                //
                //  Keystroke line right side.
                //
                rcTemp.left = rcStatusLine.right - 8 * dyBorder;
                rcTemp.right = rcTemp.left + dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                DeleteObject(hBrush);
            }

            //
            //  Solid black line across top.
            //
            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOWFRAME)))
            {
                rcTemp = rcStatusLine;
                rcTemp.bottom = rcTemp.top;
                rcTemp.top -= dyBorder;
                FillRect(hdc, &rcTemp, hBrush);
                DeleteObject(hBrush);
            }

            PaintStatusLine(hdc, TRUE, TRUE);

            EndPaint(hWnd, &ps);

            return (TRUE);
        }
        case ( WM_MEASUREITEM ) :
        {
            HDC hDC;
            HFONT hFont;
            TEXTMETRIC tm;

            hDC = GetDC(NULL);
            hFont = (HFONT)SendMessage(hWnd, WM_GETFONT, 0, 0L);
            if (hFont)
            {
                hFont = SelectObject(hDC, hFont);
            }
            GetTextMetrics(hDC, &tm);
            if (hFont)
            {
                SelectObject(hDC, hFont);
            }
            ReleaseDC(NULL, hDC);

            ((LPMEASUREITEMSTRUCT)lParam)->itemHeight = max(tm.tmHeight, DY_BITMAP);
            break;
        }
        case ( WM_DRAWITEM ) :
        {
            if (((LPDRAWITEMSTRUCT)lParam)->itemID != -1)
            {
                DrawFamilyComboItem((LPDRAWITEMSTRUCT)lParam);
            }
            break;
        }
        case ( WM_ASKCBFORMATNAME ) :
        {
            LoadString(hInst, IDS_RTF, (LPTSTR)lParam, wParam);
            return (TRUE);
        }
        case ( WM_PAINTCLIPBOARD ) :
        {
            LPPAINTSTRUCT lpPS;
            HANDLE hFont;
            LPTSTR lpstrText;

            if (hstrClipboard)
            {
                //
                //  Setup.
                //
                lpPS = (LPPAINTSTRUCT)GlobalLock((HANDLE)lParam);
                lpstrText = (LPTSTR)GlobalLock(hstrClipboard);

                //
                //  Paint.
                //
                hFont = SelectObject(lpPS->hdc, hFontClipboard);
                TextOut(lpPS->hdc, 0, 0, lpstrText, lstrlen(lpstrText));
                SelectObject(lpPS->hdc, hFont);

                //
                //  Cleanup.
                //
                GlobalUnlock(hstrClipboard);
                GlobalUnlock((HANDLE)lParam);
            }
            return (TRUE);
        }
        case ( WM_CLOSE ) :
        {
            DestroyWindow(hWnd);
            return (TRUE);
        }
        case ( WM_COMMAND ) :
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case ( IDCANCEL ) :
                case ( ID_CLOSE ) :
                {
                    DestroyWindow(hWnd);
                    return (TRUE);
                    break;
                }
                case ( ID_SELECT ) :
                {
                    WCHAR wch = sycm.chCurr;

                    if (sycm.fAnsiFont)
                    {
                        wch = ConvertANSIFontToUnicode( hWnd,
                                                        sycm.hFont,
                                                        (char)wch );
                    }

                    SendDlgItemMessage(hWnd, ID_STRING, WM_CHAR, (WPARAM)wch, 0L);
                    break;
                }
                case ( ID_COPY ) :
                {
                    CopyString(hWnd);
                    return (TRUE);
                    break;
                }
                case ( ID_FONT ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        RecalcCharMap( hWnd,
                                       &sycm,
                                       (INT)SendDlgItemMessage( hWnd,
                                                                ID_FONT,
                                                                CB_GETCURSEL,
                                                                0,
                                                                0L ),
                                       TRUE );
                        SetEditCtlFont(hWnd, ID_STRING, sycm.hFont);
                    }
                    else if (HIWORD(wParam) == CBN_SETFOCUS)
                    {
                        //
                        //  Necessary if hotkey is used to get to the CB.
                        //
                        UpdateHelpText(NULL, (HWND)lParam);
                    }

                    return (TRUE);
                    break;
                }
                case ( ID_UNICODESUBSET ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        INT iSubset;
                        INT cEntries;

                        iSubset = (INT)SendDlgItemMessage( hWnd,
                                                           ID_UNICODESUBSET,
                                                           CB_GETCURSEL,
                                                           0,
                                                           0 );
                        SubSetChanged( hWnd,
                                       iSubset,
                                       aSubsetData[iSubset].BeginRange,
                                       aSubsetData[iSubset].EndRange );

                        cEntries = (INT)SendDlgItemMessage( hWnd,
                                                            ID_UNICODESUBSET,
                                                            CB_GETCOUNT,
                                                            0,
                                                            0 ) - 1;

                        EnableWindow( GetDlgItem(hWnd, ID_PREVSUBSET),
                                      iSubset > 0 );

                        EnableWindow( GetDlgItem(hWnd, ID_NEXTSUBSET),
                                      iSubset < cEntries );
                    }
                    else if (HIWORD(wParam) == CBN_SETFOCUS)
                    {
                        //
                        //  Necessary if hotkey is used to get to the CB.
                        //
                        UpdateHelpText(NULL, (HWND)lParam);
                    }
                    return (0L);
                    break;
                }
                case ( ID_NEXTSUBSET ) :
                {
                    INT iCurSelection, iNumEntries;

                    iCurSelection = (INT)SendDlgItemMessage( hWnd,
                                                             ID_UNICODESUBSET,
                                                             CB_GETCURSEL,
                                                             0,
                                                             0 );
                    if (iCurSelection == CB_ERR)
                    {
                         return (0L);
                    }
                    iNumEntries = (INT)SendDlgItemMessage( hWnd,
                                                           ID_UNICODESUBSET,
                                                           CB_GETCOUNT,
                                                           0,
                                                           0 );
                    if (iNumEntries == CB_ERR)
                    {
                         return (0L);
                    }
                    if (iCurSelection++ < (iNumEntries - 1))
                    {
                        if (iCurSelection == 1)
                        {
                            //
                            //  Enable Previous button.
                            //
                            EnableWindow(GetDlgItem(hWnd, ID_PREVSUBSET), TRUE);
                        }

                        SendDlgItemMessage( hWnd,
                                            ID_UNICODESUBSET,
                                            CB_SETCURSEL,
                                            iCurSelection,
                                            0 );
                        SubSetChanged( hWnd,
                                       iCurSelection,
                                       aSubsetData[iCurSelection].BeginRange,
                                       aSubsetData[iCurSelection].EndRange );
                        if (iCurSelection == (iNumEntries - 1))
                        {
                            HWND hwndButton;

                            EnableWindow(GetDlgItem(hWnd, ID_NEXTSUBSET), FALSE);
                            //
                            //  Only reset the button style and focus if
                            //  the "Next" button currently has it.
                            //
                            if (iControl == ID_NEXTSUBSET)
                            {
                                SendDlgItemMessage( hwndDialog,
                                                    ID_PREVSUBSET,
                                                    BM_SETSTYLE,
                                                    BS_DEFPUSHBUTTON,
                                                    1 );
                                SendDlgItemMessage( hwndDialog,
                                                    ID_NEXTSUBSET,
                                                    BM_SETSTYLE,
                                                    BS_PUSHBUTTON,
                                                    1 );
                                hwndButton = GetDlgItem(hWnd, ID_PREVSUBSET);
                                SetFocus(hwndButton);
                                UpdateHelpText(NULL, hwndButton);
                            }
                        }
                    }
                    return (0L);
                    break;
                }
                case ( ID_PREVSUBSET ) :
                {
                    INT iCurSelection;

                    iCurSelection = (INT)SendDlgItemMessage( hWnd,
                                                             ID_UNICODESUBSET,
                                                             CB_GETCURSEL,
                                                             0,
                                                             0 );
                    if (iCurSelection == CB_ERR)
                    {
                         return (0L);
                    }
                    if (iCurSelection > 0)
                    {
                        iCurSelection--;

                        if (iCurSelection == (cSubsets - 2))
                        {
                            //
                            //  Enable Next button.
                            //
                            EnableWindow(GetDlgItem(hWnd, ID_NEXTSUBSET), TRUE);
                        }

                        SendDlgItemMessage( hWnd,
                                            ID_UNICODESUBSET,
                                            CB_SETCURSEL,
                                            iCurSelection,
                                            0 );
                        SubSetChanged( hWnd,
                                       iCurSelection,
                                       aSubsetData[iCurSelection].BeginRange,
                                       aSubsetData[iCurSelection].EndRange );
                        if (iCurSelection == 0)
                        {
                            HWND hwndButton;

                            EnableWindow(GetDlgItem(hWnd, ID_PREVSUBSET), FALSE);
                            //
                            //  Only reset the button style and focus if
                            //  the "Previous" button currently has it.
                            //
                            if (iControl == ID_PREVSUBSET)
                            {
                                SendDlgItemMessage( hwndDialog,
                                                    ID_NEXTSUBSET,
                                                    BM_SETSTYLE,
                                                    BS_DEFPUSHBUTTON,
                                                    1 );
                                SendDlgItemMessage( hwndDialog,
                                                    ID_PREVSUBSET,
                                                    BM_SETSTYLE,
                                                    BS_PUSHBUTTON,
                                                    1 );
                                hwndButton = GetDlgItem(hWnd, ID_NEXTSUBSET);
                                SetFocus(hwndButton);
                                UpdateHelpText(NULL, hwndButton);
                            }
                        }
                    }
                    return (0L);
                    break;
                }
                case ( ID_STRING ) :
                {
                    if (HIWORD(wParam) == EN_SETFOCUS)
                    {
                        //
                        //  Necessary if hotkey is used to get to the EC.
                        //
                        UpdateHelpText(NULL, (HWND)lParam);
                    }
                    else if (HIWORD(wParam) == EN_CHANGE)
                    {
                        //
                        //  Disable Copy button if there are no chars in EC.
                        //
                        INT iLength;

                        iLength = GetWindowTextLength((HWND)lParam);
                        EnableWindow(GetDlgItem(hWnd, ID_COPY), (BOOL)iLength);
                    }

                    break;
                }
                case ( ID_HELP ) :
                {
                    DoHelp(hWnd, TRUE);
                    break;
                }
            }
            break;
        }
        case ( WM_DESTROY ) :
        {
            SaveCurrentFont(hWnd);
            SaveCurrentSubset(hWnd);
            DoHelp(hWnd, FALSE);
            DeleteObject(hStaticBrush);
            PostQuitMessage(0);
            break;
        }
        case ( WM_ACTIVATEAPP ) :
        {
            if (wParam)
            {
                SendDlgItemMessage( hWnd,
                                    ID_STRING,
                                    EM_SETSEL,
                                    LOWORD(lEditSel),
                                    HIWORD(lEditSel) );
            }
            else
            {
                lEditSel = SendDlgItemMessage(hWnd, ID_STRING, EM_GETSEL, 0, 0L);
                SendDlgItemMessage(hWnd, ID_STRING, EM_SETSEL, 0, 0L);
            }
            break;
        }
    }

    return (0L);
}


////////////////////////////////////////////////////////////////////////////
//
//  CharGridWndProc
//
//  Processes messages for the character grid window.
//
////////////////////////////////////////////////////////////////////////////

LRESULT APIENTRY CharGridWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message)
    {
        case ( WM_CREATE ) :
        {
            RECT rect;
            HDC hdcScrn;
            POINT point1, point2;

            //
            //  Setup global.
            //
            hwndCharGrid = hWnd;

            GetClientRect(hWnd, &rect);

            //
            //  Calculate metrics for the character grid and the
            //  magnify window.
            //
            sycm.dxpBox = (rect.right - 1)  / (cchSymRow + 2);
            sycm.dypBox = (rect.bottom - 2) / (cchSymCol + 1);
            sycm.dxpCM  = sycm.dxpBox * cchSymRow + 1;
            sycm.dypCM  = sycm.dypBox * cchSymCol + 1;  // space inside for border

            if ((PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())) == LANG_CHINESE))
            {
                sycm.dxpMag = sycm.dxpBox * 3 + 5;
            }
            else
            {
                sycm.dxpMag = sycm.dxpBox * 2 + 4;    // twice the size + 2 bit border
            }
            sycm.dypMag = sycm.dypBox * 2 + 4;

            sycm.chCurr   = chSymFirst;
            sycm.hFontMag = NULL;
            sycm.hFont    = NULL;
            sycm.hdcMag   = NULL;
            sycm.hbmMag   = NULL;
            sycm.ypDest   = 0;

            sycm.fFocusState = sycm.fMouseDn = sycm.fCursorOff = FALSE;

            //
            //  Size the window precisely so the grid fits and is centered.
            //
            MoveWindow( hWnd,
                        (rect.right - sycm.dxpCM + 1) / 2,
                        (rect.bottom - sycm.dypCM + 1) / 2 +
                          ((LPCREATESTRUCT)lParam)->y - 2,
                        sycm.dxpCM + 2,
                        sycm.dypCM + 2,
                        FALSE );

            //
            //  Figure out what the offsets are between the dialog
            //  and the character grid window.
            //
            point1.x = point1.y = point2.x = point2.y = 0;
            ClientToScreen(hWnd, &point1);
            ClientToScreen(((LPCREATESTRUCT)lParam)->hwndParent, &point2);
#ifdef USE_MIRRORING
            sycm.xpCM = (abs(point1.x - point2.x)) - (sycm.dxpMag - sycm.dxpBox) / 2;
#else
            sycm.xpCM = (point1.x - point2.x) - (sycm.dxpMag - sycm.dxpBox) / 2;
#endif
            sycm.ypCM = (point1.y - point2.y) - (sycm.dypMag - sycm.dypBox) / 2;

            //
            //  Create dc and bitmap for the magnify window.
            //
            if ((hdcScrn = GetWindowDC(hWnd)) != NULL)
            {
                if ((sycm.hdcMag = CreateCompatibleDC(hdcScrn)) != NULL)
                {
                    SetTextColor( sycm.hdcMag,
                                  GetSysColor(COLOR_WINDOWTEXT) );
                    SetBkColor( sycm.hdcMag,
                                GetSysColor(COLOR_WINDOW) );
                    SetBkMode(sycm.hdcMag, OPAQUE);
                    if ((sycm.hbmMag =
                         CreateCompatibleBitmap( hdcScrn,
                                                 sycm.dxpMag,
                                                 sycm.dypMag * 2 )) == NULL)
                    {
                        DeleteObject(sycm.hdcMag);
                    }
                    else
                    {
                        SelectObject(sycm.hdcMag, sycm.hbmMag);
                    }
                }
                ReleaseDC(hWnd, hdcScrn);
            }
            break;
        }
        case ( WM_DESTROY ) :
        {
            if (sycm.fMouseDn)
            {
                ExitMagnify(hWnd, &sycm);
            }
            if (fDelClipboardFont)
            {
                DeleteObject(hFontClipboard);
            }
            if (sycm.hFont != NULL)
            {
                DeleteObject(sycm.hFont);
            }
            if (sycm.hFontMag != NULL)
            {
                DeleteObject(sycm.hFontMag);
            }
            if (sycm.hdcMag != NULL)
            {
                DeleteDC(sycm.hdcMag);
            }
            if (sycm.hbmMag != NULL)
            {
                DeleteObject(sycm.hbmMag);
            }
            break;
        }
        case ( WM_SETFOCUS ) :
        case ( WM_KILLFOCUS ) :
        {
            RestoreSymMag(&sycm);
            DrawSymChOutlineHwnd( &sycm,
                                  hWnd,
                                  sycm.chCurr,
                                  TRUE,
                                  message == WM_SETFOCUS );
            break;
        }
        case ( WM_LBUTTONDOWN ) :
        {
            RECT rect;

            DOUTL("WM_LBUTTONDOWN: In\n");

            //
            //  Don't draw anything if there's an update region pending.
            //
            if (GetUpdateRect(hWnd, (LPRECT)&rect, FALSE) != 0)
            {
                DOUTL("WM_LBUTTONDOWN: No upd rect\n");
                break;
            }

            SetFocus(hWnd);
            SetCapture(hWnd);

            sycm.fMouseDn = TRUE;

            if (!FMagData(&sycm))
            {
                DOUTL("WM_LBUTTONDOWN: Drawing sym outline\n");
                DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, FALSE, FALSE);
            }

            //
            //  Fall through to WM_MOUSEMOVE...
            //
        }
        case ( WM_MOUSEMOVE ) :
        {
            DOUTL("WM_MOUSEMOVE: In\n");
            if (sycm.fMouseDn)
            {
                POINT pt;
                UINT chMouseSymbol;

                DOUTL("WM_MOUSEMOVE: mouse is down\n");

                pt.x = LOWORD(lParam);
                pt.y = HIWORD(lParam);
                ClientToScreen(hWnd, (LPPOINT)&pt);
                if (WindowFromPoint(pt) == hWnd)
                {
                    ScreenToClient(hWnd, (LPPOINT)&pt);
                    //
                    //  Convert back to a 'points'-like thing.
                    //
                    lParam = MAKELONG((WORD)pt.x, (WORD)pt.y);
                    chMouseSymbol = (UINT)ChFromSymLParam(&sycm, lParam);
                    if (chMouseSymbol > (UINT)chSymLast)
                    {
                        //
                        //  We're outside of current character range (but
                        //  still within the grid).  Restore cursor and
                        //  leave magnified character.
                        //
                        if (sycm.fCursorOff)
                        {
                            sycm.fCursorOff = FALSE;
                            ShowCursor(TRUE);
                        }
                    }
                    else
                    {
                        //
                        //  We're in the grid and within the range of currently
                        //  displayed characters, display magnified character.
                        //
                        DOUTL("WM_MOUSEMOVE: in grid and subrange\n");

                        if (!sycm.fCursorOff)
                        {
                            sycm.fCursorOff = TRUE;
                            ShowCursor(FALSE);
                        }
                        DOUTL("WM_MOUSEMOVE: movsymsel ");
                        DOUTCHN( (UTCHAR)chMouseSymbol );
                        MoveSymbolSel(&sycm, (UTCHAR)chMouseSymbol);
                    }
                }
                else
                {
                    //
                    //  Left grid, leave magnified character and restore
                    //  cursor.
                    //
                    if (sycm.fCursorOff)
                    {
                        sycm.fCursorOff = FALSE;
                        ShowCursor(TRUE);
                    }
                }
            }
            DOUTL("WM_MOUSEMOVE: Leaving\n");
            break;
        }
        case ( WM_CANCELMODE ) :
        case ( WM_LBUTTONUP ) :
        {
            if (sycm.fMouseDn)
            {
                ExitMagnify(hWnd, &sycm);
            }
            break;
        }
        case ( WM_LBUTTONDBLCLK ) :
        {
            WCHAR wch = sycm.chCurr;

            //
            //  Send this character to the entry field.
            //
            if (sycm.fAnsiFont)
            {
                wch = ConvertANSIFontToUnicode(hWnd, sycm.hFont, (char)wch);
            }

            SendDlgItemMessage(hwndDialog, ID_STRING, WM_CHAR, (WPARAM)wch, 0L);
            break;
        }
        case ( WM_GETDLGCODE ) :
        {
            //
            //  Necessary to obtain arrow and tab messages.
            //
            return (DLGC_WANTARROWS | DLGC_WANTCHARS);
            break;
        }
        case ( WM_KEYDOWN ) :
        {
            UTCHAR chNew = sycm.chCurr;
            INT cchMoved;

            if (sycm.fMouseDn)
            {
                break;
            }

            switch (wParam)
            {
                case ( VK_LEFT ) :
                {
                    if (--chNew < chSymFirst)
                    {
                        return (0L);
                    }
                    break;
                }
                case ( VK_UP ) :
                {
                    if ((chNew -= cchSymRow) < chSymFirst)
                    {
                        if (!ScrollMap(GetParent(hWnd), -cchSymRow, TRUE))
                        {
                            return (0L);
                        }
                        RestoreSymMag(&sycm);
                    }
                    break;
                }
                case ( VK_RIGHT ) :
                {
                    if (++chNew > chSymLast)
                    {
                        return (0L);
                    }
                    break;
                }
                case ( VK_DOWN ) :
                {
                    if ((chNew += cchSymRow) > chSymLast)
                    {
                        if (!ScrollMap(GetParent(hWnd), cchSymRow, TRUE))
                        {
                            return (0L);
                        }
                        RestoreSymMag(&sycm);
                    }
                    break;
                }
                case ( VK_NEXT ) :
                {
                    if ((cchMoved =
                         ScrollMapPage(GetParent(hWnd), FALSE, TRUE)) == 0)
                    {
                        return (0L);
                    }
                    //
                    //  We scrolled the map!  Bump the char so it is
                    //  still in the window.
                    //
                    RestoreSymMag(&sycm);
                    chNew += cchMoved;
                    break;
                }
                case ( VK_PRIOR ) :
                {
                    if ((cchMoved =
                        ScrollMapPage( GetParent(hWnd), TRUE, TRUE )) == 0)
                    {
                        return (0L);
                    }

                    //
                    //  We scrolled the map!  Bump the char so it is
                    //  still in the window.
                    //
                    RestoreSymMag(&sycm);
                    chNew += cchMoved;
                    break;
                }
                default :
                {
                   return (0L);
                }
            }

            if (!FMagData(&sycm))
            {
                DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, FALSE, FALSE);
            }
            MoveSymbolSel(&sycm, (UTCHAR)chNew);
            break;
        }
        case ( WM_CHAR ) :
        {
            WCHAR wch = (WCHAR)wParam;
            char ch;

            if (sycm.fMouseDn)
            {
                break;
            }
            if (sycm.fAnsiFont)
            {
                if (WideCharToMultiByte( CP_ACP,
                                         0,
                                         &wch,
                                         1,
                                         &ch,
                                         1,
                                         NULL,
                                         NULL ) != 1)
                {
                    break;
                }
                wch = (WCHAR)(BYTE)ch;
            }

            if ((wch >= chSymFirst) && (wch <= chSymLast))
            {
                if (!FMagData(&sycm))
                {
                    DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, FALSE, FALSE);
                }
                MoveSymbolSel(&sycm, (UTCHAR)wch);
                SendDlgItemMessage(hwndDialog, ID_STRING, WM_CHAR, wParam, 0L);
            }
            break;
        }
        case ( WM_PAINT ) :
        {
            HDC hdc;
            PAINTSTRUCT ps;

            DOUTL("WM_PAINT: In\n");

            hdc = BeginPaint(hWnd, &ps);
            DOUTL("WM_PAINT: drawing map\n");
            DrawSymbolMap(&sycm, hdc);
            EndPaint(hWnd, &ps);

            DOUTL("WM_PAINT: Leaving\n");
            return (TRUE);
        }
        default :
        {
            return (DefWindowProc(hWnd, message, wParam, lParam));
        }
    }

    return (0L);
}


////////////////////////////////////////////////////////////////////////////
//
//  ProcessScrollMsg
//
////////////////////////////////////////////////////////////////////////////

VOID ProcessScrollMsg(
    HWND hwndDlg,
    int nCode,
    int nPos)
{
    UTCHAR chNew = sycm.chCurr;
    HWND hwndGrid = GetDlgItem(hwndDlg, ID_CHARGRID);
    int cchScroll;

    switch( nCode )
    {
        case ( SB_LINEUP ) :
        {
            cchScroll = -cchSymRow;
            break;
        }
        case ( SB_LINEDOWN ) :
        {
            cchScroll = cchSymRow;
            break;
        }
        case ( SB_PAGEUP ) :
        {
            cchScroll = (int)TRUE;
            break;
        }
        case ( SB_PAGEDOWN ) :
        {
            cchScroll = (int)FALSE;
            break;
        }
        case ( SB_THUMBTRACK ) :
        case ( SB_THUMBPOSITION ) :
        {
            cchScroll = (nPos * cchSymRow + chRangeFirst) - chSymFirst;
            break;
        }
        default :
        {
            return;
        }
    }

    if (nCode == SB_PAGEUP || nCode == SB_PAGEDOWN)
    {
        if (!ScrollMapPage(hwndDlg, (BOOL)cchScroll, FALSE))
        {
            return;
        }

        //
        //  ScrollMapPage will do the right thing to sycm.chCurr.
        //
        chNew = sycm.chCurr;
    }
    else
    {
        if (cchScroll == 0 || !ScrollMap(hwndDlg, cchScroll, FALSE))
        {
            return;
        }

        //
        //  Keep the current symbol inside the window.
        //
        while (chNew > chSymLast)
        {
            chNew -= cchSymRow;
        }

        while (chNew < chSymFirst)
        {
            chNew += cchSymRow;
        }
    }

#if 0
    if (!FMagData(&sycm))
    {
        DrawSymChOutlineHwnd(&sycm, hwndGrid, sycm.chCurr, FALSE, FALSE);
    }
    MoveSymbolSel(&sycm, (UTCHAR)chNew);
#else
    sycm.chCurr = chNew;
    InvalidateRect(hwndGrid, NULL, TRUE);
#endif
}


////////////////////////////////////////////////////////////////////////////
//
//  ScrollMapPage
//
//  Scrolls the map up or down by a page.  See ScrollMap().
//
////////////////////////////////////////////////////////////////////////////

INT ScrollMapPage(
    HWND hwndDlg,
    BOOL fUp,
    BOOL fRePaint)
{
    INT cchScroll = cchFullMap;

    if (fUp)
    {
        cchScroll = -cchScroll;
    }

    if ((chSymFirst + cchScroll) < chRangeFirst)
    {
        cchScroll = (chRangeFirst - chSymFirst);
    }
    else if ((chSymLast + cchScroll) > chRangeLast)
    {
        cchScroll = (chRangeLast - chSymLast);
    }

    return (ScrollMap(hwndDlg, cchScroll, fRePaint) ? cchScroll : 0);
}


////////////////////////////////////////////////////////////////////////////
//
//  ScrollMap
//
//  Scrolls the map up or down if there are too many chars to fit in the
//  chargrid.
//
////////////////////////////////////////////////////////////////////////////

BOOL ScrollMap(
    HWND hwndDlg,
    INT cchScroll,
    BOOL fRePaint)
{
    HWND hwndSB, hwndCharGrid;
    INT chFirst = chSymFirst + cchScroll;
    INT chLast = chSymLast + cchScroll;
    HDC hdc;

    if ((chFirst < chRangeFirst) || (chLast > chRangeLast))
    {
        return (FALSE);
    }

    hwndCharGrid = GetDlgItem(hwndDlg, ID_CHARGRID);
    hwndSB = GetDlgItem(hwndDlg, ID_MAPSCROLL);
    SetScrollPos(hwndSB, SB_CTL, (chFirst - chRangeFirst) / cchSymRow, TRUE);

    UpdateSymbolRange(hwndDlg, chFirst, chLast);

    if ((hwndDlg != NULL) && ((hdc = GetDC(hwndDlg)) != NULL))
    {
        LPINT lpdxp;
        HFONT hFont;
        UINT ch;

        hFont = SelectObject(hdc, sycm.hFont);
        lpdxp = (LPINT)sycm.rgdxp;

        if (sycm.fAnsiFont)
        {
            GetCharWidth32A(hdc, chSymFirst, chSymLast, lpdxp);
        }
        else
        {
            GetCharWidth32(hdc, chSymFirst, chSymLast, lpdxp);
        }

        SelectObject(hdc, hFont);

        for (ch = (UINT) chSymFirst; ch <= (UINT) chSymLast; ch++, lpdxp++)
        {
            *lpdxp = (sycm.dxpBox - *lpdxp) / 2 - 1;
        }
        ReleaseDC(hwndDlg, hdc);
    }

    if (fRePaint)
    {
        InvalidateRect(hwndCharGrid, NULL, TRUE);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ChFromSymLParam
//
//  Determines the character to select from the mouse position (lParam).
//
////////////////////////////////////////////////////////////////////////////

INT ChFromSymLParam(
    PSYCM psycm,
    LPARAM lParam)
{
    return (min( cchSymRow - 1,
                 max(0, ((INT)LOWORD(lParam) - 1) / psycm->dxpBox) ) +
            min( cchSymCol - 1,
                 max(0, ((INT)HIWORD(lParam) - 1) / psycm->dypBox) ) *
            cchSymRow + chSymFirst);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawSymChOutlineHwnd
//
//  Gets a DC for hwnd, calls DrawSymChOutline.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSymChOutlineHwnd(
    PSYCM psycm,
    HWND hwnd,
    UTCHAR ch,
    BOOL fVisible,
    BOOL fFocus)
{
    HDC hdc = GetDC(hwnd);

    DrawSymChOutline(psycm, hdc, ch, fVisible, fFocus);
    ReleaseDC(hwnd, hdc);
}


////////////////////////////////////////////////////////////////////////////
//
//  RecalcCharMap
//
//  Recalculates fixed character map data (font info, sizes, etc.).
//
////////////////////////////////////////////////////////////////////////////

VOID RecalcCharMap(
    HWND hwndDlg,
    PSYCM psycm,
    INT iCombo,
    BOOL fRedraw)
{
    HDC hdc;
    TEXTMETRIC tm;
    UINT ch;
    LPINT lpdxp;
    HFONT hFont;
    LOGFONT LogFont;
    ITEMDATA ItemData;
    LONG iCurSel;

    //
    //  Get rid of the old font handles.
    //
    if (hFontClipboard && (hFontClipboard == psycm->hFont))
    {
        fDelClipboardFont = TRUE;
    }
    if (psycm->hFont && (hFontClipboard != psycm->hFont))
    {
        DeleteObject(psycm->hFont);
    }
    if (psycm->hFontMag)
    {
        DeleteObject(psycm->hFontMag);
    }

    hdc = GetDC(hwndCharGrid);

    //
    //  Set up the LogFont structure.
    //  Make sure it fits in the grid.
    //
    if (PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())) == LANG_CHINESE)
    {
        LogFont.lfHeight = 16;
    }
    else
    {
        LogFont.lfHeight = psycm->dypBox - 3;    // Allow for whitespace.
    }
    //
    //  Set these to zero.
    //
    LogFont.lfWidth = LogFont.lfEscapement = LogFont.lfOrientation =
                      LogFont.lfWeight = 0;
    LogFont.lfItalic = LogFont.lfUnderline = LogFont.lfStrikeOut =
                       LogFont.lfOutPrecision = LogFont.lfClipPrecision =
                       LogFont.lfQuality = LogFont.lfPitchAndFamily = 0;

    //
    //  Let the facename and size define the font.
    //
    //  LogFont.lfCharSet = DEFAULT_CHARSET;

    //  Work around the GDI bug that assumes the font's default charset
    //  is always the system default locale.
    //
    *(DWORD *)&ItemData = SendDlgItemMessage( hwndDlg,
                                              ID_FONT,
                                              CB_GETITEMDATA,
                                              iCombo,
                                              0L );
    LogFont.lfCharSet = ItemData.CharSet;

    //
    //  Get the facename from the combo box.
    //
    SendDlgItemMessage( hwndDlg,
                        ID_FONT,
                        CB_GETLBTEXT,
                        iCombo,
                        (LONG)(LPTSTR)LogFont.lfFaceName );

    //
    //  Enable Block listbox and set defaults appropriately.
    //
    EnableWindow(GetDlgItem(hwndDlg, ID_UNICODESUBSET), TRUE);
    iCurSel = SendDlgItemMessage( hwndDlg,
                                  ID_UNICODESUBSET,
                                  CB_GETCURSEL,
                                  0,
                                  0L );
    UpdateSymbolSelection( hwndDlg,
                           aSubsetData[iCurSel].BeginRange,
                           aSubsetData[iCurSel].EndRange );
    //
    //  Enable Previous button if not on first subset.
    //
    if (iCurSel > 0)
    {
        EnableWindow(GetDlgItem(hwndDlg, ID_PREVSUBSET), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hwndDlg, ID_PREVSUBSET), FALSE);
    }
    //
    //  Enable Next button if not on last subset.
    //
    if (iCurSel < (cSubsets - 1))
    {
        EnableWindow(GetDlgItem(hwndDlg, ID_NEXTSUBSET), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hwndDlg, ID_NEXTSUBSET), FALSE);
    }

    //
    //  The first sub sel is the ANSI code page.
    //
    psycm->fAnsiFont = (iCurSel == 0);

    //
    //  Create the font.
    //
    psycm->hFont = CreateFontIndirect(&LogFont);
    hFont = SelectObject(hdc, psycm->hFont);

    //
    //  Create the magnify font.
    //
    LogFont.lfHeight = psycm->dypMag - 5;        // Allow for whitespace.
    psycm->hFontMag = CreateFontIndirect(&LogFont);

    //
    //  Calculate new values and place in window data structure.
    //
    GetTextMetrics(hdc, &tm);
    psycm->xpCh = 2;
    psycm->ypCh = (4 + psycm->dypBox - tm.tmHeight) / 2;

    lpdxp = (LPINT)psycm->rgdxp;

    if (psycm->fAnsiFont)
    {
        GetCharWidth32A(hdc, chSymFirst, chSymLast, lpdxp);
    }
    else
    {
        GetCharWidth32(hdc, chSymFirst, chSymLast, lpdxp);
    }

    SelectObject(hdc, hFont);

    for (ch = (UINT) chSymFirst; ch <= (UINT) chSymLast; ch++, lpdxp++)
    {
        *lpdxp = (psycm->dxpBox - *lpdxp) / 2 - 1;
    }
    ReleaseDC(hwndCharGrid, hdc);

    psycm->xpMagCurr = 0;              // No magnification data

    if (fRedraw)
    {
        InvalidateRect(hwndCharGrid, NULL, TRUE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawSymbolMap
//
//  Draws all of the pieces of the symbol character map.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSymbolMap(
    PSYCM psycm,
    HDC hdc)
{
    BOOL fFocus;

    DrawSymbolGrid(psycm, hdc);
    DrawSymbolChars(psycm, hdc);
    //
    //  We need to force the focus rect to paint if we have the focus
    //  since the old focus rect has been drawn over already.
    //
    if (fFocus = psycm->fFocusState)
    {
        psycm->fFocusState = FALSE;
    }
    DrawSymChOutline(psycm, hdc, psycm->chCurr, TRUE, fFocus);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawSymbolGrid
//
//  Draws the symbol character map grid.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSymbolGrid(
    PSYCM psycm,
    HDC hdc)
{
    INT cli;                // count of lines
    INT xp, yp;
    INT dxpBox = psycm->dxpBox;
    INT dypBox = psycm->dypBox;
    HPEN hpenOld;

    hpenOld = SelectObject(hdc, CreatePen( PS_SOLID,
                                           1,
                                           GetSysColor(COLOR_WINDOWFRAME) ));

    //
    //  Draw horizontal lines.
    //
    xp = psycm->dxpCM + 1;
    yp = 1;
    cli = cchSymCol+1;
    while (cli--)
    {
        MoveToEx(hdc, 1, yp, NULL);
        LineTo(hdc, xp, yp);
        yp += dypBox;
    }

    //
    //  Draw vertical lines.
    //
    yp = psycm->dypCM;
    xp = 1;
    cli = cchSymRow+1;
    while (cli--)
    {
        MoveToEx(hdc, xp, 1, NULL);
        LineTo(hdc, xp, yp);
        xp += dxpBox;
    }

    DeleteObject(SelectObject(hdc, hpenOld));
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawSymbolChars
//
//  Draws the symbol character map.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSymbolChars(
    PSYCM psycm,
    HDC hdc)
{
    INT dxpBox = psycm->dxpBox;
    INT dypBox = psycm->dypBox;
    INT cch;
    INT x, y;
    INT yp;
    TCHAR ch;
    HFONT hFontOld;
    RECT rect;
    LPRECT lprect = (LPRECT)&rect;
    LPINT lpdxp;

    //
    //  Setup the font and colors.
    //
    hFontOld = (HFONT)SelectObject(hdc, psycm->hFont);
    SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
    SetBkMode(hdc, OPAQUE);

    //
    //  Draw characters.
    //
    cch = 1;
    ch = chSymFirst;

    lpdxp = (LPINT)psycm->rgdxp;

    rect.top = 2;
    yp = psycm->ypCh;
    rect.bottom = rect.top + dypBox - 1;

    for (y = 0; y++ < cchSymCol;)
    {
        rect.left  = psycm->xpCh;
        rect.right = rect.left + dxpBox - 1;
        for (x = 0; (x++ < cchSymRow) && (ch <= chSymLast);)
        {
            if (psycm->fAnsiFont)
            {
                ExtTextOutA( hdc,
                             rect.left + (*lpdxp++),
                             yp,
                             ETO_OPAQUE | ETO_CLIPPED,
                             lprect,
                             &(CHAR)ch,
                             1,
                             NULL );
            }
            else
            {
                ExtTextOutW( hdc,
                             rect.left + (*lpdxp++),
                             yp,
                             ETO_OPAQUE | ETO_CLIPPED,
                             lprect,
                             &ch,
                             1,
                             NULL );
            }
            ch++;
            rect.left  += dxpBox;
            rect.right += dxpBox;
        }
        yp += dypBox;
        rect.top += dypBox;
        rect.bottom += dypBox;
    }

    SelectObject(hdc, hFontOld);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawSymChOutline
//
//  Draws an outline around the symbol in the character map.  If fVisible,
//  then it draws the outline, otherwise it erases it.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSymChOutline(
    PSYCM psycm,
    HDC hdc,
    UTCHAR ch,
    BOOL fVisible,
    BOOL fFocus)
{
    HBRUSH hbrOld;
    RECT rc;
    INT dxpBox = psycm->dxpBox;
    INT dypBox = psycm->dypBox;

    hbrOld = SelectObject( hdc,
                           CreateSolidBrush(GetSysColor( fVisible
                                                           ? COLOR_WINDOWFRAME
                                                           : COLOR_WINDOW )) );
    ch -= chSymFirst;

    rc.left   = (ch % cchSymRow) * dxpBox + 2;
    rc.right  = rc.left + dxpBox - 1;
    rc.top    = (ch / cchSymRow) * dypBox + 2;
    rc.bottom = rc.top  + dypBox - 1;

    //
    //  Draw selection rectangle.
    //
    PatBlt(hdc, rc.left,      rc.top - 2,    dxpBox - 1, 1,          PATCOPY);
    PatBlt(hdc, rc.left,      rc.bottom + 1, dxpBox - 1, 1,          PATCOPY);
    PatBlt(hdc, rc.left - 2,  rc.top,        1,          dypBox - 1, PATCOPY);
    PatBlt(hdc, rc.right + 1, rc.top,        1,          dypBox - 1, PATCOPY);

    DeleteObject(SelectObject(hdc, GetStockObject(NULL_BRUSH)));

    //
    //  Deal with the focus rectangle.
    //
    if (fFocus != psycm->fFocusState)
    {
        DrawFocusRect(hdc, &rc);
        psycm->fFocusState = fFocus;
    }

    SelectObject(hdc, hbrOld);
}


////////////////////////////////////////////////////////////////////////////
//
//  MoveSymbolSel
//
//  Changes the current symbol selection.  Handles drawing of magnified
//  characters.
//
////////////////////////////////////////////////////////////////////////////

VOID MoveSymbolSel(
    PSYCM psycm,
    UTCHAR chNew)
{
    HDC hdc;
    HDC hdcMag = psycm->hdcMag;
    RECT rc;
    HFONT hFontOld;
    HFONT hFontMag;                    // old font in memory dc
    HPEN hpenOld;
    UTCHAR chNorm = chNew - chSymFirst + 32;
    INT dxpMag = psycm->dxpMag;        // for quick reference
    INT dypMag = psycm->dypMag;
    INT ypMemSrc  = psycm->ypDest;
    INT ypMemDest = ypMemSrc ^ dypMag;
    INT xpCurr  = psycm->xpMagCurr;
    INT ypCurr  = psycm->ypMagCurr;
    INT xpNew   = psycm->xpCM + (psycm->dxpBox *  (chNorm % cchSymRow));
    INT ypNew   = psycm->ypCM + (psycm->dypBox * ((chNorm / cchSymRow) - 1));
    INT dxpCh;  // width of extra character space (used to center char in box)
    INT dypCh;
    SIZE sz;

    DOUTL("MoveSymbolSel: In\n");

    if (((chNew == (UTCHAR)psycm->chCurr) && FMagData(psycm)))
    {
        DOUTL("MoveSymbolSel: ch == cur && fMag... exiting\n");
        return;
    }

    //
    //  Don't draw a magnified character if the char grid has an update
    //  region or is not visible.
    //
    if (!IsWindowVisible(hwndCharGrid) ||
        GetUpdateRect(hwndCharGrid, &rc, FALSE))
    {
        DOUTL("MoveSymbolSel: not vis or upd rect... exiting\n");
        return;
    }

    hdc = GetDC(hwndDialog);

    //
    //  Setup the magnified font character.
    //
    hFontMag = SelectObject(hdcMag, psycm->hFontMag);

    if (psycm->fAnsiFont)
    {
        char chANSINew = (char)chNew;
        GetTextExtentPointA(hdcMag, &chANSINew, 1, &sz);
    }
    else
    {
        GetTextExtentPointW(hdcMag, &chNew, 1, &sz);
    }

    if (PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())) == LANG_CHINESE)
    {
        dxpCh = (dxpMag - (INT)sz.cx) / 2 - 2;
        dypCh = (dypMag - (INT)sz.cy) / 2 - 2;
    }
    else
    {
        dxpCh = (dxpMag - (INT)sz.cx) / 2 - 1;
        dypCh = (dypMag - (INT)sz.cy) / 2 - 1;
    }
    hpenOld = SelectObject(hdc, CreatePen( PS_SOLID,
                                           1,
                                           GetSysColor(COLOR_WINDOWFRAME) ));
    hFontOld = SelectObject(hdc, psycm->hFontMag);

    //
    //  Copy screen data to offscreen bitmap.
    //
    BitBlt(hdcMag, 0, ypMemDest, dxpMag, dypMag, hdc, xpNew, ypNew, SRCCOPY);

    //
    //  Setup DC.
    //
    SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
    SetBkMode(hdc, OPAQUE);

    if (FMagData(psycm))
    {
        INT xpT  = xpNew - xpCurr;     // point of overlap in offscreen data
        INT ypT  = ypNew - ypCurr;
        INT dxpT = dxpMag - abs(xpT);  // size of overlap
        INT dypT = dypMag - abs(ypT);

        DOUTL("MoveSymbolSel: FMagData\n");

        if ((dxpT > 0) && (dypT > 0))
        {
            INT xpTmax,  ypTmax;   // max(0, xpT);
            INT xpTmin,  ypTmin;   // min(0, xpT);
            INT xpTnmin, ypTnmin;  // min(0, -xpT);

            DOUTL("MoveSymbolSel: dxpT > 0 && dypT > 0\n");

            if (xpT < 0)
            {
                xpTnmin = - (xpTmin = xpT);
                xpTmax  = 0;
            }
            else
            {
                xpTmax  = xpT;
                xpTnmin = xpTmin = 0;
            }
            if (ypT < 0)
            {
                ypTnmin = - (ypTmin = ypT);
                ypTmax  = 0;
            }
            else
            {
                ypTmax  = ypT;
                ypTnmin = ypTmin = 0;
            }

            rc.left  = xpTmax;
            rc.right = xpTmin + dxpMag;
            rc.top   = ypTmax + ypMemSrc;
            rc.bottom= ypTmin + dypMag + ypMemSrc;

            //
            //  Copy overlapping offscreen data.
            //
            BitBlt( hdcMag,
                    xpTnmin,
                    ypTnmin + ypMemDest,
                    dxpT,
                    dypT,
                    hdcMag,
                    xpTmax,
                    ypTmax  + ypMemSrc,
                    SRCCOPY );

            //
            //  Print part of char over old screen data.
            //
            if (psycm->fAnsiFont)
            {
                ExtTextOutA( hdcMag,
                             xpT + dxpCh,
                             ypT + dypCh + ypMemSrc,
                             ETO_OPAQUE | ETO_CLIPPED,
                             (LPRECT)&rc,
                             &(CHAR)chNew,
                             1,
                             NULL );
            }
            else
            {
                ExtTextOutW( hdcMag,
                             xpT + dxpCh,
                             ypT + dypCh + ypMemSrc,
                             ETO_OPAQUE | ETO_CLIPPED,
                             (LPRECT)&rc,
                             &chNew,
                             1,
                             NULL );
            }
        }

        //
        //  Restore old screen data.
        //
        BitBlt(hdc, xpCurr, ypCurr, dxpMag, dypMag, hdcMag, 0, ypMemSrc, SRCCOPY);
    }

    rc.right  = (psycm->xpMagCurr = rc.left = xpNew) + dxpMag - 2;
    rc.bottom = (psycm->ypMagCurr = rc.top  = ypNew) + dypMag - 2;

    //
    //  The rectangle.
    //
    MoveToEx(hdc, rc.left, rc.top, NULL);
    LineTo(hdc, rc.left, rc.bottom - 1);
    LineTo(hdc, rc.right - 1, rc.bottom - 1);
    LineTo(hdc, rc.right - 1, rc.top);
    LineTo(hdc, rc.left, rc.top);

    //
    //  The shadow.
    //
    MoveToEx(hdc, rc.right, rc.top + 1, NULL);
    LineTo(hdc, rc.right, rc.bottom);
    LineTo(hdc, rc.left, rc.bottom);
    MoveToEx(hdc, rc.right + 1, rc.top + 2, NULL);
    LineTo(hdc, rc.right + 1, rc.bottom + 1);
    LineTo(hdc, rc.left + 1, rc.bottom + 1);

    rc.left++;
    rc.top++;
    rc.right--;
    rc.bottom--;

    //
    //  Draw magnified character on screen.
    //
    if (psycm->fAnsiFont)
    {
        ExtTextOutA( hdc,
                     xpNew + dxpCh,
                     ypNew + dypCh,
                     ETO_OPAQUE | ETO_CLIPPED,
                     (LPRECT)&rc,
                     &(CHAR)chNew,
                     1,
                     NULL );
    }
    else
    {
        ExtTextOutW( hdc,
                     xpNew + dxpCh,
                     ypNew + dypCh,
                     ETO_OPAQUE | ETO_CLIPPED,
                     (LPRECT)&rc,
                     &chNew,
                     1,
                     NULL );
    }

    psycm->ypDest = ypMemDest;

    DeleteObject(SelectObject(hdc, hpenOld));
    SelectObject(hdc, hFontOld);
    SelectObject(hdcMag, hFontMag);

    UpdateKeystrokeText(hdc, psycm->fAnsiFont, chNew, TRUE);

    ReleaseDC(hwndDialog, hdc);

    psycm->chCurr = chNew;
    DOUTL("MoveSymbolSel: Leaving\n");
}


////////////////////////////////////////////////////////////////////////////
//
//  RestoreSymMag
//
//  Restores the screen data under the magnifier.
//
////////////////////////////////////////////////////////////////////////////

VOID RestoreSymMag(
    PSYCM psycm)
{
    if (FMagData(psycm))
    {
        HDC hdc = GetDC(hwndDialog);

        BitBlt( hdc,
                psycm->xpMagCurr,
                psycm->ypMagCurr,
                psycm->dxpMag,
                psycm->dypMag,
                psycm->hdcMag,
                0,
                psycm->ypDest,
                SRCCOPY );

        ReleaseDC(hwndDialog, hdc);

        psycm->xpMagCurr = 0;     // flag - no data offscreen (see FMagData)
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  FontLoadProc
//
//  Used by EnumFonts to load our combo box with all the fonts installed
//  in the system.
//
////////////////////////////////////////////////////////////////////////////

INT APIENTRY FontLoadProc(
    LPLOGFONT lpLogFont,
    NEWTEXTMETRICEX* lpTextMetric,
    DWORD nFontType,
    LPARAM lpData)
{
    INT iPos;
    TCHAR szFace[LF_FACESIZE];

    //
    //  Check for duplicates.
    //
    iPos = (INT)SendDlgItemMessage( (HWND)lpData,
                                    ID_FONT,
                                    CB_FINDSTRING,
                                    (WPARAM)-1,
                                    (DWORD)&lpLogFont->lfFaceName );
    if (iPos == CB_ERR)
    {
NotInListYet:
        //
        //  Doesn't exist, insert the facename into the combo box.
        //
        iPos = (INT)SendDlgItemMessage( (HWND)lpData,
                                        ID_FONT,
                                        CB_ADDSTRING,
                                        0,
                                        (DWORD)&lpLogFont->lfFaceName );
    }
    else
    {
        //
        //  Make sure it is not just a substring (want a full match).
        //
        SendDlgItemMessage( (HWND)lpData,
                            ID_FONT,
                            CB_GETLBTEXT,
                            iPos,
                            (LONG)(LPTSTR)szFace );
        if (lstrcmpi(szFace, lpLogFont->lfFaceName))
        {
            goto NotInListYet;
        }

        //
        //  Already exists, blow out now if this is not a true type font.
        //
        if (!(nFontType & TRUETYPE_FONTTYPE))
        {
            return (1);
        }
    }

    //
    //  Store the pertinant font information in the combo item data.
    //
    if ((iPos != CB_ERR) && (iPos != CB_ERRSPACE))
    {
        ITEMDATA ItemData;
        DWORD   ntmFlags = lpTextMetric->ntmTm.ntmFlags;
        SHORT   sFontType = 0;

        if (ntmFlags & NTM_PS_OPENTYPE)
        {
            sFontType = PS_OPENTYPE_FONT;
        }
        else if (ntmFlags & NTM_TYPE1)
        {
            sFontType = TYPE1_FONT;
        }
        else if (nFontType & TRUETYPE_FONTTYPE)
        {
            if (ntmFlags & NTM_TT_OPENTYPE)
                sFontType = TT_OPENTYPE_FONT;
            else
                sFontType = TRUETYPE_FONT;
        }

        ItemData.FontType = sFontType;
        ItemData.CharSet = lpLogFont->lfCharSet;
        ItemData.PitchAndFamily = lpLogFont->lfPitchAndFamily;

        SendDlgItemMessage( (HWND)lpData,
                            ID_FONT,
                            CB_SETITEMDATA,
                            iPos,
                            *(DWORD *)&ItemData );
    }

    //
    //  Continue enumeration.
    //
    return (1);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetEditText
//
//  Returns HANDLE containing the text in the edit control.
//
//  NOTE: Caller is responsible for freeing this handle!
//
////////////////////////////////////////////////////////////////////////////

HANDLE GetEditText(
    HWND hwndDlg)
{
    INT cchText;
    HWND hwndEditCtl;
    HANDLE hmem;
    LPTSTR lpstrText;
    DWORD dwSel;

    hwndEditCtl = GetDlgItem(hwndDlg, ID_STRING);

    cchText = GetWindowTextLength(hwndEditCtl);

    hmem = GlobalAlloc(0, CTOB((cchText + 1)));

    lpstrText = (LPTSTR)GlobalLock(hmem);

    cchText = GetWindowText(hwndEditCtl, lpstrText, cchText+1);

    dwSel = SendMessage(hwndEditCtl, EM_GETSEL, 0, 0L);

    if (LOWORD(dwSel) != HIWORD(dwSel))
    {
        //
        //  If there is a selection, then only get the selected text.
        //
        *(lpstrText + HIWORD(dwSel)) = TEXT('\0');
        lstrcpy(lpstrText, lpstrText + LOWORD(dwSel));
    }

    GlobalUnlock(hmem);

    if (cchText == 0)
    {
        hmem = GlobalFree(hmem);
    }

    return (hmem);
}


////////////////////////////////////////////////////////////////////////////
//
//  CopyString
//
//  Implements the copy function.
//
////////////////////////////////////////////////////////////////////////////

VOID CopyString(
    HWND hwndDlg)
{
    HANDLE hmem;
    LPTSTR lpstrText;

    if (hmem = GetEditText(hwndDlg))
    {
        lpstrText = (LPTSTR)GlobalLock(hmem);

        //
        //  Copying string to clipboard.
        //
        if (OpenClipboard(hwndDlg))
        {
            EmptyClipboard();
            SendRTFToClip(hwndDlg, lpstrText);
#ifdef UNICODE
            SetClipboardData(CF_UNICODETEXT, hmem);
#else
            SetClipboardData(CF_TEXT, hmem);
#endif
            CloseClipboard();
        }
        else
        {
            //
            //  If we couldn't open the clipboard, then we need to free memory.
            //
            GlobalUnlock(hmem);
            GlobalFree(hmem);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  SendRTFToClip
//
//  Puts the string in the clipboard using Rich Text Format.  This assumes
//  that the clipboard has already been opened.
//
////////////////////////////////////////////////////////////////////////////

VOID SendRTFToClip(
    HWND hwndDlg,
    LPTSTR lpstrText)
{
    INT iCurrFont;
    ITEMDATA ItemData;
    TCHAR szFaceName[LF_FACESIZE];
    HANDLE hmemRTF, hmemClip;
    LPTSTR lpstrClipString;
    TCHAR achHeaderTmpl[] = TEXT("{\\rtf1\\ansi\\ansicpg%d {\\fonttbl{\\f0\\");
    TCHAR achHeader[sizeof(achHeaderTmpl) / sizeof(TCHAR) + 20];
    TCHAR achMiddle[] = TEXT(";}}\\sectd\\pard\\plain\\f0 ");
    INT cchUC;
#ifndef UNICODE_RTF
    LPWSTR pszRTFW;
#endif


    #define MAXLENGTHFONTFAMILY 8
    #define ALITTLEEXTRA 10    // covers extra characters + length of font size

    iCurrFont = (INT)SendDlgItemMessage(hwndDlg, ID_FONT, CB_GETCURSEL, 0, 0L);

    //
    //  Get the item data - contains fonttype, charset, and pitchandfamily.
    //
    *(DWORD *)&ItemData = SendDlgItemMessage( hwndDlg,
                                              ID_FONT,
                                              CB_GETITEMDATA,
                                              iCurrFont,
                                              0L );

    //
    //  Get the facename from the combo box.
    //
    SendDlgItemMessage( hwndDlg,
                        ID_FONT,
                        CB_GETLBTEXT,
                        iCurrFont,
                        (LPARAM)(LPTSTR)szFaceName );

    wsprintf(achHeader, achHeaderTmpl, (INT)(SHORT)GetACP());

    //
    //  16 times in case they're all > 7 bits (each chr -> \uc1\uddddddd\'xx)
    //  and room for the second byte of DBCS.
    //
    hmemRTF = GlobalAlloc( 0,
                           CTOB(lstrlen((LPTSTR)achHeader) +
                                  MAXLENGTHFONTFAMILY +
                                  lstrlen(szFaceName) +
                                  lstrlen((LPTSTR)achMiddle) +
                                  2 * 16 * lstrlen(lpstrText) +
                                  ALITTLEEXTRA) );
    if (hmemRTF == NULL)
    {
        return;
    }

    //
    //  Allocate memory for local storage of clipboard string for owner draw.
    //
    if (hmemClip  = GlobalAlloc(0, CTOB(lstrlen(lpstrText) + 1)))
    {
        //
        //  Get rid of old ones.
        //
        if (hstrClipboard)
        {
            GlobalFree(hstrClipboard);
        }
        if (fDelClipboardFont)
        {
            fDelClipboardFont = FALSE;
            DeleteObject(hFontClipboard);
        }

        //
        //  Save this stuff away for owner drawing in a clipboard viewer.
        //
        hFontClipboard = sycm.hFont;
        hstrClipboard = hmemClip;
        lstrcpy(GlobalLock(hstrClipboard), lpstrText);
        GlobalUnlock(hstrClipboard);
    }
    else
    {
        GlobalFree(hmemRTF);
        return;
    }

    lpstrClipString = GlobalLock(hmemRTF);
#ifndef UNICODE_RTF
    pszRTFW = lpstrClipString;
#endif

    lstrcpy(lpstrClipString, achHeader);

    if (ItemData.CharSet == SYMBOL_CHARSET)
    {
        lstrcat(lpstrClipString, (LPTSTR)TEXT("ftech "));
    }
    else
    {
        //
        //  Top four bits specify family.
        //
        switch (ItemData.PitchAndFamily & 0xf0)
        {
            case ( FF_DECORATIVE ) :
            {
                lstrcat(lpstrClipString, (LPTSTR)TEXT("fdecor "));
                break;
            }
            case ( FF_MODERN ) :
            {
                lstrcat(lpstrClipString, (LPTSTR)TEXT("fmodern "));
                break;
            }
            case ( FF_ROMAN ) :
            {
                lstrcat(lpstrClipString, (LPTSTR)TEXT("froman "));
                break;
            }
            case ( FF_SCRIPT ) :
            {
                lstrcat(lpstrClipString, (LPTSTR)TEXT("fscript "));
                break;
            }
            case ( FF_SWISS ) :
            {
                lstrcat(lpstrClipString, (LPTSTR)TEXT("fswiss "));
                break;
            }
            default :
            {
                break;
            }
        }
    }

    lstrcat(lpstrClipString, szFaceName);

    lstrcat(lpstrClipString, (LPTSTR)achMiddle);

    //
    //  We need to do the text character by character, making sure
    //  that we output a special sequence \'hh for characters bigger
    //  than 7 bits long!
    //
    lpstrClipString = (LPTSTR)(lpstrClipString + lstrlen(lpstrClipString));

    cchUC = 0;

    while (*lpstrText)
    {
        if ((UTCHAR)*lpstrText < 128)
        {
            if (*lpstrText == TEXT('\\') ||
                *lpstrText == TEXT('{')  ||
                *lpstrText == TEXT('}'))
            {
                //
                //  Need to preface these symbols with a '\' since they are
                //  special control characters for RTF.
                //
                *lpstrClipString++ = TEXT('\\');
            }

            *lpstrClipString++ = *lpstrText++;
        }
        else
        {
            unsigned char achTmp[2];
            unsigned char *pTmp = achTmp;
            int cch;

            cch = WideCharToMultiByte( CP_ACP,
                                       0,
                                       lpstrText,
                                       1,
                                       pTmp,
                                       2,
                                       NULL,
                                       NULL );

            //
            // Put in a \uc# to tell Unicode reader how many bytes to skip
            // and the \uN code to indicate the real unicode value.
            //
            if (cch != cchUC )
            {
                cchUC = cch;
                lpstrClipString += wsprintf( lpstrClipString,
                                             TEXT("\\uc%d"),
                                             (INT)(SHORT)cchUC );
            }

            lpstrClipString += wsprintf( lpstrClipString,
                                         TEXT("\\u%d"),
                                         (INT)(SHORT)*lpstrText );

            //
            //  Now put the \'xx string in to indicate the actual character.
            //
            lpstrText++;
            while (cch--)
            {
                *lpstrClipString++ = TEXT('\\');
                *lpstrClipString++ = TEXT('\'');
                wsprintf(achMiddle, TEXT("%x"), (INT)*pTmp++);
                *lpstrClipString++ = achMiddle[0];
                *lpstrClipString++ = achMiddle[1];
            }
        }
    }
    *lpstrClipString++ = TEXT('}');
    *lpstrClipString++ = TEXT('\0');

    if (!wCFRichText)
    {
         TCHAR szRTF[80];

         LoadString(hInst, IDS_RTF, szRTF, BTOC(sizeof(szRTF)) - 1);
         wCFRichText = RegisterClipboardFormat(szRTF);
    }

#ifndef UNICODE_RTF
    {
        //
        //  RTF is only defined for ANSI, not for Unicode, therefore
        //  we need to convert the buffer before we put it on the
        //  clipboard.  Eventually, we should add autoconversion code
        //  to USER to handle this for us.
        //
        int cch;
        HANDLE hmemRTFA;
        LPSTR pszRTFA;

        cch = WideCharToMultiByte( CP_ACP,
                                   0,
                                   pszRTFW,
                                   lpstrClipString - pszRTFW,
                                   NULL,
                                   0,
                                   NULL,
                                   NULL );

        if (cch != 0 &&
            (hmemRTFA = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,cch)) != NULL)
        {
            pszRTFA = GlobalLock(hmemRTFA);

            WideCharToMultiByte( CP_ACP,
                                 0,
                                 pszRTFW,
                                 lpstrClipString - pszRTFW,
                                 pszRTFA,
                                 cch,
                                 NULL,
                                 NULL );

            GlobalUnlock(hmemRTFA);
            GlobalUnlock(hmemRTF);
            GlobalFree(hmemRTF);

            hmemRTF = hmemRTFA;
        }
    }
#endif

    //
    //  Put RTF and OwnerDisplay formats in the clipboard.
    //
    SetClipboardData(wCFRichText, hmemRTF);
    SetClipboardData(CF_OWNERDISPLAY, NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  PointsToHeight
//
//  Calculates the height in pixels of the specified point size for the
//  current display.
//
////////////////////////////////////////////////////////////////////////////

INT PointsToHeight(
    INT iPoints)
{
    HDC hdc;
    INT iHeight;

    hdc = GetDC(HWND_DESKTOP);
    iHeight = MulDiv(iPoints, GetDeviceCaps(hdc, LOGPIXELSY), 72);
    ReleaseDC(HWND_DESKTOP, hdc);
    return (iHeight);
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateKeystrokeText
//
//  Calculates and updates the text string displayed in the Keystroke
//  field of the status bar.  It repaints the status field if fRedraw is
//  TRUE.
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateKeystrokeText(
    HDC hdc,
    BOOL fANSI,
    UTCHAR chNew,
    BOOL fRedraw)
{
    TCHAR szUnshifted[CCH_KEYNAME];
    INT vkRes;
    LONG lParam;

    if (!fANSI)
    {
        lstrcpy(szKeystrokeText, szUnicodeLabel);
        wsprintf( (LPTSTR)(szKeystrokeText + iUnicodeLabelStart),
                  TEXT("%04x"),
                  chNew );
    }
    else
    {
        lstrcpy(szKeystrokeText, szKeystrokeLabel);
        vkRes = VkKeyScan(chNew);
        //
        //  Map the virtual key code into an unshifted character value.
        //
        lParam = MapVirtualKey(LOBYTE(vkRes), 0) << 16;
        GetKeyNameText(lParam, szUnshifted, CCH_KEYNAME - 1);

        switch (HIBYTE(vkRes))
        {
            case ( 0 ) : // unshifted char
            case ( 1 ) : // character is shifted, just display the shifted char
            {
                if (chNew != TEXT(' '))
                {
                    szKeystrokeText[iKeystrokeTextStart] = chNew;
                    szKeystrokeText[iKeystrokeTextStart + 1] = TEXT('\0');
                }
                else
                {
                    lstrcat(szKeystrokeText, szUnshifted);
                }
                break;
            }
            case ( 2 ) : // character is control character
            {
                lstrcpy((LPTSTR)(szKeystrokeText + iKeystrokeTextStart), szCtrl);
                lstrcat(szKeystrokeText, (LPTSTR)szUnshifted);
                break;
            }
            case ( 6 ) : // character is CONTROL+ALT
            {
                lstrcpy((LPTSTR)(szKeystrokeText + iKeystrokeTextStart), szCtrlAlt);
                lstrcat(szKeystrokeText, (LPTSTR)szUnshifted);
                break;
            }
            case ( 7 ) : // character is SHIFT+CONTROL+ALT
            {
                lstrcpy((LPTSTR)(szKeystrokeText + iKeystrokeTextStart), szShiftCtrlAlt);
                lstrcat(szKeystrokeText, (LPTSTR)szUnshifted);
                break;
            }
            default : // Character created via Alt + Numpad
            {
                lstrcpy((LPTSTR)(szKeystrokeText + iKeystrokeTextStart), szAlt);
                wsprintf( (LPTSTR)(szKeystrokeText + lstrlen(szKeystrokeText)),
                          TEXT("%d"),
                          chNew );
                break;
            }
        }
    }

    if (fRedraw)
    {
        PaintStatusLine(hdc, FALSE, TRUE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateHelpText
//
//  Calculates if the Help string needs to be updated, and does so if
//  necessary.
//
//  If hwndCtrl is not NULL, then it specifies the window handle of the
//  control gaining focus, and lpmsg is ignored.
//
//  If hwndCtrl is NULL, then lpmsg must point to a valid message structure.
//  If it is a tab character, then we calculate what the next control is
//  that will receive the focus.
//
////////////////////////////////////////////////////////////////////////////

BOOL UpdateHelpText(
    LPMSG lpmsg,
    HWND hwndCtrl)
{
    HDC hdc;
    BOOL fPaintStatus = FALSE;
    BOOL fRet = TRUE;

    DPRINT((szDbgBuf, TEXT("UpdHlpTxt: lpmsg:0x%08lX, hwnd:0x%08lX\n"), (DWORD)lpmsg, (DWORD)hwndCtrl));

    if (hwndCtrl != NULL)
    {
        fPaintStatus = TRUE;
        iControl = GetDlgCtrlID(hwndCtrl);
    }
    else if (lpmsg->message == WM_KEYDOWN)
    {
        if (lpmsg->wParam == VK_TAB)
        {
            fPaintStatus = TRUE;
            hwndCtrl = GetNextDlgTabItem( hwndDialog,
                                          GetDlgItem(hwndDialog, iControl),
                                          (BOOL)(GetKeyState(VK_SHIFT) & 0x8000) );
            iControl = GetDlgCtrlID(hwndCtrl);
            if (iControl == ID_STRING)
            {
                //
                //  Do this ourselves, otherwise default action will select
                //  the whole edit control.
                //
                SetFocus(hwndCtrl);
                fRet = FALSE;
            }
            if (iControl == ID_CHARGRID)
            {
                //
                //  Set the default button back to "Select".  The default
                //  might have changed to the "Next" or "Previous" button.
                //
                SendMessage(hwndDialog, DM_SETDEFID, ID_SELECT, 0);
            }
        }
        else if (lpmsg->wParam == VK_F1)
        {
            PostMessage(hwndDialog, WM_COMMAND, ID_HELP, 0L);
        }
    }

    if (fPaintStatus)
    {
        hdc = GetDC(hwndDialog);
        PaintStatusLine(hdc, TRUE, FALSE);
        ReleaseDC(hwndDialog, hdc);
    }

    return (fRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  SubSetChanged
//
//  Sets the ANSI bit if appropriate and then calls UpdateSymbolSelection
//  and then repaints the window.
//
//  Repaints Keystroke field if HWND != NULL.
//  Sets sycm->fAnsiFont if 'Windows Chars' is the subset.
//  Redraws the char grid.
//
////////////////////////////////////////////////////////////////////////////

VOID SubSetChanged(
    HWND hwnd,
    INT iSubSet,
    INT ichFirst,
    INT ichLast)
{
    HDC hdc;
    BOOL fANSI = (iSubSet == 0);

    if (fANSI != sycm.fAnsiFont)
    {
        sycm.fAnsiFont = fANSI;
    }

    UpdateSymbolSelection(hwnd, ichFirst, ichLast);

    if ((hwnd != NULL) && ((hdc = GetDC(hwnd)) != NULL))
    {
        LPINT lpdxp;
        HFONT hFont;
        UINT ch;

        hFont = SelectObject(hdc, sycm.hFont);
        lpdxp = (LPINT)sycm.rgdxp;

        if (iSubSet == 0)
        {
            GetCharWidth32A(hdc, chSymFirst, chSymLast, lpdxp);
        }
        else
        {
            GetCharWidth32(hdc, chSymFirst, chSymLast, lpdxp);
        }

        SelectObject(hdc, hFont);

        for (ch = (UINT) chSymFirst; ch <= (UINT) chSymLast; ch++, lpdxp++)
        {
            *lpdxp = (sycm.dxpBox - *lpdxp) / 2 - 1;
        }
        ReleaseDC(hwnd, hdc);
    }

    InvalidateRect(hwndCharGrid, NULL, TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateSymbolSelection
//
//  Updates the values of the following global values:
//      chRangeFirst
//      chRangeLast
//  Subsets in the Unicode character set have different numbers of
//  characters.  We have to do some bounds checking in order to set an
//  appropriate sycm.chCurr value.  The "Keystroke" status field is
//  updated.
//
//  Repaints Keystroke field if HWND != NULL.
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateSymbolSelection(
    HWND hwnd,
    INT FirstChar,
    INT LastChar)
{
    int iCmd = SW_HIDE;
    HWND hwndSB;
    UINT chFirst, chLast;

    chRangeFirst = FirstChar;
    chRangeLast = LastChar;

    chFirst = chRangeFirst;

    chLast = chFirst + cchFullMap - 1;
    chLast = min(chLast, chRangeLast);

    hwndSB = GetDlgItem(hwnd, ID_MAPSCROLL);

    if (chLast != chRangeLast)
    {
        int i;

        iCmd = SW_SHOW;
        SetScrollPos(hwndSB, SB_CTL, 0, FALSE);
        i = (chRangeLast - chRangeFirst + 1) - cchFullMap;

        if (i < 0)
        {
            i = 1;
        }
        else
        {
            i = i / cchSymRow;
        }

        SetScrollRange(hwndSB, SB_CTL, 0, i, FALSE);
        InvalidateRect(hwndSB, NULL, FALSE);
    }

    ShowWindow(hwndSB, iCmd);

    UpdateSymbolRange(hwnd, chFirst, chLast);
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateSymbolRange
//
//  Updates the values of the following global values:
//      chSymFirst
//      chSymLast
//      sycm.chCurr
//  Subsets in the Unicode character set have different numbers of
//  characters.  We have to do some bounds checking in order to set an
//  appropriate sycm.chCurr value.  The "Keystroke" status field is
//  updated.
//
//  Repaints Keystroke field if HWND != NULL.
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateSymbolRange(
    HWND hwnd,
    INT FirstChar,
    INT LastChar)
{
    UTCHAR chSymOffset;

    chSymOffset = sycm.chCurr - chSymFirst;

    chSymFirst = FirstChar;
    chSymLast = LastChar;

    sycm.chCurr = chSymOffset + chSymFirst;
    if (sycm.chCurr > chSymLast)
    {
        sycm.chCurr = chSymFirst;
    }
    if (hwnd != NULL)
    {
        HDC hdc;

        hdc = GetDC(hwnd);
        UpdateKeystrokeText(hdc, sycm.fAnsiFont, sycm.chCurr, TRUE);
        ReleaseDC(hwnd, hdc);
    }
    else
    {
        UpdateKeystrokeText(NULL, sycm.fAnsiFont, sycm.chCurr, FALSE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PaintStatusLine
//
//  Paints the Help and Keystroke fields in the status bar.
//
//  Repaints Help field if fHelp == TRUE.
//  Repaints Keystroke field if fKeystroke == TRUE.
//
////////////////////////////////////////////////////////////////////////////

VOID PaintStatusLine(
    HDC hdc,
    BOOL fHelp,
    BOOL fKeystroke)
{
    HFONT hfontOld = NULL;
    RECT rect;
    INT dyBorder;
    TCHAR szHelpText[100];

    dyBorder = GetSystemMetrics(SM_CYBORDER);

    if (hfontStatus)
    {
        hfontOld = SelectObject(hdc, hfontStatus);
    }

    //
    //  Set the text and background colors.
    //
    SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));
    SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));

    if (fHelp)
    {
        //
        //  Now the help text, with a gray background.
        //
        rect.top    = rcStatusLine.top + 3 * dyBorder;
        rect.bottom = rcStatusLine.bottom - 3 * dyBorder;
        rect.left   = 9 * dyBorder;
        rect.right  = rect.left + dxHelpField - 2 * dyBorder;

        LoadString(hInst, iControl, szHelpText, BTOC(sizeof(szHelpText)) - 1);

        ExtTextOut( hdc,
                    rect.left + dyBorder * 2,
                    rect.top,
                    ETO_OPAQUE | ETO_CLIPPED,
                    &rect,
                    szHelpText,
                    lstrlen(szHelpText),
                    NULL );
    }

    if (fKeystroke)
    {
        //
        //  Now the keystroke text, with a gray background.
        //
        rect.top    = rcStatusLine.top + 3 * dyBorder;
        rect.bottom = rcStatusLine.bottom - 3 * dyBorder;
        rect.right = rcStatusLine.right - 9 * dyBorder;
        rect.left = rect.right - dxKeystrokeField + 2 * dyBorder;

        ExtTextOut( hdc,
                    rect.left + dyBorder * 2,
                    rect.top,
                    ETO_OPAQUE | ETO_CLIPPED,
                    &rect,
                    szKeystrokeText,
                    lstrlen(szKeystrokeText),
                    NULL );
    }

    if (hfontOld)
    {
        SelectObject(hdc, hfontOld);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawFamilyComboItem
//
//  Paints the font facenames and TT bitmap in the font combo box.
//
////////////////////////////////////////////////////////////////////////////

BOOL DrawFamilyComboItem(
    LPDRAWITEMSTRUCT lpdis)
{
    HDC hDC, hdcMem;
    DWORD rgbBack, rgbText;
    TCHAR szFace[LF_FACESIZE];
    HBITMAP hOld;
    INT dy;
    SHORT   sFontType;

    hDC = lpdis->hDC;

    if (lpdis->itemState & ODS_SELECTED)
    {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    }
    else
    {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    }

    SendMessage( lpdis->hwndItem,
                 CB_GETLBTEXT,
                 lpdis->itemID,
                 (LONG)(LPTSTR)szFace );
    ExtTextOut( hDC,
                lpdis->rcItem.left + DX_BITMAP,
                lpdis->rcItem.top,
                ETO_OPAQUE | ETO_CLIPPED,
                &lpdis->rcItem,
                szFace,
                lstrlen(szFace),
                NULL );

    hdcMem = CreateCompatibleDC(hDC);
    if (hdcMem)
    {
        if (hbmFont)
        {
            hOld = SelectObject(hdcMem, hbmFont);
            sFontType = ((ITEMDATA FAR *)&(lpdis->itemData))->FontType;

            if (sFontType)
            {

                int xSrc;
                dy = ((lpdis->rcItem.bottom - lpdis->rcItem.top) - DY_BITMAP) / 2;

                if (sFontType & TRUETYPE_FONT)
                    xSrc = 0;
                else if (sFontType & TT_OPENTYPE_FONT)
                    xSrc = 2;
                else if(sFontType & PS_OPENTYPE_FONT)
                    xSrc = 3;
                else if (sFontType & TYPE1_FONT)
                    xSrc = 4;

                BitBlt( hDC,
                        lpdis->rcItem.left,
                        lpdis->rcItem.top + dy,
                        DX_BITMAP,
                        DY_BITMAP,
                        hdcMem,
                        xSrc * DX_BITMAP,
                        lpdis->itemState & ODS_SELECTED ? DY_BITMAP : 0,
                        SRCCOPY );
            }
            SelectObject(hdcMem, hOld);
        }
        DeleteDC(hdcMem);
    }

    SetTextColor(hDC, rgbText);
    SetBkColor(hDC, rgbBack);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  LoadBitmaps
//
//  Loads DIB bitmaps and "fixes up" their color tables so that we get the
//  desired result for the device we are on.
//
//  This routine requires:
//    - the DIB is a 16 color DIB authored with the standard windows colors
//    - bright blue (00 00 FF) is converted to the background color
//    - light grey  (C0 C0 C0) is replaced with the button face color
//    - dark grey   (80 80 80) is replaced with the button shadow color
//
//  This means you can't have any of these colors in your bitmap.
//
////////////////////////////////////////////////////////////////////////////

HBITMAP LoadBitmaps(
    INT id)
{
    HDC hdc;
    HANDLE h, hRes;
    DWORD *p;
    LPBYTE lpBits;
    LPBITMAPINFOHEADER lpBitmapInfo;
    INT numcolors;
    DWORD rgbSelected, rgbUnselected;
    HBITMAP hbm;

    rgbSelected = GetSysColor(COLOR_HIGHLIGHT);
    //
    //  Flip the colors.
    //
    rgbSelected = RGB( GetBValue(rgbSelected),
                       GetGValue(rgbSelected),
                       GetRValue(rgbSelected) );
    rgbUnselected = GetSysColor(COLOR_WINDOW);
    //
    //  Flip the colors.
    //
    rgbUnselected = RGB( GetBValue(rgbUnselected),
                         GetGValue(rgbUnselected),
                         GetRValue(rgbUnselected) );

    h = FindResource(hInst, MAKEINTRESOURCE(id), RT_BITMAP);
    hRes = LoadResource(hInst, h);

    //
    //  Lock the bitmap and get a pointer to the color table.
    //
    lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hRes);

    if (!lpBitmapInfo)
    {
        return (FALSE);
    }

    p = (DWORD *)((LPSTR)(lpBitmapInfo) + lpBitmapInfo->biSize);

    //
    //  Search for the Solid Blue entry and replace it with the current
    //  background RGB.
    //
    numcolors = 16;

    while (numcolors-- > 0)
    {
        if (*p == BACKGROUND)
        {
            *p = rgbUnselected;
        }
        else if (*p == BACKGROUNDSEL)
        {
            *p = rgbSelected;
        }
        p++;
    }
    UnlockResource(hRes);

    //
    //  Now create the DIB.
    //
    lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hRes);

    //
    //  First skip over the header structure.
    //
    lpBits = (LPBYTE)(lpBitmapInfo + 1);

    //
    //  Skip the color table entries, if any.
    //
    lpBits += (1 << (lpBitmapInfo->biBitCount)) * sizeof(RGBQUAD);

    //
    //  Create a color bitmap compatible with the display device.
    //
    hdc = GetDC(NULL);
    hbm = CreateDIBitmap( hdc,
                          lpBitmapInfo,
                          (DWORD)CBM_INIT,
                          lpBits,
                          (LPBITMAPINFO)lpBitmapInfo,
                          DIB_RGB_COLORS );
    ReleaseDC(NULL, hdc);

    GlobalUnlock(hRes);
    FreeResource(hRes);

    return (hbm);
}


////////////////////////////////////////////////////////////////////////////
//
//  DoHelp
//
//  Invokes help if fInvokeHelp is true, or dismisses help if fInvokeHelp
//  is FALSE.
//
////////////////////////////////////////////////////////////////////////////

VOID DoHelp(
    HWND hWnd,
    BOOL fInvokeHelp)
{
    TCHAR szHelp[80];

    if (LoadString(hInst, IDS_HELP, szHelp, BTOC(sizeof(szHelp)) - 1))
    {
        if (fInvokeHelp)
        {
			// APPCOMPAT: an error in HtmlHelp prevents the unicode version from working
			// This is a HACK to get around the problem.  Remove this hack when the problem is fixed.
            HtmlHelpA(GetDesktopWindow(), "charmap.chm", HH_DISPLAY_TOPIC, 0L);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  SaveFont
//
//  Saves the current font facename in win.ini, so that it can be selected
//  the next time charmap comes up.
//
////////////////////////////////////////////////////////////////////////////

VOID SaveCurrentFont(
    HWND hWndDlg)
{
    TCHAR szFaceName[LF_FACESIZE] = TEXT("");

    SendDlgItemMessage( hWndDlg,
                        ID_FONT,
                        CB_GETLBTEXT,
                        (WORD)SendDlgItemMessage( hWndDlg,
                                                  ID_FONT,
                                                  CB_GETCURSEL,
                                                  0,
                                                  0L ),
                        (LONG)(LPTSTR)szFaceName );

    WriteProfileString(TEXT("MSCharMap"), TEXT("Font"), (LPTSTR)szFaceName);
}


////////////////////////////////////////////////////////////////////////////
//
//  SelectInitialFont
//
//  Selects the initial font by getting a saved facename from win.ini and
//  selecting it in the combo box.
//
//  Returns index to font selected.
//
////////////////////////////////////////////////////////////////////////////

INT SelectInitialFont(
    HWND hWndDlg)
{
    TCHAR szFaceName[LF_FACESIZE] = TEXT("");
    INT iIndex;

    if ((GetProfileString( TEXT("MSCharMap"),
                           TEXT("Font"),
                           NULL,
                           (LPTSTR)szFaceName,
                           BTOC(sizeof(szFaceName)) ) == 0) ||
        ((iIndex = (INT)SendDlgItemMessage( hWndDlg,
                                            ID_FONT,
                                            CB_SELECTSTRING,
                                            (WPARAM)-1,
                                            (LONG)(LPTSTR)szFaceName )) == CB_ERR))
    {
        //
        //  If there was no profile or the selection failed then try selecting
        //  the symbol font, if that fails then select the first one.
        //
        if ((iIndex = (INT)SendDlgItemMessage( hWndDlg,
                                               ID_FONT,
                                               CB_SELECTSTRING,
                                               (WPARAM)-1,
                                               (LONG)(LPTSTR)TEXT("Symbol") )) == CB_ERR)
        {
            SendDlgItemMessage(hWndDlg, ID_FONT, CB_SETCURSEL, iIndex = 0, 0L);
        }
    }

    return (iIndex);
}


////////////////////////////////////////////////////////////////////////////
//
//  SaveCurrentSubset
//
//  Saves the current subset name in win.ini, so that it can be selected
//  the next time charmap comes up.
//
////////////////////////////////////////////////////////////////////////////

VOID SaveCurrentSubset(
    HWND hWndDlg)
{
    TCHAR szSubsetName[LF_SUBSETSIZE] = TEXT("");

    SendDlgItemMessage( hWndDlg,
                        ID_UNICODESUBSET,
                        CB_GETLBTEXT,
                        (WORD)SendDlgItemMessage( hWndDlg,
                                                  ID_UNICODESUBSET,
                                                  CB_GETCURSEL,
                                                  0,
                                                  0L ),
                        (LONG)(LPTSTR)szSubsetName );

    WriteProfileString(TEXT("MSCharMap"), TEXT("Block"), (LPTSTR)szSubsetName);
}


////////////////////////////////////////////////////////////////////////////
//
//  SelectInitialSubset
//
//  Selects the initial Unicode subset by getting a saved block name from
//  win.ini.
//
//  Returns index to subset selected.
//
////////////////////////////////////////////////////////////////////////////

INT SelectInitialSubset(
    HWND hWndDlg)
{
    TCHAR szSubsetName[LF_SUBSETSIZE] = TEXT("");
    INT iIndex;

    if ((GetProfileString( TEXT("MSCharMap"),
                           TEXT("Block"),
                           NULL,
                           (LPTSTR)szSubsetName,
                           BTOC(sizeof(szSubsetName)) ) == 0) ||
        ((iIndex = (INT)SendDlgItemMessage(
                            hWndDlg,
                            ID_UNICODESUBSET,
                            CB_SELECTSTRING,
                            (WPARAM)-1,
                            (LONG)(LPTSTR)szSubsetName )) == CB_ERR))
    {
        //
        //  If there was no profile or the selection failed then try selecting
        //  the Basic Latin block, if that fails then select the first one.
        //
        if ((iIndex = (INT)SendDlgItemMessage(
                               hWndDlg,
                               ID_UNICODESUBSET,
                               CB_SELECTSTRING,
                               (WPARAM)-1,
                               (LONG)(LPTSTR)TEXT("Basic Latin") )) == CB_ERR)
        {
            SendDlgItemMessage( hWndDlg,
                                ID_UNICODESUBSET,
                                CB_SETCURSEL,
                                iIndex = 0,
                                0L );
        }
    }

    chSymFirst = aSubsetData[iIndex].BeginRange;
    chSymLast = aSubsetData[iIndex].EndRange;
    sycm.chCurr = chSymFirst;

    return (iIndex);
}


////////////////////////////////////////////////////////////////////////////
//
//  ExitMagnify
//
//  Releases mouse capture, exits magnify mode, and restores the cursor.
//
////////////////////////////////////////////////////////////////////////////

VOID ExitMagnify(
    HWND hWnd,
    PSYCM psycm)
{
    //
    //  Release capture, remove magnified character, restore cursor.
    //
    ReleaseCapture();
    RestoreSymMag(psycm);
    DrawSymChOutlineHwnd(psycm, hWnd, psycm->chCurr, TRUE, TRUE);
    if (psycm->fCursorOff)
    {
        ShowCursor(TRUE);
    }
    psycm->fMouseDn = psycm->fCursorOff = FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  SetEditCtlFont
//
//  Creates a font for the Edit control that visually matches the handle
//  given, but is guaranteed not to be bigger than the size of the edit
//  control.
//
////////////////////////////////////////////////////////////////////////////

void SetEditCtlFont(
    HWND hwndDlg,
    int idCtl,
    HFONT hfont)
{
    static HFONT hfNew = NULL;
    LOGFONT lfNew;
    HWND hwndCtl = GetDlgItem(hwndDlg, idCtl);
    RECT rc;

    if (hfNew != NULL)
    {
        DeleteObject(hfNew);
    }

    GetWindowRect(hwndCtl, &rc);

    if (GetObject(hfont, sizeof(lfNew), &lfNew) != 0)
    {
        lfNew.lfHeight = rc.bottom - rc.top - 8;
        lfNew.lfWidth = lfNew.lfEscapement = lfNew.lfOrientation =
          lfNew.lfWeight = 0;

        hfNew = CreateFontIndirect(&lfNew);
    }
    else
    {
        hfNew = hfont;
    }

    SendMessage(hwndCtl, WM_SETFONT, (WPARAM)hfNew, (LPARAM)TRUE);

    if (hfNew == hfont)
    {
        hfNew = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\oldchar\spechars\cmdlg.h ===
/*++

Copyright (c) 1991-1997,  Microsoft Corporation  All rights reserved.

Module Name:

    cmdlg.h

Abstract:

    This module contains the dialog definitions for the Charmap utility.

Revision History:

--*/



//
//  Constant Declarations.
//

#define ID_HELP                             100
#define ID_CLOSE                            101
#define ID_COPY                             102
#define ID_SELECT                           103
#define ID_STRING                           104
#define ID_FONT                             105
#define ID_TOPLEFT                          107
#define ID_CHARGRID                         108
#define ID_SUBSET                           109
#define IDBM_TT                             110
#define IDIC_CHARMAP                        111
#define IDS_HELP                            112
#define IDS_RTF                             113
#define IDS_KEYSTROKE                       114
#define IDS_SPACE                           115
#define IDS_CTRL                            116
#define IDS_CTRLALT                         117
#define IDS_SHIFTCTRLALT                    118
#define IDS_ALT                             119
#define IDS_UNICODELABEL                    120

#define IDS_WINDOWS                         1
#define IDS_LATIN1                          2
#define IDS_LATINEXA                        3
#define IDS_LATINEXB                        4
#define IDS_IPAEX                           5
#define IDS_SPACINGMODIFIERS                6
#define IDS_COMBININGDIACRITICS             7
#define IDS_BASICGREEK                      8
#define IDS_GREEKSYMBOLS                    9
#define IDS_CYRILLIC                        10
#define IDS_ARMENIAN                        11
#define IDS_HEBREW                          12
#define IDS_BASICHEBREW                     12
#define IDS_HEBREWEX                        13
#define IDS_BASICARABIC                     14
#define IDS_ARABICEX                        15
#define IDS_DEVANAGARI                      16
#define IDS_BENGALI                         17
#define IDS_GURMUKHI                        18
#define IDS_GUJARATI                        19
#define IDS_ORIYA                           20
#define IDS_TAMIL                           21
#define IDS_TELUGU                          22
#define IDS_KANNADA                         23
#define IDS_MALAYALAM                       24
#define IDS_THAI                            25
#define IDS_LAO                             26
#define IDS_BASICGEORGIAN                   27
#define IDS_GEORGIANEX                      28
#define IDS_HANGULJAMO                      29
#define IDS_LATINEXADDITIONAL               30
#define IDS_GREEKEX                         31
#define IDS_GENERALPUNCTUATION              32
#define IDS_SUPERANDSUBSCRIPTS              33
#define IDS_CURRENCYSYMBOLS                 34
#define IDS_COMBININGDIACRITICSFORSYMBOLS   35
#define IDS_LETTERLIKESYMBOLS               36
#define IDS_NUMBERFORMS                     37
#define IDS_ARROWS                          38
#define IDS_MATHEMATICALOPS                 39
#define IDS_MISCTECHNICAL                   40
#define IDS_CONTROLPICTURES                 41
#define IDS_OPTICALCHAR                     42
#define IDS_ENCLOSEDALPHANUM                43
#define IDS_BOXDRAWING                      44
#define IDS_BLOCKELEMENTS                   45
#define IDS_GEOMETRICSHAPES                 46
#define IDS_MISCDINGBATS                    47
#define IDS_DINGBATS                        48
#define IDS_CJKSYMBOLSANDPUNC               49
#define IDS_HIRAGANA                        50
#define IDS_KATAKANA                        51
#define IDS_BOPOMOFO                        52
#define IDS_HANGULCOMPATIBILITYJAMO         53
#define IDS_CJKMISC                         54
#define IDS_ENCLOSEDCJKLETTERSANDMONTHS     55
#define IDS_CJKCOMPATIBILITY                56
#define IDS_HANGUL                          57
#define IDS_HANGULSUPPA                     58
#define IDS_HANGULSUPPB                     59
#define IDS_CJKUNIFIEDIDEOGRAPHS            60
#define IDS_PRIVATEUSEAREA                  61
#define IDS_CJKCOMPATIBILITYIDEOGRAPHS      62
#define IDS_ALPAHPRESENTATIONFORMS          63
#define IDS_ARABICPRESENTATIONFORMSA        64
#define IDS_CJKCOMPFORMS                    66
#define IDS_SMALLFORMVARIANTS               67
#define IDS_ARABICPRESENTATIONFORMSB        68
#define IDS_HALFANDFULLWIDTHFORMS           69
#define IDS_SPECIALS                        70


#define ID_SUBSETLB                         201
#define ID_NEXTSUBSET                       203
#define ID_PREVSUBSET                       205

#define ID_UNICODESUBSET                    202
#define ID_MAPSCROLL                        204

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\oldchar\spechars\charmap.h ===
/*++

Copyright (c) 1991-1997,  Microsoft Corporation  All rights reserved.

Module Name:

    charmap.h

Abstract:

    This module contains the header information for the Charmap utility.

Revision History:

--*/



//
//  Include Files.
//
#include "cmdlg.h"




//
//  Constant Declarations.
//

#define BTOC(bytes)     ((bytes) / sizeof(TCHAR))
#define CTOB(cch)       ((cch) * sizeof(TCHAR))

#define cchFullMap      (256)

#define CCH_KEYNAME     50             // number of chars in keyname

#define LF_SUBSETSIZE   128




//
//  Typedef Declarations.
//

#ifdef UNICODE
typedef unsigned short UTCHAR;
#else
typedef unsigned char UTCHAR;
#endif
#define UCHAR unsigned char

typedef struct tagSYCM
{
    INT dxpBox;
    INT dypBox;
    INT dxpCM;
    INT dypCM;
    INT xpCh;
    INT ypCh;
    INT dxpMag;
    INT dypMag;
    INT xpMagCurr;
    INT ypMagCurr;
    INT ypDest;
    INT xpCM;
    INT ypCM;

    BOOL fHasFocus;
    BOOL fFocusState;
    BOOL fMouseDn;
    BOOL fCursorOff;
    BOOL fAnsiFont;
    UTCHAR chCurr;
    HFONT hFontMag;
    HFONT hFont;
    HDC hdcMag;
    HBITMAP hbmMag;
    INT rgdxp[256];
} SYCM, *PSYCM;


typedef struct tagITEMDATA
{
    SHORT FontType;
    BYTE CharSet;
    BYTE PitchAndFamily;
} ITEMDATA;


typedef struct tagUSUBSET
{
    INT BeginRange;
    INT EndRange;
    INT StringResId;
    TCHAR Name[LF_SUBSETSIZE];
} USUBSET;




//
//  Function Declarations.
//

BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, INT);
INT_PTR APIENTRY CharMapDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT APIENTRY CharGridWndProc(HWND, UINT, WPARAM, LPARAM);
INT ChFromSymLParam(PSYCM, LONG);
VOID DrawSymChOutlineHwnd(PSYCM, HWND, UTCHAR, BOOL, BOOL);
VOID RecalcCharMap(HWND, PSYCM, INT, BOOL);
VOID DrawSymbolMap(PSYCM, HDC);
VOID DrawSymbolGrid(PSYCM, HDC);
VOID DrawSymbolChars(PSYCM, HDC);
VOID DrawSymChOutline(PSYCM, HDC, UTCHAR, BOOL, BOOL);
VOID MoveSymbolSel(PSYCM, UTCHAR);
VOID RestoreSymMag(PSYCM);
INT  APIENTRY FontLoadProc(LPLOGFONT, NEWTEXTMETRICEX*, DWORD, LPARAM);
HANDLE GetEditText(HWND);
VOID CopyString(HWND);
VOID SendRTFToClip(HWND, LPTSTR);
INT PointsToHeight(INT);
VOID UpdateKeystrokeText(HDC hdc, BOOL fANSI, UTCHAR chNew, BOOL fRedraw);
VOID PaintStatusLine(HDC, BOOL, BOOL);
BOOL UpdateHelpText(LPMSG, HWND);
INT KeyboardVKeyFromChar(UTCHAR);
BOOL DrawFamilyComboItem(LPDRAWITEMSTRUCT);
HBITMAP LoadBitmaps(INT);
VOID DoHelp(HWND, BOOL);
VOID SaveCurrentFont(HWND);
INT SelectInitialFont(HWND);
VOID ExitMagnify(HWND, PSYCM);
INT SelectInitialSubset(HWND);
VOID SaveCurrentSubset(HWND);
BOOL CALLBACK SubSetDlgProc(HWND, UINT, WPARAM, LPARAM);
VOID UpdateSymbolSelection(HWND, INT, INT);
VOID UpdateSymbolRange(HWND hwnd, INT FirstChar, INT LastChar);
VOID SubSetChanged(HWND hwnd, INT iSubSet, INT ichFirst, INT ichLast);
VOID ProcessScrollMsg(HWND hwnd, int nCode, int nPos);
INT ScrollMapPage(HWND hwndDlg, BOOL fUp, BOOL fRePaint);
BOOL ScrollMap(HWND hwndDlg, INT cchScroll, BOOL fRePaint);
void SetEditCtlFont(HWND hwndDlg, int idCtl, HFONT hfont);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\oldchar\ucharmap\cmdlg.h ===
#define ID_HELP                     100
#define ID_CLOSE                    101
#define ID_COPY                     102
#define ID_SELECT                   103
#define ID_STRING                   104
#define ID_FONT                     105
#define ID_TOPLEFT                  107
#define ID_CHARGRID                 108
#define ID_SUBSET                   109
#define IDBM_TT                     110
#define IDIC_CHARMAP                111
#define IDS_HELP                    112
#define IDS_RTF                     113
#define IDS_KEYSTROKE               114
#define IDS_SPACE                   115
#define IDS_CTRL                    116
#define IDS_CTRLALT                 117
#define IDS_SHIFTCTRLALT            118
#define IDS_ALT                     119
#define IDS_UNICODELABEL            120
#define IDS_LATIN1                    1
#define IDS_LATINEXA                  3
#define IDS_LATINEXB                  4
#define IDS_IPAEX                     5
#define IDS_SPACINGMODIFIERS          6
#define IDS_COMBININGDIACRITICS       7
#define IDS_BASICGREEK                8
#define IDS_GREEKSYMBOLS              9
#define IDS_CYRILLIC                 10
#define IDS_ARMENIAN                 11
#define IDS_HEBREW                   12
#define IDS_BASICHEBREW              12
#define IDS_HEBREWEX                 13
#define IDS_BASICARABIC              14
#define IDS_ARABICEX                 15
#define IDS_DEVANAGARI               16
#define IDS_BENGALI                  17
#define IDS_GURMUKHI                 18
#define IDS_GUJARATI                 19
#define IDS_ORIYA                    20
#define IDS_TAMIL                    21
#define IDS_TELUGU                   22
#define IDS_KANNADA                  23
#define IDS_MALAYALAM                24
#define IDS_THAI                     25
#define IDS_LAO                      26
#define IDS_BASICGEORGIAN            27
#define IDS_GEORGIANEX               28
#define IDS_HANGULJAMO               29
#define IDS_LATINEXADDITIONAL        30
#define IDS_GREEKEX                  31
#define IDS_GENERALPUNCTUATION       32
#define IDS_SUPERANDSUBSCRIPTS       33
#define IDS_CURRENCYSYMBOLS          34
#define IDS_COMBININGDIACRITICSFORSYMBOLS 35
#define IDS_LETTERLIKESYMBOLS        36
#define IDS_NUMBERFORMS              37
#define IDS_ARROWS                   38
#define IDS_MATHEMATICALOPS          39
#define IDS_MISCTECHNICAL            40
#define IDS_CONTROLPICTURES          41
#define IDS_OPTICALCHAR              42
#define IDS_ENCLOSEDALPHANUM         43
#define IDS_BOXDRAWING               44
#define IDS_BLOCKELEMENTS            45
#define IDS_GEOMETRICSHAPES          46
#define IDS_MISCDINGBATS             47
#define IDS_DINGBATS                 48
#define IDS_CJKSYMBOLSANDPUNC        49
#define IDS_HIRAGANA                 50
#define IDS_KATAKANA                 51
#define IDS_BOPOMOFO                 52
#define IDS_HANGULCOMPATIBILITYJAMO  53
#define IDS_CJKMISC                  54
#define IDS_ENCLOSEDCJKLETTERSANDMONTHS 55
#define IDS_CJKCOMPATIBILITY         56
#define IDS_HANGUL                   57
#define IDS_HANGULSUPPA              58
#define IDS_HANGULSUPPB              59
#define IDS_CJKUNIFIEDIDEOGRAPHS     60
#define IDS_PRIVATEUSEAREA           61
#define IDS_CJKCOMPATIBILITYIDEOGRAPHS 62
#define IDS_ALPAHPRESENTATIONFORMS   63
#define IDS_ARABICPRESENTATIONFORMSA 64
#define IDS_CJKCOMPFORMS             65
#define IDS_SMALLFORMVARIANTS        66
#define IDS_ARABICPRESENTATIONFORMSB 67
#define IDS_HALFANDFULLWIDTHFORMS    68
#define IDS_SPECIALS                 69



#define ID_SUBSETLB                 201
#define ID_NEXTSUBSET               203
#define ID_PREVSUBSET               205

#define ID_UNICODESUBSET            202
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\cdataobj.h ===
//**********************************************************************
// File name: cdataobj.h
//
// Definition of CImpIDataObject
// Implements the IDataObject interface required for Data transfer
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//**********************************************************************

#ifndef CIMPIDATAOBJECT_H
#define CIMPIDATAOBJECT_H

class CImpIDataObject : public IDataObject {
private:
    LONG    m_cRef;     // Reference counting information
    HWND    hWndDlg;    // Dialog handle cached for dumping Rich text
    TCHAR   m_lpszText[2];   // Pointer to text which is to be dragged

public:
    // Constructor
    CImpIDataObject(HWND hWndDlg);

    // IUnknown interface members
    STDMETHODIMP QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDataObject interface members
    STDMETHODIMP GetData(FORMATETC*, STGMEDIUM*);
    STDMETHODIMP GetDataHere(FORMATETC*, STGMEDIUM*);
    STDMETHODIMP QueryGetData(FORMATETC*);
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC*, FORMATETC*);
    STDMETHODIMP SetData(FORMATETC*, STGMEDIUM*, BOOL);
    STDMETHODIMP EnumFormatEtc(DWORD, IEnumFORMATETC**);
    STDMETHODIMP DAdvise(FORMATETC*, DWORD, IAdviseSink*, DWORD*);
    STDMETHODIMP DUnadvise(DWORD);
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA**);

    // Function which transfer data
    HRESULT RenderRTFText(STGMEDIUM* pMedium);
    HRESULT RenderPlainUnicodeText(STGMEDIUM* pMedium);
    HRESULT RenderPlainAnsiText(STGMEDIUM* pMedium);

    int SetText(LPTSTR);
};

typedef CImpIDataObject *PCImpIDataObject;

#endif // CIMPIDATAOBJECT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\oldchar\ucharmap\charmap.c ===
/****************************************************************************

    PROGRAM: CharMap

    PURPOSE: Utility providing users an easy interface for selecting special
             characters.

    COMMENTS:
        Created by MikeSch (7-16-91)
        Partially derived from WinWord 2.0 Insert.Symbol dialog.

****************************************************************************/

#define WIN31
#include "windows.h"
#include <port1632.h>
#include "charmap.h"
#include "stdlib.h"
#include "tchar.h"
#ifdef UNICODE
#include "wchar.h"
#else
#include "stdio.h"
#endif
#include "commctrl.h"

/*
 * Macros
 */
#define FMagData(psycm) ((psycm)->xpMagCurr != 0)
#define abs(x) (((x) >= 0) ? (x) : (-(x)))

/*
 * Useful constants.
 */
#define STATUSPOINTSIZE          8      // Point size of status bar font.
#define DX_BITMAP               20      // Width of TT bitmap.
#define DY_BITMAP               12      // Height of TT bitmap.
#define BACKGROUND      0x000000FF      // bright blue
#define BACKGROUNDSEL   0x00FF00FF      // bright purple
#define BUTTONFACE      0x00C0C0C0      // bright grey
#define BUTTONSHADOW    0x00808080      // dark grey

// Font types
#define PS_OPENTYPE_FONT    0x0001
#define TT_OPENTYPE_FONT    0x0002
#define TRUETYPE_FONT       0x0004
#define TYPE1_FONT          0x0008

/*
 * Globals.
 */
HANDLE hInst;
INT cchSymRow = 32;          // Number of characters across the character grid.
INT cchSymCol = 8;           // Number of rows in the character grid.
UTCHAR chSymFirst = 32;
UTCHAR chSymLast  = 255;
SYCM sycm;                   // Tons of data need to do char grid painting.
UINT wCFRichText = 0;        // Private clipboard format, rich text format.
HFONT hFontClipboard = NULL; // Tells us which font is in the clipboard.
HANDLE hstrClipboard = NULL; // Contains the string which is in the clipboard.
BOOL fDelClipboardFont = FALSE; // The clipboard font needs to be deleted.
INT iControl = ID_CHARGRID;  // Index indicating which control has focus.
HBITMAP hbmFont = NULL;      // TT bitmap drawn before font facenames in combo.
LONG lEditSel = 0;           // Contains the selection range of the EC.
HBRUSH hStaticBrush;         // Used for static controls during WM_CTLCOLOR

//
// 04 Dec 92 - GregoryW
//    Currently there is no defined
//    interface for querying what character ranges a Unicode font
//    supports.  For now this table only has the subsets that contain
//    characters supported by the Lucida Sans Unicode font uncommented.
//    When we get an API that allows querying the font driver for
//    ranges of Unicode characters supported (and whether or not a font
//    is a Unicode font!) then all entries can be uncommented.
//
USUBSET aSubsetData[] = {{ 0x0020, 0x00ff, IDS_LATIN1},
                       { 0x0100, 0x017f, IDS_LATINEXA},
                       { 0x0180, 0x024f, IDS_LATINEXB},
                       { 0x0250, 0x02af, IDS_IPAEX},
                       { 0x02b0, 0x02ff, IDS_SPACINGMODIFIERS},
                       { 0x0300, 0x036f, IDS_COMBININGDIACRITICS},
                       { 0x0370, 0x03cf, IDS_BASICGREEK},
                       { 0x03d0, 0x03ff, IDS_GREEKSYMBOLS},
                       { 0x0400, 0x04ff, IDS_CYRILLIC},
// not supported       { 0x0530, 0x058f, IDS_ARMENIAN},
                       { 0x0590, 0x05ff, IDS_HEBREW},
// not supported       { 0x0600, 0x0652, IDS_BASICARABIC},
// not supported       { 0x0653, 0x06ff, IDS_ARABICEX},
// not supported       { 0x0900, 0x097f, IDS_DEVANAGARI},
// not supported       { 0x0980, 0x09ff, IDS_BENGALI},
// not supported       { 0x0a00, 0x0a7f, IDS_GURMUKHI},
// not supported       { 0x0a80, 0x0aff, IDS_GUJARATI},
// not supported       { 0x0b00, 0x0b7f, IDS_ORIYA},
// not supported       { 0x0b80, 0x0bff, IDS_TAMIL},
// not supported       { 0x0c00, 0x0c7f, IDS_TELUGU},
// not supported       { 0x0c80, 0x0cff, IDS_KANNADA},
// not supported       { 0x0d00, 0x0d7f, IDS_MALAYALAM},
// not supported       { 0x0e00, 0x0e7f, IDS_THAI},
// not supported       { 0x0e80, 0x0eff, IDS_LAO},
// not supported       { 0x10d0, 0x10ff, IDS_BASICGEORGIAN},
// not supported       { 0x10a0, 0x10cf, IDS_GEORGIANEX},
// not supported       { 0x1100, 0x11ff, IDS_HANGULJAMO},
// not supported       { 0x1e00, 0x1eff, IDS_LATINEXADDITIONAL},
// not supported       { 0x1f00, 0x1fff, IDS_GREEKEX},
// not supported       { 0x2000, 0x206f, IDS_GENERALPUNCTUATION},
// not supported       { 0x2070, 0x209f, IDS_SUPERANDSUBSCRIPTS},
                       { 0x20a0, 0x20cf, IDS_CURRENCYSYMBOLS},
// not supported       { 0x20d0, 0x20ff, IDS_COMBININGDIACRITICSFORSYMBOLS},
                       { 0x2100, 0x214f, IDS_LETTERLIKESYMBOLS},
// not supported       { 0x2150, 0x218f, IDS_NUMBERFORMS},
                       { 0x2190, 0x21ff, IDS_ARROWS},
                       { 0x2200, 0x22ff, IDS_MATHEMATICALOPS},
// not supported       { 0x2300, 0x23ff, IDS_MISCTECHNICAL},
// not supported       { 0x2400, 0x243f, IDS_CONTROLPICTURES},
// not supported       { 0x2440, 0x245f, IDS_OPTICALCHAR},
// not supported       { 0x2460, 0x24ff, IDS_ENCLOSEDALPHANUM},
// not supported       { 0x2500, 0x257f, IDS_BOXDRAWING},
// not supported       { 0x2580, 0x259f, IDS_BLOCKELEMENTS},
// not supported       { 0x25a0, 0x25ff, IDS_GEOMETRICSHAPES},
// not supported       { 0x2600, 0x26ff, IDS_MISCDINGBATS},
// not supported       { 0x2700, 0x27bf, IDS_DINGBATS},
// not supported       { 0x3000, 0x303f, IDS_CJKSYMBOLSANDPUNC},
// not supported       { 0x3040, 0x309f, IDS_HIRAGANA},
// not supported       { 0x30a0, 0x30ff, IDS_KATAKANA},
// not supported       { 0x3100, 0x312f, IDS_BOPOMOFO},
// not supported       { 0x3130, 0x318f, IDS_HANGULCOMPATIBILITYJAMO},
// not supported       { 0x3190, 0x319f, IDS_CJKMISC},
// not supported       { 0x3200, 0x32ff, IDS_ENCLOSEDCJKLETTERSANDMONTHS},
// not supported       { 0x3300, 0x33ff, IDS_CJKCOMPATIBILITY},
// not supported       { 0x3400, 0x3d2d, IDS_HANGUL},
// not supported       { 0x3d2e, 0x44b7, IDS_HANGULSUPPA},
// not supported       { 0x44b8, 0x4dff, IDS_HANGULSUPPB},
// not supported       { 0x4e00, 0x9fff, IDS_CJKUNIFIEDIDEOGRAPHS},
// not supported       { 0xe000, 0xf8ff, IDS_PRIVATEUSEAREA},
// not supported       { 0xf900, 0xfaff, IDS_CJKCOMPATIBILITYIDEOGRAPHS},
// not supported       { 0xfb00, 0xfb4f, IDS_ALPAHPRESENTATIONFORMS},
// not supported       { 0xfb50, 0xfdff, IDS_ARABICPRESENTATIONFORMSA},
// not supported       { 0xfe30, 0xfe4f, IDS_CJKCOMPFORMS},
// not supported       { 0xfe50, 0xfe6f, IDS_SMALLFORMVARIANTS},
// not supported       { 0xfe70, 0xfefe, IDS_ARABICPRESENTATIONFORMSB},
// not supported       { 0xff00, 0xffef, IDS_HALFANDFULLWIDTHFORMS},
// not supported       { 0xfff0, 0xfffd, IDS_SPECIALS}
                       };
INT cSubsets = sizeof(aSubsetData) / sizeof(USUBSET);
INT iCurSubset = 0;    // index of current Unicode subset - default to Latin-1

// Useful window handles.
HWND hwndDialog;
HWND hwndCharGrid;

// Data used to draw the status bar.
RECT rcStatusLine;                        // Bounding rect for status bar.
RECT rcToolbar[2];                        // Bounding rects for toolbars.
INT dyStatus;                             // Height of status bar.
INT dyToolbar[2];                         // Height of tool bars.
INT dxHelpField;                          // Width of help window.
INT dxKeystrokeField;                     // Width of keystroke window.
TCHAR szKeystrokeText[30];                // Buffer for keystroke text.
TCHAR szKeystrokeLabel[30];               // Buffer for keystroke label.
TCHAR szSpace[15];                        // Strings for keystroke description.
TCHAR szCtrl[15];
TCHAR szCtrlAlt[25];
TCHAR szShiftCtrlAlt[25];
TCHAR szAlt[15];
TCHAR szUnicodeLabel[23];                 // Buffer for Unicode label.
INT iKeystrokeTextStart;                  // Place to start appending text to above.
INT iUnicodeLabelStart;                   // Place to start appending text to above.
HFONT hfontStatus;                        // Font used for text of status bar.

/****************************************************************************

    FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)

    PURPOSE: calls initialization function, processes message loop, cleanup.

    COMMENTS:

****************************************************************************/

INT PASCAL WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    MSG msg;

    if (!InitApplication(hInstance))
            return (FALSE);

    InitCommonControls();

    // Perform initialization for this instance.
    if (!InitInstance(hInstance, nCmdShow)) {
        return (FALSE);
    }

    while (GetMessage(&msg,
            NULL,
            0,
            0))
    {
        // Filter for possible tabs now to implement context sensitive help.
        if (msg.message == WM_KEYDOWN)
            if (!UpdateHelpText(&msg, NULL))
                continue;

        // Main message loop.
        if (!IsDialogMessage(hwndDialog, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    // Free up some stuff.
    if (hfontStatus)
        DeleteObject(hfontStatus);
    if (hbmFont)
        DeleteObject(hbmFont);

    return (int)(msg.wParam);
}


/****************************************************************************

    FUNCTION: InitApplication(HANDLE)

    PURPOSE: Initializes window data and registers window class

    COMMENTS:

****************************************************************************/

BOOL InitApplication(HANDLE hInstance)
{
    WNDCLASS  wc;

    /*
     * Register a window class that we will use to draw the character grid
     * into.
     */
    wc.style = CS_DBLCLKS;
    wc.lpfnWndProc = CharGridWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("CharGridWClass");

    if (!RegisterClass(&wc))
        return (FALSE);

    wc.style = 0;
    wc.lpfnWndProc = DefDlgProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = DLGWINDOWEXTRA;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDIC_CHARMAP));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("MyDlgClass");

    if (!RegisterClass(&wc))
        return (FALSE);

    return TRUE;
}

/****************************************************************************

    FUNCTION:  InitInstance(HANDLE, int)

    PURPOSE:  Does some initialization and creates main window which is a
              dialog.

    COMMENTS:

****************************************************************************/

BOOL InitInstance(HANDLE hInstance, INT nCmdShow)
{
    INT i;

    // Save the instance handle in a global variable.
    hInst = hInstance;

    // This font will be used to paint the status line.
    hfontStatus = CreateFont(-PointsToHeight(STATUSPOINTSIZE), 0, 0, 0, 400, 0, 0, 0,
                     ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                     DEFAULT_QUALITY, VARIABLE_PITCH | FF_SWISS, TEXT("Helv"));
    dyStatus = 2 * PointsToHeight(STATUSPOINTSIZE);
    dyToolbar[0] = 28;  /* defined by UI gods */
    dyToolbar[1] = 28;  /* defined by UI gods */

    // Load the Unicode subset names before initializing the main window.
    for (i = 0; i < cSubsets; i++) {
        if (!LoadString(
             hInst,
             aSubsetData[i].StringResId,
             (LPTSTR)aSubsetData[i].Name,
             50)
             )
            return (FALSE);
    }

    // Create a main window for this application instance.
    if (!(hwndDialog = CreateDialog(hInstance, TEXT("CharMap"), NULL,
                              CharMapDlgProc)))
        return (FALSE);

    /*
     * Initialize some strings used for the Keystroke status bar field.
     */
    // For international purposes, this string could be length 0.
    LoadString(
        hInst,
        IDS_KEYSTROKE,
        (LPTSTR)szKeystrokeLabel,
        BTOC(sizeof(szKeystrokeLabel))
        );
    if (!LoadString(
             hInst,
             IDS_UNICODELABEL,
             (LPTSTR)szUnicodeLabel,
             BTOC(sizeof(szUnicodeLabel))
             ))
    if (!LoadString(
             hInst,
             IDS_SPACE,
             (LPTSTR)szSpace,
             BTOC(sizeof(szSpace))
             ))
        return (FALSE);
    if (!LoadString(
             hInst,
             IDS_CTRL,
             (LPTSTR)szCtrl,
             BTOC(sizeof(szCtrl))
             ))
        return (FALSE);
    if (!LoadString(
             hInst,
             IDS_CTRLALT,
             (LPTSTR)szCtrlAlt,
             BTOC(sizeof(szCtrlAlt))
             ))
        return (FALSE);
    if (!LoadString(
             hInst,
             IDS_SHIFTCTRLALT,
             (LPTSTR)szShiftCtrlAlt,
             BTOC(sizeof(szShiftCtrlAlt))
             ))
        return (FALSE);
    if (!LoadString(
             hInst,
             IDS_ALT,
             (LPTSTR)szAlt,
             BTOC(sizeof(szAlt))
             ))
        return (FALSE);

    // Store the index to where we start adding status line text changes.
    iKeystrokeTextStart = lstrlen(szKeystrokeLabel);
    iUnicodeLabelStart = lstrlen(szUnicodeLabel);

    /*
     * Initialize keystroke text, make the window visible,
     * update its client area, and return "success".
     */
    UpdateKeystrokeText(NULL, sycm.chCurr, FALSE);
    ShowWindow(hwndDialog, nCmdShow);
    UpdateWindow(hwndDialog);
    return (TRUE);

}

/****************************************************************************

    FUNCTION: CharMapDlgProc(HWND, UINT, WPARAM, LPARAM)

    PURPOSE:  Processes messages for the main window.

    COMMENTS: This window is a dialog box.

****************************************************************************/

INT_PTR  APIENTRY CharMapDlgProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message) {
        case WM_CTLCOLORSTATIC:
            {
            POINT point;

            SetBkColor((HDC)wParam, GetSysColor(COLOR_BTNFACE));
            UnrealizeObject(hStaticBrush);
            point.x = point.y = 0;
            ClientToScreen(hWnd, &point);

            return((INT_PTR)hStaticBrush);
            break;
            }

        case WM_INITDIALOG:
            {
            RECT rectParent, rectTopRightControl;
            INT iSubset;

            /*
             * Create the character grid with dimensions which just fit inside
             * the space allowed in the dialog.  When it processes the
             * WM_CREATE message it will be sized and centered more accurately.
             */
            GetClientRect(hWnd, &rectParent);
            GetWindowRect(GetDlgItem(hWnd, ID_CLOSE), &rectTopRightControl);
            ScreenToClient(hWnd, (LPPOINT)&(rectTopRightControl.left));
            ScreenToClient(hWnd, (LPPOINT)&(rectTopRightControl.right));

            if (!(hwndCharGrid =
                CreateWindow(
                    TEXT("CharGridWClass"),
                    NULL,
                    WS_CHILD | WS_VISIBLE | WS_TABSTOP,
                    1,
                    rectParent.top + dyToolbar[0] + dyToolbar[1],
                    rectParent.right - 1,
                    rectParent.bottom - rectParent.top - dyStatus - dyToolbar[0] - dyToolbar[1] - 1,
                    hWnd,
                    (HMENU) ID_CHARGRID,
                    hInst,
                    NULL
                    ))) {
                DestroyWindow(hWnd);
                break;
            }

            hStaticBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));

            // Initialize the status line data.
            dxHelpField = 22 * rectParent.right / 32;
            dxKeystrokeField = 8 * rectParent.right / 32;
            rcStatusLine = rectParent;
            rcStatusLine.top = rcStatusLine.bottom - dyStatus;

            // Initialize the toolbars
            rcToolbar[0] = rectParent;
            rcToolbar[0].bottom = rcToolbar[0].top + dyToolbar[0];

            rcToolbar[1] = rcToolbar[0];
            rcToolbar[1].top = rcToolbar[0].bottom + GetSystemMetrics(SM_CYBORDER);
            rcToolbar[1].bottom = rcToolbar[1].top + dyToolbar[1];

            // Disable Copy button.
            EnableWindow(GetDlgItem(hWnd, ID_COPY), FALSE);

            /* fill "Subset" list box */
            for (iSubset = 0; iSubset < cSubsets; iSubset++) {
                SendDlgItemMessage(
                    hWnd,
                    ID_UNICODESUBSET,
                    CB_ADDSTRING,
                    0,
                    (LPARAM)aSubsetData[iSubset].Name
                    );

            }
            iCurSubset = SelectInitialSubset(hWnd);

            }

            /* fall through to WM_FONTCHANGE */
        case WM_FONTCHANGE:
            {
            HDC hdc = GetDC(hWnd);

            /*
             * Get the fonts from the system and put them in the font selection
             * combo box.
             */
            if (message == WM_FONTCHANGE) {
                SaveCurrentFont(hWnd);
                SendDlgItemMessage(hWnd, ID_FONT, CB_RESETCONTENT, 0, 0L);
            }

            EnumFontFamilies(hdc, NULL, (FONTENUMPROC)FontLoadProc, (LPARAM)hWnd);

            ReleaseDC(hWnd, hdc);

            // Setup character dimensions and select this font.
            RecalcCharMap(hWnd, &sycm, SelectInitialFont(hWnd),
                          (message == WM_FONTCHANGE));
            SendDlgItemMessage(hWnd, ID_STRING, WM_SETFONT,
                               (WPARAM)sycm.hFont, (DWORD)TRUE);

            if (message == WM_INITDIALOG)
                SetFocus(hwndCharGrid);
                /* fall through to WM_SYSCOLORCHANGE */
            else
                break;
            }

        case WM_SYSCOLORCHANGE:
            if (hbmFont)
                DeleteObject(hbmFont);
            hbmFont = LoadBitmaps(IDBM_TT);
            DeleteObject(hStaticBrush);
            hStaticBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
            break;

        case WM_PARENTNOTIFY:
            {
            POINTS points;
            DWORD dwMsgPos;
            POINT point;

            /*
             * We process this message to implement the context sensitive
             * help.  Downclicks to controls are found here, the help
             * message is updated in the status bar.
             */
            // BUG - The parameters with this message are unreliable!
            if (wParam == WM_LBUTTONDOWN) {
                dwMsgPos = GetMessagePos();
                points = MAKEPOINTS(dwMsgPos);
                point.x = points.x;
                point.y = points.y;
                UpdateHelpText(NULL, WindowFromPoint(point));
            }

            }
            break;


    case WM_PAINT:

            {
            HBRUSH hBrush;
            RECT rcTemp, rectNextButton;
            INT dyBorder, dxBorder;
            PAINTSTRUCT ps;
            HDC hdc;

            /*
             * This code implements painting of the status bar.
             */
            hdc = BeginPaint(hWnd, &ps);

            rcTemp = rcStatusLine;

            dyBorder = GetSystemMetrics(SM_CYBORDER);
            dxBorder = GetSystemMetrics(SM_CXBORDER);

            // Make the whole thing grey.
              if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE))) {
                FillRect(hdc, &rcTemp, hBrush);
                rcTemp.left = rcToolbar[0].left;
                rcTemp.top = rcToolbar[0].top;
                rcTemp.right = rcToolbar[1].right;
                rcTemp.bottom = rcToolbar[1].bottom;
                FillRect(hdc, &rcTemp, hBrush);
                DeleteObject(hBrush);
              }

              GetWindowRect(GetDlgItem(hWnd, ID_TOPLEFT), &rectNextButton);
              ScreenToClient(hWnd, (LPPOINT)&(rectNextButton.left));
              ScreenToClient(hWnd, (LPPOINT)&(rectNextButton.right));
              // solid black line across bottom of toolbar
              if (hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOWFRAME))) {
                rcTemp = rcToolbar[0];
                rcTemp.top = rcTemp.bottom;
                rcTemp.bottom += dyBorder;
                rcTemp.left = rectNextButton.left - 2 - dxBorder;
                FillRect(hdc, &rcTemp, hBrush);
                rcTemp = rcToolbar[1];
                rcTemp.top = rcTemp.bottom;
                rcTemp.bottom += dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                // vertical line
                rcTemp.top = rcToolbar[0].top;
                rcTemp.bottom = rcToolbar[1].bottom;
                rcTemp.left = rectNextButton.left - 2 - dxBorder;
                rcTemp.right = rectNextButton.left - 2;
                FillRect(hdc, &rcTemp, hBrush);
                DeleteObject(hBrush);
              }

            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW))) {

                // Status line top.
                rcTemp.left   = 8 * dyBorder;
                rcTemp.right  = rcTemp.left + dxHelpField;
                rcTemp.top    = rcStatusLine.top + dyBorder * 2;
                rcTemp.bottom = rcTemp.top + dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                // Keystroke line top.
                rcTemp.right = rcStatusLine.right - 8 * dyBorder;
                rcTemp.left = rcTemp.right - dxKeystrokeField;
                FillRect(hdc, &rcTemp, hBrush);

                // Status line left side.
                rcTemp = rcStatusLine;
                rcTemp.left = 8 * dyBorder;
                rcTemp.right = rcTemp.left + dyBorder;
                rcTemp.top += dyBorder * 2;
                rcTemp.bottom -= dyBorder * 2;
                FillRect(hdc, &rcTemp, hBrush);

                // Keystroke line left side.
                rcTemp.left = rcStatusLine.right - 9 * dyBorder - dxKeystrokeField;
                rcTemp.right = rcTemp.left + dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                DeleteObject(hBrush);
            }

            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNHIGHLIGHT))) {

                // Status line bottom.
                rcTemp.left   = 8 * dyBorder;
                rcTemp.right  = rcTemp.left + dxHelpField;
                rcTemp.top    = rcStatusLine.bottom - 3 * dyBorder;
                rcTemp.bottom = rcTemp.top + dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                // Keystroke line bottom.
                rcTemp.right = rcStatusLine.right - 8 * dyBorder;
                rcTemp.left = rcTemp.right - dxKeystrokeField;
                FillRect(hdc, &rcTemp, hBrush);

                // Status line right side.
                rcTemp = rcStatusLine;
                rcTemp.left = 8 * dyBorder + dxHelpField;
                rcTemp.right = rcTemp.left + dyBorder;
                rcTemp.top += dyBorder * 2;
                rcTemp.bottom -= dyBorder * 2;
                FillRect(hdc, &rcTemp, hBrush);

                // Keystroke line right side.
                rcTemp.left = rcStatusLine.right - 8 * dyBorder;
                rcTemp.right = rcTemp.left + dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                DeleteObject(hBrush);
            }

            // solid black line across top

            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOWFRAME))) {
            rcTemp = rcStatusLine;
            rcTemp.bottom = rcTemp.top;
            rcTemp.top -= dyBorder;
            FillRect(hdc, &rcTemp, hBrush);
            DeleteObject(hBrush);
            }

            PaintStatusLine(hdc, TRUE, TRUE);

            EndPaint(hWnd, &ps);

            return (TRUE);
            }

        case WM_MEASUREITEM:
            {
            HDC hDC;
            HFONT hFont;
            TEXTMETRIC tm;

            hDC = GetDC(NULL);
            hFont = (HFONT)SendMessage(hWnd, WM_GETFONT, 0, 0L);
            if (hFont)
                hFont = SelectObject(hDC, hFont);
            GetTextMetrics(hDC, &tm);
            if (hFont)
                SelectObject(hDC, hFont);
            ReleaseDC(NULL, hDC);

            ((LPMEASUREITEMSTRUCT)lParam)->itemHeight = max(tm.tmHeight, DY_BITMAP);
            break;
            }

        case WM_DRAWITEM:
            if (((LPDRAWITEMSTRUCT)lParam)->itemID != -1)
                DrawFamilyComboItem((LPDRAWITEMSTRUCT)lParam);

            break;

        case WM_ASKCBFORMATNAME:
            LoadString(hInst, IDS_RTF, (LPTSTR)lParam, (UINT)wParam);

            return (TRUE);

        case WM_PAINTCLIPBOARD:
            {
            LPPAINTSTRUCT lpPS;
            HANDLE hFont;
            LPTSTR lpstrText;

            if (hstrClipboard) {
                // Setup.
                lpPS = (LPPAINTSTRUCT)GlobalLock((HANDLE)lParam);
                lpstrText = (LPTSTR)GlobalLock(hstrClipboard);

                // Lets paint.
                hFont = SelectObject(lpPS->hdc, hFontClipboard);
                TextOut(lpPS->hdc, 0, 0, lpstrText,
                        lstrlen(lpstrText));
                SelectObject(lpPS->hdc, hFont);

                // Cleanup.
                GlobalUnlock(hstrClipboard);
                GlobalUnlock((HANDLE)lParam);
            }

            return (TRUE);
            }

        case WM_CLOSE:
            DestroyWindow(hWnd);
            return (TRUE);

        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDCANCEL:
                case ID_CLOSE:
                    DestroyWindow(hWnd);
                    return (TRUE);
                    break;

                case ID_SELECT:
                    SendDlgItemMessage(hWnd, ID_STRING, WM_CHAR,
                                       (WPARAM)sycm.chCurr, 0L);
                    break;

                case ID_COPY:
                    CopyString(hWnd);
                    return (TRUE);
                    break;

                case ID_FONT:
                    if (HIWORD(wParam) == CBN_SELCHANGE) {
                        RecalcCharMap(hWnd, &sycm,
                                      (INT)SendDlgItemMessage(hWnd, ID_FONT,
                                                              CB_GETCURSEL, 0, 0L),
                                      TRUE);
                        SendDlgItemMessage(hWnd, ID_STRING, WM_SETFONT,
                                           (WPARAM)sycm.hFont, (DWORD)TRUE);
                    } else if (HIWORD(wParam) == CBN_SETFOCUS) {
                        // Necessary if hotkey is used to get to the CB.
                        UpdateHelpText(NULL, (HWND)lParam);
                    }

                    return (TRUE);
                    break;

                case ID_UNICODESUBSET:
                    if (HIWORD(wParam) == CBN_SELCHANGE) {
                        INT iSubset;

                        iSubset = (INT)SendDlgItemMessage(
                                          hWnd,
                                          ID_UNICODESUBSET,
                                          CB_GETCURSEL,
                                          0, 0);
                        UpdateSymbolSelection(
                            hWnd,
                            aSubsetData[iSubset].BeginRange,
                            aSubsetData[iSubset].EndRange
                            );
                        InvalidateRect(hwndCharGrid, NULL, TRUE);
                    } else if (HIWORD(wParam) == CBN_SETFOCUS) {
                        // Necessary if hotkey is used to get to the CB.
                        UpdateHelpText(NULL, (HWND)lParam);
                    }
                    return 0;
                    break;

                case ID_NEXTSUBSET:
                    {
                        INT iCurSelection, iNumEntries;

                        iCurSelection = (INT)SendDlgItemMessage(
                                                 hWnd,
                                                 ID_UNICODESUBSET,
                                                 CB_GETCURSEL,
                                                 0, 0);
                        if (iCurSelection == CB_ERR) {
                             return 0;
                        }
                        iNumEntries = (INT)SendDlgItemMessage(
                                               hWnd,
                                               ID_UNICODESUBSET,
                                               CB_GETCOUNT,
                                               0, 0);
                        if (iNumEntries == CB_ERR) {
                             return 0;
                        }
                        if (iCurSelection++ < (iNumEntries - 1)) {
                            if (iCurSelection == 1) {
                                // Enable Previous button
                                EnableWindow(GetDlgItem(hWnd, ID_PREVSUBSET), TRUE);
                            }

                            SendDlgItemMessage(
                                hWnd,
                                ID_UNICODESUBSET,
                                CB_SETCURSEL,
                                iCurSelection, 0);
                            UpdateSymbolSelection(
                                hWnd,
                                aSubsetData[iCurSelection].BeginRange,
                                aSubsetData[iCurSelection].EndRange
                                );
                            InvalidateRect(hwndCharGrid, NULL, TRUE);
                            if (iCurSelection == (iNumEntries - 1)) {
                                HWND hwndButton;

                                EnableWindow(GetDlgItem(hWnd, ID_NEXTSUBSET), FALSE);
                                //
                                // Only reset the button style and focus if
                                // the "Next" button currently has it.
                                //
                                if (iControl == ID_NEXTSUBSET) {
                                    SendDlgItemMessage(hwndDialog, ID_PREVSUBSET,
                                         BM_SETSTYLE, BS_DEFPUSHBUTTON, 1);
                                    SendDlgItemMessage(hwndDialog, ID_NEXTSUBSET,
                                        BM_SETSTYLE, BS_PUSHBUTTON, 1);
                                    hwndButton = GetDlgItem(hWnd, ID_PREVSUBSET);
                                    SetFocus(hwndButton);
                                    UpdateHelpText(NULL, hwndButton);
                                }
                            }
                        }

                    }
                    return 0;
                    break;

                case ID_PREVSUBSET:
                    {
                        INT iCurSelection;

                        iCurSelection = (INT)SendDlgItemMessage(
                                          hWnd,
                                          ID_UNICODESUBSET,
                                          CB_GETCURSEL,
                                          0, 0);
                        if (iCurSelection == CB_ERR) {
                             return 0;
                        }
                        if (iCurSelection > 0) {
                            iCurSelection--;

                            if (iCurSelection == (cSubsets - 2)) {
                                // Enable Next button
                                EnableWindow(GetDlgItem(hWnd, ID_NEXTSUBSET), TRUE);
                            }

                            SendDlgItemMessage(
                                hWnd,
                                ID_UNICODESUBSET,
                                CB_SETCURSEL,
                                iCurSelection, 0);
                            UpdateSymbolSelection(
                                hWnd,
                                aSubsetData[iCurSelection].BeginRange,
                                aSubsetData[iCurSelection].EndRange
                                );
                            InvalidateRect(hwndCharGrid, NULL, TRUE);
                            if (iCurSelection == 0) {
                                HWND hwndButton;

                                EnableWindow(GetDlgItem(hWnd, ID_PREVSUBSET), FALSE);
                                //
                                // Only reset the button style and focus if
                                // the "Previous" button currently has it.
                                //
                                if (iControl == ID_PREVSUBSET) {
                                    SendDlgItemMessage(hwndDialog, ID_NEXTSUBSET,
                                         BM_SETSTYLE, BS_DEFPUSHBUTTON, 1);
                                    SendDlgItemMessage(hwndDialog, ID_PREVSUBSET,
                                         BM_SETSTYLE, BS_PUSHBUTTON, 1);
                                    hwndButton = GetDlgItem(hWnd, ID_NEXTSUBSET);
                                    SetFocus(hwndButton);
                                    UpdateHelpText(NULL, hwndButton);
                                }
                            }
                        }
                    }
                    return 0;
                    break;

                case ID_STRING:
                    if (HIWORD(wParam) == EN_SETFOCUS) {
                        // Necessary if hotkey is used to get to the EC.
                        UpdateHelpText(NULL, (HWND)lParam);
                    } else if (HIWORD(wParam) == EN_CHANGE) {
                        // Disable Copy button if there are no chars in EC.
                        INT iLength;

                        iLength = GetWindowTextLength((HWND)lParam);
                        EnableWindow(GetDlgItem(hWnd, ID_COPY), (BOOL)iLength);
                    }

                    break;

                case ID_HELP:
                    DoHelp(hWnd, TRUE);
                    break;
            }
            break;

        case WM_DESTROY:
            SaveCurrentFont(hWnd);
            SaveCurrentSubset(hWnd);
            DoHelp(hWnd, FALSE);
            DeleteObject(hStaticBrush);
            PostQuitMessage(0);
            break;

        case WM_ACTIVATEAPP:
            if (wParam) {
                SendDlgItemMessage(hWnd, ID_STRING, EM_SETSEL, LOWORD(lEditSel), HIWORD(lEditSel));
            } else {
                lEditSel = (LONG)SendDlgItemMessage(hWnd, ID_STRING, EM_GETSEL, 0, 0L);
                SendDlgItemMessage(hWnd, ID_STRING, EM_SETSEL, 0, 0L);
            }
            break;


    }
    return (FALSE);
}



/****************************************************************************

    FUNCTION: CharGridWndProc(HWND, UINT, WPARAM, LPARAM)

    PURPOSE:  Processes messages for the character grid window.

    COMMENTS:

****************************************************************************/

LRESULT  APIENTRY CharGridWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{

    switch (message) {
        case WM_CREATE:
                {
                RECT rect;
                HDC hdcScrn;
                POINT point1, point2;

                // Setup global.
                hwndCharGrid = hWnd;

                GetClientRect(hWnd, &rect);

                /*
                 * Calculate metrics for the character grid and the
                 * magnify window.
                 */
                sycm.dxpBox = (rect.right-1)  / (cchSymRow + 1);
                sycm.dypBox = (rect.bottom-2) / (cchSymCol + 1);
                sycm.dxpCM  = sycm.dxpBox * cchSymRow+1;
                sycm.dypCM  = sycm.dypBox * cchSymCol+1;        // space inside for border

                sycm.dxpMag = sycm.dxpBox * 2 + 4;      // twice the size + 2 bit border
                sycm.dypMag = sycm.dypBox * 2 + 4;

                sycm.chCurr   = chSymFirst;
                sycm.hFontMag = NULL;
                sycm.hFont    = NULL;
                sycm.hdcMag   = NULL;
                sycm.hbmMag   = NULL;
                sycm.ypDest   = 0;

                sycm.fFocusState = sycm.fMouseDn = sycm.fCursorOff = FALSE;

                // Size the window precisely so the grid fits and is centered.
                MoveWindow(hWnd, (rect.right - sycm.dxpCM + 1) / 2,
                                 (rect.bottom - sycm.dypCM + 1) / 2 + ((LPCREATESTRUCT)lParam)->y - 2,
                                 sycm.dxpCM + 2,
                                 sycm.dypCM + 2,
                                 FALSE);

                /*
                 * Figure out what the offsets are between the dialog
                 * and the character grid window.
                 */
                point1.x = point1.y = point2.x = point2.y = 0;
                ClientToScreen(hWnd, &point1);
                ClientToScreen(((LPCREATESTRUCT)lParam)->hwndParent, &point2);
                sycm.xpCM = (point1.x - point2.x) - (sycm.dxpMag - sycm.dxpBox) / 2;
                sycm.ypCM = (point1.y - point2.y) - (sycm.dypMag - sycm.dypBox) / 2;


                // Create dc and bitmap for the magnify window.
                if ((hdcScrn = GetWindowDC(hWnd)) != NULL)
                        {
                        if ((sycm.hdcMag = CreateCompatibleDC(hdcScrn)) != NULL)
                                {
                                SetTextColor(sycm.hdcMag,
                                             GetSysColor(COLOR_WINDOWTEXT));
                                SetBkColor(sycm.hdcMag,
                                           GetSysColor(COLOR_WINDOW));
                                SetBkMode(sycm.hdcMag, OPAQUE);
                                if ((sycm.hbmMag = CreateCompatibleBitmap(hdcScrn,
                                         sycm.dxpMag, sycm.dypMag*2)) == NULL)
                                        {
                                        DeleteObject(sycm.hdcMag);
                                        }
                                else
                                        {
                                        SelectObject(sycm.hdcMag, sycm.hbmMag);
                                        }
                                }
                        ReleaseDC(hWnd, hdcScrn);
                        }
                }
            break;

        case WM_DESTROY:
            if (sycm.fMouseDn)
                ExitMagnify(hWnd, &sycm);
            if (fDelClipboardFont)
                DeleteObject(hFontClipboard);
            if (sycm.hFont != NULL)
                DeleteObject(sycm.hFont);
            if (sycm.hFontMag != NULL)
                DeleteObject(sycm.hFontMag);
            if (sycm.hdcMag != NULL)
                DeleteDC(sycm.hdcMag);
            if (sycm.hbmMag != NULL)
                DeleteObject(sycm.hbmMag);
            break;

        case WM_SETFOCUS:
        case WM_KILLFOCUS:
            RestoreSymMag(&sycm);
            DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, TRUE, message == WM_SETFOCUS);
            break;

        case WM_LBUTTONDOWN:
            {
            RECT rect;

            // Don't draw anything if there's an update region pending.
            if (GetUpdateRect(hWnd, (LPRECT)&rect, FALSE) != 0)
                break;

            SetFocus(hWnd);
            SetCapture(hWnd);

            sycm.fMouseDn = TRUE;

            if (!FMagData(&sycm))
                DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, FALSE, FALSE);

            }

            // Fall through to WM_MOUSEMOVE

        case WM_MOUSEMOVE:
            if (sycm.fMouseDn) {
               POINT pt;
               UTCHAR chMouseSymbol;

               pt.x = LOWORD(lParam);
               pt.y = HIWORD(lParam);
                ClientToScreen(hWnd, (LPPOINT)&pt);
                if (WindowFromPoint(pt) == hWnd) {
                    ScreenToClient(hWnd, (LPPOINT)&pt);
                    // convert back to a 'points'-like thing
                    lParam = MAKELONG((WORD)pt.x, (WORD)pt.y);
                    chMouseSymbol = (UTCHAR)ChFromSymLParam(&sycm, lParam);
                    if (chMouseSymbol > chSymLast) {
                        //
                        // We're outside of current character range (but still
                        // within the grid).  Restore cursor and leave
                        // magnified character.
                        //
                        if (sycm.fCursorOff) {
                            sycm.fCursorOff = FALSE;
                            ShowCursor(TRUE);
                        }
                    } else {
                        //
                        // We're in the grid and within the range of currently
                        // displayed characters, display magnified character.
                        //
                        if (!sycm.fCursorOff) {
                            sycm.fCursorOff = TRUE;
                            ShowCursor(FALSE);
                        }
                        MoveSymbolSel(&sycm, chMouseSymbol);
                    }
                } else {
                    // Left grid, leave magnified character and restore cursor.
                    if (sycm.fCursorOff) {
                        sycm.fCursorOff = FALSE;
                        ShowCursor(TRUE);
                    }
                }
            }
            break;

        case WM_CANCELMODE:
        case WM_LBUTTONUP:
            if (sycm.fMouseDn)
                ExitMagnify(hWnd, &sycm);

            break;

        case WM_LBUTTONDBLCLK:
            // Send this character to the entry field.
            SendDlgItemMessage(hwndDialog, ID_STRING, WM_CHAR,
                               (WPARAM)sycm.chCurr, 0L);
            break;

        case WM_GETDLGCODE:
            // Necessary to obtain arrow and tab messages.
            return (DLGC_WANTARROWS | DLGC_WANTCHARS);
            break;

        case WM_KEYDOWN:
                {
                UTCHAR chNew = sycm.chCurr;

                if (sycm.fMouseDn)
                    break;

                switch (wParam)
                        {
                case VK_LEFT:
                        if (--chNew < chSymFirst)
                                return 0L;
                        break;

                case VK_UP:
                        if ((chNew -= (UTCHAR)cchSymRow) < chSymFirst)
                                return 0L;
                        break;

                case VK_RIGHT:
                        if (++chNew > chSymLast)
                                return 0L;
                        break;

                case VK_DOWN:
                        if ((chNew += (UTCHAR)cchSymRow) > chSymLast)
                                return 0L;
                        break;

                default:
                                return 0L;
                        }       /* switch (wParam) */

                if (!FMagData(&sycm))
                        DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, FALSE, FALSE);
                MoveSymbolSel(&sycm, (UTCHAR)chNew);
                }
                break;

        case WM_CHAR:
                if (sycm.fMouseDn)
                    break;

                if (wParam >= chSymFirst  &&  wParam <= chSymLast) {
                    if (!FMagData(&sycm))
                        DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, FALSE, FALSE);
                    MoveSymbolSel(&sycm, (UTCHAR) wParam);
                    SendDlgItemMessage(hwndDialog, ID_STRING, WM_CHAR,
                                       (WPARAM)sycm.chCurr, 0L);
                }
                break;

        case WM_PAINT:
            {
            HDC hdc;
            PAINTSTRUCT ps;

            hdc = BeginPaint(hWnd, &ps);
            DrawSymbolMap(&sycm, hdc);
            EndPaint(hWnd, &ps);
                return (TRUE);
            }

        default:                          /* Passes it on if unproccessed    */
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return 0L;
}

/****************************************************************************

    FUNCTION: ChFromSymLParam(PSYCM, LPARAM)

    PURPOSE:  Determine the character to select from the mouse
              position (lParam)

    COMMENTS:

****************************************************************************/

INT ChFromSymLParam(
    PSYCM psycm,
    LPARAM lParam)
{
        return min(cchSymRow-1, max(0, ((INT) LOWORD(lParam)-1) / psycm->dxpBox))
                 + min(cchSymCol-1, max(0, ((INT) HIWORD(lParam)-1) / psycm->dypBox))
                        * cchSymRow + chSymFirst;
}


/****************************************************************************

    FUNCTION: DrawSymChOutlineHwnd(PSYCM, HWND, UTCHAR, BOOL, BOOL);

    PURPOSE:  Gets a DC for hwnd, calls DrawSymChOutline.

    COMMENTS:

****************************************************************************/

VOID DrawSymChOutlineHwnd(
    PSYCM   psycm,
    HWND    hwnd,
    UTCHAR   ch,
    BOOL    fVisible,
    BOOL    fFocus)
{
        HDC hdc = GetDC(hwnd);
        DrawSymChOutline(psycm, hdc, ch, fVisible, fFocus);
        ReleaseDC(hwnd, hdc);
}

/****************************************************************************

    FUNCTION: RecalcCharMap(HWND, PSYCM, int, BOOL);

    PURPOSE:  Recalculate fixed character map data (font info, sizes, etc.)

    COMMENTS:

****************************************************************************/

VOID RecalcCharMap(
    HWND hwndDlg,
    PSYCM psycm,
    INT iCombo,
    BOOL fRedraw)
{
        HDC          hdc;
        TEXTMETRIC   tm;
        UINT         ch;
        LPINT        lpdxp;
        HFONT        hFont;
        LOGFONT      LogFont;

        // Get rid of the old font handles.
        if (hFontClipboard && hFontClipboard == psycm->hFont)
            fDelClipboardFont = TRUE;
        if (psycm->hFont && hFontClipboard != psycm->hFont)
            DeleteObject(psycm->hFont);
        if (psycm->hFontMag)
            DeleteObject(psycm->hFontMag);

        hdc = GetDC(hwndCharGrid);

        /*
         * Set up the LogFont structure.
         */
        // Make sure it fits in the grid.
        LogFont.lfHeight = psycm->dypBox - 3; // Allow for whitespace.
        // Set these guys to zero.
        LogFont.lfWidth = LogFont.lfEscapement = LogFont.lfOrientation =
                          LogFont.lfWeight = 0;
        // Set these at zero too.
        LogFont.lfItalic = LogFont.lfUnderline = LogFont.lfStrikeOut =
            LogFont.lfOutPrecision = LogFont.lfClipPrecision =
            LogFont.lfQuality = LogFont.lfPitchAndFamily = 0;
        // Let the facename and size define the font.
        LogFont.lfCharSet = ANSI_CHARSET;
        // Get the facename from the combo box.
        SendDlgItemMessage(hwndDlg, ID_FONT, CB_GETLBTEXT, iCombo,
                           (LPARAM)(LPTSTR)LogFont.lfFaceName);

        /*
         * 27 Oct 92   GregoryW
         *   For now we don't have a way to determine if this is a
         *   Unicode font or an ANSI font.  The best we can do is
         *   look at the face name to see if it is the one Unicode
         *   font we recognize.
         */
        if (!lstrcmpi(LogFont.lfFaceName, TEXT("Lucida Sans Unicode"))) {
            LONG iCurSel;

            psycm->fAnsiFont = FALSE;
            // Enable Block listbox and set defaults appropriately.
            EnableWindow(GetDlgItem(hwndDlg, ID_UNICODESUBSET), TRUE);
            iCurSel = (LONG)SendDlgItemMessage(
                          hwndDlg,
                          ID_UNICODESUBSET,
                          CB_GETCURSEL,
                          0,
                          0L
                          );
            UpdateSymbolSelection(
                hwndDlg,
                aSubsetData[iCurSel].BeginRange,
                aSubsetData[iCurSel].EndRange
                );
            // Enable Previous button if not on first subset.
            if (iCurSel > 0) {
                EnableWindow(GetDlgItem(hwndDlg, ID_PREVSUBSET), TRUE);
            } else {
                EnableWindow(GetDlgItem(hwndDlg, ID_PREVSUBSET), FALSE);
            }
            // Enable Next button if not on last subset.
            if (iCurSel < (cSubsets - 1)) {
                EnableWindow(GetDlgItem(hwndDlg, ID_NEXTSUBSET), TRUE);
            } else {
                EnableWindow(GetDlgItem(hwndDlg, ID_NEXTSUBSET), FALSE);
            }
        } else {
            // put back the ANSI defaults and disable Unicode Block listbox
            psycm->fAnsiFont = TRUE;
            UpdateSymbolSelection(hwndDlg, 32, 255);
            EnableWindow(GetDlgItem(hwndDlg, ID_UNICODESUBSET), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, ID_NEXTSUBSET), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, ID_PREVSUBSET), FALSE);
        }

        // Create the font.
        psycm->hFont = CreateFontIndirect(&LogFont);
        hFont = SelectObject(hdc, psycm->hFont);

        // Create the magnify font.
        LogFont.lfHeight = psycm->dypMag - 5;  // Allow for whitespace.
        psycm->hFontMag = CreateFontIndirect(&LogFont);

        /*
         * Calculate new values and place in window data structure.
         */
        GetTextMetrics(hdc, &tm);
        psycm->xpCh = 2;
        psycm->ypCh = (4 + psycm->dypBox - tm.tmHeight) / 2;

        lpdxp = (LPINT) psycm->rgdxp;

        GetCharWidth(hdc, chSymFirst, chSymLast, lpdxp);

        SelectObject(hdc, hFont);

        for (ch = (UINT) chSymFirst; ch <= (UINT) chSymLast; ch++, lpdxp++)
                {
                    *lpdxp = (psycm->dxpBox - *lpdxp) / 2 - 1;
                }
        ReleaseDC(hwndCharGrid, hdc);

        psycm->xpMagCurr = 0;   // No magnification data

        if (fRedraw)
            InvalidateRect(hwndCharGrid, NULL, TRUE);
}

/****************************************************************************

    FUNCTION: DrawSymbolMap(PSYCM, HDC);

    PURPOSE:  Draw all of the pieces of the symbol character map

    COMMENTS:

****************************************************************************/

VOID DrawSymbolMap(
    PSYCM psycm,
    HDC     hdc)
{
        BOOL fFocus;

        DrawSymbolGrid(psycm, hdc);
        DrawSymbolChars(psycm, hdc);
        /*
         * We need to force the focus rect to paint if we have the focus
         * since the old focus rect has been drawn over already.
         */
        if (fFocus = psycm->fFocusState)
            psycm->fFocusState = FALSE;
        DrawSymChOutline(psycm, hdc, psycm->chCurr, TRUE, fFocus);
}


void MoveTo(HDC hdc, int x, int y){

   MoveToEx(hdc, x, y, NULL);
}

/****************************************************************************

    FUNCTION: DrawSymbolGrid(PSYCM, HDC);

    PURPOSE:  Draw the symbol character map grid.

    COMMENTS:

****************************************************************************/

VOID DrawSymbolGrid(
    PSYCM psycm,
    HDC hdc)
{
        INT    cli;             /* Count of lines */
        INT    xp, yp;
        INT    dxpBox  = psycm->dxpBox;
        INT    dypBox  = psycm->dypBox;
        HPEN   hpenOld;

        hpenOld = SelectObject(hdc, CreatePen(PS_SOLID, 1,
                                              GetSysColor(COLOR_WINDOWFRAME)));

        // Draw horizontal lines.
        xp = psycm->dxpCM + 1;
        yp = 1;
        cli = cchSymCol+1;
        while (cli--)
                {
                MoveTo(hdc, 1, yp);
                LineTo(hdc, xp, yp);
                yp += dypBox;
                }

        // Draw vertical lines.
        yp = psycm->dypCM;
        xp = 1;
        cli = cchSymRow+1;
        while (cli--)
                {
                MoveTo(hdc, xp, 1);
                LineTo(hdc, xp, yp);
                xp += dxpBox;
                }

        DeleteObject(SelectObject(hdc, hpenOld));
}

/****************************************************************************

    FUNCTION: DrawSymbolChars(PSYCM, HDC);

    PURPOSE:  Draw the symbol character map.

    COMMENTS:

****************************************************************************/

VOID DrawSymbolChars(
    PSYCM psycm,
    HDC     hdc)
{
        INT    dxpBox  = psycm->dxpBox;
        INT    dypBox  = psycm->dypBox;

        INT    cch;
        INT    x, y;
        INT    yp;
        TCHAR   ch;

        HFONT  hFontOld;

        RECT   rect;
        LPRECT lprect = (LPRECT) &rect;
        LPINT lpdxp;

        // Setup the font and colors.
        hFontOld = (HFONT) SelectObject(hdc, psycm->hFont);
        SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
        SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
        SetBkMode(hdc, OPAQUE);

        // Draw characters.
        cch = 1;
        ch = chSymFirst;

        lpdxp = (LPINT) psycm->rgdxp;

        rect.top = 2;
        yp = psycm->ypCh;
        rect.bottom = rect.top + dypBox - 1;

        for (y = 0; y++ < cchSymCol;)
                {
                rect.left  = psycm->xpCh;
                rect.right = rect.left + dxpBox - 1;
                for (x = 0; x++ < cchSymRow && ch <= chSymLast;)
                        {
                        if (psycm->fAnsiFont) {
                            ExtTextOutA(hdc, rect.left + (*lpdxp++), yp,
                                ETO_OPAQUE | ETO_CLIPPED, lprect, &(CHAR)ch, 1, NULL);
                        } else
                            ExtTextOutW(hdc, rect.left + (*lpdxp++), yp,
                                ETO_OPAQUE | ETO_CLIPPED, lprect, &ch, 1, NULL);
                        ch++;
                        rect.left  += dxpBox;
                        rect.right += dxpBox;
                        }
                yp += dypBox;
                rect.top += dypBox;
                rect.bottom += dypBox;
                }

        SelectObject(hdc, hFontOld);
}

/****************************************************************************

    FUNCTION: DrawSymChOutline(PSYCM, HDC, UTCHAR, BOOL, BOOL);

    PURPOSE:  Draw an outline around the symbol in the character map

    COMMENTS: If fVisible, draw outline else erase it.

****************************************************************************/

VOID DrawSymChOutline(
    PSYCM   psycm,
    HDC     hdc,
    UTCHAR   ch,
    BOOL    fVisible,
    BOOL    fFocus)
{
        HBRUSH hbrOld;
        RECT rc;
        INT dxpBox = psycm->dxpBox;
        INT dypBox = psycm->dypBox;

        hbrOld = SelectObject(hdc,
                              CreateSolidBrush(GetSysColor(fVisible ?
                                                           COLOR_WINDOWFRAME :
                                                           COLOR_WINDOW)));
        ch -= chSymFirst;

        rc.left   = (ch % cchSymRow) * dxpBox +2;
        rc.right  = rc.left + dxpBox -1;
        rc.top    = (ch / cchSymRow) * dypBox +2;
        rc.bottom = rc.top  + dypBox -1;

        // Draw selection rectangle.
        PatBlt( hdc, rc.left,    rc.top-2,    dxpBox-1, 1, PATCOPY);
        PatBlt( hdc, rc.left,    rc.bottom+1, dxpBox-1, 1, PATCOPY);
        PatBlt( hdc, rc.left-2,  rc.top,      1, dypBox-1, PATCOPY);
        PatBlt( hdc, rc.right+1, rc.top,      1, dypBox-1, PATCOPY);

        DeleteObject(SelectObject(hdc, GetStockObject(NULL_BRUSH)));

        // Deal with the focus rectangle.
        if (fFocus != psycm->fFocusState) {
            DrawFocusRect(hdc, &rc);
            psycm->fFocusState = fFocus;
        }

        SelectObject(hdc, hbrOld);
}


/****************************************************************************

    FUNCTION: MoveSymbolSel(PSYCM, UTCHAR);

    PURPOSE:  Change the current symbol selection.  Handles drawing of
              magnified characters.

    COMMENTS:

****************************************************************************/

VOID MoveSymbolSel(
    PSYCM psycm,
    UTCHAR chNew)
{
        HDC    hdc;
        HDC    hdcMag  = psycm->hdcMag;
        RECT   rc;
        HFONT  hFontOld;
        HFONT  hFontMag;        // old font in memory dc
        HPEN   hpenOld;

        UTCHAR chNorm = chNew - chSymFirst + 32;
        INT dxpMag = psycm->dxpMag;     // for quick reference
        INT dypMag = psycm->dypMag;
        INT ypMemSrc  = psycm->ypDest;
        INT ypMemDest = ypMemSrc ^ dypMag;
        INT xpCurr  = psycm->xpMagCurr;
        INT ypCurr  = psycm->ypMagCurr;
        INT xpNew   = psycm->xpCM + (psycm->dxpBox *  (chNorm % cchSymRow));
        INT ypNew   = psycm->ypCM + (psycm->dypBox * ((chNorm / cchSymRow) - 1));
        INT dxpCh;      // width of extra character space (used to center char in box)
        INT dypCh;

        if (((chNew == (UTCHAR)psycm->chCurr) && FMagData(psycm)))
                return;

        /*
         * Don't draw a magnified character if the char grid has an update
         * region or is not visible.
         */
        if (!IsWindowVisible(hwndCharGrid) || GetUpdateRect(hwndCharGrid, &rc, FALSE))
            return;

        hdc = GetDC(hwndDialog);

        // Setup the magnified font character.
        hFontMag = SelectObject(hdcMag, psycm->hFontMag);
        { SIZE sz;
          GetTextExtentPoint(hdcMag, &chNew, 1, &sz);

          dxpCh = (dxpMag - (INT)sz.cx) / 2 - 1;
          dypCh = (dypMag - (INT)sz.cy) / 2 - 1;
        }
        hpenOld = SelectObject(hdc, CreatePen(PS_SOLID, 1,
                                              GetSysColor(COLOR_WINDOWFRAME)));
        hFontOld = SelectObject(hdc, psycm->hFontMag);

        // Copy screen data to offscreen bitmap.
        BitBlt(hdcMag, 0, ypMemDest, dxpMag, dypMag, hdc, xpNew, ypNew, SRCCOPY);

        // Setup DC.
        SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
        SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
        SetBkMode(hdc, OPAQUE);

        if (FMagData(psycm))
                {
                INT xpT  = xpNew - xpCurr;              // point of overlap in offscreen data
                INT ypT  = ypNew - ypCurr;
                INT dxpT = dxpMag - abs(xpT);   // size of overlap
                INT dypT = dypMag - abs(ypT);

                if ((dxpT > 0) && (dypT > 0))
                        {
                        INT xpTmax,  ypTmax;   // max(0, xpT);
                        INT xpTmin,  ypTmin;   // min(0, xpT);
                        INT xpTnmin, ypTnmin;  // min(0, -xpT);

                        if (xpT < 0)
                                {
                                xpTnmin = - (xpTmin = xpT);
                                xpTmax  = 0;
                                }
                        else
                                {
                                xpTmax  = xpT;
                                xpTnmin = xpTmin = 0;
                                }
                        if (ypT < 0)
                                {
                                ypTnmin = - (ypTmin = ypT);
                                ypTmax  = 0;
                                }
                        else
                                {
                                ypTmax  = ypT;
                                ypTnmin = ypTmin = 0;
                                }

                        rc.left  = xpTmax;
                        rc.right = xpTmin + dxpMag;
                        rc.top   = ypTmax + ypMemSrc;
                        rc.bottom= ypTmin + dypMag + ypMemSrc;

                        // Copy overlapping offscreen data.
                        BitBlt(hdcMag, xpTnmin, ypTnmin + ypMemDest, dxpT, dypT,
                                   hdcMag, xpTmax,  ypTmax  + ypMemSrc, SRCCOPY);

                        // Print part of char over old screen data.
                        if (psycm->fAnsiFont) {
                            ExtTextOutA(hdcMag, xpT + dxpCh, ypT + dypCh + ypMemSrc,
                                ETO_OPAQUE | ETO_CLIPPED, (LPRECT) &rc, &(CHAR)chNew, 1, NULL);
                        } else
                            ExtTextOutW(hdcMag, xpT + dxpCh, ypT + dypCh + ypMemSrc,
                                ETO_OPAQUE | ETO_CLIPPED, (LPRECT) &rc, &chNew, 1, NULL);

                        }

                // Restore old screen data.
                BitBlt(hdc, xpCurr, ypCurr, dxpMag, dypMag, hdcMag, 0, ypMemSrc, SRCCOPY);

                }

        rc.right  = (psycm->xpMagCurr = rc.left = xpNew) + dxpMag - 2;
        rc.bottom = (psycm->ypMagCurr = rc.top  = ypNew) + dypMag - 2;


        // The rectangle.
        MoveTo(hdc, rc.left, rc.top);
        LineTo(hdc, rc.left, rc.bottom - 1);
        LineTo(hdc, rc.right - 1, rc.bottom - 1);
        LineTo(hdc, rc.right - 1, rc.top);
        LineTo(hdc, rc.left, rc.top);

        // The shadow.
        MoveTo(hdc, rc.right, rc.top + 1);
        LineTo(hdc, rc.right, rc.bottom);
        LineTo(hdc, rc.left, rc.bottom);
        MoveTo(hdc, rc.right + 1, rc.top + 2);
        LineTo(hdc, rc.right + 1, rc.bottom + 1);
        LineTo(hdc, rc.left + 1, rc.bottom + 1);

        rc.left++;
        rc.top++;
        rc.right--;
        rc.bottom--;

        // Draw magnified character on screen.
        if (psycm->fAnsiFont) {
            ExtTextOutA(hdc, xpNew + dxpCh, ypNew + dypCh,
                   ETO_OPAQUE | ETO_CLIPPED, (LPRECT) &rc, &(CHAR)chNew, 1, NULL);
        } else
            ExtTextOutW(hdc, xpNew + dxpCh, ypNew + dypCh,
                   ETO_OPAQUE | ETO_CLIPPED, (LPRECT) &rc, &chNew, 1, NULL);

        psycm->ypDest = ypMemDest;

        DeleteObject(SelectObject(hdc, hpenOld));
        SelectObject(hdc, hFontOld);
        SelectObject(hdcMag, hFontMag);

        UpdateKeystrokeText(hdc, chNew, TRUE);

        ReleaseDC(hwndDialog, hdc);

        psycm->chCurr = chNew;
}

/****************************************************************************

    FUNCTION: RestoreSymMag(PSYCM);

    PURPOSE:  Restore the screen data under the magnifier.

    COMMENTS:

****************************************************************************/

VOID RestoreSymMag(
    PSYCM psycm)
{

        if (FMagData(psycm))
                {
                HDC hdc = GetDC(hwndDialog);

                BitBlt(hdc, psycm->xpMagCurr, psycm->ypMagCurr,
                        psycm->dxpMag, psycm->dypMag,
                        psycm->hdcMag, 0, psycm->ypDest, SRCCOPY);

                ReleaseDC(hwndDialog, hdc);

                psycm->xpMagCurr = 0;   // flag - no data offscreen (see FMagData)
                }
}


/****************************************************************************

    FUNCTION: FontLoadProc(LPLOGFONT, NEWTEXTMETRICEX*, short, LPTSTR);

    PURPOSE:  Used by EnumFonts to load our combo box with all the fonts
              installed in the system.

    COMMENTS:

****************************************************************************/

INT  APIENTRY FontLoadProc(LPLOGFONT lpLogFont,
                           NEWTEXTMETRICEX* lpTextMetric,
                           DWORD nFontType,
                           LPARAM lpData)
{
    INT iPos;
    TCHAR szFace[LF_FACESIZE];

    // Check for duplicates.
    iPos = (INT)SendDlgItemMessage((HWND)lpData, ID_FONT, CB_FINDSTRING, (WPARAM)-1,
                                  (LPARAM)&lpLogFont->lfFaceName);

    if (iPos == CB_ERR) {
NotInListYet:
        // Doesn't exist, insert the facename into the combo box.
        iPos = (INT)SendDlgItemMessage((HWND)lpData, ID_FONT,
                                       CB_ADDSTRING, 0,
                                       (LPARAM)&lpLogFont->lfFaceName);
    } else {

        // make sure it is not just a substring (want a full match)
        SendDlgItemMessage((HWND)lpData, ID_FONT, CB_GETLBTEXT, iPos, (LPARAM)(LPTSTR)szFace);
        if (lstrcmpi(szFace, lpLogFont->lfFaceName))
            goto NotInListYet;

        // Already exists, blow out now if this is not a true type font.
        if (!(nFontType & TRUETYPE_FONTTYPE))
            return (1);
    }

    /*
     * Store the pertinant font information in the combo item data.
     */
    if ((iPos != CB_ERR) && (iPos != CB_ERRSPACE)) {
        ITEMDATA ItemData;
        DWORD   ntmFlags = lpTextMetric->ntmTm.ntmFlags;
        SHORT   sFontType = 0;

        if (ntmFlags & NTM_PS_OPENTYPE)
        {
            sFontType = PS_OPENTYPE_FONT;
        }
        else if (ntmFlags & NTM_TYPE1)
        {
            sFontType = TYPE1_FONT;
        }
        else if (nFontType & TRUETYPE_FONTTYPE)
        {
            if (ntmFlags & NTM_TT_OPENTYPE)
            {
                sFontType = TT_OPENTYPE_FONT;
            }
            else
                sFontType = TRUETYPE_FONT;
        }

        ItemData.FontType = sFontType;
        ItemData.CharSet = lpLogFont->lfCharSet;
        ItemData.PitchAndFamily = lpLogFont->lfPitchAndFamily;

        SendDlgItemMessage((HWND)lpData, ID_FONT, CB_SETITEMDATA, iPos,
                           *(DWORD *)&ItemData);
    }

    // Continue enumeration.
    return (1);
}

/****************************************************************************

    FUNCTION: GetEditText(HWND);

    PURPOSE:  Returns HANDLE containing the text in the edit control.

    COMMENTS: Caller is responsible for freeing this handle!

****************************************************************************/

HANDLE GetEditText(
    HWND hwndDlg)
{
    INT cchText;
    HWND hwndEditCtl;
    HANDLE hmem;
    LPTSTR lpstrText;
    LRESULT dwSel;

    hwndEditCtl = GetDlgItem(hwndDlg, ID_STRING);

    cchText = GetWindowTextLength(hwndEditCtl);

    hmem = GlobalAlloc(0, CTOB((cchText + 1)));

    lpstrText = (LPTSTR)GlobalLock(hmem);

    cchText = GetWindowText(hwndEditCtl, lpstrText, cchText+1);

    dwSel = SendMessage(hwndEditCtl, EM_GETSEL, 0, 0L);

    if (LOWORD(dwSel) != HIWORD(dwSel)) {
        // If there is a selection, then only get the selected text.
        *(lpstrText + HIWORD(dwSel)) = TEXT('\0');
        lstrcpy(lpstrText, lpstrText + LOWORD(dwSel));
    }

    GlobalUnlock(hmem);

    if (cchText == 0)
        hmem = GlobalFree(hmem);

    return (hmem);
}

/****************************************************************************

    FUNCTION: CopyString(HWND);

    PURPOSE:  Implement the Copy function.

    COMMENTS:

****************************************************************************/

VOID CopyString(
    HWND hwndDlg)
{
    HANDLE hmem;
    LPTSTR lpstrText;

    if (hmem = GetEditText(hwndDlg)) {
        lpstrText = (LPTSTR)GlobalLock(hmem);

        // Copying string to clipboard.
        if (OpenClipboard(hwndDlg)) {
            EmptyClipboard();
            SendRTFToClip(hwndDlg, lpstrText);
#ifdef UNICODE
            SetClipboardData(CF_UNICODETEXT, hmem);
#else
            SetClipboardData(CF_TEXT, hmem);
#endif
            CloseClipboard();
        } else {
            // If we couldn't open the clipboard, then we need to free memory.
            GlobalUnlock(hmem);
            GlobalFree(hmem);
        }
    }
}

/****************************************************************************

    FUNCTION: SendRTFToClip(HWND, LPTSTR);

    PURPOSE:  Put the string in the clipboard using Rich Text Format.

    COMMENTS: Assumes that the clipboard has already been opened.

****************************************************************************/

VOID SendRTFToClip(
    HWND hwndDlg,
    LPTSTR lpstrText)
{
    INT iCurrFont;
    ITEMDATA ItemData;
    TCHAR szFaceName[LF_FACESIZE];
    HANDLE hmemRTF, hmemClip;
    LPTSTR lpstrClipString;
    TCHAR achHeader[] = TEXT("{\\rtf1\\ansi {\\fonttbl{\\f0\\");
    TCHAR achMiddle[] = TEXT(";}}\\sectd\\pard\\plain\\f0 ");

    #define MAXLENGTHFONTFAMILY 8
    #define ALITTLEEXTRA 10    // Covers extra characters + length of font size.

    iCurrFont = (INT)SendDlgItemMessage(hwndDlg, ID_FONT, CB_GETCURSEL, 0, 0L);

    // Get the item data - contains fonttype, charset, and pitchandfamily.
    *(DWORD *)&ItemData = (DWORD)SendDlgItemMessage(hwndDlg, ID_FONT, CB_GETITEMDATA,
                                             iCurrFont, 0L);

    // Get the facename from the combo box.
    SendDlgItemMessage(hwndDlg, ID_FONT, CB_GETLBTEXT, iCurrFont,
                       (LPARAM)(LPTSTR)szFaceName);

    hmemRTF = GlobalAlloc(0, CTOB(lstrlen((LPTSTR)achHeader) +
                          MAXLENGTHFONTFAMILY +
                          lstrlen(szFaceName) +
                          lstrlen((LPTSTR)achMiddle) +
                          4 * lstrlen(lpstrText) +  // 4 times in case they're all > 7 bits
                          ALITTLEEXTRA));
    if (hmemRTF == NULL)
        return;

    // Allocate memory for local storage of clipboard string for owner draw.
    if (hmemClip  = GlobalAlloc(0, CTOB(lstrlen(lpstrText) + 1))) {
        // Get rid of old guys.
        if (hstrClipboard)
            GlobalFree(hstrClipboard);
        if (fDelClipboardFont) {
            fDelClipboardFont = FALSE;
            DeleteObject(hFontClipboard);
        }

        // Save this stuff away for owner drawing in a clipboard viewer.
        hFontClipboard = sycm.hFont;
        hstrClipboard = hmemClip;
        lstrcpy(GlobalLock(hstrClipboard), lpstrText);
        GlobalUnlock(hstrClipboard);
    } else {
        GlobalFree(hmemRTF);
        return;
    }

    lpstrClipString = GlobalLock(hmemRTF);

    lstrcpy(lpstrClipString, achHeader);

    if (ItemData.CharSet == SYMBOL_CHARSET) {
        lstrcat(lpstrClipString, (LPTSTR)TEXT("ftech "));
    } else {
        // top four bits specify family
        switch (ItemData.PitchAndFamily & 0xf0) {
            case FF_DECORATIVE:
                lstrcat(lpstrClipString, (LPTSTR)TEXT("fdecor "));
                break;

            case FF_MODERN:
                lstrcat(lpstrClipString, (LPTSTR)TEXT("fmodern "));
                break;

            case FF_ROMAN:
                lstrcat(lpstrClipString, (LPTSTR)TEXT("froman "));
                break;

            case FF_SCRIPT:
                lstrcat(lpstrClipString, (LPTSTR)TEXT("fscript "));
                break;

            case FF_SWISS:
                lstrcat(lpstrClipString, (LPTSTR)TEXT("fswiss "));
                break;

            default:
                break;
        }
    }

    lstrcat(lpstrClipString, szFaceName);

    lstrcat(lpstrClipString, (LPTSTR)achMiddle);

    /*
     * We need to do the text character by character, making sure
     * that we output a special sequence \'hh for characters bigger
     * than 7 bits long!
     */
    lpstrClipString = (LPTSTR)(lpstrClipString + lstrlen(lpstrClipString));
    while (*lpstrText) {
        if ((UTCHAR)*lpstrText < 128) {
            if (*lpstrText == TEXT('\\') || *lpstrText == TEXT('{') || *lpstrText == TEXT('}'))
                /*
                 * Need to preface these symbols with a '\' since they are
                 * special control characters for RTF.
                 */
                *lpstrClipString++ = TEXT('\\');

            *lpstrClipString++ = *lpstrText++;
        } else {
            *lpstrClipString++ = TEXT('\\');
            *lpstrClipString++ = TEXT('\'');
#ifdef BUG
//
//PERF - GregoryW 23/10/92  need a Unicode version of itoa...
//
            _itoa(*(UTCHAR FAR *)lpstrText++, achMiddle, 16);
#else
            wsprintf(achMiddle, TEXT("%x"), (INT)*lpstrText);
            lpstrText++;
#endif
            *lpstrClipString++ = achMiddle[0];
            *lpstrClipString++ = achMiddle[1];
        }
    }
    *lpstrClipString++ = TEXT('}');
    *lpstrClipString = TEXT('\0');

    if (!wCFRichText) {
         TCHAR szRTF[80];

         LoadString(hInst, IDS_RTF, szRTF, BTOC(sizeof(szRTF)) - 1);
         wCFRichText = RegisterClipboardFormat(szRTF);
    }

    // Put RTF and OwnerDisplay formats in the clipboard.
    SetClipboardData(wCFRichText, hmemRTF);
    SetClipboardData(CF_OWNERDISPLAY, NULL);
}

/****************************************************************************

    FUNCTION: PointsToHeight(int);

    PURPOSE:  Calculates the height in pixels of the specified point
              size for the current display.

    COMMENTS:

****************************************************************************/

INT PointsToHeight(INT iPoints)
{
    HDC hdc;
    INT iHeight;

    hdc = GetDC(HWND_DESKTOP);
    iHeight = MulDiv(iPoints, GetDeviceCaps(hdc, LOGPIXELSY), 72);
    ReleaseDC(HWND_DESKTOP, hdc);
    return(iHeight);
}

/****************************************************************************

    FUNCTION: UpdateKeystrokeText(HDC, UTCHAR, BOOL);

    PURPOSE:  Calculates and updates the text string displayed in the
              Keystroke field of the status bar.

    COMMENTS:  Repaints status field if fRedraw == TRUE.

****************************************************************************/

VOID UpdateKeystrokeText(
    HDC hdc,
    UTCHAR chNew,
    BOOL fRedraw)
{
    TCHAR szUnshifted[2];
    SHORT vkRes;

#ifdef UNICODE
    if (chNew > 255) {
        lstrcpy(szKeystrokeText, szUnicodeLabel);
        wsprintf((LPTSTR)(szKeystrokeText + iUnicodeLabelStart), TEXT("U+%04x"), chNew);
    } else {
#endif
    lstrcpy(szKeystrokeText, szKeystrokeLabel);
    if (chNew == TEXT(' ')) {
        lstrcpy((LPTSTR)(szKeystrokeText + iKeystrokeTextStart), szSpace);
    } else {
        vkRes = VkKeyScan(chNew);
        /*
         * Map the virtual key code into an unshifted character value
         */
        szUnshifted[0] = (TCHAR)MapVirtualKey(LOBYTE(vkRes), 2);
        szUnshifted[1] = TEXT('\0');

        switch(HIBYTE(vkRes)) {
            case 0: // Unshifted char.
            case 1: // Character is shifted, just display the shifted char.
                szKeystrokeText[iKeystrokeTextStart] = chNew;
                szKeystrokeText[iKeystrokeTextStart + 1] = TEXT('\0');
                break;

            case 2: // Character is control character.
                lstrcpy((LPTSTR)(szKeystrokeText + iKeystrokeTextStart), szCtrl);
                lstrcat(szKeystrokeText, (LPTSTR)szUnshifted);
                break;

            case 6: // Character is CONTROL+ALT.
                lstrcpy((LPTSTR)(szKeystrokeText + iKeystrokeTextStart), szCtrlAlt);
                lstrcat(szKeystrokeText, (LPTSTR)szUnshifted);
                break;

            case 7: // Character is SHIFT+CONTROL+ALT.
                lstrcpy((LPTSTR)(szKeystrokeText + iKeystrokeTextStart), szShiftCtrlAlt);
                lstrcat(szKeystrokeText, (LPTSTR)szUnshifted);
                break;

            default: // Character created via Alt + Numpad
                lstrcpy((LPTSTR)(szKeystrokeText + iKeystrokeTextStart), szAlt);
                wsprintf((LPTSTR)(szKeystrokeText + lstrlen(szKeystrokeText)), TEXT("%d"), chNew);
                break;
        }
    }
#ifdef UNICODE
    }
#endif

    if (fRedraw)
        PaintStatusLine(hdc, FALSE, TRUE);
}


/****************************************************************************

    FUNCTION: UpdateHelpText(LPMSG, HWND);

    PURPOSE:  Calculates if the Help string needs to be updated, and does
              so if necessary.

    COMMENTS:  If hwndCtrl is not NULL, then it specifies the window handle
               of the control gaining focus, and lpmsg is ignored.

               If hwndCtrl is NULL, then lpmsg must point to a valid message
               structure.  If it is a tab character, then we calculate
               what the next control is that will receive the focus.
****************************************************************************/

BOOL UpdateHelpText(
    LPMSG lpmsg,
    HWND hwndCtrl)
{
    HDC hdc;
    BOOL fPaintStatus = FALSE;
    BOOL fRet = TRUE;

    if (hwndCtrl != NULL) {
        fPaintStatus = TRUE;
        iControl = GetDlgCtrlID(hwndCtrl);
    } else  if (lpmsg->message == WM_KEYDOWN) {
        if (lpmsg->wParam == VK_TAB) {
            fPaintStatus = TRUE;
            hwndCtrl = GetNextDlgTabItem(hwndDialog,
                                         GetDlgItem(hwndDialog, iControl),
                                         (BOOL)(GetKeyState(VK_SHIFT) & 0x8000));
            iControl = GetDlgCtrlID(hwndCtrl);
            if (iControl == ID_STRING) {
                /*
                 * Do this ourselves, otherwise default action will select
                 * the whole edit control.
                 */
                SetFocus(hwndCtrl);
                fRet = FALSE;
            }
            if (iControl == ID_CHARGRID) {
                /*
                 * Set the default button back to "Select".  The default
                 * might have changed to the "Next" or "Previous" button.
                 */
                SendMessage(hwndDialog, DM_SETDEFID, ID_SELECT, 0);
            }
        } else if (lpmsg->wParam == VK_F1) {
            PostMessage(hwndDialog, WM_COMMAND, ID_HELP, 0L);
        }
    }

    if (fPaintStatus) {
        hdc = GetDC(hwndDialog);
        PaintStatusLine(hdc, TRUE, FALSE);
        ReleaseDC(hwndDialog, hdc);
    }

    return (fRet);
}

/****************************************************************************

    FUNCTION: UpdateSymbolSelection(HWND, INT, INT);

    PURPOSE:  Updates the values of the following global values:
                  chSymFirst
                  chSymLast
                  sycm.chCurr
              Subsets in the Unicode character set have different numbers
              of characters.  We have to do some bounds checking in order
              to set an appropriate sycm.chCurr value.  The "Keystroke"
              status field is updated.

    COMMENTS:  Repaints Keystroke field if HWND != NULL.

****************************************************************************/
VOID UpdateSymbolSelection(
    HWND hwnd,
    INT FirstChar,
    INT LastChar)
{
    UTCHAR chSymOffset;

    chSymOffset = sycm.chCurr - chSymFirst;
    chSymFirst = (UTCHAR)FirstChar;
    chSymLast = (UTCHAR)LastChar;
    sycm.chCurr = chSymOffset + chSymFirst;
    if (sycm.chCurr > chSymLast) {
        sycm.chCurr = chSymFirst;
    }
    if (hwnd != NULL) {
        HDC hdc;

        hdc = GetDC(hwnd);
        UpdateKeystrokeText(hdc, sycm.chCurr, TRUE);
        ReleaseDC(hwnd, hdc);
    } else {
        UpdateKeystrokeText(NULL, sycm.chCurr, FALSE);
    }
}

/****************************************************************************

    FUNCTION: PaintStatusLine(HDC, BOOL, BOOL);

    PURPOSE:  Paints the Help and Keystroke fields in the status bar.

    COMMENTS:  Repaints Help field if fHelp == TRUE, repaints the Keystroke
               field if fKeystroke == TRUE.

****************************************************************************/

VOID PaintStatusLine(
    HDC hdc,
    BOOL fHelp,
    BOOL fKeystroke)
{
    HFONT hfontOld = NULL;
    RECT rect;
    INT dyBorder;
    TCHAR szHelpText[100];

    dyBorder = GetSystemMetrics(SM_CYBORDER);

    if (hfontStatus)
        hfontOld = SelectObject(hdc, hfontStatus);

    // set the text and background colors

    SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));
    SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));

    if (fHelp) {
        // now the help text, with a gray background

        rect.top    = rcStatusLine.top + 3 * dyBorder;
        rect.bottom = rcStatusLine.bottom - 3 * dyBorder;
        rect.left   = 9 * dyBorder;
        rect.right  = rect.left + dxHelpField - 2 * dyBorder;

        LoadString(hInst, iControl, szHelpText, BTOC(sizeof(szHelpText)) - 1);

        ExtTextOut(hdc, rect.left + dyBorder * 2, rect.top,
                   ETO_OPAQUE | ETO_CLIPPED, &rect, szHelpText,
                   lstrlen(szHelpText), NULL);
    }

    if (fKeystroke) {
        // now the keystroke text, with a gray background
        rect.top    = rcStatusLine.top + 3 * dyBorder;
        rect.bottom = rcStatusLine.bottom - 3 * dyBorder;
        rect.right = rcStatusLine.right - 9 * dyBorder;
        rect.left = rect.right - dxKeystrokeField + 2 * dyBorder;

        ExtTextOut(hdc, rect.left + dyBorder * 2, rect.top,
                   ETO_OPAQUE | ETO_CLIPPED, &rect, szKeystrokeText,
                   lstrlen(szKeystrokeText), NULL);
    }

    if (hfontOld)
        SelectObject(hdc, hfontOld);

}

/****************************************************************************

    FUNCTION: DrawFamilyComboItem(LPDRAWITEMSTRUCT)

    PURPOSE:  Paints the font facenames and TT bitmap in the font combo box.

    COMMENTS:

****************************************************************************/

BOOL DrawFamilyComboItem(
    LPDRAWITEMSTRUCT lpdis)
{
    HDC hDC, hdcMem;
    DWORD rgbBack, rgbText;
    TCHAR szFace[LF_FACESIZE];
    HBITMAP hOld;
    INT dy;
    SHORT  sFontType;

    hDC = lpdis->hDC;

    if (lpdis->itemState & ODS_SELECTED) {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    } else {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    }

    SendMessage(lpdis->hwndItem, CB_GETLBTEXT, lpdis->itemID, (LPARAM)(LPTSTR)szFace);
    ExtTextOut(hDC, lpdis->rcItem.left + DX_BITMAP, lpdis->rcItem.top, ETO_OPAQUE | ETO_CLIPPED, &lpdis->rcItem, szFace, lstrlen(szFace), NULL);

    hdcMem = CreateCompatibleDC(hDC);
    if (hdcMem) {
        if (hbmFont) {
            hOld = SelectObject(hdcMem, hbmFont);
            sFontType = ((ITEMDATA FAR *)&(lpdis->itemData))->FontType;

            if (sFontType)
            {
                int xSrc;

                dy = ((lpdis->rcItem.bottom - lpdis->rcItem.top) - DY_BITMAP) / 2;

                if (sFontType & TRUETYPE_FONT)
                    xSrc = 0;
                else if (sFontType & TT_OPENTYPE_FONT)
                    xSrc = 2;
                else if (sFontType & PS_OPENTYPE_FONT)
                    xSrc = 3;
                else if (sFontType & TYPE1_FONT)
                    xSrc = 4;

                BitBlt(hDC, lpdis->rcItem.left, lpdis->rcItem.top + dy, DX_BITMAP, DY_BITMAP, hdcMem,
                        xSrc*DX_BITMAP, lpdis->itemState & ODS_SELECTED ? DY_BITMAP : 0, SRCCOPY);
            }

            SelectObject(hdcMem, hOld);
        }
        DeleteDC(hdcMem);
    }

    SetTextColor(hDC, rgbText);
    SetBkColor(hDC, rgbBack);

    return TRUE;
}

/****************************************************************************

    FUNCTION: LoadBitmaps(int)

    PURPOSE:  This routine loads DIB bitmaps, and "fixes up" their color tables
              so that we get the desired result for the device we are on.

    COMMENTS: This routine requires:
              - The DIB is a 16 color DIB authored with the standard windows colors.
              - bright blue (00 00 FF) is converted to the background color.
              - light grey  (C0 C0 C0) is replaced with the button face color.
              - dark grey   (80 80 80) is replaced with the button shadow color.

              This means you can't have any of these colors in your bitmap.

****************************************************************************/

HBITMAP LoadBitmaps(INT id)
{
  HDC                   hdc;
  HANDLE                h;
  DWORD FAR             *p;
  LPBYTE                lpBits;
  HANDLE                hRes;
  LPBITMAPINFOHEADER    lpBitmapInfo;
  INT numcolors;
  DWORD rgbSelected;
  DWORD rgbUnselected;
  HBITMAP hbm;

  rgbSelected = GetSysColor(COLOR_HIGHLIGHT);
  // Flip the colors.
  rgbSelected = RGB(GetBValue(rgbSelected),
                    GetGValue(rgbSelected),
                    GetRValue(rgbSelected));
  rgbUnselected = GetSysColor(COLOR_WINDOW);
  // Flip the colors.
  rgbUnselected = RGB(GetBValue(rgbUnselected),
                      GetGValue(rgbUnselected),
                      GetRValue(rgbUnselected));


  h = FindResource(hInst, MAKEINTRESOURCE(id), RT_BITMAP);
  hRes = LoadResource(hInst, h);

  /* Lock the bitmap and get a pointer to the color table. */
  lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hRes);

  if (!lpBitmapInfo)
        return FALSE;

  p = (DWORD FAR *)((LPSTR)(lpBitmapInfo) + lpBitmapInfo->biSize);

  /* Search for the Solid Blue entry and replace it with the current
   * background RGB.
   */
  numcolors = 16;

  while (numcolors-- > 0) {
      if (*p == BACKGROUND)
          *p = rgbUnselected;
      else if (*p == BACKGROUNDSEL)
          *p = rgbSelected;
      p++;
  }
  UnlockResource(hRes);

  /* Now create the DIB. */
  lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hRes);

  /* First skip over the header structure */
  lpBits = (LPBYTE)(lpBitmapInfo + 1);

  /* Skip the color table entries, if any */
  lpBits += (1 << (lpBitmapInfo->biBitCount)) * sizeof(RGBQUAD);

  /* Create a color bitmap compatible with the display device */
  hdc = GetDC(NULL);
  hbm = CreateDIBitmap(hdc, lpBitmapInfo, (DWORD)CBM_INIT, lpBits, (LPBITMAPINFO)lpBitmapInfo, DIB_RGB_COLORS);
  ReleaseDC(NULL, hdc);

  GlobalUnlock(hRes);
  FreeResource(hRes);

  return hbm;
}


/****************************************************************************

    FUNCTION: DoHelp(HWND, BOOL)

    PURPOSE:  This routine invokes help if BOOL is true, or dismisses help
              if BOOL is false.

    COMMENTS:

****************************************************************************/

VOID DoHelp(HWND hWnd, BOOL fInvokeHelp)
{
    TCHAR szHelp[80];

    if (LoadString(hInst, IDS_HELP, szHelp, BTOC(sizeof(szHelp)) - 1)) {
        if (fInvokeHelp)
            WinHelp(hWnd, (LPTSTR)szHelp, HELP_INDEX, 0L);
        else
            WinHelp(hWnd, (LPTSTR)szHelp, HELP_QUIT, 0L);
    }

}

/****************************************************************************

    FUNCTION: SaveFont(HWND)

    PURPOSE:  Used to save the current font facename in win.ini, so that
              it can be selected the next time charmap comes up.

    COMMENTS:

****************************************************************************/

VOID SaveCurrentFont(HWND hWndDlg)
{
    TCHAR szFaceName[LF_FACESIZE] = TEXT("");

    SendDlgItemMessage(hWndDlg, ID_FONT, CB_GETLBTEXT,
                       (WORD)SendDlgItemMessage(hWndDlg, ID_FONT, CB_GETCURSEL,
                                                0, 0L),
                       (LPARAM)(LPTSTR)szFaceName);

    WriteProfileString(TEXT("MSCharMap"), TEXT("Font"), (LPTSTR)szFaceName);
}


/****************************************************************************

    FUNCTION: SelectInitialFont(HWND)

    PURPOSE:  Used to select the initial font by getting a saved facename
              from win.ini and selecting it in the combo box.

    COMMENTS: Returns index to font selected.

****************************************************************************/

INT SelectInitialFont(HWND hWndDlg)
{
    TCHAR szFaceName[LF_FACESIZE] = TEXT("");
    INT iIndex;

    if ((GetProfileString(TEXT("MSCharMap"), TEXT("Font"), NULL, (LPTSTR)szFaceName,
                          BTOC(sizeof(szFaceName))) == 0) ||
        ((iIndex = (INT)SendDlgItemMessage(hWndDlg, ID_FONT, CB_SELECTSTRING, (WPARAM)-1,
                               (LPARAM)(LPTSTR)szFaceName)) == CB_ERR)) {
        /*
         * If there was no profile or the selection failed then try selecting
         * the symbol font, if that fails then select the first one.
         */
        if ((iIndex = (INT)SendDlgItemMessage(hWndDlg, ID_FONT, CB_SELECTSTRING,
                                (WPARAM)-1, (LPARAM)(LPTSTR)TEXT("Symbol"))) == CB_ERR)
            SendDlgItemMessage(hWndDlg, ID_FONT, CB_SETCURSEL, iIndex = 0, 0L);
    }

    return(iIndex);
}


/****************************************************************************

    FUNCTION: SaveCurrentSubset(HWND)

    PURPOSE:  Used to save the current subset name in win.ini, so that
              it can be selected the next time charmap comes up.

    COMMENTS:

****************************************************************************/

VOID SaveCurrentSubset(HWND hWndDlg)
{
    TCHAR szSubsetName[LF_SUBSETSIZE] = TEXT("");

    SendDlgItemMessage(hWndDlg, ID_UNICODESUBSET, CB_GETLBTEXT,
                       (WORD)SendDlgItemMessage(hWndDlg, ID_UNICODESUBSET, CB_GETCURSEL,
                                                0, 0L),
                       (LPARAM)(LPTSTR)szSubsetName);

    WriteProfileString(TEXT("MSCharMap"), TEXT("Block"), (LPTSTR)szSubsetName);
}


/****************************************************************************

    FUNCTION: SelectInitialSubset(HWND)

    PURPOSE:  Used to select the initial Unicode subset by getting a saved
              block name from win.ini.

    COMMENTS: Returns index to subset selected.

****************************************************************************/

INT SelectInitialSubset(HWND hWndDlg)
{
    TCHAR szSubsetName[LF_SUBSETSIZE] = TEXT("");
    INT iIndex;

    if (
        (GetProfileString(
             TEXT("MSCharMap"),
             TEXT("Block"),
             NULL,
             (LPTSTR)szSubsetName,
             BTOC(sizeof(szSubsetName))
             ) == 0)
       || ((iIndex = (INT)SendDlgItemMessage(
                              hWndDlg,
                              ID_UNICODESUBSET,
                              CB_SELECTSTRING,
                              (WPARAM)-1,
                              (LPARAM)(LPTSTR)szSubsetName
                              )) == CB_ERR)) {
        /*
         * If there was no profile or the selection failed then try selecting
         * the Basic Latin block, if that fails then select the first one.
         */
        if ((iIndex = (INT)SendDlgItemMessage(
                               hWndDlg,
                               ID_UNICODESUBSET,
                               CB_SELECTSTRING,
                               (WPARAM)-1,
                               (LPARAM)(LPTSTR)TEXT("Basic Latin")
                               )) == CB_ERR)
            SendDlgItemMessage(hWndDlg, ID_UNICODESUBSET, CB_SETCURSEL, iIndex = 0, 0L);
    }

    chSymFirst = (UTCHAR)aSubsetData[iIndex].BeginRange;
    chSymLast = (UTCHAR)aSubsetData[iIndex].EndRange;
    sycm.chCurr = chSymFirst;

    return iIndex;
}


/****************************************************************************

    FUNCTION: ExitMagnify(HWND, SYCM)

    PURPOSE:  Used to release mouse capture, exit magnify mode,
              and restore the cursor.

    COMMENTS:

****************************************************************************/

VOID ExitMagnify(
    HWND hWnd,
    PSYCM psycm)
{
    // Release capture, remove magnified character, restore cursor.
    ReleaseCapture();
    RestoreSymMag(psycm);
    DrawSymChOutlineHwnd(psycm, hWnd, psycm->chCurr, TRUE, TRUE);
    if (psycm->fCursorOff)
        ShowCursor(TRUE);
    psycm->fMouseDn = psycm->fCursorOff = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\oldchar\ucharmap\charmap.h ===
#include "cmdlg.h"

/* Type definitions. */
#ifdef UNICODE
typedef unsigned short UTCHAR;
#else
typedef unsigned char UTCHAR;
#endif

#define BTOC(bytes)  ((bytes) / sizeof(TCHAR))
#define CTOB(cch)    ((cch) * sizeof(TCHAR))
#define UCHAR unsigned char

typedef struct tagSYCM
  {
    INT dxpBox;
    INT dypBox;
    INT dxpCM;
    INT dypCM;
    INT xpCh;
    INT ypCh;
    INT dxpMag;
    INT dypMag;
    INT xpMagCurr;
    INT ypMagCurr;
    INT ypDest;
    INT xpCM;
    INT ypCM;

    BOOL fHasFocus;
    BOOL fFocusState;
    BOOL fMouseDn;
    BOOL fCursorOff;
    BOOL fAnsiFont;
    UTCHAR chCurr;
    HFONT hFontMag;
    HFONT hFont;
    HDC hdcMag;
    HBITMAP hbmMag;
    INT rgdxp[255];
  } SYCM;
typedef SYCM *PSYCM;

typedef struct tagITEMDATA
  {
    SHORT FontType;
    BYTE CharSet;
    BYTE PitchAndFamily;
  } ITEMDATA;


#define LF_SUBSETSIZE 40

typedef struct tagUSUBSET
  {
    INT BeginRange;
    INT EndRange;
    INT StringResId;
    TCHAR Name[LF_SUBSETSIZE];
  } USUBSET;

/* Function declarations. */

BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, INT);
INT_PTR  APIENTRY CharMapDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT  APIENTRY CharGridWndProc(HWND, UINT, WPARAM, LPARAM);
INT ChFromSymLParam(PSYCM, LPARAM);
VOID DrawSymChOutlineHwnd(PSYCM, HWND, UTCHAR, BOOL, BOOL);
VOID RecalcCharMap(HWND, PSYCM, INT, BOOL);
VOID DrawSymbolMap(PSYCM, HDC);
VOID DrawSymbolGrid(PSYCM, HDC);
VOID DrawSymbolChars(PSYCM, HDC);
VOID DrawSymChOutline(PSYCM, HDC, UTCHAR, BOOL, BOOL);
VOID MoveSymbolSel(PSYCM, UTCHAR);
VOID RestoreSymMag(PSYCM);
INT  APIENTRY FontLoadProc(LPLOGFONT, NEWTEXTMETRICEX*, DWORD, LPARAM);
HANDLE GetEditText(HWND);
VOID CopyString(HWND);
VOID SendRTFToClip(HWND, LPTSTR);
INT PointsToHeight(INT);
VOID UpdateKeystrokeText(HDC, UTCHAR, BOOL);
VOID PaintStatusLine(HDC, BOOL, BOOL);
BOOL UpdateHelpText(LPMSG, HWND);
INT KeyboardVKeyFromChar(UTCHAR);
BOOL DrawFamilyComboItem(LPDRAWITEMSTRUCT);
HBITMAP LoadBitmaps(INT);
VOID DoHelp(HWND, BOOL);
VOID SaveCurrentFont(HWND);
INT SelectInitialFont(HWND);
VOID ExitMagnify(HWND, PSYCM);
INT SelectInitialSubset(HWND);
VOID SaveCurrentSubset(HWND);
BOOL CALLBACK SubSetDlgProc(HWND, UINT, WPARAM, LPARAM);
VOID UpdateSymbolSelection(HWND, INT, INT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\cdropsrc.cxx ===
//**********************************************************************
// File name: cdropsrc.cxx
//
// Implementation file for CDropSource
// Implements the IDropSource interface required for an application to
// act as a Source in a drag and drop operation
// History :
//       Dec 23, 1997   [v-nirnay]    wrote it.
//
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//**********************************************************************

#include <windows.h>
#include <ole2.h>

#include "olecomon.h"
#include "cdropsrc.h"

//**********************************************************************
// CDropSource::CDropSource
//
// Purpose:
//      Constructor
//
// Parameters:
//      None
// Return Value:
//      None
//**********************************************************************
CDropSource::CDropSource()
{
    TRACE(TEXT("Creating New Drop SOurce\n"));
    // Initialise reference count to 0
    m_cRef = 1;
}

//**********************************************************************
// CDropSource::QueryInterface
//
// Purpose:
//      Return a pointer to a requested interface
//
// Parameters:
//      REFIID riid         -   ID of interface to be returned
//      PPVOID ppv          -   Location to return the interface
//
// Return Value:
//      NOERROR             -   Interface supported
//      E_NOINTERFACE       -   Interface NOT supported
//**********************************************************************
STDMETHODIMP CDropSource::QueryInterface(REFIID riid,
                                         PPVOID ppv)
{
    // Initialise interface pointer to NULL
    *ppv = NULL;

    // If the interface asked for is what we have set ppv
    if (riid == IID_IUnknown || riid == IID_IDropSource) {
        *ppv = this;
    }

    // Increment reference count if the interface asked for is correct
    // and return no error
    if (*ppv != NULL) {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    // Else return no such interface
    return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
// CDropSource::AddRef
//
// Purpose:
//      Increments the reference count for an interface on an object
//
// Parameters:
//      None
//
// Return Value:
//      int                 -   Value of the new reference count
//**********************************************************************
ULONG STDMETHODCALLTYPE CDropSource::AddRef()
{
    // Increment reference count
    return InterlockedIncrement((LONG*)&m_cRef);
}


//**********************************************************************
// CDropSource::Release
//
// Purpose:
//      Decrements the reference count for the interface on an object
//
// Parameters:
//      None
//
// Return Value:
//      int                 -   Value of the new reference count
//**********************************************************************
ULONG STDMETHODCALLTYPE CDropSource::Release()
{
#if DBG==1
        if( 0 == m_cRef )
        {
            DebugBreak();   // ref counting problem
        }
#endif
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

//**********************************************************************
// CDropSource::QueryContinueDrag
//
// Purpose:
//      Determines whether a drag-and-drop operation should be continued,
//      canceled, or completed
//
// Parameters:
//      BOOL fEsc           -   Status of escape key since previous call
//      DWORD grfKeyState   -   Current state of keyboard modifier keys
//
// Return Value:
//      DRAGDROP_S_CANCEL   -   Drag operation is to be cancelled
//      DRAGDROP_S_DROP     -   Drop operation is to be completed
//      S_OK                -   Drag operation is to be continued
//**********************************************************************
STDMETHODIMP CDropSource::QueryContinueDrag(BOOL fEsc,
                                            DWORD grfKeyState)
{
    // If escape key is pressed stop drag and drop
    if (fEsc) {
        return ResultFromScode(DRAGDROP_S_CANCEL);
    }

    // If LButton is up then complete the drag operation
    if (!(grfKeyState & MK_LBUTTON)) {
        return ResultFromScode(DRAGDROP_S_DROP);
    }

    return ResultFromScode(S_OK);
}

//**********************************************************************
// CDropSource::GiveFeedback
//
// Purpose:
//      Enables a source application to give visual feedback to the end
//      user during a drag-and-drop
//
// Parameters:
//      DWORD dwEffect      -   Effect of a drop operation
//
// Return Value:
//      DRAGDROP_S_USEDEFAULTCURSORS    -   Use default cursors
//**********************************************************************
STDMETHODIMP CDropSource::GiveFeedback(DWORD dwEffect)
{
    return ResultFromScode(DRAGDROP_S_USEDEFAULTCURSORS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\cmdlg.h ===
/********************************************************************
 *
 *  Header Name : cmdlg.h
 *
 *  Copyright (c) 1997-1999 Microsoft Corporation. 
 *
 ********************************************************************/

#ifndef __CMLG_H__
#define __CMLG_H__

#define ID_HELP                     100
#define ID_CLOSE                    101
#define ID_COPY                     102
#define ID_SELECT                   103
#define ID_STRING                   104
#define ID_FONT                     105
#define ID_TOPLEFT                  107
#define ID_CHARGRID                 108
#define ID_SUBSET                   109
#ifndef IDC_EDIT
#define IDC_EDIT                    1000
#endif

#define ID_ADVANCED                 119

#define IDBM_TT                     110

#define IDIC_UCE                    111

#define IDS_HELP                    112
#define IDS_RTF                     113
#define IDS_GROUPBY                 114
#define IDS_SYMBOLSET               115
#define IDS_EUDC                    116
#define IDS_ALT                     117
#define IDS_ALLFONTS                118

#define ID_CTLHOME                  121
#define ID_CTLEND                   122
#define ID_CTLLEFT                  123
#define ID_CTLRIGHT                 124
#define ID_CTLUP                    125
#define ID_CTLDOWN                  126
#define ID_CTLPRIOR                 127
#define ID_CTLNEXT                  128
#define ID_VIEWLB                   129
#define ID_VIEW                     130

#define ID_SEARCHNAME               131
#define ID_SEARCHINPUT              132
#define ID_SEARCH                   133
#define ID_STOPSEARCH               134
#define ID_FROMSPIN                 136
#define ID_FROMLB                   137
#define ID_TOTEXT                   138
#define ID_TOSPIN                   139
#define ID_FONTLB                   141
#define ID_APPLY                    142

#define ID_LISTBOX                  301
#define ID_GRID_HSCROLL             302
#define ID_GRID_VSCROLL             303

#define IDS_UNICODE                 300
#define IDS_NOCHARFOUND             400
#define IDS_SEARCH                  403
#define IDS_RESET                   405

#define IDS_ALL                     7001

#define ID_SUBSETLB                 201
#define ID_UNICODESUBSET            202
#define ID_NEXTSUBSET               203
#define ID_MAPSCROLL                204
#define ID_PREVSUBSET               205
#define ID_SEARCHSEL                206
#define IDM_COPY                    207
#define IDM_SEND                    208
#define IDM_FONT1                   209
#define IDM_FONT2                   210
#define IDM_FONT3                   211

#define ID_URANGE                   700
#define ID_FROM                     701
#define ID_FROMLABLE                702
#define ID_TO                       703
#define ID_TOLABLE                  704
#define ID_SURCONTROLS              705
#define ID_STATIC                   706

#endif  // __CMLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\cdataobj.cxx ===
//**********************************************************************
// File name: cdataobj.cxx
//
// Definition of CImpIDataObject
// Implements the IDataObject interface required for Data transfer
//
// History :
//       Dec 23, 1997   [v-nirnay]    wrote it.
//       Modified RenderRTFText output procedure for charset
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//**********************************************************************

#include <windows.h>
#include <ole2.h>
#include <strsafe.h>

#include "olecomon.h"
#include "enumfetc.h"
#include "cdataobj.h"
#include "uce.h"

// Chargrid supports three formats Rich Text, Plain text and Unicode text
// Of which the last two are standard and are already registered
CLIPFORMAT g_cfRichText = 0;

// List of FormatEtcs which are supported by Chargrid
// The first format is filled up in CImpIDataObject constructor
static FORMATETC g_FormatEtc[] =
{
    { 0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    { CF_UNICODETEXT, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    { CF_TEXT, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}
};

//**********************************************************************
// CImpIDataObject::CImpIDataObject
//
// Purpose:
//      Constructor
//
// Parameters:
//      HWND hWnd           -  Dialog handle which has to be cached
//
// Return Value:
//      None
//**********************************************************************
CImpIDataObject::CImpIDataObject(HWND hWnd)
{
    // Initialise reference count to 0
    m_cRef = 1;
    hWndDlg = hWnd;
    m_lpszText[0] = 0;

    // Register Rich Text Clipboard format if necessary
    if (g_cfRichText == 0) {
        TCHAR szRTF[80];
        int iRet = LoadString(hInst, IDS_RTF, szRTF, 80);
        g_cfRichText = (CLIPFORMAT)RegisterClipboardFormat(szRTF);
//should hardcode clipboard format. we will do it after Win2K
//        g_cfRichText = (CLIPFORMAT)RegisterClipboardFormat(RTFFMT);
        g_FormatEtc[0].cfFormat = g_cfRichText;
    }
}

//**********************************************************************
// CImpIDataObject::QueryInterface
//
// Purpose:
//      Return a pointer to a requested interface
//
// Parameters:
//      REFIID riid         -   ID of interface to be returned
//      PPVOID ppv          -   Location to return the interface
//
// Return Value:
//      NOERROR             -   Interface supported
//      E_NOINTERFACE       -   Interface NOT supported
//**********************************************************************
STDMETHODIMP CImpIDataObject::QueryInterface(REFIID riid,
                                             PPVOID ppv)
{
    // Initialise interface pointer to NULL
    *ppv = NULL;

    // If the interface asked for is what we have set ppv
    if (riid == IID_IUnknown || riid == IID_IDataObject) {
        *ppv = this;
    }

    // Increment reference count if the interface asked for is correct
    // and return no error
    if (*ppv != NULL) {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    // Else return no such interface
    return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
// CImpIDataObject::AddRef
//
// Purpose:
//      Increments the reference count for an interface on an object
//
// Parameters:
//      None
//
// Return Value:
//      int                 -   Value of the new reference count
//**********************************************************************
ULONG STDMETHODCALLTYPE CImpIDataObject::AddRef()
{
    TRACE(TEXT("In AddRef\n"));

    // Increment reference count
    return InterlockedIncrement((LONG*)&m_cRef);
}

//**********************************************************************
// CImpIDataObject::Release
//
// Purpose:
//      Decrements the reference count for the interface on an object
//
// Parameters:
//      None
//
// Return Value:
//      int                 -   Value of the new reference count
//**********************************************************************
ULONG STDMETHODCALLTYPE CImpIDataObject::Release()
{
    TRACE(TEXT("In Release\n"));

#if DBG == 1
    if ( 0 == m_cRef)
    {
        DebugBreak();  // ref counting problem
    }

#endif
    // Decrement reference count
    ULONG cRef = InterlockedDecrement(&m_cRef);

    // If there are no references then free current copy
    if (cRef == 0) 
    {
        delete this;
    }

    return cRef;
}

//**********************************************************************
// CImpIDataObject::GetData
//
// Purpose:
//      Called by a data consumer to obtain data from a source data object
//
// Parameters:
//      FORMATETC* pFormatetc  -   Pointer to the FORMATETC structure
//      STGMEDIUM* pMedium     -   Pointer to the STGMEDIUM structure
//
// Return Value:
//      S_OK                   -   Data was successfully retrieved and
//                                 placed in the storage medium provided
//      DATA_E_FORMATETC       -   Invalid value for pFormatetc
//**********************************************************************
STDMETHODIMP CImpIDataObject::GetData(FORMATETC* pFormatetc,
                                      STGMEDIUM* pMedium)
{
    SCODE   sc = DATA_E_FORMATETC; // Deflt return value data format not supported

    // Initialise the storage medium structure
    pMedium->tymed = NULL;
    pMedium->pUnkForRelease = NULL;
    pMedium->hGlobal = NULL;

    TRACE(TEXT("In GetData\n"));

    // Our CharGrid only supports drag and drop of text through global memory
    // Client wants plain text through global memory
    if (pFormatetc->cfFormat == CF_TEXT &&
        pFormatetc->dwAspect == DVASPECT_CONTENT &&
        pFormatetc->tymed == TYMED_HGLOBAL) {

        sc = RenderPlainAnsiText(pMedium);
    }

    // Client wants Unicode text through global memory
    if (pFormatetc->cfFormat == CF_UNICODETEXT &&
        pFormatetc->dwAspect == DVASPECT_CONTENT &&
        pFormatetc->tymed == TYMED_HGLOBAL) {

        sc = RenderPlainUnicodeText(pMedium);
    }

    // Client wants Rich Text through global memory
    if (pFormatetc->cfFormat == g_cfRichText &&
        pFormatetc->dwAspect == DVASPECT_CONTENT &&
        pFormatetc->tymed == TYMED_HGLOBAL) {

        sc = RenderRTFText(pMedium);
    }

    return ResultFromScode(sc);
}

//**********************************************************************
// CImpIDataObject::GetDataHere
//
// Purpose:
//      Called by a consumer to obtain data with caller allocing memory
//
// Parameters:
//      FORMATETC* pFormatetc  -   Pointer to the FORMATETC structure
//      STGMEDIUM* pMedium     -   Pointer to the STGMEDIUM structure
//
// Return Value:
//      DATA_E_FORMATETC       -   Invalid value for pFormatetc
//**********************************************************************
STDMETHODIMP CImpIDataObject::GetDataHere(FORMATETC* pFormatetc,
                                          STGMEDIUM* pMedium)
{
    // This method says that the caller allocates and frees memory,
    // we dont support this method
    return ResultFromScode(DATA_E_FORMATETC);
}

//**********************************************************************
// CImpIDataObject::GetDataHere
//
// Purpose:
//      Determines whether the data object is capable of rendering the
//      data described in the FORMATETC structure
//
// Parameters:
//      FORMATETC* pFormatetc  -   Pointer to the FORMATETC structure
//
// Return Value:
//      DV_E_FORMATETC         -   Invalid value for pFormatetc
//      S_OK                   -   Next call to GetData will be success
//**********************************************************************
STDMETHODIMP CImpIDataObject::QueryGetData(FORMATETC* pFormatetc)
{
    SCODE  sc = DV_E_FORMATETC; // dflt return value is invalid formatetc

    TRACE(TEXT("In QueryGetData\n"));

    // Our CharGrid only supports drag and drop of text through global memory

    // If the client wants text, unicode text or rich text through global memory
    // then return OK
    if (pFormatetc->cfFormat == CF_TEXT
        && pFormatetc->dwAspect == DVASPECT_CONTENT
        && pFormatetc->tymed & TYMED_HGLOBAL) {
        sc = S_OK;
    }
    else if (pFormatetc->cfFormat == CF_UNICODETEXT
        && pFormatetc->dwAspect == DVASPECT_CONTENT
        && pFormatetc->tymed & TYMED_HGLOBAL) {
        sc = S_OK;
    }
    else if (pFormatetc->cfFormat == g_cfRichText
        && pFormatetc->dwAspect == DVASPECT_CONTENT
        && pFormatetc->tymed & TYMED_HGLOBAL) {
        sc = S_OK;
    }

    return ResultFromScode(sc);
}

//**********************************************************************
// CImpIDataObject::GetCanonicalFormatEtc
//
// Purpose:
//      Provides a standard FORMATETC structure that is logically
//      equivalent to one that is more complex.
//
// Parameters:
//      FORMATETC* pFormatetcIn  -   Pointer to the FORMATETC structure
//      FORMATETC* pFormatetcOut -   Pointer to canonical equivalent
//
// Return Value:
//      E_NOTIMPL              -   This call is not implemented
//**********************************************************************

STDMETHODIMP CImpIDataObject::GetCanonicalFormatEtc(FORMATETC* pFormatetcIn,
                                                    FORMATETC* pFormatetcOut)
{
    // Chargrid does not support conversion of FORMATETC
    // Check for invalid input
    if (pFormatetcIn == NULL) {
        return ResultFromScode(E_INVALIDARG);
    }

    pFormatetcOut->ptd = NULL;

    return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
// CImpIDataObject::SetData
//
// Purpose:
//      Called by an object containing a data source to transfer data to
//      the object that implements this method
//
// Parameters:
//      FORMATETC* pFormatetc  -   Pointer to the FORMATETC structure
//      STGMEDIUM* pMedium     -   Pointer to the STGMEDIUM structure
//      BOOL       fRelease    -   Indicates who owns storage medium
//
// Return Value:
//      E_NOTIMPL              -   This call is not implemented
//**********************************************************************

STDMETHODIMP CImpIDataObject::SetData(FORMATETC* pFormatetc,
                                      STGMEDIUM* pMedium,
                                      BOOL       fRelease)
{
    // We do not allow another object to send data to us
    // So return error not implemented
    return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
// CImpIDataObject::EnumFormatEtc
//
// Purpose:
//      Creates an object for enumerating the FORMATETC structures for a data object
//
// Parameters:
//      DWORD            dwDirection     -   Pointer to the FORMATETC structure
//      IEnumFORMATETC** ppEnumFormatetc -   Pointer to canonical equivalent
//
// Return Value:
//      S_OK                             -   Enumerator object was successfully created.
//      E_NOTIMPL                        -   The direction specified by dwDirection is not supported.
//**********************************************************************
STDMETHODIMP CImpIDataObject::EnumFormatEtc(DWORD            dwDirection,
                                            IEnumFORMATETC** ppEnumFormatetc)
{
    SCODE   sc = S_OK;

    *ppEnumFormatetc = NULL;

    TRACE(TEXT("In EnumFormatEtc\n"));

    // If the direction of enumeration is Get then create
    // an instance of the standard implementation of IEnumFmtEtc
    if (dwDirection == DATADIR_GET) {
        *ppEnumFormatetc = OleStdEnumFmtEtc_Create(
            sizeof(g_FormatEtc)/sizeof(g_FormatEtc[0]),
            g_FormatEtc);

        if (*ppEnumFormatetc == NULL) {
            sc = E_OUTOFMEMORY;
        }
    } else if (dwDirection == DATADIR_SET) {
        // Chargrid does not accept SetData
        sc = E_NOTIMPL;
    } else {
        // Anything else provided as direction is an error
        sc = E_INVALIDARG;
    }

    return ResultFromScode(sc);
}

//**********************************************************************
// CImpIDataObject::DAdvise
//
// Return Value:
//      OLE_E_ADVISENOTSUPPORTED - Data object does not support change
//                                 notification
//**********************************************************************
STDMETHODIMP CImpIDataObject::DAdvise(FORMATETC*,
                                      DWORD,
                                      IAdviseSink*,
                                      DWORD*)
{
    // Chargrid does not support notifications (AdviseSink) on change of data
    // So return error advise not supported
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

//**********************************************************************
// CImpIDataObject::DUnadvise
//
// Return Value:
//      OLE_E_ADVISENOTSUPPORTED - Data object does not support change
//                                 notification
//**********************************************************************
STDMETHODIMP CImpIDataObject::DUnadvise(DWORD dwConnection)
{
    // Chargrid does not support notifications (AdviseSink) on change of data
    // So return error advise not supported
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

//**********************************************************************
// CImpIDataObject::EnumDAdvise
//
// Return Value:
//      OLE_E_ADVISENOTSUPPORTED - Data object does not support change
//                                 notification
//**********************************************************************
STDMETHODIMP CImpIDataObject::EnumDAdvise(IEnumSTATDATA**)
{
    // Chargrid does not support notifications (AdviseSink) on change of data
    // So return error advise not supported
    return ResultFromScode(OLE_E_ADVISENOTSUPPORTED);
}

//**********************************************************************
// CImpIDataObject::RenderRTFText
//
// Purpose:
//      Copies the character from currently selected grid cell to global
//      memory in Rich Text format
//
// Parameters:
//      STGMEDIUM* pMedium  -   Pointer to the STGMEDIUM structure
//
// Return Value:
//      S_OK                - Data was transferred successfully
//**********************************************************************
HRESULT CImpIDataObject::RenderRTFText(STGMEDIUM* pMedium)
{
    INT iCurrFont, iCharset, nIndex;
    FONTINFO *pFontInfo;
    TCHAR szFaceName[LF_EUDCFACESIZE];
    HANDLE hmemRTF;
    LPTSTR lpstrClipString;
    TCHAR achHeaderTmpl[] = TEXT("{\\rtf1\\ansi\\ansicpg%d {\\fonttbl{\\f0\\");
    TCHAR achHeader[sizeof(achHeaderTmpl) / sizeof(TCHAR) + 20];
    TCHAR achMiddle[] = TEXT(";}}\\sectd\\pard\\plain\\f0 ");
    INT cchUC;
    LPTSTR lpstrText;

    TRACE(TEXT("Rendering Rich Text\n"));

    lpstrText = m_lpszText;

#ifndef UNICODE_RTF
    LPWSTR pszRTFW;
#endif

#define MAXLENGTHFONTFAMILY 8
#define ALITTLEEXTRA 10    // covers extra characters + length of font size

    iCurrFont = (INT)SendDlgItemMessage(hWndDlg, ID_FONT, CB_GETCURSEL, 0, 0L);
    nIndex = (INT)SendDlgItemMessage(hWndDlg, ID_FONT, CB_GETITEMDATA, iCurrFont, 0L);
    pFontInfo = Font_pList+nIndex;
    
    HRESULT hresult = StringCchCopy(szFaceName , sizeof(szFaceName)/sizeof(szFaceName[0]),  pFontInfo->szFaceName);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    iCharset = GetCurFontCharSet(hWndDlg);

    
    hresult = StringCchPrintf(achHeader , sizeof(achHeader)/sizeof(achHeader[0]),  achHeaderTmpl, (INT)(SHORT)GetACP());
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }

    //
    //  16 times in case they're all > 7 bits (each chr -> \uc1\uddddddd\'xx)
    //  and room for the second byte of DBCS.
    //
    
    DWORD dwSize = lstrlen((LPTSTR)achHeader) +
        MAXLENGTHFONTFAMILY +
        lstrlen(szFaceName) +
        lstrlen((LPTSTR)achMiddle) +
        2 * 16 * lstrlen(lpstrText) +
        ALITTLEEXTRA;

    hmemRTF = GlobalAlloc( 0, dwSize * sizeof(TCHAR));
    
    if (hmemRTF == NULL)
    {
        return 1;
    }

    lpstrClipString = (LPTSTR)GlobalLock(hmemRTF);

#ifndef UNICODE_RTF
    pszRTFW = lpstrClipString;
#endif

    
    hresult = StringCchCopy(lpstrClipString , dwSize,  achHeader);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }

    // Add the correct charset string
    if (iCharset == SYMBOL_CHARSET)
    {
        
        hresult = StringCchCat(lpstrClipString , dwSize,  (LPTSTR)TEXT("fnil\\fcharset2 "));
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
    }
    else
    {
        //
        //  Top four bits specify family.
        //
        switch (pFontInfo->PitchAndFamily & 0xf0)
        {
            case ( FF_DECORATIVE ) :
            {
                
                hresult = StringCchCat(lpstrClipString , dwSize,  (LPTSTR)TEXT("fdecor "));
                if (!SUCCEEDED(hresult))
                {
                   return FALSE;
                }
                break;
            }
            case ( FF_MODERN ) :
            {
                
                hresult = StringCchCat(lpstrClipString , dwSize,  (LPTSTR)TEXT("fmodern "));
                if (!SUCCEEDED(hresult))
                {
                   return FALSE;
                }
                break;
            }
            case ( FF_ROMAN ) :
            {
                
                hresult = StringCchCat(lpstrClipString , dwSize,  (LPTSTR)TEXT("froman "));
                if (!SUCCEEDED(hresult))
                {
                   return FALSE;
                }
                break;
            }
            case ( FF_SCRIPT ) :
            {
                
                hresult = StringCchCat(lpstrClipString , dwSize,  (LPTSTR)TEXT("fscript "));
                if (!SUCCEEDED(hresult))
                {
                   return FALSE;
                }
                break;
            }
            case ( FF_SWISS ) :
            {
                
                hresult = StringCchCat(lpstrClipString , dwSize,  (LPTSTR)TEXT("fswiss "));
                if (!SUCCEEDED(hresult))
                {
                   return FALSE;
                }
                break;
            }
            default :
            {
                TCHAR pchar[30];
                
                hresult = StringCchPrintf(pchar , sizeof(pchar)/sizeof(pchar[0]),  TEXT("fnil\\fcharset%d "), iCharset);
                if (!SUCCEEDED(hresult))
                {
                   return FALSE;
                }
                
                hresult = StringCchCat(lpstrClipString , dwSize,  pchar);
                if (!SUCCEEDED(hresult))
                {
                   return FALSE;
                }
                break;
            }
        }
    }

    
    hresult = StringCchCat(lpstrClipString , dwSize,  szFaceName);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }

    
    hresult = StringCchCat(lpstrClipString , dwSize,  (LPTSTR)achMiddle);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }

    //
    //  We need to do the text character by character, making sure
    //  that we output a special sequence \'hh for characters bigger
    //  than 7 bits long!
    //
    int currentLen = lstrlen(lpstrClipString);
    lpstrClipString += currentLen;
    // Update dwSize after we change lpstrClipString
    dwSize -= currentLen;

    cchUC = 0;
    char achTmp[2];
    char *pTmp = achTmp;
    int cch;

    while (*lpstrText)
    {
      cch = ConvertUnicodeToAnsiFont(hWndDlg, lpstrText, pTmp);
            //
            // Put in a \uc# to tell Unicode reader how many bytes to skip
            // and the \uN code to indicate the real unicode value.
            //
            if (cch != cchUC )
            {
                cchUC = cch;                
                hresult = StringCchPrintf(lpstrClipString , dwSize,  TEXT("\\uc%d"), (INT)(SHORT)cchUC);
                if (!SUCCEEDED(hresult))
                {
                   return FALSE;
                }
                currentLen = wcslen(lpstrClipString);
                lpstrClipString += currentLen;
                dwSize -= currentLen;
            }

            
            
            hresult = StringCchPrintf(lpstrClipString , dwSize,  TEXT("\\u%d"), (INT)(SHORT)*lpstrText );
            if (!SUCCEEDED(hresult))
            {
                return FALSE;
            }
            currentLen = wcslen(lpstrClipString);
            lpstrClipString += currentLen;
            dwSize -= currentLen;

            //
            //  Now put the \'xx string in to indicate the actual character.
            //
            lpstrText++;
            while (cch--)
            {
                if (dwSize >= 2) 
                {
                    *lpstrClipString++ = TEXT('\\');
                    *lpstrClipString++ = TEXT('\'');                
                    dwSize -= 2;
                } else 
                {
                    return (FALSE);
                }
                
                hresult = StringCchPrintf(achMiddle , sizeof(achMiddle)/sizeof(achMiddle[0]),  TEXT("%x"), (INT)*pTmp++);
                if (!SUCCEEDED(hresult))
                {
                   return FALSE;
                }
                if (dwSize >= 2) 
                {
                    *lpstrClipString++ = achMiddle[0];
                    *lpstrClipString++ = achMiddle[1];
                    dwSize -= 2;
                } else 
                {
                    return (FALSE);
                }
            }
    }
    if (dwSize >= 2)
    {
        *lpstrClipString++ = TEXT('}');
        *lpstrClipString++ = TEXT('\0');
    }
#ifndef UNICODE_RTF
    {
        //
        //  RTF is only defined for ANSI, not for Unicode, therefore
        //  we need to convert the buffer before we put it on the
        //  clipboard.  Eventually, we should add autoconversion code
        //  to USER to handle this for us.
        //
        // int cch;
        HANDLE hmemRTFA;
        LPSTR pszRTFA;

        cch = WideCharToMultiByte( CP_ACP,
            0,
            pszRTFW,
            (int)(lpstrClipString - pszRTFW),
            NULL,
            0,
            NULL,
            NULL );

        if (cch != 0 &&
            (hmemRTFA = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,cch)) != NULL)
        {
            pszRTFA = (char*)GlobalLock(hmemRTFA);

            WideCharToMultiByte( CP_ACP,
                0,
                pszRTFW,
                (int)(lpstrClipString - pszRTFW),
                pszRTFA,
                cch,
                NULL,
                NULL );

            GlobalUnlock(hmemRTFA);
            GlobalUnlock(hmemRTF);
            GlobalFree(hmemRTF);

            hmemRTF = hmemRTFA;
        }
    }
#endif

    pMedium->tymed = TYMED_HGLOBAL;

    // Set memory handle by which the data is being transferred
    pMedium->hGlobal = hmemRTF;

    return S_OK;
}

//**********************************************************************
// CImpIDataObject::RenderPlainAnsiText
//
// Purpose:
//      Copies the character from currently selected grid cell to global
//      memory as Ansi Text
//
// Parameters:
//      STGMEDIUM* pMedium  -   Pointer to the STGMEDIUM structure
//
// Return Value:
//      S_OK                - Data was transferred successfully
//**********************************************************************
HRESULT CImpIDataObject::RenderPlainAnsiText(STGMEDIUM* pMedium)
{
    HGLOBAL hText;
    LPSTR   pszText;
    int     nChars;

    TRACE(TEXT("Rendering plain ANSI text\n"));

    // Convert currently selected character from Wide Char to Multibyte
    nChars = WideCharToMultiByte(CP_ACP,
        0,
        m_lpszText,  // the currently selected character
        wcslen(m_lpszText),
        NULL,
        0,
        NULL,
        NULL );

    hText = GlobalAlloc(GMEM_SHARE | GMEM_ZEROINIT, nChars+1);

    if (!hText) {
        return ResultFromScode(E_OUTOFMEMORY);
    }

    // Copy the text to the global memory
    pszText = (LPSTR)GlobalLock(hText);
    nChars = WideCharToMultiByte(CP_ACP,
        0,
        m_lpszText,  // the currently selected character
        wcslen(m_lpszText),
        pszText,
        nChars+1,
        NULL,
        NULL);

    GlobalUnlock(hText);

    // Set the storage medium by which data is transferred as global memory
    pMedium->tymed = TYMED_HGLOBAL;

    // Set memory handle by which the data is being transferred
    pMedium->hGlobal = hText;

    return S_OK;
}

//**********************************************************************
// CImpIDataObject::RenderPlainUnicodeText
//
// Purpose:
//      Copies the character from currently selected grid cell to global
//      memory as Unicode characters
//
// Parameters:
//      STGMEDIUM* pMedium  -   Pointer to the STGMEDIUM structure
//
// Return Value:
//      S_OK                - Data was transferred successfully
//**********************************************************************
HRESULT CImpIDataObject::RenderPlainUnicodeText(STGMEDIUM* pMedium)
{
    HGLOBAL hText;
    LPTSTR  pszText;

    TRACE(TEXT("Rendering plain unicode text\n"));

    hText = GlobalAlloc(GMEM_SHARE | GMEM_ZEROINIT,
        sizeof(WCHAR) * (wcslen(m_lpszText)+1));

    if (!hText) {
        TRACE(TEXT("Unable to alloc global memory\n"));
        return ResultFromScode(E_OUTOFMEMORY);
    }

    // Copy the text to the global memory
    pszText = (LPTSTR)GlobalLock(hText);
    
    HRESULT hr = StringCchCopyW(pszText, wcslen(m_lpszText)+1, m_lpszText);
    
    if (hr != S_OK)

    GlobalUnlock(hText);

    // Set the storage medium by which data is transferred as global memory
    pMedium->tymed = TYMED_HGLOBAL;

    // Set memory handle by which the data is being transferred
    pMedium->hGlobal = hText;

    return S_OK;
}


//**********************************************************************
// CImpIDataObject::SetText
//
// Purpose:
//      Sets the local pointer for text to be copied
//
// Parameters:
//      LPTSTR  lpszText    -   Pointer to text
//
// Return Value:
//      0                   -   Success
//**********************************************************************
int CImpIDataObject::SetText(LPTSTR lpszText)
{
    
    HRESULT hresult = StringCchCopy(m_lpszText , sizeof(m_lpszText)/sizeof(m_lpszText[0]),  lpszText);
    if (!SUCCEEDED(hresult))
    {
        return FALSE;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\cdropsrc.h ===
//**********************************************************************
// File name: cdropsrc.h
//
// Definition of CDropSource
// Implements the IDropSource interface required for an application to
// act as a Source in a drag and drop operation
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//**********************************************************************

#ifndef DROPSOURCE_H
#define DROPSOURCE_H

class CDropSource : public IDropSource {
private:
    LONG    m_cRef;     // Reference counting information

public:
    // Constructor
    CDropSource();

    // IUnknown interface members
    STDMETHODIMP QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDropSource specific members
    STDMETHODIMP QueryContinueDrag(BOOL, DWORD);
    STDMETHODIMP GiveFeedback(DWORD);
};

typedef CDropSource *PCDropSource;

#endif // DROPSOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\codepage.cxx ===
/****************************************************************************

    CodePage.c

    PURPOSE : Codepage related utilities for Universal Character Explorer

    Copyright (c) 1997-1999 Microsoft Corporation.
****************************************************************************/

#include "windows.h"
#include "commctrl.h"

#include "UCE.h"
#include "stdlib.h"
#include "tchar.h"
#include "stdio.h"
#include "winuser.h"
#include "string.h"
#include "search.h"

#include "winnls.h"
#include "wingdi.h"

BOOL CodePage_AddToList(LONG);

LONG *CodePage_pList       = NULL;
INT  CodePage_nCount       = 0;
LONG CodePage_lCurCodePage = 0;

/****************************************************************************

    Function : Enumerate code page callback function.

****************************************************************************/
BOOL
CALLBACK EnumCodePagesProc(
    LPTSTR lpCodePageString
    )
{
    LONG  lCodePageNum;
    TCHAR szBuf[256];

    lCodePageNum = _wtol(lpCodePageString);

    if(!IsValidCodePage(lCodePageNum))
    {
        return TRUE;
    }
    if(LoadString(hInst, lCodePageNum, szBuf, sizeof(szBuf)/sizeof(TCHAR)) == 0)
    {
        return TRUE;
    }

    CodePage_AddToList(lCodePageNum);
    return TRUE;
}

/****************************************************************************

    Function : Delete this list.

****************************************************************************/
BOOL
CodePage_DeleteList()
{
    free(CodePage_pList);
    CodePage_pList  = NULL;
    CodePage_nCount = 0;
    return TRUE;
}

/****************************************************************************

    Function : initialize list

****************************************************************************/
BOOL
CodePage_InitList()
{
    if (CodePage_pList)
    {
        CodePage_DeleteList();
    }

    CodePage_pList  = NULL;
    CodePage_nCount = 0;

    //
    // we need 1200 (Unicode codepage) that EnumSystemCodePages won't give us
    //
    CodePage_AddToList(UNICODE_CODEPAGE);

    EnumSystemCodePages((CODEPAGE_ENUMPROC)EnumCodePagesProc, CP_INSTALLED);

    return TRUE;
}

/***************************************************************************

    Function : Add a code page value to list.

****************************************************************************/
BOOL
CodePage_AddToList(
    LONG lCodePage
    )
{
    int   i, j;
    WCHAR wcBuf[256];
    WCHAR wcBufNew[256];


    if (CodePage_pList == NULL)
    {
        CodePage_pList = (LONG *) malloc(sizeof(LONG));
        if (CodePage_pList == NULL)
        {
            return FALSE;
        }
        CodePage_pList[CodePage_nCount] = lCodePage;
    }
    else
    {
        LONG *temp = NULL;

        temp = (LONG *) realloc(CodePage_pList, sizeof(LONG)*(CodePage_nCount+1));
        if (temp == NULL)
        {
            return FALSE;  // Keep the previously allocated buffer
        }
        CodePage_pList = temp;  // Replace the buffer with the newly allocated one

        LoadString(hInst, lCodePage, wcBufNew, sizeof(wcBufNew)/sizeof(WCHAR));
        for(i = 1; i < CodePage_nCount; i++)
        {
            LoadString(hInst, CodePage_pList[i], wcBuf, sizeof(wcBuf)/sizeof(WCHAR));
            if(CompareString(LOCALE_USER_DEFAULT, 0, wcBufNew, -1,  wcBuf, -1) == 1) break;
        }

        for(j = CodePage_nCount; j > i; j--)
        {
            CodePage_pList[j] = CodePage_pList[j-1];
        }
        CodePage_pList[i] = lCodePage;
    }

    CodePage_nCount++;
    return TRUE;
}

/****************************************************************************

    Function : Fill a combobox with code pages.

****************************************************************************/
BOOL
CodePage_FillToComboBox(
    HWND hWnd,
    UINT uID
    )
{
    HWND hCombo = (HWND) GetDlgItem(hWnd,uID);
    INT  i;

    if (hCombo == NULL)
    {
        return FALSE;
    }

    SendMessage(
        hCombo,
        CB_RESETCONTENT,
        0,
        0 );

    for (i=0; i < CodePage_nCount; i++)
    {
       int   nIndex;
       TCHAR szBuf[256];

       if (CodePage_pList[i] == UNICODE_CODEPAGE)
       {
           LoadString(hInst,IDS_UNICODE,szBuf,sizeof(szBuf)/sizeof(TCHAR));
           nIndex = (int)SendMessage(
                        hCombo,
                        CB_ADDSTRING,
                        (WPARAM) 0,
                        (LPARAM) szBuf);
           if(nIndex != CB_ERR)
           {
               SendMessage(
                   hCombo,
                   CB_SETITEMDATA,
                   (WPARAM) nIndex,
                   (LPARAM) CodePage_pList[i]);
           }
       }
       else
       {
           LoadString(hInst, CodePage_pList[i], szBuf, sizeof(szBuf)/sizeof(TCHAR));
           SendMessage(
               hCombo,
               CB_ADDSTRING,
               (WPARAM) 0,
               (LPARAM) szBuf);
       }
    }

    return TRUE;
}

/****************************************************************************

    Function : Get current selected codepage

/****************************************************************************/
LONG CodePage_GetCurSelCodePage(
    HWND hWnd,
    UINT uID
    )
{
    HWND hCombo = (HWND) GetDlgItem(hWnd,uID);
    INT  nIndex;
    LONG lCodePage;

    if (hCombo == NULL)
    {
        return 0;
    }

    nIndex = (INT)SendMessage(
                hCombo,
                CB_GETCURSEL,
                (WPARAM) 0,
                (LPARAM) 0L);

    if (nIndex == CB_ERR)
    {
        return 0L;
    }

    lCodePage = CodePage_pList[nIndex];

    CodePage_lCurCodePage = lCodePage;
    return lCodePage;
}

/****************************************************************************

    Function : get current codepage value

/****************************************************************************/
LONG CodePage_GetCurCodePageVal()
{
   return CodePage_lCurCodePage;
}


/****************************************************************************

    Function : Set current codepage

/****************************************************************************/
// Set to this code page, if possible and return result of operation
BOOL CodePage_SetCurrent( LONG lCodePage , HWND hWnd , UINT uID )
{
  INT   i;
  HWND  hCombo = (HWND) GetDlgItem(hWnd,uID);
  DWORD dwResult;
  BOOL  bRet=FALSE;



  for( i=0; i<CodePage_nCount; i++)
  {
    if (CodePage_pList[i] == lCodePage)  // got a match
    {
      dwResult = (DWORD)SendMessage( hCombo,
                                     CB_SETCURSEL,
                                     (WPARAM) i,
                                     (LPARAM) 0L);
      if( CB_ERR != dwResult )
          bRet=TRUE;
    }
  }

  return bRet;
}

/****************************************************************************

    Function : Is this codepage on our list ?

/****************************************************************************/
BOOL
IsCodePageOnList(
    WORD wCodePage
    )
{
    int i = CodePage_nCount;

    while(i--)
    {
      if(CodePage_pList[i] == wCodePage)
          return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\display.cxx ===
/****************************************************************************

    Display.c

    PURPOSE: manage dispaly buffer for UCE

    Copyright (c) 1997-1999 Microsoft Corporation.
****************************************************************************/

#include "windows.h"
#include "commctrl.h"

#include "UCE.h"
#include "stdlib.h"
#include "tchar.h"
#include "stdio.h"
#include "winuser.h"
#include "string.h"
#include "search.h"

#include "winnls.h"
#include "wingdi.h"

LPWSTR Display_pList  = NULL;
INT    Display_nCount = 0;

/****************************************************************************

    Display_DeleteList

****************************************************************************/
BOOL
Display_DeleteList()
{
    if (Display_pList)
    {
        free(Display_pList);
    }
    Display_pList  = NULL;
    Display_nCount = 0;
    return TRUE;
}

/****************************************************************************

    Display_InitList

****************************************************************************/
BOOL
Display_InitList()
{
    Display_pList = NULL;
    Display_nCount = 0;
    return TRUE;
}

/****************************************************************************

    Display_IsInCMapTable
    Optimised verion using binary search [v-nirnay]  Dec 25, 1997

****************************************************************************/
__inline BOOL
Display_IsInCMapTable(
    WCHAR  wCode,
    URANGE *pFontCMapTab,
    UINT    uFontCMapTabNum
    )
{
    INT uFirst=0, uLast=uFontCMapTabNum, uMiddle;
    BOOL fFound=FALSE;

    while ((uFirst <= uLast) && (fFound == FALSE))
    {
        uMiddle = (uFirst + uLast) / 2;
        if ((wCode >= pFontCMapTab[uMiddle].wcFrom) &&
            (wCode <= pFontCMapTab[uMiddle].wcTo))
        {
            fFound = TRUE;
        }
        else if (pFontCMapTab[uMiddle].wcFrom < wCode)
        {
            uFirst = uMiddle + 1;
        }
        else
        {
            uLast = uMiddle - 1;
        }
    }

    return fFound;
}

extern INT cchSymRow;

/****************************************************************************

    Display_CreateDispBuffer

****************************************************************************/
LPWSTR
Display_CreateDispBuffer(
    LPWSTR lpszSubsetChars,
    INT    nSubsetChars,
    URANGE *pCMapTab,
    INT    nNumofCMapTab,
    BOOL   bSubstitute )
{
    INT i,j;

    Display_DeleteList();

    if(nSubsetChars == 0)
    {
        return NULL;
    }

    Display_pList = (LPWSTR) malloc(sizeof(WCHAR) * (nSubsetChars + 1));
    if (! Display_pList)
    {
        return NULL;
    }

    if(lpszSubsetChars != NULL)
    {
        // Split so that bsubs does not burden normal loading process
        if (!bSubstitute)
        {
            for (i=0,j=0; i<nSubsetChars; i++)
            {
                if (Display_IsInCMapTable(lpszSubsetChars[i],pCMapTab,nNumofCMapTab))
                {
                    Display_pList[j] =  lpszSubsetChars[i];
                    j++;
                }
            }
            Display_pList[j] = (WCHAR)0;
        }
        else
        {
            for (i=0,j=0; i<nSubsetChars; i++)
            {
                // If character is space it means we have reached end of
                // line if there are no valid characters on this line
                // proceed, else fill up all characters from current
                // point to end of column with spaces. Skip all the
                // spaces in input buffer
                if ( (lpszSubsetChars[i] != (WCHAR)0x20 )
                && (Display_IsInCMapTable(lpszSubsetChars[i],pCMapTab,nNumofCMapTab)) )
                {
                    Display_pList[j] =  lpszSubsetChars[i];
                    j++;
                }
                else  // This is a hack for the grid control
                {
                    if( IsAnyListWindow() && (lpszSubsetChars[i] == (WCHAR)0x20))
                    {
                        DWORD dwLeft = ((j)%cchSymRow);
                        if (dwLeft == 0L)
                            continue;
                        dwLeft = cchSymRow - dwLeft;
                        while (dwLeft)
                        {
                            Display_pList[j] =  (WCHAR)' ';
                            j++; dwLeft--;
                        }
                        while ( (i < nSubsetChars) && (lpszSubsetChars[i] ==
                          (WCHAR)0x20) )
                        {
                            i++;
                        }
			i--;
                    }
                }
            }
            Display_pList[j] = (WCHAR)0;
        }
    }

    return Display_pList;
}

/****************************************************************************

    Display_CreateSubsetDispBuffer

****************************************************************************/
LPWSTR
Display_CreateSubsetDispBuffer(
    LPWSTR lpszSubsetChars,
    INT    nSubsetChars,
    URANGE *pCMapTab,
    INT    nNumofCMapTab,
    BOOL   bSubstitute,
    int    iFrom,
    int    iTo )
{
    INT i,j, nChars;

    Display_DeleteList();

    if(nSubsetChars == 0)
    {
        return NULL;
    }

    nChars = min(nSubsetChars, (iTo-iFrom+2));

    Display_pList = (LPWSTR) malloc(sizeof(WCHAR) * nChars);
    if (! Display_pList)
    {
        return NULL;
    }

    if(lpszSubsetChars != NULL)
    {
        i = 0;
        while ((i<nSubsetChars) && (lpszSubsetChars[i] < iFrom))
        {
            i++;
        }

        j = 0;
        while ((i<nSubsetChars) && (lpszSubsetChars[i] <= iTo))
        {
            if (Display_IsInCMapTable(lpszSubsetChars[i],pCMapTab,nNumofCMapTab))
            {
                Display_pList[j] =  lpszSubsetChars[i];
                j++;
            }
            else  // This is a hack for the grid control
            {
                if( bSubstitute && IsAnyListWindow() )
                {
                    Display_pList[j] = (WCHAR)' ';
                    j++;
                }
            }
            i++;
        }

        Display_pList[j] = (WCHAR)0;
    }

    return Display_pList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\font.cxx ===
/****************************************************************************

    font.c

    PURPOSE: manage fonts for UCE

    Copyright (c) 1997-1999 Microsoft Corporation.
****************************************************************************/

#include "windows.h"
#include "commctrl.h"

#include "UCE.h"
#include "stdlib.h"
#include "tchar.h"
#include "stdio.h"
#include "winuser.h"
#include "string.h"
#include "search.h"

#include "winnls.h"
#include "wingdi.h"
#include <strsafe.h>

#define tag_CharToIndexMap      0x636d6170        /* 'cmap' */

#define FS_2BYTE(p)  ( ((unsigned short)((p)[0]) << 8) |  (p)[1])
#define FS_4BYTE(p)  ( FS_2BYTE((p)+2) | ( (FS_2BYTE(p)+0L) << 16) )

#define SWAPW(a)        ((short) FS_2BYTE( (unsigned char *)(&a) ))
#define SWAPL(a)        ((long) FS_4BYTE( (unsigned char *)(&a) ))

FONTINFO *Font_pList  = NULL;
INT       Font_nCount = 0;

//
// kd.c
//

/****************************************************************************

  Font_EnumProc

****************************************************************************/
INT APIENTRY
Font_EnumProc(
    LPLOGFONT lpLogFont,
    NEWTEXTMETRICEX *lpTextMetric,
    int    nFontType,
    LPARAM hWnd)
{
    DWORD   ntmFlags = lpTextMetric->ntmTm.ntmFlags;
    DWORD   FontType = 0;
    URANGE *pUniRange;
    DWORD   dwSize = 0;

    // excludes FE @ font
    if(lpLogFont->lfFaceName[0] == L'@') return (1);

//OEM FONT, BITMAP FONT will be treated as SYMBOL FONT
/*
    if(lpLogFont->lfCharSet == OEM_CHARSET)
    {
        if(lstrcmpi(lpLogFont->lfFaceName, L"Terminal") == 0)
        {
            FontType = OEM_FONTTYPE;
        }
    }
*/

    if (ntmFlags & NTM_PS_OPENTYPE)
    {
        FontType = PS_OPENTYPE_FONTTYPE;
    }
    else if (ntmFlags & NTM_TYPE1)
    {
        FontType = TYPE1_FONTTYPE;
    }
    else if (nFontType & TRUETYPE_FONT)
    {
        if (ntmFlags & NTM_TT_OPENTYPE)
            FontType = TT_OPENTYPE_FONTTYPE;
        else
            FontType = TRUETYPE_FONT;
    }
    else
    {
        FontType |= SYMBOL_FONTTYPE;
    }

    if(lpLogFont->lfCharSet == SYMBOL_CHARSET)
    {
        FontType |= SYMBOL_FONTTYPE;
    }

//
//SYMBOL/OEM/BITMAP FONT get the ANSI code points, we have to
//use ConvertAnsifontToUnicode later when we display them.
//
    if(FontType & SYMBOL_FONTTYPE)
    {
        pUniRange = (URANGE *) malloc (sizeof(URANGE));
        if (pUniRange)
        {
            pUniRange[0].wcFrom = 0x0021;
            pUniRange[0].wcTo   = 0x00FF;
            dwSize = 1;
        }
        else
        {
            //
            // error message, unicode range error.
            //
        }

    }
/* treat OEM/BITMAP as SYMBOL
    else if(FontType & OEM_FONTTYPE)
    {
        dwSize = URanges(CP_OEMCP, NULL);
        pUniRange = (URANGE *) malloc (sizeof(URANGE) * dwSize);
        if (pUniRange)
        {
            URanges(CP_OEMCP, pUniRange);
        }
        else
        {
            //
            // error message, unicode range error.
            //
        }
    }
    else if(FontType == 0)                                 // BitMap font
    {
        UINT cp = 0;

        if(lpLogFont->lfCharSet != OEM_CHARSET)
        {
           cp = CharSetToCodePage(lpLogFont->lfCharSet);
        }

        dwSize = URanges(cp, NULL);
        pUniRange = (URANGE *) malloc (sizeof(URANGE) * dwSize);
        if (pUniRange)
        {
            URanges(cp, pUniRange);
        }
        else
        {
            //
            // error message, unicode range error.
            //
        }
    }
*/
    else if((FontType &  PS_OPENTYPE_FONTTYPE) ||
            (FontType &  TYPE1_FONTTYPE))
    {
        pUniRange = (URANGE *) malloc (sizeof(URANGE));
        if (pUniRange)
        {
            pUniRange[0].wcFrom = 0x0021;
            pUniRange[0].wcTo   = 0xFFFF;
            dwSize = 1;
        }
        else
        {
            //
            // error message, unicode range error.
            //
        }
    }
    else    // TT_OPENTYPE_FONTTYPE || TRUETYPE_FONT
    {
        HFONT  hFontOld;
        LPVOID lpvBuffer = NULL;
        LPBYTE lp, lp1, lp2;
        DWORD  cbData;
        DWORD  dwTag = tag_CharToIndexMap;
        WORD   Num, i;
        HFONT  hFont = NULL;
        HDC    hdc = GetWindowDC((HWND)hWnd);

        if(hdc == NULL)
        {
            goto Close;
        }

        hFont = CreateFontIndirect(lpLogFont);
        hFontOld = (HFONT) SelectObject(hdc, hFont);
        dwTag = SWAPL(dwTag);
        if(!(cbData = GetFontData(hdc, dwTag, 0, NULL, 0)))
        {
            goto Close;
        }
        if(!(lpvBuffer = (LPVOID) malloc (cbData)))
        {
            goto Close;
        }
        GetFontData(hdc, dwTag, 0, lpvBuffer, cbData);

        Num = TWO_BYTE_NUM(((CMAP_HEAD*)lpvBuffer)->NumTables);
        lp1 = (BYTE*) ((BYTE*)lpvBuffer + sizeof(CMAP_HEAD));

        while(Num >0)
        {
          if(TWO_BYTE_NUM(((CMAP_TABLE*)lp1)->Platform) == MICROSOFT_PLATFORM)
//           TWO_BYTE_NUM(((CMAP_TABLE*)lp1)->Encoding) == UNICODE_INDEXING
          {
             lp = (BYTE*)
                  lpvBuffer
                  + FOUR_BYTE_NUM(((CMAP_TABLE*)lp1)->Offset);

             if(TWO_BYTE_NUM(((CMAP_FORMAT*)lp)->Format) == CMAP_FORMAT_FOUR)
             {
                break;
             }
          }
          Num--;
          lp1 += sizeof(CMAP_TABLE);
        }

        if(Num == 0)                   // can't find Platform:3/Encoding:1 (Unicode)
        {
            goto Close;
        }

        Num  = (TWO_BYTE_NUM(((CMAP_FORMAT*)lp)->SegCountX2));
        dwSize = Num>>1;
        pUniRange = (URANGE *) malloc (sizeof(URANGE)*dwSize);
        if (!pUniRange)
        {
            goto Close;
        }

        lp2  = lp  + sizeof(CMAP_FORMAT);        // lp2 -> first WCHAR of wcTo
        lp1  = lp2 + Num + 2;                    // lp1 -> first WCHAR of wcFrom
        for(i = 0; i < Num; i++, i++)
        {
            pUniRange[i>>1].wcFrom = TWO_BYTE_NUM((lp1+i));
            pUniRange[i>>1].wcTo   = TWO_BYTE_NUM((lp2+i));
        }

        //
        // Some fonts put glyphs in U+F000-F0FF,
        // It should be marked as a Symbol font as well.
        // For example, Guttman Adi (a Hebrew font from Office).
        //

        if( dwSize <= 2 &&
           (pUniRange[0].wcFrom >= 0xF000) &&
           (pUniRange[0].wcFrom <= 0xF0FF) )
        {
            if (pUniRange[0].wcFrom  < 0xF021)
            {
                pUniRange[0].wcFrom  = 0x0021;
            }
            else
            {
                pUniRange[0].wcFrom &= 0x00FF;
            }

            pUniRange[0].wcFrom &= 0x00FF;
            pUniRange[0].wcTo   &= 0x00FF;
            if(pUniRange[0].wcFrom < 0x0021)
               pUniRange[0].wcFrom = 0x0021;
            FontType |= SYMBOL_FONTTYPE;
        }

Close:
        if(hFont) DeleteObject(hFont);
        if(lpvBuffer) free(lpvBuffer);
        if(hdc)
        {
            SelectObject(hdc, hFontOld);
            ReleaseDC((HWND)hWnd, hdc);
        }
        if(dwSize == 0) return (1);
    }

    if (!Font_AddToList(lpLogFont, FontType, pUniRange, dwSize))
    {
        //
        // error message, add data error
        //
    }

    return (1);
}

/****************************************************************************

  EUDC_Fonts

****************************************************************************/
BOOL
EUDC_Fonts(LPLOGFONT lpLogFont)
{
    TCHAR EudcReg[] = TEXT("EUDC");
    TCHAR szFaceName[LF_EUDCFACESIZE];
    DWORD dwValue;
    TCHAR szFontFile[MAX_PATH];
    TCHAR szExpandedFontFile[MAX_PATH];
    DWORD dwData;
    DWORD dwType;
    LONG  Success;
    HKEY  hKey = NULL;
    int   i;

    DWORD    dwSize;
    URANGE  *pUniRange;

    HKEY  hKeyEUDC = NULL;
//    DWORD dwIndex;
    BOOL  bEUDC_TTE = FALSE;          // include EUDC.TTE only once
    BOOL bResult = TRUE;

    Success = RegOpenKeyEx(
                  HKEY_CURRENT_USER,
                  EudcReg,
                  0,
                  KEY_READ,
                  &hKeyEUDC);
    if(Success != ERROR_SUCCESS) return FALSE;

// only display fonts of the current codepage.
//    for (dwIndex=0; ;dwIndex++)
    {
        TCHAR    szName[8];
        DWORD    cbName = sizeof(szName);
        
        HRESULT hresult = StringCchPrintf(szName, sizeof(szName)/sizeof(szName[0]), TEXT("%d"), GetACP());
        if (!SUCCEEDED(hresult))
        {
           bResult = FALSE;
           goto exit;
        }
        /*
        Success = RegEnumKeyEx( hKeyEUDC, dwIndex,
                                szName, &cbName,
                                NULL, NULL, NULL,
                                &ft );
        if(Success != ERROR_SUCCESS)
        {
          RegCloseKey(hKeyEUDC);
          return TRUE;
          //  break;
        }
        */
        Success = RegOpenKeyEx( hKeyEUDC,
                                szName,
                                0,
                                KEY_READ,
                                &hKey );
        if(Success != ERROR_SUCCESS)
        {
            goto exit;
          //  break;
        }

        for (i=0; ;i++)
        {
            dwValue = sizeof(szFaceName)/sizeof(TCHAR);
            dwData  = sizeof(szFontFile);

            Success = RegEnumValue(
                          hKey,
                          i,
                          szFaceName,
                          &dwValue,
                          NULL,
                          &dwType,
                          (LPBYTE)szFontFile,
                          &dwData
                      );
            if(Success != ERROR_SUCCESS)
            {
                break;
            }

        
            if(CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szFaceName, -1, L"SystemDefaultEUDCFont", -1) == CSTR_EQUAL)
            {
                if(bEUDC_TTE) continue;
                bEUDC_TTE = TRUE;
            }

            ExpandEnvironmentStrings(szFontFile, szExpandedFontFile, MAX_PATH);

            /*
             * if this is not 'full path'. Build 'full path'.
             *
             *   EUDC.TTE -> C:\WINNT40\FONTS\EUDC.TTE
             *
             * 1. filename should have drive letter.
             * 2. filename should have one '\\' ,at least, for root.
             */
            if ((szExpandedFontFile[1] != _T(':')) ||
                (_tcsstr(szExpandedFontFile, _T("\\")) == NULL)) {
                TCHAR tmp[MAX_PATH];
                
                hresult = StringCchCopy(tmp , sizeof(tmp)/sizeof(tmp[0]),  szExpandedFontFile);
                if (!SUCCEEDED(hresult))
                {
                   bResult = FALSE;
                   goto exit;
                }
                GetSystemWindowsDirectory(szExpandedFontFile, MAX_PATH);
        
                hresult = StringCchCat(szExpandedFontFile , sizeof(szExpandedFontFile)/sizeof(szExpandedFontFile[0]),  _T("\\FONTS\\"));
                if (!SUCCEEDED(hresult))
                {
                    bResult = FALSE;
                    goto exit;
                }
        
                hresult = StringCchCat(szExpandedFontFile , sizeof(szExpandedFontFile)/sizeof(szExpandedFontFile[0]),  tmp);
                if (!SUCCEEDED(hresult))
                {
                   bResult = FALSE;
                   goto exit;
                }
            }

            pUniRange = EUDC_Range(szExpandedFontFile, &dwSize);

            if (!pUniRange)
            {
        
              if((CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szFaceName, -1, 
                  L"SystemDefaultEUDCFont", -1) == CSTR_EQUAL) && bEUDC_TTE)
              bEUDC_TTE = false;
              continue;
            }

        
            hresult = StringCchCopy(lpLogFont->lfFaceName , sizeof(lpLogFont->lfFaceName)/sizeof(lpLogFont->lfFaceName[0]),  szFaceName);
            if (!SUCCEEDED(hresult))
            {
               bResult = FALSE;            
               goto exit;
            }
            if (!Font_AddToList(lpLogFont, EUDC_FONTTYPE | TRUETYPE_FONT,
                                pUniRange, dwSize - 1))
            {
                //
                // error message, add data error
                //
            }
        }
    }

exit:
    if (hKey != NULL) 
    {
        RegCloseKey(hKey);
    }
    if (hKeyEUDC != NULL)
    {
        RegCloseKey(hKeyEUDC);
    }
    return (bResult);
}

/****************************************************************************

    Function : Delete this list.

****************************************************************************/
BOOL
Font_DeleteList()
{
    INT i;

    for (i=0; i<Font_nCount; i++)
    {
        if (Font_pList[i].pUniRange)
        {
            free(Font_pList[i].pUniRange);
            Font_pList[i].pUniRange = NULL;
        }
    }
    free(Font_pList);
    Font_pList  = NULL;
    Font_nCount = 0;
    return TRUE;
}

/****************************************************************************

    Function : Font_InitList

****************************************************************************/
BOOL
Font_InitList(HWND hWnd)
{
    LOGFONT lf;
    HDC     hDC;

    if (Font_pList)
    {
        Font_DeleteList();
    }

    Font_pList  = NULL;
    Font_nCount = 0;

    hDC = GetWindowDC(hWnd);

    lf.lfCharSet = 1;
    lf.lfFaceName[0] = 0;
    lf.lfPitchAndFamily = 0;
    EnumFontFamiliesEx(hDC, &lf, (FONTENUMPROC) Font_EnumProc, (LPARAM) hWnd, 0);
    ReleaseDC(hWnd, hDC);

    EUDC_Fonts(&lf);

    return TRUE;
}

/****************************************************************************

    Function : Font_AddToList

****************************************************************************/
BOOL
Font_AddToList(
    LPLOGFONT lpLogFont,
    DWORD    FontType,
    URANGE  *pUniRange,
    INT     nNumofUniRange
    )
{
    if (Font_pList == NULL)
    {
        Font_pList = (FONTINFO *)  malloc(sizeof(FONTINFO));
        if (Font_pList == NULL)
        {
            return FALSE;
        }
    }
    else
    {
        int i;
        FONTINFO *temp = NULL;

        if(!(FontType & EUDC_FONTTYPE))
        {
            for(i = 0; i < Font_nCount; i++)
            {
        
                if(CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, Font_pList[i].szFaceName, -1,lpLogFont->lfFaceName, -1) == CSTR_EQUAL)
                {
                    if((lpLogFont->lfCharSet >  Font_pList[i].CharSet) &&
                       (lpLogFont->lfCharSet == SHIFTJIS_CHARSET    ||
                        lpLogFont->lfCharSet == CHINESEBIG5_CHARSET ||
                        lpLogFont->lfCharSet == GB2312_CHARSET      ||
                        lpLogFont->lfCharSet == HANGEUL_CHARSET       ))
                    {
                        Font_pList[i].CharSet = lpLogFont->lfCharSet;
                    }
                    return FALSE;
                }
            }
        }

        temp = (FONTINFO *) realloc(Font_pList, sizeof(FONTINFO)*(Font_nCount+1));
        if (temp == NULL)
        {
            return FALSE;  // keep the buffer already allocated
        }
        Font_pList = temp;  // Replace the buffer with the new allocated one.
    }

    
    HRESULT hresult = StringCchCopy(Font_pList[Font_nCount].szFaceName , sizeof(Font_pList[Font_nCount].szFaceName)/sizeof(Font_pList[Font_nCount].szFaceName[0]) ,  lpLogFont->lfFaceName);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    Font_pList[Font_nCount].CharSet = lpLogFont->lfCharSet;
    Font_pList[Font_nCount].FontType = FontType;
    Font_pList[Font_nCount].PitchAndFamily = FF_DONTCARE;
    Font_pList[Font_nCount].pUniRange = pUniRange;
    Font_pList[Font_nCount].nNumofUniRange = nNumofUniRange;
    Font_nCount++;

    return TRUE;
}

/****************************************************************************

    Function : Font_FillToComboBox

****************************************************************************/
BOOL
Font_FillToComboBox(
    HWND hWnd,
    UINT uID
    )
{
    HWND hCombo = (HWND) GetDlgItem(hWnd,uID);
    INT  i;
    INT  nIndex;
    HRESULT hresult;

    if (hCombo == NULL)
    {
        return FALSE;
    }

    SendMessage(
        hCombo,
        CB_RESETCONTENT,
        0,
        0);

    for (i=0; i < Font_nCount; i++)
    {
        WCHAR  wcBuf[LF_EUDCFACESIZE];
	
        WCHAR  wcBuf1[LF_EUDCFACESIZE];

        if(((Font_pList[i].FontType & TRUETYPE_FONT) ||
            (Font_pList[i].FontType & TT_OPENTYPE_FONTTYPE)) &&
            (Font_pList[i].CharSet == SHIFTJIS_CHARSET    ||
             Font_pList[i].CharSet == CHINESEBIG5_CHARSET ||
             Font_pList[i].CharSet == GB2312_CHARSET      ||
             Font_pList[i].CharSet == HANGEUL_CHARSET)      )
        {
             Font_pList[i].FontType |= DBCS_FONTTYPE;
        }

    
        hresult = StringCchCopy(wcBuf , sizeof(wcBuf)/sizeof(wcBuf[0]),  Font_pList[i].szFaceName);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        if(Font_pList[i].FontType & EUDC_FONTTYPE)
        {
    
           if(CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, Font_pList[i].szFaceName, -1, L"SystemDefaultEUDCFont", -1) == CSTR_EQUAL)
           {
              LoadString(hInst, IDS_ALLFONTS, wcBuf, LF_EUDCFACESIZE);
           }

           LoadString(hInst, IDS_EUDC, wcBuf1, LF_EUDCFACESIZE);
    
           hresult = StringCchCat(wcBuf , sizeof(wcBuf)/sizeof(wcBuf[0]),  wcBuf1);
           if (!SUCCEEDED(hresult))
           {
              return FALSE;
           }
        }

        nIndex = (INT)SendMessage(
                     hCombo,
                     CB_ADDSTRING,
                     (WPARAM) 0,
                     (LPARAM) wcBuf);

        if (nIndex != CB_ERR)
        {
            SendMessage(
                hCombo,
                CB_SETITEMDATA,
                (WPARAM) nIndex,
                (LPARAM) i);
        }
    }
    return TRUE;
}

/****************************************************************************

    Function : Font_GetSelFontCharSet

****************************************************************************/
BYTE
Font_GetSelFontCharSet(
    HWND hWnd,
    UINT uID,
    INT  nIndex
    )
{
    HWND hCombo = (HWND) GetDlgItem(hWnd,uID);
    INT  i;

    if (hCombo == NULL)
    {
        return DEFAULT_CHARSET;
    }

    i = (INT)SendMessage(
            hCombo,
            CB_GETITEMDATA,
            (WPARAM) nIndex,
            (LPARAM) 0);

    if ((i >= 0) && (i < Font_nCount))
    {
        return Font_pList[i].CharSet;
    }
    else
    {
        return DEFAULT_CHARSET;
    }
}


/****************************************************************************

    Function : Font_SelectByCharSet

****************************************************************************/
BOOL
Font_SelectByCharSet(
    HWND hWnd,
    UINT uID,
    UINT CharSet
    )
{
    HWND hCombo = (HWND) GetDlgItem(hWnd,uID);
    INT  nIndex;
    INT  i;

    if (hCombo == NULL)
    {
        return FALSE;
    }

    //
    // do not swtich font if charset of the current font
    // is the same as CharSet
    //
    nIndex = (INT)SendMessage(
                 hCombo,
                 CB_GETCURSEL,
                 (WPARAM) 0,
                 (LPARAM) 0);

    if( CharSet == Font_GetSelFontCharSet(hWnd, uID, nIndex))
    {
        return FALSE;
    }

    for (i = 0; i < Font_nCount; i++)
    {
        if ((Font_pList[i].CharSet == CharSet)       &&
            (Font_pList[i].FontType & DBCS_FONTTYPE)   )
        {
            break;
        }
    }
    if (i < Font_nCount)
    {
        nIndex = (INT)SendMessage(
                     hCombo,
                     CB_FINDSTRING,
                     (WPARAM) -1,
                     (LPARAM) Font_pList[i].szFaceName);

        if (nIndex == CB_ERR)
        {
            return FALSE;
        }

        nIndex = (INT)SendMessage(
                     hCombo,
                     CB_SETCURSEL,
                     (WPARAM) nIndex,
                     (LPARAM) 0);

        if (nIndex != CB_ERR)
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }
}

/****************************************************************************

    Function : Font_IsWithinCodePage

****************************************************************************/
BOOL
Font_IsWithinCodePage(
    UINT   uCodePage,
    WCHAR  wc,
    WORD   *pAnsi
    )
{

    WORD   ctype;

    BOOL bSkip = FALSE;

    GetStringTypeW(CT_CTYPE1, &wc, 1, &ctype);

    if ((!ctype)            ||
        ( ctype & C1_CNTRL) ||
        ( ctype & C1_SPACE) ||
        ( ctype & C1_BLANK)   )
    {
        return FALSE;
    }

    if (uCodePage == UNICODE_CODEPAGE)
    {
        *pAnsi = 0;
        return TRUE;
    }
    else
    {
        WCHAR wc2;

        WideCharToMultiByte(
            uCodePage,
            0,
            &(wc), 1,
            (char*) pAnsi, 2,
            NULL, NULL);

        MultiByteToWideChar(
            uCodePage,
            MB_PRECOMPOSED,
            (char*) pAnsi, 2,
            &wc2, 1);

        return (wc == wc2);
    }
}

/****************************************************************************

    Function : Font_GetCurCMapTable

****************************************************************************/
BOOL
Font_GetCurCMapTable(
    HWND   hWnd,
    UINT   uID,
    URANGE **ppCodeList,
    UINT   *puNum
    )
{
    HWND hCombo = (HWND) GetDlgItem(hWnd,uID);
    INT  nItemIndex;
    INT  nIndex;

    if (hCombo == NULL)
    {
        return FALSE;
    }

    nIndex = (INT)SendMessage(
                 hCombo,
                 CB_GETCURSEL,
                 (WPARAM) 0,
                 (LPARAM) 0L);

    if (nIndex == CB_ERR)
    {
        return FALSE;
    }

    nItemIndex = (INT)SendMessage(
                     hCombo,
                     CB_GETITEMDATA,
                     (WPARAM) nIndex,
                     (LPARAM) 0);

    if ((nItemIndex < 0) || (nItemIndex >= Font_nCount))
    {
        return FALSE;
    }

    *ppCodeList = Font_pList[nItemIndex].pUniRange;
    *puNum      = Font_pList[nItemIndex].nNumofUniRange;

    return TRUE;
}

/****************************************************************************

    Function : Font_GetCharWidth32

****************************************************************************/
BOOL
Font_GetCharWidth32(
    HDC    hDC,
    UINT   chSymFirst,
    UINT   chSymLast,
    LPINT  lpdxp,
    LPWSTR pCode
    )
{
    UINT i;
    INT  nWidth;

    if (pCode == NULL)
    {
        return FALSE;
    }

    for (i=chSymFirst; i<=chSymLast; i++)
    {
        nWidth = 0;
        GetCharWidth32(
            hDC,
            (pCode[i]),
            (pCode[i]),
            &nWidth
        );
        *lpdxp = nWidth;
        lpdxp++;
    }
    return TRUE;
}

/****************************************************************************

    Function : Font_Avail

****************************************************************************/
BOOL
Font_Avail(
    UINT CharSet
    )
{
    int i;

    for (i = 0; i < Font_nCount; i++)
    {
        if (Font_pList[i].CharSet == CharSet)
        {
            return TRUE;
        }
    }

    return FALSE;
}

/****************************************************************************

    Function : return the first DBCS charset, 0 if none

****************************************************************************/
UINT
Font_DBCS_CharSet()
{
    int i;

    for (i = 0; i < Font_nCount; i++)
    {
        if (Font_pList[i].FontType & DBCS_FONTTYPE)
        {
            return Font_pList[i].CharSet;
        }
    }

    return 0;
}

/****************************************************************************

    Function : Simulate CMAP Unicode ranges for non-TTF fonts

****************************************************************************/
DWORD
URanges(UINT CodePage, URANGE *pUR)
{
    WCHAR wcBuf[128];
    WCHAR wcTmp;
    BYTE  cTmp, cBeg;
    int   nCount, i, j;
    DWORD nUR = 0;

    if(pUR != NULL)
    {
        pUR[nUR].wcFrom = (WCHAR) ASCII_BEG;
        pUR[nUR].wcTo   = (WCHAR) ASCII_END;
    }
    nUR++;

    cBeg   = HIANSI_BEG;
    if(CodePage != CP_OEMCP)
    {
        cBeg += 32;
    }

    nCount = 0;
    for(cTmp = cBeg; cTmp != 0; cTmp++)
    {
        if(MultiByteToWideChar(CodePage, 0, (char*)&cTmp, 1, &wcTmp, 1) == 0 ||
           wcTmp <= 0x009F ||
           (wcTmp >= 0xE000 && wcTmp <= 0xF8FF))
           continue;

        for(i = 0; i < nCount; i++)
        {
            if(wcBuf[i] >= wcTmp)
                break;
        }

        if(i < nCount)
        {
            for(j = nCount; j > i; j--)
            {
                wcBuf[j] = wcBuf[j-1];
            }
        }

        wcBuf[i] = wcTmp;
        nCount++;
    }

    if(nCount > 0)
    {
        i = 0;
        while(1)
        {
            if(i == (nCount-1))
            {
                if(pUR != NULL)
                {
                    pUR[nUR].wcFrom = wcBuf[i];
                    pUR[nUR].wcTo   = wcBuf[i];
                }
                nUR++;
                break;
            }

            for(j = i; j < nCount-1; j++)
            {
                if((wcBuf[j+1] - wcBuf[j]) != 1) break;
            }

            if(pUR != NULL)
            {
                pUR[nUR].wcFrom = wcBuf[i];
                pUR[nUR].wcTo   = wcBuf[j];
            }
            nUR++;

            if(j == (nCount-1))
            {
                break;
            }

            i = j + 1;
        }
    }

    return nUR;
}

/****************************************************************************

    Function : convert CharSet to CodePage

****************************************************************************/
UINT
CharSetToCodePage(BYTE cs)
{
    switch(cs)
    {
        case (OEM_CHARSET):
        case (ANSI_CHARSET):
            return 1252;

        case (SHIFTJIS_CHARSET):
            return 932;

        case (CHINESEBIG5_CHARSET):
            return 950;

        case (HANGEUL_CHARSET):
            return 949;

        case (GB2312_CHARSET):
            return 936;

        case (EASTEUROPE_CHARSET):
            return 1250;

        case (GREEK_CHARSET):
            return 1253;

        case (RUSSIAN_CHARSET):
            return 1251;

        case (TURKISH_CHARSET):
            return 1254;

        case (BALTIC_CHARSET):
            return 1257;

        case (VIETNAMESE_CHARSET):
            return 1258;

        case (THAI_CHARSET):
            return 874;

        case (ARABIC_CHARSET):
            return 1255;

        case (HEBREW_CHARSET):
            return 1256;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\helpids.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
#ifndef HELPIDS_H
#define HELPIDS_H

#define IDH_UCE_SELECT                  103
#define IDH_UCE_COPY                    102
#define IDH_UCE_FONT                    105
#define IDH_UCE_ADVANCED                119
#define IDH_UCE_CHARSET                 130
#define IDH_UCE_SEARCHBYGROUP           202
#define IDH_UCE_SEARCHBYNAME            132
#define IDH_UCE_SEARCHRESET             133
#define IDH_UCE_COPYCHAR                104
#define IDH_UCE_GRIDCHAR                100
#define IDH_UCE_HELPBUTTON              135
#define IDH_UCE_GOTOUNICODE             140

#endif // HELPIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\enumfetc.c ===
//**********************************************************************
// File name: cdataobj.h
//
//  Standard implementation of IEnumFormatEtc. This code
//  is from \ole2\samp\ole2ui\enumfetc.c in the OLE 2 SDK.
//
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//**********************************************************************

#define STRICT  1
#include <windows.h>
#include <ole2.h>
#include "enumfetc.h"

typedef struct tagOleStdEnumFmtEtc {
  IEnumFORMATETCVtbl FAR* lpVtbl;
  ULONG m_dwRefs;       /* referance count */
  ULONG m_nIndex;       /* current index in list */
  ULONG m_nCount;       /* how many items in list */
  LPFORMATETC m_lpEtc;  /* list of formatetc */
} OLESTDENUMFMTETC, FAR* LPOLESTDENUMFMTETC;

VOID  OleStdEnumFmtEtc_Destroy(LPOLESTDENUMFMTETC pEtc);

STDMETHODIMP OleStdEnumFmtEtc_QueryInterface(
        LPENUMFORMATETC lpThis, REFIID riid, LPVOID FAR* ppobj);
STDMETHODIMP_(ULONG)  OleStdEnumFmtEtc_AddRef(LPENUMFORMATETC lpThis);
STDMETHODIMP_(ULONG)  OleStdEnumFmtEtc_Release(LPENUMFORMATETC lpThis);
STDMETHODIMP  OleStdEnumFmtEtc_Next(LPENUMFORMATETC lpThis, ULONG celt,
                                  LPFORMATETC rgelt, ULONG FAR* pceltFetched);
STDMETHODIMP  OleStdEnumFmtEtc_Skip(LPENUMFORMATETC lpThis, ULONG celt);
STDMETHODIMP  OleStdEnumFmtEtc_Reset(LPENUMFORMATETC lpThis);
STDMETHODIMP  OleStdEnumFmtEtc_Clone(LPENUMFORMATETC lpThis,
                                     LPENUMFORMATETC FAR* ppenum);

static IEnumFORMATETCVtbl g_EnumFORMATETCVtbl = {
        OleStdEnumFmtEtc_QueryInterface,
        OleStdEnumFmtEtc_AddRef,
        OleStdEnumFmtEtc_Release,
        OleStdEnumFmtEtc_Next,
        OleStdEnumFmtEtc_Skip,
        OleStdEnumFmtEtc_Reset,
        OleStdEnumFmtEtc_Clone,
};

/////////////////////////////////////////////////////////////////////////////


STDAPI_(LPENUMFORMATETC)
  OleStdEnumFmtEtc_Create(ULONG nCount, LPFORMATETC lpEtc)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPMALLOC lpMalloc=NULL;
  LPOLESTDENUMFMTETC lpEF=NULL;
  DWORD dwSize;
  WORD i;
  HRESULT hRes;

  hRes = CoGetMalloc(MEMCTX_TASK, &lpMalloc);
  if (hRes != NOERROR) {
    return NULL;
  }

  lpEF = (LPOLESTDENUMFMTETC)lpMalloc->lpVtbl->Alloc(lpMalloc,
                                                 sizeof(OLESTDENUMFMTETC));
  if (lpEF == NULL) {
    goto errReturn;
  }

  lpEF->lpVtbl = &g_EnumFORMATETCVtbl;
  lpEF->m_dwRefs = 1;
  lpEF->m_nCount = nCount;
  lpEF->m_nIndex = 0;

  dwSize = sizeof(FORMATETC) * lpEF->m_nCount;

  lpEF->m_lpEtc = (LPFORMATETC)lpMalloc->lpVtbl->Alloc(lpMalloc, dwSize);
  if (lpEF->m_lpEtc == NULL)
    goto errReturn;

  lpMalloc->lpVtbl->Release(lpMalloc);

  for (i=0; i<nCount; i++) {
    OleStdCopyFormatEtc(
            (LPFORMATETC)&(lpEF->m_lpEtc[i]), (LPFORMATETC)&(lpEtc[i]));
  }

  return (LPENUMFORMATETC)lpEF;

errReturn:
  if (lpEF != NULL)
    lpMalloc->lpVtbl->Free(lpMalloc, lpEF);

  if (lpMalloc != NULL)
    lpMalloc->lpVtbl->Release(lpMalloc);

  return NULL;

} /* OleStdEnumFmtEtc_Create()
   */


VOID
  OleStdEnumFmtEtc_Destroy(LPOLESTDENUMFMTETC lpEF)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
    LPMALLOC lpMalloc=NULL;
    WORD i;

    if (lpEF != NULL) {

        if (CoGetMalloc(MEMCTX_TASK, &lpMalloc) == NOERROR) {

            /* OLE2NOTE: we MUST free any memory that was allocated for
            **    TARGETDEVICES contained within the FORMATETC elements.
            */
            for (i=0; i<lpEF->m_nCount; i++) {
                OleStdFree(lpEF->m_lpEtc[i].ptd);
            }

            if (lpEF->m_lpEtc != NULL) {
                lpMalloc->lpVtbl->Free(lpMalloc, lpEF->m_lpEtc);
            }

            lpMalloc->lpVtbl->Free(lpMalloc, lpEF);
            lpMalloc->lpVtbl->Release(lpMalloc);
        }
    }

} /* OleStdEnumFmtEtc_Destroy()
   */


STDMETHODIMP
  OleStdEnumFmtEtc_QueryInterface(
                LPENUMFORMATETC lpThis, REFIID riid, LPVOID FAR* ppobj)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  *ppobj = NULL;

  if (IsEqualIID(riid,&IID_IUnknown) || IsEqualIID(riid,&IID_IEnumFORMATETC)){
    *ppobj = (LPVOID)lpEF;
  }

  if (*ppobj == NULL) return ResultFromScode(E_NOINTERFACE);
  else{
    OleStdEnumFmtEtc_AddRef(lpThis);
    return NOERROR;
  }

} /* OleStdEnumFmtEtc_QueryInterface()
   */


STDMETHODIMP_(ULONG)
  OleStdEnumFmtEtc_AddRef(LPENUMFORMATETC lpThis)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  return lpEF->m_dwRefs++;

} /* OleStdEnumFmtEtc_AddRef()
   */


STDMETHODIMP_(ULONG)
  OleStdEnumFmtEtc_Release(LPENUMFORMATETC lpThis)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  DWORD dwRefs = --lpEF->m_dwRefs;

  if (dwRefs == 0)
    OleStdEnumFmtEtc_Destroy(lpEF);

  return dwRefs;

} /* OleStdEnumFmtEtc_Release()
   */


STDMETHODIMP
  OleStdEnumFmtEtc_Next(LPENUMFORMATETC lpThis, ULONG celt, LPFORMATETC rgelt,
                      ULONG FAR* pceltFetched)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  ULONG i=0;
  ULONG nOffset;

  if (rgelt == NULL) {
    return ResultFromScode(E_INVALIDARG);
  }

  while (i < celt) {
    nOffset = lpEF->m_nIndex + i;

    if (nOffset < lpEF->m_nCount) {
      OleStdCopyFormatEtc(
            (LPFORMATETC)&(rgelt[i]), (LPFORMATETC)&(lpEF->m_lpEtc[nOffset]));
      i++;
    }else{
      break;
    }
  }

  lpEF->m_nIndex += (WORD)i;

  if (pceltFetched != NULL) {
    *pceltFetched = i;
  }

  if (i != celt) {
    return ResultFromScode(S_FALSE);
  }

  return NOERROR;
} /* OleStdEnumFmtEtc_Next()
   */


STDMETHODIMP
  OleStdEnumFmtEtc_Skip(LPENUMFORMATETC lpThis, ULONG celt)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  ULONG i=0;
  ULONG nOffset;

  while (i < celt) {
    nOffset = lpEF->m_nIndex + i;

    if (nOffset < lpEF->m_nCount) {
      i++;
    }else{
      break;
    }
  }

  lpEF->m_nIndex += (WORD)i;

  if (i != celt) {
    return ResultFromScode(S_FALSE);
  }

  return NOERROR;
} /* OleStdEnumFmtEtc_Skip()
   */


STDMETHODIMP
  OleStdEnumFmtEtc_Reset(LPENUMFORMATETC lpThis)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;
  lpEF->m_nIndex = 0;

  return NOERROR;
} /* OleStdEnumFmtEtc_Reset()
   */


STDMETHODIMP
  OleStdEnumFmtEtc_Clone(LPENUMFORMATETC lpThis, LPENUMFORMATETC FAR* ppenum)
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
{
  LPOLESTDENUMFMTETC lpEF = (LPOLESTDENUMFMTETC)lpThis;

  if (ppenum == NULL) {
    return ResultFromScode(E_INVALIDARG);
  }

  *ppenum = OleStdEnumFmtEtc_Create(lpEF->m_nCount, lpEF->m_lpEtc);

  // make sure cloned enumerator has same index state as the original
  if (*ppenum) {
      LPOLESTDENUMFMTETC lpEFClone = (LPOLESTDENUMFMTETC)*ppenum;
      lpEFClone->m_nIndex = lpEF->m_nIndex;
      return NOERROR;
  } else
      return ResultFromScode(E_OUTOFMEMORY);

} /* OleStdEnumFmtEtc_Clone()
   */

/*
 * OleStdCopyTargetDevice()
 *
 * Purpose:
 *  duplicate a TARGETDEVICE struct. this function allocates memory for
 *  the copy. the caller MUST free the allocated copy when done with it
 *  using the standard allocator returned from CoGetMalloc.
 *  (OleStdFree can be used to free the copy).
 *
 * Parameters:
 *  ptdSrc      pointer to source TARGETDEVICE
 *
 * Return Value:
 *    pointer to allocated copy of ptdSrc
 *    if ptdSrc==NULL then retuns NULL is returned.
 *    if ptdSrc!=NULL and memory allocation fails, then NULL is returned
 */
STDAPI_(DVTARGETDEVICE FAR*) OleStdCopyTargetDevice(DVTARGETDEVICE FAR* ptdSrc)
{
  DVTARGETDEVICE FAR* ptdDest = NULL;

  if (ptdSrc == NULL) {
    return NULL;
  }

  if ((ptdDest = (DVTARGETDEVICE FAR*)OleStdMalloc(ptdSrc->tdSize)) != NULL) {
      memcpy(ptdDest, ptdSrc, (size_t)ptdSrc->tdSize);
  }

  return ptdDest;
}


/*
 * OleStdCopyFormatEtc()
 *
 * Purpose:
 *  Copies the contents of a FORMATETC structure. this function takes
 *  special care to copy correctly copying the pointer to the TARGETDEVICE
 *  contained within the source FORMATETC structure.
 *  if the source FORMATETC has a non-NULL TARGETDEVICE, then a copy
 *  of the TARGETDEVICE will be allocated for the destination of the
 *  FORMATETC (petcDest).
 *
 *  OLE2NOTE: the caller MUST free the allocated copy of the TARGETDEVICE
 *  within the destination FORMATETC when done with it
 *  using the standard allocator returned from CoGetMalloc.
 *  (OleStdFree can be used to free the copy).
 *
 * Parameters:
 *  petcDest      pointer to destination FORMATETC
 *  petcSrc       pointer to source FORMATETC
 *
 * Return Value:
 *    returns TRUE is copy is successful; retuns FALSE if not successful
 */
STDAPI_(BOOL) OleStdCopyFormatEtc(LPFORMATETC petcDest, LPFORMATETC petcSrc)
{
  if ((petcDest == NULL) || (petcSrc == NULL)) {
    return FALSE;
  }

  petcDest->cfFormat = petcSrc->cfFormat;
  petcDest->ptd      = OleStdCopyTargetDevice(petcSrc->ptd);
  petcDest->dwAspect = petcSrc->dwAspect;
  petcDest->lindex   = petcSrc->lindex;
  petcDest->tymed    = petcSrc->tymed;

  return TRUE;

}

/* OleStdFree
** ----------
**    free memory using the currently active IMalloc* allocator
*/
STDAPI_(void) OleStdFree(LPVOID pmem)
{
    LPMALLOC pmalloc;

    if (pmem == NULL)
        return;

    if (CoGetMalloc(MEMCTX_TASK, &pmalloc) != NOERROR) {
        return;
    }

    pmalloc->lpVtbl->Free(pmalloc, pmem);

    if (pmalloc != NULL) {
        ULONG refs = pmalloc->lpVtbl->Release(pmalloc);
    }
}

/* OleStdMalloc
** ------------
**    allocate memory using the currently active IMalloc* allocator
*/
STDAPI_(LPVOID) OleStdMalloc(ULONG ulSize)
{
    LPVOID pout;
    LPMALLOC pmalloc;

    if (CoGetMalloc(MEMCTX_TASK, &pmalloc) != NOERROR) {
        return NULL;
    }

    pout = (LPVOID)pmalloc->lpVtbl->Alloc(pmalloc, ulSize);

    if (pmalloc != NULL) {
        ULONG refs = pmalloc->lpVtbl->Release(pmalloc);
    }

    return pout;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\htmlhelp.h ===
/****************************************************************************
*                                                                           *
* HtmlHelp.h																*
*                                                                           *
* Copyright (c) 1996-1999 Microsoft Corp.                       			*
*                                                                           *
****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __HTMLHELP_H__
#define __HTMLHELP_H__

#ifdef __cplusplus
extern "C" {
#endif	// __cplusplus

//	Commands to pass to HtmlHelp()

#define HH_DISPLAY_TOPIC		0x0000
#define HH_HELP_FINDER			0x0000	// WinHelp equivalent
#define HH_DISPLAY_TOC			0x0001	// not currently implemented
#define HH_DISPLAY_INDEX		0x0002	// not currently implemented
#define HH_DISPLAY_SEARCH		0x0003	// not currently implemented
#define HH_SET_WIN_TYPE 		0x0004
#define HH_GET_WIN_TYPE 		0x0005
#define HH_GET_WIN_HANDLE		0x0006
#define HH_GET_INFO_TYPES		0x0007	// not currently implemented
#define HH_SET_INFO_TYPES		0x0008	// not currently implemented
#define HH_SYNC 				0x0009
#define HH_ADD_NAV_UI			0x000A	// not currently implemented
#define HH_ADD_BUTTON			0x000B	// not currently implemented
#define HH_GETBROWSER_APP		0x000C	// not currently implemented
#define HH_KEYWORD_LOOKUP		0x000D
#define HH_DISPLAY_TEXT_POPUP	0x000E	// display string resource id or text in a popup window
#define HH_HELP_CONTEXT 		0x000F	// display mapped numeric value in dwData
#define HH_TP_HELP_CONTEXTMENU	0x0010	// text popup help, same as WinHelp HELP_CONTEXTMENU
#define HH_TP_HELP_WM_HELP		0x0011	// text popup help, same as WinHelp HELP_WM_HELP


#define HHWIN_PROP_ONTOP		  (1 << 1)	  // Top-most window (not currently implemented)
#define HHWIN_PROP_NOTITLEBAR	  (1 << 2)	  // no title bar
#define HHWIN_PROP_NODEF_STYLES   (1 << 3)	  // no default window styles (only HH_WINTYPE.dwStyles)
#define HHWIN_PROP_NODEF_EXSTYLES (1 << 4)	  // no default extended window styles (only HH_WINTYPE.dwExStyles)
#define HHWIN_PROP_TRI_PANE 	  (1 << 5)	  // use a tri-pane window
#define HHWIN_PROP_NOTB_TEXT	  (1 << 6)	  // no text on toolbar buttons
#define HHWIN_PROP_POST_QUIT	  (1 << 7)	  // post WM_QUIT message when window closes
#define HHWIN_PROP_AUTO_SYNC	  (1 << 8)	  // automatically ssync contents and index
#define HHWIN_PROP_TRACKING 	  (1 << 9)	  // send tracking notification messages
#define HHWIN_PROP_TAB_SEARCH	  (1 << 10)   // include search tab in navigation pane
#define HHWIN_PROP_TAB_HISTORY	  (1 << 11)   // include history tab in navigation pane
#define HHWIN_PROP_TAB_FAVORITES  (1 << 12)   // include favorites tab in navigation pane
#define HHWIN_PROP_CHANGE_TITLE   (1 << 13)   // Put current HTML title in title bar
#define HHWIN_PROP_NAV_ONLY_WIN   (1 << 14)   // Only display the navigation window
#define HHWIN_PROP_NO_TOOLBAR	  (1 << 15)   // Don't display a toolbar

#define HHWIN_PARAM_PROPERTIES		(1 << 1)	 // valid fsWinProperties
#define HHWIN_PARAM_STYLES			(1 << 2)	 // valid dwStyles
#define HHWIN_PARAM_EXSTYLES		(1 << 3)	 // valid dwExStyles
#define HHWIN_PARAM_RECT			(1 << 4)	 // valid rcWindowPos
#define HHWIN_PARAM_NAV_WIDTH		(1 << 5)	 // valid iNavWidth
#define HHWIN_PARAM_SHOWSTATE		(1 << 6)	 // valid nShowState
#define HHWIN_PARAM_INFOTYPES		(1 << 7)	 // valid ainfoTypes
#define HHWIN_PARAM_TB_FLAGS		(1 << 8)	 // valid fsToolBarFlags
#define HHWIN_PARAM_EXPANSION		(1 << 9)	 // valid fExpanded
#define HHWIN_PARAM_TABPOS			(1 << 10)	 // valid tabpos
#define HHWIN_PARAM_TABORDER		(1 << 11)	 // valid taborder
#define HHWIN_PARAM_HISTORY_COUNT	(1 << 12)	 // valid cHistory
#define HHWIN_PARAM_CUR_TAB 		(1 << 13)	 // valid curNavType

#define HHWIN_BUTTON_EXPAND 		(1 << 1)	 // Expand/contract button
#define HHWIN_BUTTON_BACK			(1 << 2)	 // Back button
#define HHWIN_BUTTON_FORWARD		(1 << 3)	 // Forward button
#define HHWIN_BUTTON_STOP			(1 << 4)	 // Stop button
#define HHWIN_BUTTON_REFRESH		(1 << 5)	 // Refresh button
#define HHWIN_BUTTON_HOME			(1 << 6)	 // Home button
#define HHWIN_BUTTON_BROWSE_FWD 	(1 << 7)	 // not implemented
#define HHWIN_BUTTON_BROWSE_BCK 	(1 << 8)	 // not implemented
#define HHWIN_BUTTON_NOTES			(1 << 9)	 // not implemented
#define HHWIN_BUTTON_CONTENTS		(1 << 10)	 // not implemented
#define HHWIN_BUTTON_SYNC			(1 << 11)	 // Sync button
#define HHWIN_BUTTON_OPTIONS		(1 << 12)	 // Options button
#define HHWIN_BUTTON_PRINT			(1 << 13)	 // Print button
#define HHWIN_BUTTON_INDEX			(1 << 14)	 // not implemented
#define HHWIN_BUTTON_SEARCH 		(1 << 15)	 // not implemented
#define HHWIN_BUTTON_HISTORY		(1 << 16)	 // not implemented
#define HHWIN_BUTTON_FAVORITES		(1 << 17)	 // not implemented
#define HHWIN_BUTTON_JUMP1			(1 << 18)
#define HHWIN_BUTTON_JUMP2			(1 << 19)
#define HHWIN_BUTTON_ZOOM        (1 << 20)
#define HHWIN_BUTTON_TOC_NEXT    (1 << 21)
#define HHWIN_BUTTON_TOC_PREV    (1 << 22)

// Ralphs default toolbar.
//
//#define HHWIN_DEF_BUTTONS  (HHWIN_BUTTON_EXPAND | HHWIN_BUTTON_BACK | HHWIN_BUTTON_OPTIONS | HHWIN_BUTTON_PRINT)

// VSHH's default toolbar for testing purposes only.
//
#define HHWIN_DEF_BUTTONS  (HHWIN_BUTTON_TOC_NEXT | HHWIN_BUTTON_TOC_PREV | HHWIN_BUTTON_SYNC | HHWIN_BUTTON_EXPAND | \
                            HHWIN_BUTTON_BACK | HHWIN_BUTTON_OPTIONS | HHWIN_BUTTON_PRINT | HHWIN_BUTTON_ZOOM)

// Button IDs

#define IDTB_EXPAND 				200
#define IDTB_CONTRACT				201
#define IDTB_STOP					202
#define IDTB_REFRESH				203
#define IDTB_BACK					204
#define IDTB_HOME					205
#define IDTB_SYNC					206
#define IDTB_PRINT					207
#define IDTB_OPTIONS				208
#define IDTB_FORWARD				209
#define IDTB_NOTES					210 // not implemented
#define IDTB_BROWSE_FWD 			211
#define IDTB_BROWSE_BACK			212
#define IDTB_CONTENTS				213 // not implemented
#define IDTB_INDEX					214 // not implemented
#define IDTB_SEARCH 				215 // not implemented
#define IDTB_HISTORY				216 // not implemented
#define IDTB_FAVORITES				217 // not implemented
#define IDTB_JUMP1					218
#define IDTB_JUMP2					219
#define IDTB_ZOOM						221
#define IDTB_TOC_NEXT				222
#define IDTB_TOC_PREV				223

// Notification codes

#define HHN_FIRST	(0U-860U)
#define HHN_LAST	(0U-879U)

#define HHN_NAVCOMPLETE (HHN_FIRST-0)
#define HHN_TRACK		(HHN_FIRST-1)

typedef struct tagHHN_NOTIFY
{
	NMHDR	hdr;
	PCSTR	pszUrl; // Multi-byte, null-terminated string
} HHN_NOTIFY;

typedef struct tagHH_POPUP
{
	int 	  cbStruct; 	 // sizeof this structure
	HINSTANCE hinst;		 // instance handle for string resource
	UINT	  idString; 	 // string resource id, or text id if pszFile is specified in HtmlHelp call
	LPCTSTR   pszText;		 // used if idString is zero
	POINT	  pt;			 // top center of popup window
	COLORREF  clrForeground; // use -1 for default
	COLORREF  clrBackground; // use -1 for default
	RECT	  rcMargins;	 // amount of space between edges of window and text, -1 for each member to ignore
	LPCTSTR   pszFont;		 // facename, point size, char set, BOLD ITALIC UNDERLINE
} HH_POPUP;

typedef struct tagHH_AKLINK
{
	int 	  cbStruct; 	// sizeof this structure
	BOOL	  fReserved;	// must be FALSE (really!)
	LPCTSTR   pszKeywords;	// semi-colon separated keywords
	LPCTSTR   pszUrl;		// URL to jump to if no keywords found (may be NULL)
	LPCTSTR   pszMsgText;	// Message text to display in MessageBox if pszUrl is NULL and no keyword match
	LPCTSTR   pszMsgTitle;	// Message text to display in MessageBox if pszUrl is NULL and no keyword match
	LPCTSTR   pszWindow;	// Window to display URL in
	BOOL      fIndexOnFail;	// Displays index if keyword lookup fails.
} HH_AKLINK;

enum {
	HHACT_EXPAND,
	HHACT_CONTRACT,
	HHACT_BACK,
	HHACT_FORWARD,
	HHACT_STOP,
	HHACT_REFRESH,
	HHACT_HOME,
	HHACT_SYNC,
	HHACT_OPTIONS,
	HHACT_PRINT,

	HHACT_TAB_CONTENTS,
	HHACT_TAB_INDEX,
	HHACT_TAB_SEARCH,
	HHACT_TAB_HISTORY,
	HHACT_TAB_FAVORITES,
};

typedef struct tagHHNTRACK
{
	NMHDR	hdr;
	PCSTR	pszCurUrl;	// Multi-byte, null-terminated string
	int 	idAction;	// HHACT_ value
} HHNTRACK;

enum {
	HHWIN_NAVTYPE_TOC,
	HHWIN_NAVTYPE_INDEX,
	HHWIN_NAVTYPE_SEARCH,
	HHWIN_NAVTYPE_HISTORY,		// not implemented
	HHWIN_NAVTYPE_FAVORITES,	// not implemented
};

typedef DWORD HH_INFOTYPE;
typedef HH_INFOTYPE* PHH_INFOTYPE;

enum {
	HHWIN_NAVTAB_TOP,
	HHWIN_NAVTAB_LEFT,
	HHWIN_NAVTAB_BOTTOM,
};

#define HH_MAX_TABS 19	// maximum number of tabs
enum {
	HH_TAB_CONTENTS,
	HH_TAB_INDEX,
	HH_TAB_SEARCH,
	HH_TAB_HISTORY,
	HH_TAB_FAVORITES,
};

// HH_DISPLAY_SEARCH Command Related Structures and Constants

#define HH_FTS_DEFAULT_PROXIMITY (-1)

typedef struct tagHH_FTS_QUERY
{
	int cbStruct;			   // Sizeof structure in bytes.
	BOOL fUniCodeStrings;	   // TRUE if all strings are unicode.
	LPCTSTR pszSearchQuery;    // String containing the search query.
	LONG iProximity;		   // Word proximity.
	BOOL fStemmedSearch;	   // TRUE for StemmedSearch only.
	BOOL fTitleOnly;		   // TRUE for Title search only.
	BOOL fExecute;			   // TRUE to initiate the search.
	LPCTSTR pszWindow;		   // Window to display in
} HH_FTS_QUERY;


// HH_WINTYPE Structure

typedef struct tagHH_WINTYPE {
	int 	cbStruct;		  // IN: size of this structure including all Information Types
	BOOL	fUniCodeStrings;  // IN/OUT: TRUE if all strings are in UNICODE
	LPCTSTR pszType;		  // IN/OUT: Name of a type of window
	DWORD	fsValidMembers;   // IN: Bit flag of valid members (HHWIN_PARAM_)
	DWORD	fsWinProperties;  // IN/OUT: Properties/attributes of the window (HHWIN_)

	LPCTSTR pszCaption; 	// IN/OUT: Window title
	DWORD	dwStyles;		// IN/OUT: Window styles
	DWORD	dwExStyles; 	// IN/OUT: Extended Window styles
	RECT	rcWindowPos;	// IN: Starting position, OUT: current position
	int 	nShowState; 	// IN: show state (e.g., SW_SHOW)

	HWND  hwndHelp; 		// OUT: window handle
	HWND  hwndCaller;		// OUT: who called this window

	HH_INFOTYPE* paInfoTypes;  // IN: Pointer to an array of Information Types

	// The following members are only valid if HHWIN_PROP_TRI_PANE is set

	HWND  hwndToolBar;		// OUT: toolbar window in tri-pane window
	HWND  hwndNavigation;	// OUT: navigation window in tri-pane window
	HWND  hwndHTML; 		// OUT: window displaying HTML in tri-pane window
	int   iNavWidth;		// IN/OUT: width of navigation window
	RECT  rcHTML;			// OUT: HTML window coordinates

	LPCTSTR pszToc; 		// IN: Location of the table of contents file
	LPCTSTR pszIndex;		// IN: Location of the index file
	LPCTSTR pszFile;		// IN: Location of the html file
	LPCTSTR pszHome;		// IN/OUT: html file to display when Home button is clicked
	DWORD	fsToolBarFlags; // IN: flags controling the appearance of the toolbar
	BOOL	fNotExpanded;	// IN: TRUE/FALSE to expand or contract, OUT: current state
	int 	curNavType; 	// IN/OUT: UI to display in the navigational pane
	int 	tabpos; 		// IN/OUT: NAVTAB_TOP, NAVTAB_LEFT, or NAVTAB_BOTTOM
	int 	idNotify;		// IN: ID to use for WM_NOTIFY messages
	BYTE	tabOrder[HH_MAX_TABS + 1];	  // IN/OUT: tab order: Contents, Index, Search, History, Favorites, Reserved 1-5, Custom tabs
	int 	cHistory;		// IN/OUT: number of history items to keep (default is 30)
	LPCTSTR pszJump1;		// Text for HHWIN_BUTTON_JUMP1
	LPCTSTR pszJump2;		// Text for HHWIN_BUTTON_JUMP2
	LPCTSTR pszUrlJump1;	// URL for HHWIN_BUTTON_JUMP1
	LPCTSTR pszUrlJump2;	// URL for HHWIN_BUTTON_JUMP2
	RECT	rcMinSize;		// Minimum size for window (ignored in version 1)
} HH_WINTYPE, *PHH_WINTYPE;

HWND
WINAPI
HtmlHelpA(
	HWND hwndCaller,
	LPCSTR pszFile,
	UINT uCommand,
	DWORD dwData
	);

HWND
WINAPI
HtmlHelpW(
	HWND hwndCaller,
	LPCWSTR pszFile,
	UINT uCommand,
	DWORD dwData
	);
#ifdef UNICODE
#define HtmlHelp  HtmlHelpW
#else
#define HtmlHelp  HtmlHelpA
#endif // !UNICODE

// Use the following for GetProcAddress to load from hhctrl.ocx

#define ATOM_HTMLHELP_API_ANSI	  (LPTSTR)((DWORD)((WORD)(14)))
#define ATOM_HTMLHELP_API_UNICODE (LPTSTR)((DWORD)((WORD)(15)))

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __HTMLHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\enumfetc.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//

STDAPI_(LPVOID) OleStdMalloc(ULONG ulSize);
STDAPI_(void) OleStdFree(LPVOID pmem);
STDAPI_(BOOL) OleStdCopyFormatEtc(LPFORMATETC petcDest, LPFORMATETC petcSrc);
STDAPI_(DVTARGETDEVICE FAR*) OleStdCopyTargetDevice(DVTARGETDEVICE FAR* ptdSrc);
STDAPI_(LPENUMFORMATETC)
  OleStdEnumFmtEtc_Create(ULONG nCount, LPFORMATETC lpEtc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\gridlist.cxx ===
/********************************************************************
 *
 *  Module Name : gridlist.c
 *
 *  List box (one dim) and Grid (two dim) controls for
 *  parsing and viewing subsets
 *
 *  History :
 *       Sep 03, 1997  [samera]    wrote it.
 *
 *  Copyright (c) 1997-1999 Microsoft Corporation. 
 **********************************************************************/


// NOTE: This stuff should really go into a precomp header
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "UCE.h"
#include "ucefile.h"

// global stuff

// Listbox
HWND  ghwnd     = NULL;
HWND  ghwndList = NULL;

const WCHAR wszListWndClass[]=L"LISTWNDCLASS";

#define LISTBOX_WIDTH    210
#define LISTBOX_HEIGHT   210

#define DIALOG_FONT_SIZE 8
#define DIALOG_FONT_NAME L"Microsoft Sans Serif"

// Grid Window
const WCHAR wszGridWndClass[]=L"GRIDWNDCLASS";
HWND  ghwndGrid = NULL;
HFONT hFont     = NULL;
HFONT hfList    = NULL;
HFONT hfStatic  = NULL;
HPEN  hpenDash  = NULL;

PUCE_MEMORY_FILE pGridUceMemFile = NULL;          // current active UCE file

// Grid Metrics
#define PAGE_SCROLL_SIZE 3
#define GRID_XANCHOR     5
#define GRID_YANCHOR     20
#define GRID_CELL_WIDTH  22
#define GRID_CELL_HEIGHT 22
#define GRID_MAX_COL     12
#define GRID_MAX_ROW     10
#define GRID_BOTTOM_SPACE 5
#define TITLE_X           5
#define TITLE_Y           2

INT  Grid_XAnchor;

INT  gnCurRow    = -1;
INT  gnCurCol    = -1;
INT  gnRowOffset = 0;
INT  gnColOffset = 0;
INT  gnMaxRow    = 0;
INT  gnMaxCol    = 0;
BOOL gbInDrag    = FALSE;
RECT grcGridWindow;
HWND ghwndHScroll, ghwndVScroll;
PWSTR gpwszWindowTitle;
WCHAR TableName[256];

WNDPROC fnOldListBox = NULL;
LRESULT CALLBACK EscapeProc (HWND, UINT, WPARAM, LPARAM);

/******************************Public*Routine******************************\
* CreateListWindow
*
* Create a list box in a window and set its title
*
* Return Value:
*
*   handle of create list window
*
\**************************************************************************/
HWND CreateListWindow( HWND hwndParent , PWSTR pwszWindowTitle )
{
  TEXTMETRIC tm;
  HDC   hDC;
  RECT  rc;
  HWND  hwnd;
  WCHAR buffer[64];
  int   xFrame, yFrame;
   LONG xpos;
   HWND dsktop;
   RECT drc;
   DWORD dwExStyle;

  gpwszWindowTitle = pwszWindowTitle;
  if(*pwszWindowTitle == L'0')
  {
     LoadString(hInst, _wtol(pwszWindowTitle), TableName, 256);
     gpwszWindowTitle = TableName;
  }

  // Let's know where to position it exactly
  if( NULL == ghwnd )
  {
    if( !UpdateListFont( hwndParent , ID_FONT ))
    {
      return NULL;
    }

    GetWindowRect( hwndParent , &rc );
    LoadString(hInst, IDS_GROUPBY,  buffer, 64);

      //fix for group by window too right
         dsktop = GetDesktopWindow();
         GetWindowRect(dsktop, &drc);
         if (rc.right + LISTBOX_WIDTH > drc.right)
            xpos = rc.left - LISTBOX_WIDTH;
         else
            xpos = rc.right;

    // Set the mirroring ExStyle if the main window has it.
    dwExStyle = GetWindowLong(hwndParent, GWL_EXSTYLE) & WS_EX_LAYOUTRTL;
    hwnd = CreateWindowEx( dwExStyle ,
                           wszListWndClass,
                           buffer,
                           WS_CAPTION | WS_BORDER | WS_VISIBLE |
                           WS_SYSMENU | WS_EX_CLIENTEDGE,
                           xpos,
                           rc.top,
                           LISTBOX_WIDTH,
                           LISTBOX_HEIGHT,
                           hwndParent, //if not use hwndParent, main window will come to top when activated
                           NULL,
                           hInst,
                           NULL
                         );

    xFrame = GetSystemMetrics( SM_CXSIZEFRAME );
    yFrame = GetSystemMetrics( SM_CYSIZEFRAME );

    if( NULL != hwnd )
    {
      HFONT hFontOld;
      ghwnd = hwnd;

      GetClientRect( hwnd , &rc );

      hDC = GetDC(hwndParent);
      hFontOld = (HFONT)SelectObject(hDC, hfStatic);

      // Find the height of the string
      GetTextMetrics(hDC, &tm);

      SelectObject(hDC, hFontOld);
      ReleaseDC(hwndParent, hDC);

         
      // Let's create the list box
      ghwndList = CreateWindowEx( WS_EX_CLIENTEDGE,
                                  L"LISTBOX",
                                  L"",
                                  WS_CHILD | WS_VISIBLE | LBS_NOTIFY
                                  | WS_VSCROLL | WS_HSCROLL,
                                  xFrame,
                                  tm.tmHeight + yFrame,
                                  rc.right - 2*xFrame,
                                  rc.bottom - tm.tmHeight - yFrame,
                                  hwnd,
                                  (HMENU)ID_LISTBOX,
                                  hInst,
                                  NULL
                                ) ;

      fnOldListBox = (WNDPROC)SetWindowLongPtr (ghwndList, GWLP_WNDPROC,
                                              (LPARAM) EscapeProc) ;

      SendMessage( ghwndList,
                   LB_RESETCONTENT,
                   0,
                   0
                 );
      ShowWindow( hwnd , SW_NORMAL );
      SetFocus(ghwndList);
    }
  }
  else
  {
      InvalidateRect( ghwnd , NULL , FALSE );
  }

  return ghwnd;
}

/******************************Public*Routine******************************\
* EscapeProc
*
* so that Escape key can close the window
*
\**************************************************************************/
LRESULT CALLBACK EscapeProc (HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
   if (iMsg == WM_KEYDOWN)
   {
      switch(wParam)
      {
        case VK_ESCAPE:
          {
              SendMessage(ghwnd, WM_CLOSE, 0, 0L);
              return 0L;
          }
          break;

        case VK_F6:
          {

              SetFocus(hwndCharGrid);
              return 0L;
          }
          break;
      }
   }

  return CallWindowProc (fnOldListBox, hwnd, iMsg, wParam, lParam) ;
}

/******************************Public*Routine******************************\
* InitListWindow
*
* Register ListBox main window
*
* Return Value:
*
*   TRUE if successful operation, FALSE otherwise
*
\**************************************************************************/
BOOL InitListWindow( HINSTANCE hInstance )
{
  WNDCLASS  wcListWnd;

  wcListWnd.style = 0;
  wcListWnd.lpfnWndProc = ListWndProc;
  wcListWnd.cbClsExtra = 0;
  wcListWnd.cbWndExtra = 0;
  wcListWnd.hInstance = hInstance;
  wcListWnd.hIcon = NULL;
  wcListWnd.hCursor = LoadCursor(NULL, IDC_ARROW);
  wcListWnd.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
  wcListWnd.lpszMenuName =  NULL;
  wcListWnd.lpszClassName = wszListWndClass;

  return (RegisterClass(&wcListWnd));
}


/******************************Public*Routine******************************\
* ListWndProc
*
* ListBox's MainWindow Callback Proc
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
*
\**************************************************************************/
LRESULT CALLBACK ListWndProc( HWND hWnd , UINT uMsg , WPARAM wParam , LPARAM lParam )
{
  switch( uMsg )
  {
  case WM_CREATE:
    {
      SendMessage(ghwndList, LB_SETHORIZONTALEXTENT, (WPARAM)LISTBOX_WIDTH,
      (LPARAM)0L);
    }
    break;

  case WM_SETFOCUS:
    {
      SetFocus(ghwndList);
    }
    break;

  case WM_COMMAND:
    {
      switch( LOWORD(wParam) )
      {
      case ID_LISTBOX:
        {
          if( HIWORD(wParam) == LBN_SELCHANGE )
          {
            SubSetChanged( hwndDialog );
          }
        }

      default:
        return (DefWindowProc(hWnd, uMsg, wParam, lParam));
        break;
      }
    }
    break;

  case WM_PAINT:
    {
      PAINTSTRUCT  ps;
      HDC          hPaintDC;
      HFONT        hOldFont;

      BeginPaint(hWnd, &ps);
      hPaintDC = ps.hdc;
      hOldFont = (HFONT)SelectObject(hPaintDC, hfStatic);
      SetBkColor(hPaintDC, GetSysColor(COLOR_BTNFACE));
      TextOut(hPaintDC, TITLE_X, TITLE_Y, gpwszWindowTitle,
        wcslen(gpwszWindowTitle));
      SelectObject(hPaintDC, hOldFont);
      EndPaint(hWnd, &ps);
    }
    break;

  case WM_CLOSE:
    {
      WCHAR buffer[64];

      SendMessage( GetDlgItem(hwndDialog, ID_UNICODESUBSET),
                   CB_SETCURSEL,
                   (WPARAM) 0,
                   (LPARAM) 0);
      LoadString(hInst, IDS_RESET, buffer, 64);
      SetDlgItemText(hwndDialog, ID_SEARCH, buffer);
      EnableWindow(GetDlgItem(hwndDialog, ID_SEARCH), TRUE);
      SetSearched();
      SetFocus(GetDlgItem(hwndDialog, ID_SEARCH));

      DestroyWindow(hWnd);
    }
    break;

  case WM_DESTROY:
    {
      EnableWindow(GetDlgItem(hwndDialog, ID_VIEW), TRUE);
      EnableSURControls(hwndDialog);
      ghwndList = ghwnd = NULL;

      // falls thru
    }

  default:
    return (DefWindowProc(hWnd, uMsg, wParam, lParam));
  }

  return 0L;
}


/******************************Public*Routine******************************\
* FillGroupsInListBox
*
* Fill listbox with Groups of current UCE_MEMORY_FILE
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
*
\**************************************************************************/
void FillGroupsInListBox( HWND hWnd , PUCE_MEMORY_FILE pUceMemFile )
{
  PSTR        pFile   = (char*) pUceMemFile->pvData;
  PUCE_HEADER pHeader = (PUCE_HEADER)pUceMemFile->pvData;
  PUCE_GROUP  pGroup  = (PUCE_GROUP)(pFile+sizeof(UCE_HEADER));
  INT         nGroups = ((PUCE_HEADER)pFile)->NumGroup;
  INT         i;
  INT         nIndex;

  // Reset content
  if(NULL == ghwndList)
  {
    // let's create everything!
    if( !CreateListWindow( hWnd , (PWSTR) (pFile+pHeader->OffsetTableName) ))
      return ;
  }
  else
  {
    SendMessage( ghwndList,
                 LB_RESETCONTENT,
                 0,
                 0
               );
  }

  // Set the drawing font
  SendMessage( ghwndList ,
               WM_SETFONT ,
               (WPARAM)hfList,
               (LPARAM)MAKELONG(TRUE,0)
             );

  // Fill list box
  i=0;
  while( i<nGroups )
  {
    WCHAR wcBuf[256];

    PWSTR pwszGroup = (PWSTR)(pFile+pGroup->OffsetGroupName);
    if(*pwszGroup == L'0')
    {
        LoadString(hInst, _wtol(pwszGroup), wcBuf, 255);
        pwszGroup = wcBuf;
    }
    nIndex = (INT)SendMessage( ghwndList,
                               LB_ADDSTRING,
                               (WPARAM) 0,
                               (LPARAM) pwszGroup
                             );

    if (nIndex != LB_ERR)
    {
      SendMessage( ghwndList,
                   LB_SETITEMDATA,
                   (WPARAM) nIndex,
                   (LPARAM) pGroup
                 );
    }
    pGroup++;
    i++;
  }

  // Set current selection to the 1st element
  SendMessage( ghwndList,
               LB_SETCURSEL,
               (WPARAM) 0,
               (LPARAM) 0L
             );

  return;
}


/******************************Public*Routine******************************\
* GetUnicodeCharsFromList
*
* Fills a buffer with unicode chars according to current group
* of (UCE_MEMORY_FILE) selection
*
* Return Value:
*   TRUE if successful, FALSE otherwise
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
*
\**************************************************************************/
BOOL GetUnicodeCharsFromList( HWND hWnd , PUCE_MEMORY_FILE pUceMemFile , PWSTR pwBuf  , UINT *puNum , BOOL *pbLineBreak)
{
  INT         nIndex;
  PUCE_GROUP  pGroup;
  BOOL        bRet=FALSE;
  PWSTR       pwCh;
  PSTR        pFile = (char*)pUceMemFile->pvData;


  // Reset content
  if(NULL == ghwndList)
  {
    PUCE_HEADER pHeader = (PUCE_HEADER)pFile;
    // let's create everything!
    if( !CreateListWindow( hWnd , (PWSTR) (pFile+pHeader->OffsetTableName) ))
      return FALSE;
  }

  nIndex = (INT)SendMessage( ghwndList,
                             LB_GETCURSEL,
                             (WPARAM) 0,
                             (LPARAM) 0L
                           );

  if( nIndex != LB_ERR )
  {
    pGroup = (PUCE_GROUP) SendMessage( ghwndList,
                                       LB_GETITEMDATA,
                                       (WPARAM) nIndex,
                                       (LPARAM) 0L
                                       );

    // Fill in buffer

    *puNum = pGroup->NumChar;
    pwCh   = (PWSTR) (pFile+pGroup->OffsetGroupChar);

    GetWChars( *puNum , pwCh , pwBuf , puNum , pbLineBreak);

    bRet = TRUE;
  }

  return bRet;
}


/******************************Public*Routine******************************\
* DestroyListWindow
*
* Destroy the list window, if active
*
* Return Value:

* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
void DestroyListWindow( void )
{
  if( ghwnd )
  {
    DestroyWindow( ghwnd );
  }

  return;
}


/******************************Public*Routine******************************\
* DestroyAllListWindows
*
* Destroy the list & grid window, if active. This is called when exiting
* UCE
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
void DestroyAllListWindows( void )
{
  DestroyListWindow();
  DestroyGridWindow();

  return;
}


/******************************Public*Routine******************************\
* IsListWindow
*
* Checks type of grid needed (1d or 2d) according to current active
* UCE_MEMORY_FILE
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
BOOL IsListWindow( PUCE_MEMORY_FILE pUceMemFile )
{
  BOOL        bRet = FALSE;
  PUCE_HEADER pHeader = (PUCE_HEADER)(pUceMemFile->pvData);

  if( pHeader->Row )
  {
    // Grid Window
    bRet = (ghwndGrid != NULL);
  }
  else
  {
    // List Window
    bRet = (ghwnd != NULL);
  }

  return bRet;
}


/*
 *******************************************
 *       Grid Window Control               *
 *******************************************/


/******************************Public*Routine******************************\
* InitGridWindow
*
* Register class of GridWindow
*
* Return Value:
*   TRUE if successful, FALSE otherwise
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
BOOL InitGridWindow( HINSTANCE hInstance )
{
  WNDCLASS  wcGridWnd;

  wcGridWnd.style = 0;
  wcGridWnd.lpfnWndProc = GridWndProc;
  wcGridWnd.cbClsExtra = 0;
  wcGridWnd.cbWndExtra = 0;
  wcGridWnd.hInstance = hInstance;
  wcGridWnd.hIcon = NULL ;
  wcGridWnd.hCursor = LoadCursor(NULL, IDC_ARROW);
  wcGridWnd.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
  wcGridWnd.lpszMenuName =  NULL;
  wcGridWnd.lpszClassName = wszGridWndClass;

  return (RegisterClass(&wcGridWnd));
}


/******************************Public*Routine******************************\
* CreateGridWindow
*
* Create Grid window and fills it with proper values from current UCE_MEMORY_FILE
*
* Return Value:
*   handle to grid window
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
HWND CreateGridWindow( HWND hwndParent , UINT uID , PUCE_MEMORY_FILE pUceMemFile )
{
  RECT rc;
  HWND hwnd;
  WCHAR buffer[64];
   LONG xpos;
   HWND dsktop;
   RECT drc;
   DWORD dwExStyle;

  // Let's know where to position it exactly
  if( NULL == ghwndGrid )
  {
    POINT pt;
    PUCE_HEADER pHeader = (PUCE_HEADER)(pUceMemFile->pvData);

    gpwszWindowTitle = (PWSTR)((PSTR)pHeader+pHeader->OffsetTableName);
    if(*gpwszWindowTitle == L'0')
    {
        LoadString(hInst, _wtol(gpwszWindowTitle), TableName, 256);
        gpwszWindowTitle = TableName;
    }

    GetWindowRect( hwndParent , &rc );
    GetWindowGridSize( pUceMemFile , &pt , &gnColOffset , &gnRowOffset );

    pGridUceMemFile = pUceMemFile;

    // Let's create the font that is in the list
    if( !UpdateGridFont( hwndParent , ID_FONT ))
    {
      return NULL;
    }

    LoadString(hInst, IDS_GROUPBY,  buffer, 64);
      
      //fix for group by window too right
      dsktop = GetDesktopWindow();
      GetWindowRect(dsktop, &drc);
      if (rc.right + pt.x > drc.right)
         xpos = rc.left - pt.x;
      else
         xpos = rc.right;

      //rc.left+(rc.right-rc.left),
    dwExStyle = GetWindowLong(hwndParent, GWL_EXSTYLE) & WS_EX_LAYOUTRTL;
    hwnd = CreateWindowEx( dwExStyle ,
                           wszGridWndClass,
                           buffer,
                           WS_CAPTION | WS_BORDER | WS_SYSMENU | WS_EX_CLIENTEDGE,
                           xpos,
                           rc.top,
                           pt.x,
                           pt.y,
                           hwndParent,
                           NULL,
                           hInst,
                           NULL
                         );
    if( NULL != hwnd )
    {
      INT x,y;
      SCROLLINFO sinfo;

      sinfo.cbSize = sizeof(SCROLLINFO);
      ghwndGrid = hwnd;

      // let 's create the horiz scroll bar if needed
      if( gnColOffset )
      {
        // x =  GRID_XANCHOR;
        x =  Grid_XAnchor;
        y = (GRID_YANCHOR + (gnMaxRow*GRID_CELL_HEIGHT));
        ghwndHScroll = CreateWindowEx( 0,
                                       L"SCROLLBAR",
                                       L"",
                                       WS_CHILD | WS_VISIBLE | SBS_HORZ | SBS_TOPALIGN,
                                       x,
                                       y,
                                       (gnMaxCol*GRID_CELL_WIDTH),
                                       0,
                                       hwnd,
                                       (HMENU)ID_GRID_HSCROLL,
                                       hInst,
                                       NULL
                                     );

        // Let's adjust the scroll bar metrics
        sinfo.nMin = 0;
        sinfo.nMax = gnColOffset;
        sinfo.nPos = 0;
        sinfo.nPage= gnMaxCol;
        sinfo.fMask = SIF_RANGE|SIF_POS|SIF_PAGE;
        SetScrollInfo( ghwndHScroll , SB_CTL , &sinfo , TRUE );

        gnColOffset=0;
      }

      // let 's create the vert scroll bar if needed
      if( gnRowOffset )
      {
//      x = (GRID_XANCHOR + (gnMaxCol*GRID_CELL_WIDTH));
        x = (Grid_XAnchor + (gnMaxCol*GRID_CELL_WIDTH));
        y =  GRID_YANCHOR;
        ghwndVScroll = CreateWindowEx( 0,
                                       L"SCROLLBAR",
                                       L"",
                                       WS_CHILD | WS_VISIBLE | SBS_VERT | SBS_LEFTALIGN,
                                       x,
                                       y,
                                       0,
                                       (gnMaxRow*GRID_CELL_HEIGHT),
                                       hwnd,
                                       (HMENU)ID_GRID_VSCROLL,
                                       hInst,
                                       NULL
                                     );
        // Let's adjust the scroll bar metrics
        sinfo.nMin = 0;
        sinfo.nMax = gnRowOffset + gnMaxRow - 1;
        sinfo.nPos = 0;
        sinfo.nPage= gnMaxRow;
        sinfo.fMask = SIF_RANGE|SIF_POS|SIF_PAGE;
        SetScrollInfo( ghwndVScroll , SB_CTL , &sinfo , TRUE );

        gnRowOffset=0;
      }

      ShowWindow( hwnd , SW_NORMAL );
    }
  }

  return ghwndGrid;
}


/******************************Public*Routine******************************\
* GetWindowGridSize
*
* Get window size for grid, and if scroll bars are needed
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
void GetWindowGridSize( PUCE_MEMORY_FILE pUceMemFile , POINT *pPt , INT *pnXScroll , INT *pnYScroll )
{
  PUCE_HEADER pHeader = (PUCE_HEADER)pUceMemFile->pvData;
  INT    xSize=0;
  INT    ySize=0;
  SIZE   size;
  HDC    hDC;
  HFONT  hFontOld;

  // some init stuff
  gnCurRow     =0;     // default to 1st row
  gnCurCol     =0;     // default to 1st col
  gnRowOffset  =0;
  gnColOffset  =0;
  gnMaxRow     =0;
  gnMaxCol     =0;
  gbInDrag     = FALSE;
  ghwndHScroll = ghwndVScroll = NULL;
  *pnXScroll   = *pnYScroll   = 0;

  // Calculate the basic (both edges)
  xSize += (2*GRID_XANCHOR);
  ySize += GRID_YANCHOR + GRID_BOTTOM_SPACE;

  xSize += (pHeader->Column * GRID_CELL_WIDTH);
  gnMaxCol = pHeader->Column;

  // See if wee need a horz scroll bar
  /*
  if( pHeader->Column > GRID_MAX_COL )
  {
    ySize += GetSystemMetrics( SM_CYHSCROLL );
    *pnXScroll = (pHeader->Column - GRID_MAX_COL);
    xSize += (GRID_CELL_WIDTH*GRID_MAX_COL);
    gnMaxCol = GRID_MAX_COL;
#if DBG
    OutputDebugString(L"\nShould use Horrizonal Scroll Bar");
#endif
  }
  else
  {
    xSize += (pHeader->Column * GRID_CELL_WIDTH);
    gnMaxCol = pHeader->Column;
#if DBG
    OutputDebugString(L"\nNo Horrizonal Scroll Bar Needed!");
#endif
  }
*/

  // See if we need a vert scroll bar
  if( pHeader->Row > GRID_MAX_ROW )
  {
    xSize += GetSystemMetrics( SM_CXVSCROLL );
    *pnYScroll = (pHeader->Row - GRID_MAX_ROW);
    ySize += (GRID_CELL_HEIGHT*GRID_MAX_ROW);
    gnMaxRow = GRID_MAX_ROW;
#if DBG
    OutputDebugString(L"\nShould use Vertical Scroll Bar");
#endif
  }
  else
  {
    ySize += (pHeader->Row * GRID_CELL_HEIGHT);
    gnMaxRow = pHeader->Row;
#if DBG
    OutputDebugString(L"\nNo Vertical Scroll Bar Needed!!");
#endif
  }

  // Update
  xSize += (2*GetSystemMetrics( SM_CXSIZEFRAME ));
  pPt->x = xSize;

  // Compute the size of the text which is the header for this grid
  hDC = GetDC(HWND_DESKTOP);
  hFontOld = (HFONT)SelectObject(hDC, hfStatic);
  GetTextExtentPoint32(hDC, gpwszWindowTitle,
    wcslen(gpwszWindowTitle), &size);
  SelectObject(hDC, hFontOld);
  ReleaseDC(HWND_DESKTOP, hDC);

  size.cx += (2*GRID_XANCHOR) + (2*GetSystemMetrics( SM_CXSIZEFRAME ));

  if( pPt->x < size.cx )            // kchang : for long Window Title
  {
      pPt->x = size.cx;
      Grid_XAnchor = ( pPt->x - gnMaxCol*GRID_CELL_WIDTH ) / 2
                      - GRID_XANCHOR;
  }
  else
  {
      Grid_XAnchor = GRID_XANCHOR;
  }

  // some add-ons
  ySize += (2*GetSystemMetrics( SM_CYSIZEFRAME ));
  ySize += GetSystemMetrics(SM_CYCAPTION);
  pPt->y = ySize;

  // Update our grid window control rect
  // grcGridWindow.left   = GRID_XANCHOR;
  grcGridWindow.left   = Grid_XAnchor;
  grcGridWindow.top    = GRID_YANCHOR;
  grcGridWindow.right  = (grcGridWindow.left + (gnMaxCol*GRID_CELL_WIDTH));
  grcGridWindow.bottom = (grcGridWindow.top  + (gnMaxRow*GRID_CELL_HEIGHT));

  return;
}


/******************************Public*Routine******************************\
* GridWndProc
*
* Grid Callback Window Proc
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
LRESULT CALLBACK GridWndProc( HWND hWnd , UINT uMsg , WPARAM wParam , LPARAM lParam )
{
  switch( uMsg )
  {
  case WM_CREATE:
    {
    }
    break;

  case WM_CHAR:
    {
       INT   nCurRow = gnCurRow;
       INT   nCurCol = gnCurCol;
       HDC   hDC     = GetDC( hWnd );
       WCHAR wchar   = (WCHAR) wParam;
       RECT  rc;
       WCHAR wc;
       INT   nTmpRow;
       INT   nTmpCol;

       gnCurRow = gnMaxRow-1;
       gnCurCol = gnMaxCol-1;
       while(1)
       {
          if(IsCellEnabled(gnCurRow, gnCurCol))
          {
              GetCurrentGroupChar( &wc );

              if(CompareString(0,
                     NORM_IGNORECASE     | NORM_IGNOREKANATYPE |
                     NORM_IGNORENONSPACE | NORM_IGNOREWIDTH,
                     &wc, 1,
                     &wchar, 1) == 2) 
                  break; 
          }

          if(--gnCurCol < 0)
          {
              if(--gnCurRow < 0)
              {
                  gnCurRow = nCurRow;
                  gnCurCol = nCurCol;
                  ReleaseDC( hWnd , hDC );
                  return 0L;
              }
              gnCurCol = gnMaxCol-1;
          }
       }

       nTmpRow = gnCurRow;
       nTmpCol = gnCurCol;

       gnCurRow = nCurRow;
       gnCurCol = nCurCol;
       GetCurrentRect( &rc );
       GetCurrentGroupChar( &wc );
       DrawGridCell( hDC , &rc , FALSE , wc , TRUE) ;

       gnCurRow = nTmpRow;
       gnCurCol = nTmpCol;
       GetCurrentRect( &rc );
       GetCurrentGroupChar( &wc );
       DrawGridCell( hDC , &rc , TRUE , wc , TRUE);

       ReleaseDC( hWnd , hDC );
       SubSetChanged( hwndDialog );
    }
    break;

  case WM_KEYDOWN:
    {
    BOOL bForward;
    BOOL bThisLine;
    INT  nCurRow = gnCurRow;
    INT  nCurCol = gnCurCol;

    PUCE_HEADER pHeader = (PUCE_HEADER)pGridUceMemFile->pvData;

    // If hWnd is mirrored swap left and right keys.
    if (GetWindowLongPtr(hWnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) {
        if (wParam == VK_LEFT) {
            wParam = VK_RIGHT;
        } else if (wParam == VK_RIGHT) {
            wParam = VK_LEFT;
        }
    }

    switch( LOWORD(wParam) )
       {
       case VK_ESCAPE:
            SendMessage(ghwndGrid, WM_CLOSE, 0, 0L);
            return 0L;

       case VK_HOME:
            if(GetAsyncKeyState(VK_CONTROL))
            {
               if(ghwndVScroll)  GridVScroll(hWnd , uMsg , SB_TOP, 0);
                  nCurRow = 0;
            }
             nCurCol = 0;
            bForward = false;
            bThisLine = true;
            break;

       case VK_END:
            if(GetAsyncKeyState(VK_CONTROL))
            {
               if(ghwndVScroll)  GridVScroll(hWnd, uMsg, SB_BOTTOM, 0);
               nCurRow = pHeader->Row - 1;
            }
              nCurCol = gnMaxCol - 1;
            bForward = true;
            bThisLine = true;
            break;

vk_left:
       case VK_LEFT:
            if(nCurCol == 0)
            {
                 if (nCurRow > 0)
              {
                    nCurRow--;
                nCurCol = gnMaxCol-1;
                   if (ghwndVScroll) GridVScroll(hWnd , uMsg , SB_LINEUP, 0);
              }
            }
               else
                 nCurCol--;
            bForward = false;
            bThisLine = false;
          break;

       case VK_TAB:
            if(GetAsyncKeyState(VK_SHIFT)) goto vk_left;
       case VK_RIGHT:
               if (nCurCol == gnMaxCol - 1)
            {
                 if (nCurRow < pHeader->Row -1)
              {
                    nCurRow++;
                   nCurCol = 0;
                   if (ghwndVScroll) GridVScroll(hWnd , uMsg , SB_LINEDOWN, 0);
              }
            }
            else
            {
                 nCurCol++;
            }
            bForward = true;
            bThisLine = false;
            break;

       case VK_PRIOR:
            if(ghwndVScroll != NULL)
            {
               if(nCurRow < gnMaxRow)
                   nCurRow = 0;
               else
                   nCurRow = nCurRow - gnMaxRow;
               GridVScroll(hWnd , uMsg , SB_PAGEUP, 0);
            }
            else
            {
               nCurRow = 0;
            }
          bForward = false;
            bThisLine = true;
            break;

       case VK_NEXT:
            if(ghwndVScroll != NULL)
            {
               if(nCurRow >= (pHeader->Row - gnMaxRow))
                   nCurRow = pHeader->Row - 1;
               else
                   nCurRow += gnMaxRow;
               GridVScroll(hWnd , uMsg , SB_PAGEDOWN, 0);
            }
            else
            {
               nCurRow = gnMaxRow-1;
            }
         bForward = true;
            bThisLine = true;
            break;

       case VK_UP:
            if(ghwndVScroll != NULL)
            {
                GridVScroll(hWnd , uMsg , SB_LINEUP, 0);
            }
            if (nCurRow > 0) nCurRow--;
         bForward = false;
            bThisLine = true;
            break;

       case VK_DOWN:
            if(ghwndVScroll != NULL)
            {
                GridVScroll(hWnd , uMsg , SB_LINEDOWN, 0);
            }
         if (nCurRow < pHeader->Row - 1) nCurRow++;
         bForward = true;
            bThisLine = true;
            break;

       case VK_F6:
            SetFocus(hwndCharGrid);
            return 0L;
            break;

       default:
            return 0L;
       }

       if (!bForward)
       {
         while(!IsCellEnabled(nCurRow, nCurCol))
           if (nCurCol > 0)
               nCurCol--;
           else
             if (bThisLine)
             {
               ;
             }
             else
             {
                if (nCurRow > 0)
                {
                  nCurRow--;
                  nCurCol = gnMaxCol - 1;
                  if (ghwndVScroll != NULL) GridVScroll(hWnd , uMsg , SB_LINEUP, 0);
                }
             }
       }
       else
       {
         while(!IsCellEnabled(nCurRow, nCurCol))
         {
           if (nCurCol < gnMaxCol - 1)
             nCurCol++;
           else
             if (bThisLine) //went too far , has to come back
             {
               while(!IsCellEnabled(nCurRow, nCurCol))
                 nCurCol --;
             }
             else
             {
               if (nCurRow < pHeader->Row - 1)
               {
                 nCurRow++;
                 nCurCol = 0;
                 if (ghwndVScroll != NULL) GridVScroll(hWnd , uMsg , SB_LINEDOWN, 0);
               }
               else // went too far, has to come back
               {
                 while(!IsCellEnabled(nCurRow, nCurCol))
                   nCurCol --;
               }
             }
         }
       }

       {
          RECT  rc;
          WCHAR wc;
          HDC   hDC = GetDC( hWnd );

        //Erase focus frame of old cell 
          GetCurrentRect( &rc );
          GetCurrentGroupChar( &wc );
          DrawGridCell( hDC , &rc , FALSE , wc , TRUE) ;

        //draw focus frame of new cell
          gnCurRow = nCurRow;
          gnCurCol = nCurCol;
          GetCurrentRect( &rc );
          GetCurrentGroupChar( &wc );
          DrawGridCell( hDC , &rc , TRUE , wc , TRUE);

          ReleaseDC( hWnd , hDC );
        InvalidateRect( hWnd , NULL , TRUE );
          SubSetChanged( hwndDialog );
       }

    }
    break;

  case WM_COMMAND:
    {
        return (DefWindowProc(hWnd, uMsg, wParam, lParam));
    }
  break;

  case WM_PAINT:
    {
      PAINTSTRUCT ps;
      HDC         hDC;
      HFONT       hOldFont;

      hDC = BeginPaint( hWnd , &ps );

      // Actual stuff
      DoPaint( hWnd , hDC );

      hOldFont = (HFONT)SelectObject(hDC, hfStatic);
      SetBkColor(hDC, GetSysColor(COLOR_BTNFACE));
      TextOut(hDC, TITLE_X, TITLE_Y, gpwszWindowTitle,
        wcslen(gpwszWindowTitle));
      SelectObject(hDC, hOldFont);

      EndPaint( hWnd , &ps );
    }
    break;

  // scroll bar
  case WM_HSCROLL:
      GridHScroll( hWnd , uMsg , wParam , lParam );
    break;

  case WM_VSCROLL:
      GridVScroll( hWnd , uMsg , wParam , lParam );
    break;


  // Mouse events
  case WM_LBUTTONDOWN:
    {
      // Check if in our area, and if so start tracking
      POINT pt;
      pt.x = GET_X_LPARAM(lParam);
      pt.y = GET_Y_LPARAM(lParam);

      if( PtInRect( &grcGridWindow , pt ) && IsCellEnabled(  gnCurRow , gnCurCol ) )
      {
        RECT  rc;
        HDC   hDC;
        WCHAR wc;
        BOOL  bRet;
        INT   nCurRow,nCurCol;


        // Set capture & flag (need to check if this is the same cell or not
        SetCapture( hWnd );
        gbInDrag = TRUE;

        // Clear previous active
        bRet = GetCurrentRect( &rc );
        nCurRow = (((pt.y-GRID_YANCHOR)/GRID_CELL_HEIGHT)+gnRowOffset);
 //     nCurCol = (((pt.x-GRID_XANCHOR)/GRID_CELL_WIDTH)+gnColOffset);
        nCurCol = (((pt.x-Grid_XAnchor)/GRID_CELL_WIDTH)+gnColOffset);

        if( bRet && !IsCellEnabled(  nCurRow , nCurCol ) )
        {
          break;
        }

        hDC = GetDC( hWnd );
        if( bRet )
        {
          GetCurrentGroupChar( &wc );
          DrawGridCell( hDC , &rc , FALSE , wc , TRUE) ;
        }

        // Indicate active cell
        gnCurRow = nCurRow;
        gnCurCol = nCurCol;
        if( GetCurrentRect( &rc ) )
        {
          GetCurrentGroupChar( &wc );
#if DBG
          {
            WCHAR wsz[64];
            wsprintf(&wsz[0],L"CodePoint=%x\n",wc);
            OutputDebugString( wsz );
          }
#endif
          DrawGridCell( hDC , &rc , TRUE , wc , TRUE) ;
        }

        ReleaseDC( hWnd , hDC );

        // This could be expensive for a large grid
        SubSetChanged( hwndDialog );
      }
    }
    break;

  case WM_MOUSEMOVE:
    {
      POINT pt;
      pt.x = GET_X_LPARAM(lParam);
      pt.y = GET_Y_LPARAM(lParam);
      // Move the rect as we drag in
      // get new active cell, if same then don't do anything
      // otherwise clear old and draw new one
      if( gbInDrag )
      {
        if( PtInRect( &grcGridWindow , pt ) )
        {
          WCHAR wc;
          RECT  rc;
          HDC   hDC;
          INT   nCurRow,nCurCol;
          BOOL  bRet=FALSE;

          // Some optimization so we don't draw all the time
          if( GridSamePointHit( pt ) )
            break;

          // Clear previous active
          nCurRow = (((pt.y-GRID_YANCHOR)/GRID_CELL_HEIGHT)+gnRowOffset);
//        nCurCol = (((pt.x-GRID_XANCHOR)/GRID_CELL_WIDTH)+gnColOffset);
          nCurCol = (((pt.x-Grid_XAnchor)/GRID_CELL_WIDTH)+gnColOffset);

          bRet = GetCurrentRect( &rc ) ;

          if( bRet && !IsCellEnabled(  nCurRow , nCurCol ) )
            break;

          hDC = GetDC( hWnd );
          if( bRet )
          {
            GetCurrentGroupChar( &wc );
            DrawGridCell( hDC , &rc , FALSE , wc , TRUE) ;
          }

          // Indicate active cell
          gnCurRow = nCurRow;
          gnCurCol = nCurCol;
          if( GetCurrentRect( &rc ) )
          {
            GetCurrentGroupChar( &wc );
            DrawGridCell( hDC , &rc , TRUE , wc , TRUE) ;
          }

          ReleaseDC( hWnd , hDC );

          // This could be expensive for a large grid
          SubSetChanged( hwndDialog );
        }
      }
    }
    break;

  case WM_LBUTTONUP:
    {
      // Check if we are in drag mode
      if( gbInDrag )
      {
        ReleaseCapture();
        gbInDrag = FALSE;

        // no need to update current selection since I hook
        // it on WM_MOUSEMOVE
      }
    }
    break;

  case WM_CLOSE:
    {
      WCHAR buffer[64];

      SendMessage( GetDlgItem(hwndDialog, ID_UNICODESUBSET),
                   CB_SETCURSEL,
                   (WPARAM) 0,
                   (LPARAM) 0);
      LoadString(hInst, IDS_RESET, buffer, 64);
      SetDlgItemText(hwndDialog, ID_SEARCH, buffer);
      EnableWindow(GetDlgItem(hwndDialog, ID_SEARCH), TRUE);
      SetSearched();
      SetFocus(GetDlgItem(hwndDialog, ID_SEARCH));

      DestroyWindow(hWnd);
    }
    break;

  case WM_DESTROY:
    {
      EnableWindow(GetDlgItem(hwndDialog, ID_VIEW), TRUE);
      EnableSURControls(hwndDialog);
      ghwndGrid = NULL;
      // fall through
    }

  default:
    return (DefWindowProc(hWnd, uMsg, wParam, lParam));
  }

  return 0L;
}


/******************************Public*Routine******************************\
* GridHScroll
*
* Grid Callback handler for WM_HSCROLL
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
BOOL GridHScroll( HWND hWnd , UINT uMsg , WPARAM wParam , LPARAM lParam )
{
  SCROLLINFO sinfo;

  sinfo.cbSize = sizeof( SCROLLINFO );
  sinfo.fMask = SIF_PAGE|SIF_POS|SIF_RANGE;
  GetScrollInfo( ghwndHScroll , SB_CTL , &sinfo );

  switch( LOWORD( wParam ) )
  {
  case SB_TOP:
    gnColOffset=0;
    break;

  case SB_BOTTOM:
    gnColOffset=sinfo.nMax;
    break;

  case SB_LINEUP:
    if( gnColOffset )
      gnColOffset--;
    break;

  case SB_LINEDOWN:
    if( gnColOffset < sinfo.nMax )
      gnColOffset++;
    break;

  case SB_PAGEUP:
    if( gnColOffset >= PAGE_SCROLL_SIZE )
      gnColOffset -= PAGE_SCROLL_SIZE;
    else
      gnColOffset = 0;
    break;

  case SB_PAGEDOWN:
    if( (gnColOffset + PAGE_SCROLL_SIZE) <= (INT)sinfo.nMax )
      gnColOffset += PAGE_SCROLL_SIZE;
    else
      gnColOffset = sinfo.nMax;
    break;

  default:
    return FALSE;
  }

  // update position
  sinfo.nPos = gnColOffset;
  sinfo.fMask = SIF_POS;
  SetScrollInfo( ghwndHScroll , SB_CTL , &sinfo , TRUE );

  // Update the window (silent)
  InvalidateRect( hWnd , NULL , FALSE );

  return TRUE;
}


/******************************Public*Routine******************************\
* GridVScroll
*
* Grid Callback handler for WM_VSCROLL
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
BOOL GridVScroll( HWND hWnd , UINT uMsg , WPARAM wParam , LPARAM lParam )
{
  SCROLLINFO sinfo;

  sinfo.cbSize = sizeof( SCROLLINFO );
  sinfo.fMask = SIF_PAGE|SIF_POS|SIF_RANGE;
  GetScrollInfo( ghwndVScroll , SB_CTL , &sinfo );

  switch( LOWORD( wParam ) )
  {
  case SB_TOP:
     gnRowOffset = 0;
    break;

  case SB_BOTTOM:
     gnRowOffset = sinfo.nMax - gnMaxRow + 1;
    break;

  case SB_LINEUP:
    if(gnRowOffset)
      gnRowOffset--;
    break;

  case SB_LINEDOWN:
    if( gnRowOffset < sinfo.nMax - gnMaxRow + 1)
      gnRowOffset++;
    break;

  case SB_PAGEUP:
    if( gnRowOffset > gnMaxRow )
      gnRowOffset -= gnMaxRow;
    else
      gnRowOffset = 0;
    break;

  case SB_PAGEDOWN:
    if( gnRowOffset < sinfo.nMax - gnMaxRow + 1 - gnMaxRow)
      gnRowOffset += gnMaxRow;
    else
      gnRowOffset= sinfo.nMax - gnMaxRow + 1;
    break;

  case ( SB_THUMBTRACK ) :
  case ( SB_THUMBPOSITION ) :
  {
    gnRowOffset = (HIWORD(wParam));
    break;
  }

  default:
    return FALSE;
  }

  // update position
  sinfo.nPos = gnRowOffset;
  sinfo.fMask = SIF_POS;
  SetScrollInfo( ghwndVScroll , SB_CTL , &sinfo , TRUE );

  // Update the window (silent)
  InvalidateRect( hWnd , NULL , FALSE );

  return TRUE;
}


/******************************Public*Routine******************************\
* DestroyGridWindow
*
* Destroys the grid window
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
void DestroyGridWindow( void )
{
  if( ghwndGrid )
  {
    DestroyWindow( ghwndGrid );
  }

  return;
}


/******************************Public*Routine******************************\
* DoPaint
*
* Grid's WM_PAINT handler
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
void DoPaint( HWND hWnd , HDC hDC )
{
  RECT        rc;
  INT         i,j;
  PUCE_HEADER pHeader = (PUCE_HEADER)pGridUceMemFile->pvData;
  PUCE_GROUP  pGroup = (PUCE_GROUP)((PSTR)pHeader+sizeof(UCE_HEADER)),pRefGroup;
  PWSTR       pwCh;

  // Let's draw the grid first
  rc.top    = GRID_YANCHOR;
  rc.bottom = rc.top+GRID_CELL_HEIGHT;

  // set a reference group
  pRefGroup = pGroup;

  for( i=0 ; i<gnMaxRow ; i++ )
  {
//  rc.left   = GRID_XANCHOR;
    rc.left   = Grid_XAnchor;
    rc.right  = rc.left+GRID_CELL_WIDTH;

    for( j=0 ; j<gnMaxCol ; j++ )
    {
      // draw all cells
      pGroup  = pRefGroup + (((gnRowOffset+i)*pHeader->Column)+gnColOffset+j);
      pwCh    = (PWSTR)((PSTR)pGridUceMemFile->pvData+pGroup->OffsetGroupName) ;

      DrawGridCell( hDC ,
                    &rc ,
                    (((j+gnColOffset)==gnCurCol) && ((i+gnRowOffset)==gnCurRow) && (gnCurRow!=-1)) ,
                    *pwCh ,
                    IsCellEnabled((i+gnRowOffset) , (j+gnColOffset))
                  );
      rc.left  = rc.right;
      rc.right+= GRID_CELL_WIDTH;
    }

    // next row
//  rc.left   = GRID_XANCHOR;
    rc.left   = Grid_XAnchor;
    rc.right  = rc.left+GRID_CELL_WIDTH;
    rc.top    = rc.bottom;
    rc.bottom += GRID_CELL_HEIGHT;
  }

  return;
}



/******************************Public*Routine******************************\
* MyFrameRect
*
* Draw a dashed rect (replace FrameRect)
*
* Return Value:
*
* History:
*   Sept-04-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
void MyFrameRect( HDC hDC , RECT *prc )
{
  HPEN hOldPen = (HPEN)SelectObject( hDC , hpenDash );

  MoveToEx( hDC , prc->left  , prc->top , NULL ) ;
  LineTo(   hDC , prc->right , prc->top ) ;
  LineTo(   hDC , prc->right , prc->bottom );
  LineTo(   hDC , prc->left  , prc->bottom );
  LineTo(   hDC , prc->left  , prc->top );

  SelectObject( hDC , hOldPen );

  return;
}

/******************************Public*Routine******************************\
* DrawGridCell
*
* Draws a grid cell on the current hDC and *prc rect, and fills with
* the 'wc' text
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
void DrawGridCell( HDC hDC , RECT *prc , BOOL bActive , WCHAR wc , BOOL bEnabled )
{
  HFONT    hOldFont;
  COLORREF oldTextColor,oldBkColor;
  INT      iWidth = 10;
  INT      xAnchor=prc->left;


  // text
  if( bEnabled )
  {
    oldTextColor = SetTextColor( hDC , RGB(0,0,0) );
    oldBkColor   = SetBkColor( hDC , RGB(255,255,255) );
  }
  else
  {
    oldTextColor = SetTextColor( hDC , RGB(128,128,128) );
//    oldTextColor = SetTextColor( hDC , RGB(128,128,128) );
//    oldBkColor   = SetBkColor( hDC , RGB(192,192,192) );
  }

  hOldFont = (HFONT)SelectObject( hDC , hFont );

  // Check is disabled, put space
  if( (WCHAR)0 == wc )
    wc = (WCHAR)0x20;

  GetCharWidth32( hDC , wc , wc , &iWidth );
  if( (prc->right-prc->left) > (iWidth) )
    xAnchor += (((prc->right-prc->left)-(iWidth))/2);

  ExtTextOut( hDC ,
              xAnchor,
              prc->top+4,
              ETO_OPAQUE | ETO_CLIPPED | ETO_IGNORELANGUAGE ,
              prc,
              &wc,
              1,
              NULL
            );


  // restore everything
  SelectObject( hDC , hOldFont );
  SetTextColor( hDC , oldTextColor );
  if( bEnabled )
    SetBkColor( hDC , oldBkColor );


  // rect everything else
  if( !bActive )
  {
    MyFrameRect( hDC , prc );//, GetStockObject( BLACK_BRUSH ) );
  }
  else
  {
    // Draw an inside focus if needed
    RECT rc;

    DrawFocusRect( hDC , prc );
    rc.left = prc->left+1;
    rc.right = prc->right-1;
    rc.top = prc->top+1;
    rc.bottom = prc->bottom-1;
    DrawFocusRect( hDC , &rc );
    rc.left += 1;
    rc.right -= 1;
    rc.top += 1;
    rc.bottom -= 1;
    DrawFocusRect( hDC , &rc );
  }

  return ;
}


/******************************Public*Routine******************************\
* GetCurrentRect
*
* Retreives the current active rect if visible
*
* Return Value:
*  TRUE if possible, otherwise FALSE
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
__inline BOOL GetCurrentRect( RECT *prc )
{
  if( (-1 == gnCurRow) ||
      (gnCurRow < gnRowOffset) || (gnCurRow >= (gnRowOffset+gnMaxRow)) ||
      (gnCurCol < gnColOffset) || (gnCurCol >= (gnColOffset+gnMaxCol))
    )
  {
    return FALSE;
  }

//prc->left = GRID_XANCHOR+((gnCurCol-gnColOffset)*GRID_CELL_WIDTH);
  prc->left = Grid_XAnchor+((gnCurCol-gnColOffset)*GRID_CELL_WIDTH);
  prc->right = prc->left+GRID_CELL_WIDTH;
  prc->top = GRID_YANCHOR+((gnCurRow-gnRowOffset)*GRID_CELL_HEIGHT);
  prc->bottom = prc->top+GRID_CELL_HEIGHT;

  return TRUE;
}


/******************************Public*Routine******************************\
* GetCurrentGroupChar
*
* Retreives the current char (codepoint) of the currently selected group
*
* Return Value:
*  TRUE if possible, otherwise FALSE
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
__inline void GetCurrentGroupChar( PWSTR pwCh )
{
  PUCE_HEADER pHeader = (PUCE_HEADER)pGridUceMemFile->pvData;
  PUCE_GROUP  pGroup = (PUCE_GROUP)((PSTR)pHeader+sizeof(UCE_HEADER));

  pGroup += (((gnCurRow)*pHeader->Column)+gnCurCol);
  *pwCh   = *(PWSTR)((PSTR)pGridUceMemFile->pvData+pGroup->OffsetGroupName) ;

  return;
}

/******************************Public*Routine******************************\
* IsCellEnabled
*
* Retreives the current char (codepoint) of the currently selected group
*
* Return Value:
*  TRUE if possible, otherwise FALSE
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/

__inline BOOL IsCellEnabled( INT nRow , INT nCol )
{
  DWORD       dwNum=0;
  DWORD       dwChOffset=0;
  PUCE_HEADER pHeader = (PUCE_HEADER)pGridUceMemFile->pvData;
  PUCE_GROUP  pGroup = (PUCE_GROUP)((PSTR)pHeader+sizeof(UCE_HEADER));

  if(nRow >= pHeader->Row || nCol >= pHeader->Column) return FALSE;

  pGroup += (((nRow)*pHeader->Column)+nCol);
  dwChOffset   = pGroup->OffsetGroupName ;
  dwNum        = pGroup->NumChar ;

  return ((dwNum>0) && (dwChOffset!=0));
}

/******************************Public*Routine******************************\
* GridSamePointHit
*
* Checks if the point is within the lastly drawn rect. This is a good optimization
*
* Return Value:
*  TRUE if in same rect, otherwise FALSE
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
__inline BOOL GridSamePointHit( POINT pt )
{
  INT iNewRow = (((pt.y-GRID_YANCHOR)/GRID_CELL_HEIGHT)+gnRowOffset);
//INT iNewCol = (((pt.x-GRID_XANCHOR)/GRID_CELL_WIDTH)+gnColOffset);
  INT iNewCol = (((pt.x-Grid_XAnchor)/GRID_CELL_WIDTH)+gnColOffset);

  if( (-1 == gnCurRow) ||
      ((iNewRow == gnCurRow) && (iNewCol == gnCurCol))
    )
  {
    return TRUE;
  }

  return FALSE;
}


/******************************Public*Routine******************************\
* GetUnicodeCharsFromGridWindow
*
* Reads the unicode content of the current selected group of the active
* UCE_MEMORY_FILE and fills in a buffer
*
* Return Value:
*  TRUE if successful, otherwise FALSE
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
BOOL GetUnicodeCharsFromGridWindow( HWND hWnd , PWSTR pwcBuf , UINT *puNum , BOOL *pbLineBreak)
{
  PUCE_HEADER pHeader = (PUCE_HEADER)pGridUceMemFile->pvData;
  PUCE_GROUP  pGroup = (PUCE_GROUP)((PSTR)pHeader+sizeof(UCE_HEADER));
  PWSTR       pwc;

  if( -1 == gnCurRow )   // if invalid sel
    return FALSE;


  pGroup += (((gnCurRow)*pHeader->Column)+gnCurCol);
  pwc     = (PWSTR)((PSTR)pHeader+pGroup->OffsetGroupChar);
  *puNum = pGroup->NumChar;

  GetWChars( pGroup->NumChar , pwc , pwcBuf , puNum , pbLineBreak );

  return TRUE;
}


/******************************Public*Routine******************************\
* GetWChars
*
* Unified place to read wc from/tp
*
* Return Value:
*
* History:
*   Sept-18-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
void GetWChars( INT nChars, WCHAR *pwc, WCHAR *pwcBuf, UINT *puNum, BOOL *pbLineBreak)
{
  DWORD dwI=0;
  DWORD dwCurCount=0;

  *pbLineBreak=FALSE;

  while( (INT)dwI<nChars )
  {
    // We need to fill the rest of row with spaces when we hit
    // a 0x0a. This is  to hack the current implementation
    // of the main grid
    if( (WCHAR)0x0a == *pwc )
    {
      DWORD dwLeft = ((dwCurCount)%20);
      dwLeft = 20L - dwLeft;
      *puNum += dwLeft;
      dwCurCount += dwLeft;
      while( dwLeft )
      {
        *pwcBuf = (WCHAR)' ';
        pwcBuf++;
        dwLeft--;
      }

      pwc++;
      *puNum -= 1;    // the 0x0a
      dwI++;
      *pbLineBreak=TRUE;
      continue;
    }

    // let's fill real stuff
    *pwcBuf = *pwc;

    // We need to fill the rest of row with spaces till we hit
    pwcBuf++;
    pwc++;
    dwI++;

    dwCurCount++;
  }
}

/******************************Public*Routine******************************\
* IsGridWindowAlive
*
* Checks if the grid window is created
*
* Return Value:
*  TRUE if so, otherwise FALSE
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
BOOL IsGridWindowAlive( void )
{
  return (ghwndGrid != NULL) ;
}


/******************************Public*Routine******************************\
* IsAnyListWindow
*
* Checks if any grid/list window is created
*
* Return Value:
*  TRUE if so, otherwise FALSE
* History:
*   Sept-16-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
BOOL IsAnyListWindow( void )
{
  return ((ghwndGrid != NULL) || (ghwndList != NULL));
}

/******************************Public*Routine******************************\
* CreateResources
*
* Creates any global resources the would be needed during the app lifetime
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
void CreateResources( HINSTANCE hInst, HWND hWnd )
{
  HDC hDC;

  InitListWindow( hInst );
  InitGridWindow( hInst );

  hpenDash = CreatePen( PS_SOLID , 0 , RGB(128,128,128));

  hDC = GetDC(hWnd);

//  hfStatic = CreateFont( -MulDiv(DIALOG_FONT_SIZE,
//                           GetDeviceCaps(hDC, LOGPIXELSY), 72),
  hfStatic = CreateFont( GRID_CELL_HEIGHT-7,
                         0,
                         0,0,0,
                         0,0,0,0,
                         OUT_DEFAULT_PRECIS,
                         CLIP_DEFAULT_PRECIS,
                         DEFAULT_QUALITY,
                         DEFAULT_PITCH|FF_DONTCARE,
                         DIALOG_FONT_NAME
                       );

  ReleaseDC(hWnd, hDC);
}


/******************************Public*Routine******************************\
* DeleteResources
*
* Deletes any global resources that had been created through CreateResources
*
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
void DeleteResources( void )
{
  if( hFont )
    DeleteObject( hFont );

  if( hfList )
    DeleteObject( hfList );

  if( hpenDash )
    DeleteObject( hpenDash );

  if( hfStatic )
    DeleteObject( hfStatic );

  UnregisterClass( wszListWndClass , hInst );
  UnregisterClass( wszGridWndClass , hInst );
}


/******************************Public*Routine******************************\
* CreateNewGridFont
*
* Creates a new font for the grid when the selection changes
*
* Return Value:
*
* History:
*   Sept-15-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
/*
BOOL CreateNewGridFont( HWND hWnd , UINT uID )
{
  if( ghwndGrid )
  {
    UpdateGridFont( hWnd , uID );
    InvalidateRect( ghwndGrid , NULL , FALSE );
  }

  return TRUE;
}
*/


/******************************Public*Routine******************************\
* UpdateGridFont
*
* Creates a new hFont based on the current font selection
*
* Return Value:
*
* History:
*   Sept-15-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
BOOL UpdateGridFont( HWND hwndParent , UINT uID )
{
/*
  INT  nIndex;
  INT  iCharset=0;
  BOOL bRet=FALSE;

  // Let's create the font that is in the list
  nIndex = SendDlgItemMessage( hwndParent,
                               uID,
                               CB_GETCURSEL,
                               (WPARAM) 0,
                               (LPARAM) 0L
                             );
  if( CB_ERR != nIndex )
  {
    WCHAR wszFontName[64];
    SendDlgItemMessage( hwndParent,
                        uID,
                        CB_GETLBTEXT,
                        (WPARAM) nIndex,
                        (LPARAM) (LPWSTR) &wszFontName[0]
                      );

    // if we have already created one, let's delete it
    if( hFont )
      DeleteObject( hFont );

    // Let's try grab a correct charset, if possible
    iCharset = Font_GetSelFontCharSet( hwndParent , ID_FONT , nIndex );

    hFont = CreateFont( (GRID_CELL_HEIGHT-6) ,
                        0,
                        0,0,0,
                        0,0,0,iCharset,
                        OUT_DEFAULT_PRECIS,
                        CLIP_DEFAULT_PRECIS,
                        PROOF_QUALITY,
                        VARIABLE_PITCH|FF_MODERN,
                        &wszFontName[0]
                       );

    bRet = TRUE;
  }

  return bRet;
  */
  if( hFont )
    DeleteObject( hFont );

  hFont = CreateFont( (GRID_CELL_HEIGHT-6) ,
                      0,
                      0,0,0,
                      0,0,0,DEFAULT_CHARSET,
                      OUT_DEFAULT_PRECIS,
                      CLIP_DEFAULT_PRECIS,
                      PROOF_QUALITY,
                      VARIABLE_PITCH|FF_MODERN,
                      TEXT("MS Shell Dlg")
                     );

  return TRUE;
}

/******************************Public*Routine******************************\
* CreateNewListFont
*
* Creates a new font for the list when the selection changes
*
* Return Value:
*
* History:
*   Sept-15-1997  Samer Arafeh  [samera]
*    wrote it
\**************************************************************************/
/*
BOOL CreateNewListFont( HWND hWnd , UINT uID )
{
  if( ghwndGrid )
  {
    UpdateListFont( hWnd , uID );
    InvalidateRect( ghwndList , NULL , FALSE );
  }

  return TRUE;
}
*/


/******************************Public*Routine******************************\
* UpdateListFont
*
* Creates a new hFont based on the current font selection
*
* Return Value:
*
* History:
\**************************************************************************/
BOOL UpdateListFont( HWND hwndParent , UINT uID )
{
/*
  INT  nIndex;
  INT  iCharset=0;
  BOOL bRet=FALSE;

  // Let's create the font that is in the list
  nIndex = SendDlgItemMessage( hwndParent,
                               uID,
                               CB_GETCURSEL,
                               (WPARAM) 0,
                               (LPARAM) 0L
                             );
  if( CB_ERR != nIndex )
  {
    // if we have already created one, let's delete it
    if( hfList )
      DeleteObject( hfList );

    // Let's try grab a correct charset, if possible
    iCharset = Font_GetSelFontCharSet( hwndParent , ID_FONT , nIndex );

    hfList = CreateFont( GRID_CELL_HEIGHT-7,            // 12,
                        0,
                        0,0,0,
                        0,0,0,iCharset,
                        OUT_DEFAULT_PRECIS,
                        CLIP_DEFAULT_PRECIS,
                        PROOF_QUALITY,
                        VARIABLE_PITCH|FF_MODERN,
                        DIALOG_FONT_NAME
                       );

    bRet = TRUE;
  }

  return bRet;
*/
    int nHight = GRID_CELL_HEIGHT-7;

    if( hfList )
      DeleteObject( hfList );

    // If it is a BiDi localized use a one pixel biger font.
    if (GetWindowLongPtr(hwndParent, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) {
        nHight = GRID_CELL_HEIGHT-6;
    }

    hfList = CreateFont( nHight,            // 12,
                        0,
                        0,0,0,
                        0,0,0,DEFAULT_CHARSET,
                        OUT_DEFAULT_PRECIS,
                        CLIP_DEFAULT_PRECIS,
                        PROOF_QUALITY,
                        VARIABLE_PITCH|FF_MODERN,
                        DIALOG_FONT_NAME
                       );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\oleedit.h ===
//**********************************************************************
// File name: oleedit.h
//
// Header file for extensions required to enable drag and drop with edit
// controls
//
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//**********************************************************************

#ifndef OLEEDIT_H
#define OLEEDIT_H

BOOL SetEditProc(HWND hWndEdit);
LRESULT CALLBACK OleEnabledEditControlProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
BOOL PointInSel(HWND hWnd, POINT ptDragStart);
int EditCtrlDragAndDrop(HWND hWndDlg, HWND hWndEdit, LPDROPSOURCE pDropSource);
int XToCP(HWND hWnd, LPTSTR lpszText, POINT ptDragStart);

#endif // OLEEDIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\resource.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by uce.rc
//
#define IDD_FONTCHANGEMSG               102
#define IDC_EDIT                        1000
#define IDC_CHECKNOMSG                  1001
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\olecomon.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//

#ifndef OLECOMON_H
#define OLECOMON_H

typedef LPVOID* PPVOID;
int DoDragAndDrop(HWND hWnd, LPDROPSOURCE pDropSource);

#ifdef _DEBUG
#define TRACE    OutputDebugString

#else // _DEBUG

#define TRACE    NOP_FUNCTION

#endif // _DEBUG

#endif // OLECOMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\kd.cxx ===
/****************************************************************************

    kd.c

    PURPOSE: codepage related utilities for UCE

    Copyright (c) 1997-1999 Microsoft Corporation.
****************************************************************************/

#include "windows.h"
#include "commctrl.h"

#include "UCE.h"
#include "stdlib.h"
#include "tchar.h"
#include "stdio.h"
#include "winuser.h"
#include "string.h"
#include "search.h"

#include "winnls.h"
#include "wingdi.h"

#define  NOT_EUDC(wc)  ((wc)<0xE000||(wc)>0xF8FF)

///////////////////////////////////////////////////////////////
//
// For a give codePage,
//   fills in array of defined Unicode chars
//
//  Parameter : CodePage : 0 for Unicode
//                       : any valid codepage
//
//              lpWC     : WCHAR pointer to hold the result
//                       : set to NULL to get array size
//
//  Returns : 0 for a invalid codepage
//            number of WChar for a valid codepage
//
////////////////////////////////////////////////////////////////
long
WCharCP(
   UINT CodePage,
   WCHAR *lpWC)
{
  long   lRet = 0;
  CPINFO cpinfo;
  BYTE   mb[2];
  WCHAR  wc;
  WORD   ctype;

  if(CodePage == UNICODE_CODEPAGE)                  // cp-1200
  {
    for(wc = ASCII_BEG; wc < 0xFFFF; wc++)
    {
      if(NOT_EUDC(wc))                              // always include EUDC
      {
        GetStringTypeW(CT_CTYPE1, &wc, 1, &ctype);
        if((!ctype))  continue;
      }

      if(lpWC != NULL) lpWC[lRet] = wc;
      lRet++;
    }
    return lRet;
  }

  if(!IsValidCodePage(CodePage))    return 0L;
  if(!GetCPInfo(CodePage, &cpinfo)) return 0L;

  // ASCii : 0x21 ~ 0x7F
  for(mb[0] = ASCII_BEG; mb[0] <= ASCII_END; mb[0]++)
  {
    if(MultiByteToWideChar(
            CodePage,
            MB_ERR_INVALID_CHARS,
            (const char *)mb, 1,
            &wc, 1) == 0)
        continue;

    GetStringTypeW(CT_CTYPE1, &wc, 1, &ctype);
    if(ctype & C1_CNTRL)
        continue;

    if(lpWC != NULL)
        lpWC[lRet] = wc;

    lRet++;
  }

// Single-Byte codepage only; Extended chars 0x80 ~ 0xFF

  for(mb[0] = HIANSI_BEG; mb[0] > 0; (mb[0])++)
  {
    if(MultiByteToWideChar(
                  CodePage,
                  MB_ERR_INVALID_CHARS,
                  (const char *)mb, 1,
                  &wc, 1) == 0)
          continue;

    GetStringTypeW(CT_CTYPE1, &wc, 1, &ctype);
    if((!ctype) ||
       ( ctype & C1_CNTRL))
       continue;

    if(lpWC != NULL)
        lpWC[lRet] = wc;

    lRet++;
  }

  if(cpinfo.MaxCharSize == 1)
      return lRet++;

  // DBCS only
  for(mb[0] = HIANSI_BEG; mb[0] < HIANSI_END; (mb[0])++)
  {
    if(!IsDBCSLeadByteEx(CodePage, mb[0]))
        continue;

    for(mb[1] = TRAILBYTE_BEG; mb[1] <= TRAILBYTE_END; (mb[1])++)
    {
      if(mb[1] == DELETE_CHAR)               // 0x7F is not a trail byte
          continue;

      if(MultiByteToWideChar(
                    CodePage,
                    MB_ERR_INVALID_CHARS,
                    (const char *)mb, 2,
                    &wc, 1) == 0)
            continue;

      if(NOT_EUDC(wc))                       // always include EUDC
      {
        GetStringTypeW(CT_CTYPE1, &wc, 1, &ctype);
        if((!ctype) ||
           ( ctype & C1_CNTRL))
           continue;
      }

      if(lpWC != NULL)
          lpWC[lRet] = wc;

      lRet++;
    }
  }

  return lRet;
}

///////////////////////////////////////////////////////////
//
//  find defined glyphs from an EUDC TTF font (*.tte)
//
///////////////////////////////////////////////////////////

#define W_REVERSE(w)    ((w>>8)+(w<<8))
#define DW_REVERSE(dw)  ((dw>>24)+(dw<<24)+((dw&0x00FF0000)>>8)+((dw&0x0000FF00)<<8))

typedef struct
{
    char    cTag[4];        // ttcf
    DWORD   dwVersion;
    DWORD   dwDirCount;
    DWORD   dwOffset1;

} TTCHead;

typedef struct
{
    DWORD   dwVersion;
    WORD    wNumTables;
    WORD    wSearchRange;
    WORD    wEntrySelector;
    WORD    wRangeShift;

} Header;

typedef struct
{
    char    cTag[4];
    DWORD   dwCheckSum;
    DWORD   dwOffset;
    DWORD   dwLength;

} TableDir;

typedef struct
{
    DWORD   dwVersion;
    WORD    wNumGlyphs;

} maxp;

typedef struct
{
    DWORD   dwVersion;          // 00000001 (00 01 00 00)
    BYTE    Filler[46];
    WORD    IndexToLocFormat;   // 0 for short offset, 1 for long

} head;

typedef struct
{
    WORD    wVersion;           // 0
    WORD    wNumTables;

} cmapHead;

typedef struct
{
    WORD    wPlatform;           // 3 for Microsoft
    WORD    wEncoding;           // 1 for Unicode, 0 for Symbol
    DWORD   dwOffset;

} cmap;

typedef struct
{
    WORD    wFormat;             // 4
    WORD    wLength;
    WORD    wVersion;
    WORD    wSegCountX2;
    WORD    wSeachRange;
    WORD    wEntrySelector;
    WORD    wRangeShift;

} Format4;

typedef struct
{
    WORD    wBeg;
    WORD    wEnd;
    WORD    wDelta;

} URDelta;

//////////////////////////////////////////////////////////////////////////
//
//  Simulate cmap ranges for a EUDC TTTF font file (*.tte)
//
//      Path   : file name with path
//      pSize  : number of Unicode ranges returned
//
//      return : pointer to an array of Unicode ranges
//
//////////////////////////////////////////////////////////////////////////

URANGE* EUDC_Range(TCHAR* Path, DWORD* pSize)
{
    HANDLE   hTTF, hTTFMap;
    DWORD    dwFileSize;
    LPVOID   lpvTTF;
    BYTE    *lp;
    WORD     i;

    WORD     LocFormat;
    BYTE    *pLoca;
    DWORD    dwAdjustTTC;

    WORD     NumTables = 0;
    WORD     NumGlyphs = 0;
    WORD     NumURange = 0;
    URDelta *pURDelta  = 0;
    URANGE  *pUR = 0;

    *pSize = 0;

	hTTF = CreateFile(Path,
                      GENERIC_READ,
                      0,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_READONLY,
                      NULL);
	if(hTTF == INVALID_HANDLE_VALUE)
	{
		return pUR;
	}
	
	dwFileSize = GetFileSize(hTTF, NULL);
	hTTFMap = CreateFileMapping(hTTF,
                                NULL,
                                PAGE_READONLY,
                                0,
                                dwFileSize,
                                NULL);
	if(hTTFMap == NULL)
	{
		CloseHandle(hTTF);
		return pUR;
	}

	lpvTTF = MapViewOfFile(hTTFMap, FILE_MAP_READ, 0, 0, 0);
	if(lpvTTF == NULL)
	{
		CloseHandle(hTTFMap);
		CloseHandle(hTTF);
		return pUR;
	}

    lp = (BYTE*) lpvTTF;
    dwAdjustTTC = 0;
	if(lp[0] == 't' && lp[1] == 't' && lp[2] == 'c' && lp[3] == 'f')
    {
        TTCHead* ptr = (TTCHead*) lpvTTF;
        dwAdjustTTC = DW_REVERSE(ptr->dwOffset1);
    }

    lpvTTF = (BYTE*) lpvTTF + dwAdjustTTC;
    NumTables = W_REVERSE(((Header*)lpvTTF)->wNumTables);
    if(NumTables == 0) goto NextTTF;

    lp = (BYTE*) lpvTTF + sizeof(Header);
	for(i = 0; i < NumTables; i++)
	{
        TableDir* pTD = (TableDir*) lp;

		if( lp[0] == 'm' && lp[1] == 'a' &&
			lp[2] == 'x' && lp[3] == 'p')
        {
            maxp*   pmaxp = (maxp*) ((BYTE*) lpvTTF + DW_REVERSE(pTD->dwOffset));

            NumGlyphs = W_REVERSE(pmaxp->wNumGlyphs);
        }
		else if( lp[0] == 'h' && lp[1] == 'e' &&
			     lp[2] == 'a' && lp[3] == 'd')
        {
            head*   phead = (head*) ((BYTE*) lpvTTF + DW_REVERSE(pTD->dwOffset));

            LocFormat = W_REVERSE(phead->IndexToLocFormat);
        }
		else if( lp[0] == 'l' && lp[1] == 'o' &&
			     lp[2] == 'c' && lp[3] == 'a')
        {
            pLoca = (BYTE*) lpvTTF + DW_REVERSE(pTD->dwOffset);
        }
		else if( lp[0] == 'c' && lp[1] == 'm' &&
			     lp[2] == 'a' && lp[3] == 'p')
        {
            cmapHead *pCH;
            cmap     *pCmap;
            Format4  *pF4;
            BYTE     *pByte;
            WORD      wNum;
            // int       i;

            pCH   = (cmapHead*) ((BYTE*)lpvTTF + DW_REVERSE(pTD->dwOffset));
            wNum  = W_REVERSE(pCH->wNumTables);
            pCmap = (cmap*) ((BYTE*)pCH + sizeof(cmapHead));
            for(i = 0; i < wNum; i++)
            {
                WORD Platform = W_REVERSE(pCmap->wPlatform);
                WORD Encoding = W_REVERSE(pCmap->wEncoding);
                if( Platform == 3 && (Encoding == 1 || Encoding == 0 ))
                {
                    WORD Format;

                    pF4 = (Format4*) ((BYTE*)pCH + DW_REVERSE(pCmap->dwOffset));
                    Format = W_REVERSE(pF4->wFormat);
                    if(Format == 4)
                    {
                        int   k;
                        WORD  w;

                        NumURange = (W_REVERSE(pF4->wSegCountX2) >> 1) - 1;
                        pURDelta   = (URDelta*) malloc(sizeof(URDelta)*NumURange);
                        if(!pURDelta) goto NextTTF;
                        pByte = (BYTE*) pF4 + sizeof(Format4);
                        for(k = 0; k < NumURange; k++)
                        {
                            w = *(WORD*)(pByte + sizeof(WORD)*k);
                            pURDelta[k].wEnd   = W_REVERSE(w);
                            w = *(WORD*)(pByte + sizeof(WORD)*(NumURange+1)   + 2 + sizeof(WORD)*k);
                            pURDelta[k].wBeg   = W_REVERSE(w);
                            w = *(WORD*)(pByte + sizeof(WORD)*(NumURange+1)*2 + 2 + sizeof(WORD)*k);
                            pURDelta[k].wDelta = W_REVERSE(w);
                        }
                    }

                    break;
                }
                pCmap ++;
            }
        }

        lp += sizeof(TableDir);
	}

    if(NumGlyphs == 0) goto NextTTF;
    if(pLoca     == 0) goto NextTTF;
    if(NumURange == 0) goto NextTTF;
    if(pURDelta  == 0) goto NextTTF;

    {
        WORD  wLen = 4;
        WORD  wc;
        WORD  wGIdx;
        BOOL  HasGlyph;

        if(LocFormat == 0) wLen = 2;

        for(i = 0; i < NumURange; i++)
        {
            for(wc = pURDelta[i].wBeg; wc <= pURDelta[i].wEnd; wc++)
            {
                HasGlyph = FALSE;
                wGIdx = wc + pURDelta[i].wDelta;
                if(wGIdx > NumGlyphs)
                {
                    if(pUR) free(pUR);
                    pUR = 0;
                    goto NextTTF;
                }

                if(LocFormat == 0)
                {
                    if(*(WORD*)(pLoca + wLen * wGIdx) != *(WORD*)(pLoca + wLen * (wGIdx + 1)))
                        HasGlyph = TRUE;
                }
                else
                {
                    if(*(DWORD*)(pLoca + wLen * wGIdx) != *(DWORD*)(pLoca + wLen * (wGIdx + 1)))
                        HasGlyph = TRUE;
                }

                if(HasGlyph)
                {
                    if(pUR == 0)
                    {
                        (*pSize)++;
                        pUR = (URANGE *) malloc (sizeof(URANGE));
                        if(pUR == 0) goto NextTTF;
                        pUR[0].wcFrom = wc;
                        pUR[0].wcTo   = wc;
                    }
                    else
                    {
                        if(wc - pUR[(*pSize)-1].wcTo == 1)
                        {
                            (pUR[(*pSize)-1].wcTo)++;
                        }
                        else
                        {
                            URANGE  *temp = NULL;
                            
                            (*pSize)++;
                            temp = (URANGE *) realloc ((void*)pUR, sizeof(URANGE)*(*pSize));
                            if(temp == NULL) 
                            {
                                goto NextTTF;  // Keep the previously allocated buffer
                            }
                            pUR = temp;  // replace the buffer with the newly allocated one.

                            pUR[(*pSize)-1].wcFrom = wc;
                            pUR[(*pSize)-1].wcTo   = wc;

                        }
                    }
                }           // if(HasGlyph)
            }               // for each Unicode range
        }                   // for all Unicode ranges.
    }

NextTTF:

//	UnMapViewOfFile(lpvTTF);
	CloseHandle(hTTFMap);
	CloseHandle(hTTF);
    if(pURDelta) free(pURDelta);
    return pUR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\subset.cxx ===
/****************************************************************************

    Subset.c

    PURPOSE: Subset related utilities for UCE

    Copyright (c) 1997-1999 Microsoft Corporation.
****************************************************************************/

#include "windows.h"
#include "commctrl.h"

#include "UCE.h"
#include "stdlib.h"
#include "tchar.h"
#include "stdio.h"
#include "winuser.h"
#include "string.h"
#include "search.h"

#include "winnls.h"
#include "wingdi.h"

#include "ucefile.h"

extern DWORD gFontType;

//
// Char buffer
//
WCHAR wcUnicodeBuffer[M64K];

/****************************************************************************

    Fill Subsets from UCE files

****************************************************************************/
BOOL
Subset_FillComboBox(
   HWND hWnd,
   UINT uID        )
{
  INT              i=0;
  INT              nIndex;
  PUCE_MEMORY_FILE pUceMemFile;
  INT              cFiles;
  PWSTR            pwszSubsetName;
  WCHAR            wszID[LF_SUBSETSIZE];              // I know it is "ALL"
  HWND             hCombo = (HWND) GetDlgItem(hWnd,uID);

  if(NULL == hCombo)
  {
    return FALSE;
  }

  SendMessage( hCombo,
               CB_RESETCONTENT,
               0,
               0
             );

  // Let's add the All subset (hardcoded)
  if( LoadString( hInst , IDS_ALL , wszID , LF_SUBSETSIZE ) &&
  	 wszID[0] )
  {
    nIndex = (INT)SendMessage( hCombo,
                               CB_ADDSTRING,
                               (WPARAM) 0,
                               (LPARAM)(PCWSTR) &wszID[0]
                             );

    if (nIndex != CB_ERR)
    {
      SendMessage( hCombo,
                   CB_SETITEMDATA,
                   (WPARAM) nIndex,
                   (LPARAM) 0
                 );
    }

    // set the current selection here
    SendMessage( hCombo,
                 CB_SETCURSEL,
                 (WPARAM) nIndex,
                 (LPARAM) 0
               );

  }


  cFiles = UCE_GetFiles( &pUceMemFile );

  while( i<cFiles )
  {
    WORD cp;
    BOOL IsCpOnList;

    // make sure required codepage is on our list

    cp = UCE_GetCodepage( &pUceMemFile[i] );
    if(cp == UNICODE_CODEPAGE)
    {
        IsCpOnList = TRUE;
    }
    else
    {
        IsCpOnList = IsCodePageOnList(cp);
    }

    if( IsCpOnList )
    {
      WCHAR wcBuf[256];

      UCE_GetTableName( &pUceMemFile[i] , &pwszSubsetName );
      if(*pwszSubsetName == L'0')
      {
          LoadString(hInst, _wtol(pwszSubsetName), wcBuf, 255);
          pwszSubsetName = wcBuf;
      }
      nIndex = (INT)SendMessage( hCombo,
                                 CB_ADDSTRING,
                                 (WPARAM) 0,
                                 (LPARAM) pwszSubsetName
                                );

      if (nIndex != CB_ERR)
      {
        SendMessage( hCombo,
                     CB_SETITEMDATA,
                     (WPARAM) nIndex,
                     (LPARAM)(PUCE_MEMORY_FILE) &pUceMemFile[i]
                   );
      }
    }

    i++;
  }

  return TRUE;

}

/****************************************************************************

    Read the current UCE pointer

****************************************************************************/
BOOL
GetCurrentUCEFile(
    PUCE_MEMORY_FILE *ppUceMemFile,
    HWND   hWnd,
    UINT   uID   )
{
  INT  nIndex;
  BOOL bRet = FALSE;

  nIndex = (INT)SendDlgItemMessage( hWnd,
                                    uID,
                                    CB_GETCURSEL,
                                    (WPARAM) 0,
                                    (LPARAM) 0L
                                  );

  if( nIndex != CB_ERR )
  {
    *ppUceMemFile = (PUCE_MEMORY_FILE) SendDlgItemMessage( hWnd,
                                                           uID,
                                                           CB_GETITEMDATA,
                                                           (WPARAM) nIndex,
                                                           (LPARAM) 0L
                                                         );
    bRet = TRUE;
  }

  return bRet;
}

/****************************************************************************

    Get a Unicode buffer for the current view/subset when subset is all

    Called to retreive what to display

****************************************************************************/
BOOL
Subset_GetUnicodeCharsToDisplay(
HWND   hWnd,
UINT   uID,
LONG   lCodePage,
PWSTR *ppCodeList,
UINT  *puNum,
BOOL  *pbLineBreak)
{
  PUCE_MEMORY_FILE pUceMemFile= NULL;
  HWND             hCombo     = (HWND) GetDlgItem(hWnd,uID);

  if(NULL == hCombo)
  {
    return FALSE;
  }

  // Get the Unicode of the current code page
  if( !GetCurrentUCEFile( &pUceMemFile , hWnd ,uID ) || (NULL == pUceMemFile) )
  {
    return GetUnicodeBufferOfCodePage( lCodePage , ppCodeList , puNum );
  }
  else
  {
    if( pUceMemFile )
    {
      // Let's retreive the Unicode subset from the list
      // and throw it back to the display

      if( !Subset_GetUnicode(    // if fail, then select as if All is selected
                    hWnd,
                    pUceMemFile,
                    ppCodeList,
                    puNum,
                    pbLineBreak ))
        return GetUnicodeBufferOfCodePage( lCodePage , ppCodeList , puNum );
    }
  }

  return TRUE;
}

/****************************************************************************

  Convert a codepage to unicode buffer

****************************************************************************/
BOOL
GetUnicodeBufferOfCodePage(
        LONG   lCodePage,
        PWSTR *ppwBuf,
        UINT  *puNum )
{
  *puNum  = WCharCP( lCodePage, wcUnicodeBuffer);
  *ppwBuf = wcUnicodeBuffer ;

  return (*puNum);
}

/****************************************************************************

   Decide whether to retreive unicode from 1-d or 2-d current selection

****************************************************************************/
BOOL
Subset_GetUnicode(
        HWND hWnd,
        PUCE_MEMORY_FILE pUceMemFile,
        PWSTR *ppwBuf,
        UINT *puNum,
        BOOL *pbLineBreak )
{
  BOOL bRet = FALSE;

  switch( ((PUCE_HEADER)(pUceMemFile->pvData))->Row )
  {
  case 0:           // 1-d array
    {
      // should delete grid window if any

      bRet = GetUnicodeCharsFromList(
                                     hWnd,
                                     pUceMemFile,
                                     &wcUnicodeBuffer[0],
                                     puNum,
                                     pbLineBreak
                                    );
    }
    break;

  default:          // 2-d array
    {
      // should delete list window, if any
      bRet = GetUnicodeCharsFromGridWindow(
                                           hWnd,
                                           &wcUnicodeBuffer[0],
                                           puNum,
                                           pbLineBreak
                                          );                 // till now
    }
    break;

  }

  // Update user buffer
  *ppwBuf = &wcUnicodeBuffer[0];

  return bRet;
}


/****************************************************************************

    When user selchange a subset, let's call our guys (if really changed)
    to bring up a new list (if required)
    must call SubSetChanged(...) after this

****************************************************************************/
BOOL
Subset_OnSelChange(
    HWND hWnd,
    UINT uID )
{
  static PUCE_MEMORY_FILE pLastUceMemFile = NULL;
  PUCE_MEMORY_FILE        pCurUceMemFile;
  PSTR                    pFile;
  PUCE_HEADER             pHeader;

  DWORD                   dw;
  WCHAR                  *pWC;

  // Let's know if it changed really
  if( !GetCurrentUCEFile( &pCurUceMemFile , hWnd , uID ) ||
      (NULL == pCurUceMemFile)
    )
  {
    pLastUceMemFile = pCurUceMemFile;
    DestroyAllListWindows();
    return FALSE;
  }

  // Need to check also if the window list is available
  if( (pLastUceMemFile == pCurUceMemFile) && IsListWindow( pCurUceMemFile ) )
    return FALSE;

  // If so, let's update our list view or grid
  pFile = (PSTR) pCurUceMemFile->pvData;
  pHeader  = (PUCE_HEADER) pCurUceMemFile->pvData;
  pLastUceMemFile = pCurUceMemFile;

  dw  = *(((DWORD*)pCurUceMemFile->pvData)+1);
  pWC = (WCHAR*)(((BYTE*)pCurUceMemFile->pvData)+dw);
  if(lstrcmp(pWC, L"010200") == 0)                             // Ideograf.UCE
  {
     UINT CharSet;

     if(!(gFontType & DBCS_FONTTYPE) &&
        (CharSet = Font_DBCS_CharSet()) != 0)
     {
         Font_SelectByCharSet(hWnd, ID_FONT, CharSet);
     }
  }
  else
  {
      CHARSETINFO csi;
      CPINFO      cpinfo;

      // Indicate change of view to a new font
      GetCPInfo(pHeader->Codepage, &cpinfo);
      if(cpinfo.MaxCharSize > 1 &&
         TranslateCharsetInfo((DWORD*)pHeader->Codepage, &csi, TCI_SRCCODEPAGE))
      {
          Font_SelectByCharSet(hWnd,ID_FONT, csi.ciCharset);
      }
  }

  // Let's fetch the most appropriate code page
  if( CodePage_SetCurrent( pHeader->Codepage , hWnd , ID_VIEW ) )
  {
      PostMessage( hWnd ,
                   WM_COMMAND,
                   MAKELONG(ID_VIEW,CBN_SELCHANGE),
                   0L );
  }

  switch( pHeader->Row )
  {
  case 0:
    // Destroy grid if needed
    DestroyGridWindow();
    CreateListWindow( hWnd , (PWSTR)(pFile+pHeader->OffsetTableName) ) ;
    FillGroupsInListBox( hWnd , pCurUceMemFile );
    break;

  default:
    DestroyListWindow();
    DestroyGridWindow();
    CreateGridWindow( hWnd , ID_FONT , pCurUceMemFile );
    // create grid if needed
    break;
  }

  EnableWindow(GetDlgItem(hwndDialog, ID_VIEW), FALSE);

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\uce.cxx ===
/*******************************************************************************

Module Name:

    UCE.c

Abstract:

    This module contains the main routines for the Universal Character Explorer,
    an new interface for selecting special characters.


    Copyright (c) 1997-1999 Microsoft Corporation.
********************************************************************************/

//
//  Include Files.
//

#define WIN31
#include "windows.h"
#include <stdio.h>
#include "ole2.h"
#include <richedit.h>
#include <port1632.h>


#include "stdlib.h"
#include "tchar.h"

#include <strsafe.h>

#include "commctrl.h"
#include "htmlhelp.h"

#include <uceshare.h>
#include "winnls.h"
#include "olecomon.h"
#include "cdropsrc.h"
#include "cdataobj.h"
#include "UCE.h"
#include "ucefile.h"
//#include "oleedit.h"
#include "helpids.h"
#include "resource.h"

//
//  Macros.
//

#define FMagData(psycm)      ((psycm)->xpMagCurr != 0)
#define abs(x)               (((x) >= 0) ? (x) : (-(x)))

//
//  Constant Declarations.
//

#define STATUSPOINTSIZE      9              // point size of status bar font
#define FE_STATUSPOINTSIZE   10             // FE point size of status bar font
#define DX_BITMAP            20             // width of TT bitmap
#define DY_BITMAP            12             // height of TT bitmap

#define SEARCH_WORD_MAX      8
#define SEARCH_WORD_LEN      32

#define BACKGROUND           0x000000FF     // bright blue
#define BACKGROUNDSEL        0x00FF00FF     // bright purple

TCHAR ChmHelpPath[] = TEXT("charmap.chm");

//
//  Timer IDs
//
#define ID_SCROLLTIMER      8
#define ID_DRAGTIMER        1

// defines for hex edit control
#define ZERO        0x0030
#define MAX_CHARS   4

//
//  Debug Print Code.
//

#if 0
  TCHAR szDOUT[3] = TEXT("A\n");
  TCHAR szDbgBuf[256];
  #define DOUTL(p)     OutputDebugString(TEXT(p))
  #define DOUTCHN(ch)  if(0){}else {szDOUT[0] = ch; OutputDebugString(szDOUT);}
  #define DPRINT(p)    if(0){}else {wsprintf p; OutputDebugString(szDbgBuf);}
#else
  #define DOUTL(p)
  #define DOUTCHN(ch)
  #define DPRINT(p)
#endif

//
//  Global Variables.
//

HINSTANCE hInst;
HINSTANCE ghRichEditLib=NULL; // Module handle for rich edit library

INT    cchSymRow    = 20;     // number of characters across the character grid
INT    cchSymCol    = 10;     // number of rows in the character grid
UTCHAR chSymFirst   = 0;
UTCHAR chSymLast    = 200;
UTCHAR chRangeFirst = 0;
UTCHAR chRangeLast  = 200;
INT    chPos;
INT    chCurrPos;
BOOL   fSearched    = FALSE;
BOOL   fNeedReset   = FALSE;

SYCM   sycm;                       // tons of data need to do char grid painting
WORD   wCFRichText = 0;            // private clipboard format, rich text format
HFONT  hFontClipboard = NULL;      // tells us which font is in the clipboard
HANDLE hstrClipboard = NULL;       // contains the string which is in the clipboard
BOOL   fDelClipboardFont = FALSE;  // the clipboard font needs to be deleted

HBITMAP hbmFont = NULL;            // TT bitmap drawn before font facenames in combo

LONG   lEditSel = 0;               // contains the selection range of the EC
HBRUSH hStaticBrush;               // used for static controls during WM_CTLCOLOR
BOOL   fDisplayAdvControls = TRUE; // flag which decides whether advanced
                                   // are to be displayed
DWORD  gwExpandedHeight,           // dialog height in expanded state
       gwNormalHeight;             // dialog height when advanced controls are
                                   // hidden
BOOL   fScrolled;
WPARAM prevKeys;                   // Used in drag scrolling
LPARAM ptPrevMouse;                // Used in drag scrolling

BOOL   fSURChanged=FALSE;          // used to automatically change unicode
                                   // range when MAX_CHARS chars are typed
BOOL   fSURNeedsReset=FALSE;       // Unicode start pt has changed and reset
                                   // is needed

DWORD  gFontType;                  // for the current selected font
UINT   gKBD_CP = 0;                // codepage associated with the active keyboard
BOOL   gDisplayFontChgMsg = true;

//
//  Variables required for Drag and Drop
//
BOOL   fPendingDrag = FALSE;        // is a drag and drop operation pending
int    nDragDelay = 0;              // delay after LBUTTONDOWN after which
                                    // drag and drop starts
int    nDragMinDist = 0;            // minimum distance by which cursor has to
                                    // move before drag and drop is considered
int    nScrollInterval = 0;         // Scroll interval
int    iFromPrev=0x21, iToPrev=0xFFFD;

//
//  Useful window handles.
//
HWND hwndDialog;
HWND hwndCharGrid;
HWND hwndTT;

//
//  Data used to draw the status bar.
//
RECT rcStatusLine;                // bounding rect for status bar
INT  dyStatus;                    // height of status bar

INT   dxHelpField;                // width of help window
TCHAR szKeystrokeText[MAX_PATH];  // buffer for keystroke text
TCHAR szAlt[MAX_PATH];            // buffer for Alt+
HFONT hfontStatus;                // font used for text of status bar

TCHAR szTipText[MAX_PATH];        // Tip text


static const DWORD aHelpIDs[] = {
    ID_FONT,            IDH_UCE_FONT,
    ID_FONTLB,          IDH_UCE_FONT,
    ID_HELP,            IDH_UCE_HELPBUTTON,
    ID_CHARGRID,        IDH_UCE_GRIDCHAR,
    ID_TOPLEFT,         IDH_UCE_COPYCHAR,
    ID_STRING,          IDH_UCE_COPYCHAR,
    ID_SELECT,          IDH_UCE_SELECT,
    ID_COPY,            IDH_UCE_COPY,
    ID_ADVANCED,        IDH_UCE_ADVANCED,
    ID_VIEWLB,          IDH_UCE_CHARSET,
    ID_VIEW,            IDH_UCE_CHARSET,
    ID_URANGE,          IDH_UCE_GOTOUNICODE,
    ID_FROM,            IDH_UCE_GOTOUNICODE,
    ID_SUBSETLB,        IDH_UCE_SEARCHBYGROUP,
    ID_UNICODESUBSET,   IDH_UCE_SEARCHBYGROUP,
    ID_SEARCHNAME,      IDH_UCE_SEARCHBYNAME,
    ID_SEARCHINPUT,     IDH_UCE_SEARCHBYNAME,
    ID_SEARCH,          IDH_UCE_SEARCHRESET,
0,  0
};



static ValidateData validData[] = {
    ID_FROM, 0x0021, 0xFFFD, 0x0021, 4,
    ID_TO,   0x0021, 0xFFFD, 0xFFFD, 4
};



//
// as a display buffer
//
LPWSTR pCode=NULL;

////////////////////////////////////////////////////////////////////////////
//
//  WinMain
//
//  Calls initialization function, processes message loop, cleanup.
//
////////////////////////////////////////////////////////////////////////////

INT WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    MSG msg;

    if (!InitApplication(hInstance))
    {
        return (FALSE);
    }

    //
    //  Initialize the OLE library
    //
    if (OleInitialize(NULL) != NOERROR)
        return FALSE;

    //
    //  Load the rich edit control library
    //

    if ((ghRichEditLib = LoadLibrary(L"RICHED20.DLL")) == NULL)
        return FALSE;   // Rich edit control initialisation failed


    InitCommonControls();


    //
    //  Perform initialization for this instance.
    //
    if (!InitInstance(hInstance, nCmdShow))
    {
        return (FALSE);
    }

    while (GetMessage(&msg, NULL, 0, 0))
    {
        //
        //  Main message loop.
        //
        if (!IsDialogMessage(hwndDialog, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    //
    //  Free up some stuff.
    //
    if (hfontStatus)
    {
        DeleteObject(hfontStatus);
    }

    //
    //  Free the rich edit control library
    //
    FreeLibrary(ghRichEditLib);

    //
    //  Close the OLE library and free any resources that it maintains
    //
    OleUninitialize();

    return (INT)(msg.wParam);
}

////////////////////////////////////////////////////////////////////////////
//
//  InitApplication
//
//  Initializes window data and registers window class.
//
////////////////////////////////////////////////////////////////////////////

BOOL InitApplication(
    HINSTANCE hInstance)
{
    WNDCLASS wc;

    //
    //  Register a window class that we will use to draw the character
    //  grid into.
    //
    wc.style = CS_DBLCLKS;
    wc.lpfnWndProc = CharGridWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("CharGridWClass");

    if (!RegisterClass(&wc))
    {
        return (FALSE);
    }

    wc.style = 0;
    wc.lpfnWndProc = DefDlgProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = DLGWINDOWEXTRA;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDIC_UCE));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = TEXT("MyDlgClass");

    return RegisterClass(&wc);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitInstance
//
//  Does some initialization and creates main window which is a dialog.
//
////////////////////////////////////////////////////////////////////////////

BOOL InitInstance(
    HINSTANCE   hInstance,
    INT         nCmdShow)
{
    CHARSETINFO csi;
    DWORD dw = GetACP();
/*
    LANGID PrimaryLangId = (PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())));
    BOOL bFE = ((PrimaryLangId == LANG_JAPANESE) ||
                (PrimaryLangId == LANG_KOREAN)   ||
                (PrimaryLangId == LANG_CHINESE));
*/
    //
    //  Save the instance handle in a global variable.
    //
    hInst = hInstance;

    //
    //  This font will be used to paint the status line.
    //
    if (!TranslateCharsetInfo((DWORD*)IntToPtr(dw), &csi, TCI_SRCCODEPAGE))
    {
        csi.ciCharset = ANSI_CHARSET;
    }
/*
    hfontStatus = CreateFont( -PointsToHeight(bFE
                                                ? FE_STATUSPOINTSIZE
                                                : STATUSPOINTSIZE),
*/
    hfontStatus = CreateFont( -PointsToHeight(STATUSPOINTSIZE),
                              0, 0, 0, 400, 0, 0, 0,
                              csi.ciCharset,
                              OUT_DEFAULT_PRECIS,
                              CLIP_DEFAULT_PRECIS,
                              DEFAULT_QUALITY,
                              VARIABLE_PITCH,
                              TEXT("MS Shell Dlg") );

    dyStatus = 2 * PointsToHeight(STATUSPOINTSIZE);

    //
    //  Create a main window for this application instance.
    //
    if (!(hwndDialog = CreateDialog( hInstance,
                                     TEXT("UCE"),
                                     NULL,
                                     UCEDlgProc )))
    {
        return (FALSE);
    }

    // Drag action starts after nDragDelay time
    nDragDelay = GetProfileInt(
        TEXT("windows"),
        TEXT("DragDelay"),
        DD_DEFDRAGDELAY
        );

    // If the mouse moves nDragMinDist from the place of LBUTTONDOWN
    // then Drag starts
    nDragMinDist = GetProfileInt(
        TEXT("windows"),
        TEXT("DragMinDist"),
        DD_DEFDRAGMINDIST
        );

    // Scroll Interval
    nScrollInterval = GetProfileInt(
        TEXT("windows"),
        TEXT("DragScrollInterval"),
        DD_DEFSCROLLINTERVAL
        );

    //
    //  Initialize keystroke text, make the window visible,
    //  update its client area, and return "success".
    //
    UpdateKeystrokeText(NULL, sycm.chCurr, FALSE);


    ShowWindow(hwndDialog, nCmdShow);
    UpdateWindow(hwndDialog);

                // Potential for Bug#187822, tab order problem.
                // If the initial focus should be on ID_FONT, add this code,
                // otherwise initial focus will be on ID_CHARGRID
                {
                        HWND hTmp;
                        hTmp = GetDlgItem(hwndDialog, ID_FONT);
                        SetFocus(hTmp);
                }


    return (TRUE);

}

////////////////////////////////////////////////////////////////////////////
//
//  EnumChildProc
//
//  Gets called during init for each child window.
//
////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK EnumChildProc(
    HWND hwnd,
    LPARAM lParam)
{
    LONG st;
    TCHAR szClass[MAX_PATH];

    //
    //  Get control class.
    //
    GetClassName(hwnd, szClass, MAX_PATH);
//    if (lstrcmpi(szClass, TEXT("button")) == 0 )
    if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szClass, -1, TEXT("button"), -1) == CSTR_EQUAL)
    {
        //
        //  If it is a button, set the ex style to NOTIFYPARENT.
        //
        st = GetWindowLong(hwnd, GWL_EXSTYLE);
        st = st & ~WS_EX_NOPARENTNOTIFY;
        SetWindowLong(hwnd, GWL_EXSTYLE, st);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  UCEDlgProc
//
//  Processes messages for the main window.  This window is a dialog box.
//
////////////////////////////////////////////////////////////////////////////

INT_PTR APIENTRY UCEDlgProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message)
    {
        case ( WM_KEYDOWN ) :
        {
            if(wParam == VK_F6)
            {
                if(ghwndList)
                    SetFocus(ghwndList);
                else if(ghwndGrid)
                    SetFocus(ghwndGrid);
                return 0L;
            }
            break;
        }

        case ( WM_CTLCOLORSTATIC ) :
        {
            POINT point;

            SetBkColor((HDC)wParam, GetSysColor(COLOR_BTNFACE));
            UnrealizeObject(hStaticBrush);
            point.x = point.y = 0;
            ClientToScreen(hWnd, &point);

            return ((INT_PTR)hStaticBrush);
            break;
        }

        case ( WM_INITDIALOG ) :
        {
            int   right_adjust;
            int   bottom_adjust;
            RECT  rectParent, rect;
            POINT pt;
            HWND  hwndCMSB;

            //
            //  Set buttons to send WM_PARENTNOTIFY.
            //
            EnumChildWindows(hWnd, EnumChildProc, (LPARAM)NULL );

            // Create the scroll bar first and then resize it in the Chargrid
            // window create routine
            hwndCMSB = CreateWindowEx(0L,
                                      TEXT("SCROLLBAR"),
                                      NULL,
                                      WS_CHILD | SBS_VERT | WS_VISIBLE,
                                      0,
                                      0,
                                      0,
                                      0,
                                      hWnd,
                                      (HMENU)ID_MAPSCROLL,
                                      hInst,
                                      NULL );

            //
            //  Create the character grid with dimensions which just fit
            //  inside the space allowed in the dialog.  When it processes
            //  the WM_CREATE message it will be sized and centered more
            //  accurately.
            //
            GetClientRect(hWnd, &rectParent);

            right_adjust  = (int)((rectParent.right/360) *9);
            bottom_adjust = (int)((rectParent.bottom/10) *3);

            if (!(hwndCharGrid =
                  CreateWindow( TEXT("CharGridWClass"),
                                NULL,
                                WS_CHILD | WS_VISIBLE | WS_TABSTOP,
                                0, 0,
                                rectParent.right  - right_adjust,
                                rectParent.bottom - bottom_adjust,
                                hWnd,
                                (HMENU) ID_CHARGRID,
                                hInst,
                                NULL )))
            {
                DestroyWindow(hWnd);
                break;
            }

            GetWindowRect( hwndCharGrid, &rect );
            pt.x = rect.right;
            pt.y = rect.top;

            ScreenToClient(hWnd, &pt);

//pliu            hStaticBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));

            // Compute the heights of the dialog in expanded and shrunk state
            ComputeExpandedAndShrunkHeight(hWnd);

            // Load registry setting to find if start state is expanded or shrunk
            LoadAdvancedSelection(hWnd, ID_ADVANCED, SZ_ADVANCED);

            // Resize the Dialog to correspond to expanded or shrunk state
            ResizeDialog(hWnd);

            // Compute client rect of the resized dialog
            GetClientRect(hWnd, &rectParent);

            //
            //  Initialize the status line data.
            //
            dxHelpField = 23 * rectParent.right / 32;
            rcStatusLine = rectParent;
            rcStatusLine.top = rcStatusLine.bottom - dyStatus;

            //
            //  Disable Copy & Search buttons.
            //
            EnableWindow(GetDlgItem(hWnd, ID_COPY),   FALSE);
            EnableWindow(GetDlgItem(hWnd, ID_SEARCH), FALSE);

            if (Display_InitList())
            {
                pCode = NULL;
            }

            if (Font_InitList(hWnd))
            {
                Font_FillToComboBox(hWnd,ID_FONT);
                LoadCurrentSelection(hWnd,ID_FONT,SZ_FONT,SZ_FONT_DEFAULT);
            }

            if (CodePage_InitList())
            {
                CodePage_FillToComboBox(hWnd,ID_VIEW);
                LoadCurrentSelection(hWnd,ID_VIEW,SZ_CODEPAGE,SZ_CODEPAGE_DEFAULT);
            }

            CreateResources(hInst, hWnd);  // init gui stuff
            if( UCE_EnumFiles() )
            {
                Subset_FillComboBox( hWnd , ID_UNICODESUBSET );
            }

            // Initialise the ID_ADVANCED check box
            SendMessage(GetDlgItem(hWnd, ID_ADVANCED),
                BM_SETCHECK,
                (WPARAM)((fDisplayAdvControls==TRUE)? BST_CHECKED: BST_UNCHECKED),
                (LPARAM)0L);

#ifndef DISABLE_RICHEDIT
            // Some richedit's initialization

            // Set and event mask for the rich edit control so that we
            // get a notification when text changes
            SendMessage(GetDlgItem(hWnd, ID_STRING), EM_SETEVENTMASK, 0, ENM_SELCHANGE);

            // Set necessary lang options
/* this is supposed to fix 374706, however, looks like you have to turn on IMF_AUTOFONT
   for RichEdit to change cursor correctly, but this flag cause RichEdit to lose font info.
            DWORD   dwOptions = SendMessage(GetDlgItem(hWnd, ID_STRING),
                                EM_GETLANGOPTIONS, 0, 0);
            dwOptions |= IMF_IMECANCELCOMPLETE | IMF_UIFONTS;
            SendMessage(GetDlgItem(hWnd, ID_STRING), EM_SETLANGOPTIONS, 0,
                        dwOptions);
*/
            SendMessage(GetDlgItem(hWnd, ID_STRING), EM_SETLANGOPTIONS, 0,
                        IMF_IMECANCELCOMPLETE | IMF_UIFONTS);

#else
            SendMessage(GetDlgItem(hWnd, IDC_EDIT), EM_SETEVENTMASK, 0,
                ENM_SELCHANGE);
#endif

            // Enable/diable SUR controls depending on the range selected
            EnableSURControls(hWnd);

            // Initialise the text in the two UR controls
            SetHexEditProc(GetDlgItem(hWnd, ID_FROM));
            SendMessage(GetDlgItem(hWnd, ID_FROM), EM_LIMITTEXT,
                (WPARAM)MAX_CHARS, (LPARAM)0L);

            // subclass the search edit box to handle the Enter key
            SetSearchEditProc(GetDlgItem(hWnd, ID_SEARCHINPUT));

            // Initialise codepage associated with the active keyboard
            {
                WCHAR wcBuf[8];

                if(GetLocaleInfo(LOWORD(GetKeyboardLayout(0)),
                                 LOCALE_IDEFAULTANSICODEPAGE, wcBuf, 8))
                {
                    gKBD_CP = (UINT) _wtol(wcBuf);
                }
            }

            //
            //  Fall through to WM_FONTCHANGE...
            //
        }

        case ( WM_FONTCHANGE ) :
        {
            //
            //  Get the fonts from the system and put them in the font
            //  selection combo box.
            //

            if (message == WM_FONTCHANGE)
            {
                SaveCurrentSelection(hWnd,ID_FONT,SZ_FONT);

                if (Font_InitList(hWnd))
                {
                    Font_FillToComboBox(hWnd,ID_FONT);
                }
                LoadCurrentSelection(hWnd,ID_FONT,SZ_FONT,SZ_FONT_DEFAULT);
            }

            SendMessage(hWnd, WM_COMMAND, MAKELONG(ID_FONT,CBN_SELCHANGE), 0L);

            if (message == WM_INITDIALOG)
            {
                SetFocus(hwndCharGrid);

                //
                //  Fall through to WM_SYSCOLORCHANGE...
                //
            }
            else
            {
                break;
            }
        }

        case ( WM_SYSCOLORCHANGE ) :
        {
            if (hbmFont)
            {
                DeleteObject(hbmFont);
            }
            hbmFont = LoadBitmaps(IDBM_TT);
//pliu            DeleteObject(hStaticBrush);
//pliu            hStaticBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
            break;
        }

        case ( WM_NOTIFY ):
        {
            int        iTextLength;
            LPNMHDR pnmh = (LPNMHDR)lParam;

#ifndef DISABLE_RICHEDIT
            if ((wParam == ID_STRING) && (pnmh->code == EN_SELCHANGE))
            {
                // If there is no text in the rich edit control then
                // disable the Copy button
                iTextLength = GetWindowTextLength(GetDlgItem(hWnd, ID_STRING));
                EnableWindow(GetDlgItem(hWnd, ID_COPY), (BOOL)iTextLength);
            }
#else
            if ((wParam == IDC_EDIT) && (pnmh->code == EN_SELCHANGE))
            {
                // If there is no text in the rich edit control then
                // disable the Copy button
                iTextLength = GetWindowTextLength(GetDlgItem(hWnd, IDC_EDIT));
                EnableWindow(GetDlgItem(hWnd, ID_COPY), (BOOL)iTextLength);
            }
#endif
            break;
        }

        case ( WM_PARENTNOTIFY ) :
        {
            POINTS points;
            DWORD  dwMsgPos;
            POINT  point;

            DPRINT(( szDbgBuf,
                    TEXT("WM_PARENTNOTIFY: lParam:0x%08lX, wParam:0x%08lX\n"),
                    (DWORD)lParam,
                    (DWORD)wParam ));

            //
            //  We process this message to implement the context sensitive
            //  help.  Downclicks to controls are found here, the help
            //  message is updated in the status bar.
            //
            //  The parameters with this message are unreliable!
            //
            if (LOWORD(wParam) == WM_LBUTTONDOWN)
            {
                dwMsgPos = GetMessagePos();
                points = MAKEPOINTS(dwMsgPos);
                point.x = points.x;
                point.y = points.y;
            }

            break;
        }

        case ( WM_VSCROLL ) :
        {
            ProcessScrollMsg(hWnd, LOWORD(wParam), HIWORD(wParam));
            return TRUE;
        }

        case ( WM_PAINT ) :
        {
            HBRUSH hBrush;
            RECT rcTemp;
            INT dyBorder, dxBorder;
            PAINTSTRUCT ps;
            HDC hdc;

            //
            //  This code implements painting of the status bar.
            //
            hdc = BeginPaint(hWnd, &ps);

            rcTemp = rcStatusLine;

            dyBorder = GetSystemMetrics(SM_CYBORDER);
            dxBorder = GetSystemMetrics(SM_CXBORDER);

            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW)))
            {
                //
                //  Status line top.
                //
                rcTemp.left   = 6 * dyBorder;
                rcTemp.right  = rcStatusLine.right - 8 * dyBorder;
                rcTemp.top    = rcStatusLine.top + dyBorder * 2;
                rcTemp.bottom = rcTemp.top + dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                //
                //  Status line left side.
                //
                rcTemp = rcStatusLine;
                rcTemp.left = 6 * dyBorder;
                rcTemp.right = rcTemp.left + dyBorder;
                rcTemp.top += dyBorder * 2;
                rcTemp.bottom -= dyBorder * 2;
                FillRect(hdc, &rcTemp, hBrush);

                DeleteObject(hBrush);
            }

            if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNHIGHLIGHT)))
            {
                //
                //  Status line bottom.
                //
                rcTemp.left   = 8 * dyBorder;
                rcTemp.right  = rcStatusLine.right - 8 * dyBorder;
                rcTemp.top    = rcStatusLine.bottom - 3 * dyBorder;
                rcTemp.bottom = rcTemp.top + dyBorder;
                FillRect(hdc, &rcTemp, hBrush);

                //
                //  Status line right side.
                //
                rcTemp = rcStatusLine;
                rcTemp.left = rcStatusLine.right - 8 * dyBorder;
                rcTemp.right = rcTemp.left + dyBorder;
                rcTemp.top += dyBorder * 2;
                rcTemp.bottom -= dyBorder * 2;
                FillRect(hdc, &rcTemp, hBrush);

                DeleteObject(hBrush);
            }

            PaintStatusLine(hdc, TRUE, TRUE);

            EndPaint(hWnd, &ps);
            return (TRUE);
            break;
        }

        case ( WM_MEASUREITEM ) :
        {
            HDC hDC;
            HFONT hFont;
            TEXTMETRIC tm;

            hDC = GetDC(NULL);
            hFont = (HFONT)SendMessage(hWnd, WM_GETFONT, 0, 0L);
            if (hFont)
            {
                hFont = (HFONT)SelectObject(hDC, hFont);
            }
            GetTextMetrics(hDC, &tm);
            if (hFont)
            {
                SelectObject(hDC, hFont);
            }
            ReleaseDC(NULL, hDC);

            ((LPMEASUREITEMSTRUCT)lParam)->itemHeight =
                                  max(tm.tmHeight, DY_BITMAP);

            break;
        }

        case ( WM_DRAWITEM ) :
        {
            if (((LPDRAWITEMSTRUCT)lParam)->itemID != -1)
            {
                DrawFamilyComboItem((LPDRAWITEMSTRUCT)lParam);
            }
            break;
        }

        case ( WM_ASKCBFORMATNAME ) :
        {
            LoadString(hInst, IDS_RTF, (LPTSTR)lParam, (int)wParam);
            //should hardcode clipboard format, we'll do it after Win2K
            //lstrcpy((LPTSTR)lParam, RTFFMT);
            return (TRUE);
        }

        case ( WM_PAINTCLIPBOARD ) :
        {
            LPPAINTSTRUCT lpPS;
            HANDLE hFont;
            LPTSTR lpstrText;

            if (hstrClipboard)
            {
                //
                //  Setup.
                //
                lpPS = (LPPAINTSTRUCT)GlobalLock((HANDLE)lParam);
                lpstrText = (LPTSTR)GlobalLock(hstrClipboard);

                //
                //  Paint.
                //
                hFont = SelectObject(lpPS->hdc, hFontClipboard);
                TextOut(lpPS->hdc, 0, 0, lpstrText, lstrlen(lpstrText));
                SelectObject(lpPS->hdc, hFont);

                //
                //  Cleanup.
                //
                GlobalUnlock(hstrClipboard);
                GlobalUnlock((HANDLE)lParam);
            }
            return (TRUE);
        }

        case ( WM_SYSCOMMAND):
        {
            switch (wParam)
            {
                case (SC_CLOSE):
                  DestroyWindow(hWnd);
                  return (TRUE);
            }
            break;
        }

        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                //case ( IDCANCEL ) :
                case ( ID_CLOSE ) :
                {
                    DestroyWindow(hWnd);
                    return (TRUE);
                }

                case ( ID_SELECT ) :
                {
                  WCHAR wc = (WCHAR)pCode[sycm.chCurr];
                  ConvertAnsifontToUnicode(hWnd, (char*)&pCode[sycm.chCurr], &wc);
#ifndef DISABLE_RICHEDIT
                SetRichEditFont(hWnd, ID_STRING, sycm.hFont);
                //richedit screws up symbol font display
                //use ansi code so that it can display symbols correctly.
                if (gFontType & SYMBOL_FONTTYPE)
                {
                  if ((wc >= 0xf000) && (wc <= 0xf0ff))
                    wc = (WCHAR) (BYTE)pCode[sycm.chCurr];
                }
                SendDlgItemMessage(hWnd, ID_STRING, WM_CHAR, wc, 0L);
                CopyTextToClipboard(hWnd);
#else
                SendDlgItemMessage(hWnd, IDC_EDIT, WM_SETFONT, (WPARAM)(sycm.hFont), MAKELPARAM(true,0));
                SendDlgItemMessage(hWnd, IDC_EDIT, WM_CHAR, wc, 0L);
#endif
                    break;
                }

                case ( ID_COPY ) :
                {
                    CopyTextToClipboard(hWnd);
                    return (TRUE);
                }

                case ( ID_FONT ) :
                {
                    static int preItem;
#ifdef DISABLE_RICHEDIT
                    if (HIWORD(wParam) == CBN_DROPDOWN)
                    {
                        preItem = SendDlgItemMessage(hWnd, ID_FONT, CB_GETCURSEL, 0, 0);
                    }
#endif
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        int nItem = (int)SendDlgItemMessage(hWnd, ID_FONT, CB_GETCURSEL,       0, 0);
#ifdef DISABLE_RICHEDIT
                        if ((gDisplayFontChgMsg) &&
                            (preItem != nItem) &&
                            GetWindowTextLength(GetDlgItem(hWnd, IDC_EDIT)))
                        {
                          int dlgRet = DialogBox(hInst, MAKEINTRESOURCE(IDD_FONTCHANGEMSG), hwndDialog, MsgProc);
                          if (dlgRet == IDCANCEL)
                          {
                            SendDlgItemMessage(hWnd, ID_FONT, CB_SETCURSEL, (WPARAM)preItem, 0);
                            return TRUE;
                          }
                        }
#endif
                        nItem = (int)SendDlgItemMessage(hWnd, ID_FONT, CB_GETITEMDATA, nItem, 0);
                        gFontType = Font_pList[nItem].FontType;

                        ExitMagnify(hwndCharGrid, &sycm);
                        sycm.chCurr = 0;

                        if((ghwndList == NULL) && (ghwndGrid == NULL))
                        {
                            if(gFontType & SYMBOL_FONTTYPE)
                            {
                                if(CodePage_GetCurCodePageVal() != UNICODE_CODEPAGE)
                                {

                                    SendMessage( GetDlgItem(hWnd, ID_VIEW),
                                                 CB_SETCURSEL,
                                                 (WPARAM) 0,
                                                 (LPARAM) 0);
                                }
                                EnableWindow(GetDlgItem(hWnd, ID_VIEW),          FALSE);
                                EnableWindow(GetDlgItem(hWnd, ID_FROM),          FALSE);
                                EnableWindow(GetDlgItem(hWnd, ID_SEARCHINPUT),   FALSE);
                                EnableWindow(GetDlgItem(hWnd, ID_UNICODESUBSET), FALSE);
                            }
                            else
                            {
                                EnableWindow(GetDlgItem(hWnd, ID_VIEW),          TRUE);
                                EnableWindow(GetDlgItem(hWnd, ID_SEARCHINPUT),   TRUE);
                                EnableWindow(GetDlgItem(hWnd, ID_UNICODESUBSET), TRUE);
                                if(UNICODE_CODEPAGE == CodePage_GetCurCodePageVal())
                                {
                                    EnableWindow(GetDlgItem(hWnd, ID_FROM),      TRUE);
                                }
                                else
                                {
                                    EnableWindow(GetDlgItem(hWnd, ID_FROM),      FALSE);
                                }
                            }
                        }
                        else //GroupBy windows present
                        {
                          if(gFontType & SYMBOL_FONTTYPE) //disable GroupBy
                          {
                            SendMessage(GetDlgItem(hWnd, ID_UNICODESUBSET), CB_SETCURSEL,
                                                   (WPARAM)0,(LPARAM) 0);
                            SendMessage(GetDlgItem(hWnd, ID_VIEW), CB_SETCURSEL,
                                                   (WPARAM)0,(LPARAM) 0);

                            // same as ID_VIEW changed
                            //--------------------------------
                            WCHAR buffer[256];

                            ExitMagnify(hwndCharGrid, &sycm);
                            sycm.chCurr = 0;

                            Subset_OnSelChange(hWnd , ID_UNICODESUBSET );
                            // Then say that subset has changed
                            SubSetChanged( hWnd );

                            fSearched  = FALSE;
                            fNeedReset = FALSE;
                            SetDlgItemText(hWnd, ID_SEARCHINPUT, L"");
                            LoadString(hInst, IDS_SEARCH, buffer, 255);
                            SetDlgItemText(hWnd, ID_SEARCH, buffer);
                            EnableWindow(GetDlgItem(hWnd, ID_SEARCH), FALSE);

                            // Enable or disable SUR controls
                            EnableSURControls(hWnd);
                            //--------------------------------

                            EnableWindow(GetDlgItem(hWnd, ID_VIEW),          FALSE);
                            EnableWindow(GetDlgItem(hWnd, ID_FROM),          FALSE);
                            EnableWindow(GetDlgItem(hWnd, ID_SEARCHINPUT),   FALSE);
                            EnableWindow(GetDlgItem(hWnd, ID_UNICODESUBSET), FALSE);
                          }
                          else
                          {
                            EnableWindow(GetDlgItem(hWnd, ID_UNICODESUBSET), TRUE);
                          }
                        }

                        RecalcUCE( hWnd,
                                   &sycm,
                                   nItem,
                                   TRUE );
#ifndef DISABLE_RICHEDIT
                        SetRichEditFont(hWnd, ID_STRING, sycm.hFont);
#else
                        SendDlgItemMessage(hWnd, IDC_EDIT, WM_SETFONT, WPARAM(sycm.hFont), MAKELPARAM(true,0));
#endif

                        if(fNeedReset || fSearched)
                        {
                            SendMessage(hwndDialog, WM_COMMAND, ID_SEARCH, 0L);
                        }
                    }
                    else if (HIWORD(wParam) == CBN_SETFOCUS)
                    {
                        //
                        //  Necessary if hotkey is used to get to the CB.
                        //
                        // UpdateHelpText(NULL, (HWND)lParam);
                    }

                    return (TRUE);
                }

                case ID_SEARCHINPUT:
                {
                    WCHAR buffer1[256];
                    WCHAR buffer2[256];

                    if( (HWND)lParam != GetFocus() )
                        break;

                    if(fSearched == TRUE) fNeedReset= TRUE;

                    GetWindowText((HWND)lParam, buffer1, 256);
                    if(swscanf(buffer1, L"%s", buffer2) > 0 &&
                       fSearched == FALSE)
                    {
                        LoadString(hInst, IDS_SEARCH, buffer1, 255);
                        SetDlgItemText(hWnd, ID_SEARCH, buffer1);
                        EnableWindow(GetDlgItem(hWnd, ID_SEARCH), TRUE);
                        EnableSURControls(hWnd, TRUE);
                    }
                    else
                    {
                        if(fNeedReset == FALSE)
                        {
                            LoadString(hInst, IDS_SEARCH, buffer1, 255);
                            SetDlgItemText(hWnd, ID_SEARCH, buffer1);
                            EnableWindow(GetDlgItem(hWnd, ID_SEARCH), FALSE);
                            fSearched = FALSE;
                            EnableSURControls(hWnd);
                        }
                        else
                        {
                            LoadString(hInst, IDS_RESET,  buffer2, 255);
                            SetDlgItemText(hWnd, ID_SEARCH, buffer2);
                            EnableWindow(GetDlgItem(hWnd, ID_SEARCH), TRUE);
                            fNeedReset = FALSE;
                            fSearched  = TRUE;
                        }
                    }
                    break;
                }

                case ID_SEARCH:
                {
                    WCHAR buffer[256];
                    WCHAR KeyWord[SEARCH_WORD_MAX][SEARCH_WORD_LEN];
                    WCHAR *ptr1;
                    int   i, j, k, word;
                    char  buffer3[256];
                    WCHAR wbuffer[256];
                    HDC   hdc;

                    if(fSearched == TRUE)
                    {
                        fSearched  = FALSE;
                        fNeedReset = FALSE;
                        SetDlgItemText(hWnd, ID_SEARCHINPUT, L"");
                        LoadString(hInst, IDS_SEARCH, buffer, 255);
                        SetDlgItemText(hWnd, ID_SEARCH, buffer);
                        EnableWindow(GetDlgItem(hWnd, ID_SEARCH), FALSE);
                        SendMessage(hWnd,
                                    WM_COMMAND,
                                    MAKELONG(ID_VIEW,CBN_SELCHANGE),
                                    0L);
                        EnableSURControls(hWnd);
                        break;
                    }

                    GetDlgItemText(hWnd, ID_SEARCHINPUT, buffer, 256);
                    memset(KeyWord, 0, sizeof(KeyWord));
                    ptr1 = buffer;
                    word = 1;

                    do
                    {
                        if(*ptr1 !=  ' ')
                        {
                            j = 0;

                            if(*ptr1 == '\"')   // this is a quoted string
                            {
                                while(*++ptr1 && *ptr1 != '\"')
                                {
                                    KeyWord[word][j++] = *ptr1;
                                }
                            }
                            else                // this is an unquoted string
                            {
                                do
                                {
                                    KeyWord[word][j++] = *ptr1++;
                                }
                                while(*ptr1 && *ptr1 != ' ');

                            }
                        }
                        _wcsupr(KeyWord[word]);
                        if(++word == SEARCH_WORD_MAX)
                            break;
                    }
                    while(*ptr1++ && *ptr1);

                    j = 0;
                    for(i = 0; i <= chRangeLast && pCode[i]; i++)
                    {
                        GetUName(pCode[i], wbuffer);
                        /*
                        MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                buffer3, -1,
                                wbuffer, 256); */
                        _wcsupr(wbuffer);

                        for(k = 0; k < word; k++)
                        {
                            if(wcsstr(wbuffer, KeyWord[k]) == NULL)
                                break;
                        }

                        if(k < word)
                            continue;

                        pCode[j++] = pCode[i];
                    }

                    pCode[j] = '\0';
                    chRangeLast = j - 1;
                    fSearched  = TRUE;
                    fNeedReset = TRUE;
                    LoadString(hInst, IDS_RESET,  buffer, 255);
                    SetDlgItemText(hwndDialog, ID_SEARCH, buffer);
                    EnableWindow(GetDlgItem(hWnd, ID_SEARCH), TRUE);

                    ExitMagnify(hwndCharGrid, &sycm);
                    sycm.chCurr = 0;
                    UpdateSymbolSelection(hWnd, FALSE);

                    hdc = GetDC(hwndDialog);
                    UpdateKeystrokeText(hdc, sycm.chCurr, TRUE);

                    InvalidateRect(hwndCharGrid, NULL, TRUE);
                    ReleaseDC(hwndDialog, hdc);
                    break;
                }

                case ( ID_UNICODESUBSET ) :
                {
                    WCHAR buffer[256];

                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        ExitMagnify(hwndCharGrid, &sycm);
                        sycm.chCurr = 0;

                        Subset_OnSelChange(hWnd , ID_UNICODESUBSET );
                        // Then say that subset has changed
                        SubSetChanged( hWnd );

                        fSearched  = FALSE;
                        fNeedReset = FALSE;
                        SetDlgItemText(hWnd, ID_SEARCHINPUT, L"");
                        LoadString(hInst, IDS_SEARCH, buffer, 255);
                        SetDlgItemText(hWnd, ID_SEARCH, buffer);
                        EnableWindow(GetDlgItem(hWnd, ID_SEARCH), FALSE);

                        // Enable or disable SUR controls
                        EnableSURControls(hWnd);
                    }
                    else if (HIWORD(wParam) == CBN_SETFOCUS)
                    {
                        //
                        //  Necessary if hotkey is used to get to the CB.
                        //
                    }

                    return (0L);
                }
#ifndef DISABLE_RICHEDIT
                case ( ID_STRING ) :
                {
                    if (HIWORD(wParam) == EN_SETFOCUS)
                    {
                        //
                        //  Necessary if hotkey is used to get to the EC.
                        //
                    }
                    else if (HIWORD(wParam) == EN_CHANGE)
                    {
                        //
                        //  Disable Copy button if there are no chars in EC.
                        //
                        INT iLength;

                        iLength = GetWindowTextLength((HWND)lParam);
                        EnableWindow(GetDlgItem(hWnd, ID_COPY), (BOOL)iLength);
                    }
                    break;
                }
#else
                case ( IDC_EDIT ) :
                {
                    if (HIWORD(wParam) == EN_SETFOCUS)
                    {
                        //
                        //  Necessary if hotkey is used to get to the EC.
                        //
                    }
                    else if (HIWORD(wParam) == EN_CHANGE)
                    {
                        //
                        //  Disable Copy button if there are no chars in EC.
                        //
                        INT iLength;

                        iLength = GetWindowTextLength((HWND)lParam);
                        EnableWindow(GetDlgItem(hWnd, ID_COPY), (BOOL)iLength);
                    }
                    break;
                }
#endif
                case ( ID_HELP ) :
                {
                    DoHelp(hWnd, TRUE);
                    break;
                }

                case (ID_VIEW) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        LONG lCodePage;
                        long lNumWChar;

                        ExitMagnify(hwndCharGrid, &sycm);
                        sycm.chCurr = 0;

                        lCodePage = (LONG)CodePage_GetCurSelCodePage(hWnd,ID_VIEW);
                        if(lCodePage == 0)
                            break;
                        lNumWChar = WCharCP(lCodePage, NULL);
                        if(lNumWChar == 0)
                            break;
                        pCode = Display_CreateDispBuffer(NULL,
                                               lNumWChar, NULL, 0,FALSE);
                        if (pCode == NULL)
                            break;
                        WCharCP(lCodePage, pCode);
                        chRangeLast = lstrlen(pCode)-1;
                        sycm.chCurr = 0;

                        SendMessage(
                            hWnd,
                            WM_COMMAND,
                            MAKELONG(ID_FONT,CBN_SELCHANGE),
                            0L);


                        /* auto font selection according to the codepage.

                        if (lCodePage == UNICODE_CODEPAGE)
                        {
                            SendMessage(
                                hWnd,
                                WM_COMMAND,
                                MAKELONG(ID_FONT,CBN_SELCHANGE),
                                0L);
                        }
                        else
                        {
                            CPINFO      cpinfo;

                            GetCPInfo(lCodePage, &cpinfo);
                            if(cpinfo.MaxCharSize > 1)
                            {
                                CHARSETINFO csi;

                                if(!TranslateCharsetInfo((DWORD*)lCodePage,
                                                &csi, TCI_SRCCODEPAGE))
                                {
                                    csi.ciCharset = Font_GetSelFontCharSet(
                                                     hWnd,
                                                     ID_FONT,
                                                     (INT)SendDlgItemMessage(
                                                                hWnd,
                                                                ID_FONT,
                                                                CB_GETCURSEL,
                                                                0,
                                                                0L));
                                }

                                Font_SelectByCharSet(hWnd,ID_FONT,csi.ciCharset);
                            }
                            SendMessage(
                                hWnd,
                                WM_COMMAND,
                                MAKELONG(ID_FONT,CBN_SELCHANGE),
                                0L);
                        }
                        */

                        // Enable or disable SUR controls
                        EnableSURControls(hWnd);

                        if(fNeedReset || fSearched)
                        {
                            SendMessage(hwndDialog, WM_COMMAND, ID_SEARCH, 0L);
                        }
                     }
                    break;
                }

                case (ID_SUBFUNCCHANGED):
                    break;

                case (ID_ADVANCED):
                {
                    switch (HIWORD(wParam)) {
                    case BN_CLICKED:
                        ShowHideAdvancedControls( hWnd, wParam, lParam );
                        break;
                    }
                }
                break;

                case ( ID_FROM ) :
                {
                    if (HIWORD(wParam) == EN_CHANGE)
                    {
                        HWND hWndEdit = (HWND)lParam;
                        int nLen = GetWindowTextLength(hWndEdit);
                        if ((nLen == MAX_CHARS) && (fSURChanged == FALSE))
                        {
                            fSURChanged = TRUE;
                            ValidateValues(hWndEdit);
                        }
                        else
                        {
                            fSURChanged = FALSE;
                        }
                    }

                    break;
                }
            }
            break;
        }

        case ( WM_DESTROY ) :
        {
            SaveAdvancedSelection(hWnd,ID_ADVANCED,SZ_ADVANCED);
            SaveCurrentSelection(hWnd,ID_VIEW,SZ_CODEPAGE);
            SaveCurrentSelection(hWnd,ID_FONT,SZ_FONT);
            CodePage_DeleteList();
            Font_DeleteList();
            UCE_CloseFiles();
            DeleteResources();
            Display_DeleteList();

            DoHelp(hWnd, FALSE);

            DeleteObject(hStaticBrush);
            PostQuitMessage(0);
            break;
        }

        case ( WM_CLOSE ):
        {
            DestroyWindow(hwndDialog);
            break;
        }

        case ( WM_ACTIVATEAPP ) :
        {
#if 0
// (#326752) Postponed by richedit so we work around it here (wchao, 6-16-99).
#ifndef DISABLE_RICHEDIT
            if (wParam)
            {
                SendDlgItemMessage( hWnd,
                                    ID_STRING,
                                    EM_SETSEL,
                                    LOWORD(lEditSel),
                                    HIWORD(lEditSel) );
            }
            else
            {
                lEditSel = (LONG)SendDlgItemMessage(hWnd, ID_STRING, EM_GETSEL, 0, 0L);
                SendDlgItemMessage(hWnd, ID_STRING, EM_SETSEL, 0, 0L);
            }
#else
            if (wParam)
            {
                SendDlgItemMessage( hWnd,
                                    IDC_EDIT,
                                    EM_SETSEL,
                                    LOWORD(lEditSel),
                                    HIWORD(lEditSel) );
            }
            else
            {
                lEditSel = SendDlgItemMessage(hWnd, IDC_EDIT, EM_GETSEL, 0, 0L);
                SendDlgItemMessage(hWnd, IDC_EDIT, EM_SETSEL, 0, 0L);
            }
#endif
#endif
            break;
        }

        case ( WM_CONTEXTMENU ) :
        {
            TCHAR    HelpPath[MAX_PATH];
            if( !GetWindowsDirectory( HelpPath, MAX_PATH))
                 return FALSE;
            
            HRESULT hresult = StringCchCat((TCHAR*)HelpPath, sizeof(HelpPath)/sizeof(HelpPath[0]), TEXT("\\HELP\\CHARMAP.HLP"));
            if (!SUCCEEDED(hresult))
            {
                return FALSE;
            }
            
            WinHelp((HWND)(wParam),
                   HelpPath, HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)aHelpIDs);
            return TRUE;
        }

        case ( WM_HELP ) :
        {
            DoHelp(hWnd, TRUE);
            return TRUE;
        }

    }
    return (0L);
}

////////////////////////////////////////////////////////////////////////////
//
//  CharGridWndProc
//
//  Processes messages for the character grid window.
//
////////////////////////////////////////////////////////////////////////////

LRESULT APIENTRY CharGridWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    static LPDROPSOURCE pDropSource;
    static POINT        ptDragStart;

    switch (message)
    {
        case ( WM_CREATE ) :
        {
            RECT rect;
            HDC hdcScrn;
            POINT point1, point2;
            HWND hWndScroll;

            //
            //  Setup global.
            //
            hwndCharGrid = hWnd;

            GetClientRect(hWnd, &rect);

            //
            //  Calculate metrics for the character grid and the
            //  magnify window.
            //
            sycm.dxpBox = (rect.right  - 1) / (cchSymRow + 2);
            sycm.dypBox = (rect.bottom    ) / (cchSymCol + 3);
            sycm.dxpCM  = sycm.dxpBox * cchSymRow+1;
            sycm.dypCM  = sycm.dypBox * cchSymCol+1;  // space inside for border

                                                /*
            if ((PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())) == LANG_CHINESE))
            {
                sycm.dxpMag = sycm.dxpBox * 3 + 5;
            }
                                                else if ((PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())) == LANG_HINDI) ||
                                                                                        (PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())) == LANG_TAMIL))
            {*/
                sycm.dxpMag = sycm.dxpBox * 3 + 15 ; //Indic characters are wide (#178112)
            /*}
            else
            {
                sycm.dxpMag = sycm.dxpBox * 2 + 4; // twice the size + 2 bit border
            }*/
            sycm.dypMag = sycm.dypBox * 2 + 4;

            sycm.chCurr   = chSymFirst;
            sycm.hFontMag = NULL;
            sycm.hFont    = NULL;
            sycm.hdcMag   = NULL;
            sycm.hbmMag   = NULL;
            sycm.ypDest   = 0;

            sycm.fFocusState = sycm.fMouseDn = sycm.fCursorOff = FALSE;
            sycm.fMagnify = FALSE;

            //
            //  Size the window precisely so the grid fits and is centered.
            //
            MoveWindow( hWnd,
                        (rect.right  - sycm.dxpCM) / 2 + 2,  //- 4,
                        (rect.bottom - sycm.dypCM) / 2 - 18 + 20,
                        sycm.dxpCM + 2,
                        sycm.dypCM + 2,
                        FALSE );

            //
            //  Figure out what the offsets are between the dialog
            //  and the character grid window.
            //
            point1.x = point1.y = point2.x = point2.y = 0;
            ClientToScreen(hWnd, &point1);
            ClientToScreen(((LPCREATESTRUCT)lParam)->hwndParent, &point2);
            //
            // In a mirrored charmap point1.x - point2.x will be a -ve value
            //
            sycm.xpCM = abs(point1.x - point2.x) - (sycm.dxpMag - sycm.dxpBox) / 2;
            sycm.ypCM = (point1.y - point2.y) - (sycm.dypMag - sycm.dypBox) / 2;


            //
            //  Create dc and bitmap for the magnify window.
            //
            if ((hdcScrn = GetWindowDC(hWnd)) != NULL)
            {
                if ((sycm.hdcMag = CreateCompatibleDC(hdcScrn)) != NULL)
                {
                    SetTextColor( sycm.hdcMag,
                                  GetSysColor(COLOR_WINDOWTEXT) );
                    SetBkColor( sycm.hdcMag,
                                GetSysColor(COLOR_WINDOW) );
                    SetBkMode(sycm.hdcMag, OPAQUE);

                    if ((sycm.hbmMag =
                         CreateCompatibleBitmap( hdcScrn,
                                                 sycm.dxpMag,
                                                 sycm.dypMag * 2 )) == NULL)
                    {
                        ;
                        //DeleteDC(sycm.hdcMag);
                        //DeleteObject(sycm.hdcMag);
                    }
                    else
                    {
                        SelectObject(sycm.hdcMag, sycm.hbmMag);
                    }
                }
                ReleaseDC(hWnd, hdcScrn);
            }

            // Create an instance of CDropSource for Drag and Drop
            pDropSource = new CDropSource;

            if (pDropSource == NULL) {
                // Show error message and prevent window from being shown
                return -1;
            }

            hWndScroll = GetDlgItem(GetParent(hWnd), ID_MAPSCROLL);

            GetWindowRect( hwndCharGrid, &rect );
            // Use MapWindowPoint instead of ScreenToClient to map the entire rect,
            // to swap the left and right in a mirrored window.
            MapWindowPoints(NULL, GetParent(hWnd), (LPPOINT) &rect, 2);

            MoveWindow( hWndScroll,
                        rect.right+1,
                        rect.top+1,
                        sycm.dxpBox,
                        sycm.dypCM,
                        FALSE );
            break;
        }

        case ( WM_DESTROY ) :
        {
            if (sycm.fMouseDn)
            {
                ExitMagnify(hWnd, &sycm);
            }
            if (fDelClipboardFont)
            {
                DeleteObject(hFontClipboard);
            }
            if (sycm.hFont != NULL)
            {
                DeleteObject(sycm.hFont);
            }
            if (sycm.hFontMag != NULL)
            {
                DeleteObject(sycm.hFontMag);
            }
            if (sycm.hdcMag != NULL)
            {
                DeleteDC(sycm.hdcMag);
            }
            if (sycm.hbmMag != NULL)
            {
                DeleteObject(sycm.hbmMag);
            }

            // Release pDropSource it will automatically destroy itself
            pDropSource->Release();

            break;
        }

        case ( WM_SETFOCUS )  :
        {
            WCHAR wcBuf[8];
            UINT  cp;

            if(GetLocaleInfo(LOWORD(GetKeyboardLayout(0)),
                             LOCALE_IDEFAULTANSICODEPAGE, wcBuf, 8))
            {
                cp = _wtol(wcBuf);
                if(gKBD_CP != cp)
                {
                    gKBD_CP = cp;
                    HDC hDC = GetDC(hwndDialog);
                    UpdateKeystrokeText(hDC, sycm.chCurr, TRUE);
                    ReleaseDC(hwndDialog, hDC);
                }
            }
            //
            // fall through ...
            //
        }

        case ( WM_KILLFOCUS ) :
        {
            DOUTL("Focus\n");
            if (sycm.fMagnify == FALSE)
                DrawSymChOutlineHwnd( &sycm,
                                  hWnd,
                                  sycm.chCurr,
                                  TRUE,
                                  message == WM_SETFOCUS );
            sycm.fFocusState = (message == WM_SETFOCUS);

            break;
        }

        case ( WM_TIMER ) :
        {
            switch (wParam)
            {
                case ( ID_DRAGTIMER ) :
                {
                    // If the user has kept LBUTTON down for long then
                    // start drag and drop operation
                    ReleaseCapture();
                    KillTimer(hWnd, 1);
                    fPendingDrag = FALSE;

                    // Come out of magnify mode
                    if (sycm.fMouseDn)
                    {
                        ExitMagnify(hWnd, &sycm);
                    }

                    // perform the modal drag/drop operation.
                    DoDragAndDrop(GetParent(hWnd), pDropSource);
                    break;
                }

                case ( ID_SCROLLTIMER ) :
                {
                    DoDragScroll(hWnd, (WPARAM)prevKeys, (LPARAM)ptPrevMouse);
                    break;
                }
            }

            break;
        }

        case ( WM_LBUTTONDOWN ) :
        {
            RECT    rect;
            UINT    chMouseSymbol;

            DOUTL("WM_LBUTTONDOWN: In\n");

            chMouseSymbol = (UINT)ChFromSymLParam(&sycm, lParam);

            // If cursor is off (magnified) and lbutton is clicked
            // exit magnify and go into drag mode ELSE magnify
            if ((sycm.fMagnify)&&(chMouseSymbol == sycm.chCurr))
            {
                // Store the point at which LBUTTON was down
                ptDragStart.x = (int)(short)LOWORD (lParam);
                ptDragStart.y = (int)(short)HIWORD (lParam);

                // Go into dragging mode
                fPendingDrag = TRUE;

                // Start timer
                SetTimer(hWnd, 1, nDragDelay, NULL);
                SetCapture(hWnd);
            }
            else
            {
                if(!pCode || *pCode == '\0')
                    return (0L);

                //
                //  Don't draw anything if there's an update region pending.
                //
                if (GetUpdateRect(hWnd, (LPRECT)&rect, FALSE) != 0)
                {
                    DOUTL("WM_LBUTTONDOWN: No upd rect\n");
                    break;
                }

                SetFocus(hWnd);
                SetCapture(hWnd);

                sycm.fMouseDn = TRUE;

                if ((!FMagData(&sycm))&&(sycm.fMagnify==FALSE))
                {
                    DOUTL("WM_LBUTTONDOWN: Drawing sym outline\n");
                    DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, FALSE, FALSE);
                }
            }
            ShowWindow(hwndTT, SW_HIDE);

            //
            //  Fall through to WM_MOUSEMOVE...
            //
        }

        case ( WM_MOUSEMOVE ) :
        {
            int x, y;

            if (sycm.fCursorOff)
            {
                sycm.fCursorOff = FALSE;
                ShowCursor(TRUE);
            }
            // This part is for Drag and Drop
            // If a drag is pending and mouse moves beyond threshold
            // then start our drag and drop operation
            if (fPendingDrag)
            {
                x = (int)(short)LOWORD (lParam);
                y = (int)(short)HIWORD (lParam);

                // Find if the point at which the mouse is is beyond the
                // min rectangle enclosing the point at which LBUTTON
                // was down
                if (! (((ptDragStart.x - nDragMinDist) <= x)
                    && (x <= (ptDragStart.x + nDragMinDist))
                    && ((ptDragStart.y - nDragMinDist) <= y)
                    && (y <= (ptDragStart.y + nDragMinDist))) )
                {
                    // mouse moved beyond threshhold to start drag
                    ReleaseCapture();
                    KillTimer(hWnd, 1);
                    fPendingDrag = FALSE;

                    // perform the modal drag/drop operation.
                    DoDragAndDrop(GetParent(hWnd), pDropSource);
                }
                break;
            }

            // This is the normal code
            if (sycm.fMouseDn)
            {
                POINT pt;
                UINT chMouseSymbol;

                DOUTL("WM_MOUSEMOVE: mouse is down\n");

                pt.x = LOWORD(lParam);
                pt.y = HIWORD(lParam);


                ClientToScreen(hWnd, (LPPOINT)&pt);

                if (WindowFromPoint(pt) == hWnd)
                {
                    // Kill the out of client are drag timer
                    KillTimer(hWnd, ID_SCROLLTIMER);

                    ScreenToClient(hWnd, (LPPOINT)&pt);
                    //
                    //  Convert back to a 'points'-like thing.
                    //
                    lParam = MAKELONG((WORD)pt.x, (WORD)pt.y);

                    chMouseSymbol = (UINT)ChFromSymLParam(&sycm, lParam);
                    chPos = chMouseSymbol;
                    if(chPos + chSymFirst <= chRangeLast)
                    {
                        chCurrPos = chPos;
                    }
                    else
                    {
                        chPos = chCurrPos;
                    }

                    chMouseSymbol = (UINT)ChFromSymLParam(&sycm, lParam);

                    // disable space display
                    if ( (chMouseSymbol > (UINT)chSymLast) ||
                         (IsAnyListWindow() &&
                          pCode &&
                          (pCode[chMouseSymbol] == (WCHAR)' ')) )
                    {
                        //
                        //  We're outside of current character range (but
                        //  still within the grid).  Restore cursor and
                        //  leave magnified character.
                        //
                        if (sycm.fCursorOff)
                        {
                            sycm.fCursorOff = FALSE;
                            ShowCursor(TRUE);
                        }
                    }
                    else
                    {
                        //
                        //  We're in the grid and within the range of currently
                        //  displayed characters, display magnified character.
                        //
                        DOUTL("WM_MOUSEMOVE: in grid and subrange\n");

                        if (!sycm.fCursorOff)
                        {
                            sycm.fCursorOff = TRUE;
                            ShowCursor(FALSE);
                        }
                        DOUTL("WM_MOUSEMOVE: movsymsel ");
                        DOUTCHN( (UTCHAR)chMouseSymbol );
                        MoveSymbolSel(&sycm, (UTCHAR)chMouseSymbol);
                    }
                }
                else
                {
                    //
                    //  Left grid, leave magnified character and restore
                    //  cursor.
                    //
                    DOUTL("In Drag Scroll\n");
                    if (sycm.fCursorOff)
                    {
                        sycm.fCursorOff = FALSE;
                        ShowCursor(TRUE);
                    }

                    // Here comes the scroll code for scrolling when we are
                    // outside the client area
                    DoDragScroll(hWnd, wParam, lParam);
                }
            }
            else
            {
                MSG   msg;

                //we need to fill out a message structure and pass
                //it to the tooltip with the TTM_RELAYEVENT message

                msg.hwnd    = hWnd;
                msg.message = message;
                msg.wParam  = wParam;
                msg.lParam  = lParam;
                GetCursorPos(&msg.pt);
                msg.time = GetMessageTime();

                SendMessage(hwndTT, TTM_RELAYEVENT, 0, (LPARAM)&msg);
            }

            DOUTL("WM_MOUSEMOVE: Leaving\n");
            break;
        }

        case ( WM_CANCELMODE ) :
        case ( WM_LBUTTONUP )  :
        {
            //ShowWindow(hwndTT, SW_SHOWNA);

            if (sycm.fMouseDn)
            {
                KillTimer(hWnd, ID_SCROLLTIMER);
            }
            sycm.fMouseDn = FALSE;
            ReleaseCapture();

            // This part is for drag and drop
            // Button came up before starting drag so clear flags and timer
            if (fPendingDrag)
            {
                ReleaseCapture();
                KillTimer(hWnd, 1);
                fPendingDrag = FALSE;
                ExitMagnify(hWnd, &sycm);
            }
            break;
        }

        case ( WM_LBUTTONDBLCLK ) :
        {
            UINT chMouseSymbol = (UINT)ChFromSymLParam(&sycm, lParam);

            if (chMouseSymbol <= chRangeLast &&
                pCode[chMouseSymbol] &&
                pCode[chMouseSymbol] != (WCHAR)' ' )
            {
                WCHAR wc = (WCHAR)pCode[sycm.chCurr];
                ConvertAnsifontToUnicode(hWnd, (char*)&pCode[sycm.chCurr], &wc);
#ifndef DISABLE_RICHEDIT
                SetRichEditFont(hwndDialog, ID_STRING, sycm.hFont);
                //richedit screws up symbol font display
                //we have to convert to ansi to display symbol font
                if (gFontType & SYMBOL_FONTTYPE)
                {
                  if ((wc >= 0xf000) && (wc <= 0xf0ff))
                    wc = (WCHAR)(BYTE)pCode[sycm.chCurr];
                }
                SendDlgItemMessage(hwndDialog, ID_STRING, WM_CHAR, wc, 0L);
                CopyTextToClipboard(hwndDialog);
#else
                SendDlgItemMessage(hWnd, IDC_EDIT, WM_SETFONT, (WPARAM)(sycm.hFont), MAKELPARAM(true,0));
                SendDlgItemMessage(hwndDialog, IDC_EDIT, WM_CHAR, wc, 0L);
#endif
            }
            if(sycm.fMagnify)
            {
               ExitMagnify(hwndCharGrid, &sycm);
            }
            break;
        }

        case ( WM_GETDLGCODE ) :
        {
            //
            //  Necessary to obtain arrow and tab messages.
            //
            return (DLGC_WANTARROWS | DLGC_WANTCHARS);
            break;
        }

        case ( WM_KEYDOWN ) :
        {
            UTCHAR chNew = sycm.chCurr;
            INT    cchMoved;

            fScrolled = FALSE;

            // If hWnd is mirrored swap left and right keys.
            if (GetWindowLongPtr(hWnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) {
                if (wParam == VK_LEFT) {
                    wParam = VK_RIGHT;
                } else if (wParam == VK_RIGHT) {
                    wParam = VK_LEFT;
                }
            }

            switch (wParam)
            {
                case ( VK_F6 ) :
                {
                    if(ghwndList)
                        SetFocus(ghwndList);
                    else if(ghwndGrid)
                        SetFocus(ghwndGrid);
                    return 0L;
                }

                case ( VK_LEFT ) :
                {
                    if(chNew == 0 || --chNew >= chSymFirst)
                        break;

                    SendMessage(hWnd, WM_KEYDOWN, VK_UP, 0L);

                    while(pCode[chNew] == L' ')
                        --chNew;

                    sycm.chCurr = chNew;
                    break;
                }

                case ( VK_UP ) :
                {
                    if ((chNew -  cchSymRow) >= chRangeFirst &&
                        (chNew -= (UTCHAR)cchSymRow) < chSymFirst)
                    {
                        if (!ScrollMap(GetParent(hWnd), -cchSymRow, TRUE))
                            return (0L);

                        while(pCode[chNew] == L' ')
                            --chNew;
                        sycm.chCurr = chNew;
                        RestoreSymMag(hWnd, &sycm);
                        fScrolled = TRUE;
                    }
                    break;
                }

                case ( VK_RIGHT ) :
                {
                    if ((chNew+1) > chRangeLast)
                        break;
                    if (++chNew <= chSymLast && pCode[chNew] != L' ')
                        break;

                    if (!FMagData(&sycm))
                        DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, FALSE, FALSE);

                    sycm.chCurr = ((chNew-1)/cchSymRow)*cchSymRow;
                    SendMessage(hWnd, WM_KEYDOWN, VK_DOWN, 0L);
                    return (0L);
                }

                case ( VK_DOWN ) :
                {
                                                                          if ((chNew +  cchSymRow) <= chRangeLast &&
                        (chNew += (UTCHAR)cchSymRow) <= chSymLast)
                              break;

                    if (!ScrollMap(GetParent(hWnd), cchSymRow, TRUE))
                        return (0L);

                    while(pCode[chNew] == L' ')
                        --chNew;
                    sycm.chCurr = chNew;
                    RestoreSymMag(hWnd, &sycm);
                    fScrolled = TRUE;
                    break;
                }

                case ( VK_NEXT ) :
                {
                    if(chRangeLast <= chSymLast)
                    {
                        while(chNew+cchSymRow <= chRangeLast)
                            chNew += (UTCHAR)cchSymRow;
                        break;
                    }

                    if((cchMoved =
                        ScrollMapPage(GetParent(hWnd), FALSE, TRUE)) == 0)
                    {
                        ValidateRect(hWnd, NULL);
                        return (0L);
                    }
                    //
                    //  We scrolled the map!  Bump the char so it is
                    //  still in the window.
                    //
                    RestoreSymMag(hWnd, &sycm);
                    fScrolled = TRUE;
                    chNew += (UTCHAR)cchMoved;
                    if(chNew > chRangeLast)
                       sycm.chCurr = chNew = chNew - cchSymRow;

                    while(pCode[chNew] == L' ')
                        --chNew;

                    sycm.chCurr = chNew;
                    break;
                }

                case ( VK_PRIOR ) :
                {
                    if(chSymLast < cchSymRow*cchSymCol)
                    {
                        while(chNew-cchSymRow >= 0)
                            chNew -= (UTCHAR)cchSymRow;
                        break;
                    }

                    if ((cchMoved =
                        ScrollMapPage( GetParent(hWnd), TRUE, TRUE )) == 0)
                    {
                        ValidateRect(hWnd, NULL);
                        return (0L);
                    }

                    //
                    //  We scrolled the map!  Bump the char so it is
                    //  still in the window.
                    //
                    RestoreSymMag(hWnd, &sycm);
                    fScrolled = TRUE;
                    chNew += (UTCHAR)cchMoved;

                    while(pCode[chNew] == L' ')
                        --chNew;

                    sycm.chCurr = chNew;
                    break;
                }

                case ( VK_HOME ) :
                {
                    if(GetAsyncKeyState(VK_CONTROL))
                    {
                        chNew = 0;
                        if(chSymLast > cchSymRow*cchSymCol)
                        {
                            sycm.chCurr = 0;
                            ScrollMap(GetParent(hWnd),
                                      cchSymRow*cchSymCol -chSymLast - 1,
                                      TRUE);
                            RestoreSymMag(hWnd, &sycm);
                            fScrolled = TRUE;
                        }
                    }
                    else
                    {
                        chNew = (chNew/cchSymRow)*cchSymRow;
                    }
                    break;
                }

                case ( VK_END ) :
                {
                    if(GetAsyncKeyState(VK_CONTROL))
                    {
                        chNew = chRangeLast;
                        if(chSymLast < chRangeLast)
                        {
                            int iTemp = ((chRangeLast + cchSymRow)/cchSymRow)
                                        *cchSymRow - chSymLast - 1;

                            ScrollMap(GetParent(hWnd), iTemp, TRUE);
                            RestoreSymMag(hWnd, &sycm);
                            sycm.chCurr = chRangeLast;
                            fScrolled = TRUE;
                        }
                    }
                    else
                    {
                        chNew = ((chNew+cchSymRow)/cchSymRow)*cchSymRow-1;

                        while(pCode[chNew] == L' ')
                            --chNew;

                        if(chNew > chRangeLast)
                            chNew = chRangeLast;
                    }
                    break;
                }

                            default :
                {
                   return (0L);
                }
            }

            if (!FMagData(&sycm))
                DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, FALSE, FALSE);

            while ((pCode[chNew] == L' ') && (chNew > chSymFirst))
                --chNew;

            // If scrolled and magnifed draw magnified character
            if ((fScrolled == FALSE) && (sycm.fMagnify == TRUE))
               MoveSymbolSel(&sycm, chNew);
            else
            {
                HDC  hdc;

                // else set focus to true and draw normal character
                BOOL fFocus;
                sycm.fFocusState = TRUE;
                if (fFocus = sycm.fFocusState)
                {
                    sycm.fFocusState = FALSE;
                }

                hdc = GetDC(hwndDialog);
                UpdateKeystrokeText(hdc, chNew, TRUE);
                ReleaseDC(hwndDialog, hdc);

                DrawSymChOutlineHwnd(&sycm, hWnd, chNew, TRUE, fFocus);
                sycm.chCurr = chNew;
            }

                                                {       //#bug 234106 refresh
                                                        HWND hwndCharGridLocal, hwndSB;
                                                        hwndCharGridLocal = GetDlgItem(GetParent(hWnd), ID_CHARGRID);
                                                        hwndSB = GetDlgItem(GetParent(hWnd), ID_MAPSCROLL);
                                                        InvalidateRect(hwndCharGridLocal, NULL, TRUE);
                                                        InvalidateRect(hwndSB, NULL, TRUE);
                                                }

            break;
        }

        case ( WM_CHAR ) :
        {
            WCHAR wch = (WCHAR)wParam;

            if (sycm.fMouseDn)
                break;

        // If space is typed in and user is in Magnify mode exit magnify
        // else enter magnify
            if (wch == ' ')
            {
                if (sycm.fMagnify)
                {
                    ExitMagnify(hwndCharGrid, &sycm);
                }
                else
                {
                    DrawSymChOutlineHwnd(&sycm, hWnd, sycm.chCurr, FALSE, FALSE);
                    MoveSymbolSel(&sycm, (UTCHAR)sycm.chCurr, TRUE);
                }
            }

            break;
        }

        case ( WM_PAINT ) :
        {
            HDC hdc;
            PAINTSTRUCT ps;

            DOUTL("WM_PAINT: In\n");

            hdc = BeginPaint(hWnd, &ps);
            DOUTL("WM_PAINT: drawing map\n");
            DrawSymbolMap(&sycm, hdc);

            if(fScrolled)
            {
               DOUTL("WM_PAINT: drawing scroll\n");
               // Drawing correct outline is handled in DrawSymbolMap so no need
               // to do it again here

                // IF the character is magnified draw magnified character
                if (sycm.fMagnify)
                {
                    MoveSymbolSel(&sycm, sycm.chCurr, TRUE);
                }

                fScrolled = FALSE;
            }
            else
            {
                if (sycm.fMagnify)
                {
                    DOUTL("WM_PAINT: drawing magnify\n");
                    MoveSymbolSel(&sycm, sycm.chCurr, TRUE);
                }
            }

            EndPaint(hWnd, &ps);

            DOUTL("WM_PAINT: Leaving\n");
            return (TRUE);
        }

        case ( WM_NOTIFY ) :
        {
            // Tooltip sends a notification to get text to be displayed

            LPTOOLTIPTEXT lptt = (LPTOOLTIPTEXT)lParam;
            POINT pt;
            WCHAR wc;
            INT   x, y, ch;
            DWORD dwPos = GetMessagePos();
            char  szMessageA[MAX_PATH*2];
            WCHAR szMessageW[MAX_PATH];
            LONG  lCodePage;
            HRESULT hresult;

            if(pCode == NULL || *pCode == 0) break;

            switch (lptt->hdr.code)
            {
                case TTN_NEEDTEXT:
                {
                    pt.x = LOWORD(dwPos);
                    pt.y = HIWORD(dwPos);

                    // Convert the point from screen coordinates to our
                    // window coordinates
                    MapWindowPoints(HWND_DESKTOP, hWnd, &pt, 1);

                    // Now given the point find which rectangle it lies in
                    x = pt.x / sycm.dxpBox;
                    y = pt.y / sycm.dypBox;

                    ch = chSymFirst + y*cchSymRow + x;

                    // If in magnify mode and mouse is in magnify rect then show
                    // tip for the magnified character
                    if (sycm.fMagnify == TRUE)
                    {
                        RECT  rcMagnify;
                        POINT ptLeftTop;

                        ptLeftTop.x = sycm.xpMagCurr;
                        ptLeftTop.y = sycm.ypMagCurr;

                        MapWindowPoints(hwndDialog, hwndCharGrid, &ptLeftTop, 1);

                        rcMagnify.left   = ptLeftTop.x;
                        rcMagnify.right  = rcMagnify.left + sycm.dxpMag;
                        rcMagnify.top    = ptLeftTop.y;
                        rcMagnify.bottom = rcMagnify.top + sycm.dypMag;

                        if (PtInRect(&rcMagnify, pt))
                        {
                            ch = sycm.chCurr;
                        }
                    }

                    if ((ch > chSymLast) || (ch > chRangeLast))
                        break;

                    wc = pCode[ch];

                    // Dont show tips for filler characters
                    if (wc == 0x20)
                        break;

                    if(gFontType & SYMBOL_FONTTYPE)
                    {
                        LoadString(hInst, IDS_SYMBOLSET, szMessageW, MAX_PATH);
                       
                        hresult = StringCchPrintf(szTipText , sizeof(szTipText)/sizeof(szTipText[0]),  TEXT("%s : 0x%2X"),szMessageW, wc);
                        if (!SUCCEEDED(hresult))
                        {
                           return FALSE;
                        }
                    }
                    else
                    {
                        GetUName(wc, szMessageW);
                        /*
                        MultiByteToWideChar(
                            CP_ACP, 0,
                            szMessageA, -1,
                            szMessageW, MAX_PATH);*/

                        if((lCodePage = CodePage_GetCurCodePageVal())
                            != UNICODE_CODEPAGE)
                        {
                            BYTE mb[2];
                            WORD wCharCode;

                            if (WideCharToMultiByte(
                                lCodePage, WC_NO_BEST_FIT_CHARS,
                                &wc, 1,
                                (char*)mb, 2,
                                NULL, NULL ) == 1)
                            {
                                wCharCode = mb[0];     // single-byte
                            }
                            else
                            {
                                wCharCode = (mb[0]<<8) | mb[1];
                            }

                            hresult = StringCchPrintf(szTipText, sizeof(szTipText)/sizeof(szTipText[0]) , TEXT("U+%04X (0x%2X): %s"),
                                     wc, wCharCode, szMessageW);

                            if (!SUCCEEDED(hresult))
                            {   
                                return FALSE;
                            }
                        }
                        else
                        {
                            
                            
                            hresult = StringCchPrintf(szTipText, sizeof(szTipText)/sizeof(szTipText[0]) , TEXT("U+%04X: %s"),
                                     wc, szMessageW);

                            if (!SUCCEEDED(hresult))
                            {   
                                return FALSE;
                            }

                        }
                    }
                    lstrcpyn(lptt->szText, szTipText, 80);
                }

                default:
                    break;
            }
        }
          break;

        case ( WM_INPUTLANGCHANGE ):
        {
            WCHAR wcBuf[8];
            UINT  cp;

            if(GetLocaleInfo(LOWORD(lParam), LOCALE_IDEFAULTANSICODEPAGE, wcBuf, 8))
            {
                cp = _wtol(wcBuf);
                if(gKBD_CP != cp)
                {
                    gKBD_CP = cp;
                    HDC hDC = GetDC(hwndDialog);
                    UpdateKeystrokeText(hDC, sycm.chCurr, TRUE);
                    ReleaseDC(hwndDialog, hDC);
                }
            }
            return TRUE;
        }

              default :
        {
            return (DefWindowProc(hWnd, message, wParam, lParam));
        }

    }
    return (0L);
}

///////////////////////////////////////////////////////////////////////////
//
// When enumerate Bitmap font, Symbol font, OEM font, we got the ANSI code
// points instead of Unicode. So when these fonts are going to be displayed
// we have to convert them to Unicode. (We can use TextOutA, but in
// SendDlgItemMessage, it has to be Unicode.)
//
// We can not convert it using the charset information given by the LOGFONT
// during font enumeration. Those charset information are not accurate. For
// example, in Thai system, "Small fonts" contains Thai characters, but the
// CharSet in LOGFONT is 0. However, the CharSet information in TextMetrics
// is correct.
////////////////////////////////////////////////////////////////////////////
DWORD GetCurFontCharSet(HWND hWnd)
{
  DWORD cs;
  HDC hdc;
  HFONT hfOld;
  TEXTMETRIC tm;

  hdc = GetDC(hWnd);
  hfOld = (HFONT)SelectObject(hdc, sycm.hFont);
  GetTextMetrics(hdc, &tm);
  cs = MAKELONG(tm.tmCharSet, 0);
  SelectObject(hdc, hfOld);
  ReleaseDC(hWnd, hdc);
  return cs;
}

int ConvertAnsifontToUnicode(HWND hWnd, char* mb, WCHAR* wc)
{
  CHARSETINFO csi;
  WORD cp = CP_ACP;
  int  ret = 1;
  DWORD cs;

  if (gFontType & SYMBOL_FONTTYPE)
  {
    cs = GetCurFontCharSet(hWnd);
    if (TranslateCharsetInfo((DWORD *)IntToPtr(cs), &csi, TCI_SRCCHARSET))
      cp = (WORD)(csi.ciACP);
    if ((ret = MultiByteToWideChar(cp, 0, mb, 1, wc, 1)) != 1)
      if ((ret = MultiByteToWideChar(CP_ACP, 0, mb, 1, wc, 1)) != 1)
        *wc = (WCHAR)(BYTE)(*mb);
  }
  return ret;
}

int ConvertUnicodeToAnsiFont(HWND hWnd, WCHAR* wc, char* mb)
{
  CHARSETINFO csi;
  WORD cp = CP_ACP;
  int ret = 1;
  DWORD cs;

  cs = GetCurFontCharSet(hWnd);
  if (TranslateCharsetInfo((DWORD *)IntToPtr(cs), &csi, TCI_SRCCHARSET))
    cp = (WORD)(csi.ciACP);
  if ((ret = WideCharToMultiByte(cp, 0, wc, 1, mb, 1, NULL, NULL)) == 0)
    if ((ret = WideCharToMultiByte(CP_ACP, 0, wc, 1, mb, 1, NULL, NULL)) == 0)
      *mb = (char)(BYTE)(*wc);
  return ret;
}

////////////////////////////////////////////////////////////////////////////
//
//  ProcessScrollMsg
//
////////////////////////////////////////////////////////////////////////////

VOID ProcessScrollMsg(
    HWND hwndDlg,
    int nCode,
    int nPos)
{
    UTCHAR chNew = sycm.chCurr;
    HWND hwndGrid = GetDlgItem(hwndDlg, ID_CHARGRID);
    int cchScroll;

    switch( nCode )
    {
        case ( SB_LINEUP ) :
        {
            cchScroll = -cchSymRow;
            break;
        }
        case ( SB_LINEDOWN ) :
        {
            cchScroll = cchSymRow;
            break;
        }
        case ( SB_PAGEUP ) :
        {
            cchScroll = (int)TRUE;
            break;
        }
        case ( SB_PAGEDOWN ) :
        {
            cchScroll = (int)FALSE;
            break;
        }
        case ( SB_THUMBTRACK ) :
        case ( SB_THUMBPOSITION ) :
        {
            cchScroll = (nPos * cchSymRow + chRangeFirst) - chSymFirst;
            break;
        }
        default :
        {
            return;
        }
    }

    if (nCode == SB_PAGEUP || nCode == SB_PAGEDOWN)
    {
        if (!ScrollMapPage(hwndDlg, (BOOL)cchScroll, TRUE))
        {
            return;
        }

        //
        //  ScrollMapPage will do the right thing to sycm.chCurr.
        //
        chNew = sycm.chCurr;
        fScrolled = TRUE;
        while(pCode[chNew] == L' ')
            --chNew;
    }
    else
    {
        if (cchScroll == 0 || !ScrollMap(hwndDlg, cchScroll, TRUE))
        {
            return;
        }

        //
        //  Keep the current symbol inside the window.
        //
        while (chNew > chSymLast)
        {
            chNew -= (UTCHAR)cchSymRow;
        }

        while (chNew < chSymFirst)
        {
            chNew += (UTCHAR)cchSymRow;
        }
        while(pCode[chNew] == L' ')
            --chNew;
    }

    sycm.chCurr = chNew;
    RestoreSymMag(hwndGrid, &sycm);
}

////////////////////////////////////////////////////////////////////////////
//
//  ScrollMapPage
//
//  Scrolls the map up or down by a page.  See ScrollMap().
//
////////////////////////////////////////////////////////////////////////////

INT ScrollMapPage(
    HWND hwndDlg,
    BOOL fUp,
    BOOL fRePaint)
{
    INT cchScroll = cchFullMap;

    if (fUp)
    {
        cchScroll = -cchScroll;
    }

    if ((chSymFirst + cchScroll) < chRangeFirst)
    {
        cchScroll = (chRangeFirst - chSymFirst);
    }
    else if ((chSymLast + cchScroll) > chRangeLast)
    {
        cchScroll = (1+(chRangeLast-chSymLast-1)/cchSymRow)*cchSymRow;
    }

    return (ScrollMap(hwndDlg, cchScroll, fRePaint) ? cchScroll : 0);
}


////////////////////////////////////////////////////////////////////////////
//
//  ScrollMap
//
//  Scrolls the map up or down if there are too many chars to fit in the
//  chargrid.
//
////////////////////////////////////////////////////////////////////////////

BOOL ScrollMap(
    HWND hwndDlg,
    INT cchScroll,
    BOOL fRePaint)
{
    HWND hwndSB, hwndCharGridLocal;
    INT chFirst = chSymFirst + cchScroll;
    INT chLast = chSymLast + cchScroll;
    HDC hdc;

    if ((chFirst < chRangeFirst) || (chLast > chRangeLast + cchSymRow - 1))
    {
        return (FALSE);
    }
    hwndCharGridLocal = GetDlgItem(hwndDlg, ID_CHARGRID);
    hwndSB = GetDlgItem(hwndDlg, ID_MAPSCROLL);
    SetScrollPos(hwndSB, SB_CTL, (chFirst - chRangeFirst) / cchSymRow, TRUE);

    UpdateSymbolRange(hwndDlg, chFirst, chLast);

    if ((hwndDlg != NULL) && ((hdc = GetDC(hwndDlg)) != NULL))
    {
        LPINT lpdxp;
        HFONT hFont;
        UINT ch;

        hFont = (HFONT)SelectObject(hdc, sycm.hFont);
        lpdxp = (LPINT)sycm.rgdxp;

        Font_GetCharWidth32(hdc, chSymFirst, chSymLast, lpdxp,pCode);

        SelectObject(hdc, hFont);

        for (ch = (UINT) chSymFirst; ch <= (UINT) chSymLast; ch++, lpdxp++)
        {
            *lpdxp = (sycm.dxpBox - *lpdxp) / 2;
        }
        ReleaseDC(hwndDlg, hdc);
    }

    if (fRePaint)
    {
        InvalidateRect(hwndSB, NULL, TRUE);
        InvalidateRect(hwndCharGridLocal, NULL, TRUE);
    }

    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  ChFromSymLParam
//
//  Determines the character to select from the mouse position (lParam).
//
////////////////////////////////////////////////////////////////////////////

UINT ChFromSymLParam(
    PSYCM psycm,
    LPARAM lParam)
{
    return (min( cchSymRow - 1,
                 max(0, ((INT)LOWORD(lParam) - 1) / psycm->dxpBox) ) +
            min( cchSymCol - 1,
                 max(0, ((INT)HIWORD(lParam) - 1) / psycm->dypBox) ) *
            cchSymRow + chSymFirst);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawSymChOutlineHwnd
//
//  Gets a DC for hwnd, calls DrawSymChOutline.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSymChOutlineHwnd(
    PSYCM psycm,
    HWND hwnd,
    UTCHAR ch,
    BOOL fVisible,
    BOOL fFocus)
{
    HDC hdc = GetDC(hwnd);

    DrawSymChOutline(psycm, hdc, ch, fVisible, fFocus);
    ReleaseDC(hwnd, hdc);
}


//
// Get physical font dimension from the given logical font.
// This routine may scale down the logical font size to match the best
// possible viewable size of the given font (wchao).
//
BOOL GetViewableFontDimensions (
    HDC             hdc,
    int             dypInch,        // presentation device's logical pixel per inch
    LOGFONT*        plf,            // (in/out) requested logical font
    HFONT*          phFontOld,      // (out) -optional- original font in the dc
    HFONT*          phFontNew,      // (out) new created font
    TEXTMETRIC*     ptm)            // (out) physical dimensions of *phFontNew
{
    if (!phFontNew || !ptm)
        return FALSE;

    LONG    iHeightSave = plf->lfHeight;
    LONG    iDir = plf->lfHeight < 0 ? -1 : 1;
    HFONT   hFont = CreateFontIndirect(plf);
    HFONT   hFontOld = (HFONT)SelectObject(hdc, hFont);

    GetTextMetrics(hdc, ptm);


    // This loop is only needed by bitmap font as it was digitized (either scaling up or down)
    // by GDI to a greater resolution. This makes the character looks chunky (imagine how bad
    // it would be for "Small Fonts" scaled up to 13pt). We scale down the font until it
    // matches screen resolution.

    while (plf->lfHeight && ptm->tmDigitizedAspectY != dypInch)
    {
        plf->lfHeight -= iDir;      // scaling down
        DeleteObject(hFont);
        hFont = CreateFontIndirect(plf);
        SelectObject(hdc, hFont);
        GetTextMetrics(hdc, ptm);
    }

    if (ptm->tmDigitizedAspectY != dypInch || !ptm->tmHeight)
    {
        // If we get here. GDI is really messed up.
        //
        plf->lfHeight = iHeightSave;
        DeleteObject(hFont);
        hFont = CreateFontIndirect(plf);
        SelectObject(hdc, hFont);
        GetTextMetrics(hdc, ptm);
    }

    *phFontNew = hFont;

    if (phFontOld)
        *phFontOld = hFontOld;

    return TRUE;
}



////////////////////////////////////////////////////////////////////////////
//
//  RecalcUCE
//
//  Recalculates fixed character map data (font info, sizes, etc.).
//
////////////////////////////////////////////////////////////////////////////

VOID RecalcUCE(
    HWND hwndDlg,
    PSYCM psycm,
    INT iCombo,
    BOOL fRedraw)
{
    HDC          hdc;
    TEXTMETRIC   tm;
    UINT ch;
    LPINT lpdxp;
    HFONT        hFont;
    LOGFONT      LogFont;
    LONG         iCurSel;
    int          dypInch;

    HRESULT hresult;

    //
    //  Get rid of the old font handles.
    //
    if (hFontClipboard && (hFontClipboard == psycm->hFont))
    {
        fDelClipboardFont = TRUE;
    }
    if (psycm->hFont && (hFontClipboard != psycm->hFont))
    {
        DeleteObject(psycm->hFont);
    }
    if (psycm->hFontMag)
    {
        DeleteObject(psycm->hFontMag);
    }

    hdc = GetDC(hwndCharGrid);

    //  Get device y logical pixel per inch
    dypInch = GetDeviceCaps(hdc, LOGPIXELSY);

    //
    //  Set these to zero.
    //
    LogFont.lfWidth = LogFont.lfEscapement = LogFont.lfOrientation =
                      LogFont.lfWeight = 0;
    LogFont.lfItalic = LogFont.lfUnderline = LogFont.lfStrikeOut =
                       LogFont.lfOutPrecision = LogFont.lfClipPrecision =
                       LogFont.lfQuality = LogFont.lfPitchAndFamily = 0;

    //
    //  Let the facename and size define the font.
    //
    //  LogFont.lfCharSet = DEFAULT_CHARSET;

    //  Work around the GDI bug that assumes the font's default charset
    //  is always the system default locale.
    //
    LogFont.lfCharSet = Font_pList[iCombo].CharSet;

    //
    //  Get the facename from the combo box.
    //
    // if(lstrcmpi(Font_pList[iCombo].szFaceName, L"SystemDefaultEUDCFont") == 0)
    if(CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, Font_pList[iCombo].szFaceName, -1, L"SystemDefaultEUDCFont", -1) == CSTR_EQUAL)
    {
      hresult = StringCchCopy(LogFont.lfFaceName , sizeof(LogFont.lfFaceName)/sizeof(LogFont.lfFaceName[0]),  _T("MS Sans Serif"));
      if (!SUCCEEDED(hresult))
      {
         return;
      }
    }
    else
    {
      hresult = StringCchCopy(LogFont.lfFaceName , sizeof(LogFont.lfFaceName)/sizeof(LogFont.lfFaceName[0]),  Font_pList[iCombo].szFaceName);
      if (!SUCCEEDED(hresult))
      {
         return;
      }
    }

    //
    //  Enable Block listbox and set defaults appropriately.
    //
    iCurSel = (LONG)SendDlgItemMessage( hwndDlg,
                                        ID_UNICODESUBSET,
                                        CB_GETCURSEL,
                                        0,
                                        0L );
    UpdateSymbolSelection( hwndDlg, TRUE);

    //
    //  Create the magnify font.
    //
    LogFont.lfHeight = psycm->dypMag - 5;        // Allow for whitespace.
    psycm->hFontMag = CreateFontIndirect(&LogFont);


    //
    //  Create the grid font
    //
    if (PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())) == LANG_CHINESE)
    {
        LogFont.lfHeight = 16;
    }
    else
    {
        LogFont.lfHeight = psycm->dypBox - 6;    // 3-pixel top/bottom barring.
    }


    GetViewableFontDimensions(hdc, dypInch, &LogFont, &hFont, &psycm->hFont, &tm);


    //  Font with significant descent-ascent (round) ratio
    //  e.g. most Thai fonts, Traditional Arabic.

    if (tm.tmAscent && MulDiv(tm.tmDescent, 10, tm.tmAscent) > 4)
    {
        DeleteObject(psycm->hFont);
        LogFont.lfHeight = -LogFont.lfHeight;       // request it as character height
        GetViewableFontDimensions(hdc, dypInch, &LogFont, NULL, &psycm->hFont, &tm);
        LogFont.lfHeight = tm.tmHeight;             // now take the actual cell height
    }


    //  Maximum avg width allowed inside a grid box
    LONG    iMaxAveBoxWidth = MulDiv(tm.tmHeight, psycm->dxpBox, psycm->dypBox) - 2;   // 1-pixel side barrings
    LONG    tmHeightLast = tm.tmHeight;


    //  Narrow down allowance for non-symbol proportional font
    if (tm.tmCharSet != SYMBOL_CHARSET &&
        tm.tmAveCharWidth != tm.tmMaxCharWidth)
        iMaxAveBoxWidth = MulDiv(iMaxAveBoxWidth, 70, 100); // 70% looks good for most fonts specially FE's.


    //  Try & Fit the font in grid box
    while (tm.tmAveCharWidth > iMaxAveBoxWidth)
    {
        DeleteObject(psycm->hFont);
        LogFont.lfHeight--;
        GetViewableFontDimensions(hdc, dypInch, &LogFont, NULL, &psycm->hFont, &tm);

        // Nothing better, let's get out of here.
        if (tm.tmHeight == tmHeightLast)
            break;

        tmHeightLast = tm.tmHeight;
    }

    psycm->xpCh = 2;

    psycm->ypCh = (psycm->dypBox - tm.tmHeight + 1) / 2;    // y offset display position in a grid box

    lpdxp = (LPINT) psycm->rgdxp;

    Font_GetCharWidth32(hdc, chSymFirst, chSymLast, lpdxp,pCode);

    SelectObject(hdc, hFont);

    for (ch = (UINT) chSymFirst; ch <= (UINT) chSymLast; ch++, lpdxp++)
    {
        *lpdxp = (psycm->dxpBox - *lpdxp) / 2;
    }

    ReleaseDC(hwndCharGrid, hdc);

    psycm->xpMagCurr = 0;              // No magnification data

    // Set the tooltip window for the character grid
    ResizeTipsArea(hwndCharGrid, &sycm);

    if (fRedraw)
    {
        InvalidateRect(hwndCharGrid, NULL, TRUE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawSymbolMap
//
//  Draws all of the pieces of the symbol character map.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSymbolMap(
    PSYCM psycm,
    HDC hdc)
{
    BOOL fFocus;

    DrawSymbolGrid(psycm, hdc);
    DrawSymbolChars(psycm, hdc);
    //
    //  We need to force the focus rect to paint if we have the focus
    //  since the old focus rect has been drawn over already.
    //
    if (fFocus = psycm->fFocusState)
    {
        psycm->fFocusState = FALSE;
    }

    if (psycm->fMagnify == FALSE)
    {
        DrawSymChOutline(psycm, hdc, psycm->chCurr, TRUE, fFocus);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  DrawSymbolGrid
//
//  Draws the symbol character map grid.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSymbolGrid(
    PSYCM psycm,
    HDC hdc)

{
    INT cli;                // count of lines
    INT xp, yp;
    INT dxpBox = psycm->dxpBox;
    INT dypBox = psycm->dypBox;
    HPEN hpenOld;
    INT xpos, ypos;

    hpenOld = (HPEN) SelectObject(hdc, CreatePen(PS_SOLID,
                                                 1,
                                                 GetSysColor(COLOR_WINDOWFRAME)));
    //
    //  Draw horizontal lines.
    //
    xp = psycm->dxpCM + 1;
    yp = 1;
    ypos = 0;
    cli = cchSymCol+1;
    while (cli--)
    {
        MoveToEx(hdc, 1, yp, NULL);
        LineTo(hdc, xp, yp);
        yp += dypBox;
        ypos += 1;
     }

    //
    //  Draw vertical lines.
    //
    yp = psycm->dypCM;
    xp = 1;
    xpos = 0;
    cli = cchSymRow+1;
    while (cli--)
    {
        MoveToEx(hdc, xp, 1, NULL);
        LineTo(hdc, xp, yp);
        xp += dxpBox;
        xpos += 1;
    }

    DeleteObject(SelectObject(hdc, hpenOld));
}

////////////////////////////////////////////////////////////////////////////
//
//  DrawSymbolChars
//
//  Draws the symbol character map.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSymbolChars(
    PSYCM psycm,
    HDC hdc)
{
    INT    dxpBox  = psycm->dxpBox;
    INT    dypBox  = psycm->dypBox;

    INT    cch;
    INT    x, y;
    INT    yp;
    TCHAR   ch;

    HFONT  hFontOld;
    RECT   rect;
    LPRECT lprect = (LPRECT) &rect;
    LPINT lpdxp;

    if ((pCode == NULL) || (*pCode == '\0'))
    {
        return;
    }

    //
    // Setup the font and colors.
    //
    hFontOld = (HFONT) SelectObject(hdc, psycm->hFont);
    SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
    SetBkMode(hdc, OPAQUE);

    //
    // Draw characters.
    //
    cch = 1;
    ch = chSymFirst;

    lpdxp = (LPINT) psycm->rgdxp;

    rect.top = 2;
    yp = psycm->ypCh;
    rect.bottom = rect.top + dypBox - 1;

    for (y = 0; y++ < cchSymCol;)
    {
        rect.left  = psycm->xpCh;
        rect.right = rect.left + dxpBox - 1;
        for (x = 0; (x++ < cchSymRow) && (ch <= chSymLast);)
        {
          WCHAR wc = pCode[ch];
          ConvertAnsifontToUnicode(hwndCharGrid, (char*)&pCode[ch], &wc);
          ExtTextOutW( hdc,
                       rect.left + (*lpdxp++),
                       yp,
                       ETO_OPAQUE | ETO_CLIPPED,
                       lprect,
                       &wc,
                       1,
                       NULL );
/*
// Unify display using ExtTextOutW
            if(gFontType & SYMBOL_FONTTYPE)
            {
                char mb = (char)pCode[ch];
                ExtTextOutA( hdc,
                             rect.left + (*lpdxp++),
                             yp,
                             ETO_OPAQUE | ETO_CLIPPED,
                             lprect,
                             &mb,
                             1,
                             NULL );
            }
            else if(gFontType & OEM_FONTTYPE)
            {
                char mb;
                WideCharToMultiByte(CP_OEMCP, WC_NO_BEST_FIT_CHARS,
                    &pCode[ch], 1, &mb, 1, NULL, NULL);
                ExtTextOutA( hdc,
                             rect.left + (*lpdxp++),
                             yp,
                             ETO_OPAQUE | ETO_CLIPPED,
                             lprect,
                             &mb,
                             1,
                             NULL );
            }
            else
            {
                ExtTextOutW( hdc,
                             rect.left + (*lpdxp++),
                             yp,
                             ETO_OPAQUE | ETO_CLIPPED,
                             lprect,
                             &(pCode[ch]),
                             1,
                             NULL );
            }
*/
           ch++;
           if(ch > chRangeLast)
           {
              return;
           }
           rect.left  += dxpBox;
           rect.right += dxpBox;
        }
        yp += dypBox;
        rect.top += dypBox;
        rect.bottom += dypBox;
    }

    SelectObject(hdc, hFontOld);
}

////////////////////////////////////////////////////////////////////////////
//
//  DrawSymChOutline
//
//  Draws an outline around the symbol in the character map.  If fVisible,
//  then it draws the outline, otherwise it erases it.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSymChOutline(
    PSYCM psycm,
    HDC hdc,
    UTCHAR ch,
    BOOL fVisible,
    BOOL fFocus)
{
    HBRUSH hbrOld;
    RECT rc;
    INT dxpBox = psycm->dxpBox;
    INT dypBox = psycm->dypBox;

    hbrOld = (HBRUSH)SelectObject( hdc,
                           CreateSolidBrush(GetSysColor( fVisible
                                                           ? COLOR_WINDOWFRAME
                                                           : COLOR_WINDOW )) );
    ch -= chSymFirst;

    rc.left   = (ch % cchSymRow) * dxpBox + 2;
    rc.right  = rc.left + dxpBox - 1;
    rc.top    = (ch / cchSymRow) * dypBox + 2;
    rc.bottom = rc.top  + dypBox - 1;

    //
    //  Draw selection rectangle.
    //
    PatBlt(hdc, rc.left,      rc.top - 2,    dxpBox - 1, 1,          PATCOPY);
    PatBlt(hdc, rc.left,      rc.bottom + 1, dxpBox - 1, 1,          PATCOPY);
    PatBlt(hdc, rc.left - 2,  rc.top,        1,          dypBox - 1, PATCOPY);
    PatBlt(hdc, rc.right + 1, rc.top,        1,          dypBox - 1, PATCOPY);

    DeleteObject(SelectObject(hdc, GetStockObject(NULL_BRUSH)));

    //
    //  Deal with the focus rectangle.
    //
    if (fFocus != psycm->fFocusState)
    {
        DrawFocusRect(hdc, &rc);
        psycm->fFocusState = fFocus;
    }

    SelectObject(hdc, hbrOld);
}

////////////////////////////////////////////////////////////////////////////
//
//  MoveSymbolSel
//
//  Changes the current symbol selection.  Handles drawing of magnified
//  characters.
//
////////////////////////////////////////////////////////////////////////////

VOID MoveSymbolSel(
    PSYCM psycm,
    UTCHAR chNew,
    BOOL fRepaint)
{
    HDC hdc;
    HDC hdcMag = psycm->hdcMag;
    RECT rc;
    HFONT hFontOld;
    HFONT hFontMag;                    // old font in memory dc
    HPEN hpenOld;

    UTCHAR chNorm = chNew - chSymFirst + cchSymRow;

    INT dxpMag = psycm->dxpMag;        // for quick reference
    INT dypMag = psycm->dypMag;
    INT ypMemSrc  = psycm->ypDest;
    INT ypMemDest = ypMemSrc ^ dypMag;
    INT xpCurr  = psycm->xpMagCurr;
    INT ypCurr  = psycm->ypMagCurr;
    INT xpNew   = psycm->xpCM + (psycm->dxpBox *  (chNorm % cchSymRow));
    INT ypNew   = psycm->ypCM + (psycm->dypBox * ((chNorm / cchSymRow) - 1));
    INT dxpCh;  // width of extra character space (used to center char in box)
    INT dypCh;
    SIZE sz;

    DOUTL("MoveSymbolSel: In\n");

    if(chNew > chRangeLast)
    {
        return;
    }

    if ((chNew == (UTCHAR)psycm->chCurr) && FMagData(psycm)
        && (fRepaint == FALSE))
    {
        DOUTL("MoveSymbolSel: ch == cur && fMag... exiting\n");
        return;
    }

    hdc = GetDC(hwndDialog);

    //
    //  Setup the magnified font character.
    //
    hFontMag = (HFONT)SelectObject(hdcMag, psycm->hFontMag);

    if (pCode != NULL   &&  chNew <= chRangeLast) {
        GetTextExtentPointW(hdcMag, &pCode[chNew], 1, &sz);
    }

    if (PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale())) == LANG_CHINESE)
    {
        dxpCh = (dxpMag - (INT)sz.cx) / 2 - 2;
        dypCh = (dypMag - (INT)sz.cy) / 2 - 2;
    }
    else
    {
        dxpCh = (dxpMag - (INT)sz.cx) / 2 - 1;
        dypCh = (dypMag - (INT)sz.cy) / 2 - 1;
    }
    hpenOld = (HPEN)SelectObject(hdc, CreatePen( PS_SOLID,
                                           1,
                                           GetSysColor(COLOR_WINDOWFRAME) ));
    hFontOld = (HFONT)SelectObject(hdc, psycm->hFontMag);

    //
    //  Copy screen data to offscreen bitmap.
    //
    BitBlt(hdcMag, 0, ypMemDest, dxpMag, dypMag, hdc, xpNew, ypNew, SRCCOPY);

    //
    //  Setup DC.
    //
    SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
    SetBkMode(hdc, OPAQUE);


    if (FMagData(psycm))
    {
        INT xpT  = xpNew - xpCurr;     // point of overlap in offscreen data
        INT ypT  = ypNew - ypCurr;
        INT dxpT = dxpMag - abs(xpT);  // size of overlap
        INT dypT = dypMag - abs(ypT);


        DOUTL("MoveSymbolSel: FMagData\n");

        if ((dxpT > 0) && (dypT > 0))
        {
            INT xpTmax,  ypTmax;   // max(0, xpT);
            INT xpTmin,  ypTmin;   // min(0, xpT);
            INT xpTnmin, ypTnmin;  // min(0, -xpT);

            DOUTL("MoveSymbolSel: dxpT > 0 && dypT > 0\n");

            if (xpT < 0)
            {
                xpTnmin = - (xpTmin = xpT);
                xpTmax  = 0;
            }
            else
            {
                xpTmax  = xpT;
                xpTnmin = xpTmin = 0;
            }
            if (ypT < 0)
            {
                ypTnmin = - (ypTmin = ypT);
                ypTmax  = 0;
            }
            else
            {
                ypTmax  = ypT;
                ypTnmin = ypTmin = 0;
            }

            rc.left  = xpTmax;
            rc.right = xpTmin + dxpMag;
            rc.top   = ypTmax + ypMemSrc;
            rc.bottom= ypTmin + dypMag + ypMemSrc;

            //
            //  Copy overlapping offscreen data.
            //
            BitBlt( hdcMag,
                    xpTnmin,
                    ypTnmin + ypMemDest,
                    dxpT,
                    dypT,
                    hdcMag,
                    xpTmax,
                    ypTmax  + ypMemSrc,
                    SRCCOPY );

            //
            //  Print part of char over old screen data.
            //
            WCHAR wc = pCode[chNew];
//            ConvertAnsifontToUnicode(hwndDialog, psycm->hFontMag, (char*)&pCode[chNew], &wc);
            ConvertAnsifontToUnicode(hwndDialog, (char*)&pCode[chNew], &wc);
            ExtTextOutW( hdcMag,
                         xpT + dxpCh,
                         ypT + dypCh + ypMemSrc,
                         ETO_OPAQUE | ETO_CLIPPED,
                         (LPRECT)&rc,
                         &wc,
                         1,
                         NULL );

        }
        //
        //  Restore old screen data.
        //
        BitBlt(hdc, xpCurr, ypCurr, dxpMag, dypMag, hdcMag, 0, ypMemSrc, SRCCOPY);
    }

    rc.right  = (psycm->xpMagCurr = rc.left = xpNew) + dxpMag - 2;
    rc.bottom = (psycm->ypMagCurr = rc.top  = ypNew) + dypMag - 2;

    //
    //  The rectangle.
    //
    MoveToEx(hdc, rc.left, rc.top, NULL);
    LineTo(hdc, rc.left, rc.bottom - 1);
    LineTo(hdc, rc.right - 1, rc.bottom - 1);
    LineTo(hdc, rc.right - 1, rc.top);
    LineTo(hdc, rc.left, rc.top);

    //
    //  The shadow.
    //
    MoveToEx(hdc, rc.right, rc.top + 1, NULL);
    LineTo(hdc, rc.right, rc.bottom);
    LineTo(hdc, rc.left, rc.bottom);
    MoveToEx(hdc, rc.right + 1, rc.top + 2, NULL);
    LineTo(hdc, rc.right + 1, rc.bottom + 1);
    LineTo(hdc, rc.left + 1, rc.bottom + 1);

    rc.left++;
    rc.top++;
    rc.right--;
    rc.bottom--;

    //
    //  Draw magnified character on screen.
    //
    WCHAR wc = pCode[chNew];
    ConvertAnsifontToUnicode(hwndCharGrid, (char*)&pCode[chNew], &wc);
    ExtTextOutW( hdc,
                 xpNew + dxpCh,
                 ypNew + dypCh,
                 ETO_OPAQUE | ETO_CLIPPED,
                 (LPRECT)&rc,
                 &(wc),
                 1,
                 NULL );

    psycm->ypDest = ypMemDest;

    DeleteObject(SelectObject(hdc, hpenOld));
    SelectObject(hdc, hFontOld);
    SelectObject(hdcMag, hFontMag);

    UpdateKeystrokeText(hdc, chNew, TRUE);

    ReleaseDC(hwndDialog, hdc);

    psycm->chCurr = chNew;
    psycm->fMagnify = TRUE;
    DOUTL("MoveSymbolSel: Leaving\n");
}

////////////////////////////////////////////////////////////////////////////
//
//  RestoreSymMag
//
//  Restores the screen data under the magnifier.
//
////////////////////////////////////////////////////////////////////////////

VOID RestoreSymMag(
    HWND  hWndGrid,
    PSYCM psycm)
{
    if (FMagData(psycm))
    {
        HDC hdc = GetDC(hwndDialog);

        // Does not overwrite scroll bar
        BitBlt( hdc,
                psycm->xpMagCurr,
                psycm->ypMagCurr,
                psycm->dxpMag,
                psycm->dypMag,
                psycm->hdcMag,
                0,
                psycm->ypDest,
                SRCCOPY );

        ReleaseDC(hwndDialog, hdc);

        psycm->xpMagCurr = 0;     // flag - no data offscreen (see FMagData)
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  GetEditText
//
//  Returns HANDLE containing the text in the edit control.
//
//  NOTE: Caller is responsible for freeing this handle!
//
////////////////////////////////////////////////////////////////////////////

HANDLE GetEditText(
    HWND hwndDlg)
{
    INT cchText;
    HWND hwndEditCtl;
    HANDLE hmem;
    LPTSTR lpstrText;
    DWORD dwSel;

#ifndef DISABLE_RICHEDIT
    hwndEditCtl = GetDlgItem(hwndDlg, ID_STRING);
#else
    hwndEditCtl = GetDlgItem(hwndDlg, IDC_EDIT);
#endif
    cchText = GetWindowTextLength(hwndEditCtl);

    hmem = GlobalAlloc(0, CTOB((cchText + 1)));

    if (hmem) {
        lpstrText = (LPTSTR)GlobalLock(hmem);
    
        cchText = GetWindowText(hwndEditCtl, lpstrText, cchText+1);
    
        dwSel = (DWORD)SendMessage(hwndEditCtl, EM_GETSEL, 0, 0L);
    
        if (LOWORD(dwSel) != HIWORD(dwSel))
        {
            //
            //  If there is a selection, then only get the selected text.
            //
            *(lpstrText + HIWORD(dwSel)) = TEXT('\0');
            
            HRESULT hresult = StringCchCopy(lpstrText , (cchText+1)*sizeof(TCHAR),  lpstrText + LOWORD(dwSel));
            if (!SUCCEEDED(hresult))
            {
               return FALSE;
            }
        }
    
        GlobalUnlock(hmem);
    
        if (cchText == 0)
        {
            hmem = GlobalFree(hmem);
        }
    }

    return (hmem);
}

////////////////////////////////////////////////////////////////////////////
//
//  PointsToHeight
//
//  Calculates the height in pixels of the specified point size for the
//  current display.
//
////////////////////////////////////////////////////////////////////////////

INT PointsToHeight(
    INT iPoints)
{
    HDC hdc;
    INT iHeight;

    hdc = GetDC(HWND_DESKTOP);
    iHeight = MulDiv(iPoints, GetDeviceCaps(hdc, LOGPIXELSY), 72);
    ReleaseDC(HWND_DESKTOP, hdc);
    return (iHeight);
}

////////////////////////////////////////////////////////////////////////////
//
//  UpdateKeystrokeText
//
//  Calculates and updates the text string displayed in the Keystroke
//  field of the status bar.  It repaints the status field if fRedraw is
//  TRUE.
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateKeystrokeText(
    HDC hdc,
    UTCHAR chNew,
    BOOL fRedraw)
{
    HRESULT hresult;

    if (!pCode || *pCode == '\0')
    {
       LoadString(hInst,
                  IDS_NOCHARFOUND,
                  szKeystrokeText,
                  sizeof(szKeystrokeText)/sizeof(TCHAR));
    }
    else
    {
        char  szMessageA[MAX_PATH*2];
        WCHAR szMessageW[MAX_PATH];
        LONG  lCodePage;
        BYTE  mb[2];
        WORD  wCharCode;

        szAlt[0] = 0;

        if(gFontType & SYMBOL_FONTTYPE)
        {
           LoadString(hInst, IDS_SYMBOLSET, szMessageW, MAX_PATH);
           
           hresult = StringCchPrintf(szKeystrokeText , sizeof(szKeystrokeText)/sizeof(szKeystrokeText[0]), TEXT("%s : 0x%2X"), szMessageW, pCode[chNew]);
           if (!SUCCEEDED(hresult))
           {
              return;
           }
        }
        else
        {
            GetUName(pCode[chNew],szMessageW);
            /* MultiByteToWideChar(CP_ACP, 0, szMessageA, -1, szMessageW, MAX_PATH);*/

            if((lCodePage = CodePage_GetCurCodePageVal()) != UNICODE_CODEPAGE)
            {
                int i;

                i = WideCharToMultiByte(
                        lCodePage, WC_NO_BEST_FIT_CHARS,
                        &pCode[chNew], 1,
                        (char*)mb, 2,
                        NULL, NULL );

                if(i == 1)
                {
                    wCharCode = mb[0];               // single-byte
                }
                else
                {
                    wCharCode = (mb[0]<<8) | mb[1];  // double-byte
                }

                
                hresult = StringCchPrintf(szKeystrokeText , sizeof(szKeystrokeText)/sizeof(szKeystrokeText[0]), TEXT("U+%04X (0x%2X): %s"),
                           pCode[chNew], wCharCode,szMessageW);
                if (!SUCCEEDED(hresult))
                {
                    return;
                }
            }
            else
            {
                
                hresult = StringCchPrintf(szKeystrokeText , sizeof(szKeystrokeText)/sizeof(szKeystrokeText[0]), TEXT("U+%04X: %s"),
                          pCode[chNew], szMessageW);
                if (!SUCCEEDED(hresult))
                {
                    return;
                }
            }

            // add keystroke info to high ANSI char
            // exclude Control chars
            if((pCode[chNew] > 0x009F) &&
               (WideCharToMultiByte(gKBD_CP, WC_NO_BEST_FIT_CHARS,
                                    &pCode[chNew],1,
                                    (char*)mb,2,NULL,NULL) == 1)
               && (*mb > 0x7F))
            {
               LoadString(hInst, IDS_ALT, szMessageW, MAX_PATH);
                           
                           hresult = StringCchPrintf(szAlt , sizeof(szAlt)/sizeof(szAlt[0]),  TEXT("%s: Alt+0%d"), szMessageW, *mb);
                           if (!SUCCEEDED(hresult))
                           {
                              return;
                           }
            }
        }

    }

    if (fRedraw)
    {
        PaintStatusLine(hdc, FALSE, TRUE);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  SubSetChanged
//
//  Sets the ANSI bit if appropriate and then calls UpdateSymbolSelection
//  and then repaints the window.
//
//  Repaints Keystroke field if HWND != NULL.
//
//  Redraws the char grid.
//
////////////////////////////////////////////////////////////////////////////

VOID SubSetChanged(
    HWND hwnd)
{
    HDC hdc;

    ExitMagnify(hwndCharGrid, &sycm);
    UpdateSymbolSelection(hwnd, TRUE);
    if ((hwnd != NULL) && ((hdc = GetDC(hwnd)) != NULL))
    {
        LPINT lpdxp;
        HFONT hFont;
        UINT ch;

        hFont = (HFONT)SelectObject(hdc, sycm.hFont);
        lpdxp = (LPINT)sycm.rgdxp;

        if (pCode)
        {
            Font_GetCharWidth32(hdc, chSymFirst, chSymLast, lpdxp,pCode);
        }

        SelectObject(hdc, hFont);

        for (ch = (UINT) chSymFirst; ch <= (UINT) chSymLast; ch++, lpdxp++)
        {
            *lpdxp = (sycm.dxpBox - *lpdxp) / 2;
        }
        ReleaseDC(hwnd, hdc);
    }

    if(sycm.chCurr != 0)
    {
        sycm.chCurr = 0;
        HDC hDC = GetDC(hwndDialog);
        UpdateKeystrokeText(hDC, sycm.chCurr, FALSE);
        ReleaseDC(hwndDialog, hDC);
        InvalidateRect(hwndDialog, NULL, TRUE);
    }
    InvalidateRect(hwndCharGrid, NULL, TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  UpdateSymbolSelection
//
//  Updates the values of the following global values:
//      chRangeFirst
//      chRangeLast
//  Subsets in the Unicode character set have different numbers of
//  characters.  We have to do some bounds checking in order to set an
//  appropriate sycm.chCurr value.  The "Keystroke" status field is
//  updated.
//
//  Repaints Keystroke field if HWND != NULL.
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateSymbolSelection(
    HWND hwnd,
    BOOL bUpdateRange)
{
    int iCmd = SW_HIDE;
    HWND hwndSB;
    UINT chFirst, chLast;

    chRangeFirst = 0;

    if(bUpdateRange)
    {
        LPWSTR lpszSubsetChar=NULL;
        INT    nSubsetChar = 0;
        BOOL   bLineBreak=FALSE;

        URANGE *pCMapTab = NULL;
        INT    nNumofCMapTab = 0;

        LONG lCodePage;

        lCodePage = CodePage_GetCurSelCodePage(hwnd,ID_VIEW);

        Subset_GetUnicodeCharsToDisplay(
                    hwnd,
                    ID_UNICODESUBSET,
                    lCodePage,
                    &lpszSubsetChar,
                    (unsigned int*)&nSubsetChar,
                    &bLineBreak);

        Font_GetCurCMapTable(hwnd,ID_FONT,&pCMapTab,(unsigned int*)&nNumofCMapTab);

        pCode = Display_CreateDispBuffer(
                        lpszSubsetChar,
                        nSubsetChar,
                        pCMapTab,
                        nNumofCMapTab,
                        bLineBreak);
    }

    if(pCode == NULL || *pCode == 0)
    {
           chRangeLast = 0;
    }
    else
    {
           chRangeLast = lstrlen(pCode)-1;
    }

    chFirst = chRangeFirst;

    chLast = chFirst + cchFullMap - 1;
    chLast = min(chLast, chRangeLast);

    hwndSB = GetDlgItem(hwnd, ID_MAPSCROLL);

    if (chLast != chRangeLast)
    {
        int i;

        iCmd = SW_SHOW;
        SetScrollPos(hwndSB, SB_CTL, 0, FALSE);
        i = (chRangeLast - chRangeFirst + 1) - cchFullMap;
        if (i < cchSymRow)
        {
            i = 1;
        }
        else
        {
            i = (i+cchSymRow-1) / cchSymRow;
        }

        SetScrollRange(hwndSB, SB_CTL, 0, i, FALSE);
        InvalidateRect(hwndSB, NULL, FALSE);
    }

    ShowWindow(hwndSB, iCmd);
    UpdateSymbolRange(hwnd, chFirst, chLast);

    //adjust character position
    {
        LPINT lpdxp;
        HFONT hFont;
        UINT ch;
        HDC hdc = GetDC(hwnd);

        if (hdc)
        {
          hFont = (HFONT)SelectObject(hdc, sycm.hFont);
          lpdxp = (LPINT)sycm.rgdxp;

          if (pCode)
          {
            Font_GetCharWidth32(hdc, chFirst, chLast, lpdxp,pCode);
          }

          SelectObject(hdc, hFont);

          for (ch = (UINT) chFirst; ch <= (UINT) chLast; ch++, lpdxp++)
          {
            *lpdxp = (sycm.dxpBox - *lpdxp) / 2;
          }
          ReleaseDC(hwnd, hdc);
        }
    }
}

VOID SetSpecificSelection(HWND hwnd,
                          int iFrom,
                          int iTo)
{
    int iCmd = SW_HIDE;
    HWND hwndSB;
    UINT chFirst, chLast;

    chRangeFirst = 0;

    LPWSTR lpszSubsetChar=NULL;
    INT    nSubsetChar = 0;
    BOOL   bLineBreak=FALSE;

    URANGE *pCMapTab = NULL;
    INT    nNumofCMapTab = 0;

    LONG lCodePage;

    lCodePage = CodePage_GetCurSelCodePage(hwnd,ID_VIEW);

    Subset_GetUnicodeCharsToDisplay(
                hwnd,
                ID_UNICODESUBSET,
                lCodePage,
                &lpszSubsetChar,
                (unsigned int*)&nSubsetChar,
                &bLineBreak);

    Font_GetCurCMapTable(hwnd,ID_FONT,&pCMapTab,(unsigned int*)&nNumofCMapTab);

    pCode = Display_CreateSubsetDispBuffer(
                    lpszSubsetChar,
                    nSubsetChar,
                    pCMapTab,
                    nNumofCMapTab,
                    bLineBreak,
                    iFrom,
                    iTo);

    if (pCode && pCode[0])
    {
        chRangeLast = lstrlen(pCode)-1;
    }

    chFirst = chRangeFirst;

    chLast = chFirst + cchFullMap - 1;
    chLast = min(chLast, chRangeLast);

    hwndSB = GetDlgItem(hwnd, ID_MAPSCROLL);

    if (chLast != chRangeLast)
    {
        int i;

        iCmd = SW_SHOW;
        SetScrollPos(hwndSB, SB_CTL, 0, FALSE);
        i = (chRangeLast - chRangeFirst + 1) - cchFullMap;
        if (i < cchSymRow)
        {
            i = 1;
        }
        else
        {
            i = (i+cchSymRow-1) / cchSymRow;
        }

        SetScrollRange(hwndSB, SB_CTL, 0, i, FALSE);
        InvalidateRect(hwndSB, NULL, FALSE);
    }

    ShowWindow(hwndSB, iCmd);
    UpdateSymbolRange(hwnd, chFirst, chLast);

    //adjust character position
    {
        LPINT lpdxp;
        HFONT hFont;
        UINT ch;
        HDC hdc = GetDC(hwnd);

        if (hdc)
        {
          hFont = (HFONT)SelectObject(hdc, sycm.hFont);
          lpdxp = (LPINT)sycm.rgdxp;

          if (pCode)
          {
            Font_GetCharWidth32(hdc, chFirst, chLast, lpdxp,pCode);
          }

          SelectObject(hdc, hFont);

          for (ch = (UINT) chFirst; ch <= (UINT) chLast; ch++, lpdxp++)
          {
            *lpdxp = (sycm.dxpBox - *lpdxp) / 2;
          }
          ReleaseDC(hwnd, hdc);
        }
    }

}

////////////////////////////////////////////////////////////////////////////
//
//  UpdateSymbolRange
//
//  Updates the values of the following global values:
//      chSymFirst
//      chSymLast
//      sycm.chCurr
//  Subsets in the Unicode character set have different numbers of
//  characters.  We have to do some bounds checking in order to set an
//  appropriate sycm.chCurr value.  The "Keystroke" status field is
//  updated.
//
//  Repaints Keystroke field if HWND != NULL.
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateSymbolRange(
    HWND hwnd,
    INT FirstChar,
    INT LastChar)
{
    UTCHAR chSymOffset;

    chSymOffset = sycm.chCurr - chSymFirst;

    chSymFirst = (UTCHAR)FirstChar;
    chSymLast = (UTCHAR)LastChar;

    sycm.chCurr = chSymOffset + chSymFirst;

    if (sycm.chCurr > chSymLast)
    {
        sycm.chCurr = chSymFirst;
    }
    while(sycm.chCurr>chSymFirst && pCode[sycm.chCurr] == L' ')
             --sycm.chCurr;

    if (hwnd != NULL)
    {
        HDC hdc;

        hdc = GetDC(hwnd);
        UpdateKeystrokeText(hdc, sycm.chCurr, TRUE);
        ReleaseDC(hwnd, hdc);
    }
    else
    {
        UpdateKeystrokeText(NULL, sycm.chCurr, FALSE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PaintStatusLine
//
//  Paints the Help and Keystroke fields in the status bar.
//
//  Repaints Help field if fHelp == TRUE.
//  Repaints Keystroke field if fKeystroke == TRUE.
//
////////////////////////////////////////////////////////////////////////////

VOID PaintStatusLine(
    HDC hdc,
    BOOL fHelp,
    BOOL fKeystroke)
{
    HFONT hfontOld = NULL;
    RECT rect;
    INT dyBorder;

    dyBorder = GetSystemMetrics(SM_CYBORDER);

    if (hfontStatus)
    {
        hfontOld = (HFONT)SelectObject(hdc, hfontStatus);
    }

    //
    //  Set the text and background colors.
    //
    SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));
    SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));

    if (fKeystroke)
    {
        //
        //  Now the character text, with a gray background.
        //
        rect.top    = rcStatusLine.top + 3 * dyBorder;
        rect.bottom = rcStatusLine.bottom - 3 * dyBorder;
        rect.left   = 9 * dyBorder;
        rect.right  = rcStatusLine.right - 9 * dyBorder;

        ExtTextOut( hdc,
                    rect.left + dyBorder * 2,
                    rect.top,
                    ETO_OPAQUE | ETO_CLIPPED,
                    &rect,
                    szKeystrokeText,
                    lstrlen(szKeystrokeText),
                    NULL );

        //
        //  Now the keystroke Alt+ text, with a gray background.
        //
        if(szAlt[0])
        {
          rect.left   += dxHelpField;
/*
          ExtTextOut( hdc,
                    rect.left + dyBorder * 2,
                    rect.top,
                    ETO_OPAQUE | ETO_CLIPPED,
                    &rect,
                    szAlt,
                    lstrlen(szAlt),
                    NULL );
*/
          UINT ta = GetTextAlign(hdc);
          UINT tb = ta | TA_RIGHT;
          SetTextAlign(hdc, tb);
          ExtTextOut( hdc,
                    rect.right - dyBorder * 2,
                    rect.top,
                    ETO_OPAQUE,
                    &rect,
                    szAlt,
                    lstrlen(szAlt),
                    NULL );
          SetTextAlign(hdc, ta);
        }
    }

    if (hfontOld)
    {
        SelectObject(hdc, hfontOld);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  DoHelp
//
//  Invokes help if fInvokeHelp is true, or dismisses help if fInvokeHelp
//  is FALSE.
//
////////////////////////////////////////////////////////////////////////////

VOID DoHelp(
    HWND hWnd,
    BOOL fInvokeHelp)
{
        if (fInvokeHelp)
        {
            HtmlHelpA(GetDesktopWindow(), "charmap.chm", HH_DISPLAY_TOPIC, 0L);
//WORKAROUND    HtmlHelp(hWnd, ChmHelpPath, HH_DISPLAY_TOPIC, 0L);
        }
        else
        {
            HtmlHelpA(GetDesktopWindow(), "charmap.chm", HHWIN_PROP_POST_QUIT, 0L);
//WORKAROUND    HtmlHelp(hWnd, ChmHelpPath, HHWIN_PROP_POST_QUIT, 0L);
        }
}

////////////////////////////////////////////////////////////////////////////
//
//  ExitMagnify
//
//  Releases mouse capture, exits magnify mode, and restores the cursor.
//
////////////////////////////////////////////////////////////////////////////

VOID ExitMagnify(
    HWND hWnd,
    PSYCM psycm)
{
    BOOL fFocus;
    //
    //  Release capture, remove magnified character, restore cursor.
    //
    ReleaseCapture();
    RestoreSymMag(hWnd, psycm);
    psycm->fFocusState = TRUE;
    if (fFocus = psycm->fFocusState)
    {
        psycm->fFocusState = FALSE;
    }
    DrawSymChOutlineHwnd(psycm, hWnd, psycm->chCurr, TRUE, fFocus);
    if (psycm->fCursorOff)
    {
        ShowCursor(TRUE);
    }
    psycm->fMouseDn = psycm->fCursorOff = FALSE;
    psycm->fMagnify = FALSE;
}

////////////////////////////////////////////////////////////////////////////
//
//  SetEditCtlFont
//
//  Creates a font for the Edit control that visually matches the handle
//  given, but is guaranteed not to be bigger than the size of the edit
//  control.
//
////////////////////////////////////////////////////////////////////////////

void SetEditCtlFont(
    HWND hwndDlg,
    int idCtl,
    HFONT hfont)
{
    static HFONT hfNew = NULL;
    LOGFONT lfNew;
    HWND hwndCtl = GetDlgItem(hwndDlg, idCtl);
    RECT rc;

    if (hfNew != NULL)
    {
        DeleteObject(hfNew);
    }

    GetWindowRect(hwndCtl, &rc);

    if (GetObject(hfont, sizeof(lfNew), &lfNew) != 0)
    {
        lfNew.lfHeight = rc.bottom - rc.top - 8;
        lfNew.lfWidth  = lfNew.lfEscapement = lfNew.lfOrientation =
        lfNew.lfWeight = 0;

        hfNew = CreateFontIndirect(&lfNew);
    }
    else
    {
        hfNew = hfont;
    }

    SendMessage(hwndCtl, WM_SETFONT, (WPARAM)hfNew, (LPARAM)TRUE);

    if (hfNew == hfont)
    {
        hfNew = NULL;
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  SetSearched
//
////////////////////////////////////////////////////////////////////////////
void SetSearched(void)
{
  fSearched = TRUE;
}

////////////////////////////////////////////////////////////////////////////
//
//  ComputeExpandedAndShrunkHeight
//  Computes the height of the dialog in expanded and shrunk state
//
////////////////////////////////////////////////////////////////////////////
void ComputeExpandedAndShrunkHeight(HWND hDlg)
{
    RECT rDlg, rButton;

    // Initially dialog is created in expanded state so expanded height is
    // same as current dialog height
    GetWindowRect(hDlg, &rDlg);
    gwExpandedHeight = rDlg.bottom - rDlg.top;

    // Shrunk height of dialog is y position of Advanced checkbox plus
    // height of status line plus some separator
    GetWindowRect(GetDlgItem(hDlg, ID_ADVANCED), &rButton);
    gwNormalHeight = rButton.bottom - rDlg.top + dyStatus
        + GetSystemMetrics(SM_CYFRAME);
}

////////////////////////////////////////////////////////////////////////////
//
//  ShowHideAdvancedControls
//  Toggles ID_ADVANCED checkbox and resizes the dialog accordingly
//
////////////////////////////////////////////////////////////////////////////
int ShowHideAdvancedControls(
                HWND hWnd,
                WPARAM wParam,
                LPARAM lParam)
{
    RECT    rectParent;
    int     iCheckState;

    // Get Current Check State
    iCheckState = (int)SendMessage(GetDlgItem(hWnd, ID_ADVANCED),
        BM_GETCHECK,
        (WPARAM)0L,
        (LPARAM)0L);

    // Toggle fDisplayAdvancedControls
    fDisplayAdvControls = (iCheckState == BST_CHECKED)? FALSE: TRUE;

    SendMessage( GetDlgItem(hwndDialog, ID_UNICODESUBSET),
                 CB_SETCURSEL,
                 (WPARAM) 0,
                 (LPARAM) 0);

    if(fDisplayAdvControls == FALSE)
    {
        // Since we are going back to a simple window close the list
        // which are already open
         if(ghwndList || ghwndGrid)
         {
             fSearched = TRUE;
             DestroyAllListWindows();
         }

         if(CodePage_GetCurSelCodePage(hWnd,ID_VIEW) != UNICODE_CODEPAGE)
         {
             SendMessage( GetDlgItem(hwndDialog, ID_VIEW),
                          CB_SETCURSEL,
                          (WPARAM) 0,
                          (LPARAM) 0);
             fSearched = TRUE;
         }
    }
    else
    {
         // Getting ready to show advanced controls
         WCHAR buffer[256];

         fSearched  = FALSE;
         fNeedReset = FALSE;

         SetDlgItemText(hWnd, ID_SEARCHINPUT, L"");
         LoadString(hInst, IDS_SEARCH, buffer, 255);
         SetDlgItemText(hWnd, ID_SEARCH, buffer);
         EnableWindow(GetDlgItem(hWnd, ID_SEARCH), FALSE);

         // Initialise and enable SUR controls
         EnableSURControls(hWnd);
    }

    // Change Dialog Size and enable/diable advanced controls
    ResizeDialog(hWnd);

    // Set the status line size
    GetClientRect(hWnd, &rectParent);
    rcStatusLine = rectParent;
    rcStatusLine.top = rcStatusLine.bottom - dyStatus;

    // Toggle ID_ADVANCED check
    SendMessage(GetDlgItem(hWnd, ID_ADVANCED),
        BM_SETCHECK,
        (WPARAM)((fDisplayAdvControls==TRUE)? BST_CHECKED: BST_UNCHECKED),
        (LPARAM)0L
    );

    // Force a paint message
    InvalidateRect(hWnd, NULL, TRUE);

    if(fSearched || fNeedReset)
    {
        SendMessage( hWnd,
                     WM_COMMAND,
                     MAKELONG(ID_VIEW,CBN_SELCHANGE),
                     0L);
    }

    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  ResizeDialog - Sets the dialog height to correspond to initial start state
//
////////////////////////////////////////////////////////////////////////////
void ResizeDialog(HWND hWnd)
{
    RECT rDlg;
    int  iDisplay;

    // Get size of dialog
    GetWindowRect(hWnd, &rDlg);

    // Change Dialog Size
    if (fDisplayAdvControls == FALSE)
    {
        MoveWindow(hWnd, rDlg.left, rDlg.top,
            rDlg.right - rDlg.left, gwNormalHeight, TRUE);
        iDisplay = SW_HIDE;
    }
    else
    {
        MoveWindow(hWnd, rDlg.left, rDlg.top, rDlg.right - rDlg.left,
            gwExpandedHeight, TRUE);
        iDisplay = SW_NORMAL;
    }

    // Show or hide controls depending on whether expanded dialog is
    // being shown or normal dialog is shown
    ShowWindow(GetDlgItem(hWnd, ID_VIEWLB), iDisplay);
    ShowWindow(GetDlgItem(hWnd, ID_VIEW), iDisplay);
    ShowWindow(GetDlgItem(hWnd, ID_SUBSETLB), iDisplay);
    ShowWindow(GetDlgItem(hWnd, ID_UNICODESUBSET), iDisplay);
    ShowWindow(GetDlgItem(hWnd, ID_SEARCHNAME), iDisplay);
    ShowWindow(GetDlgItem(hWnd, ID_SEARCHINPUT), iDisplay);
    ShowWindow(GetDlgItem(hWnd, ID_SEARCH), iDisplay);

    // All SUR controls
    ShowWindow(GetDlgItem(hWnd, ID_URANGE), iDisplay);
    ShowWindow(GetDlgItem(hWnd, ID_FROM), iDisplay);
}

////////////////////////////////////////////////////////////////////////////
//
//  DoDragAndDrop - Calls the modal drag and drop proc for CharGrid
//
////////////////////////////////////////////////////////////////////////////
int DoDragAndDrop(HWND hWnd, LPDROPSOURCE pDropSource)
{
    PCImpIDataObject    pDataObject;
    DWORD               dwEffect;
    TCHAR               szCurrSelection[2];

    SetRichEditFont(hwndDialog, ID_STRING, sycm.hFont);
    WCHAR wc = (WCHAR)pCode[sycm.chCurr];
    ConvertAnsifontToUnicode(hWnd, (char*)&pCode[sycm.chCurr], &wc);
    //rich edit screws up symbol fonts
    if (gFontType & SYMBOL_FONTTYPE)
    {
      if ((wc >= 0xf000) && (wc <= 0xf0ff))
        wc = (WCHAR) (BYTE)pCode[sycm.chCurr];
    }
    szCurrSelection[0] = wc;
    szCurrSelection[1] = 0;

    // Create an instance of the DataObject
    pDataObject = new CImpIDataObject(hWnd);

    pDataObject->SetText(szCurrSelection);

    // Do drag and drop with copy
    DoDragDrop(pDataObject, pDropSource, DROPEFFECT_COPY, &dwEffect);

    // Free instance of DataObject
    pDataObject->Release();

    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  CopyTextToClipboard - Copies text from the rich edit control to clipboard
//
////////////////////////////////////////////////////////////////////////////
static void CopyTextToClipboard(HWND hWndDlg)
{
    DWORD   dwSelStart, dwSelEnd;
    HWND    hWndRichEdit;

#ifndef DISABLE_RICHEDIT
    hWndRichEdit = GetDlgItem(hWndDlg, ID_STRING);
#else
    hWndRichEdit = GetDlgItem(hWndDlg, IDC_EDIT);
#endif

    SendMessage(hWndRichEdit, EM_GETSEL, (WPARAM)&dwSelStart,
        (LPARAM)&dwSelEnd);

    if (dwSelStart == dwSelEnd)
    {
        // There is no text that has been selected currently
        // So select the entire text and copy it to clipboard


        // Temporarily hide selection
        SendMessage(hWndRichEdit, EM_HIDESELECTION, (WPARAM)TRUE, (LPARAM)0);
        // Select entire text
        SendMessage(hWndRichEdit, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
        // Copy text to clipboard
        SendMessage(hWndRichEdit, WM_COPY, 0L, 0L);
        // Restore the hidden selection
        SendMessage(hWndRichEdit, EM_SETSEL, (WPARAM)dwSelStart,
            (LPARAM)dwSelEnd);
        SendMessage(hWndRichEdit, EM_HIDESELECTION, (WPARAM)FALSE, (LPARAM)0);
    }
    else
    {
        SendMessage(hWndRichEdit, WM_COPY, 0L, 0L);
    }

}

////////////////////////////////////////////////////////////////////////////
//
//  CompareCharFormats - Compares two CHARFORMATS
//  returns 1 if they are equal
//          0 if not equal
//
////////////////////////////////////////////////////////////////////////////
static int CompareCharFormats(CHARFORMAT* pcf1, CHARFORMAT* pcf2)
{
        /*
    return ( (pcf1->bPitchAndFamily == pcf2->bPitchAndFamily)
        && (lstrcmp(pcf1->szFaceName, pcf2->szFaceName) == 0)
        && (pcf1->bCharSet == pcf2->bCharSet)
        );
        */
  return ((lstrcmp(pcf1->szFaceName, pcf2->szFaceName) == 0));
}

////////////////////////////////////////////////////////////////////////////
//
//  SetRichEditFont - Compares the charformat of the current selection
//  with the charformat for the font in the chargrid. If they are not
//  equal then it sets a new charformat
//
////////////////////////////////////////////////////////////////////////////
static void SetRichEditFont(HWND hWndDlg, int idCtl, HFONT hFont)
{
    CHARFORMAT  cf, cfCurr;
    LOGFONT     lf;
    HWND        hWndRichEdit;
    RECT        rc;
    HDC         hDC;
    int         iLogPixelsYDisplay, iFontDeviceHt;
    DWORD       dwSelStart, dwSelEnd;
    HFONT       hFontEdit, hFontOld;
    TEXTMETRIC  tm;

    hWndRichEdit = GetDlgItem(hWndDlg, idCtl);
    SendMessage(hWndRichEdit, EM_GETRECT, 0, (LPARAM)&rc);
    hDC = GetDC(hWndDlg);

    hWndRichEdit = GetDlgItem(hWndDlg, ID_STRING);

    SendMessage(hWndRichEdit, EM_GETSEL, (WPARAM)&dwSelStart,
        (LPARAM)&dwSelEnd);

    // Font cell height (logical units)
    iFontDeviceHt = rc.bottom - rc.top - 2;

    // Convert font height from logical units to twips for rich edit
    // Return logical units per inch
    iLogPixelsYDisplay = GetDeviceCaps(hDC, LOGPIXELSY);

    // Get the CharFormat of the current selection
    cfCurr.cbSize = sizeof(cfCurr);
    SendMessage(hWndRichEdit, EM_GETCHARFORMAT, TRUE, (LPARAM)&cfCurr);

    // Get the Log font structure from the current font
    if (GetObject(hFont, sizeof(lf), &lf) == 0)
    {
        ReleaseDC(hWndDlg, hDC);
        return;
    }

    // Logical cell height
    lf.lfHeight = iFontDeviceHt;

    cf.bCharSet = (BYTE) GetCurFontCharSet(hWndRichEdit);

    // Fill out the CHARFORMAT structure to get the character effects.
    cf.cbSize = sizeof (cf);
    cf.dwMask = CFM_BOLD | CFM_FACE | CFM_ITALIC |
                    CFM_SIZE | CFM_UNDERLINE | CFM_OFFSET | CFM_CHARSET;
    cf.dwEffects = 0;

    // Set attributes
    if (lf.lfWeight >= FW_BOLD)
        cf.dwEffects |= CFE_BOLD;
    if (lf.lfItalic)
        cf.dwEffects |= CFE_ITALIC;

    if (lf.lfUnderline)
        cf.dwEffects |= CFE_UNDERLINE;

    cf.bPitchAndFamily = lf.lfPitchAndFamily;

    // Figure physical font internal leading

    GetViewableFontDimensions(hDC, iLogPixelsYDisplay, &lf, &hFontOld, &hFontEdit, &tm);


    // rich edit needs character height not cell height.
    // character height = cell height - internal leading
    //
    // logical units * points/inch * twips/point
    // ------------------------------------------
    // logical units / inch
    //
    cf.yHeight = MulDiv(tm.tmHeight - tm.tmInternalLeading, 1440, iLogPixelsYDisplay);

    SelectObject(hDC, hFontOld);
    DeleteObject(hFontEdit);

    cf.yOffset = 0;

    // Set the new typeface, preserving the previous effects.
    
    HRESULT hresult = StringCchCopy(cf.szFaceName, sizeof(cf.szFaceName)/sizeof(cf.szFaceName[0]), lf.lfFaceName);
    if (!SUCCEEDED(hresult))
    {
        return;
    }

    if (CompareCharFormats(&cf, &cfCurr) == 0)
        SendMessage (hWndRichEdit, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);

    ReleaseDC(hWndDlg, hDC);

}

////////////////////////////////////////////////////////////////////////////
//
//  DoDragScroll - Routine for scrolling the map when the mouse button is
//  down and mouse pointer goes outside the character grid
//
////////////////////////////////////////////////////////////////////////////
int DoDragScroll(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    RECT    rcClient;
    int     yMousePosn, iyDistance, iScrollTimer;
    DWORD   dwScrollDir;
    POINT   pt;

    // Store the current wParam and lParam so that they can be used for
    // next dragscroll
    prevKeys = wParam;
    ptPrevMouse = lParam;
    POINTSTOPOINT(pt, lParam);

    yMousePosn = pt.y;
    GetClientRect(hWnd, &rcClient);

    // Verify that we are out of the client area if not return
    if ((yMousePosn >= rcClient.top) && (yMousePosn <= rcClient.bottom))
    {
        KillTimer(hWnd, ID_SCROLLTIMER);
        return 0;
    }

    dwScrollDir = (yMousePosn < 0) ? VK_UP : VK_DOWN;

    iyDistance = (yMousePosn < 0) ?
        -yMousePosn : yMousePosn - rcClient.bottom;

    // Thus if iyDistance is less then then the scroll interval will be less
    iScrollTimer = 750 - ((UINT)iyDistance << 4);

    // Min value should be one
    if (iScrollTimer < 1)
        iScrollTimer = 1;

    // Scroll
    SendMessage(hWnd, WM_KEYDOWN, (WPARAM)dwScrollDir, (LPARAM)0L);

    // Set timer for next scroll
    SetTimer(hWnd, ID_SCROLLTIMER, iScrollTimer, NULL);

    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  FormatHex - Puts leading zeros and converts lower case to upper
//
////////////////////////////////////////////////////////////////////////////
int FormatHex(LPTSTR lpszText, LPTSTR lpszHexText, int nLen)
{
    int nChars, i, j;

    nChars = wcslen(lpszText);

    for (i=0; i<nLen-nChars; i++)
    {
        // Put the leading 0's
        lpszHexText[i] = ZERO;
    }

    for (j=0; j<nChars; j++)
    {
        // Convert all characters to upper
        lpszHexText[i+j] = towupper(lpszText[j]);
    }

    // Null terminate
    lpszHexText[nLen] = 0;

    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  InitSURControl - Initialises the default values for the SUR edit box
//                   with ID nControlId
//
////////////////////////////////////////////////////////////////////////////
int InitSURControl(HWND hWnd, int nControlId)
{
    int     i;
    TCHAR   szValue[256];

    for (i=0; i<sizeof(validData) / sizeof(validData[0]); i++)
    {
        if (validData[i].nControlId == nControlId)
        {
            // Set inital value
            
            HRESULT hresult = StringCchPrintf(szValue , sizeof(szValue)/sizeof(szValue[0]),  L"%04X", validData[i].iDefaultValue);
            if (!SUCCEEDED(hresult))
            {
               return FALSE;
            }
            //SetDlgItemText(hWnd, nControlId, szValue);
            SetDlgItemText(hWnd, nControlId, L"");
        }
    }

    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  InitSURControl - Initialises the default values for the SUR edit box
//                   with ID nControlId
//
////////////////////////////////////////////////////////////////////////////
int GetDefaultValue(int nControlId)
{
    int     i;

    for (i=0; i<sizeof(validData) / sizeof(validData[0]); i++)
    {
        if (validData[i].nControlId == nControlId)
        {
            return (validData[i].iDefaultValue);
        }
    }

    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  InitSURControls - Initialises the default values for all SUR edit boxes
//
////////////////////////////////////////////////////////////////////////////
int InitSURControls(HWND hWnd)
{
    InitSURControl(hWnd, ID_FROM);

    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  UnicodeRangeChecked - Called when Unicode Range check box is checked
//
////////////////////////////////////////////////////////////////////////////
int UnicodeRangeChecked(HWND hWnd)
{
    if (IsDlgButtonChecked(hWnd, ID_URANGE) == BST_CHECKED)
    {
        EnableWindow(GetDlgItem(hWnd, ID_FROM), TRUE);
        EnableWindow(GetDlgItem(hWnd, ID_TO), TRUE);
        InitSURControls(hWnd);

        // Show the current range
        SURangeChanged(hWnd);
    }
    else
    {
        EnableWindow(GetDlgItem(hWnd, ID_FROM), FALSE);
        EnableWindow(GetDlgItem(hWnd, ID_TO), FALSE);
        InitSURControls(hWnd);

        // Show the whole unicode range
        SURangeChanged(hWnd);
    }
    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  EnableSURControls - Enables or Disables SUR controls depending on
//                      currently selected CodePage and View
//
////////////////////////////////////////////////////////////////////////////
int EnableSURControls(HWND hWnd, BOOL fForceDisable)
{
    LONG    lCodePage;
    int     nIndex;
    BOOL    bEnabled=TRUE;


    if (fForceDisable || !IsWindowEnabled(GetDlgItem(hWnd, ID_VIEW)))
    {
        // Called when controls are to be forcibly disabled
        // irrespective of codepage and subset
        InitSURControls(hWnd);
        EnableWindow(GetDlgItem(hWnd, ID_URANGE), FALSE);
        EnableWindow(GetDlgItem(hWnd, ID_FROM), FALSE);
        iFromPrev = 0x21; iToPrev = 0xFFFD;
        return 0;
    }

    // SUR controls are disabled if Character Set is not Unicode
    // or SearchByGroup is not all
    lCodePage = (LONG)CodePage_GetCurSelCodePage(hWnd, ID_VIEW);

    nIndex = (int)SendDlgItemMessage(hWnd, ID_UNICODESUBSET, CB_GETCURSEL,
        (WPARAM) 0, (LPARAM) 0L);

    if ((lCodePage != UNICODE_CODEPAGE) || (nIndex != 0))
    {
        bEnabled = FALSE;
    }

    EnableWindow(GetDlgItem(hWnd, ID_URANGE), bEnabled);

    if (bEnabled == FALSE)
    {
        // Reset all the SUR controls
        InitSURControls(hWnd);
        EnableWindow(GetDlgItem(hWnd, ID_FROM), bEnabled);
    }
    else
    {
        EnableWindow(GetDlgItem(hWnd, ID_FROM), bEnabled);
        InitSURControls(hWnd);
    }

    // Reset values of iFromPrev and iToPrev
    iFromPrev = 0x21; iToPrev = 0xFFFD;

    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  SURangeChanged - Called when contents of one of the SUR edit boxes
//  changes. This proc updates the chargrid if the contents of the edit
//  boxes are valid
//
////////////////////////////////////////////////////////////////////////////
int SURangeChanged(HWND hWnd)
{
    int     iFrom, iTo=0xFFFD, nLen, iRet;
    TCHAR   chBuffer[MAX_CHARS+1];
    WCHAR   buffer2[256];

    nLen = GetDlgItemText(hWnd, ID_FROM, chBuffer, MAX_CHARS+1);
    if (nLen != 0){
        if (swscanf(chBuffer, L"%x", &iFrom)== EOF){
            iFrom = 0x21;
        }
    }
    else {
        iFrom = 0x21;
    }

    // Check limits
    if ((iFrom < 0x0021) || (iFrom > 0xFFFD))
    {
        iFrom = 0x0021;
        //InitSURControl(hWnd, ID_FROM);
    }

    // Check if the from and to values have changed
    if ((iFromPrev == iFrom) && (iToPrev == iTo))
    {
        // No change
        return 0;
    }

    // Selection should be the first one
    ExitMagnify(hwndCharGrid, &sycm);
    sycm.chCurr = 0;

    // Reload the buffer and set min and max range
    SetSpecificSelection(hWnd, iFrom, iTo);

    iFromPrev = iFrom;
    iToPrev = iTo;

    // Since the range has changed enable the reset button
    if (nLen != 0)
    {
        LoadString(hInst, IDS_RESET,  buffer2, 255);
        SetDlgItemText(hWnd, ID_SEARCH, buffer2);
        EnableWindow(GetDlgItem(hWnd, ID_SEARCH), TRUE);
        fNeedReset = FALSE;
        fSearched  = TRUE;
    }
    else
    {
        LoadString(hInst, IDS_SEARCH,  buffer2, 255);
        SetDlgItemText(hWnd, ID_SEARCH, buffer2);
        EnableWindow(GetDlgItem(hWnd, ID_SEARCH), FALSE);
        fNeedReset = FALSE;
        fSearched  = FALSE;
    }

    // Invalidate the charmap
    InvalidateRect(hwndCharGrid, NULL, TRUE);

    return 0;
}

////////////////////////////////////////////////////////////////////////////
//
//  ValidateValues - Validates the values in SUR edit boxes. Also formats
//  edit box text in case of valid values
//
////////////////////////////////////////////////////////////////////////////
int ValidateValues(HWND hWnd)
{
    UINT    uCtrlID;
    int     iValue1, iValue2=0xFFFD, iDefault1;
    TCHAR   szText[MAX_CHARS+1],
            szHexText[MAX_CHARS+1];

    // Subset has changed so validate upper and lower limit
    // and redisplay grid
    GetWindowText(hWnd, szText, MAX_CHARS+1);
    if (swscanf(szText, L"%x", &iValue1) == EOF){
        return 0;
    }

    uCtrlID = GetDlgCtrlID(hWnd);
    iDefault1 = GetDefaultValue(uCtrlID);

    // This code was for validation of default values
    if (uCtrlID == ID_FROM)
    {
        if ((iValue1 < iDefault1) || (iValue1 > iValue2))
        {
            SURangeChanged(GetParent(hWnd));
            return 0;
        }
    }

    SURangeChanged(GetParent(hWnd));
    FormatHex(szText, szHexText, MAX_CHARS);
    SetWindowText(hWnd, szHexText);

    return 0;
}

static WNDPROC fnEditProc = NULL;

//**********************************************************************
// SetHexEditProc
//
// Purpose:
//      Replaces current Edit window procedure with a new procedure
//      capable of validating hex text
//
// Parameters:
//      HWND  hWndEdit      -   Edit Control Handle
//
// Return Value:
//      TRUE                -   Success
//**********************************************************************
static BOOL SetHexEditProc(HWND hWndEdit)
{
    fnEditProc = (WNDPROC)SetWindowLongPtr (hWndEdit, GWLP_WNDPROC,
        (LPARAM)HexEditControlProc);

    if (fnEditProc != NULL)
        return TRUE;
    else
        return FALSE;
}


//**********************************************************************
// HexEditControlProc
//
// Purpose:
//      Edit control procedure capable of handling Hex characters
//      Allows 0-9, a-f and converts a-f to A-F
//      Enter or space - cause refresh of grid with characters
//                       starting from text entered in ID_FROM
//      Escape         - if something is present in textbox clear box
//                     - if nothing is present in textbox close app
//
//**********************************************************************
static LRESULT CALLBACK HexEditControlProc(HWND    hWnd,
                                           UINT    uMessage,
                                           WPARAM  wParam,
                                           LPARAM  lParam)
{
    switch(uMessage)
    {
        case WM_GETDLGCODE:
        {
            return (DLGC_WANTALLKEYS);
            break;
        }

        case WM_KEYDOWN:
        {
            int iLen;

            switch (wParam)
            {
                case VK_ESCAPE:
                {
                    iLen = GetWindowTextLength(hWnd);
                    if (iLen)
                    {
                        InitSURControls(GetParent(hWnd));
                        ValidateValues(hWnd);
                    }
                    else
                    {
                        SendMessage(GetParent(hWnd), WM_CLOSE, 0, 0L);
                    }
                    break;
                }

                case VK_F6:
                {

                    SetFocus(hwndCharGrid);
                    return 0L;
                }

                case VK_TAB:
                {
                    PostMessage(GetParent(hWnd), WM_NEXTDLGCTL, 0, 0L);
                    break;
                }
            }

            break;
        }

        case WM_CHAR:
        {
            TCHAR   chCharCode;

            chCharCode = (TCHAR) wParam;

            // The only characters allowed are 0-9, a-f, A-F, ' ' and '\b'
            if ((chCharCode == ' ') || (chCharCode == VK_RETURN))
            {
                fSURChanged = TRUE;
                return ValidateValues(hWnd);
            }
            else
            {
                if (chCharCode == '\b')
                    break;

                // Validate chars
                if ((chCharCode >= '0')&&(chCharCode <= '9')
                    || (chCharCode >= 'A')&&(chCharCode <= 'F')
                    || (chCharCode >= 'a')&&(chCharCode <= 'f')
                    || (chCharCode == '\b'))
                {
                    // Char is ok
                    if ((chCharCode >= 'a')&&(chCharCode <= 'f'))
                        wParam = towupper(chCharCode);
                }
            }

            break;
        }

        case WM_KILLFOCUS:
        {
            ValidateValues(hWnd);
            break;
        }
    }

    return CallWindowProc(fnEditProc, hWnd, uMessage, wParam, lParam);
}

//**********************************************************************
// CreateTooltipWindow
//
// Purpose:  Creates a new tooltip window
//
// Parameters:  hWndParent   -  App Window handle
//
// Return Value:  Window handle of the tooltip window
//**********************************************************************
HWND CreateTooltipWindow(HWND hWndParent)
{
  hwndTT = CreateWindowEx( 0,
      TOOLTIPS_CLASS,
      NULL,
      WS_POPUP | TTS_ALWAYSTIP,
      CW_USEDEFAULT,
      CW_USEDEFAULT,
      10,
      10,
      hWndParent,
      NULL,
      hInst,
      NULL);

  if (hwndTT == (HWND) NULL)
    return (HWND) NULL;

  return hwndTT;
}

//**********************************************************************
// ResizeTipsArea
//
// Purpose:  Creates a new tooltip window and sets the rectangles for
//           each tooltip
//
// Parameters:  hWnd         -  App Window handle
//
// Return Value:  None
//**********************************************************************
void ResizeTipsArea(HWND hWndGrid, PSYCM psycm)
{
    TOOLINFO ti;    // tool information
    RECT     rcKey; // tool rectangle
    int      x, y;

    if (hwndTT != NULL)
        DestroyWindow(hwndTT);

    CreateTooltipWindow(hWndGrid);

    for (x=0; x<cchSymCol; x++)
    {
        for (y=0; y<cchSymRow; y++)
        {
             ZeroMemory(&ti, sizeof(ti));
             ti.cbSize   = sizeof(TOOLINFO);
             ti.uFlags   = 0;
             ti.hwnd     = hWndGrid;
             ti.lpszText = LPSTR_TEXTCALLBACK;

             rcKey.left    = (int)(y*psycm->dxpBox);
             rcKey.right   = (int)((y+1)*psycm->dxpBox);
             rcKey.top     = (int)(x*psycm->dypBox);
             rcKey.bottom  = (int)((x+1)*psycm->dypBox);

             ti.rect = rcKey;
             SendMessage(hwndTT, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
        }
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  DrawFamilyComboItem
//
//  Paints the font facenames and TT bitmap in the font combo box.
//
////////////////////////////////////////////////////////////////////////////

BOOL DrawFamilyComboItem(
    LPDRAWITEMSTRUCT lpdis)
{
    HDC hDC, hdcMem;
    DWORD rgbBack, rgbText;
    TCHAR szFace[LF_EUDCFACESIZE];
    HBITMAP hOld;
    INT dy;
    DWORD   FontType;

    hDC = lpdis->hDC;

    if (lpdis->itemState & ODS_SELECTED)
    {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    }
    else
    {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    }

    SendMessage( lpdis->hwndItem,
                 CB_GETLBTEXT,
                 lpdis->itemID,
                 (LPARAM)(LPTSTR)szFace );
    ExtTextOut( hDC,
                lpdis->rcItem.left + DX_BITMAP,
                lpdis->rcItem.top,
                ETO_OPAQUE | ETO_CLIPPED,
                &lpdis->rcItem,
                szFace,
                lstrlen(szFace),
                NULL );

    hdcMem = CreateCompatibleDC(hDC);
    if (hdcMem)
    {
        int i;

        if (hbmFont)
        {
            hOld = (HBITMAP) SelectObject(hdcMem, hbmFont);

            i = (int)SendMessage(lpdis->hwndItem, CB_GETITEMDATA, (WPARAM) lpdis->itemID, (LPARAM) 0);

            FontType = Font_pList[i].FontType;
            if (FontType)
            {
                int xSrc;
                dy = ((lpdis->rcItem.bottom - lpdis->rcItem.top) - DY_BITMAP) / 2;

                if      (FontType & TRUETYPE_FONT ||
                         FontType & EUDC_FONTTYPE )
                    xSrc = 0;
                else if (FontType & TT_OPENTYPE_FONTTYPE)
                    xSrc = 2;
                else if (FontType & PS_OPENTYPE_FONTTYPE)
                    xSrc = 3;
                else if (FontType & TYPE1_FONTTYPE)
                    xSrc = 4;
                else
                    xSrc = -1;

                if (xSrc != -1)
                BitBlt( hDC,
                        lpdis->rcItem.left,
                        lpdis->rcItem.top + dy,
                        DX_BITMAP,
                        DY_BITMAP,
                        hdcMem,
                        xSrc * DX_BITMAP,
                        lpdis->itemState & ODS_SELECTED ? DY_BITMAP : 0,
                        SRCCOPY );
            }
            SelectObject(hdcMem, hOld);
        }
        DeleteDC(hdcMem);
    }

    SetTextColor(hDC, rgbText);
    SetBkColor(hDC, rgbBack);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  LoadBitmaps
//
//  Loads DIB bitmaps and "fixes up" their color tables so that we get the
//  desired result for the device we are on.
//
//  This routine requires:
//    - the DIB is a 16 color DIB authored with the standard windows colors
//    - bright blue (00 00 FF) is converted to the background color
//    - light grey  (C0 C0 C0) is replaced with the button face color
//    - dark grey   (80 80 80) is replaced with the button shadow color
//
//  This means you can't have any of these colors in your bitmap.
//
////////////////////////////////////////////////////////////////////////////

HBITMAP LoadBitmaps(
    INT id)
{
    HDC hdc;
    HANDLE h, hRes;
    DWORD *p;
    LPBYTE lpBits;
    LPBITMAPINFOHEADER lpBitmapInfo;
    INT numcolors;
    DWORD rgbSelected, rgbUnselected;
    HBITMAP hbm;

    rgbSelected = GetSysColor(COLOR_HIGHLIGHT);
    //
    //  Flip the colors.
    //
    rgbSelected = RGB( GetBValue(rgbSelected),
                       GetGValue(rgbSelected),
                       GetRValue(rgbSelected) );
    rgbUnselected = GetSysColor(COLOR_WINDOW);
    //
    //  Flip the colors.
    //
    rgbUnselected = RGB( GetBValue(rgbUnselected),
                         GetGValue(rgbUnselected),
                         GetRValue(rgbUnselected) );

    h = FindResource(hInst, MAKEINTRESOURCE(id), RT_BITMAP);
    hRes = LoadResource(hInst, (HRSRC) h);

    //
    //  Lock the bitmap and get a pointer to the color table.
    //
    lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hRes);

    if (!lpBitmapInfo)
    {
        return (FALSE);
    }

    p = (DWORD *)((LPSTR)(lpBitmapInfo) + lpBitmapInfo->biSize);

    //
    //  Search for the Solid Blue entry and replace it with the current
    //  background RGB.
    //

                numcolors = 16;

    while (numcolors-- > 0)
    {
        if (*p == BACKGROUND)
        {
            *p = rgbUnselected;
        }
        else if (*p == BACKGROUNDSEL)
        {
            *p = rgbSelected;
        }
        p++;
    }
    UnlockResource(hRes);

    //
    //  Now create the DIB.
    //
    lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hRes);

    //
    //  First skip over the header structure.
    //
    lpBits = (LPBYTE)(lpBitmapInfo + 1);

    //
    //  Skip the color table entries, if any.
    //
    lpBits += (1 << (lpBitmapInfo->biBitCount)) * sizeof(RGBQUAD);

    //
    //  Create a color bitmap compatible with the display device.
    //
    hdc = GetDC(NULL);
    hbm = CreateDIBitmap( hdc,
                          lpBitmapInfo,
                          (DWORD)CBM_INIT,
                          lpBits,
                          (LPBITMAPINFO)lpBitmapInfo,
                          DIB_RGB_COLORS );
    ReleaseDC(NULL, hdc);

    GlobalUnlock(hRes);
    FreeResource(hRes);

    return (hbm);
}

static WNDPROC fnSearchEditProc = NULL;

//**********************************************************************
// SetSearchEditProc
//
// Purpose:
//      Replaces current Search Edit box procedure with a new procedure
//      to handle the Enter key
//
// Parameters:
//      HWND  hWndEdit      -   Edit Control Handle
//
// Return Value:
//      TRUE                -   Success
//**********************************************************************
static BOOL SetSearchEditProc(HWND hWndEdit)
{
    fnSearchEditProc = (WNDPROC)SetWindowLongPtr (hWndEdit, GWLP_WNDPROC,
        (LPARAM)SearchEditControlProc);

    if (fnSearchEditProc != NULL)
        return TRUE;
    else
        return FALSE;
}

//**********************************************************************
// SearchEditControlProc
//
// Purpose:
//      to handle :
//         Enter     - click the search/reset button
//
//**********************************************************************
static LRESULT CALLBACK SearchEditControlProc(HWND    hWnd,
                                              UINT    uMessage,
                                              WPARAM  wParam,
                                              LPARAM  lParam)
{
    if(uMessage == WM_KEYDOWN)
    {
        if(wParam   == VK_RETURN)
            SendMessage(hwndDialog, WM_COMMAND, ID_SEARCH, 0L);
        else if(wParam   == VK_F6)
            SetFocus(hwndCharGrid);
    }

    return CallWindowProc(fnSearchEditProc, hWnd, uMessage, wParam, lParam);
}

INT_PTR CALLBACK MsgProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message)
    {
      case ( WM_INITDIALOG ):
      {
        if (gDisplayFontChgMsg)
          SendMessage(GetDlgItem(hWnd, IDC_CHECKNOMSG),
                      BM_SETCHECK,(WPARAM)BST_UNCHECKED,(LPARAM)0L);
        else
          SendMessage(GetDlgItem(hWnd, IDC_CHECKNOMSG),
                      BM_SETCHECK,(WPARAM)BST_CHECKED,(LPARAM)0L);
        return TRUE;
      }
      case ( WM_COMMAND ) :
      {
        switch (LOWORD(wParam))
        {
          case (IDOK):
            EndDialog(hWnd, IDOK);
            return TRUE;
          case (IDCANCEL):
            EndDialog(hWnd, IDCANCEL);
            return TRUE;
          case (IDC_CHECKNOMSG):
            LRESULT iCheckState;
            iCheckState = SendMessage(GetDlgItem(hWnd, IDC_CHECKNOMSG),
                                      BM_GETCHECK,(WPARAM)0L,(LPARAM)0L);
            gDisplayFontChgMsg = (iCheckState == BST_CHECKED)? FALSE: TRUE;
            return TRUE;
        }
      }
      case ( WM_SYSCOMMAND):
      {
        switch (wParam)
        {
          case ((WPARAM)SC_CLOSE):
            EndDialog(hWnd, IDCANCEL);
            return TRUE;
        }
        break;
      }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\oleedit.cxx ===
//**********************************************************************
// File name: oleedit.cxx
//
// Implements the extensions required to enable drag and drop with edit
// controls
// History :
//       Dec 23, 1997   [v-nirnay]    wrote it.
//
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//**********************************************************************

#include <windows.h>
#include <ole2.h>

#include "olecomon.h"
#include "cdataobj.h"
#include "cdropsrc.h"
#include "uce.h"
#include "oleedit.h"

WNDPROC fnEditProc = NULL;

//**********************************************************************
// SetEditProc
//
// Purpose:
//      Replaces current Edit window procedure with a new procedure
//      capable of handling drag and drop
//
// Parameters:
//      HWND  hWndEdit      -   Edit Control Handle
//
// Return Value:
//      TRUE                -   Success
//**********************************************************************
BOOL SetEditProc(HWND hWndEdit)
{
    fnEditProc = (WNDPROC)SetWindowLongPtr (hWndEdit, GWLP_WNDPROC,
        (LPARAM)OleEnabledEditControlProc);

    return TRUE;
}

//**********************************************************************
// OleEnabledEditControlProc
//
// Purpose:
//      Edit control procedure capable of handling drag and drop
//
//**********************************************************************
LRESULT CALLBACK OleEnabledEditControlProc(HWND    hWnd,
                                           UINT    uMessage,
                                           WPARAM  wParam,
                                           LPARAM  lParam)
{
    static POINT        ptDragStart;
    static BOOL         fPendingDrag = FALSE;
    static LPDROPSOURCE pDropSource = NULL;

    switch(uMessage) {
    case WM_LBUTTONDOWN:
        {
            // In case there is no drop source create one
            if (pDropSource == NULL) {
                // Create an instance of CDropSource for Drag and Drop
                pDropSource = new CDropSource;

                if (pDropSource == NULL) {
                    // Show error message and prevent window from being shown
                    return -1;
                }
            }

            // Store the point at which LBUTTON was down
            ptDragStart.x = (int)(short)LOWORD (lParam);
            ptDragStart.y = (int)(short)HIWORD (lParam);

            // Find it point is in current selection
            // If it is then go to drag mode
            if (PointInSel(hWnd, ptDragStart)) {
                fPendingDrag = TRUE;

                // Start timer
                SetTimer(hWnd, 1, nDragDelay, NULL);
                SetCapture(hWnd);

                // Do not pass control to edit window because it removes selection
                return TRUE;
            }

            break;
        }

    case WM_LBUTTONUP:
        {
            // Button came up before starting drag so clear flags and timer
            if (fPendingDrag)
            {
                ReleaseCapture();
                KillTimer(hWnd, 1);
                fPendingDrag = FALSE;
            }
            break;
        }

    case WM_MOUSEMOVE:
        {
            int x, y;

            // If a drag is pending and mouse moves beyond threshold
            // then start our drag and drop operation
            if (fPendingDrag)
            {
                x = (int)(short)LOWORD (lParam);
                y = (int)(short)HIWORD (lParam);

                // Find if the point at which the mouse is is beyond the
                // min rectangle enclosing the point at which LBUTTON
                // was down
                if (! (((ptDragStart.x - nDragMinDist) <= x)
                    && (x <= (ptDragStart.x + nDragMinDist))
                    && ((ptDragStart.y - nDragMinDist) <= y)
                    && (y <= (ptDragStart.y + nDragMinDist))) )
                {
                    // mouse moved beyond threshhold to start drag
                    ReleaseCapture();
                    KillTimer(hWnd, 1);
                    fPendingDrag = FALSE;

                    // perform the modal drag/drop operation.
                    EditCtrlDragAndDrop(GetParent(hWnd), hWnd, pDropSource);
                }
            }
            break;
        }

    case WM_TIMER:
        {
            // If the user has kept LBUTTON down for long then
            // start drag and drop operation
            ReleaseCapture();
            KillTimer(hWnd, 1);
            fPendingDrag = FALSE;

            // perform the modal drag/drop operation.
            EditCtrlDragAndDrop(GetParent(hWnd), hWnd, pDropSource);

            break;
        }

    case WM_DESTROY:
        {
            // Release pDropSource it will automatically destroy itself
            if (pDropSource)
                pDropSource->Release();

            break;
        }
    }

    return CallWindowProc(fnEditProc, hWnd, uMessage, wParam, lParam) ;
}

//**********************************************************************
// PointInSel
//
// Purpose:
//      Finds if the point provided is in current selection of edit control
//
// Parameters:
//      HWND  hWnd          -   Edit Control Handle
//      POINT ptDragStart   -   Point to be checked
//
// Return Value:
//      TRUE                -   Point in selection
//      FALSE               -   Point not in selection
//**********************************************************************
static BOOL PointInSel(HWND hWnd,
                       POINT ptDragStart)
{
    DWORD   dwStart, dwEnd;
    int     dwCharPos;
    TCHAR   szMessage[40];
    HGLOBAL hText;
    int     nChars, nRetChars;
    LPTSTR  lpszEditText;

    // Get current selection
    SendMessage(hWnd, EM_GETSEL, (WPARAM)&dwStart, (LPARAM)&dwEnd);

    // IF there is not selection
    if (dwStart == dwEnd) {
        return FALSE;
    }

    // EM_CHARFROMPOS did not work, find why
    // dwCharPos = SendMessage(hWnd, EM_CHARFROMPOS, (WPARAM)0L, (LPARAM)&ptDragStart);

    // Get text from edit control
    nChars = GetWindowTextLength(hWnd);
    if (!(hText = GlobalAlloc(GMEM_SHARE | GMEM_ZEROINIT, CTOB((nChars + 1)))))
    {
        return (FALSE);
    }
    lpszEditText = (LPTSTR)GlobalLock(hText);

    nRetChars = GetWindowText(hWnd, lpszEditText, nChars+1);
    GlobalUnlock(hText);

    // Find char from click
    dwCharPos = XToCP(hWnd, lpszEditText, ptDragStart);
    GlobalFree(hText);

    wsprintf(szMessage, TEXT("%d %d %d\n"), dwStart, dwEnd, dwCharPos);
    TRACE(szMessage);

    // Find if it is within selection
    if (((DWORD)dwCharPos >= dwStart) && ((DWORD)dwCharPos < dwEnd)) {
        return TRUE; // Lbutton was down in selection
    }

    return FALSE;
}

//**********************************************************************
// XToCP
//
// Purpose:
//      Returns char index of the character nearest to specified point
//
// Parameters:
//      HWND    hWnd        -   Edit Control Handle
//      LPTSTR  lpszText    -   Edit control text
//      POINT   ptDragStart -   Point to be checked
//
// Return Value:
//      int                 -   Char nearest to specified point
//**********************************************************************
static int XToCP(HWND   hWnd,
                 LPTSTR lpszText,
                 POINT  ptDragStart)
{
    int     nLength, i, x = 0, xPos = ptDragStart.x;
    int     iWidth[2];
    BOOL    fSuccess, fCharFound=FALSE;
    HDC     hDC;
    HFONT   hFont, hOldFont;

    nLength = wcslen(lpszText);
    hDC = GetDC(hWnd);
    hFont = (HFONT)SendMessage(hWnd, WM_GETFONT, (WPARAM)0L, (LPARAM)0L);
    hOldFont = (HFONT)SelectObject(hDC, hFont);

    for(i=0; i<nLength; i++) {
        fSuccess = GetCharWidth32(hDC,
            lpszText[i],
            lpszText[i],
            iWidth);

        if (fSuccess == FALSE) {
            ReleaseDC(hWnd, hDC);
            return -1;
        }

        x += iWidth[0];

        if (x > xPos) {
            fCharFound = TRUE;
            break;
        }
    }

    SelectObject(hDC, hOldFont);
    ReleaseDC(hWnd, hDC);

    return ((fCharFound==TRUE)? i: -1);
}

//**********************************************************************
// EditCtrlDragAndDrop
//
// Purpose:
//      Does drag and drop of text currently selected in edit control
//
// Parameters:
//      HWND          hWnd        -   Edit Control Handle
//      LPDROPSOURCE  pDropSource -   Pointer to drop source
//
// Return Value:
//      0                         -   Success
//      -1                        -   Failure
//**********************************************************************
static int EditCtrlDragAndDrop(HWND         hWndDlg,
                               HWND         hWndEdit,
                               LPDROPSOURCE pDropSource)
{
    PCImpIDataObject    pDataObject;
    DWORD               dwEffect, dwStart, dwEnd;
    LPTSTR              lpszEditText, lpszSelectedText;
    HGLOBAL             hText;
    int                 nChars, nRetChars;

    // Get current selection
    SendMessage(hWndEdit, EM_GETSEL, (WPARAM)&dwStart, (LPARAM)&dwEnd);
    // IF there is not selection
    if (dwStart == dwEnd) {
        return 0;
    }

    nChars = GetWindowTextLength(hWndEdit);
    if (!(hText = GlobalAlloc(0, CTOB((nChars + 1)))))
    {
        return (-1);
    }
    lpszEditText = (LPTSTR)GlobalLock(hText);
    nRetChars = GetWindowText(hWndEdit, lpszEditText, nChars+1);

    // The text in which we are interested is the selected text
    lpszSelectedText = lpszEditText + dwStart;
    lpszSelectedText[dwEnd-dwStart] = 0;

    GlobalUnlock(hText);

    // Create an instance of the DataObject
    pDataObject = new CImpIDataObject(hWndDlg);

    if (pDataObject == NULL)
    {
        GlobalFree(hText);
        return -1;
    }

    pDataObject->SetText(lpszSelectedText);

    // Do drag and drop with copy
    DoDragDrop(pDataObject, pDropSource, DROPEFFECT_COPY, &dwEffect);

    // Free instance of DataObject
    pDataObject->Release();

    GlobalFree(hText);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\uce.h ===
/********************************************************************
 *
 *  Header Name : uce.h
 *
 *  Copyright (c) 1997-1999 Microsoft Corporation. 
 *
 ********************************************************************/

#ifndef __UCE_H__
#define __UCE_H__

#include "cmdlg.h"
#include "ucefile.h"

#define BTOC(bytes)      ((bytes) / sizeof(TCHAR))
#define CTOB(cch)        ((cch) * sizeof(TCHAR))
#define UCHAR            unsigned char
#define UTCHAR           unsigned short

#define ASCII_BEG        0x21
#define ASCII_END        0x7F

#define HIANSI_BEG       0x80
#define HIANSI_END       0xFF

#define TRAILBYTE_BEG    0x40
#define TRAILBYTE_END    0xFE

#define DELETE_CHAR      0x7f
#define UNICODE_CODEPAGE 1200

#define cchFullMap       (200)

#define  TWO_BYTE_NUM(p)                           (((p[0])<<8)|(p[1]))
#define FOUR_BYTE_NUM(p) (((p[0])<<24)|((p[1])<<16)|((p[2])<<8)|(p[3]))

// Font types

#define TRUETYPE_FONT         0x00000004
#ifndef PS_OPENTYPE_FONTTYPE
#define PS_OPENTYPE_FONTTYPE  0x00010000
#endif
#ifndef TT_OPENTYPE_FONTTYPE
#define TT_OPENTYPE_FONTTYPE  0x00020000
#endif
#ifndef TYPE1_FONTTYPE
#define TYPE1_FONTTYPE        0x00040000
#endif
#define EUDC_FONTTYPE         0x10000000
#define SYMBOL_FONTTYPE       0x20000000
#define OEM_FONTTYPE          0x40000000
#define DBCS_FONTTYPE         0x80000000

//should be hardcoded but let's lock it during localization.
//we'll hardcode it after Win2K
//#define RTFFMT                TEXT("Rich Text Format")

typedef struct {
  char  TTCTag    [4];
  BYTE  Version   [4];
  BYTE  DirCount  [4];
  BYTE  OffsetTTF1[4];
} TTC_HEAD;

typedef struct {
  BYTE  Version      [4];
  BYTE  NumTables    [2];
  BYTE  SearchRange  [2];
  BYTE  EntrySelector[2];
  BYTE  RangeShift   [2];
} TTF_HEAD;

typedef struct {
  char  Tag     [4];
  BYTE  CheckSum[4];
  BYTE  Offset  [4];
  BYTE  Length  [4];
} TABLE_DIR;

typedef struct {
  BYTE  Format[2];
  BYTE  NumRec[2];
  BYTE  Offset[2];
} NAME_TABLE;

#define FONT_SUBFAMILY_NAME 2
#define MICROSOFT_PLATFORM  3
#define UNICODE_INDEXING    1
#define CMAP_FORMAT_FOUR    4

typedef struct {
  BYTE  Platform[2];
  BYTE  Encoding[2];  // = 1 if string is in Unicode
  BYTE  LangID  [2];
  BYTE  NameID  [2];  // = 2 for font subfamily name
  BYTE  Length  [2];
  BYTE  Offset  [2];
} NAME_RECORD;

typedef struct {
  BYTE  Version  [2];
  BYTE  NumTables[2];
} CMAP_HEAD;

typedef struct {
  BYTE  Platform[2];  // = 3 if Microsoft
  BYTE  Encoding[2];  // = 1 if string is in Unicode
  BYTE  Offset  [4];
} CMAP_TABLE;

typedef struct {
  BYTE  Format       [2];  // must be 4
  BYTE  Length       [2];
  BYTE  Version      [2];
  BYTE  SegCountX2   [2];
  BYTE  SeachgRange  [2];
  BYTE  EntrySelector[2];
  BYTE  RangeShift   [2];
} CMAP_FORMAT;

typedef struct {
  WCHAR wcFrom;
  WCHAR wcTo;
} URANGE;

typedef struct tagSYCM
  {
    INT dxpBox;
    INT dypBox;
    INT dxpCM;
    INT dypCM;
    INT xpCh;
    INT ypCh;
    INT dxpMag;
    INT dypMag;
    INT xpMagCurr;
    INT ypMagCurr;
    INT ypDest;
    INT xpCM;
    INT ypCM;
    INT CPgNum;
    INT ChWidth;

    BOOL fHasFocus;
    BOOL fFocusState;
    BOOL fMouseDn;
    BOOL fCursorOff;
    BOOL fMagnify;
    BOOL fAnsiFont;
    UTCHAR chCurr;
    HFONT hFontMag;
    HFONT hFont;
    HDC hdcMag;
    HBITMAP hbmMag;
    INT rgdxp[256];
  } SYCM;
typedef SYCM *PSYCM;

typedef struct tagITEMDATA
  {
    SHORT FontType;
    BYTE CharSet;
    BYTE PitchAndFamily;
  } ITEMDATA;

#define LF_SUBSETSIZE    128
#define LF_CODEPAGESIZE  128
#define LF_EUDCFACESIZE  256 // wingdi defines length of FACESIZE as 32 chars.
                             // charmap attaches string "Private Characters" to
                             // face name. 256 should be long enough to handle
                             // face names. 

typedef struct tagUSUBSET
  {
    INT BeginRange;
    INT EndRange;
    INT StringResId;
    TCHAR Name[LF_SUBSETSIZE];
  } USUBSET;

typedef struct tagUCODEPAGE
  {
    INT BeginRange;
    INT EndRange;
    INT StringResId;
    TCHAR Name[LF_CODEPAGESIZE];
  } UCODEPAGE;

#define MAX_LEN 50

typedef struct _tagFontInfo {
    TCHAR  szFaceName[LF_EUDCFACESIZE];
    BYTE   CharSet;
    DWORD  FontType;
    BYTE   PitchAndFamily;
    URANGE *pUniRange;
    UINT   nNumofUniRange;
} FONTINFO,*LPFONTINFO;

typedef struct tagValidateData {
    int nControlId;
    int iMinValue;
    int iMaxValue;
    int iDefaultValue;
    int iMaxChars;
} ValidateData;

/* Function declarations. */

BOOL InitApplication(HINSTANCE);
BOOL InitInstance(HINSTANCE, INT);
INT_PTR  APIENTRY UCEDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT  APIENTRY CharGridWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK MsgProc(HWND, UINT, WPARAM, LPARAM);
UINT ChFromSymLParam(PSYCM, LPARAM);
VOID DrawSymChOutlineHwnd(PSYCM, HWND, UTCHAR, BOOL, BOOL);
VOID RecalcUCE(HWND, PSYCM, INT, BOOL);
VOID DrawSymbolMap(PSYCM, HDC);
VOID DrawSymbolGrid(PSYCM, HDC);
VOID DrawSymbolChars(PSYCM, HDC);
VOID DrawSymChOutline(PSYCM, HDC, UTCHAR, BOOL, BOOL);
VOID MoveSymbolSel(PSYCM, UTCHAR, BOOL fRepaint=FALSE);
VOID RestoreSymMag(HWND, PSYCM);
HANDLE GetEditText(HWND);
INT PointsToHeight(INT);

VOID PaintStatusLine(HDC, BOOL, BOOL);
VOID UpdateKeystrokeText( HDC hdc, UTCHAR chNew, BOOL fRedraw);

INT KeyboardVKeyFromChar(UTCHAR);
BOOL DrawFamilyComboItem(LPDRAWITEMSTRUCT);
HBITMAP LoadBitmaps(INT);
VOID DoHelp(HWND, BOOL);

VOID ExitMagnify(HWND, PSYCM);

BOOL CALLBACK SubSetDlgProc(HWND, UINT, WPARAM, LPARAM);

VOID UpdateSymbolSelection(HWND, BOOL);

VOID UpdateSymbolRange( HWND hwnd, INT FirstChar, INT LastChar );

VOID SubSetChanged( HWND hwnd);

DWORD GetCurFontCharSet(HWND hWnd);
int ConvertAnsifontToUnicode(HWND hWnd, char* mb, WCHAR* wc); 
int ConvertUnicodeToAnsiFont(HWND hWnd, WCHAR* wc, char* mb); 
VOID ProcessScrollMsg( HWND hwnd, int nCode, int nPos );
INT ScrollMapPage( HWND hwndDlg, BOOL fUp, BOOL fRePaint );
BOOL ScrollMap( HWND hwndDlg, INT cchScroll, BOOL fRePaint );
void SetEditCtlFont( HWND hwndDlg, int idCtl, HFONT hfont );
void GetFonts(void);
LONG WCharCP(UINT CodePage, WCHAR *lpWC);
URANGE* EUDC_Range(TCHAR* Path, DWORD* pSize);
void UnicodeBar(void);
int ShowHideAdvancedControls(HWND hWnd, WPARAM wParam, LPARAM lParam);
void ComputeExpandedAndShrunkHeight(HWND hDlg);
void ResizeDialog(HWND hWnd);

void CopyTextToClipboard(HWND hWndDlg);
void SetRichEditFont(HWND hwndDlg, int idCtl, HFONT hFont);
int DoDragScroll(HWND hWnd, WPARAM wParam, LPARAM lParam);
int UnicodeRangeChecked(HWND hWnd);
int EnableSURControls(HWND hWnd, BOOL fForceDisable=FALSE);
int SURangeChanged(HWND hWnd);
static BOOL SetHexEditProc(HWND hWndEdit);
static LRESULT CALLBACK HexEditControlProc(HWND hWnd,UINT uMessage, WPARAM  wParam, LPARAM  lParam);
static BOOL SetSearchEditProc(HWND hWndEdit);
static LRESULT CALLBACK SearchEditControlProc(HWND hWnd,UINT uMessage, WPARAM  wParam, LPARAM  lParam);
int ValidateValues(HWND hWnd);
void ResizeTipsArea(HWND hWndGrid, PSYCM psycm);

extern HINSTANCE hInst;
extern HWND hwndDialog;
extern HWND hwndCharGrid;

extern HWND ghwndList;
extern HWND ghwndGrid;
extern BOOL fDisplayAdvControls;
extern LPWSTR pCode;
extern SYCM   sycm;
extern int    nDragDelay, nDragMinDist;
extern FONTINFO *Font_pList;


#define M64K 65536


BOOL CodePage_InitList();
BOOL CodePage_DeleteList();
BOOL CodePage_AddToList(LONG);
BOOL CodePage_FillToComboBox(HWND ,UINT);
LONG CodePage_GetCurSelCodePage(HWND,UINT);
LONG CodePage_GetCurCodePageVal();
BOOL CodePage_SetCurrent( LONG  , HWND  , UINT  );
BOOL IsCodePageOnList( WORD );

BOOL Display_DeleteList();
BOOL Display_InitList();
LPWSTR Display_CreateDispBuffer(LPWSTR,INT,URANGE *,INT,BOOL);
LPWSTR Display_CreateSubsetDispBuffer(LPWSTR,INT,URANGE *,INT,BOOL,int,int);

BOOL Subset_FillComboBox( HWND hWnd , UINT uID );
BOOL Subset_GetUnicodeCharsToDisplay(HWND,UINT,LONG,LPWSTR *,UINT *,BOOL *);
BOOL GetUnicodeBufferOfCodePage( LONG , PWSTR *, UINT *) ;
BOOL Subset_GetUnicode( HWND, PUCE_MEMORY_FILE , PWSTR * , UINT *, BOOL *);
BOOL GetUnicodeCharsFromList( HWND , PUCE_MEMORY_FILE , PWSTR , UINT * , BOOL *);
BOOL Subset_OnSelChange( HWND hWnd , UINT uID ) ;

BOOL Font_InitList(HWND hWnd);
BOOL Font_DeleteList();
BOOL Font_AddToList(LPLOGFONT,DWORD,URANGE *,INT);
BOOL Font_FillToComboBox(HWND ,UINT);
BYTE Font_GetSelFontCharSet(HWND,UINT,INT);
BOOL Font_SelectByCharSet(HWND,UINT,UINT);
BOOL Font_GetCharWidth32(HDC ,UINT ,UINT ,LPINT, LPWSTR);
BOOL Font_GetCurCMapTable(HWND,UINT,URANGE **,UINT*);
BOOL Font_Avail(UINT);
UINT Font_DBCS_CharSet();
UINT CharSetToCodePage(BYTE cs);
DWORD URanges(UINT CodePage, URANGE *pUR);


// Grid & List Window

HWND CreateListWindow( HWND  , PWSTR  );
void CreateResources( HINSTANCE, HWND );
void DeleteResources( void );
LRESULT CALLBACK ListWndProc( HWND , UINT , WPARAM  , LPARAM );
LRESULT CALLBACK GridWndProc( HWND , UINT , WPARAM  , LPARAM );
void FillGroupsInListBox( HWND , PUCE_MEMORY_FILE ) ;
void DestroyListWindow( void );
void DestroyGridWindow( void );
void DestroyAllListWindows( void ) ;
BOOL IsListWindow( PUCE_MEMORY_FILE );
HWND CreateGridWindow( HWND hwndParent , UINT uID , PUCE_MEMORY_FILE pUceMemFile );
void GetWindowGridSize( PUCE_MEMORY_FILE  , POINT * , INT * , INT * );
BOOL GridHScroll( HWND  , UINT  , WPARAM  , LPARAM  );
BOOL GridVScroll( HWND  , UINT  , WPARAM  , LPARAM  );
void DrawGridCell( HDC  , RECT * , BOOL  , WCHAR  , BOOL );
void DoPaint( HWND  , HDC  );
__inline BOOL GetCurrentRect( RECT * );
__inline void GetCurrentGroupChar( PWSTR );
__inline BOOL GridSamePointHit( POINT );
BOOL GetUnicodeCharsFromGridWindow( HWND , PWSTR  , UINT * , BOOL *);
BOOL IsGridWindowAlive( void );
BOOL CreateNewGridFont( HWND  , UINT  );
BOOL CreateNewListFont( HWND  , UINT  );
BOOL UpdateGridFont( HWND  , UINT  );
BOOL UpdateListFont( HWND  , UINT  );
BOOL IsAnyListWindow( void );
void GetWChars( INT  , WCHAR * , WCHAR * , UINT * , BOOL *);
__inline BOOL IsCellEnabled( INT  , INT  );

INT  LoadCurrentSelection(HWND, UINT, LPTSTR, LPTSTR);
BOOL SaveCurrentSelection(HWND, UINT, LPTSTR);
VOID GetSystemPathName(PWSTR ,PWSTR ,UINT );
INT  LoadAdvancedSelection(HWND, UINT, LPTSTR);
BOOL SaveAdvancedSelection(HWND, UINT,LPTSTR);

BOOL LoadNeedMessage();
void SaveNeedMessage(BOOL nMsg);

void SetSearched(void);

#define SZ_CODEPAGE         TEXT("CodePage")
#define SZ_CODEPAGE_DEFAULT TEXT("1200")
#define SZ_SUBSET           TEXT("Subset")
#define SZ_SUBSET_DEFAULT   TEXT("All")         // cannot be macro ???
#define SZ_SUBFUNC          TEXT("SubFunc")
#define SZ_SUBFUNC_DEFAULT  TEXT("0")           // cannot be macro ???
#define SZ_FONT             TEXT("Font")
#define SZ_FONT_DEFAULT     TEXT("Arial")       // cannot be macro ???
#define SZ_ADVANCED         TEXT("Advanced")

#define ID_SUBFUNCCHANGED   501

// If debug functionality is needed turn to 1
//#define DBG 0

#ifdef _DEBUG
#define TRACE    OutputDebugString

#else // _DEBUG

#define TRACE    NOP_FUNCTION

#endif // _DEBUG
#endif  // __UCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\winchat\dialogs.c ===
/*---------------------------------------------------------------------------*\
| WINCHAT RESOURCE FILE
|   This module defines the resources for the WinChat application
|
|   FUNCTIONS
|   ---------
|   dlgConnectProc
|   dlgPreferencesProc
|
|
| Copyright (c) Microsoft Corp., 1990-1993
|
| created: 01-Nov-91
| history: 01-Nov-91 <clausgi>  created.
|          29-Dec-92 <chriswil> port to NT, cleanup.
|          19-Oct-93 <chriswil> unicode enhancements from a-dianeo.
|
\*---------------------------------------------------------------------------*/

#include <windows.h>
#include <ddeml.h>
#include <commdlg.h>
#include <winchat.h>
#include "dialogs.h"
#include "globals.h"


#ifdef WIN16
#pragma alloc_text (_DLGS, dlgConnectProc, dlgPreferencesProc)
#endif
/*---------------------------------------------------------------------------*\
| DISPLAY DIALOG BOX
|   This is a routine to display a generic modal-dialog box.
|
| created: 29-Dec-92
| history: 29-Dec-92 <chriswil> created.
|
\*---------------------------------------------------------------------------*/
INT_PTR FAR dlgDisplayBox(HINSTANCE hInstance, HWND hWndParent, LPTSTR lpszTemplate, DLGPROC lpfFunction, LPARAM lParam)
{
    INT_PTR nRet;


    nRet = DialogBoxParam(hInstance,lpszTemplate,hWndParent,lpfFunction,lParam);

    return(nRet);
}


/*---------------------------------------------------------------------------*\
| CONNECT DIALOGBOX PROCEDURE
|   This routines prompts the connection dialogbox
|
| created: 11-Nov-91
| history: 29-Dev-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
INT_PTR CALLBACK dlgConnectProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL bHandled;


    bHandled = TRUE;
    switch(msg)
    {
        // result in global szConvPartner (CODEWORK replace lParam)
        //
        case WM_INITDIALOG:
            szConvPartner[0] = TEXT('\0');
            break;


        case WM_COMMAND:
            switch(wParam)
            {
                case IDOK:
                    GetDlgItemText(hwnd,IDC_CONNECTNAME,szBuf,SZBUFSIZ);
                    EndDialog(hwnd,0);
                    break;

                case IDCANCEL:
                    szConvPartner[0] = TEXT('\0');
                    EndDialog(hwnd,0);
                    break;

                default:
                    bHandled = FALSE;
                    break;
            }
            break;


        default:
            bHandled = FALSE;
            break;
    }

    return(bHandled);
}


/*---------------------------------------------------------------------------*\
| PREFERENCES DIALOGBOX PROCEDURE
|   This routines prompts the connection dialogbox
|
| created: 11-Nov-91
| history: 29-Dev-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/

// context sensitive help array
static const DWORD aHelpIDs[] =
{
    ID_TOPANDBOTTOM,    IDH_TOPANDBOTTOM,
    ID_SIDEBYSIDE  ,    IDH_SIDEBYSIDE,
    ID_RECEIVEPFONT,    IDH_RECEIVEPFONT,
    ID_RECEIVEOFONT,    IDH_RECEIVEOFONT,
    IDOK           ,    IDH_OKBUTTON,
    IDCANCEL       ,    IDH_CANCELBUTTON,
    0,    0
};

INT_PTR CALLBACK dlgPreferencesProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL bHandled;
    UINT tmp;


    bHandled = TRUE;
    switch(msg)
    {
        case WM_INITDIALOG:
            CheckDlgButton(hwnd,ID_SIDEBYSIDE  ,ChatState.fSideBySide);
            CheckDlgButton(hwnd,ID_TOPANDBOTTOM,!ChatState.fSideBySide);
            CheckDlgButton(hwnd,ID_RECEIVEOFONT,ChatState.fUseOwnFont);
            CheckDlgButton(hwnd,ID_RECEIVEPFONT,!ChatState.fUseOwnFont);
            break;


        case WM_COMMAND:
            switch(wParam)
            {
                case IDOK:
                    tmp = (BOOL)SendDlgItemMessage(hwnd,ID_RECEIVEOFONT,BM_GETCHECK,0,0L);

                    if(tmp != ChatState.fUseOwnFont)
                    {
                        ChatState.fUseOwnFont = tmp;

                        // delete old objects
                        //
                        if(hEditRcvFont)
                            DeleteObject(hEditRcvFont);

                        if(hEditRcvBrush)
                            DeleteObject(hEditRcvBrush);

                        if(ChatState.fUseOwnFont)
                        {
                            hEditRcvFont  = CreateFontIndirect((LPLOGFONT)&lfSnd);
                            hEditRcvBrush = CreateSolidBrush(SndBrushColor);
                        }
                        else
                        {
                            RcvBrushColor = PartBrushColor;
                            hEditRcvFont  = CreateFontIndirect((LPLOGFONT)&lfRcv);
                            hEditRcvBrush = CreateSolidBrush(RcvBrushColor);
                        }

                        if(hEditRcvFont)
                        {
                            SendMessage(hwndRcv,WM_SETFONT,(WPARAM)hEditRcvFont,1L);
                            InvalidateRect(hwndRcv,NULL,TRUE);
                        }

                    }

                    tmp = (BOOL)SendDlgItemMessage(hwnd,ID_SIDEBYSIDE,BM_GETCHECK,0,0L);

                    if(tmp != ChatState.fSideBySide)
                    {
                        ChatState.fSideBySide = tmp;
                        AdjustEditWindows();
                        InvalidateRect(hwndApp,NULL,FALSE);
                    }

                    EndDialog(hwnd,0);
                    break;


                case IDCANCEL:
                    EndDialog(hwnd,0);
                    break;


                default:
                    bHandled = FALSE;
                    break;
            }
            break;

           case WM_HELP:
                {
                    LPHELPINFO lphi;
                    lphi = (LPHELPINFO)lParam;
                    if (lphi->iContextType == HELPINFO_WINDOW)   // must be for a control
                    {         WinHelp (lphi->hItemHandle, szHelpFile,
                                  HELP_WM_HELP, (ULONG_PTR)aHelpIDs);
                    }
                    return TRUE;
                }
                break;

           case WM_CONTEXTMENU:
                {
                    WinHelp ((HWND)wParam, szHelpFile, HELP_CONTEXTMENU,
                    (ULONG_PTR)aHelpIDs);
                    return TRUE;
                }
                break;

        default:
            bHandled = FALSE;
            break;
    }

    return(bHandled);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\winchat\dialogs.h ===
/*---------------------------------------------------------------------------*\
| DIALOGS HEADER
|   This module contains the definitions for the dialog object.
|
|
| Copyright (c) Microsoft Corp., 1990-1993
|
| created: 01-Nov-91
| history: 01-Nov-91 <clausgi>  created.
|          29-Dec-92 <chriswil> port to NT, cleanup.
|          19-Oct-93 <chriswil> unicode enhancements from a-dianeo.
|
\*---------------------------------------------------------------------------*/

#define IDD_CONNECT         100
#define IDC_CONNECTNAME     101
#define IDD_PREFERENCES     200
#define ID_SIDEBYSIDE       201
#define ID_ANSONRESTORE     202
#define ID_TOPANDBOTTOM     203
#define ID_RECEIVEPFONT     204
#define ID_RECEIVEOFONT     205

/*
 * Context sensitive help IDs
 */
#define IDH_TOPANDBOTTOM    302
#define IDH_SIDEBYSIDE      303
#define IDH_RECEIVEPFONT    304
#define IDH_RECEIVEOFONT    305
#define IDH_OKBUTTON        306
#define IDH_CANCELBUTTON    307


INT_PTR  FAR  dlgDisplayBox(HINSTANCE,HWND,LPTSTR,DLGPROC,LPARAM);
INT_PTR CALLBACK dlgPreferencesProc(HWND,UINT,WPARAM,LPARAM);
INT_PTR CALLBACK dlgConnectProc(HWND,UINT,WPARAM,LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\winchat\dde.c ===
/*---------------------------------------------------------------------------*\
| DDE MODULE
|   This module contains the routines necessary for maintaining dde
|   conversations.
|
|   FUNCTIONS
|   ---------
|   CreateCharData
|   CreatePasteData
|   SendFontToPartner
|
|
| Copyright (c) Microsoft Corp., 1990-1993
|
| created: 01-Nov-91
| history: 01-Nov-91 <clausgi>  created.
|          29-Dec-92 <chriswil> port to NT, cleanup.
|          19-Oct-93 <chriswil> unicode enhancements from a-dianeo.
|
\*---------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include <ddeml.h>
#include <commdlg.h>
#include <commctrl.h>
#include "winchat.h"
#include "globals.h"

// CP963
BOOL TranslateMultiBytePosToWideCharPos( HWND hWnd, DWORD dwStart, DWORD dwEnd, LPDWORD lpdwStart, LPDWORD lpdwEnd )
{

    INT     nLine=0, wChars = 0, i, j, delta;   // Just to make compiler happy, initialize wChars here.
    DWORD   mCnt=0, mChars, offset, p_offset=0;
    HANDLE  hText;
    PTCHAR  pStartText;
    CHAR   szBuff[800];
    LONG   wStart, wEnd;


    *lpdwStart = 0;
    *lpdwEnd   = 0;
    wStart     = -1;
    wEnd       = -1;

    hText = (HANDLE)SendMessage( hWnd, EM_GETHANDLE, 0, 0);
    if( !( hText ) )
        return( FALSE );

    pStartText = LocalLock( hText);
    if( !( pStartText ) )
    {
        LocalUnlock( hText );
        return( FALSE );
    }

    while(1)
    {
        INT flag = 0;

        offset = (DWORD)SendMessage( hWnd, EM_LINEINDEX, nLine++, 0 );

        if( offset > 0 ) {                           //0D0A
            delta = offset - (p_offset+wChars);
            if( delta ) mCnt += delta;
            p_offset = offset;
        } else if ( offset == 0) {
            *lpdwStart = dwStart;
            *lpdwEnd   = dwEnd;
            LocalUnlock( hText );
            return( TRUE );
        } else {
            LocalUnlock( hText );
            return( FALSE );
        }

        wChars = (WORD)SendMessage( hWnd, EM_LINELENGTH, offset, 0 );

        mChars = WideCharToMultiByte( CP_ACP, 0, pStartText+offset,
            wChars, NULL, 0, NULL, NULL );

        if( (dwStart>=mCnt) && (dwStart<=mCnt+mChars)) flag |= 1;
        if((dwEnd>=mCnt) && (dwEnd<=mCnt+mChars))      flag |= 2;
        if( flag )
        {
            WideCharToMultiByte( CP_ACP, 0, pStartText+offset, wChars,
                szBuff, mChars, NULL, NULL );

            for(i=0,j=0; ; i++,j++ )
            {
                if( (flag&1) && (wStart==-1) )
                {
                    if(dwStart <= (mCnt+i) )
                    {
                        wStart = offset+j;
                        if( flag == 1 ) break;
                    }
                }
                if( (flag&2) && (wEnd==-1) )
                {
                    if(dwEnd <= (mCnt+i) )
                    {
                        wEnd = offset+j;
                        if( flag == 2 ) break;
                    }
                }
                if( (flag==3) && (wStart>-1) && (wEnd>-1) ) break;
                if( IsDBCSLeadByte(szBuff[i]) ) i++;
            }
        }
        if( (wStart>-1) && (wEnd>-1) )  break;
        mCnt += mChars;
    }

    *lpdwStart = (DWORD)wStart;
    *lpdwEnd   = (DWORD)wEnd;

   LocalUnlock( hText );
   return( TRUE );
}

BOOL
TranslateWideCharPosToMultiBytePos( HWND hWnd, DWORD dwStart, DWORD dwEnd, LPDWORD lpdwStart, LPDWORD lpdwEnd )
{
    INT     nLine=0, wChars = 0, i, j,delta;    // Just to make compiler happy, initialize wChars here.
    DWORD   mChars, mCnt=0, offset, p_offset=0;
    HANDLE  hText;
    PTCHAR  pStartText;
    CHAR   szBuff[800];
    LONG   mStart, mEnd;


    *lpdwStart = 0;
    *lpdwEnd = 0;
    mStart = -1;
    mEnd = -1;

    hText = (HANDLE)SendMessage( hWnd, EM_GETHANDLE, 0, 0);
    if( !( hText ) )
        return( FALSE );

    pStartText = LocalLock( hText);
    if( !( pStartText ) )
    {
        LocalUnlock( hText );
        return( FALSE );
    }

    while(1)
    {
        INT flag = 0;

        offset = (DWORD)SendMessage( hWnd, EM_LINEINDEX, nLine++, 0 );

        if( offset > 0 ) {                           //ODOA
            delta = offset - (p_offset+wChars);
            if( delta ) mCnt += delta;
            p_offset = offset;
        } else if ( offset == 0) {
            *lpdwStart = dwStart;
            *lpdwEnd   = dwEnd;
            LocalUnlock( hText );
            return( TRUE );
        } else {
            LocalUnlock( hText );
            return( FALSE );
        }

        wChars = (WORD)SendMessage( hWnd, EM_LINELENGTH, offset, 0 );

        mChars = WideCharToMultiByte( CP_ACP, 0, pStartText+offset,
            wChars, NULL, 0, NULL, NULL );

        if( (dwStart>=offset) && (dwStart<=offset+wChars)) flag |= 1;
        if( (dwEnd>=offset) && (dwEnd<=offset+wChars) ) flag |= 2;
        if( flag )
        {
            WideCharToMultiByte( CP_ACP, 0, pStartText+offset, wChars,
                szBuff, mChars, NULL, NULL );

            for(i=0,j=0; ; i++, j++ )
            {
                if( (flag&1) && (mStart==-1) )
                {
                    if(dwStart == (offset+i) )
                    {
                        mStart = mCnt+j;
                        if( flag==1 ) break;
                    }
                }
                if( (flag&2) && (mEnd==-1) )
                {
                    if(dwEnd == (offset+i) )
                    {
                        mEnd = mCnt+j;
                        if( flag == 2 ) break;
                    }
                }
                if( (flag==3) && (mStart>-1) && (mEnd>-1) ) break;
                if( IsDBCSLeadByte(szBuff[j]) ) j++;
            }
        }
        if( (mStart>-1) && (mEnd>-1) )  break;
        mCnt += mChars;
    }
    *lpdwStart = (DWORD)mStart;
    *lpdwEnd   = (DWORD)mEnd;

   LocalUnlock( hText );
   return( TRUE );
}


/*---------------------------------------------------------------------------*\
| DDE CALLBACK PROCEDURE
|   This routine handles the events sent by DDEML.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
HDDEDATA CALLBACK DdeCallback(UINT wType, UINT wFmt, HCONV hConv, HSZ hszTopic, HSZ hszItem, HDDEDATA hData, DWORD lData1, DWORD lData2)
{
    HDC      hdc;
    HDDEDATA hRet;
    WPARAM   wParam;
    LPARAM   lParam;
    DWORD    dwTemp1,dwTemp2;

    hRet = (HDDEDATA)0;
    switch(wType)
    {
        case XTYP_REGISTER:
        case XTYP_UNREGISTER:
            break;


            case XTYP_XACT_COMPLETE:
                    if(lData1 == XactID)
            {
                            if(hData != (HDDEDATA)0)
                {
                                    ChatState.fServerVerified = TRUE;
                            }
                else
                {
                                    SetStatusWindowText(szNoConnect);
                                    ChatState.fConnectPending = FALSE;
                                    UpdateButtonStates();
                            }
            }
            break;


            case XTYP_ADVDATA:
            case XTYP_POKE:
            if(ChatState.fConnected && (wFmt == cf_chatdata))
            {
                DdeGetData(hData,(LPBYTE)&ChatDataRcv,sizeof(ChatDataRcv),0L);

// This is failing in some cases.  Eventually, this should be in.
//
#ifndef DDEMLBUG
                if(DdeGetLastError(idInst) == DMLERR_NO_ERROR)
#endif
                {
                    switch(ChatDataRcv.type)
                    {
                        // FE specific:
                        // We have a DBCS string selection.
                        //
                        case CHT_DBCS_STRING:
                        {
                            HANDLE  hStrBuf;
                            LPSTR   lpStrBuf;

                            hStrBuf = GlobalAlloc(GMEM_FIXED,ChatDataRcv.uval.cd_dbcs.size+1);
                            if (hStrBuf)
                            {
                                lpStrBuf = GlobalLock(hStrBuf);
                                if (lpStrBuf)
                                {
                                    DdeGetData(hData,(BYTE *)lpStrBuf,ChatDataRcv.uval.cd_dbcs.size+1,XCHATSIZEA);

#ifndef DDEMLBUG
                                    if (DdeGetLastError(idInst) == DMLERR_NO_ERROR)
#endif
                                    {
                                        SendMessage(hwndRcv,EM_SETREADONLY,(WPARAM)FALSE,0L);
                                    #ifdef UNICODE
                                    {
                                        LPWSTR lpStrUnicode;
                                        ULONG  cChars = strlen(lpStrBuf) + 1;

                                        //
                                        // Get text output position from DDE packet, and set it to EditControl.
                                        //
                                        // !!! BUG BUG BUG !!!
                                        //
                                        //  If the sender is not Unicode Edit control. the position data might be
                                        // stored for MBCS string context.
                                        // in that case, we might draw the text at incorrect position.
                                        //
                                        // We have to convert to fit Unicode string.

//                                        wParam = SET_EM_SETSEL_WPARAM(LOWORD(
//ChatDataRcv.uval.cd_dbcs.SelPos),HIWORD(ChatDataRcv.uval.cd_dbcs.SelPos));
//                                        lParam = SET_EM_SETSEL_LPARAM(LOWORD(
//ChatDataRcv.uval.cd_dbcs.SelPos),HIWORD(ChatDataRcv.uval.cd_dbcs.SelPos));


                                        TranslateMultiBytePosToWideCharPos(
                                            hwndRcv,
                                            (DWORD)LOWORD(ChatDataRcv.uval.cd_dbcs.SelPos),
                                            (DWORD)HIWORD(ChatDataRcv.uval.cd_dbcs.SelPos),
                                            &dwTemp1,
                                            &dwTemp2 );
                                        // sign extend them
                                        wParam=(WPARAM)(INT_PTR)dwTemp1;
                                        lParam=(LPARAM)(INT_PTR)dwTemp2;
                                        SendMessage(hwndRcv, EM_SETSEL, wParam, lParam);

                                        //
                                        // Allocate temporary buffer for Nls conversion.
                                        //

                                        if((lpStrUnicode = LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT,
                                                                      cChars * 2)) == NULL )
                                        {
                                           break;
                                        }

                                        //
                                        //  Convert MBCS to Unicode. because DDE packet contains MBCS string any time
                                        // for downlevel connectivity, But if we are compiled with -DUNICODE flag,
                                        // EditControl can only handled Unicode, just convert it.
                                        //

                                        MultiByteToWideChar(CP_ACP,0,
                                                            lpStrBuf, cChars,
                                                            lpStrUnicode, cChars
                                                           );

                                        // Set string to EditControl.

                                        SendMessage(hwndRcv,EM_REPLACESEL,0,(LPARAM)lpStrUnicode);
                                        LocalFree(lpStrUnicode);
                                    }
                                    #else // !UNICODE
                                        wParam = SET_EM_SETSEL_WPARAM(LOWORD(ChatDataRcv.uval.cd_dbcs.SelPos),HIWORD(ChatDataRcv.uval.cd_dbcs.SelPos));
                                        lParam = SET_EM_SETSEL_LPARAM(LOWORD(ChatDataRcv.uval.cd_dbcs.SelPos),HIWORD(ChatDataRcv.uval.cd_dbcs.SelPos));
                                        SendMessage(hwndRcv,EM_SETSEL,wParam,lParam);
                                        SendMessage(hwndRcv,EM_REPLACESEL,0,(LPARAM)lpStrBuf);
                                    #endif // UNICODE
                                        SendMessage(hwndRcv,EM_SETREADONLY,(WPARAM)TRUE,0L);
                                        hRet = (HDDEDATA)TRUE;
                                    }

                                    GlobalUnlock(hStrBuf);
                                }

                                GlobalFree(hStrBuf);
                            }
                        }

                        break;


                        // This is a Unicode conversation, so mark the flag.
                        //
                        case CHT_UNICODE:
                            ChatState.fUnicode = TRUE;
                            hRet               = (HDDEDATA)TRUE;
                            break;


                        // We got a character...stuff it into the control.
                        //
                        case CHT_CHAR:

                            // In case user is tracking, so WM_CHAR is not tossed (thanks Dave)
                            //
                            SendMessage(hwndRcv,WM_LBUTTONUP,0,0L);
                            SendMessage(hwndRcv,EM_SETREADONLY,(WPARAM)FALSE,0L);

                            if (gfDbcsEnabled) {
                                TranslateMultiBytePosToWideCharPos( hwndRcv,
                                  (DWORD)HIWORD(ChatDataRcv.uval.cd_dbcs.SelPos),
                                  (DWORD)LOWORD(ChatDataRcv.uval.cd_dbcs.SelPos),
                                  &dwTemp1, &dwTemp2 );
                                // sign extend them
                                wParam=(WPARAM)(INT_PTR)dwTemp1;
                                lParam=(LPARAM)(INT_PTR)dwTemp2;
                            } else {

                                wParam = SET_EM_SETSEL_WPARAM(LOWORD(ChatDataRcv.uval.cd_char.SelPos),HIWORD(ChatDataRcv.uval.cd_char.SelPos));
                                lParam = SET_EM_SETSEL_LPARAM(LOWORD(ChatDataRcv.uval.cd_char.SelPos),HIWORD(ChatDataRcv.uval.cd_char.SelPos));
                            }
                            SendMessage(hwndRcv,EM_SETSEL,wParam,lParam);
                            SendMessage(hwndRcv,WM_CHAR,ChatDataRcv.uval.cd_char.Char,0L);
                            SendMessage(hwndRcv,EM_SETREADONLY,TRUE,0L);
                            hRet = (HDDEDATA)TRUE;
                            break;



                        // We have a paste selection.
                        //
                        case CHT_PASTEA:
                        case CHT_PASTEW:
                            {
                                HANDLE hPasteBuf,hAnsiBuf;
                                LPSTR  lpPasteBuf,lpAnsiBuf;
                                DWORD  BufSize;


                                BufSize = (ChatDataRcv.type == CHT_PASTEA ? ((ChatDataRcv.uval.cd_paste.size + 1) * sizeof(TCHAR)) : (ChatDataRcv.uval.cd_paste.size + sizeof(WCHAR)));

                                hPasteBuf = GlobalAlloc(GMEM_FIXED,BufSize);
                                if(hPasteBuf)
                                {
                                    lpPasteBuf = GlobalLock(hPasteBuf);
                                    if(lpPasteBuf)
                                    {
                                        if(ChatDataRcv.type == CHT_PASTEA)
                                        {
                                            hAnsiBuf = GlobalAlloc(GMEM_FIXED,ChatDataRcv.uval.cd_paste.size+sizeof(WCHAR));
                                            if(hAnsiBuf)
                                            {
                                                lpAnsiBuf = GlobalLock(hAnsiBuf);
                                                if(lpAnsiBuf)
                                                {
                                                    DdeGetData(hData,(BYTE *)lpAnsiBuf,ChatDataRcv.uval.cd_paste.size+sizeof(WCHAR),XCHATSIZEA);
                                                    MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,lpAnsiBuf,ChatDataRcv.uval.cd_paste.size+sizeof(WCHAR),
                                                                        (LPWSTR)lpPasteBuf,ChatDataRcv.uval.cd_paste.size+1);

                                                    GlobalUnlock(hAnsiBuf);
                                                }

                                                GlobalFree(hAnsiBuf);
                                            }
                                        }
                                        else
                                            DdeGetData(hData,(BYTE *)lpPasteBuf,ChatDataRcv.uval.cd_paste.size+sizeof(WCHAR),XCHATSIZEW);


#ifndef DDEMLBUG
                                        if(DdeGetLastError(idInst) == DMLERR_NO_ERROR)
#endif
                                        {
                                            SendMessage(hwndRcv,EM_SETREADONLY,(WPARAM)FALSE,0L);

                                            wParam = SET_EM_SETSEL_WPARAM(LOWORD(ChatDataRcv.uval.cd_char.SelPos),HIWORD(ChatDataRcv.uval.cd_char.SelPos));
                                            lParam = SET_EM_SETSEL_LPARAM(LOWORD(ChatDataRcv.uval.cd_char.SelPos),HIWORD(ChatDataRcv.uval.cd_char.SelPos));
                                            SendMessage(hwndRcv,EM_SETSEL,wParam,lParam);
                                            SendMessage(hwndRcv,EM_REPLACESEL,0,(LPARAM)lpPasteBuf);
                                            SendMessage(hwndRcv,EM_SETREADONLY,(WPARAM)TRUE,0L);
                                            hRet = (HDDEDATA)TRUE;
                                        }

                                        GlobalUnlock(hPasteBuf);
                                    }

                                    GlobalFree(hPasteBuf);
                                }
                            }
                            break;


                        // We got a font change.  Create and stuff.
                        //
                                case CHT_FONTA:
                                case CHT_FONTW:
                            if(ChatDataRcv.type == CHT_FONTA)
                            {
                               CHATDATAA ChatDataA;

                               memcpy(ChatDataA.uval.cd_win.lf.lfFaceName,ChatDataRcv.uval.cd_win.lf.lfFaceName,LF_XPACKFACESIZE + (sizeof(COLORREF) * 2));
                               ChatDataRcv.uval.cd_win.cref  = ChatDataA.uval.cd_win.cref;
                               ChatDataRcv.uval.cd_win.brush = ChatDataA.uval.cd_win.brush;

                               MultiByteToWideChar(CP_OEMCP,MB_PRECOMPOSED,ChatDataA.uval.cd_win.lf.lfFaceName,LF_XPACKFACESIZE,ChatDataRcv.uval.cd_win.lf.lfFaceName,LF_XPACKFACESIZE);
                            }

                            UnpackFont(&lfRcv,&ChatDataRcv.uval.cd_win.lf);

                            hdc = GetDC(hwndApp);
                            if(hdc)
                            {
                                RcvBrushColor = PartBrushColor = GetNearestColor(hdc,ChatDataRcv.uval.cd_win.brush);
                                RcvColorref   = GetNearestColor(hdc,ChatDataRcv.uval.cd_win.cref);
                                ReleaseDC(hwndApp,hdc);
                            }

                            if(!ChatState.fUseOwnFont)
                            {
                                if(hEditRcvFont)
                                    DeleteObject(hEditRcvFont);
                                hEditRcvFont = CreateFontIndirect(&lfRcv);

                                DeleteObject(hEditRcvBrush);
                                hEditRcvBrush = CreateSolidBrush(RcvBrushColor);

                                if(hEditRcvFont)
                                {
                                    SendMessage(hwndRcv,WM_SETFONT,(WPARAM)hEditRcvFont,1L);
                                    InvalidateRect(hwndRcv,NULL,TRUE);
                                }
                            }
                            hRet = (HDDEDATA)TRUE;
                            break;

#ifdef PROTOCOL_NEGOTIATE
                        case CHT_PROTOCOL:
                            // Determine characteristics we have in common.
                            //
                            FlagIntersection(ChatDataRcv.uval.cd_protocol.pckt);

                            // Return the flavor, if not already done.
                            //
                            if(!ChatState.fProtocolSent)
                                AnnounceSupport();
                            hRet = (HDDEDATA)TRUE;
                            break;
#endif

                        default:
                            break;
                    }
                }
            }
            break;


        case XTYP_CONNECT:
            if(!ChatState.fConnected && !ChatState.fConnectPending && !ChatState.fInProcessOfDialing)
            {
                // allow connect only on the chat topic.
                //
                if(!DdeCmpStringHandles(hszTopic,hszChatTopic))
                    hRet = (HDDEDATA)TRUE;
            }
            break;


        case XTYP_CONNECT_CONFIRM:
            ChatState.fConnectPending = TRUE;
            ChatState.fAllowAnswer    = FALSE;
            ChatState.fIsServer       = TRUE;
            ghConv                    = hConv;
            nConnectAttempt           = 0;
            UpdateButtonStates();
            break;


        case XTYP_DISCONNECT:
            if(ChatState.fConnectPending || ChatState.fConnected)
            {
                if(ChatState.fConnected)
                    StringCchPrintf(szBuf,SZBUFSIZ, szHasTerminated,(LPTSTR)szConvPartner);
                else
                if(ChatState.fServerVerified)
                    StringCchPrintf(szBuf,SZBUFSIZ, szNoConnectionTo,(LPTSTR)szConvPartner);
                else
                    StringCchCopy(szBuf,SZBUFSIZ, szNoConnect);

                SetStatusWindowText(szBuf);
                ChatState.fConnectPending = FALSE;
                ChatState.fConnected      = FALSE;
                ChatState.fIsServer       = FALSE;
                ChatState.fUnicode        = FALSE;

#ifdef PROTOCOL_NEGOTIATE
                ChatState.fProtocolSent   = FALSE;
#endif

                // suspend text entry
                //
                UpdateButtonStates();
                SendMessage(hwndSnd,EM_SETREADONLY,TRUE,0L);
                SetWindowText(hwndApp,szAppName);


                // stop the ringing immediately
                //
                if(ChatState.fMMSound)
                    sndPlaySound(NULL,SND_ASYNC);


                // cut the animation short
                //
                if(cAnimate)
                   cAnimate = 1;
            }
            break;


        case XTYP_REQUEST:
            break;


        case XTYP_ADVREQ:
            if(ChatState.fIsServer && ChatState.fConnected)
            {
                switch(ChatData.type)
                {
                    case CHT_DBCS_STRING:
                        hRet = CreateDbcsStringData();
                        break;

                    case CHT_CHAR:
                    case CHT_FONTA:
                    case CHT_FONTW:
                    case CHT_UNICODE:
                        hRet = CreateCharData();
                        break;

                    case CHT_PASTEA:
                    case CHT_PASTEW:
                        hRet = CreatePasteData();
                        break;

#ifdef PROTOCOL_NEGOTIATE
                    case CHT_PROTOCOL:
                        hRet = CreateProtocolData();
                        break;
#endif
                    default:
                        break;
                }
            }
            break;


        case XTYP_ADVSTART:
            if(ChatState.fConnectPending)
            {
                // is this the connect confirm attempt?
                //
                if(!DdeCmpStringHandles(hszItem,hszConnectTest))
                    return((HDDEDATA)TRUE);


                DdeQueryString(idInst,hszItem,szConvPartner,32L,0);
                StringCchPrintf(szBuf, SZBUFSIZ, szIsCalling,(LPTSTR)szConvPartner);
                SetStatusWindowText(szBuf);


                // set window text on initial connect attempt
                //
                if(nConnectAttempt == 0)
                {
                    StringCchPrintf(szBuf, SZBUFSIZ,TEXT("%s - [%s]"),(LPTSTR)szAppName,(LPTSTR)szConvPartner);
                    SetWindowText(hwndApp,szBuf);
                }


                if(ChatState.fAllowAnswer)
                {
                    ChatState.fConnected      = TRUE;
                    ChatState.fConnectPending = FALSE;
                    UpdateButtonStates();
                    ClearEditControls();

                    SendMessage(hwndSnd,EM_SETREADONLY,FALSE,0L);
                    StringCchPrintf(szBuf, SZBUFSIZ,szConnectedTo,(LPTSTR)szConvPartner);
                    SetStatusWindowText(szBuf);

                    if(hszConvPartner)
                        DdeFreeStringHandle(idInst,hszConvPartner);

                    hszConvPartner = DdeCreateStringHandle(idInst,szConvPartner,CP_WINUNICODE);


                    // Indicate that it is a Unicode conversation.
                    //
                    PostMessage(hwndApp,WM_COMMAND,IDX_UNICODECONV,0L);


                    // SendFontToPartner(); -- would like to do this - won't work
                    // so we workaround it by posting the app window a message
                    // to perform this function...
                    //
                    PostMessage(hwndApp,WM_COMMAND,IDX_DEFERFONTCHANGE,0L);

#ifdef PROTOCOL_NEGOTIATE
                    PostMessage(hwndApp,WM_COMMAND,IDX_DEFERPROTOCOL,0L);
#endif
                    hRet = (HDDEDATA)TRUE;
                }
                else
                if(!(nConnectAttempt++ % 6))
                {
                    // Number of animation cycles == 24: ring remote.
                    //
                    cAnimate = 24;
                    idTimer  = SetTimer(hwndApp,(UINT_PTR)1,(UINT_PTR)55,NULL);
                    FlashWindow(hwndApp,TRUE);
                    DoRing(szWcRingIn);
                }
            }
            break;

        default:
            break;
    }

    return(hRet);
}


/*---------------------------------------------------------------------------*\
| FE specific:
| CREATE DBCS STRING TRANSACTION DATA
|   This routine creates a DDE object representing the DBCS string information.
|
| created: 07-Jul-93
|
\*---------------------------------------------------------------------------*/
HDDEDATA CreateDbcsStringData(VOID)
{
    HDDEDATA hTmp = (HDDEDATA)0;
    LPSTR    lpDbcsMem;
    DWORD    cbDbcs;


    hTmp = (HDDEDATA)0;
    lpDbcsMem = GlobalLock(ChatData.uval.cd_dbcs.hString);
    if(lpDbcsMem)
    {
        cbDbcs                     = (DWORD)GlobalSize(ChatData.uval.cd_dbcs.hString);
        ChatData.uval.cd_dbcs.size = (DWORD)cbDbcs;

        hTmp = DdeCreateDataHandle(idInst,NULL,sizeof(ChatData)+cbDbcs,0L,hszTextItem,cf_chatdata,0);
        if(hTmp)
        {
            DdeAddData(hTmp,(LPBYTE)&ChatData,sizeof(ChatData),0L);
            DdeAddData(hTmp,(BYTE *)lpDbcsMem,cbDbcs,XCHATSIZEA);
        }

        GlobalUnlock(ChatData.uval.cd_dbcs.hString);
    }

    GlobalFree(ChatData.uval.cd_dbcs.hString);

    return(hTmp);
}



/*---------------------------------------------------------------------------*\
| CREATE CHARACTER TRANSACTION DATA
|   This routine creates a DDE object representing the charater information.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
HDDEDATA CreateCharData(VOID)
{
    HANDLE     hData;
    LPCHATDATA lpData;
    HDDEDATA   hTmp;
    BOOL       fDefCharUsed;


    hTmp = (HDDEDATA)0;
    hData = GlobalAlloc(GMEM_ZEROINIT | GMEM_MOVEABLE | GMEM_DDESHARE,sizeof(ChatData));
    if(hData)
    {
        lpData = (LPCHATDATA)GlobalLock(hData);
        if(lpData)
        {
            *lpData = ChatData;

            if(ChatData.type == CHT_FONTA)
            {
                lpData->uval.cd_win.cref  = ((LPCHATDATAA)lpData)->uval.cd_win.cref;
                lpData->uval.cd_win.brush = ((LPCHATDATAA)lpData)->uval.cd_win.brush;
            }

            hTmp = DdeCreateDataHandle(idInst,(LPBYTE)lpData,sizeof(ChatData),0L,hszTextItem,cf_chatdata,0);

            GlobalUnlock(hData);
        }

        GlobalFree(hData);
    }

    return(hTmp);
    UNREFERENCED_PARAMETER(fDefCharUsed);
}


/*---------------------------------------------------------------------------*\
| CREATE PASTE TRANSACTION DATA
|   This routine creates a DDE object representing the paste information.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
HDDEDATA CreatePasteData(VOID)
{
    HDDEDATA hTmp,hRet;
    HANDLE   hClipb;
    LPTSTR   lpClipMem;
    DWORD    cbClip;
    LPSTR    lpBuf;
    DWORD    dwBytes;


    hRet = (HDDEDATA)0;
    if(OpenClipboard(hwndSnd))
    {
        hClipb = GetClipboardData(CF_UNICODETEXT);
        if(hClipb)
        {
            lpClipMem = GlobalLock(hClipb);
            if(lpClipMem)
            {
                cbClip                      = (DWORD)GlobalSize(hClipb);
                                ChatData.uval.cd_paste.size = cbClip;
                hTmp = DdeCreateDataHandle(idInst,NULL,(sizeof(ChatData)+cbClip),
                                              0,hszTextItem,cf_chatdata,0);
                if(hTmp)
                {
                    DdeAddData(hTmp,(LPBYTE)&ChatData,sizeof(ChatData),0L);

                    if(ChatData.type == CHT_PASTEA)
                    {
                        dwBytes                     = WideCharToMultiByte(CP_ACP,0,lpClipMem,-1,NULL,0,NULL,NULL);
                        ChatData.uval.cd_paste.size = dwBytes;

                        lpBuf = LocalAlloc(LPTR,dwBytes);
                        if(lpBuf)
                        {
                            WideCharToMultiByte(CP_ACP,0,lpClipMem,-1,lpBuf,dwBytes,NULL,NULL);

                            DdeAddData(hTmp,(LPBYTE)lpBuf,dwBytes,XCHATSIZEA);

                            hRet = hTmp;

                            LocalFree(lpBuf);
                        }
                    }
                    else
                    {
                        DdeAddData(hTmp,(LPBYTE)lpClipMem,cbClip,XCHATSIZEW);

                        hRet = hTmp;
                    }
                }

                GlobalUnlock(hClipb);
                        }
        }

                CloseClipboard();
    }

    return(hRet);
}


#ifdef PROTOCOL_NEGOTIATE
/*---------------------------------------------------------------------------*\
| CREATE PROTOCOL TRANSACTION DATA
|   This routine creates a DDE object representing the protocol information.
|
| created: 11-Nov-91
| history: 07-Apr-93 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
HDDEDATA CreateProtocolData(VOID)
{
    HANDLE     hData;
    LPCHATDATA lpData;
    HDDEDATA   hTmp;


    hTmp = (HDDEDATA)0;
    hData = GlobalAlloc(GMEM_ZEROINIT | GMEM_MOVEABLE | GMEM_DDESHARE,sizeof(ChatData));
    if(hData)
    {
        lpData = (LPCHATDATA)GlobalLock(hData);
        if(lpData)
        {
            ChatData.type                   = CHT_PROTOCOL;
            ChatData.uval.cd_protocol.dwVer = CHT_VER;
            ChatData.uval.cd_protocol.pckt  = GetCurrentPckt();

            *lpData = ChatData;
            hTmp    = DdeCreateDataHandle(idInst,(LPBYTE)lpData,sizeof(ChatData),0L,hszTextItem,cf_chatdata,0);

            GlobalUnlock(hData);
        }

        GlobalFree(hData);
    }

    return(hTmp);
}
#endif


#ifdef PROTOCOL_NEGOTIATE
/*---------------------------------------------------------------------------*\
| GET CURRENT PACKET
|   This routine returns the current packet capabilities of the system.
|
| created: 11-Nov-91
| history: 07-Apr-93 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
PCKT GetCurrentPckt(VOID)
{
    PCKT pckt;


    pckt = PCKT_TEXT;

    return(pckt);
}
#endif


#ifdef PROTOCOL_NEGOTIATE
/*---------------------------------------------------------------------------*\
| FLAG INTERSECTION
|   This routine determines which packet types are supporte and flags the
|   appropriate ones.
|
| created: 11-Nov-91
| history: 07-Apr-93 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID FlagIntersection(PCKT pcktPartner)
{
    PCKT pcktNet;


    pcktNet = GetCurrentPckt() & pcktPartner;

    return;
}
#endif


/*---------------------------------------------------------------------------*\
| SEND FONT TO PARTNER
|   This routine sends the font-information to the partner in this
|   conversation.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID SendFontToPartner(VOID)
{
        HDDEDATA   hDdeData;
    PCHATDATAA pAChat;


    ChatData.type = (WORD)((ChatState.fUnicode ? CHT_FONTW : CHT_FONTA));

    PackFont(&ChatData.uval.cd_win.lf,&lfSnd);

    if(ChatData.type == CHT_FONTA)
    {
        pAChat                    = (PCHATDATAA)&ChatData;
        pAChat->uval.cd_win.cref  = SndColorref;
        pAChat->uval.cd_win.brush = SndBrushColor;
    }
    else
    {
        ChatData.uval.cd_win.cref  = SndColorref;
        ChatData.uval.cd_win.brush = SndBrushColor;
    }

    if(!ChatState.fIsServer)
    {
        hDdeData = DdeCreateDataHandle(idInst,(LPBYTE) &ChatData,sizeof(ChatData),0L,hszTextItem,cf_chatdata,0);
        if(hDdeData)
            DdeClientTransaction((LPBYTE)hDdeData,(DWORD)-1,ghConv,hszTextItem,cf_chatdata,XTYP_POKE,(DWORD)TIMEOUT_ASYNC,(LPDWORD)&StrXactID);
        }
    else
        DdePostAdvise(idInst,hszChatTopic,hszConvPartner);

    return;
}


/*---------------------------------------------------------------------------*\
| UNPACK FONT
|   This routine unpacks the font stored in the packed transaction.
|
| created: 04-Feb-93
| history: 04-Feb-93 <chriswil> created.
|
\*---------------------------------------------------------------------------*/
VOID UnpackFont(LPLOGFONT lf, LPXPACKFONT lfPacked)
{
    lf->lfHeight         = (LONG)(short)lfPacked->lfHeight;
    lf->lfWidth          = (LONG)(short)lfPacked->lfWidth;
    lf->lfEscapement     = (LONG)(short)lfPacked->lfEscapement;
    lf->lfOrientation    = (LONG)(short)lfPacked->lfOrientation;
    lf->lfWeight         = (LONG)(short)lfPacked->lfWeight;
    lf->lfItalic         = (BYTE)lfPacked->lfItalic;
    lf->lfUnderline      = (BYTE)lfPacked->lfUnderline;
    lf->lfStrikeOut      = (BYTE)lfPacked->lfStrikeOut;
    lf->lfCharSet        = (BYTE)lfPacked->lfCharSet;
    lf->lfOutPrecision   = (BYTE)lfPacked->lfOutPrecision;
    lf->lfClipPrecision  = (BYTE)lfPacked->lfClipPrecision;
    lf->lfQuality        = (BYTE)lfPacked->lfQuality;
    lf->lfPitchAndFamily = (BYTE)lfPacked->lfPitchAndFamily;

    StringCchCopy(lf->lfFaceName, ARRAYSIZE(lf->lfFaceName), lfPacked->lfFaceName);

    return;
}


/*---------------------------------------------------------------------------*\
| PACK FONT
|   This routine packs the font for transaction.
|
| created: 04-Feb-93
| history: 04-Feb-93 <chriswil> created.
|
\*---------------------------------------------------------------------------*/
VOID PackFont(LPXPACKFONT lfPacked, LPLOGFONT lf)
{
    BOOL fDefCharUsed;

    lfPacked->lfHeight          = (WORD)lf->lfHeight;
    lfPacked->lfWidth           = (WORD)lf->lfWidth;
    lfPacked->lfEscapement      = (WORD)lf->lfEscapement;
    lfPacked->lfOrientation     = (WORD)lf->lfOrientation;
    lfPacked->lfWeight          = (WORD)lf->lfWeight;
    lfPacked->lfItalic          = (BYTE)lf->lfItalic;
    lfPacked->lfUnderline       = (BYTE)lf->lfUnderline;
    lfPacked->lfStrikeOut       = (BYTE)lf->lfStrikeOut;
    lfPacked->lfCharSet         = (BYTE)lf->lfCharSet;
    lfPacked->lfOutPrecision    = (BYTE)lf->lfOutPrecision;
    lfPacked->lfClipPrecision   = (BYTE)lf->lfClipPrecision;
    lfPacked->lfQuality         = (BYTE)lf->lfQuality;
    lfPacked->lfPitchAndFamily  = (BYTE)lf->lfPitchAndFamily;

    if(ChatData.type == CHT_FONTA)
        WideCharToMultiByte(CP_OEMCP,0,lf->lfFaceName,LF_XPACKFACESIZE,(LPSTR)(lfPacked->lfFaceName),LF_XPACKFACESIZE,NULL,&fDefCharUsed);
    else
        StringCchCopy(lfPacked->lfFaceName,ARRAYSIZE(lfPacked->lfFaceName),lf->lfFaceName);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\utils.cxx ===
/********************************************************************
 *
 *  Module Name : utils.c
 *
 *  Various utilities for UCE
 *
 *  Copyright (c) 1997-1999 Microsoft Corporation.
 ********************************************************************/

#include "windows.h"
#include "commctrl.h"

#include "UCE.h"
#include "stdlib.h"
#include "tchar.h"
#include "stdio.h"
#include "winuser.h"
#include "string.h"
#include "search.h"

#include "winnls.h"
#include "wingdi.h"

#include <strsafe.h>
/********************************************************************

    Function : Set current selection in combobox.

********************************************************************/
BOOL LoadNeedMessage()
{
  TCHAR szVal[128] = TEXT("");
  DWORD dwRetVal;

  dwRetVal=GetProfileString(TEXT("MSUCE"),TEXT("DISPLAYFONTMSG"),TEXT(""),(LPTSTR)szVal, sizeof(szVal)/sizeof(TCHAR));
  if (!dwRetVal)
    return true;
  else
    return (BOOL)(atoi((const char*)szVal));
}

void SaveNeedMessage(BOOL nMsg)
{
  if (nMsg)
    WriteProfileString(TEXT("MSUCE"), TEXT("DISPLAYFONTMSG"), TEXT("1"));
  else
    WriteProfileString(TEXT("MSUCE"), TEXT("DISPLAYFONTMSG"), TEXT("0"));
}


INT
LoadCurrentSelection(
    HWND   hWnd,
    UINT   uID,
    LPTSTR lpszKey,
    LPTSTR lpszDefault
    )
{
    TCHAR szValueName[128] = TEXT("");
    INT nIndex;
    DWORD dwRetVal;

    nIndex = CB_ERR;

    dwRetVal = GetProfileString(
                   TEXT("MSUCE"),
                   lpszKey,
                   TEXT(""),
                   (LPTSTR)szValueName,
                   BTOC(sizeof(szValueName))
               );

    if (dwRetVal != 0)
    {
        nIndex = (INT) SendDlgItemMessage(
                           hWnd,
                           uID,
                           CB_SELECTSTRING,
                           (WPARAM)-1,
                           (LPARAM)(LPTSTR)szValueName
                       );
    }

    /*
     * If there was no profile or the selection failed then try selecting
     * the Basic Latin block, if that fails then select the first one.
     */

    if (nIndex == CB_ERR)
    {
        nIndex = (INT) SendDlgItemMessage(
                           hWnd,
                           uID,
                           CB_SELECTSTRING,
                           (WPARAM)-1,
                           (LPARAM) lpszDefault
                       );
    }

    nIndex = (INT)SendDlgItemMessage(
                 hWnd,
                 uID,
                 CB_SETCURSEL,
                 (WPARAM) (nIndex == CB_ERR) ? 0 : nIndex,
                 (LPARAM) 0L
             );

    return nIndex;
}

/********************************************************************

    Function : Used to save the current selection values in win.ini,
               so that it can be selected the next time UCE comes up.

********************************************************************/
BOOL
SaveCurrentSelection(
    HWND   hWnd,
    UINT   uID,
    LPTSTR lpszKey
    )
{
    TCHAR szValue[128] = TEXT("");
    INT nIndex;
    INT nRetVal;

    nIndex = (INT) SendDlgItemMessage(
                       hWnd,
                       uID,
                       CB_GETCURSEL,
                       (WPARAM) 0,
                       (LPARAM) 0L
                   );

    if (nIndex == CB_ERR)
    {
        return FALSE;
    }

    nRetVal = (INT)SendDlgItemMessage(
                  hWnd,
                  uID,
                  CB_GETLBTEXT,
                  (WPARAM) nIndex,
                  (LPARAM) szValue
              );

    if (nRetVal == CB_ERR)
    {
        return FALSE;
    }

    return WriteProfileString(TEXT("MSUCE"), lpszKey, szValue);
}

/********************************************************************

    Function : GetSystemPathName

********************************************************************/
VOID GetSystemPathName(
    PWSTR pwszPath,
    PWSTR pwszFileName,
    UINT  maxChar
    )
{
    UINT fnLen = wcslen(pwszFileName);
    UINT i = GetSystemDirectoryW(pwszPath, maxChar);

    // avoid error condition
    if (fnLen + 1 >= maxChar) {
        *pwszPath = L'\0';
        return;
    }
    if (i > 0 || i < maxChar - fnLen - 1) {
        pwszPath += i;
        if (pwszPath[-1] != L'\\')
            *pwszPath++ = L'\\';
    }
    
    HRESULT hresult = StringCchCopy(pwszPath, maxChar , pwszFileName);
    
    if (!SUCCEEDED(hresult))
    {
        return;
    }

}

/********************************************************************

    Function : Set current selection in combobox.

********************************************************************/
INT
LoadAdvancedSelection(
    HWND   hWnd,
    UINT   uID,
    LPTSTR lpszKey
    )
{
    TCHAR szValueName[128] = TEXT("");
    DWORD iCheckState;

    iCheckState = GetProfileInt(
                   TEXT("MSUCE"),
                   lpszKey,
                   0);

    fDisplayAdvControls = (iCheckState == 0)? FALSE: TRUE;

    return 0;
}

/********************************************************************

    Function : Used to save the current selection values in win.ini,
               so that it can be selected the next time UCE comes up.

********************************************************************/
BOOL
SaveAdvancedSelection(
    HWND   hWnd,
    UINT   uID,
    LPTSTR lpszKey
    )
{
    TCHAR szValue[128] = TEXT("");
    int   iCheckState;

    iCheckState = (fDisplayAdvControls == TRUE)? 1: 0;

    
    HRESULT hresult = StringCchPrintf(szValue , sizeof(szValue)/sizeof(szValue[0]),  L"%d", iCheckState);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }

    return WriteProfileString(TEXT("MSUCE"), lpszKey, szValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\ucefile.h ===
/********************************************************************
 *
 *  Header Name : ucefile.h
 *
 *  UCE file data structures
 *
 *
 *  History :
 *         Sep 02, 1997  [samera]   wrote it
 *
 *  Copyright (c) 1997-1999 Microsoft Corporation.
 *********************************************************************/

#ifndef __UCEFILE_H__
#define __UCEFILE_H__

#define MAX_UCE_FILES    32

typedef struct
{
  char Signature[4] ;        // should be "UCEX"
  DWORD OffsetTableName;     // Subset name
  WORD Codepage;
  WORD NumGroup;
  WORD Row;
  WORD Column;

} UCE_HEADER, *PUCE_HEADER;


//  UCEX Group Structure
typedef struct
{
  DWORD OffsetGroupName;
  DWORD OffsetGroupChar;
  DWORD NumChar;
  DWORD Reserved;

} UCE_GROUP, *PUCE_GROUP;


typedef struct Structtag_UCE_FILES
{
  HANDLE hFile;     // UCE physical file handle
  HANDLE hMapFile;  // UCE memory map file handle
  PVOID pvData;     // Start of committed address space for the file

} UCE_MEMORY_FILE, *PUCE_MEMORY_FILE;


// export
UINT UCE_EnumFiles( void );
void UCE_CloseFiles( void );
INT UCE_GetFiles( UCE_MEMORY_FILE **ppUceMemFile );
BOOL UCE_GetTableName( PUCE_MEMORY_FILE pUceMemFile , PWSTR *ppszTableName );
WORD UCE_GetCodepage( PUCE_MEMORY_FILE pUceMemFile );

#endif  // __UCEFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\uce\uce\ucefile.cxx ===
/********************************************************************
 *
 *  Module Name : ucefile.c
 *
 *  UCE-File parser
 *
 *  History :
 *       Sep 02, 1997  [samera]    wrote it.
 *
 *  Copyright (c) 1997-1999 Microsoft Corporation. 
 **********************************************************************/

#include <windows.h>
#include <commctrl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strsafe.h>

#include "uce.h"
#include "ucefile.h"



// Current opened UCE files
UCE_MEMORY_FILE  gUceFiles[MAX_UCE_FILES];
PUCE_MEMORY_FILE gpUceFile=&gUceFiles[0];
INT              gnUceFiles=0;
INT              gnMaxUceFiles=MAX_UCE_FILES;


/******************************Public*Routine******************************\
* UCE_LoadFile
*
* Load a UCE file (by mapping it in the process address space & commit it)
* it returns both ptr+handle of file
* 
* Return Value:
* TRUE if successful, FALSE otherwise
* History:
*   Sept-03-1997  Samer Arafeh  [samera]      
*    wrote it
\**************************************************************************/
BOOL UCE_LoadFile( PWSTR pwszFileName , PUCE_MEMORY_FILE pMemFile )
{
  HANDLE hFile;
  HANDLE hMapFile;
  PVOID  pvFile;
  DWORD  dwFileSize;
  WORD   CodePage;
  DWORD  dwOffset;
  WCHAR *pWC;

  // Open and map file
  hFile = CreateFile( pwszFileName,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_READONLY,
                      NULL
                    );

  if( INVALID_HANDLE_VALUE == hFile )
    goto File_Err;

  dwFileSize = GetFileSize( hFile , NULL );

  hMapFile = CreateFileMapping( hFile ,
                                NULL,
                                PAGE_READONLY,
                                0,
                                dwFileSize,
                                NULL
                              );

  if( (NULL == hMapFile) || (dwFileSize<sizeof(UCE_HEADER)) )
    goto File_Err1;

  pvFile = MapViewOfFile( hMapFile ,
                          FILE_MAP_READ,
                          0,
                          0,
                          0
                        ) ;

  if( NULL == pvFile )
    goto File_Err2;

  // verify header
  if( *((DWORD *)pvFile) != 0x58454355L ) // XECU
    goto File_Err3;

//
// The Ideograph by Radical UCE file should be included
// only if one of the 4 DBCS font and NLS is installed.
//
  dwOffset = *(((DWORD*)pvFile)+1);
  pWC = (WCHAR*)(((BYTE*)pvFile)+dwOffset);
  if(lstrcmp(pWC, L"010200") == 0)             // Ideograf.UCE
  {
     if(Font_DBCS_CharSet() == 0)
         goto File_Err3;
     if((IsValidLanguageGroup(LGRPID_JAPANESE, LGRPID_INSTALLED) == FALSE) &&
        (IsValidLanguageGroup(LGRPID_SIMPLIFIED_CHINESE, LGRPID_INSTALLED) == FALSE) &&
        (IsValidLanguageGroup(LGRPID_KOREAN, LGRPID_INSTALLED) == FALSE) &&
        (IsValidLanguageGroup(LGRPID_TRADITIONAL_CHINESE, LGRPID_INSTALLED) == FALSE))
        goto File_Err3;
  }
  
//
// A UCE file with a Non-Unicode DBCS codepage
// is included only if font & NLS are installed.
//
  CodePage = *(((WORD*)pvFile)+4);
  if(CodePage != UNICODE_CODEPAGE)
  {
      CPINFO      cpi;
      CHARSETINFO csi;

      if(!IsValidCodePage(CodePage) ||         // invalid codepage
         !GetCPInfo(CodePage, &cpi) )
      {
         goto File_Err3;
      }
                                
      if(cpi.MaxCharSize >1  &&                // DBCS  
         TranslateCharsetInfo((DWORD*)CodePage, &csi, TCI_SRCCODEPAGE))
      {
          if(!Font_Avail(csi.ciCharset))       // no font with matched charset
          {
              goto File_Err3;
          }
      }
      else
      {
          //
          // SBCS or no GDI charset, include it anyway.
          //
      }

      if(CodePage == 932)
      {
         if(IsValidLanguageGroup(LGRPID_JAPANESE, LGRPID_INSTALLED) == FALSE)
             goto File_Err3;
      }
      else if(CodePage == 936)
      {
         if(IsValidLanguageGroup(LGRPID_SIMPLIFIED_CHINESE, LGRPID_INSTALLED) == FALSE)
             goto File_Err3;
      }
      else if(CodePage == 949)
      {
         if(IsValidLanguageGroup(LGRPID_KOREAN, LGRPID_INSTALLED) == FALSE)
             goto File_Err3;
      }
      else if(CodePage == 950)
      {
         if(IsValidLanguageGroup(LGRPID_TRADITIONAL_CHINESE, LGRPID_INSTALLED) == FALSE)
             goto File_Err3;
      }
  }

  // save handle 
  pMemFile->hFile    = hFile;
  pMemFile->hMapFile = hMapFile;
  pMemFile->pvData   = pvFile;

  return TRUE;


  // Error Handler
File_Err3:
  UnmapViewOfFile(pvFile);
File_Err2:
  CloseHandle(hMapFile);
File_Err1:
  CloseHandle(hFile);
File_Err:
  
  return FALSE;
}


/******************************Public*Routine******************************\
* Uce_AddFile
*
* Add a UCE_MEMORY_File to our global list
* 
* Return Value:
* TRUE if successful, FALSE otherwise
* History:
*   Sept-03-1997  Samer Arafeh  [samera]      
*    wrote it
\**************************************************************************/
BOOL Uce_AddFile( PUCE_MEMORY_FILE pUceMemFile )
{
  PVOID pv;
  BOOL  bRet=TRUE;

  // Check if we still have enough space on our global list
  if( gnMaxUceFiles == gnUceFiles )
  {
    // Need more memory space
    pv = LocalAlloc( LMEM_FIXED , (gnMaxUceFiles+MAX_UCE_FILES)*sizeof(UCE_MEMORY_FILE));
    if( pv )
    {
      memcpy( pv , gpUceFile , sizeof(UCE_MEMORY_FILE)*gnMaxUceFiles ) ;
      if( gpUceFile != &gUceFiles[0] )
      {
        LocalFree( gpUceFile ) ;
      }
      gpUceFile = (PUCE_MEMORY_FILE)pv ;
      gnMaxUceFiles += MAX_UCE_FILES;
    }
    else
    {
     bRet = FALSE;
    }
  }

  // Let's add the file now
  if( bRet )
  {
      int    i, j;
      WCHAR  wcBuf[256];
      WCHAR  wcBufNew[256];
      PWSTR  pwszSubsetName;
      HRESULT hresult;

      UCE_GetTableName( pUceMemFile , &pwszSubsetName );
      if(*pwszSubsetName == L'0')
      {
          LoadString(hInst, _wtol(pwszSubsetName), wcBufNew, 255);
      }
      else
      {
          hresult = StringCchCopy(wcBufNew , sizeof(wcBufNew)/sizeof(wcBufNew[0]) ,  pwszSubsetName);
          if (!SUCCEEDED(hresult))
          {
             return FALSE;
          }
      }

      for(i = 0; i < gnUceFiles; i++)
      {
          UCE_GetTableName( &gpUceFile[i] , &pwszSubsetName );
          if(*pwszSubsetName == L'0')
          {
              LoadString(hInst, _wtol(pwszSubsetName), wcBuf, 255);
          }
          else
          {
              
              hresult = StringCchCopy(wcBuf , sizeof(wcBuf)/sizeof(wcBuf[0]),  pwszSubsetName);
              if (!SUCCEEDED(hresult))
              {
                 return FALSE;
              }
          }

          if(CompareString(LOCALE_USER_DEFAULT, 0, wcBufNew, -1,  wcBuf, -1) == 1) break;
      }

      for(j = gnUceFiles; j > i; j--)
      {
          memcpy( &gpUceFile[j] , &gpUceFile[j-1] , sizeof(UCE_MEMORY_FILE) );
      }

      memcpy( &gpUceFile[i] , pUceMemFile , sizeof(UCE_MEMORY_FILE) );
      gnUceFiles++ ;
  }

  return bRet ;
}


/******************************Public*Routine******************************\
* UCE_EnumFiles
*
* Begin enumerate UCE files. Return number of correct find
* 
* Return Value:
*   Number of UCE entries found including the hardcoded 'All'
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]      
*    wrote it
\**************************************************************************/
UINT UCE_EnumFiles( void )
{
    WIN32_FIND_DATA W32FindData;
    HANDLE          hFile;
    WCHAR           wszSysDir[MAX_PATH];
    WCHAR           wszFilePath[MAX_PATH];
    UCE_MEMORY_FILE uceMemFile;
    INT             nLen;

    // Get UCE directory
    if ( !GetSystemDirectory( wszSysDir, MAX_PATH ))
    {
        return (0);
    }
    nLen = lstrlenW( wszSysDir ) ;
    
    if( nLen && nLen < (MAX_PATH - 1) )
    {
      if( wszSysDir[nLen-1] != L'\\' )
      {
        wszSysDir[nLen] = L'\\';
        wszSysDir[nLen+1] = 0;
        nLen++;
      }
    }


    HRESULT hresult = StringCchCopy(wszFilePath , sizeof(wszFilePath)/sizeof(wszFilePath[0]),  wszSysDir );
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    
    hresult = StringCchCat(wszFilePath , sizeof(wszFilePath)/sizeof(wszFilePath[0]),  L"*.uce");
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }

    hFile = FindFirstFile( wszFilePath , &W32FindData );

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
      do
      {
        if( !(W32FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) 
        {
    
            hresult = StringCchCopy(wszFilePath , sizeof(wszFilePath)/sizeof(wszFilePath[0]),  wszSysDir );
            if (!SUCCEEDED(hresult))
            {
               return FALSE;
            }
            
            hresult = StringCchCat(wszFilePath , sizeof(wszFilePath)/sizeof(wszFilePath[0]),  W32FindData.cFileName );
            if (!SUCCEEDED(hresult))
            {
               return FALSE;
            }
          if( !UCE_LoadFile( wszFilePath , &uceMemFile ) ) 
          {
            //
            // Warnning, same extention, but isn't a valid UCE
            //

          }
          else
          {
            // Add file to UCE list
            Uce_AddFile( &uceMemFile );
#if DBG
            OutputDebugString(L"\nUCE File Loaded:");
            OutputDebugString(wszFilePath);
#endif 
          }
        }
        

      } while( FindNextFile( hFile , &W32FindData ));

      FindClose( hFile );
    }

    return (gnUceFiles+1);  // +1 is for default hard-coded one
}

/**************************************************************************\

  Close All UCE files, and free memory if needed

\**************************************************************************/
void UCE_CloseFiles( void )
{
  while( gnUceFiles>0 )
  {
    gnUceFiles--;
    UnmapViewOfFile( gpUceFile[gnUceFiles].pvData );
    CloseHandle( gpUceFile[gnUceFiles].hMapFile );
    CloseHandle( gpUceFile[gnUceFiles].hFile ) ;
  }

  if( gpUceFile != &gUceFiles[0] )
  {
    LocalFree( gpUceFile );
  }

  return ;
}


/******************************Public*Routine******************************\
* UCE_GetFiles
*
* Read in current list of UCE_list
* 
* Return Value:
*   Current UCE_MEMORY_FILEs loaded
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]      
*    wrote it
\**************************************************************************/
INT UCE_GetFiles( UCE_MEMORY_FILE **ppUceMemFile )
{
  *ppUceMemFile = gpUceFile ;

  return gnUceFiles;
}


/******************************Public*Routine******************************\
* UCE_GetTableName
*
* Position pointer to table name of current UCE_MEMORY_FILE
* 
* Return Value:
*
* History:
*   Sept-03-1997  Samer Arafeh  [samera]      
*    wrote it
\**************************************************************************/
BOOL UCE_GetTableName( PUCE_MEMORY_FILE pUceMemFile , PWSTR *ppszTableName )
{
  PUCE_HEADER pHeader = (PUCE_HEADER)(pUceMemFile->pvData);
  PSTR pFile= (PSTR)(pUceMemFile->pvData);

  *ppszTableName = (PWSTR)(pFile+pHeader->OffsetTableName);

  return TRUE;
}

/******************************Public*Routine******************************\
* UCE_GetCodepage
* 
* Return Value: table CodePage of current UCE_MEMORY_FILE
*
* History:
*   Nov-20-1997  kchang  created
\**************************************************************************/
WORD UCE_GetCodepage( PUCE_MEMORY_FILE pUceMemFile )
{
  PUCE_HEADER pHeader = (PUCE_HEADER)(pUceMemFile->pvData);
  PSTR pFile= (PSTR)(pUceMemFile->pvData);

  return (WORD)(pFile+pHeader->Codepage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\winchat\globals.c ===
/*---------------------------------------------------------------------------*\
| GLOBAL MODULE
|   This module contains global-variables for the appliciation.  These were
|   isolate purely for maintainability of the app.
|
|
| Copyright (c) Microsoft Corp., 1990-1993
|
| created: 29-Dec-92
| history: 29-Dec-92 <clausgi>  created with port to NT.
|          19-Oct-93 <chriswil> unicode enhancements from a-dianeo.
|
\*---------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include <ddeml.h>
#include <commdlg.h>
#include <commctrl.h>
#include <shellapi.h>
#include "winchat.h"
#include "dialogs.h"


// Send-Window Information.
//
HFONT    hEditSndFont = NULL;
HWND     hwndSnd;
HBRUSH   hEditSndBrush;
COLORREF SndColorref,SndBrushColor;
LOGFONT  lfSnd;
RECT     SndRc;


// Receive-Window Information.
//
HFONT    hEditRcvFont = NULL;
HWND     hwndRcv;
HBRUSH   hEditRcvBrush;
COLORREF RcvColorref,RcvBrushColor;
COLORREF PartBrushColor;
LOGFONT  lfRcv;
RECT     RcvRc;


// DDEML Conversation.
//
DWORD idInst         = 0;
HSZ   hszServiceName = (HSZ)0;
HSZ   hszConnect     = (HSZ)0;
HSZ   hszChatTopic   = (HSZ)0;
HSZ   hszChatShare   = (HSZ)0;
HSZ   hszTextItem    = (HSZ)0;
HSZ   hszConvPartner = (HSZ)0;
HSZ   hszConnectTest = (HSZ)0;
HSZ   hszLocalName   = (HSZ)0;
HCONV ghConv;



// Misc global variables.
//
int      dyStatus,dyButtonBar,dyBorder,cxIcon,cyIcon,cbTextLen;
UINT_PTR idTimer;
DWORD    XactID,StrXactID;
HANDLE   hInst;
HACCEL   hAccel;
HDC      hMemDC;
HBITMAP  hOldBitmap,hPhnBitmap,hOldMemObj;
HICON    hPhones[3];
HFONT    hFontStatus,hOldFont;
HBRUSH   hBtnFaceBrush;
HPEN     hShadowPen,hHilitePen,hFramePen;
UINT     cf_chatdata;
HWND     hwndActiveEdit,hwndApp;
WNETCALL WNetServerBrowseDialog;


int     ASeq[4]         = {0,1,0,2};
WORD    cAnimate        = 0;
HANDLE  hMemTextBuffer  = NULL;
int     nConnectAttempt = 0;
HWND    hwndToolbar     = NULL;
HWND    hwndStatus      = NULL;



// Pointer information.
//
WNDPROC  lpfnOldEditProc;
LPBYTE   lpbTextBuffer;



// Common-Dialog variables.
//
CHOOSEFONT  chf;
CHOOSECOLOR chc;
DWORD       CustColors[16];


CHATSTATE       ChatState;
CHATDATA        ChatData, ChatDataRcv;
WINDOWPLACEMENT Wpl;



// Global Buffers.
//
TCHAR szHelv          [SMLRCBUF];
TCHAR szAppName       [SMLRCBUF];
TCHAR szServiceName   [SMLRCBUF];
TCHAR szAlreadyConnect[BIGRCBUF];
TCHAR szAbandonFirst  [BIGRCBUF];
TCHAR szDialing       [BIGRCBUF];
TCHAR szYouCaller     [BIGRCBUF];
TCHAR szNotCalled     [BIGRCBUF];
TCHAR szNotConnected  [BIGRCBUF];
TCHAR szConnectAbandon[BIGRCBUF];
TCHAR szHangingUp     [BIGRCBUF];
TCHAR szHasTerminated [BIGRCBUF];
TCHAR szConnectedTo   [BIGRCBUF];
TCHAR szConnecting    [BIGRCBUF];
TCHAR szIsCalling     [BIGRCBUF];
TCHAR szDialHelp      [BIGRCBUF];
TCHAR szAnswerHelp    [BIGRCBUF];
TCHAR szHangUpHelp    [BIGRCBUF];
TCHAR szNoConnect     [BIGRCBUF];
TCHAR szNoConnectionTo[BIGRCBUF];
TCHAR szSysErr        [BIGRCBUF];
TCHAR szAlwaysOnTop   [BIGRCBUF];
TCHAR szNoNet         [SZBUFSIZ];
TCHAR szBuf           [SZBUFSIZ];        // general purpose string buffer
TCHAR szHelp          [SZBUFSIZ];

TCHAR szIniSection    [SZBUFSIZ];
TCHAR szIniKey1       [BIGRCBUF];
TCHAR szIniKey2       [BIGRCBUF];
TCHAR szIniRingIn     [BIGRCBUF];
TCHAR szIniRingOut    [BIGRCBUF];

TCHAR szConvPartner   [UNCNLEN] = TEXT("");    // Conversation partner.
TCHAR szLocalName     [UNCNLEN] = TEXT("");    // Computer name.


// localized strings
//
CONST TCHAR szChatTopic   [] = TEXT("Chat");
TCHAR szChatShare   [] = TEXT("CHAT$");
CONST TCHAR szWcRingIn    [] = TEXT("RingIn");
CONST TCHAR szWcRingOut   [] = TEXT("RingOut");
CONST TCHAR szSysIni      [] = TEXT("system.ini");
CONST TCHAR szVredir      [] = TEXT("Network");
CONST TCHAR szComputerName[] = TEXT("ComputerName");
CONST TCHAR szChatText    [] = TEXT("ChatText");
CONST TCHAR szConnectTest [] = TEXT("___cnc3tst___");
CONST TCHAR szWinChatClass[] = TEXT("WinChatWClass");
CONST TCHAR szWinChatMenu [] = TEXT("WinChatMenu");
CONST TCHAR szHelpFile    [] = TEXT("winchat.hlp");
CONST TCHAR szIni         [] = TEXT("Winchat.ini");
CONST TCHAR szFnt         [] = TEXT("Font");
CONST TCHAR szPref        [] = TEXT("Preferences");
CONST TCHAR szSnd         [] = TEXT("Sound");
CONST TCHAR szTool        [] = TEXT("ToolBar");
CONST TCHAR szStat        [] = TEXT("StatusBar");
CONST TCHAR szTop         [] = TEXT("TopMost");
CONST TCHAR szUseOF       [] = TEXT("UseOwnFont");
CONST TCHAR szSbS         [] = TEXT("SideBySide");
CONST TCHAR szAutoAns     [] = TEXT("AutoAnswer");
CONST TCHAR szBkgnd       [] = TEXT("BkGnd");
CONST TCHAR szNull        [] = TEXT("");




// This list must be NULL-terminated.
//
CONST UINT nIDs[] = {MH_BASE,MH_POPUPBASE,0,0};




// Code for all font aspects (CODEWORK - reduce to essential?)
//
CONST TCHAR szHeight      [] = TEXT("Height");
CONST TCHAR szWeight      [] = TEXT("Weight");
CONST TCHAR szPitchFam    [] = TEXT("PitchFam");
CONST TCHAR szItalic      [] = TEXT("Italic");
CONST TCHAR szUnderline   [] = TEXT("Underline");
CONST TCHAR szStrikeOut   [] = TEXT("Strikeout");
CONST TCHAR szFontName    [] = TEXT("Name");
CONST TCHAR szWidth       [] = TEXT("Width");
CONST TCHAR szCharSet     [] = TEXT("TCHARset");
CONST TCHAR szOutPrecision[] = TEXT("OutPrecision");
CONST TCHAR szClipPrec    [] = TEXT("ClipPrecision");
CONST TCHAR szQuality     [] = TEXT("Quality");
CONST TCHAR szColor       [] = TEXT("Color");
CONST TCHAR szPlacement   [] = TEXT("Placement");
CONST TCHAR szPlcFmt      [] = TEXT("%d %d %d %d %d %d %d");

BOOL gfDbcsEnabled;

UINT WINAPI fakeFunc()
{
    return 0;
}

HIMC (WINAPI* pfnImmGetContext)(HWND) = (PVOID)fakeFunc;
BOOL (WINAPI* pfnImmReleaseContext)(HWND, HIMC) = (PVOID)fakeFunc;
LONG (WINAPI* pfnImmGetCompositionStringW)(HIMC, DWORD, LPVOID, DWORD) = (PVOID)fakeFunc;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\winchat\globals.h ===
/*---------------------------------------------------------------------------*\
| GLOBALS HEADER FILE
|   This module contains the external references for the global-variables
|   in globals.c
|
|
| Copyright (c) Microsoft Corp., 1990-1993
|
| created: 29-Dec-92
| history: 29-Dec-92 <chriswil> created with port to NT.
|          19-Oct-93 <chriswil> unicode enhancements from a-dianeo.
|
\*---------------------------------------------------------------------------*/

#ifndef WINCHAT_GLOBALS_H
#define WINCHAT_GLOBALS_H

#include <strsafe.h>
#define ARRAYSIZE(x) (sizeof(x) / sizeof(x[0]))

extern HFONT    hEditSndFont;
extern HWND     hwndSnd;
extern HBRUSH   hEditSndBrush;
extern COLORREF SndColorref;
extern COLORREF SndBrushColor;
extern LOGFONT  lfSnd;
extern RECT     SndRc;

extern HFONT    hEditRcvFont;
extern HWND     hwndRcv;
extern HBRUSH   hEditRcvBrush;
extern COLORREF RcvColorref;
extern COLORREF RcvBrushColor;
extern COLORREF PartBrushColor;
extern LOGFONT  lfRcv;
extern RECT     RcvRc;

extern DWORD    idInst;
extern HSZ      hszServiceName;
extern HSZ      hszConnect;
extern HSZ      hszChatTopic;
extern HSZ      hszChatShare;
extern HSZ      hszTextItem;
extern HSZ      hszConvPartner;
extern HSZ      hszConnectTest;
extern HSZ      hszLocalName;
extern HCONV    ghConv;
extern UINT_PTR idTimer;
extern int      dyStatus;
extern int      dyButtonBar;
extern int      dyBorder;
extern int      cxIcon;
extern int      cyIcon;
extern int      cbTextLen;

extern DWORD    StrXactID;
extern DWORD    XactID;
extern HANDLE   hInst;
extern HACCEL   hAccel;
extern HDC      hMemDC;
extern HBITMAP  hOldBitmap;
extern HBITMAP  hPhnBitmap;
extern HBITMAP  hOldMemObj;
extern HICON    hPhones[3];
extern HFONT    hFontStatus;
extern HFONT    hOldFont;
extern HBRUSH   hBtnFaceBrush;
extern HPEN     hShadowPen;
extern HPEN     hHilitePen;
extern HPEN     hFramePen;
extern UINT     cf_chatdata;
extern HWND     hwndActiveEdit;
extern HWND     hwndApp;
extern HWND     hwndToolbar;
extern HWND     hwndStatus;

extern WNETCALL WNetServerBrowseDialog;


extern int     ASeq[];
extern WORD    cAnimate;
extern HANDLE  hMemTextBuffer;
extern int     nConnectAttempt;


extern WNDPROC  lpfnOldEditProc;
extern WNDPROC  lpfnOldRcvEditProc;

extern LPBYTE   lpbTextBuffer;



extern CHOOSEFONT  chf;
extern CHOOSECOLOR chc;
extern DWORD       CustColors[16];


extern CHATSTATE       ChatState;
extern CHATDATA        ChatData;
extern CHATDATA        ChatDataRcv;
extern WINDOWPLACEMENT Wpl;


extern TCHAR szHelv          [];
extern TCHAR szAppName       [];
extern TCHAR szServiceName   [];
extern TCHAR szAlreadyConnect[];
extern TCHAR szAbandonFirst  [];
extern TCHAR szDialing       [];
extern TCHAR szYouCaller     [];
extern TCHAR szNotCalled     [];
extern TCHAR szNotConnected  [];
extern TCHAR szConnectAbandon[];
extern TCHAR szHangingUp     [];
extern TCHAR szHasTerminated [];
extern TCHAR szConnectedTo   [];
extern TCHAR szConnecting    [];
extern TCHAR szIsCalling     [];
extern TCHAR szDialHelp      [];
extern TCHAR szAnswerHelp    [];
extern TCHAR szHangUpHelp    [];
extern TCHAR szNoConnect     [];
extern TCHAR szNoConnectionTo[];
extern TCHAR szSysErr        [];
extern TCHAR szAlwaysOnTop   [];
extern TCHAR szNoNet         [];
extern TCHAR szBuf           [];
extern TCHAR szHelp          [];
extern TCHAR szConvPartner   [];
extern TCHAR szLocalName     [];
extern CONST TCHAR szChatTopic     [];
extern TCHAR szChatShare     [];
extern CONST TCHAR szWcRingIn      [];
extern CONST TCHAR szWcRingOut     [];
extern CONST TCHAR szSysIni        [];
extern CONST TCHAR szVredir        [];
extern CONST TCHAR szComputerName  [];
extern CONST TCHAR szChatText      [];
extern CONST TCHAR szConnectTest   [];
extern CONST TCHAR szWinChatClass  [];
extern CONST TCHAR szWinChatMenu   [];
extern CONST TCHAR szHelpFile      [];
extern CONST TCHAR szIni           [];
extern CONST TCHAR szFnt           [];
extern CONST TCHAR szPref          [];
extern CONST TCHAR szSnd           [];
extern CONST TCHAR szTool          [];
extern CONST TCHAR szStat          [];
extern CONST TCHAR szTop           [];
extern CONST TCHAR szUseOF         [];
extern CONST TCHAR szSbS           [];
extern CONST TCHAR szAutoAns       [];
extern CONST TCHAR szBkgnd         [];
extern CONST TCHAR szNull          [];

extern TCHAR szIniSection    [];
extern TCHAR szIniKey1       [];
extern TCHAR szIniKey2       [];
extern TCHAR szIniRingIn     [];
extern TCHAR szIniRingOut    [];

extern CONST TCHAR szHeight        [];
extern CONST TCHAR szWeight        [];
extern CONST TCHAR szPitchFam      [];
extern CONST TCHAR szItalic        [];
extern CONST TCHAR szUnderline     [];
extern CONST TCHAR szStrikeOut     [];
extern CONST TCHAR szFontName      [];
extern CONST TCHAR szWidth         [];
extern CONST TCHAR szCharSet       [];
extern CONST TCHAR szOutPrecision  [];
extern CONST TCHAR szClipPrec      [];
extern CONST TCHAR szQuality       [];
extern CONST TCHAR szColor         [];
extern CONST TCHAR szPlacement     [];
extern CONST TCHAR szPlcFmt        [];


extern UINT CONST nIDs[];

extern BOOL gfDbcsEnabled;

extern HIMC (WINAPI* pfnImmGetContext)(HWND);
extern BOOL (WINAPI* pfnImmReleaseContext)(HWND, HIMC);
extern LONG (WINAPI* pfnImmGetCompositionStringW)(HIMC, DWORD, LPVOID, DWORD);

#endif  // WINCHAT_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\winchat\wcinit.c ===
/*---------------------------------------------------------------------------*\
| INITIALIZATION MODULE
|   This module contains the one-time initialization routines.
|
|   FUNCTIONS
|   ---------
|   InitFontFromIni
|   SaveFontToIni
|   SaveBkGndToIni
|   LoadIntlStrings
|   SaveWindowPlacement
|   ReadWindowPlacement
|   CreateTools
|   DeleteTools
|   CreateChildWindows
|
|
| Copyright (c) Microsoft Corp., 1990-1993
|
| created: 01-Nov-91
| history: 01-Nov-91 <clausgi>  created.
|          29-Dec-92 <chriswil> port to NT, cleanup.
|          19-Oct-93 <chriswil> unicode enhancements from a-dianeo.
|
\*---------------------------------------------------------------------------*/

#include <windows.h>
#include <ddeml.h>
#include <commdlg.h>
#include <stdio.h>
#include <stdlib.h>
#include <commctrl.h>
#include <tchar.h>
#include "winchat.h"
#include "globals.h"
//#include "uniconv.h"


static TBBUTTON tbButtons[] =
{
    {0,0,         TBSTATE_ENABLED, TBSTYLE_SEP,  0},
    {0,IDM_DIAL  ,TBSTATE_ENABLED,TBSTYLE_BUTTON,0},
    {1,IDM_ANSWER,TBSTATE_ENABLED,TBSTYLE_BUTTON,0},
    {2,IDM_HANGUP,TBSTATE_ENABLED,TBSTYLE_BUTTON,0},
};
#define cTbButtons sizeof(tbButtons)/sizeof(TBBUTTON)

#ifdef WIN16
#pragma alloc_text (_INIT, InitFontFromIni)
#endif
/*---------------------------------------------------------------------------*\
| INITIALIZE FONT FROM INI FILE
|   This routine initializes the font information from the winchat.ini file.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID FAR InitFontFromIni(VOID)
{
    CHARSETINFO csi;
    DWORD dw = GetACP();

    if (!TranslateCharsetInfo((DWORD*)&dw, &csi, TCI_SRCCODEPAGE)) {
        csi.ciCharset = ANSI_CHARSET;
    }

    // font related stuff
    // CODEWORK - the following code defines some somewhat arbitrary
    // constants for a first shot font - we should default to the
    // system font in an easier more portable manner.
    //
    lfSnd.lfHeight         = (int) GetPrivateProfileInt(szFnt,szHeight      ,(UINT)-13          ,szIni);
    lfSnd.lfWeight         = (int) GetPrivateProfileInt(szFnt,szWeight      ,700                ,szIni);
    lfSnd.lfWidth          = (int) GetPrivateProfileInt(szFnt,szWidth       ,  0                ,szIni);
    lfSnd.lfPitchAndFamily = (BYTE)GetPrivateProfileInt(szFnt,szPitchFam    , 22                ,szIni);
    lfSnd.lfItalic         = (BYTE)GetPrivateProfileInt(szFnt,szItalic      ,  0                ,szIni);
    lfSnd.lfUnderline      = (BYTE)GetPrivateProfileInt(szFnt,szUnderline   ,  0                ,szIni);
    lfSnd.lfStrikeOut      = (BYTE)GetPrivateProfileInt(szFnt,szStrikeOut   ,  0                ,szIni);

    lfSnd.lfCharSet        = (BYTE)GetPrivateProfileInt(szFnt, szCharSet    ,csi.ciCharset      ,szIni);

    lfSnd.lfOutPrecision   = (BYTE)GetPrivateProfileInt(szFnt,szOutPrecision,OUT_DEFAULT_PRECIS ,szIni);
    lfSnd.lfClipPrecision  = (BYTE)GetPrivateProfileInt(szFnt,szClipPrec    ,CLIP_DEFAULT_PRECIS,szIni);
    lfSnd.lfQuality        = (BYTE)GetPrivateProfileInt(szFnt,szQuality     ,DEFAULT_QUALITY    ,szIni);
    lfSnd.lfEscapement     = 0;
    lfSnd.lfOrientation    = 0;

#ifdef UNICODE
    if (gfDbcsEnabled) {
        GetPrivateProfileString(szFnt,szFontName,TEXT("MS Shell Dlg"),lfSnd.lfFaceName,LF_XPACKFACESIZE,szIni);
    }
    else {
        GetPrivateProfileString(szFnt,szFontName,TEXT("MS Shell Dlg"),lfSnd.lfFaceName,LF_XPACKFACESIZE,szIni);
    }
#else
    GetPrivateProfileString(szFnt,szFontName,TEXT("MS Shell Dlg"),lfSnd.lfFaceName,LF_XPACKFACESIZE,szIni);
#endif


    if(GetPrivateProfileString(szFnt,szColor,szNull,szBuf,SZBUFSIZ,szIni))
        SndColorref = myatol(szBuf);
    else
        SndColorref = GetSysColor(COLOR_WINDOWTEXT);

    return;
}


#ifdef WIN16
#pragma alloc_text (_INIT, SaveFontToIni)
#endif
/*---------------------------------------------------------------------------*\
| SAVE FONT TO INI FILE
|   This routine saves the font to the ini-file.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID FAR SaveFontToIni(VOID)
{
    StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%d"), lfSnd.lfHeight);
    WritePrivateProfileString(szFnt, szHeight, szBuf, szIni);

    StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%d"), lfSnd.lfWidth);
    WritePrivateProfileString(szFnt, szWidth, szBuf, szIni);

    StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%d"), (WORD)lfSnd.lfCharSet);
    WritePrivateProfileString(szFnt, szCharSet, szBuf, szIni);

    StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%d"), (WORD)lfSnd.lfOutPrecision);
    WritePrivateProfileString(szFnt, szOutPrecision, szBuf, szIni);

    StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%d"), (WORD)lfSnd.lfClipPrecision);
    WritePrivateProfileString(szFnt, szClipPrec, szBuf, szIni);

    StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%d"), (WORD)lfSnd.lfQuality);
    WritePrivateProfileString(szFnt, szQuality, szBuf, szIni);

    StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%d"), lfSnd.lfWeight);
    WritePrivateProfileString(szFnt, szWeight, szBuf, szIni);

    StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%d"), (WORD)lfSnd.lfPitchAndFamily);
    WritePrivateProfileString(szFnt, szPitchFam, szBuf, szIni);

    StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%d"), (WORD)lfSnd.lfItalic);
    WritePrivateProfileString(szFnt, szItalic, szBuf, szIni);

    StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%d"), (WORD)lfSnd.lfUnderline);
    WritePrivateProfileString(szFnt, szUnderline, szBuf, szIni);

    StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%d"), (WORD)lfSnd.lfStrikeOut);
    WritePrivateProfileString(szFnt, szStrikeOut, szBuf, szIni);

    WritePrivateProfileString(szFnt, szFontName, lfSnd.lfFaceName, szIni);
    StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%ld"), (DWORD)SndColorref);

    WritePrivateProfileString(szFnt, szColor, szBuf, szIni);

    return;
}


#ifdef WIN16
#pragma alloc_text (_INIT, SaveBkGndToIni)
#endif
/*---------------------------------------------------------------------------*\
| SAVE BACKGROUND TO INI FILE
|   This routine saves the background-color to file.
|
| created: 27-Mar-95
| history: 27-Mar-95 <chriswil> created.
|
\*---------------------------------------------------------------------------*/
VOID FAR SaveBkGndToIni(VOID)
{
    StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%ld"), (DWORD)SndBrushColor);
    WritePrivateProfileString(szPref, szBkgnd, szBuf, szIni);

    return;
}


#ifdef WIN16
#pragma alloc_text (_INIT, LoadIntlStrings)
#endif
/*---------------------------------------------------------------------------*\
| LOAD INTERNAL STRINGS
|   This routine loads the resources strings.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID FAR LoadIntlStrings(VOID)
{
    LoadString(hInst,IDS_HELV          , szHelv          , SMLRCBUF);
    LoadString(hInst,IDS_APPNAME       , szAppName       , SMLRCBUF);
    LoadString(hInst,IDS_SERVICENAME   , szServiceName   , SMLRCBUF);
    LoadString(hInst,IDS_SYSERR        , szSysErr        , BIGRCBUF);
    LoadString(hInst,IDS_DIALING       , szDialing       , BIGRCBUF);
    LoadString(hInst,IDS_CONNECTABANDON, szConnectAbandon, BIGRCBUF);
    LoadString(hInst,IDS_HANGINGUP     , szHangingUp     , BIGRCBUF);
    LoadString(hInst,IDS_HASTERMINATED , szHasTerminated , BIGRCBUF);
    LoadString(hInst,IDS_CONNECTEDTO   , szConnectedTo   , BIGRCBUF);
    LoadString(hInst,IDS_CONNECTING    , szConnecting    , BIGRCBUF);
    LoadString(hInst,IDS_ISCALLING     , szIsCalling     , BIGRCBUF);
    LoadString(hInst,IDS_DIALHELP      , szDialHelp      , BIGRCBUF);
    LoadString(hInst,IDS_ANSWERHELP    , szAnswerHelp    , BIGRCBUF);
    LoadString(hInst,IDS_HANGUPHELP    , szHangUpHelp    , BIGRCBUF);
    LoadString(hInst,IDS_NOCONNECT     , szNoConnect     , BIGRCBUF);
    LoadString(hInst,IDS_ALWAYSONTOP   , szAlwaysOnTop   , BIGRCBUF);
    LoadString(hInst,IDS_NOCONNECTTO   , szNoConnectionTo, BIGRCBUF);
    LoadString(hInst,IDS_NONETINSTALLED, szNoNet         , SZBUFSIZ);

    LoadString(hInst,IDS_INISECTION, szIniSection    , SZBUFSIZ);
    LoadString(hInst,IDS_INIPREFKEY, szIniKey1       , BIGRCBUF);
    LoadString(hInst,IDS_INIFONTKEY, szIniKey2       , BIGRCBUF);
    LoadString(hInst,IDS_INIRINGIN , szIniRingIn     , BIGRCBUF);
    LoadString(hInst,IDS_INIRINGOUT, szIniRingOut    , BIGRCBUF);

    return;
}


#ifdef WIN16
#pragma alloc_text (_INIT, SaveWindowPlacement)
#endif
/*---------------------------------------------------------------------------*\
| SAVE WINDOW PLACEMENT
|   This routine saves the window position to the inifile.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID FAR SaveWindowPlacement(PWINDOWPLACEMENT w)
{
    StringCchPrintf(szBuf,SZBUFSIZ,szPlcFmt,w->showCmd,
                            w->ptMaxPosition.x,
                            w->ptMaxPosition.y,
                            w->rcNormalPosition.left,
                            w->rcNormalPosition.top,
                            w->rcNormalPosition.right,
                            w->rcNormalPosition.bottom);

    WritePrivateProfileString(szPref,szPlacement,szBuf,szIni);

    return;
}


/*---------------------------------------------------------------------------*\
| GET WINDOW PLACEMENT
|   This routine loads the window placement from the inifile.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
BOOL FAR ReadWindowPlacement(PWINDOWPLACEMENT w)
{
    BOOL bRet;


    bRet = FALSE;
    if(GetPrivateProfileString(szPref,szPlacement,szNull,szBuf,SZBUFSIZ,szIni))
    {
        w->length = sizeof(WINDOWPLACEMENT);

        if(_stscanf(szBuf,szPlcFmt,&(w->showCmd),
                                 &(w->ptMaxPosition.x),
                                 &(w->ptMaxPosition.y),
                                 &(w->rcNormalPosition.left),
                                 &(w->rcNormalPosition.top),
                                 &(w->rcNormalPosition.right),
                                 &(w->rcNormalPosition.bottom)) == 7)
        {

            bRet = TRUE;
        }
    }

    return(bRet);
}


#ifdef WIN16
#pragma alloc_text (_INIT, CreateTools)
#endif
/*---------------------------------------------------------------------------*\
| CREATE TOOLS
|   This routine creates the visual tools for the interface.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID FAR CreateTools(HWND hwnd)
{
    HDC hdc;


    hdc        = GetDC(hwnd);
    hMemDC     = CreateCompatibleDC(hdc);
    hPhnBitmap = CreateCompatibleBitmap(hdc,cxIcon * 3,cyIcon);
    hOldMemObj = SelectObject(hMemDC,hPhnBitmap);
    ReleaseDC(hwnd,hdc);


    hHilitePen    = CreatePen(PS_SOLID,1,GetSysColor(COLOR_BTNHIGHLIGHT));
    hShadowPen    = CreatePen(PS_SOLID,1,GetSysColor(COLOR_BTNSHADOW));
    hFramePen     = CreatePen(PS_SOLID,1,GetSysColor(COLOR_WINDOWFRAME));

    hBtnFaceBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
    hEditSndBrush = CreateSolidBrush(SndBrushColor);
    hEditRcvBrush = CreateSolidBrush(RcvBrushColor);

    // Create the statusbar/toolbar for the interface.
    //
    hwndToolbar = CreateToolbarEx(hwnd,(ChatState.fToolBar ? WS_VISIBLE : 0) | WS_BORDER | TBSTYLE_TOOLTIPS,IDC_TOOLBAR,6,hInst,IDBITMAP,tbButtons,cTbButtons,0,0,0,0,sizeof(TBBUTTON));
    hwndStatus  = CreateStatusWindow((ChatState.fStatusBar ? WS_VISIBLE : 0) | WS_BORDER | WS_CHILD,szNull,hwnd,IDSTATUS);

    // Load the application icons.
    //
    hPhones[0] = LoadIcon(hInst,TEXT("phone1"));
    hPhones[1] = LoadIcon(hInst,TEXT("phone2"));
    hPhones[2] = LoadIcon(hInst,TEXT("phone3"));


    // now build the parameters based on the font we will be using
    //
    dyBorder = GetSystemMetrics(SM_CYBORDER);

    return;
}


#ifdef WIN16
#pragma alloc_text (_INIT, DeleteTools)
#endif
/*---------------------------------------------------------------------------*\
| DELETES TOOLS
|   This routine deletes the visual tools for the interface.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID FAR DeleteTools(HWND hwnd)
{
    DestroyWindow(hwndStatus);
    DestroyWindow(hwndToolbar);


    if(hEditSndFont)
        DeleteObject(hEditSndFont);

    if(hEditRcvFont)
        DeleteObject(hEditRcvFont);

    DeleteObject(hHilitePen);
    DeleteObject(hShadowPen);
    DeleteObject(hFramePen);
    DeleteObject(hBtnFaceBrush);
    DeleteObject(hEditSndBrush);
    DeleteObject(hEditRcvBrush);

    SelectObject(hMemDC,hOldMemObj);
    DeleteObject(hPhnBitmap);
    DeleteDC(hMemDC);

    return;
}


#ifdef WIN16
#pragma alloc_text (_INIT, CreateChildWindows)
#endif
/*---------------------------------------------------------------------------*\
| CREATE CHILD WINDOWS
|   This routine creates the child-windows for the application.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID FAR CreateChildWindows(HWND hwnd)
{
    hwndSnd = CreateWindow (TEXT("edit"),
                            NULL,
                            WS_CHILD | WS_BORDER | WS_MAXIMIZE | WS_VISIBLE |
                            WS_VSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | ES_READONLY,
                            0, 0, 0, 0,
                            hwnd,
                            (HMENU)ID_EDITSND,
                            hInst,
                            NULL);


    hwndRcv = CreateWindow (TEXT("edit"),
                            NULL,
                            WS_CHILD | WS_BORDER | WS_MAXIMIZE | WS_VISIBLE |
                            WS_VSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | ES_READONLY,
                            0, 0, 0, 0,
                            hwnd,
                            (HMENU)ID_EDITRCV,
                            hInst,
                            NULL);

    // hook the send window...
    //
    lpfnOldEditProc = (WNDPROC)GetWindowLongPtr(hwndSnd,GWLP_WNDPROC);
    SetWindowLongPtr(hwndSnd,GWLP_WNDPROC,(LONG_PTR)EditProc);

    ShowWindow(hwndSnd,SW_SHOW);
    ShowWindow(hwndRcv,SW_SHOW);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\afxcmn2.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXCMN2.H

#ifdef _AFXCMN2_INLINE

_AFXCMN2_INLINE CRichEdit2Ctrl::CRichEdit2Ctrl()
	{ }
_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::CanUndo() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_CANUNDO, 0, 0); }
_AFXCMN2_INLINE int CRichEdit2Ctrl::GetLineCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETLINECOUNT, 0, 0); }
_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::GetModify() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_GETMODIFY, 0, 0); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::SetModify(BOOL bModified /* = TRUE */)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETMODIFY, bModified, 0);}
_AFXCMN2_INLINE void CRichEdit2Ctrl::GetRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_GETRECT, 0, (LPARAM)lpRect); }
_AFXCMN2_INLINE CPoint CRichEdit2Ctrl::GetCharPos(long lChar) const
	{ ASSERT(::IsWindow(m_hWnd)); CPoint pt; ::SendMessage(m_hWnd, EM_POSFROMCHAR, (WPARAM)&pt, (LPARAM)lChar); return pt;}
_AFXCMN2_INLINE void CRichEdit2Ctrl::SetOptions(WORD wOp, DWORD dwFlags)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETOPTIONS, (WPARAM)wOp, (LPARAM)dwFlags); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::EmptyUndoBuffer()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EMPTYUNDOBUFFER, 0, 0); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo)
	{ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_REPLACESEL, (WPARAM) bCanUndo, (LPARAM)lpszNewText); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::SetRect(LPCRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETRECT, 0, (LPARAM)lpRect); }
_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::Undo()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_UNDO, 0, 0); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::Clear()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CLEAR, 0, 0); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::Copy()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_COPY, 0, 0); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::Cut()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CUT, 0, 0); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::Paste()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_PASTE, 0, 0); }
_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::SetReadOnly(BOOL bReadOnly /* = TRUE */ )
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETREADONLY, bReadOnly, 0L); }
_AFXCMN2_INLINE int CRichEdit2Ctrl::GetFirstVisibleLine() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETFIRSTVISIBLELINE, 0, 0L); }
_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::DisplayBand(LPRECT pDisplayRect)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_DISPLAYBAND, 0, (LPARAM)pDisplayRect); }
_AFXCMN2_INLINE void CRichEdit2Ctrl::GetSel(CHARRANGE &cr) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr); }

_AFXCMN2_INLINE void CRichEdit2Ctrl::LimitText(long nChars)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EXLIMITTEXT, 0, nChars); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::LineFromChar(long nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_EXLINEFROMCHAR, 0, nIndex); }

_AFXCMN2_INLINE void CRichEdit2Ctrl::SetSel(CHARRANGE &cr)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EXSETSEL, 0, (LPARAM)&cr); }

#ifndef _CHICAGO_
_AFXCMN2_INLINE long CRichEdit2Ctrl::FindText(DWORD dwFlags, FINDTEXTEX* pFindText) const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_FINDTEXTEX, dwFlags, (LPARAM)pFindText); }
#endif // !_CHICAGO_

_AFXCMN2_INLINE long CRichEdit2Ctrl::FormatRange(FORMATRANGE* pfr, BOOL bDisplay)
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_FORMATRANGE, (WPARAM)bDisplay, (LPARAM)pfr); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::GetEventMask() const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_GETEVENTMASK, 0, 0L); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::GetLimitText() const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_GETLIMITTEXT, 0, 0L); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::GetSelText(LPSTR lpBuf) const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpBuf); }

_AFXCMN2_INLINE void CRichEdit2Ctrl::HideSelection(BOOL bHide, BOOL bPerm)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_HIDESELECTION, bHide, bPerm); }

_AFXCMN2_INLINE void CRichEdit2Ctrl::RequestResize()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_REQUESTRESIZE, 0, 0L); }

_AFXCMN2_INLINE WORD CRichEdit2Ctrl::GetSelectionType() const
	{ ASSERT(::IsWindow(m_hWnd)); return (WORD)::SendMessage(m_hWnd, EM_SELECTIONTYPE, 0, 0L); }

_AFXCMN2_INLINE COLORREF CRichEdit2Ctrl::SetBackgroundColor(BOOL bSysColor, COLORREF cr)
	{ ASSERT(::IsWindow(m_hWnd)); return (COLORREF)::SendMessage(m_hWnd, EM_SETBKGNDCOLOR, bSysColor, cr); }

_AFXCMN2_INLINE DWORD CRichEdit2Ctrl::SetEventMask(DWORD dwEventMask)
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD)::SendMessage(m_hWnd, EM_SETEVENTMASK, 0, dwEventMask); }

_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::SetOLECallback(IRichEditOleCallback* pCallback)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETOLECALLBACK, 0, (LPARAM)pCallback); }

_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::SetTargetDevice(HDC hDC, long lLineWidth)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETTARGETDEVICE, (WPARAM)hDC, lLineWidth); }

_AFXCMN2_INLINE BOOL CRichEdit2Ctrl::SetTargetDevice(CDC &dc, long lLineWidth)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETTARGETDEVICE, (WPARAM)dc.m_hDC, lLineWidth); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::StreamIn(int nFormat, EDITSTREAM &es)
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_STREAMIN, nFormat, (LPARAM)&es); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::StreamOut(int nFormat, EDITSTREAM &es)
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, EM_STREAMOUT, nFormat, (LPARAM)&es); }

_AFXCMN2_INLINE long CRichEdit2Ctrl::GetTextLength() const
	{ ASSERT(::IsWindow(m_hWnd)); return (long)::SendMessage(m_hWnd, WM_GETTEXTLENGTH, NULL, NULL); }


#endif //_AFXCMN2_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\afxdlgs2.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXDLGS2.H

#ifdef _AFXDLGS2_INLINE

_AFXDLGS2_INLINE CString CFontDialog2::GetFaceName() const
	{ return (LPCTSTR)m_cf.lpLogFont->lfFaceName; }
_AFXDLGS2_INLINE CString CFontDialog2::GetStyleName() const
	{ return m_cf.lpszStyle; }
_AFXDLGS2_INLINE int CFontDialog2::GetSize() const
	{ return m_cf.iPointSize; }
_AFXDLGS2_INLINE int CFontDialog2::GetWeight() const
	{ return (int)m_cf.lpLogFont->lfWeight; }
_AFXDLGS2_INLINE BOOL CFontDialog2::IsItalic() const
	{ return m_cf.lpLogFont->lfItalic ? TRUE : FALSE; }
_AFXDLGS2_INLINE BOOL CFontDialog2::IsStrikeOut() const
	{ return m_cf.lpLogFont->lfStrikeOut ? TRUE : FALSE; }
_AFXDLGS2_INLINE BOOL CFontDialog2::IsBold() const
	{ return m_cf.lpLogFont->lfWeight == FW_BOLD ? TRUE : FALSE; }
_AFXDLGS2_INLINE BOOL CFontDialog2::IsUnderline() const
	{ return m_cf.lpLogFont->lfUnderline ? TRUE : FALSE; }
_AFXDLGS2_INLINE COLORREF CFontDialog2::GetColor() const
	{ return m_cf.rgbColors; }

/////////////////////////////////////////////////////////////////////////////

#endif //_AFXDLGS2_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\winchat\winchat.h ===
/*---------------------------------------------------------------------------*\
| WINCHAT MAIN HEADER FILE
|   This is the main header file for the application.
|
|
| Copyright (c) Microsoft Corp., 1990-1993
|
| created: 01-Nov-91
| history: 01-Nov-91 <clausgi>  created.
|          29-Dec-92 <chriswil> port to NT, cleanup.
|          19-Oct-93 <chriswil> unicode enhancements from a-dianeo.
|
\*---------------------------------------------------------------------------*/

//////////// compile options //////////////
#define BRD 6
///////////////////////////////////////////


#ifdef WIN16
#define APIENTRY FAR PASCAL
#define ERROR_NO_NETWORK   0
#endif

#ifdef PROTOCOL_NEGOTIATE
typedef DWORD      PCKT;        // Bitfield capabilities.
#define CHT_VER    0x100        // Version 1.00 of WinChat.
#define PCKT_TEXT  0x00000001   // All versions had better support this.
#endif




// Constants.
//
#define SZBUFSIZ            255     // maximum size buffer.
#define SMLRCBUF             32     // size A .rc file buffer
#define BIGRCBUF             64     // size B .rc file buffer
#define UNCNLEN              32     //
#define CTRL_V               22     // Edit-control paste acccelerator.
#define IDACCELERATORS        1     // Menu accelerator resource ID.



// Menuhelp Constants.
//
#define MH_BASE             0x1000
#define MH_POPUPBASE        0x1100



// Child-Window ID's for send/receive windows.
//
#define ID_BASE             0x0CAC
#define ID_EDITSND          (ID_BASE + 0)
#define ID_EDITRCV          (ID_BASE + 1)



// Child-Window Identifiers for toolbar/statusbar.
//
#define IDC_TOOLBAR         200
#define IDBITMAP            201
#define IDSTATUS            202



// Menu Identifiers.
//
#define IDM_EDITFIRST       IDM_EDITUNDO
#define IDM_EDITLAST        IDM_EDITSELECT
#define IDM_ABOUT           100
#define IDM_DIAL            101
#define IDM_HANGUP          102
#define IDM_ANSWER          103
#define IDM_EXIT            104
#define IDM_EDITUNDO        105
#define IDM_EDITCUT         106
#define IDM_EDITCOPY        107
#define IDM_EDITPASTE       108
#define IDM_EDITCLEAR       109
#define IDM_EDITSELECT      110
#define IDM_SOUND           111
#define IDM_PREFERENCES     112
#define IDM_FONT            113
#define IDM_CONTENTS        114
#define IDM_SEARCHHELP      115
#define IDM_HELPHELP        116
#define IDM_COLOR           117
#define IDM_TOPMOST         118
#define IDM_CLOCK           119
#define IDM_TOOLBAR         120
#define IDM_STATUSBAR       121
#define IDM_SWITCHWIN       122
#define IDX_DEFERFONTCHANGE 123
#define IDX_UNICODECONV     126
#define IDM_FIRST           IDM_ABOUT

#define IDH_SELECTCOMPUTER  200


#ifdef PROTOCOL_NEGOTIATE
#define IDX_DEFERPROTOCOL   124
#endif


// Resource-String Identifiers.
//
#define IDS_HELV             1
#define IDS_APPNAME          2
#define IDS_LONGAPPNAME      3
#define IDS_SYSERR           4
#define IDS_CONNECTTO        5
#define IDS_ALREADYCONNECT   6
#define IDS_ABANDONFIRST     7
#define IDS_DIALING          8
#define IDS_YOUCALLER        9
#define IDS_NOTCALLED       10
#define IDS_NOTCONNECTED    11
#define IDS_CONNECTABANDON  12
#define IDS_HANGINGUP       13
#define IDS_HASTERMINATED   14
#define IDS_CONNECTEDTO     15
#define IDS_ISCALLING       16
#define IDS_CONNECTING      17
#define IDS_SERVICENAME     18
#define IDS_DIALHELP        19
#define IDS_ANSWERHELP      20
#define IDS_HANGUPHELP      21
#define IDS_NOCONNECT       22
#define IDS_ALWAYSONTOP     23
#define IDS_NOCONNECTTO     24
#define IDS_NONETINSTALLED  25

#define IDS_INISECTION      26
#define IDS_INIPREFKEY      27
#define IDS_INIFONTKEY      28
#define IDS_INIRINGIN       29
#define IDS_INIRINGOUT      30

#define IDS_TSNOTSUPPORTED  31


// Edit-Control Notification codes.  These
// are sent to the parent of the edit
// control just as any system-notify is.
//
#define EN_CHAR             0x060F
#define EN_PASTE            0x0610

// FE specific
#define EN_DBCS_STRING      0x0611


// Chat formats.  These are used to identify
// the type of data being transfered in a
// DDE transaction.
//
#define CHT_CHAR            0x100
#define CHT_FONTA           0x101
#define CHT_PASTEA          0x102
#define CHT_UNICODE         0x110
#define CHT_FONTW           0x111
#define CHT_PASTEW          0x112

// FE specific (not Taiwan)
#define CHT_DBCS_STRING     0x103


#ifdef PROTOCOL_NEGOTIATE
#define CHT_PROTOCOL        0x105
#endif


#if 0
#define CHT_HPENDATA        0x103   // defined in WFW311.  Conflicts w/DBCS.
#define CHT_CLEARPENDATA    0x104   //
#define CHT_ADDCHATTER      0x106   //
#define CHT_DELCHATTER      0x107   //
#define CHT_CHARBURST       0x108   //
#endif



// Window Related Functions  (winchat.c)
//
int     PASCAL   WinMain(HINSTANCE,HINSTANCE,LPSTR,int);
LRESULT CALLBACK MainWndProc(HWND,UINT,WPARAM,LPARAM);
LRESULT CALLBACK EditProc(HWND,UINT,WPARAM,LPARAM);
BOOL    FAR      InitApplication(HINSTANCE);
BOOL    FAR      InitInstance(HINSTANCE,int);
VOID    FAR      UpdateButtonStates(VOID);
VOID    FAR      AdjustEditWindows(VOID);
LONG    FAR      myatol(LPTSTR);
BOOL    FAR      appGetComputerName(LPTSTR);
VOID             DrawShadowRect(HDC,LPRECT);
VOID             SendFontToPartner(VOID);
VOID             DoRing(LPCTSTR);
VOID             ClearEditControls(VOID);



// Initialization Routines  (wcinit.c)
//
VOID FAR SaveFontToIni(VOID);
VOID FAR SaveBkGndToIni(VOID);
VOID FAR InitFontFromIni(VOID);
VOID FAR LoadIntlStrings(VOID);
VOID FAR SaveWindowPlacement(PWINDOWPLACEMENT);
BOOL FAR ReadWindowPlacement(PWINDOWPLACEMENT);
VOID FAR CreateTools(HWND);
VOID FAR DeleteTools(HWND);
VOID FAR CreateChildWindows(HWND);



// Window handler routines  (winchat.c)
//
VOID    appWMCreateProc(HWND);
VOID    appWMWinIniChangeProc(HWND);
VOID    appWMSetFocusProc(HWND);
VOID    appWMMenuSelectProc(HWND,WPARAM,LPARAM);
VOID    appWMTimerProc(HWND);
VOID    appWMPaintProc(HWND);
VOID    appWMDestroyProc(HWND);
BOOL    appWMCommandProc(HWND,WPARAM,LPARAM);
VOID    appWMInitMenuProc(HMENU);
VOID    appWMSizeProc(HWND,WPARAM,LPARAM);
BOOL    appWMEraseBkGndProc(HWND);
LRESULT appWMSysCommandProc(HWND,WPARAM,LPARAM);
HBRUSH  appWMCtlColorProc(HWND,WPARAM,LPARAM);
HICON   appWMQueryDragIconProc(HWND);



// DDE Related Functions.
//
HDDEDATA CALLBACK DdeCallback(UINT,UINT,HCONV,HSZ,HSZ,HDDEDATA,DWORD,DWORD);
HDDEDATA          CreateCharData(VOID);
HDDEDATA          CreatePasteData(VOID);

// FE specific
HDDEDATA          CreateDbcsStringData(VOID);

#ifdef PROTOCOL_NEGOTIATE
HDDEDATA          CreateProtocolData(VOID);
PCKT              GetCurrentPckt(VOID);
VOID              FlagIntersection(PCKT);
VOID              AnnounceSupport(VOID);
#endif


//
//
typedef UINT (WINAPI *WNETCALL)(HWND,LPTSTR,LPTSTR,WORD,DWORD);
HINSTANCE APIENTRY WNetGetCaps(WORD);



// Chat Data.
//   This data-structure must maintain
//   fixed-size fields so that they may
//   be transfered accross platforms.
//
#ifndef RC_INVOLKED

#define LF_XPACKFACESIZE  32
#define XCHATSIZEA        60
#define XCHATSIZEW        92

#pragma pack(2)
typedef struct tagXPACKFONTA
{
    WORD lfHeight;
    WORD lfWidth;
    WORD lfEscapement;
    WORD lfOrientation;
    WORD lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[LF_XPACKFACESIZE];
} XPACKFONTA;

typedef struct tagXPACKFONTW
{
    WORD lfHeight;
    WORD lfWidth;
    WORD lfEscapement;
    WORD lfOrientation;
    WORD lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[LF_XPACKFACESIZE];
} XPACKFONTW;

typedef struct _CHATDATAA
{
    WORD type;

    union
    {

        // This data for DBCS string transfer.
        //
        struct
        {
            DWORD   SelPos;
            DWORD   size;
            HGLOBAL hString;
        } cd_dbcs;

        // This data for character transfer.
        //
        struct
        {
            DWORD SelPos;
            WORD  Char;
        } cd_char;


        // This data for remote font change.
        //
        struct
        {
            XPACKFONTA lf;
            COLORREF   cref;
            COLORREF   brush;
        } cd_win;


        // This data for remote paste.
        //
        struct
        {
            DWORD SelPos;
            DWORD size;
        } cd_paste;

#ifdef PROTOCOL_NEGOTIATE
        // This data for Protocol Negotiate.
        //
        struct
        {
            DWORD dwVer;
            PCKT  pckt;
        } cd_protocol;
#endif

    } uval;
} CHATDATAA;

typedef struct _CHATDATAW
{
    WORD type;

    union
    {

        // This data for DBCS string transfer.
        //
        struct
        {
            DWORD   SelPos;
            DWORD   size;
            HGLOBAL hString;
        } cd_dbcs;

        // This data for character transfer.
        //
        struct
        {
            DWORD SelPos;
            WORD  Char;
        } cd_char;


        // This data for remote font change.
        //
        struct
        {
            XPACKFONTW  lf;
            COLORREF    cref;
            COLORREF    brush;
        } cd_win;


        // This data for remote paste.
        //
        struct
        {
            DWORD SelPos;
            DWORD size;
        } cd_paste;

#ifdef PROTOCOL_NEGOTIATE
        // This data for Protocol Negotiate.
        //
        struct
        {
            DWORD dwVer;
            PCKT  pckt;
        } cd_protocol;
#endif

    } uval;

} CHATDATAW;

#pragma pack()

typedef XPACKFONTA      *PXPACKFONTA;
typedef XPACKFONTA NEAR *NPXPACKFONTA;
typedef XPACKFONTA FAR  *LPXPACKFONTA;

typedef CHATDATAA       *PCHATDATAA;
typedef CHATDATAA NEAR  *NPCHATDATAA;
typedef CHATDATAA FAR   *LPCHATDATAA;

typedef XPACKFONTW      *PXPACKFONTW;
typedef XPACKFONTW NEAR *NPXPACKFONTW;
typedef XPACKFONTW FAR  *LPXPACKFONTW;

typedef CHATDATAW       *PCHATDATAW;
typedef CHATDATAW NEAR  *NPCHATDATAW;
typedef CHATDATAW FAR   *LPCHATDATAW;

#ifdef UNICODE
#define XPACKFONT  XPACKFONTW
#else
#define XPACKFONT  XPACKFONTA
#endif

typedef XPACKFONT      *PXPACKFONT;
typedef XPACKFONT NEAR *NPXPACKFONT;
typedef XPACKFONT FAR  *LPXPACKFONT;

#ifdef UNICODE
#define CHATDATA   CHATDATAW
#else
#define CHATDATA   CHATDATAA
#endif

typedef CHATDATA      *PCHATDATA;
typedef CHATDATA NEAR *NPCHATDATA;
typedef CHATDATA FAR  *LPCHATDATA;

#endif


// Chat state info struct
//
typedef struct _CHATSTATE
{
    UINT fConnected          : 1;
    UINT fConnectPending     : 1;
    UINT fAllowAnswer        : 1;
    UINT fIsServer           : 1;
    UINT fServerVerified     : 1;
    UINT fInProcessOfDialing : 1;
    UINT fSound              : 1;
    UINT fMMSound            : 1;
    UINT fUseOwnFont         : 1;
    UINT fSideBySide         : 1;
    UINT fMinimized          : 1;
    UINT fTopMost            : 1;
    UINT fToolBar            : 1;
    UINT fStatusBar          : 1;
    UINT fUnicode            : 1;

#ifdef PROTOCOL_NEGOTIATE
    UINT fProtocolSent       : 1;
#endif

} CHATSTATE;
typedef CHATSTATE      *PCHATSTATE;
typedef CHATSTATE NEAR *NPCHATSTATE;
typedef CHATSTATE FAR  *LPCHATSTATE;



// Insertable macroes.
//
#define KILLSOUND              {if(ChatState.fMMSound) sndPlaySound(NULL,SND_ASYNC);}
#define SetStatusWindowText(x) {if(hwndStatus)SendMessage(hwndStatus,SB_SETTEXT,0,(LPARAM)(LPSTR)(x));}



// Helpfull porting macroes.  These were necessary
// especially for notification codes which changed
// drastically between DOS/WIN and NT.
//
#ifdef WIN32
#define GET_WM_MENUSELECT_CMD(wParam,lParam)    (UINT)(int)(short)LOWORD(wParam)
#define GET_WM_MENUSELECT_FLAGS(wParam,lParam)  (UINT)(int)(short)HIWORD(wParam)
#define GET_WM_MENUSELECT_HMENU(wParam,lParam)  (HMENU)lParam
#define SET_EM_SETSEL_WPARAM(nStart,nEnd)       (WPARAM)nStart
#define SET_EM_SETSEL_LPARAM(nStart,nEnd)       (LPARAM)nEnd
#define GET_WM_CTLCOLOREDIT_HDC(wParam,lParam)  (HDC)wParam
#define GET_WM_CTLCOLOREDIT_HWND(wParam,lParam) (HWND)lParam
#define GET_EN_SETFOCUS_NOTIFY(wParam,lParam)   (UINT)HIWORD(wParam)
#define GET_EN_SETFOCUS_CMD(wParam,lParam)      (UINT)LOWORD(wParam)
#define GET_EN_SETFOCUS_HWND(wParam,lParam)     (HWND)lParam
#define SET_EN_NOTIFY_WPARAM(id,notify,hwnd)    (WPARAM)MAKELONG(id,notify)
#define SET_EN_NOTIFY_LPARAM(id,notify,hwnd)    (LPARAM)hwnd
#define WNETGETCAPS(wFlag)                      NULL
#define WNETGETUSER(szlocal,szuser,ncount)      WNetGetUser(szlocal,szuser,ncount)
#define SETMESSAGEQUEUE(size)                   size

#else

int APIENTRY ShellAbout(HWND hWnd, LPSTR szApp, LPSTR szOtherStuff, HICON hIcon);
#define GET_WM_MENUSELECT_CMD(wParam,lParam)    (UINT)wParam
#define GET_WM_MENUSELECT_FLAGS(wParam,lParam)  (UINT)(LOWORD(lParam))
#define GET_WM_MENUSELECT_HMENU(wParam,lParam)  (HMENU)(HIWORD(lParam))
#define SET_EM_SETSEL_WPARAM(nStart,nEnd)       (WPARAM)0
#define SET_EM_SETSEL_LPARAM(nStart,nEnd)       (LPARAM)(MAKELONG(nStart,nEnd))
#define GET_WM_CTLCOLOREDIT_HDC(wParam,lParam)  (HDC)wParam
#define GET_WM_CTLCOLOREDIT_HWND(wParam,lParam) (HWND)(LOWORD(lParam))
#define GET_EN_SETFOCUS_NOTIFY(wParam,lParam)   (UINT)(HIWORD(lParam))
#define GET_EN_SETFOCUS_CMD(wParam,lParam)      (UINT)wParam
#define GET_EN_SETFOCUS_HWND(wParam,lParam)     (HWND)(LOWORD(lParam))
#define SET_EN_NOTIFY_WPARAM(id,notify,hwnd)    (WPARAM)id
#define SET_EN_NOTIFY_LPARAM(id,notify,hwnd)    (LPARAM)(MAKELONG(hwnd,notify))
#define WNETGETCAPS(wFlag)                      WNetGetCaps(wFlag)
#define WNETGETUSER(szlocal,szuser,ncount)      ERROR_NO_NETWORK
#define SETMESSAGEQUEUE(size)                   SetMessageQueue(size)
#endif




VOID PackFont(LPXPACKFONT,LPLOGFONT);
VOID UnpackFont(LPLOGFONT,LPXPACKFONT);
VOID StartIniMapping(VOID);
VOID EndIniMapping(VOID);

#ifndef ByteCountOf
#define ByteCountOf(x) sizeof(TCHAR)*(x)
#endif

#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\afximpl2.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// Auxiliary System/Screen metrics

struct AUX_DATA
{
        // system metrics
        int cxVScroll, cyHScroll;
        int cxIcon, cyIcon;

        int cxBorder2, cyBorder2;

        // device metrics for screen
        int cxPixelsPerInch, cyPixelsPerInch;

        // convenient system color
        HBRUSH hbrWindowFrame;
        HBRUSH hbrBtnFace;
#ifdef _MAC
        HBRUSH hbr3DLight;
#endif

        // color values of system colors used for CToolBar
        COLORREF clrBtnFace, clrBtnShadow, clrBtnHilite;
        COLORREF clrBtnText, clrWindowFrame;
#ifdef _MAC
        COLORREF clr3DLight;
#endif

        // standard cursors
        HCURSOR hcurWait;
        HCURSOR hcurArrow;
        HCURSOR hcurHelp;       // cursor used in Shift+F1 help

        // special GDI objects allocated on demand
        HFONT   hStatusFont;
        HFONT   hToolTipsFont;
        HBITMAP hbmMenuDot;

        // other system information
        UINT    nWinVer;        // Major.Minor version numbers
        BOOL    bWin32s;        // TRUE if Win32s (or Windows 95)
        BOOL    bWin4;          // TRUE if Windows 4.0
        BOOL    bNotWin4;       // TRUE if not Windows 4.0
        BOOL    bSmCaption;     // TRUE if WS_EX_SMCAPTION is supported
        BOOL    bMarked4;       // TRUE if marked as 4.0

#ifdef _MAC
        BOOL    bOleIgnoreSuspend;
#endif

// Implementation
        AUX_DATA();
        ~AUX_DATA();
        void UpdateSysColors();
        void UpdateSysMetrics();
};

extern AFX_DATA_IMPORT AUX_DATA afxData;

/////////////////////////////////////////////////////////////////////////////
// _AFX_EDIT_STATE

class _AFX_EDIT_STATE : public CNoTrackObject
{
public:
        _AFX_EDIT_STATE();
        virtual ~_AFX_EDIT_STATE();

        CFindReplaceDialog* pFindReplaceDlg; // find or replace dialog
        BOOL bFindOnly; // Is pFindReplace the find or replace?
        CString strFind;    // last find string
        CString strReplace; // last replace string
        BOOL bCase; // TRUE==case sensitive, FALSE==not
        int bNext;  // TRUE==search down, FALSE== search up
        BOOL bWord; // TRUE==match whole word, FALSE==not
};

#undef AFX_DATA
#define AFX_DATA

class _AFX_RICHEDIT2_STATE : public _AFX_EDIT_STATE
{
public:
	HINSTANCE m_hInstRichEdit;      // handle to richedit dll
	virtual ~_AFX_RICHEDIT2_STATE();
};

EXTERN_PROCESS_LOCAL(_AFX_RICHEDIT2_STATE, _afxRichEdit2State)

_AFX_RICHEDIT2_STATE* AFX_CDECL AfxGetRichEdit2State();


// dialog/commdlg hook procs
INT_PTR CALLBACK AfxDlgProc(HWND, UINT, WPARAM, LPARAM);

// support for standard dialogs
extern const UINT _afxNMsgSETRGB;
typedef UINT (CALLBACK* COMMDLGPROC)(HWND, UINT, WPARAM, LPARAM);

/////////////////////////////////////////////////////////////////////////////
// Special helpers

BOOL AFXAPI AfxHelpEnabled();  // determine if ID_HELP handler exists
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\afxcmn2.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXCMN2_H__
#define __AFXCMN2_H__

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifndef IMAGE_BITMAP
#define IMAGE_BITMAP 0
#endif


/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

	#ifndef _RICHEDIT_
		#include "richedit.h"
	#endif
	#ifdef __AFXOLE_H__  // only include richole if OLE support is included
		#ifndef _RICHOLE_
			#include <richole.h>
			#define _RICHOLE_
		#endif
	#else
		struct IRichEditOle;
		struct IRichEditOleCallback;
	#endif

/////////////////////////////////////////////////////////////////////////////
// AFXCMN2 - RichEdit2 Control Class

// Classes declared in this file

//CObject
	//CCmdTarget;
		//CWnd
			class CRichEdit2Ctrl;

#undef AFX_DATA
#define AFX_DATA

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Ctrl

class CRichEdit2Ctrl : public CWnd
{
	DECLARE_DYNAMIC(CRichEdit2Ctrl)

// Constructors
public:
	CRichEdit2Ctrl();
	BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
	BOOL CanUndo() const;
	int GetLineCount() const;
	BOOL GetModify() const;
	void SetModify(BOOL bModified = TRUE);
	void GetRect(LPRECT lpRect) const;
	CPoint GetCharPos(long lChar) const;
	void SetOptions(WORD wOp, DWORD dwFlags);

	// NOTE: first word in lpszBuffer must contain the size of the buffer!
	int GetLine(int nIndex, LPTSTR lpszBuffer) const;
	int GetLine(int nIndex, LPTSTR lpszBuffer, int nMaxLength) const;

	BOOL CanPaste(UINT nFormat = 0) const;
	void GetSel(long& nStartChar, long& nEndChar) const;
	void GetSel(CHARRANGE &cr) const;
	void LimitText(long nChars = 0);
	long LineFromChar(long nIndex) const;
	void SetSel(long nStartChar, long nEndChar);
	void SetSel(CHARRANGE &cr);
	DWORD GetDefaultCharFormat(CHARFORMAT &cf) const;
	DWORD GetSelectionCharFormat(CHARFORMAT &cf) const;
	long GetEventMask() const;
	long GetLimitText() const;
	DWORD GetParaFormat(PARAFORMAT &pf) const;
	// richedit EM_GETSELTEXT is ANSI
	long GetSelText(LPSTR lpBuf) const;
	CString GetSelText() const;
	WORD GetSelectionType() const;
	COLORREF SetBackgroundColor(BOOL bSysColor, COLORREF cr);
	BOOL SetDefaultCharFormat(CHARFORMAT &cf);
	BOOL SetSelectionCharFormat(CHARFORMAT &cf);
	BOOL SetWordCharFormat(CHARFORMAT &cf);
	DWORD SetEventMask(DWORD dwEventMask);
	BOOL SetParaFormat(PARAFORMAT &pf);
	BOOL SetTargetDevice(HDC hDC, long lLineWidth);
	BOOL SetTargetDevice(CDC &dc, long lLineWidth);
	long GetTextLength() const;
	BOOL SetReadOnly(BOOL bReadOnly = TRUE);
	int GetFirstVisibleLine() const;

// Operations
	void EmptyUndoBuffer();

	int LineIndex(int nLine = -1) const;
	int LineLength(int nLine = -1) const;
	void LineScroll(int nLines, int nChars = 0);
	void ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo = FALSE);
	void SetRect(LPCRECT lpRect);

	BOOL DisplayBand(LPRECT pDisplayRect);
	long FindText(DWORD dwFlags, FINDTEXTEX* pFindText) const;
	long FormatRange(FORMATRANGE* pfr, BOOL bDisplay = TRUE);
	void HideSelection(BOOL bHide, BOOL bPerm);
	void PasteSpecial(UINT nClipFormat, DWORD dvAspect = 0, HMETAFILE hMF = 0);
	void RequestResize();
	long StreamIn(int nFormat, EDITSTREAM &es);
	long StreamOut(int nFormat, EDITSTREAM &es);

	// Clipboard operations
	BOOL Undo();
	void Clear();
	void Copy();
	void Cut();
	void Paste();

// OLE support
	IRichEditOle* GetIRichEditOle() const;
	BOOL SetOLECallback(IRichEditOleCallback* pCallback);

// Implementation
public:
	virtual ~CRichEdit2Ctrl();
};
/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXCMN_INLINE inline
#include <afxcmn2.inl>
#undef _AFXCMN_INLINE
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif //__AFXCMN2_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\afxdlgs2.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXDLGS2_H__
#define __AFXDLGS2_H__

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

#ifndef _INC_COMMDLG
	#include <commdlg.h>    // common dialog APIs
#endif

	#ifndef _RICHEDIT_
		#include "richedit.h"
	#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifndef _AFX_NOFORCE_LIBS
#ifndef _MAC

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#else //!_MAC

/////////////////////////////////////////////////////////////////////////////
// Mac libraries

#endif //_MAC
#endif //!_AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXDLGS - MFC Standard dialogs

// Classes declared in this file

	// CDialog
		//class CCommonDialog;  // implementation base class

			class CFontDialog2;    // Font chooser dialog

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA

/////////////////////////////////////////////////////////////////////////////
// CFontDialog2 - used to select a font

class CFontDialog2 : public CCommonDialog
{
	DECLARE_DYNAMIC(CFontDialog2)

public:
// Attributes
	// font choosing parameter block
	CHOOSEFONT m_cf;

// Constructors
	CFontDialog2(LPLOGFONT lplfInitial = NULL,
		DWORD dwFlags = CF_EFFECTS | CF_SCREENFONTS,
		CDC* pdcPrinter = NULL,
		CWnd* pParentWnd = NULL);
	CFontDialog2(const CHARFORMAT& charformat,
		DWORD dwFlags = CF_SCREENFONTS,
		CDC* pdcPrinter = NULL,
		CWnd* pParentWnd = NULL);
// Operations
	virtual INT_PTR DoModal();

	// Get the selected font (works during DoModal displayed or after)
	void GetCurrentFont(LPLOGFONT lplf);

	// Helpers for parsing information after successful return
	CString GetFaceName() const;  // return the face name of the font
	CString GetStyleName() const; // return the style name of the font
	int GetSize() const;          // return the pt size of the font
	COLORREF GetColor() const;    // return the color of the font
	int GetWeight() const;        // return the chosen font weight
	BOOL IsStrikeOut() const;     // return TRUE if strikeout
	BOOL IsUnderline() const;     // return TRUE if underline
	BOOL IsBold() const;          // return TRUE if bold font
	BOOL IsItalic() const;        // return TRUE if italic font
	void GetCharFormat(CHARFORMAT& cf) const;

// Implementation
	LOGFONT m_lf; // default LOGFONT to store the info
	DWORD FillInLogFont(const CHARFORMAT& cf);

#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	TCHAR m_szStyleName[64]; // contains style name after return
};


#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#ifndef _AFXDLGS_INLINE
#define _AFXDLGS_INLINE inline
#endif
#include <afxdlgs2.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif //__AFXDLGS2_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\winchat\winchat.c ===
/*---------------------------------------------------------------------------*\
| WINCHAT APPLICATION MODULE
|   This is the main module file for the application.  The application was
|   originally written by ClausGi for the Windows-For-WorkGroup product.
|   In the port to NT, all references to PEN-awareness and Protocol were
|   removed.  Extensive cleanup and documenting was also added in the port.
|
|   FUNCTIONS
|   ---------
|   myatol
|   UpdateButtonStates
|   appGetComputerName
|   AdjustEditWindows
|
|
| Copyright (c) Microsoft Corp., 1990-1993
|
| created: 01-Nov-91
| history: 01-Nov-91 <clausgi>  created.
|          29-Dec-92 <chriswil> port to NT, cleanup.
|          19-Oct-93 <chriswil> unicode enhancements from a-dianeo.
|
\*---------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include <ddeml.h>
#include <commdlg.h>
#include <commctrl.h>
#include <shellapi.h>
#include <nddeapi.h>
#include <richedit.h>
#include "winchat.h"
#include "dialogs.h"
#include "globals.h"
#include "nddeagnt.h"

#include <imm.h>
#include <htmlhelp.h>

#define ASSERT(x)

// This is used in the port to NT.  Since NT doesn't haven a dialogbox for
// this function, we'll use the lanman export.
//
#ifdef WIN32
#define FOCUSDLG_DOMAINS_ONLY        (1)
#define FOCUSDLG_SERVERS_ONLY        (2)
#define FOCUSDLG_SERVERS_AND_DOMAINS (3)

#define FOCUSDLG_BROWSE_LOGON_DOMAIN         0x00010000
#define FOCUSDLG_BROWSE_WKSTA_DOMAIN         0x00020000
#define FOCUSDLG_BROWSE_OTHER_DOMAINS        0x00040000
#define FOCUSDLG_BROWSE_TRUSTING_DOMAINS     0x00080000
#define FOCUSDLG_BROWSE_WORKGROUP_DOMAINS    0x00100000

#define FOCUSDLG_BROWSE_LM2X_DOMAINS         (FOCUSDLG_BROWSE_LOGON_DOMAIN | FOCUSDLG_BROWSE_WKSTA_DOMAIN | FOCUSDLG_BROWSE_OTHER_DOMAINS)
#define FOCUSDLG_BROWSE_ALL_DOMAINS          (FOCUSDLG_BROWSE_LOCAL_DOMAINS | FOCUSDLG_BROWSE_WORKGROUP_DOMAINS)
#define FOCUSDLG_BROWSE_LOCAL_DOMAINS        (FOCUSDLG_BROWSE_LM2X_DOMAINS | FOCUSDLG_BROWSE_TRUSTING_DOMAINS)

#define MY_LOGONTYPE                         (FOCUSDLG_BROWSE_ALL_DOMAINS | FOCUSDLG_SERVERS_ONLY)

UINT APIENTRY I_SystemFocusDialog(HWND,UINT,LPWSTR,UINT,PBOOL,LPWSTR,DWORD);
#endif

BOOL TranslateWideCharPosToMultiBytePos(HWND,DWORD,DWORD,LPDWORD,LPDWORD);


/*---------------------------------------------------------------------------*\
| WINDOWS MAIN
|   This is the main event-processing loop for the application.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    MSG msg;


    msg.wParam = 0;

    if(InitApplication(hInstance))
    {
        if(InitInstance(hInstance,nCmdShow))
        {
            while(GetMessage(&msg,NULL,0,0))
            {
                if(!TranslateAccelerator(hwndApp,hAccel,&msg))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }

            if(hszConvPartner)
                DdeFreeStringHandle(idInst,hszConvPartner);

            DdeFreeStringHandle(idInst,hszChatTopic);
            DdeFreeStringHandle(idInst,hszChatShare);
            DdeFreeStringHandle(idInst,hszLocalName );
            DdeFreeStringHandle(idInst,hszTextItem);
            DdeFreeStringHandle(idInst,hszConnectTest);
            DdeUninitialize(idInst);

            EndIniMapping();
        }
    }

    return((int)msg.wParam);
}


#ifdef WIN16
#pragma alloc_text ( _INIT, InitApplication )
#endif
/*---------------------------------------------------------------------------*\
| INITIALIZE APPLICATION
|   This routine registers the application with user.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
BOOL FAR InitApplication(HINSTANCE hInstance)
{
    WNDCLASS wc;


    wc.style         = 0;
    wc.lpfnWndProc   = MainWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = LoadIcon(hInstance, TEXT("PHONE1"));
    wc.hCursor       = LoadCursor(NULL,IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
    wc.lpszMenuName  = szWinChatMenu;
    wc.lpszClassName = szWinChatClass;

    return(RegisterClass(&wc));
}


#define IMMMODULENAME L"IMM32.DLL"
#define PATHDLM     L'\\'
#define IMMMODULENAMELEN    ((sizeof PATHDLM + sizeof IMMMODULENAME) / sizeof(WCHAR))

VOID GetImmFileName(PWSTR wszImmFile)
{
    UINT i = GetSystemDirectoryW(wszImmFile, MAX_PATH);
    if (i > 0 && i < MAX_PATH - IMMMODULENAMELEN) {
        wszImmFile += i;
        if (wszImmFile[-1] != PATHDLM) {
            *wszImmFile++ = PATHDLM;
        }
    }
    StringCchCopyW(wszImmFile, MAX_PATH, IMMMODULENAME);
}

/*---------------------------------------------------------------------------*\
| IsTSRemoteSession
|
| Input:      None
| Output:     BOOL - TRUE if in a Terminal Server remote session (SessionId != 0)
|             FALSE - if error OR not in a TS rermote session
| Function:   To determine whether we are running in a TS remote session or not.
|
\*---------------------------------------------------------------------------*/
BOOL IsTSRemoteSession()
{
    BOOL      bRetVal;
    DWORD     dwSessionID;
    HINSTANCE hInst;
    FARPROC   lpfnProcessIdToSessionId;

    //assume failure
    bRetVal = FALSE;

    // load library and get proc address
    hInst=LoadLibrary(TEXT("kernel32.dll"));

    if (hInst)
    {
        lpfnProcessIdToSessionId = GetProcAddress(hInst,"ProcessIdToSessionId");

        if (lpfnProcessIdToSessionId )
        {
            if (lpfnProcessIdToSessionId(GetCurrentProcessId(),&dwSessionID))
            {
                if(dwSessionID!=0)
                {
                    bRetVal = TRUE;
                }
            }
        }

        // free the library
        FreeLibrary(hInst);
    }

    return bRetVal;
}




#ifdef WIN16
#pragma alloc_text ( _INIT, InitInstance )
#endif
/*---------------------------------------------------------------------------*\
| INITIALIZE APPLICATION INTSTANCE
|   This routine initializes instance information.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
BOOL FAR InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    HWND      hwnd;
    HMENU     hMenu;
        HINSTANCE hmodNetDriver;
    int       cAppQueue;
    BOOL      bRet;

    hInst = hInstance;


    //
    // get DBCS flag
    //
    gfDbcsEnabled = GetSystemMetrics(SM_DBCSENABLED);

    if (GetSystemMetrics(SM_IMMENABLED)) {
        //
        // if IME is enabled, get real API addresses
        //
        WCHAR wszImmFile[MAX_PATH];
        HINSTANCE hInstImm32;
        GetImmFileName(wszImmFile);
        hInstImm32 = GetModuleHandle(wszImmFile);
        if (hInstImm32) {
            pfnImmGetContext = (PVOID)GetProcAddress(hInstImm32, "ImmGetContext");
            ASSERT(pfnImmGetContext);
            pfnImmReleaseContext = (PVOID)GetProcAddress(hInstImm32, "ImmReleaseContext");
            ASSERT(pfnImmReleaseContext);
            pfnImmGetCompositionStringW = (PVOID)GetProcAddress(hInstImm32, "ImmGetCompositionStringW");
            ASSERT(pfnImmGetCompositionStringW);
        }
    }

    // increase our app queue for better performance...
    //
    for(cAppQueue=128; !SETMESSAGEQUEUE(cAppQueue); cAppQueue >>= 1);


    //
    //
    bRet = FALSE;
    if(cAppQueue >= 8)
    {
        bRet = TRUE;

        cxIcon = GetSystemMetrics(SM_CXICON);
        cyIcon = GetSystemMetrics(SM_CYICON);
        hAccel = LoadAccelerators(hInstance,MAKEINTRESOURCE(IDACCELERATORS));



        LoadIntlStrings();
        StartIniMapping();


        InitFontFromIni();


        // check if it's a Terminal Server remote session
        if (IsTSRemoteSession())
        {
            TCHAR szTSNotSupported[SZBUFSIZ];

            LoadString(hInst, IDS_TSNOTSUPPORTED, szTSNotSupported, SZBUFSIZ);

            MessageBeep(MB_ICONSTOP);
            MessageBox(NULL, szTSNotSupported, szAppName, MB_OK | MB_ICONSTOP);
            return(FALSE);
        }

        // get our machine name and map to correct character set.
        //
        if(!appGetComputerName(szLocalName))
        {
            MessageBeep(MB_ICONSTOP);
            MessageBox(NULL,szSysErr,szAppName,MB_OK | MB_ICONSTOP);
            return(FALSE);
        }


        // initialize DDEML.
        //
        if(DdeInitialize(&idInst,(PFNCALLBACK)MakeProcInstance((FARPROC)DdeCallback,hInst),APPCLASS_STANDARD,0L))
        {
            MessageBeep(MB_ICONSTOP);
            MessageBox(NULL,szSysErr,szAppName,MB_OK | MB_ICONSTOP);
            return(FALSE);
        }


        ChatState.fMinimized  = (nCmdShow == SW_MINIMIZE) ? TRUE : FALSE;
        ChatState.fMMSound    = waveOutGetNumDevs();
        ChatState.fSound      = GetPrivateProfileInt(szPref,szSnd  ,1,szIni);
        ChatState.fToolBar    = GetPrivateProfileInt(szPref,szTool ,1,szIni);
        ChatState.fStatusBar  = GetPrivateProfileInt(szPref,szStat ,1,szIni);
        ChatState.fTopMost    = GetPrivateProfileInt(szPref,szTop  ,0,szIni);
        ChatState.fSideBySide = GetPrivateProfileInt(szPref,szSbS  ,0,szIni);
        ChatState.fUseOwnFont = GetPrivateProfileInt(szPref,szUseOF,0,szIni);

        hszLocalName          = DdeCreateStringHandle(idInst,szLocalName  ,0);
        hszChatTopic          = DdeCreateStringHandle(idInst,szChatTopic  ,0);
        hszChatShare          = DdeCreateStringHandle(idInst,szChatShare  ,0);
        hszServiceName        = DdeCreateStringHandle(idInst,szServiceName,0);
        hszConnectTest        = DdeCreateStringHandle(idInst,szConnectTest,0);
        hszTextItem           = DdeCreateStringHandle(idInst,szChatText   ,0);

        if(!hszLocalName || !hszChatTopic || !hszServiceName || !hszTextItem || !hszChatShare)
        {
            MessageBeep(MB_ICONSTOP);
            MessageBox(NULL,szSysErr,szAppName,MB_OK | MB_ICONSTOP);
            return(FALSE);
        }

        DdeNameService(idInst,hszServiceName,(HSZ)0,DNS_REGISTER);


        if(DdeGetLastError(idInst) != DMLERR_NO_ERROR)
        {
            MessageBeep(MB_ICONSTOP);
            MessageBox (NULL,szSysErr,szAppName,MB_OK | MB_ICONSTOP);
            return(FALSE);
        }

        cf_chatdata = RegisterClipboardFormat(TEXT("Chat Data"));
        if(!(cf_chatdata))
        {
            MessageBeep(MB_ICONSTOP);
            MessageBox(NULL,szSysErr,szAppName,MB_OK | MB_ICONSTOP);
            return(FALSE);
        }


        // get winnet extension browse dialog entry point
        //
        WNetServerBrowseDialog = NULL;
        hmodNetDriver          = WNETGETCAPS(0xFFFF);

        if(hmodNetDriver != NULL)
            WNetServerBrowseDialog = (WNETCALL)GetProcAddress(hmodNetDriver,(LPSTR)146);



        // create main window
        hwnd = CreateWindow(
            szWinChatClass,
            szAppName,
            WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            NULL,
            NULL,
            hInstance,
            NULL
        );

        if(!hwnd)
        {
            MessageBeep(MB_ICONSTOP);
            MessageBox(NULL,szSysErr,szAppName,MB_OK | MB_ICONSTOP);
            return(FALSE);
        }

        hwndApp = hwnd; // save global

        // font choice struct init
        //
        chf.lStructSize    = sizeof(CHOOSEFONT);
        chf.lpLogFont      = &lfSnd;
        chf.Flags          = CF_SCREENFONTS | CF_EFFECTS | CF_INITTOLOGFONTSTRUCT;
        chf.rgbColors      = GetSysColor(COLOR_WINDOWTEXT);
        chf.lCustData      = 0L;
        chf.lpfnHook       = NULL;
        chf.lpTemplateName = NULL;
        chf.hInstance      = NULL;
        chf.lpszStyle      = NULL;
        chf.nFontType      = SCREEN_FONTTYPE;
        chf.nSizeMin       = 0;
        chf.nSizeMax       = 0;


        // color choice init
        //
        chc.lStructSize    = sizeof(CHOOSECOLOR);
        chc.hwndOwner      = hwndApp;
        chc.hInstance      = hInst;
        chc.lpCustColors   = (LPDWORD)CustColors;
        chc.Flags          = CC_RGBINIT | CC_PREVENTFULLOPEN;
        chc.lCustData      = 0;
        chc.lpfnHook       = NULL;
        chc.lpTemplateName = NULL;


        // window placement...
        //
        if(ReadWindowPlacement(&Wpl))
        {
            // override these - CODEWORK don't need to save
            // them to .ini, but will mis-parse old .ini files
            // if change is made.
            //
            Wpl.showCmd         = nCmdShow;
            Wpl.ptMaxPosition.x = -1;
            Wpl.ptMaxPosition.y = -1;
            Wpl.flags           = 0;

            SetWindowPlacement(hwnd,&Wpl);
            UpdateWindow(hwnd);
        }
        else
            ShowWindow(hwnd,nCmdShow);

        //
        //
        hMenu = GetSystemMenu(hwnd,FALSE);
        AppendMenu(hMenu,MF_SEPARATOR,0,NULL);

        if(ChatState.fTopMost)
            AppendMenu(hMenu,MF_ENABLED | MF_CHECKED | MF_STRING,IDM_TOPMOST,szAlwaysOnTop);
        else
            AppendMenu(hMenu,MF_ENABLED | MF_UNCHECKED | MF_STRING,IDM_TOPMOST,szAlwaysOnTop);


        // Set topmost style...
        //
        SetWindowPos(hwndApp,ChatState.fTopMost ? HWND_TOPMOST : HWND_NOTOPMOST,0,0,0,0,SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

        UpdateButtonStates();

#if !defined(_WIN64)

        {
            static NDDESHAREINFO nddeShareInfo = {
                1,              // revision
                szChatShare,
                SHARE_TYPE_STATIC,
                TEXT("WinChat|Chat\0\0"),
                TRUE,           // shared
                FALSE,          // not a service
                TRUE,           // can be started
                SW_SHOWNORMAL,
                {0,0},          // mod id
                0,              // no item list
                TEXT("")
            };

            TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 3] = TEXT("\\\\");
            DWORD cbName = MAX_COMPUTERNAME_LENGTH + 1;

            //
            // Make sure NetDDE DSDM has trusted shares set up properly for us.
            // This fix allows us to work with floating profiles.
            //

            START_NETDDE_SERVICES(hwnd);
            GetComputerName(&szComputerName[2],&cbName);
            NDdeShareAdd(szComputerName,2,NULL,(LPBYTE)&nddeShareInfo,sizeof(NDDESHAREINFO));
            NDdeSetTrustedShare(szComputerName, szChatShare,
                    NDDE_TRUST_SHARE_START | NDDE_TRUST_SHARE_INIT);
        }

#endif

    }

    return(bRet);
}


/*---------------------------------------------------------------------------*\
| MAIN WINDOW PROC
|   This is the main event-handler for the application.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
LRESULT CALLBACK MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT  lResult;


    lResult = 0l;
    switch(message)
    {
        case WM_CREATE:
            appWMCreateProc(hwnd);
            break;

        case WM_WININICHANGE:
            appWMWinIniChangeProc(hwnd);
            break;

        case WM_ERASEBKGND:
            if((lResult = (LRESULT)appWMEraseBkGndProc(hwnd)) == 0)
                lResult = DefWindowProc(hwnd,message,wParam,lParam);
            break;

        case WM_SETFOCUS:
            appWMSetFocusProc(hwnd);
            break;

        case WM_MENUSELECT:
            appWMMenuSelectProc(hwnd,wParam,lParam);
            break;

        case WM_TIMER:
            appWMTimerProc(hwnd);
            break;

        case WM_PAINT:
            appWMPaintProc(hwnd);
            break;

        case WM_QUERYDRAGICON:
            lResult = (LRESULT)(LPVOID)appWMQueryDragIconProc(hwnd);
            break;

        case WM_SIZE:
            appWMSizeProc(hwnd,wParam,lParam);
            break;

        case WM_INITMENU:
            appWMInitMenuProc((HMENU)wParam);
            break;

        case WM_SYSCOMMAND:
            if(!appWMSysCommandProc(hwnd,wParam,lParam))
                lResult = DefWindowProc(hwnd,message,wParam,lParam);
            break;

        case WM_COMMAND:
            if(!appWMCommandProc(hwnd,wParam,lParam))
                lResult = DefWindowProc(hwnd,message,wParam,lParam);
            break;

        case WM_NOTIFY:
            {
            LPTOOLTIPTEXT lpTTT = (LPTOOLTIPTEXT) lParam;

            if (lpTTT->hdr.code == TTN_NEEDTEXT) {
                LoadString (hInst, (UINT)(MH_BASE + lpTTT->hdr.idFrom), lpTTT->szText, 80);
                return TRUE;
            }
            }
            break;

#ifdef WIN32
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORSTATIC:
#else
        case WM_CTLCOLOR:
#endif
            if((lResult = (LRESULT)(LPVOID)appWMCtlColorProc(hwnd,wParam,lParam)) == 0l)
                lResult = DefWindowProc(hwnd,message,wParam,lParam);
            break;

        case WM_DESTROY:
            appWMDestroyProc(hwnd);
            break;

        case WM_CLOSE:
            WinHelp(hwnd,(LPTSTR)szHelpFile,HELP_QUIT,0L);

            // Fall through for final close.
            //


        default:
            lResult = DefWindowProc(hwnd,message,wParam,lParam);
            break;
    }

    return(lResult);
}


/*---------------------------------------------------------------------------*\
| EDIT-HOOK PROCEDURE
|   This is the main event-handler for the edit-control hook.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
LRESULT CALLBACK EditProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    WPARAM wSet;
    LPARAM lSet;
    GETTEXTLENGTHEX gettextlengthex;
    LRESULT lResult;
    LPTSTR lpszText;
    HANDLE hText;
    INT count;
    LPTSTR lpszStartSel;
    DWORD dwTemp1;
    DWORD dwTemp2;

    switch(msg) {
    case WM_IME_COMPOSITION:
        {
            LPWSTR  lpStrParam;
            LPSTR   lpStrTmp;
            HANDLE  hTmp;

            if (lParam & GCS_RESULTSTR)
            {
                HIMC  hImc;
                ULONG cCharsMbcs, cChars;

                //
                // Get input context of hwnd
                //

                if ((hImc = pfnImmGetContext(hwnd)) == 0)
                    break;

                //
                //ImmGetComposition returns the size of buffer needed in byte
                //

                cCharsMbcs =  pfnImmGetCompositionStringW(hImc,GCS_RESULTSTR, NULL , 0);
                if(!(cCharsMbcs))
                {
                    pfnImmReleaseContext(hwnd, hImc);
                    break;
                }

                lpStrParam = (LPWSTR)GlobalAlloc(GPTR,//HEAP_ZERO_MEMORY,
                                    cCharsMbcs + sizeof(WCHAR));

                if (lpStrParam==NULL)
                {
                    pfnImmReleaseContext(hwnd, hImc);
                    break;
                }

                pfnImmGetCompositionStringW(hImc, GCS_RESULTSTR, lpStrParam,
                                    cCharsMbcs);

                //
                // Compute character count including NULL char.
                //

                cChars = wcslen(lpStrParam) + 1;

                //
                // Set ChatData packet
                //

                ChatData.type                = CHT_DBCS_STRING;

                //
                // Get current cursor position
                //
                // !!! BUG BUG BUG !!!
                //
                //  This position data is only nice for Unicode Edit control.
                // is the partner has not Unicode Edit control. the string
                // will be truncated.
                //

                SendMessage(hwndSnd,EM_GETSEL,(WPARAM)&dwTemp1,(LPARAM)&dwTemp2);
                ChatData.uval.cd_dbcs.SelPos = MAKELONG((WORD)dwTemp1, (WORD)dwTemp2 );

                if (gfDbcsEnabled) {
                    //
                    // since text is passed as multi byte character string,
                    // position fixup is needed if DBCS is enabled
                    //
                    DWORD dwStart, dwEnd;

                    TranslateWideCharPosToMultiBytePos( hwndSnd,
                        (DWORD)LOWORD(ChatData.uval.cd_dbcs.SelPos),
                        (DWORD)HIWORD(ChatData.uval.cd_dbcs.SelPos),
                        &dwStart, &dwEnd );
                    ChatData.uval.cd_dbcs.SelPos
                        = MAKELONG((WORD)dwStart, (WORD)dwEnd );
               }

               //
               // Allocate string buffer for DDE.
               //

               if((hTmp = GlobalAlloc( GMEM_ZEROINIT |
                                       GMEM_MOVEABLE |
                                       GMEM_DDESHARE   ,
                                       (DWORD)cCharsMbcs)) == NULL)
               {
                    pfnImmReleaseContext(hwnd, hImc);
                    GlobalFree(lpStrParam);
                    break;
               }

               lpStrTmp                     = GlobalLock(hTmp);

               //
               // Store MBCS string into DDE buffer.
               //
               // In CHT_DBCS_STRING context, we should send mbcs string
               // for downlevel connectivity.
               //

               WideCharToMultiByte(CP_ACP,0,lpStrParam,cChars/* + 1*/,
                                            lpStrTmp  ,cCharsMbcs/* + 1*/,
                                            NULL,NULL);

               //
               // Keep the buffer handle in to DDE message packet.
               //

               GlobalUnlock(hTmp);
               ChatData.uval.cd_dbcs.hString = hTmp;

               //
               // Now, we have a packet to send server/client, just send it.
               //

               wSet = SET_EN_NOTIFY_WPARAM(ID_EDITSND,EN_DBCS_STRING,hwnd);
               lSet = SET_EN_NOTIFY_LPARAM(ID_EDITSND,EN_DBCS_STRING,hwnd);
               SendMessage(hwndApp,WM_COMMAND,wSet,lSet);

               //
               // if we have still a connection to server/client. repaint text.
               //

               if(ChatState.fConnected)
                   SendMessage(hwndSnd,EM_REPLACESEL,0,(LPARAM)lpStrParam);

               pfnImmReleaseContext(hwnd, hImc);
               GlobalFree(lpStrParam);

               return(TRUE);
            }
            break;
        }

    case WM_KEYDOWN:
        if (wParam == VK_DELETE) {
            DWORD dwLastError;
            ChatData.type                = CHT_CHAR;

            SendMessage(hwndSnd,EM_GETSEL,(WPARAM)&dwTemp1,(LPARAM)&dwTemp2);
            ChatData.uval.cd_dbcs.SelPos = MAKELONG((WORD)dwTemp1, (WORD)dwTemp2 );

            lResult=SendMessage(hwndSnd,WM_GETTEXTLENGTH,0,0);
            // if we are trying to delete at the end of the line then ignore it
            if(lResult<=LOWORD(ChatData.uval.cd_char.SelPos)) break;

            if (LOWORD(ChatData.uval.cd_char.SelPos) == HIWORD(ChatData.uval.cd_char.SelPos)) {

                // get handle to the text
                hText = (HANDLE)SendMessage( hwndSnd, EM_GETHANDLE, 0, 0);
                if( !(hText) )
                    break;

                lpszText = LocalLock( hText);
                if( !(lpszText))
                {
                    LocalUnlock(hText);
                    break;
                }
                lpszStartSel=lpszText;
                for(count=0;count<LOWORD(ChatData.uval.cd_char.SelPos);count++)
                {
                    lpszStartSel=CharNext(lpszStartSel);
                    if(lpszStartSel[0] == TEXT('\0')) break;  // if at the end then break since something is mesed
                }

                if(lpszStartSel[0] != TEXT('\0') && lpszStartSel[0] == TEXT('\r'))
                {
                    if(lpszStartSel[1] != TEXT('\0') && lpszStartSel[1] == TEXT('\n'))
                    {
                        ChatData.uval.cd_char.SelPos=MAKELONG(LOWORD(ChatData.uval.cd_char.SelPos),
                                                              HIWORD(ChatData.uval.cd_char.SelPos)+2);
                    }
                    else
                    {
                        ChatData.uval.cd_char.SelPos=MAKELONG(LOWORD(ChatData.uval.cd_char.SelPos)+1,
                                                              HIWORD(ChatData.uval.cd_char.SelPos)+1);
                    }
                }
                else
                {
                    ChatData.uval.cd_char.SelPos=MAKELONG(LOWORD(ChatData.uval.cd_char.SelPos)+1,
                                                          HIWORD(ChatData.uval.cd_char.SelPos)+1);
                }


                LocalUnlock( hText );
            }


            if (gfDbcsEnabled) {
                DWORD dwStart, dwEnd;

                TranslateWideCharPosToMultiBytePos( hwndSnd,
                    (DWORD)LOWORD(ChatData.uval.cd_dbcs.SelPos),
                    (DWORD)HIWORD(ChatData.uval.cd_dbcs.SelPos),
                     &dwStart, &dwEnd );
                ChatData.uval.cd_dbcs.SelPos
                    = MAKELONG((WORD)dwStart, (WORD)dwEnd);
            }

            ChatData.uval.cd_char.Char   = VK_BACK;

            wSet = SET_EN_NOTIFY_WPARAM(ID_EDITSND,EN_CHAR,hwnd);
            lSet = SET_EN_NOTIFY_LPARAM(ID_EDITSND,EN_CHAR,hwnd);

            SendMessage(hwndApp,WM_COMMAND,(WPARAM)wSet,(LPARAM)lSet);
        }
        break;
    case WM_CHAR:
        if(wParam != CTRL_V)
        {
            ChatData.type                = CHT_CHAR;
            SendMessage(hwndSnd,EM_GETSEL,(WPARAM)&dwTemp1,(LPARAM)&dwTemp2);
            ChatData.uval.cd_dbcs.SelPos = MAKELONG((WORD)dwTemp1, (WORD)dwTemp2 );

            if (gfDbcsEnabled) {
                DWORD dwStart, dwEnd;

                TranslateWideCharPosToMultiBytePos( hwndSnd,
                    (DWORD)LOWORD(ChatData.uval.cd_dbcs.SelPos),
                    (DWORD)HIWORD(ChatData.uval.cd_dbcs.SelPos),
                     &dwStart, &dwEnd );
                ChatData.uval.cd_dbcs.SelPos
                    = MAKELONG((WORD)dwStart, (WORD)dwEnd);
            }

            ChatData.uval.cd_char.Char   = (WORD)wParam;

            wSet = SET_EN_NOTIFY_WPARAM(ID_EDITSND,EN_CHAR,hwnd);
            lSet = SET_EN_NOTIFY_LPARAM(ID_EDITSND,EN_CHAR,hwnd);

            SendMessage(hwndApp,WM_COMMAND,wSet,lSet);
        }
        break;


    case WM_PASTE:
        ChatData.type                 = (WORD)(ChatState.fUnicode ? CHT_PASTEW : CHT_PASTEA);
        SendMessage(hwndSnd,EM_GETSEL,(WPARAM)&dwTemp1,(LPARAM)&dwTemp2);
        ChatData.uval.cd_paste.SelPos = MAKELONG(dwTemp1,dwTemp2);
        wSet = SET_EN_NOTIFY_WPARAM(ID_EDITSND,EN_PASTE,hwnd);
        lSet = SET_EN_NOTIFY_LPARAM(ID_EDITSND,EN_PASTE,hwnd);

        SendMessage(hwndApp,WM_COMMAND,wSet,lSet);
        break;
    }

    return(CallWindowProc(lpfnOldEditProc,hwnd,msg,wParam,lParam));
}


/*---------------------------------------------------------------------------*\
| APPLICATION CREATE PROCEDURE
|   This is the main event-handler for the WM_CREATE event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID appWMCreateProc(HWND hwnd)
{
    HDC   hdc;
    TCHAR buf[16] = {0};
    RECT  rc;


    // read from ini
    //
    StringCchPrintf(buf, ARRAYSIZE(buf), TEXT("%ld"),GetSysColor(COLOR_WINDOW));
    GetPrivateProfileString(szPref,szBkgnd,buf,szBuf,SZBUFSIZ,szIni);
    SndBrushColor = myatol(szBuf);


    // just in case display driver changed, set the send-color.
    //
    hdc = GetDC (hwnd);
    if(hdc)
    {
        SndBrushColor = GetNearestColor(hdc,SndBrushColor);
        ReleaseDC(hwnd,hdc);
    }

    if(ChatState.fUseOwnFont)
    {
        RcvBrushColor = SndBrushColor;
        RcvColorref   = SndColorref;
    }
    else
        RcvBrushColor = GetSysColor ( COLOR_WINDOW );

    ChatState.fConnected          = FALSE;
    ChatState.fConnectPending     = FALSE;
    ChatState.fIsServer           = FALSE;
    ChatState.fServerVerified     = TRUE;
    ChatState.fInProcessOfDialing = FALSE;
    ChatState.fUnicode            = FALSE;

    CreateTools(hwnd);
    CreateChildWindows(hwnd);

    UpdateButtonStates();

    // determine height of toolbar window and save...
    //
    GetClientRect(hwndToolbar, &rc);
    dyButtonBar = rc.bottom - rc.top;

    // determine height of statusbar window and save...
    GetClientRect(hwndStatus, &rc);
    dyStatus = rc.bottom - rc.top;


    // stuff our local font into one or both edit controls
    //
    hEditSndFont = CreateFontIndirect((LPLOGFONT)&lfSnd);
    if(hEditSndFont)
    {
        SendMessage(hwndSnd,WM_SETFONT,(WPARAM)hEditSndFont,1L);
        if(ChatState.fUseOwnFont)
            SendMessage(hwndRcv,WM_SETFONT,(WPARAM)hEditSndFont,1L);
    }


    hwndActiveEdit = hwndSnd;

    return;
}


/*---------------------------------------------------------------------------*\
| APPLICATION WININICHANGE PROCEDURE
|   This is the main event-handler for the WM_WININICHANGE event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID appWMWinIniChangeProc(HWND hwnd)
{

    if(hEditSndFont)
    {
        DeleteObject(hEditSndFont);
        hEditSndFont = CreateFontIndirect((LPLOGFONT)&lfSnd);
        if(hEditSndFont)
            SendMessage(hwndSnd,WM_SETFONT,(WPARAM)hEditSndFont,1L);
    }


    if(hEditRcvFont)
    {
        DeleteObject(hEditRcvFont);
        hEditRcvFont = CreateFontIndirect((LPLOGFONT)&lfRcv);
    }


    if(ChatState.fUseOwnFont && hEditSndFont)
        SendMessage(hwndRcv,WM_SETFONT,(WPARAM)hEditSndFont,1L);
    else
    {
        if(hEditRcvFont)
            SendMessage(hwndRcv,WM_SETFONT,(WPARAM)hEditRcvFont,1L);
    }


    return;
}


/*---------------------------------------------------------------------------*\
| APPLICATION ERASEBKGND PROCEDURE
|   This is the main event-handler for the WM_ERASEBKBND event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
BOOL appWMEraseBkGndProc(HWND hwnd)
{
    BOOL bErase;


    bErase = IsIconic(hwnd) ? TRUE : FALSE;

    return(bErase);
}


/*---------------------------------------------------------------------------*\
| APPLICATION SETFOCUS PROCEDURE
|   This is the main event-handler for the WM_SETFOCUS event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID appWMSetFocusProc(HWND hwnd)
{
    SetFocus(hwndActiveEdit);

    return;
}


/*---------------------------------------------------------------------------*\
| APPLICATION CTLCOLOR PROCEDURE
|   This is the main event-handler for the WM_CTLCOLOR event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
HBRUSH appWMCtlColorProc(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    HDC    hDC;
    HWND   hWndCtl;
    HBRUSH hBrush;


    hBrush  = NULL;
    hDC     = GET_WM_CTLCOLOREDIT_HDC(wParam,lParam);
    hWndCtl = GET_WM_CTLCOLOREDIT_HWND(wParam,lParam);


    if(hWndCtl == hwndSnd)
    {
        SetTextColor(hDC,SndColorref);
        SetBkColor(hDC,SndBrushColor);

        hBrush = hEditSndBrush;
    }
    else
    if(hWndCtl == hwndRcv)
    {
        if(ChatState.fUseOwnFont)
        {
            SetTextColor(hDC,SndColorref);
            SetBkColor(hDC,SndBrushColor);
        }
        else
        {
            SetTextColor(hDC,RcvColorref);
            SetBkColor(hDC,RcvBrushColor);
        }

        hBrush = hEditRcvBrush;
    }

    return(hBrush);
}


/*---------------------------------------------------------------------------*\
| APPLICATION SELECTMENU PROCEDURE
|   This is the main event-handler for the WM_MENUSELECT event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID appWMMenuSelectProc(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    if(wParam == IDM_TOPMOST)
    {
        if(LoadString(hInst,MH_BASE+IDM_TOPMOST,szBuf,SZBUFSIZ))
            SendMessage(hwndStatus,SB_SETTEXT,SBT_NOBORDERS|255,(LPARAM)(LPSTR)szBuf);
    }

    MenuHelp((WORD)WM_MENUSELECT,wParam,lParam,GetMenu(hwnd),hInst,hwndStatus,(LPUINT)nIDs);

    return;
}


/*---------------------------------------------------------------------------*\
| APPLICATION PAINT PROCEDURE
|   This is the main event-handler for the WM_PAINT event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID appWMPaintProc(HWND hwnd)
{
    HDC         hdc;
        PAINTSTRUCT ps;
    RECT        rc;

    hdc = BeginPaint(hwnd,&ps);
    if(hdc)
    {
        if(IsIconic(hwnd))
        {
            //
            //
            DefWindowProc(hwnd,WM_ICONERASEBKGND,(WPARAM)ps.hdc,0L);
            BitBlt(hMemDC,0,0,cxIcon,cyIcon,hdc,0,0,SRCCOPY);
            DrawIcon(hdc,0,0,hPhones[0]);


            // make 2 more copies.
            //
            BitBlt(hMemDC,cxIcon  ,0,cxIcon,cyIcon,hMemDC,0,0,SRCCOPY);
            BitBlt(hMemDC,2*cxIcon,0,cxIcon,cyIcon,hMemDC,0,0,SRCCOPY);

            // draw phones into them.
            //
            DrawIcon(hMemDC,0       ,0,hPhones[0]);
            DrawIcon(hMemDC,cxIcon  ,0,hPhones[1]);
            DrawIcon(hMemDC,2*cxIcon,0,hPhones[2]);
        }
        else
        {

#if BRD > 2
            rc = SndRc;
            rc.top--;
            rc.left--;
            DrawShadowRect(hdc,&rc);
            rc = RcvRc;
            rc.top--;
            rc.left--;
            DrawShadowRect(hdc,&rc);
#endif
        }

        EndPaint ( hwnd, &ps );
    }

    return;
}


/*---------------------------------------------------------------------------*\
| APPLICATION TIMER PROCEDURE
|   This is the main event-handler for the WM_TIMER event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID appWMTimerProc(HWND hwnd)
{
    HDC   hdc;
    DWORD dummy;


    // Animate the phone icon.
    //
    if(cAnimate)
    {
        if(--cAnimate == 0)
        {
            KillTimer(hwnd,idTimer);
            FlashWindow(hwnd,FALSE);
                }

        if(IsIconic(hwnd))
        {
            hdc = GetDC(hwndApp);
            if(hdc)
            {
                BitBlt(hdc,0,0,cxIcon,cyIcon,hMemDC,ASeq[cAnimate % 4] * cxIcon,0,SRCCOPY);
                ReleaseDC(hwndApp,hdc);
            }
        }

                return;
        }



    // We must be ringing...
    //
    if(!ChatState.fConnectPending)
    {
        KillTimer(hwnd,idTimer);
                return;
        }


    // has the existence of the server been verified (by completion
    // of the async advstart xact)?
    //
    if(!ChatState.fServerVerified)
    {
                return;
        }


    // don't want to lose this...
    //
    DdeKeepStringHandle(idInst,hszLocalName);

    if(DdeClientTransaction(NULL,0L,ghConv,hszLocalName,cf_chatdata,XTYP_ADVSTART,(DWORD)3000L,(LPDWORD)&dummy) == (HDDEDATA)TRUE)
    {
        ChatState.fConnected      = TRUE;
        ChatState.fConnectPending = FALSE;
        UpdateButtonStates();

        KILLSOUND;

        SendFontToPartner();

        StringCchPrintf(szBuf, SZBUFSIZ, szConnectedTo,(LPSTR)szConvPartner);
        SetStatusWindowText(szBuf);

        StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%s - [%s]"),(LPTSTR)szAppName,(LPTSTR)szConvPartner);
        SetWindowText(hwnd,szBuf);


        // allow text entry...
        //
        SendMessage(hwndSnd,EM_SETREADONLY,(WPARAM)FALSE,0L);

        KillTimer(hwnd,idTimer);

        AnnounceSupport();
    }
    else
    {
        // The other party has not answered yet... ring every 6 seconds.
        // Ring local,
        //
        if(!(nConnectAttempt++ % 6))
            DoRing(szWcRingOut);
    }

    return;
}


/*---------------------------------------------------------------------------*\
| APPLICATION QUERYDRAGICON PROCEDURE
|   This is the main event-handler for the WM_QUERYDRAGICON event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
HICON appWMQueryDragIconProc(HWND hwnd)
{
    HICON hIcon;


    hIcon = hPhones[0];

    return(hIcon);
}


/*---------------------------------------------------------------------------*\
| APPLICATION SIZE PROCEDURE
|   This is the main event-handler for the WM_SIZE event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID appWMSizeProc(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    if(ChatState.fMinimized && ChatState.fConnectPending && ChatState.fIsServer)
    {
        ChatState.fAllowAnswer = TRUE;
        SetStatusWindowText(szConnecting);


        // stop the ringing immediately.
        //
        KILLSOUND;
        if(ChatState.fMMSound)
            sndPlaySound(NULL,SND_ASYNC);

        // cut the animation short.
        //
        if(cAnimate)
            cAnimate = 1;
    }


    //
    //
    InvalidateRect(hwnd,NULL,TRUE);
    SendMessage(hwndToolbar,WM_SIZE,0,0L);
    SendMessage(hwndStatus ,WM_SIZE,0,0L);
    AdjustEditWindows();

    ChatState.fMinimized = (wParam == SIZE_MINIMIZED) ? TRUE : FALSE;

    return;
}


/*---------------------------------------------------------------------------*\
| APPLICATION INITMENU PROCEDURE
|   This is the main event-handler for the WM_INITMENU event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID appWMInitMenuProc(HMENU hmenu)
{
    UINT status;
    LONG l;
    TCHAR szTest[] = TEXT(" ");
    DWORD dwTemp1,dwTemp2;

    SendMessage(hwndActiveEdit,EM_GETSEL,(LPARAM)&dwTemp1,(WPARAM)&dwTemp2);
    l = MAKELONG(dwTemp1,dwTemp2);

    if(HIWORD(l) != LOWORD(l))
                status = MF_ENABLED;
        else
                status = MF_GRAYED;

    EnableMenuItem(hmenu,IDM_EDITCUT ,(hwndActiveEdit == hwndSnd && ChatState.fConnected) ? status : MF_GRAYED);
    EnableMenuItem(hmenu,IDM_EDITCOPY,status);

    status = MF_GRAYED;
    if(hwndActiveEdit == hwndSnd && ChatState.fConnected && IsClipboardFormatAvailable(CF_TEXT))
    {
        status = MF_ENABLED;
        }
    EnableMenuItem(hmenu,IDM_EDITPASTE,status);


    // select all enabled if control non-empty.
    //
    status = MF_GRAYED;
    if(SendMessage(hwndActiveEdit,WM_GETTEXT,2,(LPARAM)szTest))
                status = MF_ENABLED;
    EnableMenuItem(hmenu,IDM_EDITSELECT,status);


    // can we dial, answer and hangup.
    //
    EnableMenuItem(hmenu,IDM_DIAL  ,(!ChatState.fConnected     && !ChatState.fConnectPending) ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hmenu,IDM_ANSWER,(ChatState.fConnectPending && ChatState.fIsServer)        ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hmenu,IDM_HANGUP,(ChatState.fConnected      || ChatState.fConnectPending)  ? MF_ENABLED : MF_GRAYED);


    // Is toolbar, statusbar and sound allowed?
    //
    CheckMenuItem(hmenu,IDM_SOUND    ,(ChatState.fSound)     ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hmenu,IDM_TOOLBAR  ,(ChatState.fToolBar)   ? MF_CHECKED : MF_UNCHECKED);
    CheckMenuItem(hmenu,IDM_STATUSBAR,(ChatState.fStatusBar) ? MF_CHECKED : MF_UNCHECKED);

    return;
}


/*---------------------------------------------------------------------------*\
| APPLICATION SYSCOMMAND PROCEDURE
|   This is the main event-handler for the WM_SYSCOMMAND event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
LRESULT appWMSysCommandProc(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;
    HMENU   hmenu;


    lResult = 0l;
    switch(wParam)
    {
        case IDM_TOPMOST:
            ChatState.fTopMost = ChatState.fTopMost ? FALSE : TRUE;

            hmenu = GetSystemMenu(hwnd,FALSE);
            if(hmenu)
                CheckMenuItem(hmenu,IDM_TOPMOST,(ChatState.fTopMost) ? MF_CHECKED : MF_UNCHECKED);

            SetWindowPos(hwnd,ChatState.fTopMost ? HWND_TOPMOST : HWND_NOTOPMOST,0,0,0,0,SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
            break;
    }

    return(lResult);
}


/*---------------------------------------------------------------------------*\
| APPLICATION COMMAND PROCEDURE
|   This is the main event-handler for the WM_COMMAND event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
BOOL appWMCommandProc(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    HDC      hdc;
    int      tmp;
    UINT     uNotify;
    DWORD    dummy;
    DWORD    dwBufSize;
    HDDEDATA hDdeData;
    BOOL     bHandled,bOK,bOKPressed=FALSE;
    WPARAM   wSelStart;
    LPARAM   lSelEnd;


    bHandled = TRUE;
    switch(LOWORD(wParam))
    {
                case ID_EDITRCV:
            uNotify = GET_EN_SETFOCUS_NOTIFY(wParam,lParam);
            switch(uNotify)
            {
                case EN_SETFOCUS:
                    hwndActiveEdit = hwndRcv;
                    break;


                // If the control is out of space, honk.
                //
                case EN_ERRSPACE:
                    MessageBeep(0);
                    break;
                        }
            break;


                case ID_EDITSND:
            uNotify = GET_EN_SETFOCUS_NOTIFY(wParam,lParam);
            switch(uNotify)
            {
                // This string came from the edit-hook
                // procedure.
                //
                case EN_DBCS_STRING:
                    if(ChatState.fConnected)
                    {
                        if(!ChatState.fIsServer)
                        {
                            hDdeData = CreateDbcsStringData();
                            if(hDdeData)
                                DdeClientTransaction((LPBYTE)hDdeData,(DWORD)-1,ghConv,hszTextItem,cf_chatdata,XTYP_POKE,(DWORD)TIMEOUT_ASYNC,(LPDWORD)&dummy);
                        }
                        else
                        {
                            hszConvPartner = DdeCreateStringHandle(idInst,szConvPartner,0);
                            DdePostAdvise(idInst,hszChatTopic,hszConvPartner);
                        }
                    }
                    break;


                // This character came from the edit-hook
                // procedure.
                //
                case EN_CHAR:
                    if(ChatState.fConnected)
                    {
                        if(!ChatState.fIsServer)
                        {
                            hDdeData = CreateCharData();
                            if(hDdeData)
                                DdeClientTransaction((LPBYTE)hDdeData,(DWORD)-1,ghConv,hszTextItem,cf_chatdata,XTYP_POKE,(DWORD)TIMEOUT_ASYNC,(LPDWORD)&dummy);
                        }
                        else
                        {
                            hszConvPartner = DdeCreateStringHandle(idInst,szConvPartner,0);
                            DdePostAdvise(idInst,hszChatTopic,hszConvPartner);
                        }
                    }
                    break;

                case EN_PASTE:
                    if(ChatState.fConnected)
                    {
                        if(!ChatState.fIsServer)
                        {
                            if(IsClipboardFormatAvailable(CF_UNICODETEXT))
                            {
                                hDdeData = CreatePasteData();
                                if(hDdeData)
                                    DdeClientTransaction((LPBYTE)hDdeData,(DWORD)-1,ghConv,hszTextItem,cf_chatdata,XTYP_POKE,(DWORD)TIMEOUT_ASYNC,(LPDWORD)&StrXactID);
                            }
                        }
                        else
                        {
                             hszConvPartner = DdeCreateStringHandle(idInst,szConvPartner,0);
                             DdePostAdvise(idInst,hszChatTopic,hszConvPartner);
                        }
                    }
                    break;

                case EN_SETFOCUS:
                    hwndActiveEdit = hwndSnd;
                    break;

                case EN_ERRSPACE:
                    // If the control is out of space, honk.
                    //
                    MessageBeep(0);
                    break;
                    }
                    break;


        case IDC_TOOLBAR:
            MenuHelp(WM_COMMAND,wParam,lParam,GetMenu(hwnd),hInst,hwndStatus,(LPUINT)nIDs);
            break;


        case IDM_EXIT:
            SendMessage(hwnd,WM_CLOSE,0,0L);
            break;


        case IDM_TOOLBAR:
            if(ChatState.fToolBar)
            {
                ChatState.fToolBar = FALSE;
                ShowWindow(hwndToolbar,SW_HIDE);
                InvalidateRect(hwnd,NULL,TRUE);
                AdjustEditWindows();
            }
            else
            {
                ChatState.fToolBar = TRUE;
                InvalidateRect(hwnd,NULL,TRUE);
                AdjustEditWindows();
                ShowWindow(hwndToolbar,SW_SHOW);
            }
            break;


        case IDM_STATUSBAR:
            if(ChatState.fStatusBar)
            {
                ChatState.fStatusBar = FALSE;
                ShowWindow(hwndStatus,SW_HIDE);
                InvalidateRect(hwnd,NULL,TRUE);
                AdjustEditWindows();
            }
            else
            {
                ChatState.fStatusBar = TRUE;
                InvalidateRect(hwnd,NULL,TRUE);
                AdjustEditWindows();
                ShowWindow(hwndStatus,SW_SHOW);
            }
            break;


        case IDM_SWITCHWIN:
            if(hwndActiveEdit == hwndSnd)
                SetFocus(hwndActiveEdit = hwndRcv);
            else
                SetFocus(hwndActiveEdit = hwndSnd);
            break;


        case IDM_SOUND:
            ChatState.fSound = ChatState.fSound ? FALSE : TRUE;
            break;


        case IDM_COLOR:
            SetFocus(hwndActiveEdit);
            chc.rgbResult = SndBrushColor;

            tmp = ChooseColor((LPCHOOSECOLOR)&chc);
            if(tmp)
            {
                hdc = GetDC(hwnd);
                if(hdc)
                {
                    // must map to solid color (edit-control limitation).
                    //
                    SndBrushColor = GetNearestColor(hdc,chc.rgbResult);
                    ReleaseDC(hwnd,hdc);
                }

                DeleteObject(hEditSndBrush);
                hEditSndBrush = CreateSolidBrush(SndBrushColor);
                InvalidateRect(hwndSnd,NULL,TRUE);

                SaveBkGndToIni();

                if(ChatState.fUseOwnFont)
                {
                    RcvBrushColor = SndBrushColor;
                    DeleteObject(hEditRcvBrush);
                    hEditRcvBrush = CreateSolidBrush(RcvBrushColor);
                    InvalidateRect(hwndRcv, NULL, TRUE);
                }

                if(ChatState.fConnected)
                    SendFontToPartner();
            }
            break;


        case IDM_FONT:
            SetFocus(hwndActiveEdit);
            chf.hwndOwner = hwndSnd;
            chf.rgbColors = SndColorref;

            tmp = ChooseFont((LPCHOOSEFONT)&chf);
            if(tmp)
            {
                if(hEditSndFont)
                    DeleteObject(hEditSndFont);

                hEditSndFont = CreateFontIndirect((LPLOGFONT)&lfSnd);
                if(hEditSndFont)
                {
                    SndColorref = chf.rgbColors;
                    SaveFontToIni();

                    SendMessage(hwndSnd,WM_SETFONT,(WPARAM)hEditSndFont,1L);
                    if(ChatState.fUseOwnFont)
                    {
                        SendMessage(hwndRcv,WM_SETFONT,(WPARAM)hEditSndFont,1L);
                        RcvColorref = SndColorref;
                    }


                    // notify partner of the change
                    //
                    if(ChatState.fConnected)
                        SendFontToPartner();
                }
            }
            break;


        case IDM_DIAL:
            if(ChatState.fConnected)
            {
                SetStatusWindowText(szAlreadyConnect);
                break;
            }

            if(ChatState.fConnectPending)
            {
                SetStatusWindowText ( szAbandonFirst);
                break;
            }

            dwBufSize = SZBUFSIZ;

            WNETGETUSER((LPTSTR)NULL,(LPTSTR)szBuf,&dwBufSize);

            if(GetLastError() == ERROR_NO_NETWORK)
            {
                if(MessageBox(hwnd,szNoNet,TEXT("Chat"),MB_YESNO | MB_ICONQUESTION) == IDNO)
                    break;
            }


            ChatState.fInProcessOfDialing = TRUE;
            if(WNetServerBrowseDialog == NULL || (*WNetServerBrowseDialog)(hwnd,TEXT("MRU_Chat"),szBuf,SZBUFSIZ,0L) == WN_NOT_SUPPORTED)
            {
#if WIN32
                bOKPressed = FALSE;
                *szBuf     = TEXT('\0');


                StringCchCopy(szHelp, SZBUFSIZ, TEXT("winchat.hlp"));
                I_SystemFocusDialog(hwnd,MY_LOGONTYPE,(LPWSTR)szBuf,SZBUFSIZ,&bOKPressed,(LPWSTR)szHelp,IDH_SELECTCOMPUTER);

                if(bOKPressed)
                {
                    bOK    = TRUE;
                    StringCchCopy(szConvPartner, UNCNLEN, szBuf);
                }
#else
                dlgDisplayBox(hInst,hwnd,(LPSTR)MAKEINTRESOURCE(IDD_CONNECT),dlgConnectProc,0l);
#endif
            }

            SetFocus(hwndActiveEdit);

            if(*szBuf && bOKPressed)
            {
                CharUpper(szBuf);

                if((lstrlen(szBuf) > 2)  && (szBuf[0] == TEXT('\\')) && (szBuf[1] == TEXT('\\')))
                    StringCchCopy(szConvPartner, UNCNLEN, szBuf+2);
                else
                    StringCchCopy(szConvPartner, UNCNLEN, szBuf);

                ClearEditControls();

                StringCchPrintf(szBuf, SZBUFSIZ,szDialing,(LPSTR)szConvPartner);
                SetStatusWindowText(szBuf);

#if TESTLOCAL
                StringCchPrintf(szBuf, SZBUFSIZ,TEXT("%s"),(LPTSTR)szServiceName);
                hszConnect = DdeCreateStringHandle(idInst,szBuf,0);
                ghConv     = DdeConnect(idInst,hszConnect,hszChatTopic,NULL);
#else
                StringCchPrintf(szBuf, SZBUFSIZ,TEXT("\\\\%s\\NDDE$"),(LPTSTR)szConvPartner);
                hszConnect = DdeCreateStringHandle(idInst,szBuf,0);
                ghConv     = DdeConnect(idInst,hszConnect,hszChatShare,NULL);
#endif

                if(ghConv == (HCONV)0)
                {
                    SetStatusWindowText(szNoConnect);
                    DdeFreeStringHandle(idInst,hszConnect);
                    ChatState.fInProcessOfDialing = FALSE;
                    break;
                }

                ChatState.fConnectPending = TRUE;
                UpdateButtonStates();

                // set up server verify async xaction.
                //
                ChatState.fServerVerified = FALSE;
                DdeKeepStringHandle(idInst,hszConnectTest);
                DdeClientTransaction(NULL,0L,ghConv,hszConnectTest,cf_chatdata,XTYP_ADVSTART,(DWORD)TIMEOUT_ASYNC,(LPDWORD)&XactID);


                // Indicate that this is a Unicode conversation.
                //
                ChatData.type = CHT_UNICODE;
                hDdeData = CreateCharData ();
                if(hDdeData)
                   DdeClientTransaction((LPBYTE)hDdeData,(DWORD)-1,ghConv,hszTextItem,cf_chatdata,XTYP_POKE,(DWORD)TIMEOUT_ASYNC,(LPDWORD)&dummy);


                // set ring timer...
                // connect attempts every second - will be divided by
                // 6 for actual phone rings. This is done to speed the
                // connection process
                // want first message immediately...
                //
                idTimer = SetTimer(hwnd,1,1000,NULL);
                PostMessage(hwnd,WM_TIMER,1,0L);
                nConnectAttempt = 0;
            }

            ChatState.fInProcessOfDialing = FALSE;
            DdeFreeStringHandle(idInst,hszConnect);
            break;


        case IDM_ANSWER:
            if(ChatState.fConnectPending)
            {
                if(!ChatState.fIsServer)
                {
                    SetStatusWindowText(szYouCaller);
                    break;
                }
                else
                {
                    // allow the connection.
                    //
                    ChatState.fAllowAnswer = TRUE;
                    SetStatusWindowText(szConnecting);


                    // stop the ringing immediately.
                    //
                    if(ChatState.fMMSound)
                        sndPlaySound(NULL,SND_ASYNC);


                    // cut the animation short.
                    //
                    if(cAnimate)
                        cAnimate = 1;
                }
            }
            break;


                case IDM_HANGUP:
            if(!ChatState.fConnected && !ChatState.fConnectPending)
            {
                                break;
                        }


            if(ChatState.fConnectPending && !ChatState.fConnected)
            {
                SetStatusWindowText(szConnectAbandon);
            }
            else
            {
                SetStatusWindowText(szHangingUp);
            }


                        KILLSOUND;

            DdeDisconnect(ghConv);

                        ChatState.fConnectPending = FALSE;
            ChatState.fConnected      = FALSE;
            ChatState.fIsServer       = FALSE;
            ChatState.fUnicode        = FALSE;

#ifdef PROTOCOL_NEGOTIATE
            ChatState.fProtocolSent   = FALSE;
#endif

            // suspend text entry.
            //
            UpdateButtonStates();
            SendMessage(hwndSnd,EM_SETREADONLY,TRUE,0L);
            SetWindowText(hwndApp,szAppName);
            break;


       case IDX_UNICODECONV:
            ChatData.type  = CHT_UNICODE;
            hszConvPartner = DdeCreateStringHandle(idInst,szConvPartner,0);
            DdePostAdvise(idInst,hszChatTopic,hszConvPartner);
            break;


                case IDX_DEFERFONTCHANGE:
                        SendFontToPartner();
            break;

#ifdef PROTOCOL_NEGOTIATE
        case IDX_DEFERPROTOCOL:
            AnnounceSupport();
            break;
#endif

        case IDM_CONTENTS:
            HtmlHelpA(GetDesktopWindow(),"winchat.chm",HH_DISPLAY_TOPIC,0L);
            break;


        case IDM_ABOUT:
            ShellAbout(hwndSnd,szAppName,szNull,hPhones[0]);
                        SetFocus(hwndActiveEdit);
            break;


        case IDM_PREFERENCES:
            DialogBoxParam(hInst,(LPTSTR)MAKEINTRESOURCE(IDD_PREFERENCES),hwnd,dlgPreferencesProc,(LPARAM)0);
            break;


        case IDM_EDITCOPY:
            SendMessage(hwndActiveEdit,WM_COPY,0,0L);
            break;


        case IDM_EDITPASTE:
            SendMessage(hwndActiveEdit,WM_PASTE,0,0L);
            break;


        case IDM_EDITCUT:
            SendMessage(hwndActiveEdit,WM_CUT,0,0L);
            break;


        case IDM_EDITSELECT:
            wSelStart = SET_EM_SETSEL_WPARAM(0,-1);
            lSelEnd   = SET_EM_SETSEL_LPARAM(0,-1);
            SendMessage(hwndActiveEdit,EM_SETSEL,wSelStart,lSelEnd);
            break;


        case IDM_EDITUNDO:
            SendMessage(hwndActiveEdit,EM_UNDO,0,0L);
            break;


        default:
            bHandled = FALSE;
            break;
    }

    return(bHandled);
}


/*---------------------------------------------------------------------------*\
| APPLICATION DESTROY PROCEDURE
|   This is the main event-handler for the WM_DESTROY event.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID appWMDestroyProc(HWND hwnd)
{

    // Abandon transaction if in progress.  Force hangup
    // of conversation.
    //
    if(!ChatState.fServerVerified)
        DdeAbandonTransaction(idInst,ghConv,XactID);
    SendMessage(hwnd,WM_COMMAND,IDM_HANGUP,0L);


    // Destroy resources allocated on behalf of app.
    //
    KILLSOUND;
    DeleteTools(hwnd);


    // Save the state information.
    //
    Wpl.length = sizeof(Wpl);
    if(GetWindowPlacement(hwnd,&Wpl))
        SaveWindowPlacement(&Wpl);

    StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%d"), (UINT)ChatState.fSound);
    WritePrivateProfileString(szPref, szSnd, szBuf, szIni);

    StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%d"), (UINT)ChatState.fToolBar);
    WritePrivateProfileString(szPref, szTool, szBuf, szIni);

    StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%d"), (UINT)ChatState.fStatusBar);
    WritePrivateProfileString(szPref, szStat, szBuf, szIni);

    StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%d"), (UINT)ChatState.fTopMost);
    WritePrivateProfileString(szPref, szTop, szBuf, szIni);

    StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%d"), (UINT)ChatState.fSideBySide);
    WritePrivateProfileString(szPref, szSbS, szBuf, szIni);

    StringCchPrintf(szBuf, SZBUFSIZ, TEXT("%d"), (UINT)ChatState.fUseOwnFont);
    WritePrivateProfileString(szPref, szUseOF, szBuf, szIni);

    PostQuitMessage(0);

    return;
}


/*---------------------------------------------------------------------------*\
| ASCII TO LONG
|   This routine converts an ascii string to long.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
LONG FAR myatol(LPTSTR s)
{
        LONG ret = 0L;


    while(*s) ret = ret * 10 + (*s++ - TEXT('0'));

    return(ret);
}

/*---------------------------------------------------------------------------*\
| UPDATE BUTTON STATES
|   This routine updates the menu/toolbar buttons.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID FAR UpdateButtonStates(VOID)
{
    BOOL DialState   = FALSE;
        BOOL AnswerState = FALSE;
        BOOL HangUpState = FALSE;


    if(ChatState.fConnected)
                HangUpState = TRUE;
    else
    if(ChatState.fConnectPending)
    {
        if(!ChatState.fIsServer)
                        HangUpState = TRUE;
                else
                        AnswerState = TRUE;
        }
        else
                DialState = TRUE;

    SendMessage(hwndToolbar,TB_ENABLEBUTTON,IDM_DIAL  ,DialState);
    SendMessage(hwndToolbar,TB_ENABLEBUTTON,IDM_ANSWER,AnswerState);
    SendMessage(hwndToolbar,TB_ENABLEBUTTON,IDM_HANGUP,HangUpState);

    return;
}


/*---------------------------------------------------------------------------*\
| GET COMPUTER NAME
|   This routine returns the computer name of the machine.
|
| created: 31-Dec-92
| history: 31-Dec-92 <chriswil> created.
|
\*---------------------------------------------------------------------------*/
BOOL FAR appGetComputerName(LPTSTR lpszName)
{
    BOOL  bGet;
    DWORD dwSize;


#ifdef WIN32

    dwSize = MAX_COMPUTERNAME_LENGTH+1;
    bGet   = GetComputerName(lpszName,&dwSize);

#else

    bGet   = TRUE;
    dwSize = 0l;
    if(GetPrivateProfileString(szVredir,szComputerName,szNull,lpszName,UNCNLEN,szSysIni))
        OemToAnsi(lpszName,lpszName);

#endif

    return(bGet);
}


/*---------------------------------------------------------------------------*\
| ADJUST EDIT WINDOWS
|   This routine sizes the edit-controls.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID FAR AdjustEditWindows(VOID)
{
    int  tmpsplit;
        RECT rc;


    GetClientRect(hwndApp,&rc);

    rc.top    += ChatState.fToolBar   ? dyButtonBar + BRD : BRD;
    rc.bottom -= ChatState.fStatusBar ? dyStatus    + BRD : BRD;

    if(!ChatState.fSideBySide)
    {
        tmpsplit = rc.top + (rc.bottom - rc.top) / 2;

        SndRc.left   = RcvRc.left  = rc.left  - 1 + BRD;
        SndRc.right  = RcvRc.right = rc.right + 1 - BRD;
        SndRc.top    = rc.top;
                SndRc.bottom = tmpsplit;
        RcvRc.top    = tmpsplit + BRD;
                RcvRc.bottom = rc.bottom;
        }
    else
    {
        tmpsplit = rc.left + (rc.right - rc.left) / 2;

        SndRc.left   = rc.left  - 1   + BRD;
        SndRc.right  = tmpsplit - BRD / 2;
        RcvRc.left   = tmpsplit + BRD / 2;
        RcvRc.right  = rc.right + 1 - BRD;
        SndRc.top    = RcvRc.top    = rc.top;
        SndRc.bottom = RcvRc.bottom = rc.bottom;

    }

    MoveWindow(hwndSnd,SndRc.left,SndRc.top,SndRc.right-SndRc.left,SndRc.bottom-SndRc.top,TRUE);
    MoveWindow(hwndRcv,RcvRc.left,RcvRc.top,RcvRc.right-RcvRc.left,RcvRc.bottom-RcvRc.top,TRUE);

    return;
}


/*---------------------------------------------------------------------------*\
| CLEAR EDIT CONTROLS
|   This routine clears the send/receive edit controls.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID ClearEditControls(VOID)
{
    SendMessage(hwndSnd,EM_SETREADONLY,FALSE,0L);
    SendMessage(hwndSnd,WM_SETTEXT    ,0    ,(LPARAM)(LPSTR)szNull);
    SendMessage(hwndSnd,EM_SETREADONLY,TRUE ,0L);

    SendMessage(hwndRcv,EM_SETREADONLY,FALSE,0L);
    SendMessage(hwndRcv,WM_SETTEXT    ,0    ,(LPARAM)(LPSTR)szNull);
    SendMessage(hwndRcv,EM_SETREADONLY,TRUE ,0L);

    return;
}


/*---------------------------------------------------------------------------*\
| DO RING
|   This routine performs the phone ringing.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID DoRing(LPCTSTR sound)
{
    if(ChatState.fSound)
    {
        if(ChatState.fMMSound)
            sndPlaySound(sound,SND_ASYNC);
        else
            MessageBeep(0);
    }

    return;
}


/*---------------------------------------------------------------------------*\
| DRAW SHADOW RECT
|   This routine draws a shadow outline.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID DrawShadowRect(HDC hdc, LPRECT rc)
{
    HPEN hSavePen = SelectObject(hdc,hShadowPen);


    MoveToEx(hdc,rc->left,rc->bottom,NULL);
    LineTo(hdc,rc->left,rc->top );
    LineTo(hdc,rc->right,rc->top );
    SelectObject(hdc,hHilitePen);
    LineTo(hdc,rc->right,rc->bottom);
    LineTo(hdc,rc->left-1,rc->bottom);
    SelectObject(hdc,hSavePen);

    return;
}

#ifdef PROTOCOL_NEGOTIATE
/*---------------------------------------------------------------------------*\
| ANNOUNCE SUPPORT
|   This routine announces to the partner what we support.
|
| created: 11-Nov-91
| history: 29-Dec-92 <chriswil> ported to NT.
|
\*---------------------------------------------------------------------------*/
VOID AnnounceSupport(VOID)
{
    HDDEDATA hDdeData;
    DWORD    dummy;


    if(ChatState.fConnected)
    {
        ChatData.type = CHT_PROTOCOL;

        if(!ChatState.fIsServer)
        {
            hDdeData = CreateProtocolData();
            if(hDdeData)
                DdeClientTransaction((LPBYTE)hDdeData,(DWORD)-1L,ghConv,hszTextItem,cf_chatdata,XTYP_POKE,(DWORD)TIMEOUT_ASYNC,(LPDWORD)&dummy);
        }
        else
        {
            hszConvPartner = DdeCreateStringHandle(idInst,szConvPartner,0);
            if(hszConvPartner)
                DdePostAdvise(idInst,hszChatTopic,hszConvPartner);
        }

        ChatState.fProtocolSent = TRUE;
    }

    return;
}
#endif


/*---------------------------------------------------------------------------*\
| START INI-FILE MAPPING
|   This routines sets the private-profile settings to go to the registry on\
|   a per-user basis.
|
|
\*---------------------------------------------------------------------------*/
VOID StartIniMapping(VOID)
{
    HKEY  hKey1,hKey2,hKey3,hKeySnd;
    DWORD dwDisp,dwSize;


    if(RegCreateKeyEx(HKEY_LOCAL_MACHINE,szIniSection,0,NULL,REG_OPTION_NON_VOLATILE,KEY_WRITE,NULL,&hKey1,&dwDisp) == ERROR_SUCCESS)
    {
        if(dwDisp == REG_CREATED_NEW_KEY)
        {
            RegSetValueEx(hKey1,TEXT("Preferences"),0,REG_SZ,(LPBYTE)szIniKey1,ByteCountOf(lstrlen(szIniKey1)+1));
            RegSetValueEx(hKey1,TEXT("Font")       ,0,REG_SZ,(LPBYTE)szIniKey2,ByteCountOf(lstrlen(szIniKey2)+1));
        }

        if(RegCreateKeyEx(HKEY_CURRENT_USER,TEXT("Software\\Microsoft\\Winchat"),0,NULL,REG_OPTION_NON_VOLATILE,KEY_WRITE,NULL,&hKey1,&dwDisp) == ERROR_SUCCESS)
        {
            if(dwDisp == REG_CREATED_NEW_KEY)
            {
                RegCreateKeyEx(HKEY_CURRENT_USER,TEXT("Software\\Microsoft\\Winchat\\Preferences"),0,NULL,REG_OPTION_NON_VOLATILE,KEY_WRITE,NULL,&hKey2,&dwDisp);
                RegCreateKeyEx(HKEY_CURRENT_USER,TEXT("Software\\Microsoft\\Winchat\\Font")       ,0,NULL,REG_OPTION_NON_VOLATILE,KEY_WRITE,NULL,&hKey3,&dwDisp);

                RegCloseKey(hKey2);
                RegCloseKey(hKey3);
            }
        }

        RegCloseKey(hKey1);
    }


    // The sndPlaySound() first looks in the registry for the wav-files.  The
    // NT version doesn't have these here at setup, so Winchat will write out
    // the defaults when the strings don't exist.  This will allow uses to change
    // sounds for ringing-in and ringing-out.
    //
    if(RegOpenKeyEx(HKEY_CURRENT_USER,TEXT("Control Panel\\Sounds"),0,KEY_WRITE | KEY_QUERY_VALUE,&hKeySnd) == ERROR_SUCCESS)
    {
        dwSize = 0;
        dwDisp = REG_SZ;
        if(RegQueryValueEx(hKeySnd,TEXT("RingIn"),NULL,&dwDisp,NULL,&dwSize) != ERROR_SUCCESS)
        {
            if(dwSize == 0)
            {
                // Set the wav-file values.  Add (1) extra count to account for the null
                // terminator.
                //
                RegSetValueEx(hKeySnd,TEXT("RingIn") ,0,REG_SZ,(LPBYTE)szIniRingIn ,ByteCountOf(lstrlen(szIniRingIn)+1));
                RegSetValueEx(hKeySnd,TEXT("RingOut"),0,REG_SZ,(LPBYTE)szIniRingOut,ByteCountOf(lstrlen(szIniRingOut)+1));
            }
        }

        RegCloseKey(hKeySnd);
    }

    return;
}



/*---------------------------------------------------------------------------*\
| END INI-FILE MAPPING
|   This routines ends the ini-file mapping.  It doesn't do anything at this
|   point, but I've kept it in for some reason.
|
|
\*---------------------------------------------------------------------------*/
VOID EndIniMapping(VOID)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\afxrich2.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXRICH2.H

// CRichEdit2View
_AFXRICH2_INLINE CRichEdit2Ctrl& CRichEdit2View::GetRichEditCtrl() const
	{ return *(CRichEdit2Ctrl*)this; }
int _AFXRICH2_INLINE CRichEdit2View::GetPrintWidth() const
	{ return m_sizePaper.cx - m_rectMargin.left - m_rectMargin.right;}
CRect _AFXRICH2_INLINE CRichEdit2View::GetPrintRect() const
	{ return CRect(m_rectMargin.left, m_rectMargin.top, m_sizePaper.cx - m_rectMargin.right, m_sizePaper.cy - m_rectMargin.bottom); }
CRect _AFXRICH2_INLINE CRichEdit2View::GetPageRect() const
	{ return CRect(CPoint(0,0), m_sizePaper); }
void _AFXRICH2_INLINE CRichEdit2View::SetPaperSize(CSize sizePaper)
	{ m_sizePaper = sizePaper; }
CSize _AFXRICH2_INLINE CRichEdit2View::GetPaperSize() const
	{ return m_sizePaper; }
void _AFXRICH2_INLINE CRichEdit2View::SetMargins(const CRect& rectMargin)
	{ m_rectMargin = rectMargin; }
CRect _AFXRICH2_INLINE CRichEdit2View::GetMargins() const
	{ return m_rectMargin; }

_AFXRICH2_INLINE long CRichEdit2View::GetTextLength() const
	{ return GetRichEditCtrl().GetTextLength(); }
_AFXRICH2_INLINE CRichEdit2Doc* CRichEdit2View::GetDocument() const
{
	ASSERT(m_pDocument != NULL);
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CRichEdit2Doc)));
	return (CRichEdit2Doc*)m_pDocument;
}
_AFXRICH2_INLINE int CRichEdit2Doc::GetStreamFormat() const
	{ return m_bRTF ? SF_RTF : SF_TEXT; }
_AFXRICH2_INLINE BOOL CRichEdit2Doc::IsUnicode() const
    { return m_bUnicode; }
_AFXRICH2_INLINE void CRichEdit2Doc::InvalidateObjectCache()
	{ m_bUpdateObjectCache = TRUE; }

_AFXRICH2_INLINE void CRichEdit2CntrItem::Mark(BOOL b)
	{ m_bMark = b; }
_AFXRICH2_INLINE BOOL CRichEdit2CntrItem::IsMarked()
	{ return m_bMark||m_bLock; }
_AFXRICH2_INLINE CRichEdit2Doc* CRichEdit2CntrItem::GetDocument()
	{ return (CRichEdit2Doc*)COleClientItem::GetDocument(); }
_AFXRICH2_INLINE CRichEdit2View* CRichEdit2CntrItem::GetActiveView()
	{ return (CRichEdit2View*)COleClientItem::GetActiveView(); }

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\chicdial.cpp ===
// chicdial.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "fixhelp.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCSDialog dialog

CCSDialog::CCSDialog(UINT nIDTemplate, CWnd* pParentWnd)
	: CDialog(nIDTemplate, pParentWnd)
{
}

CCSDialog::CCSDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd)
	: CDialog(lpszTemplateName, pParentWnd)
{
}

CCSDialog::CCSDialog() : CDialog()
{
}

BEGIN_MESSAGE_MAP(CCSDialog, CDialog)
	//{{AFX_MSG_MAP(CCSDialog)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_HELP, OnHelp)
	ON_MESSAGE(WM_CONTEXTMENU, OnHelpContextMenu)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CCSDialog message handlers

LONG CCSDialog::OnHelp(WPARAM, LPARAM lParam)
{
	::WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, AfxGetApp()->m_pszHelpFilePath,
		HELP_WM_HELP, (DWORD_PTR)GetHelpIDs());
	return 0;
}

LONG CCSDialog::OnHelpContextMenu(WPARAM wParam, LPARAM)
{
	::WinHelp((HWND)wParam, AfxGetApp()->m_pszHelpFilePath,
		HELP_CONTEXTMENU, (DWORD_PTR)GetHelpIDs());
	return 0;
}

BOOL CCSDialog::OnInitDialog()
{
   CDialog::OnInitDialog();
   ModifyStyleEx(0, WS_EX_CONTEXTHELP);
   FixHelp(this, FALSE) ;
   return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
// CCSPropertyPage

CCSPropertyPage::CCSPropertyPage(UINT nIDTemplate, UINT nIDCaption)
	: CPropertyPage(nIDTemplate, nIDCaption)
{
    m_psp.dwFlags &= ~PSP_HASHELP;
}

CCSPropertyPage::CCSPropertyPage(LPCTSTR lpszTemplateName,
	UINT nIDCaption) : CPropertyPage(lpszTemplateName, nIDCaption)
{
    m_psp.dwFlags &= ~PSP_HASHELP;
}

BEGIN_MESSAGE_MAP(CCSPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CCSPropertyPage)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_HELP, OnHelp)
	ON_MESSAGE(WM_CONTEXTMENU, OnHelpContextMenu)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CCSPropertyPage message handlers

LONG CCSPropertyPage::OnHelp(WPARAM, LPARAM lParam)
{
	::WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, AfxGetApp()->m_pszHelpFilePath,
		HELP_WM_HELP, (DWORD_PTR)GetHelpIDs());
	return 0;
}

LONG CCSPropertyPage::OnHelpContextMenu(WPARAM wParam, LPARAM)
{
	::WinHelp((HWND)wParam, AfxGetApp()->m_pszHelpFilePath,
		HELP_CONTEXTMENU, (DWORD_PTR)GetHelpIDs());
	return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CCSPropertySheet

BEGIN_MESSAGE_MAP(CCSPropertySheet, CPropertySheet)
	//{{AFX_MSG_MAP(CCSPropertySheet)
	//}}AFX_MSG_MAP
   ON_WM_NCCREATE()
	ON_MESSAGE(WM_HELP, OnHelp)
	ON_MESSAGE(WM_CONTEXTMENU, OnHelpContextMenu)
END_MESSAGE_MAP()

CCSPropertySheet::CCSPropertySheet(UINT nIDCaption, CWnd *pParentWnd,
	UINT iSelectPage) : CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
    m_psh.dwFlags &= ~PSH_HASHELP;
}

CCSPropertySheet::CCSPropertySheet(LPCTSTR pszCaption, CWnd *pParentWnd,
	UINT iSelectPage) : CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
    m_psh.dwFlags &= ~PSH_HASHELP;
}

/////////////////////////////////////////////////////////////////////////////
// CCSPropertySheet message handlers

LONG CCSPropertySheet::OnHelp(WPARAM wParam, LPARAM lParam)
{
	GetActivePage()->SendMessage(WM_HELP, wParam, lParam);
	return 0;
}

LONG CCSPropertySheet::OnHelpContextMenu(WPARAM wParam, LPARAM lParam)
{
	GetActivePage()->SendMessage(WM_CONTEXTMENU, wParam, lParam);
	return 0;
}

BOOL CCSPropertySheet::PreCreateWindow(CREATESTRUCT& cs)
{
	cs.dwExStyle |= WS_EX_CONTEXTHELP;
	return CPropertySheet::PreCreateWindow(cs);
}

BOOL CCSPropertySheet::OnNcCreate(LPCREATESTRUCT)
{
   return (BOOL)Default() ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\cntritem.cpp ===
// cntritem.cpp : implementation of the CWordPadCntrItem class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"

#include "wordpdoc.h"
#include "wordpvw.h"
#include "cntritem.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWordPadCntrItem implementation

IMPLEMENT_SERIAL(CWordPadCntrItem, CRichEdit2CntrItem, 0)

CWordPadCntrItem::CWordPadCntrItem(REOBJECT *preo, CWordPadDoc* pContainer)
	: CRichEdit2CntrItem(preo, pContainer)
{
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadCntrItem diagnostics

#ifdef _DEBUG
void CWordPadCntrItem::AssertValid() const
{
	CRichEdit2CntrItem::AssertValid();
}

void CWordPadCntrItem::Dump(CDumpContext& dc) const
{
	CRichEdit2CntrItem::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\chicdial.h ===
// chicdial.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CCSDialog dialog

class CCSDialog : public CDialog
{
// Construction
public:
	CCSDialog();
	CCSDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL);
	CCSDialog(UINT nIDTemplate, CWnd* pParentWnd = NULL);

// Implementation
protected:
	virtual const DWORD* GetHelpIDs() = 0;

	// Generated message map functions
	//{{AFX_MSG(CCSDialog)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	afx_msg LONG OnHelp(WPARAM wParam, LPARAM lParam);
	afx_msg LONG OnHelpContextMenu(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()
};

class CCSPropertyPage : public CPropertyPage
{
// Construction
public:
	CCSPropertyPage(UINT nIDTemplate, UINT nIDCaption = 0);
	CCSPropertyPage(LPCTSTR lpszTemplateName, UINT nIDCaption = 0);

// Implementation
protected:
	virtual const DWORD* GetHelpIDs() = 0;

	// Generated message map functions
	//{{AFX_MSG(CCSPropertyPage)
	//}}AFX_MSG
	afx_msg LONG OnHelp(WPARAM wParam, LPARAM lParam);
	afx_msg LONG OnHelpContextMenu(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()
};

class CCSPropertySheet : public CPropertySheet
{
// Construction
public:
	CCSPropertySheet(UINT nIDCaption, CWnd *pParentWnd = NULL,
		UINT iSelectPage = 0);
	CCSPropertySheet(LPCTSTR pszCaption, CWnd *pParentWnd = NULL,
		UINT iSelectPage = 0);
// Implementation
protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	// Generated message map functions
	//{{AFX_MSG(CCSPropertySheet)
	//}}AFX_MSG
	afx_msg LONG OnHelp(WPARAM wParam, LPARAM lParam);
	afx_msg LONG OnHelpContextMenu(WPARAM wParam, LPARAM lParam);
   afx_msg BOOL OnNcCreate(LPCREATESTRUCT);
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\cntritem.h ===
// cntritem.h : interface of the CWordPadCntrItem class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CWordPadDoc;
class CWordPadView;

class CWordPadCntrItem : public CRichEdit2CntrItem
{
	DECLARE_SERIAL(CWordPadCntrItem)

// Constructors
public:
	CWordPadCntrItem(REOBJECT* preo = NULL, CWordPadDoc* pContainer = NULL);
		// Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIALIZE.
		//  IMPLEMENT_SERIALIZE requires the class have a constructor with
		//  zero arguments.  Normally, OLE items are constructed with a
		//  non-NULL document pointer.

// Attributes
public:
	CWordPadDoc* GetDocument()
		{ return (CWordPadDoc*)COleClientItem::GetDocument(); }
	CWordPadView* GetActiveView()
		{ return (CWordPadView*)COleClientItem::GetActiveView(); }

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWordPadCntrItem)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\afxrich2.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRICH2_H__
#define __AFXRICH2_H__

#ifndef __AFXWIN_H__
    #include <afxwin.h>
#endif
#ifndef __AFXDLGS_H__
    #include <afxdlgs.h>
    #include <afxdlgs2.h>
#endif
#ifndef __AFXOLE_H__
    #include <afxole.h>
#endif
#ifndef _RICHEDIT_
    #include "richedit.h"
#endif
#ifndef _RICHOLE_
    #include <richole.h>
    #define _RICHOLE_
#endif
#ifndef __AFXCMN2_H__
    #include <afxcmn2.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXRICH - RichEdit2 classes

// Classes declared in this file

//CObject
    //CCmdTarget;
        //CWnd
            //CView
                //CCtrlView
                    class CRichEdit2View;// rich text editor view

        //CDocument
            //COleDocument
                class CRichEdit2Doc;
        //CDocItem
            //COleClientItem
                class CRichEdit2CntrItem;

#undef AFX_DATA
#define AFX_DATA

enum WordWrapType
{
    WrapNone = 0,
    WrapToWindow = 1,
    WrapToTargetDevice = 2
};

// WrapNone, WrapToWindow or WrapToTargetDevice
inline int _VerifyWordWrap(int nWordWrapIn)
{
    int nWordWrapOut = WrapNone;
    if ((nWordWrapIn == WrapToWindow) || (nWordWrapIn == WrapToTargetDevice))
    {
        nWordWrapOut = nWordWrapIn;
    }
    return nWordWrapOut;
}



/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View

class _AFX_RICHEDIT2_STATE;  // private to implementation

class CRichEdit2View : public CCtrlView
{
    DECLARE_DYNCREATE(CRichEdit2View)

// Construction
public:
    CRichEdit2View();

// Attributes
public:
    int m_nWordWrap;
    int m_nBulletIndent;

    void SetPaperSize(CSize sizePaper);
    CSize GetPaperSize() const;
    void SetMargins(const CRect& rectMargin);
    CRect GetMargins() const;
    int GetPrintWidth() const;
    CRect GetPrintRect() const;
    CRect GetPageRect() const;

    //formatting
    CHARFORMAT& GetCharFormatSelection();
    PARAFORMAT& GetParaFormatSelection();
    void SetCharFormat(CHARFORMAT cf);
    void SetParaFormat(PARAFORMAT& pf);
    CRichEdit2CntrItem* GetSelectedItem() const;
    CRichEdit2CntrItem* GetInPlaceActiveItem() const;

    // CEdit control access
    CRichEdit2Ctrl& GetRichEditCtrl() const;
    CRichEdit2Doc* GetDocument() const;

    // other attributes
    long GetTextLength() const;
    static BOOL AFX_CDECL IsRichEdit2Format(CLIPFORMAT cf);
    BOOL CanPaste() const;

// Operations
public:
    void AdjustDialogPosition(CDialog* pDlg);
    HRESULT InsertItem(CRichEdit2CntrItem* pItem);
    void InsertFileAsObject(LPCTSTR lpszFileName);
    BOOL FindText(LPCTSTR lpszFind, BOOL bCase = TRUE, BOOL bWord = TRUE);
    BOOL FindTextSimple(LPCTSTR lpszFind, BOOL bCase = TRUE,
        BOOL bWord = TRUE);
    long PrintInsideRect(CDC* pDC, RECT& rectLayout, long nIndexStart,
        long nIndexStop, BOOL bOutput);
    long PrintPage(CDC* pDC, long nIndexStart, long nIndexStop);
    void DoPaste(COleDataObject& dataobj, CLIPFORMAT cf,
        HMETAFILEPICT hMetaPict);

// Helpers
    void OnCharEffect(DWORD dwMask, DWORD dwEffect);
    void OnUpdateCharEffect(CCmdUI* pCmdUI, DWORD dwMask, DWORD dwEffect) ;
    void OnParaAlign(WORD wAlign);
    void OnUpdateParaAlign(CCmdUI* pCmdUI, WORD wAlign);

// Overrideables
protected:
    virtual BOOL IsSelected(const CObject* pDocItem) const;
    virtual void OnInitialUpdate();
    virtual void OnFindNext(LPCTSTR lpszFind, BOOL bNext, BOOL bCase, BOOL bWord);
    virtual void OnReplaceSel(LPCTSTR lpszFind, BOOL bNext, BOOL bCase,
        BOOL bWord, LPCTSTR lpszReplace);
    virtual void OnReplaceAll(LPCTSTR lpszFind, LPCTSTR lpszReplace,
        BOOL bCase, BOOL bWord);
    virtual void OnTextNotFound(LPCTSTR lpszFind);
    virtual void OnPrinterChanged(const CDC& dcPrinter);
    virtual void WrapChanged();

// Advanced
    virtual BOOL OnPasteNativeObject(LPSTORAGE lpStg);
    virtual HMENU GetContextMenu(WORD, LPOLEOBJECT, CHARRANGE* );
    virtual HRESULT GetClipboardData(CHARRANGE* lpchrg, DWORD dwReco,
        LPDATAOBJECT lpRichDataObj, LPDATAOBJECT* lplpdataobj);
    virtual HRESULT QueryAcceptData(LPDATAOBJECT, CLIPFORMAT*, DWORD,
        BOOL, HGLOBAL);

// Implementation
public:
    LPRICHEDITOLE m_lpRichEditOle;
    CDC m_dcTarget;
    long m_lInitialSearchPos;
    UINT m_nPasteType;
    BOOL m_bFirstSearch;

    void TextNotFound(LPCTSTR lpszFind);
    BOOL FindText(_AFX_RICHEDIT2_STATE* pEditState);
    BOOL FindTextSimple(_AFX_RICHEDIT2_STATE* pEditState);
    long FindAndSelect(DWORD dwFlags, FINDTEXTEX& ft);
    void Stream(CArchive& ar, BOOL bSelection);
    HRESULT GetWindowContext(LPOLEINPLACEFRAME* lplpFrame,
        LPOLEINPLACEUIWINDOW* lplpDoc, LPOLEINPLACEFRAMEINFO lpFrameInfo);
    HRESULT ShowContainerUI(BOOL b);
    static DWORD CALLBACK EditStreamCallBack(DWORD_PTR dwCookie,
        LPBYTE pbBuff, LONG cb, LONG *pcb);
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
    virtual void Serialize(CArchive& ar);
    virtual void DeleteContents();
    virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo);

    static AFX_DATA ULONG lMaxSize; // maximum number of characters supported

protected:
    CRect m_rectMargin;
    CSize m_sizePaper;
    CDWordArray m_aPageStart;    // array of starting pages
    PARAFORMAT m_paraformat;
    CHARFORMAT m_charformat;
    BOOL m_bSyncCharFormat;
    BOOL m_bSyncParaFormat;

    // construction
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

    // printing support
    virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo = NULL);
    BOOL PaginateTo(CDC* pDC, CPrintInfo* pInfo);

    // find & replace support
    void OnEditFindReplace(BOOL bFindOnly);
    BOOL SameAsSelected(LPCTSTR lpszCompare, BOOL bCase, BOOL bWord);

    // special overrides for implementation

    //{{AFX_MSG(CRichEdit2View)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnUpdateNeedSel(CCmdUI* pCmdUI);
    afx_msg void OnUpdateNeedClip(CCmdUI* pCmdUI);
    afx_msg void OnUpdateNeedText(CCmdUI* pCmdUI);
    afx_msg void OnUpdateNeedFind(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
    afx_msg void OnEditCut();
    afx_msg void OnEditCopy();
    afx_msg void OnEditPaste();
    afx_msg void OnEditClear();
    afx_msg void OnEditUndo();
    afx_msg void OnEditSelectAll();
    afx_msg void OnEditFind();
    afx_msg void OnEditReplace();
    afx_msg void OnEditRepeat();
    afx_msg void OnDestroy();
    afx_msg void OnEditProperties();
    afx_msg void OnUpdateEditProperties(CCmdUI* pCmdUI);
    afx_msg void OnInsertObject();
    afx_msg void OnCancelEditCntr();
    afx_msg void OnCharBold();
    afx_msg void OnUpdateCharBold(CCmdUI* pCmdUI);
    afx_msg void OnCharItalic();
    afx_msg void OnUpdateCharItalic(CCmdUI* pCmdUI);
    afx_msg void OnCharUnderline();
    afx_msg void OnUpdateCharUnderline(CCmdUI* pCmdUI);
    afx_msg void OnParaCenter();
    afx_msg void OnUpdateParaCenter(CCmdUI* pCmdUI);
    afx_msg void OnParaLeft();
    afx_msg void OnUpdateParaLeft(CCmdUI* pCmdUI);
    afx_msg void OnParaRight();
    afx_msg void OnUpdateParaRight(CCmdUI* pCmdUI);
    afx_msg void OnBullet();
    afx_msg void OnUpdateBullet(CCmdUI* pCmdUI);
    afx_msg void OnFormatFont();
    afx_msg void OnColorPick(COLORREF cr);
    afx_msg void OnColorDefault();
    afx_msg void OnEditPasteSpecial();
    afx_msg void OnUpdateEditPasteSpecial(CCmdUI* pCmdUI);
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnDropFiles(HDROP hDropInfo);
    afx_msg void OnDevModeChange(LPTSTR lpDeviceName);
    //}}AFX_MSG
    afx_msg LRESULT OnFindReplaceCmd(WPARAM, LPARAM lParam);
    afx_msg void OnSelChange(NMHDR* pNMHDR, LRESULT* pResult);

    DECLARE_MESSAGE_MAP()

// Interface Map
public:
    BEGIN_INTERFACE_PART(RichEditOleCallback, IRichEditOleCallback)
        INIT_INTERFACE_PART(CRichEdit2View, RichEditOleCallback)
        STDMETHOD(GetNewStorage) (LPSTORAGE*);
        STDMETHOD(GetInPlaceContext) (LPOLEINPLACEFRAME*,
                                      LPOLEINPLACEUIWINDOW*,
                                      LPOLEINPLACEFRAMEINFO);
        STDMETHOD(ShowContainerUI) (BOOL);
        STDMETHOD(QueryInsertObject) (LPCLSID, LPSTORAGE, LONG);
        STDMETHOD(DeleteObject) (LPOLEOBJECT);
        STDMETHOD(QueryAcceptData) (LPDATAOBJECT, CLIPFORMAT*, DWORD,BOOL, HGLOBAL);
        STDMETHOD(ContextSensitiveHelp) (BOOL);
        STDMETHOD(GetClipboardData) (CHARRANGE*, DWORD, LPDATAOBJECT*);
        STDMETHOD(GetDragDropEffect) (BOOL, DWORD, LPDWORD);
        STDMETHOD(GetContextMenu) (WORD, LPOLEOBJECT, CHARRANGE*, HMENU*);
    END_INTERFACE_PART(RichEditOleCallback)

    DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc

class CRichEdit2Doc : public COleServerDoc
{
protected: // create from serialization only
    CRichEdit2Doc();
    DECLARE_DYNAMIC(CRichEdit2Doc)

// Attributes
public:
    BOOL m_bRTF;        // TRUE when formatted, FALSE when plain text
    BOOL m_bUnicode;    // TRUE if the doc is Unicode

    virtual CRichEdit2CntrItem* CreateClientItem(REOBJECT* preo = NULL) const = 0;

    virtual CRichEdit2View* GetView() const;
    int GetStreamFormat() const;
    BOOL IsUnicode() const;

// Implementation
protected:
    virtual COleServerItem* OnGetEmbeddedItem();
    void MarkItemsClear() const;
    void DeleteUnmarkedItems() const;
    void UpdateObjectCache();
public:
    BOOL m_bUpdateObjectCache;
    virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU);
    virtual void SetTitle(LPCTSTR lpszTitle);
    virtual COleClientItem* GetPrimarySelectedItem(CView* pView);
    virtual void DeleteContents();
    virtual POSITION GetStartPosition() const;
    virtual void PreCloseFrame(CFrameWnd* pFrameWnd);
    virtual void UpdateModifiedFlag();
    virtual BOOL IsModified();
    virtual void SetModifiedFlag(BOOL bModified = TRUE);
    virtual COleClientItem* GetInPlaceActiveItem(CWnd* pWnd);
    CRichEdit2CntrItem* LookupItem(LPOLEOBJECT lpobj) const;
    void InvalidateObjectCache();
    virtual void Serialize(CArchive& ar);   // overridden for document i/o
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2CntrItem

class CRichEdit2CntrItem : public COleClientItem
{
    DECLARE_SERIAL(CRichEdit2CntrItem)

// Constructors
public:
    CRichEdit2CntrItem(REOBJECT* preo = NULL, CRichEdit2Doc* pContainer = NULL);
        // Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIALIZE.
        //  IMPLEMENT_SERIALIZE requires the class have a constructor with
        //  zero arguments.  Normally, OLE items are constructed with a
        //  non-NULL document pointer.

// Operations
    void SyncToRichEditObject(REOBJECT& reo);

// Implementation
public:
    ~CRichEdit2CntrItem();
    LPOLECLIENTSITE m_lpClientSite;
    BOOL m_bMark;
    BOOL m_bLock;   // lock it during creation to avoid deletion
    void Mark(BOOL b);
    BOOL IsMarked();
    CRichEdit2Doc* GetDocument();
    CRichEdit2View* GetActiveView();
    HRESULT ShowContainerUI(BOOL b);
    HRESULT GetWindowContext(LPOLEINPLACEFRAME* lplpFrame,
        LPOLEINPLACEUIWINDOW* lplpDoc, LPOLEINPLACEFRAMEINFO lpFrameInfo);
    virtual LPOLECLIENTSITE GetClientSite();
    virtual BOOL ConvertTo(REFCLSID clsidNew);
    virtual BOOL ActivateAs(LPCTSTR lpszUserType, REFCLSID clsidOld,
        REFCLSID clsidNew);
    virtual void SetDrawAspect(DVASPECT nDrawAspect);
    virtual void OnDeactivateUI(BOOL bUndoable);
    virtual BOOL CanActivate();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:
    virtual BOOL OnChangeItemPosition(const CRect& rectPos);
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXRICH_INLINE inline
#include <afxrich2.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif //__AFXRICH2_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\colorlis.h ===
// colorlis.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CColorMenu window

class CColorMenu : public CMenu
{
    // The following structure is used for accessibility.  Accessibility tools
    // use it to get a descriptive string out of an owner-draw menu.  This
    // stuff will probably be put in a system header someday.

#define MSAA_MENU_SIG 0xAA0DF00DL

    // Menu's dwItemData should point to one of these structs:
    // (or can point to an app-defined struct containing this as the first 
    // member)
    typedef struct tagMSAAMENUINFO {
        DWORD   dwMSAASignature; // Must be MSAA_MENU_SIG
        DWORD   cchWText;        // Length of text in chars
        LPWSTR  pszWText;        // NUL-terminated text, in Unicode
    } MSAAMENUINFO, *LPMSAAMENUINFO;

    // Private struct to add the color index in

    struct MenuInfo
    {
        MSAAMENUINFO    msaa;
        int             index;
    };

// Construction
public:
	CColorMenu();

// Attributes
public:
    static MenuInfo m_menuInfo[17];
 
	static COLORREF GetColor(UINT id);

// Operations
public:

// Implementation
public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMIS);

};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\colorlis.cpp ===
// colorlis.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "colorlis.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CColorMenu

CColorMenu::MenuInfo CColorMenu::m_menuInfo[] = 
{
    {{MSAA_MENU_SIG, 0, NULL}, 0},    //black
    {{MSAA_MENU_SIG, 0, NULL}, 1},    //dark red
    {{MSAA_MENU_SIG, 0, NULL}, 2},    //dark green
    {{MSAA_MENU_SIG, 0, NULL}, 3},    //light brown
    {{MSAA_MENU_SIG, 0, NULL}, 4},    //dark blue
    {{MSAA_MENU_SIG, 0, NULL}, 5},    //purple
    {{MSAA_MENU_SIG, 0, NULL}, 6},    //dark cyan
    {{MSAA_MENU_SIG, 0, NULL}, 12},   //gray
    {{MSAA_MENU_SIG, 0, NULL}, 7},    //light gray
    {{MSAA_MENU_SIG, 0, NULL}, 13},   //red
    {{MSAA_MENU_SIG, 0, NULL}, 14},   //green
    {{MSAA_MENU_SIG, 0, NULL}, 15},   //yellow
    {{MSAA_MENU_SIG, 0, NULL}, 16},   //blue
    {{MSAA_MENU_SIG, 0, NULL}, 17},   //magenta
    {{MSAA_MENU_SIG, 0, NULL}, 18},   //cyan
    {{MSAA_MENU_SIG, 0, NULL}, 19},   //white
    {{MSAA_MENU_SIG, 0, NULL}, 0}     //automatic
};


CColorMenu::CColorMenu()
{
    VERIFY(CreatePopupMenu());
    ASSERT(GetMenuItemCount()==0);

    for (int i = 0; i < 17; i++)
    {
        LPWSTR pszmenutext = new WCHAR[64];

        ::LoadString(
                AfxGetInstanceHandle(),
                ID_COLOR0 + i,
                pszmenutext,
                64);

        m_menuInfo[i].msaa.pszWText = pszmenutext;
        m_menuInfo[i].msaa.cchWText = wcslen(pszmenutext);

        VERIFY(AppendMenu(MF_OWNERDRAW, ID_COLOR0+i, (LPCTSTR)&m_menuInfo[i]));
    }
}

COLORREF CColorMenu::GetColor(UINT id)
{
    ASSERT(id >= ID_COLOR0);
    ASSERT(id <= ID_COLOR16);
    if (id == ID_COLOR16) // autocolor
        return ::GetSysColor(COLOR_WINDOWTEXT);
    else
    {
        CPalette* pPal = CPalette::FromHandle( (HPALETTE) GetStockObject(DEFAULT_PALETTE));
        ASSERT(pPal != NULL);
        PALETTEENTRY pe;
        if (pPal->GetPaletteEntries(m_menuInfo[id-ID_COLOR0].index, 1, &pe) == 0)
            return ::GetSysColor(COLOR_WINDOWTEXT);
        else
            return RGB(pe.peRed,pe.peGreen,pe.peBlue);
    }
}

void CColorMenu::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
    ASSERT(lpDIS->CtlType == ODT_MENU);
    UINT id = (UINT)(WORD)lpDIS->itemID;
    ASSERT(id >= ID_COLOR0);
    ASSERT(id <= ID_COLOR16);
    CDC dc;
    dc.Attach(lpDIS->hDC);

    CRect rc(lpDIS->rcItem);
    ASSERT(rc.Width() < 500);
    if (lpDIS->itemState & ODS_FOCUS)
        dc.DrawFocusRect(&rc);

    COLORREF cr = (lpDIS->itemState & ODS_SELECTED) ?
        ::GetSysColor(COLOR_HIGHLIGHT) :
        dc.GetBkColor();

    CBrush brushFill(cr);
    cr = dc.GetTextColor();

    if (lpDIS->itemState & ODS_SELECTED)
        dc.SetTextColor(::GetSysColor(COLOR_HIGHLIGHTTEXT));

    int nBkMode = dc.SetBkMode(TRANSPARENT);
    dc.FillRect(&rc, &brushFill);

    rc.left += 50;
    CString strColor;
    strColor.LoadString(id);
    dc.TextOut(rc.left,rc.top,strColor,strColor.GetLength());
    rc.left -= 45;
    rc.top += 2;
    rc.bottom -= 2;
    rc.right = rc.left + 40;
    CBrush brush(GetColor(id));
    CBrush* pOldBrush = dc.SelectObject(&brush);
    dc.Rectangle(rc);

    dc.SelectObject(pOldBrush);
    dc.SetTextColor(cr);
    dc.SetBkMode(nBkMode);
    
    dc.Detach();
}

void CColorMenu::MeasureItem(LPMEASUREITEMSTRUCT lpMIS)
{
    ASSERT(lpMIS->CtlType == ODT_MENU);
    UINT id = (UINT)(WORD)lpMIS->itemID;
    ASSERT(id >= ID_COLOR0);
    ASSERT(id <= ID_COLOR16);
    CDisplayIC dc;
    CString strColor;
    strColor.LoadString(id);
    CSize sizeText = dc.GetTextExtent(strColor,strColor.GetLength());
    ASSERT(sizeText.cx < 500);
    lpMIS->itemWidth = sizeText.cx + 50;
    lpMIS->itemHeight = sizeText.cy;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\datedial.cpp ===
// datedial.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "datedial.h"
#include "helpids.h"
#include <winnls.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

SYSTEMTIME CDateDialog::m_time;
LCID CDateDialog::m_id;
CListBox* CDateDialog::m_pListBox = NULL;
PARAFORMAT CDateDialog::m_pf;

/////////////////////////////////////////////////////////////////////////////
// CDateDialog dialog

const DWORD CDateDialog::m_nHelpIDs[] =
{
    IDC_DATEDIALOG_LIST, IDH_WORDPAD_TIMEDATE,
    IDC_STATIC_HEADING, IDH_WORDPAD_TIMEDATE,
    0, 0
};

CDateDialog::CDateDialog(CWnd* pParent , PARAFORMAT& pf)
    : CCSDialog(CDateDialog::IDD, pParent)
{
    m_pf = pf;
    //{{AFX_DATA_INIT(CDateDialog)
    m_strSel = _T("");
    //}}AFX_DATA_INIT
}


void CDateDialog::DoDataExchange(CDataExchange* pDX)
{
    CCSDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDateDialog)
    DDX_Control(pDX, IDC_DATEDIALOG_LIST, m_listBox);
    DDX_LBString(pDX, IDC_DATEDIALOG_LIST, m_strSel);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDateDialog, CCSDialog)
    //{{AFX_MSG_MAP(CDateDialog)
    ON_LBN_DBLCLK(IDC_DATEDIALOG_LIST, OnDblclkDatedialogList)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDateDialog message handlers

BOOL CDateDialog::OnInitDialog()
{
    CCSDialog::OnInitDialog();

    m_pListBox = &m_listBox; // set static member
    GetLocalTime(&m_time);
    m_id = GetUserDefaultLCID();

    // if we have Arabic/Hebrew locale
    if ((PRIMARYLANGID(LANGIDFROMLCID(m_id))== LANG_ARABIC) || 
        (PRIMARYLANGID(LANGIDFROMLCID(m_id))== LANG_HEBREW))
    {
        if(
          (m_pf.wEffects & PFE_RTLPARA) &&
          !(GetWindowLongPtr(m_pListBox->m_hWnd,GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
          )
        {
            ::SetWindowLongPtr (m_pListBox->m_hWnd , GWL_EXSTYLE , 
               ::GetWindowLongPtr (m_pListBox->m_hWnd , GWL_EXSTYLE)|
                 WS_EX_RTLREADING | WS_EX_RIGHT | WS_EX_LEFTSCROLLBAR);
        }   
    }   
    
    EnumDateFormats(DateFmtEnumProc, m_id, DATE_SHORTDATE);
    EnumDateFormats(DateFmtEnumProc, m_id, DATE_LONGDATE);
    EnumTimeFormats(TimeFmtEnumProc, m_id, 0);

    m_pListBox = NULL;
    m_listBox.SetCurSel(0);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


// The following masks are defined in WinNls.h under #ifdef WINVER>=0x0500. so 
// even we included the header file, still we don't see it. I defined it as
// follows.

#ifndef DATE_LTRREADING 
#define DATE_LTRREADING 0x00000010
#endif //!DATE_LTRREADING 

#ifndef DATE_RTLREADING 
#define DATE_RTLREADING 0x00000020
#endif //!DATE_RTLREADING 

BOOL CALLBACK CDateDialog::DateFmtEnumProc(LPTSTR lpszFormatString)
{
    ASSERT(m_pListBox != NULL);

    TCHAR buffer[256];
    DWORD dwFlags = 0;

    // if we have Arabic/Hebrew locale
    if ((PRIMARYLANGID(LANGIDFROMLCID(m_id))== LANG_ARABIC) || 
        (PRIMARYLANGID(LANGIDFROMLCID(m_id))== LANG_HEBREW))
    {
        if (m_pf.wEffects & PFE_RTLPARA)
            dwFlags |= DATE_RTLREADING;
        else
            dwFlags |= DATE_LTRREADING;
    }   

    VERIFY(GetDateFormat(m_id, dwFlags, &m_time, lpszFormatString, buffer, ARRAYSIZE(buffer)));

    if ((PRIMARYLANGID(LANGIDFROMLCID(m_id))== LANG_ARABIC) || 
        (PRIMARYLANGID(LANGIDFROMLCID(m_id))== LANG_HEBREW))
    {
        StringCchCat(buffer, ARRAYSIZE(buffer), (m_pf.wEffects & PFE_RTLPARA) ? L"\x200F" : L"\x200E");
        // For display purposes only - ok to ignore return value.
    }   
    
    // Strip leading blanks
    TCHAR *buf = buffer;
    while (_istspace(*buf))
        ++buf;
    // we can end up with same format because a format with leading
    // zeroes may be the same as one without when a number is big enough
    // e.g. 09/10/94 9/10/94 are different but 10/10/94 and 10/10/94 are
    // the same
    if (m_pListBox->FindStringExact(-1,buf) == CB_ERR)
        m_pListBox->AddString(buf);
    return TRUE;
}

BOOL CALLBACK CDateDialog::TimeFmtEnumProc(LPTSTR lpszFormatString)
{
    ASSERT(m_pListBox != NULL);

    TCHAR buffer[256];
    TCHAR *buf = buffer;

    VERIFY(GetTimeFormat(m_id, 0, &m_time, lpszFormatString, buf, 256));

    // Strip leading blanks

    while (_istspace(*buf))
        ++buf;

    // we can end up with same format because a format with leading
    // zeroes may be the same as one without when a number is big enough
    // e.g. 09/10/94 9/10/94 are different but 10/10/94 and 10/10/94 are
    // the same
    if (m_pListBox->FindStringExact(-1,buf) == CB_ERR)
        m_pListBox->AddString(buf);
    return TRUE;
}

void CDateDialog::OnDblclkDatedialogList()
{
    OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\dlgcomm.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "stdafx2.h"
#include <dlgs.h>

#ifdef AFX_AUX_SEG
#pragma code_seg(AFX_AUX_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

static const UINT nMsgLBSELCHANGE = ::RegisterWindowMessage(LBSELCHSTRING);
static const UINT nMsgSHAREVI = ::RegisterWindowMessage(SHAREVISTRING);
static const UINT nMsgFILEOK = ::RegisterWindowMessage(FILEOKSTRING);
static const UINT nMsgCOLOROK = ::RegisterWindowMessage(COLOROKSTRING);
static const UINT nMsgHELP = ::RegisterWindowMessage(HELPMSGSTRING);

UINT_PTR CALLBACK
_AfxCommDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	if (hWnd == NULL)
		return 0;
/*
	_AFX_THREAD_STATE* pThreadState = _afxThreadState.GetData();
	if (pThreadState->m_pAlternateWndInit != NULL)
	{
		ASSERT_KINDOF(CFileDialog,pThreadState->m_pAlternateWndInit);
		pThreadState->m_pAlternateWndInit->SubclassWindow(hWnd);
		pThreadState->m_pAlternateWndInit = NULL;
	}
	ASSERT(pThreadState->m_pAlternateWndInit == NULL);
*/
	if (message == WM_INITDIALOG)
		return (UINT)AfxDlgProc(hWnd, message, wParam, lParam);

	if (message == nMsgHELP ||
	   (message == WM_COMMAND && LOWORD(wParam) == pshHelp))
	{
		// just translate the message into the AFX standard help command.
		SendMessage(hWnd, WM_COMMAND, ID_HELP, 0);
		return 1;
	}

	if (message < 0xC000)
	{
		// not a ::RegisterWindowMessage message
		return 0;
	}

	// assume it is already wired up to a permanent one
	CDialog* pDlg = (CDialog*)CWnd::FromHandlePermanent(hWnd);
	ASSERT(pDlg != NULL);
	ASSERT_KINDOF(CDialog, pDlg);

	if (pDlg->IsKindOf(RUNTIME_CLASS(CFileDialog)))
	{
		// If we're exploring then we are not interested in the Registered messages
		if (((CFileDialog*)pDlg)->m_ofn.Flags & OFN_EXPLORER)
			return 0;
	}

	// RegisterWindowMessage - does not copy to lastState buffer, so
	// CWnd::GetCurrentMessage and CWnd::Default will NOT work
	// while in these handlers

	// Dispatch special commdlg messages through our virtual callbacks
	if (message == nMsgSHAREVI)
	{
		ASSERT_KINDOF(CFileDialog, pDlg);
		return ((CFileDialog*)pDlg)->OnShareViolation((LPCTSTR)lParam);
	}
	else if (message == nMsgFILEOK)
	{
		ASSERT_KINDOF(CFileDialog, pDlg);

		if (afxData.bWin4)
			((CFileDialog*)pDlg)->m_pofnTemp = (OPENFILENAME*)lParam;

		BOOL bResult = ((CFileDialog*)pDlg)->OnFileNameOK();

		((CFileDialog*)pDlg)->m_pofnTemp = NULL;

		return bResult;
	}
	else if (message == nMsgLBSELCHANGE)
	{
		ASSERT_KINDOF(CFileDialog, pDlg);
		((CFileDialog*)pDlg)->OnLBSelChangedNotify((UINT)wParam, LOWORD(lParam),
				HIWORD(lParam));
		return 0;
	}
	else if (message == nMsgCOLOROK)
	{
		ASSERT_KINDOF(CColorDialog, pDlg);
		return ((CColorDialog*)pDlg)->OnColorOK();
	}
/*
//
// _afxNMsgSETRGB causes problems with the build.   Since it's not used
// for anything anyway, don't use it.
//

	else if (message == _afxNMsgSETRGB)
	{
		// nothing to do here, since this is a SendMessage
		return 0;
	}
*/
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\dlgfnt.cpp ===
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "stdafx2.h"

#ifdef AFX_AUX_SEG
#pragma code_seg(AFX_AUX_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// Choose Font dialog

CFontDialog2::CFontDialog2(LPLOGFONT lplfInitial, DWORD dwFlags, CDC* pdcPrinter,
	CWnd* pParentWnd) : CCommonDialog(pParentWnd)
{
	memset(&m_cf, 0, sizeof(m_cf));
	memset(&m_lf, 0, sizeof(m_lf));
	memset(&m_szStyleName, 0, sizeof(m_szStyleName));

	m_nIDHelp = AFX_IDD_FONT;

	m_cf.lStructSize = sizeof(m_cf);
	m_cf.lpszStyle = (LPTSTR)&m_szStyleName;
	m_cf.Flags = dwFlags | CF_ENABLEHOOK;
	if (!afxData.bWin4 && AfxHelpEnabled())
		m_cf.Flags |= CF_SHOWHELP;
	m_cf.lpfnHook = _AfxCommDlgProc;

	if (lplfInitial)
	{
		m_cf.lpLogFont = lplfInitial;
		m_cf.Flags |= CF_INITTOLOGFONTSTRUCT;
		memcpy(&m_lf, m_cf.lpLogFont, sizeof(m_lf));
	}
	else
	{
		m_cf.lpLogFont = &m_lf;
	}

	if (pdcPrinter)
	{
		ASSERT(pdcPrinter->m_hDC != NULL);
		m_cf.hDC = pdcPrinter->m_hDC;
		m_cf.Flags |= CF_PRINTERFONTS;
	}
}

CFontDialog2::CFontDialog2(const CHARFORMAT& charformat, DWORD dwFlags,
	CDC* pdcPrinter, CWnd* pParentWnd) : CCommonDialog(pParentWnd)
{
	memset(&m_cf, 0, sizeof(m_cf));
	memset(&m_lf, 0, sizeof(m_lf));
	memset(&m_szStyleName, 0, sizeof(m_szStyleName));

	m_nIDHelp = AFX_IDD_FONT;

	m_cf.lStructSize = sizeof(m_cf);
	m_cf.lpszStyle = (LPTSTR)&m_szStyleName;
	m_cf.Flags = dwFlags | CF_ENABLEHOOK | CF_INITTOLOGFONTSTRUCT;
	m_cf.Flags |= FillInLogFont(charformat);
	if (!afxData.bWin4 && AfxHelpEnabled())
		m_cf.Flags |= CF_SHOWHELP;
	m_cf.lpfnHook = _AfxCommDlgProc;

	m_cf.lpLogFont = &m_lf;

	if (pdcPrinter)
	{
		ASSERT(pdcPrinter->m_hDC != NULL);
		m_cf.hDC = pdcPrinter->m_hDC;
		m_cf.Flags |= CF_PRINTERFONTS;
	}
	if (charformat.dwMask & CFM_COLOR)
		m_cf.rgbColors = charformat.crTextColor;
}

INT_PTR CFontDialog2::DoModal()
{
	ASSERT_VALID(this);
	ASSERT(m_cf.Flags & CF_ENABLEHOOK);
	ASSERT(m_cf.lpfnHook != NULL); // can still be a user hook

	m_cf.hwndOwner = PreModal();
	int nResult = ::ChooseFont(&m_cf);
	PostModal();

	if (nResult == IDOK)
	{
		// copy logical font from user's initialization buffer (if needed)
		memcpy(&m_lf, m_cf.lpLogFont, sizeof(m_lf));
		return IDOK;
	}
	return nResult ? nResult : IDCANCEL;
}

void CFontDialog2::GetCurrentFont(LPLOGFONT lplf)
{
	ASSERT(lplf != NULL);

	if (m_hWnd != NULL)
		SendMessage(WM_CHOOSEFONT_GETLOGFONT, 0, (DWORD_PTR)lplf);
	else
		*lplf = m_lf;
}

////////////////////////////////////////////////////////////////////////////
// CFontDialog2 CHARFORMAT helpers

DWORD CFontDialog2::FillInLogFont(const CHARFORMAT& cf)
{
	USES_CONVERSION;
	DWORD dwFlags = 0;
	if (cf.dwMask & CFM_SIZE)
	{
		CDC dc;
		dc.CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
		LONG yPerInch = dc.GetDeviceCaps(LOGPIXELSY);
		m_lf.lfHeight = -(int) ((cf.yHeight * yPerInch) / 1440);
	}
	else
		m_lf.lfHeight = 0;

	m_lf.lfWidth = 0;
	m_lf.lfEscapement = 0;
	m_lf.lfOrientation = 0;

	if ((cf.dwMask & (CFM_ITALIC|CFM_BOLD)) == (CFM_ITALIC|CFM_BOLD))
	{
		m_lf.lfWeight = (cf.dwEffects & CFE_BOLD) ? FW_BOLD : FW_NORMAL;
		m_lf.lfItalic = (BYTE)((cf.dwEffects & CFE_ITALIC) ? TRUE : FALSE);
	}
	else
	{
		dwFlags |= CF_NOSTYLESEL;
		m_lf.lfWeight = FW_DONTCARE;
		m_lf.lfItalic = FALSE;
	}

	if ((cf.dwMask & (CFM_UNDERLINE|CFM_STRIKEOUT|CFM_COLOR)) ==
		(CFM_UNDERLINE|CFM_STRIKEOUT|CFM_COLOR))
	{
		dwFlags |= CF_EFFECTS;
		m_lf.lfUnderline = (BYTE)((cf.dwEffects & CFE_UNDERLINE) ? TRUE : FALSE);
		m_lf.lfStrikeOut = (BYTE)((cf.dwEffects & CFE_STRIKEOUT) ? TRUE : FALSE);
	}
	else
	{
		m_lf.lfUnderline = (BYTE)FALSE;
		m_lf.lfStrikeOut = (BYTE)FALSE;
	}

	if (cf.dwMask & CFM_CHARSET)
		m_lf.lfCharSet = cf.bCharSet;
	else
		dwFlags |= CF_NOSCRIPTSEL;
	m_lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
	m_lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	m_lf.lfQuality = DEFAULT_QUALITY;
	if (cf.dwMask & CFM_FACE)
	{
		m_lf.lfPitchAndFamily = cf.bPitchAndFamily;
		StringCchCopy(m_lf.lfFaceName, ARRAYSIZE(m_lf.lfFaceName), cf.szFaceName); // ignoring return value
	}
	else
	{
		m_lf.lfPitchAndFamily = DEFAULT_PITCH|FF_DONTCARE;
		m_lf.lfFaceName[0] = (TCHAR)0;
	}
	return dwFlags;
}

void CFontDialog2::GetCharFormat(CHARFORMAT& cf) const
{
	USES_CONVERSION;
	cf.dwEffects = 0;
	cf.dwMask = 0;
	if ((m_cf.Flags & CF_NOSTYLESEL) == 0)
	{
		cf.dwMask |= CFM_BOLD | CFM_ITALIC;
		cf.dwEffects |= (IsBold()) ? CFE_BOLD : 0;
		cf.dwEffects |= (IsItalic()) ? CFE_ITALIC : 0;
	}
	if ((m_cf.Flags & CF_NOSIZESEL) == 0)
	{
		cf.dwMask |= CFM_SIZE;
		//GetSize() returns in tenths of points so mulitply by 2 to get twips
		cf.yHeight = GetSize()*2;
	}

	if ((m_cf.Flags & CF_NOFACESEL) == 0)
	{
		cf.dwMask |= CFM_FACE;
		cf.bPitchAndFamily = m_cf.lpLogFont->lfPitchAndFamily;
		StringCchCopy(cf.szFaceName, ARRAYSIZE(cf.szFaceName), GetFaceName()); // ignoring return value
	}

	if (m_cf.Flags & CF_EFFECTS)
	{
		cf.dwMask |= CFM_UNDERLINE | CFM_STRIKEOUT | CFM_COLOR;
		cf.dwEffects |= (IsUnderline()) ? CFE_UNDERLINE : 0;
		cf.dwEffects |= (IsStrikeOut()) ? CFE_STRIKEOUT : 0;
		cf.crTextColor = GetColor();
	}
	if ((m_cf.Flags & CF_NOSCRIPTSEL) == 0)
	{
		cf.bCharSet = m_cf.lpLogFont->lfCharSet;
		cf.dwMask |= CFM_CHARSET;
	}
	cf.yOffset = 0;
}

////////////////////////////////////////////////////////////////////////////
// CFontDialog2 diagnostics

#ifdef _DEBUG
void CFontDialog2::Dump(CDumpContext& dc) const
{
	CDialog::Dump(dc);

	dc << "m_cf.hwndOwner = " << (UINT)m_cf.hwndOwner;
	dc << "\nm_cf.hDC = " << (UINT)m_cf.hDC;
	dc << "\nm_cf.iPointSize = " << m_cf.iPointSize;
	dc << "\nm_cf.Flags = " << (LPVOID)m_cf.Flags;
	dc << "\nm_cf.lpszStyle = " << m_cf.lpszStyle;
	dc << "\nm_cf.nSizeMin = " << m_cf.nSizeMin;
	dc << "\nm_cf.nSizeMax = " << m_cf.nSizeMax;
	dc << "\nm_cf.nFontType = " << m_cf.nFontType;
	dc << "\nm_cf.rgbColors = " << (LPVOID)m_cf.rgbColors;

	if (m_cf.lpfnHook == _AfxCommDlgProc)
		dc << "\nhook function set to standard MFC hook function";
	else
		dc << "\nhook function set to non-standard hook function";

	dc << "\n";
}
#endif //_DEBUG

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

IMPLEMENT_DYNAMIC(CFontDialog2, CDialog)

////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\dlgprnt2.cpp ===
// Copyright (C) 1992-1999 Microsoft Corporation
//
// This file is a snapshot of the version in MFC.  It contains fixes for dialog
// initialization that are not yet in the main version.

#include <afx.h>
#include <afxwin.h>
#include <afxdisp.h>
#include <afxole.h>
#include <afxpriv.h>


#include "afxprntx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW


INT_PTR CALLBACK AfxDlgProc(HWND, UINT, WPARAM, LPARAM);

/////////////////////////////////////////////////////////////////////////////
// Private class to support new NT5 printing user interface

//
//  IPrintDialogCallback interface id used by PrintDlgEx.
//
//  {5852A2C3-6530-11D1-B6A3-0000F8757BF9}
//
extern "C" const __declspec(selectany) IID IID_IPrintDialogCallback =
        {0x5852a2c3, 0x6530, 0x11d1, {0xb6, 0xa3, 0x0, 0x0, 0xf8, 0x75, 0x7b, 0xf9}};

BEGIN_INTERFACE_MAP(C_PrintDialogEx, CPrintDialog)
   INTERFACE_PART(C_PrintDialogEx, IID_IPrintDialogCallback, PrintDialogCallback)
END_INTERFACE_MAP()

C_PrintDialogEx::C_PrintDialogEx(BOOL bPrintSetupOnly,
        DWORD dwFlags, CWnd* pParentWnd)
        : CPrintDialog(bPrintSetupOnly, dwFlags, pParentWnd)
{
        memset(&m_pdex, 0, sizeof(m_pdex));
        m_pdex.lStructSize = sizeof(m_pdex);
        m_pdex.Flags = dwFlags;
}

INT_PTR C_PrintDialogEx::DoModal()
{
        ASSERT_VALID(this);

        m_pd.hwndOwner = PreModal();
        AfxUnhookWindowCreate();

        // expand m_pd data into the PRINTDLGEX structure

        m_pdex.hwndOwner = m_pd.hwndOwner;
        m_pdex.hDevMode = m_pd.hDevMode;
        m_pdex.hDevNames = m_pd.hDevNames;
        m_pdex.hDC = m_pd.hDC;
//        m_pdex.Flags = (m_pd.Flags & ~(PD_ENABLEPRINTHOOK | PD_ENABLESETUPHOOK | PD_PRINTSETUP));

        m_pdex.nMinPage = m_pd.nMinPage;
        m_pdex.nMaxPage = m_pd.nMaxPage;
        m_pdex.hInstance = m_pd.hInstance;
        m_pdex.nStartPage = START_PAGE_GENERAL;
        m_pdex.nCopies = m_pd.nCopies;
        m_pdex.lpCallback = &m_xPrintDialogCallback;

        // initialize page ranges

        PRINTPAGERANGE ourPageRange;

        if (m_pdex.Flags & PD_NOPAGENUMS)
        {
                m_pdex.lpPageRanges = NULL;
                m_pdex.nPageRanges = 0;
                m_pdex.nMaxPageRanges = 0;
        }
        else
        {
                ourPageRange.nFromPage = m_pd.nFromPage;
                ourPageRange.nToPage   = m_pd.nToPage;
                m_pdex.nPageRanges = 1;
                m_pdex.nMaxPageRanges = 1;
                m_pdex.lpPageRanges = &ourPageRange;
        }

        HMODULE hCommDlg = GetModuleHandleA("COMDLG32.DLL");
        HRESULT (STDAPICALLTYPE* pfn)(LPPRINTDLGEX);
#ifdef UNICODE
        pfn = (HRESULT (STDAPICALLTYPE*)(LPPRINTDLGEX))
                                GetProcAddress(hCommDlg, "PrintDlgExW");
#else
        pfn = (HRESULT (STDAPICALLTYPE*)(LPPRINTDLGEX))
                                GetProcAddress(hCommDlg, "PrintDlgExA");
#endif

        HRESULT hResult = E_NOTIMPL;
        if (pfn != NULL)
        {
                _AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
                ASSERT(pThreadState->m_pAlternateWndInit == NULL);

//                pThreadState->m_pAlternateWndInit = this;

                hResult = pfn(&m_pdex);
                if (SUCCEEDED(hResult))
                        ASSERT(pThreadState->m_pAlternateWndInit == NULL);
                pThreadState->m_pAlternateWndInit = NULL;
        }

        // pull data back...

        PostModal();

        if (!(m_pdex.Flags & PD_NOPAGENUMS))
        {
                m_pd.nToPage = (WORD) m_pdex.lpPageRanges->nToPage;
                m_pd.nFromPage = (WORD) m_pdex.lpPageRanges->nFromPage;
                m_pd.nMinPage = (WORD) m_pdex.nMinPage;
                m_pd.nMaxPage = (WORD) m_pdex.nMaxPage;
        }

        m_pd.hDevMode = m_pdex.hDevMode;
        m_pd.hDevNames = m_pdex.hDevNames;
        m_pd.hDC = m_pdex.hDC;
        m_pd.nCopies = (WORD)m_pdex.nCopies;
        // calculate return code
        int nResult = IDCANCEL;
        if (SUCCEEDED(hResult))
        {
                if (m_pdex.dwResultAction == PD_RESULT_PRINT)
                        nResult = IDOK;
        }
        return nResult;
}


STDMETHODIMP_(ULONG) C_PrintDialogEx::XPrintDialogCallback::AddRef()
{
        METHOD_PROLOGUE_EX_(C_PrintDialogEx, PrintDialogCallback)
        return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) C_PrintDialogEx::XPrintDialogCallback::Release()
{
        METHOD_PROLOGUE_EX_(C_PrintDialogEx, PrintDialogCallback)
        return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP C_PrintDialogEx::XPrintDialogCallback::QueryInterface(
        REFIID iid, LPVOID* ppvObj)
{
        METHOD_PROLOGUE_EX_(C_PrintDialogEx, PrintDialogCallback)
        return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP C_PrintDialogEx::XPrintDialogCallback::InitDone()
{
        METHOD_PROLOGUE_EX(C_PrintDialogEx, PrintDialogCallback)
        return pThis->OnInitDone();
}

STDMETHODIMP C_PrintDialogEx::XPrintDialogCallback::SelectionChange()
{
        METHOD_PROLOGUE_EX(C_PrintDialogEx, PrintDialogCallback)
        return pThis->OnSelectionChange();
}

STDMETHODIMP C_PrintDialogEx::XPrintDialogCallback::HandleMessage(HWND hDlg,
        UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
        METHOD_PROLOGUE_EX(C_PrintDialogEx, PrintDialogCallback)
        return pThis->OnHandleMessage(hDlg, uMsg, wParam, lParam, pResult);
}

HRESULT C_PrintDialogEx::OnInitDone()
{
        return S_FALSE;
}

HRESULT C_PrintDialogEx::OnSelectionChange()
{
        return S_FALSE;
}

HRESULT C_PrintDialogEx::OnHandleMessage(HWND hDlg, UINT uMsg,
        WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
//        UNUSED_ALWAYS(hDlg);
        HRESULT hResult = S_FALSE;
/*
        _AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
        if (pThreadState->m_pAlternateWndInit != NULL)
        {
                ASSERT_KINDOF(C_PrintDialogEx, pThreadState->m_pAlternateWndInit);
                pThreadState->m_pAlternateWndInit->SubclassWindow(hDlg);
                pThreadState->m_pAlternateWndInit = NULL;
        }
        ASSERT(pThreadState->m_pAlternateWndInit == NULL);
*/
        if (uMsg == WM_INITDIALOG)
        {
                SubclassWindow(hDlg);
                *pResult = AfxDlgProc(hDlg, uMsg, wParam, lParam);
                hResult = S_FALSE;
        }

        return hResult;
}

IMPLEMENT_DYNAMIC(C_PrintDialogEx, CPrintDialog)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\ddxm.cpp ===
// ddxm.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "ddxm.h"
#include "wordpad.h"
#include "resource.h"

// this routine prints a floatingpoint number with 2 digits after the decimal
void PASCAL DDX_Twips(CDataExchange* pDX, int nIDC, int& value)
{
	HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
	TCHAR szT[64];

	if (pDX->m_bSaveAndValidate)
	{
		::GetWindowText(hWndCtrl, szT, sizeof(szT)/sizeof(szT[0]));
		if (szT[0] != NULL) // not empty
		{
			if (!theApp.ParseMeasurement(szT, value))
			{
				AfxMessageBox(IDS_INVALID_MEASUREMENT,MB_OK|MB_ICONINFORMATION);
				pDX->Fail();            // throws exception
			}
			theApp.PrintTwips(szT, ARRAYSIZE(szT), value, 2);
			theApp.ParseMeasurement(szT, value);
		}
		else // empty
			value = INT_MAX;
	}
	else
	{
		// convert from twips to default units
		if (value != INT_MAX)
		{
			theApp.PrintTwips(szT, ARRAYSIZE(szT), value, 2);
			SetWindowText(hWndCtrl, szT);
		}
	}
}

void PASCAL DDV_MinMaxTwips(CDataExchange* pDX, int value, int minVal, int maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
	{
		// "The measurement must be between %1 and %2."
		if (!pDX->m_bSaveAndValidate)
		{
			TRACE0("Warning: initial dialog data is out of range.\n");
			return;     // don't stop now
		}
		TCHAR szMin[32];
		TCHAR szMax[32];
		theApp.PrintTwips(szMin, ARRAYSIZE(szMin), minVal, 2);
		theApp.PrintTwips(szMax, ARRAYSIZE(szMax), maxVal, 2);
		CString prompt;
		AfxFormatString2(prompt, IDS_MEASUREMENT_RANGE, szMin, szMax);
		AfxMessageBox(prompt, MB_ICONEXCLAMATION, AFX_IDS_APP_TITLE);
		prompt.Empty(); // exception prep
		pDX->Fail();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\ddxm.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include <limits.h>
void PASCAL DDX_Twips(CDataExchange* pDX, int nIDC, int& value);
void PASCAL DDV_MinMaxTwips(CDataExchange* pDX, int value, int minVal, int maxVal);
#define DDXM_BLANK INT_MAX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\docopt.cpp ===
// docopt.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "docopt.h"
#include "helpids.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDocOptPage property page

const DWORD CDocOptPage::m_nHelpIDs[] = 
{
	IDC_BOX, (DWORD) -1,
	IDC_WRAP_NONE, IDH_WORDPAD_WRAP_NO,
	IDC_WRAP_WINDOW, IDH_WORDPAD_WRAP_WINDOW,
	IDC_WRAP_RULER, IDH_WORDPAD_WRAP_RULER,
	IDC_BOXT, (DWORD) -1,
	IDC_CHECK_TOOLBAR, IDH_WORDPAD_CHECK_TOOLBAR,
	IDC_CHECK_FORMATBAR, IDH_WORDPAD_CHECK_FORMATBAR,
	IDC_CHECK_STATUSBAR, IDH_WORDPAD_CHECK_STATUSBAR,
	IDC_CHECK_RULERBAR, IDH_WORDPAD_CHECK_RULERBAR,
    AFX_IDC_TAB_CONTROL, (DWORD) -1,
	0, 0
};

CDocOptPage::CDocOptPage() : CCSPropertyPage(CDocOptPage::IDD)
{
	//{{AFX_DATA_INIT(CDocOptPage)
	m_nWordWrap = -1;
	m_bFormatBar = FALSE;
	m_bRulerBar = FALSE;
	m_bStatusBar = FALSE;
	m_bToolBar = FALSE;
	//}}AFX_DATA_INIT
}

CDocOptPage::CDocOptPage(UINT nIDCaption) : 
	CCSPropertyPage(CDocOptPage::IDD, nIDCaption)
{
	m_nWordWrap = -1;
	m_bFormatBar = FALSE;
	m_bRulerBar = FALSE;
	m_bStatusBar = FALSE;
	m_bToolBar = FALSE;
}

CDocOptPage::~CDocOptPage()
{
}

void CDocOptPage::DoDataExchange(CDataExchange* pDX)
{
	CCSPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDocOptPage)
	DDX_Radio(pDX, IDC_WRAP_NONE, m_nWordWrap);
	DDX_Check(pDX, IDC_CHECK_FORMATBAR, m_bFormatBar);
	DDX_Check(pDX, IDC_CHECK_RULERBAR, m_bRulerBar);
	DDX_Check(pDX, IDC_CHECK_STATUSBAR, m_bStatusBar);
	DDX_Check(pDX, IDC_CHECK_TOOLBAR, m_bToolBar);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDocOptPage, CCSPropertyPage)
	//{{AFX_MSG_MAP(CDocOptPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDocOptPage message handlers

/////////////////////////////////////////////////////////////////////////////
// CEmbeddedOptPage property page

CEmbeddedOptPage::CEmbeddedOptPage() : CDocOptPage(IDS_EMBEDDED_OPTIONS)
{
}

BOOL CEmbeddedOptPage::OnInitDialog()
{
	BOOL b = CDocOptPage::OnInitDialog();
	GetDlgItem(IDC_CHECK_STATUSBAR)->ShowWindow(SW_HIDE);
	return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\docopt.h ===
// docopt.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CDocOptPage dialog

class CDocOptPage : public CCSPropertyPage
{
// Construction
public:
	CDocOptPage();
	CDocOptPage(UINT nIDCaption);
	~CDocOptPage();

// Dialog Data
	//{{AFX_DATA(CDocOptPage)
	enum { IDD = IDD_OPTIONS_WRAP };
	int		m_nWordWrap;
	BOOL	m_bFormatBar;
	BOOL	m_bRulerBar;
	BOOL	m_bStatusBar;
	BOOL	m_bToolBar;
	//}}AFX_DATA


// Overrides
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDocOptPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDocOptPage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

class CEmbeddedOptPage : public CDocOptPage
{
// Construction
public:
	CEmbeddedOptPage();
// Overrides
	BOOL OnInitDialog();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\datedial.h ===
// datedial.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CDateDialog dialog

class CDateDialog : public CCSDialog
{
// Construction
public:
	CDateDialog(CWnd* pParent , PARAFORMAT& pf); // standard constructor

// Attributes
	static PARAFORMAT m_pf;
	static SYSTEMTIME m_time;
	static LCID m_id;
	static CListBox* m_pListBox;
	static BOOL CALLBACK DateFmtEnumProc(LPTSTR lpszFormatString);
	static BOOL CALLBACK TimeFmtEnumProc(LPTSTR lpszFormatString);

// Dialog Data
	//{{AFX_DATA(CDateDialog)
	enum { IDD = IDD_DATEDIALOG };
	CListBox	m_listBox;
	CString	m_strSel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDateDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}

	// Generated message map functions
	//{{AFX_MSG(CDateDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnDblclkDatedialogList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\fixhelp.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

extern BOOL g_fDisableStandardHelp ;

extern HHOOK g_HelpFixHook ;

void FixHelp(CWnd* pWnd, BOOL fFixWndProc);

void SetHelpFixHook(void) ;

void RemoveHelpFixHook(void) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\filedlg.h ===
// filedlg.h : header file
//
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.
//
// This file is to support an extended file save dialog with a
// "Use this format by default" checkbox

//
// The shell guys insist that Wordpad call GetOpenFileName with the newest
// OPENFILENAME structure but MFC doesn't support it.  MFC also needs to be
// built with _WIN32_WINNT set to 0x0400 so Wordpad can't even see the new
// structure.  Since the shell guys won't change the way they define the
// structure so that Wordpad can see both versions, it has to be snapshotted
// here.
//

#if !defined(_WIN64)
#include <pshpack1.h>   // Must byte pack to match definition in commdlg.h
#endif

typedef struct tagOFN500A {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCSTR       lpstrFilter;
   LPSTR        lpstrCustomFilter;
   DWORD        nMaxCustFilter;
   DWORD        nFilterIndex;
   LPSTR        lpstrFile;
   DWORD        nMaxFile;
   LPSTR        lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCSTR       lpstrInitialDir;
   LPCSTR       lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCSTR       lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCSTR       lpTemplateName;
   struct IMoniker **rgpMonikers;
   DWORD        cMonikers;
   DWORD        FlagsEx;
} OPENFILENAME500A, *LPOPENFILENAME500A;
typedef struct tagOFN500W {
   DWORD        lStructSize;
   HWND         hwndOwner;
   HINSTANCE    hInstance;
   LPCWSTR      lpstrFilter;
   LPWSTR       lpstrCustomFilter;
   DWORD        nMaxCustFilter;
   DWORD        nFilterIndex;
   LPWSTR       lpstrFile;
   DWORD        nMaxFile;
   LPWSTR       lpstrFileTitle;
   DWORD        nMaxFileTitle;
   LPCWSTR      lpstrInitialDir;
   LPCWSTR      lpstrTitle;
   DWORD        Flags;
   WORD         nFileOffset;
   WORD         nFileExtension;
   LPCWSTR      lpstrDefExt;
   LPARAM       lCustData;
   LPOFNHOOKPROC lpfnHook;
   LPCWSTR      lpTemplateName;
   struct IMoniker **rgpMonikers;
   DWORD        cMonikers;
   DWORD        FlagsEx;
} OPENFILENAME500W, *LPOPENFILENAME500W;
#ifdef UNICODE
typedef OPENFILENAME500W OPENFILENAME500;
typedef LPOPENFILENAME500W LPOPENFILENAME500;
#else
typedef OPENFILENAME500A OPENFILENAME500;
typedef LPOPENFILENAME500A LPOPENFILENAME500;
#endif // UNICODE

#if !defined(_WIN64)
#include <poppack.h>
#endif

class CWordpadFileDialog : public CFileDialog
{
    DECLARE_DYNAMIC(CWordpadFileDialog);

public:

    CWordpadFileDialog(BOOL bOpenFileDialog);

    int GetFileType()                           {return m_doctype;}

    static void SetDefaultFileType(int doctype)
    {
        m_defaultDoctype = doctype;
        RD_DEFAULT = doctype;
    }
    static int  GetDefaultFileType()            {return m_defaultDoctype;}

    virtual INT_PTR DoModal();

protected:

            int     m_doctype;
    static  int     m_defaultDoctype;

    LPOFNHOOKPROC   m_original_hook;

    OPENFILENAME500 m_openfilename;

    static const DWORD m_nHelpIDs[];
    virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}

    static UINT_PTR CALLBACK FileDialogHookProc(HWND, UINT, WPARAM, LPARAM);

    virtual BOOL OnFileNameOK();
    virtual void OnTypeChange();
    virtual void OnInitDone();

    // Generated message map functions
    //{{AFX_MSG(CWordpadFileDialog)
    afx_msg void OnDefaultFormatClicked();
    //}}AFX_MSG
    afx_msg LONG OnHelp(WPARAM wParam, LPARAM lParam);
    afx_msg LONG OnHelpContextMenu(WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\filenewd.cpp ===
// filenewd.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "filenewd.h"
#include "filedlg.h"
#include "helpids.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

DWORD const CFileNewDialog::m_nHelpIDs[] = 
{
	IDC_DATEDIALOG_LIST, IDH_WORDPAD_FILENEW_DOC,
    IDC_STATIC_HEADING, IDH_WORDPAD_FILENEW_DOC,
	0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CFileNewDialog dialog

CFileNewDialog::CFileNewDialog(CWnd* pParent /*=NULL*/)
	: CCSDialog(CFileNewDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFileNewDialog)
	m_nSel = -1;
	//}}AFX_DATA_INIT
}


void CFileNewDialog::DoDataExchange(CDataExchange* pDX)
{
	CCSDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFileNewDialog)
	DDX_Control(pDX, IDC_DATEDIALOG_LIST, m_listbox);
	DDX_LBIndex(pDX, IDC_DATEDIALOG_LIST, m_nSel);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFileNewDialog, CCSDialog)
	//{{AFX_MSG_MAP(CFileNewDialog)
	ON_LBN_DBLCLK(IDC_DATEDIALOG_LIST, OnDblclkDatedialogList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFileNewDialog message handlers

BOOL CFileNewDialog::OnInitDialog() 
{
	CCSDialog::OnInitDialog();

    static const struct
    {
        int     rdType;
        int     idsType;
    }
    FileTypes[] = 
    {
        {RD_RICHTEXT,    IDS_RTF_DOCUMENT},
        {RD_TEXT,        IDS_TEXT_DOCUMENT},
        {RD_UNICODETEXT, IDS_UNICODETEXT_DOCUMENT}
    };
 
	CString str;
    int     i;
    int     defType = CWordpadFileDialog::GetDefaultFileType();
    int     iSelected = 0;

    for (i = 0; i < sizeof(FileTypes)/sizeof(FileTypes[0]); i++)
    {
	    VERIFY(str.LoadString(FileTypes[i].idsType));
	    m_listbox.AddString(str);

        if (FileTypes[i].rdType == defType)
            iSelected = i; 
    }
    
	m_listbox.SetCurSel(iSelected);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CFileNewDialog::OnDblclkDatedialogList() 
{
	OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\filedlg.cpp ===
// filedlg.cpp : header file
//
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.
//
// This file is to support an extended file save dialog with a
// "Use this format by default" checkbox

#include "stdafx.h"
#include "wordpad.h"
#include "filedlg.h"
#include "ddxm.h"
#include "helpids.h"
#include <dlgs.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


DWORD const CWordpadFileDialog::m_nHelpIDs[] =
{
    IDC_DEFAULT_FORMAT, IDH_WORDPAD_DEFAULT_FORMAT,
    0, 0
};


int                  CWordpadFileDialog::m_defaultDoctype = RD_DEFAULT;



BEGIN_MESSAGE_MAP(CWordpadFileDialog, CFileDialog)
    //{{AFX_MSG_MAP(CWordpadFileDialog)
    ON_BN_CLICKED(IDC_DEFAULT_FORMAT, OnDefaultFormatClicked)
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE(WM_CONTEXTMENU, OnHelpContextMenu)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

IMPLEMENT_DYNAMIC(CWordpadFileDialog, CFileDialog)




CWordpadFileDialog::CWordpadFileDialog(BOOL bOpenFileDialog)
      : CFileDialog(bOpenFileDialog)
{
    m_ofn.Flags |= OFN_ENABLESIZING;

    if (!m_bOpenFileDialog)
    {
        m_ofn.Flags |= OFN_ENABLETEMPLATE;
        m_ofn.lpTemplateName = TEXT("DefaultFormatDialog");
    }

    m_doctype = GetDefaultFileType();
}



void CWordpadFileDialog::OnDefaultFormatClicked()
{
    if (m_bOpenFileDialog)
        return;

    m_doctype = GetTypeFromIndex(
                        m_openfilename.nFilterIndex - 1, 
                        m_bOpenFileDialog);

    GetDlgItem(IDC_DEFAULT_FORMAT)->EnableWindow(FALSE);

    // Move the focus to the filename combobox.
    GetParent()->GetDlgItem(cmb13)->SetFocus();
}



BOOL CWordpadFileDialog::OnFileNameOK()
{
    BOOL ret = CFileDialog::OnFileNameOK();

    if (!m_bOpenFileDialog)
    {
        // returns 0 if ok, 1 if not ok...
        if (0 == ret)
            SetDefaultFileType(m_doctype);
    }

    return ret;
}



void CWordpadFileDialog::OnTypeChange()
{
    CFileDialog::OnTypeChange();

    if (m_bOpenFileDialog)
        return;

    int type = GetTypeFromIndex(
                        m_openfilename.nFilterIndex - 1, 
                        m_bOpenFileDialog);

    CWnd *checkbox = GetDlgItem(IDC_DEFAULT_FORMAT);

    checkbox->SendMessage(
                        BM_SETCHECK,
                        (type == m_doctype)
                                ? BST_CHECKED
                                : BST_UNCHECKED,
                        0);

    checkbox->EnableWindow(!(type == m_doctype));

    // 
    // Change the extension of the filename presented to the user to match
    // the new type
    //

    // If the user has "Hide extensions of known types" set all this is moot
    SHELLFLAGSTATE flags;
    SHGetSettings(&flags, SSF_SHOWEXTENSIONS);
    if (!flags.fShowExtensions)
        return;

    CString filespec;

    CommDlg_OpenSave_GetSpec(
            GetParent()->GetSafeHwnd(), 
            filespec.GetBufferSetLength(MAX_PATH), 
            MAX_PATH);
    filespec.ReleaseBuffer();

    if (filespec.IsEmpty())
        return;

    CString extension = GetExtFromType(type);
    int     extstart  = filespec.ReverseFind(TEXT('.'));

    if (-1 == extstart)
        extstart = filespec.GetLength();

    if (filespec.Mid(extstart) == extension)
        return;

    filespec = filespec.Mid(0, extstart) + extension;

    CommDlg_OpenSave_SetControlText(
            GetParent()->GetSafeHwnd(),
            edt1,
            (LPCTSTR) filespec);
}



void CWordpadFileDialog::OnInitDone()
{
    CFileDialog::OnInitDone();

    if (m_bOpenFileDialog)
        return;

    OnTypeChange();
}



LONG CWordpadFileDialog::OnHelp(WPARAM, LPARAM lParam)
{
        ::WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                AfxGetApp()->m_pszHelpFilePath,
                HELP_WM_HELP, (DWORD_PTR)GetHelpIDs());
        return 0;
}

LONG CWordpadFileDialog::OnHelpContextMenu(WPARAM wParam, LPARAM)
{
        ::WinHelp((HWND)wParam, AfxGetApp()->m_pszHelpFilePath,
                HELP_CONTEXTMENU, (DWORD_PTR)GetHelpIDs());
        return 0;
}


//
// MFC assumes that when a common dialog is created, the first message that
// gets sent to it's common message handing procedure will be to that window.
// This isn't always true and although it attempts to handle this doesn't get
// it right every time.  Fix it, at least for file dialogs, by making a 
// private message procedure that does the necessary initialization and then
// calls the original
//

UINT_PTR CALLBACK CWordpadFileDialog::FileDialogHookProc(
        HWND   hWnd,
        UINT   message,
        WPARAM wParam,
        LPARAM lParam)
{
    CWordpadFileDialog *_this;

    if (WM_INITDIALOG == message)
    {
        _this = (CWordpadFileDialog *) ((OPENFILENAME *) lParam)->lCustData;
        _this->SubclassWindow(hWnd);
    }
                     
    _this = (CWordpadFileDialog *) CWnd::FromHandlePermanent(hWnd);

    if (NULL != _this)
        return (_this->m_original_hook)(hWnd, message, wParam, lParam);
    else
        return 0;
}


INT_PTR CWordpadFileDialog::DoModal()
{
    ASSERT_VALID(this);
    ASSERT(m_ofn.Flags & OFN_ENABLEHOOK);
    ASSERT(m_ofn.lpfnHook != NULL); // can still be a user hook
#ifdef _MAC
    ASSERT((m_ofn.Flags & OFN_ALLOWMULTISELECT) == 0);
#endif

    // WINBUG: This is a special case for the file open/save dialog,
    //  which sometimes pumps while it is coming up but before it has
    //  disabled the main window.
    HWND hWndFocus = ::GetFocus();
    BOOL bEnableParent = FALSE;
    m_ofn.hwndOwner = PreModal();
    AfxUnhookWindowCreate();
    if (m_ofn.hwndOwner != NULL && ::IsWindowEnabled(m_ofn.hwndOwner))
    {
        bEnableParent = TRUE;
        ::EnableWindow(m_ofn.hwndOwner, FALSE);
    }

    _AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
    ASSERT(pThreadState->m_pAlternateWndInit == NULL);

    m_original_hook = m_ofn.lpfnHook;
    m_ofn.lpfnHook = FileDialogHookProc;
    m_ofn.lCustData = (LPARAM) this;

    ZeroMemory(&m_openfilename, sizeof(m_openfilename));
    CopyMemory(&m_openfilename, &m_ofn, sizeof(m_ofn));
    m_openfilename.lStructSize = sizeof(m_openfilename);

    int nResult;
    if (m_bOpenFileDialog)
        nResult = ::GetOpenFileName((OPENFILENAME*) &m_openfilename);
    else
        nResult = ::GetSaveFileName((OPENFILENAME*) &m_openfilename);

    CopyMemory(&m_ofn, &m_openfilename, sizeof(m_ofn));
    m_ofn.lStructSize = sizeof(m_ofn);

    m_ofn.lpfnHook = m_original_hook;

    if (nResult)
        ASSERT(pThreadState->m_pAlternateWndInit == NULL);
    pThreadState->m_pAlternateWndInit = NULL;

    // WINBUG: Second part of special case for file open/save dialog.
    if (bEnableParent)
        ::EnableWindow(m_ofn.hwndOwner, TRUE);
    if (::IsWindow(hWndFocus))
        ::SetFocus(hWndFocus);

    PostModal();
    return nResult ? nResult : IDCANCEL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\doctype.cpp ===
// doctype.cpp
//
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.

#include "stdafx.h"
#include "resource.h"
#include "strings.h"

#include "multconv.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static const BYTE byteRTFPrefix[5] = {'{', '\\', 'r', 't', 'f'};
static const BYTE byteWord2Prefix[4] = {0xDB, 0xA5, 0x2D, 0x00};
static const BYTE byteCompFilePrefix[8] = {0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1};
static const BYTE byteWrite1Prefix[2] = {0x31, 0xBE};
static const BYTE byteWrite2Prefix[2] = {0x32, 0xBE};
static const BYTE byteWord5JPrefix[2] = {0x94, 0xA6};
static const BYTE byteWord5KPrefix[2] = {0x95, 0xA6};
static const BYTE byteWord5TPrefix[2] = {0x96, 0xA6};

//
// On Win64 the converters live in the same directory as Wordpad.
// On Win32 things are more complicated.  For Win2000 and Whistler they live
// in a location pointed to by the registry
//

#ifdef _WIN64

TCHAR szWordConverter[MAX_PATH] = TEXT("mswrd664.wpc");
TCHAR szWriteConverter[MAX_PATH] = TEXT("write64.wpc");
TCHAR szWord97Converter[MAX_PATH] = TEXT("mswrd864.wpc");

#define CONVERTERS_IN_WORDPAD_DIRECTORY

#else   // WIN32
//
// Registry paths to converter information.  Note that the array sizes must be
// at least MAX_PATH because the contents of the array will be replaced with
// the filesystem path in ScanForConverters.
//

#define CONVERTER_PATH(x) TEXT("Software\\Microsoft\\Shared Tools\\")   \
                            TEXT("Text Converters\\Import\\") TEXT(x)

TCHAR szWordConverter[MAX_PATH] = CONVERTER_PATH("MSWord6.wpc");
TCHAR szWriteConverter[MAX_PATH] = CONVERTER_PATH("MSWinWrite.wpc");
TCHAR szWord97Converter[MAX_PATH] = CONVERTER_PATH("MSWord8");

#undef CONVERTER_PATH

#endif // WIN32

int RD_DEFAULT = RD_RICHTEXT;

/////////////////////////////////////////////////////////////////////////////

static BOOL IsConverterFormat(LPCTSTR pszConverter, LPCTSTR pszPathName);

DocType doctypes[NUM_DOC_TYPES] =
{
    DECLARE_DOCTYPE(WINWORD2, FALSE, FALSE, FALSE, NULL, 0),
    DECLARE_DOCTYPE(WINWORD6, TRUE, FALSE, FALSE, szWordConverter, ARRAYSIZE(szWordConverter)),
    DECLARE_DOCTYPE(WORD97, TRUE, FALSE, FALSE, szWord97Converter, ARRAYSIZE(szWord97Converter)),
    DECLARE_DOCTYPE_SYN(WORDPAD, RICHTEXT, TRUE, TRUE, TRUE, NULL),
    DECLARE_DOCTYPE(WRITE, TRUE, FALSE, FALSE, szWriteConverter, ARRAYSIZE(szWriteConverter)),
    DECLARE_DOCTYPE(RICHTEXT, TRUE, TRUE, FALSE, NULL, 0),
    DECLARE_DOCTYPE(TEXT, TRUE, TRUE, FALSE, NULL, 0),
    DECLARE_DOCTYPE(OEMTEXT, TRUE, TRUE, FALSE, NULL, 0),
    DECLARE_DOCTYPE(UNICODETEXT, TRUE, TRUE, FALSE, NULL, 0),
    DECLARE_DOCTYPE(ALL, TRUE, FALSE, FALSE, NULL, 0),
    DECLARE_DOCTYPE_NULL(EMBEDDED, FALSE, FALSE, FALSE, NULL)
};

CString DocType::GetString(int nID)
{
    ASSERT(idStr != NULL);
    CString str;
    VERIFY(str.LoadString(idStr));
    CString strSub;
    AfxExtractSubString(strSub, str, nID);
    return strSub;
}

static BOOL IsConverterFormat(LPCTSTR pszConverter, LPCTSTR pszPathName)
{
    CConverter conv(pszConverter);
    return conv.IsFormatCorrect(pszPathName);
}

static BOOL IsLeadMatch(CFile& file, const BYTE* pb, UINT nCount)
{
    // check for match at beginning of file
    BOOL b = FALSE;
    BYTE* buf = new BYTE[nCount];
    
    TRY
    {
        file.SeekToBegin();
        memset(buf, 0, nCount);
        file.Read(buf, nCount);
        if (memcmp(buf, pb, nCount) == 0)
            b = TRUE;
    }
    END_TRY

    delete [] buf;
    return b;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetDocTypeFromName
//
//  Synopsis:   Give a filename, determine what sort of document it is
//  
//  Parameters: [pszPathName]   -- The filename
//              [fe]            -- Exception that caused file.open to fail
//              [defaultToText] -- See notes below
//
//  Returns:    The file type or -1 for unknown/error
//
//  Notes:      The converters don't support Unicode but the filenames do.
//              This causes problems because even though the initial check
//              for file existance will succeed the converter will be unable
//              to load the file.  We get around this by trying to load the
//              file a second time using the shortname.  However, the behavior
//              if we can't load the file as it's native type is to load it as
//              a text file.  [defaultToText] is used to suppress this on the
//              first try so we know to try again.
//
//----------------------------------------------------------------------------

int GetDocTypeFromName(
        LPCTSTR pszPathName, 
        CFileException& fe, 
        bool defaultToText)
{
    CFile file;
    ASSERT(pszPathName != NULL);
    
    ScanForConverters();

    if (!file.Open(pszPathName, CFile::modeRead | CFile::shareDenyWrite, &fe))
        return -1;

    CFileStatus _stat;
    VERIFY(file.GetStatus(_stat));

    if (_stat.m_size == 0) // file is empty
    {
        CString ext = CString(pszPathName).Right(4);
        if (ext[0] != '.')
            return RD_TEXT;
        if (lstrcmpi(ext, _T(".doc"))==0)
            return RD_WORDPAD;
        if (lstrcmpi(ext, _T(".rtf"))==0)
            return RD_RICHTEXT;
        return RD_TEXT;
    }

    // RTF
    if (IsLeadMatch(file, byteRTFPrefix, sizeof(byteRTFPrefix)))
        return RD_RICHTEXT;

    // WORD 2
    if (IsLeadMatch(file, byteWord2Prefix, sizeof(byteWord2Prefix)))
        return RD_WINWORD2;
    
    // FarEast Word5, which is based on US Word 2
    if (IsLeadMatch(file, byteWord5JPrefix, sizeof(byteWord5JPrefix)) ||
        IsLeadMatch(file, byteWord5KPrefix, sizeof(byteWord5KPrefix)) ||
        IsLeadMatch(file, byteWord5TPrefix, sizeof(byteWord5TPrefix)))
    {
        return RD_FEWINWORD5;
    }
    
    // write file can start with 31BE or 32BE depending on whether it has
    // OLE objects in it or not
    if (IsLeadMatch(file, byteWrite1Prefix, sizeof(byteWrite1Prefix)) ||
        IsLeadMatch(file, byteWrite2Prefix, sizeof(byteWrite2Prefix)))
    {
        file.Close();
        if (IsConverterFormat(szWriteConverter, pszPathName))
            return RD_WRITE;
        else if (defaultToText)
            return RD_TEXT;
        else 
            return -1;
    }

    // test for compound file
    if (IsLeadMatch(file, byteCompFilePrefix, sizeof(byteCompFilePrefix)))
    {
        file.Close();

        if (IsConverterFormat(szWordConverter, pszPathName))
        {
            return RD_WINWORD6;
        }
        else if (IsConverterFormat(szWord97Converter, pszPathName))
        {
            return RD_WORD97;
        }
        else if (defaultToText)
        {
            return RD_TEXT;
        }
        
        return -1;
    }

    //
    // If we get here we know the file exists but it is NOT any of the above
    // types.  Therefore it is either a text file or we need to open it as
    // a text file.  Either way we are justified in returning RD_TEXT
    // regardless of the defaultToText setting.
    //

    return RD_TEXT;
}

// Some document converters have buffer overrun potentials in them.
// For security reasons, these are turned off by default. There is a registry override
// so customers that need access to old file formats can still have them.
//
BOOL DocTypeDisabled(int nDocType)
{
    BOOL bDisabled = FALSE;

    if (RD_WINWORD6 == nDocType || RD_WRITE == nDocType)
    {
        bDisabled = TRUE;

        DWORD dwEnabled;
        DWORD cb = sizeof(dwEnabled);

        if (ERROR_SUCCESS == SHRegGetValue(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Wordpad", L"EnableLegacyConverters", SRRF_RT_REG_DWORD, NULL, &dwEnabled, &cb))
        {
            bDisabled = (0 == dwEnabled);
        }
        else
        {
            cb = sizeof(dwEnabled);
            if (ERROR_SUCCESS == SHRegGetValue(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Wordpad", L"EnableLegacyConverters", SRRF_RT_REG_DWORD, NULL, &dwEnabled, &cb))
            {
                bDisabled = (0 == dwEnabled);
            }
        }
    }

    return bDisabled;
}

//+--------------------------------------------------------------------------
//
//  Function:   ScanForConverters
//
//  Synopsis:   Check for any text converters
//
//  Parameters: None
//  
//  Returns:    void
//
//  Notes:      This routine will update the entries in the global doctypes
//              structure.  It should be called before trying to use the
//              converters.  The code will only run once, even if it is called
//              multiple times.
//
//              The doctypes structure is expected to be initialized with the
//              registry path to the converter.  This path is replaced with 
//              the filesystem path or NULL if an error occurs.
//
//---------------------------------------------------------------------------

void ScanForConverters()
{
#ifdef _DEBUG
#define TRACE_ERROR(error, api, string)                                     \
        {if (ERROR_SUCCESS != error)                                        \
                TRACE(                                                      \
                    TEXT("Wordpad: error 0x%08x from %s looking for")       \
                                    TEXT("\r\n\t%s\r\n"),                   \
                    error,                                                  \
                    api,                                                    \
                    string);                                                \
        }
#else // !_DEBUG
#define TRACE_ERROR(error, api, string)
#endif // !_DEBUG

    static BOOL bScanned = FALSE;

    if (bScanned)
        return;
    
    TCHAR   szExpandedPath[MAX_PATH];
    DWORD   error = ERROR_SUCCESS;

    for (int i = 0; i < NUM_DOC_TYPES; i++)
    {
        //
        // If this type is a duplicate of some other type don't try to search
        // for the converter twice
        //

        if (doctypes[i].bDup)
            continue;

        LPCTSTR pszConverterKey = doctypes[i].pszConverterName;

        if (NULL != pszConverterKey)
        {
#ifndef CONVERTERS_IN_WORDPAD_DIRECTORY // Varies depending on whether we build x86 or ia64.

            DWORD   cbConverterPath = sizeof(szExpandedPath);
            HKEY    keyConverter;


            error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                 pszConverterKey,
                                 0,
                                 KEY_READ,
                                 &keyConverter);
    
            TRACE_ERROR(error, TEXT("RegOpenKeyEx"), pszConverterKey);

            if (ERROR_SUCCESS == error)
            {            
                error = SHRegGetValue(keyConverter, NULL, L"Path", SRRF_RT_REG_SZ, NULL, szExpandedPath, &cbConverterPath);

                TRACE_ERROR(error, TEXT("RegQueryValueEx"), L"Path");

                RegCloseKey(keyConverter);
#else

            int     chars = GetModuleFileName(NULL, szExpandedPath, ARRAYSIZE(szExpandedPath));
            LPTSTR  pszConverterName = NULL;

            if (0 != chars)
                pszConverterName = PathFindFileName(szExpandedPath);

            if (NULL != pszConverterName)
            {
                *pszConverterName = 0; // Remove the filename from the path.

                error = HRESULT_CODE(StringCchCat(szExpandedPath, ARRAYSIZE(szExpandedPath), doctypes[i].pszConverterName));
#endif
                                    
                if (ERROR_SUCCESS == error)
                {
                    //
                    // The FILE_ATTRIBUTE_DIRECTORY bit will also be set if an
                    // error occurs - like file not found.
                    //

                    error = GetFileAttributes(szExpandedPath)
                                & FILE_ATTRIBUTE_DIRECTORY;

                    TRACE_ERROR(
                        error, 
                        TEXT("GetFileAttribytes"), 
                        szExpandedPath);
                }
            }

            if (ERROR_SUCCESS == error)
            {
                error = HRESULT_CODE(StringCchCopy(doctypes[i].pszConverterName, doctypes[i].cchConverterName, szExpandedPath));
            }

            if (ERROR_SUCCESS != error) // Something went wrong.
            {
                doctypes[i].pszConverterName = NULL;
            }
        }
    }

    bScanned = TRUE;
}

CString GetExtFromType(int nDocType)
{
    ScanForConverters();

    CString str = doctypes[nDocType].GetString(DOCTYPE_EXT);
    if (!str.IsEmpty())
    {
        ASSERT(str.GetLength() == 5); // "*.ext"
        ASSERT(str[1] == '.');
        return str.Right(str.GetLength()-1);
    }
    return str;
}

// returns an RD_* from an index into the openfile dialog types
int GetTypeFromIndex(int nIndex, BOOL bOpen)
{
    ScanForConverters();

    //
    // Word97 is excluded from the list of open file types in GetFileTypes.
    // Make up for it here.
    //

    if (bOpen)
        ++nIndex;

    int nCnt = 0;
    for (int i=0;i<NUM_DOC_TYPES;i++)
    {
        if (!doctypes[i].bDup &&
            (bOpen ? doctypes[i].bRead : doctypes[i].bWrite))
        {
            if (nCnt == nIndex)
                return i;
            nCnt++;
        }
    }
    ASSERT(FALSE);
    return -1;
}

// returns an index into the openfile dialog types for the RD_* type
int GetIndexFromType(int nType, BOOL bOpen)
{
    ScanForConverters();

    int nCnt = 0;
    for (int i=0;i<NUM_DOC_TYPES;i++)
    {
        if (!doctypes[i].bDup &&
            (bOpen ? doctypes[i].bRead : doctypes[i].bWrite))
        {
            if (i == nType)
                return nCnt;
            nCnt++;
        }
    }
    return -1;
}

CString GetFileTypes(BOOL bOpen)
{
    ScanForConverters();

    CString str;
    for (int i=0;i<NUM_DOC_TYPES;i++)
    {
        if (bOpen && doctypes[i].bRead 
            && !doctypes[i].bDup 
            && !(RD_WORD97 == doctypes[i].nID))
        {
            str += doctypes[i].GetString(DOCTYPE_DESC);
            str += (TCHAR)NULL;
            str += doctypes[i].GetString(DOCTYPE_EXT);
            str += (TCHAR)NULL;
        }
        else if (!bOpen && doctypes[i].bWrite && !doctypes[i].bDup)
        {
            str += doctypes[i].GetString(DOCTYPE_DOCTYPE);
            str += (TCHAR)NULL;
            str += doctypes[i].GetString(DOCTYPE_EXT);
            str += (TCHAR)NULL;
        }
    }
    return str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\doctype.h ===
// doctype.h : header file
//
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.

#define RD_WINWORD2     0
#define RD_WINWORD6     1
#define RD_WORD97       2
#define RD_WORDPAD      3
#define RD_WRITE        4
#define RD_RICHTEXT     5
#define RD_TEXT         6
#define RD_OEMTEXT      7
#define RD_UNICODETEXT  8
#define RD_ALL          9
#define RD_EMBEDDED    10
#define RD_FEWINWORD5  11
#define NUM_DOC_TYPES  12

// Validates that iFormat is one of the above types, and if not, returns iDefault.
inline int _VerifyDefaultFormat(int iFormat, int iDefault)
{
    int iFormatRet = iFormat;
    if ((iFormat < 0) || (iFormat >= NUM_DOC_TYPES))
    {
        iFormatRet = iDefault;
    }
    return iFormatRet;
}


extern int RD_DEFAULT;
#define RD_NATIVE RD_RICHTEXT

typedef BOOL (*PISFORMATFUNC)(LPCSTR pszConverter, LPCSTR pszPathName);
inline BOOL IsTextType(int nType) 
{
    return ((nType==RD_TEXT) || (nType==RD_OEMTEXT) || (nType==RD_UNICODETEXT));
}

struct DocType
{
public:
    int nID;
    int idStr;
    BOOL bRead;
    BOOL bWrite;
    BOOL bDup;
    LPTSTR pszConverterName;
    int cchConverterName;
    CString GetString(int nID);
};

#define DOCTYPE_DOCTYPE 0
#define DOCTYPE_DESC 1
#define DOCTYPE_EXT 2
#define DOCTYPE_PROGID 3

#define DECLARE_DOCTYPE(name, b1, b2, b3, p, cch) \
{RD_##name, IDS_##name##_DOC, b1, b2, b3, p, cch}
#define DECLARE_DOCTYPE_SYN(actname, name, b1, b2, b3, p) \
{RD_##actname, IDS_##name##_DOC, b1, b2, b3, p}
#define DECLARE_DOCTYPE_NULL(name, b1, b2, b3, p) \
{RD_##name, NULL, b1, b2, b3, p}

extern DocType doctypes[NUM_DOC_TYPES];

int GetDocTypeFromName(
        LPCTSTR         pszPathName, 
        CFileException& fe, 
        bool            defaultToText = true);

BOOL DocTypeDisabled(int nDocType);

#define NO_DEFAULT_TO_TEXT false

void ScanForConverters();
int GetIndexFromType(int nType, BOOL bOpen);
int GetTypeFromIndex(int nType, BOOL bOpen);
CString GetExtFromType(int nDocType);
CString GetFileTypes(BOOL bOpen);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\filenewd.h ===
// filenewd.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CFileNewDialog dialog

class CFileNewDialog : public CCSDialog
{
// Construction
public:
	CFileNewDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CFileNewDialog)
	enum { IDD = IDD_FILENEWDIALOG };
	CListBox	m_listbox;
	int		m_nSel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFileNewDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}

	// Generated message map functions
	//{{AFX_MSG(CFileNewDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnDblclkDatedialogList();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\fixhelp.cpp ===
// fixhelp.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "fixhelp.h"

BOOL g_fDisableStandardHelp = FALSE ;

HHOOK g_HelpFixHook = NULL;

LRESULT CALLBACK HelpFixControlProc(
    HWND  hwnd,
    UINT  uMsg,
    WPARAM wParam,
    LPARAM  lParam);

LRESULT CALLBACK HelpFixDialogProc(
    HWND  hwnd,
    UINT  uMsg,
    WPARAM wParam,
    LPARAM  lParam);

LRESULT CALLBACK HelpFixHook(
    int code,
    WPARAM wParam,
    LPARAM lParam) ;

class CWordPadCWnd : public CWnd
{
public:

	LRESULT CallDWP(UINT nMsg, WPARAM wParam, LPARAM lParam)
   {
	    return DefWindowProc(nMsg, wParam, lParam) ;
   }
} ;

void FixHelp(CWnd* pWnd, BOOL fFixWndProc)
{
    //
    // Subclass the main window proc if we are supposed to
	// and if MFC has alread subclassed it
    //

    if (fFixWndProc)
    {
        if (GetWindowLongPtr(pWnd->m_hWnd, GWLP_WNDPROC) == (LONG_PTR)AfxWndProc)
	     {
              SetWindowLongPtr(pWnd->m_hWnd, GWLP_WNDPROC,
                               (LONG_PTR)HelpFixDialogProc);
	     }
    }

	//
    // Search all child windows.  If their window proc
    // is AfxWndProc, then subclass with our window proc
	//

    CWnd* pWndChild = pWnd->GetWindow(GW_CHILD);
    while(pWndChild != NULL)
    {
        if (GetWindowLongPtr(pWndChild->GetSafeHwnd(), GWLP_WNDPROC) == (LONG_PTR)AfxWndProc)
        {
            SetWindowLongPtr(pWndChild->GetSafeHwnd(), GWLP_WNDPROC,
                              (LONG_PTR)HelpFixControlProc);
        }
        pWndChild = pWndChild->GetWindow(GW_HWNDNEXT);
    }
}

LRESULT CALLBACK HelpFixControlProc(
    HWND  hwnd,
	UINT  uMsg,
	WPARAM wParam,
    LPARAM  lParam)
{
    if (uMsg == WM_HELP)
    {
		//
        // bypass MFC's handler, message will be sent to
		// parent of the control
		//

        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return AfxWndProc(hwnd,uMsg,wParam,lParam);
}

LRESULT CALLBACK HelpFixDialogProc(
    HWND  hwnd,
	UINT  uMsg,
	WPARAM wParam,
    LPARAM  lParam)
{
    if (uMsg == WM_HELP)
    {
		CWordPadCWnd* pWnd = (CWordPadCWnd *) CWnd::FromHandlePermanent(hwnd) ;

		//
        // bypass MFC's handler, message will be sent to window proc for
		// the dialog box
		//

		if (NULL != pWnd)
		{
            return pWnd->CallDWP(uMsg, wParam, lParam) ;
		}
    }
    return AfxWndProc(hwnd,uMsg,wParam,lParam);
}


void SetHelpFixHook(void)
{
   g_HelpFixHook = ::SetWindowsHookEx(
                        WH_CALLWNDPROC,
                        (HOOKPROC) HelpFixHook,
                        NULL,
                        ::GetCurrentThreadId());
}

void RemoveHelpFixHook(void)
{
    if (NULL != g_HelpFixHook)
        ::UnhookWindowsHookEx(g_HelpFixHook);

    g_HelpFixHook = NULL;
}

LRESULT CALLBACK HelpFixHook(
    int code,
    WPARAM wParam,
    LPARAM lParam)
{
    if (code < 0)
    {
        return ::CallNextHookEx(
                   g_HelpFixHook,
                   code,
                   wParam,
                   lParam) ;
    }

    CWPSTRUCT *pcwps = (CWPSTRUCT *) lParam ;

    if (pcwps->message == WM_INITDIALOG)
    {
        CWnd *pWnd = CWnd::FromHandlePermanent(pcwps->hwnd) ;

        if (pWnd != NULL)
        {
            FixHelp(pWnd, TRUE) ;
        }
    }

    return ::CallNextHookEx(
                g_HelpFixHook,
                code,
                wParam,
                lParam) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\formatba.cpp ===
// formatba.cpp : implementation file
//
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.

#include "stdafx.h"

#include "wordpad.h"
#include "wordpdoc.h"
#include "wordpvw.h"
#include "formatba.h"
#include "strings.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// reserve lobyte for charset
#define PRINTER_FONT 0x0100
#define TT_FONT 0x0200
#define DEVICE_FONT 0x0400
#define PS_OPENTYPE_FONT  0x800
#define TT_OPENTYPE_FONT  0x1000
#define TYPE1_FONT  0x2000

#define BMW 16
#define BMH 15

static int nFontSizes[] =
    {8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72};
int CLocalComboBox::m_nFontHeight = 0;

class CFontDesc
{
public:
    CFontDesc(LPCTSTR lpszName, LPCTSTR lpszScript, BYTE nCharSet,
        BYTE nPitchAndFamily, DWORD dwFlags);
    CString m_strName;
    CString m_strScript;
    BYTE m_nCharSet;
    BYTE m_nPitchAndFamily;
    DWORD m_dwFlags;
};

CFontDesc::CFontDesc(LPCTSTR lpszName, LPCTSTR lpszScript, BYTE nCharSet,
    BYTE nPitchAndFamily, DWORD dwFlags)
{
    m_strName = lpszName;
    m_strScript = lpszScript;
    m_nCharSet = nCharSet;
    m_nPitchAndFamily = nPitchAndFamily;
    m_dwFlags = dwFlags;
}

BEGIN_MESSAGE_MAP(CFormatBar, CToolBar)
    //{{AFX_MSG_MAP(CFormatBar)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
    ON_CBN_DROPDOWN(IDC_FONTSIZE, OnFontSizeDropDown)
    ON_CBN_DROPDOWN(IDC_SCRIPT, OnScriptDropDown)
    ON_CBN_KILLFOCUS(IDC_FONTNAME, OnFontNameKillFocus)
    ON_CBN_KILLFOCUS(IDC_FONTSIZE, OnFontSizeKillFocus)
    ON_CBN_KILLFOCUS(IDC_SCRIPT, OnScriptKillFocus)
    ON_CBN_SETFOCUS(IDC_FONTNAME, OnComboSetFocus)
    ON_CBN_SETFOCUS(IDC_FONTSIZE, OnComboSetFocus)
    ON_CBN_SETFOCUS(IDC_SCRIPT, OnComboSetFocus)
    ON_CBN_CLOSEUP(IDC_FONTNAME, OnComboCloseUp)
    ON_CBN_CLOSEUP(IDC_FONTSIZE, OnComboCloseUp)
    ON_CBN_CLOSEUP(IDC_SCRIPT, OnComboCloseUp)
    ON_REGISTERED_MESSAGE(CWordPadApp::m_nPrinterChangedMsg, OnPrinterChanged)
    // Global help commands
END_MESSAGE_MAP()

static CSize GetBaseUnits(CFont* pFont)
{
    ASSERT(pFont != NULL);
    ASSERT(pFont->GetSafeHandle() != NULL);
    pFont = theApp.m_dcScreen.SelectObject(pFont);
    TEXTMETRIC tm;
    VERIFY(theApp.m_dcScreen.GetTextMetrics(&tm));

    theApp.m_dcScreen.SelectObject(pFont);
    return CSize(tm.tmAveCharWidth, tm.tmHeight);
}

CFormatBar::CFormatBar()
{
    CFont fnt;
    fnt.Attach(GetStockObject(theApp.m_nDefFont));
    m_szBaseUnits = GetBaseUnits(&fnt);
    CLocalComboBox::m_nFontHeight = m_szBaseUnits.cy;
}

void CFormatBar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
    CToolBar::OnUpdateCmdUI(pTarget, bDisableIfNoHndler);
    // don't update combo boxes if any of them have the focus
    if (!m_comboFontName.HasFocus()
        && !m_comboFontSize.HasFocus()
        && !m_comboScript.HasFocus())
    {
        SyncToView();
    }
}

void CFormatBar::SyncToView()
{
    USES_CONVERSION;
    // get the current font from the view and update
    CHARHDR fh;
    CHARFORMAT& cf = fh.cf;
    fh.hwndFrom = m_hWnd;
    fh.idFrom = GetDlgCtrlID();
    fh.code = FN_GETFORMAT;
    VERIFY(GetOwner()->SendMessage(WM_NOTIFY, fh.idFrom, (LPARAM)&fh));

    if (cf.dwMask & CFM_FACE)
        m_comboFontName.SetTheText(cf.szFaceName, TRUE);
    else
        m_comboFontName.SetTheText(TEXT(""));

    CString charsetname = TEXT("");
    if (cf.dwMask & CFM_CHARSET)
    {
        for (int i = 0; i < m_comboFontName.m_arrayFontDesc.GetSize(); i++)
        {
            CFontDesc *pDesc = (CFontDesc *) m_comboFontName.m_arrayFontDesc[i];

            if (pDesc->m_strName == cf.szFaceName
                && pDesc->m_nCharSet == cf.bCharSet)
            {
                charsetname = pDesc->m_strScript;
                break;
            }
        }
    }
    m_comboScript.SetTheText(charsetname);

    static bool init_script_history = true;

    if (init_script_history && TEXT('\0') != charsetname[0])
    {
        OnScriptDropDown();
        m_comboScript.PickScript();
        init_script_history = false;
    }

    // SetTwipSize only updates if different
    // -1 means selection is not a single point size
    m_comboFontSize.SetTwipSize( (cf.dwMask & CFM_SIZE) ? cf.yHeight : -1);
}

BYTE CScriptComboBox::PickScript()
{
    CString scriptname;
    int     scriptindex;

    GetTheText(scriptname);
    scriptindex = FindStringExact(-1, scriptname);

    if (CB_ERR == scriptindex)
    {
        int  i = m_history_index;

        do
        {
            scriptindex = FindStringExact(-1, m_script_history[i]);

            if (CB_ERR != scriptindex)
                break;

            i = (i + HistorySize - 1) % HistorySize;
        }
        while (i != m_history_index);

        if (CB_ERR == scriptindex)
        {
            if (1 != GetCount())
            {
                SetCurSel(-1);
                return DEFAULT_CHARSET;
            }

            scriptindex = 0;
        }

        SetCurSel(scriptindex);
        GetTheText(scriptname);
    }

    if (m_script_history[m_history_index] != scriptname)
    {
        m_history_index = (m_history_index + 1) % HistorySize;
        m_script_history[m_history_index] = scriptname;
    }

    return (BYTE) GetItemData(scriptindex);
}

void CFormatBar::OnFontSizeDropDown()
{
    CString str;
    m_comboFontName.GetTheText(str);
    LPCTSTR lpszName = NULL;
    BOOL bPrinterFont= FALSE;
    int nIndex = m_comboFontName.FindStringExact(-1, str);
    if (nIndex != CB_ERR)
    {
        CFontDesc* pDesc = (CFontDesc*)m_comboFontName.GetItemData(nIndex);
        ASSERT(pDesc != NULL);
        bPrinterFont = pDesc->m_dwFlags & PRINTER_FONT;
        lpszName = pDesc->m_strName;
    }

    int nSize = m_comboFontSize.GetTwipSize();
    if (nSize == -2) // error
    {
        AfxMessageBox(IDS_INVALID_NUMBER, MB_OK|MB_ICONINFORMATION);
        nSize = m_comboFontSize.m_nTwipsLast;
    }
    else if ((nSize >= 0 && nSize < 20) || nSize > 32760)
    {
        AfxMessageBox(IDS_INVALID_FONTSIZE, MB_OK|MB_ICONINFORMATION);
        nSize = m_comboFontSize.m_nTwipsLast;
    }

    if (bPrinterFont)
        m_comboFontSize.EnumFontSizes(m_dcPrinter, lpszName);
    else
        m_comboFontSize.EnumFontSizes(theApp.m_dcScreen, lpszName);
    m_comboFontSize.SetTwipSize(nSize);
}

void CFormatBar::OnScriptDropDown()
{
    CString fontname;
    CString scriptname;
    m_comboFontName.GetTheText(fontname);
    m_comboScript.GetTheText(scriptname);

    m_comboScript.ResetContent();
    m_comboScript.SetTheText(scriptname);

    for (int i = 0; i < m_comboFontName.m_arrayFontDesc.GetSize(); i++)
    {
        CFontDesc* pDesc = (CFontDesc*)m_comboFontName.m_arrayFontDesc[i];

        if (pDesc->m_strName == fontname)
        {
            // HACKHACK: GDI enumerates symbol type fonts multiple times.
            //           remove the duplicated charsets (ntbug:198753)

            if (CB_ERR == m_comboScript.FindStringExact(-1, pDesc->m_strScript))
            {
                int nIndex = m_comboScript.AddString(pDesc->m_strScript);
                m_comboScript.SetItemData(nIndex, pDesc->m_nCharSet);
            }
        }
    }
}

void CFormatBar::OnComboCloseUp()
{
    NotifyOwner(NM_RETURN);
}

void CFormatBar::OnComboSetFocus()
{
    NotifyOwner(NM_SETFOCUS);
}

void CFormatBar::OnFontNameKillFocus()
{
    USES_CONVERSION;
    // get the current font from the view and update
    NotifyOwner(NM_KILLFOCUS);

    CCharFormat cf;
    cf.szFaceName[0] = NULL;

    // this will retrieve the font entered in the edit control
    // it tries to match the font to something already present in the combo box
    // this effectively ignores case of a font the user enters
    // if a user enters arial, this will cause it to become Arial
    CString str;
    m_comboFontName.GetTheText(str);    // returns "arial"
    m_comboFontName.SetTheText(str);    // selects "Arial"
    m_comboFontName.GetTheText(str);    // returns "Arial"

    // if font name box is not empty
    if (str[0] != NULL)
    {
        cf.dwMask = CFM_FACE;
        int nIndex = m_comboFontName.FindStringExact(-1, str);
        if (nIndex != CB_ERR)
        {
            CFontDesc* pDesc = (CFontDesc*)m_comboFontName.GetItemData(nIndex);
            ASSERT(pDesc != NULL);
            EVAL(StringCchCopy(cf.szFaceName, ARRAYSIZE(cf.szFaceName), pDesc->m_strName) == S_OK);
            cf.bPitchAndFamily = pDesc->m_nPitchAndFamily;
        }
        else // unknown font
        {
            EVAL(StringCchCopy(cf.szFaceName, ARRAYSIZE(cf.szFaceName), str) == S_OK);
            cf.bPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
        }

        OnScriptDropDown();
        cf.bCharSet = m_comboScript.PickScript();
        cf.dwMask |= CFM_CHARSET;
        SetCharFormat(cf);
    }
}

void CFormatBar::OnFontSizeKillFocus()
{
    NotifyOwner(NM_KILLFOCUS);
    int nSize = m_comboFontSize.GetTwipSize();
    if (nSize == -2)
    {
        AfxMessageBox(IDS_INVALID_NUMBER, MB_OK|MB_ICONINFORMATION);
        nSize = m_comboFontSize.m_nTwipsLast;
    }
    else if ((nSize >= 0 && nSize < 20) || nSize > 32760)
    {
        AfxMessageBox(IDS_INVALID_FONTSIZE, MB_OK|MB_ICONINFORMATION);
        nSize = m_comboFontSize.m_nTwipsLast;
    }
    else if (nSize > 0)
    {
        CCharFormat cf;
        cf.dwMask = CFM_SIZE;
        cf.yHeight = nSize;
        SetCharFormat(cf);
    }
}

void CFormatBar::OnScriptKillFocus()
{
    NotifyOwner(NM_KILLFOCUS);

    CString str;
    m_comboScript.GetTheText(str);
    m_comboScript.SetTheText(str);
    m_comboScript.GetTheText(str);

    if (str[0] != NULL)
    {
        CCharFormat cf;
        cf.dwMask = CFM_CHARSET;
        cf.bCharSet = m_comboScript.PickScript();
        SetCharFormat(cf);
    }
}

LONG CFormatBar::OnPrinterChanged(UINT, LONG)
{
    theApp.CreatePrinterDC(m_dcPrinter);
    m_comboFontName.EnumFontFamiliesEx(m_dcPrinter);
    return 0;
}

int CFormatBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CToolBar::OnCreate(lpCreateStruct) == -1)
        return -1;

    theApp.m_listPrinterNotify.AddTail(m_hWnd);

    CRect rect(0,0, LF_FACESIZE*m_szBaseUnits.cx, 200);
    if (!m_comboFontName.Create(WS_TABSTOP|WS_VISIBLE|WS_TABSTOP|
        WS_VSCROLL|CBS_DROPDOWN|CBS_SORT|CBS_AUTOHSCROLL|CBS_HASSTRINGS|
        CBS_OWNERDRAWFIXED, rect, this, IDC_FONTNAME))
    {
        TRACE0("Failed to create fontname combo-box\n");
        return -1;
    }
    m_comboFontName.LimitText(LF_FACESIZE);

    rect.SetRect(0, 0, 10*m_szBaseUnits.cx, 200);
    if (!m_comboFontSize.Create(WS_TABSTOP|WS_VISIBLE|WS_TABSTOP|
        WS_VSCROLL|CBS_DROPDOWN, rect, this, IDC_FONTSIZE))
    {
        TRACE0("Failed to create fontsize combo-box\n");
        return -1;
    }

    rect.SetRect(0, 0, 3*LF_FACESIZE*m_szBaseUnits.cx/4, 200);
    if (!m_comboScript.Create(WS_TABSTOP|WS_VISIBLE|WS_TABSTOP|
        WS_VSCROLL|CBS_DROPDOWN|CBS_SORT|CBS_AUTOHSCROLL|CBS_HASSTRINGS,
        rect, this, IDC_SCRIPT))
    {
        TRACE0("Failed to create script combo-box\n");
        return -1;
    }

    m_comboFontSize.LimitText(4);
    m_comboFontName.EnumFontFamiliesEx(m_dcPrinter);

    return 0;
}

void CFormatBar::OnDestroy()
{
    CToolBar::OnDestroy();
    POSITION pos = theApp.m_listPrinterNotify.Find(m_hWnd);
    ASSERT(pos != NULL);
    theApp.m_listPrinterNotify.RemoveAt(pos);
}

void CFormatBar::PositionCombos()
{
    CRect rect;
    // make font name box same size as font size box
    // this is necessary since font name box is owner draw
    m_comboFontName.SetItemHeight(-1, m_comboFontSize.GetItemHeight(-1));

    m_comboFontName.GetWindowRect(&rect);
    int nHeight = rect.Height();

    m_comboFontName.GetWindowRect(&rect);
    SetButtonInfo(0, IDC_FONTNAME, TBBS_SEPARATOR, rect.Width());
    GetItemRect(0, &rect); // FontName ComboBox
    m_comboFontName.SetWindowPos(NULL, rect.left,
        ((rect.Height() - nHeight) / 2) + rect.top, 0, 0,
        SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    m_comboFontSize.GetWindowRect(&rect);
    SetButtonInfo(2, IDC_FONTSIZE, TBBS_SEPARATOR, rect.Width());
    GetItemRect(2, &rect); // FontSize ComboBox
    m_comboFontSize.SetWindowPos(NULL, rect.left,
        ((rect.Height() - nHeight) / 2) + rect.top, 0, 0,
        SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    m_comboScript.GetWindowRect(&rect);
    SetButtonInfo(4, IDC_SCRIPT, TBBS_SEPARATOR, rect.Width());
    GetItemRect(4, &rect); // Script ComboBox
    m_comboScript.SetWindowPos(NULL, rect.left,
        ((rect.Height() - nHeight) / 2) + rect.top, 0, 0,
        SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);
}

/////////////////////////////////////////////////////////////////////////////
// CFontComboBox

BEGIN_MESSAGE_MAP(CFontComboBox, CLocalComboBox)
    //{{AFX_MSG_MAP(CFontComboBox)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
    // Global help commands
END_MESSAGE_MAP()

CFontComboBox::CFontComboBox()
{
    VERIFY(m_bmFontType.LoadBitmap(IDB_FONTTYPE));
}

void CFontComboBox::OnDestroy()
{
    // destroy all the CFontDesc's
    EmptyContents();
    CLocalComboBox::OnDestroy();
}

void CFontComboBox::EmptyContents()
{
    // destroy all the CFontDesc's
    int nCount = GetCount();
    for (int i=0;i<nCount;i++)
    {
        delete (CFontDesc*)GetItemData(i);
        SetItemData(i, NULL);
    }
}

void CFontComboBox::EnumFontFamiliesEx(CDC& dc, BYTE nCharSet)
{
    CString str;
    GetTheText(str);

    EmptyContents();
    ResetContent();
    m_arrayFontDesc.RemoveAll();

    LOGFONT lf;
    memset(&lf, 0, sizeof(lf));
    lf.lfCharSet = nCharSet;

    if (dc.m_hDC != NULL)
    {
        ::EnumFontFamiliesEx(dc.m_hDC, &lf,
                (FONTENUMPROC) EnumFamPrinterCallBackEx, (LPARAM) this, NULL);
    }
    else
    {
        HDC hDC = theApp.m_dcScreen.m_hDC;
        ASSERT(hDC != NULL);

        ::EnumFontFamiliesEx(hDC, &lf,
                (FONTENUMPROC) EnumFamScreenCallBackEx, (LPARAM) this, NULL);
    }

    // Add the fonts to the dropdown.  Don't add fonts that differ only by
    // charset.

    int nCount = (int)m_arrayFontDesc.GetSize();

    for (int i = 0; i < nCount; i++)
    {
        CFontDesc *pDesc = (CFontDesc*) m_arrayFontDesc[i];

        for (int j = i - 1; j >= 0; --j)
        {
            CFontDesc *otherfont = (CFontDesc*) m_arrayFontDesc[j];

            if (pDesc->m_strName == otherfont->m_strName
                && pDesc->m_dwFlags == otherfont->m_dwFlags)
            {
                break;
            }
        }

        if (j < 0)
        {
            int nIndex = AddString(pDesc->m_strName);
            ASSERT(nIndex >= 0);
            if (nIndex >= 0)
                SetItemData(nIndex, (DWORD_PTR)pDesc);
        }
    }

    SetTheText(str);
}

void CFontComboBox::AddFont(ENUMLOGFONT* pelf, DWORD dwType, LPCTSTR lpszScript)
{
    LOGFONT& lf = pelf->elfLogFont;

    if (lf.lfCharSet == MAC_CHARSET) // don't put in MAC fonts, commdlg doesn't either
        return;

    CFontDesc* pDesc = new CFontDesc(lf.lfFaceName, lpszScript,
        lf.lfCharSet, lf.lfPitchAndFamily, dwType);
    m_arrayFontDesc.Add(pDesc);
}

VOID   vGetFontType(NEWTEXTMETRICEX* lpntm, int FontType, DWORD* pdwData)
{
    DWORD  ntmFlags = lpntm->ntmTm.ntmFlags;

    if (ntmFlags & NTM_PS_OPENTYPE)
    {
        *pdwData |= PS_OPENTYPE_FONT;
    }
    else if (ntmFlags & NTM_TYPE1)
    {
        *pdwData |= TYPE1_FONT;
    }
    else
    {
        if (FontType & TRUETYPE_FONTTYPE)
        {
            if (ntmFlags & NTM_TT_OPENTYPE)
                *pdwData |= TT_OPENTYPE_FONT;
            else
                *pdwData |= TT_FONT;
        }
        else if (FontType & DEVICE_FONTTYPE)
            *pdwData |= DEVICE_FONT;
    }
}

BOOL CALLBACK AFX_EXPORT CFontComboBox::EnumFamScreenCallBackEx(ENUMLOGFONTEX* pelf,
    NEWTEXTMETRICEX* lpntm, int FontType, LPVOID pThis)
{
    // don't put in non-printer raster fonts
    if (FontType & RASTER_FONTTYPE)
        return 1;

    DWORD dwData = 0;

    vGetFontType(lpntm, FontType, &dwData);
    ((CFontComboBox *)pThis)->AddFont((ENUMLOGFONT*)pelf, dwData, CString(pelf->elfScript));
    return 1;
}

BOOL CALLBACK AFX_EXPORT CFontComboBox::EnumFamPrinterCallBackEx(ENUMLOGFONTEX* pelf,
    NEWTEXTMETRICEX* lpntm, int FontType, LPVOID pThis)
{
    DWORD dwData = PRINTER_FONT;

    vGetFontType(lpntm, FontType, &dwData);
    ((CFontComboBox *)pThis)->AddFont((ENUMLOGFONT*)pelf, dwData, CString(pelf->elfScript));
    return 1;
}

void CFontComboBox::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
    ASSERT(lpDIS->CtlType == ODT_COMBOBOX);
    int id = (int)(WORD)lpDIS->itemID;

    CDC *pDC = CDC::FromHandle(lpDIS->hDC);
    CRect rc(lpDIS->rcItem);
    if (lpDIS->itemState & ODS_FOCUS)
        pDC->DrawFocusRect(rc);
    int nIndexDC = pDC->SaveDC();

    CBrush brushFill;
    if (lpDIS->itemState & ODS_SELECTED)
    {
        brushFill.CreateSolidBrush(::GetSysColor(COLOR_HIGHLIGHT));
        pDC->SetTextColor(::GetSysColor(COLOR_HIGHLIGHTTEXT));
    }
    else
        brushFill.CreateSolidBrush(pDC->GetBkColor());
    pDC->SetBkMode(TRANSPARENT);
    pDC->FillRect(rc, &brushFill);

    CFontDesc* pDesc= (CFontDesc*)lpDIS->itemData;
    ASSERT(pDesc != NULL);
    DWORD dwData = pDesc->m_dwFlags;
    if (dwData) // truetype or device flag set by SetItemData
    {
        CDC dc;
        dc.CreateCompatibleDC(pDC);
        CBitmap* pBitmap = dc.SelectObject(&m_bmFontType);
        int xSrc;

        if (dwData & TT_FONT)
            xSrc = 1;
        else if (dwData & TT_OPENTYPE_FONT)
            xSrc = 2;
        else if (dwData & PS_OPENTYPE_FONT)
            xSrc = 3;
        else if (dwData & TYPE1_FONT)
            xSrc = 4;
        else // DEVICE_FONT
            xSrc = 0;

        pDC->BitBlt(rc.left, rc.top, BMW, BMH, &dc, xSrc*BMW, 0, SRCAND);
        dc.SelectObject(pBitmap);
    }

    rc.left += BMW + 6;
    CString strText;
    GetLBText(id, strText);
    pDC->TextOut(rc.left,rc.top,strText,strText.GetLength());

    pDC->RestoreDC(nIndexDC);
}

void CFontComboBox::MeasureItem(LPMEASUREITEMSTRUCT lpMIS)
{
    ASSERT(lpMIS->CtlType == ODT_COMBOBOX);
    ASSERT(m_nFontHeight > 0);
    CRect rc;

    GetWindowRect(&rc);
    lpMIS->itemWidth = rc.Width();
    lpMIS->itemHeight = max(BMH, m_nFontHeight);
}

int CFontComboBox::CompareItem(LPCOMPAREITEMSTRUCT lpCIS)
{
    ASSERT(lpCIS->CtlType == ODT_COMBOBOX);
    int id1 = (int)(WORD)lpCIS->itemID1;
    int id2 = (int)(WORD)lpCIS->itemID2;
    CString str1,str2;
    if (id1 == -1)
        return -1;
    if (id2 == -1)
        return 1;
    GetLBText(id1, str1);
    GetLBText(id2, str2);
    return str1.Collate(str2);
}

/////////////////////////////////////////////////////////////////////////////
// CSizeComboBox

CSizeComboBox::CSizeComboBox()
{
    m_nTwipsLast = 0;
}

void CSizeComboBox::EnumFontSizes(CDC& dc, LPCTSTR pFontName)
{
    ResetContent();
    if (pFontName == NULL)
        return;
    if (pFontName[0] == NULL)
        return;

    ASSERT(dc.m_hDC != NULL);
    m_nLogVert = dc.GetDeviceCaps(LOGPIXELSY);

    ::EnumFontFamilies(dc.m_hDC, pFontName,
        (FONTENUMPROC) EnumSizeCallBack, (LPARAM) this);
}

void CSizeComboBox::TwipsToPointString(LPTSTR lpszBuf, int cchBuf, int nTwips)
{
    ASSERT(lpszBuf != NULL);
    lpszBuf[0] = NULL;
    if (nTwips >= 0)
    {
        // round to nearest half point
        nTwips = (nTwips+5)/10;
        if ((nTwips%2) == 0)
            StringCchPrintf(lpszBuf, cchBuf, _T("%ld"), nTwips/2);
        else
            StringCchPrintf(lpszBuf, cchBuf, _T("%.1f"), (float)nTwips/2.F);
    }
}

void CSizeComboBox::SetTwipSize(int nTwips)
{
    if (nTwips != GetTwipSize())
    {
        TCHAR buf[10];
        TwipsToPointString(buf, ARRAYSIZE(buf), nTwips);
        SetTheText(buf, TRUE);
    }
    m_nTwipsLast = nTwips;
}

int CSizeComboBox::GetTwipSize()
{
    // return values
    // -2 -- error
    // -1 -- edit box empty
    // >=0 -- font size in twips
    CString str;
    GetTheText(str);
    LPCTSTR lpszText = str;

    while (*lpszText == ' ' || *lpszText == '\t')
        lpszText++;

    if (lpszText[0] == NULL)
        return -1; // no text in control

    double d = _tcstod(lpszText, (LPTSTR*)&lpszText);
    while (*lpszText == ' ' || *lpszText == '\t')
        lpszText++;

    if (*lpszText != NULL)
        return -2;   // not terminated properly

    return (d<0.) ? 0 : (int)(d*20.);
}

BOOL CALLBACK AFX_EXPORT CSizeComboBox::EnumSizeCallBack(LOGFONT FAR* /*lplf*/,
        LPNEWTEXTMETRIC lpntm, int FontType, LPVOID lpv)
{
    CSizeComboBox* pThis = (CSizeComboBox*)lpv;
    ASSERT(pThis != NULL);
    TCHAR buf[12];
    if (
        (FontType & TRUETYPE_FONTTYPE) ||
        !( (FontType & TRUETYPE_FONTTYPE) || (FontType & RASTER_FONTTYPE) )
        ) // if truetype or vector font
    {
        // this occurs when there is a truetype and nontruetype version of a font
        if (pThis->GetCount() != 0)
            pThis->ResetContent();

        for (int i = 0; i < 16; i++)
        {
            EVAL(SUCCEEDED(StringCchPrintf(buf, ARRAYSIZE(buf), _T("%d"), nFontSizes[i]))); // Always enough room
            pThis->AddString(buf);
        }
        return FALSE; // don't call me again
    }
    // calc character height in pixels
    pThis->InsertSize(MulDiv(lpntm->tmHeight-lpntm->tmInternalLeading,
        1440, pThis->m_nLogVert));
    return TRUE; // call me again
}

void CSizeComboBox::InsertSize(int nSize)
{
    ASSERT(nSize > 0);
    DWORD dwSize = (DWORD)nSize;
    TCHAR buf[10];
    TwipsToPointString(buf, ARRAYSIZE(buf), nSize);
    if (FindStringExact(-1, buf) == CB_ERR)
    {
        int nIndex = -1;
        int nPos = 0;
        DWORD_PTR dw;
        while ((dw = GetItemData(nPos)) != CB_ERR)
        {
            if (dw > dwSize)
            {
                nIndex = nPos;
                break;
            }
            nPos++;
        }
        nIndex = InsertString(nIndex, buf);
        ASSERT(nIndex != CB_ERR);
        if (nIndex != CB_ERR)
            SetItemData(nIndex, dwSize);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CLocalComboBox

BEGIN_MESSAGE_MAP(CLocalComboBox, CComboBox)
    //{{AFX_MSG_MAP(CLocalComboBox)
    ON_WM_CREATE()
    //}}AFX_MSG_MAP
    // Global help commands
END_MESSAGE_MAP()

void CLocalComboBox::GetTheText(CString& str)
{
    int nIndex = GetCurSel();
    if (nIndex == CB_ERR)
        GetWindowText(str);
    else
        GetLBText(nIndex, str);
}

void CLocalComboBox::SetTheText(LPCTSTR lpszText,BOOL bMatchExact)
{
    int idx = (bMatchExact) ? FindStringExact(-1,lpszText) :
        FindString(-1, lpszText);
    SetCurSel( (idx==CB_ERR) ? -1 : idx);
    if (idx == CB_ERR)
        SetWindowText(lpszText);
}

BOOL CLocalComboBox::LimitText(int nMaxChars)
{
    BOOL b = CComboBox::LimitText(nMaxChars);
    if (b)
        m_nLimitText = nMaxChars;
    return b;
}

int CLocalComboBox::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CComboBox::OnCreate(lpCreateStruct) == -1)
        return -1;
    SendMessage(WM_SETFONT, (WPARAM)GetStockObject(theApp.m_nDefFont));
    return 0;
}

BOOL CLocalComboBox::PreTranslateMessage(MSG* pMsg)
{
    if (pMsg->message == WM_KEYDOWN)
    {
        CFormatBar* pBar = (CFormatBar*)GetParent();
        switch (pMsg->wParam)
        {
        case VK_ESCAPE:
            pBar->SyncToView();
            pBar->NotifyOwner(NM_RETURN);
            return TRUE;
        case VK_RETURN:
            pBar->NotifyOwner(NM_RETURN);
            return TRUE;
        case VK_TAB:
            pBar->GetNextDlgTabItem(this)->SetFocus();
            return TRUE;
        case VK_UP:
        case VK_DOWN:
            if ((GetKeyState(VK_MENU) >= 0) && (GetKeyState(VK_CONTROL) >=0) &&
                !GetDroppedState())
            {
                ShowDropDown();
                return TRUE;
            }
        }
    }

    //
    // Unless we catch the 'CatchKeys' keys here, MFC will wander around
    // trying to figure out what to do with them and eventually realize
    // that they are accellerators for the frame window and dispatch them
    // there.  We want them sent to the combobox's edit controls.
    //

    if (WM_KEYDOWN == pMsg->message || WM_SYSKEYDOWN == pMsg->message)
    {
        static const struct
        {
            int     modifier;
            WPARAM  virtkey;
        }
        CatchKeys[] =
        {
            {VK_CONTROL, 'C'},          // control-C copy
            {VK_CONTROL, 'V'},          // control-V paste
            {VK_MENU,    VK_BACK},      // alt-back undo
            {VK_SHIFT,   VK_DELETE},    // shift-delete cut
            {VK_CONTROL, VK_INSERT},    // control-insert copy
            {VK_SHIFT,   VK_INSERT},    // shift-insert paste
            {VK_CONTROL, 'X'},          // control-X cut
            {VK_CONTROL, 'Z'}           // control-Z undo
        };

        for (int i = 0; i < sizeof(CatchKeys)/sizeof(CatchKeys[0]); i++)
        {
            if (pMsg->wParam == CatchKeys[i].virtkey)
            {
                if (GetKeyState(CatchKeys[i].modifier) < 0)
                {
                    ::TranslateMessage(pMsg);
                    ::DispatchMessage(pMsg);
                    return TRUE;
                }
            }
        }
    }

    return CComboBox::PreTranslateMessage(pMsg);
}

void CFormatBar::NotifyOwner(UINT nCode)
{
    NMHDR nm;
    nm.hwndFrom = m_hWnd;
    nm.idFrom = GetDlgCtrlID();
    nm.code = nCode;
    GetOwner()->SendMessage(WM_NOTIFY, nm.idFrom, (LPARAM)&nm);
}

void CFormatBar::SetCharFormat(CCharFormat& cf)
{
    CHARHDR fnm;
    fnm.hwndFrom = m_hWnd;
    fnm.idFrom = GetDlgCtrlID();
    fnm.code = FN_SETFORMAT;
    fnm.cf = cf;
    VERIFY(GetOwner()->SendMessage(WM_NOTIFY, fnm.idFrom, (LPARAM)&fnm));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\formatpa.h ===
// formatpa.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CFormatParaDlg dialog

class CFormatParaDlg : public CCSDialog
{
// Construction
public:
	CFormatParaDlg(PARAFORMAT& pf, CWnd* pParent = NULL);   // standard constructor
	PARAFORMAT m_pf;

// Attributes
	int m_nWordWrap;

// Dialog Data
	//{{AFX_DATA(CFormatParaDlg)
	enum { IDD = IDD_FORMAT_PARA };
	int     m_nAlignment;
	int		m_nFirst;
	int		m_nLeft;
	int		m_nRight;
	//}}AFX_DATA

// Implementation
protected:
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void OnOK();

	// Generated message map functions
	//{{AFX_MSG(CFormatParaDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\formatta.cpp ===
// formatta.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "formatta.h"
#include "ddxm.h"
#include "helpids.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

const DWORD CFormatTabDlg::m_nHelpIDs[] =
{
	IDC_BUTTON_SET, IDH_WORDPAD_TABSET,
	IDC_BUTTON_CLEAR, IDH_WORDPAD_TABCLEAR,
	IDC_BUTTON_CLEARALL, IDH_WORDPAD_TAB_CLEARALL,
	IDC_COMBO1, IDH_WORDPAD_TABSTOPS,
	IDC_BOX, (DWORD) -1,
	0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CFormatTabDlg dialog

CFormatTabDlg::CFormatTabDlg(PARAFORMAT& pf, CWnd* pParent /*=NULL*/)
	: CCSDialog(CFormatTabDlg::IDD, pParent)
{
	m_pf = pf;
	m_tabarray = new LONG[MAX_TAB_STOPS];
	m_nCount = 0;
	if (m_pf.dwMask & PFM_TABSTOPS)
	{
		m_nCount = m_pf.cTabCount;
		ASSERT(m_pf.cTabCount <= MAX_TAB_STOPS);
		for (int i=0;i<m_pf.cTabCount;i++)
			m_tabarray[i] = m_pf.rgxTabs[i];
	}
	
	//{{AFX_DATA_INIT(CFormatTabDlg)
	//}}AFX_DATA_INIT
}

CFormatTabDlg::~CFormatTabDlg()
{
	delete [] m_tabarray;
}

void CFormatTabDlg::DoDataExchange(CDataExchange* pDX)
{
	CCSDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFormatTabDlg)
	DDX_Control(pDX, IDC_BUTTON_CLEARALL, m_buttonClearAll);
	DDX_Control(pDX, IDC_BUTTON_SET, m_buttonSet);
	DDX_Control(pDX, IDC_BUTTON_CLEAR, m_buttonClear);
	DDX_Control(pDX, IDC_COMBO1, m_comboBox);
	//}}AFX_DATA_MAP
	if (!pDX->m_bSaveAndValidate)
		UpdateListBox();
}

BEGIN_MESSAGE_MAP(CFormatTabDlg, CCSDialog)
	//{{AFX_MSG_MAP(CFormatTabDlg)
	ON_BN_CLICKED(IDC_BUTTON_CLEAR, OnClickedClear)
	ON_BN_CLICKED(IDC_BUTTON_CLEARALL, OnClickedClearAll)
	ON_BN_CLICKED(IDC_BUTTON_SET, OnClickedSet)
	ON_CBN_EDITCHANGE(IDC_COMBO1, OnEditChange)
	ON_CBN_SELCHANGE(IDC_COMBO1, OnSelchange)
	ON_MESSAGE(WM_HELP, OnHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFormatTabDlg message handlers

void CFormatTabDlg::OnClickedClear()
{
	int nTab;
	int nSel = m_comboBox.GetCurSel();
	if (nSel == CB_ERR)
	{
		CDataExchange dx(this, TRUE);
		DDX_Twips(&dx, IDC_COMBO1, nTab);
		DDV_MinMaxTwips(&dx, nTab, 0, 31680);
		if (nTab != DDXM_BLANK)
		{
				if (RemoveTabFromArray(nTab))
					UpdateListBox();
		}
	}
	else
	{
		ASSERT(nSel < m_nCount);
		RemoveTabFromArrayByIndex(nSel);
		UpdateListBox();
	}
	UpdateButtons();
	SetEditFocus();
}

void CFormatTabDlg::OnClickedClearAll()
{
	m_nCount = 0;
	m_comboBox.ResetContent();
	UpdateButtons();
	SetEditFocus();
}

void CFormatTabDlg::OnClickedSet()
{
	Set();
	UpdateButtons();
	SetEditFocus();
}

BOOL CFormatTabDlg::Set()
{
	int nTab = 0;
	CDataExchange dx(this, TRUE);
	DDX_Twips(&dx, IDC_COMBO1, nTab);
	DDV_MinMaxTwips(&dx, nTab, 0, 31680);
	if (nTab != DDXM_BLANK)
	{
		if (m_nCount == MAX_TAB_STOPS)
		{
			AfxMessageBox(IDS_NOMORETABS);
			m_comboBox.Clear();
			return FALSE;
		}
		if (AddTabToArray(nTab))
			UpdateListBox();
		return TRUE;
	}
	return FALSE;
}

void CFormatTabDlg::SetEditFocus()
{
	m_comboBox.SetFocus();
	m_comboBox.SetEditSel(0,-1);
}

BOOL CFormatTabDlg::RemoveTabFromArray(LONG lTab)
{
	int i;
	for (i=0;i<m_nCount;i++)
	{
		if (m_tabarray[i] == lTab)
		{
			RemoveTabFromArrayByIndex(i);
			return TRUE;
		}
	}
	return FALSE;
}

void CFormatTabDlg::RemoveTabFromArrayByIndex(int nIndex)
{
	memmove(&m_tabarray[nIndex], &m_tabarray[nIndex+1],
		(m_nCount-nIndex-1)*sizeof(LONG));
	m_nCount--;
}

BOOL CFormatTabDlg::AddTabToArray(LONG lTab)
{
	int i;
	BOOL bInsert = FALSE;
	LONG lTemp;
	for (i=0;i<m_nCount;i++)
	{
		if (!bInsert && lTab < m_tabarray[i])
			bInsert = TRUE;
		else if (lTab == m_tabarray[i]) // we don't want repeats
			return FALSE;
		if (bInsert)
		{
			lTemp = m_tabarray[i];
			m_tabarray[i] = lTab;
			lTab = lTemp;
		}
	}
	m_tabarray[m_nCount++] = lTab;
	return TRUE;
}

void CFormatTabDlg::UpdateListBox()
{
	int i;
	TCHAR szT[64];
	ASSERT(m_nCount >= 0);
	m_comboBox.ResetContent();
	for (i=0;i<m_nCount;i++)
	{
		theApp.PrintTwips(szT, ARRAYSIZE(szT), m_tabarray[i], 2);
		m_comboBox.AddString(szT);
	}
}

void CFormatTabDlg::OnOK()
{
	if (m_buttonSet.IsWindowEnabled())
	{
		if (!Set())
			return;
	}
	CCSDialog::OnOK();
	m_pf.cTabCount = (SHORT) m_nCount;
	for (int i=0;i<m_nCount;i++)
		m_pf.rgxTabs[i] = m_tabarray[i];
	m_pf.dwMask = PFM_TABSTOPS;
}

void CFormatTabDlg::OnEditChange()
{
	UpdateButtons();
}

void CFormatTabDlg::UpdateButton(CButton& button, BOOL b)
{
	if (b != button.IsWindowEnabled())
		button.EnableWindow(b);
}

void CFormatTabDlg::UpdateButtons()
{
	UpdateButton(m_buttonClearAll, m_nCount > 0);
	BOOL bHasText = (m_comboBox.GetWindowTextLength() > 0);
	UpdateButton(m_buttonSet, bHasText);
	UpdateButton(m_buttonClear, bHasText);
	WORD wID = LOWORD(GetDefID());
	if (bHasText && wID != IDC_BUTTON_SET)
		SetDefID(IDC_BUTTON_SET);
	else if (!bHasText && wID != IDOK)
		SetDefID(IDOK);
}

BOOL CFormatTabDlg::OnInitDialog()
{
	CCSDialog::OnInitDialog();
	UpdateButtons();
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CFormatTabDlg::OnSelchange()
{
	UpdateButton(m_buttonClearAll, m_nCount > 0);
	// force these since if the edit control is empty and
	// an item in the box is clicked on, the edit control will
	// not be filled in first
	UpdateButton(m_buttonSet, TRUE);
	UpdateButton(m_buttonClear, TRUE);
	WORD wID = LOWORD(GetDefID());
	if (wID != IDC_BUTTON_SET)
		SetDefID(IDC_BUTTON_SET);
}


LONG CFormatTabDlg::OnHelp(WPARAM, LPARAM lParam)
{
	LPHELPINFO phi = (LPHELPINFO) lParam ;
	HWND hWndCombo = ::GetDlgItem(m_hWnd, IDC_COMBO1) ;

	HWND hWndItem = (HWND) phi->hItemHandle ;

	if (::GetParent(hWndItem) == hWndCombo)
    {
		hWndItem = hWndCombo ;
    }

	::WinHelp(hWndItem, AfxGetApp()->m_pszHelpFilePath,
		HELP_WM_HELP, (DWORD_PTR)GetHelpIDs());

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\formatta.h ===
// formatta.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CFormatTabDlg dialog

class CFormatTabDlg : public CCSDialog
{
// Construction
public:
	CFormatTabDlg(PARAFORMAT& pf, CWnd* pParent = NULL);    // standard constructor
	~CFormatTabDlg();
	PARAFORMAT m_pf;
	LONG* m_tabarray;
	int m_nCount;

// Dialog Data
	//{{AFX_DATA(CFormatTabDlg)
	enum { IDD = IDD_FORMAT_TAB };
	CButton	m_buttonClearAll;
	CButton	m_buttonSet;
	CButton	m_buttonClear;
	CComboBox	m_comboBox;
	//}}AFX_DATA

// Implementation
protected:
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}
	void UpdateButton(CButton& button, BOOL b);
	void UpdateButtons();
	BOOL Set();
	BOOL AddTabToArray(LONG lTab);
	BOOL RemoveTabFromArray(LONG lTab);
	void RemoveTabFromArrayByIndex(int nIndex);
	void UpdateListBox();
	void SetEditFocus();
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void OnOK();

	// Generated message map functions
	//{{AFX_MSG(CFormatTabDlg)
	afx_msg void OnClickedClear();
	afx_msg void OnClickedClearAll();
	afx_msg void OnClickedSet();
	afx_msg void OnEditChange();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchange();
	afx_msg LONG OnHelp(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\formatpa.cpp ===
// formatpa.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "formatpa.h"
#include "ddxm.h"
#include "helpids.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

const DWORD CFormatParaDlg::m_nHelpIDs[] = 
{
	IDC_EDIT_LEFT, IDH_WORDPAD_INDENT_LEFT,
	IDC_EDIT_RIGHT, IDH_WORDPAD_INDENT_RIGHT,
	IDC_EDIT_FIRST_LINE, IDH_WORDPAD_INDENT_FIRST,
	IDC_BOX, (DWORD) -1,
	IDC_COMBO_ALIGNMENT, IDH_WORDPAD_ALIGN,
	IDC_TEXT_ALIGNMENT, IDH_WORDPAD_ALIGN,
	0, 0
};

/////////////////////////////////////////////////////////////////////////////
// CFormatParaDlg dialog

CFormatParaDlg::CFormatParaDlg(PARAFORMAT& pf, CWnd* pParent /*=NULL*/)
	: CCSDialog(CFormatParaDlg::IDD, pParent)
{
	m_pf = pf;
	if (m_pf.dwMask & PFM_ALIGNMENT)
	{
		if (m_pf.wAlignment & PFA_LEFT && m_pf.wAlignment & PFA_RIGHT)
			m_nAlignment = 2;
		else
			m_nAlignment = (m_pf.wAlignment & PFA_LEFT) ? 0 : 1;
	}
	else
		m_nAlignment = -1;
	//{{AFX_DATA_INIT(CFormatParaDlg)
	m_nFirst = 0;
	m_nLeft = 0;
	m_nRight = 0;
	//}}AFX_DATA_INIT
}

void CFormatParaDlg::DoDataExchange(CDataExchange* pDX)
{
	CCSDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFormatParaDlg)
	DDX_CBIndex(pDX, IDC_COMBO_ALIGNMENT, m_nAlignment);
	DDX_Twips(pDX, IDC_EDIT_FIRST_LINE, m_nFirst);
	DDV_MinMaxTwips(pDX, m_nFirst, -31680, 31680);
	DDX_Twips(pDX, IDC_EDIT_LEFT, m_nLeft);
	DDV_MinMaxTwips(pDX, m_nLeft, -31680, 31680);
	DDX_Twips(pDX, IDC_EDIT_RIGHT, m_nRight);
	DDV_MinMaxTwips(pDX, m_nRight, -31680, 31680);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CFormatParaDlg, CCSDialog)
	//{{AFX_MSG_MAP(CFormatParaDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFormatParaDlg message handlers

void CFormatParaDlg::OnOK()
{
	CCSDialog::OnOK();
	m_pf.dwMask = 0;
	if (m_nAlignment >= 0)
	{
		ASSERT(m_nAlignment < 3);
		m_pf.dwMask |= PFM_ALIGNMENT;
		m_pf.wAlignment = (WORD)((m_nAlignment == 0) ? PFA_LEFT : 
			(m_nAlignment == 1) ? PFA_RIGHT : PFA_CENTER);
	}

	//in case we have RTL Reading order, we need to reverse the sides indent.
	if ( m_pf.wEffects & PFE_RTLPARA )
	{
		if (m_nLeft != DDXM_BLANK)
			m_pf.dwMask |= PFM_RIGHTINDENT;
		if (m_nRight != DDXM_BLANK && m_nFirst != DDXM_BLANK)
			m_pf.dwMask |= PFM_STARTINDENT;
		if (m_nFirst != DDXM_BLANK)
			m_pf.dwMask |= PFM_OFFSET;

		m_pf.dxRightIndent = m_nLeft;
		m_pf.dxOffset = -m_nFirst;
		m_pf.dxStartIndent = m_nRight + m_nFirst;
	}
	else
	{
		if (m_nRight != DDXM_BLANK)
			m_pf.dwMask |= PFM_RIGHTINDENT;
		if (m_nLeft != DDXM_BLANK && m_nFirst != DDXM_BLANK)
			m_pf.dwMask |= PFM_STARTINDENT;
		if (m_nFirst != DDXM_BLANK)
			m_pf.dwMask |= PFM_OFFSET;

		m_pf.dxRightIndent = m_nRight;
		m_pf.dxOffset = -m_nFirst;
		m_pf.dxStartIndent = m_nLeft + m_nFirst;
	}	
}

BOOL CFormatParaDlg::OnInitDialog() 
{
	CComboBox* pBox = (CComboBox*)GetDlgItem(IDC_COMBO_ALIGNMENT);
	CString str;
	str.LoadString(IDS_LEFT);
	pBox->AddString(str);
	str.LoadString(IDS_RIGHT);
	pBox->AddString(str);
	str.LoadString(IDS_CENTER);
	pBox->AddString(str);

	if (m_nWordWrap == 0)
	{
		GetDlgItem(IDC_COMBO_ALIGNMENT)->EnableWindow(FALSE);
		GetDlgItem(IDC_TEXT_ALIGNMENT)->EnableWindow(FALSE);
	}

	if ( m_pf.wEffects & PFE_RTLPARA )
	{
		m_nLeft = (m_pf.dwMask & PFM_RIGHTINDENT) ? m_pf.dxRightIndent : DDXM_BLANK;
		if (m_pf.dwMask & PFM_OFFSET)
		{
			m_nFirst = -m_pf.dxOffset;
			m_nRight = (m_pf.dwMask & PFM_STARTINDENT) ? 
				m_pf.dxStartIndent + m_pf.dxOffset : DDXM_BLANK;
		}
		else
			m_nRight = m_nFirst = DDXM_BLANK;
	}
	else
	{

		m_nRight = (m_pf.dwMask & PFM_RIGHTINDENT) ? m_pf.dxRightIndent : DDXM_BLANK;
		if (m_pf.dwMask & PFM_OFFSET)
		{
			m_nFirst = -m_pf.dxOffset;
			m_nLeft = (m_pf.dwMask & PFM_STARTINDENT) ? 
				m_pf.dxStartIndent + m_pf.dxOffset : DDXM_BLANK;
		}
		else
			m_nLeft = m_nFirst = DDXM_BLANK;
	}
	
	CCSDialog::OnInitDialog();
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\formatba.h ===
// formatba.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __FORMATBA_H__
#define __FORMATBA_H__

class CWordPadView;

/*
typedef struct tagNMHDR
{
    HWND  hwndFrom;
    UINT  idFrom;
    UINT  code;         // NM_ code
}   NMHDR;
*/

struct CHARHDR : public tagNMHDR
{
	CHARFORMAT cf;
	CHARHDR() {cf.cbSize = sizeof(CHARFORMAT);}
};

#define FN_SETFORMAT	0x1000
#define FN_GETFORMAT	0x1001

/////////////////////////////////////////////////////////////////////////////
// CLocalComboBox

class CLocalComboBox : public CComboBox
{
public:

//Attributes
	CPtrArray m_arrayFontDesc;
	static int m_nFontHeight;
	int m_nLimitText;
	BOOL HasFocus()
	{
		HWND hWnd = ::GetFocus();
		return (NULL != hWnd) && (hWnd == m_hWnd || ::IsChild(m_hWnd, hWnd));
	}
	void GetTheText(CString& str);
	void SetTheText(LPCTSTR lpszText,BOOL bMatchExact = FALSE);

//Operations
	BOOL LimitText(int nMaxChars);

// Implementation
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	// Generated message map functions
	//{{AFX_MSG(CLocalComboBox)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CFontComboBox : public CLocalComboBox
{
public:
	CFontComboBox();

//Attributes
	CBitmap m_bmFontType;

//Operations
	void EnumFontFamiliesEx(CDC& dc, BYTE nCharSet = DEFAULT_CHARSET);
	void AddFont(ENUMLOGFONT* pelf, DWORD dwType, LPCTSTR lpszScript = NULL);
	void EmptyContents();

	static BOOL CALLBACK AFX_EXPORT EnumFamScreenCallBackEx(
		ENUMLOGFONTEX* pelf, NEWTEXTMETRICEX* /*lpntm*/, int FontType, 
		LPVOID pThis);
	static BOOL CALLBACK AFX_EXPORT EnumFamPrinterCallBackEx(
		ENUMLOGFONTEX* pelf, NEWTEXTMETRICEX* /*lpntm*/, int FontType, 
		LPVOID pThis);

//Overridables
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMIS);
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCIS);
	// Generated message map functions
	//{{AFX_MSG(CFontComboBox)
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CSizeComboBox : public CLocalComboBox
{
public:
	CSizeComboBox();

//Attributes
	int m_nLogVert;
	int m_nTwipsLast;
public:
	void EnumFontSizes(CDC& dc, LPCTSTR pFontName);
	static BOOL FAR PASCAL EnumSizeCallBack(LOGFONT FAR* lplf, 
		LPNEWTEXTMETRIC lpntm,int FontType, LPVOID lpv);
	void TwipsToPointString(LPTSTR lpszBuf, int cchBuf, int nTwips);
	void SetTwipSize(int nSize);
	int GetTwipSize();
	void InsertSize(int nSize);
};

class CScriptComboBox : public CLocalComboBox
{
    enum {HistorySize = 4};

public:

    CScriptComboBox() {m_history_index = 0;}

    BYTE PickScript();

private:

    //
    // HACKHACK: All this history stuff is to help make choosing a script for
    // a font easier.  There doesn't seem to be anyway to get a "good" script
    // for a given font/locale so what we do is save the last serveral scripts
    // and hope that the font the user just switched to supports one of them.
    //

    CString m_script_history[HistorySize];
    int     m_history_index;
};

/////////////////////////////////////////////////////////////////////////////
// CFormatBar dialog
class CFormatBar : public CToolBar
{
// Construction
public:
	CFormatBar();

// Operations
public:
	void PositionCombos();
	void SyncToView();

// Attributes
public:
    CDC             m_dcPrinter;
    CSize           m_szBaseUnits;
    CFontComboBox   m_comboFontName;
    CSizeComboBox   m_comboFontSize;
    CScriptComboBox m_comboScript;

// Implementation
public:
	void NotifyOwner(UINT nCode);

protected:
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	void SetCharFormat(CCharFormat& cf);

	// Generated message map functions
	//{{AFX_MSG(CFormatBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	afx_msg void OnFontNameKillFocus();
	afx_msg void OnFontSizeKillFocus();
	afx_msg void OnScriptKillFocus();
	afx_msg void OnFontSizeDropDown();
	afx_msg void OnScriptDropDown();
	afx_msg void OnComboCloseUp();
	afx_msg void OnComboSetFocus();
	afx_msg LONG OnPrinterChanged(UINT, LONG); //handles registered message
	DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\helpids.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#define IDH_WORDPAD_TIMEDATE		1001

#define IDH_WORDPAD_ALIGN			1003
#define IDH_WORDPAD_TABSET			1004
#define IDH_WORDPAD_TABCLEAR		1005
#define IDH_WORDPAD_TAB_CLEARALL	1006
#define IDH_WORDPAD_TABSTOPS		1007
#define IDH_WORDPAD_TEXTFILE		1008
#define IDH_WORDPAD_FORMATTED		1009

#define IDH_WORDPAD_WORD6FILE		1017
#define IDH_WORDPAD_FILENEW_DOC		1018
#define IDH_WORDPAD_OPTIONS_AUTOWORDSEL	1019

#define IDH_WORDPAD_INDENT_LEFT		1020
#define IDH_WORDPAD_INDENT_RIGHT	1021
#define IDH_WORDPAD_INDENT_FIRST	1022

#define IDH_WORDPAD_WRAP_NO			1023
#define IDH_WORDPAD_WRAP_WINDOW		1024
#define IDH_WORDPAD_WRAP_RULER		1025

#define IDH_WORDPAD_INCHES			1027
#define IDH_WORDPAD_CENTIMETERS		1028
#define IDH_WORDPAD_POINTS			1029
#define IDH_WORDPAD_PICAS			1030

#define IDH_WORDPAD_CHECK_TOOLBAR	1031
#define IDH_WORDPAD_CHECK_FORMATBAR	1032
#define IDH_WORDPAD_CHECK_STATUSBAR	1033
#define IDH_WORDPAD_CHECK_RULERBAR	1034

#define IDH_WORDPAD_TOPMARGIN		1035
#define IDH_WORDPAD_BOTTOMMARGIN	1036
#define IDH_WORDPAD_LEFTMARGIN 		1037
#define IDH_WORDPAD_RIGHTMARGIN		1038

#define IDH_WORDPAD_DEFAULT_FORMAT  1039
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\key.cpp ===
// key.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "key.h"
#include <winreg.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CKey

void CKey::Close()
{
    if (m_hKey != NULL)
    {

#if defined(_DEBUG)
        LONG lRes = RegCloseKey(m_hKey);
        ASSERT(lRes == ERROR_SUCCESS);
#else
        RegCloseKey(m_hKey);
#endif

        m_hKey = NULL;
    }
}

BOOL CKey::Create(HKEY hKey, LPCTSTR lpszKeyName, REGSAM samDesired)
{
    ASSERT(hKey != NULL);
    return (RegCreateKeyEx(hKey, lpszKeyName, 0, NULL, 0, samDesired, NULL, &m_hKey, NULL) == ERROR_SUCCESS);
}

BOOL CKey::Open(HKEY hKey, LPCTSTR lpszKeyName, REGSAM samDesired)
{
    ASSERT(hKey != NULL);
    return (RegOpenKeyEx(hKey, lpszKeyName, 0, samDesired, &m_hKey) == ERROR_SUCCESS);
}

BOOL CKey::SetStringValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
    ASSERT(m_hKey != NULL);
    return (RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ,
        (BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR)) == ERROR_SUCCESS);
}

BOOL CKey::GetStringValue(CString& str, LPCTSTR lpszValueName)
{
    ASSERT(m_hKey != NULL);
    str.Empty();
    DWORD dw = 0;
    DWORD dwType = 0;
    LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
        NULL, &dw);
    if (lRes == ERROR_SUCCESS)
    {
        ASSERT(dwType == REG_SZ);
        LPTSTR lpsz = str.GetBufferSetLength(dw);
        lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType, (BYTE*)lpsz, &dw);
        ASSERT(lRes == ERROR_SUCCESS);
        str.ReleaseBuffer();
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\key.h ===
// key.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CKey 

class CKey
{
public:
	CKey() {m_hKey = NULL;}
	~CKey() {Close();}

// Attributes
public:
	HKEY m_hKey;
	BOOL SetStringValue(LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);
	BOOL GetStringValue(CString& str, LPCTSTR lpszValueName = NULL);

// Operations
public:
	BOOL Create(HKEY hKey, LPCTSTR lpszKeyName, REGSAM samDesired);
	BOOL Open(HKEY hKey, LPCTSTR lpszKeyName, REGSAM samDesired);
	void Close();

// Overrides

// Implementation
protected:
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\ipframe.h ===
// ipframe.h : interface of the CInPlaceFrame class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CWordPadResizeBar : public COleResizeBar
{
public: 
	void SetMinSize(CSize size) {m_tracker.m_sizeMin = size;}
};

class CInPlaceFrame : public COleIPFrameWnd
{
	DECLARE_DYNCREATE(CInPlaceFrame)
public:
	CInPlaceFrame() {};

// Attributes
public:
	CToolBar m_wndToolBar;
	CFormatBar m_wndFormatBar;
	CRulerBar m_wndRulerBar;
	CWordPadResizeBar m_wndResizeBar;
	COleDropTarget m_dropTarget;

// Operations
public:
	virtual void RecalcLayout(BOOL bNotify = TRUE);
	virtual void CalcWindowRect(LPRECT lpClientRect, 
		UINT nAdjustType = adjustBorder);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInPlaceFrame)
	public:
	virtual BOOL OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* pWndDoc);
	virtual void RepositionFrame(LPCRECT lpPosRect, LPCRECT lpClipRect);
	//}}AFX_VIRTUAL

// Implementation
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	BOOL CreateToolBar(CWnd* pWndFrame);
	BOOL CreateFormatBar(CWnd* pWndFrame);
	BOOL CreateRulerBar(CWnd* pWndFrame);

// Generated message map functions
protected:
	//{{AFX_MSG(CInPlaceFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnHelpFinder();
	afx_msg void OnCharColor();
	afx_msg void OnPenToggle();
	//}}AFX_MSG
	LRESULT OnResizeChild(WPARAM wParam, LPARAM lParam);
	afx_msg LONG OnBarState(UINT wParam, LONG lParam);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\listdlg.cpp ===
// listdlg.cpp : Defines the class behaviors for the application.
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "resource.h"
#include "listdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CListDlg, CDialog)
	//{{AFX_MSG_MAP(CListDlg)
	ON_LBN_DBLCLK(IDC_LISTDIALOG_LIST, OnOK)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CListDlg::CListDlg(UINT idStrDlgTitle, UINT idStrListTitle, 
	const CStringList& listItems, int nDefSel) : CDialog(CListDlg::IDD),
	m_listItems(listItems)
{
	VERIFY(m_strDlgTitle.LoadString(idStrDlgTitle));
	VERIFY(m_strListTitle.LoadString(idStrListTitle));
	m_nSelection = nDefSel;
}

BOOL CListDlg::OnInitDialog()
{
	SetWindowText(m_strDlgTitle);
// fix this
	SetDlgItemText(IDC_STATIC_HEADING, m_strListTitle);
	CListBox* pListBox = (CListBox*)GetDlgItem(IDC_LISTDIALOG_LIST);
	ASSERT(pListBox != NULL);
	// fill with document templates in list

	POSITION pos = m_listItems.GetHeadPosition();
	while (pos != NULL)
	{
		 if ( pListBox->AddString(m_listItems.GetNext(pos)) == -1)
		 	return FALSE;
	}
	pListBox->SetCurSel(m_nSelection);

	return CDialog::OnInitDialog();
}

void CListDlg::OnOK()
{
	CListBox* pListBox = (CListBox*)GetDlgItem(IDC_LISTDIALOG_LIST);
	ASSERT(pListBox != NULL);
	m_nSelection = pListBox->GetCurSel();
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\listdlg.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CListDlg : public CDialog
{
public:
	//{{AFX_DATA(CListDlg)
	enum { IDD = IDD_LISTDIALOG };
	//}}AFX_DATA
	CListDlg::CListDlg(UINT idStrDlgTitle, UINT idStrListTitle, 
		const CStringList& listItems, int nDefSel=0);
	CString m_strDlgTitle,m_strListTitle;
	const CStringList& m_listItems;
	int m_nSelection;

protected:
	BOOL OnInitDialog();
	//{{AFX_MSG(CListDlg)
	afx_msg void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\ipframe.cpp ===
// ipframe.cpp : implementation of the CInPlaceFrame class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "formatba.h"
#include "ruler.h"
#include "ipframe.h"
#include "wordpdoc.h"
#include "wordpvw.h"
#include "colorlis.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame

IMPLEMENT_DYNCREATE(CInPlaceFrame, COleIPFrameWnd)

BEGIN_MESSAGE_MAP(CInPlaceFrame, COleIPFrameWnd)
	//{{AFX_MSG_MAP(CInPlaceFrame)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_COMMAND(ID_HELP, OnHelpFinder)
	ON_COMMAND(ID_CHAR_COLOR, OnCharColor)
	ON_COMMAND(ID_HELP_INDEX, OnHelpFinder)
	ON_COMMAND(ID_PEN_TOGGLE, OnPenToggle)
	//}}AFX_MSG_MAP
	ON_UPDATE_COMMAND_UI(ID_VIEW_TOOLBAR, OnUpdateControlBarMenu)
	ON_COMMAND_EX(ID_VIEW_TOOLBAR, OnBarCheck)
	ON_UPDATE_COMMAND_UI(ID_VIEW_FORMATBAR, OnUpdateControlBarMenu)
	ON_COMMAND_EX(ID_VIEW_FORMATBAR, OnBarCheck)
	ON_UPDATE_COMMAND_UI(ID_VIEW_RULER, OnUpdateControlBarMenu)
	ON_COMMAND_EX(ID_VIEW_RULER, OnBarCheck)
	ON_MESSAGE(WM_SIZECHILD, OnResizeChild)
	ON_MESSAGE(WPM_BARSTATE, OnBarState)
	ON_COMMAND(ID_DEFAULT_HELP, OnHelpFinder)
//	ON_COMMAND(ID_CONTEXT_HELP, COleIPFrameWnd::OnContextHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// arrays of IDs used to initialize control bars

static UINT BASED_CODE toolButtons[] =
{
	// same order as in the bitmap 'itoolbar.bmp'
	ID_EDIT_CUT,
	ID_EDIT_COPY,
	ID_EDIT_PASTE,

		ID_SEPARATOR,
	ID_PEN_TOGGLE,
	ID_PEN_PERIOD,
	ID_PEN_SPACE,
	ID_PEN_BACKSPACE,
	ID_PEN_NEWLINE,
	ID_PEN_LENS
};

#define NUM_PEN_ITEMS 7
#define NUM_PEN_TOGGLE 5

static UINT BASED_CODE format[] =
{
	// same order as in the bitmap 'format.bmp'
		ID_SEPARATOR, // font name combo box
		ID_SEPARATOR,
		ID_SEPARATOR, // font size combo box
		ID_SEPARATOR,
        ID_SEPARATOR, // font script combo box
        ID_SEPARATOR,
	ID_CHAR_BOLD,
	ID_CHAR_ITALIC,
	ID_CHAR_UNDERLINE,
	ID_CHAR_COLOR,
		ID_SEPARATOR,
	ID_PARA_LEFT,
	ID_PARA_CENTER,
	ID_PARA_RIGHT,
		ID_SEPARATOR,
	ID_INSERT_BULLET,
};

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame construction/destruction

int CInPlaceFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (COleIPFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	// CResizeBar implements in-place resizing.
	if (!m_wndResizeBar.Create(this))
	{
		TRACE0("Failed to create resize bar\n");
		return -1;      // fail to create
	}

	if (!CreateRulerBar(this))
		return FALSE;

	// By default, it is a good idea to register a drop-target that does
	//  nothing with your frame window.  This prevents drops from
	//  "falling through" to a container that supports drag-drop.
	m_dropTarget.Register(this);

	return 0;
}

// OnCreateControlBars is called by the framework to create control bars on the
//  container application's windows.  pWndFrame is the top level frame window of
//  the container and is always non-NULL.  pWndDoc is the doc level frame window
//  and will be NULL when the container is an SDI application.  A server
//  application can place MFC control bars on either window.
BOOL CInPlaceFrame::OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* /*pWndDoc*/)
{
	if (!CreateToolBar(pWndFrame))
		return FALSE;

	if (!CreateFormatBar(pWndFrame))
		return FALSE;

	// set owner to this window, so messages are delivered to correct app
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	m_wndFormatBar.EnableDocking(CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM);
	pWndFrame->EnableDocking(CBRS_ALIGN_ANY);
	pWndFrame->DockControlBar(&m_wndToolBar);
	pWndFrame->DockControlBar(&m_wndFormatBar);

	m_wndToolBar.SetOwner(this);
	m_wndFormatBar.SetOwner(this);
	m_wndRulerBar.SetOwner(this);
	OnBarState(1, RD_EMBEDDED); //load bar state
	return TRUE;
}

BOOL CInPlaceFrame::CreateToolBar(CWnd* pWndFrame)
{
	// Create toolbar on client's frame window
	ASSERT(m_wndToolBar.m_hWnd == NULL);
	int nPen = GetSystemMetrics(SM_PENWINDOWS) ? NUM_PEN_TOGGLE : 
		NUM_PEN_ITEMS;
	UINT nID = theApp.m_bLargeIcons ? 
		IDR_SRVR_INPLACE_BIG : IDR_SRVR_INPLACE;
	if (!m_wndToolBar.Create(pWndFrame, WS_CHILD|WS_VISIBLE|CBRS_TOP|
			CBRS_TOOLTIPS|CBRS_FLYBY|CBRS_SIZE_DYNAMIC)||
		!m_wndToolBar.LoadBitmap(nID) ||
		!m_wndToolBar.SetButtons(toolButtons, 
			sizeof(toolButtons)/sizeof(UINT) - nPen))
	{
		TRACE0("Failed to create toolbar\n");
		return FALSE;      // fail to create
	}
	if (theApp.m_bLargeIcons)
		m_wndToolBar.SetSizes(CSize(31,30), CSize(24,24));
	else
		m_wndToolBar.SetSizes(CSize(23,22), CSize(16,16));
	CString str;
	str.LoadString(IDS_TITLE_TOOLBAR);
	m_wndToolBar.SetWindowText(str);
	return TRUE;
}

BOOL CInPlaceFrame::CreateFormatBar(CWnd* pWndFrame)
{
	ASSERT(m_wndFormatBar.m_hWnd == NULL);
	m_wndFormatBar.m_hWndOwner = m_hWnd;
	UINT nID = theApp.m_bLargeIcons ? IDB_FORMATBAR_BIG : IDB_FORMATBAR;
	if (!m_wndFormatBar.Create(pWndFrame, WS_CHILD|WS_VISIBLE|CBRS_TOP|
		CBRS_TOOLTIPS|CBRS_FLYBY|CBRS_HIDE_INPLACE|CBRS_SIZE_DYNAMIC, ID_VIEW_FORMATBAR) ||
		!m_wndFormatBar.LoadBitmap(nID) ||
		!m_wndFormatBar.SetButtons(format, 
			sizeof(format)/sizeof(UINT)))
	{
		TRACE0("Failed to create FormatBar\n");
		return FALSE;      // fail to create
	}

	if (theApp.m_bLargeIcons)
		m_wndFormatBar.SetSizes(CSize(31,30), CSize(24,24));
	else
		m_wndFormatBar.SetSizes(CSize(23,22), CSize(16,16));
	CString str;
	str.LoadString(IDS_TITLE_FORMATBAR);
	m_wndFormatBar.SetWindowText(str);
	m_wndFormatBar.PositionCombos();
	return TRUE;
}

CInPlaceFrame::CreateRulerBar(CWnd* pWndFrame)
{
	if (!m_wndRulerBar.Create(pWndFrame, 
		WS_CHILD|WS_VISIBLE|CBRS_ALIGN_TOP|CBRS_HIDE_INPLACE, ID_VIEW_RULER))
	{
		TRACE0("Failed to create ruler\n");
		return FALSE;      // fail to create
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame Operations

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame diagnostics

#ifdef _DEBUG
void CInPlaceFrame::AssertValid() const
{
	COleIPFrameWnd::AssertValid();
}

void CInPlaceFrame::Dump(CDumpContext& dc) const
{
	COleIPFrameWnd::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CInPlaceFrame commands

void CInPlaceFrame::OnDestroy()
{
	m_wndToolBar.DestroyWindow();
	m_wndFormatBar.DestroyWindow();
	COleIPFrameWnd::OnDestroy();
}

void CInPlaceFrame::RepositionFrame(LPCRECT lpPosRect, LPCRECT lpClipRect)
{
	CRect rectNew = lpPosRect;
	rectNew.left -= HORZ_TEXTOFFSET;
	rectNew.top -= VERT_TEXTOFFSET;
	m_wndResizeBar.BringWindowToTop();
	COleIPFrameWnd::RepositionFrame(&rectNew, lpClipRect);
	CWnd* pWnd = GetActiveView();
	if (pWnd != NULL)
		pWnd->BringWindowToTop();
	m_wndRulerBar.BringWindowToTop();
}

void CInPlaceFrame::RecalcLayout(BOOL bNotify)
{
	if (m_wndResizeBar.m_hWnd != NULL)
		m_wndResizeBar.BringWindowToTop();
	COleIPFrameWnd::RecalcLayout(bNotify);
	CWnd* pWnd = GetActiveView();
	if (pWnd != NULL)
		pWnd->BringWindowToTop();
	if (m_wndRulerBar.m_hWnd != NULL)
		m_wndRulerBar.BringWindowToTop();

	// at least 12 pt region plus ruler if it exists
	CDisplayIC dc;
	CSize size;
	size.cy = MulDiv(12, dc.GetDeviceCaps(LOGPIXELSY), 72)+1;
	size.cx = dc.GetDeviceCaps(LOGPIXELSX)/4; // 1/4"
	size.cx += HORZ_TEXTOFFSET; //adjust for offset
	size.cy += VERT_TEXTOFFSET;
	if (m_wndRulerBar.m_hWnd != NULL && m_wndRulerBar.IsVisible())
	{
		CRect rect;
		m_wndRulerBar.GetWindowRect(&rect);
		size.cy += rect.Height();
	}
	m_wndResizeBar.SetMinSize(size);
}

void CInPlaceFrame::CalcWindowRect(LPRECT lpClientRect, UINT nAdjustType)
{
	COleIPFrameWnd::CalcWindowRect(lpClientRect, nAdjustType);
}

LRESULT CInPlaceFrame::OnResizeChild(WPARAM /*wParam*/, LPARAM lParam)
{
	// notify the container that the rectangle has changed!
	CWordPadDoc* pDoc = (CWordPadDoc*)GetActiveDocument();
	if (pDoc == NULL)
		return 0;

	ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CWordPadDoc)));

	// get new rect and parent
	CRect rectNew;
	rectNew.CopyRect((LPCRECT)lParam);
	CWnd* pParentWnd = GetParent();
	ASSERT_VALID(pParentWnd);

	// convert rectNew relative to pParentWnd
	ClientToScreen(&rectNew);
	pParentWnd->ScreenToClient(&rectNew);

	if (m_wndRulerBar.GetStyle()&WS_VISIBLE)
	{
		CRect rect;
		m_wndRulerBar.GetWindowRect(&rect);
		rectNew.top += rect.Height();
	}
	rectNew.left += HORZ_TEXTOFFSET;
	rectNew.top += VERT_TEXTOFFSET;

	// adjust the new rectangle for the current control bars
	CWnd* pLeftOver = GetDlgItem(AFX_IDW_PANE_FIRST);
	ASSERT(pLeftOver != NULL);
	CRect rectCur = m_rectPos;
	pLeftOver->CalcWindowRect(&rectCur, CWnd::adjustOutside);
	rectNew.left += m_rectPos.left - rectCur.left;
	rectNew.top += m_rectPos.top - rectCur.top;
	rectNew.right -= rectCur.right - m_rectPos.right;
	rectNew.bottom -= rectCur.bottom - m_rectPos.bottom;
	OnRequestPositionChange(rectNew);

	return 0;
}

LONG CInPlaceFrame::OnBarState(UINT wParam, LONG lParam)
{
	if (lParam == -1)
		return 0L;
	if (wParam == 0)
	{
		GetDockState(theApp.GetDockState(RD_EMBEDDED));
		ASSERT(m_pMainFrame != NULL);
		m_pMainFrame->GetDockState(theApp.GetDockState(RD_EMBEDDED, FALSE));
	}
	else
	{
		SetDockState(theApp.GetDockState(RD_EMBEDDED));
		m_pMainFrame->SetDockState(theApp.GetDockState(RD_EMBEDDED, FALSE));
	}
	return 0L;
}

void CInPlaceFrame::OnHelpFinder() 
{
    ::HtmlHelpA( ::GetDesktopWindow(), "wordpad.chm", HH_DISPLAY_TOPIC, 0L );
}

void CInPlaceFrame::OnCharColor() 
{
	CColorMenu colorMenu;
	CRect rc;
	int index = m_wndFormatBar.CommandToIndex(ID_CHAR_COLOR);
	m_wndFormatBar.GetItemRect(index, &rc);
	m_wndFormatBar.ClientToScreen(rc);
	colorMenu.TrackPopupMenu(TPM_LEFTALIGN|TPM_LEFTBUTTON,rc.left,rc.bottom, this);
}

void CInPlaceFrame::OnPenToggle() 
{
	static int nPen = 0;
	m_wndToolBar.SetButtons(toolButtons, sizeof(toolButtons)/sizeof(UINT) - nPen);
	nPen = (nPen == 0) ? NUM_PEN_TOGGLE : 0;
	m_wndToolBar.Invalidate();
	m_wndToolBar.GetParentFrame()->RecalcLayout();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\mainfrm.h ===
// mainfrm.h : interface of the CMainFrame class
//
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.

#include "formatba.h"
#include "ruler.h"

class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
    CMainFrame();
    DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:
    HICON m_hIconDoc;
    HICON m_hIconText;
    HICON m_hIconWrite;
    HICON GetIcon(int nDocType);

// Operations
public:

// Overrides
    BOOL OnBarCheck(UINT barID);

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    public:
    virtual void ActivateFrame(int nCmdShow = -1);
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

public:
    CToolBar    m_wndToolBar;
    CStatusBar  m_wndStatusBar;
    CFormatBar  m_wndFormatBar;
    CRulerBar   m_wndRulerBar;
protected:  // control bar embedded members
    BOOL CreateToolBar();
    BOOL CreateFormatBar();
    BOOL CreateStatusBar();
    BOOL CreateRulerBar();
// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSysColorChange();
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnMove(int x, int y);
    afx_msg void OnHelpFinder();
    afx_msg void OnDropFiles(HDROP hDropInfo);
    afx_msg void OnCharColor();
    afx_msg void OnPenToggle();
    afx_msg void OnFontChange();
    afx_msg BOOL OnQueryNewPalette();
    afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
    afx_msg void OnDevModeChange(LPTSTR lpDeviceName);
    //}}AFX_MSG
    afx_msg LONG OnBarState(UINT wParam, LONG lParam);
    afx_msg LONG OnOpenMsg(UINT wParam, LONG lParam);
   afx_msg LONG OnOLEHelpMsg(UINT wParam, LONG lParam);
    DECLARE_MESSAGE_MAP()

    virtual void DelayUpdateFrameMenu(HMENU hMenuAlt);
    afx_msg void OnIdleUpdateCmdUI();
    bool    m_inupdate;
    bool    m_reset;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\mainfrm.cpp ===
// mainfrm.cpp : implementation of the CMainFrame class
//
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.

#include "stdafx.h"

#include "wordpad.h"
#include "mainfrm.h"
#include "wordpdoc.h"
#include "wordpvw.h"
#include "strings.h"
#include "colorlis.h"
#include "filedlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_CREATE()
    ON_WM_SYSCOLORCHANGE()
    ON_WM_SIZE()
    ON_WM_MOVE()
    ON_COMMAND(ID_HELP, OnHelpFinder)
    ON_WM_DROPFILES()
    ON_COMMAND(ID_CHAR_COLOR, OnCharColor)
    ON_COMMAND(ID_PEN_TOGGLE, OnPenToggle)
    ON_WM_FONTCHANGE()
    ON_WM_QUERYNEWPALETTE()
    ON_WM_PALETTECHANGED()
    ON_WM_DEVMODECHANGE()
    ON_COMMAND(ID_HELP_INDEX, OnHelpFinder)
    //}}AFX_MSG_MAP
    // Global help commands
//  ON_COMMAND(ID_CONTEXT_HELP, CFrameWnd::OnContextHelp)
    ON_COMMAND(ID_DEFAULT_HELP, OnHelpFinder)
    ON_UPDATE_COMMAND_UI(ID_VIEW_FORMATBAR, OnUpdateControlBarMenu)
    ON_UPDATE_COMMAND_UI(ID_VIEW_RULER, OnUpdateControlBarMenu)
    ON_MESSAGE(WPM_BARSTATE, OnBarState)
    ON_REGISTERED_MESSAGE(CWordPadApp::m_nOpenMsg, OnOpenMsg)
    ON_COMMAND_EX(ID_VIEW_STATUS_BAR, OnBarCheck)
    ON_COMMAND_EX(ID_VIEW_TOOLBAR, OnBarCheck)
    ON_COMMAND_EX(ID_VIEW_FORMATBAR, OnBarCheck)
    ON_COMMAND_EX(ID_VIEW_RULER, OnBarCheck)
   ON_REGISTERED_MESSAGE(CWordPadApp::m_nOLEHelpMsg, OnOLEHelpMsg)

    ON_MESSAGE_VOID(WM_IDLEUPDATECMDUI, OnIdleUpdateCmdUI)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// arrays of IDs used to initialize control bars

// toolbar buttons - IDs are command buttons
static UINT BASED_CODE toolbar[] =
{
    // same order as in the bitmap 'toolbar.bmp'
    // (int nBitmap, int nCommand, BYTE byteState, BYTE byteStyle, DWORD dw, int nString)
    ID_FILE_NEW,
    ID_FILE_OPEN,
    ID_FILE_SAVE,
ID_SEPARATOR,
    ID_FILE_PRINT_DIRECT,
    ID_FILE_PRINT_PREVIEW,
ID_SEPARATOR,
    ID_EDIT_FIND,
ID_SEPARATOR,
    ID_EDIT_CUT,
    ID_EDIT_COPY,
    ID_EDIT_PASTE,
    ID_EDIT_UNDO,
ID_SEPARATOR,
    ID_INSERT_DATE_TIME,
ID_SEPARATOR,
    ID_PEN_TOGGLE,
    ID_PEN_PERIOD,
    ID_PEN_SPACE,
    ID_PEN_BACKSPACE,
    ID_PEN_NEWLINE,
    ID_PEN_LENS
};

#define NUM_PEN_ITEMS 7
#define NUM_PEN_TOGGLE 5

static UINT BASED_CODE format[] =
{
    // same order as in the bitmap 'format.bmp'
        ID_SEPARATOR, // font name combo box
        ID_SEPARATOR,
        ID_SEPARATOR, // font size combo box
        ID_SEPARATOR,
        ID_SEPARATOR, // font script combo box
        ID_SEPARATOR,
    ID_CHAR_BOLD,
    ID_CHAR_ITALIC,
    ID_CHAR_UNDERLINE,
    ID_CHAR_COLOR,
        ID_SEPARATOR,
    ID_PARA_LEFT,
    ID_PARA_CENTER,
    ID_PARA_RIGHT,
        ID_SEPARATOR,
    ID_INSERT_BULLET,
};

static UINT BASED_CODE indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
    m_hIconDoc = theApp.LoadIcon(IDI_ICON_DOC);
    m_hIconText = theApp.LoadIcon(IDI_ICON_TEXT);
    m_hIconWrite = theApp.LoadIcon(IDI_ICON_WRITE);

    m_inupdate = false;
    m_reset = false;
}

CMainFrame::~CMainFrame()
{
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    WNDCLASS wndcls;

    BOOL bRes = CFrameWnd::PreCreateWindow(cs);
    HINSTANCE hInst = AfxGetInstanceHandle();

    // see if the class already exists
    if (!::GetClassInfo(hInst, szWordPadClass, &wndcls))
    {
        // get default stuff
        ::GetClassInfo(hInst, cs.lpszClass, &wndcls);
        wndcls.style &= ~(CS_HREDRAW|CS_VREDRAW);
        // register a new class
        wndcls.lpszClassName = szWordPadClass;
        wndcls.hIcon = ::LoadIcon(hInst, MAKEINTRESOURCE(IDR_MAINFRAME));
        ASSERT(wndcls.hIcon != NULL);
        if (!AfxRegisterClass(&wndcls))
            AfxThrowResourceException();
    }
    cs.lpszClass = szWordPadClass;
    CRect rect = theApp.m_rectInitialFrame;
    if (rect.Width() > 0 && rect.Height() > 0)
    {
        // make sure window will be visible
        CDisplayIC dc;
        CRect rectDisplay(0, 0, dc.GetDeviceCaps(HORZRES),
            dc.GetDeviceCaps(VERTRES));
        if (rectDisplay.PtInRect(rect.TopLeft()) &&
            rectDisplay.PtInRect(rect.BottomRight()))
        {
            cs.x = rect.left;
            cs.y = rect.top;
            cs.cx = rect.Width();
            cs.cy = rect.Height();
        }
    }
    return bRes;
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    if (!CreateToolBar())
        return -1;

    if (!CreateFormatBar())
        return -1;

    if (!CreateStatusBar())
        return -1;

    EnableDocking(CBRS_ALIGN_ANY);

    if (!CreateRulerBar())
        return -1;

    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    m_wndFormatBar.EnableDocking(CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM);
    DockControlBar(&m_wndToolBar);
    DockControlBar(&m_wndFormatBar);

    CWnd* pView = GetDlgItem(AFX_IDW_PANE_FIRST);
    if (pView != NULL)  
    {
        pView->SetWindowPos(&wndBottom, 0, 0, 0, 0,
            SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE);
    }

    return 0;
}

BOOL CMainFrame::CreateToolBar()
{
    int nPen = GetSystemMetrics(SM_PENWINDOWS) ? NUM_PEN_TOGGLE :
        NUM_PEN_ITEMS;
    UINT nID = theApp.m_bLargeIcons ? IDR_MAINFRAME1_BIG :
        IDR_MAINFRAME1;

    // If we have Large Icons then we should specify the correct Image size for
    // the toolbar before calling LoadBitmap because the number of buttons in the
    // toolbar calculated inside MFC (AddReplaceBitmap in BarTool.cpp) as Bitmap width
    // divided by ImageSize.cx. and this conflict with mirroring support if you have
    // incorrect number of buttons .
    if (theApp.m_bLargeIcons)
        m_wndToolBar.SetSizes(CSize(31,30), CSize(24,24));
        
    if (!m_wndToolBar.Create(this,
        WS_CHILD|WS_VISIBLE|CBRS_TOP|CBRS_TOOLTIPS|CBRS_FLYBY|CBRS_SIZE_DYNAMIC)||
        !m_wndToolBar.LoadBitmap(nID) ||
        !m_wndToolBar.SetButtons(toolbar, sizeof(toolbar)/sizeof(UINT) - nPen))
    {
        TRACE0("Failed to create toolbar\n");
        return FALSE;      // fail to create
    }
    if (theApp.m_bLargeIcons)
        m_wndToolBar.SetSizes(CSize(31,30), CSize(24,24));
    else
        m_wndToolBar.SetSizes(CSize(23,22), CSize(16,16));
    CString str;
    str.LoadString(IDS_TITLE_TOOLBAR);
    m_wndToolBar.SetWindowText(str);
    return TRUE;
}

BOOL CMainFrame::CreateFormatBar()
{
    UINT nID = theApp.m_bLargeIcons ? IDB_FORMATBAR_BIG : IDB_FORMATBAR;

    // If we have Large Icons then we should specify the correct Image size for
    // the toolbar before calling LoadBitmap because the number of buttons in the
    // toolbar calculated inside MFC (AddReplaceBitmap in BarTool.cpp) as Bitmap width
    // divided by ImageSize.cx. and this conflict with mirroring support if you have
    // incorrect number of buttons .
    if (theApp.m_bLargeIcons)
        m_wndFormatBar.SetSizes(CSize(31,30), CSize(24,24));
        
    if (!m_wndFormatBar.Create(this,
        WS_CHILD|WS_VISIBLE|CBRS_TOP|CBRS_TOOLTIPS|CBRS_FLYBY|CBRS_HIDE_INPLACE|CBRS_SIZE_DYNAMIC,
        ID_VIEW_FORMATBAR) ||
        !m_wndFormatBar.LoadBitmap(nID) ||
        !m_wndFormatBar.SetButtons(format, sizeof(format)/sizeof(UINT)))
    {
        TRACE0("Failed to create FormatBar\n");
        return FALSE;      // fail to create
    }

    if (theApp.m_bLargeIcons)
        m_wndFormatBar.SetSizes(CSize(31,30), CSize(24,24));
    else
        m_wndFormatBar.SetSizes(CSize(23,22), CSize(16,16));
    CString str;
    str.LoadString(IDS_TITLE_FORMATBAR);
    m_wndFormatBar.SetWindowText(str);
    m_wndFormatBar.PositionCombos();
    return TRUE;
}

BOOL CMainFrame::CreateRulerBar()
{
    if (!m_wndRulerBar.Create(this,
        WS_CHILD|WS_VISIBLE|CBRS_TOP|CBRS_HIDE_INPLACE, ID_VIEW_RULER))
    {
        TRACE0("Failed to create ruler\n");
        return FALSE;      // fail to create
    }
    return TRUE;
}

BOOL CMainFrame::CreateStatusBar()
{
    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return FALSE;      // fail to create
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame Operations

HICON CMainFrame::GetIcon(int nDocType)
{
    switch (nDocType)
    {
        case RD_WINWORD6:
        case RD_WORDPAD:
        case RD_EMBEDDED:
        case RD_RICHTEXT:
            return m_hIconDoc;
        case RD_TEXT:
        case RD_OEMTEXT:
            return m_hIconText;
        case RD_WRITE:
            return m_hIconWrite;
    }
    return m_hIconDoc;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

void CMainFrame::OnFontChange()
{
    m_wndFormatBar.SendMessage(CWordPadApp::m_nPrinterChangedMsg);
}

void CMainFrame::OnDevModeChange(LPTSTR lpDeviceName)
{
    theApp.NotifyPrinterChanged();
    CFrameWnd::OnDevModeChange(lpDeviceName); //sends message to descendants
}

void CMainFrame::OnSysColorChange()
{
    CFrameWnd::OnSysColorChange();
    m_wndRulerBar.SendMessage(WM_SYSCOLORCHANGE);
}

void CMainFrame::ActivateFrame(int nCmdShow)
{
    WINDOWPLACEMENT wp ;

    wp.length = sizeof(WINDOWPLACEMENT) ;

    if (GetWindowPlacement(&wp))
    {
        memcpy(&wp.rcNormalPosition, &theApp.m_rectInitialFrame, sizeof(RECT)) ;

        if (-1 != nCmdShow)
            wp.showCmd = nCmdShow;
        
        SetWindowPlacement(&wp) ;
    }
    
    CFrameWnd::ActivateFrame(nCmdShow);
    // make sure and display the toolbar, ruler, etc while loading a document.
    OnIdleUpdateCmdUI();
    UpdateWindow();
}

void CMainFrame::OnSize(UINT nType, int cx, int cy)
{
    CFrameWnd::OnSize(nType, cx, cy);
    theApp.m_bMaximized = (nType == SIZE_MAXIMIZED);
    if (nType == SIZE_RESTORED)
        GetWindowRect(theApp.m_rectInitialFrame);
}

BOOL CMainFrame::OnBarCheck(UINT barID)
{
    CDocOptions::CBarState &state = theApp.GetDocOptions().GetBarState();
    CControlBar            *bar = GetControlBar(barID);
    BOOL                    bVisible = !(bar->GetStyle() & WS_VISIBLE);

    switch (barID)
    {
    case ID_VIEW_STATUS_BAR: state.m_bStatusBar = bVisible;   break;
    case ID_VIEW_FORMATBAR:  state.m_bFormatBar = bVisible;   break;
    case ID_VIEW_RULER:      state.m_bRulerBar = bVisible;    break;
    case ID_VIEW_TOOLBAR:    state.m_bToolBar = bVisible;     break;
    }

    return CFrameWnd::OnBarCheck(barID);
}

LONG CMainFrame::OnBarState(UINT wParam, LONG lParam)
{
    if (lParam == -1)
        return 0L;
    ASSERT(lParam != RD_EMBEDDED);
    if (wParam == 0)
    {
        CDockState& ds = theApp.GetDockState(lParam);
        ds.Clear(); // empty out the dock state
        GetDockState(ds);
    }
    else
    {
        if (IsTextType(lParam))
        {
            // in text mode hide the ruler and format bar so that it is the default
            CControlBar* pBar = GetControlBar(ID_VIEW_FORMATBAR);
            if (pBar != NULL)
                pBar->ShowWindow(SW_HIDE);
            pBar = GetControlBar(ID_VIEW_RULER);
            if (pBar != NULL)
                pBar->ShowWindow(SW_HIDE);
        }
        HICON hIcon = GetIcon((int)lParam);
        SendMessage(WM_SETICON, TRUE, (LPARAM)hIcon);
        SetDockState(theApp.GetDockState(lParam));
    }
    return 0L;
}

void CMainFrame::OnMove(int x, int y)
{
    CFrameWnd::OnMove(x, y);
    WINDOWPLACEMENT wp;
    wp.length = sizeof(wp);
    GetWindowPlacement(&wp);
    theApp.m_rectInitialFrame = wp.rcNormalPosition;
    CView* pView = GetActiveView();
    if (pView != NULL)
        pView->SendMessage(WM_MOVE);
}

LONG CMainFrame::OnOpenMsg(UINT, LONG lParam)
{
    TCHAR szAtomName[256];
    szAtomName[0] = NULL;
    GlobalGetAtomName((ATOM)lParam, szAtomName, 256);
    CWordPadDoc* pDoc = (CWordPadDoc*)GetActiveDocument();
    if (szAtomName[0] != NULL && pDoc != NULL)
    {
        if (lstrcmpi(szAtomName, pDoc->GetPathName()) == 0)
            return TRUE;
    }
    return FALSE;
}

LONG CMainFrame::OnOLEHelpMsg(UINT, LONG)
{
    CWnd* pMainWnd = AfxGetMainWnd();
    ASSERT_VALID(pMainWnd);

    // return global app help mode state to FALSE (backward compatibility)
    m_bHelpMode = FALSE;
    pMainWnd->PostMessage(WM_KICKIDLE); // trigger idle update

    ::HtmlHelpA( ::GetDesktopWindow(), "wordpad.chm", HH_DISPLAY_TOPIC, 0L );

   return TRUE ;
}

void CMainFrame::OnHelpFinder()
{
    ::HtmlHelpA( ::GetDesktopWindow(), "wordpad.chm", HH_DISPLAY_TOPIC, 0L );
}

void CMainFrame::OnDropFiles(HDROP hDropInfo)
{
    TCHAR szFileName[_MAX_PATH];
    ::DragQueryFile(hDropInfo, 0, szFileName, _MAX_PATH);
    ::DragFinish(hDropInfo);
    theApp.OpenDocumentFile(szFileName);
}

void CMainFrame::OnCharColor()
{
    CColorMenu colorMenu;
    CRect rc;
    int index = m_wndFormatBar.CommandToIndex(ID_CHAR_COLOR);
    m_wndFormatBar.GetItemRect(index, &rc);
    m_wndFormatBar.ClientToScreen(rc);
    colorMenu.TrackPopupMenu(TPM_LEFTALIGN|TPM_LEFTBUTTON,rc.left,rc.bottom, this);
}

void CMainFrame::OnPenToggle()
{
    static int nPen = 0;
    m_wndToolBar.SetButtons(toolbar, sizeof(toolbar)/sizeof(UINT) - nPen);
    nPen = (nPen == 0) ? NUM_PEN_TOGGLE : 0;
    m_wndToolBar.Invalidate();
    m_wndToolBar.GetParentFrame()->RecalcLayout();
}

BOOL CMainFrame::OnQueryNewPalette()
{
    CView* pView = GetActiveView();
    if (pView != NULL)
        return pView->SendMessage(WM_QUERYNEWPALETTE) != 0;
    return FALSE;
}

void CMainFrame::OnPaletteChanged(CWnd* pFocusWnd)
{
    CView* pView = GetActiveView();
    if (pView != NULL)
        pView->SendMessage(WM_PALETTECHANGED, (WPARAM)pFocusWnd->GetSafeHwnd());
}

//
// HACKHACK: MFC has a bug where m_nIdleFlags gets clobbered if the flags are
//           updated during idle processing (MFC4.2).  Workaround it by
//           forcing idleMenu and idleLayout after idle processing if 
//           DelayUpdateFrameMenu gets called during idle processing.
//

void CMainFrame::OnIdleUpdateCmdUI()
{
    m_inupdate = true;
    CFrameWnd::OnIdleUpdateCmdUI();

    if (m_reset)
    {
        m_nIdleFlags |= idleMenu | idleLayout;
        m_reset = false;
    }

    m_inupdate = false;
}

void CMainFrame::DelayUpdateFrameMenu(HMENU hMenuAlt)
{
    if (m_inupdate)
        m_reset = true;

    CFrameWnd::DelayUpdateFrameMenu(hMenuAlt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\mswd6_32.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef MSWD6_32_H
#define MSWD6_32_H

typedef unsigned long (pascal *PFN_RTF_CALLBACK)(int, int);

extern "C" int pascal InitConverter32(HANDLE, char *);
extern "C" HANDLE pascal RegisterApp32(unsigned long, void *);
extern "C" int pascal IsFormatCorrect32(HANDLE, HANDLE);
extern "C" int pascal ForeignToRtf32(HANDLE, void *, HANDLE, HANDLE, HANDLE, PFN_RTF_CALLBACK);
extern "C" int pascal RtfToForeign32(HANDLE, LPSTORAGE, HANDLE, HANDLE, PFN_RTF_CALLBACK);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\oleimpl3.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


/////////////////////////////////////////////////////////////////////////////
// OLE data (like AUX_DATA)

struct OLE_DATA
{
	// OLE 1.0 clipboard formats
	UINT    cfNative, cfOwnerLink, cfObjectLink;

	// OLE 2.0 clipboard formats
	UINT    cfEmbeddedObject, cfEmbedSource, cfLinkSource;
	UINT    cfObjectDescriptor, cfLinkSourceDescriptor;
	UINT    cfFileName, cfFileNameW;

	//RichEdit formats
	UINT    cfRichTextFormat;
	UINT    cfRichTextAndObjects;

	OLE_DATA();
};

extern OLE_DATA _oleData;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\multconv.h ===
// convert.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifdef CONVERTERS

/////////////////////////////////////////////////////////////////////////////
// CConverter

typedef int (CALLBACK *LPFNOUT)(int cch, int nPercentComplete);
typedef int (CALLBACK *LPFNIN)(int flags, int nPercentComplete);
typedef BOOL (FAR PASCAL *PINITCONVERTER)(HWND hWnd, LPCSTR lpszModuleName);
typedef BOOL (FAR PASCAL *PISFORMATCORRECT)(HANDLE ghszFile, HANDLE ghszClass);
typedef int (FAR PASCAL *PFOREIGNTORTF)(HANDLE ghszFile, LPVOID lpv, HANDLE ghBuff, 
	HANDLE ghszClass, HANDLE ghszSubset, LPFNOUT lpfnOut);
typedef int (FAR PASCAL *PRTFTOFOREIGN)(HANDLE ghszFile, LPVOID lpv, HANDLE ghBuff, 
	HANDLE ghszClass, LPFNIN lpfnIn);
typedef HGLOBAL (FAR PASCAL *PREGISTERAPP)(long lFlags, void *lpRegApp);


//
// Some defines taken from the converter group's convapi.h
//

#define fRegAppSupportNonOem    0x00000008  // supports non-Oem filenames
#define RegAppOpcodeCharset             0x03    // for REGAPPRET


#endif

/////////////////////////////////////////////////////////////////////////////
// CTrackFile
class CTrackFile : public CFile
{ 
public:
//Construction
	CTrackFile(CFrameWnd* pWnd);
	~CTrackFile();
	
//Attributes
	int m_nLastPercent;
	DWORD m_dwLength;
	CFrameWnd* m_pFrameWnd;
	CString m_strComplete;
	CString m_strWait;
	CString m_strSaving;
//Operations
	void OutputPercent(int nPercentComplete = 0);
	void OutputString(LPCTSTR lpsz);
	virtual UINT Read(void FAR* lpBuf, UINT nCount);
	virtual void Write(const void FAR* lpBuf, UINT nCount);
};

class COEMFile : public CTrackFile
{
public:
	COEMFile(CFrameWnd* pWnd);
	virtual UINT Read(void FAR* lpBuf, UINT nCount);
	virtual void Write(const void FAR* lpBuf, UINT nCount);
};

#ifdef CONVERTERS

class CConverter : public CTrackFile
{
public:
	CConverter(LPCTSTR pszLibName, CFrameWnd* pWnd = NULL);

public:
//Attributes
	int m_nPercent;
	BOOL m_bDone;
	BOOL m_bConvErr;
	virtual DWORD GetPosition() const;

// Operations
	BOOL IsFormatCorrect(LPCTSTR pszFileName);
	BOOL DoConversion();
	virtual BOOL Open(LPCTSTR lpszFileName, UINT nOpenFlags,
		CFileException* pError = NULL);
	void WaitForConverter();
	void WaitForBuffer();

// Overridables
	virtual LONG Seek(LONG lOff, UINT nFrom);
	virtual DWORD GetLength() const;

	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);

	virtual void Abort();
	virtual void Flush();
	virtual void Close();

// Unsupported
	virtual CFile* Duplicate() const;
	virtual void LockRange(DWORD dwPos, DWORD dwCount);
	virtual void UnlockRange(DWORD dwPos, DWORD dwCount);
	virtual void SetLength(DWORD dwNewLen);

//Implementation
public:
	~CConverter();

protected:
	int         m_nBytesAvail;
	int         m_nBytesWritten;
	HANDLE      m_hEventFile;
	HANDLE      m_hEventConv;
	BOOL        m_bForeignToRtf;        // True to convert to RTF, else from
	HGLOBAL     m_hBuff;                // Buffer for converter data
	BYTE*       m_pBuf;                 // Pointer to m_hBuff data
	HGLOBAL     m_hFileName;            // File to convert
	HINSTANCE   m_hLibCnv;              // The converter dll
    BOOL        m_bUseOEM;              // TRUE to use OEM filenames

    // Entry points into the converter dll

	PINITCONVERTER      m_pInitConverter;
	PISFORMATCORRECT    m_pIsFormatCorrect;
	PFOREIGNTORTF       m_pForeignToRtf;
	PRTFTOFOREIGN       m_pRtfToForeign;
    PREGISTERAPP        m_pRegisterApp;

	int CALLBACK WriteOut(int cch, int nPercentComplete);
	int CALLBACK ReadIn(int nPercentComplete);
	static HGLOBAL StringToHGLOBAL(LPCSTR pstr);
	static int CALLBACK WriteOutStatic(int cch, int nPercentComplete);
	static int CALLBACK ReadInStatic(int flags, int nPercentComplete);
	static UINT AFX_CDECL ConverterThread(LPVOID pParam);
	static CConverter *m_pThis;

	void LoadFunctions();
    void NegotiateForNonOEM();

    #ifndef _X86_

    //We need to change the error mode when using the write converter
    //to fix some alignment problems caused by the write converter.  These
    //problems do not affect x86 platforms.

    UINT m_uPrevErrMode ;

    #endif
};

#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\oleinit.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "stdafx2.h"

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

#ifdef _MAC
AEEventHandlerUPP _afxPfnOleAuto;
#endif

/////////////////////////////////////////////////////////////////////////////
// OLE OLE_DATA init structure

OLE_DATA _oleData;

OLE_DATA::OLE_DATA()
{
	// OLE 1.0 Clipboard formats
	cfNative = ::RegisterClipboardFormat(_T("Native"));
	cfOwnerLink = ::RegisterClipboardFormat(_T("OwnerLink"));
	cfObjectLink = ::RegisterClipboardFormat(_T("ObjectLink"));

	// OLE 2.0 Clipboard formats
	cfEmbeddedObject = ::RegisterClipboardFormat(_T("Embedded Object"));
	cfEmbedSource = ::RegisterClipboardFormat(_T("Embed Source"));
	cfLinkSource = ::RegisterClipboardFormat(_T("Link Source"));
	cfObjectDescriptor = ::RegisterClipboardFormat(_T("Object Descriptor"));
	cfLinkSourceDescriptor = ::RegisterClipboardFormat(_T("Link Source Descriptor"));
	cfFileName = ::RegisterClipboardFormat(_T("FileName"));
	cfFileNameW = ::RegisterClipboardFormat(_T("FileNameW"));
	cfRichTextFormat = ::RegisterClipboardFormat(_T("Rich Text Format"));
	cfRichTextAndObjects = ::RegisterClipboardFormat(_T("RichEdit Text and Objects"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\multconv.cpp ===
// convert.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "multconv.h"
#include "mswd6_32.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifdef CONVERTERS
CConverter* CConverter::m_pThis = NULL;
#endif

#define BUFFSIZE 4096

CTrackFile::CTrackFile(CFrameWnd* pWnd) : CFile()
{
    m_nLastPercent = -1;
    m_dwLength = 0;
    m_pFrameWnd = pWnd;
    VERIFY(m_strComplete.LoadString(IDS_COMPLETE));
    VERIFY(m_strWait.LoadString(IDS_PLEASE_WAIT));
    VERIFY(m_strSaving.LoadString(IDS_SAVING));
//  OutputPercent(0);
}

CTrackFile::~CTrackFile()
{
    OutputPercent(100);
    if (m_pFrameWnd != NULL)
        m_pFrameWnd->SetMessageText(AFX_IDS_IDLEMESSAGE);
}

UINT CTrackFile::Read(void FAR* lpBuf, UINT nCount)
{
    UINT n = CFile::Read(lpBuf, nCount);
    if (m_dwLength != 0)
        OutputPercent((int)((GetPosition()*100)/m_dwLength));
    return n;
}

void CTrackFile::Write(const void FAR* lpBuf, UINT nCount)
{
    CFile::Write(lpBuf, nCount);
    OutputString(m_strSaving);
//  if (m_dwLength != 0)
//      OutputPercent((int)((GetPosition()*100)/m_dwLength));
}

void CTrackFile::OutputString(LPCTSTR lpsz)
{
    if (m_pFrameWnd != NULL)
    {
        m_pFrameWnd->SetMessageText(lpsz);
        CWnd* pBarWnd = m_pFrameWnd->GetMessageBar();
        if (pBarWnd != NULL)
            pBarWnd->UpdateWindow();
    }
}

void CTrackFile::OutputPercent(int nPercentComplete)
{
    if (m_pFrameWnd != NULL && m_nLastPercent != nPercentComplete)
    {
        m_nLastPercent = nPercentComplete;
        TCHAR buf[64];
        int n = nPercentComplete;
        if (SUCCEEDED(StringCchPrintf(buf, ARRAYSIZE(buf), (n==100) ? m_strWait : m_strComplete, n)))
        {
            OutputString(buf);
        }
    }
}

COEMFile::COEMFile(CFrameWnd* pWnd) : CTrackFile(pWnd)
{
}

UINT COEMFile::Read(void FAR* lpBuf, UINT nCount)
{
    UINT n = CTrackFile::Read(lpBuf, nCount);
    OemToCharBuffA((const char*)lpBuf, (char*)lpBuf, n);
    return n;
}

void COEMFile::Write(const void FAR* lpBuf, UINT nCount)
{
    CharToOemBuffA((const char*)lpBuf, (char*)lpBuf, nCount);
    CTrackFile::Write(lpBuf, nCount);
}

#ifdef CONVERTERS

HGLOBAL CConverter::StringToHGLOBAL(LPCSTR pstr)
{
    HGLOBAL hMem = NULL;
    if (pstr != NULL)
    {
        size_t cch = (lstrlenA(pstr)*2) + 1; // Why are we allocating this much?
        hMem = GlobalAlloc(GHND, cch);
        if (NULL == hMem)
            AfxThrowMemoryException();
        char* p = (char*) GlobalLock(hMem);
        if (p != NULL)
            EVAL(StringCchCopyA(p, cch, pstr) == S_OK);
        GlobalUnlock(hMem);
    }
    return hMem;
}

CConverter::CConverter(LPCTSTR pszLibName, CFrameWnd* pWnd) : CTrackFile(pWnd)
{
    USES_CONVERSION;
    m_hBuff = NULL;
    m_pBuf = NULL;
    m_nBytesAvail = 0;
    m_nBytesWritten = 0;
    m_nPercent = 0;
    m_hEventFile = NULL;
    m_hEventConv = NULL;
    m_bDone = TRUE;
    m_bConvErr = FALSE;
    m_hFileName = NULL;
    m_bUseOEM = TRUE;

    #ifndef _X86_

    //Prevent known alignment exception problems in write converter
    //from crashing the app on some RISC machines

    m_uPrevErrMode = SetErrorMode(SEM_NOALIGNMENTFAULTEXCEPT);

    #endif

    // Safe to call LoadLibrary - this should be a fully-qualified pathname.
    m_hLibCnv = LoadLibrary(pszLibName);

    if (NULL != m_hLibCnv)
    {
        LoadFunctions();
        ASSERT(m_pInitConverter != NULL);
        if (m_pInitConverter != NULL)
        {
         //
         // For the current converters, you have to pass a *static*
         // string to InitConverter32
         //

            VERIFY(m_pInitConverter(AfxGetMainWnd()->GetSafeHwnd(), "WORDPAD"));
        }

        if (m_pRegisterApp != NULL)
        {
            NegotiateForNonOEM();
        }
    }
}

CConverter::~CConverter()
{
    if (!m_bDone) // converter thread hasn't exited
    {
        m_bDone = TRUE;

        if (!m_bForeignToRtf)
            WaitForConverter();

        m_nBytesAvail = 0;
        VERIFY(ResetEvent(m_hEventFile));
        m_nBytesAvail = 0;
        SetEvent(m_hEventConv);
        WaitForConverter();// wait for DoConversion exit
        VERIFY(ResetEvent(m_hEventFile));
    }

    if (m_hEventFile != NULL)
        VERIFY(CloseHandle(m_hEventFile));
    if (m_hEventConv != NULL)
        VERIFY(CloseHandle(m_hEventConv));
    if (m_hLibCnv != NULL)
        FreeLibrary(m_hLibCnv);
    if (m_hFileName != NULL)
        GlobalFree(m_hFileName);

    #ifndef _X86_

    //Reset error mode to what it was before we changed it in
    //the constructor

    SetErrorMode(m_uPrevErrMode);

    #endif
}

void CConverter::WaitForConverter()
{
    // while event not signalled -- process messages
    while (MsgWaitForMultipleObjects(1, &m_hEventFile, FALSE, INFINITE,
        QS_SENDMESSAGE) != WAIT_OBJECT_0)
    {
        MSG msg;
        while (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
}

void CConverter::WaitForBuffer()
{
    // while event not signalled -- process messages
    while (MsgWaitForMultipleObjects(1, &m_hEventConv, FALSE, INFINITE,
        QS_SENDMESSAGE) != WAIT_OBJECT_0)
    {
        MSG msg;
        while (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
}

UINT AFX_CDECL CConverter::ConverterThread(LPVOID)  // AFX_CDECL added by t-stefb
{
    ASSERT(m_pThis != NULL);

#if defined(_DEBUG)
    HRESULT hRes = OleInitialize(NULL);
    ASSERT(hRes == S_OK || hRes == S_FALSE);
#else
    OleInitialize(NULL);
#endif

    m_pThis->DoConversion();
    OleUninitialize();

    return 0;
}

BOOL CConverter::IsFormatCorrect(LPCWSTR pszFileName)
{
    BOOL bRet = FALSE;
    if (m_hLibCnv == NULL || m_pIsFormatCorrect == NULL)
    {
        bRet = FALSE;
    }
    else
    {
        char buf[_MAX_PATH];
        if (WideCharToMultiByte(CP_ACP, 0, pszFileName, -1, buf, ARRAYSIZE(buf), NULL, NULL))
        {
            if (m_bUseOEM)
                CharToOemA(buf, buf);

            HGLOBAL hFileName = StringToHGLOBAL(buf);
            HGLOBAL hDesc = GlobalAlloc(GHND, 256);
            if (NULL == hDesc)
                AfxThrowMemoryException();
            int nRet = m_pIsFormatCorrect(hFileName, hDesc);
            GlobalFree(hDesc);
            GlobalFree(hFileName);
            bRet = (nRet == 1) ? TRUE : FALSE;
        }
        else
        {
            bRet = FALSE;
        }
    }
    return bRet;
}

// static callback function
int CALLBACK CConverter::WriteOutStatic(int cch, int nPercentComplete)
{
    ASSERT(m_pThis != NULL);
    return m_pThis->WriteOut(cch, nPercentComplete);
}

int CALLBACK CConverter::WriteOut(int cch, int nPercentComplete)
{
    ASSERT(m_hBuff != NULL);
    m_nPercent = nPercentComplete;
    if (m_hBuff == NULL)
        return -9;

    //
    // If m_bDone is TRUE that means the richedit control has stopped
    // streaming in text and is trying to destroy the CConverter object but
    // the converter still has more data to give
    //

    if (m_bDone)
    {
        ASSERT(!"Richedit control stopped streaming prematurely");
        AfxMessageBox(IDS_CONVERTER_ABORTED);
        return -9;
    }

    if (cch != 0)
    {
        WaitForBuffer();
        VERIFY(ResetEvent(m_hEventConv));
        m_nBytesAvail = cch;
        SetEvent(m_hEventFile);
        WaitForBuffer();
    }
    return 0; //everything OK
}

int CALLBACK CConverter::ReadInStatic(int /*flags*/, int nPercentComplete)
{
    ASSERT(m_pThis != NULL);
    return m_pThis->ReadIn(nPercentComplete);
}

int CALLBACK CConverter::ReadIn(int /*nPercentComplete*/)
{
    ASSERT(m_hBuff != NULL);
    if (m_hBuff == NULL)
        return -8;

    SetEvent(m_hEventFile);
    WaitForBuffer();
    VERIFY(ResetEvent(m_hEventConv));

    return m_nBytesAvail;
}

BOOL CConverter::DoConversion()
{
    USES_CONVERSION;
    m_nLastPercent = -1;
//  m_dwLength = 0; // prevent Read/Write from displaying
    m_nPercent = 0;

    ASSERT(m_hBuff != NULL);
    ASSERT(m_pThis != NULL);
    HGLOBAL hDesc = StringToHGLOBAL("");
    HGLOBAL hSubset = StringToHGLOBAL("");

    int nRet = -1;
    if (m_bForeignToRtf && NULL != m_pForeignToRtf)
    {
        ASSERT(m_pForeignToRtf != NULL);
        ASSERT(m_hFileName != NULL);
        nRet = m_pForeignToRtf(m_hFileName, NULL, m_hBuff, hDesc, hSubset,
            (LPFNOUT)WriteOutStatic);
        // wait for next CConverter::Read to come through
        WaitForBuffer();
        VERIFY(ResetEvent(m_hEventConv));
    }
    else if (!m_bForeignToRtf && NULL != m_pRtfToForeign)
    {
        ASSERT(m_pRtfToForeign != NULL);
        ASSERT(m_hFileName != NULL);
        nRet = m_pRtfToForeign(m_hFileName, NULL, m_hBuff, hDesc,
            (LPFNIN)ReadInStatic);
        // don't need to wait for m_hEventConv
    }

    GlobalFree(hDesc);
    GlobalFree(hSubset);
    if (m_pBuf != NULL)
        GlobalUnlock(m_hBuff);
    GlobalFree(m_hBuff);

    if (nRet != 0)
        m_bConvErr = TRUE;

    m_bDone = TRUE;
    m_nPercent = 100;
    m_nLastPercent = -1;

    SetEvent(m_hEventFile);

    return (nRet == 0);
}

void CConverter::LoadFunctions()
{
    m_pInitConverter = (PINITCONVERTER)GetProcAddress(m_hLibCnv, "InitConverter32");
    m_pIsFormatCorrect = (PISFORMATCORRECT)GetProcAddress(m_hLibCnv, "IsFormatCorrect32");
    m_pForeignToRtf = (PFOREIGNTORTF)GetProcAddress(m_hLibCnv, "ForeignToRtf32");
    m_pRtfToForeign = (PRTFTOFOREIGN)GetProcAddress(m_hLibCnv, "RtfToForeign32");
    m_pRegisterApp = (PREGISTERAPP) GetProcAddress(m_hLibCnv, "RegisterApp");
}
#endif // #ifdef CONVERTERS

///////////////////////////////////////////////////////////////////////////////

BOOL CConverter::Open(LPCWSTR pszFileName, UINT nOpenFlags,
    CFileException* pException)
{
    USES_CONVERSION;
    BOOL bRet;
    // The converters only speak ansi
    char buf[_MAX_PATH];
    if (WideCharToMultiByte(CP_ACP, 0, pszFileName, -1, buf, ARRAYSIZE(buf), NULL, NULL))
    {
        if (m_bUseOEM)
            CharToOemA(buf, buf);

        // let's make sure we could do what is wanted directly even though we aren't
        m_bCloseOnDelete = FALSE;
        m_hFile = (UINT_PTR)hFileNull;

        BOOL bOpen = CFile::Open(pszFileName, nOpenFlags, pException);
        CFile::Close();
        if (!bOpen)
            return FALSE;

        m_bForeignToRtf = !(nOpenFlags & (CFile::modeReadWrite | CFile::modeWrite));

        // check for reading empty file
        if (m_bForeignToRtf)
        {
            CFileStatus _stat;
            if (CFile::GetStatus(pszFileName, _stat) && _stat.m_size == 0)
                return TRUE;
        }

        //create the events
        m_hEventFile = CreateEvent(NULL, TRUE, FALSE, NULL);
        m_hEventConv = CreateEvent(NULL, TRUE, FALSE, NULL);
        //create the converter thread and create the events

        ASSERT(m_hFileName == NULL);
        m_hFileName = StringToHGLOBAL(buf);

        m_pThis = this;
        m_bDone = FALSE;
        m_hBuff = GlobalAlloc(GHND, BUFFSIZE);
        ASSERT(m_hBuff != NULL);

        AfxBeginThread(ConverterThread, this, THREAD_PRIORITY_NORMAL, 0, 0, NULL);
        bRet = TRUE;
    }
    else
    {
        bRet = FALSE;
    }
    return bRet;
}

// m_hEventConv -- the main thread signals this event when ready for more data
// m_hEventFile -- the converter signals this event when data is ready

UINT CConverter::Read(void FAR* lpBuf, UINT nCount)
{
    ASSERT(m_bForeignToRtf);
    if (m_bDone)
        return 0;
    // if converter is done
    int cch = nCount;
    BYTE* pBuf = (BYTE*)lpBuf;
    while (cch != 0)
    {
        if (m_nBytesAvail == 0)
        {
            if (m_pBuf != NULL)
                GlobalUnlock(m_hBuff);
            m_pBuf = NULL;
            SetEvent(m_hEventConv);
            WaitForConverter();
            VERIFY(ResetEvent(m_hEventFile));
            if (m_bConvErr)
                AfxThrowFileException(CFileException::generic);
            if (m_bDone)
                return nCount - cch;
            m_pBuf = (BYTE*)GlobalLock(m_hBuff);
            ASSERT(m_pBuf != NULL);
        }
        int nBytes = min(cch, m_nBytesAvail);
        memcpy(pBuf, m_pBuf, nBytes);
        pBuf += nBytes;
        m_pBuf += nBytes;
        m_nBytesAvail -= nBytes;
        cch -= nBytes;
        OutputPercent(m_nPercent);
    }
    return nCount - cch;
}

void CConverter::Write(const void FAR* lpBuf, UINT nCount)
{
    ASSERT(!m_bForeignToRtf);

    m_nBytesWritten += nCount;
    while (nCount != 0)
    {
        WaitForConverter();
        VERIFY(ResetEvent(m_hEventFile));
        if (m_bConvErr)
            AfxThrowFileException(CFileException::generic);
        m_nBytesAvail = min(nCount, BUFFSIZE);
        nCount -= m_nBytesAvail;
        BYTE* pBuf = (BYTE*)GlobalLock(m_hBuff);
        ASSERT(pBuf != NULL);
        memcpy(pBuf, lpBuf, m_nBytesAvail);
        GlobalUnlock(m_hBuff);
        SetEvent(m_hEventConv);
    }
    OutputString(m_strSaving);
}

LONG CConverter::Seek(LONG lOff, UINT nFrom)
{
    if (lOff != 0 && nFrom != current)
        AfxThrowNotSupportedException();
    return 0;
}

DWORD CConverter::GetPosition() const
{
    return 0;
}

void CConverter::Flush()
{
}

void CConverter::Close()
{
    if (!m_bDone) // converter thread hasn't exited
    {
        m_bDone = TRUE;

        if (!m_bForeignToRtf)
            WaitForConverter();

        m_nBytesAvail = 0;
        VERIFY(ResetEvent(m_hEventFile));
        m_nBytesAvail = 0;
        SetEvent(m_hEventConv);
        WaitForConverter();// wait for DoConversion exit
        VERIFY(ResetEvent(m_hEventFile));
    }

    if (m_bConvErr)
        AfxThrowFileException(CFileException::generic);
}

void CConverter::Abort()
{
}

DWORD CConverter::GetLength() const
{
    ASSERT_VALID(this);
    return 1;
}

CFile* CConverter::Duplicate() const
{
    AfxThrowNotSupportedException();
    return NULL;
}

void CConverter::LockRange(DWORD, DWORD)
{
    AfxThrowNotSupportedException();
}

void CConverter::UnlockRange(DWORD, DWORD)
{
    AfxThrowNotSupportedException();
}

void CConverter::SetLength(DWORD)
{
    AfxThrowNotSupportedException();
}



//+--------------------------------------------------------------------------
//
//  Method:     CConverter::NegotiateForNonOEM
//
//  Synopsis:   Try to tell the converter not to expect OEM filenames
//
//  Parameters: None
//
//  Returns:    void
//
//  Notes:      The converter's RegisterApp function will return a handle
//              containing it's preferences (what it supports).  The
//              data structure is a 16-bit size and then a sequence of
//              records.  For each record the first byte is the size, the
//              second is the "opcode", and then some variable-length opcode
//              specific data.  All sizes are inclusive.
//
//---------------------------------------------------------------------------

void CConverter::NegotiateForNonOEM()
{
    ASSERT(NULL != m_pRegisterApp);

    HGLOBAL     hPrefs;
    BYTE       *pPrefs;
    __int16     cbPrefs;

    //
    // Tell the converter we don't want to use OEM
    //

    hPrefs = (*m_pRegisterApp)(fRegAppSupportNonOem, NULL);

    if (NULL == hPrefs)
        return;

    pPrefs = (BYTE *) GlobalLock(hPrefs);

    if (NULL == pPrefs)
    {
        ASSERT(!"GlobalLock failed");
        GlobalFree(hPrefs);
        return;
    }

    //
    // Parse the returned structure looking for a RegAppOpcodeCharset opcode.
    // The argument for this opcode should be either ANSI_CHARSET or
    // OEM_CHARSET.  If its ANSI_CHARSET then we can talk Ansi otherwise were
    // stuck with OEM.
    //

    cbPrefs = (__int16) ((* (__int16 *) pPrefs) - sizeof(cbPrefs));
    pPrefs += sizeof(cbPrefs);

    while (cbPrefs > 0)
    {
        if (RegAppOpcodeCharset == pPrefs[1])
        {
            ASSERT(ANSI_CHARSET == pPrefs[2] || OEM_CHARSET == pPrefs[2]);

            m_bUseOEM = (OEM_CHARSET == pPrefs[2]);
            break;
        }
        else
        {
            if (pPrefs[0] <= 0)
            {
                ASSERT(!"RegisterApp is returning bogus data");
                break;
            }

            cbPrefs = (__int16) (cbPrefs - pPrefs[0]);
            pPrefs += pPrefs[0];
        }
    }

    GlobalUnlock(pPrefs);
    GlobalFree(hPrefs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\options.cpp ===
// options.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "strings.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDocOptions


void CDocOptions::SaveDockState(CDockState& ds, LPCTSTR lpszProfileName, LPCTSTR lpszLayout)
{
    CMemFile file;
    CArchive ar(&file, CArchive::store);
    ds.Serialize(ar);
    ar.Close();
    int nSize = file.GetLength();
    ASSERT(nSize < 4096);
    BYTE* p = new BYTE[nSize];
    file.SeekToBegin();
    file.Read(p, nSize);
    theApp.WriteProfileBinary(lpszProfileName, lpszLayout, p, nSize);
    delete [] p;
}

void CDocOptions::SaveOptions(LPCTSTR lpszProfileName)
{
    SaveDockState(m_ds1, lpszProfileName, szLayout1);
    SaveDockState(m_ds2, lpszProfileName, szLayout2);
    theApp.WriteProfileInt(lpszProfileName, szWrap, m_nWordWrap);

    int barstate[2] = {0, 0};

    for (int i = 0; i < 2; i++)
    {
        barstate[i] = barstate[i] | (m_barstate[i].m_bRulerBar  ? 0x1 : 0);
        barstate[i] = barstate[i] | (m_barstate[i].m_bStatusBar ? 0x2 : 0);
        barstate[i] = barstate[i] | (m_barstate[i].m_bToolBar   ? 0x4 : 0);
        barstate[i] = barstate[i] | (m_barstate[i].m_bFormatBar ? 0x8 : 0);
    }

    theApp.WriteProfileInt(lpszProfileName, TEXT("BarState0"), barstate[0]);
    theApp.WriteProfileInt(lpszProfileName, TEXT("BarState1"), barstate[1]);
}

void CDocOptions::LoadDockState(CDockState& ds, LPCTSTR lpszProfileName, LPCTSTR lpszLayout)
{
    BYTE* p;
    UINT nLen = 0;
    if (theApp.GetProfileBinary(lpszProfileName, lpszLayout, &p, &nLen))
    {
        ASSERT(nLen < 4096);

      //
      // APPCOMPAT: If this value is not reasonable, then we have likely run into
      // a registry corruption problem with wordpad that seems to appear only once
      // every 2-3 months.  If the registry is corrupted, then we need to fix
      // it or wordpad will get into a weird state.
      //

      if (nLen >= 4096)
      {
          delete p ;

          HKEY hKeyApp = theApp.GetAppRegistryKey() ;

          if ((HKEY) 0 != hKeyApp)
          {
              RegDeleteKey(hKeyApp, lpszProfileName) ;
              RegCloseKey(hKeyApp) ;
          }
      }
      else
      {
            CMemFile file;
            file.Write(p, nLen);
            file.SeekToBegin();
            CArchive ar(&file, CArchive::load);
            ds.Serialize(ar);
            ar.Close();
            delete p;
      }
    }
}


void CDocOptions::LoadOptions(LPCTSTR lpszProfileName)
{
    LoadDockState(m_ds1, lpszProfileName, szLayout1);
    LoadDockState(m_ds2, lpszProfileName, szLayout2);
    m_nWordWrap = _VerifyWordWrap(theApp.GetProfileInt(lpszProfileName, szWrap, m_nDefWrap));

    for (int bar = 0; bar < 2; bar++)
    {
        CDockState& ds = (bar == 0) ? m_ds1 : m_ds2;
        CBarState& barstate = m_barstate[bar];

        int defaultstate = (lpszProfileName == szTextSection) ? 0x6 : 0xf;
        int state;

        if (0 == bar)
        {
            state = theApp.GetProfileInt(lpszProfileName, TEXT("BarState0"), defaultstate);
        }
        else
        {
            state = theApp.GetProfileInt(lpszProfileName, TEXT("BarState1"), defaultstate);
        }

        barstate.m_bRulerBar =  (state & 0x1) != 0;
        barstate.m_bStatusBar = (state & 0x2) != 0;
        barstate.m_bToolBar =   (state & 0x4) != 0;
        barstate.m_bFormatBar = (state & 0x8) != 0;

        //
        // The following code is used to setup the barstate from the dock state.
        // It is really only here to support upgrading from NT 4 or Win95 to
        // NT 5 or Memphis.  It can problably be removed for NT 6.
        //

        for (int i = 0;i < ds.m_arrBarInfo.GetSize(); i++)
        {
            CControlBarInfo* pInfo = (CControlBarInfo*)ds.m_arrBarInfo[i];
            ASSERT(pInfo != NULL);
            switch (pInfo->m_nBarID)
            {
                case ID_VIEW_FORMATBAR:
                    barstate.m_bFormatBar = pInfo->m_bVisible;
                    break;
                case ID_VIEW_RULER:
                    barstate.m_bRulerBar = pInfo->m_bVisible;
                    break;
                case ID_VIEW_TOOLBAR:
                    barstate.m_bToolBar = pInfo->m_bVisible;;
                    break;
                case ID_VIEW_STATUS_BAR:
                    barstate.m_bStatusBar = pInfo->m_bVisible;;
                    break;
            }
        }
    }
    
}

/////////////////////////////////////////////////////////////////////////////
// CUnit

const CUnit& CUnit::operator=(const CUnit& unit)
{
    m_nTPU = unit.m_nTPU;
    m_nSmallDiv = unit.m_nSmallDiv;
    m_nMediumDiv = unit.m_nMediumDiv;
    m_nLargeDiv = unit.m_nLargeDiv;
    m_nMinMove = unit.m_nMinMove;
    m_nAbbrevID = unit.m_nAbbrevID;
    m_bSpaceAbbrev = unit.m_bSpaceAbbrev;
    m_strAbbrev = unit.m_strAbbrev;
    return *this;
}

CUnit::CUnit(int nTPU, int nSmallDiv, int nMediumDiv, int nLargeDiv,
        int nMinMove, UINT nAbbrevID, BOOL bSpaceAbbrev)
{
    m_nTPU = nTPU;
    m_nSmallDiv = nSmallDiv;
    m_nMediumDiv = nMediumDiv;
    m_nLargeDiv = nLargeDiv;
    m_nMinMove = nMinMove;
    m_nAbbrevID = nAbbrevID;
    m_bSpaceAbbrev = bSpaceAbbrev;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\options.h ===
// options.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CUnit
{
public:
	int m_nTPU;
	int m_nSmallDiv;	// small divisions - small line displayed
	int m_nMediumDiv;	// medium divisions - large line displayed
	int m_nLargeDiv;	// large divisions - numbers displayed
	int m_nMinMove;		// minimum tracking movements
	UINT m_nAbbrevID;
	BOOL m_bSpaceAbbrev; // put space before abbreviation
	CString m_strAbbrev;// cm, pt, pi, ", in, inch, inches

	CUnit() {}
	CUnit(int nTPU, int nSmallDiv, int nMediumDiv, int nLargeDiv, 
		int nMinMove, UINT nAbbrevID, BOOL bSpaceAbbrev);
	const CUnit& operator=(const CUnit& unit);
};

class CDocOptions
{
public:
	CDocOptions(int nDefWrap) {m_nDefWrap = nDefWrap;}
	CDockState m_ds1;
	CDockState m_ds2;

	int m_nWordWrap;
	int m_nDefWrap;

    struct CBarState
    {
        BOOL m_bRulerBar;
        BOOL m_bStatusBar;
        BOOL m_bToolBar;
        BOOL m_bFormatBar;
    }
    m_barstate[2];

	void SaveOptions(LPCTSTR lpsz);
	void LoadOptions(LPCTSTR lpsz);
	void SaveDockState(CDockState& ds, LPCTSTR lpszProfileName, 
		LPCTSTR lpszLayout);
	void LoadDockState(CDockState& ds, LPCTSTR lpszProfileName, 
		LPCTSTR lpszLayout);
	CDockState& GetDockState(BOOL bPrimary) {return (bPrimary) ? m_ds1 : m_ds2;}
    CBarState & GetBarState(BOOL bPrimary = TRUE) {return bPrimary ? m_barstate[0] : m_barstate[1];}
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\pageset.h ===
// pageset.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CPageSetupDlg dialog

class CPageSetupDlg : public CCSDialog
{
// Construction
public:
	CPageSetupDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CPageSetupDlg)
	enum { IDD = IDD_PAGE_SETUP_DIALOG };
	int		m_nTopMargin;
	int		m_nRightMargin;
	int		m_nLeftMargin;
	int		m_nBottomMargin;
	//}}AFX_DATA

// Implementation
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

	// Generated message map functions
	//{{AFX_MSG(CPageSetupDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\optionsh.h ===
// optionsh.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// COptionSheet

class COptionSheet : public CCSPropertySheet
{
// Construction
public:
	COptionSheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:
	CUnitsPage units;
	CDocOptPage pageText;
	CDocOptPage pageRTF;
	CDocOptPage pageWord;
	CDocOptPage pageWrite;
	CEmbeddedOptPage pageEmbedded;

// Operations
public:
	INT_PTR DoModal();
	void SetPageButtons(CDocOptPage& page, CDocOptions& options, BOOL bPrimary = TRUE);
	void SetState(CDocOptPage& page, CDocOptions& optiosn, BOOL bPrimary = TRUE);

// Overrides
    virtual LONG OnHelp(WPARAM, LPARAM lParam);
    virtual LONG OnHelpContextMenu(WPARAM, LPARAM lParam);

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COptionSheet)
	//}}AFX_VIRTUAL

// Implementation
public:

	// Generated message map functions
protected:
	//{{AFX_MSG(COptionSheet)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wordpad.rc
//
#define IDR_SRVR_INPLACE                4
#define IDR_SRVR_EMBEDDED               5
#define IDR_CNTR_INPLACE                6
#define IDP_OLE_INIT_FAILED             100
#define IDP_FAILED_TO_CREATE            102
#define IDS_INVALID_MEASUREMENT         103
#define IDS_PLEASE_WAIT                 104
#define IDS_COMPLETE                    105
#define IDS_SAVE_UNSUPPORTED            106
#define IDS_CLOSE_TEXT                  107
#define IDS_RICHED_LOAD_FAIL            108
#define IDC_COMBO_ALIGNMENT             111
#define IDS_DEFAULTTEXTFONT             111
#define IDS_SAVE_FORMAT_TEXT            112
#define IDS_SAVE_FORMAT                 113
#define IDS_SAVING                      113
#define IDS_CLIP_RTF                    114
#define IDS_FORMATTING                  115
#define IDS_LEFT                        116
#define IDS_CENTER                      117
#define IDS_RIGHT                       118
#define IDS_NOWRAP                      119
#define IDS_MEASUREMENT_RANGE           119
#define IDS_WRAPTOWINDOW                120
#define IDS_INVALID_NUMBER              120
#define IDS_WRAPTORULER                 121
#define IDS_INVALID_FONTSIZE            121
#define IDS_INCHES                      122
#define IDS_CENTIMETERS                 123
#define IDS_POINTS                      124
#define IDS_PICAS                       125
#define IDR_MAINFRAME                   128
#define IDS_TEXT_DOC                    129
#define IDS_RICHTEXT_DOC                130
#define IDB_BITMAP_TT                   130
#define IDS_WRITE_DOC                   131
#define IDB_RULER_BLOCK                 131
#define IDS_ALL_DOC                     132
#define IDB_RULER_BLOCKM                132
#define IDS_WINWORD6_DOC                133
#define IDB_RULER_DOWN                  133
#define IDS_WINWORD2_DOC                134
#define IDB_RULER_DOWNM                 134
#define IDB_RULER_TAB                   135
#define IDB_RULER_TABM                  136
#define IDS_FILE_EXISTS                 136
#define IDB_RULER_UP                    137
#define IDS_MAPILOAD_FAILED             137
#define IDS_OEMTEXT_DOC                 137
#define IDB_RULER_UPM                   138
#define IDS_CLIP_TEXT                   138
#define IDB_FORMATBAR                   139
#define IDS_CLIP_FILENAME               139
#define IDR_MAINFRAME1                  140
#define IDB_FORMATBAR_BIG               141
#define IDR_COLOR_MENU                  142
#define IDR_MAINFRAME_BIG               142
#define IDD_FORMAT_PARA                 143
#define IDR_MAINFRAME1_BIG              143
#define IDR_SRVR_INPLACE_BIG            144
#define IDD_FORMAT_TAB                  145
#define IDD_LISTDIALOG                  147
#define IDD_OPTIONS                     148
#define IDS_DT1                         149
#define IDD_PAGE_SETUP_DIALOG           150
#define IDS_DT2                         150
#define IDR_MENU1                       151
#define IDS_DT3                         151
#define IDD_DATEDIALOG                  151
#define IDS_DT4                         152
#define IDR_TEXT_POPUP                  152
#define IDS_DT5                         153
#define IDS_DT6                         154
#define IDI_ICON_DOC                    154
#define IDS_DT7                         155
#define IDI_ICON_WRITE                  155
#define IDS_DT8                         156
#define IDS_DT9                         157
#define IDD_SPLASH                      157
#define IDS_DT10                        158
#define IDD_OPTIONS_UNITS               158
#define IDS_DT11                        159
#define IDD_OPTIONS_WRAP                159
#define IDS_DT12                        160
#define IDD_OPTIONS_MARGINS             160
#define IDD_FILENEWDIALOG               160
#define IDS_DT13                        161
#define IDB_BITMAP48                    162
#define IDB_BITMAP_PRINTER              163
#define IDS_FINISHED_SEARCH             164
#define IDC_FONTNAME                    165
#define IDI_ICON_TEXT                   165
#define IDC_FONTSIZE                    166
#define IDS_TITLE_FORMATBAR             167
#define IDB_PRINTER                     167
#define IDB_FONTTYPE                    167
#define IDS_TITLE_TOOLBAR               168
#define IDS_INCH1_ABBREV                169
#define IDS_INCH2_ABBREV                170
#define IDS_INCH3_ABBREV                171
#define IDS_INCH4_ABBREV                172
#define IDS_CM_ABBREV                   173
#define IDS_POINT_ABBREV                174
#define IDS_PICA_ABBREV                 175
#define IDS_NOMORETABS                  176
#define IDS_MAPI_FAIL                   177
#define IDS_ERRSPACE                    178
#define IDS_CANT_LOAD                   179
#define IDS_TOOMANYFILES                180
#define IDS_DIRFULL                     181
#define IDS_SHAREVIOLATION              182
#define IDS_TEXT_OPTIONS                183
#define IDS_RTF_OPTIONS                 184
#define IDS_WORD6_OPTIONS               185
#define IDS_OPTIONS                     186
#define IDS_WRITE_OPTIONS               187
#define IDS_EMBEDDED_OPTIONS            188
#define IDS_TEXT_DOCUMENT               189
#define IDS_RTF_DOCUMENT                190
#define IDS_WORD6_DOCUMENT              191
#define IDS_WRITEPROTECT                192
#define IDS_UNICODETEXT_DOC             193
#define IDS_UNICODETEXT_DOCUMENT        194
#define IDS_CONVERTER_ABORTED           195
#define IDS_WORD97_DOC                  196
#define IDS_FEWINWORD5_DOC              198
#define IDS_INCH1_NOLOC                 199
#define IDS_INCH2_NOLOC                 200
#define IDS_INCH3_NOLOC                 201
#define IDS_INCH4_NOLOC                 202
#define IDS_CM_NOLOC                    203
#define IDS_POINT_NOLOC                 204
#define IDS_PICA_NOLOC                  205
#define IDS_FILENAME_TO_LONG            206
#define IDC_SCRIPT                      207
#define IDS_WRI_DOC                     208
#define IDS_WORDPAD_DOCUMENT            209
#define IDC_EDIT_LEFT                   1000
#define IDC_EDIT_RIGHT                  1001
#define IDC_EDIT_FIRST_LINE             1002
#define IDC_BUTTON_SET                  1005
#define IDC_EDIT_BM                     1005
#define IDC_BUTTON_CLEAR                1006
#define IDC_EDIT_LM                     1006
#define IDC_BUTTON_CLEARALL             1007
#define IDC_EDIT_RM                     1007
#define IDC_STATIC_HEADING              1009
#define IDC_COMBO_WRAP                  1011
#define IDC_COMBO_UNITS                 1012
#define IDC_EDIT_TM                     1016
#define IDC_TEXT_ALIGNMENT              1017
#define IDC_LISTDIALOG_LIST             1018
#define IDC_DATEDIALOG_LIST             1018
#define IDC_COMBO1                      1019
#define IDC_TEXT_WRAP                   1020
#define IDC_TEXT_UNITS                  1021
#define IDC_BOX                         1022
#define IDC_BIGICON                     1023
#define IDC_UNITS_IN                    1024
#define IDC_UNITS_CM                    1025
#define IDC_WRAP_RULER                  1025
#define IDC_UNITS_PT                    1026
#define IDC_WRAP_WINDOW                 1026
#define IDC_UNITS_PI                    1027
#define IDC_WRAP_NONE                   1027
#define IDC_CHECK_TOOLBAR               1028
#define IDC_CHECK_FORMATBAR             1029
#define IDC_WORDSEL                     1029
#define IDC_CHECK_RULERBAR              1030
#define IDC_CHECK_STATUSBAR             1031
#define IDC_BOXT                        1032
#define IDC_DEFAULT_FORMAT              1033
#define IDC_ALWAYS_RTF                  1034
#define ID_CANCEL_EDIT_CNTR             32768
#define ID_CANCEL_EDIT_SRVR             32769
#define ID_PAGE_SETUP                   32771
#define ID_VIEW_OPTIONS                 32776
#define ID_INSERT_BULLET                32777
#define ID_INSERT_DATE_TIME             32778
#define ID_FORMAT_PARAGRAPH             32780
#define ID_FORMAT_TABS                  32781
#define ID_COLOR0                       32782
#define ID_COLOR1                       32783
#define ID_COLOR2                       32784
#define ID_COLOR3                       32785
#define ID_COLOR4                       32786
#define ID_COLOR5                       32787
#define ID_COLOR6                       32788
#define ID_COLOR7                       32789
#define ID_COLOR8                       32790
#define ID_COLOR9                       32791
#define ID_COLOR10                      32792
#define ID_COLOR11                      32793
#define ID_COLOR12                      32794
#define ID_COLOR13                      32795
#define ID_COLOR14                      32796
#define ID_COLOR15                      32797
#define ID_COLOR16                      32798
#define ID_CHAR_BOLD                    32799
#define ID_CHAR_ITALIC                  32800
#define ID_CHAR_COLOR                   32801
#define ID_CHAR_UNDERLINE               32802
#define ID_PARA_LEFT                    32803
#define ID_PARA_CENTER                  32804
#define ID_PARA_RIGHT                   32805
#define ID_PEN_PERIOD                   32807
#define ID_PEN_SPACE                    32808
#define ID_PEN_BACKSPACE                32809
#define ID_PEN_NEWLINE                  32810
#define ID_OLE_VERB_POPUP               32811
#define ID_PEN_TOGGLE                   32812
#define ID_PEN_LENS                     32813
#define ID_PEN_TAB                      32814
#define ID_VIEW_FORMATBAR               59396
#define ID_VIEW_RULER                   59397
#define ID_DELAYED_INVALIDATE           59398
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\optionsh.cpp ===
// optionsh.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "unitspag.h"
#include "docopt.h"
#include "optionsh.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COptionSheet

COptionSheet::COptionSheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	: CCSPropertySheet(nIDCaption, pParentWnd, iSelectPage),
	pageText(IDS_TEXT_OPTIONS), pageRTF(IDS_RTF_OPTIONS),
	pageWord(IDS_WORD6_OPTIONS), pageWrite(IDS_WRITE_OPTIONS),
	pageEmbedded()
{
	units.m_nUnits = theApp.GetUnits();
	units.m_bWordSel = theApp.m_bWordSel;
	pageText.m_nWordWrap = theApp.GetDocOptions(RD_TEXT).m_nWordWrap;
	pageRTF.m_nWordWrap = theApp.GetDocOptions(RD_RICHTEXT).m_nWordWrap;
	pageWord.m_nWordWrap = theApp.GetDocOptions(RD_WINWORD6).m_nWordWrap;
	pageWrite.m_nWordWrap = theApp.GetDocOptions(RD_WRITE).m_nWordWrap;
	pageEmbedded.m_nWordWrap = theApp.GetDocOptions(RD_EMBEDDED).m_nWordWrap;
	SetPageButtons(pageText, theApp.GetDocOptions(RD_TEXT));
	SetPageButtons(pageRTF, theApp.GetDocOptions(RD_RICHTEXT));
	SetPageButtons(pageWord, theApp.GetDocOptions(RD_WINWORD6));
	SetPageButtons(pageWrite, theApp.GetDocOptions(RD_WRITE));
	SetPageButtons(pageEmbedded, theApp.GetDocOptions(RD_EMBEDDED));
	SetPageButtons(pageEmbedded, theApp.GetDocOptions(RD_EMBEDDED), FALSE);
	AddPage(&units);
	AddPage(&pageText);
	AddPage(&pageRTF);
	AddPage(&pageWord);
	AddPage(&pageWrite);
	AddPage(&pageEmbedded);
}

void COptionSheet::SetPageButtons(CDocOptPage& page, CDocOptions& options, BOOL bPrimary)
{
    CDocOptions::CBarState& barstate = options.GetBarState(bPrimary);

    page.m_bFormatBar = barstate.m_bFormatBar;
    page.m_bRulerBar  = barstate.m_bRulerBar;
    page.m_bToolBar   = barstate.m_bToolBar;
    page.m_bStatusBar = barstate.m_bStatusBar;
}

void COptionSheet::SetState(CDocOptPage& page, CDocOptions& options, BOOL bPrimary)
{
    CDocOptions::CBarState& barstate = options.GetBarState(bPrimary);
    CDockState&             ds = options.GetDockState(bPrimary);

    barstate.m_bFormatBar = page.m_bFormatBar;
    barstate.m_bRulerBar  = page.m_bRulerBar;
    barstate.m_bToolBar   = page.m_bToolBar;
    barstate.m_bStatusBar = page.m_bStatusBar;

    for (int i = 0;i < ds.m_arrBarInfo.GetSize(); i++)
	{
		CControlBarInfo* pInfo = (CControlBarInfo*)ds.m_arrBarInfo[i];
		ASSERT(pInfo != NULL);
		switch (pInfo->m_nBarID)
		{
			case ID_VIEW_FORMATBAR:
				pInfo->m_bVisible = page.m_bFormatBar;
				break;
			case ID_VIEW_RULER:
				pInfo->m_bVisible = page.m_bRulerBar;
				break;
			case ID_VIEW_TOOLBAR:
				pInfo->m_bVisible = page.m_bToolBar;
				break;
			case ID_VIEW_STATUS_BAR:
				pInfo->m_bVisible = page.m_bStatusBar;
				break;
		}
	}
}

const DWORD m_nHelpIDs[] =
{
    AFX_IDC_TAB_CONTROL, (DWORD) -1,
    0, 0
};

LONG COptionSheet::OnHelp(WPARAM, LPARAM lParam)
{
    ::WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                AfxGetApp()->m_pszHelpFilePath,
                HELP_WM_HELP, (DWORD_PTR) m_nHelpIDs);
    return 0;
}

LONG COptionSheet::OnHelpContextMenu(WPARAM wParam, LPARAM)
{
    ::WinHelp((HWND)wParam, AfxGetApp()->m_pszHelpFilePath,
              HELP_CONTEXTMENU, (DWORD_PTR) m_nHelpIDs);
    return 0;
}

BEGIN_MESSAGE_MAP(COptionSheet, CCSPropertySheet)
	//{{AFX_MSG_MAP(COptionSheet)
	ON_WM_CREATE()
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE(WM_CONTEXTMENU, OnHelpContextMenu)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// COptionSheet message handlers

INT_PTR COptionSheet::DoModal()
{
   //
   // Turn apply button off
   //

   m_psh.dwFlags |= PSH_NOAPPLYNOW ;

	INT_PTR nRes = CCSPropertySheet::DoModal();
	if (nRes == IDOK)
	{
		SetState(pageText, theApp.GetDocOptions(RD_TEXT));
		SetState(pageRTF, theApp.GetDocOptions(RD_RICHTEXT));
		SetState(pageWord, theApp.GetDocOptions(RD_WINWORD6));
		SetState(pageWrite, theApp.GetDocOptions(RD_WRITE));
		SetState(pageEmbedded, theApp.GetDocOptions(RD_EMBEDDED));
		SetState(pageEmbedded, theApp.GetDocOptions(RD_EMBEDDED), FALSE);
		theApp.SetUnits(units.m_nUnits);
		theApp.m_bWordSel = units.m_bWordSel;
		theApp.GetDocOptions(RD_TEXT).m_nWordWrap = pageText.m_nWordWrap;
		theApp.GetDocOptions(RD_RICHTEXT).m_nWordWrap = pageRTF.m_nWordWrap;
		theApp.GetDocOptions(RD_WINWORD6).m_nWordWrap = pageWord.m_nWordWrap;
		theApp.GetDocOptions(RD_WRITE).m_nWordWrap = pageWrite.m_nWordWrap;
		theApp.GetDocOptions(RD_EMBEDDED).m_nWordWrap = pageEmbedded.m_nWordWrap;
	}
	return nRes;
}

/////////////////////////////////////////////////////////////////////////////
// COptionSheet message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\pageset.cpp ===
// pageset.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "resource.h"
#include "pageset.h"
#include "ruler.h"
#include "ddxm.h"
#include "helpids.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPageSetupDlg dialog

const DWORD CPageSetupDlg::m_nHelpIDs[] = 
{
	IDC_EDIT_TM, IDH_WORDPAD_TOPMARGIN,
	IDC_EDIT_BM, IDH_WORDPAD_BOTTOMMARGIN,
	IDC_EDIT_LM, IDH_WORDPAD_LEFTMARGIN,
	IDC_EDIT_RM, IDH_WORDPAD_RIGHTMARGIN,
	IDC_BOX, (DWORD) -1,
	0, 0
};

CPageSetupDlg::CPageSetupDlg(CWnd* pParent /*=NULL*/)
	: CCSDialog(CPageSetupDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPageSetupDlg)
	m_nTopMargin = 0;
	m_nRightMargin = 0;
	m_nLeftMargin = 0;
	m_nBottomMargin = 0;
	//}}AFX_DATA_INIT
}

void CPageSetupDlg::DoDataExchange(CDataExchange* pDX)
{
	CCSDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPageSetupDlg)
	DDX_Twips(pDX, IDC_EDIT_TM, m_nTopMargin);
	DDV_MinMaxTwips(pDX, m_nTopMargin, -31680, 31680);
	DDX_Twips(pDX, IDC_EDIT_RM, m_nRightMargin);
	DDV_MinMaxTwips(pDX, m_nRightMargin, -31680, 31680);
	DDX_Twips(pDX, IDC_EDIT_LM, m_nLeftMargin);
	DDV_MinMaxTwips(pDX, m_nLeftMargin, -31680, 31680);
	DDX_Twips(pDX, IDC_EDIT_BM, m_nBottomMargin);
	DDV_MinMaxTwips(pDX, m_nBottomMargin, -31680, 31680);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CPageSetupDlg, CCSDialog)
	//{{AFX_MSG_MAP(CPageSetupDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPageSetupDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\richedit.h ===
/*
 *	RICHEDIT.H
 *	
 *	Purpose:
 *		RICHEDIT v2.0/3.0/4.0 public definitions
 *		functionality available for v2.0 and 3.0 that is not in the original
 *		Windows 95 release.
 *	
 *	Copyright (c) 1993-2001, Microsoft Corporation
 */

#ifndef _RICHEDIT_
#define	_RICHEDIT_

#ifdef _WIN32
#include <pshpack4.h>
#elif !defined(RC_INVOKED)
#pragma pack(4)
#endif

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// To mimic older RichEdit behavior, set _RICHEDIT_VER to appropriate value
//		Version 1.0		0x0100	
//		Version 2.0		0x0200	
//		Version 2.1		0x0210	
#ifndef _RICHEDIT_VER
#define _RICHEDIT_VER	0x0300
#endif

#define cchTextLimitDefault 32767

#define MSFTEDIT_CLASS		L"RICHEDIT50W"
// NOTE:  MSFTEDIT.DLL only registers MSFTEDIT_CLASS.  If an application wants
// to use the following Richedit classes, it needs to load the riched20.dll.
// Otherwise, CreateWindow with RICHEDIT_CLASS would fail.
// This also applies to any dialog that uses RICHEDIT_CLASS, 

// RichEdit 2.0 Window Class 
// On Windows CE, avoid possible conflicts on Win95
#define CERICHEDIT_CLASSA	"RichEditCEA"
#define CERICHEDIT_CLASSW	L"RichEditCEW"

#define RICHEDIT_CLASSA		"RichEdit20A"
#define RICHEDIT_CLASS10A	"RICHEDIT"			// Richedit 1.0

#ifndef MACPORT
#define RICHEDIT_CLASSW		L"RichEdit20W"
#else	//----------------------MACPORT 
#define RICHEDIT_CLASSW		TEXT("RichEdit20W")	// MACPORT change 
#endif // MACPORT  

#if (_RICHEDIT_VER >= 0x0200 )
#ifdef UNICODE
#define RICHEDIT_CLASS		RICHEDIT_CLASSW
#else
#define RICHEDIT_CLASS		RICHEDIT_CLASSA
#endif // UNICODE 
#else
#define RICHEDIT_CLASS		RICHEDIT_CLASS10A
#endif // _RICHEDIT_VER >= 0x0200 

// RichEdit messages 

#ifndef WM_CONTEXTMENU
#define WM_CONTEXTMENU			0x007B
#endif

#ifndef WM_UNICHAR
#define WM_UNICHAR				0x0109
#endif

#ifndef WM_PRINTCLIENT
#define WM_PRINTCLIENT			0x0318
#endif

#ifndef EM_GETLIMITTEXT
#define EM_GETLIMITTEXT			(WM_USER + 37)
#endif

#ifndef EM_POSFROMCHAR	
#define EM_POSFROMCHAR			(WM_USER + 38)
#define EM_CHARFROMPOS			(WM_USER + 39)
#endif

#ifndef EM_SCROLLCARET
#define EM_SCROLLCARET			(WM_USER + 49)
#endif
#define EM_CANPASTE				(WM_USER + 50)
#define EM_DISPLAYBAND			(WM_USER + 51)
#define EM_EXGETSEL				(WM_USER + 52)
#define EM_EXLIMITTEXT			(WM_USER + 53)
#define EM_EXLINEFROMCHAR		(WM_USER + 54)
#define EM_EXSETSEL				(WM_USER + 55)
#define EM_FINDTEXT				(WM_USER + 56)
#define EM_FORMATRANGE			(WM_USER + 57)
#define EM_GETCHARFORMAT		(WM_USER + 58)
#define EM_GETEVENTMASK			(WM_USER + 59)
#define EM_GETOLEINTERFACE		(WM_USER + 60)
#define EM_GETPARAFORMAT		(WM_USER + 61)
#define EM_GETSELTEXT			(WM_USER + 62)
#define EM_HIDESELECTION		(WM_USER + 63)
#define EM_PASTESPECIAL			(WM_USER + 64)
#define EM_REQUESTRESIZE		(WM_USER + 65)
#define EM_SELECTIONTYPE		(WM_USER + 66)
#define EM_SETBKGNDCOLOR		(WM_USER + 67)
#define EM_SETCHARFORMAT		(WM_USER + 68)
#define EM_SETEVENTMASK			(WM_USER + 69)
#define EM_SETOLECALLBACK		(WM_USER + 70)
#define EM_SETPARAFORMAT		(WM_USER + 71)
#define EM_SETTARGETDEVICE		(WM_USER + 72)
#define EM_STREAMIN				(WM_USER + 73)
#define EM_STREAMOUT			(WM_USER + 74)
#define EM_GETTEXTRANGE			(WM_USER + 75)
#define EM_FINDWORDBREAK		(WM_USER + 76)
#define EM_SETOPTIONS			(WM_USER + 77)
#define EM_GETOPTIONS			(WM_USER + 78)
#define EM_FINDTEXTEX			(WM_USER + 79)
#ifdef _WIN32
#define EM_GETWORDBREAKPROCEX	(WM_USER + 80)
#define EM_SETWORDBREAKPROCEX	(WM_USER + 81)
#endif

// RichEdit 2.0 messages 
#define	EM_SETUNDOLIMIT			(WM_USER + 82)
#define EM_REDO					(WM_USER + 84)
#define EM_CANREDO				(WM_USER + 85)
#define EM_GETUNDONAME			(WM_USER + 86)
#define EM_GETREDONAME			(WM_USER + 87)
#define EM_STOPGROUPTYPING		(WM_USER + 88)

#define EM_SETTEXTMODE			(WM_USER + 89)
#define EM_GETTEXTMODE			(WM_USER + 90)

// enum for use with EM_GET/SETTEXTMODE 
typedef enum tagTextMode
{
	TM_PLAINTEXT			= 1,
	TM_RICHTEXT				= 2,	// Default behavior 
	TM_SINGLELEVELUNDO		= 4,
	TM_MULTILEVELUNDO		= 8,	// Default behavior 
	TM_SINGLECODEPAGE		= 16,
	TM_MULTICODEPAGE		= 32	// Default behavior 
} TEXTMODE;

#define EM_AUTOURLDETECT		(WM_USER + 91)
#define EM_GETAUTOURLDETECT		(WM_USER + 92)
#define EM_SETPALETTE			(WM_USER + 93)
#define EM_GETTEXTEX			(WM_USER + 94)
#define EM_GETTEXTLENGTHEX		(WM_USER + 95)
#define EM_SHOWSCROLLBAR		(WM_USER + 96)
#define EM_SETTEXTEX			(WM_USER + 97)

// East Asia specific messages 
#define EM_SETPUNCTUATION		(WM_USER + 100)
#define EM_GETPUNCTUATION		(WM_USER + 101)
#define EM_SETWORDWRAPMODE		(WM_USER + 102)
#define EM_GETWORDWRAPMODE		(WM_USER + 103)
#define EM_SETIMECOLOR			(WM_USER + 104)
#define EM_GETIMECOLOR			(WM_USER + 105)
#define EM_SETIMEOPTIONS		(WM_USER + 106)
#define EM_GETIMEOPTIONS		(WM_USER + 107)
#define EM_CONVPOSITION 		(WM_USER + 108)

#define EM_SETLANGOPTIONS		(WM_USER + 120)
#define EM_GETLANGOPTIONS		(WM_USER + 121)
#define EM_GETIMECOMPMODE		(WM_USER + 122)

#define EM_FINDTEXTW			(WM_USER + 123)
#define EM_FINDTEXTEXW			(WM_USER + 124)

// RE3.0 FE messages 
#define EM_RECONVERSION			(WM_USER + 125)
#define EM_SETIMEMODEBIAS		(WM_USER + 126)	
#define EM_GETIMEMODEBIAS		(WM_USER + 127)

// BiDi specific messages 
#define EM_SETBIDIOPTIONS		(WM_USER + 200)
#define EM_GETBIDIOPTIONS		(WM_USER + 201)

#define EM_SETTYPOGRAPHYOPTIONS	(WM_USER + 202)
#define EM_GETTYPOGRAPHYOPTIONS	(WM_USER + 203)

// Extended edit style specific messages 
#define EM_SETEDITSTYLE			(WM_USER + 204)
#define EM_GETEDITSTYLE			(WM_USER + 205)

// Extended edit style masks 
#define	SES_EMULATESYSEDIT		1
#define SES_BEEPONMAXTEXT		2
#define	SES_EXTENDBACKCOLOR		4
#define SES_MAPCPS				8
#define SES_EMULATE10			16
#define	SES_USECRLF				32
#define SES_USEAIMM				64
#define SES_NOIME				128

#define SES_ALLOWBEEPS			256
#define SES_UPPERCASE			512
#define	SES_LOWERCASE			1024
#define SES_NOINPUTSEQUENCECHK	2048
#define SES_BIDI				4096
#define SES_SCROLLONKILLFOCUS	8192
#define	SES_XLTCRCRLFTOCR		16384
#define SES_DRAFTMODE			32768

#define	SES_USECTF				0x0010000
#define SES_HIDEGRIDLINES		0x0020000
#define SES_USEATFONT			0x0040000
#define SES_CUSTOMLOOK			0x0080000
#define SES_LBSCROLLNOTIFY		0x0100000
#define SES_CTFALLOWEMBED		0x0200000
#define SES_CTFALLOWSMARTTAG	0x0400000
#define SES_CTFALLOWPROOFING	0x0800000

// REListbox scroll notification
#define LBN_PRESCROLL			0x04000
#define LBN_POSTSCROLL			0x08000

// Options for EM_SETLANGOPTIONS and EM_GETLANGOPTIONS 
#define IMF_AUTOKEYBOARD		0x0001
#define IMF_AUTOFONT			0x0002
#define IMF_IMECANCELCOMPLETE	0x0004	// High completes comp string when aborting, low cancels
#define IMF_IMEALWAYSSENDNOTIFY 0x0008
#define IMF_AUTOFONTSIZEADJUST	0x0010
#define IMF_UIFONTS				0x0020
#define IMF_DUALFONT			0x0080

// Values for EM_GETIMECOMPMODE 
#define ICM_NOTOPEN				0x0000
#define ICM_LEVEL3				0x0001
#define ICM_LEVEL2				0x0002
#define ICM_LEVEL2_5			0x0003
#define ICM_LEVEL2_SUI			0x0004
#define ICM_CTF					0x0005

// Options for EM_SETTYPOGRAPHYOPTIONS 
#define	TO_ADVANCEDTYPOGRAPHY	1
#define	TO_SIMPLELINEBREAK		2
#define TO_DISABLECUSTOMTEXTOUT	4
#define TO_ADVANCEDLAYOUT		8

// Pegasus outline mode messages (RE 3.0) 

// Outline mode message
#define EM_OUTLINE              (WM_USER + 220)
// Message for getting and restoring scroll pos
#define EM_GETSCROLLPOS         (WM_USER + 221)
#define EM_SETSCROLLPOS         (WM_USER + 222)
// Change fontsize in current selection by wParam
#define EM_SETFONTSIZE          (WM_USER + 223)
#define EM_GETZOOM				(WM_USER + 224)
#define EM_SETZOOM				(WM_USER + 225)
#define EM_GETVIEWKIND			(WM_USER + 226)
#define EM_SETVIEWKIND			(WM_USER + 227)

// RichEdit 4.0 messages
#define EM_GETPAGE				(WM_USER + 228)
#define EM_SETPAGE				(WM_USER + 229)
#define EM_GETHYPHENATEINFO		(WM_USER + 230)
#define EM_SETHYPHENATEINFO		(WM_USER + 231)
#define EM_GETPAGEROTATE		(WM_USER + 235)
#define EM_SETPAGEROTATE		(WM_USER + 236)
#define EM_GETCTFMODEBIAS		(WM_USER + 237)
#define EM_SETCTFMODEBIAS		(WM_USER + 238)
#define EM_GETCTFOPENSTATUS		(WM_USER + 240)
#define EM_SETCTFOPENSTATUS		(WM_USER + 241)
#define EM_GETIMECOMPTEXT		(WM_USER + 242)
#define EM_ISIME				(WM_USER + 243)
#define EM_GETIMEPROPERTY		(WM_USER + 244)

// EM_SETPAGEROTATE wparam values
#define EPR_0					0		// Text flows left to right and top to bottom
#define EPR_270					1		// Text flows top to bottom and right to left
#define EPR_180					2		// Text flows right to left and bottom to top
#define	EPR_90					3		// Text flows bottom to top and left to right

// EM_SETCTFMODEBIAS wparam values
#define CTFMODEBIAS_DEFAULT					0x0000
#define CTFMODEBIAS_FILENAME				0x0001
#define CTFMODEBIAS_NAME					0x0002
#define CTFMODEBIAS_READING					0x0003
#define CTFMODEBIAS_DATETIME				0x0004
#define CTFMODEBIAS_CONVERSATION			0x0005
#define CTFMODEBIAS_NUMERIC					0x0006
#define CTFMODEBIAS_HIRAGANA				0x0007
#define CTFMODEBIAS_KATAKANA				0x0008
#define CTFMODEBIAS_HANGUL					0x0009
#define CTFMODEBIAS_HALFWIDTHKATAKANA		0x000A
#define CTFMODEBIAS_FULLWIDTHALPHANUMERIC	0x000B
#define CTFMODEBIAS_HALFWIDTHALPHANUMERIC	0x000C

// EM_SETIMEMODEBIAS lparam values
#define IMF_SMODE_PLAURALCLAUSE	0x0001
#define IMF_SMODE_NONE			0x0002

// EM_GETIMECOMPTEXT wparam structure
typedef struct _imecomptext {
	LONG	cb;			// count of bytes in the output buffer.
	DWORD	flags;		// value specifying the composition string type.
						//	Currently only support ICT_RESULTREADSTR
} IMECOMPTEXT;
#define ICT_RESULTREADSTR		1

// Outline mode wparam values
#define EMO_EXIT                0       // Enter normal mode,  lparam ignored
#define EMO_ENTER               1       // Enter outline mode, lparam ignored
#define EMO_PROMOTE             2       // LOWORD(lparam) == 0 ==>
                                        //  promote  to body-text
                                        // LOWORD(lparam) != 0 ==>
                                        //  promote/demote current selection
                                        //  by indicated number of levels
#define EMO_EXPAND              3       // HIWORD(lparam) = EMO_EXPANDSELECTION
                                        //  -> expands selection to level
                                        //  indicated in LOWORD(lparam)
                                        //  LOWORD(lparam) = -1/+1 corresponds
                                        //  to collapse/expand button presses
                                        //  in winword (other values are
                                        //  equivalent to having pressed these
                                        //  buttons more than once)
                                        //  HIWORD(lparam) = EMO_EXPANDDOCUMENT
                                        //  -> expands whole document to
                                        //  indicated level
#define EMO_MOVESELECTION       4       // LOWORD(lparam) != 0 -> move current
                                        //  selection up/down by indicated amount
#define EMO_GETVIEWMODE			5		// Returns VM_NORMAL or VM_OUTLINE

// EMO_EXPAND options
#define EMO_EXPANDSELECTION     0
#define EMO_EXPANDDOCUMENT      1

#define VM_NORMAL				4		// Agrees with RTF \viewkindN
#define VM_OUTLINE				2
#define VM_PAGE					9		// Screen page view (not print layout)

// New notifications 
#define EN_MSGFILTER			0x0700
#define EN_REQUESTRESIZE		0x0701
#define EN_SELCHANGE			0x0702
#define EN_DROPFILES			0x0703
#define EN_PROTECTED			0x0704
#define EN_CORRECTTEXT			0x0705			// PenWin specific 
#define EN_STOPNOUNDO			0x0706
#define EN_IMECHANGE			0x0707			// East Asia specific 
#define EN_SAVECLIPBOARD		0x0708
#define EN_OLEOPFAILED			0x0709
#define EN_OBJECTPOSITIONS		0x070a
#define EN_LINK					0x070b
#define EN_DRAGDROPDONE			0x070c
#define EN_PARAGRAPHEXPANDED	0x070d
#define EN_PAGECHANGE			0x070e
#define EN_LOWFIRTF				0x070f
#define EN_ALIGNLTR				0x0710			// BiDi specific notification
#define EN_ALIGNRTL				0x0711			// BiDi specific notification
#define EN_CLIPFORMAT			0x0712

// Event notification masks 
#define ENM_NONE				0x00000000
#define ENM_CHANGE				0x00000001
#define ENM_UPDATE				0x00000002
#define ENM_SCROLL				0x00000004
#define ENM_SCROLLEVENTS		0x00000008
#define ENM_DRAGDROPDONE		0x00000010
#define ENM_PARAGRAPHEXPANDED	0x00000020
#define ENM_PAGECHANGE			0x00000040
#define ENM_CLIPFORMAT			0x00000080
#define ENM_KEYEVENTS			0x00010000
#define ENM_MOUSEEVENTS			0x00020000
#define ENM_REQUESTRESIZE		0x00040000
#define ENM_SELCHANGE			0x00080000
#define ENM_DROPFILES			0x00100000
#define ENM_PROTECTED			0x00200000
#define ENM_CORRECTTEXT			0x00400000		// PenWin specific 
#define ENM_IMECHANGE			0x00800000		// Used by RE1.0 compatibility
#define ENM_LANGCHANGE			0x01000000
#define ENM_OBJECTPOSITIONS		0x02000000
#define ENM_LINK				0x04000000
#define ENM_LOWFIRTF			0x08000000


// New edit control styles 
#define ES_SAVESEL				0x00008000
#define ES_SUNKEN				0x00004000
#define ES_DISABLENOSCROLL		0x00002000
// Same as WS_MAXIMIZE, but that doesn't make sense so we re-use the value 
#define ES_SELECTIONBAR			0x01000000
// Same as ES_UPPERCASE, but re-used to completely disable OLE drag'n'drop 
#define ES_NOOLEDRAGDROP		0x00000008

// New edit control extended style 
#if (_WIN32_WINNT > 0x0400) || (WINVER > 0x0400)
#define ES_EX_NOCALLOLEINIT		0x00000000		// Not supported in RE 2.0/3.0 
#else
#ifdef	_WIN32
#define ES_EX_NOCALLOLEINIT		0x01000000
#endif	
#endif

// These flags are used in FE Windows 
#define ES_VERTICAL				0x00400000		// Not supported in RE 2.0/3.0 
#define	ES_NOIME				0x00080000
#define ES_SELFIME				0x00040000

// Edit control options 
#define ECO_AUTOWORDSELECTION	0x00000001
#define ECO_AUTOVSCROLL			0x00000040
#define ECO_AUTOHSCROLL			0x00000080
#define ECO_NOHIDESEL			0x00000100
#define ECO_READONLY			0x00000800
#define ECO_WANTRETURN			0x00001000
#define ECO_SAVESEL				0x00008000
#define ECO_SELECTIONBAR		0x01000000
#define ECO_VERTICAL			0x00400000		// FE specific 


// ECO operations 
#define ECOOP_SET				0x0001
#define ECOOP_OR				0x0002
#define ECOOP_AND				0x0003
#define ECOOP_XOR				0x0004

// New word break function actions 
#define WB_CLASSIFY			3
#define WB_MOVEWORDLEFT		4
#define WB_MOVEWORDRIGHT	5
#define WB_LEFTBREAK		6
#define WB_RIGHTBREAK		7

// East Asia specific flags 
#define WB_MOVEWORDPREV		4
#define WB_MOVEWORDNEXT		5
#define WB_PREVBREAK		6
#define WB_NEXTBREAK		7

#define PC_FOLLOWING		1
#define	PC_LEADING			2
#define	PC_OVERFLOW			3
#define	PC_DELIMITER		4
#define WBF_WORDWRAP		0x010
#define WBF_WORDBREAK		0x020
#define	WBF_OVERFLOW		0x040	
#define WBF_LEVEL1			0x080
#define	WBF_LEVEL2			0x100
#define	WBF_CUSTOM			0x200

// East Asia specific flags 
#define IMF_FORCENONE           0x0001
#define IMF_FORCEENABLE         0x0002
#define IMF_FORCEDISABLE        0x0004
#define IMF_CLOSESTATUSWINDOW   0x0008
#define IMF_VERTICAL            0x0020
#define IMF_FORCEACTIVE         0x0040
#define IMF_FORCEINACTIVE       0x0080
#define IMF_FORCEREMEMBER       0x0100
#define IMF_MULTIPLEEDIT        0x0400

// Word break flags (used with WB_CLASSIFY) 
#define WBF_CLASS			((BYTE) 0x0F)
#define WBF_ISWHITE			((BYTE) 0x10)
#define WBF_BREAKLINE		((BYTE) 0x20)
#define WBF_BREAKAFTER		((BYTE) 0x40)


// Data types 

#ifdef _WIN32
// Extended edit word break proc (character set aware) 
typedef LONG (*EDITWORDBREAKPROCEX)(char *pchText, LONG cchText, BYTE bCharSet, INT action);
#endif

// All character format measurements are in twips 
typedef struct _charformat
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	char		szFaceName[LF_FACESIZE];
} CHARFORMATA;

typedef struct _charformatw
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	WCHAR		szFaceName[LF_FACESIZE];
} CHARFORMATW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define CHARFORMAT CHARFORMATW
#else
#define CHARFORMAT CHARFORMATA
#endif // UNICODE 
#else
#define CHARFORMAT CHARFORMATA
#endif // _RICHEDIT_VER >= 0x0200 

// CHARFORMAT2 structure 

#ifdef __cplusplus

struct CHARFORMAT2W : _charformatw
{
	WORD		wWeight;			// Font weight (LOGFONT value)
	SHORT		sSpacing;			// Amount to space between letters
	COLORREF	crBackColor;		// Background color
	LCID		lcid;				// Locale ID
	DWORD		dwReserved;			// Reserved. Must be 0
	SHORT		sStyle;				// Style handle
	WORD		wKerning;			// Twip size above which to kern char pair
	BYTE		bUnderlineType;		// Underline type
	BYTE		bAnimation;			// Animated text like marching ants
	BYTE		bRevAuthor;			// Revision author index
};

struct CHARFORMAT2A : _charformat
{
	WORD		wWeight;			// Font weight (LOGFONT value)
	SHORT		sSpacing;			// Amount to space between letters
	COLORREF	crBackColor;		// Background color
	LCID		lcid;				// Locale ID
	DWORD		dwReserved;			// Reserved. Must be 0
	SHORT		sStyle;				// Style handle
	WORD		wKerning;			// Twip size above which to kern char pair
	BYTE		bUnderlineType;		// Underline type
	BYTE		bAnimation;			// Animated text like marching ants
	BYTE		bRevAuthor;			// Revision author index
};

#else	// regular C-style  

typedef struct _charformat2w
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;			// > 0 for superscript, < 0 for subscript 
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	WCHAR		szFaceName[LF_FACESIZE];
	WORD		wWeight;			// Font weight (LOGFONT value)		
	SHORT		sSpacing;			// Amount to space between letters	
	COLORREF	crBackColor;		// Background color					
	LCID		lcid;				// Locale ID						
	DWORD		dwReserved;			// Reserved. Must be 0				
	SHORT		sStyle;				// Style handle						
	WORD		wKerning;			// Twip size above which to kern char pair
	BYTE		bUnderlineType;		// Underline type					
	BYTE		bAnimation;			// Animated text like marching ants	
	BYTE		bRevAuthor;			// Revision author index			
	BYTE		bReserved1;
} CHARFORMAT2W;

typedef struct _charformat2a
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;			// > 0 for superscript, < 0 for subscript 
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	char		szFaceName[LF_FACESIZE];
	WORD		wWeight;			// Font weight (LOGFONT value)		
	SHORT		sSpacing;			// Amount to space between letters	
	COLORREF	crBackColor;		// Background color					
	LCID		lcid;				// Locale ID						
	DWORD		dwReserved;			// Reserved. Must be 0				
	SHORT		sStyle;				// Style handle						
	WORD		wKerning;			// Twip size above which to kern char pair
	BYTE		bUnderlineType;		// Underline type					
	BYTE		bAnimation;			// Animated text like marching ants	
	BYTE		bRevAuthor;			// Revision author index			
} CHARFORMAT2A;

#endif // C++ 

#ifdef UNICODE
#define CHARFORMAT2	CHARFORMAT2W
#else
#define CHARFORMAT2 CHARFORMAT2A
#endif

#define CHARFORMATDELTA		(sizeof(CHARFORMAT2) - sizeof(CHARFORMAT))


// CFM_COLOR mirrors CFE_AUTOCOLOR, a little hack to easily deal with autocolor

// CHARFORMAT masks 
#define CFM_BOLD		0x00000001
#define CFM_ITALIC		0x00000002
#define CFM_UNDERLINE	0x00000004
#define CFM_STRIKEOUT	0x00000008
#define CFM_PROTECTED	0x00000010
#define CFM_LINK		0x00000020			// Exchange hyperlink extension 
#define CFM_SIZE		0x80000000
#define CFM_COLOR		0x40000000
#define CFM_FACE		0x20000000
#define CFM_OFFSET		0x10000000
#define CFM_CHARSET		0x08000000

// CHARFORMAT effects 
#define CFE_BOLD		0x0001
#define CFE_ITALIC		0x0002
#define CFE_UNDERLINE	0x0004
#define CFE_STRIKEOUT	0x0008
#define CFE_PROTECTED	0x0010
#define CFE_LINK		0x0020
#define CFE_AUTOCOLOR	0x40000000			// NOTE: this corresponds to 
											// CFM_COLOR, which controls it 
// Masks and effects defined for CHARFORMAT2 -- an (*) indicates
// that the data is stored by RichEdit 2.0/3.0, but not displayed
#define CFM_SMALLCAPS		0x0040			// (*)	
#define	CFM_ALLCAPS			0x0080			// Displayed by 3.0	
#define	CFM_HIDDEN			0x0100			// Hidden by 3.0 
#define	CFM_OUTLINE			0x0200			// (*)	
#define	CFM_SHADOW			0x0400			// (*)	
#define	CFM_EMBOSS			0x0800			// (*)	
#define	CFM_IMPRINT			0x1000			// (*)	
#define CFM_DISABLED		0x2000
#define	CFM_REVISED			0x4000

#define CFM_BACKCOLOR		0x04000000
#define CFM_LCID			0x02000000
#define	CFM_UNDERLINETYPE	0x00800000		// Many displayed by 3.0 
#define	CFM_WEIGHT			0x00400000
#define CFM_SPACING			0x00200000		// Displayed by 3.0	
#define CFM_KERNING			0x00100000		// (*)	
#define CFM_STYLE			0x00080000		// (*)	
#define CFM_ANIMATION		0x00040000		// (*)	
#define CFM_REVAUTHOR		0x00008000

#define CFE_SUBSCRIPT		0x00010000		// Superscript and subscript are 
#define CFE_SUPERSCRIPT		0x00020000		//  mutually exclusive			 

#define CFM_SUBSCRIPT		CFE_SUBSCRIPT | CFE_SUPERSCRIPT
#define CFM_SUPERSCRIPT		CFM_SUBSCRIPT

// CHARFORMAT "ALL" masks
#define CFM_EFFECTS (CFM_BOLD | CFM_ITALIC | CFM_UNDERLINE | CFM_COLOR | \
					 CFM_STRIKEOUT | CFE_PROTECTED | CFM_LINK)
#define CFM_ALL (CFM_EFFECTS | CFM_SIZE | CFM_FACE | CFM_OFFSET | CFM_CHARSET)

#define	CFM_EFFECTS2 (CFM_EFFECTS | CFM_DISABLED | CFM_SMALLCAPS | CFM_ALLCAPS \
					| CFM_HIDDEN  | CFM_OUTLINE | CFM_SHADOW | CFM_EMBOSS \
					| CFM_IMPRINT | CFM_DISABLED | CFM_REVISED \
					| CFM_SUBSCRIPT | CFM_SUPERSCRIPT | CFM_BACKCOLOR)

#define CFM_ALL2	 (CFM_ALL | CFM_EFFECTS2 | CFM_BACKCOLOR | CFM_LCID \
					| CFM_UNDERLINETYPE | CFM_WEIGHT | CFM_REVAUTHOR \
					| CFM_SPACING | CFM_KERNING | CFM_STYLE | CFM_ANIMATION)

#define	CFE_SMALLCAPS		CFM_SMALLCAPS
#define	CFE_ALLCAPS			CFM_ALLCAPS
#define	CFE_HIDDEN			CFM_HIDDEN
#define	CFE_OUTLINE			CFM_OUTLINE
#define	CFE_SHADOW			CFM_SHADOW
#define	CFE_EMBOSS			CFM_EMBOSS
#define	CFE_IMPRINT			CFM_IMPRINT
#define	CFE_DISABLED		CFM_DISABLED
#define	CFE_REVISED			CFM_REVISED

// CFE_AUTOCOLOR and CFE_AUTOBACKCOLOR correspond to CFM_COLOR and
// CFM_BACKCOLOR, respectively, which control them
#define CFE_AUTOBACKCOLOR	CFM_BACKCOLOR

// Underline types. RE 1.0 displays only CFU_UNDERLINE
#define CFU_CF1UNDERLINE	0xFF	// Map charformat's bit underline to CF2
#define CFU_INVERT			0xFE	// For IME composition fake a selection
#define CFU_UNDERLINETHICKLONGDASH		18	// (*) display as dash
#define CFU_UNDERLINETHICKDOTTED		17	// (*) display as dot
#define CFU_UNDERLINETHICKDASHDOTDOT	16	// (*) display as dash dot dot
#define CFU_UNDERLINETHICKDASHDOT		15	// (*) display as dash dot
#define CFU_UNDERLINETHICKDASH			14	// (*) display as dash
#define CFU_UNDERLINELONGDASH			13	// (*) display as dash
#define CFU_UNDERLINEHEAVYWAVE			12	// (*) display as wave
#define CFU_UNDERLINEDOUBLEWAVE			11	// (*) display as wave
#define CFU_UNDERLINEHAIRLINE			10	// (*) display as single	
#define CFU_UNDERLINETHICK				9
#define CFU_UNDERLINEWAVE				8
#define	CFU_UNDERLINEDASHDOTDOT			7
#define	CFU_UNDERLINEDASHDOT			6
#define	CFU_UNDERLINEDASH				5
#define	CFU_UNDERLINEDOTTED				4
#define	CFU_UNDERLINEDOUBLE				3	// (*) display as single
#define CFU_UNDERLINEWORD				2	// (*) display as single	
#define CFU_UNDERLINE					1
#define CFU_UNDERLINENONE				0

#define yHeightCharPtsMost 1638

// EM_SETCHARFORMAT wParam masks 
#define SCF_SELECTION		0x0001
#define SCF_WORD			0x0002
#define SCF_DEFAULT			0x0000	// Set default charformat or paraformat
#define SCF_ALL				0x0004	// Not valid with SCF_SELECTION or SCF_WORD
#define SCF_USEUIRULES		0x0008	// Modifier for SCF_SELECTION; says that
									//  format came from a toolbar, etc., and
									//  hence UI formatting rules should be
									//  used instead of literal formatting
#define SCF_ASSOCIATEFONT	0x0010	// Associate fontname with bCharSet (one
									//  possible for each of Western, ME, FE,
									//  Thai)
#define SCF_NOKBUPDATE		0x0020	// Do not update KB layput for this change
									//  even if autokeyboard is on
#define SCF_ASSOCIATEFONT2	0x0040	// Associate plane-2 (surrogate) font

typedef struct _charrange
{
	LONG	cpMin;
	LONG	cpMax;
} CHARRANGE;

typedef struct _textrange
{
	CHARRANGE chrg;
	LPSTR lpstrText;	// Allocated by caller, zero terminated by RichEdit 
} TEXTRANGEA;

typedef struct _textrangew
{
	CHARRANGE chrg;
	LPWSTR lpstrText;	// Allocated by caller, zero terminated by RichEdit 
} TEXTRANGEW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define TEXTRANGE 	TEXTRANGEW
#else
#define TEXTRANGE	TEXTRANGEA
#endif // UNICODE 
#else
#define TEXTRANGE	TEXTRANGEA
#endif // _RICHEDIT_VER >= 0x0200 

#if (WINVER >= 0x0500) && defined( _OBJBASE_H_ )
typedef DWORD (CALLBACK *EDITSTREAMCALLBACK)(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb);

typedef struct _editstream
{
	DWORD_PTR dwCookie;		// User value passed to callback as first parameter 
	DWORD	  dwError;		// Last error 
	EDITSTREAMCALLBACK pfnCallback;
} EDITSTREAM;
#else
typedef DWORD (CALLBACK *EDITSTREAMCALLBACK)(DWORD dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb);

typedef struct _editstream
{
	DWORD dwCookie;		/* user value passed to callback as first parameter */
	DWORD dwError;		/* last error */
	EDITSTREAMCALLBACK pfnCallback;
} EDITSTREAM;
#endif

// Stream formats. Flags are all in low word, since high word
// gives possible codepage choice. 
#define SF_TEXT			0x0001
#define SF_RTF			0x0002
#define SF_RTFNOOBJS	0x0003		// Write only 
#define SF_TEXTIZED		0x0004		// Write only 

#define SF_UNICODE		0x0010		// Unicode file (UCS2 little endian) 
#define SF_USECODEPAGE	0x0020		// CodePage given by high word 
#define SF_NCRFORNONASCII 0x40		// Output /uN for nonASCII 
#define	SFF_WRITEXTRAPAR  0x80		// Output \par at end

// Flag telling stream operations to operate on selection only 
// EM_STREAMIN  replaces current selection 
// EM_STREAMOUT streams out current selection 
#define SFF_SELECTION	0x8000

// Flag telling stream operations to ignore some FE control words 
// having to do with FE word breaking and horiz vs vertical text. 
// Not used in RichEdit 2.0 and later	
#define SFF_PLAINRTF	0x4000

// Flag telling file stream output (SFF_SELECTION flag not set) to persist 
// \viewscaleN control word. 
#define SFF_PERSISTVIEWSCALE 0x2000

// Flag telling file stream input with SFF_SELECTION flag not set not to 
// close the document 
#define SFF_KEEPDOCINFO	0x1000

// Flag telling stream operations to output in Pocket Word format 
#define SFF_PWD			0x0800

// 3-bit field specifying the value of N - 1 to use for \rtfN or \pwdN 
#define SF_RTFVAL		0x0700

typedef struct _findtext
{
	CHARRANGE chrg;
	LPCSTR lpstrText;
} FINDTEXTA;

typedef struct _findtextw
{
	CHARRANGE chrg;
	LPCWSTR lpstrText;
} FINDTEXTW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define FINDTEXT	FINDTEXTW
#else
#define FINDTEXT	FINDTEXTA
#endif	// UNICODE 
#else
#define FINDTEXT	FINDTEXTA
#endif // _RICHEDIT_VER >= 0x0200 

typedef struct _findtextexa
{
	CHARRANGE chrg;
	LPCSTR	  lpstrText;
	CHARRANGE chrgText;
} FINDTEXTEXA;

typedef struct _findtextexw
{
	CHARRANGE chrg;
	LPCWSTR	  lpstrText;
	CHARRANGE chrgText;
} FINDTEXTEXW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define FINDTEXTEX	FINDTEXTEXW
#else
#define FINDTEXTEX	FINDTEXTEXA
#endif // UNICODE 
#else
#define FINDTEXTEX	FINDTEXTEXA
#endif // _RICHEDIT_VER >= 0x0200 


typedef struct _formatrange
{
	HDC hdc;
	HDC hdcTarget;
	RECT rc;
	RECT rcPage;
	CHARRANGE chrg;
} FORMATRANGE;

// All paragraph measurements are in twips 

#define MAX_TAB_STOPS 32
#define lDefaultTab 720
#define MAX_TABLE_CELLS 63

// This is a hack to make PARAFORMAT compatible with RE 1.0 
#define	wReserved	wEffects

typedef struct _paraformat
{
	UINT	cbSize;
	DWORD	dwMask;
	WORD	wNumbering;
	WORD	wEffects;
	LONG	dxStartIndent;
	LONG	dxRightIndent;
	LONG	dxOffset;
	WORD	wAlignment;
	SHORT	cTabCount;
	LONG	rgxTabs[MAX_TAB_STOPS];
} PARAFORMAT;

#ifdef __cplusplus
struct PARAFORMAT2 : _paraformat
{
	LONG	dySpaceBefore;			// Vertical spacing before para
	LONG	dySpaceAfter;			// Vertical spacing after para
	LONG	dyLineSpacing;			// Line spacing depending on Rule
	SHORT	sStyle;					// Style handle
	BYTE	bLineSpacingRule;		// Rule for line spacing (see tom.doc)
	BYTE	bOutlineLevel;			// Outline level
	WORD	wShadingWeight;			// Shading in hundredths of a per cent
	WORD	wShadingStyle;			// Nibble 0: style, 1: cfpat, 2: cbpat
	WORD	wNumberingStart;		// Starting value for numbering
	WORD	wNumberingStyle;		// Alignment, roman/arabic, (), ), ., etc.
	WORD	wNumberingTab;			// Space bet FirstIndent & 1st-line text
	WORD	wBorderSpace;			// Border-text spaces (nbl/bdr in pts)
	WORD	wBorderWidth;			// Pen widths (nbl/bdr in half pts)
	WORD	wBorders;				// Border styles (nibble/border)
};

#else	// Regular C-style	

typedef struct _paraformat2
{
	UINT	cbSize;
	DWORD	dwMask;
	WORD	wNumbering;
	WORD	wReserved;
	LONG	dxStartIndent;
	LONG	dxRightIndent;
	LONG	dxOffset;
	WORD	wAlignment;
	SHORT	cTabCount;
	LONG	rgxTabs[MAX_TAB_STOPS];
 	LONG	dySpaceBefore;			// Vertical spacing before para			
	LONG	dySpaceAfter;			// Vertical spacing after para			
	LONG	dyLineSpacing;			// Line spacing depending on Rule		
	SHORT	sStyle;					// Style handle							
	BYTE	bLineSpacingRule;		// Rule for line spacing (see tom.doc)	
	BYTE	bOutlineLevel;			// Outline Level						
	WORD	wShadingWeight;			// Shading in hundredths of a per cent	
	WORD	wShadingStyle;			// Byte 0: style, nib 2: cfpat, 3: cbpat
	WORD	wNumberingStart;		// Starting value for numbering				
	WORD	wNumberingStyle;		// Alignment, Roman/Arabic, (), ), ., etc.
	WORD	wNumberingTab;			// Space bet 1st indent and 1st-line text
	WORD	wBorderSpace;			// Border-text spaces (nbl/bdr in pts)	
	WORD	wBorderWidth;			// Pen widths (nbl/bdr in half twips)	
	WORD	wBorders;				// Border styles (nibble/border)		
} PARAFORMAT2;

#endif // C++	


// PARAFORMAT mask values 
#define PFM_STARTINDENT			0x00000001
#define PFM_RIGHTINDENT			0x00000002
#define PFM_OFFSET				0x00000004
#define PFM_ALIGNMENT			0x00000008
#define PFM_TABSTOPS			0x00000010
#define PFM_NUMBERING			0x00000020
#define PFM_OFFSETINDENT		0x80000000

// PARAFORMAT 2.0 masks and effects 
#define PFM_SPACEBEFORE			0x00000040
#define PFM_SPACEAFTER			0x00000080
#define PFM_LINESPACING			0x00000100
#define	PFM_STYLE				0x00000400
#define PFM_BORDER				0x00000800	// (*)	
#define PFM_SHADING				0x00001000	// (*)	
#define PFM_NUMBERINGSTYLE		0x00002000	// RE 3.0	
#define PFM_NUMBERINGTAB		0x00004000	// RE 3.0	
#define PFM_NUMBERINGSTART		0x00008000	// RE 3.0	

#define PFM_RTLPARA				0x00010000
#define PFM_KEEP				0x00020000	// (*)	
#define PFM_KEEPNEXT			0x00040000	// (*)	
#define PFM_PAGEBREAKBEFORE		0x00080000	// (*)	
#define PFM_NOLINENUMBER		0x00100000	// (*)	
#define PFM_NOWIDOWCONTROL		0x00200000	// (*)	
#define PFM_DONOTHYPHEN			0x00400000	// (*)	
#define PFM_SIDEBYSIDE			0x00800000	// (*)	
#define PFM_TABLE				0x40000000	// RE 3.0 
#define PFM_TEXTWRAPPINGBREAK	0x20000000	// RE 3.0 
#define PFM_TABLEROWDELIMITER	0x10000000	// RE 4.0 

// The following three properties are read only
#define PFM_COLLAPSED			0x01000000	// RE 3.0 
#define PFM_OUTLINELEVEL		0x02000000	// RE 3.0 
#define PFM_BOX					0x04000000	// RE 3.0 
#define PFM_RESERVED2			0x08000000	// RE 4.0 


// PARAFORMAT "ALL" masks
#define	PFM_ALL (PFM_STARTINDENT | PFM_RIGHTINDENT | PFM_OFFSET	| \
				 PFM_ALIGNMENT   | PFM_TABSTOPS    | PFM_NUMBERING | \
				 PFM_OFFSETINDENT| PFM_RTLPARA)

// Note: PARAFORMAT has no effects (BiDi RichEdit 1.0 does have PFE_RTLPARA)
#define PFM_EFFECTS (PFM_RTLPARA | PFM_KEEP | PFM_KEEPNEXT | PFM_TABLE \
					| PFM_PAGEBREAKBEFORE | PFM_NOLINENUMBER  \
					| PFM_NOWIDOWCONTROL | PFM_DONOTHYPHEN | PFM_SIDEBYSIDE \
					| PFM_TABLE | PFM_TABLEROWDELIMITER)

#define PFM_ALL2	(PFM_ALL | PFM_EFFECTS | PFM_SPACEBEFORE | PFM_SPACEAFTER \
					| PFM_LINESPACING | PFM_STYLE | PFM_SHADING | PFM_BORDER \
					| PFM_NUMBERINGTAB | PFM_NUMBERINGSTART | PFM_NUMBERINGSTYLE)

#define PFE_RTLPARA				(PFM_RTLPARA		 >> 16)
#define PFE_KEEP				(PFM_KEEP			 >> 16)	// (*)	
#define PFE_KEEPNEXT			(PFM_KEEPNEXT		 >> 16)	// (*)	
#define PFE_PAGEBREAKBEFORE		(PFM_PAGEBREAKBEFORE >> 16)	// (*)	
#define PFE_NOLINENUMBER		(PFM_NOLINENUMBER	 >> 16)	// (*)	
#define PFE_NOWIDOWCONTROL		(PFM_NOWIDOWCONTROL	 >> 16)	// (*)	
#define PFE_DONOTHYPHEN			(PFM_DONOTHYPHEN 	 >> 16)	// (*)	
#define PFE_SIDEBYSIDE			(PFM_SIDEBYSIDE		 >> 16)	// (*)	
#define PFE_TEXTWRAPPINGBREAK	(PFM_TEXTWRAPPINGBREAK>>16) // (*)	

// The following four effects are read only
#define PFE_COLLAPSED			(PFM_COLLAPSED		 >> 16)	// (+)	
#define PFE_BOX					(PFM_BOX			 >> 16)	// (+)	
#define PFE_TABLE				(PFM_TABLE			 >> 16)	// Inside table row. RE 3.0 
#define PFE_TABLEROWDELIMITER	(PFM_TABLEROWDELIMITER>>16)	// Table row start. RE 4.0 

// PARAFORMAT numbering options 
#define PFN_BULLET		1		// tomListBullet

// PARAFORMAT2 wNumbering options 
#define PFN_ARABIC		2		// tomListNumberAsArabic:   0, 1, 2,	...
#define PFN_LCLETTER	3		// tomListNumberAsLCLetter: a, b, c,	...
#define	PFN_UCLETTER	4		// tomListNumberAsUCLetter: A, B, C,	...
#define	PFN_LCROMAN		5		// tomListNumberAsLCRoman:  i, ii, iii,	...
#define	PFN_UCROMAN		6		// tomListNumberAsUCRoman:  I, II, III,	...

// PARAFORMAT2 wNumberingStyle options 
#define PFNS_PAREN		0x000	// default, e.g.,				  1)	
#define	PFNS_PARENS		0x100	// tomListParentheses/256, e.g., (1)	
#define PFNS_PERIOD		0x200	// tomListPeriod/256, e.g.,		  1.	
#define PFNS_PLAIN		0x300	// tomListPlain/256, e.g.,		  1		
#define PFNS_NONUMBER	0x400	// Used for continuation w/o number

#define PFNS_NEWNUMBER	0x8000	// Start new number with wNumberingStart		
								// (can be combined with other PFNS_xxx)
// PARAFORMAT alignment options 
#define PFA_LEFT			 1
#define PFA_RIGHT			 2
#define PFA_CENTER			 3

// PARAFORMAT2 alignment options 
#define	PFA_JUSTIFY			 4	// New paragraph-alignment option 2.0 (*) 
#define PFA_FULL_INTERWORD	 4	// These are supported in 3.0 with advanced
#define PFA_FULL_INTERLETTER 5	//  typography enabled
#define PFA_FULL_SCALED		 6
#define	PFA_FULL_GLYPHS		 7
#define	PFA_SNAP_GRID		 8


// Notification structures 
#ifndef WM_NOTIFY
#define WM_NOTIFY		0x004E

typedef struct _nmhdr
{
	HWND	hwndFrom;
	UINT	idFrom;
	UINT	code;
} NMHDR;
#endif  // !WM_NOTIFY 

typedef struct _msgfilter
{
	NMHDR	nmhdr;
	UINT	msg;
	WPARAM	wParam;
	LPARAM	lParam;
} MSGFILTER;

typedef struct _reqresize
{
	NMHDR nmhdr;
	RECT rc;
} REQRESIZE;

typedef struct _selchange
{
	NMHDR nmhdr;
	CHARRANGE chrg;
	WORD seltyp;
} SELCHANGE;

#if (WINVER >= 0x0500) && defined( _OBJBASE_H_ )
typedef struct _clipboardformat
{
	NMHDR nmhdr;
	CLIPFORMAT cf;
} CLIPBOARDFORMAT;
#endif

#define SEL_EMPTY		0x0000
#define SEL_TEXT		0x0001
#define SEL_OBJECT		0x0002
#define SEL_MULTICHAR	0x0004
#define SEL_MULTIOBJECT	0x0008

// Used with IRichEditOleCallback::GetContextMenu, this flag will be
// passed as a "selection type".  It indicates that a context menu for
// a right-mouse drag drop should be generated.  The IOleObject parameter
// will really be the IDataObject for the drop
#define GCM_RIGHTMOUSEDROP  0x8000

typedef struct _endropfiles
{
	NMHDR nmhdr;
	HANDLE hDrop;
	LONG cp;
	BOOL fProtected;
} ENDROPFILES;

typedef struct _enprotected
{
	NMHDR nmhdr;
	UINT msg;
	WPARAM wParam;
	LPARAM lParam;
	CHARRANGE chrg;
} ENPROTECTED;

typedef struct _ensaveclipboard
{
	NMHDR nmhdr;
	LONG cObjectCount;
    LONG cch;
} ENSAVECLIPBOARD;

#ifndef MACPORT
typedef struct _enoleopfailed
{
	NMHDR nmhdr;
	LONG iob;
	LONG lOper;
	HRESULT hr;
} ENOLEOPFAILED;
#endif

#define	OLEOP_DOVERB	1

typedef struct _objectpositions
{
    NMHDR nmhdr;
    LONG cObjectCount;
    LONG *pcpPositions;
} OBJECTPOSITIONS;

typedef struct _enlink
{
    NMHDR nmhdr;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    CHARRANGE chrg;
} ENLINK;

typedef struct _enlowfirtf
{
    NMHDR nmhdr;
	char *szControl;
} ENLOWFIRTF;

// PenWin specific 
typedef struct _encorrecttext
{
	NMHDR nmhdr;
	CHARRANGE chrg;
	WORD seltyp;
} ENCORRECTTEXT;

// East Asia specific 
typedef struct _punctuation
{
	UINT	iSize;
	LPSTR	szPunctuation;
} PUNCTUATION;

// East Asia specific 
typedef struct _compcolor
{
	COLORREF crText;
	COLORREF crBackground;
	DWORD dwEffects;
}COMPCOLOR;


// Clipboard formats - use as parameter to RegisterClipboardFormat() 
#define CF_RTF 			TEXT("Rich Text Format")
#define CF_RTFNOOBJS 	TEXT("Rich Text Format Without Objects")
#define CF_RETEXTOBJ 	TEXT("RichEdit Text and Objects")

// Paste Special 
typedef struct _repastespecial
{
	DWORD		dwAspect;
#if (WINVER >= 0x0500) && defined( _OBJBASE_H_ )
	DWORD_PTR	dwParam;
#else
	DWORD	dwParam;
#endif
} REPASTESPECIAL;

//	UndoName info 
typedef enum _undonameid
{
    UID_UNKNOWN     = 0,
	UID_TYPING		= 1,
	UID_DELETE 		= 2,
	UID_DRAGDROP	= 3,
	UID_CUT			= 4,
	UID_PASTE		= 5,
	UID_AUTOCORRECT = 6
} UNDONAMEID;

// Flags for the SETEXTEX data structure 
#define ST_DEFAULT		0
#define ST_KEEPUNDO		1
#define ST_SELECTION	2
#define ST_NEWCHARS 	4

// EM_SETTEXTEX info; this struct is passed in the wparam of the message 
typedef struct _settextex
{
	DWORD	flags;			// Flags (see the ST_XXX defines)			
	UINT	codepage;		// Code page for translation (CP_ACP for sys default,
						    //  1200 for Unicode, -1 for control default)	
} SETTEXTEX;

// Flags for the GETEXTEX data structure 
#define GT_DEFAULT		0
#define GT_USECRLF		1
#define GT_SELECTION	2
#define GT_RAWTEXT		4
#define GT_NOHIDDENTEXT	8

// EM_GETTEXTEX info; this struct is passed in the wparam of the message 
typedef struct _gettextex
{
	DWORD	cb;				// Count of bytes in the string				
	DWORD	flags;			// Flags (see the GT_XXX defines			
	UINT	codepage;		// Code page for translation (CP_ACP for sys default,
						    //  1200 for Unicode, -1 for control default)	
	LPCSTR	lpDefaultChar;	// Replacement for unmappable chars			
	LPBOOL	lpUsedDefChar;	// Pointer to flag set when def char used	
} GETTEXTEX;

// Flags for the GETTEXTLENGTHEX data structure							
#define GTL_DEFAULT		0	// Do default (return # of chars)		
#define GTL_USECRLF		1	// Compute answer using CRLFs for paragraphs
#define GTL_PRECISE		2	// Compute a precise answer					
#define GTL_CLOSE		4	// Fast computation of a "close" answer		
#define GTL_NUMCHARS	8	// Return number of characters			
#define GTL_NUMBYTES	16	// Return number of _bytes_				

// EM_GETTEXTLENGTHEX info; this struct is passed in the wparam of the msg 
typedef struct _gettextlengthex
{
	DWORD	flags;			// Flags (see GTL_XXX defines)				
	UINT	codepage;		// Code page for translation (CP_ACP for default,
							//  1200 for Unicode)							
} GETTEXTLENGTHEX;
	
// BiDi specific features 
typedef struct _bidioptions
{
	UINT	cbSize;
	WORD	wMask;
	WORD	wEffects; 
} BIDIOPTIONS;

// BIDIOPTIONS masks 
#if (_RICHEDIT_VER == 0x0100)
#define BOM_DEFPARADIR			0x0001	// Default paragraph direction (implies alignment) (obsolete) 
#define BOM_PLAINTEXT			0x0002	// Use plain text layout (obsolete) 
#endif // _RICHEDIT_VER == 0x0100 
#define BOM_NEUTRALOVERRIDE		0x0004	// Override neutral layout (obsolete) 
#define BOM_CONTEXTREADING		0x0008	// Context reading order 
#define BOM_CONTEXTALIGNMENT	0x0010	// Context alignment 

// BIDIOPTIONS effects 
#if (_RICHEDIT_VER == 0x0100)
#define BOE_RTLDIR				0x0001	// Default paragraph direction (implies alignment) (obsolete) 
#define BOE_PLAINTEXT			0x0002	// Use plain text layout (obsolete) 
#endif // _RICHEDIT_VER == 0x0100 
#define BOE_NEUTRALOVERRIDE		0x0004	// Override neutral layout (obsolete) 
#define BOE_CONTEXTREADING		0x0008	// Context reading order 
#define BOE_CONTEXTALIGNMENT	0x0010	// Context alignment 

// Additional EM_FINDTEXT[EX] flags 
#define FR_MATCHDIAC                    0x20000000
#define FR_MATCHKASHIDA                 0x40000000
#define FR_MATCHALEFHAMZA               0x80000000
	
// UNICODE embedding character 
#ifndef WCH_EMBEDDING
#define WCH_EMBEDDING (WCHAR)0xFFFC
#endif // WCH_EMBEDDING 
		
// khyph - Kind of hyphenation
typedef enum tagKHYPH
{
	khyphNil,				// No Hyphenation
	khyphNormal,			// Normal Hyphenation
	khyphAddBefore,			// Add letter before hyphen
	khyphChangeBefore,		// Change letter before hyphen
	khyphDeleteBefore,		// Delete letter before hyphen
	khyphChangeAfter,		// Change letter after hyphen
	khyphDelAndChange		// Delete letter before hyphen and change
							//  letter preceding hyphen
} KHYPH;

typedef struct hyphresult
{
	KHYPH khyph;			// Kind of hyphenation
	long  ichHyph;			// Character which was hyphenated
	WCHAR chHyph;			// Depending on hyphenation type, character added, changed, etc.
} HYPHRESULT;

void WINAPI HyphenateProc(WCHAR *pszWord, LANGID langid, long ichExceed, HYPHRESULT *phyphresult);
typedef struct tagHyphenateInfo
{
	SHORT cbSize;			// Size of HYPHENATEINFO structure
	SHORT dxHyphenateZone;	// If a space character is closer to the margin
							//  than this value, don't hyphenate (in TWIPs)
	void (WINAPI* pfnHyphenate)(WCHAR*, LANGID, long, HYPHRESULT*);
} HYPHENATEINFO;

#ifdef _WIN32
#include <poppack.h>
#elif !defined(RC_INVOKED)
#pragma pack()
#endif

#ifdef __cplusplus
}
#endif  // __cplusplus 

#endif // !_RICHEDIT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\ruler.cpp ===
// ruler.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "ruler.h"
#include "wordpvw.h"
#include "wordpdoc.h"
#include "strings.h"
#include <memory.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define HEIGHT 17
#define RULERBARHEIGHT 17


CRulerItem::CRulerItem(UINT nBitmapID)
{
    m_nAlignment = TA_CENTER;
    m_pDC = NULL;
    m_bTrack = FALSE;
    m_hbm = NULL;
    m_hbmMask = NULL;
    if (nBitmapID != 0)
    {
        m_hbmMask = ::LoadBitmap(
            AfxFindResourceHandle(MAKEINTRESOURCE(nBitmapID+1), RT_BITMAP), 
            MAKEINTRESOURCE(nBitmapID+1));
        ASSERT(m_hbmMask != NULL);
        VERIFY(LoadMaskedBitmap(MAKEINTRESOURCE(nBitmapID)));
        BITMAP bm;
        ::GetObject(m_hbm, sizeof(BITMAP), &bm);
        m_size = CSize(bm.bmWidth, bm.bmHeight);
    }
}

CRulerItem::~CRulerItem()
{
    if (m_hbm != NULL)
        ::DeleteObject(m_hbm);
    if (m_hbmMask != NULL)
        ::DeleteObject(m_hbmMask);
}

BOOL CRulerItem::LoadMaskedBitmap(LPCTSTR lpszResourceName)
{
    ASSERT(lpszResourceName != NULL);

    if (m_hbm != NULL)
        ::DeleteObject(m_hbm);

    HINSTANCE hInst = AfxFindResourceHandle(lpszResourceName, RT_BITMAP);
    HRSRC hRsrc = ::FindResource(hInst, lpszResourceName, RT_BITMAP);
    if (hRsrc == NULL)
        return FALSE;

    m_hbm = AfxLoadSysColorBitmap(hInst, hRsrc);
    return (m_hbm != NULL);
}

void CRulerItem::SetHorzPosTwips(int nXPos)
{
    if (GetHorzPosTwips() != nXPos)
    {
        if (m_bTrack)
            DrawFocusLine();
        Invalidate();
        m_nXPosTwips = nXPos;
        Invalidate();
        if (m_bTrack)
            DrawFocusLine();
    }
}

void CRulerItem::TrackHorzPosTwips(int nXPos, BOOL /*bOnRuler*/)
{
    int nMin = GetMin();
    int nMax = GetMax();
    if (nXPos < nMin)
        nXPos = nMin;
    if (nXPos > nMax)
        nXPos = nMax;
    SetHorzPosTwips(nXPos);
}

void CRulerItem::DrawFocusLine()
{
    if (GetHorzPosTwips() != 0)
    {
        m_rcTrack.left = m_rcTrack.right = GetHorzPosPix();
        ASSERT(m_pDC != NULL);
        int nLeft = m_pRuler->XRulerToClient(m_rcTrack.left);
        m_pDC->MoveTo(nLeft, m_rcTrack.top);
        m_pDC->LineTo(nLeft, m_rcTrack.bottom);
    }
}

void CRulerItem::SetTrack(BOOL b)
{
    m_bTrack = b;
    
    if (m_pDC != NULL) // just in case we lost focus Capture somewhere
    {
        DrawFocusLine();
        m_pDC->RestoreDC(-1);
        delete m_pDC ;
        m_pDC = NULL;
    }
    if (m_bTrack)
    {
        CWordPadView* pView = (CWordPadView*)m_pRuler->GetView();
        ASSERT(pView != NULL);
        pView->GetClientRect(&m_rcTrack);
        m_pDC = new CWindowDC(pView);
        m_pDC->SaveDC();
        m_pDC->SelectObject(&m_pRuler->penFocusLine);
        m_pDC->SetROP2(R2_XORPEN);
        DrawFocusLine();
    }
}

void CRulerItem::Invalidate()
{
    CRect rc = GetHitRectPix();
    m_pRuler->RulerToClient(rc.TopLeft());
    m_pRuler->RulerToClient(rc.BottomRight());
    m_pRuler->InvalidateRect(rc);
}

CRect CRulerItem::GetHitRectPix()
{
    int nx = GetHorzPosPix();
    return CRect( 
        CPoint( 
            (m_nAlignment == TA_CENTER) ? (nx - m_size.cx/2) :
            (m_nAlignment == TA_LEFT) ? nx : nx - m_size.cx
            , m_nYPosPix
            ), 
        m_size);
}

void CRulerItem::Draw(CDC& dc)
{
    CDC dcBitmap;
    dcBitmap.CreateCompatibleDC(&dc);
    CPoint pt(GetHorzPosPix(), GetVertPosPix());

    HGDIOBJ hbm = ::SelectObject(dcBitmap.m_hDC, m_hbmMask);

    // do mask part
    if (m_nAlignment == TA_CENTER)
        dc.BitBlt(pt.x - m_size.cx/2, pt.y, m_size.cx, m_size.cy, &dcBitmap, 0, 0, SRCAND);
    else if (m_nAlignment == TA_LEFT)
        dc.BitBlt(pt.x, pt.y, m_size.cx, m_size.cy, &dcBitmap, 0, 0, SRCAND);
    else // TA_RIGHT
        dc.BitBlt(pt.x - m_size.cx, pt.y, m_size.cx, m_size.cy, &dcBitmap, 0, 0, SRCAND);
    
    // do image part
    ::SelectObject(dcBitmap.m_hDC, m_hbm);

    if (m_nAlignment == TA_CENTER)
        dc.BitBlt(pt.x - m_size.cx/2, pt.y, m_size.cx, m_size.cy, &dcBitmap, 0, 0, SRCINVERT);
    else if (m_nAlignment == TA_LEFT)
        dc.BitBlt(pt.x, pt.y, m_size.cx, m_size.cy, &dcBitmap, 0, 0, SRCINVERT);
    else // TA_RIGHT
        dc.BitBlt(pt.x - m_size.cx, pt.y, m_size.cx, m_size.cy, &dcBitmap, 0, 0, SRCINVERT);

    ::SelectObject(dcBitmap.m_hDC, hbm);
}

CComboRulerItem::CComboRulerItem(UINT nBitmapID1, UINT nBitmapID2, CRulerItem& item)
    : CRulerItem(nBitmapID1), m_secondary(nBitmapID2) , m_link(item)
{
    m_bHitPrimary = TRUE;
}

BOOL CComboRulerItem::HitTestPix(CPoint pt)
{
    m_bHitPrimary = FALSE;
    if (CRulerItem::GetHitRectPix().PtInRect(pt))
        m_bHitPrimary = TRUE;
    else 
        return m_secondary.HitTestPix(pt);
    return TRUE;
}

void CComboRulerItem::Draw(CDC& dc)
{
    CRulerItem::Draw(dc);
    m_secondary.Draw(dc);
}

void CComboRulerItem::SetHorzPosTwips(int nXPos)
{
    if (m_bHitPrimary) // only change linked items by delta
        m_link.SetHorzPosTwips(m_link.GetHorzPosTwips() + nXPos - GetHorzPosTwips());
    CRulerItem::SetHorzPosTwips(nXPos);
    m_secondary.SetHorzPosTwips(nXPos);
}

void CComboRulerItem::TrackHorzPosTwips(int nXPos, BOOL /*bOnRuler*/)
{
    int nMin = GetMin();
    int nMax = GetMax();
    if (nXPos < nMin)
        nXPos = nMin;
    if (nXPos > nMax)
        nXPos = nMax;
    SetHorzPosTwips(nXPos);
}

void CComboRulerItem::SetVertPos(int nYPos)
{
    m_secondary.SetVertPos(nYPos);
    nYPos += m_secondary.GetHitRectPix().Height();
    CRulerItem::SetVertPos(nYPos);
}

void CComboRulerItem::SetAlignment(int nAlign)
{
    CRulerItem::SetAlignment(nAlign);
    m_secondary.SetAlignment(nAlign);
}

void CComboRulerItem::SetRuler(CRulerBar* pRuler)
{
    m_pRuler = pRuler;
    m_secondary.SetRuler(pRuler);
}

void CComboRulerItem::SetBounds(int nMin, int nMax)
{
    CRulerItem::SetBounds(nMin, nMax);
    m_secondary.SetBounds(nMin, nMax);
}

int CComboRulerItem::GetMin()
{
    if (m_bHitPrimary)
    {
        int nPDist = GetHorzPosTwips() - CRulerItem::GetMin();
        int nLDist = m_link.GetHorzPosTwips() - m_link.GetMin();
        return GetHorzPosTwips() - min(nPDist, nLDist);
    }
    else
        return CRulerItem::GetMin();
}

int CComboRulerItem::GetMax()
{
    if (m_bHitPrimary)
    {
        int nPDist = CRulerItem::GetMax() - GetHorzPosTwips();
        int nLDist = m_link.GetMax() - m_link.GetHorzPosTwips();
        int nMinDist = (nPDist < nLDist) ? nPDist : nLDist;
        return GetHorzPosTwips() + nMinDist;
    }
    else
        return CRulerItem::GetMax();
}

void CTabRulerItem::TrackHorzPosTwips(int nXPos, BOOL bOnRuler)
{
    if (bOnRuler)
        CRulerItem::TrackHorzPosTwips(nXPos, bOnRuler);
    else
        CRulerItem::TrackHorzPosTwips(0, bOnRuler);
}


BEGIN_MESSAGE_MAP(CRulerBar, CControlBar)
    //{{AFX_MSG_MAP(CRulerBar)
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_MOUSEMOVE()
    ON_WM_SYSCOLORCHANGE()
    ON_WM_WINDOWPOSCHANGING()
    ON_WM_SHOWWINDOW()
    ON_WM_WINDOWPOSCHANGED()
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_SIZEPARENT, OnSizeParent)
    // Global help commands
END_MESSAGE_MAP()

CRulerBar::CRulerBar() : 
    m_leftmargin(IDB_RULER_BLOCK, IDB_RULER_UP, m_indent), 
    m_indent(IDB_RULER_DOWN), 
    m_rightmargin(IDB_RULER_UP),
    m_tabItem(IDB_RULER_TAB)
{
    m_bDeferInProgress = FALSE;
    m_leftmargin.SetRuler(this);
    m_indent.SetRuler(this);
    m_rightmargin.SetRuler(this);

    // all of the tab stops share handles
    for (int i=0;i<MAX_TAB_STOPS;i++)
    {
        m_pTabItems[i].m_hbm = m_tabItem.m_hbm;
        m_pTabItems[i].m_hbmMask = m_tabItem.m_hbmMask;
        m_pTabItems[i].m_size = m_tabItem.m_size;
    }

    m_unit.m_nTPU = 0;
    m_nScroll = 0;

    LOGFONT lf;
    memcpy(&lf, &theApp.m_lf, sizeof(lf));
    EVAL(StringCchCopy(lf.lfFaceName, ARRAYSIZE(lf.lfFaceName), L"MS Shell Dlg") == S_OK);
    lf.lfWidth = 0;
    VERIFY(fnt.CreateFontIndirect(&lf));

    m_nTabs = 0;
    m_leftmargin.SetVertPos(9);
    m_indent.SetVertPos(-1);
    m_rightmargin.SetVertPos(9);

    m_cxLeftBorder = 0;
    m_cyTopBorder = 4;
    m_cyBottomBorder = 6;
    
    m_pSelItem = NULL;

    m_logx = theApp.m_dcScreen.GetDeviceCaps(LOGPIXELSX);

    CreateGDIObjects();
}

CRulerBar::~CRulerBar()
{
    // set handles to NULL to avoid deleting twice
    for (int i=0;i<MAX_TAB_STOPS;i++)
    {
        m_pTabItems[i].m_hbm = NULL;
        m_pTabItems[i].m_hbmMask = NULL;
    }
}

void CRulerBar::CreateGDIObjects()
{
    penFocusLine.DeleteObject();
    penBtnHighLight.DeleteObject();
    penBtnShadow.DeleteObject();
    penWindowFrame.DeleteObject();
    penBtnText.DeleteObject();
    penBtnFace.DeleteObject();
    penWindowText.DeleteObject();
    penWindow.DeleteObject();
    brushWindow.DeleteObject();
    brushBtnFace.DeleteObject();

    penFocusLine.CreatePen(PS_DOT, 1,GetSysColor(COLOR_WINDOWTEXT));
    penBtnHighLight.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_BTNHIGHLIGHT));
    penBtnShadow.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_BTNSHADOW));
    penWindowFrame.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_WINDOWFRAME));
    penBtnText.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_BTNTEXT));
    penBtnFace.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_BTNFACE));
    penWindowText.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_WINDOWTEXT));
    penWindow.CreatePen(PS_SOLID, 0, GetSysColor(COLOR_WINDOW));
    brushWindow.CreateSolidBrush(GetSysColor(COLOR_WINDOW));
    brushBtnFace.CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
}

void CRulerBar::OnUpdateCmdUI(CFrameWnd* /*pTarget*/, BOOL /*bDisableIfNoHndler*/)
{
    ASSERT_VALID(this);
    //Get the page size and see if changed -- from document
    //get margins and tabs and see if changed -- from view
    if (m_pSelItem == NULL) // only update if not in middle of dragging
    {
        CWordPadView* pView = (CWordPadView*)GetView();
        ASSERT(pView != NULL);
        Update(pView->GetPaperSize(), pView->GetMargins());
        Update(pView->GetParaFormatSelection());
        CRect rect;
        pView->GetRichEditCtrl().GetRect(&rect);
        CPoint pt = rect.TopLeft();
        pView->ClientToScreen(&pt);
        ScreenToClient(&pt);
        if (m_cxLeftBorder != pt.x)
        {
            m_cxLeftBorder = pt.x;
            Invalidate();
        }

        int nScroll = 0;

        if (pView->GetStyle() & WS_HSCROLL)
            nScroll = pView->GetScrollPos(SB_HORZ);

        if (nScroll != m_nScroll)
        {
            m_nScroll = nScroll;
            Invalidate();
        }
    }
}

CSize CRulerBar::GetBaseUnits()
{
    ASSERT(fnt.GetSafeHandle() != NULL);
    CFont* pFont = theApp.m_dcScreen.SelectObject(&fnt);
    TEXTMETRIC tm;
    VERIFY(theApp.m_dcScreen.GetTextMetrics(&tm) == TRUE);
    theApp.m_dcScreen.SelectObject(pFont);
//  return CSize(tm.tmAveCharWidth, tm.tmHeight+tm.tmDescent);
    return CSize(tm.tmAveCharWidth, tm.tmHeight);
}

BOOL CRulerBar::Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID)
{
    ASSERT_VALID(pParentWnd);   // must have a parent

    dwStyle |= WS_CLIPSIBLINGS;
    // force WS_CLIPSIBLINGS (avoids SetWindowPos bugs)
    m_dwStyle = (UINT)dwStyle;

    // create the HWND
    CRect rect;
    rect.SetRectEmpty();
    LPCTSTR lpszClass = AfxRegisterWndClass(0, ::LoadCursor(NULL, IDC_ARROW),
        (HBRUSH)(COLOR_BTNFACE+1), NULL);

    if (!CWnd::Create(lpszClass, NULL, dwStyle, rect, pParentWnd, nID))
        return FALSE;
    // NOTE: Parent must resize itself for control bar to be resized

    // Turn off mirroring style for the ruler to make it appear over RichEdit
    // formatting area especially RichEdit control will never be mirrored.
    ::SetWindowLongPtr(m_hWnd , GWL_EXSTYLE ,  
          ::GetWindowLongPtr(m_hWnd , GWL_EXSTYLE ) & ~WS_EX_LAYOUTRTL);

    int i;
    int nMax = 100;
    for (i=0;i<MAX_TAB_STOPS;i++)
    {
        m_pTabItems[i].SetRuler(this);
        m_pTabItems[i].SetVertPos(8);
        m_pTabItems[i].SetHorzPosTwips(0);
        m_pTabItems[i].SetBounds(0, nMax);
    }
    return TRUE;
}

CSize CRulerBar::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
{
    ASSERT(bHorz);
    CSize m_size = CControlBar::CalcFixedLayout(bStretch, bHorz);
    CRect rectSize;
    rectSize.SetRectEmpty();
    CalcInsideRect(rectSize, bHorz);       // will be negative size
    m_size.cy = RULERBARHEIGHT - rectSize.Height();
    return m_size;
}

void CRulerBar::Update(const PARAFORMAT& pf)
{
    ASSERT(pf.cTabCount <= MAX_TAB_STOPS);

    m_leftmargin.SetHorzPosTwips((int)(pf.dxStartIndent + pf.dxOffset));
    m_indent.SetHorzPosTwips((int)pf.dxStartIndent);
    m_rightmargin.SetHorzPosTwips(PrintWidth() - (int) pf.dxRightIndent);

    int i = 0;
    for (i=0;i<pf.cTabCount;i++)
        m_pTabItems[i].SetHorzPosTwips((int)pf.rgxTabs[i]);
    for ( ;i<MAX_TAB_STOPS; i++)
        m_pTabItems[i].SetHorzPosTwips(0);
}

void CRulerBar::Update(CSize sizePaper, const CRect& rectMargins)
{
    if ((sizePaper != m_sizePaper) || (rectMargins != m_rectMargin))
    {
        m_sizePaper = sizePaper;
        m_rectMargin = rectMargins;
        Invalidate();
    }
    if (m_unit.m_nTPU != theApp.GetTPU())
    {
        m_unit = theApp.GetUnit();
        Invalidate();
    }
}

void CRulerBar::FillInParaFormat(PARAFORMAT& pf)
{
    pf.dwMask = PFM_STARTINDENT | PFM_RIGHTINDENT | PFM_OFFSET | PFM_TABSTOPS;
    pf.dxStartIndent = m_indent.GetHorzPosTwips();
    pf.dxOffset = m_leftmargin.GetHorzPosTwips() - pf.dxStartIndent;
    pf.dxRightIndent = PrintWidth() - m_rightmargin.GetHorzPosTwips();
    pf.cTabCount = 0L;
    SortTabs();
    int i, nPos = 0;
    for (i=0;i<MAX_TAB_STOPS;i++)
    {
        // get rid of zeroes and multiples
        // i.e. if we have 0,0,0,1,2,3,4,4,5
        // we will get tabs at 1,2,3,4,5
        if (nPos != m_pTabItems[i].GetHorzPosTwips())
        {
            nPos = m_pTabItems[i].GetHorzPosTwips();
            pf.rgxTabs[pf.cTabCount++] = nPos;
        }
    }
}

// simple bubble sort is adequate for small number of tabs
void CRulerBar::SortTabs()
{
    int i,j, nPos;
    for (i=0;i<MAX_TAB_STOPS - 1;i++)
    {
        for (j=i+1; j < MAX_TAB_STOPS;j++)
        {
            if (m_pTabItems[j].GetHorzPosTwips() < m_pTabItems[i].GetHorzPosTwips())
            {
                nPos = m_pTabItems[j].GetHorzPosTwips();
                m_pTabItems[j].SetHorzPosTwips(m_pTabItems[i].GetHorzPosTwips());
                m_pTabItems[i].SetHorzPosTwips(nPos);
            }
        }
    }
}

void CRulerBar::DoPaint(CDC* pDC)
{
    CControlBar::DoPaint(pDC); // CControlBar::DoPaint -- draws border
    if (m_unit.m_nTPU != 0)
    {
        pDC->SaveDC();
        // offset coordinate system
        CPoint pointOffset(0,0);
        RulerToClient(pointOffset);
        pDC->SetViewportOrg(pointOffset);

        DrawFace(*pDC);
        DrawTickMarks(*pDC);

        DrawTabs(*pDC);
        m_leftmargin.Draw(*pDC);
        m_indent.Draw(*pDC);
        m_rightmargin.Draw(*pDC);   

        pDC->RestoreDC(-1);
    }
    // Do not call CControlBar::OnPaint() for painting messages
}

void CRulerBar::DrawTabs(CDC& dc)
{
    int i;
    int nPos = 0;
    for (i=0;i<MAX_TAB_STOPS;i++)
    {
        if (m_pTabItems[i].GetHorzPosTwips() > nPos)
            nPos = (m_pTabItems[i].GetHorzPosTwips());
        m_pTabItems[i].Draw(dc);
    }
    int nPageWidth = PrintWidth();
    nPos = nPos - nPos%720 + 720;
    dc.SelectObject(&penBtnShadow);
    for ( ; nPos < nPageWidth; nPos += 720)
    {
        int nx = XTwipsToRuler(nPos);
        dc.MoveTo(nx, HEIGHT - 1);
        dc.LineTo(nx, HEIGHT + 1);
    }
}

void CRulerBar::DrawFace(CDC& dc)
{
    int nPageWidth = XTwipsToRuler(PrintWidth());
    int nPageEdge = XTwipsToRuler(PrintWidth() + m_rectMargin.right);

    dc.SaveDC();

    dc.SelectObject(&penBtnShadow);
    dc.MoveTo(0,0);
    dc.LineTo(nPageEdge - 1, 0);
    dc.LineTo(nPageEdge - 1, HEIGHT - 2);
    dc.LineTo(nPageWidth - 1, HEIGHT - 2);
    dc.LineTo(nPageWidth - 1, 1);
    dc.LineTo(nPageWidth, 1);
    dc.LineTo(nPageWidth, HEIGHT -2);
    
    dc.SelectObject(&penBtnHighLight);
    dc.MoveTo(nPageWidth, HEIGHT - 1);
    dc.LineTo(nPageEdge, HEIGHT -1);
    dc.MoveTo(nPageWidth + 1, HEIGHT - 3);
    dc.LineTo(nPageWidth + 1, 1);
    dc.LineTo(nPageEdge - 1, 1);
    
    dc.SelectObject(&penWindow);
    dc.MoveTo(0, HEIGHT - 1);
    dc.LineTo(nPageWidth, HEIGHT -1);

    dc.SelectObject(&penBtnFace);
    dc.MoveTo(1, HEIGHT - 2);
    dc.LineTo(nPageWidth - 1, HEIGHT - 2);
    
    dc.SelectObject(&penWindowFrame);
    dc.MoveTo(0, HEIGHT - 2);
    dc.LineTo(0, 1);
    dc.LineTo(nPageWidth - 1, 1);
    
    dc.FillRect(CRect(1, 2, nPageWidth - 1, HEIGHT-2), &brushWindow);
    dc.FillRect(CRect(nPageWidth + 2, 2, nPageEdge - 1, HEIGHT-2), &brushBtnFace);

    CRect rcClient;
    GetClientRect(&rcClient);
    ClientToRuler(rcClient);
    rcClient.top = HEIGHT;
    rcClient.bottom = HEIGHT + 8;
    rcClient.right -= 2;

    DrawEdge(dc, &rcClient, EDGE_RAISED, BF_BOTTOM | BF_MIDDLE);
    
    //
    // Small fixup to account for the fact that the left border needs to merge
    // with the window below the ruler.
    //

    dc.SetPixel(rcClient.left, rcClient.bottom-1, GetSysColor(COLOR_3DSHADOW));

    dc.RestoreDC(-1);
}

void CRulerBar::DrawTickMarks(CDC& dc)
{
    dc.SaveDC();

    dc.SelectObject(&penWindowText);
    dc.SelectObject(&fnt);
    dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT));
    dc.SetBkMode(TRANSPARENT);

    DrawDiv(dc, m_unit.m_nSmallDiv, m_unit.m_nLargeDiv, 2);
    DrawDiv(dc, m_unit.m_nMediumDiv, m_unit.m_nLargeDiv, 5);
    DrawNumbers(dc, m_unit.m_nLargeDiv, m_unit.m_nTPU);
    
    dc.RestoreDC(-1);
}

void CRulerBar::DrawNumbers(CDC& dc, int nInc, int nTPU)
{
    int nPageWidth = PrintWidth();
    int nPageEdge = nPageWidth + m_rectMargin.right;
    TCHAR buf[12];

    int nTwips, nPixel, nLen;

    for (nTwips = nInc; nTwips < nPageEdge; nTwips += nInc)
    {
        if (nTwips == nPageWidth)
            continue;
        nPixel = XTwipsToRuler(nTwips);
        EVAL(SUCCEEDED(StringCchPrintf(buf, ARRAYSIZE(buf), _T("%d"), nTwips/nTPU))); // Always enough room.
        nLen = lstrlen(buf);
        CSize sz = dc.GetTextExtent(buf, nLen);
        dc.ExtTextOut(nPixel - sz.cx/2, HEIGHT/2 - sz.cy/2, 0, NULL, buf, nLen, NULL);
    }
}

void CRulerBar::DrawDiv(CDC& dc, int nInc, int nLargeDiv, int nLength)
{
    int nPageWidth = PrintWidth();
    int nPageEdge = nPageWidth + m_rectMargin.right;

    int nTwips, nPixel;

    for (nTwips = nInc; nTwips < nPageEdge; nTwips += nInc)
    {
        if (nTwips == nPageWidth || nTwips%nLargeDiv == 0)
            continue;
        nPixel = XTwipsToRuler(nTwips);
        dc.MoveTo(nPixel, HEIGHT/2 - nLength/2);
        dc.LineTo(nPixel, HEIGHT/2 - nLength/2 + nLength);
    }
}

void CRulerBar::OnLButtonDown(UINT nFlags, CPoint point)
{
    CPoint pt = point;
    ClientToRuler(pt);
    
    m_pSelItem = NULL;
    if (m_leftmargin.HitTestPix(pt))
        m_pSelItem = &m_leftmargin;
    else if (m_indent.HitTestPix(pt))
        m_pSelItem = &m_indent;
    else if (m_rightmargin.HitTestPix(pt))
        m_pSelItem = &m_rightmargin;
    else
        m_pSelItem = GetHitTabPix(pt);
    if (m_pSelItem == NULL)
        m_pSelItem = GetFreeTab();
    if (m_pSelItem == NULL)
        return;
    SetCapture();

    m_pSelItem->SetTrack(TRUE);
    SetMarginBounds();
    OnMouseMove(nFlags, point);
}

void CRulerBar::SetMarginBounds()
{
    m_leftmargin.SetBounds(0, m_rightmargin.GetHorzPosTwips());
    m_indent.SetBounds(0, m_rightmargin.GetHorzPosTwips());

    int nMin = (m_leftmargin.GetHorzPosTwips() > m_indent.GetHorzPosTwips()) ? 
        m_leftmargin.GetHorzPosTwips() : m_indent.GetHorzPosTwips();
    int nMax = PrintWidth() + m_rectMargin.right;
    m_rightmargin.SetBounds(nMin, nMax);
    
    // tabs can go from zero to the right page edge
    for (int i=0;i<MAX_TAB_STOPS;i++)
        m_pTabItems[i].SetBounds(0, nMax);
}

CRulerItem* CRulerBar::GetFreeTab()
{
    int i;
    for (i=0;i<MAX_TAB_STOPS;i++)
    {
        if (m_pTabItems[i].GetHorzPosTwips() == 0)
            return &m_pTabItems[i];
    }
    return NULL;
}

CTabRulerItem* CRulerBar::GetHitTabPix(CPoint point)
{
    int i;
    for (i=0;i<MAX_TAB_STOPS;i++)
    {
        if (m_pTabItems[i].HitTestPix(point))
            return &m_pTabItems[i];
    }
    return NULL;
}

void CRulerBar::OnLButtonUp(UINT nFlags, CPoint point)
{
    if (::GetCapture() != m_hWnd)
        return;
    OnMouseMove(nFlags, point);
    m_pSelItem->SetTrack(FALSE);
    ReleaseCapture();
    CWordPadView* pView = (CWordPadView*)GetView();
    ASSERT(pView != NULL);
    PARAFORMAT& pf = pView->GetParaFormatSelection();
    FillInParaFormat(pf);
    pView->SetParaFormat(pf);
    m_pSelItem = NULL;
}

void CRulerBar::OnMouseMove(UINT nFlags, CPoint point)
{
    CControlBar::OnMouseMove(nFlags, point);
// use ::GetCapture to avoid creating temporaries
    if (::GetCapture() != m_hWnd)
        return;
    ASSERT(m_pSelItem != NULL);
    CRect rc(0,0, XTwipsToRuler(PrintWidth() + m_rectMargin.right), HEIGHT);
    RulerToClient(rc);
    BOOL bOnRuler = rc.PtInRect(point);

// snap to minimum movement
    point.x = XClientToTwips(point.x);
    point.x += m_unit.m_nMinMove/2;
    point.x -= point.x%m_unit.m_nMinMove;

    m_pSelItem->TrackHorzPosTwips(point.x, bOnRuler);
    UpdateWindow();
}

void CRulerBar::OnSysColorChange()
{
    CControlBar::OnSysColorChange();
    CreateGDIObjects();
    Invalidate();   
}

void CRulerBar::OnWindowPosChanging(WINDOWPOS FAR* lpwndpos) 
{
    CControlBar::OnWindowPosChanging(lpwndpos);
    CRect rect;
    GetClientRect(rect);
    int minx = min(rect.Width(), lpwndpos->cx);
    int maxx = max(rect.Width(), lpwndpos->cx);
    rect.SetRect(minx-2, rect.bottom - 6, minx, rect.bottom);
    InvalidateRect(rect);
    rect.SetRect(maxx-2, rect.bottom - 6, maxx, rect.bottom);
    InvalidateRect(rect);
}

void CRulerBar::OnShowWindow(BOOL bShow, UINT nStatus) 
{
    CControlBar::OnShowWindow(bShow, nStatus);
    m_bDeferInProgress = FALSE; 
}

void CRulerBar::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos) 
{
    CControlBar::OnWindowPosChanged(lpwndpos);
    m_bDeferInProgress = FALSE; 
}

LRESULT CRulerBar::OnSizeParent(WPARAM wParam, LPARAM lParam)
{
    BOOL bVis = GetStyle() & WS_VISIBLE;
    if ((bVis && (m_nStateFlags & delayHide)) ||
        (!bVis && (m_nStateFlags & delayShow)))
    {
        m_bDeferInProgress = TRUE;
    }
    return CControlBar::OnSizeParent(wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	wordpad.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\srvritem.h ===
// srvritem.h : interface of the CWordPadSrvrItem class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

class CWordPadDoc;
class CWordPadView;

class CEmbeddedItem : public COleServerItem
{
	DECLARE_DYNAMIC(CEmbeddedItem)

// Constructors
public:
	CEmbeddedItem(CWordPadDoc* pContainerDoc, int nBeg = 0, int nEnd = -1);

// Attributes
	int m_nBeg;
	int m_nEnd;
	LPDATAOBJECT m_lpRichDataObj;
	CWordPadDoc* GetDocument() const
		{ return (CWordPadDoc*) COleServerItem::GetDocument(); }
	CWordPadView* GetView() const;

// Implementation
public:
	BOOL OnDrawEx(CDC* pDC, CSize& rSize, BOOL bOutput);
	virtual BOOL OnDraw(CDC* pDC, CSize& rSize);
	virtual BOOL OnGetExtent(DVASPECT dwDrawAspect, CSize& rSize);

protected:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\stdafx2.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// STDAFX.H is the header that includes the standard includes that are used
//  for most of the project.  These are compiled into a pre-compiled header

// turn off warnings for /W4 (just for MFC implementation)
#ifndef ALL_WARNINGS
#pragma warning(disable: 4073)  // disable warning about using init_seg
#ifdef _MAC
#pragma warning(disable: 4121)  // disable (incorrect?) warning about packing of MachineLocation in OSUtils.h
#endif
#endif

// MFC inline constructors (including compiler generated) can get deep
#pragma inline_depth(16)

// override default values for data import/export when building MFC DLLs
#ifdef _AFX_CORE_IMPL
	#define AFX_CORE_DATA   AFX_DATA_EXPORT
	#define AFX_CORE_DATADEF
#endif

#ifdef _AFX_OLE_IMPL
	#define AFX_OLE_DATA    AFX_DATA_EXPORT
	#define AFX_OLE_DATADEF
#endif

#ifdef _AFX_DB_IMPL
	#define AFX_DB_DATA     AFX_DATA_EXPORT
	#define AFX_DB_DATADEF
#endif

#ifdef _AFX_NET_IMPL
	#define AFX_NET_DATA    AFX_DATA_EXPORT
	#define AFX_NET_DATADEF
#endif

#ifndef _AFX_NOFORCE_LIBS
#define _AFX_NOFORCE_LIBS
#endif

#define _AFX_FULLTYPEINFO
#define VC_EXTRALEAN
#define NO_ANSIUNI_ONLY

// include these first so that protected structures in winwlm.h are declared
#ifdef _MAC
#define SystemSevenOrLater 1
#include <macname1.h>
#include <Types.h>
#include <QuickDraw.h>
#include <AppleEvents.h>
#include <macname2.h>
#endif

// core headers
#include "afx.h"
#include "afxplex_.h"
#include "afxcoll.h"

// public headers
#include "afxwin.h"

//
// MFC 4.2 hardcodes _RICHEDIT_VER to 0x0100 in afxwin.h.  This prevents
// richedit.h from enabling any richedit 2.0 features.
//

#ifdef _RICHEDIT_VER
#if _RICHEDIT_VER < 0x0200
#undef _RICHEDIT_VER
#define _RICHEDIT_VER 0x0200
#endif
#endif

#ifndef _AFX_ENABLE_INLINES
#define _AFX_ENABLE_INLINES
#endif

#define _AFXCMN2_INLINE     inline 
#define _AFXDLGS2_INLINE    inline
#define _AFXRICH2_INLINE    inline

#include "afxdlgs.h"
#include "afxdlgs2.h"
#include "afxext.h"
#ifndef _AFX_NO_OLE_SUPPORT
	#ifndef _OLE2_H_
		#include <ole2.h>
	#endif

#include <winspool.h>

#ifdef _MAC
	// include OLE dialog/helper APIs
	#include <ole2ui.h>
#else
	// include OLE dialog/helper APIs
	#ifndef _OLEDLG_H_
		#include <oledlg.h>
	#endif
#endif

	#include <winreg.h>
		#include "afxcom_.h"
//	#include "oleimpl.h"
	#include "afxole.h"
#ifndef _MAC
	#include "afxdocob.h"
#endif

#ifndef _AFX_NO_DAO_SUPPORT
	#include "afxdao.h"
#endif

	#include "afxodlgs.h"
#endif

#ifndef _AFX_NO_OCX_SUPPORT
	#include "afxctl.h"
#endif
#ifndef _AFX_NO_DB_SUPPORT
	#include "afxdb.h"
#endif
#ifndef _AFX_NO_SYNC_SUPPORT
	#include "afxmt.h"
#endif
#ifndef _AFX_NO_INET_SUPPORT
	#include "afxinet.h"
#endif

// private headers as well
#include "afxpriv.h"
#include "afximpl2.h"
//#include "winhand_.h"
#ifndef _AFX_NO_OLE_SUPPORT
	#include "oleimpl3.h"
#endif
#ifndef _AFX_NO_OCX_SUPPORT
//	#include "ctlimpl.h"
#endif
#ifndef _AFX_NO_DB_SUPPORT
//	#include "dbimpl.h"
#endif
#ifndef _AFX_NO_DAO_SUPPORT
//	#include "daoimpl.h"
#endif
#ifndef _AFX_NO_SOCKET_SUPPORT
	#ifndef _WINSOCKAPI_
//		#include <winsock.h>
	#endif
//	#include "sockimpl.h"
//	#include "afxsock.h"
#endif
#ifndef _AFX_NO_AFXCMN_SUPPORT
//	#include "commimpl.h"
	#include "afxcmn.h"
	#include "afxcview.h"
#endif
	#include "afxrich2.h"

#include <winreg.h>
#include <winnls.h>
#include <stddef.h>
#include <limits.h>
#include <malloc.h>
#include <new.h>
#ifndef _AFX_OLD_EXCEPTIONS
#include <eh.h>     // for set_terminate
#endif

#undef AfxWndProc

// implementation uses _AFX_PACKING as well
#ifdef _AFX_PACKING
#ifndef ALL_WARNINGS
#pragma warning(disable: 4103)
#endif
#pragma pack(_AFX_PACKING)
#endif

// special exception handling just for MFC library implementation
#ifndef _AFX_OLD_EXCEPTIONS

// MFC does not rely on auto-delete semantics of the TRY..CATCH macros,
//  therefore those macros are mapped to something closer to the native
//  C++ exception handling mechanism when building MFC itself.

#undef TRY
#define TRY { try {

#undef CATCH
#define CATCH(class, e) } catch (class* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(class))); UNUSED(e);

#undef AND_CATCH
#define AND_CATCH(class, e) } catch (class* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(class))); UNUSED(e);

#undef CATCH_ALL
#define CATCH_ALL(e) } catch (CException* e) \
	{ { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); UNUSED(e);

#undef AND_CATCH_ALL
#define AND_CATCH_ALL(e) } catch (CException* e) \
	{ { ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); UNUSED(e);

#undef END_TRY
#define END_TRY } catch (CException* e) \
	{ ASSERT(e->IsKindOf(RUNTIME_CLASS(CException))); e->Delete(); } }

#undef THROW_LAST
#define THROW_LAST() throw

// Because of the above definitions of TRY...CATCH it is necessary to
//  explicitly delete exception objects at the catch site.

#define DELETE_EXCEPTION(e) do { e->Delete(); } while (0)
#define NO_CPP_EXCEPTION(expr)

#else   //!_AFX_OLD_EXCEPTIONS

// In this case, the TRY..CATCH macros provide auto-delete semantics, so
//  it is not necessary to explicitly delete exception objects at the catch site.

#define DELETE_EXCEPTION(e)
#define NO_CPP_EXCEPTION(expr) expr

#endif  //_AFX_OLD_EXCEPTIONS


#include <afxcmn2.h>
#include <afxrich2.h>

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef _UNICODE
#define VC_EXTRALEAN            // use stripped down Win32 headers
#endif

#define CONVERTERS

#include <afxwin.h>         // MFC core and standard components

//
// MFC 4.2 hardcodes _RICHEDIT_VER to 0x0100 in afxwin.h.  This prevents
// richedit.h from enabling any richedit 2.0 features.
//

#ifdef _RICHEDIT_VER
#if _RICHEDIT_VER < 0x0200
#undef _RICHEDIT_VER
#define _RICHEDIT_VER 0x0200
#endif
#endif

#include <objbase.h>
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxcmn.h>
//#include <afxrich.h>
#include <afxpriv.h>

//
// Private headers for richedit2 support until MFC gets native support
//

#ifndef _AFX_ENABLE_INLINES
#define _AFX_ENABLE_INLINES
#endif

#define _AFXCMN2_INLINE     inline
#define _AFXDLGS2_INLINE    inline
#define _AFXRICH2_INLINE    inline

#include <afxdlgs2.h>
#include <afxcmn2.h>
#include <afxrich2.h>



#define HORZ_TEXTOFFSET 15
#define VERT_TEXTOFFSET 5

class CDisplayIC : public CDC
{
public:
	CDisplayIC() { CreateIC(_T("DISPLAY"), NULL, NULL, NULL); }
};

struct CCharFormat : public CHARFORMAT  // re20 requires this line; added by t-stefb
//struct CCharFormat : public _charformat
{
	CCharFormat() {cbSize = sizeof(CHARFORMAT);}  // re20 requires this line; added by t-stefb
//	CCharFormat() {cbSize = sizeof(_charformat);}
	BOOL operator==(CCharFormat& cf);
};

struct CParaFormat : public _paraformat
{
	CParaFormat() {cbSize = sizeof(_paraformat);}
	BOOL operator==(PARAFORMAT& pf);
};

#include "doctype.h"
#include "chicdial.h"

#include <htmlhelp.h>
#include <shlwapi.h>
#include <strsafe.h>
#include <debug.h>
#include <ccstock.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\srvritem.cpp ===
// srvritem.cpp : implementation of the CWordPadSrvrItem class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "wordpdoc.h"
#include "wordpvw.h"
#include "srvritem.h"
#include <limits.h>

IMPLEMENT_DYNAMIC(CEmbeddedItem, COleServerItem)

extern CLIPFORMAT cfRTF;

CEmbeddedItem::CEmbeddedItem(CWordPadDoc* pContainerDoc, int nBeg, int nEnd)
	: COleServerItem(pContainerDoc, TRUE)
{
	ASSERT(pContainerDoc != NULL);
	ASSERT_VALID(pContainerDoc);
	m_nBeg = nBeg;
	m_nEnd = nEnd;
}

CWordPadView* CEmbeddedItem::GetView() const
{
	CDocument* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	POSITION pos = pDoc->GetFirstViewPosition();
	if (pos == NULL)
		return NULL;

	CWordPadView* pView = (CWordPadView*)pDoc->GetNextView(pos);
	ASSERT_VALID(pView);
	ASSERT(pView->IsKindOf(RUNTIME_CLASS(CWordPadView)));
	return pView;
}

void CEmbeddedItem::Serialize(CArchive& ar)
{
	if (m_lpRichDataObj != NULL)
	{
		ASSERT(ar.IsStoring());
		FORMATETC etc = {NULL, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
		etc.cfFormat = (CLIPFORMAT)cfRTF;
		STGMEDIUM stg;
		if (SUCCEEDED(m_lpRichDataObj->GetData(&etc, &stg)))
		{
			LPBYTE p = (LPBYTE)GlobalLock(stg.hGlobal);
			if (p != NULL)
			{
				ar.Write(p, (DWORD)GlobalSize(stg.hGlobal));
				GlobalUnlock(stg.hGlobal);
			}
			ASSERT(stg.tymed == TYMED_HGLOBAL);
			ReleaseStgMedium(&stg);
		}
	}
	else
		GetDocument()->Serialize(ar);
}

BOOL CEmbeddedItem::OnGetExtent(DVASPECT dwDrawAspect, CSize& rSize)
{
	if (dwDrawAspect != DVASPECT_CONTENT)
		return COleServerItem::OnGetExtent(dwDrawAspect, rSize);

	CClientDC dc(NULL);
	return OnDrawEx(&dc, rSize, FALSE);
}

BOOL CEmbeddedItem::OnDraw(CDC* pDC, CSize& rSize)
{
	return OnDrawEx(pDC, rSize, TRUE);
}

BOOL CEmbeddedItem::OnDrawEx(CDC* pDC, CSize& rSize, BOOL bOutput)
{
	CDisplayIC dc;
	CWordPadView* pView = GetView();
	if (pView == NULL)
		return FALSE;
	ASSERT_VALID(pView);

	int nWrap = pView->m_nWordWrap;

	CRect rect;//rect in twips
	rect.left = rect.top = 0;
	rect.bottom = 32767; // bottomless

	rect.right = 32767;
	if (nWrap == 0) // no word wrap
		rect.right = 32767;
	else if (nWrap == 1) // wrap to window
	{
		CRect rectClient;
		pView->GetClientRect(&rectClient);
		rect.right = rectClient.right - HORZ_TEXTOFFSET;
		rect.right = MulDiv(rect.right, 1440, dc.GetDeviceCaps(LOGPIXELSX));
	}
	else if (nWrap == 2) // wrap to ruler
		rect.right = pView->GetPrintWidth();

	// first just determine the correct extents of the text
	pDC->SetBkMode(TRANSPARENT);
	
	if (pView->PrintInsideRect(pDC, rect, m_nBeg, m_nEnd, FALSE) == 0)
	{
		// default to 12pts high and 4" wide if no text
		rect.bottom = rect.top+12*20+1; // 12 pts high
		rect.right = rect.left+ 4*1440;
	}
	rect.bottom+=3*(1440/dc.GetDeviceCaps(LOGPIXELSX)); // three pixels

	// then, really output the text
	CRect rectOut = rect; // don't pass rect because it will get clobbered
	if (bOutput)
		pView->PrintInsideRect(pDC, rectOut, m_nBeg, m_nEnd, TRUE);
	ASSERT(rectOut.right == rect.right);

	// adjust for border (rect.left is already adjusted)
	if (pView->GetStyle() & WS_HSCROLL)
		++rect.bottom;  // account for border on scroll bar!

	// return HIMETRIC size
	rSize = rect.Size();
	rSize.cx = MulDiv(rSize.cx, 2540, 1440); // convert twips to HIMETRIC
	rSize.cy = MulDiv(rSize.cy, 2540, 1440); // convert twips to HIMETRIC
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\ruler.h ===
// riched.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __RULER_H__
#define __RULER_H__

class CWordPadView;
class CWordPadDoc;
class CRulerBar;

// ruler items include left margin, right margin, indent, and tabs

// horz positions in twips -- necessary to avoid rounding errors
// vertical position in pixels
class CRulerItem
{
public:
    CRulerItem(UINT nBitmapID = 0);
    ~CRulerItem();
    virtual BOOL HitTestPix(CPoint pt) { return GetHitRectPix().PtInRect(pt); }
    virtual void Draw(CDC& dc);
    virtual void SetHorzPosTwips(int nXPos);
    virtual void TrackHorzPosTwips(int nXPos, BOOL bOnRuler = TRUE);
    virtual void SetVertPos(int nYPos) { m_nYPosPix = nYPos; }
    virtual void SetAlignment(int nAlign) {m_nAlignment = nAlign;}
    virtual void SetRuler(CRulerBar* pRuler) {m_pRuler = pRuler;}
    virtual void SetBounds(int nMin, int nMax) { m_nMin = nMin; m_nMax = nMax; }
    int GetMin() { return m_nMin;}
    int GetMax() { return m_nMax;}
    void Invalidate();
    int GetVertPosPix() { return m_nYPosPix;}
    int GetHorzPosTwips() { return m_nXPosTwips;}
    int GetHorzPosPix();
    CRect GetHitRectPix();
    void DrawFocusLine();
    void SetTrack(BOOL b);

    HBITMAP m_hbm;
    HBITMAP m_hbmMask;
    CSize m_size;   // size of item in pixels

// Operations
    BOOL LoadMaskedBitmap(LPCTSTR lpszResourceName);

protected:
    int m_nYPosPix;
    int m_nXPosTwips;
    int m_nAlignment;
    BOOL m_bTrack;
    CRulerBar* m_pRuler;
    CRect m_rcTrack;
    CDC* m_pDC; // dc used for drawing tracking line
    int m_nMin, m_nMax;
};

class CComboRulerItem : public CRulerItem
{ 
public:
    CComboRulerItem(UINT nBitmapID1, UINT nBitmapID2, CRulerItem& item);
    virtual BOOL HitTestPix(CPoint pt);
    virtual void Draw(CDC& dc);
    virtual void SetHorzPosTwips(int nXPos);
    virtual void TrackHorzPosTwips(int nXPos, BOOL bOnRuler = TRUE);
    virtual void SetVertPos(int nYPos);
    virtual void SetAlignment(int nAlign);
    virtual void SetRuler(CRulerBar* pRuler);
    virtual void SetBounds(int nMin, int nMax);
    int GetMin();
    int GetMax();
protected:
    CRulerItem m_secondary;
    CRulerItem& m_link;
    BOOL m_bHitPrimary;
};

class CTabRulerItem : public CRulerItem
{
public:
    CTabRulerItem() { SetAlignment(TA_LEFT); }
    virtual void Draw(CDC& dc) {if (GetHorzPosTwips() != 0) CRulerItem::Draw(dc);}
    virtual void TrackHorzPosTwips(int nXPos, BOOL bOnRuler = TRUE);
    virtual BOOL HitTestPix(CPoint pt) { return (GetHorzPosTwips() != 0) ? CRulerItem::HitTestPix(pt) : FALSE;}
};

/////////////////////////////////////////////////////////////////////////////
// CRulerBar

class CRulerBar : public CControlBar
{
// Construction
public:
    CRulerBar();
    ~CRulerBar();

// Operations
public:
    virtual BOOL Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID);
protected:
    void Update(const PARAFORMAT& pf);
    void Update(CSize sizePaper, const CRect& rectMargins);

// Attributes
public:
    BOOL m_bDeferInProgress;
    CUnit m_unit;
    CRulerItem* m_pSelItem;
    CFont fnt;
    CSize GetBaseUnits();
    CComboRulerItem m_leftmargin;
    CRulerItem m_indent;
    CRulerItem m_rightmargin;
    CRulerItem m_tabItem;
    CTabRulerItem m_pTabItems[MAX_TAB_STOPS];
    CSize m_sizePaper;
    CRect m_rectMargin;
    int PrintWidth() {return m_sizePaper.cx - m_rectMargin.left - 
        m_rectMargin.right;}
    int m_nTabs;
    int m_logx;
    int m_nLinePos;
    int m_nScroll; // in pixels

    CPen penFocusLine;
    CPen penBtnHighLight;
    CPen penBtnShadow;
    CPen penWindowFrame;
    CPen penBtnText;
    CPen penBtnFace;
    CPen penWindowText;
    CPen penWindow;
    CBrush brushWindow;
    CBrush brushBtnFace;

// Implementation
public:
    virtual void DoPaint(CDC* pDC);
    virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
    void ClientToRuler(CPoint& pt) {pt.Offset(-m_cxLeftBorder+m_nScroll, -m_cyTopBorder);}
    void ClientToRuler(CRect& rect) {rect.OffsetRect(-m_cxLeftBorder+m_nScroll, -m_cyTopBorder);}
    void RulerToClient(CPoint& pt) {pt.Offset(m_cxLeftBorder-m_nScroll, m_cyTopBorder);}
    void RulerToClient(CRect& rect) {rect.OffsetRect(m_cxLeftBorder-m_nScroll, m_cyTopBorder);}

    int XTwipsToClient(int nT) {return MulDiv(nT, m_logx, 1440) + m_cxLeftBorder - m_nScroll;}
    int XClientToTwips(int nC) {return MulDiv(nC - m_cxLeftBorder + m_nScroll, 1440, m_logx);}

    int XTwipsToRuler(int nT) {return MulDiv(nT, m_logx, 1440);}
    int XRulerToTwips(int nR) {return MulDiv(nR, 1440, m_logx);}

    int XRulerToClient(int nR) {return nR + m_cxLeftBorder - m_nScroll;}
    int XClientToRuler(int nC) {return nC - m_cxLeftBorder + m_nScroll;}

protected:
    virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
    void CreateGDIObjects();
    void DrawFace(CDC& dc);
    void DrawTickMarks(CDC& dC);
    void DrawNumbers(CDC& dc, int nInc, int nTPU);
    void DrawDiv(CDC& dc, int nInc, int nLargeDiv, int nLength);
    void DrawTabs(CDC& dc);
    void FillInParaFormat(PARAFORMAT& pf);
    void SortTabs();
    void SetMarginBounds();
    CRulerItem* GetFreeTab();
    CView* GetView()
    {
        ASSERT(GetParent() != NULL);
        return ((CFrameWnd*)GetParent())->GetActiveView();
    }
    CDocument* GetDocument() { return GetView()->GetDocument(); }

    CTabRulerItem* GetHitTabPix(CPoint pt);

    // Generated message map functions
    //{{AFX_MSG(CRulerBar)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg void OnSysColorChange();
    afx_msg void OnWindowPosChanging(WINDOWPOS FAR* lpwndpos);
    afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
    afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
    //}}AFX_MSG
    afx_msg LRESULT OnSizeParent(WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()
    
    friend class CRulerItem;
};

inline int CRulerItem::GetHorzPosPix()
    { return m_pRuler->XTwipsToRuler(m_nXPosTwips); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\strings.h ===
// strings.h : defines all extern const strings
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

extern const TCHAR szWordPadClass[];
extern const TCHAR szLayout1[];
extern const TCHAR szLayout2[];
extern const TCHAR szRegKey[];

extern const TCHAR szTextSection[];
extern const TCHAR szRTFSection[];
extern const TCHAR szWordSection[];
extern const TCHAR szWriteSection[];
extern const TCHAR szIPSection[];
extern const TCHAR szWrap[];
extern const TCHAR szPageMargin[];

extern const TCHAR szSection[];
extern const TCHAR szWordSel[];
extern const TCHAR szUnits[];
extern const TCHAR szFrameRect[];
extern const TCHAR szMaximized[];
extern const TCHAR szDeleteTemp[];

extern const TCHAR szSumInfo[];
extern const TCHAR szContents[];

extern TCHAR szWordConverter[];
extern TCHAR szWriteConverter[];
extern TCHAR szWord97Converter[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\unitspag.h ===
// unitspag.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CUnitsPage dialog

class CUnitsPage : public CCSPropertyPage
{
// Construction
public:
	CUnitsPage();   // standard constructor

// Dialog Data
	//{{AFX_DATA(CUnitsPage)
	enum { IDD = IDD_OPTIONS_UNITS };
	int		m_nUnits;
	BOOL	m_bWordSel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CUnitsPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	static const DWORD m_nHelpIDs[];
	virtual const DWORD* GetHelpIDs() {return m_nHelpIDs;}

	// Generated message map functions
	//{{AFX_MSG(CUnitsPage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\unitspag.cpp ===
// unitspag.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "unitspag.h"
#include "helpids.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CUnitsPage dialog

const DWORD CUnitsPage::m_nHelpIDs[] = 
{
	IDC_BOX, (DWORD) -1,
	IDC_UNITS_IN, IDH_WORDPAD_INCHES,
	IDC_UNITS_CM, IDH_WORDPAD_CENTIMETERS,
	IDC_UNITS_PT, IDH_WORDPAD_POINTS,
	IDC_UNITS_PI, IDH_WORDPAD_PICAS,
	IDC_WORDSEL, IDH_WORDPAD_OPTIONS_AUTOWORDSEL,
 	0, 0
};

CUnitsPage::CUnitsPage() : CCSPropertyPage(CUnitsPage::IDD)
{
	//{{AFX_DATA_INIT(CUnitsPage)
	m_nUnits = -1;
	m_bWordSel = FALSE;
	//}}AFX_DATA_INIT
}


void CUnitsPage::DoDataExchange(CDataExchange* pDX)
{
	CCSPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CUnitsPage)
	DDX_Radio(pDX, IDC_UNITS_IN, m_nUnits);
	DDX_Check(pDX, IDC_WORDSEL, m_bWordSel);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CUnitsPage, CCSPropertyPage)
	//{{AFX_MSG_MAP(CUnitsPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CUnitsPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\strings.cpp ===
// strings.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "strings.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

const TCHAR szWordPadClass[] = _T("WordPadClass");
const TCHAR szLayout1[] = _T("Layout2");
const TCHAR szLayout2[] = _T("LayoutAux2");
const TCHAR szRegKey[] = _T("Microsoft\\Windows\\CurrentVersion\\Applets");

const TCHAR szTextSection[] = _T("Text");
const TCHAR szRTFSection[] = _T("RTF");
const TCHAR szWordSection[] = _T("Word6");
const TCHAR szWriteSection[] =_T("Write");
const TCHAR szIPSection[] = _T("IP");
const TCHAR szWrap[] = _T("Wrap");
const TCHAR szPageMargin[] = _T("PageMargin");

const TCHAR szSection[] = _T("Options");
const TCHAR szWordSel[] = _T("WordSel");
const TCHAR szUnits[] = _T("Units");
const TCHAR szFrameRect[] = _T("FrameRect");
const TCHAR szMaximized[] = _T("Maximized");

const TCHAR szSumInfo[] = _T("\005SummaryInformation");
const TCHAR szContents[] = _T("Contents");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\wordpad.cpp ===
// wordpad.cpp : Defines the class behaviors for the application.
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "wordpad.h"
#include "mainfrm.h"
#include "ipframe.h"
#include "wordpdoc.h"
#include "wordpvw.h"
#include "strings.h"
#include "key.h"
#include "filenewd.h"
#include <locale.h>
#include <winnls.h>
#include <winreg.h>
#include "fixhelp.h"
#include "filedlg.h"

#if _WIN32_IE < 0x400
#undef _WIN32_IE
#define _WIN32_IE   0x0400
#endif
#include <shlobj.h>

#define szRichName    L"RICHED20"
#define szNewRichName L"MSFTEDIT.DLL"

extern BOOL AFXAPI AfxFullPath(LPTSTR lpszPathOut, LPCTSTR lpszFileIn);
static BOOL RegisterHelper(LPCTSTR* rglpszRegister, LPCTSTR* rglpszSymbols,
                           BOOL bReplace);

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CLIPFORMAT cfEmbeddedObject;
CLIPFORMAT cfRTF;
CLIPFORMAT cfRTO;

int CWordPadApp::m_nOpenMsg = RegisterWindowMessage(_T("WordPadOpenMessage"));
int CWordPadApp::m_nPrinterChangedMsg = RegisterWindowMessage(_T("WordPadPrinterChanged"));
int CWordPadApp::m_nOLEHelpMsg = RegisterWindowMessage(SZOLEUI_MSG_HELP);

CUnit CWordPadApp::m_units[] =
{
    //    TPU,  SmallDiv,MedDiv,LargeDiv,MinMove,szAbbrev,         bSpace
    CUnit(1440, 180,     720,   1440,    90,     IDS_INCH1_ABBREV, FALSE),//"
        CUnit(568,  142,     284,   568,     142,    IDS_CM_ABBREV,    TRUE),//cm's
        CUnit(20,   120,     720,   720,     100,    IDS_POINT_ABBREV, TRUE),//points
        CUnit(240,  240,     1440,  1440,    120,    IDS_PICA_ABBREV,  TRUE),//picas
        CUnit(1440, 180,     720,   1440,    90,     IDS_INCH2_ABBREV, FALSE),//in
        CUnit(1440, 180,     720,   1440,    90,     IDS_INCH3_ABBREV, FALSE),//inch
        CUnit(1440, 180,     720,   1440,    90,     IDS_INCH4_ABBREV, FALSE),//inches

        // Non-localized units

        CUnit(1440, 180,     720,   1440,    90,     IDS_INCH1_NOLOC,  FALSE),//"
        CUnit(1440, 180,     720,   1440,    90,     IDS_INCH2_NOLOC,  FALSE),//in
        CUnit(1440, 180,     720,   1440,    90,     IDS_INCH3_NOLOC,  FALSE),//inch
        CUnit(1440, 180,     720,   1440,    90,     IDS_INCH4_NOLOC,  FALSE),//inches
        CUnit(568,  142,     284,   568,     142,    IDS_CM_NOLOC,     TRUE),//cm's
        CUnit(20,   120,     720,   720,     100,    IDS_POINT_NOLOC,  TRUE),//points
        CUnit(240,  240,     1440,  1440,    120,    IDS_PICA_NOLOC,   TRUE)//picas
};

const int CWordPadApp::m_nPrimaryNumUnits = 4;
const int CWordPadApp::m_nNumUnits = sizeof(m_units) / sizeof(m_units[0]);


/////////////////////////////////////////////////////////////////////////////
// CWordPadApp

BEGIN_MESSAGE_MAP(CWordPadApp, CWinApp)
//{{AFX_MSG_MAP(CWordPadApp)
ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
ON_COMMAND(ID_FILE_NEW, OnFileNew)
ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CWordPadCommandLineInfo::ParseParam(const char* pszParam,BOOL bFlag,BOOL bLast)
{
    if (bFlag)
    {
        if (lstrcmpA(pszParam, "t") == 0)
        {
            m_bForceTextMode = TRUE;
            return;
        }
    }
    CCommandLineInfo::ParseParam(pszParam, bFlag, bLast);
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadApp construction

CWordPadApp::CWordPadApp()
      : m_optionsText(0),
        m_optionsRTF(1),
        m_optionsWord(2),
        m_optionsWrite(2),
        m_optionsIP(2),
        m_optionsNull(0),
        m_initialization_phase(InitializationPending),
        m_pInitializationThread(NULL),
        m_always_convert_to_rtf(FALSE)
{
    // _tsetlocale(LC_ALL, _T(""));
    setlocale(LC_ALL, "");     // change made by t-stefb

    DWORD dwVersion = ::GetVersion();
    m_bWin4 = (BYTE)dwVersion >= 4;
#ifndef _UNICODE
    m_bWin31 = (dwVersion > 0x80000000 && !m_bWin4);
#endif
    m_nDefFont = (m_bWin4) ? DEFAULT_GUI_FONT : ANSI_VAR_FONT;
    m_dcScreen.Attach(::GetDC(NULL));
    m_bLargeIcons = m_dcScreen.GetDeviceCaps(LOGPIXELSX) >= 120;
    m_bForceOEM = FALSE;
}

CWordPadApp::~CWordPadApp()
{
    if (m_atomEnableCTF)
        GlobalDeleteAtom(m_atomEnableCTF);
    if (m_atomProcessCTF)
        GlobalDeleteAtom(m_atomProcessCTF);
    
    if (m_dcScreen.m_hDC != NULL)
        ::ReleaseDC(NULL, m_dcScreen.Detach());

    delete m_pInitializationThread;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWordPadApp object

CWordPadApp theApp;

// Register the application's document templates.  Document templates
//  serve as the connection between documents, frame windows and views.
static CSingleDocTemplate DocTemplate(
                                      IDR_MAINFRAME,
                                      RUNTIME_CLASS(CWordPadDoc),
                                      RUNTIME_CLASS(CMainFrame),       // main SDI frame window
                                      RUNTIME_CLASS(CWordPadView));

// This identifier was generated to be statistically unique for your app.
// You may change it if you prefer to choose a specific identifier.
static const CLSID BASED_CODE clsid =
{ 0x73FDDC80L, 0xAEA9, 0x101A, { 0x98, 0xA7, 0x00, 0xAA, 0x00, 0x37, 0x49, 0x59} };

/////////////////////////////////////////////////////////////////////////////
// CWordPadApp initialization


BOOL CWordPadApp::InitInstance()
{
    ParseCommandLine(cmdInfo);

    if (::FindWindow(szWordPadClass, NULL) && IsDocOpen(cmdInfo.m_strFileName))
        return FALSE;

    SetRegistryKey(szRegKey);

    // The resistry stuff shouldn't be localized so just hardcode it

    if (NULL != m_pszProfileName)
        free((void *) m_pszProfileName);

    m_pszProfileName = _tcsdup(TEXT("Wordpad"));

    LoadOptions();

    Enable3dControls();
    if (!cmdInfo.m_bRunEmbedded)
    {
        switch (m_nCmdShow)
        {
        case SW_RESTORE:
        case SW_SHOW:
        case SW_SHOWDEFAULT:
        case SW_SHOWNA:
        case SW_SHOWNOACTIVATE:
        case SW_SHOWNORMAL:
        case SW_SHOWMAXIMIZED:
            if (m_bMaximized)
                m_nCmdShow = SW_SHOWMAXIMIZED;
            break;
        }
    }
    else
    {
        //Excel 4 will start OLE servers minimized
        m_nCmdShow = SW_SHOWNORMAL;
    }
    int nCmdShow = m_nCmdShow;

    LoadAbbrevStrings();

    m_pszHelpFilePath = _tcsdup(WORDPAD_HELP_FILE) ;

    // Initialize OLE libraries
    if (!AfxOleInit())
    {
        AfxMessageBox(IDP_OLE_INIT_FAILED);
        return FALSE;
    }
    RegisterFormats();

    // Initialize RichEdit control
    if (LoadLibrary(szNewRichName) == NULL &&
        LoadLibrary(szRichName) == NULL)
    {
        AfxMessageBox(IDS_RICHED_LOAD_FAIL, MB_OK|MB_ICONEXCLAMATION);
        return FALSE;
    }

    // initialize Cicero process ATOMs
    m_atomEnableCTF  = AddAtom(TF_ENABLE_PROCESS_ATOM);
    m_atomProcessCTF = AddAtom(TF_PROCESS_ATOM);
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    DocTemplate.SetContainerInfo(IDR_CNTR_INPLACE);
    DocTemplate.SetServerInfo(
        IDR_SRVR_EMBEDDED, IDR_SRVR_INPLACE,
        RUNTIME_CLASS(CInPlaceFrame));

    // Connect the COleTemplateServer to the document template.
    //  The COleTemplateServer creates new documents on behalf
    //  of requesting OLE containers by using information
    //  specified in the document template.
    m_server.ConnectTemplate(clsid, &DocTemplate, TRUE);


    //
    // Setup deferred initialization now so the printer can start
    // initializing in case we get a print or printto command at startup
    //

    m_pInitializationThread = AfxBeginThread(
        DoDeferredInitialization,
        this,
        THREAD_PRIORITY_IDLE,
        0,
        CREATE_SUSPENDED);

    if (NULL != m_pInitializationThread)
    {
        m_pInitializationThread->m_bAutoDelete = FALSE;
        m_pInitializationThread->ResumeThread();
    }

    // Check to see if launched as OLE server
    if (cmdInfo.m_bRunEmbedded || cmdInfo.m_bRunAutomated)
    {
        // Register all OLE server (factories) as running.  This enables the
        //  OLE libraries to create objects from other applications.
        COleTemplateServer::RegisterAll();
        AfxOleSetUserCtrl(FALSE);

        // Application was run with /Embedding or /Automation.  Don't show the
        //  main window in this case.
        return TRUE;
    }

    // make sure the main window is showing
    m_bPromptForType = FALSE;
    OnFileNew();
    m_bPromptForType = TRUE;
    m_nCmdShow = -1;
    if (m_pMainWnd == NULL) // i.e. OnFileNew failed
        return FALSE;

    TRY
    {
        if (!cmdInfo.m_strFileName.IsEmpty())  // open an existing document
            m_nCmdShow = nCmdShow;
        // Dispatch commands specified on the command line
        if (cmdInfo.m_nShellCommand != CCommandLineInfo::FileNew &&
            !ProcessShellCommand(cmdInfo))
        {
            return FALSE;
        }
    }
    CATCH(CFileException, e)
    {
        CString error;
        AfxFormatString1(error, AFX_IDP_FAILED_TO_OPEN_DOC, cmdInfo.m_strFileName);
        AfxMessageBox(error, MB_ICONEXCLAMATION, AFX_IDP_FAILED_TO_OPEN_DOC);
        return FALSE;
    }
    END_CATCH

    // Enable File Manager drag/drop open
    m_pMainWnd->DragAcceptFiles();

    //
    // Set the current directory to "My Documents" so that will be the default
    // location for the first save/open
    //

    TCHAR szDefaultPath[MAX_PATH];

    if (SHGetSpecialFolderPath(NULL, szDefaultPath, CSIDL_PERSONAL, FALSE))
        SetCurrentDirectory(szDefaultPath);

    return TRUE;
}

BOOL CWordPadApp::IsDocOpen(LPCTSTR lpszFileName)
{
    if (lpszFileName[0] == NULL)
        return FALSE;
    TCHAR szPath[_MAX_PATH];
    AfxFullPath(szPath, lpszFileName);
    ATOM atom = GlobalAddAtom(szPath);
    ASSERT(atom != NULL);
    if (atom == NULL)
        return FALSE;
    EnumWindows(StaticEnumProc, (LPARAM)&atom);
    if (atom == NULL)
        return TRUE;
    DeleteAtom(atom);
    return FALSE;
}

BOOL CALLBACK CWordPadApp::StaticEnumProc(HWND hWnd, LPARAM lParam)
{
    TCHAR szClassName[30];
    GetClassName(hWnd, szClassName, 30);
    if (lstrcmp(szClassName, szWordPadClass) != 0)
        return TRUE;

    ATOM* pAtom = (ATOM*)lParam;
    ASSERT(pAtom != NULL);
    DWORD_PTR dw = 0;
    ::SendMessageTimeout(hWnd, m_nOpenMsg, NULL, (LPARAM)*pAtom,
        SMTO_ABORTIFHUNG, 500, &dw);
    if (dw)
    {
        ::SetForegroundWindow(hWnd);
        DeleteAtom(*pAtom);
        *pAtom = NULL;
        return FALSE;
    }
    return TRUE;
}

void CWordPadApp::RegisterFormats()
{
    cfEmbeddedObject = (CLIPFORMAT)::RegisterClipboardFormat(_T("Embedded Object"));
    cfRTF = (CLIPFORMAT)::RegisterClipboardFormat(CF_RTF);
    cfRTO = (CLIPFORMAT)::RegisterClipboardFormat(CF_RETEXTOBJ);
}

CDocOptions& CWordPadApp::GetDocOptions(int nDocType)
{
    switch (nDocType)
    {
    case RD_WINWORD6:
    case RD_WORDPAD:
    case RD_WORD97:
        return m_optionsWord;
    case RD_RICHTEXT:
        return m_optionsRTF;
    case RD_TEXT:
    case RD_OEMTEXT:
    case RD_UNICODETEXT:
        return m_optionsText;
    case RD_WRITE:
        return m_optionsWrite;
    case RD_EMBEDDED:
        return m_optionsIP;
    }
    ASSERT(FALSE);
    return m_optionsNull;
}

CDockState& CWordPadApp::GetDockState(int nDocType, BOOL bPrimary)
{
    return GetDocOptions(nDocType).GetDockState(bPrimary);
}

void CWordPadApp::SaveOptions()
{
    WriteProfileInt(szSection, szWordSel, m_bWordSel);
    WriteProfileInt(szSection, szUnits, GetUnits());
    WriteProfileInt(szSection, szMaximized, m_bMaximized);
    WriteProfileBinary(szSection, szFrameRect, (BYTE*)&m_rectInitialFrame,
        sizeof(CRect));
    WriteProfileBinary(szSection, szPageMargin, (BYTE*)&m_rectPageMargin,
        sizeof(CRect));
    m_optionsText.SaveOptions(szTextSection);
    m_optionsRTF.SaveOptions(szRTFSection);
    m_optionsWord.SaveOptions(szWordSection);
    m_optionsWrite.SaveOptions(szWriteSection);
    m_optionsIP.SaveOptions(szIPSection);
    WriteProfileInt(
            szSection,
            TEXT("DefaultFormat"),
            CWordpadFileDialog::GetDefaultFileType());

    if (ShouldAlwaysConvertToRTF())
        WriteProfileInt(szSection, TEXT("AlwaysConvertToRTF"), TRUE);
}

void CWordPadApp::SetUnits(int n)
{
    RIPMSG(n>=0 && n <m_nPrimaryNumUnits, "CWordPadApp::SetUnits - units out of bounds");

    if (n < 0)
    {
        n = 0;
    }

    if (n >= m_nPrimaryNumUnits)
    {
        n = m_nPrimaryNumUnits - 1;
    }

    m_nUnits = n;
}

void CWordPadApp::LoadOptions()
{
    BYTE* pb = NULL;
    UINT nLen = 0;

    HKEY key;
    bool bNewInstall = true;
    if (ERROR_SUCCESS == RegOpenKeyEx(GetAppRegistryKey(), szSection, 0, KEY_READ, &key))
    {
        bNewInstall = false;
        RegCloseKey(key);
    }

    HFONT hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    if (hFont == NULL)
        hFont = (HFONT)GetStockObject(ANSI_VAR_FONT);
    VERIFY(GetObject(hFont, sizeof(LOGFONT), &m_lf));

    m_bWordSel = GetProfileInt(szSection, szWordSel, TRUE);
    TCHAR buf[2];
    buf[0] = NULL;
    GetLocaleInfo(GetUserDefaultLCID(), LOCALE_IMEASURE, buf, 2);
    int nDefUnits = buf[0] == _T('1') ? 0 : 1;
    SetUnits(GetProfileInt(szSection, szUnits, nDefUnits));
    m_bMaximized = GetProfileInt(szSection, szMaximized, (int)FALSE);

    if (GetProfileBinary(szSection, szFrameRect, &pb, &nLen))
    {
        ASSERT(nLen == sizeof(CRect));
        memcpy(&m_rectInitialFrame, pb, sizeof(CRect));
        delete [] pb;
    }
    else
        m_rectInitialFrame.SetRect(0,0,0,0);


    CRect rectScreen(0, 0, GetSystemMetrics(SM_CXSCREEN),
        GetSystemMetrics(SM_CYSCREEN));
    CRect rectInt;
    rectInt.IntersectRect(&rectScreen, &m_rectInitialFrame);
    if (rectInt.Width() < 10 || rectInt.Height() < 10)
        m_rectInitialFrame.SetRect(0, 0, 0, 0);

    if (GetProfileBinary(szSection, szPageMargin, &pb, &nLen))
    {
        ASSERT(nLen == sizeof(CRect));
        memcpy(&m_rectPageMargin, pb, sizeof(CRect));
        delete [] pb;
    }
    else
        m_rectPageMargin.SetRect(1800, 1440, 1800, 1440);

    //
    // Set the default format to RTF for new installs, Word6 (or whatever) was
    // perviously selected for upgrades
    //

    int defformat = RD_NATIVE;

    if (!bNewInstall)
        defformat = _VerifyDefaultFormat(GetProfileInt(szSection,TEXT("DefaultFormat"), RD_WORDPAD), RD_WORDPAD);

    CWordpadFileDialog::SetDefaultFileType(defformat);

    if (GetProfileInt(szSection, TEXT("AlwaysConvertToRTF"), FALSE))
        SetAlwaysConvertToRTF();

    m_nFilterIndex = GetIndexFromType(RD_DEFAULT, TRUE);

    m_optionsText.LoadOptions(szTextSection);
    m_optionsRTF.LoadOptions(szRTFSection);
    m_optionsWord.LoadOptions(szWordSection);
    m_optionsWrite.LoadOptions(szWriteSection);
    m_optionsIP.LoadOptions(szIPSection);
}

void CWordPadApp::LoadAbbrevStrings()
{
    for (int i=0;i<m_nNumUnits;i++)
        m_units[i].m_strAbbrev.LoadString(m_units[i].m_nAbbrevID);
}

BOOL CWordPadApp::ParseMeasurement(LPTSTR buf, int& lVal)
{
    TCHAR* pch;
    if (buf[0] == NULL)
        return FALSE;
    float f = (float)_tcstod(buf,&pch);

    // eat white space, if any
    while (_istspace(*pch))
        pch++;

    if (pch[0] == NULL) // default
    {
        lVal = (f < 0.f) ? (int)(f*GetTPU()-0.5f) : (int)(f*GetTPU()+0.5f);
        return TRUE;
    }
    for (int i=0;i<m_nNumUnits;i++)
    {
        if (lstrcmpi(pch, GetAbbrev(i)) == 0)
        {
            lVal = (f < 0.f) ? (int)(f*GetTPU(i)-0.5f) : (int)(f*GetTPU(i)+0.5f);
            return TRUE;
        }
    }
    return FALSE;
}

void CWordPadApp::PrintTwips(WCHAR* buf, int cchBuf, int nValue, int nDec)
{
    ASSERT(nDec == 2);
    int div = GetTPU();
    int lval = nValue;
    BOOL bNeg = FALSE;

    int* pVal = (int *) alloca((nDec + 1) * sizeof(int));

    if (lval < 0)
    {
        bNeg = TRUE;
        lval = -lval;
    }

    for (int i=0;i<=nDec;i++)
    {
        pVal[i] = lval/div; //integer number
        lval -= pVal[i]*div;
        lval *= 10;
    }
    i--;
    if (lval >= div/2)
        pVal[i]++;

    while ((pVal[i] == 10) && (i != 0))
    {
        pVal[i] = 0;
        pVal[--i]++;
    }

    while (nDec && pVal[nDec] == 0)
        nDec--;

    StringCchPrintf(buf, cchBuf, L"%.*f", nDec, (float)nValue/(float)div);

    if (m_units[m_nUnits].m_bSpaceAbbrev)
        StringCchCat(buf, cchBuf, L" ");
    StringCchCat(buf, cchBuf, GetAbbrev());
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadApp commands

void CWordPadApp::OnAppAbout()
{
    CString strTitle;
    VERIFY(strTitle.LoadString(AFX_IDS_APP_TITLE));
    ShellAbout(m_pMainWnd->GetSafeHwnd(), strTitle, _T(""), LoadIcon(IDR_MAINFRAME));
}

int CWordPadApp::ExitInstance()
{
    FreeLibrary(GetModuleHandle(szRichName));

    HMODULE hMod = GetModuleHandle(szNewRichName);
    if (hMod)
        FreeLibrary(hMod);

    SaveOptions();

    return CWinApp::ExitInstance();
}

void CWordPadApp::OnFileNew()
{
    int nDocType = -1;
    if (!m_bPromptForType)
    {
        if (cmdInfo.m_bForceTextMode)
            nDocType = RD_TEXT;
        else if (!cmdInfo.m_strFileName.IsEmpty())
        {
            CFileException fe;
            nDocType = GetDocTypeFromName(cmdInfo.m_strFileName, fe);
            if (DocTypeDisabled(nDocType))
            {
                nDocType = RD_DEFAULT;
            }
        }
        if (nDocType == -1)
            nDocType = RD_DEFAULT;
    }
    else
    {
        CFileNewDialog dlg;
        if (dlg.DoModal() == IDCANCEL)
            return;

        nDocType = (dlg.m_nSel == 1) ? RD_TEXT :
                   (dlg.m_nSel == 2) ? RD_UNICODETEXT :
                   RD_RICHTEXT;

        if (nDocType != RD_TEXT)
            cmdInfo.m_bForceTextMode = FALSE;
    }
    m_nNewDocType = nDocType;
    DocTemplate.OpenDocumentFile(NULL);
    // if returns NULL, the user has already been alerted
}

// prompt for file name - used for open and save as
// static function called from app
BOOL CWordPadApp::PromptForFileName(CString& fileName, UINT nIDSTitle,
                                    DWORD dwFlags, BOOL bOpenFileDialog, int* pType)
{
    ScanForConverters();
    CWordpadFileDialog dlgFile(bOpenFileDialog);
    CString title;

    VERIFY(title.LoadString(nIDSTitle));

    dlgFile.m_ofn.Flags |= dwFlags;

    int nIndex = m_nFilterIndex;
    if (!bOpenFileDialog)
    {
        int nDocType = (pType != NULL) ? *pType : RD_DEFAULT;
        nIndex = GetIndexFromType(nDocType, bOpenFileDialog);
        if (nIndex == -1)
            nIndex = GetIndexFromType(RD_DEFAULT, bOpenFileDialog);
        if (nIndex == -1)
            nIndex = GetIndexFromType(RD_NATIVE, bOpenFileDialog);
        ASSERT(nIndex != -1);
        nIndex++;
    }
    dlgFile.m_ofn.nFilterIndex = nIndex;
    // strDefExt is necessary to hold onto the memory from GetExtFromType
    CString strDefExt = GetExtFromType(GetTypeFromIndex(nIndex-1, bOpenFileDialog));

    //
    // The open file dialog doesn't want the extension to start with '.' but
    // thats how GetExtFromType gives it to us.
    //

    dlgFile.m_ofn.lpstrDefExt = strDefExt;
    ASSERT(TEXT('.') == *dlgFile.m_ofn.lpstrDefExt);
    ++dlgFile.m_ofn.lpstrDefExt;

    CString strFilter = GetFileTypes(bOpenFileDialog);
    dlgFile.m_ofn.lpstrFilter = strFilter;
    dlgFile.m_ofn.lpstrTitle = title;
    dlgFile.m_ofn.lpstrFile = fileName.GetBuffer(_MAX_PATH);

    BOOL bRet;
    int  namelen;

    do
    {
        bRet = (dlgFile.DoModal() == IDOK) ? TRUE : FALSE;

        if (!bRet)
            break;

        // The converters only speak ansi so make sure the filename isn't to
        // long for DBCS.
        namelen = WideCharToMultiByte(CP_ACP, 0, fileName, -1, NULL, 0,NULL,NULL);

        if (namelen > MAX_PATH - 2)
        {
            CString   message;
            AfxFormatString1(message, IDS_FILENAME_TO_LONG, fileName);
            AfxMessageBox(message);
        }
    }
    while (namelen > MAX_PATH - 2);

    fileName.ReleaseBuffer();
    if (bRet)
    {
        if (bOpenFileDialog)
            m_nFilterIndex = dlgFile.m_ofn.nFilterIndex;
        if (pType != NULL)
        {
            int nIndex = (int)dlgFile.m_ofn.nFilterIndex - 1;
            ASSERT(nIndex >= 0);
            *pType = GetTypeFromIndex(nIndex, bOpenFileDialog);
        }
    }
    return bRet;
}

void CWordPadApp::OnFileOpen()
{
    // prompt the user (with all document templates)
    CString newName;
    int nType = RD_DEFAULT;
    if (!PromptForFileName(newName, AFX_IDS_OPENFILE,
        OFN_HIDEREADONLY | OFN_FILEMUSTEXIST, TRUE, &nType))
        return; // open cancelled

    if (nType == RD_OEMTEXT)
        m_bForceOEM = TRUE;
    OpenDocumentFile(newName);
    m_bForceOEM = FALSE;
    // if returns NULL, the user has already been alerted
}

BOOL CWordPadApp::OnDDECommand(LPTSTR /*lpszCommand*/)
{
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// DDE and ShellExecute support

//HKEY_CLASSES_ROOT\.RTF = rtffile
//HKEY_CLASSES_ROOT\rtffile =
//HKEY_CLASSES_ROOT\rtffile\CLSID = {73FDDC80-AEA9-101A-98A7-00AA00374959}
//HKEY_CLASSES_ROOT\rtffile\protocol\StdFileEditing\server = WORDPAD.EXE
//HKEY_CLASSES_ROOT\rtffile\protocol\StdFileEditing\verb\0 = &Edit
//HKEY_CLASSES_ROOT\rtffile\shell\open\command = WORDPAD.EXE %1
//HKEY_CLASSES_ROOT\rtffile\shell\print\command = WORDPAD.EXE /p %1

#define REGENTRY(key, value) _T(key) _T("\0\0") _T(value)
#define REGENTRYX(key, valuename, value) _T(key) _T("\0") _T(valuename) _T("\0") _T(value)

static const TCHAR sz00[] = REGENTRY("%2", "%5");
static const TCHAR sz01[] = REGENTRY("%2\\CLSID", "%1");
static const TCHAR sz02[] = REGENTRY("%2\\Insertable", "");
static const TCHAR sz03[] = REGENTRY("%2\\protocol\\StdFileEditing\\verb\\0", "&Edit");
static const TCHAR sz04[] = REGENTRY("%2\\protocol\\StdFileEditing\\server", "%3");
static const TCHAR sz05[] = REGENTRY("CLSID\\%1", "%5");
static const TCHAR sz06[] = REGENTRY("CLSID\\%1\\ProgID", "%2");
static const TCHAR sz07[] = REGENTRY("CLSID\\%1\\InprocHandler32", "ole32.dll");
static const TCHAR sz08[] = REGENTRY("CLSID\\%1\\LocalServer32", "%3");
static const TCHAR sz09[] = REGENTRY("CLSID\\%1\\Verb\\0", "&Edit,0,2");
static const TCHAR sz10[] = REGENTRY("CLSID\\%1\\Verb\\1", "&Open,0,2");
static const TCHAR sz11[] = REGENTRY("CLSID\\%1\\Insertable", "");
static const TCHAR sz12[] = REGENTRY("CLSID\\%1\\AuxUserType\\2", "%4");
static const TCHAR sz13[] = REGENTRY("CLSID\\%1\\AuxUserType\\3", "%6");
static const TCHAR sz14[] = REGENTRY("CLSID\\%1\\DefaultIcon", "%3,1");
static const TCHAR sz15[] = REGENTRY("CLSID\\%1\\MiscStatus", "0");
static const TCHAR sz16[] = REGENTRY("%2\\shell\\open\\command", "%3 \"%%1\"");
static const TCHAR sz17[] = REGENTRY("%2\\shell\\print\\command", "%3 /p \"%%1\"");
static const TCHAR sz18[] = REGENTRY("%7", "%2");
static const TCHAR sz19[] = REGENTRY("%2", ""); // like sz00 only no long type name
static const TCHAR sz20[] = REGENTRY("%2\\shell\\printto\\command", "%3 /pt \"%%1\" \"%%2\" \"%%3\" \"%%4\"");
static const TCHAR sz21[] = REGENTRY("%2\\DefaultIcon", "%3,%8");
static const TCHAR sz22[] = REGENTRYX("%7\\ShellNew", "NullFile", "true");
static const TCHAR sz23[] = REGENTRYX("%7\\ShellNew", "Data", "{\\rtf1}");

// %1 - class ID
// %2 - class name            WordPad.Document.1
// %3 - SFN executable path      C:\PROGRA~1\ACCESS~1\WORDPAD.EXE
// %4 - short type name       Document
// %5 - long type name        Microsoft WordPad Document
// %6 - long application name Microsoft WordPad
// %7 = extension          .rtf
// %8 = default icon       0,1,2,3
#define NUM_REG_ARGS 8

static const LPCTSTR rglpszWordPadRegister[] =
{sz00, sz02, sz03, sz05, sz09, sz10, sz11, sz15, NULL};

static const LPCTSTR rglpszWordPadOverwrite[] =
{sz01, sz04, sz06, sz07, sz08, sz12, sz13, sz14, sz16, sz17, sz20, NULL};

//static const LPCTSTR rglpszExtRegister[] =
//{sz00, sz18, NULL};

//static const LPCTSTR rglpszExtOverwrite[] =
//{sz01, sz16, sz17, sz21, NULL};

static const LPCTSTR rglpszWriExtRegister[] =
{sz18, NULL};
static const LPCTSTR rglpszWriRegister[] =
{sz00, sz01, sz16, sz17, sz20, sz21, NULL};

static const LPCTSTR rglpszRtfExtRegister[] =
{sz18, sz23, NULL};
static const LPCTSTR rglpszRtfRegister[] =
{sz00, sz01, sz16, sz17, sz20, sz21, NULL};

static const LPCTSTR rglpszTxtExtRegister[] =
{sz18, sz22, NULL};
static const LPCTSTR rglpszTxtRegister[] =
{sz00, sz01, sz16, sz17, sz20, sz21, NULL};

static const LPCTSTR rglpszDocExtRegister[] =
{sz18, sz22, NULL};
static const LPCTSTR rglpszDocRegister[] =
{sz00, sz01, sz16, sz17, sz20, sz21, NULL};

static void RegisterExt(LPCTSTR lpszExt, LPCTSTR lpszProgID, UINT nIDTypeName,
                        LPCTSTR* rglpszSymbols, LPCTSTR* rglpszExtRegister,
                        LPCTSTR* rglpszRegister, int nIcon)
{
    // don't overwrite anything with the extensions
    CString strWhole;
    VERIFY(strWhole.LoadString(nIDTypeName));
    CString str;
    AfxExtractSubString(str, strWhole, DOCTYPE_PROGID);

    rglpszSymbols[1] = lpszProgID;
    rglpszSymbols[4] = str;
    rglpszSymbols[6] = lpszExt;
    WCHAR buf[12];
    EVAL(SUCCEEDED(StringCchPrintf(buf, ARRAYSIZE(buf), L"%d", nIcon))); // Can never fail
    rglpszSymbols[7] = buf;
    // check for .ext and progid
    CKey key;
    if (!key.Open(HKEY_CLASSES_ROOT, lpszExt, KEY_READ)) // .ext doesn't exist
        RegisterHelper(rglpszExtRegister, rglpszSymbols, TRUE);
    key.Close();
    if (!key.Open(HKEY_CLASSES_ROOT, lpszProgID, KEY_READ)) // ProgID doesn't exist (i.e. txtfile)
        RegisterHelper(rglpszRegister, rglpszSymbols, TRUE);
}

void CWordPadApp::UpdateRegistry()
{
    // If stuff is already initialized, don't overwrite it

    HKEY rtfkey;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT(".rtf"), 0, KEY_READ, &rtfkey))
    {
        // .rtf is already registered, assume the rest are as well
        RegCloseKey(rtfkey);
        return;
    }

    USES_CONVERSION;
    LPOLESTR lpszClassID = NULL;
    CDocTemplate* pDocTemplate = &DocTemplate;

    // get registration info from doc template string
    CString strServerName;
    CString strLocalServerName;
    CString strLocalShortName;

    if (!pDocTemplate->GetDocString(strServerName,
        CDocTemplate::regFileTypeId) || strServerName.IsEmpty())
    {
        TRACE0("Error: not enough information in DocTemplate to register OLE server.\n");
        return;
    }
    if (!pDocTemplate->GetDocString(strLocalServerName,
        CDocTemplate::regFileTypeName))
        strLocalServerName = strServerName;     // use non-localized name
    if (!pDocTemplate->GetDocString(strLocalShortName,
        CDocTemplate::fileNewName))
        strLocalShortName = strLocalServerName; // use long name

    ASSERT(strServerName.Find(' ') == -1);  // no spaces allowed

    ::StringFromCLSID(clsid, &lpszClassID);
    ASSERT (lpszClassID != NULL);

    // get path name to server
    TCHAR szLongPathName[_MAX_PATH];
    TCHAR szShortPathName[_MAX_PATH];
    ::GetModuleFileName(AfxGetInstanceHandle(), szLongPathName, _MAX_PATH);
    ::GetShortPathName(szLongPathName, szShortPathName, _MAX_PATH);

    LPCTSTR rglpszSymbols[NUM_REG_ARGS];
    rglpszSymbols[0] = OLE2CT(lpszClassID);
    rglpszSymbols[1] = strServerName;
    rglpszSymbols[2] = szShortPathName;
    rglpszSymbols[3] = strLocalShortName;
    rglpszSymbols[4] = strLocalServerName;
    rglpszSymbols[5] = m_pszAppName; // will usually be long, readable name
    rglpszSymbols[6] = NULL;

    if (RegisterHelper((LPCTSTR*)rglpszWordPadRegister, rglpszSymbols, FALSE))
        RegisterHelper((LPCTSTR*)rglpszWordPadOverwrite, rglpszSymbols, TRUE);

    // RegisterExt(_T(".txt"), _T("txtfile"), IDS_TEXT_DOC, rglpszSymbols,
    //    (LPCTSTR*)rglpszTxtExtRegister, (LPCTSTR*)rglpszTxtRegister, 3);
    RegisterExt(_T(".rtf"), _T("rtffile"), IDS_RICHTEXT_DOC, rglpszSymbols,
        (LPCTSTR*)rglpszRtfExtRegister, (LPCTSTR*)rglpszRtfRegister, 1);
    RegisterExt(_T(".wri"), _T("wrifile"), IDS_WRITE_DOC, rglpszSymbols,
        (LPCTSTR*)rglpszWriExtRegister, (LPCTSTR*)rglpszWriRegister, 2);
    RegisterExt(_T(".doc"), _T("WordPad.Document.1"), IDS_WINWORD6_DOC, rglpszSymbols,
        (LPCTSTR*)rglpszDocExtRegister, (LPCTSTR*)rglpszDocRegister, 1);

    // free memory for class ID
    ASSERT(lpszClassID != NULL);
    CoTaskMemFree(lpszClassID);
}

BOOL RegisterHelper(LPCTSTR* rglpszRegister, LPCTSTR* rglpszSymbols,
                    BOOL bReplace)
{
    ASSERT(rglpszRegister != NULL);
    ASSERT(rglpszSymbols != NULL);

    WCHAR szKey[256];
    WCHAR szValue[256];
    LPCTSTR pszValueName;

    BOOL bResult = TRUE;
    while (*rglpszRegister != NULL)
    {
        LPCTSTR lpszKey = *rglpszRegister++;
        if (*lpszKey == '\0')
            continue;

        LPCTSTR lpszValueName = lpszKey + lstrlen(lpszKey) + 1;
        LPCTSTR lpszValue = lpszValueName + lstrlen(lpszValueName) + 1;

        DWORD dwRes;

        // lpszKey is a safe format string - see REGENTRY
        dwRes = FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                              lpszKey, NULL,   NULL, szKey, ARRAYSIZE(szKey), (va_list*)rglpszSymbols);

        if (dwRes == 0)
            continue;
        
        pszValueName = lpszValueName;
        
        // lpszValue is safe format string - see REGENTRY
        dwRes = FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                              lpszValue, NULL, NULL, szValue, ARRAYSIZE(szValue), (va_list*)rglpszSymbols);

        if (dwRes == 0)
            continue;

        if (!szKey[0])
        {
            TRACE1("Warning: skipping empty key '%s'.\n", lpszKey);
            continue;
        }

        CKey key;
        VERIFY(key.Create(HKEY_CLASSES_ROOT, szKey, KEY_ALL_ACCESS));
        if (!bReplace)
        {
            CString str;
            if (key.GetStringValue(str, pszValueName) && !str.IsEmpty())
                continue;
        }

        if (!key.SetStringValue(szValue, pszValueName))
        {
            TRACE2("Error: failed setting key '%s' to value '%s'.\n", szKey, szValue);
            bResult = FALSE;
            break;
        }
    }

    return bResult;
}

void CWordPadApp::WinHelp(DWORD dwData, UINT nCmd)
{
    if (g_fDisableStandardHelp)
    {
        return ;
    }

    if ( (nCmd == HELP_FINDER) || (nCmd == HELP_CONTENTS) || (nCmd == HELP_INDEX) )
    {
        ::HtmlHelpA( ::GetDesktopWindow(), "wordpad.chm", HH_DISPLAY_TOPIC, 0L );   
        return;
    }
    CWinApp::WinHelp(dwData, nCmd);
}

BOOL CWordPadApp::PreTranslateMessage(MSG* pMsg)
{
    if (pMsg->message == WM_PAINT)
        return FALSE;
    // CWinApp::PreTranslateMessage does nothing but call base
    return CWinThread::PreTranslateMessage(pMsg);
}

void CWordPadApp::NotifyPrinterChanged(BOOL bUpdatePrinterSelection)
{
    if (bUpdatePrinterSelection)
        UpdatePrinterSelection(TRUE);

    POSITION pos = m_listPrinterNotify.GetHeadPosition();
    while (pos != NULL)
    {
        HWND hWnd = m_listPrinterNotify.GetNext(pos);
        ::SendMessage(hWnd, m_nPrinterChangedMsg, 0, 0);
    }
}

BOOL CWordPadApp::IsIdleMessage(MSG* pMsg)
{
    if (pMsg->message == WM_MOUSEMOVE || pMsg->message == WM_NCMOUSEMOVE)
        return FALSE;
    return CWinApp::IsIdleMessage(pMsg);
}

#define DN_PADDINGCHARS 16

HGLOBAL CWordPadApp::CreateDevNames()
{
    HGLOBAL hDev = NULL;
    CString strDriverName;
    CString strPrinterName;
    CString strPortName;

    if (!cmdInfo.m_strPrinterName.IsEmpty())
    {
        strDriverName = cmdInfo.m_strDriverName;
        strPrinterName = cmdInfo.m_strPrinterName;
        strPortName = cmdInfo.m_strPortName;
    }
    else
    {
        PRINTDLG    printdlg;
        DEVNAMES   *devnames;

        if (!GetPrinterDeviceDefaults(&printdlg))
            return NULL;

        devnames = (DEVNAMES *) ::GlobalLock(printdlg.hDevNames);
        if (NULL == devnames)
            return NULL;

        strDriverName = (LPTSTR) ((BYTE *) devnames) + devnames->wDriverOffset;
        strPrinterName = (LPTSTR) ((BYTE *) devnames) + devnames->wDeviceOffset;
        strPortName = (LPTSTR) ((BYTE *) devnames) + devnames->wOutputOffset;

        ::GlobalUnlock(printdlg.hDevNames);
    }

    DWORD cbDevNames ;

    int cchDriverName = strDriverName.GetLength() + 1;
    int cchPrinterName = strPrinterName.GetLength() + 1;
    int cchPortName = strPortName.GetLength() + 1;

    cbDevNames = cchDriverName + cchPrinterName + cchPortName + DN_PADDINGCHARS ;

    cbDevNames *= sizeof(TCHAR) ;
    cbDevNames += sizeof(DEVNAMES) ;

    hDev = GlobalAlloc(GPTR, cbDevNames) ;

    if (NULL == hDev)
        return NULL;

    LPDEVNAMES lpDev = (LPDEVNAMES)GlobalLock(hDev) ;

    // Sufficient memory was allocated for these strcpy's above.
    lpDev->wDriverOffset = sizeof(DEVNAMES) / sizeof(TCHAR) ;
    StringCchCopy((LPTSTR) lpDev + lpDev->wDriverOffset, cchDriverName, strDriverName) ;

    lpDev->wDeviceOffset = (WORD) (lpDev->wDriverOffset
        + strDriverName.GetLength() + 1);
    StringCchCopy((LPTSTR) lpDev + lpDev->wDeviceOffset, cchPrinterName, strPrinterName) ;

    lpDev->wOutputOffset = (WORD) (lpDev->wDeviceOffset
        + strPrinterName.GetLength() + 1);
    StringCchCopy((LPTSTR) lpDev + lpDev->wOutputOffset, cchPortName, strPortName) ;

    lpDev->wDefault = 0;

    return hDev;
}

//+---------------------------------------------------------------------------
//
//  Method:     CWordPadApp::DoDeferredInitialization, static
//
//  Synopsis:   Thread entry point for low priority initialization
//
//  Parameters: [pvWordPadApp]          -- Pointer to to CWordPadApp
//
//  Returns:    Thread exit code
//
//---------------------------------------------------------------------------

UINT AFX_CDECL CWordPadApp::DoDeferredInitialization(LPVOID pvWordPadApp)
{
    ASSERT(NULL != pvWordPadApp);


    CWordPadApp *pWordPadApp = (CWordPadApp *) pvWordPadApp;

    pWordPadApp->m_initialization_phase = InitializingPrinter;
    pWordPadApp->m_hDevNames = pWordPadApp->CreateDevNames();

    pWordPadApp->m_initialization_phase = UpdatingPrinterRelatedUI;
    pWordPadApp->NotifyPrinterChanged( ((pWordPadApp->m_hDevNames) == NULL) );

    pWordPadApp->m_initialization_phase = UpdatingRegistry;
    pWordPadApp->UpdateRegistry();

    pWordPadApp->m_initialization_phase = InitializationComplete;

    return 0;
}

//+--------------------------------------------------------------------------
//
//  Method:     CWordPadApp::EnsurePrinterIsInitialized
//
//  Synopsis:   Make sure the printer is done initializing
//
//  Parameters: None
//
//  Returns:    void
//
//  Notes:      We'll only wait two minutes.  If the printer takes that long
//              to initialize printing probably is going to be flakey anyway.
//
//              The main purpose of doing printer initialization on a different
//              thread is so that it doesn't get in the way of doing real work.
//              On the other hand if printing is the real work we should try to
//              get things moving so bump it up from idle priority.
//
//---------------------------------------------------------------------------

void CWordPadApp::EnsurePrinterIsInitialized()
{
    int     nWaits = 0;
    BOOL    bBumpedPriority = FALSE;

    if (NULL == m_pInitializationThread)
    {
        ASSERT(NULL != m_pInitializationThread);
        bBumpedPriority = TRUE;
    }

    while (m_initialization_phase <= InitializingPrinter && nWaits < 1200)
    {
        if (!bBumpedPriority)
        {
            m_pInitializationThread->SetThreadPriority(
                THREAD_PRIORITY_ABOVE_NORMAL);
            bBumpedPriority = TRUE;
        }

        Sleep(100);
        ++nWaits;
    }

    if (bBumpedPriority)
        m_pInitializationThread->SetThreadPriority(THREAD_PRIORITY_IDLE);
}


// Free with delete []
LPSTR WideToAnsiNewArray(LPCWSTR pwsz)
{
    LPSTR psz = NULL;
    int cbBuf = WideCharToMultiByte(CP_ACP, 0, pwsz, -1, NULL, 0, NULL, NULL);
    if (cbBuf)
    {
        psz = new char[cbBuf];
        if (psz)
        {
            cbBuf = WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz, cbBuf, NULL, NULL);

            if (!cbBuf)
            {
                // Conversion failed?
                delete [] psz;
                psz = NULL;
            }
        }
    }
    return psz;
}

// Free with delete []
LPWSTR AnsiToWideNewArray(LPCSTR psz)
{
    LPWSTR pwsz = NULL;
    int cchBuf = MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (cchBuf)
    {
        pwsz = new WCHAR[cchBuf];
        if (pwsz)
        {
            cchBuf = MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, cchBuf);

            if (!cchBuf)
            {
                // Conversion failed?
                delete [] pwsz;
                pwsz = NULL;
            }
        }
    }
    return pwsz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\winctrl2.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "stdafx2.h"

#ifdef AFX_CMNCTL_SEG
#pragma code_seg(AFX_CMNCTL_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CRichEdit

CRichEdit2Ctrl::~CRichEdit2Ctrl()
{
	DestroyWindow();
}


#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

IMPLEMENT_DYNAMIC(CRichEdit2Ctrl, CWnd)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\viewrich.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "stdafx2.h"
#include "wordpad.h"

// See Win98 HACKHACK below
#ifdef _CHICAGO_
#include <initguid.h>
#include <tom.h>
#pragma comment (lib, "oleaut32.lib")
#endif // _CHICAGO_

// Hack multimon to work with NT4 headers but NT5 libs
#if _WIN32_WINNT < 0x0500
#include <multimon.h>
#undef GetSystemMetrics
#undef MonitorFromWindow
#undef MonitorFromRect
#undef MonitorFromPoint
#undef GetMonitorInfo
#undef EnumDisplayMonitors
#undef EnumDisplayDevices
extern "C"
{
WINUSERAPI
HMONITOR
WINAPI
MonitorFromWindow( IN HWND hwnd, IN DWORD dwFlags);
WINUSERAPI BOOL WINAPI GetMonitorInfoA( IN HMONITOR hMonitor, OUT LPMONITORINFO lpmi);
WINUSERAPI BOOL WINAPI GetMonitorInfoW( IN HMONITOR hMonitor, OUT LPMONITORINFO lpmi);
#ifdef UNICODE
#define GetMonitorInfo  GetMonitorInfoW
#else
#define GetMonitorInfo  GetMonitorInfoA
#endif // !UNICODE
}
#endif

#ifdef AFX_CORE4_SEG
#pragma code_seg(AFX_CORE4_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CRe2Object

class CRe2Object : public _reobject
{
public:
    CRe2Object();
    CRe2Object(CRichEdit2CntrItem* pItem);
    ~CRe2Object();
};

CRe2Object::CRe2Object()
{
    cbStruct = sizeof(REOBJECT);
    poleobj = NULL;
    pstg = NULL;
    polesite = NULL;
}

CRe2Object::CRe2Object(CRichEdit2CntrItem* pItem)
{
    ASSERT(pItem != NULL);
    cbStruct = sizeof(REOBJECT);

    pItem->GetClassID(&clsid);
    poleobj = pItem->m_lpObject;
    pstg = pItem->m_lpStorage;
    polesite = pItem->m_lpClientSite;
    ASSERT(poleobj != NULL);
    ASSERT(pstg != NULL);
    ASSERT(polesite != NULL);
    poleobj->AddRef();
    pstg->AddRef();
    polesite->AddRef();

    sizel.cx = sizel.cy = 0; // let richedit determine initial size
    dvaspect = pItem->GetDrawAspect();
    dwFlags = REO_RESIZABLE;
    dwUser = 0;
}

CRe2Object::~CRe2Object()
{
    if (poleobj != NULL)
        poleobj->Release();
    if (pstg != NULL)
        pstg->Release();
    if (polesite != NULL)
        polesite->Release();
}


//+-------------------------------------------------------------------------
//
//  HACKHACK:
//
//  The Richedit2 control is Unicode internally so it needs to convert
//  strings from Ansi to Unicode when it recieves a EM_FINDTEXTEX message.
//  Unfortunately it seems to set the code page for the conversion based
//  on the current keyboard layout.  This breaks in the following scenario:
//
//  Start Wordpad on FE Win98 and type some DBCS chars.  Pull up the find
//  dialog and enter one of the DBCS chars that you typed before.  Set the
//  keyboard layout to US and try to find the character - it will fail.
//  Now set it to non-US and try the find - it will work.
//
//  The hack is to do the conversion ourselves using the system default
//  codepage and then do the find using the TOM interfaces.
//
//  Richedit3 is supposed to be smarter about this whole issue and hopefully
//  this hack can be removed then.
//
//--------------------------------------------------------------------------

#ifdef _CHICAGO_
long CRichEdit2Ctrl::FindText(DWORD dwFlags, FINDTEXTEX* pFindText) const
{
    long            index = -1;
    ITextRange     *range = NULL;
    HRESULT         hr = S_OK;
    UINT            cchFind = _tcslen(pFindText->lpstrText) + 1;
    LPWSTR          lpwszFind = NULL;
    long            length;

    //
    // Get the base richedit ole interface
    //

    IUnknown *unk = GetIRichEditOle();

    if (NULL == unk)
        hr = E_NOINTERFACE;

    //
    // Get a range object
    //

    if (S_OK == hr)
    {
        ITextDocument *doc;

        hr = unk->QueryInterface(IID_ITextDocument, (void **) &doc);

        if (S_OK == hr)
        {
            hr = doc->Range(
                        pFindText->chrg.cpMin,
                        pFindText->chrg.cpMax,
                        &range);

            doc->Release();
        }

        unk->Release();
    }

    //
    // Convert the text-to-find to Unicode using the system default code page
    //

    if (S_OK == hr)
    {
        try
        {
             lpwszFind = (LPWSTR) alloca(cchFind * sizeof(WCHAR));
        }
        catch (...)
        {
            _resetstkoflw();
            hr = E_OUTOFMEMORY; // alloca failed
        }

        if (S_OK == hr)
        {
            int error = MultiByteToWideChar(
                                CP_ACP,
                                MB_ERR_INVALID_CHARS,
                                pFindText->lpstrText,
                                -1,
                                lpwszFind,
                                cchFind);

            if (0 != error)
                lpwszFind = SysAllocString(lpwszFind);
            else
                hr = E_FAIL;

            if (S_OK == hr && NULL == lpwszFind)
                hr = E_OUTOFMEMORY;
        }
    }

    //
    // Try to find the text
    //

    if (S_OK == hr)
    {
        long flags = 0;

        flags |= (dwFlags & FR_MATCHCASE) ? tomMatchCase : 0;
        flags |= (dwFlags & FR_WHOLEWORD) ? tomMatchWord : 0;

        hr = range->FindText((BSTR) lpwszFind, 0, flags, &length);

        SysFreeString(lpwszFind);

        if (S_OK == hr)
        {
            hr = range->GetIndex(tomCharacter, &index);

            if (S_OK == hr)
            {
                // GetIndex returns 1-based indices, EM_FINDTEXTEX returns
                // 0-based indices.

                --index;
                pFindText->chrgText.cpMin = index;
                pFindText->chrgText.cpMax = index + length;
            }
        }
    }

    if (NULL != range)
        range->Release();

    //
    // If all else fails, fall back to EM_FINDTEXTEX
    //

    if (S_OK != hr)
        index = (long)::SendMessage(
                            m_hWnd,
                            EM_FINDTEXTEX,
                            dwFlags,
                            (LPARAM)pFindText);

    return index;
}
#endif // _CHICAGO



/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View

static const UINT nMsgFindReplace = ::RegisterWindowMessage(FINDMSGSTRING);

BEGIN_MESSAGE_MAP(CRichEdit2View, CCtrlView)
    //{{AFX_MSG_MAP(CRichEdit2View)
    ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateNeedSel)
    ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateNeedClip)
    ON_UPDATE_COMMAND_UI(ID_EDIT_FIND, OnUpdateNeedText)
    ON_UPDATE_COMMAND_UI(ID_EDIT_REPEAT, OnUpdateNeedFind)
    ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
    ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_SPECIAL, OnUpdateEditPasteSpecial)
    ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_PROPERTIES, OnUpdateEditProperties)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateNeedSel)
    ON_UPDATE_COMMAND_UI(ID_EDIT_CLEAR, OnUpdateNeedSel)
    ON_UPDATE_COMMAND_UI(ID_EDIT_SELECT_ALL, OnUpdateNeedText)
    ON_UPDATE_COMMAND_UI(ID_EDIT_REPLACE, OnUpdateNeedText)
    ON_COMMAND(ID_EDIT_CUT, OnEditCut)
    ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
    ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
    ON_COMMAND(ID_EDIT_CLEAR, OnEditClear)
    ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
    ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectAll)
    ON_COMMAND(ID_EDIT_FIND, OnEditFind)
    ON_COMMAND(ID_EDIT_REPLACE, OnEditReplace)
    ON_COMMAND(ID_EDIT_REPEAT, OnEditRepeat)
    ON_COMMAND(ID_EDIT_PASTE_SPECIAL, OnEditPasteSpecial)
    ON_COMMAND(ID_OLE_EDIT_PROPERTIES, OnEditProperties)
    ON_COMMAND(ID_OLE_INSERT_NEW, OnInsertObject)
    ON_COMMAND(ID_FORMAT_FONT, OnFormatFont)
    ON_WM_SIZE()
    ON_WM_CREATE()
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
    ON_NOTIFY_REFLECT(EN_SELCHANGE, OnSelChange)
    ON_REGISTERED_MESSAGE(nMsgFindReplace, OnFindReplaceCmd)
END_MESSAGE_MAP()

// richedit buffer limit -- let's set it at 16M
AFX_DATADEF ULONG CRichEdit2View::lMaxSize = 0xffffff;

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View construction/destruction

CRichEdit2View::CRichEdit2View() : CCtrlView(MSFTEDIT_CLASS, AFX_WS_DEFAULT_VIEW |
    WS_HSCROLL | WS_VSCROLL | ES_AUTOHSCROLL | ES_AUTOVSCROLL |
    ES_MULTILINE | ES_NOHIDESEL | ES_SAVESEL | ES_SELECTIONBAR)
{
    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
    m_lpRichEditOle = NULL;
    m_nBulletIndent = 720; // 1/2 inch
    m_nWordWrap = WrapToWindow;
    m_nPasteType = 0;
    SetPaperSize(CSize(8*1440+720, 11*1440));
    SetMargins(CRect(0,0,0,0));
    m_charformat.cbSize = sizeof(CHARFORMAT);
    m_paraformat.cbSize = sizeof(PARAFORMAT);
}

BOOL CRichEdit2View::PreCreateWindow(CREATESTRUCT& cs)
{
    _AFX_RICHEDIT2_STATE* pState = AfxGetRichEdit2State();
    BOOL bRet = TRUE;
    if (pState->m_hInstRichEdit == NULL)
    {
        bRet = FALSE;
        pState->m_hInstRichEdit = LoadLibrary(L"MSFTEDIT.DLL");

        if (!pState->m_hInstRichEdit)
        {
            pState->m_hInstRichEdit = LoadLibrary(L"RICHED20.DLL");
        }

        if (pState->m_hInstRichEdit)
        {
            bRet = TRUE;
        }
    }

    CCtrlView::PreCreateWindow(cs);
    cs.lpszName = &afxChNil;

    cs.cx = cs.cy = 100; // necessary to avoid bug with ES_SELECTIONBAR and zero for cx and cy
    cs.style |= WS_CLIPSIBLINGS;

    return bRet;
}

int CRichEdit2View::OnCreate(LPCREATESTRUCT lpcs)
{
    if (CCtrlView::OnCreate(lpcs) != 0)
        return -1;
    GetRichEditCtrl().LimitText(lMaxSize);
    GetRichEditCtrl().SetEventMask(ENM_SELCHANGE | ENM_CHANGE | ENM_SCROLL);
    VERIFY(GetRichEditCtrl().SetOLECallback(&m_xRichEditOleCallback));
    m_lpRichEditOle = GetRichEditCtrl().GetIRichEditOle();
    DragAcceptFiles();
    GetRichEditCtrl().SetOptions(ECOOP_OR, ECO_AUTOWORDSELECTION);
    WrapChanged();
    ASSERT(m_lpRichEditOle != NULL);

    DWORD_PTR dwOptions = GetRichEditCtrl().SendMessage(EM_GETLANGOPTIONS, 0, 0);
    dwOptions &= ~IMF_DUALFONT;
    GetRichEditCtrl().SendMessage(EM_SETLANGOPTIONS, 0, dwOptions);

    dwOptions = (SES_USECTF | SES_CTFALLOWEMBED | SES_CTFALLOWSMARTTAG | SES_CTFALLOWPROOFING);
    GetRichEditCtrl().SendMessage(EM_SETEDITSTYLE, dwOptions, dwOptions);

    return 0;
}

void CRichEdit2View::OnInitialUpdate()
{
    CCtrlView::OnInitialUpdate();
    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View document like functions

void CRichEdit2View::DeleteContents()
{
    ASSERT_VALID(this);
    ASSERT(m_hWnd != NULL);
    SetWindowText(_T(""));
    GetRichEditCtrl().EmptyUndoBuffer();
    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
    ASSERT_VALID(this);
}

void CRichEdit2View::WrapChanged()
{
    CWaitCursor wait;
    CRichEdit2Ctrl& ctrl = GetRichEditCtrl();
    if (m_nWordWrap == WrapNone)
        ctrl.SetTargetDevice(NULL, 1);
    else if (m_nWordWrap == WrapToWindow)
        ctrl.SetTargetDevice(NULL, 0);
    else if (m_nWordWrap == WrapToTargetDevice) // wrap to ruler
    {
        AfxGetApp()->CreatePrinterDC(m_dcTarget);
        if (m_dcTarget.m_hDC == NULL)
            m_dcTarget.CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
        ctrl.SetTargetDevice(m_dcTarget, GetPrintWidth());
    }
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View serialization support

class _afxRichEditCookie
{
public:
    CArchive& m_ar;
    DWORD m_dwError;
    _afxRichEditCookie(CArchive& ar) : m_ar(ar) {m_dwError=0;}
};

void CRichEdit2View::Serialize(CArchive& ar)
    // Read and write CRichEdit2View object to archive, with length prefix.
{
    ASSERT_VALID(this);
    ASSERT(m_hWnd != NULL);
    Stream(ar, FALSE);
    ASSERT_VALID(this);
}

void CRichEdit2View::Stream(CArchive& ar, BOOL bSelection)
{
    EDITSTREAM es = {0, 0, EditStreamCallBack};
    _afxRichEditCookie cookie(ar);
    es.dwCookie = (DWORD_PTR)&cookie;
    int nFormat = GetDocument()->GetStreamFormat();

    if (bSelection)
        nFormat |= SFF_SELECTION;
    if (GetDocument()->IsUnicode())
        nFormat |= SF_UNICODE;

    if (ar.IsStoring())
        GetRichEditCtrl().StreamOut(nFormat, es);
    else
    {
        GetRichEditCtrl().StreamIn(nFormat, es);
        Invalidate();
    }
    if (cookie.m_dwError != 0)
        AfxThrowFileException(cookie.m_dwError);
}

// return 0 for no error, otherwise return error code
DWORD CALLBACK CRichEdit2View::EditStreamCallBack(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb)
{
    _afxRichEditCookie* pCookie = (_afxRichEditCookie*)dwCookie;
    CArchive& ar = pCookie->m_ar;
    ar.Flush();
    DWORD dw = 0;
    *pcb = cb;
    TRY
    {
        if (ar.IsStoring())
            ar.GetFile()->WriteHuge(pbBuff, cb);
        else
            *pcb = ar.GetFile()->ReadHuge(pbBuff, cb);
    }
    CATCH(CFileException, e)
    {
        *pcb = 0;
        pCookie->m_dwError = (DWORD)e->m_cause;
        dw = 1;
        DELETE_EXCEPTION(e);
    }
    AND_CATCH_ALL(e)
    {
        *pcb = 0;
        pCookie->m_dwError = (DWORD)CFileException::generic;
        dw = 1;
        DELETE_EXCEPTION(e);
    }
    END_CATCH_ALL
    return dw;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View Printing support

void CRichEdit2View::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo*)
{
    ASSERT_VALID(this);
//  ASSERT_VALID(pDC);
    // initialize page start vector
    ASSERT(m_aPageStart.GetSize() == 0);
    m_aPageStart.Add(0);
    ASSERT(m_aPageStart.GetSize() > 0);
    GetRichEditCtrl().FormatRange(NULL, FALSE); // required by RichEdit to clear out cache

    ASSERT_VALID(this);
}

BOOL CRichEdit2View::PaginateTo(CDC* pDC, CPrintInfo* pInfo)
    // attempts pagination to pInfo->m_nCurPage, TRUE == success
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);

    CRect rectSave = pInfo->m_rectDraw;
    UINT nPageSave = pInfo->m_nCurPage;
    ASSERT(nPageSave > 1);
    ASSERT(nPageSave >= (UINT)m_aPageStart.GetSize());
    VERIFY(pDC->SaveDC() != 0);
    pDC->IntersectClipRect(0, 0, 0, 0);
    pInfo->m_nCurPage = (UINT)m_aPageStart.GetSize();
    while (pInfo->m_nCurPage < nPageSave)
    {
        ASSERT(pInfo->m_nCurPage == (UINT)m_aPageStart.GetSize());
        OnPrepareDC(pDC, pInfo);
        ASSERT(pInfo->m_bContinuePrinting);
        pInfo->m_rectDraw.SetRect(0, 0,
            pDC->GetDeviceCaps(HORZRES), pDC->GetDeviceCaps(VERTRES));
        pDC->DPtoLP(&pInfo->m_rectDraw);
        OnPrint(pDC, pInfo);
        if (pInfo->m_nCurPage == (UINT)m_aPageStart.GetSize())
            break;
        ++pInfo->m_nCurPage;
    }
    BOOL bResult = pInfo->m_nCurPage == nPageSave;
    pDC->RestoreDC(-1);
    pInfo->m_nCurPage = nPageSave;
    pInfo->m_rectDraw = rectSave;
    ASSERT_VALID(this);
    return bResult;
}

void CRichEdit2View::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    ASSERT(pInfo != NULL);  // overriding OnPaint -- never get this.

    pDC->SetMapMode(MM_TEXT);

    if (pInfo->m_nCurPage > (UINT)m_aPageStart.GetSize() &&
        !PaginateTo(pDC, pInfo))
    {
        // can't paginate to that page, thus cannot print it.
        pInfo->m_bContinuePrinting = FALSE;
    }
    ASSERT_VALID(this);
}

long CRichEdit2View::PrintPage(CDC* pDC, long nIndexStart, long nIndexStop)
    // worker function for laying out text in a rectangle.
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    FORMATRANGE fr;

    // offset by printing offset
    pDC->SetViewportOrg(-pDC->GetDeviceCaps(PHYSICALOFFSETX),
        -pDC->GetDeviceCaps(PHYSICALOFFSETY));
    // adjust DC because richedit doesn't do things like MFC
    if (::GetDeviceCaps(pDC->m_hDC, TECHNOLOGY) != DT_METAFILE && pDC->m_hAttribDC != NULL)
    {
        ::ScaleWindowExtEx(pDC->m_hDC,
            ::GetDeviceCaps(pDC->m_hDC, LOGPIXELSX),
            ::GetDeviceCaps(pDC->m_hAttribDC, LOGPIXELSX),
            ::GetDeviceCaps(pDC->m_hDC, LOGPIXELSY),
            ::GetDeviceCaps(pDC->m_hAttribDC, LOGPIXELSY), NULL);
    }

    fr.hdcTarget = pDC->m_hAttribDC;
    fr.hdc = pDC->m_hDC;
    fr.rcPage = GetPageRect();
    fr.rc = GetPrintRect();

    fr.chrg.cpMin = nIndexStart;
    fr.chrg.cpMax = nIndexStop;
    long lRes = GetRichEditCtrl().FormatRange(&fr,TRUE);

    return lRes;
}

long CRichEdit2View::PrintInsideRect(CDC* pDC, RECT& rectLayout,
    long nIndexStart, long nIndexStop, BOOL bOutput)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    FORMATRANGE fr;

    // adjust DC because richedit doesn't do things like MFC
    if (::GetDeviceCaps(pDC->m_hDC, TECHNOLOGY) != DT_METAFILE && pDC->m_hAttribDC != NULL)
    {
        ::ScaleWindowExtEx(pDC->m_hDC,
            ::GetDeviceCaps(pDC->m_hDC, LOGPIXELSX),
            ::GetDeviceCaps(pDC->m_hAttribDC, LOGPIXELSX),
            ::GetDeviceCaps(pDC->m_hDC, LOGPIXELSY),
            ::GetDeviceCaps(pDC->m_hAttribDC, LOGPIXELSY), NULL);
    }

    fr.hdcTarget = pDC->m_hAttribDC;
    fr.hdc = pDC->m_hDC;
    // convert rect to twips
    fr.rcPage = rectLayout;
    fr.rc = rectLayout;

    fr.chrg.cpMin = nIndexStart;
    fr.chrg.cpMax = nIndexStop;
    GetRichEditCtrl().FormatRange(NULL, FALSE); // required by RichEdit to clear out cache
    // if bOutput is FALSE, we only measure
    long lres = GetRichEditCtrl().FormatRange(&fr, bOutput);
    GetRichEditCtrl().FormatRange(NULL, FALSE); // required by RichEdit to clear out cache

    rectLayout = fr.rc;
    return lres;
}

void CRichEdit2View::OnPrint(CDC* pDC, CPrintInfo* pInfo)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    ASSERT(pInfo != NULL);
    ASSERT(pInfo->m_bContinuePrinting);

    UINT nPage = pInfo->m_nCurPage;
    ASSERT(nPage <= (UINT)m_aPageStart.GetSize());
    long nIndex = (long) m_aPageStart[nPage-1];

    // print as much as possible in the current page.
    nIndex = PrintPage(pDC, nIndex, 0xFFFFFFFF);

    if (nIndex >= GetTextLength())
    {
        TRACE0("End of Document\n");
        pInfo->SetMaxPage(nPage);
    }

    // update pagination information for page just printed
    if (nPage == (UINT)m_aPageStart.GetSize())
    {
        if (nIndex < GetTextLength())
            m_aPageStart.Add(nIndex);
    }
    else
    {
        ASSERT(nPage+1 <= (UINT)m_aPageStart.GetSize());
        ASSERT(nIndex == (long)m_aPageStart[nPage+1-1]);
    }
}


void CRichEdit2View::OnEndPrinting(CDC*, CPrintInfo*)
{
    ASSERT_VALID(this);
    GetRichEditCtrl().FormatRange(NULL, FALSE); // required by RichEdit to clear out cache
    m_aPageStart.RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View::XRichEditOleCallback

BEGIN_INTERFACE_MAP(CRichEdit2View, CCtrlView)
    // we use IID_IUnknown because richedit doesn't define an IID
    INTERFACE_PART(CRichEdit2View, IID_IUnknown, RichEditOleCallback)
END_INTERFACE_MAP()

STDMETHODIMP_(ULONG) CRichEdit2View::XRichEditOleCallback::AddRef()
{
    METHOD_PROLOGUE_EX_(CRichEdit2View, RichEditOleCallback)
    return (ULONG)pThis->InternalAddRef();
}

STDMETHODIMP_(ULONG) CRichEdit2View::XRichEditOleCallback::Release()
{
    METHOD_PROLOGUE_EX_(CRichEdit2View, RichEditOleCallback)
    return (ULONG)pThis->InternalRelease();
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::QueryInterface(
    REFIID iid, LPVOID* ppvObj)
{
    METHOD_PROLOGUE_EX_(CRichEdit2View, RichEditOleCallback)
    return (HRESULT)pThis->InternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::GetNewStorage(LPSTORAGE* ppstg)
{
    METHOD_PROLOGUE_EX_(CRichEdit2View, RichEditOleCallback)

    // Create a flat storage and steal it from the client item
    // the client item is only used for creating the storage
    COleClientItem item;
    item.GetItemStorageFlat();
    *ppstg = item.m_lpStorage;
    HRESULT hRes = E_OUTOFMEMORY;
    if (item.m_lpStorage != NULL)
    {
        item.m_lpStorage = NULL;
        hRes = S_OK;
    }
    pThis->GetDocument()->InvalidateObjectCache();
    return hRes;
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::GetInPlaceContext(
    LPOLEINPLACEFRAME* lplpFrame, LPOLEINPLACEUIWINDOW* lplpDoc,
    LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    METHOD_PROLOGUE_EX(CRichEdit2View, RichEditOleCallback)
    return pThis->GetWindowContext(lplpFrame, lplpDoc, lpFrameInfo);
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::ShowContainerUI(BOOL fShow)
{
    METHOD_PROLOGUE_EX(CRichEdit2View, RichEditOleCallback)
    return pThis->ShowContainerUI(fShow);
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::QueryInsertObject(
    LPCLSID /*lpclsid*/, LPSTORAGE /*pstg*/, LONG /*cp*/)
{
    METHOD_PROLOGUE_EX(CRichEdit2View, RichEditOleCallback)
    pThis->GetDocument()->InvalidateObjectCache();
    return S_OK;
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::DeleteObject(LPOLEOBJECT /*lpoleobj*/)
{
    METHOD_PROLOGUE_EX_(CRichEdit2View, RichEditOleCallback)
    pThis->GetDocument()->InvalidateObjectCache();
    return S_OK;
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::QueryAcceptData(
    LPDATAOBJECT lpdataobj, CLIPFORMAT* lpcfFormat, DWORD reco,
    BOOL fReally, HGLOBAL hMetaPict)
{
    METHOD_PROLOGUE_EX(CRichEdit2View, RichEditOleCallback)
    return pThis->QueryAcceptData(lpdataobj, lpcfFormat, reco,
        fReally, hMetaPict);
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::ContextSensitiveHelp(BOOL /*fEnterMode*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::GetClipboardData(
    CHARRANGE* lpchrg, DWORD reco, LPDATAOBJECT* lplpdataobj)
{
    METHOD_PROLOGUE_EX(CRichEdit2View, RichEditOleCallback)
    LPDATAOBJECT lpOrigDataObject = NULL;

    // get richedit's data object
    if (FAILED(pThis->m_lpRichEditOle->GetClipboardData(lpchrg, reco,
        &lpOrigDataObject)))
    {
        return E_NOTIMPL;
    }

    // allow changes
    HRESULT hRes = pThis->GetClipboardData(lpchrg, reco, lpOrigDataObject,
        lplpdataobj);

    // if changed then free original object
    if (SUCCEEDED(hRes))
    {
        if (lpOrigDataObject!=NULL)
            lpOrigDataObject->Release();
        return hRes;
    }
    else
    {
        // use richedit's data object
        *lplpdataobj = lpOrigDataObject;
        return S_OK;
    }
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::GetDragDropEffect(
    BOOL fDrag, DWORD grfKeyState, LPDWORD pdwEffect)
{
    if (!fDrag) // allowable dest effects
    {
        DWORD dwEffect;
        // check for force link
        if ((grfKeyState & (MK_CONTROL|MK_SHIFT)) == (MK_CONTROL|MK_SHIFT))
            dwEffect = DROPEFFECT_LINK;
        // check for force copy
        else if ((grfKeyState & MK_CONTROL) == MK_CONTROL)
            dwEffect = DROPEFFECT_COPY;
        // check for force move
        else if ((grfKeyState & MK_ALT) == MK_ALT)
            dwEffect = DROPEFFECT_MOVE;
        // default -- recommended action is move
        else
            dwEffect = DROPEFFECT_MOVE;
        if (dwEffect & *pdwEffect) // make sure allowed type
            *pdwEffect = dwEffect;
    }
    return S_OK;
}

STDMETHODIMP CRichEdit2View::XRichEditOleCallback::GetContextMenu(
    WORD seltype, LPOLEOBJECT lpoleobj, CHARRANGE* lpchrg,
    HMENU* lphmenu)
{
    METHOD_PROLOGUE_EX(CRichEdit2View, RichEditOleCallback)
    HMENU hMenu = pThis->GetContextMenu(seltype, lpoleobj, lpchrg);
    if (hMenu == NULL)
        return E_NOTIMPL;
    *lphmenu = hMenu;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View command helpers

void CRichEdit2View::OnCharEffect(DWORD dwMask, DWORD dwEffect)
{
    GetCharFormatSelection();
    if (m_charformat.dwMask & dwMask) // selection is all the same
        m_charformat.dwEffects ^= dwEffect;
    else
        m_charformat.dwEffects |= dwEffect;
    m_charformat.dwMask = dwMask;
    SetCharFormat(m_charformat);
}

void CRichEdit2View::OnUpdateCharEffect(CCmdUI* pCmdUI, DWORD dwMask, DWORD dwEffect)
{
    GetCharFormatSelection();
    pCmdUI->SetCheck((m_charformat.dwMask & dwMask) ?
        ((m_charformat.dwEffects & dwEffect) ? 1 : 0) : 2);
}

void CRichEdit2View::OnParaAlign(WORD wAlign)
{
    GetParaFormatSelection();
    m_paraformat.dwMask = PFM_ALIGNMENT;
    m_paraformat.wAlignment = wAlign;
    SetParaFormat(m_paraformat);
}

void CRichEdit2View::OnUpdateParaAlign(CCmdUI* pCmdUI, WORD wAlign)
{
    GetParaFormatSelection();
    // disable if no word wrap since alignment is meaningless
    pCmdUI->Enable( (m_nWordWrap == WrapNone) ?
        FALSE : TRUE);
    pCmdUI->SetCheck( (m_paraformat.dwMask & PFM_ALIGNMENT) ?
        ((m_paraformat.wAlignment == wAlign) ? 1 : 0) : 2);
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View commands

void CRichEdit2View::OnUpdateNeedSel(CCmdUI* pCmdUI)
{
    ASSERT_VALID(this);
    long nStartChar, nEndChar;
    GetRichEditCtrl().GetSel(nStartChar, nEndChar);
    pCmdUI->Enable(nStartChar != nEndChar);
    ASSERT_VALID(this);
}

void CRichEdit2View::OnUpdateNeedClip(CCmdUI* pCmdUI)
{
    ASSERT_VALID(this);
    pCmdUI->Enable(CanPaste());
}

void CRichEdit2View::OnUpdateNeedText(CCmdUI* pCmdUI)
{
    ASSERT_VALID(this);
    pCmdUI->Enable(GetTextLength() != 0);
}

void CRichEdit2View::OnUpdateNeedFind(CCmdUI* pCmdUI)
{
    ASSERT_VALID(this);
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    pCmdUI->Enable(GetTextLength() != 0 &&
        !pEditState->strFind.IsEmpty());
}

void CRichEdit2View::OnUpdateEditUndo(CCmdUI* pCmdUI)
{
    ASSERT_VALID(this);
    pCmdUI->Enable(GetRichEditCtrl().CanUndo());
}

void CRichEdit2View::OnEditCut()
{
    ASSERT_VALID(this);
    GetRichEditCtrl().Cut();
}

void CRichEdit2View::OnEditCopy()
{
    ASSERT_VALID(this);
    GetRichEditCtrl().Copy();
}

void CRichEdit2View::OnEditPaste()
{
    ASSERT_VALID(this);
    m_nPasteType = 0;
    GetRichEditCtrl().Paste();
}

void CRichEdit2View::OnEditClear()
{
    ASSERT_VALID(this);
    GetRichEditCtrl().Clear();
}

void CRichEdit2View::OnEditUndo()
{
    ASSERT_VALID(this);
    GetRichEditCtrl().Undo();
    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
}

void CRichEdit2View::OnEditSelectAll()
{
    ASSERT_VALID(this);
    GetRichEditCtrl().SetSel(0, -1);
}

void CRichEdit2View::OnEditFind()
{
    ASSERT_VALID(this);
    OnEditFindReplace(TRUE);
}

void CRichEdit2View::OnEditReplace()
{
    ASSERT_VALID(this);
    OnEditFindReplace(FALSE);
}

void CRichEdit2View::OnEditRepeat()
{
    ASSERT_VALID(this);
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    if (!FindText(pEditState))
        TextNotFound(pEditState->strFind);
}

void CRichEdit2View::OnCancelEditCntr()
{
    m_lpRichEditOle->InPlaceDeactivate();
}

void CRichEdit2View::OnInsertObject()
{
    // Invoke the standard Insert Object dialog box to obtain information
    COleInsertDialog dlg;
    if (dlg.DoModal() != IDOK)
        return;

    CWaitCursor wait;

    CRichEdit2CntrItem* pItem = NULL;
    TRY
    {
        // create item from dialog results
        pItem = GetDocument()->CreateClientItem();
        pItem->m_bLock = TRUE;
        if (!dlg.CreateItem(pItem))
        {
            pItem->m_bLock = FALSE;
            AfxThrowMemoryException();  // any exception will do
        }

        HRESULT hr = InsertItem(pItem);
        pItem->UpdateItemType();

        pItem->m_bLock = FALSE;

        if (hr != NOERROR)
            AfxThrowOleException(hr);

        // if insert new object -- initially show the object
        if (dlg.GetSelectionType() == COleInsertDialog::createNewItem)
            pItem->DoVerb(OLEIVERB_SHOW, this);
    }
    CATCH(CException, e)
    {
        if (pItem != NULL)
        {
            ASSERT_VALID(pItem);
            pItem->Delete();
        }
        AfxMessageBox(AFX_IDP_FAILED_TO_CREATE);
    }
    END_CATCH
}

void CRichEdit2View::OnSelChange(NMHDR* pNMHDR, LRESULT* pResult)
{
    ASSERT(pNMHDR->code == EN_SELCHANGE);
    UNUSED(pNMHDR); // not used in release builds

    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
    *pResult = 0;
}

void CRichEdit2View::OnDestroy()
{
    if (m_lpRichEditOle != NULL)
        m_lpRichEditOle->Release();
    CCtrlView::OnDestroy();
}

void CRichEdit2View::OnEditProperties()
{
    ASSERT(m_lpRichEditOle != NULL);
    CRichEdit2CntrItem* pSelection = GetSelectedItem();
    // make sure item is in sync with richedit's item
    CRe2Object reo;
    m_lpRichEditOle->GetObject(REO_IOB_SELECTION, &reo, REO_GETOBJ_NO_INTERFACES);
    pSelection->SyncToRichEditObject(reo);

    //
    // HACKHACK:  Due to a mismatch between the NT build environment and MFC
    //            wrt to the setting of _WIN32_IE, Wordpad and MFC have 
    //            different views of how large a COlePropertiesDialog is.  The
    //            result is that MFC ends up wiping part of the stack in it's
    //            initialization code.  Hack some extra space until the
    //            mismatch is resolved.
    //
//    COlePropertiesDialog dlg(pSelection);
    struct Hack
    {
        COlePropertiesDialog dlg;
        BYTE                 space[128];
    
        Hack(CRichEdit2CntrItem *pSelection) : dlg(pSelection) {}
    }
    hack(pSelection);
    COlePropertiesDialog &dlg = hack.dlg;

    //
    // The Object Properties dialog doesn't display a help button even if
    // you tell it to.  The dialogs under it (e.g. Change Icon) will display
    // the help button though.  We never want a help button but MFC turns it
    // on by default.  If the Ole dialogs are fixed to not display the help
    // button then this can be removed.
    //
    dlg.m_op.dwFlags &= ~OPF_SHOWHELP;

    dlg.DoModal();
}

void CRichEdit2View::OnUpdateEditProperties(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(GetSelectedItem() != NULL);
}

void CRichEdit2View::OnCharBold()
{
    OnCharEffect(CFM_BOLD, CFE_BOLD);
}

void CRichEdit2View::OnUpdateCharBold(CCmdUI* pCmdUI)
{
    OnUpdateCharEffect(pCmdUI, CFM_BOLD, CFE_BOLD);
}

void CRichEdit2View::OnCharItalic()
{
    OnCharEffect(CFM_ITALIC, CFE_ITALIC);
}

void CRichEdit2View::OnUpdateCharItalic(CCmdUI* pCmdUI)
{
    OnUpdateCharEffect(pCmdUI, CFM_ITALIC, CFE_ITALIC);
}

void CRichEdit2View::OnCharUnderline()
{
    OnCharEffect(CFM_UNDERLINE, CFE_UNDERLINE);
}

void CRichEdit2View::OnUpdateCharUnderline(CCmdUI* pCmdUI)
{
    OnUpdateCharEffect(pCmdUI, CFM_UNDERLINE, CFE_UNDERLINE);
}

void CRichEdit2View::OnParaCenter()
{
    OnParaAlign(PFA_CENTER);
}

void CRichEdit2View::OnUpdateParaCenter(CCmdUI* pCmdUI)
{
    OnUpdateParaAlign(pCmdUI, PFA_CENTER);
}

void CRichEdit2View::OnParaLeft()
{
    OnParaAlign(PFA_LEFT);
}

void CRichEdit2View::OnUpdateParaLeft(CCmdUI* pCmdUI)
{
    OnUpdateParaAlign(pCmdUI, PFA_LEFT);
}

void CRichEdit2View::OnParaRight()
{
    OnParaAlign(PFA_RIGHT);
}

void CRichEdit2View::OnUpdateParaRight(CCmdUI* pCmdUI)
{
    OnUpdateParaAlign(pCmdUI, PFA_RIGHT);
}

void CRichEdit2View::OnBullet()
{
    GetParaFormatSelection();
    if (m_paraformat.dwMask & PFM_NUMBERING && m_paraformat.wNumbering == PFN_BULLET)
    {
        m_paraformat.wNumbering = 0;
        m_paraformat.dxOffset = 0;
        m_paraformat.dxStartIndent = 0;
        m_paraformat.dwMask = PFM_NUMBERING | PFM_STARTINDENT | PFM_OFFSET;
    }
    else
    {
        m_paraformat.wNumbering = PFN_BULLET;
        m_paraformat.dwMask = PFM_NUMBERING;
        if (m_paraformat.dxOffset == 0)
        {
            m_paraformat.dxOffset = m_nBulletIndent;
            m_paraformat.dwMask = PFM_NUMBERING | PFM_STARTINDENT | PFM_OFFSET;
        }
    }
    SetParaFormat(m_paraformat);
}

void CRichEdit2View::OnUpdateBullet(CCmdUI* pCmdUI)
{
    GetParaFormatSelection();
    pCmdUI->SetCheck( (m_paraformat.dwMask & PFM_NUMBERING) ? ((m_paraformat.wNumbering & PFN_BULLET) ? 1 : 0) : 2);
}

void CRichEdit2View::OnFormatFont()
{
    GetCharFormatSelection();
    CFontDialog2 dlg(m_charformat, CF_BOTH|CF_NOOEMFONTS);
    if (dlg.DoModal() == IDOK)
    {
        dlg.GetCharFormat(m_charformat);
        SetCharFormat(m_charformat);
    }
}

void CRichEdit2View::OnColorPick(COLORREF cr)
{
    GetCharFormatSelection();
    m_charformat.dwMask = CFM_COLOR;
    m_charformat.dwEffects = NULL;
    m_charformat.crTextColor = cr;
    SetCharFormat(m_charformat);
}

void CRichEdit2View::OnColorDefault()
{
    GetCharFormatSelection();
    m_charformat.dwMask = CFM_COLOR;
    m_charformat.dwEffects = CFE_AUTOCOLOR;
    SetCharFormat(m_charformat);
}

void CRichEdit2View::OnEditPasteSpecial()
{
    COlePasteSpecialDialog dlg;
    dlg.AddStandardFormats();
    dlg.AddFormat(_oleData.cfRichTextFormat, TYMED_HGLOBAL, AFX_IDS_RTF_FORMAT, FALSE, FALSE);
    dlg.AddFormat(CF_TEXT, TYMED_HGLOBAL, AFX_IDS_TEXT_FORMAT, FALSE, FALSE);

    if (dlg.DoModal() != IDOK)
        return;

    DVASPECT dv = dlg.GetDrawAspect();
    HMETAFILE hMF = (HMETAFILE)dlg.GetIconicMetafile();
    CLIPFORMAT cf =
        dlg.m_ps.arrPasteEntries[dlg.m_ps.nSelectedIndex].fmtetc.cfFormat;

    CWaitCursor wait;
    SetCapture();

    // we set the target type so that QueryAcceptData know what to paste
    m_nPasteType = dlg.GetSelectionType();
    GetRichEditCtrl().PasteSpecial(cf, dv, hMF);
    m_nPasteType = 0;

    ReleaseCapture();
}

void CRichEdit2View::OnUpdateEditPasteSpecial(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(CanPaste());
}

void CRichEdit2View::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    if (nChar == VK_F10 && GetKeyState(VK_SHIFT) < 0)
    {
        CRect rect;
        GetClientRect(rect);
        CPoint pt = rect.CenterPoint();
        SendMessage(WM_CONTEXTMENU, (WPARAM)m_hWnd, MAKELPARAM(pt.x, pt.y));
    }
    else
        CCtrlView::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CRichEdit2View::OnDropFiles(HDROP hDropInfo)
{
    TCHAR szFileName[_MAX_PATH];
    UINT nFileCount = ::DragQueryFile(hDropInfo, 0xFFFFFFFF, NULL, 0);
    ASSERT(nFileCount != 0);
    CHARRANGE cr;

    GetRichEditCtrl().GetSel(cr);
    int nMin = cr.cpMin;
    for (UINT i=0;i<nFileCount;i++)
    {
        ::DragQueryFile(hDropInfo, i, szFileName, ARRAYSIZE(szFileName));
        InsertFileAsObject(szFileName);
        GetRichEditCtrl().GetSel(cr);
        cr.cpMin = cr.cpMax;
        GetRichEditCtrl().SetSel(cr);
        UpdateWindow();
    }
    cr.cpMin = nMin;
    GetRichEditCtrl().SetSel(cr);
    ::DragFinish(hDropInfo);
}

void CRichEdit2View::OnDevModeChange(LPTSTR /*lpDeviceName*/)
{
    // WM_DEVMODECHANGE forwarded by the main window of the app
    CDC dc;
    AfxGetApp()->CreatePrinterDC(dc);
    OnPrinterChanged(dc);
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View attributes

BOOL AFX_CDECL CRichEdit2View::IsRichEdit2Format(CLIPFORMAT cf)
{
    return ((cf == _oleData.cfRichTextFormat)     ||
            (cf == _oleData.cfRichTextAndObjects) ||
            (cf == CF_TEXT)                       ||
            (cf == CF_UNICODETEXT));
}

BOOL CRichEdit2View::CanPaste() const
{
    return (CountClipboardFormats() != 0) &&
        (IsClipboardFormatAvailable(CF_TEXT) ||
        IsClipboardFormatAvailable(_oleData.cfRichTextFormat) ||
        IsClipboardFormatAvailable(_oleData.cfEmbedSource) ||
        IsClipboardFormatAvailable(_oleData.cfEmbeddedObject) ||
        IsClipboardFormatAvailable(_oleData.cfFileName) ||
        IsClipboardFormatAvailable(_oleData.cfFileNameW) ||
        IsClipboardFormatAvailable(CF_METAFILEPICT) ||
        IsClipboardFormatAvailable(CF_DIB) ||
        IsClipboardFormatAvailable(CF_BITMAP) ||
        GetRichEditCtrl().CanPaste());
}

CHARFORMAT& CRichEdit2View::GetCharFormatSelection()
{
    if (m_bSyncCharFormat)
    {
        GetRichEditCtrl().GetSelectionCharFormat(m_charformat);
        m_bSyncCharFormat = FALSE;
    }
    return m_charformat;
}

PARAFORMAT& CRichEdit2View::GetParaFormatSelection()
{
    if (m_bSyncParaFormat)
    {
        GetRichEditCtrl().GetParaFormat(m_paraformat);
        m_bSyncParaFormat = FALSE;
    }
    return m_paraformat;
}

void CRichEdit2View::SetCharFormat(CHARFORMAT cf)
{
    CWaitCursor wait;
    GetRichEditCtrl().SetSelectionCharFormat(cf);
    m_bSyncCharFormat = TRUE;
}

void CRichEdit2View::SetParaFormat(PARAFORMAT& pf)
{
    CWaitCursor wait;
    GetRichEditCtrl().SetParaFormat(pf);
    m_bSyncParaFormat = TRUE;
}

CRichEdit2CntrItem* CRichEdit2View::GetSelectedItem() const
{
    ASSERT(m_lpRichEditOle != NULL);
    CRichEdit2Doc* pDoc = GetDocument();
    CRichEdit2CntrItem* pItem = NULL;

    CRe2Object reo;
    HRESULT hr = m_lpRichEditOle->GetObject(REO_IOB_SELECTION, &reo,
        REO_GETOBJ_ALL_INTERFACES);
    //reo's interfaces are all in UNICODE
    if (GetScode(hr) == S_OK)
    {
        pItem = pDoc->LookupItem(reo.poleobj);
        if (pItem == NULL)
            pItem = pDoc->CreateClientItem(&reo);
        ASSERT(pItem != NULL);
    }
    return pItem;
}

CRichEdit2CntrItem* CRichEdit2View::GetInPlaceActiveItem() const
{
    ASSERT(m_lpRichEditOle != NULL);
    CRichEdit2Doc* pDoc = GetDocument();
    CRichEdit2CntrItem* pItem = NULL;

    CRe2Object reo;
    HRESULT hr = m_lpRichEditOle->GetObject(REO_IOB_SELECTION, &reo,
        REO_GETOBJ_ALL_INTERFACES);
    //reo's interfaces are all in UNICODE
    if (GetScode(hr) == S_OK && (reo.dwFlags & REO_INPLACEACTIVE))
    {
        pItem = pDoc->LookupItem(reo.poleobj);
        if (pItem == NULL)
            pItem = pDoc->CreateClientItem(&reo);
        ASSERT(pItem != NULL);
    }
    return pItem;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View operations
HRESULT CRichEdit2View::InsertItem(CRichEdit2CntrItem* pItem)
{
    ASSERT(m_lpRichEditOle != NULL);
    CRe2Object reo(pItem);
    reo.cp = REO_CP_SELECTION;

    HRESULT hr = m_lpRichEditOle->InsertObject(&reo);

    CHARRANGE cr;
    GetRichEditCtrl().GetSel(cr);
    cr.cpMin = cr.cpMax -1;
    GetRichEditCtrl().SetSel(cr);
    return hr;
}

void CRichEdit2View::InsertFileAsObject(LPCTSTR lpszFileName)
{
    CString str = lpszFileName;
    CWaitCursor wait;
    CRichEdit2CntrItem* pItem = NULL;
    TRY
    {
        // create item from dialog results
        pItem = GetDocument()->CreateClientItem();
        pItem->m_bLock = TRUE;
        if (!pItem->CreateFromFile(str))
            AfxThrowMemoryException();  // any exception will do
        pItem->UpdateLink();
        InsertItem(pItem);
        pItem->m_bLock = FALSE;
    }
    CATCH(CException, e)
    {
        if (pItem != NULL)
        {
            pItem->m_bLock = FALSE;
            ASSERT_VALID(pItem);
            pItem->Delete();
        }
    }
    END_CATCH
}

//
// CRichEditView::DoPaste doesn't return an error but we need it to...
//
HRESULT g_hrPaste;

void CRichEdit2View::DoPaste(COleDataObject& dataobj, CLIPFORMAT cf, HMETAFILEPICT hMetaPict)
{
    CWaitCursor wait;

    g_hrPaste = S_FALSE;

    CRichEdit2CntrItem* pItem = NULL;
    TRY
    {
        // create item from dialog results
        pItem = GetDocument()->CreateClientItem();
        pItem->m_bLock = TRUE;

        if (m_nPasteType == COlePasteSpecialDialog::pasteLink)      // paste link
        {
            if (!pItem->CreateLinkFromData(&dataobj))
                AfxThrowMemoryException();  // any exception will do
        }
        else if (m_nPasteType == COlePasteSpecialDialog::pasteNormal)
        {
            if (!pItem->CreateFromData(&dataobj))
                AfxThrowMemoryException();      // any exception will do
        }
        else if (m_nPasteType == COlePasteSpecialDialog::pasteStatic)
        {
            if (!pItem->CreateStaticFromData(&dataobj))
                AfxThrowMemoryException();      // any exception will do
        }
        else
        {
            // paste embedded
            if (!pItem->CreateFromData(&dataobj) &&
                !pItem->CreateStaticFromData(&dataobj))
            {
                AfxThrowMemoryException();      // any exception will do
            }
        }

        if (cf == 0)
        {
            // copy the current iconic representation
            FORMATETC fmtetc;
            fmtetc.cfFormat = CF_METAFILEPICT;
            fmtetc.dwAspect = DVASPECT_ICON;
            fmtetc.ptd = NULL;
            fmtetc.tymed = TYMED_MFPICT;
            fmtetc.lindex = 1;
            HGLOBAL hObj = dataobj.GetGlobalData(CF_METAFILEPICT, &fmtetc);
            if (hObj != NULL)
            {
                pItem->SetIconicMetafile(hObj);
                // the following code is an easy way to free a metafile pict
                STGMEDIUM stgMed;
                memset(&stgMed, 0, sizeof(stgMed));
                stgMed.tymed = TYMED_MFPICT;
                stgMed.hGlobal = hObj;
                ReleaseStgMedium(&stgMed);
            }

            // set the current drawing aspect
            hObj = dataobj.GetGlobalData((CLIPFORMAT)_oleData.cfObjectDescriptor);
            if (hObj != NULL)
            {
                ASSERT(hObj != NULL);
                // got CF_OBJECTDESCRIPTOR ok.  Lock it down and extract size.
                LPOBJECTDESCRIPTOR pObjDesc = (LPOBJECTDESCRIPTOR)GlobalLock(hObj);
                ASSERT(pObjDesc != NULL);
                ((COleClientItem*)pItem)->SetDrawAspect((DVASPECT)pObjDesc->dwDrawAspect);
                GlobalUnlock(hObj);
                GlobalFree(hObj);
            }
        }
        else
        {
            if (hMetaPict != NULL)
            {
                pItem->SetIconicMetafile(hMetaPict);
                ((COleClientItem*)pItem)->SetDrawAspect(DVASPECT_ICON);
            }
            else
                ((COleClientItem*)pItem)->SetDrawAspect(DVASPECT_CONTENT);
        }

/////////
        HRESULT hr = InsertItem(pItem);
        pItem->UpdateItemType();

        pItem->m_bLock = FALSE;

        if (hr != NOERROR)
            AfxThrowOleException(hr);

    }
    CATCH(CException, e)
    {
        if (pItem != NULL)
        {
            pItem->m_bLock = FALSE;
            ASSERT_VALID(pItem);
            pItem->Delete();
        }
        g_hrPaste = E_FAIL;
    }
    END_CATCH
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View virtuals

void CRichEdit2View::OnPrinterChanged(const CDC& dcPrinter)
{
    // this is typically called by the view when it gets a WM_DEVMODECHANGE
    // also called during page setup
    CSize size;
    if (dcPrinter.m_hDC != NULL)
    {
        // this will fill in the page size
        size.cx = MulDiv(dcPrinter.GetDeviceCaps(PHYSICALWIDTH), 1440,
            dcPrinter.GetDeviceCaps(LOGPIXELSX));
        size.cy = MulDiv(dcPrinter.GetDeviceCaps(PHYSICALHEIGHT), 1440,
            dcPrinter.GetDeviceCaps(LOGPIXELSY));
    }
    else
        size = CSize(8*1440+720, 11*1440); // 8.5" by 11"
    if (GetPaperSize() != size)
    {
        SetPaperSize(size);
        if (m_nWordWrap == WrapToTargetDevice) //wrap to ruler
            WrapChanged();
    }
}

BOOL CRichEdit2View::OnPasteNativeObject(LPSTORAGE)
{
    // use this function to pull out native data from an embedded object
    // one would typically do this by create a COleStreamFile and attaching it
    // to an archive
    return FALSE;
}

HMENU CRichEdit2View::GetContextMenu(WORD, LPOLEOBJECT, CHARRANGE* )
{
    return NULL;
}

HRESULT CRichEdit2View::GetClipboardData(CHARRANGE* /*lpchrg*/, DWORD /*reco*/,
    LPDATAOBJECT /*lpRichDataObj*/, LPDATAOBJECT* /*lplpdataobj*/)
{
    return E_NOTIMPL;
}

HRESULT CRichEdit2View::QueryAcceptData(LPDATAOBJECT lpdataobj,
    CLIPFORMAT* lpcfFormat, DWORD /*dwReco*/, BOOL bReally, HGLOBAL hMetaPict)
{
    ASSERT(lpcfFormat != NULL);
    if (!bReally) // not actually pasting
        return S_OK;
    // if direct pasting a particular native format allow it
    if (IsRichEdit2Format(*lpcfFormat))
        return S_OK;

    COleDataObject dataobj;
    dataobj.Attach(lpdataobj, FALSE);
    // if format is 0, then force particular formats if available
    if (*lpcfFormat == 0 && (m_nPasteType == 0))
    {
        if (dataobj.IsDataAvailable((CLIPFORMAT)_oleData.cfRichTextAndObjects)) // native avail, let richedit do as it wants
            return S_OK;
        else if (dataobj.IsDataAvailable((CLIPFORMAT)_oleData.cfRichTextFormat))
        {
            *lpcfFormat = (CLIPFORMAT)_oleData.cfRichTextFormat;
            return S_OK;
        }
        else if (dataobj.IsDataAvailable(CF_UNICODETEXT))
        {
            *lpcfFormat = CF_UNICODETEXT;
            return S_OK;
        }
        else if (dataobj.IsDataAvailable(CF_TEXT))
        {
            *lpcfFormat = CF_TEXT;
            return S_OK;
        }
    }
    // paste OLE formats

    DoPaste(dataobj, *lpcfFormat, hMetaPict);
    return g_hrPaste;
}

HRESULT CRichEdit2View::GetWindowContext(LPOLEINPLACEFRAME* lplpFrame,
    LPOLEINPLACEUIWINDOW* lplpDoc, LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    CRichEdit2CntrItem* pItem = GetSelectedItem();
    if (pItem == NULL)
        return E_FAIL;
    pItem->m_pView = this;
    HRESULT hr = pItem->GetWindowContext(lplpFrame, lplpDoc, lpFrameInfo);
    pItem->m_pView = NULL;
    return hr;
}

HRESULT CRichEdit2View::ShowContainerUI(BOOL b)
{
    CRichEdit2CntrItem* pItem = GetSelectedItem();
    if (pItem == NULL)
        return E_FAIL;
    if (b)
        pItem->m_pView = this;
    HRESULT hr = pItem->ShowContainerUI(b);
    if (FAILED(hr) || !b)
        pItem->m_pView = NULL;
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View Find & Replace

void CRichEdit2View::AdjustDialogPosition(CDialog* pDlg)
{
    ASSERT(pDlg != NULL);

    long lStart, lEnd;
    GetRichEditCtrl().GetSel(lStart, lEnd);
    CPoint point = GetRichEditCtrl().GetCharPos(lStart);
    ClientToScreen(&point);
    CRect rectDlg;
    pDlg->GetWindowRect(&rectDlg);
    if (rectDlg.PtInRect(point))
    {
        if (point.y > rectDlg.Height())
            rectDlg.OffsetRect(0, point.y - rectDlg.bottom - 20);
        else
        {
            HMONITOR hMonitor = MonitorFromWindow(*pDlg, MONITOR_DEFAULTTONEAREST);
            MONITORINFO monitorInfo;
            monitorInfo.cbSize = sizeof(monitorInfo);
            GetMonitorInfo(hMonitor, &monitorInfo);

            int nVertExt = monitorInfo.rcMonitor.bottom
                           - monitorInfo.rcMonitor.top;
            if (point.y + rectDlg.Height() < nVertExt)
                rectDlg.OffsetRect(0, 40 + point.y - rectDlg.top);
        }
        pDlg->MoveWindow(&rectDlg);
    }
}

void CRichEdit2View::OnEditFindReplace(BOOL bFindOnly)
{
    ASSERT_VALID(this);
    m_bFirstSearch = TRUE;
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    if (pEditState->pFindReplaceDlg != NULL)
    {
        if (pEditState->bFindOnly == bFindOnly)
        {
            pEditState->pFindReplaceDlg->SetActiveWindow();
            pEditState->pFindReplaceDlg->ShowWindow(SW_SHOW);
            return;
        }
        else
        {
            ASSERT(pEditState->bFindOnly != bFindOnly);
            pEditState->pFindReplaceDlg->SendMessage(WM_CLOSE);
            ASSERT(pEditState->pFindReplaceDlg == NULL);
            ASSERT_VALID(this);
        }
    }
    CString strFind = GetRichEditCtrl().GetSelText();
    // if selection is empty or spans multiple lines use old find text
    if (strFind.IsEmpty() || (strFind.FindOneOf(_T("\n\r")) != -1))
        strFind = pEditState->strFind;
    CString strReplace = pEditState->strReplace;
    pEditState->pFindReplaceDlg = new CFindReplaceDialog;
    ASSERT(pEditState->pFindReplaceDlg != NULL);
    DWORD dwFlags = NULL;
    if (pEditState->bNext)
        dwFlags |= FR_DOWN;
    if (pEditState->bCase)
        dwFlags |= FR_MATCHCASE;
    if (pEditState->bWord)
        dwFlags |= FR_WHOLEWORD;
    // hide stuff that RichEdit doesn't support
    dwFlags |= FR_HIDEUPDOWN;
    if (!pEditState->pFindReplaceDlg->Create(bFindOnly, strFind,
        strReplace, dwFlags, this))
    {
        pEditState->pFindReplaceDlg = NULL;
        ASSERT_VALID(this);
        return;
    }
    ASSERT(pEditState->pFindReplaceDlg != NULL);
    pEditState->bFindOnly = bFindOnly;
    pEditState->pFindReplaceDlg->SetActiveWindow();
    pEditState->pFindReplaceDlg->ShowWindow(SW_SHOW);
    ASSERT_VALID(this);
}

void CRichEdit2View::OnFindNext(LPCTSTR lpszFind, BOOL bNext, BOOL bCase, BOOL bWord)
{
    ASSERT_VALID(this);

    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    pEditState->strFind = lpszFind;
    pEditState->bCase = bCase;
    pEditState->bWord = bWord;
    pEditState->bNext = bNext;

    if (!FindText(pEditState))
        TextNotFound(pEditState->strFind);
    else
        AdjustDialogPosition(pEditState->pFindReplaceDlg);
    ASSERT_VALID(this);
}

void CRichEdit2View::OnReplaceSel(LPCTSTR lpszFind, BOOL bNext, BOOL bCase,
    BOOL bWord, LPCTSTR lpszReplace)
{
    ASSERT_VALID(this);
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    pEditState->strFind = lpszFind;
    pEditState->strReplace = lpszReplace;
    pEditState->bCase = bCase;
    pEditState->bWord = bWord;
    pEditState->bNext = bNext;

    if (!SameAsSelected(pEditState->strFind, pEditState->bCase, pEditState->bWord))
    {
        if (!FindText(pEditState))
            TextNotFound(pEditState->strFind);
        else
            AdjustDialogPosition(pEditState->pFindReplaceDlg);
        return;
    }

    long start;
    long end;
    long length1;
    long length2;

    GetRichEditCtrl().GetSel(start, end);
    length1 = end - start;

    GetRichEditCtrl().ReplaceSel(pEditState->strReplace, TRUE);
    if (!FindText(pEditState))
    {
        TextNotFound(pEditState->strFind);
    }
    else
    {
        GetRichEditCtrl().GetSel(start, end);
        length2 = end - start;

        if (m_lInitialSearchPos < 0)
            m_lInitialSearchPos += (length2 - length1);

        AdjustDialogPosition(pEditState->pFindReplaceDlg);
    }
    ASSERT_VALID(this);
}

void CRichEdit2View::OnReplaceAll(LPCTSTR lpszFind, LPCTSTR lpszReplace, BOOL bCase, BOOL bWord)
{
    ASSERT_VALID(this);
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    pEditState->strFind = lpszFind;
    pEditState->strReplace = lpszReplace;
    pEditState->bCase = bCase;
    pEditState->bWord = bWord;
    pEditState->bNext = TRUE;

    CWaitCursor wait;
    // no selection or different than what looking for
    if (!SameAsSelected(pEditState->strFind, pEditState->bCase, pEditState->bWord))
    {
        if (!FindText(pEditState))
        {
            TextNotFound(pEditState->strFind);
            return;
        }
    }

    GetRichEditCtrl().HideSelection(TRUE, FALSE);
    do
    {
        GetRichEditCtrl().ReplaceSel(pEditState->strReplace, TRUE);
    } while (FindTextSimple(pEditState));
    TextNotFound(pEditState->strFind);
    GetRichEditCtrl().HideSelection(FALSE, FALSE);

    ASSERT_VALID(this);
}

LRESULT CRichEdit2View::OnFindReplaceCmd(WPARAM, LPARAM lParam)
{
    ASSERT_VALID(this);
    CFindReplaceDialog* pDialog = CFindReplaceDialog::GetNotifier(lParam);
    ASSERT(pDialog != NULL);
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    ASSERT(pDialog == pEditState->pFindReplaceDlg);
    if (pDialog->IsTerminating())
        pEditState->pFindReplaceDlg = NULL;
    else if (pDialog->FindNext())
    {
        OnFindNext(pDialog->GetFindString(), pDialog->SearchDown(),
            pDialog->MatchCase(), pDialog->MatchWholeWord());
    }
    else if (pDialog->ReplaceCurrent())
    {
        ASSERT(!pEditState->bFindOnly);
        OnReplaceSel(pDialog->GetFindString(),
            pDialog->SearchDown(), pDialog->MatchCase(), pDialog->MatchWholeWord(),
            pDialog->GetReplaceString());
    }
    else if (pDialog->ReplaceAll())
    {
        ASSERT(!pEditState->bFindOnly);
        OnReplaceAll(pDialog->GetFindString(), pDialog->GetReplaceString(),
            pDialog->MatchCase(), pDialog->MatchWholeWord());
    }
    ASSERT_VALID(this);
    return 0;
}

BOOL CRichEdit2View::SameAsSelected(LPCTSTR lpszCompare, BOOL bCase, BOOL /*bWord*/)
{
    CString strSelect = GetRichEditCtrl().GetSelText();
    return (bCase && lstrcmp(lpszCompare, strSelect) == 0) ||
        (!bCase && lstrcmpi(lpszCompare, strSelect) == 0);
}

BOOL CRichEdit2View::FindText(_AFX_RICHEDIT2_STATE* pEditState)
{
    ASSERT(pEditState != NULL);
    return FindText(pEditState->strFind, pEditState->bCase, pEditState->bWord);
}

BOOL CRichEdit2View::FindText(LPCTSTR lpszFind, BOOL bCase, BOOL bWord)
{
    ASSERT_VALID(this);
    CWaitCursor wait;
    return FindTextSimple(lpszFind, bCase, bWord);
}

BOOL CRichEdit2View::FindTextSimple(_AFX_RICHEDIT2_STATE* pEditState)
{
    ASSERT(pEditState != NULL);
    return FindTextSimple(pEditState->strFind, pEditState->bCase, pEditState->bWord);
}

BOOL CRichEdit2View::FindTextSimple(LPCTSTR lpszFind, BOOL bCase, BOOL bWord)
{
    USES_CONVERSION;
    ASSERT(lpszFind != NULL);
    FINDTEXTEX  ft;
    long        cchText;

    GETTEXTLENGTHEX textlen;

    textlen.flags = GTL_NUMCHARS;
#ifdef UNICODE
    textlen.codepage = 1200;            // Unicode code page
#else
    textlen.codepage = CP_ACP;
#endif

    cchText = (long)GetRichEditCtrl().SendMessage(
                                    EM_GETTEXTLENGTHEX,
                                    (WPARAM) &textlen,
                                    0);

    GetRichEditCtrl().GetSel(ft.chrg);

    if (m_bFirstSearch)
    {
        m_lInitialSearchPos = ft.chrg.cpMin;
        m_bFirstSearch = FALSE;
    }
    //REVIEW: Is this cast safe?
    ft.lpstrText = (LPTSTR)lpszFind;
    if (ft.chrg.cpMin != ft.chrg.cpMax) // i.e. there is a selection
        ft.chrg.cpMin++;

    DWORD dwFlags = bCase ? FR_MATCHCASE : 0;
    dwFlags |= bWord ? FR_WHOLEWORD : 0;
    dwFlags |= FR_DOWN;

    ft.chrg.cpMax = cchText;

    long index = GetRichEditCtrl().FindText(dwFlags, &ft);

    if (-1 == index && m_lInitialSearchPos > 0)
    {
        //
        // m_lInitialSearchPos pulls double duty as the point at which we
        // started searching and a flag which says if we've wrapped back
        // to the beginning of the text during a search.  If it's negative
        // (biased by the number of characters) then we've already wrapped
        //

        m_lInitialSearchPos = m_lInitialSearchPos - cchText;

        ft.chrg.cpMin = 0;
        ft.chrg.cpMax = cchText;
        index = GetRichEditCtrl().FindText(dwFlags, &ft);
    }

    if (-1 != index && m_lInitialSearchPos < 0)
        if (index >= (m_lInitialSearchPos + cchText) )
            index = -1;

    if (-1 != index)
        GetRichEditCtrl().SetSel(ft.chrgText);

    return (-1 != index);
}

long CRichEdit2View::FindAndSelect(DWORD dwFlags, FINDTEXTEX& ft)
{
    long index = GetRichEditCtrl().FindText(dwFlags, &ft);
    if (index != -1) // i.e. we found something
        GetRichEditCtrl().SetSel(ft.chrgText);
    return index;
}

void CRichEdit2View::TextNotFound(LPCTSTR lpszFind)
{
    ASSERT_VALID(this);
    m_bFirstSearch = TRUE;
    OnTextNotFound(lpszFind);
}

void CRichEdit2View::OnTextNotFound(LPCTSTR)
{
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2View diagnostics

#ifdef _DEBUG
void CRichEdit2View::AssertValid() const
{
    CCtrlView::AssertValid();
    ASSERT_VALID(&m_aPageStart);
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    if (pEditState->pFindReplaceDlg != NULL)
        ASSERT_VALID(pEditState->pFindReplaceDlg);
}

void CRichEdit2View::Dump(CDumpContext& dc) const
{
    CCtrlView::Dump(dc);
    AFX_DUMP1(dc, "\nm_aPageStart ", &m_aPageStart);
    AFX_DUMP0(dc, "\n Static Member Data:");
    _AFX_RICHEDIT2_STATE* pEditState = _afxRichEdit2State;
    if (pEditState->pFindReplaceDlg != NULL)
    {
        AFX_DUMP1(dc, "\npFindReplaceDlg = ",
            (void*)pEditState->pFindReplaceDlg);
        AFX_DUMP1(dc, "\nbFindOnly = ", pEditState->bFindOnly);
    }
    AFX_DUMP1(dc, "\nstrFind = ", pEditState->strFind);
    AFX_DUMP1(dc, "\nstrReplace = ", pEditState->strReplace);
    AFX_DUMP1(dc, "\nbCase = ", pEditState->bCase);
    AFX_DUMP1(dc, "\nbWord = ", pEditState->bWord);
    AFX_DUMP1(dc, "\nbNext = ", pEditState->bNext);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// OLE Client support and commands

BOOL CRichEdit2View::IsSelected(const CObject* pDocItem) const
{
    return (pDocItem == GetSelectedItem());
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc

CRichEdit2Doc::CRichEdit2Doc()
{
    m_bRTF = TRUE;
    m_bUnicode = FALSE;
    m_bUpdateObjectCache = FALSE;
    ASSERT_VALID(this);
}

CRichEdit2View* CRichEdit2Doc::GetView() const
{
    // find the first view - if there are no views
    // we must return NULL

    POSITION pos = GetFirstViewPosition();
    if (pos == NULL)
        return NULL;

    // find the first view that is a CRichEdit2View

    CView* pView;
    while (pos != NULL)
    {
        pView = GetNextView(pos);
        if (pView->IsKindOf(RUNTIME_CLASS(CRichEdit2View)))
            return (CRichEdit2View*) pView;
    }

    // can't find one--return NULL

    return NULL;
}

BOOL CRichEdit2Doc::IsModified()
{
    return GetView()->GetRichEditCtrl().GetModify();
}

void CRichEdit2Doc::SetModifiedFlag(BOOL bModified)
{
    GetView()->GetRichEditCtrl().SetModify(bModified);
    ASSERT(!!GetView()->GetRichEditCtrl().GetModify() == !!bModified);
}

COleClientItem* CRichEdit2Doc::GetInPlaceActiveItem(CWnd* pWnd)
{
    ASSERT_KINDOF(CRichEdit2View, pWnd);
    CRichEdit2View* pView = (CRichEdit2View*)pWnd;
    return pView->GetInPlaceActiveItem();
}

void CRichEdit2Doc::SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU)
{
    // we call CDocument and not COleServerDoc because we don't want to do the
    // SetHostNames stuff here.  The richedit will do it. And we tell the richedit
    // in SetTitle
    CDocument::SetPathName(lpszPathName, bAddToMRU);
}

void CRichEdit2Doc::SetTitle(LPCTSTR pwszTitle)
{
    USES_CONVERSION;
    COleServerDoc::SetTitle(pwszTitle);
    CRichEdit2View *pView = GetView();
    ASSERT(pView != NULL);
    ASSERT(pView->m_lpRichEditOle != NULL);
    LPCSTR pszAppName = WideToAnsiNewArray(AfxGetAppName());
    if (pszAppName)
    {
        LPCSTR pszTitle = WideToAnsiNewArray(pwszTitle);

        if (pszTitle)
        {
            pView->m_lpRichEditOle->SetHostNames(pszAppName, pszTitle);
            delete [] pszTitle;
        }
        delete [] pszAppName;
    }
}

CRichEdit2CntrItem* CRichEdit2Doc::LookupItem(LPOLEOBJECT lpobj) const
{
    POSITION pos = COleServerDoc::GetStartPosition();
    CRichEdit2CntrItem* pItem;
    while (pos != NULL)
    {
        pItem = (CRichEdit2CntrItem*) COleServerDoc::GetNextItem(pos);
        // delete item is right type and not under construction
        if (pItem->IsKindOf(RUNTIME_CLASS(CRichEdit2CntrItem)) &&
            pItem->m_lpObject == lpobj)
        {
            return pItem;
        }
    }
    return NULL;
}

CRichEdit2CntrItem* CRichEdit2Doc::CreateClientItem(REOBJECT* preo) const
{
    // cast away constness of this
    return new CRichEdit2CntrItem(preo, (CRichEdit2Doc*)this);
    // a derived class typically needs  to return its own item of a class
    // derived from CRichEdit2CntrItem
}

void CRichEdit2Doc::MarkItemsClear() const
{
    POSITION pos = COleServerDoc::GetStartPosition();
    CRichEdit2CntrItem* pItem;
    while (pos != NULL)
    {
        pItem = (CRichEdit2CntrItem*) COleServerDoc::GetNextItem(pos);
        // Mark item as not in use unless under construction (i.e. m_lpObject == NULL)
        if (pItem->IsKindOf(RUNTIME_CLASS(CRichEdit2CntrItem)))
            pItem->Mark( (pItem->m_lpObject == NULL) ? TRUE : FALSE);
    }
}

void CRichEdit2Doc::DeleteUnmarkedItems() const
{
    POSITION pos = COleServerDoc::GetStartPosition();
    CRichEdit2CntrItem* pItem;
    while (pos != NULL)
    {
        pItem = (CRichEdit2CntrItem*) COleServerDoc::GetNextItem(pos);
        // Mark item as not in use unless under construction (i.e. m_lpObject == NULL)
        if (pItem->IsKindOf(RUNTIME_CLASS(CRichEdit2CntrItem)) && !pItem->IsMarked())
            delete pItem;
    }
}

POSITION CRichEdit2Doc::GetStartPosition() const
{
    if (m_bUpdateObjectCache)
        ((CRichEdit2Doc*)this)->UpdateObjectCache(); //cast away const
    return COleServerDoc::GetStartPosition();
}

void CRichEdit2Doc::UpdateObjectCache()
{
    CRichEdit2View* pView = GetView();
    CRichEdit2CntrItem* pItem;
    if (pView != NULL)
    {
        ASSERT(pView->m_lpRichEditOle != NULL);
        MarkItemsClear();
        long i,nCount = pView->m_lpRichEditOle->GetObjectCount();
        for (i=0;i<nCount;i++)
        {
            CRe2Object reo; // needs to be in here so destructor called to release interfaces
            HRESULT hr = pView->m_lpRichEditOle->GetObject(i, &reo, REO_GETOBJ_ALL_INTERFACES);
            //reo interfaces are UNICODE
            ASSERT(SUCCEEDED(hr));
            if (GetScode(hr) == S_OK)
            {
                pItem = LookupItem(reo.poleobj);
                if (pItem == NULL)
                {
                    pItem = ((CRichEdit2Doc*)this)->CreateClientItem(&reo);
                    pItem->UpdateItemType();
                }
                ASSERT(pItem != NULL);
                pItem->Mark(TRUE);
            }
        }
        DeleteUnmarkedItems();
    }
    m_bUpdateObjectCache = FALSE;
}
/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc Attributes

COleClientItem* CRichEdit2Doc::GetPrimarySelectedItem(CView* pView)
{
    ASSERT(pView->IsKindOf(RUNTIME_CLASS(CRichEdit2View)));
    return ((CRichEdit2View*)pView)->GetSelectedItem();
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc Operations

void CRichEdit2Doc::DeleteContents()
{
    COleServerDoc::DeleteContents();
    CWaitCursor wait;
    CRichEdit2View *pView = GetView();
    if (pView != NULL)
    {
        pView->DeleteContents();
        pView->GetRichEditCtrl().SetModify(FALSE);
        ASSERT(pView->GetRichEditCtrl().GetModify() == FALSE);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc serialization

void CRichEdit2Doc::Serialize(CArchive& ar)
{
    CRichEdit2View *pView = GetView();
    if (pView != NULL)
        pView->Serialize(ar);
    // we don't call the base class COleServerDoc::Serialize
    // because we don't want the client items serialized
    // the client items are handled directly by the RichEdit control
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc diagnostics

#ifdef _DEBUG
void CRichEdit2Doc::AssertValid() const
{
    COleServerDoc::AssertValid();
}

void CRichEdit2Doc::Dump(CDumpContext& dc) const
{
    COleServerDoc::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2Doc commands

void CRichEdit2Doc::PreCloseFrame(CFrameWnd* pFrameArg)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pFrameArg);

    // turn off redraw so the user doesn't see the deactivation happening
    BOOL bSetRedraw = FALSE;
    if (pFrameArg->GetStyle() & WS_VISIBLE)
    {
        pFrameArg->SendMessage(WM_SETREDRAW, (WPARAM)FALSE);
        bSetRedraw = TRUE;
    }

    // deactivate any inplace active items on this frame
    GetView()->m_lpRichEditOle->InPlaceDeactivate();

    POSITION pos = GetStartPosition();
    CRichEdit2CntrItem* pItem;
    while (pos != NULL)
    {
        pItem = (CRichEdit2CntrItem*) GetNextClientItem(pos);
        if (pItem == NULL)
            break;
        ASSERT(pItem->IsKindOf(RUNTIME_CLASS(CRichEdit2CntrItem)));
        pItem->Close();
    }

    // turn redraw back on
    if (bSetRedraw)
        pFrameArg->SendMessage(WM_SETREDRAW, (WPARAM)TRUE);
}

void CRichEdit2Doc::UpdateModifiedFlag()
{
    // don't do anything here
    // let the richedit handle all of this
}

COleServerItem* CRichEdit2Doc::OnGetEmbeddedItem()
{
    ASSERT(FALSE);
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2CntrItem implementation

CRichEdit2CntrItem::CRichEdit2CntrItem(REOBJECT *preo, CRichEdit2Doc* pContainer)
    : COleClientItem(pContainer)
{
    m_bMark = FALSE;
    m_bLock = FALSE;
    if (preo != NULL)
    {
        ASSERT(preo->poleobj != NULL);
        ASSERT(preo->pstg != NULL);
        ASSERT(preo->polesite != NULL);
        m_lpObject = preo->poleobj;
        m_lpStorage = preo->pstg;
        m_lpClientSite = preo->polesite;
        m_lpObject->AddRef();
        m_lpStorage->AddRef();
        m_lpClientSite->AddRef();
    }
    else
    {
        m_lpObject = NULL;
        m_lpStorage = NULL;
        m_lpClientSite = NULL;
    }
}

CRichEdit2CntrItem::~CRichEdit2CntrItem()
{
    if (m_lpClientSite != NULL)
        m_lpClientSite->Release();
}

void CRichEdit2CntrItem::OnDeactivateUI(BOOL bUndoable)
{
    CView* pView = GetActiveView();
    if (pView != NULL)
    {
        ASSERT(pView->GetParentFrame() != NULL);
        pView->GetParentFrame()->SendMessage(WM_SETMESSAGESTRING,
            (WPARAM)AFX_IDS_IDLEMESSAGE);
    }
    COleClientItem::OnDeactivateUI(bUndoable);
}

HRESULT CRichEdit2CntrItem::ShowContainerUI(BOOL b)
{
    if (!CanActivate())
        return E_NOTIMPL;
    if (b)
    {
        OnDeactivateUI(FALSE);
        OnDeactivate();
    }
    else
    {
        OnActivate();
        OnActivateUI();
    }
    return S_OK;
}

BOOL CRichEdit2CntrItem::OnChangeItemPosition(const CRect& /*rectPos*/)
{
    ASSERT_VALID(this);

    // richedit handles this
    return FALSE;
}

BOOL CRichEdit2CntrItem::CanActivate()
{
    // Editing in-place while the server itself is being edited in-place
    //  does not work and is not supported.  So, disable in-place
    //  activation in this case.
    COleServerDoc* pDoc = DYNAMIC_DOWNCAST(COleServerDoc, GetDocument());
    if (pDoc != NULL && pDoc->IsInPlaceActive())
        return FALSE;

    // otherwise, rely on default behavior
    return COleClientItem::CanActivate();
}

HRESULT CRichEdit2CntrItem::GetWindowContext(LPOLEINPLACEFRAME* lplpFrame,
    LPOLEINPLACEUIWINDOW* lplpDoc, LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    CRect rc1,rc2;
    if (!CanActivate())
        return E_NOTIMPL;
    return m_xOleIPSite.GetWindowContext(lplpFrame, lplpDoc, &rc1, &rc2, lpFrameInfo);
}

BOOL CRichEdit2CntrItem::ConvertTo(REFCLSID clsidNew)
{
    USES_CONVERSION;
    LPRICHEDITOLE preole = GetDocument()->GetView()->m_lpRichEditOle;
    LPOLESTR lpOleStr;
    OleRegGetUserType(clsidNew, USERCLASSTYPE_FULL, &lpOleStr);
    LPCTSTR pwsz = OLE2CT(lpOleStr);
    BOOL bRet;
    LPSTR psz = WideToAnsiNewArray(pwsz);
    if (psz)
    {
        bRet = SUCCEEDED(preole->ConvertObject(REO_IOB_SELECTION, clsidNew, psz));
        delete [] psz;
    }
    else
    {
        bRet = FALSE;
    }

    CoTaskMemFree(lpOleStr);
    return (bRet);
}

BOOL CRichEdit2CntrItem::ActivateAs(LPCTSTR, REFCLSID clsidOld,
    REFCLSID clsidNew)
{
    LPRICHEDITOLE preole = GetDocument()->GetView()->m_lpRichEditOle;
    HRESULT hRes = preole->ActivateAs(clsidOld, clsidNew);
    return (SUCCEEDED(hRes));
}

void CRichEdit2CntrItem::SetDrawAspect(DVASPECT nDrawAspect)
{
    LPRICHEDITOLE preole = GetDocument()->GetView()->m_lpRichEditOle;
    preole->SetDvaspect(REO_IOB_SELECTION, nDrawAspect);
    COleClientItem::SetDrawAspect(nDrawAspect);
}

void CRichEdit2CntrItem::SyncToRichEditObject(REOBJECT& reo)
{
    COleClientItem::SetDrawAspect((DVASPECT)reo.dvaspect);
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2CntrItem diagnostics

#ifdef _DEBUG
void CRichEdit2CntrItem::AssertValid() const
{
    COleClientItem::AssertValid();
}

void CRichEdit2CntrItem::Dump(CDumpContext& dc) const
{
    COleClientItem::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////

LPOLECLIENTSITE CRichEdit2CntrItem::GetClientSite()
{
    if (m_lpClientSite == NULL)
    {
        CRichEdit2Doc* pDoc = DYNAMIC_DOWNCAST(CRichEdit2Doc, GetDocument());
        CRichEdit2View* pView = DYNAMIC_DOWNCAST(CRichEdit2View, pDoc->GetView());
        ASSERT(pView->m_lpRichEditOle != NULL);
        HRESULT hr = pView->m_lpRichEditOle->GetClientSite(&m_lpClientSite);
        if (hr != S_OK)
            AfxThrowOleException(hr);
    }
    ASSERT(m_lpClientSite != NULL);
    return m_lpClientSite;
}

/////////////////////////////////////////////////////////////////////////////

#ifndef _AFX_ENABLE_INLINES

static const char _szAfxWinInl[] = "afxrich2.inl";
#undef THIS_FILE
#define THIS_FILE _szAfxWinInl
#define _AFXRICH_INLINE
#include "afxrich2.inl"

#endif //_AFX_ENABLE_INLINES

/////////////////////////////////////////////////////////////////////////////

#ifdef AFX_INIT_SEG
#pragma code_seg(AFX_INIT_SEG)
#endif

IMPLEMENT_SERIAL(CRichEdit2CntrItem, COleClientItem, 0)
IMPLEMENT_DYNAMIC(CRichEdit2Doc, COleServerDoc)
IMPLEMENT_DYNCREATE(CRichEdit2View, CCtrlView)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\winctrl4.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "stdafx.h"
#include "stdafx2.h"
#include "wordpad.h"

#ifdef AFX_CMNCTL_SEG
#pragma code_seg(AFX_CMNCTL_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// _AFX_RICHEDIT2_STATE

_AFX_RICHEDIT2_STATE::~_AFX_RICHEDIT2_STATE()
{
	if (m_hInstRichEdit != NULL)
#ifndef _MAC
		::FreeLibrary(m_hInstRichEdit);
#else
		REFreeLibrary(m_hInstRichEdit);
#endif
}

_AFX_RICHEDIT2_STATE* AFX_CDECL AfxGetRichEdit2State()
{
	return _afxRichEdit2State.GetData();
}

/////////////////////////////////////////////////////////////////////////////
// CRichEdit2

BOOL CRichEdit2Ctrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	_AFX_RICHEDIT2_STATE* pState = _afxRichEdit2State;
	if (pState->m_hInstRichEdit == NULL)
	{
		pState->m_hInstRichEdit = LoadLibrary(L"RICHED20.DLL");
		if (pState->m_hInstRichEdit == NULL)
			return FALSE;
	}

	CWnd* pWnd = this;

	return pWnd->Create(_T("RICHEDIT"), NULL, dwStyle, rect, pParentWnd, nID);
}

int CRichEdit2Ctrl::GetLine(int nIndex, LPTSTR lpszBuffer) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex,
		(LPARAM)lpszBuffer);
}

int CRichEdit2Ctrl::LineIndex(int nLine /* = -1 */) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)::SendMessage(m_hWnd, EM_LINEINDEX, nLine, 0);
}

int CRichEdit2Ctrl::LineLength(int nLine /* = -1 */) const
{
	ASSERT(::IsWindow(m_hWnd));
	return (int)::SendMessage(m_hWnd, EM_LINELENGTH, nLine, 0);
}

void CRichEdit2Ctrl::LineScroll(int nLines, int nChars /* = 0 */)
{
	ASSERT(::IsWindow(m_hWnd));
	::SendMessage(m_hWnd, EM_LINESCROLL, nChars, nLines);
}

void CRichEdit2Ctrl::SetSel(long nStartChar, long nEndChar)
{
	ASSERT(::IsWindow(m_hWnd));
	CHARRANGE cr;
	cr.cpMin = nStartChar;
	cr.cpMax = nEndChar;
	::SendMessage(m_hWnd, EM_EXSETSEL, 0, (LPARAM)&cr);
}

BOOL CRichEdit2Ctrl::CanPaste(UINT nFormat) const
{
	ASSERT(::IsWindow(m_hWnd));
	COleMessageFilter* pFilter = AfxOleGetMessageFilter();
	if (pFilter != NULL)
		pFilter->BeginBusyState();
	BOOL b = (BOOL)::SendMessage(m_hWnd, EM_CANPASTE, nFormat, 0L);
	if (pFilter != NULL)
		pFilter->EndBusyState();
	return b;
}

void CRichEdit2Ctrl::PasteSpecial(UINT nClipFormat, DWORD dvAspect, HMETAFILE hMF)
{
	ASSERT(::IsWindow(m_hWnd));
	REPASTESPECIAL reps;
	reps.dwAspect = dvAspect;
	reps.dwParam = (DWORD_PTR)hMF;
	::SendMessage(m_hWnd, EM_PASTESPECIAL, nClipFormat, (LPARAM)&reps);
}

int CRichEdit2Ctrl::GetLine(int nIndex, LPTSTR lpszBuffer, int nMaxLength) const
{
	ASSERT(::IsWindow(m_hWnd));
	*(LPINT)lpszBuffer = nMaxLength;
	return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
}

void CRichEdit2Ctrl::GetSel(long& nStartChar, long& nEndChar) const
{
	ASSERT(::IsWindow(m_hWnd));
	CHARRANGE cr;
	::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);
	nStartChar = cr.cpMin;
	nEndChar = cr.cpMax;
}

CString CRichEdit2Ctrl::GetSelText() const
{
	ASSERT(::IsWindow(m_hWnd));

	CHARRANGE cr;
    LPTSTR    lpsz;

	cr.cpMin = cr.cpMax = 0;
	::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);

    try
    {
        // Need to use sizeof(WCHAR) to include DBCS characters
	    lpsz = (TCHAR*)_alloca((cr.cpMax - cr.cpMin + 1)*sizeof(WCHAR));

        // lpsz[0] = NULL;

        //
        // APPCOMPAT: The Ansi richedit2 control does not zero terminate the
        //         returned string if the current selection contains nothing
        //         but DBCS characters.
        //

        ZeroMemory(lpsz, (cr.cpMax - cr.cpMin + 1)*sizeof(WCHAR));

	    ::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpsz);
    }
    catch(...)
    {
        //
        // If _alloca fails it will throw an exception.  It's ok to return a
        // constant string here because it will immediately get copied into
        // a CString.
        //
        _resetstkoflw();
        lpsz = TEXT("");
    }

	return lpsz;
}

IRichEditOle* CRichEdit2Ctrl::GetIRichEditOle() const
{
	ASSERT(::IsWindow(m_hWnd));
	IRichEditOle *pRichItem = NULL;
	::SendMessage(m_hWnd, EM_GETOLEINTERFACE, 0, (LPARAM)&pRichItem);
	return pRichItem;
}

BOOL CRichEdit2Ctrl::SetDefaultCharFormat(CHARFORMAT &cf)
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT);
	return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, 0, (LPARAM)&cf);
}

BOOL CRichEdit2Ctrl::SetSelectionCharFormat(CHARFORMAT &cf)
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT);
	return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
}

BOOL CRichEdit2Ctrl::SetWordCharFormat(CHARFORMAT &cf)
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT);
	return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION|SCF_WORD, (LPARAM)&cf);
}

DWORD CRichEdit2Ctrl::GetDefaultCharFormat(CHARFORMAT &cf) const
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT);
	return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 0, (LPARAM)&cf);
}

DWORD CRichEdit2Ctrl::GetSelectionCharFormat(CHARFORMAT &cf) const
{
	ASSERT(::IsWindow(m_hWnd));
	cf.cbSize = sizeof(CHARFORMAT);
	return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 1, (LPARAM)&cf);
}

DWORD CRichEdit2Ctrl::GetParaFormat(PARAFORMAT &pf) const
{
	ASSERT(::IsWindow(m_hWnd));
	pf.cbSize = sizeof(PARAFORMAT);
	return (DWORD)::SendMessage(m_hWnd, EM_GETPARAFORMAT, 0, (LPARAM)&pf);
}

BOOL CRichEdit2Ctrl::SetParaFormat(PARAFORMAT &pf)
{
	ASSERT(::IsWindow(m_hWnd));
	pf.cbSize = sizeof(PARAFORMAT);
	return (BOOL)::SendMessage(m_hWnd, EM_SETPARAFORMAT, 0, (LPARAM)&pf);
}

/////////////////////////////////////////////////////////////////////////////

#pragma warning(disable: 4074)
#pragma init_seg(lib)

PROCESS_LOCAL(_AFX_RICHEDIT2_STATE, _afxRichEdit2State)

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\wordpdoc.cpp ===
// wordpdoc.cpp : implementation of the CWordPadDoc class
//
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.

#include "stdafx.h"

#include "wordpad.h"
#include "wordpdoc.h"
#include "wordpvw.h"
#include "cntritem.h"
#include "srvritem.h"
#include "formatba.h"

#include "mainfrm.h"
#include "ipframe.h"
#include "helpids.h"
#include "strings.h"
#include "unitspag.h"
#include "docopt.h"
#include "optionsh.h"

#include "multconv.h"

#include "fixhelp.h"

BOOL AskAboutFormatLoss(CWordPadDoc *pDoc) ;

//
// These defines are from ..\shell\userpri\uconvert.h
//

#define REVERSE_BYTE_ORDER_MARK   0xFFFE
#define BYTE_ORDER_MARK           0xFEFF

BOOL CheckForUnicodeTextFile(LPCTSTR lpszPathName) ;


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern BOOL AFXAPI AfxFullPath(LPTSTR lpszPathOut, LPCTSTR lpszFileIn);
extern UINT AFXAPI AfxGetFileTitle(LPCTSTR lpszPathName, LPTSTR lpszTitle, UINT nMax);

#ifndef OFN_EXPLORER
#define OFN_EXPLORER 0x00080000L
#endif


//
// This small class implements the "This is an unsupported save format" dialog.
// It's main purpose is to provide a place to hang the "always convert to RTF"
// checkbox.
//

class UnsupportedSaveFormatDialog : public CDialog
{
public:

    UnsupportedSaveFormatDialog()
        : CDialog(TEXT("UnsupportedSaveFormatDialog")),
          m_always_convert_to_rtf(false)
    {
    }

    BOOL ShouldAlwaysConvertToRTF() {return m_always_convert_to_rtf;}

protected:

    BOOL    m_always_convert_to_rtf;

    void DoDataExchange(CDataExchange *pDX)
    {
        CDialog::DoDataExchange(pDX);
        DDX_Check(pDX, IDC_ALWAYS_RTF, m_always_convert_to_rtf);
    }
};



/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc
IMPLEMENT_DYNCREATE(CWordPadDoc, CRichEdit2Doc)

BEGIN_MESSAGE_MAP(CWordPadDoc, CRichEdit2Doc)
    //{{AFX_MSG_MAP(CWordPadDoc)
    ON_COMMAND(ID_VIEW_OPTIONS, OnViewOptions)
    ON_UPDATE_COMMAND_UI(ID_OLE_VERB_POPUP, OnUpdateOleVerbPopup)
    ON_COMMAND(ID_FILE_SEND_MAIL, OnFileSendMail)
    ON_UPDATE_COMMAND_UI(ID_FILE_NEW, OnUpdateIfEmbedded)
    ON_UPDATE_COMMAND_UI(ID_FILE_OPEN, OnUpdateIfEmbedded)
    ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateIfEmbedded)
    ON_UPDATE_COMMAND_UI(ID_FILE_PRINT, OnUpdateIfEmbedded)
    ON_UPDATE_COMMAND_UI(ID_FILE_PRINT_DIRECT, OnUpdateIfEmbedded)
    ON_UPDATE_COMMAND_UI(ID_FILE_PRINT_PREVIEW, OnUpdateIfEmbedded)
    //}}AFX_MSG_MAP
    ON_UPDATE_COMMAND_UI(ID_FILE_SEND_MAIL, OnUpdateFileSendMail)
    ON_COMMAND(ID_OLE_EDIT_LINKS, OnEditLinks)
    ON_UPDATE_COMMAND_UI(ID_OLE_VERB_FIRST, CRichEdit2Doc::OnUpdateObjectVerbMenu)
    ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_CONVERT, CRichEdit2Doc::OnUpdateObjectVerbMenu)
    ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_LINKS, CRichEdit2Doc::OnUpdateEditLinksMenu)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc construction/destruction

CWordPadDoc::CWordPadDoc()
{
    m_nDocType = -1;
    m_nNewDocType = -1;
    m_short_filename = NULL;
}

BOOL CWordPadDoc::OnNewDocument()
{
    if (!CRichEdit2Doc::OnNewDocument())
        return FALSE;

    //correct type already set in theApp.m_nNewDocType;
    int nDocType = (IsEmbedded()) ? RD_EMBEDDED : theApp.m_nNewDocType;

    GetView()->SetDefaultFont(IsTextType(nDocType));
    SetDocType(nDocType);

    return TRUE;
}

void CWordPadDoc::ReportSaveLoadException(LPCTSTR lpszPathName,
    CException* e, BOOL bSaving, UINT nIDP)
{
    if (!m_bDeferErrors && e != NULL)
    {
        ASSERT_VALID(e);
        if (e->IsKindOf(RUNTIME_CLASS(CFileException)))
        {
            switch (((CFileException*)e)->m_cause)
            {
            case CFileException::fileNotFound:
            case CFileException::badPath:
                nIDP = AFX_IDP_FAILED_INVALID_PATH;
                break;
            case CFileException::diskFull:
                nIDP = AFX_IDP_FAILED_DISK_FULL;
                break;
            case CFileException::accessDenied:
                nIDP = AFX_IDP_FILE_ACCESS_DENIED;

                if (((CFileException*)e)->m_lOsError == ERROR_WRITE_PROTECT)
                    nIDP = IDS_WRITEPROTECT;
                break;
            case CFileException::tooManyOpenFiles:
                nIDP = IDS_TOOMANYFILES;
                break;
            case CFileException::directoryFull:
                nIDP = IDS_DIRFULL;
                break;
            case CFileException::sharingViolation:
                nIDP = IDS_SHAREVIOLATION;
                break;
            case CFileException::lockViolation:
            case CFileException::badSeek:
            case CFileException::generic:
            case CFileException::invalidFile:
            case CFileException::hardIO:
                nIDP = bSaving ? AFX_IDP_FAILED_IO_ERROR_WRITE :
                        AFX_IDP_FAILED_IO_ERROR_READ;
                break;
            default:
                break;
            }
            CString prompt;
            AfxFormatString1(prompt, nIDP, lpszPathName);
            AfxMessageBox(prompt, MB_ICONEXCLAMATION, nIDP);
            return;
        }
    }
    CRichEdit2Doc::ReportSaveLoadException(lpszPathName, e, bSaving, nIDP);
    return;
}


BOOL CheckForUnicodeTextFile(LPCTSTR lpszPathName)
{
    BOOL fRet = FALSE ;
    HANDLE hFile = (HANDLE) 0 ;
    WORD wBOM ;
    DWORD dwBytesRead = 0 ;
    BOOL bTmp ;

    if (lpszPathName == NULL)
    {
       return FALSE ;
    }

    hFile =     CreateFile(
                lpszPathName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL) ;

    if (hFile == INVALID_HANDLE_VALUE)
    {
       return FALSE ;
    }

    bTmp = ReadFile(
               hFile,
               &wBOM,
               sizeof(WORD),
               &dwBytesRead,
               NULL) ;

    if (bTmp)
    {
        if (dwBytesRead == sizeof(WORD))
        {
            if ( (wBOM == BYTE_ORDER_MARK) ||
                 (wBOM == REVERSE_BYTE_ORDER_MARK) )
            {
                fRet = TRUE ;

            }
        }
    }

    CloseHandle(hFile) ;

    return fRet ;
}

BOOL CWordPadDoc::OnOpenDocument2(LPCTSTR lpszPathName, bool defaultToText, BOOL* pbAccessDenied)
{
    if (pbAccessDenied)
        *pbAccessDenied = FALSE;

    if (m_lpRootStg != NULL) // we are embedded
    {
        // we really want to use the converter on this storage
        m_nNewDocType = RD_EMBEDDED;
    }
    else
    {
        if (theApp.cmdInfo.m_bForceTextMode)
            m_nNewDocType = RD_TEXT;
        else
        {
            CFileException fe;
            m_nNewDocType = GetDocTypeFromName(lpszPathName, fe, defaultToText);

            if (m_nNewDocType == -1)
            {
                if (defaultToText)
                {
                    ReportSaveLoadException(lpszPathName, &fe, FALSE,
                        AFX_IDP_FAILED_TO_OPEN_DOC);
                }
                return FALSE;
            }

            if (RD_FEWINWORD5 == m_nNewDocType)
            {
                AfxMessageBox(IDS_FEWINWORD5_DOC, MB_OK, MB_ICONINFORMATION);
                 if (pbAccessDenied)
                   *pbAccessDenied = TRUE;
                return FALSE;
            }

            if (m_nNewDocType == RD_TEXT && theApp.m_bForceOEM)
                m_nNewDocType = RD_OEMTEXT;
        }
        ScanForConverters();
        if (!doctypes[m_nNewDocType].bRead || DocTypeDisabled(m_nNewDocType))
        {
            CString str;
            CString strName = doctypes[m_nNewDocType].GetString(DOCTYPE_DOCTYPE);
            AfxFormatString1(str, IDS_CANT_LOAD, strName);
            AfxMessageBox(str, MB_OK|MB_ICONINFORMATION);
            if (pbAccessDenied)
               *pbAccessDenied = TRUE;
            return FALSE;
        }
    }

    if (RD_TEXT == m_nNewDocType)
    {
        if (CheckForUnicodeTextFile(lpszPathName))
            m_nNewDocType = RD_UNICODETEXT;
    }

    if (!CRichEdit2Doc::OnOpenDocument(lpszPathName))
        return FALSE;

    // Update any Ole links

    COleUpdateDialog(this).DoModal();

    return TRUE;
}

BOOL CWordPadDoc::OnOpenDocument(LPCTSTR lpszPathName)
{
    BOOL bAccessDenied = FALSE;

    if (OnOpenDocument2(lpszPathName, NO_DEFAULT_TO_TEXT, &bAccessDenied))
    {
        delete [] m_short_filename;
        m_short_filename = NULL;
        return TRUE;
    }

    // if we know we failed, don't try the short name
    if (bAccessDenied)
        return FALSE;

    LPTSTR short_filename = new TCHAR[MAX_PATH];

    if (NULL == short_filename)
        AfxThrowMemoryException();

    if (0 == ::GetShortPathName(lpszPathName, short_filename, MAX_PATH))
    {
        delete [] short_filename;

        if (ERROR_FILE_NOT_FOUND == GetLastError())
        {
            CFileException fe(CFileException::fileNotFound);
            ReportSaveLoadException(lpszPathName, &fe, FALSE,
                                    AFX_IDP_FAILED_TO_OPEN_DOC);
            return FALSE;
        }

        AfxThrowFileException(
                    CFileException::generic, 
                    GetLastError(), 
                    lpszPathName);
    }

    if (OnOpenDocument2(short_filename))
    {
        delete [] m_short_filename;
        m_short_filename = short_filename;
        return TRUE;
    }

    delete [] short_filename;

    return FALSE;
}

void CWordPadDoc::Serialize(CArchive& ar)
{
    COleMessageFilter* pFilter = AfxOleGetMessageFilter();
    ASSERT(pFilter != NULL);
    pFilter->EnableBusyDialog(FALSE);

    if (ar.IsLoading())
        SetDocType(m_nNewDocType);

    //
    // Strip (or output) the byte order mark if this is a Unicode file
    //

    if (m_bUnicode)
    {
        if (ar.IsLoading())
        {
            WORD byte_order_mark;

            ar >> byte_order_mark;

            // No support for byte-reversed files

            ASSERT(BYTE_ORDER_MARK == byte_order_mark);
        }
        else
        {
            ar << (WORD) BYTE_ORDER_MARK;
        }
    }

    CRichEdit2Doc::Serialize(ar);
    pFilter->EnableBusyDialog(TRUE);
}



BOOL AskAboutFormatLoss(CWordPadDoc *pDoc)
{
    UNREFERENCED_PARAMETER(pDoc);
    return (IDYES == AfxMessageBox(IDS_SAVE_FORMAT_TEXT, MB_YESNO));
}

BOOL CWordPadDoc::DoSave(LPCTSTR pszPathName, BOOL bReplace /*=TRUE*/)
    // Save the document data to a file
    // pszPathName = path name where to save document file
    // if pszPathName is NULL then the user will be prompted (SaveAs)
    // note: pszPathName can be different than 'm_strPathName'
    // if 'bReplace' is TRUE will change file name if successful (SaveAs)
    // if 'bReplace' is FALSE will not change path name (SaveCopyAs)
{
    if (NULL != pszPathName)
        if (pszPathName == m_strPathName && NULL != m_short_filename)
            pszPathName = m_short_filename;   

    CString newName = pszPathName;
    int nOrigDocType = m_nDocType;  //saved in case of SaveCopyAs or failure
    int nDocType ;

    //  newName     bWrite  type    result
    //  empty       TRUE    -       SaveAs dialog
    //  empty       FALSE   -       SaveAs dialog
    //  notempty    TRUE    -       nothing
    //  notempty    FALSE   W6      warn (change to wordpad, save as, cancel)
    //  notempty    FALSE   other   warn (save as, cancel)

    BOOL bModified = IsModified();

    ScanForConverters();

    BOOL bSaveAs = FALSE;

    if (newName.IsEmpty())
    {
        bSaveAs = TRUE;
    }
    else if (!doctypes[m_nDocType].bWrite)
    {
        if (!theApp.ShouldAlwaysConvertToRTF())
        {
            UnsupportedSaveFormatDialog dialog;
        
            if (IDOK != dialog.DoModal())
                return FALSE;

            if (dialog.ShouldAlwaysConvertToRTF())
                theApp.SetAlwaysConvertToRTF();
        }

        m_nDocType = RD_RICHTEXT;
    }

    if (m_lpRootStg == NULL && IsTextType(m_nDocType) &&
        !bSaveAs && !GetView()->IsFormatText())
    {
        if (!AskAboutFormatLoss(this))
            bSaveAs = TRUE;
    }

    GetView()->GetParentFrame()->RecalcLayout();

    if (bSaveAs)
    {
      newName = m_strPathName;

        if (bReplace && newName.IsEmpty())
        {
            newName = m_strTitle;
            int iBad = newName.FindOneOf(_T(" #%;/\\"));    // dubious filename
            if (iBad != -1)
                newName.ReleaseBuffer(iBad);

            // append the default suffix if there is one
            newName += GetExtFromType(m_nDocType);
        }

        nDocType = m_nDocType;

promptloop:

        if (!theApp.PromptForFileName(newName,
            bReplace ? AFX_IDS_SAVEFILE : AFX_IDS_SAVEFILECOPY,
            OFN_HIDEREADONLY | OFN_PATHMUSTEXIST, FALSE, &nDocType))
        {
            SetDocType(nOrigDocType, TRUE);
            return FALSE;       // don't even try to save
        }
      else
      {
          //
          // If we are transitioning from non-text to text, we need
          // to warn the user if there is any formatting / graphics
          // that will be lost
          //

          if (IsTextType(nDocType))
          {
              if (m_lpRootStg == NULL && !GetView()->IsFormatText())
              {
                if (!AskAboutFormatLoss(this))
                    goto promptloop;
              }
          }
      }

        SetDocType(nDocType, TRUE);
    }

    BeginWaitCursor();

    if (!OnSaveDocument(newName))
    {
        //
        // The original code deleted the file if an error occurred, on the
        // assumption that if we tried to save a file and something went wrong
        // but there was a file there after the save, the file is probably
        // bogus.  This fails if there is an existing file that doesn't have
        // write access but does have delete access.  How can this happen?
        // The security UI does not remove delete access when you remove
        // write access.
        //

        // restore orginal document type
        SetDocType(nOrigDocType, TRUE);
        EndWaitCursor();
        return FALSE;
    }

    EndWaitCursor();
    if (bReplace)
    {
        int nType = m_nDocType;
        SetDocType(nOrigDocType, TRUE);
        SetDocType(nType);
        // Reset the title and change the document name
        if (NULL == m_short_filename 
            || 0 != newName.CompareNoCase(m_short_filename))
        {
            SetPathName(newName, TRUE);

            // If we saved to a new filename, reset the short name
            if (bSaveAs)
            {
                delete [] m_short_filename;
                m_short_filename = NULL;
            }
        }
    }
    else // SaveCopyAs
    {
        SetDocType(nOrigDocType, TRUE);
        SetModifiedFlag(bModified);
    }
    return TRUE;        // success
}


class COIPF : public COleIPFrameWnd
{
public:
    CFrameWnd* GetMainFrame() { return m_pMainFrame;}
    CFrameWnd* GetDocFrame() { return m_pDocFrame;}
};

void CWordPadDoc::OnDeactivateUI(BOOL bUndoable)
{
    if (GetView()->m_bDelayUpdateItems)
        UpdateAllItems(NULL);
    SaveState(m_nDocType);
    CRichEdit2Doc::OnDeactivateUI(bUndoable);
    COIPF* pFrame = (COIPF*)m_pInPlaceFrame;
    if (pFrame != NULL)
    {
        if (pFrame->GetMainFrame() != NULL)
            ForceDelayed(pFrame->GetMainFrame());
        if (pFrame->GetDocFrame() != NULL)
            ForceDelayed(pFrame->GetDocFrame());
    }
}

void CWordPadDoc::ForceDelayed(CFrameWnd* pFrameWnd)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pFrameWnd);

    POSITION pos = pFrameWnd->m_listControlBars.GetHeadPosition();
    while (pos != NULL)
    {
        // show/hide the next control bar
        CControlBar* pBar =
            (CControlBar*)pFrameWnd->m_listControlBars.GetNext(pos);

        BOOL bVis = pBar->GetStyle() & WS_VISIBLE;
        UINT swpFlags = 0;
        if ((pBar->m_nStateFlags & CControlBar::delayHide) && bVis)
            swpFlags = SWP_HIDEWINDOW;
        else if ((pBar->m_nStateFlags & CControlBar::delayShow) && !bVis)
            swpFlags = SWP_SHOWWINDOW;
        pBar->m_nStateFlags &= ~(CControlBar::delayShow|CControlBar::delayHide);
        if (swpFlags != 0)
        {
            pBar->SetWindowPos(NULL, 0, 0, 0, 0, swpFlags|
                SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc Attributes
CLSID CWordPadDoc::GetClassID()
{
    return (m_pFactory == NULL) ? CLSID_NULL : m_pFactory->GetClassID();
}

void CWordPadDoc::SetDocType(int nNewDocType, BOOL bNoOptionChange)
{
    ASSERT(nNewDocType != -1);
    if (nNewDocType == m_nDocType)
        return;

    m_bRTF = !IsTextType(nNewDocType);
    m_bUnicode = (nNewDocType == RD_UNICODETEXT);

    if (bNoOptionChange)
        m_nDocType = nNewDocType;
    else
    {
        SaveState(m_nDocType);
        m_nDocType = nNewDocType;
        RestoreState(m_nDocType);
    }
}

CWordPadView* CWordPadDoc::GetView()
{
    POSITION pos = GetFirstViewPosition();
    return (CWordPadView* )GetNextView( pos );
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc Operations

CFile* CWordPadDoc::GetFile(LPCTSTR pszPathName, UINT nOpenFlags, CFileException* pException)
{
    CTrackFile* pFile = NULL;
    CFrameWnd* pWnd = GetView()->GetParentFrame();
#ifdef CONVERTERS
    ScanForConverters();

    // if writing use current doc type otherwise use new doc type
    int nType = (nOpenFlags & CFile::modeReadWrite) ? m_nDocType : m_nNewDocType;
    // m_nNewDocType will be same as m_nDocType except when opening a new file
    if (doctypes[nType].pszConverterName != NULL)
        pFile = new CConverter(doctypes[nType].pszConverterName, pWnd);
    else
#endif
    if (nType == RD_OEMTEXT)
        pFile = new COEMFile(pWnd);
    else
        pFile = new CTrackFile(pWnd);
    if (!pFile->Open(pszPathName, nOpenFlags, pException))
    {
        delete pFile;
        return NULL;
    }
    if (nOpenFlags & (CFile::modeWrite | CFile::modeReadWrite))
        pFile->m_dwLength = 0; // can't estimate this
    else
        pFile->m_dwLength = pFile->GetLength();
    return pFile;
}

CRichEdit2CntrItem* CWordPadDoc::CreateClientItem(REOBJECT* preo) const
{
    // cast away constness of this
    return new CWordPadCntrItem(preo, (CWordPadDoc*)this);
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc server implementation

COleServerItem* CWordPadDoc::OnGetEmbeddedItem()
{
    // OnGetEmbeddedItem is called by the framework to get the COleServerItem
    //  that is associated with the document.  It is only called when necessary.

    CEmbeddedItem* pItem = new CEmbeddedItem(this);
    ASSERT_VALID(pItem);
    return pItem;
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc serialization

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc diagnostics

#ifdef _DEBUG
void CWordPadDoc::AssertValid() const
{
    CRichEdit2Doc::AssertValid();
}

void CWordPadDoc::Dump(CDumpContext& dc) const
{
    CRichEdit2Doc::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWordPadDoc commands

int CWordPadDoc::MapType(int nType)
{
    if (nType == RD_OEMTEXT || nType == RD_UNICODETEXT)
        nType = RD_TEXT;
    else if (!IsInPlaceActive() && nType == RD_EMBEDDED)
        nType = RD_RICHTEXT;
    return nType;
}

void CWordPadDoc::OnViewOptions()
{
    int nType = MapType(m_nDocType);
    int nFirstPage = 3;
    if (nType == RD_TEXT)
        nFirstPage = 1;
    else if (nType == RD_RICHTEXT)
        nFirstPage = 2;
    else if (nType == RD_WRITE)
        nFirstPage = 4;
    else if (nType == RD_EMBEDDED)
        nFirstPage = 5;

    SaveState(nType);

    COptionSheet sheet(IDS_OPTIONS, NULL, nFirstPage);

    if (sheet.DoModal() == IDOK)
    {
        CWordPadView* pView = GetView();
        if (theApp.m_bWordSel)
            pView->GetRichEditCtrl().SetOptions(ECOOP_OR, ECO_AUTOWORDSELECTION);
        else
        {
            pView->GetRichEditCtrl().SetOptions(ECOOP_AND,
                ~(DWORD)ECO_AUTOWORDSELECTION);
        }
        RestoreState(nType);
    }
}

void CWordPadDoc::OnUpdateOleVerbPopup(CCmdUI* pCmdUI)
{
    pCmdUI->m_pParentMenu = pCmdUI->m_pMenu;
    CRichEdit2Doc::OnUpdateObjectVerbMenu(pCmdUI);
}

BOOL CWordPadDoc::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{
    if (nCode == CN_COMMAND && nID == ID_OLE_VERB_POPUP)
        nID = ID_OLE_VERB_FIRST;    
    return CRichEdit2Doc::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

void CWordPadDoc::SaveState(int nType)
{
    if (nType == -1)
        return;
    nType = MapType(nType);
    CWordPadView* pView = GetView();
    if (pView != NULL)
    {
        CFrameWnd* pFrame = pView->GetParentFrame();
        ASSERT(pFrame != NULL);
        // save current state
        pFrame->SendMessage(WPM_BARSTATE, 0, nType);
        theApp.GetDocOptions(nType).m_nWordWrap = pView->m_nWordWrap;
    }
}

void CWordPadDoc::RestoreState(int nType)
{
    if (nType == -1)
        return;
    nType = MapType(nType);
    CWordPadView* pView = GetView();
    if (pView != NULL)
    {
        CFrameWnd* pFrame = pView->GetParentFrame();
        ASSERT(pFrame != NULL);
        // set new state
        pFrame->SendMessage(WPM_BARSTATE, 1, nType);
        int nWrapNew = theApp.GetDocOptions(nType).m_nWordWrap;
        if (pView->m_nWordWrap != nWrapNew)
        {
            pView->m_nWordWrap = nWrapNew;
            pView->WrapChanged();
        }
    }
}

void CWordPadDoc::OnCloseDocument()
{
    SaveState(m_nDocType);
    CRichEdit2Doc::OnCloseDocument();
}

void CWordPadDoc::PreCloseFrame(CFrameWnd* pFrameArg)
{
    CRichEdit2Doc::PreCloseFrame(pFrameArg);
    SaveState(m_nDocType);
}

void CWordPadDoc::OnFileSendMail()
{
    if (m_strTitle.Find('.') == -1)
    {
        // add the extension because the default extension will be wrong
        CString strOldTitle = m_strTitle;
        m_strTitle += GetExtFromType(m_nDocType);
        CRichEdit2Doc::OnFileSendMail();
        m_strTitle = strOldTitle;
    }
    else
        CRichEdit2Doc::OnFileSendMail();
}

void CWordPadDoc::OnUpdateIfEmbedded(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(!IsEmbedded());
}


void CWordPadDoc::OnEditLinks()
{
    g_fDisableStandardHelp = TRUE ;

    SetHelpFixHook() ;

    COleLinksDialog dlg(this, GetRoutingView_());
    dlg.m_el.dwFlags |= ELF_DISABLECANCELLINK;
    dlg.DoModal();

    RemoveHelpFixHook() ;

    g_fDisableStandardHelp = FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\wordpdoc.h ===
// wordpdoc.h : interface of the CWordPadDoc class
//
// Copyright (C) 1992-1999 Microsoft Corporation
// All rights reserved.

class CFormatBar;
class CWordPadSrvrItem;
class CWordPadView;

class CWordPadDoc : public CRichEdit2Doc
{
protected: // create from serialization only
	CWordPadDoc();
	DECLARE_DYNCREATE(CWordPadDoc)

// Attributes
public:
	int     m_nDocType;
	int     m_nNewDocType;
    LPTSTR  m_short_filename;

	void SetDocType(int nDocType, BOOL bNoOptionChange = FALSE);
	CWordPadView* GetView();
	CLSID GetClassID();
	LPCTSTR GetSection();

// Operations
public:
	void SaveState(int nType);
	void RestoreState(int nType);
	virtual CFile* GetFile(LPCTSTR pszPathName, UINT nOpenFlags, 
		CFileException* pException);
	virtual BOOL DoSave(LPCTSTR pszPathName, BOOL bReplace = TRUE);
	int MapType(int nType);
	void ForceDelayed(CFrameWnd* pFrameWnd);

// Overrides
	virtual CRichEdit2CntrItem* CreateClientItem(REOBJECT* preo) const;
	virtual void OnDeactivateUI(BOOL bUndoable);
	virtual void Serialize(CArchive& ar);
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWordPadDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	BOOL OnOpenDocument2(LPCTSTR lpszPathName, bool defaultToText=true, BOOL* pbAccessDenied=NULL);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual void OnCloseDocument();
	virtual void ReportSaveLoadException(LPCTSTR lpszPathName, CException* e, BOOL bSaving, UINT nIDPDefault);
	protected:
	virtual COleServerItem* OnGetEmbeddedItem();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual void PreCloseFrame(CFrameWnd* pFrameArg);
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CWordPadDoc)
	afx_msg void OnViewOptions();
	afx_msg void OnUpdateOleVerbPopup(CCmdUI* pCmdUI);
	afx_msg void OnFileSendMail();
	afx_msg void OnUpdateIfEmbedded(CCmdUI* pCmdUI);
	afx_msg void OnEditLinks();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\wordpad.h ===
// wordpad.h : main header file for the WORDPAD application
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols
#include "options.h"
#include "afxtempl.h"
#include "msctf.h"

#define WPM_BARSTATE WM_USER

#define WORDPAD_HELP_FILE TEXT("WORDPAD.HLP")


// If MFC ever compiles with WINVER >= 0x500 then this cruft should be removed.
#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL    0x400000
#endif // WS_EX_LAYOUTRTL


// Free with delete[]
LPSTR WideToAnsiNewArray(LPCWSTR pwsz);
LPWSTR AnsiToWideNewArray(LPCSTR psz);


/////////////////////////////////////////////////////////////////////////////
// CWordPadApp:
// See wordpad.cpp for the implementation of this class
//

class CWordPadCommandLineInfo : public CCommandLineInfo
{
public:
    CWordPadCommandLineInfo() {m_bForceTextMode = FALSE;}
    BOOL m_bForceTextMode;
    virtual void ParseParam(const char* pszParam,BOOL bFlag,BOOL bLast);
};

class CWordPadApp : public CWinApp
{
private:

    enum InitializationPhase
    {
        InitializationPending       = 0,
        InitializingPrinter         = 1,
        UpdatingPrinterRelatedUI    = 2,
        UpdatingRegistry            = 3,
        InitializationComplete      = 99
    };

public:
    CWordPadApp();
    ~CWordPadApp();

//Attributes
    CWordPadCommandLineInfo cmdInfo;
    CDC m_dcScreen;
    LOGFONT m_lf;
    int m_nDefFont;
    static int m_nOpenMsg;
    static int m_nPrinterChangedMsg;
   static int m_nOLEHelpMsg;
    CRect m_rectPageMargin;
    CRect m_rectInitialFrame;
    BOOL m_bMaximized;
    BOOL m_bPromptForType;
    BOOL m_bWin4;
#ifndef _UNICODE
    BOOL m_bWin31;
#endif
    BOOL m_bLargeIcons;
    BOOL m_bForceTextMode;
    BOOL m_bWordSel;
    BOOL m_bForceOEM;
    BOOL m_always_convert_to_rtf;
    int m_nFilterIndex;
    int m_nNewDocType;
    CDocOptions m_optionsText;
    CDocOptions m_optionsRTF;
    CDocOptions m_optionsWord; //wrap to ruler
    CDocOptions m_optionsWrite; //wrap to ruler
    CDocOptions m_optionsIP;    //wrap to ruler
    CDocOptions m_optionsNull;
    CList<HWND, HWND> m_listPrinterNotify;

    BOOL IsDocOpen(LPCTSTR lpszFileName);

// Get
    int GetUnits() {return m_nUnits;}
    int GetTPU() { return GetTPU(m_nUnits);}
    int GetTPU(int n) { return m_units[n].m_nTPU;}
    LPCTSTR GetAbbrev() { return m_units[m_nUnits].m_strAbbrev;}
    LPCTSTR GetAbbrev(int n) { return m_units[n].m_strAbbrev;}
    const CUnit& GetUnit() {return m_units[m_nUnits];}
    CDockState& GetDockState(int nDocType, BOOL bPrimary = TRUE);
    CDocOptions& GetDocOptions(int nDocType);
    CDocOptions& GetDocOptions() {return GetDocOptions(m_nNewDocType);}
    BOOL ShouldAlwaysConvertToRTF() {return m_always_convert_to_rtf;}

// Set
    void SetUnits(int n);
    void SetAlwaysConvertToRTF() {m_always_convert_to_rtf = TRUE;}

// Operations
    void RegisterFormats();
    static BOOL CALLBACK StaticEnumProc(HWND hWnd, LPARAM lParam);
    void UpdateRegistry();
    void NotifyPrinterChanged(BOOL bUpdatePrinterSelection = FALSE);
    BOOL PromptForFileName(CString& fileName, UINT nIDSTitle, DWORD dwFlags,
        BOOL bOpenFileDialog, int* pType = NULL);

    BOOL ParseMeasurement(TCHAR* buf, int& lVal);
    void PrintTwips(WCHAR* buf, int cchBuf, int nValue, int nDecimal);
    void SaveOptions();
    void LoadOptions();
    void LoadAbbrevStrings();
    HGLOBAL CreateDevNames();
    void EnsurePrinterIsInitialized();

   HGLOBAL GetDevNames(void)
   {
       return m_hDevNames ;
   }

// Overrides
    BOOL IsIdleMessage(MSG* pMsg);
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWordPadApp)
    public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
    virtual BOOL OnDDECommand(LPTSTR lpszCommand);
    virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    //}}AFX_VIRTUAL

// Implementation
    COleTemplateServer m_server;
        // Server object for document creation

    //{{AFX_MSG(CWordPadApp)
    afx_msg void OnAppAbout();
    afx_msg void OnFileNew();
    afx_msg void OnFileOpen();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
private:
    int m_nUnits;
    static const int m_nPrimaryNumUnits;
    static const int m_nNumUnits;
    static CUnit m_units[];

// Initialization

    volatile InitializationPhase m_initialization_phase;
    CWinThread *                 m_pInitializationThread;
// Cicero process atoms
    ATOM m_atomEnableCTF;
    ATOM m_atomProcessCTF;

    static UINT AFX_CDECL DoDeferredInitialization(LPVOID pvWordPadApp);
};

/////////////////////////////////////////////////////////////////////////////

extern CWordPadApp theApp;
//inline CWordPadApp* GetWordPadApp() {return (CWordPadApp*)AfxGetApp();}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\wordpvw.cpp ===
// wordpvw.cpp : implementation of the CWordPadView class
//
// Copyright (C) 1992-1999 Microsoft Corporation


#include "stdafx.h"
#include "wordpad.h"
#include "cntritem.h"
#include "srvritem.h"

#include "wordpdoc.h"
#include "wordpvw.h"
#include "formatta.h"
#include "datedial.h"
#include "formatpa.h"
#include "formatba.h"
#include "ruler.h"
#include "strings.h"
#include "colorlis.h"
#include "pageset.h"
#include <penwin.h>
#include "fixhelp.h"

#include <afxprntx.h>
#include "dlgprnt2.cpp"
#ifndef PD_CURRENTPAGE
#define PD_CURRENTPAGE                 0x00400000
#define PD_NOCURRENTPAGE               0x00800000
#endif

extern CLIPFORMAT cfEmbeddedObject;
extern CLIPFORMAT cfRTO;

BOOL g_fInternalDragDrop = FALSE ;
BOOL g_fRightButtonDrag = FALSE;

#ifdef _DEBUG
#undef THIS_FILE
#endif


BOOL CWordPadView::m_bIsMirrored = FALSE;


BOOL CCharFormat::operator==(CCharFormat& cf)
{
    return
        dwMask == cf.dwMask
        && dwEffects == cf.dwEffects
        && yHeight == cf.yHeight
        && yOffset == cf.yOffset
        && crTextColor == cf.crTextColor
        && bPitchAndFamily == cf.bPitchAndFamily
        && (lstrcmp(szFaceName, cf.szFaceName) == 0);
}

BOOL CParaFormat::operator==(PARAFORMAT& pf)
{
    if(
        dwMask != pf.dwMask
        || wNumbering != pf.wNumbering
        || wReserved != pf.wReserved
        || dxStartIndent != pf.dxStartIndent
        || dxRightIndent != pf.dxRightIndent
        || dxOffset != pf.dxOffset
        || cTabCount != pf.cTabCount
        )
    {
        return FALSE;
    }
    for (int i=0;i<pf.cTabCount;i++)
    {
        if (rgxTabs[i] != pf.rgxTabs[i])
            return FALSE;
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadView

IMPLEMENT_DYNCREATE(CWordPadView, CRichEdit2View)

//WM_WININICHANGE -- default printer might have changed
//WM_FONTCHANGE -- pool of fonts changed
//WM_DEVMODECHANGE -- printer settings changes

BEGIN_MESSAGE_MAP(CWordPadView, CRichEdit2View)
ON_COMMAND(ID_OLE_INSERT_NEW, OnInsertObject)
ON_COMMAND(ID_CANCEL_EDIT_CNTR, OnCancelEditCntr)
ON_COMMAND(ID_CANCEL_EDIT_SRVR, OnCancelEditSrvr)
//{{AFX_MSG_MAP(CWordPadView)
ON_COMMAND(ID_PAGE_SETUP, OnPageSetup)
ON_COMMAND(ID_CHAR_BOLD, OnCharBold)
ON_UPDATE_COMMAND_UI(ID_CHAR_BOLD, OnUpdateCharBold)
ON_COMMAND(ID_CHAR_ITALIC, OnCharItalic)
ON_UPDATE_COMMAND_UI(ID_CHAR_ITALIC, OnUpdateCharItalic)
ON_COMMAND(ID_CHAR_UNDERLINE, OnCharUnderline)
ON_UPDATE_COMMAND_UI(ID_CHAR_UNDERLINE, OnUpdateCharUnderline)
ON_COMMAND(ID_PARA_CENTER, OnParaCenter)
ON_UPDATE_COMMAND_UI(ID_PARA_CENTER, OnUpdateParaCenter)
ON_COMMAND(ID_PARA_LEFT, OnParaLeft)
ON_UPDATE_COMMAND_UI(ID_PARA_LEFT, OnUpdateParaLeft)
ON_COMMAND(ID_PARA_RIGHT, OnParaRight)
ON_UPDATE_COMMAND_UI(ID_PARA_RIGHT, OnUpdateParaRight)
ON_WM_CREATE()
ON_COMMAND(ID_INSERT_DATE_TIME, OnInsertDateTime)
ON_COMMAND(ID_FORMAT_PARAGRAPH, OnFormatParagraph)
ON_COMMAND(ID_FORMAT_FONT, OnFormatFont)
ON_COMMAND(ID_EDIT_PASTE_SPECIAL, OnEditPasteSpecial)
ON_COMMAND(ID_OLE_EDIT_PROPERTIES, OnEditProperties)
ON_COMMAND(ID_EDIT_FIND, OnEditFind)
ON_COMMAND(ID_EDIT_REPLACE, OnEditReplace)
ON_COMMAND(ID_FORMAT_TABS, OnFormatTabs)
ON_COMMAND(ID_COLOR16, OnColorDefault)
ON_WM_TIMER()
ON_WM_DESTROY()
ON_WM_MEASUREITEM()
ON_COMMAND(ID_PEN_BACKSPACE, OnPenBackspace)
ON_COMMAND(ID_PEN_NEWLINE, OnPenNewline)
ON_COMMAND(ID_PEN_PERIOD, OnPenPeriod)
ON_COMMAND(ID_PEN_SPACE, OnPenSpace)
ON_WM_SIZE()
ON_WM_KEYDOWN()
ON_COMMAND(ID_FILE_PRINT, OnFilePrint)
ON_COMMAND(ID_FILE_PRINT_DIRECT, OnFilePrint)
ON_WM_DROPFILES()
ON_COMMAND(ID_PEN_LENS, OnPenLens)
ON_COMMAND(ID_PEN_TAB, OnPenTab)
ON_COMMAND(ID_DELAYED_INVALIDATE, OnDelayedInvalidate)
ON_WM_PALETTECHANGED()
ON_WM_QUERYNEWPALETTE()
ON_WM_WININICHANGE()
//}}AFX_MSG_MAP
// Standard printing commands
ON_COMMAND(ID_INSERT_BULLET, CRichEdit2View::OnBullet)
ON_UPDATE_COMMAND_UI(ID_INSERT_BULLET, CRichEdit2View::OnUpdateBullet)
ON_COMMAND(ID_FILE_PRINT_PREVIEW, OnFilePrintPreview)
ON_COMMAND_RANGE(ID_COLOR0, ID_COLOR16, OnColorPick)
ON_EN_CHANGE(AFX_IDW_PANE_FIRST, OnEditChange)
ON_WM_MOUSEACTIVATE()
ON_REGISTERED_MESSAGE(CWordPadApp::m_nPrinterChangedMsg, OnPrinterChangedMsg)
ON_NOTIFY(FN_GETFORMAT, ID_VIEW_FORMATBAR, OnGetCharFormat)
ON_NOTIFY(FN_SETFORMAT, ID_VIEW_FORMATBAR, OnSetCharFormat)
ON_NOTIFY(NM_SETFOCUS, ID_VIEW_FORMATBAR, OnBarSetFocus)
ON_NOTIFY(NM_KILLFOCUS, ID_VIEW_FORMATBAR, OnBarKillFocus)
ON_NOTIFY(NM_RETURN, ID_VIEW_FORMATBAR, OnBarReturn)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWordPadView construction/destruction

CWordPadView::CWordPadView()
{
    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
    m_uTimerID = 0;
    m_bDelayUpdateItems = FALSE;
    m_bOnBar = FALSE;
    m_bInPrint = FALSE;
    m_nPasteType = 0;
    m_rectMargin = theApp.m_rectPageMargin;
}

BOOL CWordPadView::PreCreateWindow(CREATESTRUCT& cs)
{
    BOOL bRes = CRichEdit2View::PreCreateWindow(cs);
    cs.style |= ES_SELECTIONBAR;
    return bRes;
}



/////////////////////////////////////////////////////////////////////////////
// CWordPadView attributes

BOOL CWordPadView::IsFormatText()
{
    // this function checks to see if any formatting is not default text
    BOOL bRes = FALSE;
    CHARRANGE cr;
    CCharFormat cf;
    CParaFormat pf;
    GetRichEditCtrl().GetSel(cr);
    GetRichEditCtrl().HideSelection(TRUE, FALSE);
    GetRichEditCtrl().SetSel(0,-1);

    if (!(GetRichEditCtrl().GetSelectionType() & (SEL_OBJECT|SEL_MULTIOBJECT)))
    {
        GetRichEditCtrl().GetSelectionCharFormat(cf);

        //
        // Richedit sometimes returns these masks which are not important to us
        //

        cf.dwMask &= ~(CFM_LINK | CFM_CHARSET) ;

        //
        // Richedit sometimes returns the wrong thing here.  This is not that
        // important for the CHARFORMAT comparison, but it fouls things up if
        // we don't work around it.
        //

        CCharFormat   defCF;
        GetDefaultFont(defCF, TRUE);

        cf.bPitchAndFamily = defCF.bPitchAndFamily ;

        if (cf == defCF)
        {
            GetRichEditCtrl().GetParaFormat(pf);

            // These get reset in SetDefaultFont so be symmetric.
            pf.dwMask &= ~ (PFM_RTLPARA | PFM_ALIGNMENT);

            if (pf == m_defParaFormat)
                bRes = TRUE;
        }
    }

    GetRichEditCtrl().SetSel(cr);
    GetRichEditCtrl().HideSelection(FALSE, FALSE);
    return bRes;
}

HMENU CWordPadView::GetContextMenu(WORD, LPOLEOBJECT, CHARRANGE* )
{
    CRichEdit2CntrItem* pItem = GetSelectedItem();
    if (pItem == NULL || !pItem->IsInPlaceActive())
    {
        CMenu menuText;
        menuText.LoadMenu(IDR_TEXT_POPUP);
        CMenu* pMenuPopup = menuText.GetSubMenu(0);
        menuText.RemoveMenu(0, MF_BYPOSITION);
        if (!GetSystemMetrics(SM_PENWINDOWS))
        {
            //delete pen specific stuff
            // remove Insert Keystrokes
            pMenuPopup->DeleteMenu(ID_PEN_LENS, MF_BYCOMMAND);
            int nIndex = pMenuPopup->GetMenuItemCount()-1; //index of last item
            // remove Edit Text...
            pMenuPopup->DeleteMenu(nIndex, MF_BYPOSITION);
            // remove separator
            pMenuPopup->DeleteMenu(nIndex-1, MF_BYPOSITION);
        }
        return pMenuPopup->Detach();
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadView operations
void CWordPadView::MirrorTheContainer(BOOL bMirror)
{
    // if WordPad not mirrored, then don't do anything
    LONG lExStyle;
    if (!m_bIsMirrored)
       return;
        
    CWnd *pWnd = AfxGetMainWnd() ;
    if (NULL == pWnd)
        return ;
    lExStyle = (LONG)::GetWindowLongPtr(pWnd->m_hWnd , GWL_EXSTYLE);
    if (bMirror)
       lExStyle |=  WS_EX_LAYOUTRTL;
    else
       lExStyle &= ~WS_EX_LAYOUTRTL;
   ::SetWindowLongPtr(pWnd->m_hWnd , GWL_EXSTYLE , lExStyle);
}

void CWordPadView::WrapChanged()
{
    CWaitCursor wait;
    CFrameWnd* pFrameWnd = GetParentFrame();
    ASSERT(pFrameWnd != NULL);
    pFrameWnd->SetMessageText(IDS_FORMATTING);
    CWnd* pBarWnd = pFrameWnd->GetMessageBar();
    if (pBarWnd != NULL)
        pBarWnd->UpdateWindow();

    CRichEdit2View::WrapChanged();

    pFrameWnd->SetMessageText(AFX_IDS_IDLEMESSAGE);
    if (pBarWnd != NULL)
        pBarWnd->UpdateWindow();
}

void CWordPadView::SetUpdateTimer()
{
    if (m_uTimerID != 0) // if outstanding timer kill it
        KillTimer(m_uTimerID);
    m_uTimerID = SetTimer(1, 1000, NULL); //set a timer for 1000 milliseconds
    if (m_uTimerID == 0) // no timer available so force update now
        GetDocument()->UpdateAllItems(NULL);
    else
        m_bDelayUpdateItems = TRUE;
}

void CWordPadView::DeleteContents()
{
    ASSERT_VALID(this);
    ASSERT(m_hWnd != NULL);
    CRichEdit2View::DeleteContents();
    SetDefaultFont(IsTextType(GetDocument()->m_nNewDocType));
}

void CWordPadView::SetDefaultFont(BOOL bText)
{
    ASSERT_VALID(this);
    ASSERT(m_hWnd != NULL);

    CCharFormat cf;

    m_bSyncCharFormat = m_bSyncParaFormat = TRUE;
    // set the default character format -- the FALSE makes it the default
    GetDefaultFont(cf, bText);
    GetRichEditCtrl().SetSel(0,-1);
    GetRichEditCtrl().SetDefaultCharFormat(cf);
    GetRichEditCtrl().SetSelectionCharFormat(cf);

    //
    // Setting the charformat with a NULL font name automagically sets
    // the reading direction and alignment.  Don't muck with it.
    //

    m_defParaFormat.dwMask &= ~ (PFM_RTLPARA | PFM_ALIGNMENT);
    
    GetRichEditCtrl().SetParaFormat(m_defParaFormat);

    GetRichEditCtrl().SetSel(0,0);
    GetRichEditCtrl().EmptyUndoBuffer();
    GetRichEditCtrl().SetModify(FALSE);
    ASSERT_VALID(this);
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadView drawing

/////////////////////////////////////////////////////////////////////////////
// CWordPadView printing

void CWordPadView::OnBeginPrinting(CDC* pDC, CPrintInfo* printInfo)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    // initialize page start vector
    ASSERT(m_aPageStart.GetSize() == 0);
    ASSERT(NULL != printInfo);
    ASSERT(NULL != printInfo->m_pPD);

    OnPrinterChanged(*pDC);

    //
    // Copy some flags from PRINTDLGEX to PRINTDLG that mfc doesn't
    //

    C_PrintDialogEx *pPDEx = (C_PrintDialogEx *) printInfo->m_pPD;
    pPDEx->m_pd.Flags |= pPDEx->m_pdex.Flags & PD_SELECTION;

    m_aPageStart.Add(0);
    ASSERT(m_aPageStart.GetSize() > 0);

    if (printInfo->m_pPD->PrintSelection())
    {
        CHARRANGE   range;

        GetRichEditCtrl().GetSel(range);
        m_aPageStart[0] = range.cpMin;
    }

    GetRichEditCtrl().FormatRange(NULL, FALSE); // required by RichEdit to clear out cache

    ASSERT_VALID(this);
}

void CWordPadView::OnPrint(CDC* pDC, CPrintInfo* pInfo)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    ASSERT(pInfo != NULL);
    ASSERT(pInfo->m_bContinuePrinting);
    ASSERT(NULL != pInfo->m_pPD);

    UINT nPage              = pInfo->m_nCurPage;
    ASSERT(nPage <= (UINT)m_aPageStart.GetSize());

    long nIndex             = (long) m_aPageStart[nPage-1];
    BOOL bPrintSelection    = pInfo->m_pPD->PrintSelection();
    long nFinalCharIndex;

    if (bPrintSelection)
    {
        CHARRANGE range;

        GetRichEditCtrl().GetSel(range);

        nFinalCharIndex = range.cpMax;
    }
    else
    {
        GETTEXTLENGTHEX textlen;

        textlen.flags = GTL_DEFAULT;
#ifdef UNICODE
        textlen.codepage = 1200;            // Unicode code page
#else
        textlen.codepage = CP_ACP;
#endif

        nFinalCharIndex = (long)this->SendMessage(
            EM_GETTEXTLENGTHEX,
            (WPARAM) &textlen,
            0);
    }

    // print as much as possible in the current page.
    nIndex = PrintPage(pDC, nIndex, nFinalCharIndex);

    if (nIndex >= nFinalCharIndex)
    {
        TRACE0("End of Document\n");
        pInfo->SetMaxPage(nPage);
        pInfo->m_bContinuePrinting = FALSE;
    }

    // update pagination information for page just printed
    if (nPage == (UINT)m_aPageStart.GetSize())
    {
        if (nIndex < nFinalCharIndex)
            m_aPageStart.Add(nIndex);
    }
    else
    {
        ASSERT(nPage+1 <= (UINT)m_aPageStart.GetSize());
        ASSERT(nIndex == (long)m_aPageStart[nPage+1-1]);
    }

    if (pInfo != NULL && pInfo->m_bPreview)
        DrawMargins(pDC);
}

void CWordPadView::DrawMargins(CDC* pDC)
{
    if (pDC->m_hAttribDC != NULL)
    {
        CRect rect;
        rect.left = m_rectMargin.left;
        rect.right = m_sizePaper.cx - m_rectMargin.right;
        rect.top = m_rectMargin.top;
        rect.bottom = m_sizePaper.cy - m_rectMargin.bottom;
        //rect in twips
        int logx = ::GetDeviceCaps(pDC->m_hDC, LOGPIXELSX);
        int logy = ::GetDeviceCaps(pDC->m_hDC, LOGPIXELSY);
        rect.left = MulDiv(rect.left, logx, 1440);
        rect.right = MulDiv(rect.right, logx, 1440);
        rect.top = MulDiv(rect.top, logy, 1440);
        rect.bottom = MulDiv(rect.bottom, logy, 1440);
        CPen pen(PS_DOT, 0, pDC->GetTextColor());
        CPen* ppen = pDC->SelectObject(&pen);
        pDC->MoveTo(0, rect.top);
        pDC->LineTo(10000, rect.top);
        pDC->MoveTo(rect.left, 0);
        pDC->LineTo(rect.left, 10000);
        pDC->MoveTo(0, rect.bottom);
        pDC->LineTo(10000, rect.bottom);
        pDC->MoveTo(rect.right, 0);
        pDC->LineTo(rect.right, 10000);
        pDC->SelectObject(ppen);
    }
}

BOOL CWordPadView::OnPreparePrinting(CPrintInfo* pInfo)
{
    CWordPadApp *pApp = NULL ;

    //
    // Swap out the default print dialog with the new PrintDlgEx version.
    // Hopefully MFC will come up with a better way to do this sometime.
    //

    C_PrintDialogEx *pPDEx = new C_PrintDialogEx(FALSE, PD_RETURNDC | PD_ALLPAGES | PD_NOSELECTION | PD_NOCURRENTPAGE | PD_USEDEVMODECOPIESANDCOLLATE);

    if (NULL == pPDEx)
        return FALSE;

    m_oldprintdlg = pInfo->m_pPD;
    pInfo->m_pPD = pPDEx;
    pInfo->SetMinPage(1);
    pInfo->SetMaxPage(0xffff);

    pInfo->m_pPD->m_pd.nFromPage = 1;
    pInfo->m_pPD->m_pd.nToPage = 1;

    pApp = (CWordPadApp *) AfxGetApp() ;

    if (NULL != pApp)
    {
        if ( (pApp->cmdInfo.m_nShellCommand == CCommandLineInfo::FilePrintTo) ||
            (pApp->cmdInfo.m_nShellCommand == CCommandLineInfo::FilePrint) )
        {
            if (pInfo->m_pPD->m_pd.hDevNames == NULL)
            {
                HGLOBAL hDn = pApp->GetDevNames() ;

                if (hDn != NULL)
                {
                    pInfo->m_pPD->m_pd.hDevNames = hDn ;
                }
            }
        }
    }

    if (SEL_EMPTY != GetRichEditCtrl().GetSelectionType())
    {
        pInfo->m_pPD->m_pd.Flags = pInfo->m_pPD->m_pd.Flags & ~PD_NOSELECTION;
        pPDEx->m_pdex.Flags = pPDEx->m_pdex.Flags & ~PD_NOSELECTION;
    }

    return DoPreparePrinting(pInfo);
}

void CWordPadView::OnEndPrinting(CDC*dc, CPrintInfo*pInfo)
{
    ASSERT_VALID(this);

    //
    // Swap the original print dlg back
    //

    delete (C_PrintDialogEx *) pInfo->m_pPD;
    pInfo->m_pPD = m_oldprintdlg;
    m_oldprintdlg = NULL;

    CRichEdit2View::OnEndPrinting(dc, pInfo);
}

void CWordPadView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);
    ASSERT(pInfo != NULL);  // overriding OnPaint -- never get this.

    if (!pInfo->m_bContinuePrinting)
        return;

    pDC->SetMapMode(MM_TEXT);

    if (pInfo->m_nCurPage > (UINT)m_aPageStart.GetSize() &&
        !PaginateTo(pDC, pInfo))
    {
        // can't paginate to that page, thus cannot print it.
        pInfo->m_bContinuePrinting = FALSE;
    }
    ASSERT_VALID(this);
}

BOOL CWordPadView::PaginateTo(CDC* pDC, CPrintInfo* pInfo)
// attempts pagination to pInfo->m_nCurPage, TRUE == success
{
    ASSERT_VALID(this);
    ASSERT_VALID(pDC);

    CRect rectSave = pInfo->m_rectDraw;
    UINT nPageSave = pInfo->m_nCurPage;
    ASSERT(nPageSave > 1);
    ASSERT(nPageSave >= (UINT)m_aPageStart.GetSize());
    pDC->IntersectClipRect(0, 0, 0, 0);
    pInfo->m_nCurPage = (UINT)m_aPageStart.GetSize();
    while (pInfo->m_nCurPage < nPageSave)
    {
        ASSERT(pInfo->m_nCurPage == (UINT)m_aPageStart.GetSize());
        OnPrepareDC(pDC, pInfo);
        ASSERT(pInfo->m_bContinuePrinting);
        pInfo->m_rectDraw.SetRect(0, 0,
            pDC->GetDeviceCaps(HORZRES), pDC->GetDeviceCaps(VERTRES));
        pDC->DPtoLP(&pInfo->m_rectDraw);
        OnPrint(pDC, pInfo);
        if (pInfo->m_nCurPage == (UINT)m_aPageStart.GetSize())
            break;
        ++pInfo->m_nCurPage;
    }
    BOOL bResult = pInfo->m_nCurPage == nPageSave;
    pInfo->m_nCurPage = nPageSave;
    pInfo->m_rectDraw = rectSave;
    pDC->SelectClipRgn(NULL) ;
    ASSERT_VALID(this);
    return bResult;
}


/////////////////////////////////////////////////////////////////////////////
// OLE Client support and commands

inline int roundleast(int n)
{
    int mod = n%10;
    n -= mod;
    if (mod >= 5)
        n += 10;
    else if (mod <= -5)
        n -= 10;
    return n;
}

static void RoundRect(FAR UNALIGNED RECT *r1)
{
    r1->left = roundleast(r1->left);
    r1->right = roundleast(r1->right);
    r1->top = roundleast(r1->top);
    r1->bottom = roundleast(r1->bottom);
}

static void MulDivRect(FAR UNALIGNED RECT *r1, FAR UNALIGNED RECT * r2, int num, int div)
{
    r1->left = MulDiv(r2->left, num, div);
    r1->top = MulDiv(r2->top, num, div);
    r1->right = MulDiv(r2->right, num, div);
    r1->bottom = MulDiv(r2->bottom, num, div);
}

void CWordPadView::OnPageSetup()
{
    theApp.EnsurePrinterIsInitialized();

    CPageSetupDialog dlg;
    PAGESETUPDLG& psd = dlg.m_psd;
    BOOL bMetric = theApp.GetUnits() == 1; //centimeters
    BOOL fUpdateWrap = FALSE ;
    psd.Flags |= PSD_MARGINS | (bMetric ? PSD_INHUNDREDTHSOFMILLIMETERS :
    PSD_INTHOUSANDTHSOFINCHES);
    int nUnitsPerInch = bMetric ? 2540 : 1000;
    MulDivRect(&psd.rtMargin, m_rectMargin, nUnitsPerInch, 1440);
    RoundRect(&psd.rtMargin);
    // get the current device from the app
    PRINTDLG pd;
    pd.hDevNames = NULL;
    pd.hDevMode = NULL;
    theApp.GetPrinterDeviceDefaults(&pd);
    psd.hDevNames = pd.hDevNames;
    psd.hDevMode = pd.hDevMode;

    SetHelpFixHook() ;

    if (dlg.DoModal() == IDOK)
    {
        RoundRect(&psd.rtMargin);
        MulDivRect(m_rectMargin, &psd.rtMargin, 1440, nUnitsPerInch);
        theApp.m_rectPageMargin = m_rectMargin;

        //
        // SelectPrinter will free the existing devnames and devmodes if the
        // third parameter is TRUE.  We don't want to do that because the
        // print dialog frees them and allocates new ones.
        //

        theApp.SelectPrinter(psd.hDevNames, psd.hDevMode, FALSE);
        theApp.NotifyPrinterChanged();
        fUpdateWrap = TRUE ;
    }

    RemoveHelpFixHook() ;

    // PageSetupDlg failed
    if (CommDlgExtendedError() != 0)
    {
        CPageSetupDlg dlg;
        dlg.m_nBottomMargin = m_rectMargin.bottom;
        dlg.m_nLeftMargin = m_rectMargin.left;
        dlg.m_nRightMargin = m_rectMargin.right;
        dlg.m_nTopMargin = m_rectMargin.top;
        if (dlg.DoModal() == IDOK)
        {
            m_rectMargin.SetRect(dlg.m_nLeftMargin, dlg.m_nTopMargin,
                dlg.m_nRightMargin, dlg.m_nBottomMargin);
            // m_page will be changed at this point
            theApp.m_rectPageMargin = m_rectMargin;
            theApp.NotifyPrinterChanged();
            fUpdateWrap = TRUE ;
        }
    }

    if (fUpdateWrap)
    {
        CRichEdit2View::WrapChanged();
    }
}

/////////////////////////////////////////////////////////////////////////////
// OLE Server support

// The following command handler provides the standard keyboard
//  user interface to cancel an in-place editing session.  Here,
//  the server (not the container) causes the deactivation.
void CWordPadView::OnCancelEditSrvr()
{
    GetDocument()->OnDeactivateUI(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CWordPadView diagnostics

#ifdef _DEBUG
void CWordPadView::AssertValid() const
{
    CRichEdit2View::AssertValid();
}

void CWordPadView::Dump(CDumpContext& dc) const
{
    CRichEdit2View::Dump(dc);
}

CWordPadDoc* CWordPadView::GetDocument() // non-debug version is inline
{
    return (CWordPadDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWordPadView message helpers

/////////////////////////////////////////////////////////////////////////////
// CWordPadView message handlers

int CWordPadView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CRichEdit2View::OnCreate(lpCreateStruct) == -1)
        return -1;
    theApp.m_listPrinterNotify.AddTail(m_hWnd);

    if (theApp.m_bWordSel)
        GetRichEditCtrl().SetOptions(ECOOP_OR, ECO_AUTOWORDSELECTION);
    else
        GetRichEditCtrl().SetOptions(ECOOP_AND, ~(DWORD)ECO_AUTOWORDSELECTION);
    //      GetRichEditCtrl().SetOptions(ECOOP_OR, ECO_SELECTIONBAR);

    GetRichEditCtrl().GetParaFormat(m_defParaFormat);
    m_defParaFormat.cTabCount = 0;

    //
    // Insert our own wrapper interface callback here to get around MFC defaults
    //

    VERIFY(GetRichEditCtrl().SetOLECallback(&m_xWordPadRichEditOleCallback));

    
    if (::GetWindowLongPtr(::GetParent(m_hWnd) , GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
           m_bIsMirrored = TRUE;

    return 0;
}

void CWordPadView::GetDefaultFont(CCharFormat& cf, BOOL bText)
{
    USES_CONVERSION;
    CString strDefFont;
    if (bText)
        VERIFY(strDefFont.LoadString(IDS_DEFAULTTEXTFONT));
    ASSERT(cf.cbSize == sizeof(CHARFORMAT));
    cf.dwMask = CFM_BOLD|CFM_ITALIC|CFM_UNDERLINE|CFM_STRIKEOUT|CFM_SIZE|
        CFM_COLOR|CFM_OFFSET|CFM_PROTECTED;
    cf.dwEffects = CFE_AUTOCOLOR;
    cf.yHeight = 200; //10pt
    cf.yOffset = 0;
    cf.crTextColor = RGB(0, 0, 0);
    cf.bCharSet = 0;
    cf.bPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
    EVAL(StringCchCopy(cf.szFaceName, ARRAYSIZE(cf.szFaceName), strDefFont) == S_OK);
    cf.dwMask |= CFM_FACE;
}

void CWordPadView::OnInsertDateTime()
{
    // When changing the paragraph direction by Ctrl+Shift the m_bSyncParaFormat
    // will not reset. we reset it to force GetParaFormatSelection read current
    // paragraph direction by calling GetRichEditCtrl().GetParaFormat()
    m_bSyncParaFormat = TRUE;

    CDateDialog dlg(NULL , GetParaFormatSelection());
    if (dlg.DoModal() == IDOK)
    {
        GetRichEditCtrl().ReplaceSel(dlg.m_strSel, TRUE);
    }
}

void CWordPadView::OnFormatParagraph()
{
    CFormatParaDlg dlg(GetParaFormatSelection());
    dlg.m_nWordWrap = m_nWordWrap;
    if (dlg.DoModal() == IDOK)
        SetParaFormat(dlg.m_pf);
}

void CWordPadView::OnFormatTabs()
{
    CFormatTabDlg dlg(GetParaFormatSelection());
    if (dlg.DoModal() == IDOK)
        SetParaFormat(dlg.m_pf);
}

void CWordPadView::OnTextNotFound(LPCTSTR /* UNREF lpStr */)
{
    ASSERT_VALID(this);

    // HACKHACK:
    //
    // When AfxMessageBox is called MFC disables the find dialog and pops up
    // the message box.  After the user dismisses it, User tries to set the
    // focus back to the window that had it before the message box, however
    // this window is disabled so eventually what ends up happening is that
    // the find dialog, and not any control in it, has the focus.  This screws
    // up alt hotkeys for buttons and such.

    HWND h = ::GetFocus();
    AfxMessageBox(IDS_FINISHED_SEARCH,MB_OK|MB_ICONINFORMATION);
    ::SetFocus(h);
}

void CWordPadView::OnColorPick(UINT nID)
{
    CRichEdit2View::OnColorPick(CColorMenu::GetColor(nID));
}

void CWordPadView::OnTimer(UINT_PTR nIDEvent)
{
    if (m_uTimerID != nIDEvent) // not our timer
        CRichEdit2View::OnTimer(nIDEvent);
    else
    {
        KillTimer(m_uTimerID); // kill one-shot timer
        m_uTimerID = 0;
        if (m_bDelayUpdateItems)
            GetDocument()->UpdateAllItems(NULL);
        m_bDelayUpdateItems = FALSE;
    }
}

void CWordPadView::OnEditChange()
{
    SetUpdateTimer();
}

void CWordPadView::OnDestroy()
{
    POSITION pos = theApp.m_listPrinterNotify.Find(m_hWnd);
    ASSERT(pos != NULL);
    theApp.m_listPrinterNotify.RemoveAt(pos);

    if (m_uTimerID != 0) // if outstanding timer kill it
        OnTimer(m_uTimerID);
    ASSERT(m_uTimerID == 0);

    CRichEdit2View::OnDestroy();

    CWnd *pWnd = AfxGetMainWnd() ;

    if (NULL == pWnd)
    {
        return ;
    }

    pWnd = pWnd->GetTopLevelParent() ;

    if (NULL == pWnd)
    {
        return ;
    }

    ::WinHelp(pWnd->m_hWnd, WORDPAD_HELP_FILE, HELP_QUIT, 0) ;
}

void CWordPadView::CalcWindowRect(LPRECT lpClientRect, UINT nAdjustType)
{
    CRichEdit2View::CalcWindowRect(lpClientRect, nAdjustType);

    if (theApp.m_bWin4 && nAdjustType != 0 && (GetStyle() & WS_VSCROLL))
        lpClientRect->right--;

    // if the ruler is visible then slide the view up under the ruler to avoid
    // showing the top border of the view
    if (GetExStyle() & WS_EX_CLIENTEDGE)
    {
        CFrameWnd* pFrame = GetParentFrame();
        if (pFrame != NULL)
        {
            CRulerBar* pBar = (CRulerBar*)pFrame->GetControlBar(ID_VIEW_RULER);
            if (pBar != NULL)
            {
                BOOL bVis = pBar->IsVisible();
                if (pBar->m_bDeferInProgress)
                    bVis = !bVis;
                if (bVis)
                    lpClientRect->top -= 2;
            }
        }
    }
}

void CWordPadView::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMIS)
{
    lpMIS->itemID = (UINT)(WORD)lpMIS->itemID;
    CRichEdit2View::OnMeasureItem(nIDCtl, lpMIS);
}

void CWordPadView::OnPenBackspace()
{
    SendMessage(WM_KEYDOWN, VK_BACK, 0);
    SendMessage(WM_KEYUP, VK_BACK, 0);
}

void CWordPadView::OnPenNewline()
{
    SendMessage(WM_CHAR, '\n', 0);
}

void CWordPadView::OnPenPeriod()
{
    SendMessage(WM_CHAR, '.', 0);
}

void CWordPadView::OnPenSpace()
{
    SendMessage(WM_CHAR, ' ', 0);
}

void CWordPadView::OnPenTab()
{
    SendMessage(WM_CHAR, VK_TAB, 0);
}

void CWordPadView::OnDelayedInvalidate()
{
    Invalidate() ;
}

void CWordPadView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    if (nChar == VK_F10 && GetKeyState(VK_SHIFT) < 0)
    {
        long nStart, nEnd;
        GetRichEditCtrl().GetSel(nStart, nEnd);
        CPoint pt = GetRichEditCtrl().GetCharPos(nEnd);
        SendMessage(WM_CONTEXTMENU, (WPARAM)m_hWnd, MAKELPARAM(pt.x, pt.y));
    }

    CRichEdit2View::OnKeyDown(nChar, nRepCnt, nFlags);
}

HRESULT CWordPadView::GetClipboardData(CHARRANGE* lpchrg, DWORD /*reco*/,
                                       LPDATAOBJECT lpRichDataObj,     LPDATAOBJECT* lplpdataobj)
{
    CHARRANGE& cr = *lpchrg;

    if (NULL == lpRichDataObj)
        return E_INVALIDARG;

    if ((cr.cpMax - cr.cpMin == 1) &&
        GetRichEditCtrl().GetSelectionType() == SEL_OBJECT)
    {
        return E_NOTIMPL;
    }

    BeginWaitCursor();
    //create the data source
    COleDataSource* pDataSource = new COleDataSource;

    // put the formats into the data source
    LPENUMFORMATETC lpEnumFormatEtc;
    lpRichDataObj->EnumFormatEtc(DATADIR_GET, &lpEnumFormatEtc);
    if (lpEnumFormatEtc != NULL)
    {
        FORMATETC etc;
        while (lpEnumFormatEtc->Next(1, &etc, NULL) == S_OK)
        {
            STGMEDIUM stgMedium;
            lpRichDataObj->GetData(&etc, &stgMedium);
            pDataSource->CacheData(etc.cfFormat, &stgMedium, &etc);
        }
        lpEnumFormatEtc->Release();
    }

    CEmbeddedItem item(GetDocument(), cr.cpMin, cr.cpMax);
    item.m_lpRichDataObj = lpRichDataObj;
    // get wordpad formats
    item.GetClipboardData(pDataSource);

    // get the IDataObject from the data source
    *lplpdataobj =  (LPDATAOBJECT)pDataSource->GetInterface(&IID_IDataObject);

    EndWaitCursor();
    return S_OK;
}


HRESULT CWordPadView::PasteHDROPFormat(HDROP hDrop)
{
    HRESULT hr = S_OK ;
    UINT i ;
    TCHAR szFile[MAX_PATH + 1] ;
    CHARRANGE cr ;
    LONG tmp ;
    UINT cFiles ;

    cFiles = DragQueryFile(hDrop, (UINT) -1, NULL, 0) ;

    GetRichEditCtrl().GetSel(cr);

    tmp = cr.cpMin ;

    for (i=0; i<cFiles; i++)
    {
        ::DragQueryFile(hDrop, i, szFile, MAX_PATH) ;

        if (FILE_ATTRIBUTE_DIRECTORY == GetFileAttributes(szFile))
        {
            continue ;
        }

        //
        // Fix the selection state up so that multiple objects insert
        // at the right spot
        //

        cr.cpMin = cr.cpMax ;

        GetRichEditCtrl().SetSel(cr);

        //
        // Insert from file
        //

        InsertFileAsObject(szFile) ;
    }

    GetRichEditCtrl().SetSel(cr);

    return hr ;
}

HRESULT CWordPadView::QueryAcceptData(LPDATAOBJECT lpdataobj,
                                      CLIPFORMAT* lpcfFormat, DWORD reco, BOOL bReally,
                                      HGLOBAL hMetaPict)
{
    HRESULT hr = S_OK ;

    if (!bReally)
    {
        g_fRightButtonDrag = 0x8000 & GetAsyncKeyState(
            GetSystemMetrics(SM_SWAPBUTTON)
            ? VK_LBUTTON
            : VK_RBUTTON);
    }

    //
    // If we are doing an inproc drag-drop, we want our drop
    // effect to be DROPEFFECT_MOVE but if we are drag-dropping
    // from another application, we want our effect to be
    // DROPEFFECT_COPY -- in particular so that we don't delete
    // icons dragged from the explorer or text dragged from Word!
    //
    // The reason for this hack is that richedit doesn't supply
    // any mechanism for us to determine whether or not we are
    // both the drop source and the drop target.
    //

    if (!bReally)
    {
        LPUNKNOWN pUnk = NULL ;

        if (S_OK == lpdataobj->QueryInterface(
            IID_IProxyManager,
            (LPVOID *) &pUnk))
        {
            //
            // We got an IProxyManager pointer, so we are NOT doing an
            // inproc drag drop
            //

            pUnk->Release() ;

            g_fInternalDragDrop = FALSE ;
        }
        else
        {
            g_fInternalDragDrop = TRUE ;
        }
    }
    else
    {
        g_fInternalDragDrop = FALSE ;
    }

    //
    // Check for native data first
    //

    if (bReally && *lpcfFormat == 0 && (m_nPasteType == 0))
    {
        COleDataObject dataobj;
        dataobj.Attach(lpdataobj, FALSE);
        if (!dataobj.IsDataAvailable(cfRTO)) // native avail, let richedit do as it wants
        {
            if (dataobj.IsDataAvailable(cfEmbeddedObject))
            {
                if (PasteNative(lpdataobj))
                {
                    hr = S_FALSE ;

                    goto errRet ;
                }
            }
        }
    }

    //
    // We need to support HDROP format from the explorer
    // and the desktop
    //

    if (bReally)
    {
        FORMATETC fe ;

        fe.cfFormat = CF_HDROP ;
        fe.ptd = NULL ;
        fe.dwAspect = DVASPECT_CONTENT ;
        fe.lindex = -1 ;
        fe.tymed = TYMED_HGLOBAL ;

        if (S_OK == lpdataobj->QueryGetData(&fe))
        {
            STGMEDIUM sm ;

            sm.tymed = TYMED_NULL ;
            sm.hGlobal = (HGLOBAL) 0 ;
            sm.pUnkForRelease = NULL ;

            if (S_OK == lpdataobj->GetData(&fe, &sm))
            {
                //
                // If we have a single file in our HDROP data then
                // embed source might *also* be available in which case we
                // should just use the default richedit logic and
                // skip PasteHDROPFormat().  We should not ever get
                // embed source AND an HDROP data block containing
                // multiple files because OLE only supports one drop
                // source per drag-drop operation.  The default richedit
                // logic should handle all cases while dropping a single
                // file, we just have to special case things while dropping
                // multiple files.
                //

                if (DragQueryFile((HDROP) sm.hGlobal, (UINT) -1, NULL, 0) > 1)
                {
                    PasteHDROPFormat((HDROP) sm.hGlobal) ;
                    hr = S_FALSE ;
                }
                else
                {
                    hr = S_OK ;
                }

                ::ReleaseStgMedium(&sm) ;

                if (S_FALSE == hr)
                {
                    goto errRet ;
                }
            }
        }
    }

    //
    // If all else fails, let richedit give it a try
    //

    hr = CRichEdit2View::QueryAcceptData(lpdataobj, lpcfFormat, reco, bReally,
        hMetaPict);

errRet:

    if (bReally)
    {
        //
        // We post a message to ourselves here instead of just calling
        // ::Invalidate() because the richedit control doesn't always
        // repaint unless it is completely done with the data transfer operation.
        //

        PostMessage(WM_COMMAND, ID_DELAYED_INVALIDATE, 0) ;
    }

    return hr ;
}


BOOL CWordPadView::PasteNative(LPDATAOBJECT lpdataobj)
{
    // check data object for wordpad object
    // if true, pull out RTF directly

    FORMATETC etc = {NULL, NULL, DVASPECT_CONTENT, -1, TYMED_ISTORAGE};
    etc.cfFormat = (CLIPFORMAT)cfEmbeddedObject;
    STGMEDIUM stgMedium = {TYMED_ISTORAGE, 0, NULL};

    // create an IStorage to transfer the data in
    LPLOCKBYTES lpLockBytes;
    if (FAILED(::CreateILockBytesOnHGlobal(NULL, TRUE, &lpLockBytes)))
        return FALSE;
    ASSERT(lpLockBytes != NULL);

    HRESULT hr = ::StgCreateDocfileOnILockBytes(lpLockBytes,
        STGM_SHARE_EXCLUSIVE|STGM_CREATE|STGM_READWRITE, 0, &stgMedium.pstg);
    lpLockBytes->Release(); //storage addref'd
    if (FAILED(hr))
        return FALSE;

    ASSERT(stgMedium.pstg != NULL);

    CLSID clsid;

    BOOL bRes = FALSE; //let richedit do what it wants

    if (SUCCEEDED(lpdataobj->GetDataHere(&etc, &stgMedium)) &&
        SUCCEEDED(ReadClassStg(stgMedium.pstg, &clsid)) &&
        clsid == GetDocument()->GetClassID())
    {
        //pull out RTF now
        // open Contents stream

        COleStreamFile file;
        CFileException fe;
        if (file.OpenStream(stgMedium.pstg, szContents,
            CFile::modeReadWrite|CFile::shareExclusive, &fe))
        {
            CRichEdit2Doc  *doc = GetDocument();
            BOOL            bRTF = doc->m_bRTF;
            BOOL            bUnicode = doc->m_bUnicode;

            // Force the "current" stream type to be rtf

            doc->m_bRTF = TRUE;
            doc->m_bUnicode = FALSE;

            // load it with CArchive (loads from Contents stream)
            CArchive loadArchive(&file, CArchive::load |
                CArchive::bNoFlushOnDelete);
            Stream(loadArchive, TRUE); //stream in selection

            // Restore the "current" stream type

            doc->m_bRTF = bRTF;
            doc->m_bUnicode = bUnicode;

            bRes = TRUE; // don't let richedit do anything
        }
    }
    ::ReleaseStgMedium(&stgMedium);
    return bRes;
}

// things to fix
// if format==0 we are doing a straight EM_PASTE
//      look for native formats
//              richedit specific -- allow richedit to handle (these will be first)
//              look for RTF, CF_TEXT.  If there paste special as these
//      Do standard OLE scenario

// if pasting a particular format (format != 0)
//      if richedit specific, allow through
//      if RTF, CF_TEXT. paste special
//      if OLE format, do standard OLE scenario


void CWordPadView::OnFilePrint()
{
    theApp.EnsurePrinterIsInitialized();

    // don't allow winini changes to occur while printing
    m_bInPrint = TRUE;

    SetHelpFixHook() ;

    CRichEdit2View::OnFilePrint();

    RemoveHelpFixHook() ;

    // printer may have changed
    theApp.NotifyPrinterChanged(); // this will cause a GetDocument()->PrinterChanged();
    m_bInPrint = FALSE;
}

void CWordPadView::OnFilePrintPreview()
{
    theApp.EnsurePrinterIsInitialized();

    CRichEdit2View::OnFilePrintPreview();
}

int CWordPadView::OnMouseActivate(CWnd* pWnd, UINT nHitTest, UINT message)
{
    if (m_bOnBar)
    {
        SetFocus();
        return MA_ACTIVATEANDEAT;
    }
    else
        return CRichEdit2View::OnMouseActivate(pWnd, nHitTest, message);
}

typedef BOOL (WINAPI *PCWPROC)(HWND, LPSTR, UINT, LPVOID, DWORD, DWORD);
void CWordPadView::OnPenLens()
{
    USES_CONVERSION;
    HINSTANCE hLib = LoadLibrary(L"PENWIN32.DLL");
    if (hLib == NULL)
        return;
    PCWPROC pCorrectWriting = (PCWPROC)GetProcAddress(hLib, "CorrectWriting");
    ASSERT(pCorrectWriting != NULL);
    if (pCorrectWriting != NULL)
    {
        CHARRANGE cr;
        GetRichEditCtrl().GetSel(cr);
        int nCnt = 2*(cr.cpMax-cr.cpMin);
        BOOL bSel = (nCnt != 0);
        nCnt = max(1024, nCnt);
        char* pBuf = new char[nCnt];
        if (pBuf)
        {
            pBuf[0] = 0;
            if (bSel)
            {
                GetRichEditCtrl().GetSelText(pBuf);
            }

            if (pCorrectWriting(m_hWnd, pBuf, nCnt, 0, bSel ? 0 : CWR_INSERT, 0))
            {
                LPWSTR pwszBuf = AnsiToWideNewArray(pBuf);
                if (pwszBuf)
                {
                    GetRichEditCtrl().ReplaceSel(pwszBuf);
                    delete [] pwszBuf;
                }
            }
            delete [] pBuf;
        }
    }
    FreeLibrary(hLib);
}

LONG CWordPadView::OnPrinterChangedMsg(UINT, LONG)
{
    CDC dc;
    AfxGetApp()->CreatePrinterDC(dc);
    OnPrinterChanged(dc);
    return 0;
}

static void ForwardPaletteChanged(HWND hWndParent, HWND hWndFocus)
{
    // this is a quick and dirty hack to send the WM_QUERYNEWPALETTE to a window that is interested
    HWND hWnd = NULL;
    for (hWnd = ::GetWindow(hWndParent, GW_CHILD); hWnd != NULL; hWnd = ::GetWindow(hWnd, GW_HWNDNEXT))
    {
        if (hWnd != hWndFocus)
        {
            ::SendMessage(hWnd, WM_PALETTECHANGED, (WPARAM)hWndFocus, 0L);
            ForwardPaletteChanged(hWnd, hWndFocus);
        }
    }
}

void CWordPadView::OnPaletteChanged(CWnd* pFocusWnd)
{
    ForwardPaletteChanged(m_hWnd, pFocusWnd->GetSafeHwnd());
    // allow the richedit control to realize its palette
    // remove this if if richedit fixes their code so that
    // they don't realize their palette into foreground
    if (::GetWindow(m_hWnd, GW_CHILD) == NULL)
        CRichEdit2View::OnPaletteChanged(pFocusWnd);
}

static BOOL FindQueryPalette(HWND hWndParent)
{
    // this is a quick and dirty hack to send the WM_QUERYNEWPALETTE to a window that is interested
    HWND hWnd = NULL;
    for (hWnd = ::GetWindow(hWndParent, GW_CHILD); hWnd != NULL; hWnd = ::GetWindow(hWnd, GW_HWNDNEXT))
    {
        if (::SendMessage(hWnd, WM_QUERYNEWPALETTE, 0, 0L))
            return TRUE;
        else if (FindQueryPalette(hWnd))
            return TRUE;
    }
    return FALSE;
}

BOOL CWordPadView::OnQueryNewPalette()
{
    if(FindQueryPalette(m_hWnd))
        return TRUE;
    return CRichEdit2View::OnQueryNewPalette();
}

void CWordPadView::OnWinIniChange(LPCTSTR lpszSection)
{
    CRichEdit2View::OnWinIniChange(lpszSection);
    //printer might have changed
    if (!m_bInPrint)
    {
        if (lstrcmpi(lpszSection, _T("windows")) == 0)
            theApp.NotifyPrinterChanged(TRUE); // force update to defaults
    }
}

void CWordPadView::OnSize(UINT nType, int cx, int cy)
{
    CRichEdit2View::OnSize(nType, cx, cy);
    CRect rect(HORZ_TEXTOFFSET, VERT_TEXTOFFSET, cx, cy);
    GetRichEditCtrl().SetRect(rect);
}

void CWordPadView::OnGetCharFormat(NMHDR* pNMHDR, LRESULT* pRes)
{
    ASSERT(pNMHDR != NULL);
    ASSERT(pRes != NULL);

    ((CHARHDR*)pNMHDR)->cf = GetCharFormatSelection();
    *pRes = 1;
}

void CWordPadView::OnSetCharFormat(NMHDR* pNMHDR, LRESULT* pRes)
{
    ASSERT(pNMHDR != NULL);
    ASSERT(pRes != NULL);
    SetCharFormat(((CHARHDR*)pNMHDR)->cf);
    *pRes = 1;
}

void CWordPadView::OnBarSetFocus(NMHDR*, LRESULT*)
{
    m_bOnBar = TRUE;
}

void CWordPadView::OnBarKillFocus(NMHDR*, LRESULT*)
{
    m_bOnBar = FALSE;
}

void CWordPadView::OnBarReturn(NMHDR*, LRESULT* )
{
    SetFocus();
}

void CWordPadView::OnFormatFont()
{
    SetHelpFixHook() ;

    CRichEdit2View::OnFormatFont() ;

    RemoveHelpFixHook() ;
}

void CWordPadView::OnInsertObject()
{
    g_fDisableStandardHelp = TRUE ;

    SetHelpFixHook() ;

    CRichEdit2View::OnInsertObject() ;

    RemoveHelpFixHook() ;

    g_fDisableStandardHelp = FALSE ;
}

void CWordPadView::OnEditPasteSpecial()
{
    g_fDisableStandardHelp = TRUE ;

    SetHelpFixHook() ;

    CRichEdit2View::OnEditPasteSpecial() ;

    RemoveHelpFixHook() ;

    g_fDisableStandardHelp = FALSE ;
}

void CWordPadView::OnEditFind()
{
    SetHelpFixHook() ;

    CRichEdit2View::OnEditFind() ;

    RemoveHelpFixHook() ;
}

void CWordPadView::OnEditReplace()
{
    SetHelpFixHook() ;

    CRichEdit2View::OnEditReplace() ;

    RemoveHelpFixHook() ;
}

void CWordPadView::OnEditProperties()
{
    g_fDisableStandardHelp = TRUE ;

    SetHelpFixHook() ;

    CRichEdit2View::OnEditProperties() ;

    RemoveHelpFixHook() ;

    g_fDisableStandardHelp = FALSE ;
}


/////////////////////////////////////////////////////////////////////////////
// CWordPadView::XRichEditOleCallback
//
// We implement this so we can override the defaults that MFC has set up.  For
// the most part, we just delegate to MFC.
//

BEGIN_INTERFACE_MAP(CWordPadView, CCtrlView)
// we use IID_IUnknown because richedit doesn't define an IID
INTERFACE_PART(CWordPadView, IID_IUnknown, WordPadRichEditOleCallback)
END_INTERFACE_MAP()

STDMETHODIMP_(ULONG) CWordPadView::XWordPadRichEditOleCallback::AddRef()
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        return pThis->m_xRichEditOleCallback.AddRef() ;
}

STDMETHODIMP_(ULONG) CWordPadView::XWordPadRichEditOleCallback::Release()
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        return pThis->m_xRichEditOleCallback.Release() ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::QueryInterface(
                                                                       REFIID iid, LPVOID* ppvObj)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        return pThis->m_xRichEditOleCallback.QueryInterface(iid, ppvObj) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::GetNewStorage(LPSTORAGE* ppstg)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        return pThis->m_xRichEditOleCallback.GetNewStorage(ppstg) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::GetInPlaceContext(
                                                                          LPOLEINPLACEFRAME* lplpFrame, LPOLEINPLACEUIWINDOW* lplpDoc,
                                                                          LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        // Turn off the mirroring so the server can do the caculation without any problem.
        // We turn it on again in ShowContainerUI
        MirrorTheContainer(FALSE);

        return pThis->m_xRichEditOleCallback.GetInPlaceContext(lplpFrame, lplpDoc, lpFrameInfo) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::ShowContainerUI(BOOL fShow)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        // Turn on the mirroring if object UI gonna deactivate.
        if (fShow)
            MirrorTheContainer(fShow);

        return pThis->m_xRichEditOleCallback.ShowContainerUI(fShow) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::QueryInsertObject(
                                                                          LPCLSID lpclsid, LPSTORAGE pstg, LONG cp)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        return pThis->m_xRichEditOleCallback.QueryInsertObject(lpclsid, pstg, cp) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::DeleteObject(LPOLEOBJECT lpoleobj)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        return pThis->m_xRichEditOleCallback.DeleteObject(lpoleobj) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::QueryAcceptData(
                                                                        LPDATAOBJECT lpdataobj, CLIPFORMAT* lpcfFormat, DWORD reco,
                                                                        BOOL fReally, HGLOBAL hMetaPict)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        return pThis->m_xRichEditOleCallback.QueryAcceptData(lpdataobj, lpcfFormat, reco,
        fReally, hMetaPict) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::ContextSensitiveHelp(BOOL fEnterMode)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        return pThis->m_xRichEditOleCallback.ContextSensitiveHelp(fEnterMode) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::GetClipboardData(
                                                                         CHARRANGE* lpchrg, DWORD reco, LPDATAOBJECT* lplpdataobj)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        return pThis->m_xRichEditOleCallback.GetClipboardData(lpchrg, reco, lplpdataobj) ;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::GetDragDropEffect(
                                                                          BOOL fDrag, DWORD grfKeyState, LPDWORD pdwEffect)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        if (!fDrag) // allowable dest effects
        {
            DWORD   dwEffect;

            // check for force link
#ifndef _MAC
            if ((grfKeyState & (MK_CONTROL|MK_SHIFT)) == (MK_CONTROL|MK_SHIFT))
#else
                if ((grfKeyState & (MK_OPTION|MK_SHIFT)) == (MK_OPTION|MK_SHIFT))
#endif
                    dwEffect = DROPEFFECT_LINK;
                // check for force copy
#ifndef _MAC
                else if ((grfKeyState & MK_CONTROL) == MK_CONTROL)
#else
                    else if ((grfKeyState & MK_OPTION) == MK_OPTION)
#endif
                    dwEffect = DROPEFFECT_COPY;
                // check for force move
                else if ((grfKeyState & MK_ALT) == MK_ALT)
                    dwEffect = DROPEFFECT_MOVE;
                // default -- recommended action is 'copy' (overridden from MFC default)
                else
                {
                    if (g_fInternalDragDrop)
                    {
                        dwEffect = DROPEFFECT_MOVE ;
                    }
                    else
                    {
                        dwEffect = DROPEFFECT_COPY;
                    }
                }

                pThis->m_nPasteType = 0;

                if (dwEffect & *pdwEffect) // make sure allowed type
                {
                    *pdwEffect = dwEffect;

                    if (DROPEFFECT_LINK == dwEffect)
                        pThis->m_nPasteType = COlePasteSpecialDialog::pasteLink;
                }
        }
        return S_OK;
}

STDMETHODIMP CWordPadView::XWordPadRichEditOleCallback::GetContextMenu(
                                                                       WORD seltype, LPOLEOBJECT lpoleobj, CHARRANGE* lpchrg,
                                                                       HMENU* lphmenu)
{
    METHOD_PROLOGUE_EX_(CWordPadView, WordPadRichEditOleCallback)

        HRESULT hr;

    if (g_fRightButtonDrag)
        hr = E_FAIL;
    else
        hr = pThis->m_xRichEditOleCallback.GetContextMenu(
        seltype,
        lpoleobj,
        lpchrg,
        lphmenu);

    g_fRightButtonDrag = FALSE;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\wordpvw.h ===
// wordpvw.h : interface of the CWordPadView class
//
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


class CWordPadView : public CRichEdit2View
{
protected: // create from serialization only
    CWordPadView();
    DECLARE_DYNCREATE(CWordPadView)

// Attributes
public:
    static BOOL m_bIsMirrored;

    UINT_PTR m_uTimerID;
    BOOL m_bDelayUpdateItems;
    BOOL m_bInPrint;
    CParaFormat m_defParaFormat;

    CWordPadDoc* GetDocument();
    BOOL IsFormatText();

    virtual HMENU GetContextMenu(WORD seltype, LPOLEOBJECT lpoleobj,
        CHARRANGE* lpchrg);

// Operations
public:
    BOOL PasteNative(LPDATAOBJECT lpdataobj);
    void SetDefaultFont(BOOL bText);
    void SetUpdateTimer();
    void GetDefaultFont(CCharFormat& cf, BOOL bText);
    void DrawMargins(CDC* pDC);
    BOOL SelectPalette();
   HRESULT PasteHDROPFormat(HDROP hDrop) ;
   BOOL PaginateTo(CDC* pDC, CPrintInfo* pInfo) ;

    static void MirrorTheContainer(BOOL bMirror);

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWordPadView)
    protected:
    virtual void CalcWindowRect(LPRECT lpClientRect, UINT nAdjustType = adjustBorder);
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual void OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* printInfo);
    virtual void CWordPadView::OnEndPrinting(CDC*dc, CPrintInfo*pInfo);
    virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo);
    //}}AFX_VIRTUAL
    BOOL OnPreparePrinting(CPrintInfo* pInfo);
    virtual HRESULT GetClipboardData(CHARRANGE* lpchrg, DWORD reco,
        LPDATAOBJECT lpRichDataObj, LPDATAOBJECT* lplpdataobj);
    virtual HRESULT QueryAcceptData(LPDATAOBJECT, CLIPFORMAT*, DWORD,
        BOOL, HGLOBAL);
public:
    virtual void WrapChanged();

// Implementation
public:
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

//
// Wrapper for the richedit callback interface so we can
// get around some MFC defaults
//

public:

    BEGIN_INTERFACE_PART(WordPadRichEditOleCallback, IRichEditOleCallback)
        INIT_INTERFACE_PART(CWordPadView, WordPadRichEditOleCallback)
        STDMETHOD(GetNewStorage) (LPSTORAGE*);
        STDMETHOD(GetInPlaceContext) (LPOLEINPLACEFRAME*,
                                      LPOLEINPLACEUIWINDOW*,
                                      LPOLEINPLACEFRAMEINFO);
        STDMETHOD(ShowContainerUI) (BOOL);
        STDMETHOD(QueryInsertObject) (LPCLSID, LPSTORAGE, LONG);
        STDMETHOD(DeleteObject) (LPOLEOBJECT);
        STDMETHOD(QueryAcceptData) (LPDATAOBJECT, CLIPFORMAT*, DWORD,BOOL, HGLOBAL);
        STDMETHOD(ContextSensitiveHelp) (BOOL);
        STDMETHOD(GetClipboardData) (CHARRANGE*, DWORD, LPDATAOBJECT*);
        STDMETHOD(GetDragDropEffect) (BOOL, DWORD, LPDWORD);
        STDMETHOD(GetContextMenu) (WORD, LPOLEOBJECT, CHARRANGE*, HMENU*);
    END_INTERFACE_PART(WordPadRichEditOleCallback)

    DECLARE_INTERFACE_MAP()


protected:
    BOOL m_bOnBar;

    CPrintDialog *m_oldprintdlg;

    // OLE Container support

    virtual void DeleteContents();
    virtual void OnTextNotFound(LPCTSTR);

// Generated message map functions
protected:
    afx_msg void OnCancelEditSrvr();
    //{{AFX_MSG(CWordPadView)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnPageSetup();
    afx_msg void OnInsertDateTime();
   afx_msg void OnInsertObject();
    afx_msg void OnFormatParagraph();
    afx_msg void OnFormatFont();
    afx_msg void OnFormatTabs();
   afx_msg void OnEditPasteSpecial();
   afx_msg void OnEditProperties();
    afx_msg void OnEditFind();
    afx_msg void OnEditReplace();
    afx_msg void OnTimer(UINT_PTR nIDEvent);
    afx_msg void OnDestroy();
    afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
    afx_msg void OnPenBackspace();
    afx_msg void OnPenNewline();
    afx_msg void OnPenPeriod();
    afx_msg void OnPenSpace();
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnFilePrint();
    afx_msg void OnFilePrintPreview();
    afx_msg void OnPenLens();
    afx_msg void OnPenTab();
    afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
    afx_msg BOOL OnQueryNewPalette();
    afx_msg void OnWinIniChange(LPCTSTR lpszSection);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnDelayedInvalidate() ;
    //}}AFX_MSG
    afx_msg void OnEditChange();
    afx_msg void OnColorPick(UINT nID);
    afx_msg int OnMouseActivate(CWnd* pWnd, UINT nHitTest, UINT message);
    afx_msg LONG OnPrinterChangedMsg(UINT, LONG);
    afx_msg void OnGetCharFormat(NMHDR* pNMHDR, LRESULT* pRes);
    afx_msg void OnSetCharFormat(NMHDR* pNMHDR, LRESULT* pRes);
    afx_msg void OnBarSetFocus(NMHDR*, LRESULT*);
    afx_msg void OnBarKillFocus(NMHDR*, LRESULT*);
    afx_msg void OnBarReturn(NMHDR*, LRESULT* );
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in wordpvw.cpp
inline CWordPadDoc* CWordPadView::GetDocument()
   { return (CWordPadDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\core\convtype.h ===
#ifndef CONVTYPE_H
#define CONVTYPE_H

//
// %%File:      CONVTYPE.H
//
// %%Unit:      CORE/Common Conversions Code
//
// %%Author:    JohnPil
//
// Copyright (C) 1989-1993, Microsoft Corp.
//
// Global type definitions for conversions code.
//


typedef int bool;

#ifndef PASCAL
#define PASCAL pascal
#endif

#ifndef FAR
#ifdef PC
#define FAR _far
#else
#define FAR
#endif
#endif

#ifndef NEAR
#ifdef PC
#define NEAR _near
#else
#define NEAR
#endif
#endif

// Use __HUGE rather than HUGE or _HUGE as Excel mathpack defines both as externs
#ifndef __HUGE
#ifdef PC
#ifndef NT
#define __HUGE _huge
#else
#define __HUGE
#endif //NT
#else
#define __HUGE
#endif //PC
#endif //__HUGE

#ifndef STATIC
#define STATIC static
#endif

#ifndef EXTERN
#define EXTERN extern
#endif

//  ABSOLUTE SIZE
//  -------------
#ifndef VOID
#define VOID void
#endif

#ifndef BYTE
#define BYTE unsigned char				// 8-bit unsigned data
#define BYTE_MAX 255
#endif

#ifndef CHAR
#define CHAR char						// 8-bit data
#endif

typedef unsigned CHAR UCHAR;

typedef short int SHORT;
#define SHORT_MAX						32767
#define SHORT_MIN						-32767

#ifndef WORD
#define WORD unsigned short				// 16-bit unsigned data
#define WORD_MAX 65535
#endif

typedef WORD BF;						// bitfields are 16-bit unsigned

#ifndef LONG
#define LONG long						// 32-bit data
#endif

#ifndef DWORD
#define DWORD unsigned long				// 32-bit unsigned data
#endif

#ifndef FLOAT
#define FLOAT float						// fixed size absolute float
#endif

#ifndef DOUBLE
#ifndef NT_WORDPAD
#define DOUBLE double					// fixed size absolute double
#endif
#endif

//  VARIABLE SIZE
//  -------------
#ifndef INT
#define INT int							// Most efficient size for processing info
#endif

#ifndef UNSIGNED
#define UNSIGNED unsigned INT
#endif

#ifndef BOOL
#define BOOL INT						// Boolean data
#endif

#define FC              long
#define CP              long
#define PN              WORD
typedef unsigned char byte;

// things which are normally defined in windows.h for windows, but now on Mac
#ifdef MAC

#define LOWORD(l)           ((WORD)(DWORD)(l))
#define HIWORD(l)           ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))

typedef char FAR *LPSTR;
typedef const char FAR *LPCSTR;
typedef WORD HWND;

#endif

// define platform-independent function type templates

#if defined(MAC)

typedef int (PASCAL * FARPROC) ();
typedef void FAR *LPVOID;	// These are already defined for PC in Windows.h
typedef void **HGLOBAL;		// but have to be defined for Mac.

#define LOCAL(type) type NEAR PASCAL
#define GLOBAL(type) type PASCAL

#elif defined(NT)

typedef int (WINAPI * FARPROC)();

#define LOCAL(type) type NEAR WINAPI
#define GLOBAL(type) type WINAPI

#elif defined(DOS)

typedef int (FAR PASCAL * FARPROC)();

#define LOCAL(type) type NEAR PASCAL
#define GLOBAL(type) type PASCAL

#else
#error Enforced Compilation Error
#endif


// define main function types

#define LOCALVOID 		LOCAL(VOID)
#define LOCALBOOL 		LOCAL(BOOL)
#define LOCALCH   		LOCAL(char)
#define LOCALBYTE 		LOCAL(BYTE)
#define LOCALINT  		LOCAL(INT)
#define LOCALUNS      	LOCAL(UNSIGNED)
#define LOCALSHORT		LOCAL(SHORT)
#define LOCALWORD       LOCAL(WORD)
#define LOCALLONG		LOCAL(LONG)
#define LOCALDWORD  	LOCAL(DWORD)
#define LOCALFC 		LOCAL(FC)
#define LOCALCP   		LOCAL(CP)
#define LOCALPVOID  	LOCAL(void *)
#define LOCALHVOID   	LOCAL(void **)
#define LOCALPCH  		LOCAL(char *)
#define LOCALSZ   		LOCAL(char *)
#define LOCALLPCH 		LOCAL(char FAR *)
#define LOCALUCHAR   	LOCAL(unsigned char)
#define LOCALPUCHAR  	LOCAL(unsigned char *)
#define LOCALFH			LOCAL(FH)

#define GLOBALVOID 		GLOBAL(VOID)
#define GLOBALBOOL 		GLOBAL(BOOL)
#define GLOBALCH   		GLOBAL(char)
#define GLOBALBYTE 		GLOBAL(BYTE)
#define GLOBALINT  		GLOBAL(INT)
#define GLOBALUNS      	GLOBAL(UNSIGNED)
#define GLOBALSHORT		GLOBAL(SHORT)
#define GLOBALWORD      GLOBAL(WORD)
#define GLOBALLONG		GLOBAL(LONG)
#define GLOBALDWORD  	GLOBAL(DWORD)
#define GLOBALFC 		GLOBAL(FC)
#define GLOBALCP   		GLOBAL(CP)
#define GLOBALPVOID  	GLOBAL(void *)
#define GLOBALHVOID   	GLOBAL(void **)
#define GLOBALPCH  		GLOBAL(char *)
#define GLOBALSZ   		GLOBAL(char *)
#define GLOBALLPCH  	GLOBAL(char FAR *)
#define GLOBALUCHAR   	GLOBAL(unsigned char)
#define GLOBALPUCHAR  	GLOBAL(unsigned char *)
#define GLOBALFH        GLOBAL(FH)
#define GLOBALFN        GLOBAL(FN)
#ifndef DOSSA
#define GLOBALHGLOBAL	GLOBAL(HGLOBAL)
#define GLOBALLPVOID	GLOBAL(LPVOID)
#endif

#define fTrue           1
#define fFalse          0

#ifndef NULL
#define NULL	0
#endif

#ifndef hgNil
#define hgNil ((HGLOBAL)NULL)
#endif

// maximum lengths of numbers->strings, used with SzFrom???? funcs.
#define cchMaxSzInt		7
#define cchMaxSzWord 	6
#define cchMaxSzLong	12
#define cchMaxSzDword	11

#endif // CONVTYPE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\accwiz.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_ACCWIZ_H
#define _INC_ACCWIZ_H

#include "schemes.h" // For SCHEMEDATALOCAL
#include "resource.h"

// Helper function
void LoadArrayFromStringTable(int nIdString, int *rgnValues, int *pnCountValues);

// Macros used to save debug info to/from the INI file
// JMC: HACK - Default to '1' for options!!!!!!!!
#define GET_SAVED_INT(xxx) xxx = GetPrivateProfileInt(__TEXT("Options"), __TEXT(#xxx), 1, __TEXT("AccWiz.ini"))
#define PUT_SAVED_INT(xxx) wsprintf(sz, __TEXT("%i"), xxx);WritePrivateProfileString(__TEXT("Options"), __TEXT(#xxx), sz, __TEXT("AccWiz.ini"))

// This class contains the general options for the whole wizard
class CAccWizOptions
{
public:
	CAccWizOptions()
	{
    }
	~CAccWizOptions()
	{
	}
    void InitAccWizOptions()
    {
		OSVERSIONINFO osvi;
		ZeroMemory(&osvi, sizeof(osvi));
		osvi.dwOSVersionInfoSize = sizeof(osvi);
		GetVersionEx(&osvi);
		m_bWin95 = (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);

		m_nMinimalFontSize = -1; // This will be set by the welcome page

		///////////////////////////////////////////////
		// Calculate globals that we need
 		HDC hDC = GetDC(NULL);
		m_nLogPixelsY = GetDeviceCaps(hDC, LOGPIXELSY);
		ReleaseDC(NULL, hDC);



		///////////////////////////////////////////////
		// Get the default char set for fonts
		TCHAR szCharSet[20];
		if(LoadString(g_hInstDll,IDS_FONTCHARSET, szCharSet,sizeof(szCharSet)/sizeof(TCHAR))) {
			m_lfCharSet = (BYTE)_tcstoul(szCharSet,NULL,10);
		} else {
			m_lfCharSet = 0; // Default
		}

		///////////////////////////////////////////////
		// Get the standard MS Sans Serif fonts
		// JMC: HACK - Free these resources
		int rgnStandardMSSansSerifFontSizes[] = {8, 10, 12, 14, 18, 24};
		LOGFONT lf;
		ZeroMemory(&lf, sizeof(lf));
		lf.lfCharSet = m_lfCharSet;
		LoadString(g_hInstDll, IDS_SYSTEMFONTNAME, lf.lfFaceName, ARRAYSIZE(lf.lfFaceName));
		

		for(int i=0;i<6;i++)
		{
			lf.lfHeight = 0 - (int)((float)m_nLogPixelsY * (float)rgnStandardMSSansSerifFontSizes[i]/ (float)72 + (float).5);
			m_rgnStdMSSansSerifFonts[i] = CreateFontIndirect(&lf);

			// Create underlined version
			lf.lfUnderline = 1;
			m_rgnStdMSSansSerifFonts[i + 6] = CreateFontIndirect(&lf);
			lf.lfUnderline = 0;

		}
		
		// Store away original non-client metrics
		// Get original metrics
		GetNonClientMetrics(&m_ncmOrig, &m_lfIconOrig);

		// Load original Wiz Scheme settings
		m_schemeOriginal.LoadOriginal();

		// Copy to the Preview scheme and to the current scheme
		m_schemePreview = m_schemeOriginal;
		m_schemeCurrent = m_schemeOriginal;

		// This is set by the welcome page, so that the second part knows to update it's check boxes.
		// The second page clears this flag
		m_bWelcomePageTouched = FALSE;

		// this is the default windows settings (for Win2K not necessarilly for Whistler)
		m_schemeWindowsDefault.SetToWindowsDefault();
#ifdef _DEBUG
		m_schemeOriginal.Dump();
#endif
	}

	void RestoreOriginalColorsToPreview()
	{
		memcpy(m_schemePreview.m_rgb, m_schemeOriginal.m_rgb, sizeof(m_schemePreview.m_rgb));
	}

	void ApplyPreview()
	{
		m_schemeCurrent.ApplyChanges(m_schemePreview);
	}
    void ApplyOriginal()
    {
        m_schemeCurrent.ApplyChanges(m_schemeOriginal, &m_ncmOrig, &m_lfIconOrig);
	}
	
    void ApplyWindowsDefault();

	BOOL m_bWelcomePageTouched;

	int m_nLogPixelsY;

	int m_nMinimalFontSize;

	HFONT GetClosestMSSansSerif(int nPointSize, BOOL bUnderlined = FALSE)
	{
		// For Underlined fonts, add '6' the the index
		int nOffset = bUnderlined?6:0;

		if(nPointSize <= 8)
			return m_rgnStdMSSansSerifFonts[0 + nOffset];
		else if(nPointSize <= 10)
			return m_rgnStdMSSansSerifFonts[1 + nOffset];
		else if(nPointSize <= 12)
			return m_rgnStdMSSansSerifFonts[2 + nOffset];
		else if(nPointSize <= 14)
			return m_rgnStdMSSansSerifFonts[3 + nOffset];
		else if(nPointSize <= 18)
			return m_rgnStdMSSansSerifFonts[4 + nOffset];
		return m_rgnStdMSSansSerifFonts[5];
	}

	void ReportChanges(HWND hwndChanges)
	{
		m_schemeCurrent.ReportChanges(m_schemeOriginal, hwndChanges);
	}

	BOOL m_bWin95;
	BYTE m_lfCharSet;

	WIZSCHEME m_schemePreview;
	WIZSCHEME m_schemeOriginal;

protected:
	// Dialogs never modify these copies of the scheme
	WIZSCHEME m_schemeCurrent;
	WIZSCHEME m_schemeWindowsDefault;

	NONCLIENTMETRICS m_ncmOrig;
	LOGFONT m_lfIconOrig;

	HFONT m_rgnStdMSSansSerifFonts[6 * 2]; // 0-5 are for 8, 10, 12, 14, 18, 24.  6-11 are for the same things, but underlined

	friend class CWelcome2Pg; // TODO: HACK - This is only here to give CWelcome2Pg access to m_schemeCurrent
};

// This variable will be accessible to any derived wizard page.
// It contains information specific to this application
extern CAccWizOptions g_Options;


VOID WINAPI AccWiz_RunDllA(HWND hwnd, HINSTANCE hInstance, LPSTR pszCmdLine, INT nCmdShow);
VOID WINAPI AccWiz_RunDllW(HWND hwnd, HINSTANCE hInstance, LPWSTR pszCmdLine, INT nCmdShow);

#endif // _INC_ACCWIZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\write\write.c ===
#include <windows.h>
#include <shellapi.h>

int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    STARTUPINFOA si;
    LPSTR pszCmdLine = GetCommandLineA();

    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
    	     != '\"') );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
    	    pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
    	    pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    ShellExecuteA(HWND_DESKTOP, NULL, "wordpad.exe", lpCmdLine, NULL,
                      si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    return 0 ;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\wordpad\core\ntloio.c ===
//
// %%File:      NTLOIO.C
//
// %%Unit:      CORE/Common Conversions Code
//
// %%Author:    SMueller
//
// Copyright (C) 1993, Microsoft Corp.
//
// This file contains NT (Win32) specific low-level I/O routines.
//
// We provide wrappers for standard Win32 APIs.
//
// The routines here should work in exes and dlls.  Ideally without
// ifdefs.
//
// ToDo:
// - Open needs to concern itself with binary mode
//

#include "conv.h"
DeclareFileName

#include "ntloio.h"


//
// Local functions
//

//
// Exported APIs
//

#if defined(USEFUNCS)
/*   F   I N I T   L O I O   N T   */
/*-------------------------------------------------------------------------
    Owner: SMueller

	Initialize the LoIO package.  Essential to call this routine before
	doing any other LoIO stuff.
-------------------------------------------------------------------------*/
GLOBALBOOL _FInitLoIO_NT(VOID)
{
	// nothing currently comes to mind
	return(fTrue);
}
#endif // USEFUNCS


#if defined(USEFUNCS)
/*  F   U N I N I T   L O I O   N T   */
/*-------------------------------------------------------------------------
    Owner: SMueller

	Uninitialize the LoIO package.  Good form to call this routine
	when done LoIO stuff.
-------------------------------------------------------------------------*/
GLOBALBOOL _FUninitLoIO_NT(VOID)
{
	// nothing currently comes to mind
	return(fTrue);
}
#endif // USEFUNCS


/*   F H   O P E N   F S   N T   */
/*-------------------------------------------------------------------------
    Owner: SMueller
 
	Opens a file and returns a file handle to it, creating it
	if it doesn't already exist and oflags specifies that we should.
	If file couldn't be opened, return FI_ERROR.
	Note that oflags is specified using convio canonical flags, as
	opposed to any Windows OF_* or Win32 FILE_* values.

	Consider: using FILE_FLAG_DELETE_ON_CLOSE to support our auto-delete
	functionality
-------------------------------------------------------------------------*/
GLOBALFH _FhOpenFs_NT(CHAR* szFileSpec, OFLAGS oflags)
{
	FH		fh;
	BOOL	fCreate;
	BOOL	fTruncate;
	BOOL	fFailExists;
	BOOL	fBinary;
	BOOL	fAppend;
	DWORD	permission;
	DWORD	createmode;
	DWORD	attributes;
	DWORD	sharemode;

	// extract useful info from oflags
	// we don't do much error checking since it's been done higher up
	fCreate = oflags & FI_CREATE;
	fTruncate = oflags & FI_TRUNCATE;
	fFailExists = oflags & FI_FAILEXISTS;
	fAppend = oflags & FI_APPEND;

	// The actual mapping encoded below
	//    fCreate  &&  fTruncate  && fFailExists    ->    CREATE_NEW
	//    fCreate  &&  fTruncate                    ->    CREATE_ALWAYS
	//    fCreate  &&                fFailExists    ->    CREATE_NEW
	//    fCreate                                   ->    OPEN_ALWAYS
	//                 fTruncate  && fFailExists    ->    failure
	//                 fTruncate                    ->    TRUNCATE_EXISTING
	//                               fFailExists    ->    failure
	//                   <none>                     ->    OPEN_EXISTING
	//
	if (fCreate && fFailExists)
		createmode = CREATE_NEW;
	else if (fCreate && fTruncate)
		createmode = CREATE_ALWAYS;
	else if (fCreate)
		createmode = OPEN_ALWAYS;
	else if (fFailExists)
		return (FH)FI_ERROR;
	else if (fTruncate)
		createmode = TRUNCATE_EXISTING;
	else // none
		createmode = OPEN_EXISTING;

	// hints to file system
	attributes = FILE_FLAG_SEQUENTIAL_SCAN;
	if (oflags & FI_TEMP)
		attributes |= FILE_ATTRIBUTE_TEMPORARY;

	// the only thing we potentially care about file type is whether
	// it's text or binary.
	if (oflags & FI_RTF || oflags & FI_TEXT)
	 	fBinary = fFalse;
	else if (oflags & FI_BINARY)
	 	fBinary = fTrue;
	else
		AssertSz(fFalse, "_FhOpenFs_NT: bogus logical file type");

	// mask out values we no longer care about
	oflags &= FI_READWRITE;

	// REVIEW smueller(jimw): Why not use a switch statement here?
	//  (since OFLAGS is short, an int type)?
	// extract the main mode and map to Windows value
	sharemode = 0;
	if (oflags == FI_READ)
		{
	 	permission = GENERIC_READ;
		sharemode = FILE_SHARE_READ;
		}
	else if (oflags == FI_WRITE)
	 	permission = GENERIC_WRITE;
	else if (oflags == FI_READWRITE)
	 	permission = GENERIC_READ | GENERIC_WRITE;
	else
		AssertSz(fFalse, "_FhOpenFs_NT: bogus open mode");

	fh = CreateFile(szFileSpec, permission, sharemode, (LPSECURITY_ATTRIBUTES)0,
	                createmode, attributes, (HANDLE)NULL);

	// if open succeeded, and caller wants, position file pointer at end
	if (fh == INVALID_HANDLE_VALUE)
		{
		Debug(DWORD err = GetLastError());
		return (FH)FI_ERROR;
		}

	if (fAppend)
		{
		SetFilePointer(fh, 0, NULL, FILE_END);
		}

	return fh;
}


#if defined(USEFUNCS)
/*   F   C L O S E   F H   N T   */
/*-------------------------------------------------------------------------
    Owner: SMueller
 
	Close a file handle.  Return success/failure.
	review: check for the existence of a return code.
-------------------------------------------------------------------------*/
GLOBALBOOL _FCloseFh_NT(FH fh, OFLAGS oflags)
{
	return CloseHandle(fh);
}
#endif // USEFUNCS


/*   C B   R E A D   F H   N T   */
/*-------------------------------------------------------------------------
    Owner: SMueller
 
	Read cb bytes from file fh into buffer at pb.  Return count of
	bytes actually read, or FI_ERROR.
-------------------------------------------------------------------------*/
GLOBALLONG _CbReadFh_NT(FH fh, VOID *pb, LONG cb)
{
	LONG cbr;
	return ReadFile(fh, pb, cb, &cbr, NULL) ? cbr : FI_ERROR;
}


/*   C B   W R I T E   F H   N T   */
/*-------------------------------------------------------------------------
	Owner: SMueller

	Write cb bytes from buffer at pb to file fh.  Return count of
	bytes actually written, or FI_ERROR.
-------------------------------------------------------------------------*/
GLOBALLONG _CbWriteFh_NT(FH fh, VOID *pb, LONG cb)
{
	LONG cbw;
	return WriteFile(fh, pb, cb, &cbw, NULL) ? cbw : FI_ERROR;
}


#if defined(USEFUNCS)
/*   F C   S E E K   F H   N T   */
/*-------------------------------------------------------------------------
	Owner: SMueller

	Seek from location so, fc bytes away on file fh.  Return new
	location or FI_ERROR.
-------------------------------------------------------------------------*/
GLOBALFC _FcSeekFh_NT(FH fh, FC fc, SHORT so)
{
	return(SetFilePointer(fh, fc, NULL, so));
}
#endif // USEFUNCS


#if defined(USEFUNCS)
/*   F C   C U R R   F H   N T   */
/*-------------------------------------------------------------------------
	Owner: SMueller

	Return current file position or FI_ERROR.
-------------------------------------------------------------------------*/
GLOBALFC _FcCurrFh_NT(FH fh)
{
	// find out where we are by moving nowhere from here
	return(SetFilePointer(fh, 0, NULL, FILE_CURRENT));
}
#endif // USEFUNCS


#if defined(USEFUNCS)
/*   F C   M A X   F H   N T   */
/*-------------------------------------------------------------------------
	Owner: SMueller

	Return maximum file position (i.e. size of file, i.e. offset of EOF)
	or FI_ERROR.
-------------------------------------------------------------------------*/
GLOBALFC _FcMaxFh_NT(FH fh)
{
	return(GetFileSize(fh, NULL));
}
#endif // USEFUNCS


/*   F C   S E T   M A X   F H   N T   */
/*-------------------------------------------------------------------------
	Owner: SMueller

	Set end of file to current position.  Return new file size or FI_ERROR.
-------------------------------------------------------------------------*/
GLOBALFC _FcSetMaxFh_NT(FH fh)
{
	FC fc;

	fc = SetFilePointer(fh, 0, NULL, FILE_CURRENT);  // get current position
	return (SetEndOfFile(fh) ? fc : FI_ERROR);
}


#if defined(USEFUNCS)
/*   F   D E L E T E   S Z   N T   */
/*-------------------------------------------------------------------------
	Owner: SMueller

	Delete an existing file.  Return success/failure.
-------------------------------------------------------------------------*/
GLOBALBOOL _FDeleteSz_NT(CHAR *szFileSpec)
{
	return DeleteFile(szFileSpec);
}
#endif // USEFUNCS


#if defined(USEFUNCS)
/*   F   R E N A M E   S Z   S Z   N T   */
/*-------------------------------------------------------------------------
	Owner: SMueller

	Rename an existing file.  Supports rename across directories.
	Return success/failure.
-------------------------------------------------------------------------*/
GLOBALBOOL _FRenameSzSz_NT(CHAR *szFileSpec, CHAR *szNewSpec)
{
	return MoveFile(szFileSpec, szNewSpec);
}
#endif // USEFUNCS


/*   F   G E T   C O N V E R T E R   D I R   N T   */
/*-------------------------------------------------------------------------
    Owner: SMueller
 
    Gets the FileSpec for the directory where the currently executing
	converter file lives.  Directory will always contain a trailing
	backslash.
-------------------------------------------------------------------------*/
GLOBALBOOL _FGetConverterDir_NT(CHAR ***phszDirectory)
{
	UINT lRet;
	CHAR *psz;
	INT cbsz;

	*phszDirectory = (CHAR**)HAllocAbort(MAXPATH + 1);
	psz = **phszDirectory;
	lRet = GetModuleFileName(hInstance, psz, MAXPATH);

	if (lRet == 0 || lRet >= MAXPATH)
		{
		FreeH(*phszDirectory);
		return fFalse;
		}
	FTruncateFileSpec(psz);

	// ensure there's a trailing backslash
	cbsz = CchSz(psz);
	if (psz[cbsz - 1] != '\\')
		{
		psz[cbsz] = '\\';
		psz[cbsz + 1] = '\0';
		}

	return fTrue;
}


/*   F   G E T   T E M P   D I R   N T   */
/*-------------------------------------------------------------------------
    Owner: SMueller
 
    Gets the FileSpec for the directory where temp files are to be stored.
	Directory will always contain a trailing backslash.
-------------------------------------------------------------------------*/
GLOBALBOOL _FGetTempDir_NT(CHAR ***phszDirectory)
{
	UINT lRet;
	CHAR *psz;
	INT cbsz;
    UINT nTest;
    char rgchTest[MAXPATH + 1];

	*phszDirectory = (CHAR**)HAllocAbort(MAXPATH + 1);
	psz = **phszDirectory;
	lRet = GetTempPath(MAXPATH, psz);

	if (lRet == 0 || lRet > MAXPATH)
		{
		FreeH(*phszDirectory);
		return fFalse;
		}

	// ensure there's a trailing backslash
	cbsz = CchSz(psz);
	if (psz[cbsz - 1] != '\\')
		{
		psz[cbsz] = '\\';
		psz[cbsz + 1] = '\0';
		}

    // Copied from the conv96 project -- MikeW
    
    // if we don't have a valid temp directory (because of fouled up %TEMP%
    // and %TMP%) ...
    if ((nTest = GetTempFileName(psz, "tst", 0, rgchTest)) == 0)
        {
        // ... use preferences (Windows) directory, which is probably not
        // fouled up, and writable.
        FreeH(*phszDirectory);
        return _FGetPrefsDir_NT(phszDirectory);
        }
    else
        {
        // clean up after GetTempFileName, which actually does create the temp
        // file, but at least does a reasonably good job of deciding quickly
        // that a directory doesn't exist or isn't writable
        DeleteFile(rgchTest);
        }

    return fTrue;
}


/*   F   G E T   P R E F S   D I R   N T   */
/*-------------------------------------------------------------------------
    Owner: SMueller
 
    Gets the FileSpec for the directory where preferences files are to
    be stored.  Directory will always contain a trailing backslash.
-------------------------------------------------------------------------*/
GLOBALBOOL _FGetPrefsDir_NT(CHAR ***phszDirectory)
{
	UINT lRet;
	CHAR *psz;
	INT cbsz;

	*phszDirectory = (CHAR**)HAllocAbort(MAXPATH + 1);
	psz = **phszDirectory;
	lRet = GetWindowsDirectory(psz, MAXPATH);

	if (lRet == 0 || lRet > MAXPATH)
		{
		FreeH(*phszDirectory);
		return fFalse;
		}

	// ensure there's a trailing backslash
	cbsz = CchSz(psz);
	if (psz[cbsz - 1] != '\\')
		{
		psz[cbsz] = '\\';
		psz[cbsz + 1] = '\0';
		}

	return fTrue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\accwiz.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // PCH
#pragma hdrstop

#include "AccWiz.h"

#include "resource.h"

#include "pgfinish.h"
#include "pgGenric.h"

// Welcome page
#include "pgnWelCome.h"
#include "pgWelcom.h"
#include "pgWelco2.h"

// Options page
#include "pgWizOpt.h"

// Color pages
#include "pgLokPrv.h"

// Mouse pages
#include "pgMseCur.h"
#include "pgMseBut.h"
#include "pgcaret.h"

#include "pgTmeOut.h"
#include "pgSveDef.h"
#include "pgSveFil.h"

#include "pgExtras.h"



#include "LookPrev.h"
#include "Select.h"
#include "w95trace.h"

EXTERN_C BOOL WINAPI LinkWindow_RegisterClass() ;

// Declaration of the global options variable
CAccWizOptions g_Options;
HINSTANCE g_hInstDll = NULL;    // DLL instance handle.

BOOL g_bHACKHACKSavedOptions = FALSE;
HANDLE              g_hAccwizRunning;

int WINAPI WinMain( 
				   HINSTANCE hInstance, // handle to current instance 
				   HINSTANCE hPrevInstance, // handle to previous instance 
				   LPSTR lpCmdLine, // pointer to command line 
				   int nCmdShow // show state of window 
				   )
{
	g_hInstDll = hInstance;
    
    SetLastError(0);
    // Allow only ONE instance of the program to run.
    // The mutex is automatically destroyed when Accwiz exits
    g_hAccwizRunning = CreateMutex(NULL, TRUE, TEXT("AK:AccwizRunning:KHALI"));
    if ( (g_hAccwizRunning == NULL) ||
        (GetLastError() == ERROR_ALREADY_EXISTS) )
    {
        return 0;
    }
	
	// Required for Link Window OLE marshalling :AK
    DBPRINTF(TEXT("Calling CoInitialize\r\n"));
	if (FAILED(CoInitialize(NULL)))
		return 0;	// Prefix #113783 (quit if CoInitialize fails)

    g_Options.InitAccWizOptions();
	InitCommonControls();

	// for the Link Window in finish page...
	LinkWindow_RegisterClass();

	VERIFY(CLookPrev::sm_Globals.Initialize()); // Make sure this has been initialized
	// VERIFY(CSelection::Initialize()); // Make sure this has been initialized: chnage this!

	// Get the commandline so that it works for MUI/Unicode
	LPTSTR lpCmdLineW = GetCommandLine();

	
  
	if ( *lpCmdLineW == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++lpCmdLineW && (*lpCmdLineW
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *lpCmdLineW == TEXT('\"') )
            lpCmdLineW++;
    }
    else {
        while (*lpCmdLineW > TEXT(' '))
            lpCmdLineW++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*lpCmdLineW && (*lpCmdLineW <= TEXT(' '))) {
        lpCmdLineW++;
    }

	if(NULL != lpCmdLineW && lstrlen(lpCmdLineW))
	{
		TCHAR szFileName[_MAX_PATH];

		lstrcpyn(szFileName, lpCmdLineW, _MAX_PATH-1);
		lpCmdLineW[_MAX_PATH-1] = TEXT('\0');

		StrTrim(szFileName, TEXT("\"\0"));

		// Load the settings file back in.
		HANDLE hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if(hFile != INVALID_HANDLE_VALUE)
		{
            // declare structs for each scheme we might encounter

            WIZSCHEME_LEGACY_STRUCT(WIZSCHEME_WIN9X, schemeLegacyWin9x, COLOR_MAX_WIN9X) /* Win9x & Millen */
            WIZSCHEME_LEGACY_STRUCT(WIZSCHEME_NT400, schemeLegacyNT400, COLOR_MAX_NT400) /* WinNT 4.0 */
            WIZSCHEME_LEGACY_STRUCT(WIZSCHEME_NT500, schemeLegacyNT500, COLOR_MAX_NT500) /* Win2K */
            WIZSCHEME_LEGACY_STRUCT(WIZSCHEME_NT401, schemeLegacyNT501, COLOR_MAX_NT501) /* WinXP */

            // see if we can find the right scheme in order of ascending size

            #define OLD2NEW_SCHEME(scheme) \
            { \
				BOOL bResult; \
			    DWORD dwRead; \
                bResult = ReadFile(hFile, (LPVOID)&scheme, sizeof(scheme), &dwRead, NULL); \
                if (bResult==0 || dwRead != scheme.m_cbSize) \
                { \
		            StringTableMessageBox(NULL, IDS_WIZERRORLOADINGFILETEXT, IDS_WIZERRORLOADINGFILETITLE, MB_OK); \
		            return 0; \
                } \
                WIZSCHEME_COPY_LEGACY(g_Options.m_schemePreview, scheme) \
                /* legacy schemes wouldn't have theme or wallpaper set */ \
                g_Options.m_schemePreview.ClearTheme(); \
                g_Options.m_schemePreview.ClearWallpaper(); \
                /* figure out what the legacy scheme's SelectedStyle and SelectedSize is */ \
                g_Options.m_schemePreview.SetStyleNSize(); \
            }

			DWORD dwFileSize = GetFileSize(hFile, NULL);
            if (dwFileSize == schemeLegacyWin9x.m_cbSize)
            {
                OLD2NEW_SCHEME(schemeLegacyWin9x)
            }
            else if (dwFileSize == schemeLegacyNT400.m_cbSize)
            {
                OLD2NEW_SCHEME(schemeLegacyNT400)
            }
            else if (dwFileSize == schemeLegacyNT500.m_cbSize)
            {
                OLD2NEW_SCHEME(schemeLegacyNT500)
            }
            else if (dwFileSize == schemeLegacyNT501.m_cbSize)
            {
                OLD2NEW_SCHEME(schemeLegacyNT501)
            }
            else
            {
				StringTableMessageBox(NULL, IDS_WIZERRORLOADINGFILETEXT, IDS_WIZERRORLOADINGFILETITLE, MB_OK);
				return 0;
            }

			// IMPORTANT: For loaded schemes, we always want to change to the windows default font
			g_Options.m_schemePreview.m_PortableNonClientMetrics.m_nFontFaces = 1;

			g_bHACKHACKSavedOptions = TRUE;
			g_Options.ApplyPreview();
		}
		else
		{
			StringTableMessageBox(NULL, IDS_WIZERRORLOADINGFILETEXT, IDS_WIZERRORLOADINGFILETITLE, MB_OK);
			return 0;
		}

	}

#ifdef UNICODE	
	AccWiz_RunDllW(NULL, hInstance, lpCmdLineW, nCmdShow);
#else
	AccWiz_RunDllA(NULL, hInstance, lpCmdLineW, nCmdShow);
#endif

	return 0;
}


HRESULT
CreateAndRunWizard(
				   HWND hwndParent);

HRESULT
CreateAndRunWizard2(
				   HWND hwndParent);

HRESULT
OnProcessAttach(
				HINSTANCE hInstDll);

HRESULT
OnProcessDetach(
				VOID);

INT
PropSheetCallback(
				  HWND hwnd,
				  UINT uMsg,
				  LPARAM lParam);


VOID WINAPI AccWiz_RunDllA(HWND hwnd, HINSTANCE hInstance, LPSTR pszCmdLineA, INT nCmdShow)
{
	if (NULL != pszCmdLineA)
	{
		LPWSTR pszCmdLineW = NULL;
		INT cchCmdLine = MultiByteToWideChar(CP_ACP,
											 0,
											 pszCmdLineA,
											 -1,
											 NULL,
											 0);
		pszCmdLineW = new WCHAR[cchCmdLine];
		if (NULL != pszCmdLineW)
		{
			MultiByteToWideChar(CP_ACP,
								0,
								pszCmdLineA,
								-1,
								pszCmdLineW,
								cchCmdLine);

			AccWiz_RunDllW(hwnd, hInstance, pszCmdLineW, nCmdShow);

			delete[] pszCmdLineW;
		}
	}
}


VOID WINAPI AccWiz_RunDllW(HWND hwnd, HINSTANCE hInstance, LPWSTR pszCmdLineW, INT nCmdShow)
{
	HWND hwndParent   = GetDesktopWindow();

	HRESULT hResult;
	if(!g_bHACKHACKSavedOptions)
		hResult = CreateAndRunWizard(hwndParent);
	else
		hResult = CreateAndRunWizard2(hwndParent);


	if(!SUCCEEDED(hResult))
	{
		// TODO: Put out of memory message here
		_ASSERTE(FALSE);
#pragma message("Put Out of Memory message here")
	}
}



const INT MAX_PAGES  = 26;

HRESULT
CreateAndRunWizard(
				   HWND hwndParent)
{
	HRESULT hResult = E_OUTOFMEMORY;
	
	PROPSHEETPAGE psp[MAX_PAGES];
	WizardPage *rgpwp[MAX_PAGES];
	
	// Zero init the arrays
	memset(psp, 0, sizeof(psp));
	memset(rgpwp, 0, sizeof(rgpwp));
	
	// ///////////////////////
	// Create Pages Here - NOTE: Order does not matter - we'll control it with our own list
	//
	int nCountPages = 0;
	rgpwp[nCountPages++] = new CWizWelcomePg(psp + nCountPages);
	rgpwp[nCountPages++] = new CWelcomePg(psp + nCountPages);
	rgpwp[nCountPages++] = new CWelcome2Pg(psp + nCountPages);

	rgpwp[nCountPages++] = new CWizardOptionsPg(psp + nCountPages);
	
	rgpwp[nCountPages++] = new CScrollBarPg(psp + nCountPages);

	rgpwp[nCountPages++] = new CIconSizePg(psp + nCountPages);


	// Color	
	rgpwp[nCountPages++] = new CLookPreviewColorPg(psp + nCountPages);
	
	// Sound
	rgpwp[nCountPages++] = new CSoundSentryPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CShowSoundsPg(psp + nCountPages);
	
	// Keyboard
	rgpwp[nCountPages++] = new CStickyKeysPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CFilterKeysPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CFilterKeysSettingsPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CToggleKeysPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CShowKeyboardHelpPg(psp + nCountPages);
	
	// Mouse
	rgpwp[nCountPages++] = new CMouseKeysPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CMouseKeysSettingsPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CMouseTrailsPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CMouseCursorPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CMouseButtonPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CMouseSpeedPg(psp + nCountPages);
    rgpwp[nCountPages++] = new CCaretPg(psp + nCountPages);

	
	// Standard Wizard pages
	rgpwp[nCountPages++] = new CGenericWizPg(psp + nCountPages, IDD_WIZNOOPTIONSSELECTED, IDS_WIZNOOPTIONSSELECTEDTITLE, IDS_WIZNOOPTIONSSELECTEDSUBTITLE);
	rgpwp[nCountPages++] = new CAccessTimeOutPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CSaveForDefaultUserPg(psp + nCountPages);
	rgpwp[nCountPages++] = new CSaveToFilePg(psp + nCountPages);
	rgpwp[nCountPages++] = new FinishWizPg(psp + nCountPages);
	
	// Make sure we have the correct number of pages in our wizard
	_ASSERTE(MAX_PAGES == nCountPages);
	
	// Make sure pages were created
	for (int i = 0; i < nCountPages; i++)
	{
		if (NULL == rgpwp[i])
			break;
	}
	
	if(i<nCountPages)
	{
		// We didn't have enough memory to create all the pages
		// Clean out allocated pages and return
		for(int i=0;i<nCountPages;i++)
			if(rgpwp[i])
				delete rgpwp[i];
			return E_OUTOFMEMORY;
	}


	
	// Create the orders for the pages to be run
	DWORD rgdwMainPath[] = {
                        IDD_WIZNEWWELCOME,
						IDD_WIZWELCOME,
						IDD_WIZWELCOME2,
						IDD_WIZOPTIONS,
						IDD_WIZFINISH // We need this placeholder here so we get a 'NEXT' button on IDD_WIZOPTIONS
							};

	if(!WizardPage::sm_WizPageOrder.AddPages(0xFFFFFFFF, rgdwMainPath, ARRAYSIZE(rgdwMainPath)))
		return E_OUTOFMEMORY;

	/////////////////////////////////////////////
	// See if we need the 16 or 256 color bitmap
	BOOL bUse256ColorBmp = FALSE;
	HDC hdc = GetDC(NULL);
	if(hdc)
	{
		if(GetDeviceCaps(hdc,BITSPIXEL) >= 8)
			bUse256ColorBmp = TRUE;
		ReleaseDC(NULL, hdc);
	}


	////////////////////////////////
	// Do the property sheet

	PROPSHEETHEADER psh;
	memset(&psh, 0, sizeof(psh));
	psh.dwSize		= sizeof(PROPSHEETHEADER);
	psh.dwFlags 	= PSH_USECALLBACK | PSH_WIZARD | PSH_PROPSHEETPAGE
		| PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER /*| *//*PSH_STRETCHWATERMARK*/;
	psh.hwndParent	= hwndParent;
	psh.hInstance	= g_hInstDll;
	psh.pszIcon 	= NULL;
	psh.pszCaption	= NULL;
	psh.nPages		= MAX_PAGES;
	psh.nStartPage	= 54331; // We will actually set it in PropSheetCallback to rgdwMainPath[0]
	// NOTE: Bug - This only works if nStartPage is non-zero
	psh.ppsp		= psp;
	psh.pfnCallback = PropSheetCallback;

#if 0
	psh.nStartPage	= 0; // We will actually set it in PropSheetCallback to rgdwMainPath[0]
	psh.pfnCallback = NULL;
	psh.dwFlags 	= PSH_WIZARD | PSH_PROPSHEETPAGE;
#endif
	
	psh.pszbmWatermark = MAKEINTRESOURCE(IDB_ACCWIZ);
    psh.pszbmHeader = MAKEINTRESOURCE(IDB_ACCMARK);

#if 0 // Right now, no watermarks
	psh.pszbmWatermark = bUse256ColorBmp?MAKEINTRESOURCE(IDB_WATERMARK256):MAKEINTRESOURCE(IDB_WATERMARK16);
	psh.pszbmHeader = bUse256ColorBmp?MAKEINTRESOURCE(IDB_BANNER256):MAKEINTRESOURCE(IDB_BANNER16);
#endif
   
	
    if (-1 != PropertySheet(&psh))
		hResult = NO_ERROR;
	else
		hResult = E_FAIL;

    // Clean up memory allocated for WizardPage's
	for(i=0;i<nCountPages;i++)
		if(rgpwp[i])
			delete rgpwp[i];
		
	
	return hResult;
}












HRESULT
CreateAndRunWizard2(
				   HWND hwndParent)
{
	HRESULT hResult = E_OUTOFMEMORY;
	
	PROPSHEETPAGE psp[1];
	WizardPage *rgpwp[1];
	
	// Zero init the arrays
	memset(psp, 0, sizeof(psp));
	memset(rgpwp, 0, sizeof(rgpwp));
	
	// ///////////////////////
	// Create Pages Here - NOTE: Order does not matter - we'll control it with our own list
	//
	int nCountPages = 0;
	rgpwp[nCountPages++] = new FinishWizPg(psp + nCountPages);
	
	// Make sure pages were created
	for (int i = 0; i < nCountPages; i++)
	{
		if (NULL == rgpwp[i])
			break;
	}
	
	if(i<nCountPages)
	{
		// We didn't have enough memory to create all the pages
		// Clean out allocated pages and return
		for(int i=0;i<nCountPages;i++)
			if(rgpwp[i])
				delete rgpwp[i];
			return E_OUTOFMEMORY;
	}


	
	// Create the orders for the pages to be run
	DWORD rgdwMainPath[] = {
						IDD_WIZFINISH // We need this placeholder here so we get a 'NEXT' button on IDD_WIZOPTIONS
							};

	if(!WizardPage::sm_WizPageOrder.AddPages(0xFFFFFFFF, rgdwMainPath, ARRAYSIZE(rgdwMainPath)))
		return E_OUTOFMEMORY;

	/////////////////////////////////////////////
	// See if we need the 16 or 256 color bitmap
	BOOL bUse256ColorBmp = FALSE;
	HDC hdc = GetDC(NULL);
	if(hdc)
	{
		if(GetDeviceCaps(hdc,BITSPIXEL) >= 8)
			bUse256ColorBmp = TRUE;
		ReleaseDC(NULL, hdc);
	}


	////////////////////////////////
	// Do the property sheet

	PROPSHEETHEADER psh;
	memset(&psh, 0, sizeof(psh));
	psh.dwSize		= sizeof(PROPSHEETHEADER);
	psh.dwFlags 	= PSH_USECALLBACK | PSH_WIZARD | PSH_PROPSHEETPAGE
		| PSH_WIZARD97 | PSH_WATERMARK |PSH_HEADER /*| *//*PSH_STRETCHWATERMARK*/;
	psh.hwndParent	= hwndParent;
	psh.hInstance	= g_hInstDll;
	psh.pszIcon 	= NULL;
	psh.pszCaption	= NULL;
	psh.nPages		= 1;
	psh.nStartPage	= 54331; // We will actually set it in PropSheetCallback to rgdwMainPath[0]
	// NOTE: Bug - This only works if nStartPage is non-zero
	psh.ppsp		= psp;
	psh.pfnCallback = PropSheetCallback;

#if 0
	psh.nStartPage	= 0; // We will actually set it in PropSheetCallback to rgdwMainPath[0]
	psh.pfnCallback = NULL;
	psh.dwFlags 	= PSH_WIZARD | PSH_PROPSHEETPAGE;
#endif
	
	psh.pszbmWatermark = MAKEINTRESOURCE(IDB_ACCWIZ);
    psh.pszbmHeader = MAKEINTRESOURCE(IDB_ACCMARK);

#if 0 // Right now, no watermarks
	psh.pszbmWatermark = bUse256ColorBmp?MAKEINTRESOURCE(IDB_WATERMARK256):MAKEINTRESOURCE(IDB_WATERMARK16);
	psh.pszbmHeader = bUse256ColorBmp?MAKEINTRESOURCE(IDB_BANNER256):MAKEINTRESOURCE(IDB_BANNER16);
#endif
	
	if (-1 != PropertySheet(&psh))
		hResult = NO_ERROR;
	else
		hResult = E_FAIL;
	
	// Clean up memory allocated for WizardPage's
	for(i=0;i<nCountPages;i++)
		if(rgpwp[i])
			delete rgpwp[i];
		
		
		
		
		
	return hResult;
}















INT
PropSheetCallback(
				  HWND hwnd,
				  UINT uMsg,
				  LPARAM lParam
				  )
{
	switch(uMsg)
	{
	case PSCB_PRECREATE:
		break;
		
	case PSCB_INITIALIZED:
        {
            // Set the first page according to are global list of page orders
            //			PropSheet_SetCurSelByID(hwnd, WizardPage::sm_WizPageOrder.GetFirstPage());
            // HACK - Set TO Options page since we added WIZWIZ page
            
            // HACK. Remove Context Sensitive help
            LONG Style = GetWindowLong(hwnd, GWL_EXSTYLE);
            
            if(0 == Style)
            {
                // DbgTrace((DEBUG_ERROR, "GetWindowLong failed. WizDlgs.cpp\n"));
                // DbgTraceSystemError(GetLastError());
            }
            if(0 == SetWindowLong(hwnd, GWL_EXSTYLE, Style & ~WS_EX_CONTEXTHELP))
            {
                // DbgTrace((DEBUG_ERROR, "SetWindowLong failed. WizDlgs.cpp\n"));
                // DbgTraceSystemError(GetLastError());
            }

#ifdef WIZWIZ
			_ASSERTE(IDD_WIZWIZ == WizardPage::sm_WizPageOrder.GetFirstPage()); // Change this if we remove the wiz wiz page
			PropSheet_SetCurSelByID(hwnd, IDD_WIZWELCOME);
#endif
		}
		break;
	}
	return 0;
}


// Helper functions
// Helper function
void LoadArrayFromStringTable(int nIdString, int *rgnValues, int *pnCountValues)
{
	// This function load the allowed value array from the string table
	// If the values are not stored in the string table, the function
	// can be overridden in a derived class
	// Load in allowed sizes for scroll bar from string table

	_ASSERTE(nIdString); // Make sure we were passed a string

	TCHAR szArray[255];
    LoadString(g_hInstDll, nIdString, szArray, ARRAYSIZE(szArray));

	// Assume at most MAX_DISTINCT_VALUES sizes
	LPTSTR szCurrentLocation = szArray;
	for(int i=0;i<MAX_DISTINCT_VALUES;i++)
	{
		if(!szCurrentLocation)
			break;
		int cFlds = _stscanf(szCurrentLocation, __TEXT("%i"), &rgnValues[i]);
		_ASSERTE(cFlds);
		if (!cFlds)
			break;	// Prefix #113775 (no more fields)

		// Find the next space
		// NOTE: If there are more than one spaces between characters, this will read the same entry twice
		szCurrentLocation = _tcschr(++szCurrentLocation, __TEXT(' '));
	}
	*pnCountValues = i;
	_ASSERTE(*pnCountValues);
}



// This function is prototyped in the pre-compiled header
int StringTableMessageBox(HWND hWnd, int nText, int nCaption, UINT uType)
{
	TCHAR szTitle[1024];
	TCHAR szText[1024];
	LoadString(g_hInstDll, nCaption, szTitle, ARRAYSIZE(szTitle));
	LoadString(g_hInstDll, nText, szText, ARRAYSIZE(szText));
	return MessageBox(hWnd, szText, szTitle, uType);
}

void CAccWizOptions::ApplyWindowsDefault()
{
    HKEY hkey;
    DWORD dwDisposition;
    DWORD len;
    
    m_schemeCurrent.ApplyChanges(m_schemeWindowsDefault);
    
    // BUG: Update the preview scheme. Else will put back the old 
    // color scheme if something changes
    m_schemePreview = m_schemeWindowsDefault;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\curschme.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "CurSchme.h"

DWORD g_dwSchemeSource;

static LPCTSTR g_rgszCursorNames[] = 
{
	__TEXT("Arrow"),    
	__TEXT("Help"),       
	__TEXT("AppStarting"),
	__TEXT("Wait"),       
	__TEXT("Crosshair"),  
	__TEXT("IBeam"),      
	__TEXT("NWPen"),      
	__TEXT("No"),         
	__TEXT("SizeNS"),     
	__TEXT("SizeWE"),     
	__TEXT("SizeNWSE"),   
	__TEXT("SizeNESW"),   
	__TEXT("SizeAll"),    
	__TEXT("UpArrow"),    
	__TEXT("Hand"),       
	NULL // This is the default value
};


#define CCURSORS   (sizeof(g_rgszCursorNames) / sizeof(g_rgszCursorNames[0]))

TCHAR g_szOrigCursors[CCURSORS][_MAX_PATH];
DWORD g_dwOrigSchemeSource = 0;

const TCHAR g_szCursorRegPath[] = REGSTR_PATH_CURSORS;
const TCHAR szSchemeSource[] = TEXT("Scheme Source");


TCHAR g_szSchemeNames[8][100]; // HACK - We have to make sure the scheme names are less than 100 characters



typedef
LANGID
(WINAPI *pfnGetUserDefaultUILanguage)(
    void
    );
typedef
LANGID
(WINAPI *pfnGetSystemDefaultUILanguage)(
    void
    );


BOOL IsMUI_Enabled()
{

    OSVERSIONINFO verinfo;
    LANGID        rcLang;
    HMODULE       hModule;
    pfnGetUserDefaultUILanguage gpfnGetUserDefaultUILanguage;     
    pfnGetSystemDefaultUILanguage gpfnGetSystemDefaultUILanguage; 
    static        g_bPFNLoaded=FALSE;
    static        g_bMUIStatus=FALSE;


    if(g_bPFNLoaded)
       return g_bMUIStatus;

    g_bPFNLoaded = TRUE;

    verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);    
    GetVersionEx( &verinfo) ;

    if (verinfo.dwMajorVersion == 5)        
    {   

       hModule = GetModuleHandle(TEXT("kernel32.dll"));
       if (hModule)
       {
          gpfnGetSystemDefaultUILanguage =
          (pfnGetSystemDefaultUILanguage)GetProcAddress(hModule,"GetSystemDefaultUILanguage");
          if (gpfnGetSystemDefaultUILanguage)
          {
             rcLang = (LANGID) gpfnGetSystemDefaultUILanguage();
             if (rcLang == 0x409 )
             {  
                gpfnGetUserDefaultUILanguage =
                (pfnGetUserDefaultUILanguage)GetProcAddress(hModule,"GetUserDefaultUILanguage");
                
                if (gpfnGetUserDefaultUILanguage)
                {
                   if (rcLang != (LANGID)gpfnGetUserDefaultUILanguage() )
                   {
                       g_bMUIStatus = TRUE;
                   }

                }
             }
          }
       }
    }
    return g_bMUIStatus;
}

void LoadCursorSchemeNames()
{  
	static BOOL g_bSchemeNamesLoaded = FALSE;
   
	if(g_bSchemeNamesLoaded)
		return;
	g_bSchemeNamesLoaded = TRUE;
   if (!IsMUI_Enabled())
   {
	LoadString(g_hInstDll, IDS_CURSOR_SCHEME_WINDOWS_STANDARD_LARGE     , g_szSchemeNames[0], 100);
   	LoadString(g_hInstDll, IDS_CURSOR_SCHEME_WINDOWS_STANDARD_EXTRALARGE, g_szSchemeNames[1], 100);
   	LoadString(g_hInstDll, IDS_CURSOR_SCHEME_WINDOWS_BLACK              , g_szSchemeNames[2], 100);
   	LoadString(g_hInstDll, IDS_CURSOR_SCHEME_WINDOWS_BLACK_LARGE        , g_szSchemeNames[3], 100);
   	LoadString(g_hInstDll, IDS_CURSOR_SCHEME_WINDOWS_BLACK_EXTRALARGE   , g_szSchemeNames[4], 100);
   	LoadString(g_hInstDll, IDS_CURSOR_SCHEME_WINDOWS_INVERTED           , g_szSchemeNames[5], 100);
   	LoadString(g_hInstDll, IDS_CURSOR_SCHEME_WINDOWS_INVERTED_LARGE     , g_szSchemeNames[6], 100);
   	LoadString(g_hInstDll, IDS_CURSOR_SCHEME_WINDOWS_INVERTED_EXTRALARGE, g_szSchemeNames[7], 100);
   }
   else
   {     
      lstrcpy(g_szSchemeNames[0],IDSENG_CURSOR_SCHEME_WINDOWS_STANDARD_LARGE);    
      lstrcpy(g_szSchemeNames[1],IDSENG_CURSOR_SCHEME_WINDOWS_STANDARD_EXTRALARGE);
      lstrcpy(g_szSchemeNames[2],IDSENG_CURSOR_SCHEME_WINDOWS_BLACK);
      lstrcpy(g_szSchemeNames[3],IDSENG_CURSOR_SCHEME_WINDOWS_BLACK_LARGE);
      lstrcpy(g_szSchemeNames[4],IDSENG_CURSOR_SCHEME_WINDOWS_BLACK_EXTRALARGE);
      lstrcpy(g_szSchemeNames[5],IDSENG_CURSOR_SCHEME_WINDOWS_INVERTED);
      lstrcpy(g_szSchemeNames[6],IDSENG_CURSOR_SCHEME_WINDOWS_INVERTED_LARGE);
      lstrcpy(g_szSchemeNames[7],IDSENG_CURSOR_SCHEME_WINDOWS_INVERTED_EXTRALARGE);
   }
   
	// Load the current cursor settings
	HKEY hkCursors;
	if (ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, g_szCursorRegPath, 0, KEY_READ,
		 &hkCursors ))
	{
		for(int i=0;i<CCURSORS;i++)
		{
			g_szOrigCursors[i][0] = 0;
			DWORD dwCount = _MAX_PATH * sizeof(TCHAR);
			DWORD dwType;
			RegQueryValueEx( hkCursors,
					         g_rgszCursorNames[i],
					         NULL,
					         &dwType,
					         (LPBYTE)g_szOrigCursors[i],
					         &dwCount );
			g_szOrigCursors[i][ARRAYSIZE(g_szOrigCursors[i])-1] = TEXT('\0'); // ensure NUL termination
      
		}
		// Get the scheme source value
		DWORD dwLen = sizeof(g_dwOrigSchemeSource);
		if (RegQueryValueEx( hkCursors, szSchemeSource, NULL, NULL, (unsigned char *)&g_dwOrigSchemeSource, &dwLen ) != ERROR_SUCCESS)
			g_dwOrigSchemeSource = 1;
		RegCloseKey(hkCursors);
	}
	else
		_ASSERTE(FALSE);

}

static const TCHAR c_szRegPathCursorSchemes[] = REGSTR_PATH_CURSORS TEXT( "\\Schemes" );
static const TCHAR c_szRegPathSystemSchemes[] = REGSTR_PATH_SETUP TEXT("\\Control Panel\\Cursors\\Schemes");



// ApplyScheme(int nScheme)
// '0' Scheme loaded in g_szOrigScheme
// '1' Windows Default
// '2' Standard Large
// '3' Standard Ex Large
// '4' Black
// '5' Black Large
// '6' Black Ex Large
// '7' Inverted
// '8' Inverted Large
// '9' Inverted Ex Large
void ApplyCursorScheme(int nScheme)
{
	LoadCursorSchemeNames();
	HKEY hkCursors;
    DWORD dwPosition;

    // Initially for default cursor, The registry "\\ControlPanel\Cursors" is not created 
    // so. Create the registry values: a-anilk
	if(ERROR_SUCCESS != RegCreateKeyEx( HKEY_CURRENT_USER, g_szCursorRegPath, 0L, TEXT(""), 
        REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkCursors, &dwPosition ))
		return;

	int i;

	DWORD dwSchemeSource;

	switch(nScheme)
	{
	case 0: // Original scheme
		dwSchemeSource = g_dwOrigSchemeSource;
		for(i=0;i<CCURSORS;i++)
			RegSetValueEx( hkCursors, g_rgszCursorNames[i], 0L, REG_SZ, (CONST LPBYTE)g_szOrigCursors[i], (lstrlen(g_szOrigCursors[i])+1)*sizeof(TCHAR));
		break;
	case 1: // Windows default
		dwSchemeSource = 0;
		for(i=0;i<CCURSORS;i++)
			RegSetValueEx( hkCursors, g_rgszCursorNames[i], 0L, REG_SZ, (CONST LPBYTE)TEXT(""), sizeof(TCHAR));
		break;
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
	case 7:
	case 8:
	case 9:
		{
			dwSchemeSource = 2; // Assume System schemes
			HKEY hkScheme;
			// Try to find the 'system' schemes first
			if(ERROR_SUCCESS != RegOpenKeyEx( HKEY_LOCAL_MACHINE, c_szRegPathSystemSchemes, 
				0, KEY_READ,&hkScheme ))
			{
				// Couldn't find system schemes, try looking in user schemes
				dwSchemeSource = 1; // User schemes
				if(ERROR_SUCCESS != RegOpenKeyEx( HKEY_CURRENT_USER, c_szRegPathCursorSchemes, 0, KEY_READ, &hkScheme ))
					return;
			}

			DWORD dwCount = 0;
			DWORD dwType;
			long nResult;
			if(ERROR_SUCCESS != (nResult = RegQueryValueEx( hkScheme, g_szSchemeNames[nScheme - 2], NULL, &dwType, NULL, &dwCount )))
				dwCount = sizeof TCHAR; // The value probably was not there.  Fake it and allocate 1 byte.

			DWORD dwOrigCount = dwCount;
	
			LPTSTR lpszData = (LPTSTR)new BYTE[dwCount]; // NOTE: For Unicode, RegQueryValueEx still returns the 'Byte' size not 'Char count'
			lpszData[0] = 0;

			if(ERROR_SUCCESS == nResult)
				RegQueryValueEx( hkScheme, g_szSchemeNames[nScheme - 2], NULL, &dwType, (LPBYTE)lpszData, &dwCount );
			lpszData[dwOrigCount/(sizeof TCHAR)-1] = TEXT('\0'); // ensure NUL termination

			LPTSTR lpszCurrentValue = lpszData;
			LPTSTR lpszFinalNULL = lpszData + lstrlen(lpszData);
			// Parse the information
			for(i=0;i<CCURSORS;i++)
			{
				// Hack to set the default value
				if(CCURSORS - 1 == i)
				{
					lpszCurrentValue = g_szSchemeNames[nScheme - 2];
					RegSetValueEx( hkCursors, NULL, 0L, REG_SZ, (CONST LPBYTE)lpszCurrentValue, (lstrlen(lpszCurrentValue)+1)*sizeof(TCHAR));
				}
				else
				{
					// Find next comma
					LPTSTR lpszComma = _tcschr(lpszCurrentValue, __TEXT(','));
					// Turn it into a zero
					if(lpszComma)
						*lpszComma = 0;
					RegSetValueEx( hkCursors, g_rgszCursorNames[i], 0L, REG_SZ, (CONST LPBYTE)lpszCurrentValue, (lstrlen(lpszCurrentValue)+1)*sizeof(TCHAR));
					lpszCurrentValue = min(lpszFinalNULL, lpszCurrentValue + lstrlen(lpszCurrentValue) + 1);
				}

			}
			delete [] lpszData;
			RegCloseKey(hkScheme);
		}
		break;
	default:
		_ASSERTE(FALSE);

	}

	// Save the 'Scheme Source'
	RegSetValueEx(hkCursors, szSchemeSource, 0, REG_DWORD, (unsigned char *)&dwSchemeSource, sizeof(dwSchemeSource));
	
	RegCloseKey(hkCursors);
	SystemParametersInfo( SPI_SETCURSORS, 0, 0, SPIF_SENDCHANGE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\curschme.h ===
//Copyright (c) 1997-2000 Microsoft Corporation


#ifndef _INC_CURSCHME_H
#define _INC_CURSCHME_H

void ApplyCursorScheme(int nScheme);
#define IDSENG_CURSOR_SCHEME_WINDOWS_STANDARD_LARGE      __TEXT("Windows Standard (large)")
#define IDSENG_CURSOR_SCHEME_WINDOWS_STANDARD_EXTRALARGE __TEXT("Windows Standard (extra large)")
#define IDSENG_CURSOR_SCHEME_WINDOWS_BLACK               __TEXT("Windows Black ")
#define IDSENG_CURSOR_SCHEME_WINDOWS_BLACK_LARGE         __TEXT("Windows Black (large)")
#define IDSENG_CURSOR_SCHEME_WINDOWS_BLACK_EXTRALARGE    __TEXT("Windows Black (extra large)")
#define IDSENG_CURSOR_SCHEME_WINDOWS_INVERTED            __TEXT("Windows Inverted")
#define IDSENG_CURSOR_SCHEME_WINDOWS_INVERTED_LARGE      __TEXT("Windows Inverted (large)") 
#define IDSENG_CURSOR_SCHEME_WINDOWS_INVERTED_EXTRALARGE __TEXT("Windows Inverted (extra large)")            


#endif // _INC_CURSCHME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\dlgfonts.h ===
//Copyright (c) 1997-2000 Microsoft Corporation



////////////////////////////////////
//
// Stuff used for different fonts in dialogs
//

void DialogFonts_InitWizardPage(
	IN HWND hwndWizardPage
	);

//
////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\desk.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifdef ARRAYSIZE
#undef ARRAYSIZE
#endif

#ifdef SIZEOF
#undef SIZEOF
#endif

#define CCH_NONE          20        /* ARRAYSIZE( "(None)" ), big enough for German */
#define CCH_CLOSE         20        /* ARRAYSIZE( "Close" ), big enough for German */

#define CMSEC_COVER_WINDOW_TIMEOUT  (15 * 1000)     // 15 second timeout
#define ID_CVRWND_TIMER             0x96F251CC      // somewhat uniq id

// information about the monitor bitmap
// x, y, dx, dy define the size of the "screen" part of the bitmap
// the RGB is the color of the screen's desktop
// these numbers are VERY hard-coded to a monitor bitmap
#define MON_X   16
#define MON_Y   17
#define MON_DX  152
#define MON_DY  112
#define MON_RGB RGB(0, 128, 128)
#define MON_TRAY 8


#define         MIN_MINUTES     1
#define         MAX_MINUTES     60
#define         BUFFER_SIZE     400

#define         MAX_METHODS     100

VOID RefreshColors (void);

BOOL DeskInitCpl(void);
void DeskShowPropSheet( HINSTANCE hInst, HWND hwndParent, LPCTSTR szCmdLine );

BOOL APIENTRY BackgroundDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
BOOL APIENTRY ScreenSaverDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
BOOL APIENTRY AppearanceDlgProc( HWND hDlg, UINT message, UINT   wParam, LONG   lParam);
BOOL CALLBACK DisplayPageProc(   HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

BOOL FAR GetMonitorSettingsPage(LPPROPSHEETPAGE psp, int iDevice);

BOOL APIENTRY DeskDefPropPageProc( HWND hDlg, UINT message, UINT wParam, LONG lParam);
LONG WINAPI MyStrToLong(LPCTSTR sz);

// background previewer includes

#define DIBERR_SUCCESS  1       // successful open
#define DIBERR_NOOPEN   -1      // file could not be opened
#define DIBERR_INVALID  -2      // file is not a valid bitmap

#define BP_NEWPAT       0x01    // pattern changed
#define BP_NEWWALL      0x02    // wallpaper changed
#define BP_TILE         0x04    // tile the wallpaper (center otherwise)
#define BP_REINIT       0x08    // reload the image (system colors changed)

#define WM_SETBACKINFO (WM_USER + 1)

#define BACKPREV_CLASS TEXT("BackgroundPreview")
#define LOOKPREV_CLASS TEXT("LookPreview")

BOOL FAR PASCAL RegisterBackPreviewClass(HINSTANCE hInst);
BOOL FAR PASCAL RegisterLookPreviewClass(HINSTANCE hInst);

HBITMAP FAR LoadMonitorBitmap( BOOL bFillDesktop );

#ifdef UNICODE
    UINT WinExecN( LPCTSTR lpCmdLine, UINT uCmdShow );
#else
    // If we're on Win95, then just use the ANSI-only WinExec instead of
    // rolling our own
#   define WinExecN    WinExec
#endif

#define SETTINGSPAGE_DEFAULT    -1
#define SETTINGSPAGE_FALLBACK   0

#define Assert(p)   /* nothing */

#define ARRAYSIZE( a )  (sizeof(a) / sizeof(a[0]))
#define SIZEOF( a )     sizeof(a)


//
// CreateCoverWindow
//
// creates a window which obscures the display
//  flags:
//      0 means erase to black
//      COVER_NOPAINT means "freeze" the display
//
// just post it a WM_CLOSE when you're done with it
//
#define COVER_NOPAINT (0x1)
//
HWND FAR PASCAL CreateCoverWindow( DWORD flags );
//

//
// Macro to replace MAKEPOINT() since points now have 32 bit x & y
//
#define LPARAM2POINT( lp, ppt ) \
    ((ppt)->x = LOWORD(lp), (ppt)->y = HIWORD(lp))

//
// Globals
//

extern TCHAR g_szNULL[];
extern TCHAR g_szNone[CCH_NONE];
extern TCHAR g_szClose[CCH_CLOSE];
extern TCHAR g_szControlIni[];
extern TCHAR g_szPatterns[];

extern TCHAR g_szCurPattern[];   // name of currently selected pattern
extern TCHAR g_szCurWallpaper[]; // name of currently selected wallpaper
extern BOOL g_bValidBitmap;     // whether or not wallpaper is valid

extern TCHAR g_szBoot[];
extern TCHAR g_szSystemIni[];
extern TCHAR g_szWindows[];

extern HDC g_hdcMem;

#if 0
#   pragma message(__FILE__"(134): warning : remove debug code before checkin")
#   define DBG_PRINT
#   define DPRINT(s)   OutputDebugString(TEXT(s) TEXT("\n"))
#   define DPRINTF(p)   if(1){TCHAR szdbuf[256]; wsprintf p; OutputDebugString(szdbuf);}else

#   ifdef DM_TRACE
#       undef DM_TRACE
#   endif
#   define DM_TRACE     szdbuf
#else
// Remove all the DPRINTS once we have debugged USER
#   define DPRINT(s)
#   define DPRINTF(p)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\deskid.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#define IDC_STATIC                      -1

#define DLG_SCREENSAVER  150
#define DLG_BACKGROUND   151
#define DLG_APPEARANCE   152
#define DLG_MONITOR      153
#define DLG_ADAPTER      154
#define DLG_CUSTOMFONT   155
#define DLG_COLORPICK    156
#define DLG_PATTERN      157
#define DLG_MULTIMONITOR 159

#define DLG_FLICKER	160
#define DLG_KEEPNEW	161
#define DLG_SAVESCHEME	162

#define IDS_ICON    40
#define IDS_NAME    41
#define IDS_INFO    42
#define IDS_DESK_NOMEM  43

#define IDB_VIDMETR	120
#define IDB_COLOR1	121
#define IDB_COLOR4	122
#define IDB_COLOR8	123
#define IDB_ENERGYSTAR	124

#define IDC_NO_HELP_1	200	// Used in place of IDC_STATIC when context Help
#define IDC_NO_HELP_2	201	// should be disabled for a control
#define IDC_NO_HELP_3	202	

// screen saver controls
#define IDC_CHOICES		1000
#define IDC_METHOD              1001
#define IDC_BIGICON             1002
#define IDC_SETTING             1003
#define IDC_TEST                1004
#define IDC_ENERGYSTAR_BMP	1005
#define IDC_SCREENSAVEDELAY     1006
#define IDC_SCREENSAVEARROW     1007

#define IDC_LOWPOWERCONFIG      1008

//                              1014        unused
#define IDC_DEMO                1015
#define IDC_SSDELAYLABEL        1016
#define IDC_ENERGY_TEXT         1017
#define IDC_ENERGY_TEXT2        1018
#define IDC_ENERGY_TEXT3        1019
#define IDC_USEPASSWORD	        1020
#define IDC_SETPASSWORD         1021
#define IDC_SSDELAYSCALE        1022

#define IDS_POWERCFG_CMDLINE    1030

// background controls
#define IDC_PATLIST	1100
#define IDC_WALLLIST	1101
#define IDC_EDITPAT	1102
#define IDC_BROWSEWALL	1103
#define IDC_CENTER	1104
#define IDC_TILE	1105
#define IDC_PATTERN	1106
#define IDC_WALLPAPER	1107
#define IDC_BACKPREV	1108
#define IDC_TXT_DISPLAY 1109

// background dialog strings
#define IDS_NONE	1100
#define IDS_UNLISTEDPAT	1101
#define IDS_BITMAPOPENERR	1102
#define IDS_DIB_NOOPEN		1103
#define IDS_DIB_INVALID		1104
#define IDS_DIB_NOMEM		1105
#define IDS_BADWALLPAPER	1106
#define IDS_BROWSETITLE         1107
#define IDS_BROWSEFILTER        1108

// appearance controls
#define IDC_SCHEMES	1400
#define IDC_SAVESCHEME	1401
#define IDC_DELSCHEME	1402
#define IDC_ELEMENTS	1403
#define IDC_MAINSIZE	1404
#define IDC_FONTNAME	1407
#define IDC_FONTSIZE	1408
#define IDC_FONTBOLD	1409
#define IDC_FONTITAL	1410
#define IDC_SIZEARROWS	1411
#define IDC_MAINCOLOR	1412
#define IDC_TEXTCOLOR	1413
#define IDC_GRADCOLOR   1414

#define IDC_SIZELABEL		1450
#define IDC_COLORLABEL		1451
#define IDC_FONTLABEL		1452
#define IDC_FNCOLORLABEL	1453
#define IDC_FONTSIZELABEL	1454

#define IDC_LOOKPREV	1470

// these need to be all clumped together because they are treated as a group
#define IDC_STARTMAINCOLOR	1500
#define IDC_CUSTOMMAINCOLOR	1549
#define IDC_ENDMAINCOLOR	IDC_CUSTOMMAINCOLOR
#define IDC_STARTTEXTCOLOR	1550
#define IDC_CUSTOMTEXTCOLOR	1599
#define IDC_ENDTEXTCOLOR	IDC_CUSTOMTEXTCOLOR

// appearance elements
#define ELNAME_DESKTOP		1401
#define ELNAME_INACTIVECAPTION	1402
#define ELNAME_INACTIVEBORDER	1403
#define ELNAME_ACTIVECAPTION	1404
#define ELNAME_ACTIVEBORDER	1405
#define ELNAME_MENU		1406
#define ELNAME_MENUSELECTED	1407
#define ELNAME_WINDOW		1408
#define ELNAME_SCROLLBAR	1409
#define ELNAME_BUTTON		1410
#define ELNAME_SMALLCAPTION	1411
#define ELNAME_ICONTITLE	1412
#define ELNAME_CAPTIONBUTTON	1413
#define ELNAME_DISABLEDMENU	1414
#define ELNAME_MSGBOX		1415
#define ELNAME_SCROLLBUTTON	1416
#define ELNAME_APPSPACE		1417
#define ELNAME_SMCAPSYSBUT	1418
#define ELNAME_SMALLWINDOW	1419
#define ELNAME_DXICON           1420
#define ELNAME_DYICON           1421
#define ELNAME_INFO             1422
#define ELNAME_ICON             1423
#define ELNAME_SMICON           1424

// appearance strings for sample
#define IDS_ACTIVE	1450
#define IDS_INACTIVE	1451
#define IDS_MINIMIZED	1452
#define IDS_ICONTITLE	1453
#define IDS_NORMAL	1454
#define IDS_DISABLED	1455
#define IDS_SELECTED	1456
#define IDS_MSGBOX	1457
#define IDS_BUTTONTEXT	1458
#define IDS_SMCAPTION	1459
#define IDS_WINDOWTEXT	1460
#define IDS_MSGBOXTEXT	1461

#define IDS_FONTBOLD    1463
#define IDS_FONTITAL    1464

#define IDS_BLANKNAME		1480
#define IDS_NOSCHEME2DEL	1481

// appearance preview menu
#define IDR_MENU	1
#define IDM_NORMAL	10
#define IDM_DISABLED	11
#define IDM_SELECTED	12

// monitor settings controls
#define IDC_COLORLIST	1200
#define IDC_RESLIST	1201
#define IDC_RESSIZE	1204
#define IDC_SCREENSAMPLE 1205
#define IDC_COLORSAMPLE 1206
#define IDC_RESXY	1207
#define IDC_ZOOMIN	1209
#define IDC_ZOOMOUT	1210
#define IDC_CUSTOMFONT  1211
#define IDC_FONTLIST    1212
#define IDC_CHANGEDRV   1213
#define IDC_FULLDRAG    1214
#define IDC_SMOOTHFONTS 1215
#define IDC_FONTGROUPBOX 1216

#define BMP_MONITOR	1250

// adapter settings controls
#define IDC_ADAPTERNAME		1301
#define IDC_ADAPTERCHANGE	1302
#define IDC_MONITORNAME		1303
#define IDC_MONITORCHANGE	1304
#define IDC_DRVMAN		1305
#define IDC_DRVVER		1306
#define IDC_DRVFILES		1307
#define IDC_DPMS		1308
#define IDC_DRVMAN_TXT		1309
#define IDC_DRVVER_TXT		1310
#define IDC_DRVFILES_TXT	1311

#define IDS_CLOSE		1300

// strings for monitor settings
// the ordering matches a color resolution array
// NOTE: numbering = base + (res/4)
#define IDS_COLOR	1200
#define IDS_COLOR_1	IDS_COLOR + 0
#define IDS_COLOR_4	IDS_COLOR + 1
#define IDS_COLOR_8	IDS_COLOR + 2
#define IDS_COLOR_16	IDS_COLOR + 4
#define IDS_COLOR_24	IDS_COLOR + 6
#define IDS_COLOR_32	IDS_COLOR + 8

#define IDS_CANCELNEW	1220
#define IDS_FAILRESET	1221
#define IDS_X_BY_Y	1224
#define IDS_UNKNOWN	1225
#define IDS_NOINFO	1226
#define IDS_CUSTFONTPER 1229
#define IDS_CUSTFONTWARN 1230
#define IDS_PAT_REMOVE  1231
#define IDS_PAT_CHANGE  1232
#define IDS_PAT_CREATE  1233
#define IDS_REMOVEPATCAPTION	1234
#define IDS_CHANGEPATCAPTION	1235

#define IDS_WARNFLICK1  1250
#define IDS_WARNFLICK2  1251
// order is based on values in ddk\inc16\valmode.inc
#define	IDS_NOVALID0	1254
#define	IDS_NOVALID1	1255
#define	IDS_NOVALID2	1256
#define	IDS_NOVALID3	1257
#define	IDS_NOVALID4	1258
#define	IDS_NOMONITOR	1260
#define IDS_FALLBACKMODE 1261
#define IDS_FALLBACKDRV 1262

#define IDS_NOADAPTER           1270
#define IDS_CONFLICT            1271
#define IDS_BADSETTINGS         1272
#define IDS_DISPDISABLED        1273

//controls & strings for custom font dialog
#define IDC_CUSTOMSAMPLE	1400
#define IDC_CUSTOMRULER		1501
#define IDC_CUSTOMCOMBO		1502

#define IDS_10PTSAMPLE		1500
#define IDS_RULERDIRECTION      1501
#define IDS_10PTSAMPLEFACENAME  1510

#define IDS_NEWSETTINGS         1600
#define IDS_NEWSETTINGS_RESTART 1601

#define IDS_CATRESCOLOR         1610

// color picker mini-dialog
#define IDC_16COLORS	1615
#define IDC_COLORCUST	1616
#define IDC_COLOROTHER	1617
#define IDC_COLORETCH	1618

// patern edit dialog

#define IDD_PATTERN		1700
#define IDD_PATTERNCOMBO	1701
#define IDD_ADDPATTERN		1702
#define IDD_CHANGEPATTERN       1703
#define IDD_DELPATTERN		1704
#define IDD_PATSAMPLE           1705
#define IDD_PATSAMPLE_TXT       1706
#define IDD_PATTERN_TXT		1707

// Multimonitor controls

#define IDC_DISPLAYLIST         1800
#define IDC_DISPLAYDESK         1801
#define IDC_DISPLAYPROPERTIES   1802
#define IDC_DISPLAYNAME         1803
#define IDC_DISPLAYMODE         1804
#define IDC_DISPLAYUSEME        1805
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\dlgfonts.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "DlgFonts.h"
#include "accwiz.h" // for g_Options


HFONT BigBoldFont = NULL;
HFONT BoldFont = NULL;
HFONT BigFont = NULL;


// Helper function
void SetControlFont(HFONT hFont, HWND hwnd, int nId)
{
	if(!hFont)
		return;
	HWND hwndControl = GetDlgItem(hwnd, nId);
	if(!hwndControl)
		return;
	SetWindowFont(hwndControl, hFont, TRUE);
}


void SetupFonts(HWND hwnd)
{
	// Only execute this code once
	static BOOL bOneTime = TRUE;
	if(bOneTime)
		bOneTime = FALSE;
	else
		return;

	// Create the fonts we need based on the dialog font
	NONCLIENTMETRICS ncm;
	memset(&ncm, 0, sizeof(ncm));
	ncm.cbSize = sizeof(ncm);
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

	LOGFONT BigBoldLogFont = ncm.lfMessageFont;
	LOGFONT BoldLogFont = ncm.lfMessageFont;
	LOGFONT BigLogFont = ncm.lfMessageFont;

	// Create Big Bold Font and Bold Font
    BigBoldLogFont.lfWeight = FW_BOLD;
	BoldLogFont.lfWeight = FW_BOLD;
    BigLogFont.lfWeight = FW_NORMAL;

    TCHAR FontSizeString[24];
    int FontSizeBigBold;
    int FontSizeBold;
    int FontSizeBig;

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
	BigBoldLogFont.lfCharSet = g_Options.m_lfCharSet;
	BoldLogFont.lfCharSet = g_Options.m_lfCharSet;
	BigLogFont.lfCharSet = g_Options.m_lfCharSet;

    if(!LoadString(g_hInstDll,IDS_BIGBOLDFONTNAME,BigBoldLogFont.lfFaceName,LF_FACESIZE)) {
        lstrcpy(BigBoldLogFont.lfFaceName,TEXT("MS Serif"));
    }

    if(!LoadString(g_hInstDll,IDS_BOLDFONTNAME,BoldLogFont.lfFaceName,LF_FACESIZE)) {
        lstrcpy(BoldLogFont.lfFaceName,TEXT("MS Serif"));
    }

    if(!LoadString(g_hInstDll,IDS_BIGFONTNAME,BigLogFont.lfFaceName,LF_FACESIZE)) {
        lstrcpy(BigLogFont.lfFaceName,TEXT("MS Serif"));
    }

    if(LoadString(g_hInstDll,IDS_BIGBOLDFONTSIZE,FontSizeString,sizeof(FontSizeString)/sizeof(TCHAR))) {
		FontSizeBigBold = _tcstoul(FontSizeString,NULL,10);
    } else {
        FontSizeBigBold = 16;
    }

    if(LoadString(g_hInstDll,IDS_BOLDFONTSIZE,FontSizeString,sizeof(FontSizeString)/sizeof(TCHAR))) {
        FontSizeBold = _tcstoul(FontSizeString,NULL,10);
    } else {
        FontSizeBold = 8;
    }

    if(LoadString(g_hInstDll,IDS_BIGFONTSIZE,FontSizeString,sizeof(FontSizeString)/sizeof(TCHAR))) {
        FontSizeBig = _tcstoul(FontSizeString,NULL,10);
    } else {
        FontSizeBig = 16;
    }

	HDC hdc;
    if(hdc = GetDC(hwnd)) {

        BigBoldLogFont.lfHeight = 0 - (int)((float)GetDeviceCaps(hdc,LOGPIXELSY) * (float)FontSizeBigBold / (float)72 + (float).5);
        BoldLogFont.lfHeight = 0 - (int)((float)GetDeviceCaps(hdc,LOGPIXELSY) * (float)FontSizeBold / (float)72 + (float).5);
        BigLogFont.lfHeight = 0 - (int)((float)GetDeviceCaps(hdc,LOGPIXELSY) * (float)FontSizeBig / (float)72 + (float).5);

        BigBoldFont = CreateFontIndirect(&BigBoldLogFont);
		BoldFont = CreateFontIndirect(&BoldLogFont);
        BigFont = CreateFontIndirect(&BigLogFont);

        ReleaseDC(hwnd,hdc);
    }

}

void DialogFonts_InitWizardPage(
	IN HWND hwndWizardPage
	)
{
	SetupFonts(hwndWizardPage);

	// If we are going to change the fonts of all wizard pages,
	// we can't allow the user to go back and change the size
	// they picked.  This is because this function is only called
	// once for each page.
/*
	if(-1 != g_Options.m_nMinimalFontSize)
	{
*/
	HWND hwndChild = GetTopWindow(hwndWizardPage);
	do
	{
		int nId = GetDlgCtrlID(hwndChild);
		switch(nId)
		{
		case IDC_BOLDTITLE:
			SetControlFont(BoldFont, hwndWizardPage, IDC_BOLDTITLE);
			break;
		case IDC_BIGBOLDTITLE:
			SetControlFont(BigBoldFont, hwndWizardPage, IDC_BIGBOLDTITLE);
			break;
		case IDC_BIGTITLE:
			SetControlFont(BigFont, hwndWizardPage, IDC_BIGTITLE);
			break;
#if 0 // This used to be for the icon size page
		case IDC_STATICNORMAL:
			SetWindowFont(hwndChild, g_Options.GetClosestMSSansSerif(8), TRUE);
			break;
		case IDC_STATICLARGE:
			SetWindowFont(hwndChild, g_Options.GetClosestMSSansSerif(12), TRUE);
			break;
		case IDC_STATICEXTRALARGE:
			SetWindowFont(hwndChild, g_Options.GetClosestMSSansSerif(18), TRUE);
			break;
#endif
		default:
#if 0 // We decided that we weren't going to resize the fonts in the dialog
			// DON'T go above 12 points for the dialog fonts
			SetWindowFont(hwndChild, g_Options.GetClosestMSSansSerif(min(12, g_Options.m_nMinimalFontSize)), TRUE);
#endif
			break;
		}
	}
	while(hwndChild = GetNextWindow(hwndChild, GW_HWNDNEXT));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\look.h ===
//Copyright (c) 1997-2000 Microsoft Corporation

#define FONT_NONE	-1
#define FONT_CAPTION	0
#define FONT_SMCAPTION	1
#define FONT_MENU	2
#define FONT_ICONTITLE	3
#define FONT_STATUS	4
#define FONT_MSGBOX	5

#define NUM_FONTS	6
typedef struct {
    HFONT hfont;
    LOGFONT lf;
} LOOK_FONT;
extern LOOK_FONT g_fonts[];

#define COLOR_NONE	-1
extern HBRUSH g_brushes[];
extern HPALETTE g_hpal3D;
extern BOOL g_bPalette;

#define SIZE_NONE	-1
#define SIZE_FRAME	0
#define SIZE_SCROLL	1
#define SIZE_CAPTION	2
#define SIZE_SMCAPTION	3
#define SIZE_MENU	4
#define SIZE_DXICON     5
#define SIZE_DYICON     6
#define SIZE_ICON       7
#define SIZE_SMICON     8

#define NUM_SIZES	9

typedef struct {
    int CurSize;
    int MinSize;
    int MaxSize;
} LOOK_SIZE;
extern LOOK_SIZE g_sizes[];

typedef struct {
    int iMainColor;
    int iSize;
    BOOL fLinkSizeToFont;
    int iTextColor;
    int iFont;
    int iResId;		// id of name in resource (or -1 if duplicate)
    int iBaseElement;	// index of element that this overlaps (or -1)
    RECT rc;
    int iGradColor;
} LOOK_ELEMENT;

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//this order has to match the array order in lookdlg.c
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
enum _ELEMENTS {
    ELEMENT_APPSPACE = 0,
    ELEMENT_DESKTOP,
    ELEMENT_INACTIVEBORDER,
    ELEMENT_ACTIVEBORDER,
    ELEMENT_INACTIVECAPTION,
    ELEMENT_INACTIVESYSBUT1,
    ELEMENT_INACTIVESYSBUT2,
    ELEMENT_ACTIVECAPTION,
    ELEMENT_ACTIVESYSBUT1,
    ELEMENT_ACTIVESYSBUT2,
    ELEMENT_MENUNORMAL,
    ELEMENT_MENUSELECTED,
    ELEMENT_MENUDISABLED,
    ELEMENT_WINDOW,
    ELEMENT_MSGBOX,
    ELEMENT_MSGBOXCAPTION,
    ELEMENT_MSGBOXSYSBUT,
    ELEMENT_SCROLLBAR,
    ELEMENT_SCROLLUP,
    ELEMENT_SCROLLDOWN,
    ELEMENT_BUTTON,
    ELEMENT_SMCAPTION,
    ELEMENT_ICON,
    ELEMENT_ICONHORZSPACING,
    ELEMENT_ICONVERTSPACING,
    ELEMENT_INFO
};
// BOGUS:  need to get a size from somewhere
#define NUM_ELEMENTS ELEMENT_INFO+1

#if 0
// go fix lookdlg.c if you decide to add this back in
    ELEMENT_SMICON,
#endif


#define CPI_VGAONLY	0x0001
#define CPI_PALETTEOK	0x0002

typedef struct {
    HWND hwndParent;    // parent for any modal dialogs (choosecolor et al)
    HWND hwndOwner;     // control that owns mini color picker
    COLORREF rgb;
    UINT flags;
    HPALETTE hpal;
} COLORPICK_INFO, FAR * LPCOLORPICK_INFO;

extern int cyBorder;
extern int cxBorder;
extern int cyEdge;
extern int cxEdge;

// NOTE: the order in g_elements must match the enum order above
extern LOOK_ELEMENT g_elements[];

void FAR PASCAL Look_SelectElement(HWND hDlg, int iElement, DWORD dwFlags);

BOOL WINAPI ChooseColorMini(LPCOLORPICK_INFO lpcpi);

DWORD FAR PASCAL DarkenColor(DWORD rgb, int n);
DWORD FAR PASCAL BrightenColor(DWORD rgb, int n);


#define LF32toLF(lplf32, lplf)  (*(lplf) = *(lplf32))
#define LFtoLF32(lplf, lplf32)  (*(lplf32) = *(lplf))

// HACK - REMOVE THESE
extern int g_LogDPI;              // logical resolution of display
extern HPALETTE g_hpalVGA;              // only exist if palette device
void GetMyNonClientMetrics(LPNONCLIENTMETRICS lpncm);
void SetMyNonClientMetrics(LPNONCLIENTMETRICS lpncm);
void PASCAL Look_RebuildSysStuff(BOOL fInit);
#if(WINVER >= 0x0501)
#define NT40_COLOR_ENDCOLORS         COLOR_ENDCOLORS
#else
#define NT40_COLOR_ENDCOLORS         COLOR_GRADIENTINACTIVECAPTION
#endif
#define NT40_COLOR_MAX               (NT40_COLOR_ENDCOLORS+1)
#define NT40_COLOR_MAX_REAL          (COLOR_INFOBK + 1)
extern const TCHAR c_szRegPathUserMetrics[];
extern const TCHAR c_szRegValIconSize[];
extern const TCHAR c_szRegValSmallIconSize[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\lookprev.h ===
//Copyright (c) 1997-2000 Microsoft Corporation

#define CCH_MAX_STRING    256

class CLookPreviewGlobals
{
public:
	CLookPreviewGlobals()
	{
		// We don't initialize stuff here because we rely
		// on some other global variables that are not yet initialized
		m_bInitialized = FALSE;
	}
	BOOL Initialize();

	TCHAR m_szActive[CCH_MAX_STRING];
	TCHAR m_szInactive[CCH_MAX_STRING];
	TCHAR m_szMinimized[CCH_MAX_STRING];
	TCHAR m_szIconTitle[CCH_MAX_STRING];
	TCHAR m_szNormal[CCH_MAX_STRING];
	TCHAR m_szDisabled[CCH_MAX_STRING];
	TCHAR m_szSelected[CCH_MAX_STRING];
	TCHAR m_szMsgBox[CCH_MAX_STRING];
	TCHAR m_szButton[CCH_MAX_STRING];
//	TCHAR m_szSmallCaption[40];
	TCHAR m_szWindowText[CCH_MAX_STRING];
	TCHAR m_szMsgBoxText[CCH_MAX_STRING];

protected:
	static BOOL sm_bOneInstanceCreated; // This variable insures that only one instance of CLookPreviewGlobals is created
	BOOL m_bInitialized;
};

class CLookPrev
{
public:
	CLookPrev()
	{
		m_hwnd = NULL;
		m_hmenuSample = NULL;
		m_hbmLook = NULL;       // bitmap for the appearance preview
	}
	
	HWND m_hwnd;

	// Static window proc
	static LRESULT CALLBACK LookPreviewWndProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	static CLookPreviewGlobals sm_Globals;

protected:
	HMENU m_hmenuSample;
	HBITMAP m_hbmLook;       // bitmap for the appearance preview

	void ShowBitmap(HDC hdc);
	void Draw(HDC hdc);

protected: // Message handlers
	void OnCreate();
	void OnDestroy();
	void OnRepaint();
	void OnRecalc();
	void OnPaint(HDC hdc);
};


// Messages for the Look Preview window
#define LPM_REPAINT		WM_USER + 1
#define LPM_RECALC		WM_USER + 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\lookdlg.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
/*  LOOKDLG.C
**
**
**
**  History:
**
*/
#include "pch.hxx" // PCH
#pragma hdrstop

#include "AccWiz.h"

#include "desk.h"
#include "deskid.h"
#include "look.h"
#include <commdlg.h>
#include <commctrl.h>
#include <regstr.h>
#include "help.h"



#define RGB_PALETTE 0x02000000

void FAR SetMagicColors(HDC, DWORD, WORD);

#define CENTRIES_3D 3

HPALETTE g_hpal3D = NULL;               // only exist if palette device
HPALETTE g_hpalVGA = NULL;              // only exist if palette device
BOOL g_bPalette = FALSE;                // is this a palette device?
int cyBorder;
int cxBorder;
int cxEdge;
int cyEdge;

HWND g_hwndTooltip;

LOOK_FONT g_fonts[NUM_FONTS];
HBRUSH g_brushes[NT40_COLOR_MAX];

BOOL g_bInit = TRUE;

BOOL g_fProprtySheetExiting = FALSE;

#define METRIC_CHANGE 0x0001
#define COLOR_CHANGE  0x0002
#define SCHEME_CHANGE 0x8000
UINT g_fChanged;

LOOK_SIZE g_sizes[NUM_SIZES] = {
/* SIZE_FRAME */        {0, 0, 50},
/* SIZE_SCROLL */       {0, 8, 100},
/* SIZE_CAPTION */      {0, 8, 100},
/* SIZE_SMCAPTION */    {0, 4, 100},
/* SIZE_MENU */         {0, 8, 100},
/* SIZE_DXICON */       {0, 0, 150},    // x spacing
/* SIZE_DYICON */       {0, 0, 150},    // y spacing
/* SIZE_ICON */         {0, 16, 72},    // shell icon size
/* SIZE_SMICON */       {0, 8, 36},     // shell small icon size
};

LOOK_SIZE g_elCurSize;

#define COLORFLAG_SOLID 0x0001

UINT g_colorFlags[NT40_COLOR_MAX] = {
/* COLOR_SCROLLBAR           */ 0,
/* COLOR_DESKTOP             */ 0,
/* COLOR_ACTIVECAPTION       */ COLORFLAG_SOLID,
/* COLOR_INACTIVECAPTION     */ COLORFLAG_SOLID,
/* COLOR_MENU                */ COLORFLAG_SOLID,
/* COLOR_WINDOW              */ COLORFLAG_SOLID,
/* COLOR_WINDOWFRAME         */ COLORFLAG_SOLID,
/* COLOR_MENUTEXT            */ COLORFLAG_SOLID,
/* COLOR_WINDOWTEXT          */ COLORFLAG_SOLID,
/* COLOR_CAPTIONTEXT         */ COLORFLAG_SOLID,
/* COLOR_ACTIVEBORDER        */ 0,
/* COLOR_INACTIVEBORDER      */ 0,
/* COLOR_APPWORKSPACE        */ 0,
/* COLOR_HIGHLIGHT           */ COLORFLAG_SOLID,
/* COLOR_HIGHLIGHTTEXT       */ COLORFLAG_SOLID,
/* COLOR_3DFACE              */ COLORFLAG_SOLID,
/* COLOR_3DSHADOW            */ COLORFLAG_SOLID,
/* COLOR_GRAYTEXT            */ COLORFLAG_SOLID,
/* COLOR_BTNTEXT             */ COLORFLAG_SOLID,
/* COLOR_INACTIVECAPTIONTEXT */ COLORFLAG_SOLID,
/* COLOR_3DHILIGHT           */ COLORFLAG_SOLID,
/* COLOR_3DDKSHADOW          */ COLORFLAG_SOLID,
/* COLOR_3DLIGHT             */ COLORFLAG_SOLID,
/* COLOR_INFOTEXT            */ COLORFLAG_SOLID,
/* COLOR_INFOBK              */ 0,
/* COLOR_3DALTFACE           */ COLORFLAG_SOLID,
/* COLOR_HOTLIGHT            */ COLORFLAG_SOLID,
/* COLOR_GRADIENTACTIVECAPTION */ COLORFLAG_SOLID,
/* COLOR_GRADIENTINACTIVECAPTION */ COLORFLAG_SOLID
#if(WINVER >= 0x0501)
/* COLOR_MENUHILIGHT         */, COLORFLAG_SOLID,
/* COLOR_MENUBAR             */  COLORFLAG_SOLID
#endif /* WINVER >= 0x0501 */
};

// strings for color names.
PTSTR s_pszColorNames[NT40_COLOR_MAX] = {
/* COLOR_SCROLLBAR           */ TEXT("Scrollbar"),
/* COLOR_DESKTOP             */ TEXT("Background"),
/* COLOR_ACTIVECAPTION       */ TEXT("ActiveTitle"),
/* COLOR_INACTIVECAPTION     */ TEXT("InactiveTitle"),
/* COLOR_MENU                */ TEXT("Menu"),
/* COLOR_WINDOW              */ TEXT("Window"),
/* COLOR_WINDOWFRAME         */ TEXT("WindowFrame"),
/* COLOR_MENUTEXT            */ TEXT("MenuText"),
/* COLOR_WINDOWTEXT          */ TEXT("WindowText"),
/* COLOR_CAPTIONTEXT         */ TEXT("TitleText"),
/* COLOR_ACTIVEBORDER        */ TEXT("ActiveBorder"),
/* COLOR_INACTIVEBORDER      */ TEXT("InactiveBorder"),
/* COLOR_APPWORKSPACE        */ TEXT("AppWorkspace"),
/* COLOR_HIGHLIGHT           */ TEXT("Hilight"),
/* COLOR_HIGHLIGHTTEXT       */ TEXT("HilightText"),
/* COLOR_3DFACE              */ TEXT("ButtonFace"),
/* COLOR_3DSHADOW            */ TEXT("ButtonShadow"),
/* COLOR_GRAYTEXT            */ TEXT("GrayText"),
/* COLOR_BTNTEXT             */ TEXT("ButtonText"),
/* COLOR_INACTIVECAPTIONTEXT */ TEXT("InactiveTitleText"),
/* COLOR_3DHILIGHT           */ TEXT("ButtonHilight"),
/* COLOR_3DDKSHADOW          */ TEXT("ButtonDkShadow"),
/* COLOR_3DLIGHT             */ TEXT("ButtonLight"),
/* COLOR_INFOTEXT            */ TEXT("InfoText"),
/* COLOR_INFOBK              */ TEXT("InfoWindow"),
/* COLOR_3DALTFACE           */ TEXT("ButtonAlternateFace"),
/* COLOR_HOTLIGHT            */ TEXT("HotTracking"),
/* COLOR_GRADIENTACTIVECAPTION */ TEXT("GradientActiveTitle"),
/* COLOR_GRADIENTINACTIVECAPTION */ TEXT("GradientInactiveTitle")
#if(WINVER >= 0x0501)
/* COLOR_MENUHILIGHT         */ ,TEXT("MenuHighlighted"),
/* COLOR_MENUBAR             */  TEXT("MenuBar")
#endif /* WINVER >= 0x0501 */
};
TCHAR g_szColors[] = TEXT("colors");           // colors section name

// Location of the Colors subkey in Registry; Defined in RegStr.h
TCHAR szRegStr_Colors[] = REGSTR_PATH_COLORS;

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//this order has to match the enum order in look.h
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
LOOK_ELEMENT g_elements[] = {
/* ELEMENT_APPSPACE        */   {COLOR_APPWORKSPACE,    SIZE_NONE,      FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_APPSPACE, -1,       {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_DESKTOP         */   {COLOR_BACKGROUND,      SIZE_NONE,      FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_DESKTOP, -1,        {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_INACTIVEBORDER  */   {COLOR_INACTIVEBORDER,  SIZE_FRAME,     FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_INACTIVEBORDER, -1, {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_ACTIVEBORDER    */   {COLOR_ACTIVEBORDER,    SIZE_FRAME,     FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_ACTIVEBORDER, -1,   {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_INACTIVECAPTION */   {COLOR_INACTIVECAPTION, SIZE_CAPTION,   TRUE,    COLOR_INACTIVECAPTIONTEXT,FONT_CAPTION,ELNAME_INACTIVECAPTION, -1,{-1,-1,-1,-1}, COLOR_GRADIENTINACTIVECAPTION},
/* ELEMENT_INACTIVESYSBUT1 */   {COLOR_NONE,            SIZE_CAPTION,   FALSE,   COLOR_NONE,             FONT_NONE,     -1, ELEMENT_ACTIVESYSBUT1, {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_INACTIVESYSBUT2 */   {COLOR_NONE,            SIZE_CAPTION,   FALSE,   COLOR_NONE,             FONT_NONE,     -1, ELEMENT_ACTIVESYSBUT1, {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_ACTIVECAPTION   */   {COLOR_ACTIVECAPTION,   SIZE_CAPTION,   TRUE,    COLOR_CAPTIONTEXT,      FONT_CAPTION,  ELNAME_ACTIVECAPTION, -1,  {-1,-1,-1,-1}, COLOR_GRADIENTACTIVECAPTION},
/* ELEMENT_ACTIVESYSBUT1   */   {COLOR_NONE,            SIZE_CAPTION,   FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_CAPTIONBUTTON, -1,  {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_ACTIVESYSBUT2   */   {COLOR_NONE,            SIZE_CAPTION,   FALSE,   COLOR_NONE,             FONT_NONE,     -1, ELEMENT_ACTIVESYSBUT1, {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_MENUNORMAL      */   {COLOR_MENU,            SIZE_MENU,      TRUE,    COLOR_MENUTEXT,         FONT_MENU,     ELNAME_MENU, -1,           {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_MENUSELECTED    */   {COLOR_HIGHLIGHT,       SIZE_MENU,      TRUE,    COLOR_HIGHLIGHTTEXT,    FONT_MENU,     ELNAME_MENUSELECTED, -1,   {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_MENUDISABLED    */   {COLOR_MENU,            SIZE_MENU,      TRUE,    COLOR_NONE,             FONT_MENU,     -1, ELEMENT_MENUNORMAL,    {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_WINDOW          */   {COLOR_WINDOW,          SIZE_NONE,      FALSE,   COLOR_WINDOWTEXT,       FONT_NONE,     ELNAME_WINDOW, -1,         {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_MSGBOX          */   {COLOR_NONE,            SIZE_NONE,      TRUE,    COLOR_WINDOWTEXT,       FONT_MSGBOX,   ELNAME_MSGBOX, -1,         {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_MSGBOXCAPTION   */   {COLOR_ACTIVECAPTION,   SIZE_CAPTION,   TRUE,    COLOR_CAPTIONTEXT,      FONT_CAPTION,  -1, ELEMENT_ACTIVECAPTION, {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_MSGBOXSYSBUT    */   {COLOR_3DFACE,          SIZE_CAPTION,   TRUE,    COLOR_BTNTEXT,          FONT_CAPTION,  -1, ELEMENT_ACTIVESYSBUT1, {-1,-1,-1,-1}, COLOR_NONE},
// do not even try to set a scrollbar color the system will ignore you
/* ELEMENT_SCROLLBAR       */   {COLOR_NONE,            SIZE_SCROLL,    FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_SCROLLBAR, -1,      {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_SCROLLUP        */   {COLOR_NONE,            SIZE_SCROLL,    FALSE,   COLOR_NONE,             FONT_NONE,     -1, ELEMENT_SCROLLBAR,     {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_SCROLLDOWN      */   {COLOR_NONE,            SIZE_SCROLL,    FALSE,   COLOR_NONE,             FONT_NONE,     -1, ELEMENT_SCROLLBAR,     {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_BUTTON          */   {COLOR_3DFACE,          SIZE_NONE,      FALSE,   COLOR_BTNTEXT,          FONT_NONE,     ELNAME_BUTTON, -1,         {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_SMCAPTION       */   {COLOR_NONE,            SIZE_SMCAPTION, TRUE,    COLOR_NONE,             FONT_SMCAPTION,ELNAME_SMALLCAPTION, -1,   {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_ICON            */   {COLOR_NONE,            SIZE_ICON,      FALSE,   COLOR_NONE,             FONT_ICONTITLE,ELNAME_ICON, -1,           {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_ICONHORZSPACING */   {COLOR_NONE,            SIZE_DXICON,    FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_DXICON, -1,         {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_ICONVERTSPACING */   {COLOR_NONE,            SIZE_DYICON,    FALSE,   COLOR_NONE,             FONT_NONE,     ELNAME_DYICON, -1,         {-1,-1,-1,-1}, COLOR_NONE},
/* ELEMENT_INFO            */   {COLOR_INFOBK,          SIZE_NONE,      TRUE,    COLOR_INFOTEXT,         FONT_STATUS,   ELNAME_INFO, -1,           {-1,-1,-1,-1}, COLOR_NONE},
};

// used by ChooseColor dialog
COLORREF g_CustomColors[16];

// structure used to store a scheme in the registry
#ifdef UNICODE
#   define SCHEME_VERSION 2        // Ver 2 == Unicode
#else
#   define SCHEME_VERSION 1        // Ver 1 == Win95 ANSI
#endif

/*
 * Note -- this must match the High Contrast accessibility code
 *  in windows\gina\winlogon.
 */

typedef struct {
    SHORT version;
    WORD  wDummy;               // for alignment
    NONCLIENTMETRICS ncm;
    LOGFONT lfIconTitle;
    COLORREF rgb[NT40_COLOR_MAX];
} SCHEMEDATA;


HWND g_hDlg = NULL;             // nonzero if page is up
int g_iCurElement = -2;         // start off as not even "not set"
int g_LogDPI = 96;              // logical resolution of display
#define ELCUR           (g_elements[g_iCurElement])
#define ELCURFONT       (g_fonts[ELCUR.iFont])
// this one kept separately for range purposes
#define ELCURSIZE       g_elCurSize
int g_iPrevSize = SIZE_NONE;

#define MAXSCHEMENAME 100
TCHAR g_szCurScheme[MAXSCHEMENAME];      // current scheme name
TCHAR g_szLastScheme[MAXSCHEMENAME];     // last scheme they had

HBRUSH g_hbrMainColor = NULL;
HBRUSH g_hbrTextColor = NULL;
HBRUSH g_hbrGradColor = NULL;

const TCHAR c_szRegPathUserMetrics[] = TEXT("Control Panel\\Desktop\\WindowMetrics");
const TCHAR c_szRegValIconSize[] = TEXT("Shell Icon Size");
const TCHAR c_szRegValSmallIconSize[] = TEXT("Shell Small Icon Size");

void NEAR PASCAL Look_Repaint(HWND hDlg, BOOL bRecalc);
BOOL NEAR PASCAL Look_ChangeColor(HWND hDlg, int iColor, COLORREF rgb);
BOOL CALLBACK SaveSchemeDlgProc(HWND, UINT, WPARAM, LPARAM);
void NEAR PASCAL Look_UpdateSizeBasedOnFont(HWND hDlg, BOOL fComputeIdeal);
void NEAR PASCAL Look_SetCurSizeAndRange(HWND hDlg);
void NEAR PASCAL Look_SyncSize(HWND hDlg);
void NEAR PASCAL Look_DoSizeStuff(HWND hDlg, BOOL fCanComputeIdeal);


COLORREF GetNearestPaletteColor(HPALETTE hpal, COLORREF rgb)
{
    PALETTEENTRY pe;
    GetPaletteEntries(hpal, GetNearestPaletteIndex(hpal, rgb & 0x00FFFFFF), 1, &pe);
    return RGB(pe.peRed, pe.peGreen, pe.peBlue);
}

BOOL IsPaletteColor(HPALETTE hpal, COLORREF rgb)
{
    return GetNearestPaletteColor(hpal, rgb) == (rgb & 0xFFFFFF);
}

COLORREF NearestColor(int iColor, COLORREF rgb)
{
    rgb &= 0x00FFFFFF;

    //
    // if we are on a palette device, we need to do special stuff...
    //
    if (g_bPalette)
    {
        if (g_colorFlags[iColor] & COLORFLAG_SOLID)
        {
            if (IsPaletteColor(g_hpal3D, rgb))
                rgb |= RGB_PALETTE;
            else
                rgb = GetNearestPaletteColor(g_hpalVGA, rgb);
        }
        else
        {
            if (IsPaletteColor(g_hpal3D, rgb))
                rgb |= RGB_PALETTE;

            else if (IsPaletteColor((HPALETTE)GetStockObject(DEFAULT_PALETTE), rgb))
                rgb ^= 0x000001;    // force a dither
        }
    }
    else
    {
        // map color to nearest color if we need to for this UI element.
        if (g_colorFlags[iColor] & COLORFLAG_SOLID)
        {
            HDC hdc = GetDC(NULL);
            rgb = GetNearestColor(hdc, rgb);
            ReleaseDC(NULL, hdc);
        }
    }

    return rgb;
}



void NEAR PASCAL Set3DPaletteColor(COLORREF rgb, int iColor)
{
    int iPalette;
    PALETTEENTRY pe;

    if (!g_hpal3D)
        return;

    switch (iColor)
    {
        case COLOR_3DFACE:
            iPalette = 16;
            break;
        case COLOR_3DSHADOW:
            iPalette = 17;
            break;
        case COLOR_3DHILIGHT:
            iPalette = 18;
            break;
        default:
            return;
    }

    pe.peRed    = GetRValue(rgb);
    pe.peGreen  = GetGValue(rgb);
    pe.peBlue   = GetBValue(rgb);
    pe.peFlags  = 0;
    SetPaletteEntries(g_hpal3D, iPalette, 1, (LPPALETTEENTRY)&pe);
}


void NEAR PASCAL Look_RebuildSysStuff(BOOL fInit)
{
    int i;
    PALETTEENTRY pal[4];
    HPALETTE hpal = (HPALETTE)GetStockObject(DEFAULT_PALETTE);

    SelectObject(g_hdcMem, GetStockObject(BLACK_BRUSH));
    SelectObject(g_hdcMem, GetStockObject(SYSTEM_FONT));

    for (i = 0; i < NUM_FONTS; i++)
    {
        if (g_fonts[i].hfont)
            DeleteObject(g_fonts[i].hfont);
        g_fonts[i].hfont = CreateFontIndirect(&g_fonts[i].lf);
    }

    if (fInit)
    {
        // get current magic colors
        GetPaletteEntries(hpal, 8,  4, pal);
        SetPaletteEntries(g_hpal3D, 16,  4, pal);

        // set up magic colors in the 3d palette
        if (!IsPaletteColor(hpal, g_Options.m_schemePreview.m_rgb[COLOR_3DFACE]))
        {
            Set3DPaletteColor(g_Options.m_schemePreview.m_rgb[COLOR_3DFACE], COLOR_3DFACE);
            Set3DPaletteColor(g_Options.m_schemePreview.m_rgb[COLOR_3DSHADOW], COLOR_3DSHADOW);
            Set3DPaletteColor(g_Options.m_schemePreview.m_rgb[COLOR_3DHILIGHT], COLOR_3DHILIGHT);
        }
    }

    for (i = 0; i < NT40_COLOR_MAX; i++)
    {
        if (g_brushes[i])
            DeleteObject(g_brushes[i]);

        g_brushes[i] = CreateSolidBrush(NearestColor(i, g_Options.m_schemePreview.m_rgb[i]));
    }
}

#ifndef LF32toLF

void NEAR LF32toLF(LPLOGFONT_32 lplf32, LPLOGFONT lplf)
{
    lplf->lfHeight       = (int) lplf32->lfHeight;
    lplf->lfWidth        = (int) lplf32->lfWidth;
    lplf->lfEscapement   = (int) lplf32->lfEscapement;
    lplf->lfOrientation  = (int) lplf32->lfOrientation;
    lplf->lfWeight       = (int) lplf32->lfWeight;
    *((LPCOMMONFONT) &lplf->lfItalic) = lplf32->lfCommon;
}
#endif


void NEAR SetMyNonClientMetrics(LPNONCLIENTMETRICS lpncm)
{
    g_sizes[SIZE_FRAME].CurSize = (int)lpncm->iBorderWidth;
    g_sizes[SIZE_SCROLL].CurSize = (int)lpncm->iScrollWidth;
    g_sizes[SIZE_CAPTION].CurSize = (int)lpncm->iCaptionHeight;
    g_sizes[SIZE_SMCAPTION].CurSize = (int)lpncm->iSmCaptionHeight;
    g_sizes[SIZE_MENU].CurSize = (int)lpncm->iMenuHeight;

    LF32toLF(&(lpncm->lfCaptionFont), &(g_fonts[FONT_CAPTION].lf));
    LF32toLF(&(lpncm->lfSmCaptionFont), &(g_fonts[FONT_SMCAPTION].lf));
    LF32toLF(&(lpncm->lfMenuFont), &(g_fonts[FONT_MENU].lf));
    LF32toLF(&(lpncm->lfStatusFont), &(g_fonts[FONT_STATUS].lf));
    LF32toLF(&(lpncm->lfMessageFont), &(g_fonts[FONT_MSGBOX].lf));
}

/*
** Fill in a NONCLIENTMETRICS structure with latest preview stuff
*/
void NEAR GetMyNonClientMetrics(LPNONCLIENTMETRICS lpncm)
{
    lpncm->iBorderWidth = (LONG)g_sizes[SIZE_FRAME].CurSize;
    lpncm->iScrollWidth = lpncm->iScrollHeight = (LONG)g_sizes[SIZE_SCROLL].CurSize;
    lpncm->iCaptionWidth = lpncm->iCaptionHeight = (LONG)g_sizes[SIZE_CAPTION].CurSize;
    lpncm->iSmCaptionWidth = lpncm->iSmCaptionHeight = (LONG)g_sizes[SIZE_SMCAPTION].CurSize;
    lpncm->iMenuWidth = lpncm->iMenuHeight = (LONG)g_sizes[SIZE_MENU].CurSize;
    LFtoLF32(&(g_fonts[FONT_CAPTION].lf), &(lpncm->lfCaptionFont));
    LFtoLF32(&(g_fonts[FONT_SMCAPTION].lf), &(lpncm->lfSmCaptionFont));
    LFtoLF32(&(g_fonts[FONT_MENU].lf), &(lpncm->lfMenuFont));
    LFtoLF32(&(g_fonts[FONT_STATUS].lf), &(lpncm->lfStatusFont));
    LFtoLF32(&(g_fonts[FONT_MSGBOX].lf), &(lpncm->lfMessageFont));
}




/*
** clean up any mess made in maintaining system information
** also, write out any global changes in our setup.
*/
void NEAR PASCAL Look_DestroySysStuff(void)
{
    int i;
    HKEY hkAppear;

    SelectObject(g_hdcMem, GetStockObject(BLACK_BRUSH));
    SelectObject(g_hdcMem, GetStockObject(SYSTEM_FONT));

    for (i = 0; i < NUM_FONTS; i++)
    {
        if (g_fonts[i].hfont)
            DeleteObject(g_fonts[i].hfont);
    }
    for (i = 0; i < NT40_COLOR_MAX; i++)
    {
        if (g_brushes[i])
            DeleteObject(g_brushes[i]);
    }

    if (g_hpal3D)
        DeleteObject(g_hpal3D);

    if (g_hpalVGA)
        DeleteObject(g_hpalVGA);

    // save out possible changes to custom color table
    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_APPEARANCE, 0, KEY_SET_VALUE, &hkAppear) == ERROR_SUCCESS)
    {
        RegSetValueEx(hkAppear, REGSTR_VAL_CUSTOMCOLORS, 0L, REG_BINARY,
                                (LPBYTE)g_CustomColors, sizeof(g_CustomColors));
        
 	 RegCloseKey(hkAppear);
    }
}

//------------------------ mini font picker controls --------------------------
/*
** initialize the constant dialog components
**
** initialize the list of element names.  this stays constant with the
** possible exception that some items might be added/removed depending
** on some special case conditions.
*/

void NEAR PASCAL Look_DestroyDialog(HWND hDlg)
{
    HFONT hfont, hfontOther;

    hfontOther = (HFONT)SendDlgItemMessage(hDlg, IDC_MAINSIZE, WM_GETFONT, 0, 0L);
    hfont = (HFONT)SendDlgItemMessage(hDlg, IDC_FONTBOLD, WM_GETFONT, 0, 0L);
    if (hfont && (hfont != hfontOther))
        DeleteObject(hfont);
    hfont = (HFONT)SendDlgItemMessage(hDlg, IDC_FONTITAL, WM_GETFONT, 0, 0L);
    if (hfont && (hfont != hfontOther))
        DeleteObject(hfont);

    DestroyWindow(g_hwndTooltip);
}


#define LSE_SETCUR 0x0001
#define LSE_ALWAYS 0x0002

const static DWORD FAR aAppearanceHelpIds[] = {
        IDC_SCHEMES,        IDH_APPEAR_SCHEME,
        IDC_SAVESCHEME,     IDH_APPEAR_SAVEAS,
        IDC_DELSCHEME,      IDH_APPEAR_DELETE,
        IDC_ELEMENTS,       IDH_APPEAR_ITEM,
        IDC_MAINCOLOR,      IDH_APPEAR_BACKGRNDCOLOR,
        IDC_SIZELABEL,      IDH_APPEAR_ITEMSIZE,
        IDC_MAINSIZE,       IDH_APPEAR_ITEMSIZE,
        IDC_SIZEARROWS,     IDH_APPEAR_ITEMSIZE,
        IDC_FONTLABEL,      IDH_APPEAR_FONT,
        IDC_FONTNAME,       IDH_APPEAR_FONT,
        IDC_FONTSIZE,       IDH_APPEAR_FONTSIZE,
        IDC_FONTBOLD,       IDH_APPEAR_FONTBOLD,
        IDC_FONTITAL,       IDH_APPEAR_FONTITALIC,
        IDC_LOOKPREV,       IDH_APPEAR_GRAPHIC,
        IDC_FONTSIZELABEL,  IDH_APPEAR_FONTSIZE,
        IDC_COLORLABEL,     IDH_APPEAR_BACKGRNDCOLOR,
        IDC_TEXTCOLOR,      IDH_APPEAR_FONTCOLOR,
        IDC_FNCOLORLABEL,   IDH_APPEAR_FONTCOLOR,

        0, 0
};


LONG WINAPI MyStrToLong(LPCTSTR sz)
{
    long l=0;

    while (*sz >= TEXT('0') && *sz <= TEXT('9'))
        l = l*10 + (*sz++ - TEXT('0'));

    return l;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgcaret.cpp ===
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgcaret.h"
#include "w95trace.c"

#define BLINK           1000
#define BLINK_OFF       -1

#define CURSORMIN       200
#define CURSORMAX       1300
#define CURSORSUM       (CURSORMIN + CURSORMAX)
#define CURSORRANGE     (CURSORMAX - CURSORMIN)

CCaretPg::CCaretPg(	LPPROPSHEETPAGE ppsp ) : WizardPage(ppsp, IDS_CARETTITLE, IDS_CARETSUBTITLE)
{
	m_dwPageId = IDD_CARET;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
    hwndCursorScroll = NULL;
    uNewBlinkTime = uBlinkTime = 0;
    dwOriginalSize = dwNewSize = 0;
    fBlink = TRUE;
}


CCaretPg::~CCaretPg(void)
{
}


LRESULT CCaretPg::OnInitDialog( HWND hwnd, WPARAM wParam,LPARAM lParam )
{
    DBPRINTF(TEXT("OnInitDialog\r\n"));
    BOOL fRv = SystemParametersInfo(SPI_GETCARETWIDTH, 0, (PVOID)&dwOriginalSize, 0);
    dwNewSize = dwOriginalSize;

    uBlinkTime = RegQueryStrDW(
				     DEFAULT_BLINK_RATE
			       , HKEY_CURRENT_USER
			       , CONTROL_PANEL_DESKTOP
			       , CURSOR_BLINK_RATE);

    // Blink rate of -1 means it is off; a special case to CURSORMAX

    if (uBlinkTime == BLINK_OFF)
        uBlinkTime = CURSORMAX;

    uNewBlinkTime = uBlinkTime;

    // Update the Caret UI
    SendMessage(GetDlgItem(hwnd, KCURSOR_WIDTH), TBM_SETRANGE, 0, MAKELONG(1, 20));
    SendMessage(GetDlgItem(hwnd, KCURSOR_WIDTH), TBM_SETPOS, TRUE, (LONG)dwOriginalSize);

    SendMessage(GetDlgItem(hwnd, KCURSOR_RATE), TBM_SETRANGE, 0, MAKELONG(CURSORMIN / 100, CURSORMAX / 100));
    SendMessage(GetDlgItem(hwnd, KCURSOR_RATE), TBM_SETPOS, TRUE, (LONG)(CURSORSUM - uBlinkTime) / 100);

    // Update Blink and caret size
    hwndCaret = GetDlgItem(hwnd, KCURSOR_BLINK);
    GetWindowRect(hwndCaret, &rCursor);
    MapWindowPoints(HWND_DESKTOP, hwnd, (LPPOINT)&rCursor, 2);

    rCursor.right = rCursor.left + dwOriginalSize;

	return 1;
}


void CCaretPg::UpdateControls()
{
	// Nothing to do
}

void CCaretPg::DrawCaret(HWND hwnd, BOOL fClearFirst)
{
    HDC hDC = GetDC(hwnd);
    if (hDC)
    {
        HBRUSH hBrush;
        if (fClearFirst)
        {
            hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
            if (hBrush)
            {
                RECT rect;
                GetWindowRect(hwndCaret, &rect);
                MapWindowPoints(HWND_DESKTOP, hwnd, (LPPOINT)&rect, 2);
                FillRect(hDC, &rect, hBrush);
                InvalidateRect(hwndCaret, &rect, TRUE);
                DeleteObject(hBrush);
            }
        }
        hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNTEXT));
        if (hBrush)
        {
            FillRect(hDC, &rCursor, hBrush);
            InvalidateRect(hwndCaret, &rCursor, TRUE);
            DeleteObject(hBrush);
        }
        ReleaseDC(hwnd,hDC);
    }
}

LRESULT CCaretPg::OnTimer( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
    if (wParam == BLINK)
    {
        BOOL fNoBlinkRate = (uNewBlinkTime == CURSORMAX)?TRUE:FALSE;
        if (fBlink || fNoBlinkRate)
        {
            DrawCaret(hwnd, fNoBlinkRate);
        }
        else
	    {
            InvalidateRect(hwndCaret, NULL, TRUE);
	    }

        if (fNoBlinkRate)
            KillTimer(hwnd, wParam);

        fBlink = !fBlink;
    }
    return 1;
}


LRESULT CCaretPg::OnHScroll( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
    if ((HWND)lParam == GetDlgItem(hwnd, KCURSOR_RATE))
    {
        // blink rate setting

        int nCurrent = (int)SendMessage( (HWND)lParam, TBM_GETPOS, 0, 0L );
        uNewBlinkTime = CURSORSUM - (nCurrent * 100);

        // reset the bink rate timer

        SetTimer(hwnd, BLINK, uNewBlinkTime, NULL);

        if (uNewBlinkTime == CURSORMAX) // draw the caret immediately; if we wait
            DrawCaret(hwnd, TRUE);      // for the timer there is a visible delay
    }
    else
    {
        // cursor width setting

        dwNewSize = (int)SendMessage( (HWND)lParam, TBM_GETPOS, 0, 0L );
	    
	    rCursor.right = rCursor.left + dwNewSize;
        DrawCaret(hwnd, (uNewBlinkTime == CURSORMAX));
    }

    return 1;
}

LRESULT CCaretPg::OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
{
    DBPRINTF(TEXT("OnPSN_SetActive:  uNewBlinkTime = %d\r\n"), uNewBlinkTime);
    if (uNewBlinkTime < CURSORMAX)
    {
        // start the blink rate timer to simulate cursor
        SetTimer(hwnd, BLINK, uBlinkTime, NULL);
    }
    else
    {
        // get the timer to draw the caret immediately
        SetTimer(hwnd, BLINK, 0, NULL);
    }
    return 1;
}

LRESULT CCaretPg::OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
{
    g_Options.m_schemePreview.m_uCursorBlinkTime = (uNewBlinkTime < CURSORMAX)?uNewBlinkTime:BLINK_OFF;
	g_Options.m_schemePreview.m_dwCaretWidth = dwNewSize;
    g_Options.ApplyPreview();
	return WizardPage::OnPSN_WizNext(hwnd, idCtl, pnmh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgbase.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx"
#pragma hdrstop

#include "pgbase.h"
#include "resource.h"
#include "DlgFonts.h"

/***************************************************************************
 * Use the following define if for some reason we have to go back to using
 * a message loop to let shell have time to update the UI
 *
#define NEED_MSG_PUMP
 **************************************************************************/

// Initialization of static members
CWizardPageOrder WizardPage::sm_WizPageOrder;

WizardPage::WizardPage(
					   LPPROPSHEETPAGE ppsp,
					   int nIdTitle,
					   int nIdSubTitle
					   ) : m_hwnd(NULL), m_dwPageId(0)
{
	_ASSERTE(NULL != ppsp);
	
	// If we have a subtitle, we must have a title
	_ASSERTE(nIdSubTitle?nIdTitle:TRUE);
	
	//
	// Many of the members are 0 or NULL.
	//
	ZeroMemory(ppsp, sizeof(PROPSHEETPAGE));
	
	ppsp->dwSize	= sizeof(PROPSHEETPAGE);
	
	ppsp->dwFlags	= PSP_DEFAULT;
	ppsp->hInstance = g_hInstDll;
	
	// If we are using a title/subtitle, include the flags
	// Otherwise, hide the header
	if(nIdTitle)
	{
		ppsp->dwFlags |= PSP_USEHEADERTITLE | (nIdSubTitle?PSP_USEHEADERSUBTITLE:0);
		ppsp->pszHeaderTitle = MAKEINTRESOURCE(nIdTitle);
		ppsp->pszHeaderSubTitle = MAKEINTRESOURCE(nIdSubTitle);
		// ppsp->pszbmHeader = MAKEINTRESOURCE(IDB_ACCMARK);
	}
	else
		ppsp->dwFlags |= PSP_HIDEHEADER;
	
	
	//
	// Callback is a base class function.  The derived page
	// classes need to implement OnPropSheetPageCreate() and
	// OnPropSheetPageRelease() if they want to handle this callback.
	// By WizardPage::OnPropSheetPageCreate() returns 1.
	//
	ppsp->pfnCallback = WizardPage::PropSheetPageCallback;
	ppsp->dwFlags	 |= (PSP_USECALLBACK /*| PSP_USEREFPARENT*/); // JMC: TODO: Do we want PSP_USEREFPARENT
	
	//
	// Store "this" in the page struct so we can call member functions
	// from the page's message proc.
	//
	_ASSERTE(NULL != this);
	ppsp->lParam = (LPARAM)this;
	
	//
	// All dialog messages first go through the base class' message proc.
	// Virtual functions are called for some messages.	If not processed
	// using a message-specific virtual function, the message is passed
	// to the derived class instance through the virtual funcion HandleMsg.
	//
	ppsp->pfnDlgProc = WizardPage::DlgProc;
}


WizardPage::~WizardPage(
						VOID
						)
{
}


UINT
WizardPage::PropSheetPageCallback(
								  HWND hwnd,
								  UINT uMsg,
								  LPPROPSHEETPAGE ppsp
								  )
{
	UINT uResult = 0;
	WizardPage *pThis = (WizardPage *)ppsp->lParam;
	_ASSERTE(NULL != pThis);
	
	switch(uMsg)
	{
	case PSPCB_CREATE:
		uResult = pThis->OnPropSheetPageCreate(hwnd, ppsp);
		break;
		
	case PSPCB_RELEASE:
		uResult = pThis->OnPropSheetPageRelease(hwnd, ppsp);
		//
		// IMPORTANT:
		// This is where we delete each property sheet page.
		// HERE and ONLY HERE.
		//
		//			  delete pThis; // We won't do this since we'll keep our own list
		// The reason it won't work is because if you never get to a page, you
		// will never get this message
		break;
	}
	return uResult;
}



//
// This is a static method.
//
INT_PTR
WizardPage::DlgProc(
					HWND hwnd,
					UINT uMsg,
					WPARAM wParam,
					LPARAM lParam
					)
{
	INT_PTR bResult		= FALSE;
	PROPSHEETPAGE *ppsp = NULL;
	
	if (WM_INITDIALOG == uMsg)
		ppsp = (PROPSHEETPAGE *)lParam;
	else
		ppsp = (PROPSHEETPAGE *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
	
	if (NULL != ppsp)
	{
		WizardPage *pThis = (WizardPage *)ppsp->lParam;
		_ASSERTE(NULL != pThis);
		
		switch(uMsg)
		{
		case WM_INITDIALOG:
			{
				// The following will set fonts for 'known' controls,
				DialogFonts_InitWizardPage(hwnd);
				
				//
				// Store address of PROPSHEETPAGE struct for this page
				// in window's user data.
				//
				SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);
				pThis->m_hwnd = hwnd;
				bResult = pThis->OnInitDialog(hwnd, wParam, lParam);
			}
			break;
			
		case WM_NOTIFY:
			bResult = pThis->OnNotify(hwnd, wParam, lParam);
			break;
			
		case PSM_QUERYSIBLINGS:
			bResult = pThis->OnPSM_QuerySiblings(hwnd, wParam, lParam);
			break;
			
		case WM_COMMAND:
			bResult = pThis->OnCommand(hwnd, wParam, lParam);
			break;

		case WM_TIMER:
			bResult = pThis->OnTimer(hwnd, wParam, lParam);
			break;

		case WM_DRAWITEM:
			bResult = pThis->OnDrawItem(hwnd, wParam, lParam);
			break;

		default:
			//
			// Let derived class instance handle any other messages
			// as needed.
			//
			bResult = pThis->HandleMsg(hwnd, uMsg, wParam, lParam);
			break;
		}
	}
	
	return bResult;
}


LRESULT
WizardPage::OnNotify(
					 HWND hwnd,
					 WPARAM wParam,
					 LPARAM lParam
					 )
{
	INT idCtl		= (INT)wParam;
	LPNMHDR pnmh	= (LPNMHDR)lParam;	
	LRESULT lResult = 0;
	
	switch(pnmh->code)
	{
	case PSN_APPLY:
		lResult = OnPSN_Apply(hwnd, idCtl, (LPPSHNOTIFY)pnmh);
		break;
	case PSN_HELP:
		lResult = OnPSN_Help(hwnd, idCtl, (LPPSHNOTIFY)pnmh);
		break;
	case PSN_KILLACTIVE:
		lResult = OnPSN_KillActive(hwnd, idCtl, (LPPSHNOTIFY)pnmh);
		break;
	case PSN_QUERYCANCEL:
		lResult = OnPSN_QueryCancel(hwnd, idCtl, (LPPSHNOTIFY)pnmh);
		break;
	case PSN_RESET:
		lResult = OnPSN_Reset(hwnd, idCtl, (LPPSHNOTIFY)pnmh);
		break;
	case PSN_SETACTIVE:
		lResult = OnPSN_SetActive(hwnd, idCtl, (LPPSHNOTIFY)pnmh);
		break;
	case PSN_WIZBACK:
		lResult = OnPSN_WizBack(hwnd, idCtl, (LPPSHNOTIFY)pnmh);
		break;
	case PSN_WIZNEXT:
		lResult = OnPSN_WizNext(hwnd, idCtl, (LPPSHNOTIFY)pnmh);
		break;
	case PSN_WIZFINISH:
		lResult = OnPSN_WizFinish(hwnd, idCtl, (LPPSHNOTIFY)pnmh);
		break;
	case NM_CLICK:
	case NM_RETURN:
		OnMsgNotify(hwnd, idCtl, (LPNMHDR) pnmh);
		break;
	default:
		break;
	}
	return lResult;
}


LRESULT
WizardPage::OnPSN_SetActive(
							HWND hwnd,
							INT idCtl,
							LPPSHNOTIFY pnmh
							)
{
	// JMC: TODO: Maybe put this in the OnNotify Code so the overrided class does
	// not have to call this

	//
	// By default, each wizard page has a BACK and NEXT button.
	//
	DWORD dwFlags = 0;
	if(sm_WizPageOrder.GetPrevPage(m_dwPageId))
		dwFlags |= PSWIZB_BACK;
	
	if(sm_WizPageOrder.GetNextPage(m_dwPageId))
		dwFlags |= PSWIZB_NEXT;
	else
		dwFlags |= PSWIZB_FINISH;
	
	PropSheet_SetWizButtons(GetParent(hwnd), dwFlags);
	
	// Tell the wizard that it's ok to go to this page
	SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
	return TRUE;
}


LRESULT
WizardPage::OnPSM_QuerySiblings(
								HWND hwnd,
								WPARAM wParam,
								LPARAM lParam
								)
{
	return 0;
}

LRESULT
WizardPage::OnPSN_QueryCancel(
							   HWND hwnd,
							   INT idCtl,
							   LPPSHNOTIFY pnmh
							   )
{
	//If nothing has changed just exit...
	if ( memcmp( &g_Options.m_schemePreview, &g_Options.m_schemeOriginal, sizeof(WIZSCHEME)) == 0)
	{
		SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
		return TRUE;
	}
	// if ( 
	switch(StringTableMessageBox(hwnd, IDS_WIZSAVECHANGESMESSAGETEXT, IDS_WIZSAVECHANGESMESSAGETITLE, MB_YESNO))
	{
	case IDYES:
		SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
		break;
	case IDNO:
    {
		// Restore all settings to the original settings
		g_Options.ApplyOriginal();

#if NEED_MSG_PUMP
        if (SetTimer(hwnd, 1, 4000, NULL))
        {
             // Wait for messages to be processed

            BOOL fKeepChecking = TRUE;
            while (fKeepChecking)
            {
                MSG msg;
                while (PeekMessage(&msg, hwnd, WM_TIMER, WM_TIMER, PM_REMOVE))
                {
                    if (msg.message == WM_TIMER)
                    {
                        KillTimer(hwnd, 1);
                        fKeepChecking = FALSE;
                        break;
                    }
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            } 
        }
#endif

		SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
    }
		break;
	case IDCANCEL:
		SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 1);
		break;

	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgcaret.h ===
#ifndef _INC_PGCARET_H
#define _INC_PGCARET_H

#include "pgbase.h"

class CCaretPg: public WizardPage
{
public:
    CCaretPg(LPPROPSHEETPAGE ppsp);
    ~CCaretPg(VOID);

protected:
	void UpdateControls();

	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
    LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam) {return 1;}
    LRESULT OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
    LRESULT OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
	LRESULT OnTimer( HWND hwnd, WPARAM wParam, LPARAM lParam );
	LRESULT OnHScroll( HWND hwnd, WPARAM wParam, LPARAM lParam );
	LRESULT HandleMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		LRESULT rv = 0;
		switch(uMsg)
		{
        case WM_HSCROLL:
			rv = OnHScroll(hwnd, wParam, lParam);
			break;

        // sliders don't get this message so pass it on
	    case WM_SYSCOLORCHANGE:
		    SendMessage(GetDlgItem(hwnd, KCURSOR_WIDTH), WM_SYSCOLORCHANGE, 0, 0);
		    SendMessage(GetDlgItem(hwnd, KCURSOR_RATE), WM_SYSCOLORCHANGE, 0, 0);
		    break;

		default:
			break;
		}
		return rv;
	}

private:
    void CCaretPg::DrawCaret(HWND hwnd, BOOL fClearFirst);

    BOOL fBlink;
    UINT uNewBlinkTime, uBlinkTime;
    DWORD dwNewSize, dwOriginalSize;
    HWND hwndCursorScroll;
    RECT rCursor;
    HWND hwndCaret;
};

#endif // _INC_PGCARET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\lookprev.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
/*  LOOKPREV.C
**
**
**
**  History:
**
*/
#include "pch.hxx" // PCH
#pragma hdrstop

#include "AccWiz.h"

#include "desk.h"
//#include "deskid.h"
#include "resource.h"
#include "look.h"

#include "LookPrev.h"

#define RCZ(element)         g_elements[element].rc


//////////////////////////////////
// Support function
void MyDrawBorderBelow(HDC hdc, LPRECT prc);
void MyDrawFrame(HDC hdc, LPRECT prc, HBRUSH hbrColor, int cl);


HDC g_hdcMem;
TCHAR g_szABC[] = TEXT("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
int cxSize;

//////////////////////////////////////////////////////////////
// Declarations of static variables declared in classes
BOOL CLookPreviewGlobals::sm_bOneInstanceCreated = FALSE; // This variable insures that only one instance of CLookPreviewGlobals is created
CLookPreviewGlobals CLookPrev::sm_Globals;

//////////////////////////////////////////////////////////////
// CLookPreviewGlobals member functions
//

BOOL CLookPreviewGlobals::Initialize()
{
   if(m_bInitialized)
      return TRUE;

   m_bInitialized = TRUE;

   // Make sure there is only one instance of this class created
   _ASSERT(!sm_bOneInstanceCreated);
   sm_bOneInstanceCreated = TRUE;

   //
   // Load our display strings.
   //
   VERIFY(LoadString(g_hInstDll, IDS_ACTIVE, m_szActive, ARRAYSIZE(m_szActive)));
   VERIFY(LoadString(g_hInstDll, IDS_INACTIVE, m_szInactive, ARRAYSIZE(m_szInactive)));
   VERIFY(LoadString(g_hInstDll, IDS_MINIMIZED, m_szMinimized, ARRAYSIZE(m_szMinimized)));
   VERIFY(LoadString(g_hInstDll, IDS_ICONTITLE, m_szIconTitle, ARRAYSIZE(m_szIconTitle)));
   VERIFY(LoadString(g_hInstDll, IDS_NORMAL, m_szNormal, ARRAYSIZE(m_szNormal)));
   VERIFY(LoadString(g_hInstDll, IDS_DISABLED, m_szDisabled, ARRAYSIZE(m_szDisabled)));
   VERIFY(LoadString(g_hInstDll, IDS_SELECTED, m_szSelected, ARRAYSIZE(m_szSelected)));
   VERIFY(LoadString(g_hInstDll, IDS_MSGBOX, m_szMsgBox, ARRAYSIZE(m_szMsgBox)));
   VERIFY(LoadString(g_hInstDll, IDS_BUTTONTEXT, m_szButton, ARRAYSIZE(m_szButton)));
//    VERIFY(LoadString(g_hInstDll, IDS_SMCAPTION, m_szSmallCaption, ARRAYSIZE(m_szSmallCaption)));
   VERIFY(LoadString(g_hInstDll, IDS_WINDOWTEXT, m_szWindowText, ARRAYSIZE(m_szWindowText)));
   VERIFY(LoadString(g_hInstDll, IDS_MSGBOXTEXT, m_szMsgBoxText, ARRAYSIZE(m_szMsgBoxText)));

   /////////////////////////////////////////////
   // Register Look Preview window class
   WNDCLASS wc;
   memset(&wc, 0, sizeof(wc));
   wc.style = 0;
   wc.lpfnWndProc = CLookPrev::LookPreviewWndProc;
   wc.cbClsExtra = 0;
   wc.cbWndExtra = 0;
   wc.hInstance = g_hInstDll;
   wc.hIcon = NULL;
   wc.hCursor = LoadCursor(NULL, IDC_ARROW);
   wc.hbrBackground = (HBRUSH)(COLOR_3DFACE+1);
   wc.lpszMenuName = NULL;
   wc.lpszClassName = LOOKPREV_CLASS;

   VERIFY(RegisterClass(&wc));

   /////////////////////////////////////////////
   // Global initialization of g_hdcMem
   HBITMAP hbmDefault;
   HDC hdc = GetDC(NULL);
   VERIFY(g_hdcMem = CreateCompatibleDC(hdc));
   ReleaseDC(NULL, hdc);

   HBITMAP hbm = CreateBitmap(1, 1, 1, 1, NULL);
   if (!hbm)
      return FALSE;	// Prefix #113777 (avoid null handle reference)

   hbmDefault = (HBITMAP)SelectObject(g_hdcMem, hbm);
   SelectObject(g_hdcMem, hbmDefault);
   DeleteObject(hbm);


   /////////////////////////////////////////////
   // Old initialization form Look_InitSysStuff()
   int i;
   NONCLIENTMETRICS ncm;
   HKEY hkey;

   hdc = GetDC(NULL);
   g_LogDPI = GetDeviceCaps(hdc, LOGPIXELSY);
   g_bPalette = GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE;
   ReleaseDC(NULL, hdc);

   // always make a palette even on non-pal device
   if (g_bPalette || TRUE)
   {
      DWORD pal[21];
      HPALETTE hpal = (HPALETTE)GetStockObject(DEFAULT_PALETTE);

      pal[1]   = RGB(255, 255, 255);
      pal[2]   = RGB(0,   0,  0  );
      pal[3]   = RGB(192, 192, 192);
      pal[4]   = RGB(128, 128, 128);
      pal[5]   = RGB(255, 0,  0  );
      pal[6]   = RGB(128, 0,  0  );
      pal[7]   = RGB(255, 255, 0  );
      pal[8]   = RGB(128, 128, 0  );
      pal[9]   = RGB(0  , 255, 0  );
      pal[10] = RGB(0  , 128, 0  );
      pal[11] = RGB(0  , 255, 255);
      pal[12] = RGB(0 , 128, 128); // Needs to be changed to get Blue color
      pal[13] = RGB(0  , 0,   255);
      pal[14] = RGB(0  , 0,   128);
      pal[15] = RGB(255, 0,   255);
      pal[16] = RGB(128, 0,   128);

      GetPaletteEntries(hpal, 11, 1, (LPPALETTEENTRY)&pal[17]);
      pal[0]   = MAKELONG(0x300, 17);
      g_hpalVGA = CreatePalette((LPLOGPALETTE)pal);

      // get magic colors
      GetPaletteEntries(hpal, 8, 4, (LPPALETTEENTRY)&pal[17]);

      pal[0]   = MAKELONG(0x300, 20);
      g_hpal3D = CreatePalette((LPLOGPALETTE)pal);
   }

   // system colors
   for (i = 0; i < NT40_COLOR_MAX; i++)
   {
      g_Options.m_schemePreview.m_rgb[i] = GetSysColor(i);
      g_brushes[i] = NULL;
   }

   // sizes and fonts
   ncm.cbSize = sizeof(ncm);
   SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm),
                        (void far *)(LPNONCLIENTMETRICS)&ncm, FALSE);

   SetMyNonClientMetrics(&ncm);

   SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT),
            (void far *)(LPLOGFONT)&(g_fonts[FONT_ICONTITLE].lf), FALSE);

   SystemParametersInfo(SPI_SETGRADIENTCAPTIONS, 0, (PVOID)TRUE, 0);

   // default shell icon sizes
   g_sizes[ SIZE_ICON ].CurSize = GetSystemMetrics( SM_CXICON );
   g_sizes[ SIZE_SMICON ].CurSize = g_sizes[ SIZE_ICON ].CurSize / 2;

   if( RegOpenKeyEx( HKEY_CURRENT_USER, c_szRegPathUserMetrics, 0, KEY_QUERY_VALUE, &hkey )
      == ERROR_SUCCESS )
   {
      TCHAR val[ 8 ];
      LONG len = sizeof( val );

      if( RegQueryValueEx( hkey, c_szRegValIconSize, 0, NULL, (LPBYTE)val,
         (LPDWORD)&len ) == ERROR_SUCCESS )
      {
		 val[ARRAYSIZE(val)-1] = TEXT('\0'); // ensure NUL termination
         g_sizes[ SIZE_ICON ].CurSize = (int)MyStrToLong( val );
      }

      len = SIZEOF( val );
      if( RegQueryValueEx( hkey, c_szRegValSmallIconSize, 0, NULL, (LPBYTE)val,
         (LPDWORD)&len ) == ERROR_SUCCESS )
      {
		 val[ARRAYSIZE(val)-1] = TEXT('\0'); // ensure NUL termination
         g_sizes[ SIZE_SMICON ].CurSize = (int)MyStrToLong( val );
      }

      RegCloseKey( hkey );
   }

   g_sizes[ SIZE_DXICON ].CurSize =
      GetSystemMetrics( SM_CXICONSPACING ) - g_sizes[ SIZE_ICON ].CurSize;
   if( g_sizes[ SIZE_DXICON ].CurSize < 0 )
      g_sizes[ SIZE_DXICON ].CurSize = DEF_SPACING;

   g_sizes[ SIZE_DYICON ].CurSize =
      GetSystemMetrics( SM_CYICONSPACING ) - g_sizes[ SIZE_ICON ].CurSize;
   if( g_sizes[ SIZE_DYICON ].CurSize < 0 )
      g_sizes[ SIZE_DYICON ].CurSize = DEF_SPACING;

   // clean out the memory
   for (i = 0; i < NUM_FONTS; i++)
   {
      g_fonts[i].hfont = NULL;
   }

   // build all the brushes/fonts we need
   Look_RebuildSysStuff(TRUE);


   // From Look_InitDialog
   // initialize some globals
   cyBorder = GetSystemMetrics(SM_CYBORDER);
   cxBorder = GetSystemMetrics(SM_CXBORDER);
   cxEdge = GetSystemMetrics(SM_CXEDGE);
   cyEdge = GetSystemMetrics(SM_CYEDGE);

   return TRUE;
}


//////////////////////////////////////////////////////////////
// CLookPreviewGlobals member functions
//

// This is the static window proc function of CLookPrev
LRESULT CALLBACK CLookPrev::LookPreviewWndProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
   PAINTSTRUCT ps;

   CLookPrev *pThis = (CLookPrev *)GetWindowLongPtr(hWnd, GWLP_USERDATA);
   if(!pThis)
   {
      // Create the class to handle this object
      // Store the 'this' pointer in 
      pThis = new CLookPrev;
      if (!pThis)
            return ERROR_NOT_ENOUGH_MEMORY;	// Prefix #113776 (catch null pointer)

      pThis->m_hwnd = hWnd;
      SetWindowLongPtr (hWnd, GWLP_USERDATA, (INT_PTR)pThis);
   }

   switch(message)
   {
      case WM_NCCREATE:
         {
            DWORD dw;
            dw = GetWindowLong (hWnd,GWL_STYLE);
            SetWindowLong (hWnd, GWL_STYLE, dw | WS_BORDER);
            dw = GetWindowLong (hWnd,GWL_EXSTYLE);
            SetWindowLong (hWnd, GWL_EXSTYLE, dw | WS_EX_CLIENTEDGE);
         }
         return TRUE;

      case WM_CREATE:
         pThis->OnCreate();
         break;

      case WM_PALETTECHANGED:
         if ((HWND)wParam == hWnd)
            break;
         //fallthru
      case WM_QUERYNEWPALETTE:
         if (g_hpal3D)
            InvalidateRect(hWnd, NULL, FALSE);
         break;

      case WM_PAINT:
         BeginPaint(hWnd, &ps);
         pThis->OnPaint(ps.hdc);
         EndPaint(hWnd, &ps);
         return 0;

      case LPM_REPAINT:
         pThis->OnRepaint();
         return 0;

      case LPM_RECALC:
         pThis->OnRecalc();
         return 0;

   }
   return DefWindowProc(hWnd,message,wParam,lParam);
}

void CLookPrev::OnCreate()
{
   // Load menu for window
   m_hmenuSample = LoadMenu(g_hInstDll, MAKEINTRESOURCE(IDR_MENU));
   EnableMenuItem(m_hmenuSample, IDM_DISABLED, MF_GRAYED | MF_BYCOMMAND);
   HiliteMenuItem(m_hwnd, m_hmenuSample, IDM_SELECTED, MF_HILITE | MF_BYCOMMAND);

   // Create Bitmap for window
   RECT rc;
   HDC hdc;
   GetClientRect(m_hwnd, &rc);
   hdc = GetDC(NULL);
   m_hbmLook = CreateCompatibleBitmap(hdc, rc.right - rc.left, rc.bottom - rc.top);
   ReleaseDC(NULL, hdc);
   // Mirror the memory DC if the window is mirrored to keep the text readable.
   if (GetWindowLong(m_hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) {
       SetLayout(g_hdcMem, LAYOUT_RTL);
   }
}

void CLookPrev::OnDestroy()
{
   if (m_hbmLook)
      DeleteObject(m_hbmLook);
   if (m_hmenuSample)
      DestroyMenu(m_hmenuSample);

   // Un-allocate memory for this instance of the class
   delete this;
}


void CLookPrev::OnPaint(HDC hdc)
{
   if (m_hbmLook)
      ShowBitmap(hdc);
   else
      Draw(hdc);
}

void CLookPrev::ShowBitmap(HDC hdc)
{
   RECT rc;
   HBITMAP hbmOld;
   HPALETTE hpalOld = NULL;

   if (g_hpal3D)
   {
      hpalOld = SelectPalette(hdc, g_hpal3D, FALSE);
      RealizePalette(hdc);
   }

   GetClientRect(m_hwnd, &rc);
   hbmOld = (HBITMAP)SelectObject(g_hdcMem, m_hbmLook);
   BitBlt(hdc, 0, 0, rc.right - rc.left, rc.bottom - rc.top, g_hdcMem, 0, 0, SRCCOPY);
   SelectObject(g_hdcMem, hbmOld);

   if (hpalOld)
   {
      SelectPalette(hdc, hpalOld, FALSE);
      RealizePalette(hdc);
   }
}



void CLookPrev::Draw(HDC hdc)
{
   RECT rcT;
   int nMode;
   DWORD rgbBk;

   int cySize;
   HANDLE hOldColors;
   HPALETTE hpalOld = NULL;
   HICON hiconLogo;
// HFONT hfontOld;

   SaveDC(hdc);

   if (g_hpal3D)
   {
      hpalOld = SelectPalette(hdc, g_hpal3D, TRUE);
      RealizePalette(hdc);
   }

   hOldColors = SetSysColorsTemp(g_Options.m_schemePreview.m_rgb, g_brushes, COLOR_MAX_97_NT5/*COLOR_MAX_95_NT4*/);

   hiconLogo = (HICON)LoadImage(NULL, IDI_APPLICATION, IMAGE_ICON,
                  g_sizes[SIZE_CAPTION].CurSize - 2*cxBorder,
                  g_sizes[SIZE_CAPTION].CurSize - 2*cyBorder, 0);

   //
   // Setup drawing stuff
   //
   nMode = SetBkMode(hdc, TRANSPARENT);
   rgbBk = GetTextColor(hdc);

//   cxSize   = GetSystemMetrics(SM_CXSIZE);
   cySize   = GetSystemMetrics(SM_CYSIZE);

   //
   // Desktop
   //
   FillRect(hdc, &RCZ(ELEMENT_DESKTOP), g_brushes[COLOR_BACKGROUND]);

   //
   // Inactive window
   //

   // Border
   rcT = RCZ(ELEMENT_INACTIVEBORDER);
   DrawEdge(hdc, &rcT, EDGE_RAISED, BF_RECT | BF_ADJUST);
   MyDrawFrame(hdc, &rcT, g_brushes[COLOR_INACTIVEBORDER], g_sizes[SIZE_FRAME].CurSize);
   MyDrawFrame(hdc, &rcT, g_brushes[COLOR_3DFACE], 1);

   // Caption
   rcT = RCZ(ELEMENT_INACTIVECAPTION);
   MyDrawBorderBelow(hdc, &rcT);

   // NOTE: because USER draws icon stuff using its own DC and subsequently
   // its own palette, we need to make sure to use the inactivecaption
   // brush before USER does so that it will be realized against our palette.
   // this might get fixed in USER by better be safe. 

   // "clip" the caption title under the buttons
   rcT.left = RCZ(ELEMENT_INACTIVESYSBUT2).left - cyEdge;
   FillRect(hdc, &rcT, g_brushes[COLOR_GRADIENTINACTIVECAPTION]);
   rcT.right = rcT.left;
   rcT.left = RCZ(ELEMENT_INACTIVECAPTION).left;
   DrawCaptionTemp(NULL, hdc, &rcT, g_fonts[FONT_CAPTION].hfont, hiconLogo, sm_Globals.m_szInactive, DC_ICON | DC_TEXT | DC_GRADIENT);

   DrawFrameControl(hdc, &RCZ(ELEMENT_INACTIVESYSBUT1), DFC_CAPTION, DFCS_CAPTIONCLOSE);
   rcT = RCZ(ELEMENT_INACTIVESYSBUT2);
   rcT.right -= (rcT.right - rcT.left)/2;
   DrawFrameControl(hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONMIN);
   rcT.left = rcT.right;
   rcT.right = RCZ(ELEMENT_INACTIVESYSBUT2).right;
   DrawFrameControl(hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONMAX);


#if 0
   //
   // small caption window
   // 

   {
   HICON hicon;
   int temp;


   rcT = RCZ(ELEMENT_SMCAPTION);
   hicon = (HICON)LoadImage(NULL, IDI_APPLICATION,
         IMAGE_ICON,
                  g_sizes[SIZE_SMCAPTION].CurSize - 2*cxBorder,
                  g_sizes[SIZE_SMCAPTION].CurSize - 2*cyBorder,
               0);

   DrawEdge(hdc, &rcT, EDGE_RAISED, BF_TOP | BF_LEFT | BF_RIGHT | BF_ADJUST);
   MyDrawFrame(hdc, &rcT, g_brushes[COLOR_3DFACE], 1);
   // "clip" the caption title under the buttons
   temp = rcT.left;  // remember start of actual caption
   rcT.left = RCZ(ELEMENT_SMCAPSYSBUT).left - cxEdge;
   FillRect(hdc, &rcT, g_brushes[COLOR_ACTIVECAPTION]);
   rcT.right = rcT.left;
   rcT.left = temp;  // start of actual caption
   DrawCaptionTemp(NULL, hdc, &rcT, g_fonts[FONT_SMCAPTION].hfont, hicon, sm_Globals.m_szSmallCaption, DC_SMALLCAP | DC_ICON | DC_TEXT);
   DestroyIcon(hicon);

   DrawFrameControl(hdc, &RCZ(ELEMENT_SMCAPSYSBUT), DFC_CAPTION, DFCS_CAPTIONCLOSE);
   }
#endif

   //
   // Active window
   //

   // Border
   rcT = RCZ(ELEMENT_ACTIVEBORDER);
   DrawEdge(hdc, &rcT, EDGE_RAISED, BF_RECT | BF_ADJUST);
   MyDrawFrame(hdc, &rcT, g_brushes[COLOR_ACTIVEBORDER], g_sizes[SIZE_FRAME].CurSize);
   MyDrawFrame(hdc, &rcT, g_brushes[COLOR_3DFACE], 1);

   // Caption
   rcT = RCZ(ELEMENT_ACTIVECAPTION);
   MyDrawBorderBelow(hdc, &rcT);
   // "clip" the caption title under the buttons
   rcT.left = RCZ(ELEMENT_ACTIVESYSBUT2).left - cxEdge;
   FillRect(hdc, &rcT, g_brushes[COLOR_GRADIENTACTIVECAPTION]);
   rcT.right = rcT.left;
   rcT.left = RCZ(ELEMENT_ACTIVECAPTION).left;
   DrawCaptionTemp(NULL, hdc, &rcT, g_fonts[FONT_CAPTION].hfont, hiconLogo, sm_Globals.m_szActive, DC_ACTIVE | DC_ICON | DC_TEXT | DC_GRADIENT);

   DrawFrameControl(hdc, &RCZ(ELEMENT_ACTIVESYSBUT1), DFC_CAPTION, DFCS_CAPTIONCLOSE);
   rcT = RCZ(ELEMENT_ACTIVESYSBUT2);
   rcT.right -= (rcT.right - rcT.left)/2;
   DrawFrameControl(hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONMIN);
   rcT.left = rcT.right;
   rcT.right = RCZ(ELEMENT_ACTIVESYSBUT2).right;
   DrawFrameControl(hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONMAX);

   // Menu
   rcT = RCZ(ELEMENT_MENUNORMAL);
   
#if 0 // HACK TO SLIP USING DrawMenuBarTemp() which is not available on Memphis
   DrawMenuBarTemp(m_hwnd, hdc, &rcT, g_Options.m_hmenuSample, g_fonts[FONT_MENU].hfont);
#else
   {
      // JMC: HACK - HARD CODED TEXT
      HFONT hOldFont = (HFONT)SelectObject(hdc, g_fonts[FONT_MENU].hfont);
      COLORREF clrrefOldText = SetTextColor(hdc, g_Options.m_schemePreview.m_rgb[COLOR_MENUTEXT]);
      COLORREF clrrefOldBk = SetBkColor(hdc, g_Options.m_schemePreview.m_rgb[COLOR_MENU]);
      int nOldMode = SetBkMode(hdc, OPAQUE);
//    LPCTSTR lpszText = __TEXT("  File   Edit   Help");
      TCHAR szText[200];
      LoadString(g_hInstDll, IDS_PREVIEWMENUTEXT, szText, ARRAYSIZE(szText));
      ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcT, NULL, 0, NULL);
      DrawText(hdc, szText, lstrlen(szText), &rcT, DT_VCENTER | DT_SINGLELINE | DT_EXPANDTABS);
      SetTextColor(hdc, clrrefOldText);
      SetBkColor(hdc, clrrefOldBk);
      SetBkMode(hdc, nOldMode);
      SelectObject(hdc, hOldFont);
   }
#endif
   MyDrawBorderBelow(hdc, &rcT);

   //
   // Client area
   //

   rcT = RCZ(ELEMENT_WINDOW);
   DrawEdge(hdc, &rcT, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
   FillRect(hdc, &rcT, g_brushes[COLOR_WINDOW]);

   // window text
   SetBkMode(hdc, TRANSPARENT);
   SetTextColor(hdc, g_Options.m_schemePreview.m_rgb[COLOR_WINDOWTEXT]);
   TextOut(hdc, RCZ(ELEMENT_WINDOW).left + 2*cxEdge, RCZ(ELEMENT_WINDOW).top + 2*cyEdge, sm_Globals.m_szWindowText, lstrlen(sm_Globals.m_szWindowText));

   //
   // scroll bar
   //
   rcT = RCZ(ELEMENT_SCROLLBAR);
   //MyDrawFrame(hdc, &rcT, g_brushes[COLOR_3DSHADOW], 1);
   //g_brushes[COLOR_SCROLLBAR]);
   //FillRect(hdc, &rcT, (HBRUSH)DefWindowProc(m_hwnd, WM_CTLCOLORSCROLLBAR, (WPARAM)hdc, (LPARAM)m_hwnd));
   FillRect(hdc, &rcT, g_brushes[COLOR_SCROLLBAR]);

   DrawFrameControl(hdc, &RCZ(ELEMENT_SCROLLUP), DFC_SCROLL, DFCS_SCROLLUP);
   DrawFrameControl(hdc, &RCZ(ELEMENT_SCROLLDOWN), DFC_SCROLL, DFCS_SCROLLDOWN);

#if 0 // Don't draw message box
   //
   // MessageBox
   //
   rcT = RCZ(ELEMENT_MSGBOX);
   DrawEdge(hdc, &rcT, EDGE_RAISED, BF_RECT | BF_ADJUST);
   FillRect(hdc, &rcT, g_brushes[COLOR_3DFACE]);

   rcT = RCZ(ELEMENT_MSGBOXCAPTION);
   MyDrawBorderBelow(hdc, &rcT);
   // "clip" the caption title under the buttons
   rcT.left = RCZ(ELEMENT_MSGBOXSYSBUT).left - cxEdge;
   FillRect(hdc, &rcT, g_brushes[COLOR_GRADIENTACTIVECAPTION]);
   rcT.right = rcT.left;
   rcT.left = RCZ(ELEMENT_MSGBOXCAPTION).left;
   DrawCaptionTemp(NULL, hdc, &rcT, g_fonts[FONT_CAPTION].hfont, hiconLogo, sm_Globals.m_szMsgBox, DC_ACTIVE | DC_ICON | DC_TEXT | DC_GRADIENT);

   DrawFrameControl(hdc, &RCZ(ELEMENT_MSGBOXSYSBUT), DFC_CAPTION, DFCS_CAPTIONCLOSE);

   // message box text
   SetBkMode(hdc, TRANSPARENT);
   SetTextColor(hdc, g_Options.m_schemePreview.m_rgb[COLOR_WINDOWTEXT]);
   hfontOld = (HFONT)SelectObject(hdc, g_fonts[FONT_MSGBOX].hfont);
   TextOut(hdc, RCZ(ELEMENT_MSGBOX).left + 3*cxEdge, RCZ(ELEMENT_MSGBOXCAPTION).bottom + cyEdge,
                  sm_Globals.m_szMsgBoxText, lstrlen(sm_Globals.m_szMsgBoxText));
   if (hfontOld)
      SelectObject(hdc, hfontOld);

   //
   // Button
   //
   rcT = RCZ(ELEMENT_BUTTON);
   DrawFrameControl(hdc, &rcT, DFC_BUTTON, DFCS_BUTTONPUSH);

// ?????? what font should this use ??????
   SetBkMode(hdc, TRANSPARENT);
   SetTextColor(hdc, g_Options.m_schemePreview.m_rgb[COLOR_BTNTEXT]);
   DrawText(hdc, sm_Globals.m_szButton, -1, &rcT, DT_CENTER | DT_NOPREFIX |
      DT_SINGLELINE | DT_VCENTER);
#endif

   SetBkColor(hdc, rgbBk);
   SetBkMode(hdc, nMode);

   if (hiconLogo)
      DestroyIcon(hiconLogo);

   SetSysColorsTemp(NULL, NULL, (UINT_PTR)hOldColors);

   if (hpalOld)
   {
      hpalOld = SelectPalette(hdc, hpalOld, FALSE);
      RealizePalette(hdc);
   }

   RestoreDC(hdc, -1);
}

void CLookPrev::OnRepaint()
{
   HBITMAP hbmOld;

   if (m_hbmLook)
   {
      hbmOld = (HBITMAP)SelectObject(g_hdcMem, m_hbmLook);
      Draw(g_hdcMem);
      SelectObject(g_hdcMem, hbmOld);
   }
   InvalidateRect(m_hwnd, NULL, FALSE);
}


void CLookPrev::OnRecalc()
{
   DWORD cxNormal;
   int cxDisabled, cxSelected;
   int cxAvgCharx2;
   RECT rc;
   HFONT hfontT;
   int cxFrame, cyFrame;
   int cyCaption;
   int i;
   SIZE sizButton;

   GetClientRect(m_hwnd, &rc);

   //
   // Get our drawing data
   //
   cxSize = GetSystemMetrics(SM_CXSIZE);
   cxFrame = (g_sizes[SIZE_FRAME].CurSize + 1) * cxBorder + cxEdge;
   cyFrame = (g_sizes[SIZE_FRAME].CurSize + 1) * cyBorder + cyEdge;
   cyCaption = g_sizes[SIZE_CAPTION].CurSize;

   //
   // Get text dimensions, with proper font.
   //

   hfontT = (HFONT)SelectObject(g_hdcMem, g_fonts[FONT_MENU].hfont);

   GetTextExtentPoint32(g_hdcMem, sm_Globals.m_szNormal, lstrlen(sm_Globals.m_szNormal), &sizButton);
   cxNormal = sizButton.cx;

   GetTextExtentPoint32(g_hdcMem, sm_Globals.m_szDisabled, lstrlen(sm_Globals.m_szDisabled), &sizButton);
   cxDisabled = sizButton.cx;

   GetTextExtentPoint32(g_hdcMem, sm_Globals.m_szSelected, lstrlen(sm_Globals.m_szSelected), &sizButton);
   cxSelected = sizButton.cx;

   // get the average width (USER style) of menu font
   GetTextExtentPoint32(g_hdcMem, g_szABC, 52, &sizButton);
   cxAvgCharx2 = 2 * (sizButton.cx / 52);

   // actual menu-handling widths of strings is bigger
   cxDisabled += cxAvgCharx2;
   cxSelected += cxAvgCharx2;
   cxNormal += cxAvgCharx2;

   SelectObject(g_hdcMem, hfontT);

   GetTextExtentPoint32(g_hdcMem, sm_Globals.m_szButton, lstrlen(sm_Globals.m_szButton), &sizButton);

   //
   // Desktop
   //
   RCZ(ELEMENT_DESKTOP) = rc;

   InflateRect(&rc, -8*cxBorder, -8*cyBorder);

   //
   // Windows
   //
   rc.bottom -= cyFrame + cyCaption;
   RCZ(ELEMENT_ACTIVEBORDER) = rc;
   OffsetRect(&RCZ(ELEMENT_ACTIVEBORDER), cxFrame,
                  cyFrame + cyCaption + cyBorder);
   RCZ(ELEMENT_ACTIVEBORDER).bottom -= cyCaption;

   //
   // Inactive window
   //

   rc.right -= cyCaption;
   RCZ(ELEMENT_INACTIVEBORDER) = rc;

   // Caption
   InflateRect(&rc, -cxFrame, -cyFrame);
   rc.bottom = rc.top + cyCaption + cyBorder;
   RCZ(ELEMENT_INACTIVECAPTION) = rc;

   // close button
   InflateRect(&rc, -cxEdge, -cyEdge);
   rc.bottom -= cyBorder;     // compensate for magic line under caption
   RCZ(ELEMENT_INACTIVESYSBUT1) = rc;
   RCZ(ELEMENT_INACTIVESYSBUT1).left = rc.right - (cyCaption - cxEdge);

   // min/max buttons
   RCZ(ELEMENT_INACTIVESYSBUT2) = rc;
   RCZ(ELEMENT_INACTIVESYSBUT2).right = RCZ(ELEMENT_INACTIVESYSBUT1).left - cxEdge;
   RCZ(ELEMENT_INACTIVESYSBUT2).left = RCZ(ELEMENT_INACTIVESYSBUT2).right - 
                                    2 * (cyCaption - cxEdge);

#if 0
   //
   // small caption window
   //
   RCZ(ELEMENT_SMCAPTION) = RCZ(ELEMENT_ACTIVEBORDER);
   RCZ(ELEMENT_SMCAPTION).bottom = RCZ(ELEMENT_SMCAPTION).top;
   RCZ(ELEMENT_SMCAPTION).top -= g_sizes[SIZE_SMCAPTION].CurSize + cyEdge + 2 * cyBorder;
   RCZ(ELEMENT_SMCAPTION).right -= cxFrame;
   RCZ(ELEMENT_SMCAPTION).left = RCZ(ELEMENT_INACTIVECAPTION).right + 2 * cxFrame;

   RCZ(ELEMENT_SMCAPSYSBUT) = RCZ(ELEMENT_SMCAPTION);
   // deflate inside frame/border to caption and then another edge's worth
   RCZ(ELEMENT_SMCAPSYSBUT).right -= 2 * cxEdge + cxBorder;
   RCZ(ELEMENT_SMCAPSYSBUT).top += 2 * cxEdge + cxBorder;
   RCZ(ELEMENT_SMCAPSYSBUT).bottom -= cxEdge + cxBorder;
   RCZ(ELEMENT_SMCAPSYSBUT).left = RCZ(ELEMENT_SMCAPSYSBUT).right - 
                              (g_sizes[SIZE_SMCAPTION].CurSize - cxEdge);
#endif

   //
   // Active window
   //

   // Caption
   rc = RCZ(ELEMENT_ACTIVEBORDER);
   InflateRect(&rc, -cxFrame, -cyFrame);
   RCZ(ELEMENT_ACTIVECAPTION) = rc;
   RCZ(ELEMENT_ACTIVECAPTION).bottom = 
      RCZ(ELEMENT_ACTIVECAPTION).top + cyCaption + cyBorder;

   // close button
   RCZ(ELEMENT_ACTIVESYSBUT1) = RCZ(ELEMENT_ACTIVECAPTION);
   InflateRect(&RCZ(ELEMENT_ACTIVESYSBUT1), -cxEdge, -cyEdge);
   RCZ(ELEMENT_ACTIVESYSBUT1).bottom -= cyBorder;     // compensate for magic line under caption
   RCZ(ELEMENT_ACTIVESYSBUT1).left = RCZ(ELEMENT_ACTIVESYSBUT1).right - 
                              (cyCaption - cxEdge);

   // min/max buttons
   RCZ(ELEMENT_ACTIVESYSBUT2) = RCZ(ELEMENT_ACTIVESYSBUT1);
   RCZ(ELEMENT_ACTIVESYSBUT2).right = RCZ(ELEMENT_ACTIVESYSBUT1).left - cxEdge;
   RCZ(ELEMENT_ACTIVESYSBUT2).left = RCZ(ELEMENT_ACTIVESYSBUT2).right - 
                                    2 * (cyCaption - cxEdge);

   // Menu
   rc.top = RCZ(ELEMENT_ACTIVECAPTION).bottom;
   RCZ(ELEMENT_MENUNORMAL) = rc;
   rc.top = RCZ(ELEMENT_MENUNORMAL).bottom = RCZ(ELEMENT_MENUNORMAL).top + g_sizes[SIZE_MENU].CurSize;
   RCZ(ELEMENT_MENUDISABLED) = RCZ(ELEMENT_MENUSELECTED) = RCZ(ELEMENT_MENUNORMAL);

   RCZ(ELEMENT_MENUDISABLED).left = RCZ(ELEMENT_MENUNORMAL).left + cxNormal;
   RCZ(ELEMENT_MENUDISABLED).right = RCZ(ELEMENT_MENUSELECTED).left = 
                  RCZ(ELEMENT_MENUDISABLED).left + cxDisabled;
   RCZ(ELEMENT_MENUSELECTED).right = RCZ(ELEMENT_MENUSELECTED).left + cxSelected;
   
   //
   // Client
   //
   RCZ(ELEMENT_WINDOW) = rc;

   //
   // Scrollbar
   //
   InflateRect(&rc, -cxEdge, -cyEdge); // take off client edge
   RCZ(ELEMENT_SCROLLBAR) = rc;
   rc.right = RCZ(ELEMENT_SCROLLBAR).left = rc.right - g_sizes[SIZE_SCROLL].CurSize;
   RCZ(ELEMENT_SCROLLUP) = RCZ(ELEMENT_SCROLLBAR);
   RCZ(ELEMENT_SCROLLUP).bottom = RCZ(ELEMENT_SCROLLBAR).top + g_sizes[SIZE_SCROLL].CurSize; 

   RCZ(ELEMENT_SCROLLDOWN) = RCZ(ELEMENT_SCROLLBAR);
   RCZ(ELEMENT_SCROLLDOWN).top = RCZ(ELEMENT_SCROLLBAR).bottom - g_sizes[SIZE_SCROLL].CurSize; 

   //
   // Message Box
   //
   rc.top = RCZ(ELEMENT_WINDOW).top + (RCZ(ELEMENT_WINDOW).bottom - RCZ(ELEMENT_WINDOW).top) / 2;
   rc.bottom = RCZ(ELEMENT_DESKTOP).bottom - 2*cyEdge;
   rc.left = RCZ(ELEMENT_WINDOW).left + 2*cyEdge;
   rc.right = RCZ(ELEMENT_WINDOW).left + (RCZ(ELEMENT_WINDOW).right - RCZ(ELEMENT_WINDOW).left) / 2 + 3*cyCaption;
   RCZ(ELEMENT_MSGBOX) = rc;

   // Caption
   RCZ(ELEMENT_MSGBOXCAPTION) = rc;
   RCZ(ELEMENT_MSGBOXCAPTION).top += cyEdge + cyBorder;
   RCZ(ELEMENT_MSGBOXCAPTION).bottom = RCZ(ELEMENT_MSGBOXCAPTION).top + cyCaption + cyBorder;
   RCZ(ELEMENT_MSGBOXCAPTION).left += cxEdge + cxBorder;
   RCZ(ELEMENT_MSGBOXCAPTION).right -= cxEdge + cxBorder;

   RCZ(ELEMENT_MSGBOXSYSBUT) = RCZ(ELEMENT_MSGBOXCAPTION);
   InflateRect(&RCZ(ELEMENT_MSGBOXSYSBUT), -cxEdge, -cyEdge);
   RCZ(ELEMENT_MSGBOXSYSBUT).left = RCZ(ELEMENT_MSGBOXSYSBUT).right - 
                              (cyCaption - cxEdge);
   RCZ(ELEMENT_MSGBOXSYSBUT).bottom -= cyBorder;      // line under caption

   // Button
   RCZ(ELEMENT_BUTTON).bottom = RCZ(ELEMENT_MSGBOX).bottom - (4*cyBorder + cyEdge);
   RCZ(ELEMENT_BUTTON).top = RCZ(ELEMENT_BUTTON).bottom - (sizButton.cy + 8 * cyBorder);

   i = (RCZ(ELEMENT_BUTTON).bottom - RCZ(ELEMENT_BUTTON).top) * 3;
   RCZ(ELEMENT_BUTTON).left = (rc.left + (rc.right - rc.left)/2) - i/2;
   RCZ(ELEMENT_BUTTON).right = RCZ(ELEMENT_BUTTON).left + i;
}












/////////////////////////////////////////////////////////
// Support functions





// ----------------------------------------------------------------------------
//
//  MyDrawFrame() -
//
//  Draws bordered frame, border size cl, and adjusts passed in rect.
//
// ----------------------------------------------------------------------------
void MyDrawFrame(HDC hdc, LPRECT prc, HBRUSH hbrColor, int cl)
{
   HBRUSH hbr;
   int cx, cy;
   RECT rcT;

   rcT = *prc;
   cx = cl * cxBorder;
   cy = cl * cyBorder;

   hbr = (HBRUSH)SelectObject(hdc, hbrColor);

   PatBlt(hdc, rcT.left, rcT.top, cx, rcT.bottom - rcT.top, PATCOPY);
   rcT.left += cx;

   PatBlt(hdc, rcT.left, rcT.top, rcT.right - rcT.left, cy, PATCOPY);
   rcT.top += cy;

   rcT.right -= cx;
   PatBlt(hdc, rcT.right, rcT.top, cx, rcT.bottom - rcT.top, PATCOPY);

   rcT.bottom -= cy;
   PatBlt(hdc, rcT.left, rcT.bottom, rcT.right - rcT.left, cy, PATCOPY);

   hbr = (HBRUSH)SelectObject(hdc, hbr);

   *prc = rcT;
}

/*
** draw a cyBorder band of 3DFACE at the bottom of the given rectangle.
** also, adjust the rectangle accordingly.
*/
void MyDrawBorderBelow(HDC hdc, LPRECT prc)
{
   int i;

   i = prc->top;
   prc->top = prc->bottom - cyBorder;
   FillRect(hdc, prc, g_brushes[COLOR_3DFACE]);
   prc->top = i;
   prc->bottom -= cyBorder;
}

/*-------------------------------------------------------------------
** draw a full window caption with system menu, minimize button,
** maximize button, and text.
**-------------------------------------------------------------------*/
void DrawFullCaption(HDC hdc, LPRECT prc, LPTSTR lpszTitle, UINT flags)
{
   int iRight;
   int iFont;

   SaveDC(hdc);

   // special case gross for small caption that already drew on bottom
   if (!(flags & DC_SMALLCAP))
      MyDrawBorderBelow(hdc, prc);

   iRight = prc->right;
   prc->right = prc->left + cxSize;
   DrawFrameControl(hdc, prc, DFC_CAPTION, DFCS_CAPTIONCLOSE);

   prc->left = prc->right;
   prc->right = iRight - 2*cxSize;
   iFont = flags & DC_SMALLCAP ? FONT_SMCAPTION : FONT_CAPTION;
   DrawCaptionTemp(NULL, hdc, prc, g_fonts[iFont].hfont, NULL, lpszTitle, flags | DC_ICON | DC_TEXT);

   prc->left = prc->right;
   prc->right = prc->left + cxSize;
   DrawFrameControl(hdc, prc, DFC_CAPTION, DFCS_CAPTIONMIN);
   prc->left = prc->right;
   prc->right = prc->left + cxSize;
   DrawFrameControl(hdc, prc, DFC_CAPTION, DFCS_CAPTIONMAX);

   RestoreDC(hdc, -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgbase.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef __WIZARD_PAGE_BASECLASS_H
#define __WIZARD_PAGE_BASECLASS_H

//
// Special "Wizard Page Messages"
//

#include "AccWiz.h" // JMC: TODO: Maybe move this somewhere else

class CWizardPageOrder
{
public:
	CWizardPageOrder()
	{
		m_nCount = 0;
		for(int i=0;i<ARRAYSIZE(m_rgdwPageIds);i++)
			m_rgdwPageIds[i] = 0;
	}


	BOOL AddPages(DWORD nInsertAfter, DWORD *rgdwIds, int nCount)
	{
		// First remove the pages if they are already there
		RemovePages(rgdwIds, nCount);

		int nStart = m_nCount - 1; // This will add to the end of the array
		if(0xFFFFFFFF != nInsertAfter)
		{
			for(nStart = 0;nStart < m_nCount;nStart++)
				if(m_rgdwPageIds[nStart] == nInsertAfter) break;
			if(nStart >= m_nCount)
			{
				_ASSERTE(FALSE); // The specified insert after was not in the array
				return FALSE;
			}
		}
		
		// Check to see if we have enough space.
		if(nCount + m_nCount > ARRAYSIZE(m_rgdwPageIds))
		{
			_ASSERTE(FALSE); // We don't have space
			return FALSE;
		}

		// Move current allocation upwards
		for(int i=m_nCount-1;i>nStart;i--)
			m_rgdwPageIds[i + nCount] = m_rgdwPageIds[i];

		// Insert new values
		for(i = 0;i<nCount;i++)
			m_rgdwPageIds[nStart + i + 1] = rgdwIds[i];

		// Set new value for m_nCount
		m_nCount += nCount;

		return TRUE;
	}

	BOOL RemovePages(DWORD *rgdwIds, int nCount)
	{
		// NOTE: This will scan the array and find the max and min locations
		// of all the elements in rgdwIds.  It then removes everything from min to max.
		// This is needed in case a sub page added more sub pages.
		int nMin = m_nCount + 1;
		int nMax = 0;
		for(int i=0;i<m_nCount;i++)
		{
			for(int j=0;j<nCount;j++)
			{
				if(m_rgdwPageIds[i] == rgdwIds[j])
				{
					nMin = min(i, nMin);
					nMax = max(i, nMax);
				}
			}
		}
		if(nMax < nMin)
		{
//			_ASSERTE(FALSE); // we could not find the range
			return FALSE;
		}

		// Move elements down
		int nCountElementsToRemove = nMax - nMin + 1;
		for(i=0;i<m_nCount - (nMax + 1);i++)
			m_rgdwPageIds[nMin + i] = m_rgdwPageIds[nMin + i + nCountElementsToRemove];

		// Figure out new m_nCount;
		m_nCount -= nCountElementsToRemove;
		return TRUE;
	}

	DWORD GetNextPage(DWORD dwPageId)
	{
		DWORD dwNextPage = 0;
		// Find the specified page
		for(int i=0;i<m_nCount;i++)
			if(m_rgdwPageIds[i] == dwPageId) break;

		if(i>=m_nCount)
		{
			_ASSERTE(FALSE); // We could not find the current page
			return 0;
		}

		// If we are not on the last page, return the 'next' page
		if(i < (m_nCount-1))
			dwNextPage = m_rgdwPageIds[i+1];

		return dwNextPage;
	}
	DWORD GetPrevPage(DWORD dwPageId)
	{
		DWORD dwPrevPage = 0;
		// Find the specified page
		for(int i=0;i<m_nCount;i++)
			if(m_rgdwPageIds[i] == dwPageId) break;

		if(i>=m_nCount)
		{
			_ASSERTE(FALSE); // We could not find the current page
			return 0;
		}

		// If we are not on the first page, return the 'prev' page
		if(i > 0)
			dwPrevPage = m_rgdwPageIds[i - 1];

		return dwPrevPage;
	}

	DWORD GetFirstPage()
	{
		_ASSERTE(m_nCount); // only call if we have values in the class
		return m_rgdwPageIds[0];
	}

	BOOL GrowArray(int nNewMax)
	{
		_ASSERTE(FALSE); // Not yet implemented
		return FALSE;
	}


protected:
	int m_nCount;
	DWORD m_rgdwPageIds[100]; // JMC: NOTE: We hard code a max of 100 pages that this
							// object can support.  100 is reasonable, since wizards
							// cannot currently support more than 100 pages.
};

class WizardPage
{
public:
	WizardPage(LPPROPSHEETPAGE ppsp, int nIdTitle, int nIdSubTitle);
	virtual ~WizardPage(VOID);
	
	//
	// Object is to apply settings to the system so that they take effect.
	//
	virtual LRESULT ApplySettings(VOID)
	{ return 0; }
	//
	// Object reports if user has changed something in the wizard page.
	//
	virtual BOOL Changed(VOID)
	{ return FALSE; }
	//
	// Object is to restore the original settings in effect when the page
	// was first opened.
	// Don't appy these to the system.	Object will receive an
	// ApplySettings notification when this is required.
	//
	virtual VOID RestoreOriginalSettings(VOID)
	{ /* By default, nothing happens */ }
	//
	// Object is to restore the settings most previously applied.
	// Don't appy these to the system.	Object will receive an
	// ApplySettings notification when this is required.
	//
	virtual VOID RestorePreviousSettings(VOID)
	{ /* By default, nothing happens */ }
	
	// This static member contains the order for all wizard pages in the app
	static CWizardPageOrder sm_WizPageOrder;
	
protected:
	HWND m_hwnd;  // Dialog's hwnd.
	DWORD m_dwPageId;
	
	virtual BOOL AdjustWizPageOrder()
	{
		// Default does nothing
		return TRUE;
	}
	
	//
	// Derived classes override these to respond to page create/release
	// notifications.
	//
	virtual UINT OnPropSheetPageCreate(HWND hwnd, LPPROPSHEETPAGE ppsp)
	{ return 1; }
	virtual UINT OnPropSheetPageRelease(HWND hwnd, LPPROPSHEETPAGE ppsp)
	{ return 1; }
	
	//
	// Method for performing operations common to all wizard pages in response
	// to given messages.  This is the function given to the PROPSHEETPAGE struct.
	//
	static INT_PTR DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	
protected:
	//
	// Prevent copying.
	//
	WizardPage(const WizardPage& rhs);
	WizardPage& operator = (const WizardPage& rhs);
	
	static UINT PropSheetPageCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
	
	virtual LRESULT HandleMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{ return 0; }
	virtual LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{ return 1; }
	//
	// Property sheet notifications.
	//
	virtual LRESULT OnPSN_Apply(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
	{ return 0; }
	virtual LRESULT OnPSN_Help(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
	{ return 0; }
	virtual LRESULT OnPSN_KillActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
	{ return 0; }
	virtual LRESULT OnPSN_QueryCancel(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
	virtual LRESULT OnPSN_Reset(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
	{ return 0; }
	virtual LRESULT OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
	virtual LRESULT OnPSN_WizBack(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
	{
		AdjustWizPageOrder();
		SetWindowLongPtr(hwnd, DWLP_MSGRESULT,
                         sm_WizPageOrder.GetPrevPage(m_dwPageId));
		return TRUE;
	}
	virtual LRESULT OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
	{
		AdjustWizPageOrder();
		SetWindowLongPtr(hwnd, DWLP_MSGRESULT,
                         sm_WizPageOrder.GetNextPage(m_dwPageId));
		return TRUE;
	}
	virtual LRESULT OnPSN_WizFinish(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
	{ return 0; }
	
	
	virtual LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{ return 0; }
	
	virtual LRESULT OnDrawItem(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{ return 0; }
	
	virtual LRESULT OnTimer(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{ return 0; }

	virtual BOOL OnMsgNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
	{ return 0; }

	LRESULT OnPSM_QuerySiblings(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnNotify(HWND hwnd, WPARAM wParam, LPARAM lParam);
	
};



#endif // __WIZARD_PAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgfinish.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef __FINISH_WIZARD_PAGE_H
#define __FINISH_WIZARD_PAGE_H

#include "pgbase.h"

class FinishWizPg : public WizardPage
{
public:
	FinishWizPg(LPPROPSHEETPAGE ppsp);
	~FinishWizPg(VOID);
	
private:
	
	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
	BOOL OnMsgNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
	
};

#endif // __FINISH_WIZARD_PAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pggenric.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGGENRIC_H
#define _INC_PGGENRIC_H

#include "pgbase.h"

class CGenericWizPg : public WizardPage
{
    public:
        CGenericWizPg(LPPROPSHEETPAGE ppsp, DWORD dwPageId, int nIdTitle = IDS_GENERICPAGETITLE, int nIdSubTitle = IDS_GENERICPAGESUBTITLE);
        ~CGenericWizPg(VOID);

    private:
	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);

};

#endif // _INC_PGGENRIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgextras.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGEXTRAS_H
#define _INC_PGEXTRAS_H

#include "pgbase.h"
#include "Select.h"

class CYesNoPg : public WizardPage
{
public:
	CYesNoPg(LPPROPSHEETPAGE ppsp, int nIdTitle, int nIdSubTitle, int nPageId)
		: WizardPage(ppsp, nIdTitle, nIdSubTitle)
	{
		m_dwPageId = nPageId;
		ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
	}
protected:
	virtual BOOL IsOptionSet() = 0;
	virtual void SetOptions(BOOL bOn) = 0;
	virtual int GetSettingsPage() {return 0;} // Default is no next page

	
	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{
		// Make sure the controls exist
		_ASSERTE(GetDlgItem(m_hwnd, IDC_RADIOYES));
		_ASSERTE(GetDlgItem(m_hwnd, IDC_RADIONO));

		// Set Yes/No buttons
		Button_SetCheck(GetDlgItem(m_hwnd, IDC_RADIOYES), IsOptionSet());
		Button_SetCheck(GetDlgItem(m_hwnd, IDC_RADIONO), !IsOptionSet());
		return 1;
	}
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{
		LRESULT lResult = 1;
		SetOptions(Button_GetCheck(GetDlgItem(m_hwnd, IDC_RADIOYES)));
		g_Options.ApplyPreview();
		return lResult;
	}
	LRESULT OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
	{
	 	DWORD dwTemp = GetSettingsPage();
		if(dwTemp)
		{
			if(Button_GetCheck(GetDlgItem(m_hwnd, IDC_RADIOYES)))
				sm_WizPageOrder.AddPages(m_dwPageId, &dwTemp, 1);
			else
				sm_WizPageOrder.RemovePages(&dwTemp, 1);
		}
		return WizardPage::OnPSN_WizNext(hwnd, idCtl, pnmh);
	}


};

class CSoundSentryPg : public CYesNoPg
{
public:
    CSoundSentryPg(LPPROPSHEETPAGE ppsp)
		: CYesNoPg(ppsp, IDS_SNDWIZSENTRYTITLE, IDS_SNDWIZSENTRYSUBTITLE, IDD_SNDWIZSENTRYSHOWSOUNDS) {}
protected:
	BOOL IsOptionSet()
	{
		return (g_Options.m_schemePreview.m_SOUNDSENTRY.dwFlags & SSF_SOUNDSENTRYON);
	}
	void SetOptions(BOOL bOn)
	{
		if(bOn)
		{
			g_Options.m_schemePreview.m_SOUNDSENTRY.dwFlags |= SSF_SOUNDSENTRYON;
            g_Options.m_schemePreview.m_SOUNDSENTRY.dwFlags &= SSF_VALID;

			// Hard code to flash 'Window' if we are setting this option
			g_Options.m_schemePreview.m_SOUNDSENTRY.iWindowsEffect = SSWF_WINDOW;

            // For NT: The other options are not supported. a-anilk
			g_Options.m_schemePreview.m_SOUNDSENTRY.iFSTextEffect = 0;
			g_Options.m_schemePreview.m_SOUNDSENTRY.iFSGrafEffect = 0;
		}
		else
			g_Options.m_schemePreview.m_SOUNDSENTRY.dwFlags &= ~SSF_SOUNDSENTRYON;
	}
};

class CShowSoundsPg : public CYesNoPg
{
public:
    CShowSoundsPg(LPPROPSHEETPAGE ppsp)
		: CYesNoPg(ppsp, IDS_SNDWIZSHOWSOUNDSTITLE, IDS_SNDWIZSHOWSOUNDSSUBTITLE, IDD_SNDWIZSENTRYSHOWSOUNDS2) {}
protected:
	BOOL IsOptionSet()
	{
		return (g_Options.m_schemePreview.m_bShowSounds);
	}
	void SetOptions(BOOL bOn)
	{
		g_Options.m_schemePreview.m_bShowSounds = bOn;
	}
};

class CFilterKeysPg : public CYesNoPg
{
public:
    CFilterKeysPg(LPPROPSHEETPAGE ppsp)
		: CYesNoPg(ppsp, IDS_WIZFILTERKEYSTITLE, IDS_WIZFILTERKEYSSUBTITLE, IDD_KBDWIZFILTERKEYS1) {}
protected:
	BOOL IsOptionSet()
	{
		// Return TRUE if filterkeys is ON
		return (g_Options.m_schemePreview.m_FILTERKEYS.dwFlags & FKF_FILTERKEYSON);
	}
	void SetOptions(BOOL bOn)
	{
		if(bOn)
		{
			g_Options.m_schemePreview.m_FILTERKEYS.dwFlags |= FKF_FILTERKEYSON;

            // this code only sets iBounceMSec and doesn't let users set the
            // other filter key options so init the other values to zero
			g_Options.m_schemePreview.m_FILTERKEYS.iWaitMSec = 0;
			g_Options.m_schemePreview.m_FILTERKEYS.iDelayMSec = 0;
			g_Options.m_schemePreview.m_FILTERKEYS.iRepeatMSec = 0;
		}
		else
        {
			g_Options.m_schemePreview.m_FILTERKEYS.dwFlags &= ~FKF_FILTERKEYSON;
        }
	}
	int GetSettingsPage() {return IDD_KBDWIZFILTERKEYS2;}

};


/***************************************/

//
// Times are in milliseconds
//
#define BOUNCESIZE 5
UINT BounceTable[BOUNCESIZE] = {
    {  500 },
    {  700 },
    { 1000 },
    { 1500 },
    { 2000 }
};

class CFilterKeysSettingsPg : public WizardPage
{
public:
    CFilterKeysSettingsPg(LPPROPSHEETPAGE ppsp)
		: WizardPage(ppsp, IDS_WIZFILTERKEYSETTING, IDS_WIZFILTERKEYSSUBTITLE)
	{
		m_dwPageId = IDD_KBDWIZFILTERKEYS2;
		ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
	}

protected:
	void UpdateTime()
	{
		INT_PTR nBounceRate = SendDlgItemMessage(m_hwnd,IDC_BK_BOUNCERATE, TBM_GETPOS, 0,0);
		if(nBounceRate < 1 || nBounceRate > BOUNCESIZE)
			nBounceRate = 1;

		// Look up in table
		nBounceRate = BounceTable[nBounceRate - 1];

		TCHAR buf[10], buf2[20];
		wsprintf(buf,__TEXT("%d.%d"),nBounceRate/1000,	(nBounceRate%1000)/100);
		GetNumberFormat(LOCALE_USER_DEFAULT, 0, buf, NULL, buf2, 20);
		SetDlgItemText(m_hwnd, IDC_BK_TIME, buf2);
	}
	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{
		_ASSERTE(g_Options.m_schemePreview.m_FILTERKEYS.iBounceMSec);
		_ASSERTE(GetDlgItem(m_hwnd, IDC_RADIOBEEPYES));
		_ASSERTE(GetDlgItem(m_hwnd, IDC_RADIOBEEPNO));

		Button_SetCheck(GetDlgItem(m_hwnd, IDC_RADIOBEEPYES), (g_Options.m_schemePreview.m_FILTERKEYS.dwFlags & FKF_CLICKON));
		Button_SetCheck(GetDlgItem(m_hwnd, IDC_RADIOBEEPNO), !(g_Options.m_schemePreview.m_FILTERKEYS.dwFlags & FKF_CLICKON));

		// Set slider for bounce rate
		SendDlgItemMessage(m_hwnd,IDC_BK_BOUNCERATE, TBM_SETRANGE,
							 TRUE,MAKELONG(1,BOUNCESIZE));

		// Figure out initial settings
		// Make sure initial slider settings is not SMALLER than current setting
		int nIndex = 0;
		for(int i=BOUNCESIZE - 1;i>=0;i--)
		{
			if(BounceTable[i] >= g_Options.m_schemePreview.m_FILTERKEYS.iBounceMSec)
				nIndex = i;
			else
				break;
		}
		SendDlgItemMessage(m_hwnd,IDC_BK_BOUNCERATE, TBM_SETPOS, TRUE, nIndex+1);
		UpdateTime();

		return 1;
	}
	LRESULT HandleMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		switch(uMsg)
		{
		case WM_HSCROLL:
			{
				UpdateTime();

				if(Button_GetCheck(GetDlgItem(m_hwnd, IDC_RADIOBEEPYES)))
					g_Options.m_schemePreview.m_FILTERKEYS.dwFlags |= FKF_CLICKON;
				else
					g_Options.m_schemePreview.m_FILTERKEYS.dwFlags &= ~FKF_CLICKON;

				// Bounce Keys
				INT_PTR nIndex = SendDlgItemMessage(m_hwnd, IDC_BK_BOUNCERATE, TBM_GETPOS, 0, 0);
                // this code only sets iBounceMSec and doesn't let users set the
                // other filter key options so init the other values to zero
				g_Options.m_schemePreview.m_FILTERKEYS.iWaitMSec = 0;
				g_Options.m_schemePreview.m_FILTERKEYS.iDelayMSec = 0;
				g_Options.m_schemePreview.m_FILTERKEYS.iRepeatMSec = 0;
				g_Options.m_schemePreview.m_FILTERKEYS.iBounceMSec = BounceTable[nIndex - 1];

				g_Options.ApplyPreview();
			}
			break;
		default:
			break;
		}
		return 0;
	}

    // Handle Next> and make sure you transfer all settings as the user may not 
    // always change bounce repeat rate : a-anilk
    LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{
		LRESULT lResult = 1;

		WORD wNotifyCode = HIWORD(wParam);
		WORD wCtlID      = LOWORD(wParam);
		HWND hwndCtl     = (HWND)lParam;

		switch(wCtlID)
		{
		case IDC_RADIOBEEPYES:
		case IDC_RADIOBEEPNO:
			if(Button_GetCheck(GetDlgItem(m_hwnd, IDC_RADIOBEEPYES)))
				g_Options.m_schemePreview.m_FILTERKEYS.dwFlags |= FKF_CLICKON;
			else
				g_Options.m_schemePreview.m_FILTERKEYS.dwFlags &= ~FKF_CLICKON;

            g_Options.ApplyPreview();

			lResult = 0;
			break;

		default:
			break;
		}
		return lResult;
	}

};

////////////////////////////////////////////////////////////////////
// Mouse Keys
class CMouseKeysPg : public CYesNoPg
{
public:
    CMouseKeysPg(LPPROPSHEETPAGE ppsp)
		: CYesNoPg(ppsp, IDS_MSEWIZMOUSEKEYSTITLE, IDS_MSEWIZMOUSEKEYSSUBTITLE, IDD_MSEWIZMOUSEKEYS) {}
protected:
	BOOL IsOptionSet()
	{
		return (g_Options.m_schemePreview.m_MOUSEKEYS.dwFlags & MKF_MOUSEKEYSON);
	}
	void SetOptions(BOOL bOn)
	{
		if(bOn)
			g_Options.m_schemePreview.m_MOUSEKEYS.dwFlags |= MKF_MOUSEKEYSON;
		else
			g_Options.m_schemePreview.m_MOUSEKEYS.dwFlags &= ~MKF_MOUSEKEYSON;
	}
	int GetSettingsPage() {return IDD_MSEWIZMOUSEKEYS1;}

};

static UINT g_nSpeedTable[] = { 10, 20, 30, 40, 60, 80, 120, 180, 360 };
static UINT g_nAccelTable[] = { 5000, 4500, 4000, 3500, 3000, 2500, 2000, 1500, 1000 };

class CMouseKeysSettingsPg : public WizardPage
{
public:
    CMouseKeysSettingsPg(LPPROPSHEETPAGE ppsp)
		: WizardPage(ppsp, IDS_MSEWIZMOUSEKEYSETTING, IDS_MSEWIZMOUSEKEYSSUBTITLE)
	{
		m_dwPageId = IDD_MSEWIZMOUSEKEYS1;
		ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
	}

protected:
	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{
		// ALWAYS use modifiers
//		Button_SetCheck(GetDlgItem(m_hwnd, IDC_MK_USEMODKEYS), g_Options.m_schemePreview.m_MOUSEKEYS.dwFlags & MKF_MODIFIERS);

		if(g_Options.m_schemePreview.m_MOUSEKEYS.dwFlags & MKF_REPLACENUMBERS)
			Button_SetCheck(GetDlgItem(m_hwnd, IDC_MK_NLON), TRUE);
		else
			Button_SetCheck(GetDlgItem(m_hwnd, IDC_MK_NLOFF), TRUE);

		SendDlgItemMessage(m_hwnd,IDC_MK_TOPSPEED, TBM_SETRANGE, TRUE,MAKELONG(0,8));
		SendDlgItemMessage(m_hwnd,IDC_MK_ACCEL, TBM_SETRANGE, TRUE,MAKELONG(0,8));

		int nIndex = 0;
		for(int i=8;i>=0;i--)
		{
			if(g_nSpeedTable[i] >= g_Options.m_schemePreview.m_MOUSEKEYS.iMaxSpeed)
				nIndex = i;
			else
				break;
		}
		SendDlgItemMessage(m_hwnd,IDC_MK_TOPSPEED, TBM_SETPOS, TRUE, nIndex);

		for(i=8;i>=0;i--)
		{
			if(g_nAccelTable[i] <= g_Options.m_schemePreview.m_MOUSEKEYS.iTimeToMaxSpeed)
				nIndex = i;
			else
				break;
		}
		SendDlgItemMessage(m_hwnd,IDC_MK_ACCEL, TBM_SETPOS, TRUE, nIndex);
		return 1;
	}

	void GetSettingsFromControls()
	{
		INT_PTR nIndex;

		g_Options.m_schemePreview.m_MOUSEKEYS.dwFlags |= MKF_MOUSEKEYSON;
		if(TRUE/*Button_GetCheck(GetDlgItem(m_hwnd, IDC_MK_USEMODKEYS))*/) // NOTE: ALWAYS use modifiers
			g_Options.m_schemePreview.m_MOUSEKEYS.dwFlags |= MKF_MODIFIERS;
		else
			g_Options.m_schemePreview.m_MOUSEKEYS.dwFlags &= ~MKF_MODIFIERS;

		if(Button_GetCheck(GetDlgItem(m_hwnd, IDC_MK_NLON)))
			g_Options.m_schemePreview.m_MOUSEKEYS.dwFlags |= MKF_REPLACENUMBERS;
		else
			g_Options.m_schemePreview.m_MOUSEKEYS.dwFlags &= ~MKF_REPLACENUMBERS;

		nIndex = SendDlgItemMessage(m_hwnd, IDC_MK_TOPSPEED, TBM_GETPOS, 0, 0);
		g_Options.m_schemePreview.m_MOUSEKEYS.iMaxSpeed = g_nSpeedTable[nIndex];
		nIndex = SendDlgItemMessage(m_hwnd, IDC_MK_ACCEL, TBM_GETPOS, 0, 0);
		g_Options.m_schemePreview.m_MOUSEKEYS.iTimeToMaxSpeed = g_nAccelTable[nIndex];

 #pragma message("Handle THis!")
		// 3/15/95 -
		// Always init the control speed to 1/8 of the screen width/
//		g_mk.iCtrlSpeed = GetSystemMetrics(SM_CXSCREEN) / 16;

		g_Options.ApplyPreview();
	}

	LRESULT HandleMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		switch(uMsg)
		{
		case WM_HSCROLL:
			GetSettingsFromControls();
			break;
		default:
			break;
		}
		return 0;
	}

	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{
		LRESULT lResult = 1;

		WORD wNotifyCode = HIWORD(wParam);
		WORD wCtlID      = LOWORD(wParam);
		HWND hwndCtl     = (HWND)lParam;

		switch(wCtlID)
		{
		case IDC_MK_NLON:
		case IDC_MK_NLOFF:
			GetSettingsFromControls();
			lResult = 0;
			break;

		default:
			break;
		}
		return lResult;
	}
};

//
////////////////////////////////////////////////////////////////////


class CStickyKeysPg : public CYesNoPg
{
public:
    CStickyKeysPg(LPPROPSHEETPAGE ppsp)
		: CYesNoPg(ppsp, IDS_WIZSTICKYKEYSTITLE, IDS_WIZSTICKYKEYSSUBTITLE, IDD_KBDWIZSTICKYKEYS) {}
protected:
	BOOL IsOptionSet()
	{
		return g_Options.m_schemePreview.m_STICKYKEYS.dwFlags & SKF_STICKYKEYSON;
	}
	void SetOptions(BOOL bOn)
	{
		if(bOn)
		{
			g_Options.m_schemePreview.m_STICKYKEYS.dwFlags |= SKF_STICKYKEYSON;

			// Turn selected flags on
			g_Options.m_schemePreview.m_STICKYKEYS.dwFlags |= SKF_TRISTATE;
			g_Options.m_schemePreview.m_STICKYKEYS.dwFlags |= SKF_TWOKEYSOFF;
			g_Options.m_schemePreview.m_STICKYKEYS.dwFlags |= SKF_AUDIBLEFEEDBACK;
		}
		else
			g_Options.m_schemePreview.m_STICKYKEYS.dwFlags &= ~SKF_STICKYKEYSON;
	}
};

class CToggleKeysPg : public CYesNoPg
{
public:
    CToggleKeysPg(LPPROPSHEETPAGE ppsp)
		: CYesNoPg(ppsp, IDS_WIZTOGGLEKEYSTITLE, IDS_WIZTOGGLEKEYSSUBTITLE, IDD_KBDWIZTOGGLEKEYS) {}
protected:
	BOOL IsOptionSet()
	{
		return g_Options.m_schemePreview.m_TOGGLEKEYS.dwFlags & TKF_TOGGLEKEYSON;
	}
	void SetOptions(BOOL bOn)
	{
		if(bOn)
			g_Options.m_schemePreview.m_TOGGLEKEYS.dwFlags |= TKF_TOGGLEKEYSON;
		else
			g_Options.m_schemePreview.m_TOGGLEKEYS.dwFlags &= ~TKF_TOGGLEKEYSON;
	}
};

class CShowKeyboardHelpPg : public CYesNoPg
{
public:
    CShowKeyboardHelpPg(LPPROPSHEETPAGE ppsp)
		: CYesNoPg(ppsp, IDS_WIZSHOWEXTRAKEYBOARDHELPTITLE, IDS_WIZSHOWEXTRAKEYBOARDHELPSUBTITLE, IDD_KBDWIZSHOWEXTRAKEYBOARDHELP) {}
protected:
	BOOL IsOptionSet()
	{
		return g_Options.m_schemePreview.m_bShowExtraKeyboardHelp;
	}
	void SetOptions(BOOL bOn)
	{
		g_Options.m_schemePreview.m_bShowExtraKeyboardHelp = bOn;
	}
};


class CMouseSpeedPg : public WizardPage
{
public:
    CMouseSpeedPg(LPPROPSHEETPAGE ppsp)
		: WizardPage(ppsp, IDS_MSEWIZMOUSESPEEDTITLE, IDS_MSEWIZMOUSESPEEDSUBTITLE)
	{
		m_dwPageId = IDD_MSEWIZMOUSESPEED;
		ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
	}

protected:
	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
	{
		// Set slider for mouse speed, (limit 1 to 20), and set its initial value
		SendDlgItemMessage(m_hwnd,IDC_SLIDER1, TBM_SETRANGE, TRUE,MAKELONG(1,20));
		SendDlgItemMessage(m_hwnd,IDC_SLIDER1, TBM_SETPOS, TRUE, min(20, max(1, g_Options.m_schemePreview.m_nMouseSpeed)));
		return 1;
	}
	LRESULT HandleMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		switch(uMsg)
		{
		case WM_HSCROLL:
			g_Options.m_schemePreview.m_nMouseSpeed = (UINT)SendDlgItemMessage(m_hwnd, IDC_SLIDER1, TBM_GETPOS, 0, 0);
			g_Options.ApplyPreview();
			break;
		default:
			break;
		}
		return 0;
	}
};


class CMouseTrailsPg : public CYesNoPg
{
public:
    CMouseTrailsPg(LPPROPSHEETPAGE ppsp)
		: CYesNoPg(ppsp, IDS_MSEWIZMOUSETRAILSTITLE, IDS_MSEWIZMOUSETRAILSSUBTITLE, IDD_MSEWIZMOUSETRAILS) {}
protected:
	BOOL IsOptionSet()
	{
		return (g_Options.m_schemePreview.m_nMouseTrails > 1);
	}
	void SetOptions(BOOL bOn)
	{
		g_Options.m_schemePreview.m_nMouseTrails = bOn?7:0;
	}
};




#endif // _INC_PGEXTRAS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgfinish.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "shlobj.h"
#include "pgfinish.h"

#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"


FinishWizPg::FinishWizPg( 
						 LPPROPSHEETPAGE ppsp
						 ) : WizardPage(ppsp, 0, 0)
{
	m_dwPageId = IDD_WIZFINISH;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
}


FinishWizPg::~FinishWizPg(
						  VOID
						  )
{
}


LRESULT
FinishWizPg::OnInitDialog(
						  HWND hwnd,
						  WPARAM wParam,
						  LPARAM lParam
						  )
{
	g_Options.ReportChanges(GetDlgItem(hwnd, IDC_SZCHANGES));
	
	return 1;
}

LRESULT
FinishWizPg::OnPSN_SetActive(
							 HWND hwnd, 
							 INT idCtl, 
							 LPPSHNOTIFY pnmh
							 )
{
	// Call the base class
	WizardPage::OnPSN_SetActive(hwnd, idCtl, pnmh);
	
	g_Options.ReportChanges(GetDlgItem(hwnd, IDC_SZCHANGES));
	
	return TRUE;
}


BOOL FinishWizPg::OnMsgNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    // Hope the site addr is not more than 256 characters
    TCHAR webAddr[256];
    
    LoadString(g_hInstDll, IDS_ENABLEWEB, webAddr, 256);
    ShellExecute(hwnd, NULL, webAddr, NULL, NULL, SW_SHOW); 
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pggenric.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgGenric.h"


CGenericWizPg::CGenericWizPg( 
    LPPROPSHEETPAGE ppsp,
	DWORD dwPageId,
	int nIdTitle /* = IDS_GENERICPAGETITLE */,
	int nIdSubTitle /* = IDS_GENERICPAGESUBTITLE */
    ) : WizardPage(ppsp, nIdTitle, nIdSubTitle)
{
	m_dwPageId = dwPageId;
    ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
}


CGenericWizPg::~CGenericWizPg(
    VOID
    )
{
}



LRESULT
CGenericWizPg::OnInitDialog(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	Button_SetCheck(GetDlgItem(m_hwnd, IDC_RADIO2), TRUE);
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pglokprv.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgLokPrv.h"

CLookPreviewPg::CLookPreviewPg(
							   LPPROPSHEETPAGE ppsp,
							   int dwPageId,
							   int nIdTitle,
							   int nIdSubTitle,
							   int nIdValueString
							   ) : WizardPage(ppsp, nIdTitle, nIdSubTitle)
{
	m_dwPageId = dwPageId;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);

	m_nIdValueString = nIdValueString;

	m_nCountValues = 0;
	m_nCurValueIndex = 0;
    m_nOrigValueIndex = 0;

	m_hwndSlider = 0;
	m_hwndListBox = 0;
}



CLookPreviewPg::~CLookPreviewPg(
	VOID
	)
{
}

#include "LookPrev.h"

void PASCAL Look_RebuildSysStuff(BOOL fInit);
void SetMyNonClientMetrics(LPNONCLIENTMETRICS lpncm);

LRESULT
CLookPreviewPg::OnInitDialog(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	SendMessage(GetDlgItem(m_hwnd, IDC_LOOKPREV), LPM_RECALC, 0, 0);
	SendMessage(GetDlgItem(m_hwnd, IDC_LOOKPREV), LPM_REPAINT, 0, 0);

	LoadValueArray();

	m_hwndListBox = GetDlgItem(m_hwnd, IDC_PREVLIST);

	// Get the initial value for the type of preview we are doing
	int nCurrentSize = GetCurrentValue(NULL/*&g_Options.m_schemePreview.m_ncm*/);

	// Find next larger
	for(int i=m_nCountValues - 1;i>=0;i--)
	{
		if(m_rgnValues[i] >= nCurrentSize)
			m_nCurValueIndex = i;
		else break;
	}
    m_nOrigValueIndex = m_nCurValueIndex;

	// Initialize the high contrast colors listbox

	for(i=0;i<m_nCountValues;i++)
	{
		TCHAR sz[100];
		GetValueItemText(i, sz, ARRAYSIZE(sz));
		ListBox_AddString(m_hwndListBox, sz);
	}
	ListBox_SetCurSel(m_hwndListBox, m_nCurValueIndex);

	UpdateControls();
	return 1;
}


void CLookPreviewPg::LoadValueArray()
{
	LoadArrayFromStringTable(m_nIdValueString, m_rgnValues, &m_nCountValues);
}


void CLookPreviewPg::UpdateControls()
{
}

LRESULT
CLookPreviewPg::OnCommand(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	LRESULT lResult = 1;

	WORD wNotifyCode = HIWORD(wParam);
	WORD wCtlID      = LOWORD(wParam);
	HWND hwndCtl     = (HWND)lParam;

	switch(wCtlID)
	{
	    case IDC_PREVLIST:
		switch(wNotifyCode)
		{
		    case LBN_SELCHANGE:
			UpdatePreview(wCtlID);
			break;

		    default:
			break;
		}
        break;

        default:
		break;
	}

	return lResult;
}

void CLookPreviewPg::ResetColors()
{
	if(0 != m_nCurValueIndex)
	{
		int nCount = GetScheme(m_nCurValueIndex-1).nColorsUsed;
		for(int i=0;i<nCount;i++)
        {
			g_Options.m_schemePreview.m_rgb[i] = GetScheme(m_nCurValueIndex-1).rgb[i];
        }
	}
	else
	{
		// Use scheme that we came in here with
		g_Options.RestoreOriginalColorsToPreview();
	}

	Look_RebuildSysStuff(TRUE);
	SendMessage(GetDlgItem(m_hwnd, IDC_LOOKPREV), LPM_REPAINT, 0, 0);
}

LRESULT
CLookPreviewPg::HandleMsg(
	HWND hwnd,
	UINT uMsg,
	WPARAM wParam,
	LPARAM lParam
	)
{
	return 0;
}

void CLookPreviewPg::UpdatePreview(int nActionCtl)
{
	// Calculate new index based on the control that generated this event
	switch(nActionCtl)
	{
	    case IDC_PREVLIST:
		m_nCurValueIndex = ListBox_GetCurSel(m_hwndListBox);
		break;

	    default:
		break;
	}

	// Make sure we are withing range
	m_nCurValueIndex = max(m_nCurValueIndex, 0);
	m_nCurValueIndex = min(m_nCurValueIndex, m_nCountValues - 1);

	// Modify the ncm structure

	// JMC: The wizard currently does not muck with m_ncm any more - we only change the colors
	// Therefore, we can call ModifyMyNonClientMetrics() with a dummy variable
	NONCLIENTMETRICS ncmDummy;
	ModifyMyNonClientMetrics(ncmDummy/*g_Options.m_schemePreview.m_ncm*/);
    if (m_nCurValueIndex == 0)
    {
        // If we are here the user is going "back" and we revert to "Windows Classic" (Why?)
        LoadString(g_hInstDll, IDS_SCHEME_CURRENTCOLORSCHEME+100, g_Options.m_schemePreview.m_szSelectedStyle, MAX_NUM_SZ);
    }
    else
    {
        lstrcpy(g_Options.m_schemePreview.m_szSelectedStyle, GetScheme(m_nCurValueIndex-1).szNameIndexId);
    }

	Look_RebuildSysStuff(TRUE);
	SendMessage(GetDlgItem(m_hwnd, IDC_LOOKPREV), LPM_RECALC, 0, 0);
	SendMessage(GetDlgItem(m_hwnd, IDC_LOOKPREV), LPM_REPAINT, 0, 0);
}

LRESULT
CLookPreviewPg::OnPSN_WizNext(
						   HWND hwnd,
						   INT idCtl,
						   LPPSHNOTIFY pnmh
						   )
{
    if (m_nOrigValueIndex != m_nCurValueIndex)
    {
        // we are applying the preview; clear theme and wallpaper
        // so visual style gets turned off before we make the change.
        if (m_nCurValueIndex)
        {
		    g_Options.m_schemePreview.ClearTheme();
		    g_Options.m_schemePreview.ClearWallpaper();
        }
        else
        {
            memcpy(&g_Options.m_schemePreview, &g_Options.m_schemeOriginal, sizeof(WIZSCHEME));
        }
	    g_Options.ApplyPreview();
        m_nOrigValueIndex = m_nCurValueIndex;
    }

	return WizardPage::OnPSN_WizNext(hwnd, idCtl, pnmh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgmsebut.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGMSEBUT_H
#define _INC_PGMSEBUT_H

#include "pgbase.h"

class CMouseButtonPg : public WizardPage
{
public:
    CMouseButtonPg(LPPROPSHEETPAGE ppsp);
    ~CMouseButtonPg(VOID);

protected:
	POINT m_ptRight;
	POINT m_ptLeft;
	void UpdateControls();

	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
};

#endif // _INC_PGMSEBUT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgmsecur.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGMSECUR_H
#define _INC_PGMSECUR_H

#include "pgbase.h"

class CMouseCursorPg : public WizardPage
{
public:
    CMouseCursorPg(LPPROPSHEETPAGE ppsp);
    ~CMouseCursorPg(VOID);

protected:
	void UpdateControls();

	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);


private:

};

#endif // _INC_PGMSECUR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgmsecur.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgMseCur.h"


CMouseCursorPg::CMouseCursorPg(
	LPPROPSHEETPAGE ppsp
	) : WizardPage(ppsp, IDS_MSEWIZMOUSECURSORTITLE, IDS_MSEWIZMOUSECURSORSUBTITLE)
{
	m_dwPageId = IDD_MSEWIZMOUSECURSOR;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
}


CMouseCursorPg::~CMouseCursorPg(
	VOID
	)
{
}

LRESULT
CMouseCursorPg::OnInitDialog(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	HICON hIconSmallWhite = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_CURSOR_SMALL_WHITE));
	HICON hIconMediumWhite = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_CURSOR_MEDIUM_WHITE));
	HICON hIconLargeWhite = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_CURSOR_LARGE_WHITE));

	HICON hIconSmallBlack = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_CURSOR_SMALL_BLACK));
	HICON hIconMediumBlack = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_CURSOR_MEDIUM_BLACK));
	HICON hIconLargeBlack = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_CURSOR_LARGE_BLACK));

	HICON hIconSmallInverting = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_CURSOR_SMALL_INVERTING));
	HICON hIconMediumInverting = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_CURSOR_MEDIUM_INVERTING));
	HICON hIconLargeInverting = LoadIcon(g_hInstDll, MAKEINTRESOURCE(IDI_CURSOR_LARGE_INVERTING));

#pragma message ("Need to destroy bitmaps in OnDestroy")
	SendMessage(GetDlgItem(m_hwnd, IDC_RADIO2), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIconSmallWhite);
	SendMessage(GetDlgItem(m_hwnd, IDC_RADIO3), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIconMediumWhite);
	SendMessage(GetDlgItem(m_hwnd, IDC_RADIO4), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIconLargeWhite);

	SendMessage(GetDlgItem(m_hwnd, IDC_RADIO5), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIconSmallBlack);
	SendMessage(GetDlgItem(m_hwnd, IDC_RADIO6), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIconMediumBlack);
	SendMessage(GetDlgItem(m_hwnd, IDC_RADIO7), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIconLargeBlack);

	SendMessage(GetDlgItem(m_hwnd, IDC_RADIO8), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIconSmallInverting);
	SendMessage(GetDlgItem(m_hwnd, IDC_RADIO9), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIconMediumInverting);
	SendMessage(GetDlgItem(m_hwnd, IDC_RADIO10), BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIconLargeInverting);

	Button_SetCheck(GetDlgItem(m_hwnd, IDC_RADIO1), TRUE);

	UpdateControls();
	return 1;
}


void CMouseCursorPg::UpdateControls()
{
	// Nothing to do
}


LRESULT
CMouseCursorPg::OnCommand(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	LRESULT lResult = 1;

	WORD wNotifyCode = HIWORD(wParam);
	WORD wCtlID      = LOWORD(wParam);
	HWND hwndCtl     = (HWND)lParam;

	HCURSOR hCursor = NULL;
	switch(wCtlID)
	{
	case IDC_RADIO1:
		g_Options.m_schemePreview.m_nCursorScheme = 0;
		break;
	case IDC_RADIO2:
		g_Options.m_schemePreview.m_nCursorScheme = 1;
		break;
	case IDC_RADIO3:
		g_Options.m_schemePreview.m_nCursorScheme = 2;
		break;
	case IDC_RADIO4:
		g_Options.m_schemePreview.m_nCursorScheme = 3;
		break;
	case IDC_RADIO5:
		g_Options.m_schemePreview.m_nCursorScheme = 4;
		break;
	case IDC_RADIO6:
		g_Options.m_schemePreview.m_nCursorScheme = 5;
		break;
	case IDC_RADIO7:
		g_Options.m_schemePreview.m_nCursorScheme = 6;
		break;
	case IDC_RADIO8:
		g_Options.m_schemePreview.m_nCursorScheme = 7;
		break;
	case IDC_RADIO9:
		g_Options.m_schemePreview.m_nCursorScheme = 8;
		break;
	case IDC_RADIO10:
		g_Options.m_schemePreview.m_nCursorScheme = 9;
		break;
	default:
		break;
	}
	g_Options.ApplyPreview();

	return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgnwelcome.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgnWelcome.h"
#include "select.h"

CWizWelcomePg::CWizWelcomePg(
						   LPPROPSHEETPAGE ppsp
						   ) : WizardPage(ppsp, 0, 0)
{
	m_dwPageId = IDD_WIZNEWWELCOME;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
}


CWizWelcomePg::~CWizWelcomePg(
							VOID
							)
{
}


LRESULT
CWizWelcomePg::OnCommand(
						HWND hwnd,
						WPARAM wParam,
						LPARAM lParam
						)
{
	LRESULT lResult = 1;
	
	return lResult;
}





LRESULT
CWizWelcomePg::OnPSN_WizNext(
						   HWND hwnd,
						   INT idCtl,
						   LPPSHNOTIFY pnmh
						   )
{
	return WizardPage::OnPSN_WizNext(hwnd, idCtl, pnmh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pglokprv.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGLOKPRV_H
#define _INC_PGLOKPRV_H

#include "pgbase.h"

class CLookPreviewPg : public WizardPage
{
public:
    CLookPreviewPg(LPPROPSHEETPAGE ppsp, int dwPageId, int nIdTitle, int nIdSubTitle, int nIdValueString);
    ~CLookPreviewPg(VOID);


protected: // Virtual functions
	// Override this if the values are not stored in a string table
	virtual void LoadValueArray();

	// This must be overridden so that the dialog knows what item to select as the default
	virtual int GetCurrentValue(NONCLIENTMETRICS *pncm) = 0;

	// If the dialog is using a list box, the user MUST override this function
	virtual void GetValueItemText(int nIndex, LPTSTR lpszBuffer, int nLen) {_ASSERTE(FALSE);}

	// Must be overridden to set ncm to appropriate values based on Value array index
	virtual void ModifyMyNonClientMetrics(NONCLIENTMETRICS &ncm) = 0;

protected:
	void UpdatePreview(int nActionCtl);

	int m_nIdValueString;
	HWND m_hwndSlider;
	HWND m_hwndListBox;

	int m_nCountValues;
	int m_rgnValues[MAX_DISTINCT_VALUES];
	int m_nCurValueIndex;
	int m_nOrigValueIndex;

	void ResetColors();
	void UpdateControls();
	

	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT HandleMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	LRESULT OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);


private:

};



/////////////////////////////////////////////////////////////
// Color page

class CLookPreviewColorPg : public CLookPreviewPg
{
public:
	CLookPreviewColorPg(LPPROPSHEETPAGE ppsp)
		: CLookPreviewPg(	ppsp,
							IDD_PREV_COLOR,
							IDS_LKPREV_COLORTITLE,
							IDS_LKPREV_COLORSUBTITLE,
							0) {};

	virtual void LoadValueArray()
	{
		// For colors, we just use 0 to GetSchemeCount()
		m_nCountValues = GetSchemeCount() + 1;
		for(int i=0;i<m_nCountValues;i++)
			m_rgnValues[i] = i;
	}
	virtual int GetCurrentValue(NONCLIENTMETRICS *pncm) {return 0;}; // Always return value of 0
	virtual void GetValueItemText(int nIndex, LPTSTR lpszBuffer, int nLen)
	{
		_ASSERTE(nIndex < GetSchemeCount() + 1);
		if(0 == nIndex)
		{
			LoadString(g_hInstDll, IDS_SCHEME_CURRENTCOLORSCHEME, lpszBuffer, nLen);
		}
		else
			GetSchemeName(nIndex - 1, lpszBuffer, nLen);
	}
	virtual void ModifyMyNonClientMetrics(NONCLIENTMETRICS &ncm)
	{
		ResetColors();
	}

};


#endif // _INC_PGLOKPRV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgnwelcome.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _PGNWELCOME_H
#define _PGNWELCOME_H

#include "pgbase.h"
#include "Select.h"

class CWizWelcomePg : public WizardPage
{
public:
    CWizWelcomePg(LPPROPSHEETPAGE ppsp);
    ~CWizWelcomePg(VOID);

protected:
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
private:

};

#endif /*_PGNWELCOME_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgmsebut.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgMseBut.h"

CMouseButtonPg::CMouseButtonPg(
	LPPROPSHEETPAGE ppsp
	) : WizardPage(ppsp, IDS_MSEWIZBUTTONCONFIGTITLE, IDS_MSEWIZBUTTONCONFIGSUBTITLE)
{
	m_dwPageId = IDD_MSEWIZBUTTONCONFIG;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
}


CMouseButtonPg::~CMouseButtonPg(
	VOID
	)
{
}

LRESULT
CMouseButtonPg::OnInitDialog(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	if(g_Options.m_schemePreview.m_bSwapMouseButtons)
		Button_SetCheck(GetDlgItem(m_hwnd, MOUSE_LEFTHAND), TRUE);
	else
		Button_SetCheck(GetDlgItem(m_hwnd, MOUSE_RIGHTHAND), TRUE);

	RECT rc;
	GetWindowRect(GetDlgItem(m_hwnd, IDC_OBJECTMENU), &rc);
    MapWindowPoints(HWND_DESKTOP, m_hwnd, (LPPOINT)&rc, 2);
	m_ptRight.x = rc.left;
	m_ptRight.y = rc.top;
	GetWindowRect(GetDlgItem(m_hwnd, IDC_SELECTDRAG), &rc);
    MapWindowPoints(HWND_DESKTOP, m_hwnd, (LPPOINT)&rc, 2);
	m_ptLeft.x = rc.left;
	m_ptLeft.y = rc.top;


	UpdateControls();
	return 1;
}


void CMouseButtonPg::UpdateControls()
{
	if(Button_GetCheck(GetDlgItem(m_hwnd, MOUSE_RIGHTHAND)))
	{
		SetWindowPos(GetDlgItem(m_hwnd, IDC_OBJECTMENU), NULL, m_ptRight.x, m_ptRight.y, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
		SetWindowPos(GetDlgItem(m_hwnd, IDC_SELECTDRAG), NULL, m_ptLeft.x, m_ptLeft.y, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
		ShowWindow(GetDlgItem(m_hwnd, IDC_MOUSEPIC1), TRUE);
		ShowWindow(GetDlgItem(m_hwnd, IDC_MOUSEPIC2), FALSE);
	}
	else
	{
		SetWindowPos(GetDlgItem(m_hwnd, IDC_OBJECTMENU), NULL, m_ptLeft.x, m_ptLeft.y, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
		SetWindowPos(GetDlgItem(m_hwnd, IDC_SELECTDRAG), NULL, m_ptRight.x, m_ptRight.y, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
		ShowWindow(GetDlgItem(m_hwnd, IDC_MOUSEPIC1), FALSE);
		ShowWindow(GetDlgItem(m_hwnd, IDC_MOUSEPIC2), TRUE);
	}

}


LRESULT
CMouseButtonPg::OnCommand(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	LRESULT lResult = 1;

	WORD wNotifyCode = HIWORD(wParam);
	WORD wCtlID      = LOWORD(wParam);
	HWND hwndCtl     = (HWND)lParam;

	switch(wCtlID)
	{
	case MOUSE_LEFTHAND:
	case MOUSE_RIGHTHAND:
		UpdateControls();
		break;

	}
	g_Options.m_schemePreview.m_bSwapMouseButtons = Button_GetCheck(GetDlgItem(m_hwnd, MOUSE_LEFTHAND));
	g_Options.ApplyPreview();
	return lResult;
}

LRESULT
CMouseButtonPg::OnPSN_WizNext(
						   HWND hwnd,
						   INT idCtl,
						   LPPSHNOTIFY pnmh
						   )
{
	return WizardPage::OnPSN_WizNext(hwnd, idCtl, pnmh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgsvedef.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgSveDef.h"


// JMC: This is taken from access.cpl

/***********************************************************************/
// CopyKey( hKey, hKeyDst, name )
//     create the destination key
//     for each value
//         CopyValue
//     for each subkey
//         CopyKey

DWORD CopyKey( HKEY hkeySrc, HKEY hkeyDst, LPSTR szKey )
{
    HKEY hkeyOld = NULL, hkeyNew = NULL;
    char szValue[128];
    BYTE szData[128];
    char szBuffer[128];
    DWORD iStatus;
    UINT nValue, nKey;
    DWORD iValueLen, iDataLen;
	DWORD dwType;

    iStatus = RegOpenKeyExA( hkeySrc, szKey, 0, KEY_ENUMERATE_SUB_KEYS |
		KEY_SET_VALUE, &hkeyOld );
    if( iStatus != ERROR_SUCCESS)
        goto exit;

    iStatus = RegOpenKeyExA( hkeyDst, szKey, 0, KEY_ENUMERATE_SUB_KEYS, &hkeyNew );
    if( iStatus != ERROR_SUCCESS )
    {
        iStatus = RegCreateKeyExA( hkeyDst, szKey, 0, "", 0, KEY_SET_VALUE,
			NULL, &hkeyNew, NULL);
        if( iStatus != ERROR_SUCCESS )
        {
            goto exit;
        }
    }
    //*********** copy the values **************** //

    for( nValue = 0, iValueLen=sizeof szValue, iDataLen=sizeof szValue;
         ERROR_SUCCESS == (iStatus = RegEnumValueA(hkeyOld,
                                                  nValue,
                                                  szValue,
                                                  &iValueLen,
                                                  NULL, // reserved
                                                  &dwType, // don't need type
                                                  szData,
                                                  &iDataLen ) );
         nValue ++, iValueLen=sizeof szValue, iDataLen=sizeof szValue )
     {
         iStatus = RegSetValueExA( hkeyNew,
                                  szValue,
                                  0, // reserved
                                  dwType,
                                  szData,
                                  iDataLen);
     }
    if( iStatus != ERROR_NO_MORE_ITEMS )
    {
        goto exit;
    }

    //*********** copy the subtrees ************** //

    for( nKey = 0;
         ERROR_SUCCESS == (iStatus = RegEnumKeyA(hkeyOld,nKey,szBuffer,sizeof(szBuffer)));
         nKey ++ )
     {
         iStatus = CopyKey( hkeyOld, hkeyNew, szBuffer );
         if( iStatus != ERROR_NO_MORE_ITEMS && iStatus != ERROR_SUCCESS )
            {
                goto exit;
            }
     }

    if( iStatus == ERROR_NO_MORE_ITEMS )
        iStatus = ERROR_SUCCESS;

exit:
    if (hkeyOld)
        RegCloseKey(hkeyOld);
    if (hkeyNew)
        RegCloseKey(hkeyNew);

    return iStatus;
}

DWORD SaveLookToDefaultUser( void )
{
    DWORD iStatus;
    HKEY hkeyDst;

    iStatus  = RegOpenKeyExA( HKEY_USERS, ".DEFAULT", 0,
		KEY_SET_VALUE | KEY_ENUMERATE_SUB_KEYS, &hkeyDst );
    if( iStatus != ERROR_SUCCESS )
        return iStatus;
    iStatus = CopyKey( HKEY_CURRENT_USER, hkeyDst, "Control Panel\\Desktop");
    iStatus = CopyKey( HKEY_CURRENT_USER, hkeyDst, "Control Panel\\Colors");
    RegCloseKey( hkeyDst );
    return iStatus;
}

DWORD SaveAccessibilityToDefaultUser( void )
{
    DWORD iStatus;
    HKEY hkeyDst;

    iStatus  = RegOpenKeyExA( HKEY_USERS, ".DEFAULT", 0, KEY_SET_VALUE, &hkeyDst );
    if( iStatus != ERROR_SUCCESS )
        return iStatus;
    iStatus = CopyKey( HKEY_CURRENT_USER, hkeyDst, "Control Panel\\Accessibility");
    RegCloseKey( hkeyDst );
    return iStatus;
}



CSaveForDefaultUserPg::CSaveForDefaultUserPg( 
    LPPROPSHEETPAGE ppsp
	) : WizardPage(ppsp, IDS_WIZSAVEASDEFAULTTITLE, IDS_WIZSAVEASDEFAULTSUBTITLE)
{
	m_dwPageId = IDD_WIZWORKSTATIONDEFAULT;
    ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
}


CSaveForDefaultUserPg::~CSaveForDefaultUserPg(
    VOID
    )
{
}

LRESULT CSaveForDefaultUserPg::OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
{
	if(Button_GetCheck(GetDlgItem(m_hwnd, IDC_CHECKSAVESETTINGTODEFAULT)))
	{
		SaveAccessibilityToDefaultUser();
		// JMC Check for admin privleges for both callse
		if(ERROR_SUCCESS != SaveLookToDefaultUser())
			StringTableMessageBox(m_hwnd, IDS_WIZERRORNEEDADMINTEXT, IDS_WIZERRORNEEDADMINTITLE, MB_OK);
	}
	return WizardPage::OnPSN_WizNext(hwnd, idCtl, pnmh);
}

LRESULT
CSaveForDefaultUserPg::OnCommand(
								 HWND hwnd,
								 WPARAM wParam,
								 LPARAM lParam
								 )
{
	LRESULT lResult = 1;
	
	WORD wNotifyCode = HIWORD(wParam);
	WORD wCtlID 	 = LOWORD(wParam);
	HWND hwndCtl	 = (HWND)lParam;
	
	return lResult;
}

LRESULT
CSaveForDefaultUserPg::OnInitDialog(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	Button_SetCheck(GetDlgItem(m_hwnd, IDC_RADIO2), TRUE);
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgsvefil.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGSVEFIL_H
#define _INC_PGSVEFIL_H

#include "pgbase.h"

class CSaveToFilePg : public WizardPage
{
public:
    CSaveToFilePg(LPPROPSHEETPAGE ppsp);
    ~CSaveToFilePg(VOID);

protected:
	void UpdateControls();

	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);


private:

};

#endif // _INC_PGSVEFIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgtmeout.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGTMEOUT_H
#define _INC_PGTMEOUT_H

#include "pgbase.h"

class CAccessTimeOutPg : public WizardPage
{
public:
	CAccessTimeOutPg(LPPROPSHEETPAGE ppsp);
	~CAccessTimeOutPg(VOID);

protected:
	void UpdateControls();

	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
};



#endif // _INC_PGTMEOUT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgsvefil.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgSveFil.h"

CSaveToFilePg::CSaveToFilePg(
	LPPROPSHEETPAGE ppsp
	) : WizardPage(ppsp, IDS_WIZSAVETOFILETITLE, IDS_WIZSAVETOFILESUBTITLE)
{
	m_dwPageId = IDD_WIZSAVETOFILE;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
}


CSaveToFilePg::~CSaveToFilePg(
	VOID
	)
{
}

LRESULT
CSaveToFilePg::OnInitDialog(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	UpdateControls();
	return 1;
}


void CSaveToFilePg::UpdateControls()
{
	// No options
}


LRESULT
CSaveToFilePg::OnCommand(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	LRESULT lResult = 1;

	WORD wNotifyCode = HIWORD(wParam);
	WORD wCtlID      = LOWORD(wParam);
	HWND hwndCtl     = (HWND)lParam;

	switch(wCtlID)
	{
	case IDC_BTNBROWSE:
		{
			// These commands require us to re-enable/disable the appropriate controls
			TCHAR szBuf[_MAX_PATH];
			TCHAR szBuf2[_MAX_PATH];
			TCHAR szDefaultName[_MAX_PATH];
			LoadString(g_hInstDll, IDS_DEFAULTSAVEFILENAME, szDefaultName, ARRAYSIZE(szDefaultName));
			
			TCHAR szFilterName[_MAX_PATH];
			TCHAR szTemp[_MAX_PATH];
			ZeroMemory(szFilterName, _MAX_PATH);
			LoadString(g_hInstDll, IDS_FILTERNAME, szFilterName, ARRAYSIZE(szFilterName));
			LoadString(g_hInstDll, IDS_FILTER, szTemp, ARRAYSIZE(szTemp));

			// Copy the extension to after the filter name
			lstrcpy(&szFilterName[lstrlen(szFilterName) + 1], szTemp);

			// Double NULL terminate it
			szFilterName[lstrlen(szFilterName) + 1 + lstrlen(szTemp) + 1] = 0;
			szFilterName[lstrlen(szFilterName) + 1 + lstrlen(szTemp) + 2] = 0;


			memset(szBuf, 0, ARRAYSIZE(szBuf));
			memset(szBuf2, 0, ARRAYSIZE(szBuf));
			wsprintf(szBuf, szDefaultName);
			OPENFILENAME ofn;
			memset(&ofn, 0, sizeof(ofn));
			ofn.lStructSize = sizeof(ofn);
			ofn.hwndOwner = m_hwnd;
			ofn.hInstance = g_hInstDll;
			ofn.lpstrFilter = szFilterName; 
			ofn.lpstrCustomFilter = NULL;
			ofn.nMaxCustFilter = 0;
			ofn.nFilterIndex = 0;
			ofn.lpstrFile = szBuf;
			ofn.nMaxFile = _MAX_PATH;
			ofn.lpstrFileTitle = szBuf2;
			ofn.nMaxFileTitle = _MAX_PATH;
			ofn.lpstrInitialDir = NULL;
			ofn.lpstrTitle = NULL;
			ofn.Flags = OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;
			ofn.nFileOffset = 0;
			ofn.nFileExtension = 0;
			ofn.lpstrDefExt = __TEXT("acw");
			ofn.lCustData = NULL;
			ofn.lpfnHook = NULL;
			ofn.lpTemplateName = NULL;
			BOOL bOk = GetSaveFileName(&ofn);
			if(bOk)
			{
				// Save the file to disk.
				HANDLE hFile = CreateFile(ofn.lpstrFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
				if(hFile != INVALID_HANDLE_VALUE)
				{
					DWORD dwWritten;
					WriteFile(hFile, (LPCVOID)&g_Options.m_schemePreview, sizeof(g_Options.m_schemePreview), &dwWritten, NULL);
					CloseHandle(hFile);
					// TODO: Maybe go to the next page
				}
				else
					StringTableMessageBox(m_hwnd, IDS_WIZERRORSAVINGFILETEXT, IDS_WIZERRORSAVINGFILETITLE, MB_OK);
			}

			UpdateControls();
			lResult = 0;
		}
		break;
																					 
	default:
		break;
	}

	return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgsvedef.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGSVEDEF_H
#define _INC_PGSVEDEF_H

#include "pgbase.h"

class CSaveForDefaultUserPg : public WizardPage
{
public:
	CSaveForDefaultUserPg(LPPROPSHEETPAGE ppsp);
	~CSaveForDefaultUserPg(VOID);
	
private:
	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);
	
};

#endif // _INC_PGSVEDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgtmeout.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgTmeOut.h"

CAccessTimeOutPg::CAccessTimeOutPg(
	LPPROPSHEETPAGE ppsp
	) : WizardPage(ppsp, IDS_WIZACCESSTIMEOUTTITLE, IDS_WIZACCESSTIMEOUTSUBTITLE)
{
	m_dwPageId = IDD_WIZACCESSTIMEOUT;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
}


CAccessTimeOutPg::~CAccessTimeOutPg(
	VOID
	)
{
}

int g_nTimeOuts = 6;
DWORD g_rgdwTimeOuts[] = {5*60000, 10*60000, 15*60000, 20*60000, 25*60000, 30*60000};

LRESULT
CAccessTimeOutPg::OnInitDialog(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	HWND hwndTimeOut = GetDlgItem(m_hwnd, IDC_TO_TIMEOUTVAL);


	// JMC: TODO: Maybe move these into the string table

	// Set timeouts for 5 to 30 minutes
	int i;
	for (i= 0; i < g_nTimeOuts; i++)
	{
		TCHAR buf[256];
		wsprintf(buf,__TEXT("%d"),g_rgdwTimeOuts[i]/60000);
		ComboBox_InsertString(hwndTimeOut, i, buf);
	}



	BOOL bEnable = g_Options.m_schemePreview.m_ACCESSTIMEOUT.dwFlags & ATF_TIMEOUTON;
	if(bEnable)
	{
		Button_SetCheck(GetDlgItem(m_hwnd, IDC_TO_ENABLE), TRUE);
		EnableWindow (GetDlgItem(m_hwnd,IDC_TO_TIMEOUTVAL),TRUE);
	}
	else
	{
		// Hack for radio buttons
		if(GetDlgItem(m_hwnd, IDC_TO_DISABLE))
			Button_SetCheck(GetDlgItem(m_hwnd, IDC_TO_DISABLE), TRUE);
		EnableWindow (GetDlgItem(m_hwnd,IDC_TO_TIMEOUTVAL),FALSE);
	}

	// Figure out the time to use as default
	int nIndex = 0;
	for(i = g_nTimeOuts - 1;i>=0;i--)
	{
		// Brute Force find the largest value
		if(g_rgdwTimeOuts[i] >= g_Options.m_schemePreview.m_ACCESSTIMEOUT.iTimeOutMSec)
			nIndex = i;
		else
			break;
	}
	ComboBox_SetCurSel(hwndTimeOut, nIndex);

	return 1;
}


void CAccessTimeOutPg::UpdateControls()
{
	// enable/disable the combo box depending on which radio
	// button is selected
	if(Button_GetCheck(GetDlgItem(m_hwnd, IDC_TO_ENABLE)))
	{
		EnableWindow (GetDlgItem(m_hwnd,IDC_TO_TIMEOUTVAL), TRUE);
		EnableWindow (GetDlgItem(m_hwnd,IDC_MIN), TRUE);
	}
	else
	{
		EnableWindow (GetDlgItem(m_hwnd,IDC_TO_TIMEOUTVAL), FALSE);
		EnableWindow (GetDlgItem(m_hwnd,IDC_MIN), FALSE);
	}

}


LRESULT
CAccessTimeOutPg::OnCommand(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	LRESULT lResult = 1;

	WORD wNotifyCode = HIWORD(wParam);
	WORD wCtlID      = LOWORD(wParam);
	HWND hwndCtl     = (HWND)lParam;

	switch(wCtlID)
	{
	case IDC_TO_DISABLE:
	case IDC_TO_ENABLE:
		// These commands require us to re-enable/disable the appropriate controls
		UpdateControls();
		lResult = 0;
		break;

	default:
		break;
	}

	return lResult;
}

LRESULT
CAccessTimeOutPg::OnPSN_WizNext(
						   HWND hwnd,
						   INT idCtl,
						   LPPSHNOTIFY pnmh
						   )
{
	BOOL bUseAccessTimeOut= Button_GetCheck(GetDlgItem(m_hwnd, IDC_TO_ENABLE));

	if(bUseAccessTimeOut)
		g_Options.m_schemePreview.m_ACCESSTIMEOUT.dwFlags |= ATF_TIMEOUTON;
	else
		g_Options.m_schemePreview.m_ACCESSTIMEOUT.dwFlags &= ~ATF_TIMEOUTON;

	int nIndex = ComboBox_GetCurSel(GetDlgItem(m_hwnd, IDC_TO_TIMEOUTVAL));
	g_Options.m_schemePreview.m_ACCESSTIMEOUT.iTimeOutMSec = g_rgdwTimeOuts[nIndex];


	g_Options.ApplyPreview();

	return WizardPage::OnPSN_WizNext(hwnd, idCtl, pnmh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgwelco2.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgWelco2.h"

#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

// Intelli-menu regsitry
#define REGSTR_EXPLORER TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer")
#define REGSTR_INTELLIMENU REGSTR_EXPLORER TEXT("\\Advanced")

#define REGSTR_IE TEXT("Software\\Microsoft\\Internet Explorer\\Main")
#define STRMENU TEXT("IntelliMenus")
#define FAVMENU TEXT("FavIntelliMenus")

CWelcome2Pg::CWelcome2Pg(
	LPPROPSHEETPAGE ppsp
	) : WizardPage(ppsp, IDS_WELCOME2TITLE, IDS_WELCOME2SUBTITLE)
{
	m_dwPageId = IDD_WIZWELCOME2;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
	m_pDisplayModes = NULL;
	m_nDisplayModes = 0;
	m_nBestDisplayMode = -1;
	m_IntlVal = FALSE;


	// These are our state variables so we know not to do these things twice.
	m_bMagnifierRun = FALSE;
	m_bResolutionSwitched = FALSE;
	m_bFontsChanged = FALSE;

}


CWelcome2Pg::~CWelcome2Pg(
	VOID
	)
{
	if(m_pDisplayModes)
		delete [] m_pDisplayModes;
}

LRESULT
CWelcome2Pg::OnInitDialog(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	// Enumerate available video modes
	// Check if SM_CMONITORS is > 0 then set text so we don't
	// change resolution.

	DEVMODE dm;
	// Calculate number of display modes
	for(m_nDisplayModes=0;m_nDisplayModes<2000;m_nDisplayModes++) // Limit to 2000 display modes.  If it is this high, something is wrong
		if(!EnumDisplaySettings(NULL, m_nDisplayModes, &dm))
			break;

	m_pDisplayModes = new CDisplayModeInfo[m_nDisplayModes];
	for(int i=0;i<m_nDisplayModes;i++)
		EnumDisplaySettings(NULL, i, &m_pDisplayModes[i].m_DevMode);


	m_nBestDisplayMode = -1;

	memset(&m_dvmdOrig, 0, sizeof(m_dvmdOrig));

	HDC hdc = GetDC(NULL);  // Screen DC used to get current display settings
	// JMC: HOW DO WE GET dmDisplayFlags?
	// TODO: Maybe use ChangeDisplaySettings(NULL, 0) to restore original mode
	m_dvmdOrig.dmSize = sizeof(m_dvmdOrig);
	m_dvmdOrig.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT | /* DM_DISPLAYFLAGS | */(g_Options.m_bWin95?0:DM_DISPLAYFREQUENCY);
	m_dvmdOrig.dmPelsWidth        = GetDeviceCaps(hdc, HORZRES);
	m_dvmdOrig.dmPelsHeight       = GetDeviceCaps(hdc, VERTRES);
	m_dvmdOrig.dmBitsPerPel       = GetDeviceCaps(hdc, BITSPIXEL);
	m_dvmdOrig.dmDisplayFrequency = g_Options.m_bWin95?0:GetDeviceCaps(hdc, VREFRESH);
	ReleaseDC(NULL, hdc);


	for(i=0;i<m_nDisplayModes;i++)
	{
		// Skip anything 'higher' than current mode
		if(		m_pDisplayModes[i].m_DevMode.dmPelsWidth > m_dvmdOrig.dmPelsWidth
			||	m_pDisplayModes[i].m_DevMode.dmPelsHeight > m_dvmdOrig.dmPelsHeight
			||	m_pDisplayModes[i].m_DevMode.dmBitsPerPel > m_dvmdOrig.dmBitsPerPel
			||	(!g_Options.m_bWin95 && m_pDisplayModes[i].m_DevMode.dmDisplayFrequency > m_dvmdOrig.dmDisplayFrequency) )
			continue;

		// Skip this if it is 'worse' than the current best mode
		if(		-1 != m_nBestDisplayMode
			&&	(		m_pDisplayModes[i].m_DevMode.dmPelsWidth < m_pDisplayModes[m_nBestDisplayMode].m_DevMode.dmPelsWidth
					||	m_pDisplayModes[i].m_DevMode.dmPelsHeight < m_pDisplayModes[m_nBestDisplayMode].m_DevMode.dmPelsHeight
					||	m_pDisplayModes[i].m_DevMode.dmBitsPerPel < m_pDisplayModes[m_nBestDisplayMode].m_DevMode.dmBitsPerPel
					||	(!g_Options.m_bWin95 && m_pDisplayModes[i].m_DevMode.dmDisplayFrequency < m_pDisplayModes[m_nBestDisplayMode].m_DevMode.dmDisplayFrequency) ) )
			continue;

		// Skip anything 'less than' 800 x 600 (JMC: Used to be 640 x 480)
		if(		m_pDisplayModes[i].m_DevMode.dmPelsWidth < 800
			||	m_pDisplayModes[i].m_DevMode.dmPelsHeight < 600 )
			continue;


		// See if this is 'smaller' than the current resolution
		if(	m_pDisplayModes[i].m_DevMode.dmPelsHeight < m_dvmdOrig.dmPelsHeight )
			m_nBestDisplayMode = i;

	}

	// Get original metrics
	GetNonClientMetrics(&m_ncmOrig, &m_lfIconOrig);
	
	SetCheckBoxesFromWelcomePageInfo();

	// Set the Personalized menu check box
	HKEY hKey;
	DWORD dwType;
	TCHAR lpszData[24];
	DWORD dwCount = 24;

	if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, REGSTR_INTELLIMENU, 0, KEY_QUERY_VALUE, &hKey))
	{
		if ( ERROR_SUCCESS == RegQueryValueEx( hKey, STRMENU, NULL, &dwType, (LPBYTE)lpszData, &dwCount ) )
		{
			lpszData[ARRAYSIZE(lpszData)-1] = TEXT('\0');  // ensure NUL termination
			if ( lstrcmp(lpszData, TEXT("No") ) == 0 )
				m_IntlVal = TRUE;
		}
	}

	Button_SetCheck(GetDlgItem(hwnd, IDC_PERMENU), m_IntlVal);

	return 1;
}


void CWelcome2Pg::UpdateControls()
{
	BOOL bChangeRes = Button_GetCheck(GetDlgItem(m_hwnd, IDC_SWITCHRESOLUTION));
	BOOL bChangeFont = Button_GetCheck(GetDlgItem(m_hwnd, IDC_CHANGEFONTS));
	BOOL bMagnifier = Button_GetCheck(GetDlgItem(m_hwnd, IDC_USEMAGNIFY));
	DWORD_PTR result;

	if(bChangeRes && !m_bResolutionSwitched)
	{
		if(IDOK != StringTableMessageBox(m_hwnd,IDS_WIZCHANGESHAPPENINGTEXT, IDS_WIZCHANGESHAPPENINGTITLE, MB_OKCANCEL))
		{
			// The user does not want to do this
			Button_SetCheck(GetDlgItem(m_hwnd, IDC_SWITCHRESOLUTION), FALSE);
		}
		else
		{
			// Lets change the resolution
			if(DISP_CHANGE_SUCCESSFUL != ChangeDisplaySettings(&m_pDisplayModes[m_nBestDisplayMode].m_DevMode, CDS_TEST))
			{
			}
			else
				ChangeDisplaySettings(&m_pDisplayModes[m_nBestDisplayMode].m_DevMode, CDS_UPDATEREGISTRY | CDS_GLOBAL);

			if(IDOK != StringTableMessageBox(m_hwnd, IDS_WIZCANCELCHANGESTEXT, IDS_WIZCANCELCHANGESTITLE, MB_OKCANCEL))
			{
				// Restore original settings
				ChangeDisplaySettings(&m_dvmdOrig, CDS_UPDATEREGISTRY | CDS_GLOBAL);
				Button_SetCheck(GetDlgItem(m_hwnd, IDC_SWITCHRESOLUTION), FALSE);
			}
			else
				m_bResolutionSwitched = TRUE; // We REALLY changed the settings
		}
	}
	else if (!bChangeRes && m_bResolutionSwitched)
	{
		m_bResolutionSwitched = FALSE;
		// Restore original settings
		ChangeDisplaySettings(&m_dvmdOrig, CDS_UPDATEREGISTRY | CDS_GLOBAL);
	}

	if(bChangeFont && !m_bFontsChanged)
	{
		m_bFontsChanged = TRUE;

		// Get current metrics
		NONCLIENTMETRICS ncm;
		memset(&ncm, 0, sizeof(ncm));
		ncm.cbSize = sizeof(ncm);
		SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);

		LOGFONT lf;
		memset(&lf, 0, sizeof(lf));
		lf.lfHeight = -MulDiv(g_Options.m_nMinimalFontSize, g_Options.m_nLogPixelsY, 72);
		lf.lfWeight = FW_BOLD;
		lf.lfCharSet = g_Options.m_lfCharSet;
		LoadString(g_hInstDll, IDS_SYSTEMFONTNAME, lf.lfFaceName, ARRAYSIZE(lf.lfFaceName));


		// Captions are BOLD
		ncm.lfCaptionFont = lf;

		lf.lfWeight = FW_NORMAL;

		ncm.lfSmCaptionFont = lf; 
		ncm.lfMenuFont = lf;
		ncm.lfStatusFont = lf;
		ncm.lfMessageFont = lf;

		// DYNAMICS
		// JMC: TODO: Change caption height / menu height / button width to match.
		// JMC: HACK
		lf.lfWeight = FW_BOLD; // Caption is BOLD
		HFONT hFont = CreateFontIndirect(&lf);
		lf.lfWeight = FW_NORMAL; // Still need lf for ICON
		TEXTMETRIC tm;
		HDC hdc = GetDC(m_hwnd);
		HFONT hfontOld = (HFONT)SelectObject(hdc, hFont);
		GetTextMetrics(hdc, &tm);
		if (hfontOld)
			SelectObject(hdc, hfontOld);
		ReleaseDC(m_hwnd, hdc);

		/*int cyBorder = GetSystemMetrics(SM_CYBORDER);
		int nSize = abs(lf.lfHeight) + abs(tm.tmExternalLeading) + 2 * cyBorder;
		nSize = max(nSize, GetSystemMetrics(SM_CYICON)/2 + 2 * cyBorder);*/

		// The above calculation of metric sizes is incorrect, Morever, The other values
		// are also wrong..So using hardcoded values: Based on Display.cpl
		// BUG: Changes maybe required for 9x here!!
		if (g_Options.m_nMinimalFontSize >= 14 )
			ncm.iCaptionWidth = ncm.iCaptionHeight = 26;
		else
			ncm.iCaptionWidth = ncm.iCaptionHeight = 18;
		
		ncm.iSmCaptionWidth = 15;
		ncm.iSmCaptionHeight = 15;
		ncm.iMenuWidth = 18;
		ncm.iMenuHeight = 18;

		SystemParametersInfo(SPI_SETNONCLIENTMETRICS, sizeof(ncm), &ncm, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
		SystemParametersInfo(SPI_SETICONTITLELOGFONT, sizeof(lf), &lf, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
		SendMessageTimeout(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0, SMTO_ABORTIFHUNG, 5000, &result );
		SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, SPI_SETNONCLIENTMETRICS, (LPARAM)__TEXT("WindowMetrics"),
			SMTO_ABORTIFHUNG, 5000, &result);

		// HACK - TODO Remove this from here
		g_Options.m_schemePreview.m_PortableNonClientMetrics.LoadOriginal();
		g_Options.m_schemeCurrent.m_PortableNonClientMetrics.LoadOriginal();
	}
	else if (!bChangeFont && m_bFontsChanged)
	{
		m_bFontsChanged = FALSE;

		SystemParametersInfo(SPI_SETNONCLIENTMETRICS, sizeof(m_ncmOrig), &m_ncmOrig, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
		SystemParametersInfo(SPI_SETICONTITLELOGFONT, sizeof(m_lfIconOrig), &m_lfIconOrig, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
		SendMessageTimeout(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0, SMTO_ABORTIFHUNG, 5000, &result);
		SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, SPI_SETNONCLIENTMETRICS, (LPARAM)__TEXT("WindowMetrics"),
			SMTO_ABORTIFHUNG, 5000, &result);

		// HACK - TODO Remove this from here
		g_Options.m_schemePreview.m_PortableNonClientMetrics.LoadOriginal();
		g_Options.m_schemeCurrent.m_PortableNonClientMetrics.LoadOriginal();
	}
	
	if(bMagnifier && !m_bMagnifierRun)
	{
		// Start magnifier
		m_bMagnifierRun = TRUE;
        TCHAR szMagnifyPath[_MAX_PATH+2];
        TCHAR szSystemDir[_MAX_PATH];
        TCHAR szSystemDirPath[_MAX_PATH+2];
        const TCHAR c_szMagnifier[] = TEXT("\\Magnify.exe\"");
        const TCHAR c_szQuote[] = TEXT("\"");
        LPTSTR pszDestEnd;
        size_t cchRemaining;
        LPTSTR pszIEDestEnd;
        size_t cchIERemaining;
        HRESULT hrSystemDir;


        // Form quoted system path 
        GetSystemDirectory(szSystemDir,ARRAYSIZE(szSystemDir));

        StringCchCopyEx(szSystemDirPath, ARRAYSIZE(szSystemDirPath), c_szQuote, &pszDestEnd, &cchRemaining, 0);
        StringCchCopyEx(pszDestEnd, cchRemaining, szSystemDir, &pszDestEnd, &cchRemaining, 0);
        hrSystemDir = StringCchCopyEx(pszDestEnd, cchRemaining, c_szQuote, &pszDestEnd,&cchRemaining, 0);

        // Form quoted executable path
        StringCchCopyEx(szMagnifyPath, ARRAYSIZE(szMagnifyPath),c_szQuote,&pszDestEnd,&cchRemaining, 0);
        StringCchCopyEx(pszDestEnd,cchRemaining,szSystemDir, &pszDestEnd, &cchRemaining, 0);

        if (S_OK==hrSystemDir && S_OK==StringCchCopyEx(pszDestEnd,cchRemaining,c_szMagnifier,&pszDestEnd,&cchRemaining, 0))
        {   
            ShellExecute(NULL, NULL, szMagnifyPath, NULL, szSystemDirPath, SW_SHOWNORMAL/*SW_SHOWMINIMIZED*/);
        }
	}
	else if (!bMagnifier && m_bMagnifierRun)
	{
		// Stop magnifier
		m_bMagnifierRun = FALSE;
		TCHAR szMag[200];
		LoadString(g_hInstDll, IDS_NAMEOFMAGNIFIER, szMag, ARRAYSIZE(szMag));
		if(HWND hwnd = FindWindow(NULL, szMag))
			SendMessage(hwnd, WM_CLOSE, 0, 0);
	}
	
}


void CWelcome2Pg::SetCheckBoxesFromWelcomePageInfo()
{
	// This algorithm chooses which check boxes to set based on the
	// minimal legible font size specified in g_Options.m_nMinimalFontSize

	// HACK:
//	g_Options.m_nMinimalFontSize = MulDiv(abs(g_Options.m_schemePreview.m_ncm.lfCaptionFont.lfHeight), 72, g_Options.m_nLogPixelsY);

	BOOL bSwitchRes = FALSE;
	BOOL bChangeFonts = FALSE;
 	BOOL bUseMagnify = FALSE;
	switch(g_Options.m_nMinimalFontSize)
	{
	case 8:
	case 9:  // Required for JPN
	case 10:
	case 11: // Required For JPN
		bChangeFonts = TRUE;
		break;
	case 12:
		bChangeFonts = TRUE;
		bSwitchRes = TRUE;
		break;
	case 14:
	case 15: // Required for JPN
	case 16:
	case 18:
	case 20:
	case 22:
	case 24:
		bChangeFonts = TRUE;
		bUseMagnify = TRUE;
		break;
	}

	// JMC: TODO: Handle if the user does not have permission to change
	// the display settings!!!!!!!!!!!!!!

	if(-1 == m_nBestDisplayMode)
	{
		bSwitchRes = FALSE;
//		SetWindowText(GetDlgItem(m_hwnd, IDC_SZRESMESSAGE),
//			__TEXT("There are no display resolutions that would be better for the size text you chose."));
		EnableWindow(GetDlgItem(m_hwnd, IDC_SWITCHRESOLUTION), FALSE);
	}
	else
	{
#if 0 // We don't display special text any more
		TCHAR sz[200];
		TCHAR szTemp[1024];
		LoadString(g_hInstDll, IDS_DISPLAYRESOLUTIONINFO, szTemp, ARRAYSIZE(szTemp));
		wsprintf(sz, szTemp,
			m_dvmdOrig.dmPelsWidth,
			m_dvmdOrig.dmPelsHeight,
			m_pDisplayModes[m_nBestDisplayMode].m_DevMode.dmPelsWidth,
			m_pDisplayModes[m_nBestDisplayMode].m_DevMode.dmPelsHeight);
		SetWindowText(GetDlgItem(m_hwnd, IDC_SZRESMESSAGE), sz);
#endif
		EnableWindow(GetDlgItem(m_hwnd, IDC_SWITCHRESOLUTION), TRUE);
	}

	Button_SetCheck(GetDlgItem(m_hwnd, IDC_SWITCHRESOLUTION), bSwitchRes);
	Button_SetCheck(GetDlgItem(m_hwnd, IDC_CHANGEFONTS), bChangeFonts);
	Button_SetCheck(GetDlgItem(m_hwnd, IDC_USEMAGNIFY), bUseMagnify);
	UpdateControls();
}


LRESULT
CWelcome2Pg::OnCommand(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	LRESULT lResult = 1;

	WORD wNotifyCode = HIWORD(wParam);
	WORD wCtlID      = LOWORD(wParam);
	HWND hwndCtl     = (HWND)lParam;


	// NOTE: DO NOT CALL UpdateControls()
	// UpdateControls() should only be called when entering this page
	// since it sets the check boxes based on the minimal font size
	// determined by the previous wizard page
	
	
	switch(wCtlID)
	{
	case IDC_SWITCHRESOLUTION:
	case IDC_CHANGEFONTS:
	case IDC_USEMAGNIFY:
		UpdateControls();
		lResult = 0;
	break;
	
	  default:
	  break;
	  }
	
	return lResult;
}

LRESULT
CWelcome2Pg::OnPSN_SetActive(
							 HWND hwnd, 
							 INT idCtl, 
							 LPPSHNOTIFY pnmh
							 )
{
	// Call the base class
	WizardPage::OnPSN_SetActive(hwnd, idCtl, pnmh);

	// Make sure our check boxes reflect any change in the minimal
	// font size specified by g_Options.m_nMinimalFontSize
	if(g_Options.m_bWelcomePageTouched)
	{
		g_Options.m_bWelcomePageTouched = FALSE;
		SetCheckBoxesFromWelcomePageInfo();
	}
	
	return TRUE;
}

LRESULT
CWelcome2Pg::OnPSN_WizNext(
						   HWND hwnd,
						   INT idCtl,
						   LPPSHNOTIFY pnmh
						   )
{
	BOOL bIMenu = Button_GetCheck(GetDlgItem(m_hwnd, IDC_PERMENU));
	
    if (!m_bFontsChanged)
    {
        g_Options.m_schemePreview.m_nSelectedSize = g_Options.m_schemeOriginal.m_nSelectedSize;
    }

	// If Intelli-menus are changed
	if(bIMenu != m_IntlVal)
	{
		HKEY hKey;
		DWORD_PTR result;
		
		LPTSTR psz = bIMenu ?  TEXT("No") : TEXT("Yes");

		// Change the Registry entries....
		if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, REGSTR_INTELLIMENU, 0, KEY_SET_VALUE, &hKey) )
		{
			RegSetValueEx( hKey, STRMENU, 0, REG_SZ, (LPBYTE)psz,
						(lstrlen(psz) + 1) * sizeof(TCHAR) );

			RegCloseKey(hKey);
		}

		if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, REGSTR_IE, 0, KEY_SET_VALUE, &hKey) )
		{
			RegSetValueEx( hKey, FAVMENU, 0, REG_SZ, (LPBYTE)psz,
						(lstrlen(psz) + 1) * sizeof(TCHAR) );

			RegCloseKey(hKey);
		}

		m_IntlVal = bIMenu;
		SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, 0, 
			(LPARAM) 0, SMTO_ABORTIFHUNG, 5000, &result);
	}

	return WizardPage::OnPSN_WizNext(hwnd, idCtl, pnmh);
}

LRESULT
CWelcome2Pg::OnPSN_WizBack(
						   HWND hwnd,
						   INT idCtl,
						   LPPSHNOTIFY pnmh
						   )
{
	
    // Undo any changes
	Button_SetCheck(GetDlgItem(m_hwnd, IDC_SWITCHRESOLUTION), FALSE);
	Button_SetCheck(GetDlgItem(m_hwnd, IDC_CHANGEFONTS), FALSE);
	Button_SetCheck(GetDlgItem(m_hwnd, IDC_USEMAGNIFY), FALSE);
	
    // While going back. Just update variables only. Don't apply changes.
    // DONOT call UpdateControls(): a-anilk

    BOOL bChangeRes = Button_GetCheck(GetDlgItem(m_hwnd, IDC_SWITCHRESOLUTION));
	BOOL bChangeFont = Button_GetCheck(GetDlgItem(m_hwnd, IDC_CHANGEFONTS));
	BOOL bMagnifier = Button_GetCheck(GetDlgItem(m_hwnd, IDC_USEMAGNIFY));
    m_bFontsChanged = FALSE;

	return WizardPage::OnPSN_WizBack(hwnd, idCtl, pnmh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgwelcom.cpp ===
// Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgWelcom.h"

#include "select.h"
extern HPALETTE g_hpal3D;

UINT IDMapT[3][2] = { 0, IDC_TEXT1,
					  1, IDC_TEXT2,
					  2, IDC_TEXT3
					};

// a-anilk; Re-write to use owner drawn controls: 05/08/99
CWelcomePg::CWelcomePg(
						   LPPROPSHEETPAGE ppsp
						   ) : WizardPage(ppsp, IDS_TEXTSIZETITLE, IDS_TEXTSIZESUBTITLE)
{
	m_dwPageId = IDD_WIZWELCOME;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
	
	m_nCurrentHilight = 0;
	m_nCurValueIndex = 0;
}


CWelcomePg::~CWelcomePg(
							VOID
							)
{
}


LRESULT
CWelcomePg::OnCommand(
						HWND hwnd,
						WPARAM wParam,
						LPARAM lParam
						)
{
	LRESULT lResult = 1;
	
	return lResult;
}

LRESULT CWelcomePg::OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	SetFocus(GetDlgItem(hwnd, IDC_TEXT1));

	LoadString(g_hInstDll, IDS_WELCOMETEXT1, m_szWelcomeText[0], ARRAYSIZE(m_szWelcomeText[0]));
	LoadString(g_hInstDll, IDS_WELCOMETEXT2, m_szWelcomeText[1], ARRAYSIZE(m_szWelcomeText[1]));
	LoadString(g_hInstDll, IDS_WELCOMETEXT3, m_szWelcomeText[2], ARRAYSIZE(m_szWelcomeText[2]));
	LoadString(g_hInstDll, IDS_WELCOMETEXT4, m_szWelcomeText[3], ARRAYSIZE(m_szWelcomeText[3]));

	LoadArrayFromStringTable(IDS_LKPREV_WELCOME_MINTEXTSIZES, m_rgnValues, &m_nCountValues);

	return 1;
}

void CWelcomePg::InvalidateRects(int PrevHilight)
{
	InvalidateRect(GetDlgItem(m_hwnd, IDMapT[PrevHilight][1]), NULL, TRUE);
}

// These is to set the Focus and sync the painting
LRESULT CWelcomePg::OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
{
	syncInit = FALSE;
	uIDEvent = SetTimer(hwnd, NULL, 100, NULL);
	m_nCurrentHilight = m_nCurValueIndex = 0;

	// Localization taken care... 9,11,15 in JPN
	if ( g_Options.m_nMinimalFontSize <=9 )
		m_nCurrentHilight = 0;
	else if (g_Options.m_nMinimalFontSize <=12 )
		m_nCurrentHilight = 1;
	else if (g_Options.m_nMinimalFontSize <=16 )
		m_nCurrentHilight = 2;

	m_nCurValueIndex = m_nCurrentHilight;

	return 0;
}

LRESULT CWelcomePg::OnTimer( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
	KillTimer(hwnd, uIDEvent);
	syncInit = TRUE;
	return 1;
}

// Sets the focus to the current item in OnInitDialog. 
void CWelcomePg::SetFocussedItem(int m_nCurrentHilight)
{
	SetFocus(GetDlgItem(m_hwnd, IDMapT[m_nCurrentHilight][1]));
}

LRESULT CWelcomePg::OnDrawItem(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	UINT idCtrl = (UINT) wParam;
	LPDRAWITEMSTRUCT lpDrawItemStruct = (LPDRAWITEMSTRUCT) lParam;
	int index;
	
	if ( !syncInit)
		SetFocussedItem(m_nCurrentHilight);


	switch(idCtrl)
	{

	case IDC_TEXT1:
		index = 0;
		break;
	
	case IDC_TEXT2:
		index = 1;
		break;
		
	case IDC_TEXT3:
		index = 2;
		break;

	default:
		_ASSERTE(FALSE);
		return 1;	// Prefix #113778 (this should never happen; only three controls on dialog)
		break;

	}
	
	// For each button, Check the state, And if the button is selected,
	// means that it has current focus, So Re-paint the previously hilighted and 
	// the current selected buttons....
	// Make sure we ignore the initial events so that we minimize the flicker...
	if ( (lpDrawItemStruct->itemState & ODS_FOCUS) && (m_nCurrentHilight != index))
	{
		if ( syncInit )
		{
			// Erase the previous one...
			InvalidateRects(m_nCurrentHilight);
			Sleep(100);
			m_nCurrentHilight= m_nCurValueIndex = index;
		}
	}
	Draw( lpDrawItemStruct, index );

	return 1;
}


void CWelcomePg::Draw(LPDRAWITEMSTRUCT ldi, int i)
{
	int nOldBkMode = SetBkMode(ldi->hDC, TRANSPARENT);
	HDC hdc = ldi->hDC;
	
	RECT rcOriginal = ldi->rcItem;
	HFONT hFontOld = (HFONT)SelectObject(hdc, g_Options.GetClosestMSSansSerif(m_rgnValues[i], (m_nCurrentHilight == i)));
	TextOut(hdc, rcOriginal.left + 10 , rcOriginal.top + 10 - i, m_szWelcomeText[i], lstrlen(m_szWelcomeText[i]));
	SelectObject(hdc, hFontOld);
	
	SetBkMode(ldi->hDC, nOldBkMode);

	//If current hi-lighted item, Then draw the bounding rectangle. 
	if ( m_nCurrentHilight == i)
	{
		DrawHilight(m_hwnd, ldi);
	}
}


LRESULT
CWelcomePg::OnPSN_WizNext(
						   HWND hwnd,
						   INT idCtl,
						   LPPSHNOTIFY pnmh
						   )
{
	// Tell the second page that we've done something
	g_Options.m_bWelcomePageTouched = TRUE;

    // In addition to knowing the actual font size we need to know if it's normal,
    // large or extra large so we can update display CPL on what's happened.
	g_Options.m_nMinimalFontSize = m_rgnValues[m_nCurValueIndex];
    g_Options.m_schemePreview.m_nSelectedSize = m_nCurValueIndex;

	return WizardPage::OnPSN_WizNext(hwnd, idCtl, pnmh);
#if 0 
	// We are going to allow people to 'back' to this page
	// As a HACK, we want this page to come out only once.
	// If we try to remove ourselves, and the call the
	// default OnPSN_WizNext(), we'll get an assert when
	// that function tries to find the 'next' page.  Instead
	// we manually do the things from OnPSN_WizNext()

	// Remove ourself from the wizard after we select a size.
	DWORD dwTemp = IDD_WIZWELCOME;
	sm_WizPageOrder.RemovePages(&dwTemp, 1);
	SetWindowLong(hwnd, DWL_MSGRESULT, IDD_WIZWELCOME2);
	return TRUE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgwelcom.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGWELCOM_H
#define _INC_PGWELCOM_H

#include "pgbase.h"

class CWelcomePg : public WizardPage
{
public:
    CWelcomePg(LPPROPSHEETPAGE ppsp);
    ~CWelcomePg(VOID);

protected:
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
	LRESULT OnDrawItem(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	inline void InvalidateRects(int PrevHilight);
	LRESULT OnTimer( HWND hwnd, WPARAM wParam, LPARAM lParam );
	LRESULT OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
	inline void SetFocussedItem(int m_nCurrentHilight);

	TCHAR m_szWelcomeText[4][85];
private:

	void Draw(LPDRAWITEMSTRUCT ldi, int i);
	int m_nCountValues;
	int m_rgnValues[MAX_DISTINCT_VALUES];
	int m_nCurValueIndex;
	int m_nCurrentHilight;
	BOOL syncInit;
	UINT uIDEvent;
};

#endif // _INC_PGWELCOM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgwelco2.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGMINTX2_H
#define _INC_PGMINTX2_H

#include "pgbase.h"

struct CDisplayModeInfo
{
	CDisplayModeInfo() {memset(&m_DevMode, 0, sizeof(m_DevMode));m_bCanUse = FALSE;}
	DEVMODE m_DevMode;
	BOOL m_bCanUse;
};

class CWelcome2Pg : public WizardPage
{
public:
	CWelcome2Pg(LPPROPSHEETPAGE ppsp);
	~CWelcome2Pg(VOID);
	
protected:
	void UpdateControls();
	void SetCheckBoxesFromWelcomePageInfo();
	CDisplayModeInfo *m_pDisplayModes;
	int m_nDisplayModes;
	int m_nBestDisplayMode;

	// MOVE THIS STUFF TO THE ACC WIZ OPTIONS
	DEVMODE m_dvmdOrig;
	NONCLIENTMETRICS m_ncmOrig;
	LOGFONT m_lfIconOrig;


	BOOL m_bMagnifierRun;
	BOOL m_bResolutionSwitched;
	BOOL m_bFontsChanged;
	BOOL m_IntlVal;

	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
	LRESULT OnPSN_WizNext(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
	LRESULT OnPSN_WizBack(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);
	
private:
	
};

#endif // _INC_PGMINTX2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgwizopt.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
#ifndef _INC_PGWIZOPT_H
#define _INC_PGWIZOPT_H

#include "pgbase.h"

class CWizardOptionsPg : public WizardPage
{
public:
	CWizardOptionsPg(LPPROPSHEETPAGE ppsp);
	~CWizardOptionsPg(VOID);

protected:
	BOOL AdjustWizPageOrder();
	LRESULT OnCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);
private:
    BOOL restoreOpt;
};

#endif // _INC_PGWIZOPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\pgwizopt.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "resource.h"
#include "pgWizOpt.h"
#include "w95trace.h"

BOOL IsAdmin();

CWizardOptionsPg::CWizardOptionsPg( 
    LPPROPSHEETPAGE ppsp
	) : WizardPage(ppsp, IDS_WIZOPTTITLE, IDS_WIZOPTSUBTITLE)
{
	m_dwPageId = IDD_WIZOPTIONS;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
    restoreOpt = FALSE;
}


CWizardOptionsPg::~CWizardOptionsPg(
    VOID
    )
{
}


DWORD g_rgdwWizNoOptionsSelected[] = {IDD_WIZNOOPTIONSSELECTED};

DWORD g_rgdwWizDoBlind[] = {
							IDD_FNTWIZSCROLLBAR, // scroll bar
							IDD_PREV_ICON2,
							IDD_PREV_COLOR,
                            IDD_MSEWIZMOUSECURSOR,
                            IDD_CARET
								};
DWORD g_rgdwWizDoSounds[] = {
							IDD_SNDWIZSENTRYSHOWSOUNDS,
							IDD_SNDWIZSENTRYSHOWSOUNDS2,
								};
DWORD g_rgdwWizDoKeyboardMouse[] = {
							IDD_KBDWIZSTICKYKEYS,
							IDD_KBDWIZFILTERKEYS1,
							IDD_KBDWIZFILTERKEYS2,
							IDD_KBDWIZTOGGLEKEYS,
							IDD_KBDWIZSHOWEXTRAKEYBOARDHELP,
							IDD_MSEWIZMOUSEKEYS,
							IDD_MSEWIZMOUSECURSOR,
							IDD_MSEWIZBUTTONCONFIG,
							IDD_MSEWIZMOUSESPEED
								};


DWORD g_rgdwWizDoAdmin[] = {
						IDD_WIZACCESSTIMEOUT,
						IDD_WIZWORKSTATIONDEFAULT
							};
DWORD g_rgdwWizFinalPages[] = {
						IDD_WIZFINISH
							};


BOOL CWizardOptionsPg::AdjustWizPageOrder()
{
	BOOL bDoBlind = Button_GetCheck(GetDlgItem(m_hwnd, IDC_DOBLIND));
	BOOL bDoSounds = Button_GetCheck(GetDlgItem(m_hwnd, IDC_DOSOUND));
	BOOL bDoKeyboardMouse = Button_GetCheck(GetDlgItem(m_hwnd, IDC_DOKEYBOARDMOUSE));
	BOOL bDoAdmin = Button_GetCheck(GetDlgItem(m_hwnd, IDC_DOADMIN));

	BOOL bDoNoOptions = (!bDoBlind && !bDoSounds && !bDoKeyboardMouse && !bDoAdmin && !restoreOpt);

	// First remove all possible pages since we want to insert them in the correct order
	// Return value does not matter since the pages may not be in the array
	sm_WizPageOrder.RemovePages(g_rgdwWizNoOptionsSelected, ARRAYSIZE(g_rgdwWizNoOptionsSelected));
	sm_WizPageOrder.RemovePages(g_rgdwWizDoBlind, ARRAYSIZE(g_rgdwWizDoBlind));
	sm_WizPageOrder.RemovePages(g_rgdwWizDoSounds, ARRAYSIZE(g_rgdwWizDoSounds));
	sm_WizPageOrder.RemovePages(g_rgdwWizDoKeyboardMouse, ARRAYSIZE(g_rgdwWizDoKeyboardMouse));
	sm_WizPageOrder.RemovePages(g_rgdwWizDoAdmin, ARRAYSIZE(g_rgdwWizDoAdmin));
	sm_WizPageOrder.RemovePages(g_rgdwWizFinalPages, ARRAYSIZE(g_rgdwWizFinalPages));

	// Then Add in pages in groups in the reverse order that we want them to appear.
	// We do them this way since they are inserted after this page, so the first group inserted
	// will be the last group at the end of this.

	// NOTE: We do not care about the return value from AddPages() in the sense
	// that we they do not allocate or free memory so it does not hurt to keep calling them.  We
	// Will propogate a return value of FALSE if any of them fail.

	BOOL bSuccess = TRUE;

	// Add Final Pages
	bSuccess = bSuccess && sm_WizPageOrder.AddPages(m_dwPageId, g_rgdwWizFinalPages, ARRAYSIZE(g_rgdwWizFinalPages));

	if(bDoNoOptions)
		bSuccess = bSuccess && sm_WizPageOrder.AddPages(m_dwPageId, g_rgdwWizNoOptionsSelected, ARRAYSIZE(g_rgdwWizNoOptionsSelected));

	if(bDoAdmin)
    {
		bSuccess = bSuccess && sm_WizPageOrder.AddPages(m_dwPageId, g_rgdwWizDoAdmin, ARRAYSIZE(g_rgdwWizDoAdmin));
        // Incase you are NOT an admin Remove admin page
        if ( !IsAdmin() )
	        sm_WizPageOrder.RemovePages(&g_rgdwWizDoAdmin[1], 1);
    }

	if(bDoKeyboardMouse)
		bSuccess = bSuccess && sm_WizPageOrder.AddPages(m_dwPageId, g_rgdwWizDoKeyboardMouse, ARRAYSIZE(g_rgdwWizDoKeyboardMouse));

	if(bDoSounds)
		bSuccess = bSuccess && sm_WizPageOrder.AddPages(m_dwPageId, g_rgdwWizDoSounds, ARRAYSIZE(g_rgdwWizDoSounds));

	if(bDoBlind)
		bSuccess = bSuccess && sm_WizPageOrder.AddPages(m_dwPageId, g_rgdwWizDoBlind, ARRAYSIZE(g_rgdwWizDoBlind));

	return bSuccess;
}


LRESULT
CWizardOptionsPg::OnCommand(
	HWND hwnd,
	WPARAM wParam,
	LPARAM lParam
	)
{
	LRESULT lResult = 1;

	WORD wNotifyCode = HIWORD(wParam);
	WORD wCtlID      = LOWORD(wParam);
	HWND hwndCtl     = (HWND)lParam;

	switch(wCtlID)
	{
	case IDC_BTNRESTORETODEFAULT:
		g_Options.ApplyWindowsDefault();
        restoreOpt = TRUE;
		break;

	default:
		break;
	}

	return lResult;
}

BOOL IsAdmin()
{
    HKEY hkey;
    BOOL fOk = (ERROR_SUCCESS == RegOpenKeyExA( HKEY_USERS, ".Default", 0, KEY_ALL_ACCESS, &hkey ));

    if(fOk)
    {
        RegCloseKey(hkey);
    }
    
	return fOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\precomp.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation

#include "pch.hxx" // PCH
#pragma hdrstop

/////////////////////////////////////////////////////////////////
// This file exists for creating the pre-compiled header only. //
/////////////////////////////////////////////////////////////////

#include "resource.h"

void FixupLogfont(LOGFONT *pLogFont)
{
	TCHAR lfFaceName[LF_FACESIZE];
	_ASSERTE(ARRAYSIZE(lfFaceName) == ARRAYSIZE(pLogFont->lfFaceName));

	// This makes sure that logfonts don't have any garbage characters after the NULL termination
	ZeroMemory(lfFaceName, ARRAYSIZE(lfFaceName));
	lstrcpy(lfFaceName, pLogFont->lfFaceName);
	memcpy(pLogFont->lfFaceName, lfFaceName, ARRAYSIZE(lfFaceName));
}

void GetNonClientMetrics(NONCLIENTMETRICS *pncm, LOGFONT *plfIcon)
{
	ZeroMemory(pncm, sizeof(*pncm));
	ZeroMemory(plfIcon, sizeof(*plfIcon));

	pncm->cbSize = sizeof(*pncm);
	SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(*pncm), pncm, 0);
	SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(*plfIcon), plfIcon, 0);

	// We fix up the log fonts so they can be compared with our new logfonts by a memcmp() call
	FixupLogfont(&pncm->lfCaptionFont);
	FixupLogfont(&pncm->lfSmCaptionFont);
	FixupLogfont(&pncm->lfMenuFont);
	FixupLogfont(&pncm->lfStatusFont);
	FixupLogfont(&pncm->lfMessageFont);
	FixupLogfont(plfIcon);
}

BOOL IsCurrentFaceNamesDifferent()
{
	TCHAR lfFaceName[LF_FACESIZE];
	LoadString(g_hInstDll, IDS_SYSTEMFONTNAME, lfFaceName, ARRAYSIZE(lfFaceName));
	NONCLIENTMETRICS ncm;
	LOGFONT lfIcon;
	GetNonClientMetrics(&ncm, &lfIcon);
	if(		0 != lstrcmp(lfFaceName, ncm.lfCaptionFont.lfFaceName)
		||	0 != lstrcmp(lfFaceName, ncm.lfSmCaptionFont.lfFaceName)
		||	0 != lstrcmp(lfFaceName, ncm.lfMenuFont.lfFaceName)
		||	0 != lstrcmp(lfFaceName, ncm.lfStatusFont.lfFaceName)
		||	0 != lstrcmp(lfFaceName, ncm.lfMessageFont.lfFaceName)
		||	0 != lstrcmp(lfFaceName, lfIcon.lfFaceName) )
	{
		return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\resource.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AccWiz.rc
//
#define IDR_MENU                        1
#define IDR_MENUWITHSELECTED            2
#define IDS_WIZNOOPTIONSSELECTEDTITLE   4
#define IDS_WIZNOOPTIONSSELECTEDSUBTITLE 5
#define IDS_GENERICPAGETITLE            6
#define IDS_GENERICPAGESUBTITLE         7
#define IDS_WIZFILTERKEYSTITLE          8
#define IDS_WIZFILTERKEYSSUBTITLE       9
#define IDS_WIZSTICKYKEYSTITLE          10
#define IDM_NORMAL                      10
#define IDS_WIZSTICKYKEYSSUBTITLE       11
#define IDM_DISABLED                    11
#define IDS_WIZTOGGLEKEYSTITLE          12
#define IDM_SELECTED                    12
#define IDS_WIZTOGGLEKEYSSUBTITLE       13
#define IDS_WIZSHOWEXTRAKEYBOARDHELPTITLE 14
#define IDS_WIZSHOWEXTRAKEYBOARDHELPSUBTITLE 15
#define IDS_WIZHOTKEYANDNOTIFICATIONTITLE 18
#define IDS_WIZHOTKEYANDNOTIFICATIONSUBTITLE 19
#define IDS_WIZSAVEASDEFAULTTITLE       20
#define IDS_WIZSAVEASDEFAULTSUBTITLE    21
#define IDS_WIZACCESSTIMEOUTTITLE       22
#define IDS_WIZACCESSTIMEOUTSUBTITLE    23
#define IDS_WIZSAVETOFILETITLE          24
#define IDS_WIZSAVETOFILESUBTITLE       25
#define IDS_WIZOPTTITLE                 26
#define IDS_WIZOPTSUBTITLE              27
#define IDS_MSEWIZMOUSEKEYSTITLE        90
#define IDS_MSEWIZMOUSEKEYSSUBTITLE     91
#define IDS_MSEWIZMOUSECURSORTITLE      92
#define IDS_MSEWIZMOUSECURSORSUBTITLE   93
#define IDS_MSEWIZBUTTONCONFIGTITLE     94
#define IDS_MSEWIZBUTTONCONFIGSUBTITLE  95
#define IDC_GROUPBOX_2                  96
#define IDS_MSEWIZMOUSESPEEDTITLE       96
#define IDC_GROUPBOX_3                  97
#define IDS_MSEWIZMOUSESPEEDSUBTITLE    97
#define IDS_MSEWIZMOUSETRAILSTITLE      98
#define IDS_MSEWIZMOUSETRAILSSUBTITLE   99
#define MOUSE_LEFTHAND                  100
#define IDB_MOUSE                       100
#define MOUSE_RIGHTHAND                 101
#define IDI_APP_ICON                    101
#define KBLINK_EDIT                     103
#define KCURSOR_BLINK                   104
#define KCURSOR_RATE                    105
#define KCURSOR_WIDTH                   108
#define IDD_WIZFINISH                   109
#define IDC_SELECTDRAG                  109
#define IDI_CURSOR_SMALL_BLACK          109
#define IDS_SNDWIZSENTRYSHOWSOUNDSTITLE 110
#define IDC_OBJECTMENU                  110
#define IDS_SNDWIZSENTRYSHOWSOUNDSSUBTITLE 111
#define IDI_CURSOR_SMALL_INVERTING      111
#define IDI_CURSOR_MEDIUM_BLACK         112
#define IDS_SNDWIZSENTRYTITLE           112
#define IDI_CURSOR_MEDIUM_INVERTING     113
#define IDS_SNDWIZSENTRYSUBTITLE        113
#define IDS_SNDWIZSHOWSOUNDSTITLE       114
#define IDS_SNDWIZSHOWSOUNDSSUBTITLE    115
#define IDB_ACCWIZ                      128
#define IDB_ACCMARK                     129
#define IDD_CARET                       132
#define IDD_WIZOPTIONS                  154
#define IDD_WIZWORKSTATIONDEFAULT       176
#define IDD_WIZNOOPTIONSSELECTED        177
#define IDD_MSEWIZMOUSECURSOR           181
#define IDD_SNDWIZSENTRYSHOWSOUNDS      182
#define IDD_MSEWIZMOUSEKEYS             183
#define IDD_KBDWIZSTICKYKEYS            184
#define IDD_KBDWIZTOGGLEKEYS            186
#define IDD_KBDWIZSHOWEXTRAKEYBOARDHELP 187
#define IDI_CURSOR_LARGE_INVERTING      242
#define IDI_CURSOR_SMALL_WHITE          243
#define IDI_CURSOR_MEDIUM_WHITE         244
#define IDI_CURSOR_LARGE_WHITE          245
#define IDI_CURSOR_LARGE_BLACK          246
#define IDS_SNDSEN_SSWF_NONE            300
#define IDS_SNDSEN_SSWF_TITLE           301
#define IDS_SNDSEN_SSWF_WINDOW          302
#define IDS_SNDSEN_SSWF_DISPLAY         303
#define IDS_SNDSEN_SSTF_NONE            304
#define IDS_SNDSEN_SSTF_CHARS           305
#define IDS_SNDSEN_SSTF_BORDER          306
#define IDS_SNDSEN_SSTF_DISPLAY         307
#define IDD_MSEWIZBUTTONCONFIG          400
#define IDS_WELCOMETITLE                400
#define IDD_WIZSAVETOFILE               402
#define IDD_WIZWELCOME2                 404
#define IDD_FNTWIZSCROLLBAR             405
#define IDD_PREV_COLOR                  410
#define IDD_WIZACCESSTIMEOUT            417
#define IDD_MSEWIZMOUSEKEYS1            419
#define IDD_SNDWIZSENTRYSHOWSOUNDS2     422
#define IDD_WIZWELCOME                  423
#define IDD_PREV_ICON2                  424
#define IDD_MSEWIZMOUSESPEED            425
#define IDD_KBDWIZFILTERKEYS1           426
#define IDD_KBDWIZFILTERKEYS2           427
#define IDD_WIZLAUNCHMAGNIFY            428
#define IDD_WIZLAUNCHSCREENREADER       429
#define IDD_WIZLAUNCHONSCREENKEYBOARD   430
#define IDD_MSEWIZMOUSETRAILS           431
#define IDD_WIZNEWWELCOME               432
#define IDC_MK_TOPSPEED                 603
#define IDC_MK_ACCEL                    604
#define IDC_CHECKSAVESETTINGTODEFAULT   1000
#define IDC_DOBLIND                     1006
#define IDC_DOKEYBOARDMOUSE             1007
#define IDC_DOSOUND                     1008
#define IDC_DOADMIN                     1009
#define IDC_PERMENU                     1010
#define IDC_TRANSPARENT1                1011
#define IDC_MK_NLOFF                    1018
#define IDC_MK_NLON                     1019
#define IDC_FK_LBL_TESTBOX              1024
#define IDC_BK_TIME_LBL_SHORT           1025
#define IDC_BK_TIME_LBL_LONG            1026
#define IDC_MK_LBL1                     1033
#define IDC_MK_LBL2                     1034
#define IDC_MK_LBL3                     1035
#define IDC_MK_LBL4                     1036
#define IDC_TO_ENABLE                   1037
#define IDC_MK_LBL5                     1037
#define IDC_TO_TIMEOUTVAL               1038
#define IDC_MK_LBL6                     1038
#define IDC_MK_LBL7                     1039
#define IDC_RADIO1                      1042
#define IDC_RADIO2                      1043
#define IDC_RADIO3                      1044
#define IDC_RADIO4                      1045
#define IDC_RADIO5                      1046
#define IDC_RADIO6                      1047
#define IDC_RADIO7                      1048
#define IDC_BTNBROWSE                   1048
#define IDC_FK_TESTBOX                  1049
#define IDC_RADIO8                      1049
#define IDC_RADIO9                      1050
#define IDC_RADIO10                     1051
#define IDC_SWITCHRESOLUTION            1053
#define IDC_CHANGEFONTS                 1054
#define IDC_USEMAGNIFY                  1055
#define IDC_BK_TIME                     1056
#define IDC_SZRESMESSAGE                1056
#define IDC_BK_BOUNCERATE               1057
#define IDC_BTNRESTORETODEFAULT         1057
#define IDC_PREVLIST                    1074
#define IDC_RADIOYES                    1077
#define IDC_BK_TIME_LBL2                1088
#define IDC_TO_DISABLE                  1089
#define IDC_MOUSEPIC2                   1097
#define IDC_MOUSEPIC1                   1098
#define IDC_SLIDER1                     1105
#define IDC_SELECTIONMINTEXT            1107
#define IDC_SELECTIONICONSIZE           1108
#define IDC_SELECTIONSCROLLBAR          1109
#define IDC_SZCHANGES                   1110
#define IDC_RADIONO                     1111
#define IDC_RADIOBEEPYES                1113
#define IDC_RADIOBEEPNO                 1114
#define IDC_TEXT1                       1116
#define IDC_TEXT2                       1117
#define IDC_TEXT3                       1118
#define IDC_CHECK1                      1119
#define IDC_ICON1                       1120
#define IDC_ICON2                       1121
#define IDC_ICON3                       1122
#define IDC_SCROLL1                     1123
#define IDC_SCROLL2                     1124
#define IDC_SCROLL3                     1125
#define IDC_MIN                         1125
#define IDC_SCROLL4                     1126
#define IDS_ACTIVE                      1450
#define IDS_INACTIVE                    1451
#define IDS_MINIMIZED                   1452
#define IDS_ICONTITLE                   1453
#define IDS_NORMAL                      1454
#define IDS_DISABLED                    1455
#define IDS_SELECTED                    1456
#define IDS_MSGBOX                      1457
#define IDS_BUTTONTEXT                  1458
#define IDS_SMCAPTION                   1459
#define IDS_WINDOWTEXT                  1460
#define IDS_MSGBOXTEXT                  1461
#define IDC_LOOKPREV                    1470
#define IDS_WIZSAVECHANGESMESSAGETITLE  1501
#define IDS_WIZSAVECHANGESMESSAGETEXT   1502
#define IDS_WIZERRORLOADINGFILETITLE    1503
#define IDS_WIZERRORLOADINGFILETEXT     1504
#define IDS_WIZERRORNEEDADMINTITLE      1505
#define IDS_WIZERRORNEEDADMINTEXT       1506
#define IDS_WIZERRORSAVINGFILETITLE     1507
#define IDS_WIZERRORSAVINGFILETEXT      1508
#define IDS_WIZCHANGESHAPPENINGTITLE    1509
#define IDS_WIZCHANGESHAPPENINGTEXT     1510
#define IDS_WIZCANCELCHANGESTITLE       1511
#define IDS_WIZCANCELCHANGESTEXT        1512
#define IDS_ICONSIZENAMENORMAL          1600
#define IDS_ICONSIZENAMELARGE           1601
#define IDS_ICONSIZENAMEEXTRALARGE      1602
#define IDS_DEFAULTSAVEFILENAME         1700
#define IDS_FILTERNAME                  1701
#define IDS_FILTER                      1702
#define IDS_FILTER2                     1703
#define IDS_DISPLAYRESOLUTIONINFO       1709
#define IDS_SCHEME_HIGHCONTRASTBLACK    2000
#define IDS_SCHEME_HIGHCONTRASTWHITE    2001
#define IDS_SCHEME_HIGHCONTRASTBLACKALTERNATE 2002
#define IDS_SCHEME_HIGHCONTRASTWHITEALTERNATE 2003
#define IDS_SCHEME_WINDOWSSTANDARD      2004
#define IDS_SCHEME_CURRENTCOLORSCHEME   2005
#define IDS_SCHEME_BLAHBLAHBLAH         2006
#define IDC_BIGBOLDTITLE                2090
#define IDC_BOLDTITLE                   2091
#define IDC_BIGTITLE                    2092
#define IDB_MOUSE2                      2570
#define IDS_LKPREV_SCROLLSIZES          3000
#define IDS_LKPREV_MINTEXTSIZES         3001
#define IDS_LKPREV_BORDERSIZES          3002
#define IDS_LKPREV_WELCOME_MINTEXTSIZES 3003
#define IDS_LKPREV_MINTEXTTITLE         3100
#define IDS_LKPREV_MINTEXTSUBTITLE      3101
#define IDS_LKPREV_COLORTITLE           3102
#define IDS_LKPREV_COLORSUBTITLE        3103
#define IDS_LKPREV_SCROLLBARTITLE       3104
#define IDS_LKPREV_SCROLLBARSUBTITLE    3105
#define IDS_LKPREV_BORDERTITLE          3106
#define IDS_LKPREV_BORDERSUBTITLE       3107
#define IDS_LKPREV_ICONTITLE            3108
#define IDS_LKPREV_ICONSUBTITLE         3109
#define IDS_WELCOME2TITLE               3110
#define IDS_WELCOME2SUBTITLE            3111
#define IDS_ICONPREV_ITEM1              3112
#define IDS_ICONPREV_ITEM2              3113
#define IDS_ICONPREV_ITEM3              3114
#define IDS_ICONPREV_ITEM4              3115
#define IDS_ICONPREV_ITEM5              3116
#define IDS_ICONPREV_ITEM6              3117
#define IDS_BIGBOLDFONTSIZE             4000
#define IDS_BIGBOLDFONTNAME             4001
#define IDS_BOLDFONTSIZE                4002
#define IDS_BOLDFONTNAME                4003
#define IDS_BIGFONTSIZE                 4004
#define IDS_BIGFONTNAME                 4005
#define IDS_SYSTEMFONTNAME              4006
#define IDS_FONTCHARSET                 4100
#define IDS_WINDOWSDEFAULTSIZES         4200
#define IDS_PREVIEWMENUTEXT             4501
#define IDS_CURSOR_SCHEME_WINDOWS_STANDARD_LARGE 5002
#define IDS_CURSOR_SCHEME_WINDOWS_STANDARD_EXTRALARGE 5003
#define IDS_CURSOR_SCHEME_WINDOWS_BLACK 5004
#define IDS_CURSOR_SCHEME_WINDOWS_BLACK_LARGE 5005
#define IDS_CURSOR_SCHEME_WINDOWS_BLACK_EXTRALARGE 5006
#define IDS_CURSOR_SCHEME_WINDOWS_INVERTED 5007
#define IDS_CURSOR_SCHEME_WINDOWS_INVERTED_LARGE 5008
#define IDS_CURSOR_SCHEME_WINDOWS_INVERTED_EXTRALARGE 5009
#define IDS_WELCOMETEXT1                6001
#define IDS_WELCOMETEXT2                6002
#define IDS_WELCOMETEXT3                6003
#define IDS_WELCOMETEXT4                6004
#define IDS_CHANGESFILTERKEYS           7000
#define IDS_CHANGESMOUSEKEYS            7001
#define IDS_CHANGESSERIALKEYS           7002
#define IDS_CHANGESSTICKYKEYS           7003
#define IDS_CHANGESTOGGLEKEYS           7004
#define IDS_CHANGESSOUNDSENTRY          7005
#define IDS_CHANGESACCESSTIMEOUT        7006
#define IDS_CHANGESHIGHCONTRAST         7007
#define IDS_CHANGESShowSounds           7008
#define IDS_CHANGESShowExtraKeyboardHelp 7009
#define IDS_CHANGESSwapMouseButtons     7010
#define IDS_CHANGESCOLOR                7011
#define IDS_CHANGESNONCLIENTMETRICS     7012
#define IDS_CHANGESMouseSpeed           7013
#define IDS_CHANGESMouseTrails          7014
#define IDS_CHANGESIconSize             7015
#define IDS_CHANGES16                   7016
#define IDS_CHANGESCursorScheme         7016
#define IDS_CHANGES17                   7017
#define IDS_CHANGESScrollWidth          7017
#define IDS_CHANGES18                   7018
#define IDS_CHANGESBorderWidth          7018
#define IDS_CHANGES19                   7019
#define IDS_CHANGES19a                  7019
#define IDS_CHANGESCaretWidth           7020
#define IDS_CHANGESBlinkRate            7021
#define IDS_CHANGES22                   7022
#define IDS_CHANGESNOCHANGES            7023
#define IDC_WEBLINK                     7050
#define IDS_NAMEOFMAGNIFIER             8001
#define IDS_WIZFILTERKEYSETTING         8002
#define IDS_MSEWIZMOUSEKEYSETTING       8003
#define IDS_MSEWIZMOUSEKEYSETSUB        8004
#define IDS_TEXTSIZESUBTITLE            8004
#define IDS_TEXTSIZETITLE               8005
#define IDS_ENABLEWEB                   8006
#define IDS_CARETTITLE                  8007
#define IDS_CARETSUBTITLE               8008
#define IDS_FRIENDLYTYPENAME            16
#define IDS_FRIENDLYTYPENAMETIP         17

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1126
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\schemes.h ===
//Copyright (c) 1997-2000 Microsoft Corporation

#ifndef _INC_SCHEMES_H
#define _INC_SCHEMES_H

// HACK - THESE VALUES ARE HARD CODED
#define COLOR_MAX_95_NT4		25
#if(WINVER >= 0x0501)
#define COLOR_MAX_97_NT5		31
#elif(WINVER == 0x0500)
#define COLOR_MAX_97_NT5		29
#else
#define COLOR_MAX_97_NT5		25
#endif

#define MAX_THEME_SZ 512
#define MAX_NUM_SZ 20
#define DEF_SPACING 43  // default horizontal and vertical icon spacing

#define CONTROL_PANEL_DESKTOP TEXT("Control Panel\\Desktop")
#define CURSOR_BLINK_RATE TEXT("CursorBlinkRate")
#define DEFAULT_BLINK_RATE 530
DWORD WINAPI RegQueryStrDW(DWORD dwDefault, HKEY hkey, LPTSTR lpSubKey, LPTSTR lpValueName);
BOOL RegSetStrDW(HKEY hkey, LPTSTR lpSection, LPCTSTR lpKeyName, DWORD dwValue);

#include "resource.h"

#include "CurSchme.h"

// Specify all external variables
extern PTSTR s_pszColorNames[]; // JMC: HACK
extern TCHAR g_szColors[]; // = TEXT("colors");           // colors section name

// Location of the Colors subkey in Registry; Defined in RegStr.h
extern TCHAR szRegStr_Colors[]; // = REGSTR_PATH_COLORS;

extern TCHAR g_winScheme[];

// Scheme data used locally by this app - NOTE: This structure
// does NOT use or need the A and W forms for its members.  The other schemedata's
// MUST use the A and W forms since that's how they are stored in the registry
typedef struct {
	int nNameStringId;       // the rid of the name of the color scheme
    TCHAR szNameIndexId[MAX_NUM_SZ]; // the index into HKCU\Control Panel\Appearance\New Schemes
	int nColorsUsed;
    COLORREF rgb[COLOR_MAX_97_NT5];
} SCHEMEDATALOCAL;


struct PORTABLE_NONCLIENTMETRICS
{
	// Non-ClientMetric storage area
	int m_iBorderWidth;
	int m_iScrollWidth;
	int m_iScrollHeight;
	int m_iCaptionWidth;
	int m_iCaptionHeight;
	int m_lfCaptionFont_lfHeight;
	int m_lfCaptionFont_lfWeight;
	int m_iSmCaptionWidth;
	int m_iSmCaptionHeight;
	int m_lfSmCaptionFont_lfHeight;
	int m_lfSmCaptionFont_lfWeight;
	int m_iMenuWidth;
	int m_iMenuHeight;
	int m_lfMenuFont_lfHeight;
	int m_lfMenuFont_lfWeight;
	int m_lfStatusFont_lfHeight;
	int m_lfStatusFont_lfWeight;
	int m_lfMessageFont_lfHeight;
	int m_lfMessageFont_lfWeight;
	int m_lfIconWindowsDefault_lfHeight;
	int m_lfIconWindowsDefault_lfWeight;

	int m_nFontFaces; // 0 = NoChanges, 1 = Use WindowsDefault font face

	void SetToWindowsDefault()
	{
		m_nFontFaces = 1;

		int rgnValues[MAX_DISTINCT_VALUES];
		int nCountValues;
		LoadArrayFromStringTable(IDS_WINDOWSDEFAULTSIZES, rgnValues, &nCountValues);
		_ASSERTE(21 == nCountValues);
		if(21 != nCountValues)
		{
			// Below is the hard-coded defaults for the window metrics
			m_iBorderWidth = 1;
			m_iScrollWidth = 16;
			m_iScrollHeight = 16;
			m_iCaptionWidth = 18;
			m_iCaptionHeight = 18;
			m_lfCaptionFont_lfHeight = -11;
			m_lfCaptionFont_lfWeight = 700;
			m_iSmCaptionWidth = 15;
			m_iSmCaptionHeight = 15;
			m_lfSmCaptionFont_lfHeight = -11;
			m_lfSmCaptionFont_lfWeight = 700;
			m_iMenuWidth = 18;
			m_iMenuHeight = 18;
			m_lfMenuFont_lfHeight = -11;
			m_lfMenuFont_lfWeight = 400;
			m_lfStatusFont_lfHeight = -11;
			m_lfStatusFont_lfWeight = 400;
			m_lfMessageFont_lfHeight = -11;
			m_lfMessageFont_lfWeight = 400;
			m_lfIconWindowsDefault_lfHeight = -11;
			m_lfIconWindowsDefault_lfWeight = 400;
		}
		else
		{
			m_iBorderWidth = rgnValues[0];
			m_iScrollWidth = rgnValues[1];
			m_iScrollHeight = rgnValues[2];
			m_iCaptionWidth = rgnValues[3];
			m_iCaptionHeight = rgnValues[4];
			m_lfCaptionFont_lfHeight = rgnValues[5];
			m_lfCaptionFont_lfWeight = rgnValues[6];
			m_iSmCaptionWidth = rgnValues[7];
			m_iSmCaptionHeight = rgnValues[8];
			m_lfSmCaptionFont_lfHeight = rgnValues[9];
			m_lfSmCaptionFont_lfWeight = rgnValues[10];
			m_iMenuWidth = rgnValues[11];
			m_iMenuHeight = rgnValues[12];
			m_lfMenuFont_lfHeight = rgnValues[13];
			m_lfMenuFont_lfWeight = rgnValues[14];
			m_lfStatusFont_lfHeight = rgnValues[15];
			m_lfStatusFont_lfWeight = rgnValues[16];
			m_lfMessageFont_lfHeight = rgnValues[17];
			m_lfMessageFont_lfWeight = rgnValues[18];
			m_lfIconWindowsDefault_lfHeight = rgnValues[19];
			m_lfIconWindowsDefault_lfWeight = rgnValues[20];
		}
	}

	void LoadOriginal()
	{
		NONCLIENTMETRICS ncmTemp;
		LOGFONT lfIcon;
		GetNonClientMetrics(&ncmTemp, &lfIcon);

		m_iBorderWidth = ncmTemp.iBorderWidth;
		m_iScrollWidth = ncmTemp.iScrollWidth;
		m_iScrollHeight = ncmTemp.iScrollHeight;
		m_iCaptionWidth = ncmTemp.iCaptionWidth;
		m_iCaptionHeight = ncmTemp.iCaptionHeight;
		m_lfCaptionFont_lfHeight = ncmTemp.lfCaptionFont.lfHeight;
		m_lfCaptionFont_lfWeight = ncmTemp.lfCaptionFont.lfWeight;
		m_iSmCaptionWidth = ncmTemp.iSmCaptionWidth;
		m_iSmCaptionHeight = ncmTemp.iSmCaptionHeight;
		m_lfSmCaptionFont_lfHeight = ncmTemp.lfSmCaptionFont.lfHeight;
		m_lfSmCaptionFont_lfWeight = ncmTemp.lfSmCaptionFont.lfWeight;
		m_iMenuWidth = ncmTemp.iMenuWidth;
		m_iMenuHeight = ncmTemp.iMenuHeight;
		m_lfMenuFont_lfHeight = ncmTemp.lfMenuFont.lfHeight;
		m_lfMenuFont_lfWeight = ncmTemp.lfMenuFont.lfWeight;
		m_lfStatusFont_lfHeight = ncmTemp.lfStatusFont.lfHeight;
		m_lfStatusFont_lfWeight = ncmTemp.lfStatusFont.lfWeight;
		m_lfMessageFont_lfHeight = ncmTemp.lfMessageFont.lfHeight;
		m_lfMessageFont_lfWeight = ncmTemp.lfMessageFont.lfWeight;
		m_lfIconWindowsDefault_lfHeight = lfIcon.lfHeight;
		m_lfIconWindowsDefault_lfWeight = lfIcon.lfWeight;

		m_nFontFaces = 0;
	}

	void ApplyChanges() const;

};

struct WIZSCHEME
{
	WIZSCHEME()
	{
		ZeroMemory(this, sizeof(*this));
		m_cbSize = sizeof(*this);
		m_dwVersion = 0x000000FF;
		ClearTheme();
		ClearWallpaper();
        m_nSelectedSize = -1;
        m_szSelectedStyle[0] = 0;
	}
	DWORD m_cbSize;
	DWORD m_dwVersion;

	COLORREF m_rgb[COLOR_MAX_97_NT5];
	void LoadOriginal();

	FILTERKEYS m_FILTERKEYS;
	MOUSEKEYS m_MOUSEKEYS;
	STICKYKEYS m_STICKYKEYS;
	TOGGLEKEYS m_TOGGLEKEYS;
	SOUNDSENTRY m_SOUNDSENTRY;
	ACCESSTIMEOUT m_ACCESSTIMEOUT;
//	SERIALKEYS m_SERIALKEYS;

	BOOL m_bShowSounds;
	BOOL m_bShowExtraKeyboardHelp;
	BOOL m_bSwapMouseButtons;
	int m_nMouseTrails;
	int m_nMouseSpeed;
	int m_nIconSize;
	int m_nCursorScheme;
	// int m_nScrollWidth;
	// int m_nBorderWidth;

	PORTABLE_NONCLIENTMETRICS m_PortableNonClientMetrics;


#ifdef _DEBUG
	void Dump()
	{
		FILE *pStream = fopen( "c:\\txt.acw", "w" );
		if(pStream)
		{
			for(int i=0;i<COLOR_MAX_97_NT5;i++)
				fprintf(pStream, "m_rgb[%2i] = RGB(%3i,%3i,%3i);\r\n", i, GetRValue(m_rgb[i]), GetGValue(m_rgb[i]), GetBValue(m_rgb[i]));
#define TEMP_MAC(xxx, yyy) fprintf(pStream, "m_" #xxx "." #yyy " = %i;\r\n", m_##xxx.yyy)
			TEMP_MAC(FILTERKEYS, cbSize);
			TEMP_MAC(FILTERKEYS, dwFlags);
			TEMP_MAC(FILTERKEYS, iWaitMSec);
			TEMP_MAC(FILTERKEYS, iDelayMSec);
			TEMP_MAC(FILTERKEYS, iRepeatMSec);
			TEMP_MAC(FILTERKEYS, iBounceMSec);

			TEMP_MAC(MOUSEKEYS, cbSize);
			TEMP_MAC(MOUSEKEYS, dwFlags);
			TEMP_MAC(MOUSEKEYS, iMaxSpeed);
			TEMP_MAC(MOUSEKEYS, iTimeToMaxSpeed);
			TEMP_MAC(MOUSEKEYS, iCtrlSpeed);
			TEMP_MAC(MOUSEKEYS, dwReserved1);
			TEMP_MAC(MOUSEKEYS, dwReserved2);

			TEMP_MAC(STICKYKEYS, cbSize);
			TEMP_MAC(STICKYKEYS, dwFlags);

			TEMP_MAC(TOGGLEKEYS, cbSize);
			TEMP_MAC(TOGGLEKEYS, dwFlags);

			TEMP_MAC(SOUNDSENTRY, cbSize);
			TEMP_MAC(SOUNDSENTRY, dwFlags);
			TEMP_MAC(SOUNDSENTRY, iFSTextEffect);
			TEMP_MAC(SOUNDSENTRY, iFSTextEffectMSec);
			TEMP_MAC(SOUNDSENTRY, iFSTextEffectColorBits);
			TEMP_MAC(SOUNDSENTRY, iFSGrafEffect);
			TEMP_MAC(SOUNDSENTRY, iFSGrafEffectMSec);
			TEMP_MAC(SOUNDSENTRY, iFSGrafEffectColor);
			TEMP_MAC(SOUNDSENTRY, iWindowsEffect);
			TEMP_MAC(SOUNDSENTRY, iWindowsEffectMSec);
			TEMP_MAC(SOUNDSENTRY, lpszWindowsEffectDLL);
			TEMP_MAC(SOUNDSENTRY, iWindowsEffectOrdinal);

			TEMP_MAC(ACCESSTIMEOUT, cbSize);
			TEMP_MAC(ACCESSTIMEOUT, dwFlags);
			TEMP_MAC(ACCESSTIMEOUT, iTimeOutMSec);

#define TEMP_MAC2(xxx) fprintf(pStream, #xxx " = %i;\r\n", xxx)
			TEMP_MAC2(m_bShowSounds);
			TEMP_MAC2(m_bShowExtraKeyboardHelp);
			TEMP_MAC2(m_bSwapMouseButtons);
			TEMP_MAC2(m_nMouseTrails);
			TEMP_MAC2(m_nMouseSpeed);
			TEMP_MAC2(m_nIconSize);
			TEMP_MAC2(m_nCursorScheme);

			NONCLIENTMETRICS ncm;
			LOGFONT lf;
			GetNonClientMetrics(&ncm, &lf);

#define TEMP_MAC3(xxx) fprintf(pStream, "m_ncmWindowsDefault." #xxx " = %i;\n", ncm.xxx)
#define TEMP_MAC4(xxx) fprintf(pStream, "m_ncmWindowsDefault." #xxx ".lfHeight = %i;\nm_ncmWindowsDefault." #xxx ".lfWeight = %i;\n", ncm.xxx.lfHeight, ncm.xxx.lfWeight)
			TEMP_MAC3(cbSize);
			TEMP_MAC3(iBorderWidth);
			TEMP_MAC3(iScrollWidth);
			TEMP_MAC3(iScrollHeight);
			TEMP_MAC3(iCaptionWidth);
			TEMP_MAC3(iCaptionHeight);
			TEMP_MAC4(lfCaptionFont);
			TEMP_MAC3(iSmCaptionWidth);
			TEMP_MAC3(iSmCaptionHeight);
			TEMP_MAC4(lfSmCaptionFont);
			TEMP_MAC3(iMenuWidth);
			TEMP_MAC3(iMenuHeight);
			TEMP_MAC4(lfMenuFont);
			TEMP_MAC4(lfStatusFont);
			TEMP_MAC4(lfMessageFont);

			fprintf(pStream, "m_lfIconWindowsDefault.lfHeight = %i;\nm_lfIconWindowsDefault.lfWeight = %i;\n", lf.lfHeight, lf.lfWeight);


			// Print for string table
#undef TEMP_MAC3
#undef TEMP_MAC4
#define TEMP_MAC3(xxx) fprintf(pStream, "%i ", ncm.xxx)
#define TEMP_MAC4(xxx) fprintf(pStream, "%i %i ", ncm.xxx.lfHeight, ncm.xxx.lfWeight)
			TEMP_MAC3(cbSize);
			TEMP_MAC3(iBorderWidth);
			TEMP_MAC3(iScrollWidth);
			TEMP_MAC3(iScrollHeight);
			TEMP_MAC3(iCaptionWidth);
			TEMP_MAC3(iCaptionHeight);
			TEMP_MAC4(lfCaptionFont);
			TEMP_MAC3(iSmCaptionWidth);
			TEMP_MAC3(iSmCaptionHeight);
			TEMP_MAC4(lfSmCaptionFont);
			TEMP_MAC3(iMenuWidth);
			TEMP_MAC3(iMenuHeight);
			TEMP_MAC4(lfMenuFont);
			TEMP_MAC4(lfStatusFont);
			TEMP_MAC4(lfMessageFont);

			fprintf(pStream, "%i %i\n", lf.lfHeight, lf.lfWeight);

			fclose(pStream);
		}

	}
#endif

	void SetToWindowsDefault()
	{
		m_rgb[ 0] = RGB(212,208,200); //192,192,192
		m_rgb[ 1] = RGB( 58,110,165);
		m_rgb[ 2] = RGB( 10, 36,106); // 0,0,128
		m_rgb[ 3] = RGB(128,128,128);
		m_rgb[ 4] = RGB(212,208,200); //192,192,192
		m_rgb[ 5] = RGB(255,255,255);
		m_rgb[ 6] = RGB(  0,  0,  0);
		m_rgb[ 7] = RGB(  0,  0,  0);
		m_rgb[ 8] = RGB(  0,  0,  0);
		m_rgb[ 9] = RGB(255,255,255);
		m_rgb[10] = RGB(212,208,200); //192,192,192
		m_rgb[11] = RGB(212,208,200); //192,192,192
		m_rgb[12] = RGB(128,128,128);
		m_rgb[13] = RGB( 10, 36,106); // 0,0,128
		m_rgb[14] = RGB(255,255,255);
		m_rgb[15] = RGB(212,208,200); //192,192,192
		m_rgb[16] = RGB(128,128,128);
		m_rgb[17] = RGB(128,128,128);
		m_rgb[18] = RGB(  0,  0,  0);
		m_rgb[19] = RGB(212,208,200); //192,192,192
		m_rgb[20] = RGB(255,255,255);
		m_rgb[21] = RGB( 81, 81, 75); // 0,0,0
		m_rgb[22] = RGB(236,234,231); // 192,192,192
		m_rgb[23] = RGB(  0,  0,  0);
		m_rgb[24] = RGB(255,255,225);
		m_rgb[25] = RGB(181,181,181); // button alternate face
		m_rgb[26] = RGB(  0,  0,128); 
		m_rgb[27] = RGB( 166,202,240); // 16,132,208
		m_rgb[28] = RGB(192,192,192); // 181,181,181

		ClearTheme();
		ClearWallpaper();

		m_FILTERKEYS.cbSize = 24;
		m_FILTERKEYS.dwFlags = 126;
		m_FILTERKEYS.iWaitMSec = 1000;
		m_FILTERKEYS.iDelayMSec = 1000; //500
		m_FILTERKEYS.iRepeatMSec = 500; //1000
		m_FILTERKEYS.iBounceMSec = 0;
		m_MOUSEKEYS.cbSize = 28;
		m_MOUSEKEYS.dwFlags = 62; //58
		m_MOUSEKEYS.iMaxSpeed = 40;
		m_MOUSEKEYS.iTimeToMaxSpeed = 300;
		m_MOUSEKEYS.iCtrlSpeed = 80;
		m_MOUSEKEYS.dwReserved1 = 0;
		m_MOUSEKEYS.dwReserved2 = 0;
		m_STICKYKEYS.cbSize = 8;
		m_STICKYKEYS.dwFlags = 510; //506
		m_TOGGLEKEYS.cbSize = 8;
		m_TOGGLEKEYS.dwFlags = 30; //26
		m_SOUNDSENTRY.cbSize = 48;
		m_SOUNDSENTRY.dwFlags = 2;
		m_SOUNDSENTRY.iFSTextEffect = 2;
		m_SOUNDSENTRY.iFSTextEffectMSec = 500;
		m_SOUNDSENTRY.iFSTextEffectColorBits = 0;
		m_SOUNDSENTRY.iFSGrafEffect = 3;
		m_SOUNDSENTRY.iFSGrafEffectMSec = 500;
		m_SOUNDSENTRY.iFSGrafEffectColor = 0;
		m_SOUNDSENTRY.iWindowsEffect = 1;
		m_SOUNDSENTRY.iWindowsEffectMSec = 500;
		m_SOUNDSENTRY.lpszWindowsEffectDLL = 0;
		m_SOUNDSENTRY.iWindowsEffectOrdinal = 0;
		m_ACCESSTIMEOUT.cbSize = 12;
		m_ACCESSTIMEOUT.dwFlags = 2; //3
		m_ACCESSTIMEOUT.iTimeOutMSec = 300000;
		m_bShowSounds = 0;
		m_bShowExtraKeyboardHelp = 0;
		m_bSwapMouseButtons = 0;
		m_nMouseTrails = 0;
		m_nMouseSpeed = 10;
        m_dwCaretWidth = 1;
        m_uCursorBlinkTime = 530;
		m_nIconSize = 32;
		m_nCursorScheme = 1;


		_ASSERTE(sizeof(m_FILTERKEYS) == m_FILTERKEYS.cbSize);
		_ASSERTE(sizeof(m_MOUSEKEYS) == m_MOUSEKEYS.cbSize);
		_ASSERTE(sizeof(m_STICKYKEYS) == m_STICKYKEYS.cbSize);
		_ASSERTE(sizeof(m_TOGGLEKEYS) == m_TOGGLEKEYS.cbSize);
		_ASSERTE(sizeof(m_SOUNDSENTRY) == m_SOUNDSENTRY.cbSize);
		_ASSERTE(sizeof(m_ACCESSTIMEOUT) == m_ACCESSTIMEOUT.cbSize);

		m_PortableNonClientMetrics.SetToWindowsDefault();

	}

	void AddChangesLine(int nId, LPTSTR szBuffer)
	{
		TCHAR szTemp[80];
		LoadString(g_hInstDll, nId, szTemp, ARRAYSIZE(szTemp));
		lstrcat(szBuffer, szTemp);
		lstrcat(szBuffer, __TEXT("\r\n"));
	}

	void ReportChanges(const WIZSCHEME &schemeOriginal, HWND hwndChanges)
	{
		TCHAR szChanges[80*20];
		szChanges[0] = 0;

		// Check for change in colors
		if(0 != memcmp(schemeOriginal.m_rgb, m_rgb, sizeof(m_rgb)))
			AddChangesLine(IDS_CHANGESCOLOR, szChanges);

#define TEST_CHANGES(xxx) if(0 != memcmp(&schemeOriginal.m_##xxx, &m_##xxx, sizeof(schemeOriginal.m_##xxx))) AddChangesLine(IDS_CHANGES##xxx, szChanges)
 		TEST_CHANGES(FILTERKEYS);
		TEST_CHANGES(MOUSEKEYS);
		TEST_CHANGES(STICKYKEYS);
		TEST_CHANGES(TOGGLEKEYS);
		TEST_CHANGES(SOUNDSENTRY);
		TEST_CHANGES(ACCESSTIMEOUT);
//		TEST_CHANGES(SERIALKEYS);

#define TEST_CHANGES2(xxx) if(schemeOriginal.m_b##xxx != m_b##xxx) AddChangesLine(IDS_CHANGES##xxx, szChanges)
 		TEST_CHANGES2(ShowSounds);
		TEST_CHANGES2(ShowExtraKeyboardHelp);
		TEST_CHANGES2(SwapMouseButtons);

#define TEST_CHANGES3(xxx) if(schemeOriginal.m_n##xxx != m_n##xxx) AddChangesLine(IDS_CHANGES##xxx, szChanges)
		TEST_CHANGES3(MouseTrails);
		TEST_CHANGES3(MouseSpeed);
		TEST_CHANGES3(IconSize);
		TEST_CHANGES3(CursorScheme);

        // Add Caret changes
        if (schemeOriginal.m_dwCaretWidth != m_dwCaretWidth)
            AddChangesLine(IDS_CHANGESCaretWidth, szChanges);
        if (schemeOriginal.m_uCursorBlinkTime != m_uCursorBlinkTime)
            AddChangesLine(IDS_CHANGESBlinkRate, szChanges);

		// TODO: ScrollWidth and BorderWidth have been removed

		// TODO: This provieds only one broad change line for all metric changes (including border/scroll bar)
		// NOTE: we have to check if any of our portable metrics are different, OR, windows is currently
		// not using the default windows font.
		PORTABLE_NONCLIENTMETRICS pncm1(schemeOriginal.m_PortableNonClientMetrics);
		PORTABLE_NONCLIENTMETRICS pncm2(m_PortableNonClientMetrics);
		pncm1.m_nFontFaces = pncm2.m_nFontFaces = 0; // WE MUST IGNORE THIS VALUE WHEN COMPARING

		if(		0 != memcmp(&pncm1, &pncm2, sizeof(pncm1))
			||	(m_PortableNonClientMetrics.m_nFontFaces == 1 && IsCurrentFaceNamesDifferent()))
			AddChangesLine(IDS_CHANGESNONCLIENTMETRICS, szChanges);

		if(!lstrlen(szChanges))
			AddChangesLine(IDS_CHANGESNOCHANGES, szChanges);

		SetWindowText(hwndChanges, szChanges);
	}

    void ApplyChanges(const WIZSCHEME &schemeNew, NONCLIENTMETRICS *pForceNCM = NULL, LOGFONT *pForcelfIcon = NULL);


	////////////////////////////////////////////////////////////
	// Setting the icon size

	static DWORD SetShellLargeIconSize( DWORD dwNewSize )
	{
		#define MAX_LENGTH   512
		HKEY   hKey;
		DWORD   dwOldSize = dwNewSize;

		// open the registry
		if (ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER
                                , TEXT("Control Panel\\desktop\\WindowMetrics"),0
								, KEY_QUERY_VALUE | KEY_SET_VALUE, &hKey))
        {
            DWORD   dwLength = MAX_LENGTH, dwType = REG_SZ;
		    TCHAR   szBuffer[MAX_LENGTH];

			ZeroMemory(szBuffer, sizeof szBuffer);

		    // get the last size so we can return it
		    if (ERROR_SUCCESS == RegQueryValueEx( hKey, TEXT("Shell Icon Size")
                                        , NULL, &dwType, (LPBYTE)szBuffer, &dwLength))
            {
				szBuffer[MAX_LENGTH-1] = TEXT('\0');  // ensure NUL termination
		        dwOldSize = _ttol( szBuffer );

		        // We will allow only values >=16 and <=72
		        if( (dwNewSize>=16) && (dwNewSize<=72) )
		        {
                    // get the current cell size of icon (includes spacing)
                    ICONMETRICS iconmetrics;
                    iconmetrics.cbSize = sizeof(ICONMETRICS);
                    SystemParametersInfo(SPI_GETICONMETRICS, sizeof(ICONMETRICS), &iconmetrics, 0);

                    // compute the new cell size (including spacing)
                    iconmetrics.iHorzSpacing = dwNewSize + DEF_SPACING;
                    iconmetrics.iVertSpacing = iconmetrics.iHorzSpacing;

                    // update both the icon size and icon cell size and send notifications
			        wsprintf( szBuffer, TEXT("%d"), dwNewSize );
			        RegSetValueEx( hKey, TEXT("Shell Icon Size"), 0, REG_SZ, (LPBYTE)szBuffer,
					        (lstrlen(szBuffer) + 1) * sizeof(TCHAR) );

                    SystemParametersInfo(SPI_SETICONMETRICS, sizeof(ICONMETRICS)
                                        , &iconmetrics, SPIF_SENDWININICHANGE);
			        SendMessage( HWND_BROADCAST, WM_SETTINGCHANGE, SPI_SETICONMETRICS
                                        , 0/*(LPARAM)("WindowMetrics")*/ );
		        }
            }
		    // Clean up
		    RegCloseKey( hKey );
        }
		// Let everyone know that things changed
		return dwOldSize;
		#undef MAX_LENGTH
	}

    ///////////////////////////////////////////////////////////////////////////
    // New in Whistler
    ///////////////////////////////////////////////////////////////////////////

    DWORD m_dwCaretWidth;
    UINT m_uCursorBlinkTime;

	TCHAR m_szWallpaper[MAX_THEME_SZ];
	TCHAR m_szThemeName[MAX_THEME_SZ];
	TCHAR m_szThemeColor[MAX_THEME_SZ];
	TCHAR m_szThemeSize[MAX_THEME_SZ];
    BOOL m_fFlatMenus;
    BOOL m_fDropShadows;
    TCHAR m_szSelectedStyle[MAX_NUM_SZ];    // this is a number 0 thru 21 (21 color schemes)
    int m_nSelectedSize;                    // this is a number 0 thru 3 (normal, large, extra large)

    void UpdateSelectedSize(int nSelectedSize, LPCTSTR pszSelectedStyle);
	void SetHCFlag(BOOL fSetOn);
	void SaveTheme();
	BOOL SetTheme(LPCTSTR pszThemeName, LPCTSTR pszThemeColor, LPCTSTR pszThemeSize);
	void ClearTheme()
	{
		m_szThemeName[0] = 0;
		m_szThemeColor[0] = 0;
		m_szThemeSize[0] = 0;
	}
	void SaveWallpaper();
	void SetWallpaper(LPCTSTR pszWallpaper);
	void ClearWallpaper()
	{
		m_szWallpaper[0] = 0;
	}
    void SetStyleNSize();
};

int GetSchemeCount();
void GetSchemeName(int nIndex, LPTSTR lpszName, int nLen);
SCHEMEDATALOCAL &GetScheme(int nIndex);

//////////////////////////////////////////////////////////////////////////////////
// Legacy scheme structures - only used for reading ACW files
//////////////////////////////////////////////////////////////////////////////////


#define COLOR_MAX_WIN9X 25
#define COLOR_MAX_NT400 25
#define COLOR_MAX_NT500 29
#define COLOR_MAX_NT501 31

#define WIZSCHEME_LEGACY_STRUCT(szStruct, szName, nColors) \
    struct szStruct \
    { \
	    szStruct() \
	    { \
		    ZeroMemory(this, sizeof(*this)); \
		    m_cbSize = sizeof(*this); \
		    m_dwVersion = 0x000000FF; \
	    } \
	    DWORD m_cbSize; \
	    DWORD m_dwVersion; \
	    COLORREF m_rgb[nColors]; \
	    FILTERKEYS m_FILTERKEYS; \
	    MOUSEKEYS m_MOUSEKEYS; \
	    STICKYKEYS m_STICKYKEYS; \
	    TOGGLEKEYS m_TOGGLEKEYS; \
	    SOUNDSENTRY m_SOUNDSENTRY; \
	    ACCESSTIMEOUT m_ACCESSTIMEOUT; \
	    BOOL m_bShowSounds; \
	    BOOL m_bShowExtraKeyboardHelp; \
	    BOOL m_bSwapMouseButtons; \
	    int m_nMouseTrails; \
	    int m_nMouseSpeed; \
	    int m_nIconSize; \
	    int m_nCursorScheme; \
	    PORTABLE_NONCLIENTMETRICS m_PortableNonClientMetrics; \
    } szName;

#define WIZSCHEME_COPY_LEGACY(dst, src) \
{ \
    /* ignore m_cbSize */ \
	 dst.m_dwVersion = src.m_dwVersion; \
	 memcpy(dst.m_rgb, src.m_rgb, min(sizeof(dst.m_rgb), sizeof(src.m_rgb))); \
	 dst.m_FILTERKEYS= src.m_FILTERKEYS; \
	 dst.m_MOUSEKEYS= src.m_MOUSEKEYS; \
	 dst.m_STICKYKEYS= src.m_STICKYKEYS; \
	 dst.m_TOGGLEKEYS= src.m_TOGGLEKEYS; \
	 dst.m_SOUNDSENTRY= src.m_SOUNDSENTRY; \
	 dst.m_ACCESSTIMEOUT= src.m_ACCESSTIMEOUT; \
	 dst.m_bShowSounds= src.m_bShowSounds; \
	 dst.m_bShowExtraKeyboardHelp= src.m_bShowExtraKeyboardHelp; \
	 dst.m_bSwapMouseButtons= src.m_bSwapMouseButtons; \
	 dst.m_nMouseTrails= src.m_nMouseTrails; \
	 dst.m_nMouseSpeed= src.m_nMouseSpeed; \
	 dst.m_nIconSize= src.m_nIconSize; \
	 dst.m_nCursorScheme= src.m_nCursorScheme; \
	 dst.m_PortableNonClientMetrics= src.m_PortableNonClientMetrics; \
}


///////////////////////////////////////////
// Stuff for Fonts
int GetFontCount();
void GetFontLogFont(int nIndex, LOGFONT *pLogFont);

#endif // _INC_SCHEMES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\select.h ===
//Copyright (c) 1997-2000 Microsoft Corporation

#ifndef _INC_SELECT_H
#define _INC_SELECT_H


class WizardPage;
void DrawHilight(HWND hWnd, LPDRAWITEMSTRUCT ldi);

// CIconSizePg
class CIconSizePg : public WizardPage
{
public:
    CIconSizePg(LPPROPSHEETPAGE ppsp);

protected:
	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnDrawItem(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnTimer( HWND hwnd, WPARAM wParam, LPARAM lParam );
	LRESULT OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);

private:
	void Draw(LPDRAWITEMSTRUCT ldi, int i);
	inline void SetFocussedItem(int m_nCurrentHilight);
	inline void InvalidateRects(int PrevHilight);
	LRESULT SelectionChanged(int nNewSelection);
	UINT GetCtrlID(int);

	int m_nCountValues;
	int m_rgnValues[MAX_DISTINCT_VALUES];
	int m_nCurValueIndex;
	int m_nCurrentHilight;
	BOOL syncInit;
	UINT uIDEvent;
};


// CScrollBarPg
class CScrollBarPg : public WizardPage
{
public:
    CScrollBarPg(LPPROPSHEETPAGE ppsp);

protected:
	LRESULT OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam);
	
	LRESULT OnDrawItem(HWND hwnd, WPARAM wParam, LPARAM lParam);
	LRESULT OnTimer( HWND hwnd, WPARAM wParam, LPARAM lParam );
	LRESULT OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh);

private:
	void Draw(LPDRAWITEMSTRUCT ldi, int i);
	inline void SetFocussedItem(int m_nCurrentHilight);
	inline void InvalidateRects(int PrevHilight);
	LRESULT SettingChanged(int sel);
	UINT GetCtrlID(int);

	int m_nCountValues;
	int m_rgnValues[MAX_DISTINCT_VALUES];
	int m_nCurValueIndex;
	int m_nCurrentHilight;
	BOOL syncInit;
	UINT uIDEvent;
};


#endif // _INC_SELECT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\select.cpp ===
// Copyright (c) 1997-2000 Microsoft Corporation
//  Select.cpp

#include "pch.hxx" // PCH
#pragma hdrstop

#include "pgbase.h"
#include "AccWiz.h"
#include "resource.h"
#include "Select.h"

extern HPALETTE g_hpal3D;

// Re-Write to use owner drawn controls....:a-anilk
//////////////////////////////////////////////////////////////
// CIconSizePg member functions
//
UINT IDMap[3][2] = { 0, IDC_ICON1,
					 1, IDC_ICON2,
					 2, IDC_ICON3
					};
			

CIconSizePg::CIconSizePg(LPPROPSHEETPAGE ppsp)
				: WizardPage(ppsp, IDS_LKPREV_ICONTITLE, IDS_LKPREV_ICONSUBTITLE)
{
	m_dwPageId = IDD_PREV_ICON2;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
	m_nCountValues = 3;
	m_rgnValues[0] = 32;
	m_rgnValues[1] = 48;
	m_rgnValues[2] = 64;
}

LRESULT CIconSizePg::OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	// Initialize the current selection..
	if(g_Options.m_schemePreview.m_nIconSize <= 32)
		m_nCurValueIndex = 0;
	else if(g_Options.m_schemePreview.m_nIconSize <= 48)
		m_nCurValueIndex = 1;
	else
		m_nCurValueIndex = 2;

	m_nCurrentHilight = m_nCurValueIndex;

	return 1;
}


// These is to set the Focus and sync the painting
LRESULT CIconSizePg::OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
{
	syncInit = FALSE;
	uIDEvent = SetTimer(hwnd, NULL, 100, NULL);
	return 0;
}

LRESULT CIconSizePg::OnTimer( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
	KillTimer(hwnd, uIDEvent);
	syncInit = TRUE;
	return 1;
}

// Selection has changed, So Apply for preview. 
LRESULT CIconSizePg::SelectionChanged(int nNewSelection)
{
	g_Options.m_schemePreview.m_nIconSize = m_rgnValues[nNewSelection];
	g_Options.ApplyPreview();

	return 0;
}

// Re-paints the previous radio control. 
void CIconSizePg::InvalidateRects(int PrevHilight)
{
	InvalidateRect(GetDlgItem(m_hwnd, IDMap[PrevHilight][1]), NULL, TRUE);
}

// Sets the focus to the current item in OnInitDialog. 
void CIconSizePg::SetFocussedItem(int m_nCurrentHilight)
{
	SetFocus(GetDlgItem(m_hwnd, IDMap[m_nCurrentHilight][1]));
}

// DrawItem. Handles painting checks the focussed item 
// to determine selection changes
LRESULT CIconSizePg::OnDrawItem(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	UINT idCtrl = (UINT) wParam;
	LPDRAWITEMSTRUCT lpDrawItemStruct = (LPDRAWITEMSTRUCT) lParam;
	int index;
	BOOL hasChanged = FALSE;

	if ( !syncInit)
		SetFocussedItem(m_nCurrentHilight);

	switch(idCtrl)
	{

	case IDC_ICON1:
		index = 0;
		break;
	
	case IDC_ICON2:
		index = 1;
		break;
		
	case IDC_ICON3:
		index = 2;
		break;

	default:
		_ASSERTE(FALSE);
		return 1;	// Prefix #113781 (this should never happen; only three controls on dialog)
		break;
	}
	
	// For each button, Check the state, And if the button is selected,
	// means that it has current focus, So Re-paint the previously hilighted and 
	// the current selected buttons....
	// Make sure we ignore the initial events so that we minimize the flicker...
	if ( (lpDrawItemStruct->itemState & ODS_FOCUS) && (m_nCurrentHilight != index))
	{
		// If focussed item!
		if ( syncInit )
		{
			// Erase the previous one...
			InvalidateRects(m_nCurrentHilight);
			m_nCurrentHilight= m_nCurValueIndex = index;
			
			SelectionChanged(m_nCurValueIndex);
		}
	}

	Draw( lpDrawItemStruct, index );

	return 1;
}



void CIconSizePg::Draw(LPDRAWITEMSTRUCT ldi, int i)
{
	HDC hdc = ldi->hDC;

	int nOldBkMode = SetBkMode(hdc, TRANSPARENT);
	int nOldAlign = SetTextAlign(hdc, TA_CENTER);
	
	RECT rcOriginal = ldi->rcItem ;
	TCHAR sz[100];
	LPCTSTR szBitmap = NULL;
	int nFontSize = 8;
	int nOffset = 0;
	HBITMAP hBitmap;

	switch(i)
	{
	case 0:
		szBitmap = __TEXT("IDB_ICON_SAMPLE_NORMAL2"); // NO NEED TO LOCALIZE

		LoadString(g_hInstDll, IDS_ICONSIZENAMENORMAL, sz, ARRAYSIZE(sz));
		nFontSize = 8; 
		nOffset = 16 + 2;
		break;
	case 1:
		szBitmap = __TEXT("IDB_ICON_SAMPLE_LARGE2"); // NO NEED TO LOCALIZE

		LoadString(g_hInstDll, IDS_ICONSIZENAMELARGE, sz, ARRAYSIZE(sz));
		nFontSize = 12; 
		nOffset = 24 + 2;
		break;
	case 2:
		szBitmap = __TEXT("IDB_ICON_SAMPLE_EXLARGE2"); // NO NEED TO LOCALIZE

		LoadString(g_hInstDll, IDS_ICONSIZENAMEEXTRALARGE, sz, ARRAYSIZE(sz));
		nFontSize = 18; 
		nOffset = 32 + 2;
		break;
	default:
		_ASSERTE(FALSE);
		break;
	}

	HFONT hFontOld = (HFONT)SelectObject(hdc, g_Options.GetClosestMSSansSerif(nFontSize, (m_nCurrentHilight == i)));
	TextOut(hdc,
		(rcOriginal.left + rcOriginal.right)/2,
		(rcOriginal.top + rcOriginal.bottom)/2 + nOffset,
		sz, lstrlen(sz));
	HGDIOBJ hObject = SelectObject(hdc, hFontOld);
	DeleteObject(hObject);

	HDC hDC = CreateCompatibleDC(hdc);
	if (!hDC)
		return;	// Prefix #113779 (out of resources; give up)

// Paint the selected Bitmap. 
	hBitmap = (HBITMAP) LoadImage( g_hInstDll, szBitmap, IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_SHARED  | LR_LOADMAP3DCOLORS);
	HGDIOBJ hBitmapOld = SelectObject(hDC, hBitmap);

	BitBlt(hdc, (rcOriginal.left + rcOriginal.right)/2 - nOffset, 
				(rcOriginal.top + rcOriginal.bottom)/2 - nOffset, 100, 100, hDC, 0, 0, SRCCOPY);
	SelectObject(hdc, hBitmapOld);
	DeleteObject(hBitmap);

	DeleteDC(hDC);

	SetTextAlign(hdc, nOldAlign);
	SetBkMode(hdc, nOldBkMode);

	//If current hi-lighted item, Then draw the bounding rectangle. 
	if ( m_nCurrentHilight == i)
	{
		DrawHilight(m_hwnd, ldi);
	}
}




/////////////////////////////////
//CScrollBarPg members 
/////////////////////////////////
//
// Map the button-ID and the selection index
//
UINT IDMapS[4][2] = { 0, IDC_SCROLL1,
					  1, IDC_SCROLL2,
					  2, IDC_SCROLL3,
					  3, IDC_SCROLL4
					};

CScrollBarPg::CScrollBarPg(LPPROPSHEETPAGE ppsp)
		: WizardPage(ppsp, IDS_LKPREV_SCROLLBARTITLE, IDS_LKPREV_SCROLLBARSUBTITLE)
{
	m_dwPageId = IDD_FNTWIZSCROLLBAR;
	ppsp->pszTemplate = MAKEINTRESOURCE(m_dwPageId);
	
	// Initializes the scroll bar widths and number of elements from string table. 
	LoadArrayFromStringTable(IDS_LKPREV_SCROLLSIZES, m_rgnValues, &m_nCountValues);

}


LRESULT CScrollBarPg::OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	m_nCurValueIndex = m_nCountValues - 1;
	
	// Compute the current scroll bar type...
	for(int i=0; i < m_nCountValues; i++)
	{
		if(g_Options.m_schemePreview.m_PortableNonClientMetrics.m_iScrollWidth <= m_rgnValues[i])
		{
			m_nCurValueIndex = i;
			break;
		}
	}

	m_nCurrentHilight = m_nCurValueIndex;
	return 1;
}


// When page set active, Start Timer to set the Focus and ignore the 
// Hilighted events....
LRESULT CScrollBarPg::OnPSN_SetActive(HWND hwnd, INT idCtl, LPPSHNOTIFY pnmh)
{
	syncInit = FALSE;
	uIDEvent = SetTimer(hwnd, NULL, 100, NULL);

	return 0;
}

// Timer Handler
LRESULT CScrollBarPg::OnTimer( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
	KillTimer(hwnd, uIDEvent);
	syncInit = TRUE;
	return 1;
}

// Apply new settings...
LRESULT CScrollBarPg::SettingChanged(int nNewSelection)
{
	int nNewValue = (int) m_rgnValues[nNewSelection];

	g_Options.m_schemePreview.m_PortableNonClientMetrics.m_iScrollWidth = nNewValue;
	g_Options.m_schemePreview.m_PortableNonClientMetrics.m_iScrollHeight = nNewValue;
	g_Options.m_schemePreview.m_PortableNonClientMetrics.m_iBorderWidth = nNewSelection; 
	
	g_Options.ApplyPreview();

	return 0;
}

// Set the current focussed item....
void CScrollBarPg::SetFocussedItem(int m_nCurrentHilight)
{
	SetFocus(GetDlgItem(m_hwnd, IDMapS[m_nCurrentHilight][1]));
}

// Erase the previous one....
void CScrollBarPg::InvalidateRects(int PrevHilight)
{
	InvalidateRect(GetDlgItem(m_hwnd, IDMapS[PrevHilight][1]), NULL, TRUE);
}

// Owner Draw message
LRESULT CScrollBarPg::OnDrawItem(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
	UINT idCtrl = (UINT) wParam;
	LPDRAWITEMSTRUCT lpDrawItemStruct = (LPDRAWITEMSTRUCT) lParam;
	int index;

	if ( !syncInit)
		SetFocussedItem(m_nCurrentHilight);

	switch(idCtrl)
	{

	case IDC_SCROLL1:
		index = 0;
		break;
	
	case IDC_SCROLL2:
		index = 1;
		break;
		
	case IDC_SCROLL3:
		index = 2;
		break;

	case IDC_SCROLL4:
		index = 3;
		break;

	default:
		// Error
		_ASSERTE(FALSE);
		return 1;	// Prefix #113782 (this should never happen; only four controls on dialog)
		break;
	}
	
	// For each button, Check the state, And if the button is selected,
	// means that it has current focus, So Re-paint the previously hilighted and 
	// the current selected buttons....
	// Make sure we ignore the initial events so that we minimize the flicker...
	if ( (lpDrawItemStruct->itemState & ODS_FOCUS) && (m_nCurrentHilight != index))
	{
		if ( syncInit )
		{
			// Erase the previous one...
			InvalidateRects(m_nCurrentHilight);

			m_nCurrentHilight= m_nCurValueIndex = index;
			SettingChanged(m_nCurValueIndex);
			// dirty = TRUE;
		}
	}

	Draw( lpDrawItemStruct, index );

	return 1;
}

// Paints the scroll bars and the selected item
void CScrollBarPg::Draw(LPDRAWITEMSTRUCT ldi, int i)
{
	HDC hdc = ldi->hDC;

	RECT rcOriginal = ldi->rcItem ;
	RECT rci = rcOriginal;
	InflateRect(&rcOriginal, -10, -10);
	
	// Draw border
	DrawEdge(hdc, &rcOriginal, EDGE_RAISED, BF_BOTTOMRIGHT| BF_ADJUST);
	DrawEdge(hdc, &rcOriginal, BDR_RAISEDINNER, BF_FLAT | BF_BOTTOMRIGHT | BF_ADJUST);
	DrawEdge(hdc, &rcOriginal, BDR_RAISEDINNER, BF_FLAT | BF_BOTTOMRIGHT | BF_ADJUST);
	
	// Adjust for the border
	rcOriginal.right -= i;
	rcOriginal.bottom -= i;
	
	// Adjust to the width of the scroll bar
	rcOriginal.left = rcOriginal.right - m_rgnValues[i];
	
	RECT rc = rcOriginal;
	
	
	// Drop the top
	rc.bottom = rc.top + m_rgnValues[i];
	DrawFrameControl(hdc, &rc, DFC_SCROLL, DFCS_SCROLLUP);
	
	// Draw the middle
	rc.top = rc.bottom;
	rc.bottom = rcOriginal.bottom - 2 * m_rgnValues[i];
	HBRUSH hbr = (HBRUSH)DefWindowProc(m_hwnd, WM_CTLCOLORSCROLLBAR, (WPARAM)hdc, (LPARAM)m_hwnd);
	HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, hbr);
	HPEN hpenOld = (HPEN)SelectObject(hdc, GetStockObject(NULL_PEN));
	//				ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
	Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
	HGDIOBJ hObject = SelectObject(hdc, hbrOld);
	DeleteObject(hObject);
	SelectObject(hdc, hpenOld);
	
	// Draw the bottom
	rc.top = rc.bottom;
	rc.bottom = rc.top + m_rgnValues[i];
	DrawFrameControl(hdc, &rc, DFC_SCROLL, DFCS_SCROLLDOWN);
	
	// Draw the thumb
	rc.top = rc.bottom;
	rc.bottom = rc.top + m_rgnValues[i];
	DrawFrameControl(hdc, &rc, DFC_SCROLL, DFCS_SCROLLSIZEGRIP);
	
	// Draw the right arrow
	rc.right = rc.left;
	rc.left = rc.right - m_rgnValues[i];
	DrawFrameControl(hdc, &rc, DFC_SCROLL, DFCS_SCROLLRIGHT);
	
	// Draw the middle of the bottom scroll bar
	rc.right = rc.left;
	rc.left = rci.left + 10;
	hbr = (HBRUSH)DefWindowProc(m_hwnd, WM_CTLCOLORSCROLLBAR, (WPARAM)hdc, (LPARAM)m_hwnd);
	hbrOld = (HBRUSH)SelectObject(hdc, hbr);
	hpenOld = (HPEN)SelectObject(hdc, GetStockObject(NULL_PEN));
	//				ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
	Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
	hObject = SelectObject(hdc, hbrOld);
	DeleteObject(hObject);
	hObject = SelectObject(hdc, hpenOld);
	DeleteObject(hObject);

	//If current hi-lighted item, Then draw the bounding rectangle. 
	if ( m_nCurrentHilight == i)
	{
		DrawHilight(m_hwnd, ldi);
	}
}

// Global function to draw the hilighted rectangle....
void DrawHilight(HWND hWnd, LPDRAWITEMSTRUCT ldi)
{
	HDC hdc = ldi->hDC;
	UINT clrH = COLOR_HIGHLIGHT;

	HPALETTE hpalOld = NULL;

	SaveDC(hdc);

	if (g_hpal3D)
	{
		hpalOld = SelectPalette(hdc, g_hpal3D, TRUE);
		RealizePalette(hdc);
	}

	// Set the color for drawing the scroll bar
	COLORREF clrrefOld = SetBkColor(hdc, GetSysColor(COLOR_3DHILIGHT));
	COLORREF clrrefOldText = SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));

	// OnDraw(hdc);
	
	// Draw the focus
	RECT rc = ldi->rcItem;
	InflateRect(&rc, -2, -2);
	
	RECT rcTemp;
	
	// If current window not in focus
	if ( GetForegroundWindow() != GetParent(hWnd) )
		clrH = COLOR_GRAYTEXT;

	HWND hwF = GetFocus();

	// Use 'selected' color for scroll bar selection
	COLORREF clrrefSelected = GetSysColor(COLOR_GRAYTEXT); 
	
	if ( (hwF != NULL) && (GetParent(hwF) == hWnd))
		clrrefSelected = GetSysColor(COLOR_HIGHLIGHT); // Use 'Gray' or 'Selected'

	SetBkColor(hdc, clrrefSelected);
	
	// Draw left
	rcTemp = rc;
	rcTemp.right = rcTemp.left + 5;
	ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcTemp, NULL, 0, NULL);
	
	// Draw top
	rcTemp = rc;
	rcTemp.bottom = rcTemp.top + 5;
	ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcTemp, NULL, 0, NULL);
	
	// Draw right
	rcTemp = rc;
	rcTemp.left = rcTemp.right - 5;
	ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcTemp, NULL, 0, NULL);
	
	// Draw bottom
	rcTemp = rc;
	rcTemp.top = rcTemp.bottom - 5;
	ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcTemp, NULL, 0, NULL);
	
	// Reset the color from drawing the scroll bar
	SetBkColor(hdc, clrrefOld);
	SetTextColor(hdc, clrrefOldText);

	if (hpalOld)
	{
		hpalOld = SelectPalette(hdc, hpalOld, FALSE);
		DeleteObject(hpalOld);
		RealizePalette(hdc);
	}

	RestoreDC(hdc, -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\schemes.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation
#include "pch.hxx" // pch
#pragma hdrstop

#include "Schemes.h"
#include <WININET.H>
#include <initguid.h>
#include <shlobj.h>
#include <objbase.h>
#include <shlguid.h>
#include <uxthemep.h>
#include "w95trace.h"

// To use the old way of enumerating fonts to get the font list,
// and reading schemes from the registry, remove the comments from
// the two lines below
//#define ENUMERATEFONTS
//#define READSCHEMESFROMREGISTRY

#define CPL_APPEARANCE_NEW_SCHEMES TEXT("Control Panel\\Appearance\\New Schemes")
#define NEW_SCHEMES_SELECTEDSTYLE  TEXT("SelectedStyle")
#define NEW_SCHEMES_SELECTEDSIZE   TEXT("SelectedSize")
#define HC_KEY              TEXT("Control Panel\\Accessibility\\HighContrast")
#define HC_FLAGS            TEXT("Flags")
#define PRE_HC_WALLPAPER    TEXT("Pre-High Contrast Wallpaper")
#define SYSPARAMINFO(xxx) m_##xxx.cbSize = sizeof(m_##xxx);SystemParametersInfo(SPI_GET##xxx, sizeof(m_##xxx), &m_##xxx, 0)

//
// Helper functions
//

#define REG_SET_DWSZ(hk, key, dw) \
{ \
    TCHAR szValue[20]; \
    wsprintf(szValue, TEXT("%d"), dw); \
    RegSetValueEx(hk, key, NULL, REG_SZ, (LPCBYTE)szValue, (lstrlen(szValue)+1)*sizeof(TCHAR)); \
}

void WIZSCHEME::ApplyChanges(const WIZSCHEME &schemeNew, NONCLIENTMETRICS *pForceNCM, LOGFONT *pForcelfIcon)
    {
        //
        // If user has changed the color scheme then apply the new scheme.  Since this is
        // a high contrast scheme, also set the high contrast bit.  We have to do this
        // w/o using SystemParametersInfo(SPI_SETHIGHCONTRAST...) because that function
        // also sets non-client metrics that accwiz must deal with separately from color.
        //

        BOOL fThemingOn = SetTheme(
                              schemeNew.m_szThemeName
                            , schemeNew.m_szThemeColor
                            , schemeNew.m_szThemeSize);

        SetWallpaper(schemeNew.m_szWallpaper);  // set wallpaper to new scheme's value

        if (fThemingOn)
        {
            DBPRINTF(TEXT("ApplyChanges:  Theming is being turned on\r\n"));
            SetHCFlag(FALSE);                       // manually set high contrast flag off

            // restore "flatmenu" and "dropshadows" settings 
            SystemParametersInfo(SPI_SETFLATMENU, 0, IntToPtr(schemeNew.m_fFlatMenus), SPIF_SENDCHANGE);
            SystemParametersInfo(SPI_SETDROPSHADOW, 0, IntToPtr(schemeNew.m_fDropShadows), SPIF_SENDCHANGE);
        }
        else if (lstrcmpi(schemeNew.m_szSelectedStyle, m_szSelectedStyle))
        {
            DBPRINTF(TEXT("ApplyChanges:  Theming is off or being turned off\r\n"));
            // Setting a high contrast scheme

            if (0 != memcmp(schemeNew.m_rgb, m_rgb, sizeof(m_rgb)))
            {
                SetHCFlag(TRUE);                    // first, manually set the high contrast flag
                                                    // (requires logoff/logon to take affect)

                // reset "flatmenu" and "dropshadows" settings 
                SystemParametersInfo(SPI_SETFLATMENU, 0, IntToPtr(FALSE), SPIF_SENDCHANGE);
                SystemParametersInfo(SPI_SETDROPSHADOW, 0, IntToPtr(FALSE), SPIF_SENDCHANGE);

                // update the color scheme
                int rgInts[COLOR_MAX_97_NT5];          // then set UI elements to selected color scheme
                for(int i=0;i<COLOR_MAX_97_NT5;i++)
                {
                    rgInts[i] = i;
                }

                SetSysColors(COLOR_MAX_97_NT5, rgInts, schemeNew.m_rgb);
 
                // The following code updates the registry HKCU\Control Panel\Colors to
                // reflect the new scheme so its available when the user logs on again

                HKEY hk;
                if (RegCreateKeyEx(HKEY_CURRENT_USER, szRegStr_Colors, 0,
                    TEXT(""), 0, KEY_SET_VALUE, NULL, &hk, NULL) == ERROR_SUCCESS)
                {
                    TCHAR szRGB[32];
                    for (i = 0; i < COLOR_MAX_97_NT5; i++)
                    {
                        COLORREF rgb;
                        rgb = schemeNew.m_rgb[i];
                        wsprintf(szRGB, TEXT("%d %d %d"), GetRValue(rgb), GetGValue(rgb), GetBValue(rgb));

                        WriteProfileString(g_szColors, s_pszColorNames[i], szRGB);  // update win.ini
                        RegSetValueEx(hk                                            // update registry
                            , s_pszColorNames[i]
                            , 0L, REG_SZ
                            , (LPBYTE)szRGB
                            , sizeof(TCHAR) * (lstrlen(szRGB)+1));
                    }

                    RegCloseKey(hk);
                }

                // The W2K color schemes changed with WinXP.  The old schemes (which we still use)
                // are still there but display CPL uses a new method for selecting colors.  These 
                // colors are under HKCU\Control Panel\Appearance\New Schemes.  The "SelectedStyle"
                // string value is the current scheme.  The number (0 thru 21) corresponds to the
                // order of the old colors under HKCU\Control Panel\Appearance\Schemes (excluding
                // those schemes with (large) and (extra large)).  The details for the scheme are
                // subkeys (0 thru nn) under "New Schemes".  In order for display CPL to show the
                // correct current scheme after we've been run, we need to update "SelectedStyle" 
                // and "SelectedSize" (under the subkey specified in "SelectedStyle") with the
                // correct index and size numbers.  Display CPL uses a much more robust way of
                // determining the legacy index but we only support four colors so we shouldn't
                // need all the extra code.

                if (RegOpenKeyEx(
                            HKEY_CURRENT_USER, 
                            CPL_APPEARANCE_NEW_SCHEMES, 
                            0, KEY_ALL_ACCESS, 
                            &hk) == ERROR_SUCCESS)
                {
                    long lRv = RegSetValueEx(
                                        hk, 
                                        NEW_SCHEMES_SELECTEDSTYLE, 
                                        0, REG_SZ, 
                                        (LPCBYTE)schemeNew.m_szSelectedStyle, 
                                        (lstrlen(schemeNew.m_szSelectedStyle)+1)*sizeof(TCHAR));

                    RegCloseKey(hk);

                    // If we've changed color then the size must be updated for that scheme
                    UpdateSelectedSize(schemeNew.m_nSelectedSize, schemeNew.m_szSelectedStyle);
                }
            } 
            else if (schemeNew.m_nSelectedSize >= 0 && schemeNew.m_nSelectedSize != m_nSelectedSize)
            {
                // Also update size if it changed but the color scheme didn't
                UpdateSelectedSize(schemeNew.m_nSelectedSize, schemeNew.m_szSelectedStyle);
            }
        }
        //
        // Apply any other changes
        //

#define APPLY_SCHEME_CURRENT(xxx) if(0 != memcmp(&schemeNew.m_##xxx, &m_##xxx, sizeof(schemeNew.m_##xxx))) SystemParametersInfo(SPI_SET##xxx, sizeof(schemeNew.m_##xxx), (PVOID)&schemeNew.m_##xxx, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE)

        APPLY_SCHEME_CURRENT(FILTERKEYS);
        APPLY_SCHEME_CURRENT(MOUSEKEYS);
        APPLY_SCHEME_CURRENT(STICKYKEYS);
        APPLY_SCHEME_CURRENT(TOGGLEKEYS);
        APPLY_SCHEME_CURRENT(SOUNDSENTRY);
        APPLY_SCHEME_CURRENT(ACCESSTIMEOUT);
//      APPLY_SCHEME_CURRENT(SERIALKEYS);

        // Check Show Sounds
        if(schemeNew.m_bShowSounds != m_bShowSounds)
            SystemParametersInfo(SPI_SETSHOWSOUNDS, schemeNew.m_bShowSounds, NULL, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);

        // Check Extra keyboard help
        if(schemeNew.m_bShowExtraKeyboardHelp != m_bShowExtraKeyboardHelp)
        {
            // Both required: 
            SystemParametersInfo(SPI_SETKEYBOARDPREF, schemeNew.m_bShowExtraKeyboardHelp, NULL, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
            SystemParametersInfo(SPI_SETKEYBOARDCUES, 0, IntToPtr(schemeNew.m_bShowExtraKeyboardHelp), SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
        }

        // Check swap mouse buttons
        if(schemeNew.m_bSwapMouseButtons != m_bSwapMouseButtons)
            SwapMouseButton(schemeNew.m_bSwapMouseButtons);

        // Check Mouse Trails
        if(schemeNew.m_nMouseTrails != m_nMouseTrails)
            SystemParametersInfo(SPI_SETMOUSETRAILS, schemeNew.m_nMouseTrails, NULL, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);

        // Check Mouse Speed
        if(schemeNew.m_nMouseSpeed != m_nMouseSpeed)
            SystemParametersInfo(SPI_SETMOUSESPEED, 0, IntToPtr(schemeNew.m_nMouseSpeed), SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);

        // Reset cursor width and blink time
        if (schemeNew.m_dwCaretWidth != m_dwCaretWidth)
            SystemParametersInfo(SPI_SETCARETWIDTH, 0, IntToPtr(schemeNew.m_dwCaretWidth), SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);

        if (schemeNew.m_uCursorBlinkTime != m_uCursorBlinkTime)
        {
            // Set the blink rate for this session
            SetCaretBlinkTime(schemeNew.m_uCursorBlinkTime);

            // and persist it to the registry
            RegSetStrDW(HKEY_CURRENT_USER, CONTROL_PANEL_DESKTOP, CURSOR_BLINK_RATE, schemeNew.m_uCursorBlinkTime);
        }

        // Check icon size
        if(schemeNew.m_nIconSize != m_nIconSize)
            WIZSCHEME::SetShellLargeIconSize(schemeNew.m_nIconSize);

        // Check cursor scheme
        if(schemeNew.m_nCursorScheme != m_nCursorScheme)
            ApplyCursorScheme(schemeNew.m_nCursorScheme);

        // NonClientMetric changes
        {
            NONCLIENTMETRICS ncmOrig;
            LOGFONT lfOrig;
            GetNonClientMetrics(&ncmOrig, &lfOrig);
            if(pForceNCM)
            {
                // If they gave us a NCM, they must also give us a LOGFONT for the icon
                _ASSERTE(pForcelfIcon);
                // We were given an Original NCM to use
                if(0 != memcmp(pForceNCM, &ncmOrig, sizeof(ncmOrig)))
                    SystemParametersInfo(SPI_SETNONCLIENTMETRICS, sizeof(*pForceNCM), pForceNCM, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
                if(0 != memcmp(pForcelfIcon, &lfOrig, sizeof(lfOrig)))
                    SystemParametersInfo(SPI_SETICONTITLELOGFONT, sizeof(*pForcelfIcon), pForcelfIcon, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
            }
            else
            {
                // Note: This part of apply changes does not look at schemeCurrent - it only looks
                // at what we are applying
                schemeNew.m_PortableNonClientMetrics.ApplyChanges();
            }
        }


        *this = schemeNew;
    }

// Set the high contrast flag on or off based on fSet
void WIZSCHEME::SetHCFlag(BOOL fSetOn)
{
    // 
    // This key is cached in the OS so setting it outside of 
    // SystemParametersInfo(SPI_SETHIGHCONTRAST doesn't take
    // effect until the user logs off and on again.  Is there
    // a way to cause the cache to be refreshed?
    //
    HKEY hk;
    if (RegOpenKeyEx(HKEY_CURRENT_USER, HC_KEY, 0, KEY_ALL_ACCESS, &hk) == ERROR_SUCCESS)
    {
        TCHAR szValue[20];
        DWORD dwSize = sizeof(szValue);
        ZeroMemory(szValue, dwSize);

        if (RegQueryValueEx(hk, HC_FLAGS, NULL, NULL, (LPBYTE)szValue, &dwSize) == ERROR_SUCCESS)
        {
            szValue[ARRAYSIZE(szValue)-1] = TEXT('\0');  // ensure NUL termination
            DWORD dwValue = _ttol(szValue);

            if (fSetOn && !(dwValue & HCF_HIGHCONTRASTON))
            {
                dwValue |= HCF_HIGHCONTRASTON;
                REG_SET_DWSZ(hk, HC_FLAGS, dwValue)
            }
            else if (!fSetOn && (dwValue & HCF_HIGHCONTRASTON))
            {
                dwValue &= ~HCF_HIGHCONTRASTON;
                REG_SET_DWSZ(hk, HC_FLAGS, dwValue)
            }
        }
        RegCloseKey(hk);
    }
}

/***************************************************************************
 * SaveWallpaper
 * 
 * Saves the current wallpaper setting from the system.
 *
 * ISSUE we aren't getting all the active desktop properties; just wallpaper.
 * This isn't a regression in that we didn't even restore wallpaper in W2K.
 *
 ***************************************************************************/
void WIZSCHEME::SaveWallpaper()
{
    IActiveDesktop *p;
    HRESULT hr = CoCreateInstance(
                  CLSID_ActiveDesktop
                , NULL
                , CLSCTX_INPROC_SERVER
                , IID_IActiveDesktop
                , (void **)&p);
    if (SUCCEEDED(hr) && p)
    {
        hr = p->GetWallpaper(m_szWallpaper, MAX_THEME_SZ, 0);
        p->Release();
    }
    DBPRINTF(TEXT("SaveWallpaper:  m_szWallpaper = %s (hr = 0x%x)\r\n"), m_szWallpaper, hr);
}

/***************************************************************************
 * SetWallpaper
 *
 * Restores the pre-high contrast wallpaper setting.  Reads the setting
 * stored in the accessibility registry entries and restores the system
 * setting.  No error return as there isn't anything we can do.
 * 
 ***************************************************************************/
void WIZSCHEME::SetWallpaper(LPCTSTR pszWallpaper)
{
    if (lstrcmpi(m_szWallpaper, pszWallpaper))
    {
        IActiveDesktop *p;
        LPCTSTR psz = (pszWallpaper)?pszWallpaper:TEXT("");

        HRESULT hr = CoCreateInstance(
                      CLSID_ActiveDesktop
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , IID_IActiveDesktop
                    , (void **)&p);
        if (SUCCEEDED(hr) && p)
        {
            hr = p->SetWallpaper(psz, 0);
            if (SUCCEEDED(hr))
                p->ApplyChanges(AD_APPLY_ALL);

            p->Release();
        }
        DBPRINTF(TEXT("SetWallpaper:  psz = %s (hr = 0x%x)\r\n"), psz, hr);
    }
}

/***************************************************************************
 * SaveTheme
 *
 * Saves the theme file settings that are active before accwiz was run.
 * 
 ***************************************************************************/
void WIZSCHEME::SaveTheme()
{
    HRESULT hr = E_FAIL;

    if (IsThemeActive())
    {
        hr = GetCurrentThemeName(
                  m_szThemeName, MAX_THEME_SZ
                , m_szThemeColor, MAX_THEME_SZ
                , m_szThemeSize, MAX_THEME_SZ);
    }

    if (FAILED(hr))
    {
        // themes is not turned on
        m_szThemeName[0] = 0;
        m_szThemeColor[0] = 0;
        m_szThemeSize[0] = 0;
    }

    //---- save off "flatmenu" and "dropshadows" settings ---
    SystemParametersInfo(SPI_GETFLATMENU, 0, (PVOID)&m_fFlatMenus, 0);
    SystemParametersInfo(SPI_GETDROPSHADOW, 0, (PVOID)&m_fDropShadows, 0);

    DBPRINTF(TEXT("SaveTheme:  m_szThemeName = %s m_szThemeColor = %s m_szThemeSize = %s (hr = 0x%x)\r\n"), m_szThemeName, m_szThemeColor, m_szThemeSize, hr);
}

/***************************************************************************
 * SetTheme
 *
 * If a theme name, color and size is passed then sets it 
 * else turns off theming. 
 *
 * Returns TRUE if a theme was set else FALSE it themes were turned off.
 * 
 ***************************************************************************/
BOOL WIZSCHEME::SetTheme(LPCTSTR pszThemeName, LPCTSTR pszThemeColor, LPCTSTR pszThemeSize)
{
    BOOL fRet = FALSE;      // didn't turn themes on

    // only attempt to do anything if the new theme differs from current
    if ( lstrcmpi(m_szThemeName, pszThemeName)
      || lstrcmpi(m_szThemeColor, pszThemeColor)
      || lstrcmpi(m_szThemeSize, pszThemeSize) )
    {
        HRESULT hr;
        if (pszThemeName[0] && pszThemeColor[0] && pszThemeSize[0])
        {
            hr = SetSystemVisualStyle(pszThemeName, pszThemeColor, pszThemeSize, 
                                   AT_LOAD_SYSMETRICS | AT_SYNC_LOADMETRICS);
            if (SUCCEEDED(hr))
            {
                fRet = TRUE;    // turned themes on
            }
            DBPRINTF(TEXT("SetTheme:  pszThemeName = %s pszThemeColor = %s pszThemeSize = %s(hr = 0x%x)\r\n"), pszThemeName, pszThemeColor, pszThemeSize, hr);
        } 
        else if (IsThemeActive())
        {
            hr = ApplyTheme(NULL, 0, NULL);
            DBPRINTF(TEXT("SetTheme:  Themes are now off hr = 0x%x\r\n"), hr);
        }
    }

    return fRet;
}

/***************************************************************************
 * UpdateSelectedSize
 *
 * Updates the SelectedSize under a "New Scheme" entry. 
 *
 * NOTE:  AccWiz doesn't use the font metrics from the registry so
 *        it doesn't actually give fonts that are "normal", "large"
 *        and "extra large" as display and access CPLs know them.
 *        The closest sizes are "normal" and "large".
 * 
 ***************************************************************************/
void WIZSCHEME::UpdateSelectedSize(int nSelectedSize, LPCTSTR pszSelectedStyle)
{
    LPTSTR pszSelectedSize;
    LPTSTR aszSelectedSizes[] = {TEXT("0")/*normal*/, TEXT("2")/*large*/, TEXT("1")/*extra large*/};

    switch (nSelectedSize)
    {
        case 0: pszSelectedSize = aszSelectedSizes[0]; break; // normal text size
        case 1: pszSelectedSize = aszSelectedSizes[0]; break; // normal text size
        case 2: pszSelectedSize = aszSelectedSizes[1]; break; // large text size
        default: pszSelectedSize =  0;                 break;
    }

    if (pszSelectedSize)
    {
        HKEY hk;
        if (RegOpenKeyEx(HKEY_CURRENT_USER, 
                         CPL_APPEARANCE_NEW_SCHEMES, 
                         0, KEY_ALL_ACCESS, 
                         &hk) == ERROR_SUCCESS)
        {
            HKEY hkSub;
            if (RegOpenKeyEx(hk, pszSelectedStyle, 0, KEY_ALL_ACCESS, &hkSub) == ERROR_SUCCESS)
            {
                RegSetValueEx(hkSub, 
                              NEW_SCHEMES_SELECTEDSIZE, 
                              0, REG_SZ, 
                              (LPCBYTE)pszSelectedSize, 
                              (lstrlen(pszSelectedSize)+1)*sizeof(TCHAR));

                RegCloseKey(hkSub);
            }
            
            RegCloseKey(hk);
        }
    }
}

/***************************************************************************
 * SetStyleNSize
 *
 * Helper for legacy schemes - figures out SelectedStyle and SelectedSize
 * from the legacy scheme's data. 
 * 
 ***************************************************************************/
void WIZSCHEME::SetStyleNSize()
{
    int cStdSchemes = GetSchemeCount();
    int i;

    // Init the fields this function will be setting

    m_szSelectedStyle[0] = 0;
    m_nSelectedSize = 0;

    // Figure out the SelectedStyle by finding the best-match for
    // colors between what accwiz supports now and what it had in
    // previous versions.  After finding the best match, copy the
    // latest colors in; this fixes some bugs with old colors.

    SCHEMEDATALOCAL sdlTemp;
    int iBestColorFit = -1; // guarrantee we'll find one
    int cBestMatch = 0;

    for (i=0;i<cStdSchemes;i++)
    {
        int cMatches = 0;
        sdlTemp = GetScheme(i);

        // assumption:  sizeof(m_rgb) > sizeof(sdlTemp.rgb)
        for (int cColor = 0;cColor < sdlTemp.nColorsUsed; cColor++)
        {
            if (sdlTemp.rgb[cColor] == m_rgb[cColor])
            {
                cMatches++;
            }
        }

        if (cBestMatch < cMatches)
        {
            iBestColorFit = i;
            cBestMatch = cMatches;
        }

        // if its an exact match just use it
        if (cMatches == sdlTemp.nColorsUsed)
            break;
    }

    // load up the SelectedStyle
    sdlTemp = GetScheme(iBestColorFit);
    LoadString(g_hInstDll, sdlTemp.nNameStringId+100
                         , m_szSelectedStyle
                         , ARRAYSIZE(m_szSelectedStyle));

    // fix up any color problems
    memcpy(m_rgb, sdlTemp.rgb, sizeof(sdlTemp.rgb));

    // Figure out the SelectedSize based on reverse-compute minimum
    // font size and hard-coded limits from the Welcome page

    HDC hDC = GetDC(NULL);
    if (hDC)
    {
        long lMinFontSize = ((-m_PortableNonClientMetrics.m_lfCaptionFont_lfHeight)*72)/GetDeviceCaps(hDC, LOGPIXELSY);
        ReleaseDC(NULL, hDC);
    
        if (lMinFontSize <=9)
        {
            m_nSelectedSize = 0;
        }
        else if (lMinFontSize <=12)
        {
            m_nSelectedSize = 1;
        }
        else if (lMinFontSize <=16)
        {
            m_nSelectedSize = 2;
        }
    }
}

void WIZSCHEME::LoadOriginal()
{
    DBPRINTF(TEXT("LoadOriginal\r\n"));
    //
    // Save off current UI element colors, theme information, and wallpaper setting
    //

    for(int i=0;i<COLOR_MAX_97_NT5;i++)
        m_rgb[i] = GetSysColor(i);

    SaveTheme();
    SaveWallpaper();

    //
    // Save off the rest of the UI settings
    //

    SYSPARAMINFO(FILTERKEYS);
    SYSPARAMINFO(MOUSEKEYS);
    SYSPARAMINFO(STICKYKEYS);
    SYSPARAMINFO(TOGGLEKEYS);
    SYSPARAMINFO(SOUNDSENTRY);
    SYSPARAMINFO(ACCESSTIMEOUT);

    m_bShowSounds = GetSystemMetrics(SM_SHOWSOUNDS);
    SystemParametersInfo(SPI_GETKEYBOARDPREF, 0, &m_bShowExtraKeyboardHelp, 0);
    m_bSwapMouseButtons = GetSystemMetrics(SM_SWAPBUTTON);
    SystemParametersInfo(SPI_GETMOUSETRAILS, 0, &m_nMouseTrails, 0);
    SystemParametersInfo(SPI_GETMOUSESPEED,0, &m_nMouseSpeed, 0);
    SystemParametersInfo(SPI_GETCARETWIDTH, 0 , &m_dwCaretWidth, 0);
    m_uCursorBlinkTime = RegQueryStrDW(
                             DEFAULT_BLINK_RATE
                           , HKEY_CURRENT_USER
                           , CONTROL_PANEL_DESKTOP
                           , CURSOR_BLINK_RATE);
    m_nIconSize = SetShellLargeIconSize(0); // This just gets the current size
    m_nCursorScheme = 0;                    // We are always using the 'current' cursor scheme =)

    m_PortableNonClientMetrics.LoadOriginal();

    // Save off current "New Schemes" settings if we aren't themed

    if (IsThemeActive())
    {
        LoadString(g_hInstDll, IDS_SCHEME_CURRENTCOLORSCHEME+100, m_szSelectedStyle, MAX_NUM_SZ);
        m_nSelectedSize = 0;
    }
    else
    {
        HKEY hk;
        if (RegOpenKeyEx(HKEY_CURRENT_USER, CPL_APPEARANCE_NEW_SCHEMES, 0, KEY_READ, &hk) == ERROR_SUCCESS)
        {
            DWORD ccb = sizeof(m_szSelectedStyle);
            m_szSelectedStyle[0] = 0;
            if (RegQueryValueEx(hk, NEW_SCHEMES_SELECTEDSTYLE, 0, NULL, (LPBYTE)m_szSelectedStyle, &ccb) == ERROR_SUCCESS && ccb > 2)
            {
                HKEY hkSub;
                m_szSelectedStyle[ARRAYSIZE(m_szSelectedStyle)-1] = TEXT('\0');
                if (RegOpenKeyEx(hk, m_szSelectedStyle, 0, KEY_READ, &hkSub) == ERROR_SUCCESS)
                {
                    TCHAR szSize[MAX_NUM_SZ] = {0};
                    ccb = sizeof(szSize);
                    DBPRINTF(TEXT("RegQueryValueEx(NEW_SCHEMES_SELECTEDSIZE=%s,,,ccb=%d)\r\n"), NEW_SCHEMES_SELECTEDSIZE, ccb);
                    ZeroMemory(szSize,sizeof szSize);
                    RegQueryValueEx(hkSub, NEW_SCHEMES_SELECTEDSIZE, 0, NULL, (LPBYTE)szSize, &ccb);
                    szSize[ARRAYSIZE(szSize)-1] = TEXT('\0');

                    m_nSelectedSize = (szSize[0] && ccb > 2) ? _wtoi(szSize) : -1;
                    DBPRINTF(TEXT("szSize=%d ccb=%d m_nSelectedSize=%d\r\n"), szSize, ccb, m_nSelectedSize);
                    RegCloseKey(hkSub);
                }
            }
            RegCloseKey(hk);
        }
    }
}


/////////////////////////////////////////////////////////////////////
//  New way of enumerating fonts

#ifndef ENUMERATEFONTS

static LPCTSTR g_lpszFontNames[] =
{
    __TEXT("Arial"),
    __TEXT("MS Sans Serif"),
    __TEXT("Tahoma"),
    __TEXT("Times New Roman")
};

int GetFontCount()
{
    return ARRAYSIZE(g_lpszFontNames);
}

void GetFontLogFont(int nIndex, LOGFONT *pLogFont)
{
    _ASSERTE(nIndex < ARRAYSIZE(g_lpszFontNames));
    memset(pLogFont, 0, sizeof(*pLogFont));
    lstrcpy(pLogFont->lfFaceName, g_lpszFontNames[nIndex]);
}


#endif // ENUMERATEFONTS

//
/////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////
//  New way of storing schemes as hard coded values

// CONSIDER - this isn't a very robust way to do this; see sethc

#ifndef READSCHEMESFROMREGISTRY

#include "resource.h"

static SCHEMEDATALOCAL g_rgSchemeData[] = 
{
    {
        IDS_SCHEME_HIGHCONTRASTBLACKALTERNATE,
        {NULL},
#if(WINVER >= 0x0501)
        31,
#elif(WINVER == 0x0500)
        29,
#else
        25,
#endif
        {
            RGB(  0,   0,   0), // Scrollbar
            RGB(  0,   0,   0), // Background
            RGB(  0,   0, 255), // ActiveTitle
            RGB(  0, 255, 255), // InactiveTitle
            RGB(  0,   0,   0), // Menu
            RGB(  0,   0,   0), // Window
            RGB(255, 255, 255), // WindowFrame
            RGB(255, 255, 255), // MenuText
            RGB(255, 255,   0), // WindowText
            RGB(255, 255, 255), // TitleText
            RGB(  0,   0, 255), // ActiveBorder
            RGB(  0, 255, 255), // InactiveBorder
            RGB(  0,   0,   0), // AppWorkspace
            RGB(  0, 128,   0), // Hilight
            RGB(255, 255, 255), // HilightText
            RGB(  0,   0,   0), // ButtonFace
            RGB(128, 128, 128), // ButtonShadow
            RGB(  0, 255,   0), // GrayText
            RGB(255, 255, 255), // ButtonText
            RGB(  0,   0,   0), // InactiveTitleText
            RGB(192, 192, 192), // ButtonHilight
            RGB(255, 255, 255), // ButtonDkShadow
            RGB(255, 255, 255), // ButtonLight
            RGB(255, 255,   0), // InfoText
            RGB(  0,   0,   0), // InfoWindow
#if(WINVER >= 0x0500)
            RGB(192, 192, 192), // ButtonAlternateFace
            RGB(128,   0, 128), // HotTrackingColor
            RGB(  0,   0, 255), // GradientActiveTitle
            RGB(  0, 255, 255), // GradientInactiveTitle
#if(WINVER >= 0x0501)
            RGB(128,   0, 128), // MenuHighlighted
            RGB(  0,   0,   0)  // MenuBar
#endif /* WINVER >= 0x0501 */
#endif /* WINVER >= 0x0500 */
        }
    },
    {
        IDS_SCHEME_HIGHCONTRASTWHITEALTERNATE,
        {NULL},
#if(WINVER >= 0x0501)
        31,
#elif(WINVER == 0x0500)
        29,
#else
        25,
#endif
        {
            RGB(  0,   0,   0), // Scrollbar
            RGB(  0,   0,   0), // Background
            RGB(  0, 255, 255), // ActiveTitle
            RGB(  0,   0, 255), // InactiveTitle
            RGB(  0,   0,   0), // Menu
            RGB(  0,   0,   0), // Window
            RGB(255, 255, 255), // WindowFrame
            RGB(  0, 255,   0), // MenuText
            RGB(  0, 255,   0), // WindowText
            RGB(  0,   0,   0), // TitleText
            RGB(  0, 255, 255), // ActiveBorder
            RGB(  0,   0, 255), // InactiveBorder
            RGB(255, 251, 240), // AppWorkspace
            RGB(  0,   0, 255), // Hilight
            RGB(255, 255, 255), // HilightText
            RGB(  0,   0,   0), // ButtonFace
            RGB(128, 128, 128), // ButtonShadow
            RGB(  0, 255,   0), // GrayText
            RGB(  0, 255,   0), // ButtonText
            RGB(255, 255, 255), // InactiveTitleText
            RGB(192, 192, 192), // ButtonHilight
            RGB(255, 255, 255), // ButtonDkShadow
            RGB(255, 255, 255), // ButtonLight
            RGB(  0,   0,   0), // InfoText
            RGB(255, 255,   0), // InfoWindow
#if(WINVER >= 0x0500)
            RGB(192, 192, 192), // ButtonAlternateFace
            RGB(128,   0, 128), // HotTrackingColor
            RGB(  0, 255, 255), // GradientActiveTitle
            RGB(  0,   0, 255), // GradientInactiveTitle
#if(WINVER >= 0x0501)
            RGB(128,   0, 128), // MenuHighlighted
            RGB(  0,   0,   0)  // MenuBar
#endif /* WINVER >= 0x0501 */
#endif /* WINVER >= 0x0500 */
        }
    },
    {
        IDS_SCHEME_HIGHCONTRASTBLACK,
        {NULL},
#if(WINVER >= 0x0501)
        31,
#elif(WINVER == 0x0500)
        29,
#else
        25,
#endif
        {
            RGB(  0,   0,   0), // Scrollbar
            RGB(  0,   0,   0), // Background
            RGB(128,   0, 128), // ActiveTitle
            RGB(  0, 128,   0), // InactiveTitle
            RGB(  0,   0,   0), // Menu
            RGB(  0,   0,   0), // Window
            RGB(255, 255, 255), // WindowFrame
            RGB(255, 255, 255), // MenuText
            RGB(255, 255, 255), // WindowText
            RGB(255, 255, 255), // TitleText
            RGB(255, 255,   0), // ActiveBorder
            RGB(  0, 128,   0), // InactiveBorder
            RGB(  0,   0,   0), // AppWorkspace
            RGB(128,   0, 128), // Hilight
            RGB(255, 255, 255), // HilightText
            RGB(  0,   0,   0), // ButtonFace
            RGB(128, 128, 128), // ButtonShadow
            RGB(  0, 255,   0), // GrayText
            RGB(255, 255, 255), // ButtonText
            RGB(255, 255, 255), // InactiveTitleText
            RGB(192, 192, 192), // ButtonHilight
            RGB(255, 255, 255), // ButtonDkShadow
            RGB(255, 255, 255), // ButtonLight
            RGB(255, 255, 255), // InfoText
            RGB(  0,   0,   0), // InfoWindow
#if(WINVER >= 0x0500)
            RGB(192, 192, 192), // ButtonAlternateFace
            RGB(128,   0, 128), // HotTrackingColor
            RGB(128,   0, 128), // GradientActiveTitle
            RGB(  0, 128,   0), // GradientInactiveTitle
#if(WINVER >= 0x0501)
            RGB(128,   0, 128), // MenuHighlighted
            RGB(  0,   0,   0)  // MenuBar
#endif /* WINVER >= 0x0501 */
#endif /* WINVER >= 0x0500 */
        }
    },
    {
        IDS_SCHEME_HIGHCONTRASTWHITE,
        {NULL},
#if(WINVER >= 0x0501)
        31,
#elif(WINVER == 0x0500)
        29,
#else
        25,
#endif
        {
            RGB(255, 255, 255), // Scrollbar
            RGB(255, 255, 255), // Background
            RGB(  0,   0,   0), // ActiveTitle
            RGB(255, 255, 255), // InactiveTitle
            RGB(255, 255, 255), // Menu
            RGB(255, 255, 255), // Window
            RGB(  0,   0,   0), // WindowFrame
            RGB(  0,   0,   0), // MenuText             (enabled menu text FlatMenuMode = TRUE)
            RGB(  0,   0,   0), // WindowText
            RGB(255, 255, 255), // TitleText
            RGB(128, 128, 128), // ActiveBorder
            RGB(192, 192, 192), // InactiveBorder
            RGB(128, 128, 128), // AppWorkspace
            RGB(  0,   0,   0), // Hilight              (and enabled menu highlighted background FlatMenuMode = FALSE)
            RGB(255, 255, 255), // HilightText          (and menu highlighted text FlatMenuMode = FALSE)
            RGB(255, 255, 255), // ButtonFace
            RGB(128, 128, 128), // ButtonShadow
            RGB(  0, 255,   0), // GrayText             (disabled menu text highlighted = green)
            RGB(  0,   0,   0), // ButtonText
            RGB(  0,   0,   0), // InactiveTitleText
            RGB(192, 192, 192), // ButtonHilight        (disabled menu text = grey)
            RGB(  0,   0,   0), // ButtonDkShadow
            RGB(192, 192, 192), // ButtonLight
            RGB(  0,   0,   0), // InfoText
            RGB(255, 255, 255), // InfoWindow
#if(WINVER >= 0x0500)
            RGB(192, 192, 192), // ButtonAlternateFace
            RGB(  0,   0,   0), // HotTrackingColor
            RGB(  0,   0,   0), // GradientActiveTitle
            RGB(255, 255, 255), // GradientInactiveTitle
#if(WINVER >= 0x0501)
            RGB(  0,   0,   0), // MenuHighlighted      (enabled menu highlighted background FlatMenuMode = TRUE)
            RGB(255, 255, 255)  // MenuBar
#endif /* WINVER >= 0x0501 */
#endif /* WINVER >= 0x0500 */
        }
    }
};


int GetSchemeCount()
{
    return ARRAYSIZE(g_rgSchemeData);
}

// GetSchemeName is only called to initialize the color scheme list box
void GetSchemeName(int nIndex, LPTSTR lpszName, int nLen) // JMC: HACK - You must allocate enough space
{
    _ASSERTE(nIndex < ARRAYSIZE(g_rgSchemeData));
    LoadString(g_hInstDll, g_rgSchemeData[nIndex].nNameStringId, lpszName, nLen);   // return the name
    LoadString(g_hInstDll, g_rgSchemeData[nIndex].nNameStringId+100
                         , g_rgSchemeData[nIndex].szNameIndexId
                         , ARRAYSIZE(g_rgSchemeData[nIndex].szNameIndexId));        // get the "SelectedStyle" index
}

SCHEMEDATALOCAL &GetScheme(int nIndex)
{
    _ASSERTE(nIndex < ARRAYSIZE(g_rgSchemeData));
    return g_rgSchemeData[nIndex];
}


#endif // READSCHEMESFROMREGISTRY

//
/////////////////////////////////////////////////////////////////////





/////////////////////////////////////////////////////////////////////
// Below this point in the file, we have the old way we use
// to enumerate fonts and schemes.





/////////////////////////////////////////////////////////////////////
//  Old way of enumerating fonts
#ifdef ENUMERATEFONTS

// Global Variables
static ENUMLOGFONTEX g_rgFonts[200]; // JMC: HACK - At Most 200 Fonts
static int g_nFontCount = 0;
static BOOL bFontsAlreadyInit = FALSE;

void Font_Init();

int GetFontCount()
{
    if(!bFontsAlreadyInit)
        Font_Init();
    return g_nFontCount;
}

void GetFontLogFont(int nIndex, LOGFONT *pLogFont)
{
    if(!bFontsAlreadyInit)
        Font_Init();
    *pLogFont = g_rgFonts[nIndex].elfLogFont;
}


int CALLBACK EnumFontFamExProc(
    ENUMLOGFONTEX *lpelfe,  // pointer to logical-font data
    NEWTEXTMETRICEX *lpntme,    // pointer to physical-font data
    int FontType,   // type of font
    LPARAM lParam   // application-defined data 
   )
{
    if(g_nFontCount>200)
        return 0; // JMC: HACK - Stop enumerating if more than 200 families

    // Don't use if we already have this font name
    BOOL bHave = FALSE;
    for(int i=0;i<g_nFontCount;i++)
        if(0 == lstrcmp((TCHAR *)g_rgFonts[i].elfFullName, (TCHAR *)lpelfe->elfFullName))
        {
            bHave = TRUE;
            break;
        }
    if(!bHave)
        g_rgFonts[g_nFontCount++] = *lpelfe;
    return 1;
}

void Font_Init()
{
    // Only do the stuff in this function once.
    if(bFontsAlreadyInit)
        return;
    bFontsAlreadyInit = TRUE;

    LOGFONT lf;
    memset(&lf, 0, sizeof(lf));
//  lf.lfCharSet = DEFAULT_CHARSET;
    lf.lfCharSet = OEM_CHARSET;
    HDC hdc = GetDC(NULL);
    EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC)EnumFontFamExProc, 0, 0);
    ReleaseDC(NULL, hdc);
    // JMC: Make sure there is at least one font
}

#endif ENUMERATEFONTS

//
/////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////
//  Old way of reading schemes from the registry

#ifdef READSCHEMESFROMREGISTRY

extern PTSTR s_pszColorNames[]; // JMC: HACK


// Scheme data for Windows 95
typedef struct {
    SHORT version;
//    NONCLIENTMETRICSA ncm;
//    LOGFONTA lfIconTitle;
    BYTE rgDummy[390]; // This is the size of NONCLIENTMETRICSA and LOGFONTA in 16 bit Windows!!!
    COLORREF rgb[COLOR_MAX_95_NT4];
} SCHEMEDATA_95;

// New scheme data for Windows 97
typedef struct {
    SHORT version;
//    NONCLIENTMETRICSA ncm;
//    LOGFONTA lfIconTitle;
    BYTE rgDummy[390]; // This is the size of NONCLIENTMETRICSA and LOGFONTA in 16 bit Windows!!!
    COLORREF rgb[COLOR_MAX_97_NT5];
} SCHEMEDATA_97;

// Scheme data for Windows NT 4.0
typedef struct {
    SHORT version;
    WORD  wDummy;               // for alignment
    NONCLIENTMETRICSW ncm;
    LOGFONTW lfIconTitle;
    COLORREF rgb[COLOR_MAX_95_NT4];
} SCHEMEDATA_NT4;

// Scheme data for Windows NT 5.0
typedef struct {
    SHORT version;
    WORD  wDummy;               // for alignment
    NONCLIENTMETRICSW ncm;
    LOGFONTW lfIconTitle;
    COLORREF rgb[COLOR_MAX_97_NT5];
} SCHEMEDATA_NT5;

static SCHEMEDATALOCAL g_rgSchemeData[100]; // JMC: HACK - At Most 100 schemes
static TCHAR g_rgSchemeNames[100][100];
static int g_nSchemeCount = 0;
static BOOL bSchemesAlreadyInit = FALSE;

void Scheme_Init();

int GetSchemeCount()
{
    Scheme_Init();
    return g_nSchemeCount;
}

void GetSchemeName(int nIndex, LPTSTR lpszName, int nLen) // JMC: HACK - You must allocate enough space
{
    Scheme_Init();
    _tcsncpy(lpszName, g_rgSchemeNames[i], nLen - 1);
    lpstName[nLen - 1] = 0; // Guarantee NULL termination
}

SCHEMEDATALOCAL &GetScheme(int nIndex)
{
    Scheme_Init();
    return g_rgSchemeData[nIndex];
}

void Scheme_Init()
{
    // Only do the stuff in this function once.
    if(bSchemesAlreadyInit)
        return;
    bSchemesAlreadyInit = TRUE;

    HKEY hkSchemes;
    DWORD dw, dwSize;
    TCHAR szBuf[100];

    g_nSchemeCount = 0;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_LOOKSCHEMES, 0, KEY_READ_VALUE |
        KEY_ENUMERATE_SUB_KEYS, &hkSchemes) != ERROR_SUCCESS)
        return;

    for (dw=0; ; dw++)
    {
        if(g_nSchemeCount>99)
            break; //JMC: HACK - At Most 100 schemes

        dwSize = ARRAYSIZE(szBuf);
        if (RegEnumValue(hkSchemes, dw, szBuf, &dwSize, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
            break;  // Bail if no more values

        DWORD dwType;
        DWORD dwSize;
        RegQueryValueEx(hkSchemes, szBuf, NULL, &dwType, NULL, &dwSize);
        if(dwType == REG_BINARY)
        {
            // Always copy the current name to the name array - if there
            // is an error in the data, we just won't upcount g_nSchemeCount
            lstrcpy(g_rgSchemeNames[g_nSchemeCount], szBuf);

            // Find out which type of scheme this is, and convert to the
            // SCHEMEDATALOCAL type
            switch(dwSize)
            {
            case sizeof(SCHEMEDATA_95):
                {
                    SCHEMEDATA_95 sd;
                    RegQueryValueEx(hkSchemes, szBuf, NULL, &dwType, (BYTE *)&sd, &dwSize);
                    if(1 != sd.version)
                        break; // We have the wrong version even though the size was correct

                    // Copy the color information from the registry info to g_rgSchemeData
                    g_rgSchemeData[g_nSchemeCount].nColorsUsed = COLOR_MAX_95_NT4;

                    // Copy the color array
                    for(int i=0;i<g_rgSchemeData[g_nSchemeCount].nColorsUsed;i++)
                        g_rgSchemeData[g_nSchemeCount].rgb[i] = sd.rgb[i];

                    g_nSchemeCount++;
                }
                break;
            case sizeof(SCHEMEDATA_NT4):
                {
                    SCHEMEDATA_NT4 sd;
                    RegQueryValueEx(hkSchemes, szBuf, NULL, &dwType, (BYTE *)&sd, &dwSize);
                    if(2 != sd.version)
                        break; // We have the wrong version even though the size was correct

                    // Copy the color information from the registry info to g_rgSchemeData
                    g_rgSchemeData[g_nSchemeCount].nColorsUsed = COLOR_MAX_95_NT4;

                    // Copy the color array
                    for(int i=0;i<g_rgSchemeData[g_nSchemeCount].nColorsUsed;i++)
                        g_rgSchemeData[g_nSchemeCount].rgb[i] = sd.rgb[i];

                    g_nSchemeCount++;
                }
                break;
            case sizeof(SCHEMEDATA_97):
                {
                    SCHEMEDATA_97 sd;
                    RegQueryValueEx(hkSchemes, szBuf, NULL, &dwType, (BYTE *)&sd, &dwSize);
                    if(3 != sd.version)
                        break; // We have the wrong version even though the size was correct

                    // Copy the color information from the registry info to g_rgSchemeData
                    g_rgSchemeData[g_nSchemeCount].nColorsUsed = COLOR_MAX_97_NT5;

                    // Copy the color array
                    for(int i=0;i<g_rgSchemeData[g_nSchemeCount].nColorsUsed;i++)
                        g_rgSchemeData[g_nSchemeCount].rgb[i] = sd.rgb[i];

                    g_nSchemeCount++;
                }
                break;
            case sizeof(SCHEMEDATA_NT5):
                {
                    SCHEMEDATA_NT5 sd;
                    RegQueryValueEx(hkSchemes, szBuf, NULL, &dwType, (BYTE *)&sd, &dwSize);
                    if(2 != sd.version)
                        break; // We have the wrong version even though the size was correct

                    // Copy the color information from the registry info to g_rgSchemeData
                    g_rgSchemeData[g_nSchemeCount].nColorsUsed = COLOR_MAX_97_NT5;

                    // Copy the color array
                    for(int i=0;i<g_rgSchemeData[g_nSchemeCount].nColorsUsed;i++)
                        g_rgSchemeData[g_nSchemeCount].rgb[i] = sd.rgb[i];

                    g_nSchemeCount++;
                }
                break;
            default:
                // We had an unknown sized structure in the registry - IGNORE IT
#ifdef _DEBUG
                TCHAR sz[200];
                wsprintf(sz, __TEXT("Scheme - %s, size = %i, sizeof(95) = %i, sizeof(NT4) = %i, sizeof(97) = %i, sizeof(NT5) = %i"), szBuf, dwSize,
                        sizeof(SCHEMEDATA_95),
                        sizeof(SCHEMEDATA_NT4),
                        sizeof(SCHEMEDATA_97),
                        sizeof(SCHEMEDATA_NT5)
                        );
                MessageBox(NULL, sz, NULL, MB_OK);
#endif // _DEBUG
                break;
            }
        }
    }
    RegCloseKey(hkSchemes);
}

#endif // READSCHEMESFROMREGISTRY

void PORTABLE_NONCLIENTMETRICS::ApplyChanges() const
{
        NONCLIENTMETRICS ncmOrig;
        LOGFONT lfIconOrig;
        GetNonClientMetrics(&ncmOrig, &lfIconOrig);

        NONCLIENTMETRICS ncmNew;
        LOGFONT lfIconNew;

        ZeroMemory(&ncmNew, sizeof(ncmNew));
        ZeroMemory(&lfIconNew, sizeof(lfIconNew));

        ncmNew.cbSize = sizeof(ncmNew);
        ncmNew.iBorderWidth = m_iBorderWidth;
        ncmNew.iScrollWidth = m_iScrollWidth;
        ncmNew.iScrollHeight = m_iScrollHeight;
        ncmNew.iCaptionWidth = m_iCaptionWidth;
        ncmNew.iCaptionHeight = m_iCaptionHeight;
        ncmNew.lfCaptionFont.lfHeight = m_lfCaptionFont_lfHeight;
        ncmNew.lfCaptionFont.lfWeight = m_lfCaptionFont_lfWeight;
        ncmNew.iSmCaptionWidth = m_iSmCaptionWidth;
        ncmNew.iSmCaptionHeight = m_iSmCaptionHeight;
        ncmNew.lfSmCaptionFont.lfHeight = m_lfSmCaptionFont_lfHeight;
        ncmNew.lfSmCaptionFont.lfWeight = m_lfSmCaptionFont_lfWeight;
        ncmNew.iMenuWidth = m_iMenuWidth;
        ncmNew.iMenuHeight = m_iMenuHeight;
        ncmNew.lfMenuFont.lfHeight = m_lfMenuFont_lfHeight;
        ncmNew.lfMenuFont.lfWeight = m_lfMenuFont_lfWeight;
        ncmNew.lfStatusFont.lfHeight = m_lfStatusFont_lfHeight;
        ncmNew.lfStatusFont.lfWeight = m_lfStatusFont_lfWeight;
        ncmNew.lfMessageFont.lfHeight = m_lfMessageFont_lfHeight;
        ncmNew.lfMessageFont.lfWeight = m_lfMessageFont_lfWeight;
        lfIconNew.lfHeight = m_lfIconWindowsDefault_lfHeight;
        lfIconNew.lfWeight = m_lfIconWindowsDefault_lfWeight;


        // Fill in fonts
        if(m_nFontFaces)
        {
            TCHAR lfFaceName[LF_FACESIZE];
            LoadString(g_hInstDll, IDS_SYSTEMFONTNAME, lfFaceName, ARRAYSIZE(lfFaceName));

            BYTE lfCharSet;
            TCHAR szCharSet[20];
            if(LoadString(g_hInstDll,IDS_FONTCHARSET, szCharSet,sizeof(szCharSet)/sizeof(TCHAR))) {
                lfCharSet = (BYTE)_tcstoul(szCharSet,NULL,10);
            } else {
                lfCharSet = 0; // Default
            }

            ncmNew.lfCaptionFont.lfCharSet = lfCharSet;
            ncmNew.lfSmCaptionFont.lfCharSet = lfCharSet;
            ncmNew.lfMenuFont.lfCharSet = lfCharSet;
            ncmNew.lfStatusFont.lfCharSet = lfCharSet;
            ncmNew.lfMessageFont.lfCharSet = lfCharSet;
            lfIconNew.lfCharSet = lfCharSet;

            lstrcpy(ncmNew.lfCaptionFont.lfFaceName, lfFaceName);
            lstrcpy(ncmNew.lfSmCaptionFont.lfFaceName, lfFaceName);
            lstrcpy(ncmNew.lfMenuFont.lfFaceName, lfFaceName);
            lstrcpy(ncmNew.lfStatusFont.lfFaceName, lfFaceName);
            lstrcpy(ncmNew.lfMessageFont.lfFaceName, lfFaceName);
            lstrcpy(lfIconNew.lfFaceName, lfFaceName);
        }
        else
        {
            ncmNew.lfCaptionFont.lfCharSet = ncmOrig.lfCaptionFont.lfCharSet;
            ncmNew.lfSmCaptionFont.lfCharSet = ncmOrig.lfSmCaptionFont.lfCharSet;
            ncmNew.lfMenuFont.lfCharSet = ncmOrig.lfMenuFont.lfCharSet;
            ncmNew.lfStatusFont.lfCharSet = ncmOrig.lfStatusFont.lfCharSet;
            ncmNew.lfMessageFont.lfCharSet = ncmOrig.lfMessageFont.lfCharSet;
            lfIconNew.lfCharSet = lfIconOrig.lfCharSet;

            lstrcpy(ncmNew.lfCaptionFont.lfFaceName, ncmOrig.lfCaptionFont.lfFaceName);
            lstrcpy(ncmNew.lfSmCaptionFont.lfFaceName, ncmOrig.lfSmCaptionFont.lfFaceName);
            lstrcpy(ncmNew.lfMenuFont.lfFaceName, ncmOrig.lfMenuFont.lfFaceName);
            lstrcpy(ncmNew.lfStatusFont.lfFaceName, ncmOrig.lfStatusFont.lfFaceName);
            lstrcpy(ncmNew.lfMessageFont.lfFaceName, ncmOrig.lfMessageFont.lfFaceName);
            lstrcpy(lfIconNew.lfFaceName, lfIconOrig.lfFaceName);
        }


        if(0 != memcmp(&ncmNew, &ncmOrig, sizeof(ncmOrig)))
            SystemParametersInfo(SPI_SETNONCLIENTMETRICS, sizeof(ncmNew), (PVOID)&ncmNew, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
        if(0 != memcmp(&lfIconNew, &lfIconOrig, sizeof(lfIconOrig)))
            SystemParametersInfo(SPI_SETICONTITLELOGFONT, sizeof(lfIconNew), &lfIconNew, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
}

// Helpers for setting/getting numeric string reg entry 
void WINAPI RegQueryStr(
   LPTSTR lpDefault,
   HKEY hkey,
   LPTSTR lpSubKey,
   LPTSTR lpValueName,
   LPTSTR lpszValue,
   DWORD cbData) // note this is bytes, not characters.
{
   DWORD dwType;
   DWORD dwLast = cbData / (sizeof TCHAR) - 1;

   lstrcpy(lpszValue, lpDefault);
   if (ERROR_SUCCESS == RegOpenKeyEx(hkey, lpSubKey, 0, KEY_QUERY_VALUE, &hkey)) 
   {
      RegQueryValueEx(hkey, lpValueName, NULL, &dwType, (PBYTE) lpszValue, &cbData);
      lpszValue[dwLast] = TEXT('\0');
      RegCloseKey(hkey);
   }
}

BOOL RegSetStr(
    HKEY hkey,
    LPCTSTR lpSection,
    LPCTSTR lpKeyName,
    LPCTSTR lpString)
{
    BOOL fRet = FALSE;
    LONG lErr;
    DWORD dwDisposition;

    lErr = RegCreateKeyEx(
            hkey,
            lpSection,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_SET_VALUE,
            NULL,
            &hkey,
            &dwDisposition);

    if (ERROR_SUCCESS == lErr)
    {
        if (NULL != lpString)
        {
            lErr = RegSetValueEx(
                    hkey,
                    lpKeyName,
                    0,
                    REG_SZ,
                    (CONST BYTE *)lpString,
                    (lstrlen(lpString) + 1) * sizeof(*lpString));
        }
        else
        {
            lErr = RegSetValueEx(
                    hkey,
                    lpKeyName,
                    0,
                    REG_SZ,
                    (CONST BYTE *)__TEXT(""),
                    1 * sizeof(*lpString));
        }

        if (ERROR_SUCCESS == lErr)
        {
            fRet = TRUE;
        }
        RegCloseKey(hkey);
    }
    return(fRet);
}

DWORD WINAPI RegQueryStrDW(
    DWORD dwDefault,
    HKEY hkey,
    LPTSTR lpSubKey,
    LPTSTR lpValueName)
{
    DWORD dwRet = dwDefault;
    TCHAR szTemp[40];
    TCHAR szDefault[40];
    DWORD dwSize = sizeof(szTemp);

    wsprintf(szDefault, TEXT("%d"), dwDefault);

    RegQueryStr(szDefault, hkey, lpSubKey, lpValueName, szTemp, dwSize);

    dwRet = _ttol(szTemp);

    return dwRet;
}


BOOL RegSetStrDW(HKEY hkey, LPTSTR lpSection, LPCTSTR lpKeyName, DWORD dwValue)
{
    TCHAR szTemp[40];

    wsprintf(szTemp, TEXT("%d"), dwValue);
    return RegSetStr(hkey, lpSection, lpKeyName, szTemp);
}

//
/////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\sources.inc ===
TARGETNAME=accwiz
TARGETPATH=obj
TARGETTYPE=PROGRAM
USE_MSVCRT=1
USE_NATIVE_EH=1

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
           $(WINDOWS_LIB_PATH)\user32p.lib   \
           $(SDK_LIB_PATH)\gdi32.lib    \
           $(SDK_LIB_PATH)\mpr.lib      \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\comctl32.lib \
           $(SDK_LIB_PATH)\comdlg32.lib \
           $(SDK_LIB_PATH)\syssetup.lib \
           $(SDK_LIB_PATH)\setupapi.lib \
           $(SDK_LIB_PATH)\version.lib  \
           $(SDK_LIB_PATH)\shlwapi.lib  \
           $(SHELL_LIB_PATH)\shell32p.lib \
           $(SDK_LIB_PATH)\ole32.lib    \
		   $(SHELL_LIB_PATH)\uxthemep.lib

NOT_LEAN_AND_MEAN=1

!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=..;$(WINDOWS_INC_PATH);..\..\inc;$(SHELL_INC_PATH)

SOURCES= ..\Accwiz.cpp      \
         ..\CurSchme.cpp    \
         ..\DLGFONTS.CPP    \
         ..\LOOKDLG.CPP     \
         ..\LOOKPREV.CPP    \
         ..\precomp.CPP     \
         ..\Pgbase.cpp      \
         ..\Pgfinish.cpp    \
         ..\PGGENRIC.CPP    \
         ..\PGLOKPRV.CPP    \
         ..\PGMSEBUT.CPP    \
         ..\Pgmsecur.cpp    \
         ..\PGSVEDEF.CPP    \
         ..\Pgsvefil.cpp    \
         ..\PGTMEOUT.CPP    \
         ..\pgnWelCome.cpp  \
         ..\pgWelco2.cpp    \
         ..\pgWelcom.cpp    \
         ..\Pgwizopt.cpp    \
         ..\pgcaret.cpp     \
         ..\SCHEMES.CPP     \
         ..\Select.cpp      \
         ..\accwiz.rc

UMENTRY=winmain

UMTYPE=windows

PRECOMPILED_INCLUDE=..\pch.hxx
PRECOMPILED_PCH=pch.pch
PRECOMPILED_OBJ=pch.obj
PRECOMPILED_CXX=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\accwiz\version.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
// ACCWIZ.EXE version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "Microsoft Accessibility Wizard"
#define VER_INTERNALNAME_STR        "ACCWIZ"
#define VER_ORIGINALFILENAME_STR    "ACCWIZ.EXE"
#define VER_FILETYPE                VFT_APP
#define VER_FILESUBTYPE             VFT2_UNKNOWN

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\inc\deskswitch.c ===
/*************************************************************************
    Module:     DeskSwitch.c

    Copyright (C) 1997-2000 by Microsoft Corporation.  All rights reserved.
*************************************************************************/
#ifdef _WIN32_IE
#undef _WIN32_IE
#endif
#define _WIN32_IE 0x0600
#include <shlwapi.h>    // for IsOS
#include <shlwapip.h>    // for IsOS

////////////////////////////////////////////////////////////////////////////
// Helper functions and globals for detecting desktop switch
//
// Usage:  Call InitWatchDeskSwitch() with an hWnd and message during
//         initialization.  The message will be posted to hWnd whenever
//         a desktop switch has occurred.  When the message is received
//         the desktop switch has taken place already.
//
//         Call TermWatchDeskSwitch() to stop watching for desktop
//         switches.
////////////////////////////////////////////////////////////////////////////

HANDLE g_hDesktopSwitchThread = 0;
HANDLE g_hDesktopSwitchEvent = 0;
HANDLE g_hTerminateEvent = 0;

typedef struct MsgInfo {
    HWND    hWnd;
    DWORD   dwMsg;
    DWORD   dwTIDMain;
    DWORD   fPostMultiple;
} MSG_INFO;
MSG_INFO g_MsgInfo;

void Cleanup()
{
	if (g_hDesktopSwitchEvent)
	{
		CloseHandle(g_hDesktopSwitchEvent);
		g_hDesktopSwitchEvent = 0;
	}
	if (g_hTerminateEvent)
	{
		CloseHandle(g_hTerminateEvent);
		g_hTerminateEvent = 0;
	}
}

#ifndef DESKTOP_ACCESSDENIED
#define DESKTOP_ACCESSDENIED 0
#define DESKTOP_DEFAULT      1
#define DESKTOP_SCREENSAVER  2
#define DESKTOP_WINLOGON     3
#define DESKTOP_TESTDISPLAY  4
#define DESKTOP_OTHER        5
#endif

int GetDesktopType()
{
    HDESK hdesk;
    TCHAR szName[100];
    DWORD nl;
    int iCurrentDesktop = DESKTOP_OTHER;

    hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (!hdesk)
    {
         hdesk = OpenDesktop(TEXT("Winlogon"), 0, FALSE, MAXIMUM_ALLOWED);
         if (!hdesk)
         {
            // fails when ap has insufficient permission on secure desktop
            return DESKTOP_ACCESSDENIED;
         }
    }
    GetUserObjectInformation(hdesk, UOI_NAME, szName, 100, &nl);
    CloseDesktop(hdesk);

    if (!lstrcmpi(szName, TEXT("Default"))) 
    {
        iCurrentDesktop = DESKTOP_DEFAULT;
    } else if (!lstrcmpi(szName, TEXT("Winlogon")))
    {
        iCurrentDesktop = DESKTOP_WINLOGON;
    }
    return iCurrentDesktop;
}

// WatchDesktopProc - waits indefinitely for a desktop switch.  When
//                    it gets one, it posts a message to the window
//                    specified in InitWatchDeskSwitch.  It also waits
//                    on an event that signals the procedure to exit.
//
DWORD WatchDesktopProc(LPVOID pvData)
{
    BOOL fCont = TRUE;
    DWORD dwEventIndex;
	HANDLE ahEvents[2];
    int iDesktopT, iCurrentDesktop = GetDesktopType();

    SetThreadDesktop(GetThreadDesktop(g_MsgInfo.dwTIDMain));

	ahEvents[0] = g_hDesktopSwitchEvent;
	ahEvents[1] = g_hTerminateEvent;
    
    while (fCont)
    {
        iDesktopT = GetDesktopType();
        if (iDesktopT == iCurrentDesktop)
        {
            DBPRINTF(TEXT("Wait for desktop switch or exit on desktop = %d\r\n"), iCurrentDesktop);
            dwEventIndex = WaitForMultipleObjects(2, ahEvents, FALSE, INFINITE);
		    dwEventIndex -= WAIT_OBJECT_0;
        } else
        {
            // missed a desktop switch so handle it
            dwEventIndex = 0;
        }

        switch (dwEventIndex) 
        {
			case 0:
            // With a FUS there is a spurious switch to Winlogon
            iDesktopT = GetDesktopType();
            DBPRINTF(TEXT("desktop switch from %d to %d\r\n"), iCurrentDesktop, iDesktopT);
            if (iDesktopT != iCurrentDesktop)
            {
                iCurrentDesktop = iDesktopT;

			    // Handle desk switch event
			    DBPRINTF(TEXT("WatchDesktopProc:  PostMessage(0x%x, %d...) desktop %d\r\n"), g_MsgInfo.hWnd, g_MsgInfo.dwMsg, iCurrentDesktop);
			    PostMessage(g_MsgInfo.hWnd, g_MsgInfo.dwMsg, iCurrentDesktop, 0);
            } else DBPRINTF(TEXT("WatchDesktopProc:  Ignore switch to %d\r\n"), iDesktopT);
			break;

			case 1:
			// Handle terminate thread event
			fCont = FALSE;
			DBPRINTF(TEXT("WatchDesktopProc:  got terminate event\r\n"));
			break;

            default:
			// Unexpected event
            fCont = FALSE;
			DBPRINTF(TEXT("WatchDesktopProc unexpected event %d\r\n"), dwEventIndex + WAIT_OBJECT_0);
			break;
        }
    }

	Cleanup();

    DBPRINTF(TEXT("WatchDesktopProc returning...\r\n"));
    return 0;
}

// InitWatchDeskSwitch - starts a thread to watch for desktop switches
//
// hWnd  [in]   - window handle to post message to
// dwMsg [in]   - message to post on desktop switch
//
// Call this function after the window has been created whenever it
// is to wait for a desktop switch.
// 
void InitWatchDeskSwitch(HWND hWnd, DWORD dwMsg)
{
    DWORD dwTID;

    if (g_hDesktopSwitchThread || g_hDesktopSwitchEvent)
        return; // don't do this again if it's already running

	// Create an unnamed event used to signal the thread to terminate
	g_hTerminateEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

	// and open the desktop switch event.  If utility manager is
    // running then we will wait on it's desktop switch event otherwise
    // wait on the system desktop switch event.  If waiting on utilman
    // then only post one switch message.
	g_hDesktopSwitchEvent = OpenEvent(SYNCHRONIZE
                                    , FALSE
                                    , TEXT("UtilMan_DesktopSwitch"));
    g_MsgInfo.fPostMultiple = FALSE;

    if (!g_hDesktopSwitchEvent)
    {
	    g_hDesktopSwitchEvent = OpenEvent(SYNCHRONIZE
                                        , FALSE
                                        , TEXT("WinSta0_DesktopSwitch"));
        g_MsgInfo.fPostMultiple = TRUE;
    }

    if (g_hDesktopSwitchEvent && g_hTerminateEvent)
    {
		g_MsgInfo.hWnd = hWnd;
		g_MsgInfo.dwMsg = dwMsg;
		g_MsgInfo.dwTIDMain = GetCurrentThreadId();

		DBPRINTF(TEXT("InitWatchDeskSwitch(0x%x, %d, %d)\r\n"), g_MsgInfo.hWnd, g_MsgInfo.dwMsg, g_MsgInfo.dwTIDMain);
		g_hDesktopSwitchThread = CreateThread(
					  NULL, 0
					, WatchDesktopProc
					, &g_MsgInfo, 0
					, &dwTID);
    }

	// cleanup if failed to create thread

    if (!g_hDesktopSwitchThread)
    {
        DBPRINTF(TEXT("InitWatchDeskSwitch failed!\r\n"));
		Cleanup();
    }
}

// TermWatchDeskSwitch - cleans up after a desktop switch
//
// Call this function to terminate the thread that is watching
// for desktop switches (if it is running) and to clean up the
// event handle.
// 
void TermWatchDeskSwitch()
{
    DBPRINTF(TEXT("TermWatchDeskSwitch...\r\n"));
    if (g_hDesktopSwitchThread)
    {
		SetEvent(g_hTerminateEvent);
        DBPRINTF(TEXT("TermWatchDeskSwitch: SetEvent(0x%x)\r\n"), g_hDesktopSwitchThread);
        g_hDesktopSwitchThread = 0;
    } else DBPRINTF(TEXT("TermWatchDeskSwitch: g_hDesktopSwitchThread = 0\r\n"));
}

////////////////////////////////////////////////////////////////////////////
// helper functions for detecting if UtilMan is running (in
// which case this applets is being managed by it)
////////////////////////////////////////////////////////////////////////////

__inline BOOL IsUtilManRunning()
{
    HANDLE hEvent = OpenEvent(SYNCHRONIZE, FALSE, TEXT("UtilityManagerIsActiveEvent"));
    if (hEvent != NULL)
    {
        CloseHandle(hEvent);
        return TRUE;
    }
    return FALSE;
}

__inline BOOL CanLockDesktopWithoutDisconnect()
{
    // This function may have to change if UI is added to Whistler that
    // allows switching users for computers that are part of a domain.
    // For now, domain users may have FUS enabled because TS allows remote
    // logon which can result in multiple sessions on a machine (a form
    // of FUS) even though Start/Logoff doesn't allow the "Switch User" 
    // option.  In this case, the user can lock their desktop without
    // causing their session to disconnect.  If FUS is explicitly off
    // in the registry then "Switch User" is not a Logoff option nor can
    // a remote logon happen and the user can lock their desktop without
    // causing their session to disconnect.
    return (IsOS(OS_DOMAINMEMBER) || !IsOS(OS_FASTUSERSWITCHING));
}

////////////////////////////////////////////////////////////////////////////
// RunSecure - helper function to tell accessibility UI when to run secure
//             (no help, no active URL links, etc...).  Accessibility UI
//             should run in secure mode if it is running on the winlogon
//             desktop or as SYSTEM.
////////////////////////////////////////////////////////////////////////////
BOOL RunSecure(DWORD dwDesktop)
{
    BOOL fOK = TRUE;
    BOOL fIsLocalSystem = TRUE;
    SID_IDENTIFIER_AUTHORITY siaLocalSystem = SECURITY_NT_AUTHORITY;
    PSID psidSystem = 0;

    if (dwDesktop == DESKTOP_WINLOGON)
        return TRUE;

    if (AllocateAndInitializeSid(&siaLocalSystem, 
                                1,
                                SECURITY_LOCAL_SYSTEM_RID,
                                0, 0, 0, 0, 0, 0, 0,
                                &psidSystem) && psidSystem)
    {           
        fOK = CheckTokenMembership(NULL, psidSystem, &fIsLocalSystem);
        FreeSid(psidSystem);
    }

    return (fOK && fIsLocalSystem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\inc\mappedfile.h ===
//Copyright (c) 1997-2000 Microsoft Corporation
//
// This header contains classes used to manage the memory mapped file for this DLL
//

class CScopeMutex
{
public:
    CScopeMutex()
        : m_hMutex(0)
        {};
    ~CScopeMutex() { MutexRelease(); }
    BOOL Create(LPCTSTR szMutex, unsigned long ulWait)
    {
	    m_hMutex = CreateMutex( NULL, FALSE, szMutex );
        if (m_hMutex)
        {
    	    WaitForSingleObject(m_hMutex, ulWait);
			return TRUE;
        }
	    DBPRINTF(TEXT("CScopeMutex::Create FAILED\r\n"));
        return FALSE;
    }
    void Release()
    {
        MutexRelease();
    }

private:
    HANDLE m_hMutex;

    inline void MutexRelease()
    {
        if (m_hMutex)
        {
	        ReleaseMutex(m_hMutex);
	        CloseHandle(m_hMutex);
            m_hMutex = 0;
        }
    }
};

class CMemMappedFile 
{
public:
    CMemMappedFile()     
        : m_hMappedFile(0)
        , m_pvMappedAddr(0)
        , m_fFirstOpen(FALSE)
        {};
    ~CMemMappedFile() { Close(); }
    BOOL Open(LPCTSTR szName, unsigned long ulMemSize);
    BOOL AccessMem(void **ppvMappedAddr);
    void Close();
    BOOL FirstOpen() { return m_fFirstOpen; }

private:
    HANDLE m_hMappedFile;
    void *m_pvMappedAddr;
    BOOL m_fFirstOpen;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\inc\w95trace.c ===
// Copyright (c) 1996-1999 Microsoft Corporation


/*
    Implementation of Win95 tracing facility to mimic that of NT. Works on both.
*/

#pragma warning(disable:4201)	// allows nameless structs and unions
#pragma warning(disable:4514)	// don't care when unreferenced inline functions are removed
#pragma warning(disable:4706)	// we are allowed to assign within a conditional


#include "windows.h"
#include <stdio.h>
#include <stdarg.h>
#include <process.h>
#include "w95trace.h"

// Uncomment the following line if you need debugging but can't use the mutex
//#define NOMUTEX

#if defined( _DEBUG ) ||defined( DEBUG ) || defined( DBG )

#ifdef __cplusplus
extern "C" {
#endif

static HANDLE g_hSpewFile = INVALID_HANDLE_VALUE;

__inline BOOL TestMutex()
{
#ifndef NOMUTEX
    HANDLE hTestMutex = OpenMutex( SYNCHRONIZE, FALSE, TEXT("oleacc-msaa-use-dbwin") );
    if( ! hTestMutex )
        return FALSE;
    CloseHandle( hTestMutex );
#endif
    return TRUE;
}

void OutputDebugStringW95( LPCTSTR lpOutputString, ...)
{
    // Only produce output if this mutex is set...
    if (TestMutex())
	{
        HANDLE heventDBWIN;  /* DBWIN32 synchronization object */
        HANDLE heventData;   /* data passing synch object */
        HANDLE hSharedFile;  /* memory mapped file shared data */
        LPTSTR lpszSharedMem;
        TCHAR achBuffer[500];
        int cch;

        /* create the output buffer */
        va_list args;
        va_start(args, lpOutputString);
        cch = wvsprintf(achBuffer, lpOutputString, args);
        va_end(args);

        /* 
            Do a regular OutputDebugString so that the output is 
            still seen in the debugger window if it exists.

            This ifdef is necessary to avoid infinite recursion 
            from the inclusion of W95TRACE.H
        */
#ifdef UNICODE
        OutputDebugStringW(achBuffer);
#else
        ::OutputDebugStringA(achBuffer);
#endif

//        Uncomment the following lines if you need DBPRINTF lines to go to a file
//        (your code will have to open and close the file)
//        if (g_hSpewFile && g_hSpewFile != INVALID_HANDLE_VALUE)
//        {
//            SpewToFile(achBuffer);
//        }

        /* bail if it's not Win95 */
        {
            OSVERSIONINFO VerInfo;
            VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
            GetVersionEx(&VerInfo);
            if ( VerInfo.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS )
                return;
        }

        /* make sure DBWIN is open and waiting */
        heventDBWIN = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("DBWIN_BUFFER_READY"));
        if ( !heventDBWIN )
        {
            //MessageBox(NULL, TEXT("DBWIN_BUFFER_READY nonexistent"), NULL, MB_OK);
            return;            
        }

        /* get a handle to the data synch object */
        heventData = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("DBWIN_DATA_READY"));
        if ( !heventData )
        {
            // MessageBox(NULL, TEXT("DBWIN_DATA_READY nonexistent"), NULL, MB_OK);
            CloseHandle(heventDBWIN);
            return;            
        }
    
        hSharedFile = CreateFileMapping((HANDLE)-1, NULL, PAGE_READWRITE, 0, 4096, TEXT("DBWIN_BUFFER"));
        if (!hSharedFile) 
        {
            //MessageBox(NULL, TEXT("DebugTrace: Unable to create file mapping object DBWIN_BUFFER"), TEXT("Error"), MB_OK);
            CloseHandle(heventDBWIN);
            CloseHandle(heventData);
            return;
        }

        lpszSharedMem = (LPTSTR)MapViewOfFile(hSharedFile, FILE_MAP_WRITE, 0, 0, 512);
        if (!lpszSharedMem) 
        {
            //MessageBox(NULL, "DebugTrace: Unable to map shared memory", "Error", MB_OK);
            CloseHandle(heventDBWIN);
            CloseHandle(heventData);
            return;
        }

        /* wait for buffer event */
        WaitForSingleObject(heventDBWIN, INFINITE);

        /* write it to the shared memory */
        *((LPDWORD)lpszSharedMem) = _getpid();
        wsprintf(lpszSharedMem + sizeof(DWORD), TEXT("%s"), achBuffer);

        /* signal data ready event */
        SetEvent(heventData);

        /* clean up handles */
        CloseHandle(hSharedFile);
        CloseHandle(heventData);
        CloseHandle(heventDBWIN);
	}
    return;
}
void SpewOpenFile(LPCTSTR pszSpewFile)
{
#ifdef UNICODE // only works for unicode
    // Only produce output if this mutex is set...
    if (g_hSpewFile == INVALID_HANDLE_VALUE && TestMutex())
    {
        TCHAR szSpewFile[MAX_PATH] = TEXT("C:\\");
#ifndef NOMUTEX
        // if NOMUTEX is defined most likely you are debugging when
        // there's no interactive user (so no temp path)
        GetTempPath(MAX_PATH, szSpewFile);
#endif
        if (lstrlen(szSpewFile)+lstrlen(pszSpewFile) >= MAX_PATH)
        {
            MessageBox(NULL, TEXT("SpewOpenFile:  Name will be longer than MAX_PATH"), TEXT("OOPS"), MB_OK);
            return;
        }
        lstrcat(szSpewFile, pszSpewFile);
        g_hSpewFile = CreateFile(szSpewFile, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == g_hSpewFile)
        {
//            MessageBox(NULL, TEXT("SpewOpenFile:  Unable to open spew file"), TEXT("Error"), MB_OK);
        }
    }
#endif
}
void SpewToFile( LPCTSTR lpOutputString, ...)
{
#ifdef UNICODE // only works for unicode
    if (g_hSpewFile != INVALID_HANDLE_VALUE && TestMutex())
    {
        TCHAR achBuffer[1025];
        CHAR achAnsiBuf[500];
        DWORD dwcBytesWr, dwcBytes;
        va_list args;
        va_start(args, lpOutputString);
        wvsprintf(achBuffer, lpOutputString, args);
        dwcBytes = WideCharToMultiByte(CP_ACP, 0, achBuffer, -1, achAnsiBuf, sizeof(achAnsiBuf)*sizeof(CHAR), NULL, NULL);
        if (!WriteFile(g_hSpewFile, achAnsiBuf, dwcBytes-1, &dwcBytesWr, NULL))
        {
//            MessageBox(NULL, TEXT("SpewToFile:  Unable to write to spew file"), TEXT("Error"), MB_OK);
        }
        va_end(args);
    }
#endif
}
void SpewCloseFile()
{
#ifdef UNICODE // only works for unicode
    if (g_hSpewFile != INVALID_HANDLE_VALUE && TestMutex())
        CloseHandle(g_hSpewFile);
#endif
}
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\inc\mappedfile.cpp ===
//Copyright (c) 1997-2000 Microsoft Corporation

// Memory mapped file routines

#include <windows.h>
#include "w95trace.h"
#include "mappedfile.h"

BOOL CMemMappedFile::Open(
    LPCTSTR szName,         // name of the mapped file
    unsigned long ulMemSize // size of the mapped file
    )
{
    // assumption: the code isn't going to call Open twice w/different szName
    if (!m_hMappedFile)
    {
        // Create the mapped file from system page file.  If it has been created
        // previously, then CreateFileMapping acts like OpenFileMapping.

        m_hMappedFile = CreateFileMapping(
            INVALID_HANDLE_VALUE,    // Current file handle. 
            NULL,                    // Default security. 
            PAGE_READWRITE,          // Read/write permission. 
            0,                       // Hi-order DWORD of file size
            ulMemSize,               // Lo-order DWORD of file size
            szName);                 // Name of mapping object. 

        if (!m_hMappedFile) 
        {
            DBPRINTF(TEXT("CMemMappedFile::Open:  CreateFileMapping %s failed 0x%x\r\n"), szName, GetLastError());
            return FALSE;
        }

        // Note if this is the first open for the file?
        m_fFirstOpen = (GetLastError() == ERROR_SUCCESS)?TRUE:FALSE;
    }

    return TRUE;
}

BOOL CMemMappedFile::AccessMem(
    void **ppvMappedAddr    // returned pointer into memory
    )
{
    if (IsBadWritePtr(ppvMappedAddr, sizeof(void *)))
        return FALSE;

    if (!m_hMappedFile)
        return FALSE;

    // Get a pointer to the mapped memory if we don't already have it

    if (!m_pvMappedAddr)
    {
	    DBPRINTF(TEXT("MapViewOfFile\r\n"));
        m_pvMappedAddr = MapViewOfFile(
            m_hMappedFile,           // Handle to mapping object. 
            FILE_MAP_ALL_ACCESS,     // Read/write permission 
            0,                       // Max. object size. 
            0,                       // Size of hFile. 
            0);                      // Map entire file. 

        *ppvMappedAddr = m_pvMappedAddr;
    }

    if (NULL == m_pvMappedAddr) 
    {
        DBPRINTF(TEXT("CMemMappedFile::AccessMem:  MapViewOfFile failed 0x%x\r\n"), GetLastError());
        return FALSE;
    }

    return TRUE;
}

void CMemMappedFile::Close()
{
    if (m_pvMappedAddr)
    {
        UnmapViewOfFile(m_pvMappedAddr);
	    m_pvMappedAddr = 0;
    }

    if (m_hMappedFile)
    {
        CloseHandle(m_hMappedFile);
        m_hMappedFile = 0;
    }

    m_fFirstOpen = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\inc\w95trace.h ===
/*
    declarations for Win95 tracing facility
*/

#ifndef __TRACEW95__
#define __TRACEW95__



#if defined( _DEBUG ) ||defined( DEBUG ) || defined( DBG )

#define DBPRINTF OutputDebugStringW95




// redefine all the MFC macros to point to us

#undef  TRACE
#define TRACE   OutputDebugStringW95

#undef  TRACE0
#define TRACE0   OutputDebugStringW95

#undef  TRACE1
#define TRACE1   OutputDebugStringW95

#undef  TRACE2
#define TRACE2   OutputDebugStringW95

#undef  TRACE3
#define TRACE3   OutputDebugStringW95

// redefine OutputDebugString so that it works with 
// API calls
#undef OutputDebugString
#define OutputDebugString   OutputDebugStringW95


// function declarations
#ifdef __cplusplus
extern "C" {
#endif
void OutputDebugStringW95( LPCTSTR lpOutputString, ... );
void SpewOpenFile(LPCTSTR pszSpewFile);
void SpewToFile( LPCTSTR lpOutputString, ...);
void SpewCloseFile();
#ifdef __cplusplus
}
#endif



#else
// avoid warning:
// error C4353: nonstandard extension used: constant 0 as function expression.
// Use '__noop' function intrinsic instead
  #define DBPRINTF        __noop
  #define SpewOpenFile    __noop
  #define SpewToFile      __noop
  #define SpewCloseFile   __noop
#endif  // _DEBUG || DEBUG || DBG


#endif  //__TRACEW95__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\inc\tssessionnotify.c ===
#include "wtsapi32.h"   // for terminal services

typedef LRESULT CALLBACK FN_TSNotifyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
typedef BOOL (WINAPI *LPWTSREGISTERSESSIONNOTIFICATION)(HWND hWnd, DWORD dwFlags);
typedef BOOL (WINAPI *LPWTSUNREGISTERSESSIONNOTIFICATION)(HWND hWnd);
HMODULE g_hLibrary = 0;
LPWTSREGISTERSESSIONNOTIFICATION g_lpfnWTSRegisterSessionNotification = 0;
LPWTSUNREGISTERSESSIONNOTIFICATION g_lpfnWTSUnRegisterSessionNotification = 0;

BOOL GetWTSLib()
{
	TCHAR szSysDir[_MAX_PATH+15];
	int ctch = GetSystemDirectory(szSysDir, _MAX_PATH);  // leave enouph space for the dll
	if (!ctch)
		return FALSE;	// should never happen

	lstrcat(szSysDir, _TEXT("\\"));
	lstrcat(szSysDir, TEXT("wtsapi32.dll") );

	g_hLibrary = LoadLibrary(szSysDir);
	if (g_hLibrary)
	{
	    g_lpfnWTSRegisterSessionNotification 
            = (LPWTSREGISTERSESSIONNOTIFICATION)GetProcAddress(
                                                      g_hLibrary
                                                    , "WTSRegisterSessionNotification");
	    g_lpfnWTSUnRegisterSessionNotification 
            = (LPWTSUNREGISTERSESSIONNOTIFICATION)GetProcAddress(
                                                      g_hLibrary
                                                    , "WTSUnRegisterSessionNotification");
	}
    return (g_lpfnWTSRegisterSessionNotification 
         && g_lpfnWTSUnRegisterSessionNotification)?TRUE:FALSE;
}

void FreeWTSLib()
{
	if (g_hLibrary)
	{
		FreeLibrary(g_hLibrary);
        g_hLibrary = 0;
        g_lpfnWTSRegisterSessionNotification = 0;
        g_lpfnWTSUnRegisterSessionNotification = 0;
	}
}

// CreateWTSNotifyWindow - create a message-only windows to handle 
// terminal server notification messages
//
HWND CreateWTSNotifyWindow(HINSTANCE hInstance, FN_TSNotifyWndProc lpfnTSNotifyWndProc)
{
    HWND hWnd = 0;

    if (GetWTSLib())
    {
        LPTSTR pszWindowClass = TEXT("TS Notify Window");
	    WNDCLASS wc;
	    wc.style = 0;
	    wc.lpfnWndProc = lpfnTSNotifyWndProc;
        wc.cbClsExtra = 0;
	    wc.cbWndExtra = 0;
	    wc.hInstance = hInstance;
        wc.hIcon = NULL;
	    wc.hCursor = NULL;
	    wc.hbrBackground = NULL;
        wc.lpszMenuName = NULL;
	    wc.lpszClassName = pszWindowClass;

        // RegisterClass can legally fail sometimes.  If the class fails 
        // to register, we'll fail when we try to create the window.

	    RegisterClass(&wc);

	    // Create window to receive terminal service notification messages
        hWnd = CreateWindow(
                      pszWindowClass
                    , NULL,0,0,0,0,0
                    , HWND_MESSAGE
                    , NULL, hInstance, NULL);
	    if( hWnd )
	    {
            if (!g_lpfnWTSRegisterSessionNotification(hWnd, NOTIFY_FOR_THIS_SESSION))
            {
                DBPRINTF(TEXT("CreateWTSNotifyWindow:  WTSRegisterSessionNotification FAILED %d\r\n"), GetLastError());
                DestroyWindow(hWnd);
                hWnd = 0;
            }
        }
    }

    return hWnd;
}

// DestroyWTSNotifyWindow - clean up terminal server notification window
//
void DestroyWTSNotifyWindow(HWND hWnd)
{
	if(hWnd && g_lpfnWTSUnRegisterSessionNotification)
	{
        g_lpfnWTSUnRegisterSessionNotification(hWnd);
        DBPRINTF(TEXT("DestroyWTSNotifyWindow:  WTSUnRegisterSessionNotification returned %d\r\n"), GetLastError());
    }

	if(hWnd)
	{
        DestroyWindow(hWnd);
    }
    FreeWTSLib();
}

/*
// TSNotifyWndProc - callback that receives window message notifications from terminal services
//
// This is a sample notification callback function
//
LRESULT CALLBACK TSNotifyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg != WM_WTSSESSION_CHANGE)
        return 0;

	switch (wParam)
	{
		case WTS_CONSOLE_CONNECT:   // local session is connected
		break;

		case WTS_CONSOLE_DISCONNECT:// local session is disconnected
		break;

		case WTS_REMOTE_CONNECT:    // remote session is connected
		break;

		case WTS_REMOTE_DISCONNECT: // remote session is disconnected
		break;

		case WTS_SESSION_LOGON:     // session is being logged on
		break;

		case WTS_SESSION_LOGOFF:    // session is being logged off
		break;

		default:
		break;
	}

	return DefWindowProc( hwnd, uMsg, wParam, lParam );
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\inc\wineventrefilter.h ===
//
// wineventrefilter - utility class to filter out reentrant WinEvent events
//
// Copyright (C) 1998 by Microsoft Corporation.  All rights reserved.
//



typedef 
void CALLBACK FN_WinEventProc( HWINEVENTHOOK hEvent,
                               DWORD         event,
                               HWND          hwnd,
                               LONG          idObject,
                               LONG          idChild,
                               DWORD         idThread,
                               DWORD         dwmsEventTime );


class WinEventReentrancyFilter
{
public:

    virtual ~WinEventReentrancyFilter() { }
    virtual void SetCallback( FN_WinEventProc *  pWinEventProc ) = 0;
    virtual void HandleWinEvent( HWINEVENTHOOK hEvent,
                                 DWORD         event,
                                 HWND          hwnd,
                                 LONG          idObject,
                                 LONG          idChild,
                                 DWORD         idThread,
                                 DWORD         dwmsEventTime ) = 0;
};


WinEventReentrancyFilter * CreateWinEventReentrancyFilter();




// Template class that makes this easier to use.
//
// If your existing code looks like...
//
//     void CALLBACK MyWinEventProc( ... );
//
//     ...
//
//     HWINEVENTHOOK hHook = SetWinEventHook(
//                                    ...
//                                    MyWinEventProc
//                                    ... );
//
//
// Change it to...
//
//     // No changes to WinEventProc
//     void CALLBACK WinEventProc( ... );
//
//     // * Add a new global - the template parameter is the name of your
//     //   existing callback...
//     CWinEventReentrancyFilter< MyWinEventProc > g_WinEventReFilter;
//
//     ...
//
//
//     // * Call SetWinEventHook using g_WinEventReFilter.WinEventProc
//     //   instead of your callback. This will filter reentrant events,
//     //   and pass them to your callback in the correct order.
//     HWINEVENTHOOK hHook = SetWinEventHook(
//                                    ...
//                                    g_WinEventReFilter.WinEventProc
//                                    ... );
//
//
// It is acceptable to use multiple filters, provided that they all
// use different callbacks. For example, this is allowed:
//
//     void CALLBACK MyWinEventProc1( ... );
//     void CALLBACK MyWinEventProc2( ... );
//
//     CWinEventReentrancyFilter< MyWinEventProc1 > g_WinEventReFilter1;
//     CWinEventReentrancyFilter< MyWinEventProc2 > g_WinEventReFilter2;
//
// ... but this is NOT allowed ...
//
//     void CALLBACK MyWinEventProc( ... );
//
//     CWinEventReentrancyFilter< MyWinEventProc > g_WinEventReFilter1;
//     CWinEventReentrancyFilter< MyWinEventProc > g_WinEventReFilter2;
//

template < FN_WinEventProc pCallback >
class CWinEventReentrancyFilter
{
    static
    WinEventReentrancyFilter * m_pFilter;

public:

    CWinEventReentrancyFilter()
    {
        m_pFilter = CreateWinEventReentrancyFilter();
        if( m_pFilter )
        {
            m_pFilter->SetCallback( pCallback );
        }
    }

    BOOL Check()
    {
        return m_pFilter;
    }

    ~CWinEventReentrancyFilter()
    {
        if( m_pFilter )
        {
            delete m_pFilter;
        }
    }

    static
    void CALLBACK WinEventProc( HWINEVENTHOOK hEvent,
                                DWORD         event,
                                HWND          hwnd,
                                LONG          idObject,
                                LONG          idChild,
                                DWORD         idThread,
                                DWORD         dwmsEventTime )
    {
        if( ! m_pFilter )
            return;
        m_pFilter->HandleWinEvent( hEvent, event, hwnd, idObject, idChild,
                                   idThread, dwmsEventTime );
    }
};

template < FN_WinEventProc pCallback >
WinEventReentrancyFilter * CWinEventReentrancyFilter< pCallback >::m_pFilter = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\narrator\narrator\narrator.cpp ===
/*************************************************************************
    Project:    Narrator
    Module:     narrator.c

    Author:     Paul Blenkhorn 
    Date:       April 1997

    Notes:      Contains main application initalization code
                Credit to be given to MSAA team - bits of code have been
                lifted from:
                Babble, Inspect, and Snapshot.

    Copyright (C) 1997-1999 by Microsoft Corporation.  All rights reserved.
    See bottom of file for disclaimer

    History: Bug Fixes/ New features/ Additions: 1999 Anil Kumar

*************************************************************************/
#define STRICT

#include <windows.h>
#include <windowsx.h>
#include <oleacc.h>
#include <string.h>
#include <stdio.h>
#include <mmsystem.h>
#include <initguid.h>
#include <objbase.h>
#include <objerror.h>
#include <ole2ver.h>
#include <commctrl.h>
#include "Narrator.h"
#include "resource.h"
#include <htmlhelp.h>
#include "reader.h"
#include "..\NarrHook\keys.h"
#include "w95trace.c"
#include "DeskSwitch.c"

// Bring in Speech API declarations
// The SAPI5 define determines whether SAPI5 or SAPI4 is used.  Comment out
// the next line to use SAPI4.
#define SAPI5
#ifndef SAPI5
#include "speech.h"
#else
#include "sapi.h"
#endif
#include <stdlib.h>

// UM
#include <TCHAR.h>
#include <string.h>
#include <WinSvc.h>
#include <stdio.h>

#define MAX_ENUMMODES 80
#define MAX_LANGUAGES 27
#define MAX_NAMELEN   30	// number of characters in the name excluding the path info
#define WM_DELAYEDMINIMIZE WM_USER + 102
#define ARRAYSIZE(n)    (sizeof(n)/sizeof(n[0]))

#ifndef SAPI5
// TTS info
TTSMODEINFO gaTTSInfo[MAX_ENUMMODES];
PIAUDIOMULTIMEDIADEVICE    pIAMM;      // multimedia device interface for audio-dest
#endif

DEFINE_GUID(MSTTS_GUID, 
0xC5C35D60, 0xDA44, 0x11D1, 0xB1, 0xF1, 0x0, 0x0, 0xF8, 0x03, 0xE4, 0x56);


// language test table, taken from WINNT.h...
LPTSTR Languages[MAX_LANGUAGES]={
    TEXT("NEUTRAL"),TEXT("BULGARIAN"),TEXT("CHINESE"),TEXT("CROATIAN"),TEXT("CZECH"),
    TEXT("DANISH"),TEXT("DUTCH"),TEXT("ENGLISH"),TEXT("FINNISH"),
    TEXT("FRENCH"),TEXT("GERMAN"),TEXT("GREEK"),TEXT("HUNGARIAN"),TEXT("ICELANDIC"),
    TEXT("ITALIAN"),TEXT("JAPANESE"),TEXT("KOREAN"),TEXT("NORWEGIAN"),
    TEXT("POLISH"),TEXT("PORTUGUESE"),TEXT("ROMANIAN"),TEXT("RUSSIAN"),TEXT("SLOVAK"),
    TEXT("SLOVENIAN"),TEXT("SPANISH"),TEXT("SWEDISH"),TEXT("TURKISH")};

WORD LanguageID[MAX_LANGUAGES]={
    LANG_NEUTRAL,LANG_BULGARIAN,LANG_CHINESE,LANG_CROATIAN,LANG_CZECH,LANG_DANISH,LANG_DUTCH,
    LANG_ENGLISH,LANG_FINNISH,LANG_FRENCH,LANG_GERMAN,LANG_GREEK,LANG_HUNGARIAN,LANG_ICELANDIC,
    LANG_ITALIAN,LANG_JAPANESE,LANG_KOREAN,LANG_NORWEGIAN,LANG_POLISH,LANG_PORTUGUESE,
    LANG_ROMANIAN,LANG_RUSSIAN,LANG_SLOVAK,LANG_SLOVENIAN,LANG_SPANISH,LANG_SWEDISH,LANG_TURKISH};

// Start Type
DWORD StartMin = FALSE;
// Show warning
DWORD ShowWarn = TRUE;

// the total number of enumerated modes
DWORD gnmodes=0;                        

// Local functions
#ifndef SAPI5
PITTSCENTRAL FindAndSelect(PTTSMODEINFO pTTSInfo);
#endif
BOOL InitTTS(void);
BOOL UnInitTTS(void);

// Dialog call back procs
INT_PTR CALLBACK MainDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK AboutDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ConfirmProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK WarnDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

BOOL InitApp(HINSTANCE hInstance, int nCmdShow);
BOOL UnInitApp(void);
BOOL SpeakString(TCHAR * pszSpeakText, BOOL forceRead, DWORD dwFlags);
void Shutup(void);
int MessageBoxLoadStrings (HWND hWnd,UINT uIDText,UINT uIDCaption,UINT uType);
void SetRegistryValues();
BOOL SetVolume (int nVolume);
BOOL SetSpeed (int nSpeed);
BOOL SetPitch (int nPitch);
DWORD GetDesktop();
void CenterWindow(HWND);
void FilterSpeech(TCHAR* szSpeak);


// Global varibles
TCHAR               g_szLastStringSpoken[MAX_TEXT] = { NULL };
HWND				g_hwndMain = NULL;
HINSTANCE			g_hInst;
BOOL				g_fAppExiting = FALSE;

int currentVoice = -1;

#ifndef SAPI5
PITTSCENTRAL		g_pITTSCentral;
PITTSENUM			g_pITTSEnum = NULL;
PITTSATTRIBUTES		g_pITTSAttributes = NULL;
#else
ISpObjectToken *g_pVoiceTokens[80];
WCHAR g_szCurrentVoice[256];
WCHAR *g_szVoices[80];

ISpVoice            *g_pISpV = NULL;
#define SPEAK_NORMAL    SPF_ASYNC | SPF_IS_NOT_XML
#define SPEAK_XML       SPF_ASYNC | SPF_PERSIST_XML
#define SPEAK_MUTE      SPF_PURGEBEFORESPEAK
//
//  Simple inline function converts a ulong to a hex string.
//
inline void SpHexFromUlong(WCHAR * psz, ULONG ul)
{
    const static WCHAR szHexChars[] = L"0123456789ABCDEF";
    if (ul == 0)    
    {        
        psz[0] = L'0';
        psz[1] = 0;    
    }
    else    
    {        
        ULONG ulChars = 1;
        psz[0] = 0;

        while (ul)        
        {            
            memmove(psz + 1, psz, ulChars * sizeof(WCHAR));
            psz[0] = szHexChars[ul % 16];
            ul /= 16;            
            ulChars++;
        }    
    }
}


inline HRESULT SpEnumTokens(
    const WCHAR * pszCategoryId, 
    const WCHAR * pszReqAttribs, 
    const WCHAR * pszOptAttribs, 
    IEnumSpObjectTokens ** ppEnum)
{
    HRESULT hr = S_OK;
    const BOOL fCreateIfNotExist = FALSE;
    
    ISpObjectTokenCategory *cpCategory;
    hr = CoCreateInstance(CLSID_SpObjectTokenCategory, NULL, CLSCTX_ALL, 
                          __uuidof(ISpObjectTokenCategory), 
                          reinterpret_cast<void **>(&cpCategory) );
    
    if (SUCCEEDED(hr))
        hr = cpCategory->SetId(pszCategoryId, fCreateIfNotExist);
    
    if (SUCCEEDED(hr))
        hr = cpCategory->EnumTokens( pszReqAttribs, pszOptAttribs, ppEnum);
        
    cpCategory->Release();
    
    return hr;
}

#endif

DWORD minSpeed, maxSpeed, lastSpeed = -1, currentSpeed = 5;
WORD minPitch, maxPitch, lastPitch = -1, currentPitch = 5;
DWORD minVolume, maxVolume, lastVolume = -1, currentVolume = 5;

#define SET_VALUE(fn, newVal, lastVal) \
{ \
    if (lastVal != newVal) {\
        fn(newVal); \
        lastVal = newVal; \
    } \
}

inline void SetDialogIcon(HWND hwnd)
{
    HANDLE hIcon = LoadImage( g_hInst, MAKEINTRESOURCE(IDI_ICON1), 
                               IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0);
    if(hIcon)
         SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);

}

// Combo box support
int GetComboItemData(HWND hwnd);
void FillAndSetCombo(HWND hwnd, int iMinVal, int iMaxVal, int iSelVal);


BOOL				g_startUM = FALSE; // Started from Utililty Manager
HANDLE              g_hMutexNarratorRunning;
BOOL				logonCheck = FALSE;	

// UM stuff
static BOOL  AssignDesktop(LPDWORD desktopID, LPTSTR pname);
static BOOL InitMyProcessDesktopAccess(VOID);
static VOID ExitMyProcessDesktopAccess(VOID);
static HWINSTA origWinStation = NULL;
static HWINSTA userWinStation = NULL;
// Keep a global desktop ID
DWORD desktopID;


// For Link Window
EXTERN_C BOOL WINAPI LinkWindow_RegisterClass() ;

// For Utility Manager
#define UTILMAN_DESKTOP_CHANGED_MESSAGE   __TEXT("UtilityManagerDesktopChanged")
#define DESKTOP_ACCESSDENIED 0
#define DESKTOP_DEFAULT      1
#define DESKTOP_SCREENSAVER  2
#define DESKTOP_WINLOGON     3
#define DESKTOP_TESTDISPLAY  4
#define DESKTOP_OTHER        5


//CS help
DWORD g_rgHelpIds[] = {	IDC_VOICESETTINGS, 70600,
						IDC_VOICE, 70605,
						IDC_NAME, 70605,
						IDC_COMBOSPEED, 70610,
						IDC_COMBOVOLUME, 70615,
						IDC_COMBOPITCH, 70620,
                        IDC_MODIFIERS, 70645,
                        IDC_ANNOUNCE, 70710,
						IDC_READING, 70625,
                        IDC_MOUSEPTR, 70695,
						IDC_MSRCONFIG, 70600,
						IDC_STARTMIN, 70705,
						IDC_EXIT, -1,
						IDC_MSRHELP, -1,
						IDC_CAPTION, -1
                        };

// IsSystem - Returns TRUE if our process is running as SYSTEM
//
BOOL IsSystem()
{
    BOOL fStatus = FALSE;
    BOOL fIsLocalSystem = FALSE;
    SID_IDENTIFIER_AUTHORITY siaLocalSystem = SECURITY_NT_AUTHORITY;
    PSID psidSystem;
    if (!AllocateAndInitializeSid(&siaLocalSystem, 
                                            1,
                                            SECURITY_LOCAL_SYSTEM_RID,
                                            0, 0, 0, 0, 0, 0, 0,
                                            &psidSystem))
    {
        return FALSE;
    }

    if (psidSystem) 
    {
        fStatus = CheckTokenMembership(NULL, psidSystem, &fIsLocalSystem);
    }

    return (fStatus && fIsLocalSystem);
}

BOOL IsInteractiveUser()
{
    BOOL fStatus = FALSE;
    BOOL fIsInteractiveUser = FALSE;
    PSID psidInteractiveUser = 0;
    SID_IDENTIFIER_AUTHORITY siaLocalSystem = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid(&siaLocalSystem, 
                                1,
                                SECURITY_INTERACTIVE_RID,
                                0, 0, 0, 0, 0, 0, 0,
                                &psidInteractiveUser))
    {           
        psidInteractiveUser = 0;
    }

    if (psidInteractiveUser) 
    {
        fStatus = CheckTokenMembership(NULL, psidInteractiveUser, &fIsInteractiveUser);
    }

    return (fStatus && fIsInteractiveUser);
}


/*************************************************************************
Function:   WinMain
Purpose:    Entry point of application
Inputs:
Returns:    Int containing the return value of the app.
History:
*************************************************************************/
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    UINT deskSwitchMsg;

	// Get the commandline so that it works for MUI/Unicode
	LPTSTR lpCmdLineW = GetCommandLine();
  
	if(NULL != lpCmdLineW && lstrlen(lpCmdLineW))
	{
	    LPTSTR psz = wcschr(lpCmdLineW,_TEXT('/'));
	    if (psz && lstrcmpi(psz, TEXT("/UM")) == 0)
        {
			g_startUM = TRUE;
        }
	}

	// Don't allow multiple versions of Narrator running at a time.  If
    // this instance was started by UtilMan then the code tries up to 4 
    // times to detect the absence of the narrator mutex;  during a 
    // desktop switch we need to wait for the old narrator to quit.

    int cTries;
    for (cTries=0;cTries < 4;cTries++)
    {
	    g_hMutexNarratorRunning = CreateMutex(NULL, TRUE, TEXT("AK:NarratorRunning"));
	    if (g_hMutexNarratorRunning && GetLastError() == ERROR_SUCCESS)
            break;    // mutex created and it didn't already exist

        // cleanup before possible retry
        if (g_hMutexNarratorRunning)
        {
            CloseHandle(g_hMutexNarratorRunning);
            g_hMutexNarratorRunning = 0;
        }

		if (!g_startUM)
            break;    // not started by UtilMan but there's another narrator running

        // pause...
        Sleep(500);
    }
    if (!g_hMutexNarratorRunning || cTries >= 4)
        return 0;   // fail to start narrator
	
    InitCommonControls();

	// for the Link Window in finish page...
	LinkWindow_RegisterClass();

    // Initialization
    g_hInst = hInstance;

    TCHAR name[300];

    // For Multiple desktops (UM)
    deskSwitchMsg = RegisterWindowMessage(UTILMAN_DESKTOP_CHANGED_MESSAGE);

    InitMyProcessDesktopAccess();
	AssignDesktop(&desktopID,name);

    //  the only place it is ok to run as system is on the DESKTOP_WINLOGON desktop.  If that is
    //  not where we are than get out before we cause any security problems.  The check for interactive 
    //  user is ther to make sure we run during setup or oobe becuase the security threat only exists
    //  when a user can exploit it
    if (DESKTOP_WINLOGON !=  desktopID && IsSystem() && IsInteractiveUser() )
    {
        if ( g_hMutexNarratorRunning ) 
        ReleaseMutex(g_hMutexNarratorRunning);
        ExitMyProcessDesktopAccess();
        return 0;
    }
    

    SpewOpenFile(TEXT("NarratorSpew.txt"));

    if (InitApp(hInstance, nCmdShow))
    {
        MSG     msg;

        // Main message loop
        while (GetMessage(&msg, NULL, 0, 0))
        {
            if (!IsDialogMessage(g_hwndMain, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);

                if (msg.message == deskSwitchMsg)
                {
                    g_fAppExiting = TRUE;

                    UnInitApp();
                }
            }
        }
    }

    SpewCloseFile();

    // UM
    ExitMyProcessDesktopAccess();
    return 0;
}


/*************************************************************************
Function:
Purpose:
Inputs:
Returns:
History:
*************************************************************************/
LPTSTR LangIDtoString( WORD LangID )
{
    int i;
    for( i=0; i<MAX_LANGUAGES; i++ )
    {
        if( (LangID & 0xFF) == LanguageID[i] )
            return Languages[i];
    }

    return NULL;
}

#ifndef SAPI5
/*************************************************************************
Function:
Purpose: Get the range for speed, pitch etc..,
Inputs:
Returns:
History:
*************************************************************************/
void GetSpeechMinMaxValues(void)
{
    WORD	tmpPitch;
    DWORD	tmpSpeed;
    DWORD	tmpVolume;

    g_pITTSAttributes->PitchGet(&tmpPitch);
    g_pITTSAttributes->PitchSet(TTSATTR_MAXPITCH);
    g_pITTSAttributes->PitchGet(&maxPitch);
    g_pITTSAttributes->PitchSet(TTSATTR_MINPITCH);
    g_pITTSAttributes->PitchGet(&minPitch);
    g_pITTSAttributes->PitchSet(tmpPitch);

    g_pITTSAttributes->SpeedGet(&tmpSpeed);
    g_pITTSAttributes->SpeedSet(TTSATTR_MINSPEED);
    g_pITTSAttributes->SpeedGet(&minSpeed);
    g_pITTSAttributes->SpeedSet(TTSATTR_MAXSPEED);
    g_pITTSAttributes->SpeedGet(&maxSpeed);
    g_pITTSAttributes->SpeedSet(tmpSpeed);

    g_pITTSAttributes->VolumeGet(&tmpVolume);
    g_pITTSAttributes->VolumeSet(TTSATTR_MINVOLUME);
    g_pITTSAttributes->VolumeGet(&minVolume);
    g_pITTSAttributes->VolumeSet(TTSATTR_MAXVOLUME);
    g_pITTSAttributes->VolumeGet(&maxVolume);
    g_pITTSAttributes->VolumeSet(tmpVolume);
}
#endif

/*************************************************************************
    Function:   VoiceDlgProc
    Purpose:    Handles messages for the Voice Box dialog
    Inputs:
    Returns:
    History:
*************************************************************************/
INT_PTR CALLBACK VoiceDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	static WORD oldVoice, oldPitch;
    static DWORD oldSpeed, oldVolume;
	static HWND hwndList;
	WORD	wNewPitch;
	
	DWORD   i;
	int     Selection;
	
	TCHAR   szTxt[MAX_TEXT];
	HRESULT hRes;
	
	szTxt[0]=TEXT('\0');
	
	switch (uMsg)
	{
		case WM_INITDIALOG:
			oldVoice = currentVoice; // save voice parameters in case of CANCEL
			oldPitch = currentPitch;
			oldVolume = currentVolume;
			oldSpeed = currentSpeed;
			
			Shutup();

			hwndList = GetDlgItem(hwnd, IDC_NAME);
			SetDialogIcon(hwnd);

			// Only allow picking a voice when not on secure desktop
			if ( !logonCheck )
			{
#ifndef SAPI5
				for (i = 0; i < gnmodes; i++)
				{
					lstrcpyn(szTxt,gaTTSInfo[i].szModeName,MAX_TEXT);
					lstrcatn(szTxt,TEXT(", "),MAX_TEXT);
					
					lstrcatn(szTxt,
						LangIDtoString(gaTTSInfo[i].language.LanguageID),
						MAX_TEXT);
					lstrcatn(szTxt,TEXT(", "),MAX_TEXT);
					
					lstrcatn(szTxt,gaTTSInfo[i].szMfgName,MAX_TEXT);
					
					SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM) szTxt);
				}
#else
                // Show the description for the voice narrator is using
            	for ( int i = 0; i < ARRAYSIZE( g_szVoices ) && g_szVoices[i] != NULL; i++ )
            	{
        	        SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM) g_szVoices[i] );
            	}
            	
                hRes = g_pISpV->SetVoice( g_pVoiceTokens[currentVoice] );
				if ( FAILED(hRes) )
                    DBPRINTF (TEXT("SetVoice failed hr=0x%lX\r\n"),hRes);
#endif
            	SendMessage(hwndList, LB_SETCURSEL, currentVoice, 0L);
			}
			else
			{
				LoadString(g_hInst, IDS_SAM, szTxt, MAX_TEXT);

				SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM) szTxt);
				EnableWindow(hwndList, FALSE);
			}
            FillAndSetCombo(GetDlgItem(hwnd, IDC_COMBOSPEED), 1, 9, currentSpeed);
            FillAndSetCombo(GetDlgItem(hwnd, IDC_COMBOVOLUME), 1, 9, currentVolume);
            FillAndSetCombo(GetDlgItem(hwnd, IDC_COMBOPITCH), 1, 9, currentPitch);

			break;
			
			
		case WM_COMMAND:
            {
			DWORD	dwValue;
			int control = LOWORD(wParam);
			switch (LOWORD(wParam))
			{
				case IDC_NAME:
					hwndList = GetDlgItem(hwnd,IDC_NAME);

					Selection = (WORD) SendMessage(hwndList, LB_GETCURSEL,0, 0L);
					if (Selection < 0 || Selection > 79)
						Selection = 0;
					Shutup();
#ifndef SAPI5
					if (currentVoice != Selection) 
					{ // voice changed!
						MessageBeep(MB_OK);
						currentVoice = (WORD)Selection;
						// Get the audio dest
						g_pITTSCentral->Release();
						
						if ( pIAMM )
						{
							pIAMM->Release();
							pIAMM = NULL;
						}

						hRes = CoCreateInstance(CLSID_MMAudioDest,
							NULL,
							CLSCTX_ALL,
							IID_IAudioMultiMediaDevice,
							(void**)&pIAMM);

						if (FAILED(hRes))
							return TRUE;     // error

						hRes = g_pITTSEnum->Select( gaTTSInfo[Selection].gModeID,
							&g_pITTSCentral,
							(LPUNKNOWN) pIAMM);
						
						if (FAILED(hRes))
							MessageBeep(MB_OK);
						g_pITTSAttributes->Release();
						
						hRes = g_pITTSCentral->QueryInterface (IID_ITTSAttributes, (void**)&g_pITTSAttributes);
					}
					
					GetSpeechMinMaxValues(); // get speech parameters for this voice
#else
                    if (  currentVoice != Selection )
                    {
                        currentVoice = Selection;
                        hRes = g_pISpV->SetVoice( g_pVoiceTokens[currentVoice] );
                        if ( FAILED(hRes) )
                        {   
                            DBPRINTF (TEXT("SetVoice failed hr=0x%lX\r\n"),hRes);
                        }
                        SendMessage(hwndList, LB_SETCURSEL, currentVoice, 0L);
                    }
#endif
					// then reset pitch etc. accordingly
                    currentPitch = GetComboItemData(GetDlgItem(hwnd, IDC_COMBOPITCH));
                    currentSpeed = GetComboItemData(GetDlgItem(hwnd, IDC_COMBOSPEED));
                    currentVolume = GetComboItemData(GetDlgItem(hwnd, IDC_COMBOVOLUME));

                    SET_VALUE(SetPitch, currentPitch, lastPitch)
                    SET_VALUE(SetSpeed, currentSpeed, lastSpeed)
                    SET_VALUE(SetVolume, currentVolume, lastVolume)
					
					break;
				
				case IDC_COMBOSPEED:
					if (IsWindowVisible(GetDlgItem(hwnd, control)))
					{
                        dwValue = GetComboItemData(GetDlgItem(hwnd, control));
                        SET_VALUE(SetSpeed, dwValue, lastSpeed)
					}
					break;
				
				case IDC_COMBOVOLUME:
					if (IsWindowVisible(GetDlgItem(hwnd, control)))
					{
                        dwValue = GetComboItemData(GetDlgItem(hwnd, control));
                        SET_VALUE(SetVolume, dwValue, lastVolume)
					}
					break;
				
				case IDC_COMBOPITCH:
					if (IsWindowVisible(GetDlgItem(hwnd, control)))
					{
                        dwValue = GetComboItemData(GetDlgItem(hwnd, control));
                        SET_VALUE(SetPitch, dwValue, lastPitch)
					}
					break;
				
				case IDCANCEL:
					MessageBeep(MB_OK);
					Shutup();
#ifndef SAPI5
					if (currentVoice != oldVoice) 
					{ // voice changed!
						currentVoice = oldVoice;
						
						// Get the audio dest
						g_pITTSCentral->Release();

						if ( pIAMM )
						{
							pIAMM->Release();
							pIAMM = NULL;
						}

						hRes = CoCreateInstance(CLSID_MMAudioDest,
							NULL,
							CLSCTX_ALL,
							IID_IAudioMultiMediaDevice,
							(void**)&pIAMM);

						if (FAILED(hRes))
							return TRUE;     // error

						hRes = g_pITTSEnum->Select( gaTTSInfo[currentVoice].gModeID,
							&g_pITTSCentral,
							(LPUNKNOWN) pIAMM);

						if (FAILED(hRes))
							MessageBeep(MB_OK);
						
						g_pITTSAttributes->Release();
						hRes = g_pITTSCentral->QueryInterface (IID_ITTSAttributes, (void**)&g_pITTSAttributes);
					}
					
					GetSpeechMinMaxValues(); // speech get parameters for old voice
#endif
                    currentPitch = oldPitch; // restore old values
                    SET_VALUE(SetPitch, currentPitch, lastPitch)

                    currentSpeed = oldSpeed;
                    SET_VALUE(SetSpeed, currentSpeed, lastSpeed)

                    currentVolume = oldVolume;
                    SET_VALUE(SetVolume, currentVolume, lastVolume)

                    EndDialog (hwnd, IDCANCEL);
					return(TRUE);

				case IDOK: // set values of pitch etc. from check boxes

                    currentPitch = GetComboItemData(GetDlgItem(hwnd, IDC_COMBOPITCH));
                    currentSpeed = GetComboItemData(GetDlgItem(hwnd, IDC_COMBOSPEED));
                    currentVolume = GetComboItemData(GetDlgItem(hwnd, IDC_COMBOVOLUME));

                    SET_VALUE(SetPitch, currentPitch, lastPitch)
                    SET_VALUE(SetSpeed, currentSpeed, lastSpeed)
                    SET_VALUE(SetVolume, currentVolume, lastVolume)

                    SetRegistryValues();
					EndDialog (hwnd, IDOK);
					return(TRUE);
			} // end switch on control of WM_COMMAND
            }
			break;

        case WM_CONTEXTMENU:  // right mouse click
			if ( !RunSecure(GetDesktop()) )
			{
				WinHelp((HWND) wParam, __TEXT("reader.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_rgHelpIds);
			}
            break;

		case WM_CLOSE:
				EndDialog (hwnd, IDOK);
				return TRUE;
			break;

        case WM_HELP:
			if ( !RunSecure(GetDesktop()) )
			{
				WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, __TEXT("reader.hlp"), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_rgHelpIds);
			}
            return(TRUE);

	} // end switch uMsg

	return(FALSE);  // didn't handle
}



/*************************************************************************
    Function:   SetVolume
    Purpose:    set volume to a normalized value 1-9
    Inputs:     int volume in range 1-9
    Returns:
    History:    At the application layer, volume is a number from 0 to 100 
                where 100 is the maximum value for a voice. It is a linear 
                progression so that a value 50 represents half of the loudest 
                permitted. The increments should be the range divided by 100.
*************************************************************************/
BOOL SetVolume (int nVolume)
{
#ifndef SAPI5
	DWORD	dwNewVolume;
	WORD	wNewVolumeLeft,
			wNewVolumeRight;

	//ASSERT (nVolume >= 1 && nVolume <= 9);
	wNewVolumeLeft = (WORD)( (LOWORD(minVolume) + (((LOWORD(maxVolume) - LOWORD(minVolume))/9.0)*nVolume)) );
	wNewVolumeRight = (WORD)( (HIWORD(minVolume) + (((HIWORD(maxVolume) - HIWORD(minVolume))/9.0)*nVolume)) );
	dwNewVolume = MAKELONG (wNewVolumeLeft,wNewVolumeRight);

    return (SUCCEEDED(g_pITTSAttributes->VolumeSet(dwNewVolume)));
#else
	USHORT 		usNewVolume;
	HRESULT		hr;	

	if(nVolume < 1) nVolume = 1;
	if(nVolume > 9) nVolume = 9;
	//calculate a value between 10 and 90
	usNewVolume = (USHORT)( nVolume * 10 ); 
	hr = g_pISpV->SetVolume(usNewVolume); 
    return	SUCCEEDED(hr);
#endif
}

/*************************************************************************
    Function:   SetSpeed
    Purpose:    set Speed to a normalized value 1-9
    Inputs:     int Speed in range 1-9
    Returns:
    History:    The value can range from -10 to +10. 
	            A value of 0 sets a voice to speak at its default rate. 
	            A value of -10 sets a voice to speak at one-sixth of its default rate. 
	            A value of +10 sets a voice to speak at 6 times its default rate. 
	            Each increment between -10 and +10 is logarithmically distributed such 
	            that incrementing or decrementing by 1 is multiplying or dividing the 
	            rate by the 10th root of 6 (about 1.2). Values more extreme than -10 and +10 
	            will be passed to an engine. However, SAPI 5.0-compliant engines may not 
	            support such extremes and may clip the rate to the maximum or minimum 
                rate it supports.
*************************************************************************/
BOOL SetSpeed (int nSpeed)
{
#ifndef SAPI5
	DWORD	dwNewSpeed;

	//ASSERT (nSpeed >= 1 && nSpeed <= 9);
	dwNewSpeed = minSpeed + (DWORD) ((maxSpeed-minSpeed)/9.0*nSpeed);
	return (SUCCEEDED(g_pITTSAttributes->SpeedSet(dwNewSpeed)));
#else
	long		lNewSpeed;				
	HRESULT		hr;	

	if(nSpeed < 1) nSpeed = 1;		
	if(nSpeed > 9) nSpeed = 9;		
	switch(nSpeed)					
	{							
	    case 1:		lNewSpeed = -8;		break;
	    case 2:		lNewSpeed = -6;		break;
	    case 3:		lNewSpeed = -4;		break;
	    case 4:		lNewSpeed = -2;		break;
	    case 5:		lNewSpeed = 0;		break;
	    case 6:		lNewSpeed = 2;		break;
	    case 7:		lNewSpeed = 4;		break;
	    case 8:		lNewSpeed = 6;		break;
	    case 9:		lNewSpeed = 8;		break;
	    default:	lNewSpeed = 0;		break;
	}
	hr = g_pISpV->SetRate(lNewSpeed); 
	return SUCCEEDED(hr);			
#endif
}

/*************************************************************************
    Function:   SetPitch
    Purpose:    set Pitch to a normalized value 1-9
    Inputs:     int Pitch in range 1-9
    Returns:
    History:    The value can range from -10 to +10. A value of 0 sets a voice to speak at 
                its default pitch. A value of -10 sets a voice to speak at three-fourths of 
                its default pitch. A value of +10 sets a voice to speak at four-thirds of 
                its default pitch. Each increment between -10 and +10 is logarithmically 
                distributed such that incrementing or decrementing by 1 is multiplying or 
                dividing the pitch by the 24th root of 2 (about 1.03). Values outside of 
                the -10 and +10 range will be passed to an engine. However, SAPI 5.0-compliant 
                engines may not support such extremes and may clip the pitch to the maximum or 
                minimum it supports. Values of -24 and +24 must lower and raise pitch by 1 octave 
                respectively. All incrementing or decrementing by 1 must multiply or divide the 
                pitch by the 24th root of 2.

                Pitch changes can only be submitted via ::Speak using XML embedded in a string.

*************************************************************************/
BOOL SetPitch (int nPitch)
{
#ifndef SAPI5
	WORD	wNewPitch;

	wNewPitch = (WORD)((minPitch + (((maxPitch - minPitch)/9.0)*nPitch)));
	return (SUCCEEDED(g_pITTSAttributes->PitchSet(wNewPitch)));
#else
	if(nPitch < 1) nPitch = 1;		
	if(nPitch > 9) nPitch = 9;	
    
	int	nNewPitch;			
	switch(nPitch)					
	{								
	    case 1:		nNewPitch = -8;		break;
	    case 2:		nNewPitch = -6;		break;
	    case 3:		nNewPitch = -4;		break;
	    case 4:		nNewPitch = -2;		break;
	    case 5:		nNewPitch = 0;		break;
	    case 6:		nNewPitch = 2;		break;
	    case 7:		nNewPitch = 4;		break;
	    case 8:		nNewPitch = 6;		break;
	    case 9:		nNewPitch = 8;		break;
	    default:	nNewPitch = 0;		break;
	}

    LPTSTR pszSpeak = new TCHAR[60];
    if (pszSpeak)
    {
	    wsprintf(pszSpeak,L"<PITCH ABSMIDDLE=\"%d\"/>",nNewPitch);
	    SpeakString(pszSpeak, TRUE, SPEAK_XML);
        delete [] pszSpeak;
    }

	return TRUE;		
#endif
}

#define TIMERID 6466
/*************************************************************************
    Function:   MainDlgProc
    Purpose:    Handles messages for the Main dialog
    Inputs:
    Returns:
    History:
*************************************************************************/
INT_PTR CALLBACK MainDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szText[MAX_TEXT];
    switch (uMsg)
        {
        case WM_INITDIALOG:
            {
	    	    SetDialogIcon(hwnd);
	    	    
			    // Disable Help button on other desktops
                BOOL fRunSecure = RunSecure(GetDesktop());
			    if ( fRunSecure )
			    {
				    EnableWindow(GetDlgItem(hwnd, IDC_MSRHELP), FALSE);
			    }

			    CheckDlgButton(hwnd,IDC_MOUSEPTR,GetTrackInputFocus());
			    CheckDlgButton(hwnd,IDC_READING,GetEchoChars());
			    CheckDlgButton(hwnd,IDC_ANNOUNCE,GetAnnounceWindow());
			    CheckDlgButton(hwnd,IDC_STARTMIN,StartMin);
			    
			    // To show the warning message on default desktop...
                if (ShowWarn && !fRunSecure)
    			    SetTimer(hwnd, TIMERID, 20, NULL);

                // Enable desktop switching detection
                InitWatchDeskSwitch(hwnd, WM_MSRDESKSW);
            }
            break;

		case WM_TIMER:
			KillTimer(hwnd, (UINT)wParam);
		    DialogBox (g_hInst, MAKEINTRESOURCE(IDD_WARNING),hwnd, WarnDlgProc);
            return TRUE;
			break;

        case WM_WININICHANGE:
            if (g_fAppExiting) break;

            // If someone else turns off the system-wide screen reader
            // flag, we want to turn it back on.
            if (wParam == SPI_SETSCREENREADER && !lParam)
                SystemParametersInfo(SPI_SETSCREENREADER, TRUE, NULL, SPIF_UPDATEINIFILE|SPIF_SENDCHANGE);
            return 0;

		case WM_DELAYEDMINIMIZE:
			// Delayed mimimize message
			ShowWindow(hwnd, SW_HIDE);
			ShowWindow(hwnd, SW_MINIMIZE);
			break;

		case WM_MUTE:
			Shutup();
			break;

        case WM_MSRSPEAK:
            GetCurrentText(szText, MAX_TEXT);
			SpeakString(szText, TRUE, SPEAK_NORMAL);
			break;

        case WM_MSRSPEAKXML:
            GetCurrentText(szText, MAX_TEXT);
			SpeakString(szText, TRUE, SPEAK_XML);
			break;

        case WM_MSRSPEAKMUTE:
            SpeakString(NULL, TRUE, SPEAK_MUTE);
            break;

        case WM_CLOSE:
        case WM_MSRDESKSW:
            // When the desktop changes, if UtilMan is running and FUS isn't
            // enabled then exit (when FUS is enabled we don't have to worry
            // about running on another desktop therefore we don't need to
            // exit).  UtilMan will start us up again if necessary.
            Shutup();
            g_startUM = IsUtilManRunning();
            // Jan23,2001 Optimization to FUS piggybacks the winlogon desktop
            // to the session being switch from.  This means we have to quit
            // in case user needs to run from the winlogon desktop.
            if (uMsg == WM_MSRDESKSW && (!g_startUM /*|| !CanLockDesktopWithoutDisconnect()*/))
                break;  // ignore message

            // UtilMan is managing starting us.  UtilMan will 
            // start us up again if necessary so quit...

        case WM_MSRQUIT:
			// Do not show an exit confirmation if started from UM and not at logon desktop
			if ( !g_startUM && !RunSecure(GetDesktop()) )
			{
				if (IDOK != DialogBox(g_hInst, MAKEINTRESOURCE(IDD_CONFIRMEXIT), g_hwndMain, ConfirmProc))
					return(FALSE);
			}
            // Intentional fall through

		case WM_DESTROY:
            // Required for desktop switches :a-anilk
            g_fAppExiting = TRUE;
			g_hwndMain = NULL;

            TermWatchDeskSwitch();    // Terminate the desktop switch thread
			UnInitApp();
            
			if ( g_hMutexNarratorRunning ) 
				ReleaseMutex(g_hMutexNarratorRunning);
            // Let others know that you are turning off the system-wide
		    // screen reader flag.
            SystemParametersInfo(SPI_SETSCREENREADER, FALSE, NULL, SPIF_UPDATEINIFILE|SPIF_SENDCHANGE);

            EndDialog (hwnd, IDCANCEL);
            PostQuitMessage(0);

            return(TRUE);

		case WM_MSRHELP:
            // Show HTML help
			if ( !RunSecure(GetDesktop()) )
			{
				 HtmlHelp(hwnd ,TEXT("reader.chm"),HH_DISPLAY_TOPIC, 0);
			}
			break;

		case WM_MSRCONFIGURE:
			DialogBox (g_hInst, MAKEINTRESOURCE(IDD_VOICE),hwnd, VoiceDlgProc);
			break;

		case WM_HELP:
			if ( !RunSecure(GetDesktop()) )
			{
				HtmlHelp(hwnd ,TEXT("reader.chm"),HH_DISPLAY_TOPIC, 0);
			}
			break;

		case WM_CONTEXTMENU:  // right mouse click
			if ( !RunSecure(GetDesktop()) )
			{
				WinHelp((HWND) wParam, __TEXT("reader.hlp"), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_rgHelpIds);
			}
            break;

        case WM_SYSCOMMAND:
	        if ((wParam & 0xFFF0) == IDM_ABOUTBOX)
            {
		        DialogBox (g_hInst, MAKEINTRESOURCE(IDD_ABOUTBOX),hwnd,AboutDlgProc);
                return TRUE;
	        }
            break;
            
        // case WM_QUERYENDSESSION:
		// return TRUE;

		case WM_ENDSESSION:
		{
			 HKEY hKey;
			 DWORD dwPosition;
			 const TCHAR szSubKey[] =  __TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
			 const TCHAR szImageName[] = __TEXT("Narrator.exe");
             		 const TCHAR szValueName[] = __TEXT("RunNarrator");

			 if ( ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, szSubKey, 0, NULL,
				 REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hKey, &dwPosition))
			 {
				 RegSetValueEx(hKey, (LPCTSTR) szValueName, 0, REG_SZ, (CONST BYTE*)szImageName, (lstrlen(szImageName)+1)*sizeof(TCHAR) );
				 RegCloseKey(hKey);
			 }
		}
        return 0;

        case WM_COMMAND:
            switch (LOWORD(wParam))
                {
			case IDC_MSRHELP :
				PostMessage(hwnd, WM_MSRHELP,0,0);
				break;

			case IDC_MINIMIZE:
				BackToApplication();
				break;

			case IDC_MSRCONFIG :
				PostMessage(hwnd, WM_MSRCONFIGURE,0,0);
				break;

			case IDC_EXIT :
				PostMessage(hwnd, WM_MSRQUIT,0,0);
				break;

			case IDC_ANNOUNCE:
				SetAnnounceWindow(IsDlgButtonChecked(hwnd,IDC_ANNOUNCE));
				SetAnnounceMenu(IsDlgButtonChecked(hwnd,IDC_ANNOUNCE));
                SetAnnouncePopup(IsDlgButtonChecked(hwnd,IDC_ANNOUNCE));
				break;

			case IDC_READING:
				if (IsDlgButtonChecked(hwnd,IDC_READING))
					SetEchoChars(MSR_ECHOALNUM | MSR_ECHOSPACE | MSR_ECHODELETE | MSR_ECHOMODIFIERS 
								 | MSR_ECHOENTER | MSR_ECHOBACK | MSR_ECHOTAB);
				else
					SetEchoChars(0);
				SetRegistryValues();	
				break;

			case IDC_MOUSEPTR:
				SetTrackInputFocus(IsDlgButtonChecked(hwnd,IDC_MOUSEPTR));
				SetTrackCaret(IsDlgButtonChecked(hwnd,IDC_MOUSEPTR));
				break;

			case IDC_STARTMIN:
				StartMin = IsDlgButtonChecked(hwnd,IDC_STARTMIN);
				break;
        }
	}
    return(FALSE);  // didn't handle
}

/*************************************************************************
    Function:   AboutDlgProc
    Purpose:    Handles messages for the About Box dialog
    Inputs:
    Returns:
    History:
*************************************************************************/
INT_PTR CALLBACK AboutDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
			Shutup();
			SetDialogIcon(hwnd);

			// If minimized, Center on the desktop..
			if ( IsIconic(g_hwndMain) )
			{
				CenterWindow(hwnd);
			}
            if (RunSecure(GetDesktop()) )
            {
                EnableWindow(GetDlgItem(hwnd, IDC_ENABLEWEBA), FALSE); 
            }
			return TRUE;

			break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
				case IDOK:
                case IDCANCEL:
					Shutup();
                    EndDialog (hwnd, IDCANCEL);
                    return(TRUE);
                }
				break;

				case WM_NOTIFY:
					{
						INT idCtl		= (INT)wParam;
						LPNMHDR pnmh	= (LPNMHDR)lParam;
						switch ( pnmh->code)
						{
							case NM_RETURN:
							case NM_CLICK:
							if ( idCtl == IDC_ENABLEWEBA && !RunSecure(GetDesktop()) )
							{
								TCHAR webAddr[256];
								LoadString(g_hInst, IDS_ENABLEWEB, webAddr, 256);
								ShellExecute(hwnd, NULL, webAddr, NULL, NULL, SW_SHOW); 
							}
							break;
						}
					}
					break;

            };

    return(FALSE);  // didn't handle
}


/*************************************************************************
    Function:   WarnDlgProc
    Purpose:    Handles messages for the Warning dialog
    Inputs:
    Returns:
    History:
*************************************************************************/
INT_PTR CALLBACK WarnDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
			Shutup();
			SetDialogIcon(hwnd);

			// If minimized, Center on the desktop..
			if ( IsIconic(g_hwndMain) )
			{
				CenterWindow(hwnd);
			}
			return TRUE;

			break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
				case IDC_WARNING:
					ShowWarn = !(IsDlgButtonChecked(hwnd,IDC_WARNING));
				break;

				case IDOK:
                case IDCANCEL:
					Shutup();
                    EndDialog (hwnd, IDCANCEL);
                    return(TRUE);
			} 
			break;

		case WM_NOTIFY:
			{
				INT idCtl		= (INT)wParam;
				LPNMHDR pnmh	= (LPNMHDR)lParam;
				switch ( pnmh->code)
				{
					case NM_RETURN:
					case NM_CLICK:
					if ( idCtl == IDC_ENABLEWEBA && !RunSecure(GetDesktop()))
					{
						TCHAR webAddr[256];
						LoadString(g_hInst, IDS_ENABLEWEB, webAddr, 256);
						ShellExecute(hwnd, NULL, webAddr, NULL, NULL, SW_SHOW); 
					}
					break;
				}
			}
			break;
     };

    return(FALSE);  // didn't handle
}

#define SET_NUMREGENTRY(key, keyname, t) \
{ \
    t value = Get ## keyname(); \
    RegSetValueEx(key, TEXT(#keyname), 0, REG_DWORD, (CONST BYTE *)&value, sizeof(t)); \
}
#define GET_NUMREGENTRY(key, keyname, t) \
{ \
	DWORD dwSize = sizeof(t); \
    t value; \
	if (RegQueryValueEx(key, TEXT(#keyname), 0, NULL, (BYTE *)&value, &dwSize) == ERROR_SUCCESS) \
        Set ## keyname(value); \
}
/*************************************************************************
    Function:
    Purpose: Save registry values
    Inputs:
    Returns:
    History:
*************************************************************************/
void SetRegistryValues()
{ // set up the registry
    HKEY reg_key;	// key for the registry

    if (SUCCEEDED (RegOpenKeyEx (HKEY_CURRENT_USER,__TEXT("Software\\Microsoft\\Narrator"),0,KEY_WRITE,&reg_key)))
    {
        // These we are setting from data stored in narrhook.dll
        SET_NUMREGENTRY(reg_key, TrackCaret, BOOL)
        SET_NUMREGENTRY(reg_key, TrackInputFocus, BOOL)
        SET_NUMREGENTRY(reg_key, EchoChars, int)
        SET_NUMREGENTRY(reg_key, AnnounceWindow, BOOL)
        SET_NUMREGENTRY(reg_key, AnnounceMenu, BOOL)
        SET_NUMREGENTRY(reg_key, AnnouncePopup, BOOL)
        SET_NUMREGENTRY(reg_key, AnnounceToolTips, BOOL)
        SET_NUMREGENTRY(reg_key, ReviewLevel, int)
        // These are properties of the speech engine or narrator itself
        RegSetValueEx(reg_key,__TEXT("CurrentSpeed"),0,REG_DWORD,(unsigned char *) &currentSpeed,sizeof(currentSpeed));
        RegSetValueEx(reg_key,__TEXT("CurrentPitch"),0,REG_DWORD,(unsigned char *) &currentPitch,sizeof(currentPitch));
        RegSetValueEx(reg_key,__TEXT("CurrentVolume"),0,REG_DWORD,(unsigned char *) &currentVolume,sizeof(currentVolume));
#ifndef SAPI5
        RegSetValueEx(reg_key,__TEXT("CurrentVoice"),0,REG_DWORD,(unsigned char *) &currentVoice,sizeof(currentVoice));
#else
        RegSetValueEx(reg_key,__TEXT("CurrentVoice"),0,REG_SZ,
                      (unsigned char *) g_szVoices[currentVoice],lstrlen(g_szVoices[currentVoice])*sizeof(TCHAR)+sizeof(TCHAR));
#endif
        RegSetValueEx(reg_key,__TEXT("StartType"),0,REG_DWORD,(unsigned char *) &StartMin,sizeof(StartMin));
        RegSetValueEx(reg_key,__TEXT("ShowWarning"),0,REG_DWORD, (BYTE*) &ShowWarn,sizeof(ShowWarn));
        RegCloseKey (reg_key);
        return;
    }
}

/*************************************************************************
    Function:
    Purpose: Get Registry values
    Inputs:
    Returns:
    History:
*************************************************************************/
void GetRegistryValues()
{
	DWORD	result;
	HKEY	reg_key;
	DWORD	reg_size;

    // We use RegCreateKeyEx instead of RegOpenKeyEx to make sure that the
    // key is created if it doesn't exist. Note that if the key doesn't
    // exist, the values used will already be set. All these values are
    // globals imported from narrhook.dll
	RegCreateKeyEx(HKEY_CURRENT_USER,__TEXT("Software\\Microsoft\\Narrator"),0,
        __TEXT("MSR"),REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS, NULL, &reg_key, &result);
	if (result == REG_OPENED_EXISTING_KEY)
    {
        // These values go into narrhook DLL shared data
        GET_NUMREGENTRY(reg_key, TrackCaret, BOOL)
        GET_NUMREGENTRY(reg_key, TrackInputFocus, BOOL)
        GET_NUMREGENTRY(reg_key, EchoChars, int)
        GET_NUMREGENTRY(reg_key, AnnounceWindow, BOOL)
        GET_NUMREGENTRY(reg_key, AnnounceMenu, BOOL)
        GET_NUMREGENTRY(reg_key, AnnouncePopup, BOOL)
        GET_NUMREGENTRY(reg_key, AnnounceToolTips, BOOL)
        GET_NUMREGENTRY(reg_key, ReviewLevel, int)
        // These values go into the speech engine or narrator itself
		reg_size = sizeof(currentSpeed);
		RegQueryValueEx(reg_key,__TEXT("CurrentSpeed"),0,NULL,(unsigned char *) &currentSpeed,&reg_size);
		reg_size = sizeof(currentPitch);
		RegQueryValueEx(reg_key,__TEXT("CurrentPitch"),0,NULL,(unsigned char *) &currentPitch,&reg_size);
		reg_size = sizeof(currentVolume);
		RegQueryValueEx(reg_key,__TEXT("CurrentVolume"),0,NULL,(unsigned char *) &currentVolume,&reg_size);
#ifndef SAPI5
		reg_size = sizeof(currentVoice);
        RegQueryValueEx(reg_key,__TEXT("CurrentVoice"),0,NULL,(unsigned char *) &currentVoice,&reg_size);
#else
		reg_size = sizeof(g_szCurrentVoice);
		RegQueryValueEx(reg_key,__TEXT("CurrentVoice"),0,NULL,(unsigned char *) g_szCurrentVoice,&reg_size);
#endif
		// Minimized Value
		reg_size = sizeof(StartMin);
		RegQueryValueEx(reg_key,__TEXT("StartType"),0,NULL,(unsigned char *) &StartMin,&reg_size);
		reg_size = sizeof(ShowWarn);
		RegQueryValueEx(reg_key,__TEXT("ShowWarning"),0,NULL,(unsigned char *) &ShowWarn,&reg_size);
	}
    // If the key was just created, then these values should already be set.
	// The values are exported from narrhook.dll, and must be initialized
	// when they are declared.
	RegCloseKey (reg_key);
}


/*************************************************************************
    Function:   InitApp
    Purpose:    Initalizes the application.
    Inputs:     HINSTANCE hInstance - Handle to the current instance
                INT nCmdShow - how to present the window
    Returns:    TRUE if app initalized without error.
    History:
*************************************************************************/
BOOL InitApp(HINSTANCE hInstance, int nCmdShow)
{
    HMENU	hSysMenu;
	RECT	rcWorkArea;
	RECT	rcWindow;
	int		xPos,yPos;
	HRESULT	hr;

#ifdef SAPI5
	memset( g_szCurrentVoice, NULL, sizeof(g_szCurrentVoice) );
    wcscpy( g_szCurrentVoice, L"Microsoft Sam" );
#endif
	GetRegistryValues();
	// SMode = InitMode();

	// start COM
	hr = CoInitialize(NULL);
	if (FAILED (hr))
	{
		DBPRINTF (TEXT("CoInitialize on primary thread returned 0x%lX\r\n"),hr);
		MessageBoxLoadStrings (NULL, IDS_NO_OLE, IDS_MSR_ERROR, MB_OK);
		return FALSE;
	}
	
	// Create the TTS Objects
	// sets the global variable g_pITTSCentral
	// if it fails, will throw up a message box
	if (InitTTS())
	{
		// Initialize Microsoft Active Accessibility
		// this is in narrhook.dll
		// Installs WinEvent hook, creates helper thread
		if (InitMSAA())
		{
			// Set the system screenreader flag on.
			// e.g. Word 97 will expose the caret position.
			SystemParametersInfo(SPI_SETSCREENREADER, TRUE, NULL, SPIF_UPDATEINIFILE|SPIF_SENDCHANGE);
			
			// Create the dialog box
			g_hwndMain = CreateDialog(g_hInst, MAKEINTRESOURCE(IDD_MAIN),
											    0, MainDlgProc);

			if (!g_hwndMain)
			{
				DBPRINTF(TEXT("unable to create main dialog\r\n"));
				return(FALSE);
			}

			// Init global hot keys (need to do here because we need a hwnd)
			InitKeys(g_hwndMain);

			// set icon for this dialog if we can...
			// not an easy way to do this that I know of.
			// hIcon is in the WndClass, which means that if we change it for
			// us, we change it for everyone. Which means that we would
			// have to create a superclass that looks like a dialog but
			// has it's own hIcon. Sheesh.

			// Add "About Narrator..." menu item to system menu.
			hSysMenu = GetSystemMenu(g_hwndMain,FALSE);
			if (hSysMenu != NULL)
			{
				TCHAR szAboutMenu[100];

				if (LoadString(g_hInst,IDS_ABOUTBOX,szAboutMenu,ARRAYSIZE(szAboutMenu)))
				{
					AppendMenu(hSysMenu,MF_SEPARATOR,NULL,NULL);
					AppendMenu(hSysMenu,MF_STRING,IDM_ABOUTBOX,szAboutMenu);
				}
			}

			// Place dialog at bottom right of screen:AK
			HWND hWndInsertAfter;
            BOOL fRunSecure = RunSecure(GetDesktop());

			hWndInsertAfter =  ( fRunSecure ) ? HWND_TOPMOST:HWND_TOP;

			SystemParametersInfo (SPI_GETWORKAREA,NULL,&rcWorkArea,NULL);
			GetWindowRect (g_hwndMain,&rcWindow);
			xPos = rcWorkArea.right - (rcWindow.right - rcWindow.left);
			yPos = rcWorkArea.bottom - (rcWindow.bottom - rcWindow.top);
			SetWindowPos(g_hwndMain, hWndInsertAfter, 
			              xPos, yPos, 0, 0, SWP_NOSIZE |SWP_NOACTIVATE);

			// If Start type is Minimized. 
			if(StartMin || fRunSecure)
			{
				ShowWindow(g_hwndMain, SW_SHOWMINIMIZED);
				// This is required to kill focus from Narrator
				// And put the focus back to the active window. 
				PostMessage(g_hwndMain, WM_DELAYEDMINIMIZE, 0, 0);
			}
			else 
				ShowWindow(g_hwndMain,nCmdShow);
			return TRUE;
		}
	}

	// Something failed, exit false
	return FALSE;
}


/*************************************************************************
    Function:   UnInitApp
    Purpose:    Shuts down the application
    Inputs:     none
    Returns:    TRUE if app uninitalized properly
    History:
*************************************************************************/
BOOL UnInitApp(void)
{
	SetRegistryValues();
    if (UnInitTTS())
        {
        if (UnInitMSAA())
            {
            UninitKeys();
            return TRUE;
            }
        }
    return FALSE;
}

/*************************************************************************
    Function:   SpeakString
    Purpose:    Sends a string of text to the speech engine
    Inputs:     PSZ pszSpeakText - String of ANSI characters to be spoken
                                   Speech control tags can be embedded.
    Returns:    BOOL - TRUE if string was buffered correctly
    History:
*************************************************************************/
BOOL SpeakString(TCHAR * szSpeak, BOOL forceRead, DWORD dwFlags)
{
    // Check for redundent speak, filter out, If it is not Forced read
    if ((lstrcmp(szSpeak, g_szLastStringSpoken) == 0) && (forceRead == FALSE))
        return FALSE;

    if (dwFlags != SPEAK_MUTE)
    {
	    if (szSpeak[0] == 0) // don't speak null string
		    return FALSE;

	    // if exiting stop
	    if (g_fAppExiting)
		    return FALSE;

        // Different string, save off
        lstrcpyn(g_szLastStringSpoken, szSpeak, MAX_TEXT);
        g_szLastStringSpoken[MAX_TEXT-1] = TEXT('\0');

	    FilterSpeech(szSpeak);

        // The L&H speech engine for japanese, goes crazy if you pass a
        // " ", It now takes approx 1 min to come back to life. Need to remove
        // once they fix their stuff! :a-anilk
        if (lstrcmp(szSpeak, TEXT(" ")) == 0)
        {
            return FALSE;
        }

#ifdef SAPI5
        // if there is only punctuation then speak it
        int i = 0;
        int cAlpha = 0;
        while( szSpeak[i] != NULL && i < MAX_TEXT)
    	{
    		if ( _istalpha(szSpeak[i++]) )
    			cAlpha++;
    	}

        if ( !cAlpha )
            dwFlags |= SPF_NLP_MASK;
#endif
    }

#ifndef SAPI5
    SDATA data;
	data.dwSize = (DWORD)(lstrlen(szSpeak)+1) * sizeof(TCHAR);
	data.pData = szSpeak;
	g_pITTSCentral->TextData (CHARSET_TEXT, 0, data, NULL, IID_ITTSBufNotifySinkW);
#else
	HRESULT hr = g_pISpV->Speak(szSpeak, dwFlags, NULL);
    if (FAILED(hr))
    {
        DBPRINTF(TEXT("SpeakString:  Speak returned 0x%x\r\n"), hr);
        return FALSE;
    }
#endif
    SpewToFile(TEXT("%s\r\n"), szSpeak);
	return TRUE;
}

/*************************************************************************
    Function:   InitTTS
    Purpose:    Starts the Text to Speech Engine
    Inputs:     none
    Returns:    BOOL - TRUE if successful
    History:
*************************************************************************/
BOOL InitTTS(void)
{
	// See if we have a Text To Speech engine to use, and initialize it if it is there.
#ifndef SAPI5
	TTSMODEINFO   ttsModeInfo;
	memset (&ttsModeInfo, 0, sizeof(ttsModeInfo));
	g_pITTSCentral = FindAndSelect (&ttsModeInfo);
	if (!g_pITTSCentral)
#else
	HRESULT hr = CoCreateInstance(CLSID_SpVoice, NULL, CLSCTX_INPROC_SERVER, IID_ISpVoice, (void**)&g_pISpV);
    if (FAILED(hr) || !g_pISpV)
#endif
	{
		MessageBoxLoadStrings (NULL, IDS_NO_TTS, IDS_MSR_ERROR, MB_OK);
		return FALSE;
	};
#ifdef SAPI5
   	memset( g_szVoices, NULL, sizeof(g_szVoices) );
   	memset( g_pVoiceTokens, NULL, sizeof(g_pVoiceTokens) );

    ISpObjectToken *pDefaultVoiceToken = NULL;
    WCHAR *szVoice = NULL;

    hr = g_pISpV->GetVoice(&pDefaultVoiceToken);
    if (SUCCEEDED(hr))
    {
        ISpObjectToken *pCurVoiceToken = pDefaultVoiceToken;
    	IEnumSpObjectTokens *pIEnumSpObjectTokens;
	    hr = SpEnumTokens(SPCAT_VOICES, NULL, NULL, &pIEnumSpObjectTokens);
		if (SUCCEEDED(hr))
		{
    	    ISpObjectToken *pCurVoiceToken;
		    int i = 0;
    	    while (pIEnumSpObjectTokens->Next(1, &pCurVoiceToken, NULL) == S_OK)	
			{
				hr = pCurVoiceToken->GetStringValue(NULL, &szVoice);
		        if (SUCCEEDED(hr))
		        {
                    // if this test for MS Sam is removed all voices in the machine will appear
            	    if ( wcscmp( szVoice, L"Microsoft Sam" ) == 0 )
            	    {
    		            currentVoice = i;
                        hr = g_pISpV->SetVoice( pCurVoiceToken );
		                if (FAILED(hr))
		                    return FALSE;
                        g_szVoices[i] = szVoice;
    		            g_pVoiceTokens[i++] = pCurVoiceToken;
    		        }
                }
                else
                {
                    return FALSE;
                }
   			} 
            if ( currentVoice < 0 )
                return FALSE;
        }
		else
		{
    		return FALSE;
		}
    }
    else
    {
        return FALSE;
    }

    SET_VALUE(SetPitch, currentPitch, lastPitch)
    SET_VALUE(SetSpeed, currentSpeed, lastSpeed)
    SET_VALUE(SetVolume, currentVolume, lastVolume)
#endif
	return TRUE;
}

/*************************************************************************
    Function:   UnInitTTS
    Purpose:    Shuts down the Text to Speech subsystem
    Inputs:     none
    Returns:    BOOL - TRUE if successful
    History:
*************************************************************************/
BOOL UnInitTTS(void)
{
#ifndef SAPI5
    // Release out TTS object - if we have one
    if (g_pITTSCentral)
    {
        g_pITTSCentral->Release();
        g_pITTSCentral = 0;
    }

   // Release IITSAttributes - if we have one:a-anilk
    if (g_pITTSAttributes)
    {
        g_pITTSAttributes->Release();
        g_pITTSAttributes = 0;
    }

	if ( pIAMM )
	{
		pIAMM->Release();
		pIAMM = NULL;
	}
#else
    // Release speech tokens and voice strings
	for ( int i = 0; i < ARRAYSIZE( g_pVoiceTokens ) && g_pVoiceTokens[i] != NULL; i++ )
	{
	    CoTaskMemFree(g_szVoices[i]);
        g_pVoiceTokens[i]->Release();
	}

    // Release speech engine
    if (g_pISpV)
    {
	    g_pISpV->Release();
        g_pISpV = 0;
    }
#endif
    return TRUE;
}

/*************************************************************************
    Function:   Shutup
    Purpose:    stops speaking, flushes speech buffers
    Inputs:     none
    Returns:    none
    History:	
*************************************************************************/
void Shutup(void)
{
#ifndef SAPI5
    if (g_pITTSCentral && !g_fAppExiting)
        g_pITTSCentral->AudioReset();
#else
	if (g_pISpV && !g_fAppExiting)
        SendMessage(g_hwndMain, WM_MSRSPEAKMUTE, 0, 0);
#endif
}

#ifndef SAPI5
/*************************************************************************
    Function:   FindAndSelect
    Purpose:    Selects the TTS engine
    Inputs:     PTTSMODEINFO pTTSInfo - Desired mode
    Returns:    PITTSCENTRAL - Pointer to ITTSCentral interface of engine
    History:	a-anilk created
*************************************************************************/
PITTSCENTRAL FindAndSelect(PTTSMODEINFO pTTSInfo)
{
    PITTSCENTRAL    pITTSCentral;           // central interface
    HRESULT         hRes;
    WORD            voice;
	TCHAR           defaultVoice[128];
	WORD			defLangID;

	hRes = CoCreateInstance (CLSID_TTSEnumerator, NULL, CLSCTX_ALL, IID_ITTSEnum, (void**)&g_pITTSEnum);
    if (FAILED(hRes))
        return NULL;

	// Security Check, Disallow Non-Microsoft Engines on Logon desktops..
	logonCheck = RunSecure(GetDesktop());

    // Get the audio dest
    hRes = CoCreateInstance(CLSID_MMAudioDest,
                            NULL,
                            CLSCTX_ALL,
                            IID_IAudioMultiMediaDevice,
                            (void**)&pIAMM);
    if (FAILED(hRes))
        return NULL;     // error
	
    pIAMM->DeviceNumSet (WAVE_MAPPER);

	if ( !logonCheck )
	{
		hRes = g_pITTSEnum->Next(MAX_ENUMMODES,gaTTSInfo,&gnmodes);
		if (FAILED(hRes))
		{
			DBPRINTF(TEXT("Failed to get any TTS Engine"));
			return NULL;     // error
		}
	
		defLangID = (WORD) GetUserDefaultUILanguage();

		// If the voice needs to be changed, Check in the list of voices..
		// If found a matching language, Great. Otherwise cribb! Anyway select a 
		// voice at the end, First one id none is found...
		// If not initialized, Then we need to over ride voice
		if ( currentVoice < 0 || currentVoice >= gnmodes ) 
		{
			for (voice = 0; voice < gnmodes; voice++)
			{
				if (gaTTSInfo[voice].language.LanguageID == defLangID)
					break;
			}

			if (voice >= gnmodes)
				voice = 0;

			currentVoice = voice;
		}
		

		if( gaTTSInfo[currentVoice].language.LanguageID != defLangID )
		{
			// Error message saying that the language was not not found...AK
			MessageBoxLoadStrings (NULL, IDS_LANGW, IDS_WARNING, MB_OK);
		}

		// Pass off the multi-media-device interface as an IUnknown (since it is one)
		hRes = g_pITTSEnum->Select( gaTTSInfo[currentVoice].gModeID,
									&pITTSCentral,
									(LPUNKNOWN) pIAMM);
		if (FAILED(hRes))
			return NULL;
	}
	else
	{
		// Pass off the multi-media-device interface as an IUnknown (since it is one)
		hRes = g_pITTSEnum->Select( MSTTS_GUID,
									&pITTSCentral,
									(LPUNKNOWN) pIAMM);
		if (FAILED(hRes))
			return NULL;

	}

	hRes = pITTSCentral->QueryInterface (IID_ITTSAttributes, (void**)&g_pITTSAttributes);

	if( FAILED(hRes) )
		return NULL;
	else
    {
		GetSpeechMinMaxValues();
    }

    SET_VALUE(SetPitch, currentPitch, lastPitch)
    SET_VALUE(SetSpeed, currentSpeed, lastSpeed)
    SET_VALUE(SetVolume, currentVolume, lastVolume)

    return pITTSCentral;
}
#endif // ifndef SAPI5

/*************************************************************************
    Function:
    Purpose:
    Inputs:
    Returns:
    History:
*************************************************************************/
int MessageBoxLoadStrings (HWND hWnd,UINT uIDText,UINT uIDCaption,UINT uType)
{
	TCHAR szText[1024];
	TCHAR szCaption[128];

	LoadString(g_hInst, uIDText, szText, sizeof(szText)/sizeof(TCHAR));	// raid #113790
	LoadString(g_hInst, uIDCaption, szCaption, sizeof(szCaption)/sizeof(TCHAR)); // raid #113791
	return (MessageBox(hWnd, szText, szCaption, uType));
}

// AssignDeskTop() For UM
// a-anilk. 1-12-98
static BOOL  AssignDesktop(LPDWORD desktopID, LPTSTR pname)
{
    HDESK hdesk;
    wchar_t name[300];
    DWORD nl;

    *desktopID = DESKTOP_ACCESSDENIED;
    hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);

    if (!hdesk)
    {
        // OpenInputDesktop will mostly fail on "Winlogon" desktop
        hdesk = OpenDesktop(__TEXT("Winlogon"),0,FALSE,MAXIMUM_ALLOWED);
        if (!hdesk)
            return FALSE;
    }

    GetUserObjectInformation(hdesk,UOI_NAME,name,300,&nl);

    if (pname)
        wcscpy(pname, name);
    if (!_wcsicmp(name, __TEXT("Default")))
        *desktopID = DESKTOP_DEFAULT;
    else if (!_wcsicmp(name, __TEXT("Winlogon")))
    {
        *desktopID = DESKTOP_WINLOGON;
    }
    else if (!_wcsicmp(name, __TEXT("screen-saver")))
        *desktopID = DESKTOP_SCREENSAVER;
    else if (!_wcsicmp(name, __TEXT("Display.Cpl Desktop")))
        *desktopID = DESKTOP_TESTDISPLAY;
    else
        *desktopID = DESKTOP_OTHER;
    
	CloseDesktop(GetThreadDesktop(GetCurrentThreadId()));
    SetThreadDesktop(hdesk);
    
    return TRUE;
}


// InitMyProcessDesktopAccess
// a-anilk: 1-12-98
static BOOL InitMyProcessDesktopAccess(VOID)
{
  origWinStation = GetProcessWindowStation();
  userWinStation = OpenWindowStation(__TEXT("WinSta0"), FALSE, MAXIMUM_ALLOWED);

  if (!userWinStation)
    return FALSE;
  
  SetProcessWindowStation(userWinStation);
  return TRUE;
}

// ExitMyProcessDesktopAccess
// a-anilk: 1-12-98
static VOID ExitMyProcessDesktopAccess(VOID)
{
  if (origWinStation)
    SetProcessWindowStation(origWinStation);

  if (userWinStation)
  {
	CloseWindowStation(userWinStation);
    userWinStation = NULL;
  }
}

// a-anilk added
// Returns the current desktop-ID
DWORD GetDesktop()
{
    HDESK hdesk;
    TCHAR name[300];
    DWORD value, nl, desktopID = DESKTOP_ACCESSDENIED;
    HKEY reg_key;
    DWORD cbData = sizeof(DWORD);
	LONG retVal;

	// Check if we are in setup mode...
	if (SUCCEEDED( RegOpenKeyEx(HKEY_LOCAL_MACHINE, __TEXT("SYSTEM\\Setup"), 0, KEY_READ, &reg_key)) )
    {
		retVal = RegQueryValueEx(reg_key, __TEXT("SystemSetupInProgress"), 0, NULL, (LPBYTE) &value, &cbData);

		RegCloseKey(reg_key);
		
		if ( (retVal== ERROR_SUCCESS) && value )
			// Setup is in progress...
			return DESKTOP_ACCESSDENIED;
	}

	hdesk = OpenInputDesktop(0, FALSE, MAXIMUM_ALLOWED);
    if (!hdesk)
    {
        // OpenInputDesktop will mostly fail on "Winlogon" desktop
        hdesk = OpenDesktop(__TEXT("Winlogon"),0,FALSE,MAXIMUM_ALLOWED);
        if (!hdesk)
            return DESKTOP_WINLOGON;
    }
    
	GetUserObjectInformation(hdesk, UOI_NAME, name, 300, &nl);
    CloseDesktop(hdesk);
    
	if (!_wcsicmp(name, __TEXT("Default")))
        desktopID = DESKTOP_DEFAULT;

    else if (!_wcsicmp(name, __TEXT("Winlogon")))
        desktopID = DESKTOP_WINLOGON;

    else if (!_wcsicmp(name, __TEXT("screen-saver")))
        desktopID = DESKTOP_SCREENSAVER;

    else if (!_wcsicmp(name, __TEXT("Display.Cpl Desktop")))
        desktopID = DESKTOP_TESTDISPLAY;

    else
        desktopID = DESKTOP_OTHER;
    
	return desktopID;
}

//Confirmation dialog.
INT_PTR CALLBACK ConfirmProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
			{
				if ( IsIconic(g_hwndMain) )
				{
					CenterWindow(hwnd);
				}

				return TRUE;
			}
			break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
				case IDOK:
					Shutup();
                    EndDialog (hwnd, IDOK);
                    return(TRUE);
                case IDCANCEL:
					Shutup();
                    EndDialog (hwnd, IDCANCEL);
                    return(TRUE);
             }
     };

     return(FALSE);  // didn't handle
}

// Centers Narrator dialogs when main window is minimized:AK
void CenterWindow(HWND hwnd)
{
	RECT rect, dRect;
	GetWindowRect(GetDesktopWindow(), &dRect);
	GetWindowRect(hwnd, &rect);
	rect.left = (dRect.right - (rect.right - rect.left))/2;
	rect.top = (dRect.bottom - (rect.bottom - rect.top))/2;

	SetWindowPos(hwnd, HWND_TOPMOST ,rect.left,rect.top,0,0,SWP_NOSIZE | SWP_NOACTIVATE);
}

// Helper method Filters smiley face utterances: AK
void FilterSpeech(TCHAR* szSpeak)
{
	// the GUID's have a Tab followed by a {0087....
	// If you find this pattern. Then donot speak that:AK
	if ( lstrlen(szSpeak) <= 3 )
		return;

    TCHAR *szSpeakBegin = szSpeak;
	// make sure the we don't go over MAX_TEXT.
	while((*(szSpeak+3)) != NULL && (szSpeak-szSpeakBegin < MAX_TEXT-3))
	{
		if ( (*szSpeak == '(') && iswalpha(*(szSpeak + 1)) && ( (*(szSpeak + 3) == ')')) )
		{
			// Replace by isAlpha drive...
			*(szSpeak + 2) = ' ';
		}

		szSpeak++;
	}
}

// Helper functions for combo boxes

int GetComboItemData(HWND hwnd)
{
    int iValue = CB_ERR;
    LRESULT iCurSel = SendMessage(hwnd, CB_GETCURSEL, 0, 0);
    if (iCurSel != CB_ERR)
        iValue = SendMessage(hwnd, CB_GETITEMDATA, iCurSel, 0);

    return iValue;
}

void FillAndSetCombo(HWND hwnd, int iMinVal, int iMaxVal, int iSelVal)
{
    SendMessage(hwnd, CB_RESETCONTENT, 0, 0);

    int iSelPos = -1;
    for (int i=0;iMaxVal >= iMinVal;i++, iMaxVal--)
    {
        TCHAR szItem[100];
        wsprintf(szItem, TEXT("%d"), iMaxVal);

        int iPos = SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)szItem);
        SendMessage(hwnd, CB_SETITEMDATA, iPos, iMaxVal);

        if (iSelVal == iMaxVal)
            iSelPos = iPos; // note the current selection
    }

    // show the current value
    SendMessage(hwnd, CB_SETCURSEL, iSelPos, 0);
}
/*************************************************************************
    THE INFORMATION AND CODE PROVIDED HEREUNDER (COLLECTIVELY REFERRED TO
    AS "SOFTWARE") IS PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN
    NO EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
    ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
    CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
    MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGES. SOME STATES DO NOT ALLOW THE EXCLUSION OR
    LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES SO THE
    FOREGOING LIMITATION MAY NOT APPLY.
*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\narrator\narrator\reader.h ===
#define IDH_READER_SETTINGS_VOICE		70600 //settings dialog
#define IDH_READER_SELECT_VOICE			70605 //voice dialog
#define IDH_READER_VOICE_SPEED			70610 //voice dialog
#define IDH_READER_VOICE_VOLUME			70615 //voice dialog
#define IDH_READER_VOICE_PITCH			70620 //voice dialog
#define IDH_READER_SETTINGS_READING		70625 //settings dialog
#define IDH_READER_READING_PRINTABLE		70630 //reading dialog
#define IDH_READER_READING_DELETE		70635 //reading dialog
#define IDH_READER_READING_SPACE		70640 //reading dialog
#define IDH_READER_READING_MODIFIERS		70645 //reading dialog
#define IDH_READER_READING_TAB			70650 //reading dialog
#define IDH_READER_READING_BACKSPACE		70655 //reading dialog
#define IDH_READER_READING_ENTER		70660 //reading dialog
#define IDH_READER_SETTINGS_EVENTS		70665 //settings dialog
#define IDH_READER_EVENT_WINDOW			70670 //event dialog
#define IDH_READER_EVENT_MENU			70675 //event dialog
#define IDH_READER_EVENT_POPUP_MENU		70680 //event dialog
#define IDH_READER_EVENT_TOOLTIPS		70685 //event dialog
#define IDH_READER_SETTINGS_MOUSEPOINTER	70690 //settings dialog
#define IDH_READER_MOUSE_ACTIVE_ITEM		70695 //mouse dialog
#define IDH_READER_MOUSE_INSERTION_POINT	70700 //mouse dialog
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\narrator\narrator\narrator.h ===
// Narrator Globals
#define WM_MSRREPEAT WM_APP+1 //A key for us to process
#define WM_MSRSPEAK WM_APP+2
#define WM_MUTE WM_APP+3
#define WM_MSRHELP WM_APP+4
#define WM_MSRQUIT WM_APP+5
#define WM_MSRCONFIGURE WM_APP+6
#define WM_MSRDESKSW WM_APP+7
#define WM_MSRSPEAKXML WM_APP+8
#define WM_MSRSPEAKMUTE WM_APP+9

#define MSR_ECHOALNUM		  1
#define MSR_ECHOBACK		  2
#define MSR_ECHOSPACE		  4
#define MSR_ECHODELETE		  8
#define MSR_ECHOTAB			 16
#define MSR_ECHOENTER		 32
#define MSR_ECHOMODIFIERS	 64
#define MSR_ECHOGRAPHICS	128

#define ID_PROPERTYFIRST    100
#define ID_NAME         100
#define ID_ROLE         101
#define ID_STATE        102
#define ID_LOCATION     103
#define ID_DESCRIPTION  104
#define ID_VALUE        105
#define ID_HELP         106
#define ID_SHORTCUT     107
#define ID_DEFAULT      108
#define ID_PARENT       109
#define ID_CHILDREN     110
#define ID_SELECTION    111
#define ID_WINDOW       112
#define ID_PROPERTYLAST 112
#define UMR_MACHINE_KEY HKEY_LOCAL_MACHINE
#define UM_REGISTRY_KEY TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Accessibility\\Utility Manager")

#define MAX_TEXT 20000  

typedef struct tagObjectInfo
{
    HWND hwnd;
    long* plObj;
    VARIANT varChild;
} OBJINFO;

typedef tagObjectInfo* LPOBJINFO;

// Macros and function prototypes for debugging
#include "..\..\inc\w95trace.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\narrator\narrhook\getprop.cpp ===
/*************************************************************************
	Project:    Narrator
    Module:     getprop.cpp

    Author:     Charles Oppermann (ChuckOp)   
    Date:       24 October 1996
    
    Notes:      Gets Object Information

    Copyright (C) 1996 by Microsoft Corporation.  All rights reserved.
    See bottom of file for disclaimer
    
    History: Clean up buffer problems : a-anilk

*************************************************************************/
#define STRICT
#include <windows.h>
#include <windowsx.h>
#include <winerror.h>

#include <oleacc.h>

#include "..\Narrator\Narrator.h"
#include "getprop.h"
#define ARRAYSIZE(x)   (sizeof(x) / sizeof(*x))

void GetObjectProperty(IAccessible*, long, int, LPTSTR, UINT);
void VariantMyInit(VARIANT *pv);

// --------------------------------------------------------------------------
//
//  GetObjectProperty
//
// --------------------------------------------------------------------------
void GetObjectProperty(IAccessible * pobj, LONG idChild, int idProperty,
    LPTSTR lpszName,  UINT cchName)
{
    HRESULT hr=0;
    VARIANT varChild;
    BSTR bstr;
    RECT rc;
    VARIANT varResult;
	TCHAR bigbuf[4096] = TEXT("");


	if (!lpszName || cchName<1) return;
    *lpszName = 0;

    if ( cchName > ARRAYSIZE(bigbuf) )
        cchName = ARRAYSIZE(bigbuf);
    
    //
    // Clear out the possible return value objects
    //
    bstr = NULL;
    SetRectEmpty(&rc);
    VariantMyInit(&varResult);

    //
    // Setup the VARIANT child to pass in to the property
    //
    VariantMyInit(&varChild);
    varChild.vt = VT_I4;
    varChild.lVal = idChild;

    
    //
    // Get the property
    //
    switch (idProperty)
    {
        case ID_NAME:
                hr = pobj->get_accName(varChild, &bstr);
            break;

        case ID_DESCRIPTION:
                hr = pobj->get_accDescription(varChild, &bstr);
            break;

        case ID_VALUE:
                hr = pobj->get_accValue(varChild, &bstr);
            break;

        case ID_HELP:
            // Future enhancement:  Try help file instead if failure
               hr = pobj->get_accHelp(varChild, &bstr);
            break;

        case ID_SHORTCUT:
                hr = pobj->get_accKeyboardShortcut(varChild, &bstr);
            break;

        case ID_DEFAULT:
                hr = pobj->get_accDefaultAction(varChild, &bstr);
            break;

        case ID_ROLE:
                hr = pobj->get_accRole(varChild, &varResult);
            break;

        case ID_STATE:
                hr = pobj->get_accState(varChild, &varResult);
            break;

        case ID_LOCATION:
                hr = pobj->accLocation(&rc.left, &rc.top, &rc.right, &rc.bottom, varChild);
            break;
        case ID_CHILDREN:
//            hr = GetObjectChildren(pobj, idChild, lpszName, cchName);
            break;

        case ID_SELECTION:
//            hr = GetObjectSelection(pobj, idChild, lpszName, cchName);
            break;

        case ID_PARENT:
//            hr = GetObjectParent(pobj, idChild, lpszName, cchName);
            break;

        case ID_WINDOW:
//            hr = GetObjectWindow(pobj, lpszName, cchName);
            break;

    }

    // Return if the IAccessible call failed.
    if (!SUCCEEDED(hr))
    {
#ifdef _DEBUG
        // Pass back the error string to be displayed

        LPVOID  lpMsgBuf;
        LPTSTR  lpTChar;
        int     length;
     
        length = FormatMessage( 
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            hr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf,
            0,
            NULL 
        );
        lpTChar = (LPTSTR)lpMsgBuf;
        // remove the \r\n at the end of the string
        if (length > 2)
            if (lpTChar[length-2] == '\r')
                lpTChar[length-2] = 0;

      	wsprintf(bigbuf, TEXT("['%s' hr 0x%lx idProperty %d pobj 0x%lx idChild 0x%lx]"), lpMsgBuf,hr, idProperty, pobj, idChild);
		bigbuf[cchName-1]=0;
		lstrcpy(lpszName, bigbuf);

        // Free the buffer.
        LocalFree( lpMsgBuf );
#endif
        return;
    }

    //
    // Convert it to a display string
    //
    switch (idProperty)
    {
        // These are the cases already taken care of.
        case ID_SELECTION:
        case ID_CHILDREN:
        case ID_PARENT:
        case ID_WINDOW:
            break;

        // These are the cases where we got unicode string back
        case ID_NAME:
        case ID_DESCRIPTION:
        case ID_VALUE:
        case ID_HELP:
        case ID_SHORTCUT:
        case ID_DEFAULT:
            if (bstr)
            {
#ifdef UNICODE
			lstrcpyn(bigbuf, bstr, sizeof(bigbuf) / sizeof(TCHAR));
#else
            WideCharToMultiByte(CP_ACP, 0, bstr, -1, (LPBYTE)bigbuf, cchName, NULL, NULL);
#endif
           
			SysFreeString(bstr);

            }
            break;

        case ID_LOCATION:
            wsprintf(bigbuf, TEXT("{%04d, %04d, %04d, %04d}"), rc.left, rc.top,
                rc.left + rc.right, rc.top + rc.bottom);
            break;

        case ID_ROLE: // Role can be either I4 or BSTR
            break;

        case ID_STATE: // State can either be I4 or BSTR
            if (varResult.vt == VT_BSTR)
            {
#ifdef UNICODE
			lstrcpyn(bigbuf, varResult.bstrVal, sizeof(bigbuf) / sizeof(TCHAR));
#else
                // If we got back a string, use that.
            WideCharToMultiByte(CP_ACP, 0, varResult.bstrVal, -1,
                    bigbuf, cchName, NULL, NULL);
#endif
            }
            else if (varResult.vt == VT_I4)
            {
                int     iStateBit;
                DWORD   lStateBits;
                LPTSTR  lpszT;
                UINT    cchT;

                // We have a mask of standard states.  Make a string.
                // Separate the states with ",".
                lpszT = bigbuf;

                for (iStateBit = 0, lStateBits = 1; iStateBit < 32; iStateBit++, (lStateBits <<= 1))
                {
                    if (varResult.lVal & lStateBits)
                    {
                        cchT = GetStateText(lStateBits, lpszT, cchName);

						// If it is link, say so
						// if (lStateBits==STATE_SYSTEM_LINKED) Say(SAY_ALWAYS, lpszT);

                        lpszT += cchT;
                        cchName -= cchT;

                        *lpszT++ = ',';
                        *lpszT++ = ' ';
                    }
                }

                //
                // Clip off final ", "
                //
                if (varResult.lVal)
                {
                    *(lpszT-2) = 0;
                    *(lpszT-1) = 0;
                }
                else
                    GetStateText(0, bigbuf, cchName);
            }

            VariantClear(&varResult);
            break;

        default:
            DebugBreak();
    }

	bigbuf[cchName-1]=0;
	lstrcpy(lpszName, bigbuf);
	return;
}


/*************************************************************************
    Function:   GetObjectName
    Purpose:    
    Inputs:     
    Returns:    
    History:
*************************************************************************/
/* DWORD GetObjectName(LPOBJINFO poiObj,LPTSTR lpszBuf, int cchBuf)
{
    BSTR  bszName;
    IAccessible* pIAcc;
    long* pl;

    bszName = NULL;

    // Get the object out of the struct
    pl = poiObj->plObj;

    pIAcc =(IAccessible*)pl;

	GetObjectProperty(pIAcc, poiObj->varChild.lVal, ID_NAME, lpszBuf, cchBuf);
	return(0);
}
*/
/*
DWORD GetObjectDescription(LPOBJINFO poiObj,LPTSTR lpszBuf, int cchBuf)
{
    DWORD dwRetVal;
    BSTR  bszDesc;
    IAccessible* pIAcc;
    long* pl;

    bszDesc = NULL;

    // Get the object out of the struct
    pl = poiObj->plObj;

    pIAcc =(IAccessible*)pl;

    // Get the object's name
    pIAcc->get_accDescription(poiObj->varChild, &bszDesc);
    
    // Did we get name string?
    if (bszDesc)
        {
        // Convert from OLE Unicode
        if (WideCharToMultiByte(CP_ACP, 0, 
                            bszDesc,
                            WC_SEPCHARS, // -1
                            lpszBuf,
                            cchBuf,
                            NULL, NULL))
            {
            SysFreeString(bszDesc);

            dwRetVal = NO_ERROR;
            }
        else
            {
            dwRetVal = GetLastError();
            }
        return(dwRetVal);
        }
        
    
    // Need general failure handling routine
    MessageBeep(MB_ICONEXCLAMATION);
    
    return(ERROR_INVALID_FUNCTION);
}
*/
/*
DWORD GetObjectValue(LPOBJINFO poiObj, LPTSTR lpszBuf, int cchBuf)
{
    DWORD dwRetVal;
    BSTR  bszValue;
    IAccessible* pIAcc;
    long* pl;

    bszValue = NULL;

    // Get the object out of the struct
    pl = poiObj->plObj;

    pIAcc =(IAccessible*)pl;

    // Get the object's name
    pIAcc->get_accValue(poiObj->varChild, &bszValue);
    
    // Did we get name string?
    if (bszValue)
        {
        // Convert from OLE Unicode
        if (WideCharToMultiByte(CP_ACP, 0, 
                            bszValue,
                            WC_SEPCHARS, // -1
                            lpszBuf,
                            cchBuf,
                            NULL, NULL))
            {
            SysFreeString(bszValue);

            dwRetVal = NO_ERROR;
            }
        else
            {
            dwRetVal = GetLastError();
            }
        return(dwRetVal);
        }
        
    
    // Need general failure handling routine
    MessageBeep(MB_ICONEXCLAMATION);
    
    return(ERROR_INVALID_FUNCTION);
}
*/

void VariantMyInit(VARIANT *pv)
{
	VariantInit(pv);
	pv->lVal=0;
}

/*************************************************************************
    THE INFORMATION AND CODE PROVIDED HEREUNDER (COLLECTIVELY REFERRED TO
    AS "SOFTWARE") IS PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN
    NO EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
    ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
    CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
    MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGES. SOME STATES DO NOT ALLOW THE EXCLUSION OR
    LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES SO THE
    FOREGOING LIMITATION MAY NOT APPLY.
*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\narrator\narrator\sources.inc ===
#
# We need to make sure we pick up the right information in the header files
# TODO: Verify that this is the right place for these defines
#

C_DEFINES=$(C_DEFINES)  -DUNICODE -D_UNICODE

WIN32_IE_VERSION=0x0400
WIN32_WINNT_VERSION=0x0500

TARGETNAME=Narrator
TARGETPATH=obj
TARGETTYPE=PROGRAM
USE_MSVCRT=1
USE_NATIVE_EH=1

TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\ole32.lib    \
           $(SDK_LIB_PATH)\winmm.lib    \
           $(SHELL_LIB_PATH)\shell32p.lib \
           $(SDK_LIB_PATH)\htmlhelp.lib \
		   $(SDK_LIB_PATH)\comctl32.lib \
           $(SHELL_LIB_PATH)\shlwapip.lib \
           $(SDK_LIB_PATH)\sapi.lib

NOT_LEAN_AND_MEAN=1

!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

SOURCES= ..\Narrator.cpp   \
         ..\Narrator.rc

INCLUDES=$(ENDUSER_INC_PATH);..\..\..\inc

UMTYPE=windows
UMENTRY=winmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\narrator\narrator\version.h ===
// NARRATOR.EXE version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "Microsoft Narrator"
#define VER_INTERNALNAME_STR        "NARRATOR"
#define VER_ORIGINALFILENAME_STR    "NARRATOR.EXE"
#define VER_FILETYPE                VFT_APP
#define VER_FILESUBTYPE             VFT2_UNKNOWN

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\narrator\narrator\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Narrator.rc
//
#define IDS_COPYRIGHT                   3
#define IDS_VOICE                       8
#define IDS_THETEXT                     9
#define IDS_THETITLE                    10
#define IDS_NO_OLE                      11
#define IDS_NO_SOUNDCARD                12
#define IDS_NO_TTS                      13
#define IDS_MSR_ERROR                   14
#define IDS_ABOUTBOX                    16
#define IDM_ABOUTBOX                    0x0010
#define IDS_HELLO                       17
#define IDS_INTRO                       18
#define IDS_ENABLEWEB                   19
#define IDS_LANGW                       20
#define IDS_WARNING                     21
#define IDS_ERROR                       22
#define IDS_SECURE                      23
#define IDS_SAM                         24
#define IDD_MAIN                        101
#define IDI_ICON1                       102
#define IDD_MOUSE                       103
#define IDD_CONFIG                      104
#define IDD_HELP                        105
#define IDD_REVIEW                      109
#define IDD_VOICE                       110
#define IDD_EVENTS                      112
#define IDD_ABOUTBOX                    113
#define IDD_CONFIRMEXIT                 122
#define IDD_WARNING                     123
#define IDC_EXIT                        1000
#define IDC_MOUSEBUTTON                 1002
#define IDC_INPUTFOCUS                  1004
#define IDC_CARET                       1006
#define IDC_MSRHELP                     1009
#define IDC_MSRCONFIG                   1010
#define IDC_VOICESETTINGS               1017
#define IDC_READING                     1018
#define IDC_EVENTS                      1019
#define IDC_MINIMIZE                    1020
#define IDC_BACKSPACE                   1021
#define IDC_SPACE                       1022
#define IDC_DELETE                      1023
#define IDC_TAB                         1024
#define IDC_ENTER                       1025
#define IDC_MODIFIERS                   1026
#define IDC_ALNUM                       1027
#define IDC_COMBOSPEED                  1030
#define IDC_COMBOVOLUME                 1031
#define IDC_COMBOPITCH                  1032
#define IDC_NAME                        1036
#define IDC_ANNOUNCE_WINDOW             1051
#define IDC_ANNOUNCE_MENU               1052
#define IDC_ANNOUNCEPOPUP               1053
#define IDC_ANNOUNCETOOLTIPS            1054
#define IDC_WINDOWINFO                  1056
#define IDC_BEGINNER                    1059
#define IDC_EXPERIENCED                 1060
#define IDC_PASSIVE                     1061
#define IDC_ABOUTICON                   1062
#define IDC_ABOUTVERSION                1063
#define IDC_ABOUTCOPYRIGHT              1064
#define IDC_ABOUTDISCLAIMER             1065
#define IDC_ABOUTWEBSITE                1066
#define IDC_ABOUTWEBSITE2               1067
#define IDC_SPEEDSLIDER                 1068
#define IDC_ABOUTWEBSITE3               1068
#define IDC_VOLUMESLIDER                1069
#define IDC_PITCHSLIDER                 1070
#define IDC_VOICE                       1071
#define IDC_SPEED                       1072
#define IDC_VOLUME                      1073
#define IDC_PITCH                       1074
#define IDC_NARR_DESC                   1075
#define IDC_ANNOUNCE                    1078
#define IDC_MOUSEPTR                    1080
#define IDC_STARTMIN                    1081
#define IDC_CAPTION                     1082
#define IDC_WARNING                     1083
#define IDC_WARND                       1084
#define IDC_WARND2                      1085
#define IDC_ENABLEWEBA                  1086
#define IDC_ENABLEWEB                   1087
#define IDC_ENABLEWEB2                  1088
#define IDC_WARND3                      1089

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        123
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1088
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\narrator\narrator\speech.h ===
/*****************************************************************8
Speech.H - Header file to use the Microsoft Speech APIs.

Copyright 1994, 1995 by Microsoft corporation.All rights reserved.
*/

#ifndef _SPEECH_
#define _SPEECH_

// Disable the warning for zero-length arrays in structures
#pragma warning(disable:4200)


/************************************************************************
Defines common to all of the speech APIs.
*/

// Application  Speech API   Compiler Defines                   _S_UNICODE
// -----------------------------------------------------------------------------
//   ANSI        ANSI        <none>                             undefined
//   ANSI        Unicode     _S_UNICODE                         defined
//   Unicode     ANSI        (UNICODE || _UNICODE) && _S_ANSI   undefined
//   Unicode     Unicode     (UNICODE || _UNICODE)              defined

#if (defined(UNICODE) || defined(_UNICODE)) && !defined(_S_ANSI)
#ifndef _S_UNICODE
#define _S_UNICODE
#endif
#endif

/************************************************************************
defines */
#define  SVFN_LEN    (262)
#define  LANG_LEN    (64)
#define  EI_TITLESIZE   (128)
#define  EI_DESCSIZE    (512)
#define  EI_FIXSIZE     (512)
#define  SVPI_MFGLEN    (64)
#define  SVPI_PRODLEN   (64)
#define  SVPI_COMPLEN   (64)
#define  SVPI_COPYRIGHTLEN (128)
#define  SVI_MFGLEN     (SVPI_MFGLEN)
#define  SETBIT(x)      ((DWORD)1 << (x))


// Error Macros
#define  FACILITY_SPEECH   (FACILITY_ITF)
#define  SPEECHERROR(x)    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_SPEECH, (x)+0x200)
#define  AUDERROR(x)       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_SPEECH, (x)+0x300)
#define  SRWARNING(x)      MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_SPEECH, (x)+0x400)
#define  SRERROR(x)        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_SPEECH, (x)+0x400)
#define  TTSERROR(x)       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_SPEECH, (x)+0x500)
#define  VCMDERROR(x)      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_SPEECH, (x)+0x600)
#define  VTXTERROR(x)      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_SPEECH, (x)+0x700)
#define  LEXERROR(x)       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_SPEECH, (x)+0x800)

// Audio Errors
#define  AUDERR_NONE                      S_OK                          // 0x00000000
#define  AUDERR_BADDEVICEID               AUDERROR(1)                   // 0x80040301
#define  AUDERR_NEEDWAVEFORMAT            AUDERROR(2)                   // 0x80040302
#define  AUDERR_NOTSUPPORTED              E_NOTIMPL                     // 0x80004001
#define  AUDERR_NOTENOUGHDATA             SPEECHERROR(1)                // 0x80040201
#define  AUDERR_NOTPLAYING                AUDERROR(6)                   // 0x80040306
#define  AUDERR_INVALIDPARAM              E_INVALIDARG                  // 0x80070057
#define  AUDERR_WAVEFORMATNOTSUPPORTED    SPEECHERROR(2)                // 0x80040202
#define  AUDERR_WAVEDEVICEBUSY            SPEECHERROR(3)                // 0x80040203
#define  AUDERR_WAVEDEVNOTSUPPORTED       AUDERROR(18)                  // 0x80040312
#define  AUDERR_NOTRECORDING              AUDERROR(19)                  // 0x80040313
#define  AUDERR_INVALIDFLAG               SPEECHERROR(4)                // 0x80040204
#define  AUDERR_INVALIDHANDLE             E_HANDLE                      // 0x80070006
#define  AUDERR_NODRIVER                  AUDERROR(23)                  // 0x80040317
#define  AUDERR_HANDLEBUSY                AUDERROR(24)                  // 0x80040318
#define  AUDERR_INVALIDNOTIFYSINK         AUDERROR(25)                  // 0x80040319
#define  AUDERR_WAVENOTENABLED            AUDERROR(26)                  // 0x8004031A
#define  AUDERR_ALREADYCLAIMED            AUDERROR(29)                  // 0x8004031D
#define  AUDERR_NOTCLAIMED                AUDERROR(30)                  // 0x8004031E
#define  AUDERR_STILLPLAYING              AUDERROR(31)                  // 0x8004031F
#define  AUDERR_ALREADYSTARTED            AUDERROR(32)                  // 0x80040320
#define  AUDERR_SYNCNOTALLOWED            AUDERROR(33)                  // 0x80040321

// Speech Recognition Warnings
#define  SRWARN_BAD_LIST_PRONUNCIATION    SRWARNING(1)

// Speech Recognition Errors
#define  SRERR_NONE                       S_OK                          // 0x00000000
#define  SRERR_OUTOFDISK                  SPEECHERROR(5)                // 0x80040205
#define  SRERR_NOTSUPPORTED               E_NOTIMPL                     // 0x80004001
#define  SRERR_NOTENOUGHDATA              AUDERR_NOTENOUGHDATA          // 0x80040201
#define  SRERR_VALUEOUTOFRANGE            E_UNEXPECTED                  // 0x8000FFFF
#define  SRERR_GRAMMARTOOCOMPLEX          SRERROR(6)                    // 0x80040406
#define  SRERR_GRAMMARWRONGTYPE           SRERROR(7)                    // 0x80040407
#define  SRERR_INVALIDWINDOW              OLE_E_INVALIDHWND             // 0x8004000F
#define  SRERR_INVALIDPARAM               E_INVALIDARG                  // 0x80070057
#define  SRERR_INVALIDMODE                SPEECHERROR(6)                // 0x80040206
#define  SRERR_TOOMANYGRAMMARS            SRERROR(11)                   // 0x8004040B
#define  SRERR_INVALIDLIST                SPEECHERROR(7)                // 0x80040207
#define  SRERR_WAVEDEVICEBUSY             AUDERR_WAVEDEVICEBUSY         // 0x80040203
#define  SRERR_WAVEFORMATNOTSUPPORTED     AUDERR_WAVEFORMATNOTSUPPORTED // 0x80040202
#define  SRERR_INVALIDCHAR                SPEECHERROR(8)                // 0x80040208
#define  SRERR_GRAMTOOCOMPLEX             SRERR_GRAMMARTOOCOMPLEX       // 0x80040406
#define  SRERR_GRAMTOOLARGE               SRERROR(17)                   // 0x80040411
#define  SRERR_INVALIDINTERFACE           E_NOINTERFACE                 // 0x80004002
#define  SRERR_INVALIDKEY                 SPEECHERROR(9)                // 0x80040209
#define  SRERR_INVALIDFLAG                AUDERR_INVALIDFLAG            // 0x80040204
#define  SRERR_GRAMMARERROR               SRERROR(22)                   // 0x80040416
#define  SRERR_INVALIDRULE                SRERROR(23)                   // 0x80040417
#define  SRERR_RULEALREADYACTIVE          SRERROR(24)                   // 0x80040418
#define  SRERR_RULENOTACTIVE              SRERROR(25)                   // 0x80040419
#define  SRERR_NOUSERSELECTED             SRERROR(26)                   // 0x8004041A
#define  SRERR_BAD_PRONUNCIATION          SRERROR(27)                   // 0x8004041B
#define  SRERR_DATAFILEERROR              SRERROR(28)                   // 0x8004041C
#define  SRERR_GRAMMARALREADYACTIVE       SRERROR(29)                   // 0x8004041D
#define  SRERR_GRAMMARNOTACTIVE           SRERROR(30)                   // 0x8004041E
#define  SRERR_GLOBALGRAMMARALREADYACTIVE SRERROR(31)                   // 0x8004041F
#define  SRERR_LANGUAGEMISMATCH           SRERROR(32)                   // 0x80040420
#define  SRERR_MULTIPLELANG               SRERROR(33)                   // 0x80040421
#define  SRERR_LDGRAMMARNOWORDS           SRERROR(34)                   // 0x80040422
#define  SRERR_NOLEXICON                  SRERROR(35)                   // 0x80040423
#define  SRERR_SPEAKEREXISTS              SRERROR(36)                   // 0x80040424
#define  SRERR_GRAMMARENGINEMISMATCH      SRERROR(37)                   // 0x80040425


// Text to Speech Errors
#define  TTSERR_NONE                      S_OK                          // 0x00000000
#define  TTSERR_INVALIDINTERFACE          E_NOINTERFACE                 // 0x80004002
#define  TTSERR_OUTOFDISK                 SRERR_OUTOFDISK               // 0x80040205
#define  TTSERR_NOTSUPPORTED              E_NOTIMPL                     // 0x80004001
#define  TTSERR_VALUEOUTOFRANGE           E_UNEXPECTED                  // 0x8000FFFF
#define  TTSERR_INVALIDWINDOW             OLE_E_INVALIDHWND             // 0x8004000F
#define  TTSERR_INVALIDPARAM              E_INVALIDARG                  // 0x80070057
#define  TTSERR_INVALIDMODE               SRERR_INVALIDMODE             // 0x80040206
#define  TTSERR_INVALIDKEY                SRERR_INVALIDKEY              // 0x80040209
#define  TTSERR_WAVEFORMATNOTSUPPORTED    AUDERR_WAVEFORMATNOTSUPPORTED // 0x80040202
#define  TTSERR_INVALIDCHAR               SRERR_INVALIDCHAR             // 0x80040208
#define  TTSERR_QUEUEFULL                 SPEECHERROR(10)               // 0x8004020A
#define  TTSERR_WAVEDEVICEBUSY            AUDERR_WAVEDEVICEBUSY         // 0x80040203
#define  TTSERR_NOTPAUSED                 TTSERROR(1)                   // 0x80040501
#define  TTSERR_ALREADYPAUSED             TTSERROR(2)                   // 0x80040502


// Voice Command Errors

/*
 *  Everything worked
 */
#define  VCMDERR_NONE                     S_OK                          // 0x00000000

/*
 *  Voice Commands could not allocate memory
 */
#define  VCMDERR_OUTOFMEM                 E_OUTOFMEMORY                 // 0x8007000E

/*
 *  Voice Commands could not store/retrieve a command set from the database
 */
#define  VCMDERR_OUTOFDISK                SRERR_OUTOFDISK               // 0x80040205

/*
 *  Function not implemented
 */
#define  VCMDERR_NOTSUPPORTED             E_NOTIMPL                     // 0x80004001

/*
 *  A parameter was passed that was out of the ranged of accepted values
 */
#define  VCMDERR_VALUEOUTOFRANGE          E_UNEXPECTED                  // 0x8000FFFF

/*
 *  A menu was too complex to compile a context-free grammar
 */
#define  VCMDERR_MENUTOOCOMPLEX           VCMDERROR(0x06)               //  0x80040606

/*
 *  Language mismatch between the speech recognition mode and menu trying
 *  to create
 */
#define  VCMDERR_MENUWRONGLANGUAGE        VCMDERROR(0x07)               // 0x80040607

/*
 *  An invalid window handle was passed to Voice Commands
 */
#define  VCMDERR_INVALIDWINDOW            OLE_E_INVALIDHWND             // 0x8004000F

/*
 *  Voice Commands detected a bad function parameter
 */
#define  VCMDERR_INVALIDPARAM             E_INVALIDARG                  // 0x80070057

/*
 *  This function cannot be completed right now, usually when trying to do
 *  some operation while no speech recognition site is established
 */
#define  VCMDERR_INVALIDMODE              SRERR_INVALIDMODE             // 0x80040206

/*
 *  There are too many Voice Commands menu
 */                                                                     // 0x8004060B
#define  VCMDERR_TOOMANYMENUS             VCMDERROR(0x0B)

/*
 *  Invalid list passed to ListSet/ListGet
 */
#define  VCMDERR_INVALIDLIST              SRERR_INVALIDLIST             // 0x80040207

/*
 *  Trying to open an existing menu that is not in the Voice Commands database
 */
#define  VCMDERR_MENUDOESNOTEXIST         VCMDERROR(0x0D)               // 0x8004060D

/*
 *  The function could not be completed because the menu is actively 
 *  listening for commands
 */
#define  VCMDERR_MENUACTIVE               VCMDERROR(0x0E)               // 0x8004060E

/*
 *  No speech recognition engine is started
 */
#define  VCMDERR_NOENGINE                 VCMDERROR(0x0F)               // 0x8004060F

/*
 *  Voice Commands could not acquire a Grammar interface from the speech
 *  recognition engine
 */
#define  VCMDERR_NOGRAMMARINTERFACE       VCMDERROR(0x10)               // 0x80040610

/*
 *  Voice Commands could not acquire a Find interface from the speech
 *  recognition engine
 */
#define  VCMDERR_NOFINDINTERFACE          VCMDERROR(0x11)               // 0x80040611

/*
 *  Voice Commands could not create a speech recognition enumerator
 */
#define  VCMDERR_CANTCREATESRENUM         VCMDERROR(0x12)               // 0x80040612

/*
 *  Voice Commands could get the appropriate site information to start a
 *  speech recognition engine
 */
#define  VCMDERR_NOSITEINFO               VCMDERROR(0x13)               // 0x80040613

/*
 *  Voice Commands could not find a speech recognition engine
 */
#define  VCMDERR_SRFINDFAILED             VCMDERROR(0x14)               // 0x80040614

/*
 *  Voice Commands could not create an audio source object
 */
#define  VCMDERR_CANTCREATEAUDIODEVICE    VCMDERROR(0x15)               // 0x80040615

/*
 *  Voice Commands could not set the appropriate device number in the
 *  audio source object
 */
#define  VCMDERR_CANTSETDEVICE            VCMDERROR(0x16)               // 0x80040616

/*
 *  Voice Commands could not select a speech recognition engine. Usually the
 *  error will occur when Voice Commands has enumerated and found an
 *  appropriate speech recognition engine, then it is not able to actually
 *  select/start the engine. There are different reasons that the engine won't
 *  start, but the most common is that there is no wave in device.
 */
#define  VCMDERR_CANTSELECTENGINE         VCMDERROR(0x17)               // 0x80040617

/*
 *  Voice Commands could not create a notfication sink for engine
 *  notifications
 */
#define  VCMDERR_CANTCREATENOTIFY         VCMDERROR(0x18)               // 0x80040618

/*
 *  Voice Commands could not create internal data structures.
 */
#define  VCMDERR_CANTCREATEDATASTRUCTURES VCMDERROR(0x19)               // 0x80040619

/*
 *  Voice Commands could not initialize internal data structures
 */
#define  VCMDERR_CANTINITDATASTRUCTURES   VCMDERROR(0x1A)               // 0x8004061A

/*
 *  The menu does not have an entry in the Voice Commands cache
 */
#define  VCMDERR_NOCACHEDATA              VCMDERROR(0x1B)               // 0x8004061B

/*
 *  The menu does not have commands
 */
#define  VCMDERR_NOCOMMANDS               VCMDERROR(0x1C)               // 0x8004061C

/*
 *  Voice Commands cannot extract unique words needed for the engine grammar
 */
#define  VCMDERR_CANTXTRACTWORDS          VCMDERROR(0x1D)               // 0x8004061D

/*
 *  Voice Commands could not get the command set database name
 */
#define  VCMDERR_CANTGETDBNAME            VCMDERROR(0x1E)               // 0x8004061E

/*
 *  Voice Commands could not create a registry key
 */
#define  VCMDERR_CANTCREATEKEY            VCMDERROR(0x1F)               // 0x8004061F

/*
 *  Voice Commands could not create a new database name
 */
#define  VCMDERR_CANTCREATEDBNAME         VCMDERROR(0x20)               // 0x80040620

/*
 *  Voice Commands could not update the registry
 */
#define  VCMDERR_CANTUPDATEREGISTRY       VCMDERROR(0x21)               // 0x80040621

/*
 *  Voice Commands could not open the registry
 */
#define  VCMDERR_CANTOPENREGISTRY         VCMDERROR(0x22)               // 0x80040622

/*
 *  Voice Commands could not open the command set database
 */
#define  VCMDERR_CANTOPENDATABASE         VCMDERROR(0x23)               // 0x80040623

/*
 *  Voice Commands could not create a database storage object
 */
#define  VCMDERR_CANTCREATESTORAGE        VCMDERROR(0x24)               // 0x80040624

/*
 *  Voice Commands could not do CmdMimic
 */
#define  VCMDERR_CANNOTMIMIC              VCMDERROR(0x25)               // 0x80040625

/*
 *  A menu of this name already exist
 */
#define  VCMDERR_MENUEXIST                VCMDERROR(0x26)               // 0x80040626

/*
 *  A menu of this name is open and cannot be deleted right now
 */
#define  VCMDERR_MENUOPEN                 VCMDERROR(0x27)               // 0x80040627


// Voice Text Errors
#define  VTXTERR_NONE                     S_OK                          // 0x00000000

/*
 *  Voice Text failed to allocate memory it needed
 */
#define  VTXTERR_OUTOFMEM                 E_OUTOFMEMORY                 // 0x8007000E

/*
 *  An empty string ("") was passed to the Speak function
 */
#define  VTXTERR_EMPTYSPEAKSTRING         SPEECHERROR(0x0b)             // 0x8004020B

/*
 *  An invalid parameter was passed to a Voice Text function
 */
#define  VTXTERR_INVALIDPARAM             E_INVALIDARG                  // 0x80070057

/*
 *  The called function cannot be done at this time. This usually occurs
 *  when trying to call a function that needs a site, but no site has been
 *  registered.
 */
#define  VTXTERR_INVALIDMODE              SRERR_INVALIDMODE             // 0x80040206

/*
 *  No text-to-speech engine is started
 */
#define  VTXTERR_NOENGINE                 VTXTERROR(0x0F)               // 0x8004070F

/*
 *  Voice Text could not acquire a Find interface from the text-to-speech
 *  engine
 */
#define  VTXTERR_NOFINDINTERFACE          VTXTERROR(0x11)               // 0x80040711

/*
 *  Voice Text could not create a text-to-speech enumerator
 */
#define  VTXTERR_CANTCREATETTSENUM        VTXTERROR(0x12)               // 0x80040712

/*
 *  Voice Text could get the appropriate site information to start a
 *  text-to-speech engine
 */
#define  VTXTERR_NOSITEINFO               VTXTERROR(0x13)               // 0x80040713

/*
 *  Voice Text could not find a text-to-speech engine
 */
#define  VTXTERR_TTSFINDFAILED            VTXTERROR(0x14)               // 0x80040714

/*
 *  Voice Text could not create an audio destination object
 */
#define  VTXTERR_CANTCREATEAUDIODEVICE    VTXTERROR(0x15)               // 0x80040715

/*
 *  Voice Text could not set the appropriate device number in the
 *  audio destination object
 */
#define  VTXTERR_CANTSETDEVICE            VTXTERROR(0x16)               // 0x80040716

/*
 *  Voice Text could not select a text-to-speech engine. Usually the
 *  error will occur when Voice Text has enumerated and found an
 *  appropriate text-to-speech engine, then it is not able to actually
 *  select/start the engine.
 */
#define  VTXTERR_CANTSELECTENGINE         VTXTERROR(0x17)               // 0x80040717

/*
 *  Voice Text could not create a notfication sink for engine
 *  notifications
 */
#define  VTXTERR_CANTCREATENOTIFY         VTXTERROR(0x18)               // 0x80040718

/*
 *  Voice Text is disabled at this time
 */
#define  VTXTERR_NOTENABLED               VTXTERROR(0x19)               // 0x80040719

#define  VTXTERR_OUTOFDISK                SRERR_OUTOFDISK               // 0x80040205
#define  VTXTERR_NOTSUPPORTED             E_NOTIMPL                     // 0x80004001
#define  VTXTERR_NOTENOUGHDATA            AUDERR_NOTENOUGHDATA          // 0x80040201
#define  VTXTERR_QUEUEFULL                TTSERR_QUEUEFULL              // 0x8004020A
#define  VTXTERR_VALUEOUTOFRANGE          E_UNEXPECTED                  // 0x8000FFFF
#define  VTXTERR_INVALIDWINDOW            OLE_E_INVALIDHWND             // 0x8004000F
#define  VTXTERR_WAVEDEVICEBUSY           AUDERR_WAVEDEVICEBUSY         // 0x80040203
#define  VTXTERR_WAVEFORMATNOTSUPPORTED   AUDERR_WAVEFORMATNOTSUPPORTED // 0x80040202
#define  VTXTERR_INVALIDCHAR              SRERR_INVALIDCHAR             // 0x80040208


// ILexPronounce errors
#define  LEXERR_INVALIDTEXTCHAR           LEXERROR(0x01)                // 0x80040801
#define  LEXERR_INVALIDSENSE              LEXERROR(0x02)                // 0x80040802
#define  LEXERR_NOTINLEX                  LEXERROR(0x03)                // 0x80040803
#define  LEXERR_OUTOFDISK                 LEXERROR(0x04)                // 0x80040804
#define  LEXERR_INVALIDPRONCHAR           LEXERROR(0x05)                // 0x80040805
#define  LEXERR_ALREADYINLEX              LEXERROR(0x06)                // 0x80040806
#define  LEXERR_PRNBUFTOOSMALL            LEXERROR(0x07)                // 0x80040807
#define  LEXERR_ENGBUFTOOSMALL            LEXERROR(0x08)                // 0x80040808



/************************************************************************
typedefs */

typedef LPUNKNOWN FAR * PIUNKNOWN;

typedef struct {
   PVOID    pData;
   DWORD    dwSize;
   } SDATA, * PSDATA;



typedef struct {
   LANGID   LanguageID;
   WCHAR    szDialect[LANG_LEN];
   } LANGUAGEW, FAR * PLANGUAGEW;

typedef struct {
   LANGID   LanguageID;
   CHAR     szDialect[LANG_LEN];
   } LANGUAGEA, FAR * PLANGUAGEA;

#ifdef  _S_UNICODE
#define LANGUAGE    LANGUAGEW
#define PLANGUAGE   PLANGUAGEW
#else
#define LANGUAGE    LANGUAGEA
#define PLANGUAGE   PLANGUAGEA
#endif  // _S_UNICODE



typedef unsigned _int64 QWORD, * PQWORD;

typedef enum {
   CHARSET_TEXT           = 0,
   CHARSET_IPAPHONETIC    = 1,
   CHARSET_ENGINEPHONETIC = 2
   } VOICECHARSET;

typedef enum _VOICEPARTOFSPEECH {
   VPS_UNKNOWN = 0,
   VPS_NOUN = 1,
   VPS_VERB = 2,
   VPS_ADVERB = 3,
   VPS_ADJECTIVE = 4,
   VPS_PROPERNOUN = 5,
   VPS_PRONOUN = 6,
   VPS_CONJUNCTION = 7,
   VPS_CARDINAL = 8,
   VPS_ORDINAL = 9,
   VPS_DETERMINER = 10,
   VPS_QUANTIFIER = 11,
   VPS_PUNCTUATION = 12,
   VPS_CONTRACTION = 13,
   VPS_INTERJECTION = 14,
   VPS_ABBREVIATION = 15,
   VPS_PREPOSITION = 16
   } VOICEPARTOFSPEECH;


typedef struct {
   DWORD   dwNextPhonemeNode;
   DWORD   dwUpAlternatePhonemeNode;
   DWORD   dwDownAlternatePhonemeNode;
   DWORD   dwPreviousPhonemeNode;
   DWORD   dwWordNode;
   QWORD   qwStartTime;
   QWORD   qwEndTime;
   DWORD   dwPhonemeScore;
   WORD    wVolume;
   WORD    wPitch;
   } SRRESPHONEMENODE, *PSRRESPHONEMENODE;


typedef struct {
   DWORD   dwNextWordNode;
   DWORD   dwUpAlternateWordNode;
   DWORD   dwDownAlternateWordNode;
   DWORD   dwPreviousWordNode;
   DWORD   dwPhonemeNode;
   QWORD   qwStartTime;
   QWORD   qwEndTime;
   DWORD   dwWordScore;
   WORD      wVolume;
   WORD      wPitch;
   VOICEPARTOFSPEECH   pos;
   DWORD   dwCFGParse;
   DWORD   dwCue;
   } SRRESWORDNODE, * PSRRESWORDNODE;


/************************************************************************
interfaces */

/*
 * ILexPronounce
 */

#undef   INTERFACE
#define  INTERFACE   ILexPronounceW

DEFINE_GUID(IID_ILexPronounceW, 0x090CD9A2, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ILexPronounceW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // LexPronounceW members
   STDMETHOD (Add)            (THIS_ VOICECHARSET, PCWSTR, PCWSTR, 
			       VOICEPARTOFSPEECH, PVOID, DWORD) PURE;
   STDMETHOD (Get)            (THIS_ VOICECHARSET, PCWSTR, WORD, PWSTR, 
			       DWORD, DWORD *, VOICEPARTOFSPEECH *, PVOID, 
			       DWORD, DWORD *) PURE;
   STDMETHOD (Remove)         (THIS_ PCWSTR, WORD) PURE;
   };

typedef ILexPronounceW FAR * PILEXPRONOUNCEW;


#undef   INTERFACE
#define  INTERFACE   ILexPronounceA

DEFINE_GUID(IID_ILexPronounceA, 0x2F26B9C0L, 0xDB31, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ILexPronounceA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // LexPronounceA members
   STDMETHOD (Add)            (THIS_ VOICECHARSET, PCSTR, PCSTR, 
			       VOICEPARTOFSPEECH, PVOID, DWORD) PURE;
   STDMETHOD (Get)            (THIS_ VOICECHARSET, PCSTR, WORD, PSTR, 
			       DWORD, DWORD *, VOICEPARTOFSPEECH *, PVOID, 
			       DWORD, DWORD *) PURE;
   STDMETHOD (Remove)         (THIS_ PCSTR, WORD) PURE;
   };

typedef ILexPronounceA FAR * PILEXPRONOUNCEA;


#ifdef _S_UNICODE
 #define ILexPronounce        ILexPronounceW
 #define IID_ILexPronounce    IID_ILexPronounceW
 #define PILEXPRONOUNCE       PILEXPRONOUNCEW

#else
 #define ILexPronounce        ILexPronounceA
 #define IID_ILexPronounce    IID_ILexPronounceA
 #define PILEXPRONOUNCE       PILEXPRONOUNCEA

#endif   // _S_UNICODE



/************************************************************************
Audio source/destiantion API
*/

/************************************************************************
defines */

// AudioStop
#define      IANSRSN_NODATA             0
#define      IANSRSN_PRIORITY           1
#define      IANSRSN_INACTIVE           2
#define      IANSRSN_EOF                3

// IAudioSourceInstrumented::StateSet
#define          IASISTATE_PASSTHROUGH      0
#define          IASISTATE_PASSNOTHING      1
#define          IASISTATE_PASSREADFROMWAVE 2
#define          IASISTATE_PASSWRITETOWAVE  3

/************************************************************************
typedefs */

/************************************************************************
Class IDs */
// {CB96B400-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(CLSID_MMAudioDest, 
0xcb96b400, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);
// {D24FE500-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(CLSID_MMAudioSource, 
0xd24fe500, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);
// {D4023720-E4B9-11cf-8D56-00A0C9034A7E}
DEFINE_GUID(CLSID_InstAudioSource, 
0xd4023720, 0xe4b9, 0x11cf, 0x8d, 0x56, 0x0, 0xa0, 0xc9, 0x3, 0x4a, 0x7e);

/************************************************************************
interfaces */

// IAudio
#undef   INTERFACE
#define  INTERFACE   IAudio

// {F546B340-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(IID_IAudio, 
0xf546b340, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

DECLARE_INTERFACE_ (IAudio, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IAudio members
   STDMETHOD (Flush)          (THIS) PURE;
   STDMETHOD (LevelGet)       (THIS_ DWORD *) PURE;
   STDMETHOD (LevelSet)       (THIS_ DWORD) PURE;
   STDMETHOD (PassNotify)     (THIS_ PVOID, IID) PURE;
   STDMETHOD (PosnGet)        (THIS_ PQWORD) PURE;
   STDMETHOD (Claim)          (THIS) PURE;
   STDMETHOD (UnClaim)        (THIS) PURE;
   STDMETHOD (Start)          (THIS) PURE;
   STDMETHOD (Stop)           (THIS) PURE;
   STDMETHOD (TotalGet)       (THIS_ PQWORD) PURE;
   STDMETHOD (ToFileTime)     (THIS_ PQWORD, FILETIME *) PURE;
   STDMETHOD (WaveFormatGet)  (THIS_ PSDATA) PURE;
   STDMETHOD (WaveFormatSet)  (THIS_ SDATA) PURE;
   };

typedef IAudio FAR * PIAUDIO;

// IAudioDest

#undef   INTERFACE
#define  INTERFACE   IAudioDest

// {2EC34DA0-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(IID_IAudioDest, 
0x2ec34da0, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

DECLARE_INTERFACE_ (IAudioDest, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IAudioDest members
   STDMETHOD (FreeSpace)      (THIS_ DWORD *, BOOL *) PURE;
   STDMETHOD (DataSet)        (THIS_ PVOID, DWORD) PURE;
   STDMETHOD (BookMark)       (THIS_ DWORD) PURE;
   };

typedef IAudioDest FAR * PIAUDIODEST;



// IAudioDestNotifySink

#undef   INTERFACE
#define  INTERFACE   IAudioDestNotifySink

// {ACB08C00-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(IID_IAudioDestNotifySink, 
0xacb08c00, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

DECLARE_INTERFACE_ (IAudioDestNotifySink, IUnknown) {
   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IAudioDestNotifySink members
   STDMETHOD (AudioStop)      (THIS_ WORD) PURE;
   STDMETHOD (AudioStart)     (THIS) PURE;
   STDMETHOD (FreeSpace)      (THIS_ DWORD, BOOL) PURE;
   STDMETHOD (BookMark)       (THIS_ DWORD, BOOL) PURE;
   };

typedef IAudioDestNotifySink FAR * PIAUDIODESTNOTIFYSINK;



// IAudioMultiMediaDevice

#undef   INTERFACE
#define  INTERFACE   IAudioMultiMediaDevice

// {B68AD320-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(IID_IAudioMultiMediaDevice, 
0xb68ad320, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

DECLARE_INTERFACE_ (IAudioMultiMediaDevice, IUnknown) {
   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IAudioMultiMediaDevice members
   STDMETHOD (CustomMessage)  (THIS_ UINT, SDATA) PURE;
   STDMETHOD (DeviceNumGet)   (THIS_ DWORD*) PURE;
   STDMETHOD (DeviceNumSet)   (THIS_ DWORD) PURE;
   };

typedef IAudioMultiMediaDevice FAR * PIAUDIOMULTIMEDIADEVICE;



// IAudioSource
#undef   INTERFACE
#define  INTERFACE   IAudioSource

// {BC06A220-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(IID_IAudioSource, 
0xbc06a220, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

DECLARE_INTERFACE_ (IAudioSource, IUnknown) {
   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IAudioSource members
   STDMETHOD (DataAvailable)  (THIS_ DWORD *, BOOL *) PURE;
   STDMETHOD (DataGet)        (THIS_ PVOID, DWORD, DWORD *) PURE;
   };

typedef IAudioSource FAR * PIAUDIOSOURCE;



// IAudioSourceInstrumented
#undef   INTERFACE
#define  INTERFACE   IAudioSourceInstrumented

// {D4023721-E4B9-11cf-8D56-00A0C9034A7E}
DEFINE_GUID(IID_IAudioSourceInstrumented, 
0xd4023721, 0xe4b9, 0x11cf, 0x8d, 0x56, 0x0, 0xa0, 0xc9, 0x3, 0x4a, 0x7e);

DECLARE_INTERFACE_ (IAudioSourceInstrumented, IUnknown) {
   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IAudioSourceInstrumented members
   STDMETHOD (AudioSource)    (THIS_ LPUNKNOWN) PURE;
   STDMETHOD (RegistryGet)    (THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD (RegistrySet)    (THIS_ PCWSTR) PURE;
   STDMETHOD (StateGet)       (THIS_ DWORD*) PURE;
   STDMETHOD (StateSet)       (THIS_ DWORD) PURE;
   STDMETHOD (WaveFileReadGet)(THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD (WaveFileReadSet)(THIS_ PCWSTR) PURE;
   STDMETHOD (WaveFileWriteGet)(THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD (WaveFileWriteSet)(THIS_ PCWSTR) PURE;
   };

typedef IAudioSourceInstrumented FAR * PIAUDIOSOURCEINSTRUMENTED;


// IAudioSourceNotifySink
#undef   INTERFACE
#define  INTERFACE   IAudioSourceNotifySink

// {C0BD9A80-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(IID_IAudioSourceNotifySink, 
0xc0bd9a80, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

DECLARE_INTERFACE_ (IAudioSourceNotifySink, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IAudioSourceNotifySink members
   STDMETHOD (AudioStop)      (THIS_ WORD) PURE;
   STDMETHOD (AudioStart)     (THIS) PURE;
   STDMETHOD (DataAvailable)  (THIS_ DWORD, BOOL) PURE;
   STDMETHOD (Overflow)       (THIS_ DWORD) PURE;
   };

typedef IAudioSourceNotifySink FAR * PIAUDIOSOURCENOTIFYSINK;



/************************************************************************
defines */
/* SRINFO */
#define  SRMI_NAMELEN                  SVFN_LEN

#define  SRSEQUENCE_DISCRETE           (0)
#define  SRSEQUENCE_CONTINUOUS          (1)
#define  SRSEQUENCE_WORDSPOT            (2)
#define  SRSEQUENCE_CONTCFGDISCDICT     (3)

#define  SRGRAM_CFG                    SETBIT(0)
#define  SRGRAM_DICTATION              SETBIT(1)
#define  SRGRAM_LIMITEDDOMAIN          SETBIT(2)

#define  SRFEATURE_INDEPSPEAKER        SETBIT(0)
#define  SRFEATURE_INDEPMICROPHONE     SETBIT(1)
#define  SRFEATURE_TRAINWORD           SETBIT(2)
#define  SRFEATURE_TRAINPHONETIC       SETBIT(3)
#define  SRFEATURE_WILDCARD            SETBIT(4)
#define  SRFEATURE_ANYWORD             SETBIT(5)
#define  SRFEATURE_PCOPTIMIZED         SETBIT(6)
#define  SRFEATURE_PHONEOPTIMIZED      SETBIT(7)
#define  SRFEATURE_GRAMLIST            SETBIT(8)
#define  SRFEATURE_GRAMLINK            SETBIT(9)
#define  SRFEATURE_MULTILINGUAL        SETBIT(10)
#define  SRFEATURE_GRAMRECURSIVE       SETBIT(11)
#define  SRFEATURE_IPAUNICODE          SETBIT(12)

#define  SRI_ILEXPRONOUNCE             SETBIT(0)
#define  SRI_ISRATTRIBUTES             SETBIT(1)
#define  SRI_ISRCENTRAL                SETBIT(2)
#define  SRI_ISRDIALOGS                SETBIT(3)
#define  SRI_ISRGRAMCOMMON             SETBIT(4)
#define  SRI_ISRGRAMCFG                SETBIT(5)
#define  SRI_ISRGRAMDICTATION          SETBIT(6)
#define  SRI_ISRGRAMINSERTIONGUI       SETBIT(7)
#define  SRI_ISRESBASIC                SETBIT(8)
#define  SRI_ISRESMERGE                SETBIT(9)
#define  SRI_ISRESAUDIO                SETBIT(10)
#define  SRI_ISRESCORRECTION           SETBIT(11)
#define  SRI_ISRESEVAL                 SETBIT(12)
#define  SRI_ISRESGRAPH                SETBIT(13)
#define  SRI_ISRESMEMORY               SETBIT(14)
#define  SRI_ISRESMODIFYGUI            SETBIT(15)
#define  SRI_ISRESSPEAKER              SETBIT(16)
#define  SRI_ISRSPEAKER                SETBIT(17)
#define  SRI_ISRESSCORES               SETBIT(18)


// ISRGramCommon::TrainQuery
#define   SRGRAMQ_NONE                    0
#define   SRGRAMQ_GENERALTRAIN            1
#define   SRGRAMQ_PHRASE                  2
#define   SRGRAMQ_DIALOG                  3

// ISRGramNotifySink::PhraseFinish
#define   ISRNOTEFIN_RECOGNIZED         SETBIT(0)
#define   ISRNOTEFIN_THISGRAMMAR        SETBIT(1)
#define   ISRNOTEFIN_FROMTHISGRAMMAR    SETBIT(2)

// ISRGramNotifySink::Training
#define   SRGNSTRAIN_GENERAL            SETBIT(0)
#define   SRGNSTRAIN_GRAMMAR            SETBIT(1)
#define   SRGNSTRAIN_MICROPHONE         SETBIT(2)

// ISRNotifySink::AttribChange
#define   ISRNSAC_AUTOGAINENABLE        1
#define   ISRNSAC_THRESHOLD             2
#define   ISRNSAC_ECHO                  3
#define   ISRNSAC_ENERGYFLOOR           4
#define   ISRNSAC_MICROPHONE            5
#define   ISRNSAC_REALTIME              6
#define   ISRNSAC_SPEAKER               7
#define   ISRNSAC_TIMEOUT               8

/* Interference */
#define  SRMSGINT_NOISE                (0x0001)
#define  SRMSGINT_NOSIGNAL             (0x0002)
#define  SRMSGINT_TOOLOUD              (0x0003)
#define  SRMSGINT_TOOQUIET             (0x0004)
#define  SRMSGINT_AUDIODATA_STOPPED    (0x0005)
#define  SRMSGINT_AUDIODATA_STARTED    (0x0006)
#define  SRMSGINT_IAUDIO_STARTED       (0x0007)
#define  SRMSGINT_IAUDIO_STOPPED       (0x0008)

// Gramamr header values
#define   SRHDRTYPE_CFG                  0
#define   SRHDRTYPE_LIMITEDDOMAIN        1
#define   SRHDRTYPE_DICTATION            2

#define   SRHDRFLAG_UNICODE              SETBIT(0)  

/* SRCFGSYMBOL */
#define  SRCFG_STARTOPERATION          (1)
#define  SRCFG_ENDOPERATION            (2)
#define  SRCFG_WORD                    (3)
#define  SRCFG_RULE                    (4)
#define  SRCFG_WILDCARD                (5)
#define  SRCFG_LIST                    (6)

#define  SRCFGO_SEQUENCE               (1)
#define  SRCFGO_ALTERNATIVE            (2)
#define  SRCFGO_REPEAT                 (3)
#define  SRCFGO_OPTIONAL               (4)


// Grammar-chunk IDs
#define   SRCK_LANGUAGE                  1
#define   SRCKCFG_WORDS                  2
#define   SRCKCFG_RULES                  3
#define   SRCKCFG_EXPORTRULES            4
#define   SRCKCFG_IMPORTRULES            5
#define   SRCKCFG_LISTS                  6
#define   SRCKD_TOPIC                    7
#define   SRCKD_COMMON                   8
#define   SRCKD_GROUP                    9
#define   SRCKD_SAMPLE                   10
#define   SRCKLD_WORDS                   11
#define   SRCKLD_GROUP                   12
#define   SRCKLD_SAMPLE                  13 
#define   SRCKD_WORDCOUNT                14

/* TrainQuery */
#define  SRTQEX_REQUIRED               (0x0000)
#define  SRTQEX_RECOMMENDED            (0x0001)

/* ISRResCorrection */
#define  SRCORCONFIDENCE_SOME          (0x0001)
#define  SRCORCONFIDENCE_VERY          (0x0002)

/* ISRResMemory constants */
#define  SRRESMEMKIND_AUDIO            SETBIT(0)
#define  SRRESMEMKIND_CORRECTION       SETBIT(1)
#define  SRRESMEMKIND_EVAL             SETBIT(2)
#define  SRRESMEMKIND_PHONEMEGRAPH     SETBIT(3)
#define  SRRESMEMKIND_WORDGRAPH        SETBIT(4)

// Attribute minimums and maximums
#define  SRATTR_MINAUTOGAIN               0
#define  SRATTR_MAXAUTOGAIN               100
#define  SRATTR_MINENERGYFLOOR            0
#define  SRATTR_MAXENERGYFLOOR            0xffff
#define  SRATTR_MINREALTIME               0
#define  SRATTR_MAXREALTIME               0xffffffff
#define  SRATTR_MINTHRESHOLD              0
#define  SRATTR_MAXTHRESHOLD              100
#define  SRATTR_MINTOINCOMPLETE           0
#define  SRATTR_MAXTOINCOMPLETE           0xffffffff
#define  SRATTR_MINTOCOMPLETE             0
#define  SRATTR_MAXTOCOMPLETE             0xffffffff


/************************************************************************
typedefs */

typedef struct {
   DWORD    dwSize;
   DWORD    dwUniqueID;
   BYTE     abData[0];
   } SRCFGRULE, * PSRCFGRULE;



typedef struct {
   DWORD    dwSize;
   DWORD    dwRuleNum;
   WCHAR    szString[0];
   } SRCFGIMPRULEW, * PSRCFGIMPRULEW;

typedef struct {
   DWORD    dwSize;
   DWORD    dwRuleNum;
   CHAR     szString[0];
   } SRCFGIMPRULEA, * PSRCFGIMPRULEA;

#ifdef  _S_UNICODE
#define  SRCFGIMPRULE      SRCFGIMPRULEW
#define  PSRCFGIMPRULE     PSRCFGIMPRULEW
#else
#define  SRCFGIMPRULE      SRCFGIMPRULEA
#define  PSRCFGIMPRULE     PSRCFGIMPRULEA
#endif  // _S_UNICODE



typedef struct {
   DWORD    dwSize;
   DWORD    dwRuleNum;
   WCHAR    szString[0];
   } SRCFGXRULEW, * PSRCFGXRULEW;

typedef struct {
   DWORD    dwSize;
   DWORD    dwRuleNum;
   CHAR     szString[0];
   } SRCFGXRULEA, * PSRCFGXRULEA;

#ifdef  _S_UNICODE
#define  SRCFGXRULE     SRCFGXRULEW
#define  PSRCFGXRULE    PSRCFGXRULEW
#else
#define  SRCFGXRULE     SRCFGXRULEA
#define  PSRCFGXRULE    PSRCFGXRULEA
#endif  // _S_UNICODE



typedef struct {
   DWORD    dwSize;
   DWORD    dwListNum;
   WCHAR    szString[0];
   } SRCFGLISTW, * PSRCFGLISTW;

typedef struct {
   DWORD    dwSize;
   DWORD    dwListNum;
   CHAR     szString[0];
   } SRCFGLISTA, * PSRCFGLISTA;

#ifdef  _S_UNICODE
#define  SRCFGLIST      SRCFGLISTW
#define  PSRCFGLIST     PSRCFGLISTW
#else
#define  SRCFGLIST      SRCFGLISTA
#define  PSRCFGLIST     PSRCFGLISTA
#endif  // _S_UNICODE



typedef struct {
   WORD     wType;
   WORD     wProbability;
   DWORD    dwValue;
   } SRCFGSYMBOL, * PSRCFGSYMBOL;



typedef struct {
   DWORD    dwSize;
   DWORD    dwWordNum;
   WCHAR    szWord[0];
   } SRWORDW, * PSRWORDW;

typedef struct {
   DWORD    dwSize;
   DWORD    dwWordNum;
   CHAR     szWord[0];
   } SRWORDA, * PSRWORDA;

#ifdef  _S_UNICODE
#define  SRWORD      SRWORDW
#define  PSRWORD     PSRWORDW
#else
#define  SRWORD      SRWORDA
#define  PSRWORD     PSRWORDA
#endif  // _S_UNICODE



typedef struct {
   DWORD    dwSize;
   BYTE     abWords[0];
   } SRPHRASEW, * PSRPHRASEW;

typedef struct {
   DWORD    dwSize;
   BYTE     abWords[0];
   } SRPHRASEA, * PSRPHRASEA;

#ifdef  _S_UNICODE
#define  SRPHRASE    SRPHRASEW
#define  PSRPHRASE   PSRPHRASEW
#else
#define  SRPHRASE    SRPHRASEA
#define  PSRPHRASE   PSRPHRASEA
#endif  // _S_UNICODE



typedef struct {
   DWORD      dwType;
   DWORD      dwFlags;
   } SRHEADER, *PSRHEADER;

typedef struct {
   DWORD      dwChunkID;
   DWORD      dwChunkSize;
   BYTE       avInfo[0];
   } SRCHUNK, *PSRCHUNK;



typedef struct {
   GUID       gEngineID;
   WCHAR      szMfgName[SRMI_NAMELEN];
   WCHAR      szProductName[SRMI_NAMELEN];
   GUID       gModeID;
   WCHAR      szModeName[SRMI_NAMELEN];
   LANGUAGEW  language;
   DWORD      dwSequencing;
   DWORD      dwMaxWordsVocab;
   DWORD      dwMaxWordsState;
   DWORD      dwGrammars;
   DWORD      dwFeatures;
   DWORD      dwInterfaces;
   DWORD      dwEngineFeatures;
   } SRMODEINFOW, * PSRMODEINFOW;

typedef struct {
   GUID       gEngineID;
   CHAR       szMfgName[SRMI_NAMELEN];
   CHAR       szProductName[SRMI_NAMELEN];
   GUID       gModeID;
   CHAR       szModeName[SRMI_NAMELEN];
   LANGUAGEA  language;
   DWORD      dwSequencing;
   DWORD      dwMaxWordsVocab;
   DWORD      dwMaxWordsState;
   DWORD      dwGrammars;
   DWORD      dwFeatures;
   DWORD      dwInterfaces;
   DWORD      dwEngineFeatures;
   } SRMODEINFOA, * PSRMODEINFOA;

#ifdef  _S_UNICODE
#define  SRMODEINFO     SRMODEINFOW
#define  PSRMODEINFO    PSRMODEINFOW
#else
#define  SRMODEINFO     SRMODEINFOA
#define  PSRMODEINFO    PSRMODEINFOA
#endif  // _S_UNICODE



typedef struct {
   DWORD      dwEngineID;
   DWORD      dwMfgName;
   DWORD      dwProductName;
   DWORD      dwModeID;
   DWORD      dwModeName;
   DWORD      dwLanguage;
   DWORD      dwDialect;
   DWORD      dwSequencing;
   DWORD      dwMaxWordsVocab;
   DWORD      dwMaxWordsState;
   DWORD      dwGrammars;
   DWORD      dwFeatures;
   DWORD      dwInterfaces;
   DWORD      dwEngineFeatures;
   } SRMODEINFORANK, * PSRMODEINFORANK;



// speech recognition enumeration sharing object
typedef struct {
   QWORD        qwInstanceID;
   DWORD        dwDeviceID;
   SRMODEINFOW  srModeInfo;
} SRSHAREW, * PSRSHAREW;

typedef struct {
   QWORD        qwInstanceID;
   DWORD        dwDeviceID;
   SRMODEINFOA  srModeInfo;
} SRSHAREA, * PSRSHAREA;

#ifdef  _S_UNICODE
#define  SRSHARE    SRSHAREW
#define  PSRSHARE   PSRSHAREW
#else
#define  SRSHARE    SRSHAREA
#define  PSRSHARE   PSRSHAREA
#endif  // _S_UNICODE




// ISRCentral::GrammarLoad
typedef enum {
   SRGRMFMT_CFG = 0x0000,
   SRGRMFMT_LIMITEDDOMAIN = 0x0001,
   SRGRMFMT_DICTATION = 0x0002,
   SRGRMFMT_CFGNATIVE = 0x8000,
   SRGRMFMT_LIMITEDDOMAINNATIVE = 0x8001,
   SRGRMFMT_DICTATIONNATIVE = 0x8002,
   } SRGRMFMT, * PSRGRMFMT;

/************************************************************************
Class IDs */


// {E02D16C0-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(CLSID_SREnumerator, 
0xe02d16c0, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);


/************************************************************************
interfaces */


/*
 * ISRAttributes
 */

#undef   INTERFACE
#define  INTERFACE   ISRAttributesW

DEFINE_GUID(IID_ISRAttributesW, 0x68A33AA0L, 0x44CD, 0x101B, 0x90, 0xA8, 0x00, 0xAA, 0x00, 0x3E, 0x4B, 0x50);

DECLARE_INTERFACE_ (ISRAttributesW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRAttributesW members
   STDMETHOD (AutoGainEnableGet) (THIS_ DWORD *) PURE;
   STDMETHOD (AutoGainEnableSet) (THIS_ DWORD) PURE;
   STDMETHOD (EchoGet)           (THIS_ BOOL *) PURE;
   STDMETHOD (EchoSet)           (THIS_ BOOL) PURE;
   STDMETHOD (EnergyFloorGet)    (THIS_ WORD *) PURE;
   STDMETHOD (EnergyFloorSet)    (THIS_ WORD) PURE;
   STDMETHOD (MicrophoneGet)     (THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD (MicrophoneSet)     (THIS_ PCWSTR) PURE;
   STDMETHOD (RealTimeGet)       (THIS_ DWORD *) PURE;
   STDMETHOD (RealTimeSet)       (THIS_ DWORD) PURE;
   STDMETHOD (SpeakerGet)        (THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD (SpeakerSet)        (THIS_ PCWSTR) PURE;
   STDMETHOD (TimeOutGet)        (THIS_ DWORD *, DWORD *) PURE;
   STDMETHOD (TimeOutSet)        (THIS_ DWORD, DWORD) PURE;
   STDMETHOD (ThresholdGet)      (THIS_ DWORD *) PURE;
   STDMETHOD (ThresholdSet)      (THIS_ DWORD) PURE;
   };

typedef ISRAttributesW FAR * PISRATTRIBUTESW;


#undef   INTERFACE
#define  INTERFACE   ISRAttributesA

DEFINE_GUID(IID_ISRAttributesA, 0x2F26B9C1L, 0xDB31, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRAttributesA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRAttributesA members
   STDMETHOD (AutoGainEnableGet) (THIS_ DWORD *) PURE;
   STDMETHOD (AutoGainEnableSet) (THIS_ DWORD) PURE;
   STDMETHOD (EchoGet)           (THIS_ BOOL *) PURE;
   STDMETHOD (EchoSet)           (THIS_ BOOL) PURE;
   STDMETHOD (EnergyFloorGet)    (THIS_ WORD *) PURE;
   STDMETHOD (EnergyFloorSet)    (THIS_ WORD) PURE;
   STDMETHOD (MicrophoneGet)     (THIS_ PSTR, DWORD, DWORD *) PURE;
   STDMETHOD (MicrophoneSet)     (THIS_ PCSTR) PURE;
   STDMETHOD (RealTimeGet)       (THIS_ DWORD *) PURE;
   STDMETHOD (RealTimeSet)       (THIS_ DWORD) PURE;
   STDMETHOD (SpeakerGet)        (THIS_ PSTR, DWORD, DWORD *) PURE;
   STDMETHOD (SpeakerSet)        (THIS_ PCSTR) PURE;
   STDMETHOD (TimeOutGet)        (THIS_ DWORD *, DWORD *) PURE;
   STDMETHOD (TimeOutSet)        (THIS_ DWORD, DWORD) PURE;
   STDMETHOD (ThresholdGet)      (THIS_ DWORD *) PURE;
   STDMETHOD (ThresholdSet)      (THIS_ DWORD) PURE;
   };

typedef ISRAttributesA FAR * PISRATTRIBUTESA;


#ifdef _S_UNICODE
 #define ISRAttributes        ISRAttributesW
 #define IID_ISRAttributes    IID_ISRAttributesW
 #define PISRATTRIBUTES       PISRATTRIBUTESW

#else
 #define ISRAttributes        ISRAttributesA
 #define IID_ISRAttributes    IID_ISRAttributesA
 #define PISRATTRIBUTES       PISRATTRIBUTESA

#endif // _S_UNICODE



/*
 * ISRCentral
 */

#undef   INTERFACE
#define  INTERFACE   ISRCentralW

DEFINE_GUID(IID_ISRCentralW, 0xB9BD3860L, 0x44DB, 0x101B, 0x90, 0xA8, 0x00, 0xAA, 0x00, 0x3E, 0x4B, 0x50);

DECLARE_INTERFACE_ (ISRCentralW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRCentralW members
   STDMETHOD (ModeGet)        (THIS_ PSRMODEINFOW) PURE;
   STDMETHOD (GrammarLoad)    (THIS_ SRGRMFMT, SDATA, PVOID, IID, LPUNKNOWN *) PURE;
   STDMETHOD (Pause)          (THIS) PURE;
   STDMETHOD (PosnGet)        (THIS_ PQWORD) PURE;
   STDMETHOD (Resume)         (THIS) PURE;
   STDMETHOD (ToFileTime)     (THIS_ PQWORD, FILETIME *) PURE;
   STDMETHOD (Register)       (THIS_ PVOID, IID, DWORD*) PURE;
   STDMETHOD (UnRegister)     (THIS_ DWORD) PURE;
   };

typedef ISRCentralW FAR * PISRCENTRALW;


#undef   INTERFACE
#define  INTERFACE   ISRCentralA

DEFINE_GUID(IID_ISRCentralA, 0x2F26B9C2L, 0xDB31, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRCentralA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRCentralA members
   STDMETHOD (ModeGet)        (THIS_ PSRMODEINFOA) PURE;
   STDMETHOD (GrammarLoad)    (THIS_ SRGRMFMT, SDATA, PVOID, IID, LPUNKNOWN *) PURE;
   STDMETHOD (Pause)          (THIS) PURE;
   STDMETHOD (PosnGet)        (THIS_ PQWORD) PURE;
   STDMETHOD (Resume)         (THIS) PURE;
   STDMETHOD (ToFileTime)     (THIS_ PQWORD, FILETIME *) PURE;
   STDMETHOD (Register)       (THIS_ PVOID, IID, DWORD*) PURE;
   STDMETHOD (UnRegister)     (THIS_ DWORD) PURE;
   };

typedef ISRCentralA FAR * PISRCENTRALA;


#ifdef _S_UNICODE
 #define ISRCentral           ISRCentralW
 #define IID_ISRCentral       IID_ISRCentralW
 #define PISRCENTRAL          PISRCENTRALW

#else
 #define ISRCentral           ISRCentralA
 #define IID_ISRCentral       IID_ISRCentralA
 #define PISRCENTRAL          PISRCENTRALA

#endif   // _S_UNICODE



/*
 * ISRDialogs
 */

#undef   INTERFACE
#define  INTERFACE   ISRDialogsW

DEFINE_GUID(IID_ISRDialogsW, 0xBCFB4C60L, 0x44DB, 0x101B, 0x90, 0xA8, 0x00, 0xAA, 0x00, 0x3E, 0x4B, 0x50);

DECLARE_INTERFACE_ (ISRDialogsW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRDialogsW members
   STDMETHOD (AboutDlg)       (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (GeneralDlg)     (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (LexiconDlg)     (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (TrainMicDlg)    (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (TrainGeneralDlg)(THIS_ HWND, PCWSTR) PURE;
   };

typedef ISRDialogsW FAR * PISRDIALOGSW;


#undef   INTERFACE
#define  INTERFACE   ISRDialogsA

DEFINE_GUID(IID_ISRDialogsA, 0x05EB6C60L, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRDialogsA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRDialogsA members
   STDMETHOD (AboutDlg)       (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (GeneralDlg)     (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (LexiconDlg)     (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (TrainMicDlg)    (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (TrainGeneralDlg)(THIS_ HWND, PCSTR) PURE;
   };

typedef ISRDialogsA FAR * PISRDIALOGSA;


#ifdef _S_UNICODE
 #define ISRDialogs        ISRDialogsW
 #define IID_ISRDialogs    IID_ISRDialogsW
 #define PISRDIALOGS       PISRDIALOGSW

#else
 #define ISRDialogs        ISRDialogsA
 #define IID_ISRDialogs    IID_ISRDialogsA
 #define PISRDIALOGS       PISRDIALOGSA

#endif



/*
 *  ISREnum
 */

#undef   INTERFACE
#define  INTERFACE   ISREnumW

DEFINE_GUID(IID_ISREnumW, 0xBFA9F1A0L, 0x44DB, 0x101B, 0x90, 0xA8, 0x00, 0xAA, 0x00, 0x3E, 0x4B, 0x50);

DECLARE_INTERFACE_ (ISREnumW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISREnumW members
   STDMETHOD (Next)           (THIS_ ULONG, PSRMODEINFOW, ULONG *) PURE;
   STDMETHOD (Skip)           (THIS_ ULONG) PURE;
   STDMETHOD (Reset)          (THIS) PURE;
   STDMETHOD (Clone)          (THIS_ ISREnumW * FAR *) PURE;
   STDMETHOD (Select)         (THIS_ GUID, PISRCENTRALW *, LPUNKNOWN) PURE;
   };

typedef ISREnumW FAR * PISRENUMW;


#undef   INTERFACE
#define  INTERFACE   ISREnumA

DEFINE_GUID(IID_ISREnumA, 0x05EB6C61L, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISREnumA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISREnumA members
   STDMETHOD (Next)           (THIS_ ULONG, PSRMODEINFOA, ULONG *) PURE;
   STDMETHOD (Skip)           (THIS_ ULONG) PURE;
   STDMETHOD (Reset)          (THIS) PURE;
   STDMETHOD (Clone)          (THIS_ ISREnumA * FAR *) PURE;
   STDMETHOD (Select)         (THIS_ GUID, PISRCENTRALA *, LPUNKNOWN) PURE;
   };

typedef ISREnumA FAR * PISRENUMA;


#ifdef _S_UNICODE
 #define ISREnum           ISREnumW
 #define IID_ISREnum       IID_ISREnumW
 #define PISRENUM          PISRENUMW

#else
 #define ISREnum           ISREnumA
 #define IID_ISREnum       IID_ISREnumA
 #define PISRENUM          PISRENUMA

#endif



/*
 * ISRFind
 */

#undef   INTERFACE
#define  INTERFACE   ISRFindW

DEFINE_GUID(IID_ISRFindW, 0xC2835060L, 0x44DB, 0x101B, 0x90, 0xA8, 0x00, 0xAA, 0x00, 0x3E, 0x4B, 0x50);

DECLARE_INTERFACE_ (ISRFindW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRFindW members
   STDMETHOD (Find)           (THIS_ PSRMODEINFOW, PSRMODEINFORANK, PSRMODEINFOW) PURE;
   STDMETHOD (Select)         (THIS_ GUID, PISRCENTRALW *, LPUNKNOWN) PURE;
   };

typedef ISRFindW FAR * PISRFINDW;


#undef   INTERFACE
#define  INTERFACE   ISRFindA

DEFINE_GUID(IID_ISRFindA, 0x05EB6C62L, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRFindA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRFindA members
   STDMETHOD (Find)           (THIS_ PSRMODEINFOA, PSRMODEINFORANK, PSRMODEINFOA) PURE;
   STDMETHOD (Select)         (THIS_ GUID, PISRCENTRALA *, LPUNKNOWN) PURE;
   };

typedef ISRFindA FAR * PISRFINDA;


#ifdef _S_UNICODE
 #define ISRFind           ISRFindW
 #define IID_ISRFind       IID_ISRFindW
 #define PISRFIND          PISRFINDW

#else
 #define ISRFind           ISRFindA
 #define IID_ISRFind       IID_ISRFindA
 #define PISRFIND          PISRFINDA

#endif



/*
 * ISRGramCommon
 */

#undef   INTERFACE
#define  INTERFACE   ISRGramCommonW

DEFINE_GUID(IID_ISRGramCommonW, 0xe8c3e160, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

DECLARE_INTERFACE_ (ISRGramCommonW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)    (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)     (THIS) PURE;
   STDMETHOD_(ULONG,Release)    (THIS) PURE;

   // ISRGramCommonW members
   STDMETHOD (Activate)         (THIS_ HWND, BOOL, PCWSTR) PURE;
   STDMETHOD (Archive)          (THIS_ BOOL, PVOID, DWORD, DWORD *) PURE;
   STDMETHOD (BookMark)         (THIS_ QWORD, DWORD) PURE;
   STDMETHOD (Deactivate)       (THIS_ PCWSTR) PURE;
   STDMETHOD (DeteriorationGet) (THIS_ DWORD *, DWORD *, DWORD *) PURE;
   STDMETHOD (DeteriorationSet) (THIS_ DWORD, DWORD, DWORD) PURE;
   STDMETHOD (TrainDlg)         (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (TrainPhrase)      (THIS_ DWORD, PSDATA) PURE;
   STDMETHOD (TrainQuery)       (THIS_ DWORD *) PURE;
   };

typedef ISRGramCommonW FAR * PISRGRAMCOMMONW;


#undef   INTERFACE
#define  INTERFACE   ISRGramCommonA

DEFINE_GUID(IID_ISRGramCommonA, 0x05EB6C63L, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRGramCommonA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)    (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)     (THIS) PURE;
   STDMETHOD_(ULONG,Release)    (THIS) PURE;

   // ISRGramCommonA members
   STDMETHOD (Activate)         (THIS_ HWND, BOOL, PCSTR) PURE;
   STDMETHOD (Archive)          (THIS_ BOOL, PVOID, DWORD, DWORD *) PURE;
   STDMETHOD (BookMark)         (THIS_ QWORD, DWORD) PURE;
   STDMETHOD (Deactivate)       (THIS_ PCSTR) PURE;
   STDMETHOD (DeteriorationGet) (THIS_ DWORD *, DWORD *, DWORD *) PURE;
   STDMETHOD (DeteriorationSet) (THIS_ DWORD, DWORD, DWORD) PURE;
   STDMETHOD (TrainDlg)         (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (TrainPhrase)      (THIS_ DWORD, PSDATA) PURE;
   STDMETHOD (TrainQuery)       (THIS_ DWORD *) PURE;
   };

typedef ISRGramCommonA FAR * PISRGRAMCOMMONA;


#ifdef _S_UNICODE
 #define ISRGramCommon        ISRGramCommonW
 #define IID_ISRGramCommon    IID_ISRGramCommonW
 #define PISRGRAMCOMMON       PISRGRAMCOMMONW

#else
 #define ISRGramCommon        ISRGramCommonA
 #define IID_ISRGramCommon    IID_ISRGramCommonA
 #define PISRGRAMCOMMON       PISRGRAMCOMMONA

#endif



/*
 * ISRGramCFG
 */

#undef   INTERFACE
#define  INTERFACE   ISRGramCFGW

DEFINE_GUID(IID_ISRGramCFGW, 0xecc0b180, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

DECLARE_INTERFACE_ (ISRGramCFGW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRGramCFGW members
   STDMETHOD (LinkQuery)      (THIS_ PCWSTR, BOOL *) PURE;
   STDMETHOD (ListAppend)     (THIS_ PCWSTR, SDATA) PURE;
   STDMETHOD (ListGet)        (THIS_ PCWSTR, PSDATA) PURE;
   STDMETHOD (ListRemove)     (THIS_ PCWSTR, SDATA) PURE;
   STDMETHOD (ListSet)        (THIS_ PCWSTR, SDATA) PURE;
   STDMETHOD (ListQuery)      (THIS_ PCWSTR, BOOL *) PURE;
   };

typedef ISRGramCFGW FAR * PISRGRAMCFGW;


#undef   INTERFACE
#define  INTERFACE   ISRGramCFGA

DEFINE_GUID(IID_ISRGramCFGA, 0x05EB6C64L, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRGramCFGA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRGramCFGA members
   STDMETHOD (LinkQuery)      (THIS_ PCSTR, BOOL *) PURE;
   STDMETHOD (ListAppend)     (THIS_ PCSTR, SDATA) PURE;
   STDMETHOD (ListGet)        (THIS_ PCSTR, PSDATA) PURE;
   STDMETHOD (ListRemove)     (THIS_ PCSTR, SDATA) PURE;
   STDMETHOD (ListSet)        (THIS_ PCSTR, SDATA) PURE;
   STDMETHOD (ListQuery)      (THIS_ PCSTR, BOOL *) PURE;
   };

typedef ISRGramCFGA FAR * PISRGRAMCFGA;


#ifdef _S_UNICODE
 #define ISRGramCFG        ISRGramCFGW
 #define IID_ISRGramCFG    IID_ISRGramCFGW
 #define PISRGRAMCFG       PISRGRAMCFGW

#else
 #define ISRGramCFG        ISRGramCFGA
 #define IID_ISRGramCFG    IID_ISRGramCFGA
 #define PISRGRAMCFG       PISRGRAMCFGA

#endif



/* 
 * ISRGramDictation
 */

#undef   INTERFACE
#define  INTERFACE   ISRGramDictationW

DEFINE_GUID(IID_ISRGramDictationW, 0x090CD9A3, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRGramDictationW, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRGramDictationW members
   STDMETHOD (Context)        (THIS_ PCWSTR, PCWSTR) PURE;
   STDMETHOD (Hint)           (THIS_ PCWSTR) PURE;
   STDMETHOD (Words)          (THIS_ PCWSTR) PURE;
   };

typedef ISRGramDictationW FAR *PISRGRAMDICTATIONW;


#undef   INTERFACE
#define  INTERFACE   ISRGramDictationA

DEFINE_GUID(IID_ISRGramDictationA, 0x05EB6C65L, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRGramDictationA, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRGramDictationA members
   STDMETHOD (Context)        (THIS_ PCSTR, PCSTR) PURE;
   STDMETHOD (Hint)           (THIS_ PCSTR) PURE;
   STDMETHOD (Words)          (THIS_ PCSTR) PURE;
   };

typedef ISRGramDictationA FAR *PISRGRAMDICTATIONA;


#ifdef _S_UNICODE
 #define ISRGramDictation        ISRGramDictationW
 #define IID_ISRGramDictation    IID_ISRGramDictationW
 #define PISRGRAMDICTATION       PISRGRAMDICTATIONW

#else
 #define ISRGramDictation        ISRGramDictationA
 #define IID_ISRGramDictation    IID_ISRGramDictationA
 #define PISRGRAMDICTATION       PISRGRAMDICTATIONA

#endif



// ISRGramInsertionGUI
// This does not need an ANSI/UNICODE interface because no characters are passed
#undef   INTERFACE
#define  INTERFACE   ISRGramInsertionGUI

// {090CD9A4-DA1A-11CD-B3CA-00AA0047BA4F}
DEFINE_GUID(IID_ISRGramInsertionGUI,
0x090CD9A4, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRGramInsertionGUI, IUnknown) {
   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRGramInsertionGUI members
   STDMETHOD (Hide)           (THIS) PURE;
   STDMETHOD (Move)           (THIS_ RECT) PURE;
   STDMETHOD (Show)           (THIS_ HWND) PURE;
   };

typedef ISRGramInsertionGUI FAR *PISRGRAMINSERTIONGUI;



/*
 * ISRGramNotifySink
 */

#undef   INTERFACE
#define  INTERFACE   ISRGramNotifySinkW

DEFINE_GUID(IID_ISRGramNotifySinkW,  0xf106bfa0, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

// {B1AAC561-75D6-11cf-8D15-00A0C9034A7E}
DEFINE_GUID(IID_ISRGramNotifySinkMW, 0xb1aac561, 0x75d6, 0x11cf, 0x8d, 0x15, 0x0, 0xa0, 0xc9, 0x3, 0x4a, 0x7e);

DECLARE_INTERFACE_ (ISRGramNotifySinkW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRGramNotifySinkW members
   STDMETHOD (BookMark)       (THIS_ DWORD) PURE;
   STDMETHOD (Paused)         (THIS) PURE;
   STDMETHOD (PhraseFinish)   (THIS_ DWORD, QWORD, QWORD, PSRPHRASEW, LPUNKNOWN) PURE;
   STDMETHOD (PhraseHypothesis)(THIS_ DWORD, QWORD, QWORD, PSRPHRASEW, LPUNKNOWN) PURE;
   STDMETHOD (PhraseStart)    (THIS_ QWORD) PURE;
   STDMETHOD (ReEvaluate)     (THIS_ LPUNKNOWN) PURE;
   STDMETHOD (Training)       (THIS_ DWORD) PURE;
   STDMETHOD (UnArchive)      (THIS_ LPUNKNOWN) PURE;
   };

typedef ISRGramNotifySinkW FAR * PISRGRAMNOTIFYSINKW;


// ISRGramNotifySinkA
#undef   INTERFACE
#define  INTERFACE   ISRGramNotifySinkA

// {EFEEA350-CE5E-11cd-9D96-00AA002FC7C9}
DEFINE_GUID(IID_ISRGramNotifySinkA, 
0xefeea350, 0xce5e, 0x11cd, 0x9d, 0x96, 0x0, 0xaa, 0x0, 0x2f, 0xc7, 0xc9);

// {B1AAC562-75D6-11cf-8D15-00A0C9034A7E}
DEFINE_GUID(IID_ISRGramNotifySinkMA, 
0xb1aac562, 0x75d6, 0x11cf, 0x8d, 0x15, 0x0, 0xa0, 0xc9, 0x3, 0x4a, 0x7e);

DECLARE_INTERFACE_ (ISRGramNotifySinkA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRGramNotifySinkA members
   STDMETHOD (BookMark)       (THIS_ DWORD) PURE;
   STDMETHOD (Paused)         (THIS) PURE;
   STDMETHOD (PhraseFinish)   (THIS_ DWORD, QWORD, QWORD, PSRPHRASEA, LPUNKNOWN) PURE;
   STDMETHOD (PhraseHypothesis)(THIS_ DWORD, QWORD, QWORD, PSRPHRASEA, LPUNKNOWN) PURE;
   STDMETHOD (PhraseStart)    (THIS_ QWORD) PURE;
   STDMETHOD (ReEvaluate)     (THIS_ LPUNKNOWN) PURE;
   STDMETHOD (Training)       (THIS_ DWORD) PURE;
   STDMETHOD (UnArchive)      (THIS_ LPUNKNOWN) PURE;
   };

typedef ISRGramNotifySinkA FAR * PISRGRAMNOTIFYSINKA;


#ifdef _S_UNICODE
 #define ISRGramNotifySink       ISRGramNotifySinkW
 #define IID_ISRGramNotifySink   IID_ISRGramNotifySinkW
 #define IID_ISRGramNotifySinkM  IID_ISRGramNotifySinkMW
 #define PISRGRAMNOTIFYSINK      PISRGRAMNOTIFYSINKW

#else
 #define ISRGramNotifySink       ISRGramNotifySinkA
 #define IID_ISRGramNotifySink   IID_ISRGramNotifySinkA
 #define IID_ISRGramNotifySinkM  IID_ISRGramNotifySinkMA
 #define PISRGRAMNOTIFYSINK      PISRGRAMNOTIFYSINKA

#endif   // _S_UNICODE



// ISRNotifySink
// This does not need an ANSI/UNICODE interface because no characters are passed
#undef   INTERFACE
#define  INTERFACE   ISRNotifySink

DEFINE_GUID(IID_ISRNotifySink,
0x090CD9B0L, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRNotifySink, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRNotifySink members
   STDMETHOD (AttribChanged)  (THIS_ DWORD) PURE;
   STDMETHOD (Interference)   (THIS_ QWORD, QWORD, DWORD) PURE;
   STDMETHOD (Sound)          (THIS_ QWORD, QWORD) PURE;
   STDMETHOD (UtteranceBegin) (THIS_ QWORD) PURE;
   STDMETHOD (UtteranceEnd)   (THIS_ QWORD, QWORD) PURE;
   STDMETHOD (VUMeter)        (THIS_ QWORD, WORD) PURE;
   };

typedef ISRNotifySink FAR *PISRNOTIFYSINK;

// Just in case anyone uses the wide/ansi versions
#define ISRNotifySinkW       ISRNotifySink
#define IID_ISRNotifySinkW   IID_ISRNotifySink
#define PISRNOTIFYSINKW      PISRNOTIFYSINK
#define ISRNotifySinkA       ISRNotifySink
#define IID_ISRNotifySinkA   IID_ISRNotifySink
#define PISRNOTIFYSINKA      PISRNOTIFYSINK


/*
 * ISRResBasic
 */

#undef   INTERFACE
#define  INTERFACE   ISRResBasicW

DEFINE_GUID(IID_ISRResBasicW, 0x090CD9A5, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResBasicW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRResBasicW members
   STDMETHOD (PhraseGet)      (THIS_ DWORD, PSRPHRASEW, DWORD,  DWORD *) PURE;
   STDMETHOD (Identify)       (THIS_ GUID *) PURE;
   STDMETHOD (TimeGet)        (THIS_ PQWORD, PQWORD) PURE;
   STDMETHOD (FlagsGet)       (THIS_ DWORD, DWORD *) PURE;
   };

typedef ISRResBasicW FAR *PISRRESBASICW;


#undef   INTERFACE
#define  INTERFACE   ISRResBasicA

DEFINE_GUID(IID_ISRResBasicA, 0x05EB6C66L, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResBasicA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRResBasicA members
   STDMETHOD (PhraseGet)      (THIS_ DWORD, PSRPHRASEA, DWORD,  DWORD *) PURE;
   STDMETHOD (Identify)       (THIS_ GUID *) PURE;
   STDMETHOD (TimeGet)        (THIS_ PQWORD, PQWORD) PURE;
   STDMETHOD (FlagsGet)       (THIS_ DWORD, DWORD *) PURE;
   };

typedef ISRResBasicA FAR *PISRRESBASICA;


#ifdef _S_UNICODE
 #define ISRResBasic             ISRResBasicW
 #define IID_ISRResBasic         IID_ISRResBasicW
 #define PISRRESBASIC            PISRRESBASICW

#else
 #define ISRResBasic             ISRResBasicA
 #define IID_ISRResBasic         IID_ISRResBasicA
 #define PISRRESBASIC            PISRRESBASICA

#endif   // _S_UNICODE


/*
 * ISRResScore
 * This does not need an ANSI/UNICODE interface because no characters are passed
 */

#undef INTERFACE
#define INTERFACE       ISRResScores


// {0B37F1E0-B8DE-11cf-B22E-00AA00A215ED}
DEFINE_GUID(IID_ISRResScores, 0xb37f1e0, 0xb8de, 0x11cf, 0xb2, 0x2e, 0x0, 0xaa, 0x0, 0xa2, 0x15, 0xed);

DECLARE_INTERFACE_ (ISRResScores, IUnknown) {

	// IUnknown members
	STDMETHOD (QueryInterface)      (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
	STDMETHOD_(ULONG,Release)  (THIS) PURE;

	// ISRResScores members
	STDMETHOD (GetPhraseScore) (THIS_ DWORD, long FAR *) PURE;
	STDMETHOD (GetWordScores)  (THIS_ DWORD, long FAR *, DWORD, LPDWORD) PURE;
};

typedef ISRResScores FAR* PISRRESSCORES;

// In case someone uses the A/W versions...

#define ISRResScoresW           ISRResScores
#define IID_ISRResScoresW       IID_ISRResScores
#define PISRRESSCORESW          PISRRESSCORES
#define ISRResScoresA           ISRResScores
#define IID_ISRResScoresA       IID_ISRResScores
#define PISRRESSCORESA          PISRRESSCORES



/*
 * ISRResMerge
 * This does not need an ANSI/UNICODE interface because no characters are passed
 */

#undef   INTERFACE
#define  INTERFACE   ISRResMerge

DEFINE_GUID(IID_ISRResMerge, 0x090CD9A6, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResMerge, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRResMerge members
   STDMETHOD (Merge)          (THIS_ LPUNKNOWN, PIUNKNOWN ) PURE;
   STDMETHOD (Split)          (THIS_ QWORD, PIUNKNOWN , PIUNKNOWN ) PURE;
   };

typedef ISRResMerge FAR *PISRRESMERGE;



/*
 * ISRResAudio
 * This does not need an ANSI/UNICODE interface because no characters are passed
 */

#undef   INTERFACE
#define  INTERFACE   ISRResAudio

DEFINE_GUID(IID_ISRResAudio, 0x090CD9A7, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResAudio, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRResAudio members
   STDMETHOD (GetWAV)         (THIS_ PSDATA) PURE;
   };

typedef ISRResAudio FAR *PISRRESAUDIO;



/*
 * ISRResCorrection
 */

#undef   INTERFACE
#define  INTERFACE   ISRResCorrectionW

DEFINE_GUID(IID_ISRResCorrectionW, 0x090CD9A8L, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResCorrectionW, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRResCorrectionW members
   STDMETHOD (Correction)         (THIS_ PSRPHRASEW, WORD) PURE;
   STDMETHOD (Validate)           (THIS_ WORD) PURE;
   };

typedef ISRResCorrectionW FAR *PISRRESCORRECTIONW;


#undef   INTERFACE
#define  INTERFACE   ISRResCorrectionA

DEFINE_GUID(IID_ISRResCorrectionA, 0x05EB6C67L, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResCorrectionA, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRResCorrectionA members
   STDMETHOD (Correction)         (THIS_ PSRPHRASEA, WORD) PURE;
   STDMETHOD (Validate)           (THIS_ WORD) PURE;
   };

typedef ISRResCorrectionA FAR *PISRRESCORRECTIONA;


#ifdef _S_UNICODE
 #define ISRResCorrection        ISRResCorrectionW
 #define IID_ISRResCorrection    IID_ISRResCorrectionW
 #define PISRRESCORRECTION       PISRRESCORRECTIONW

#else
 #define ISRResCorrection        ISRResCorrectionA
 #define IID_ISRResCorrection    IID_ISRResCorrectionA
 #define PISRRESCORRECTION       PISRRESCORRECTIONA

#endif   // _S_UNICODE



// ISRResEval
// This does not need an ANSI/UNICODE interface because no characters are passed
#undef   INTERFACE
#define  INTERFACE   ISRResEval

// {90CD9A9-DA1A-11CD-B3CA-00AA0047BA4F}
DEFINE_GUID(IID_ISRResEval,
0x090CD9A9, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResEval, IUnknown) {
   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   //  SRResEval members
   STDMETHOD (ReEvaluate)     (THIS_ BOOL *) PURE;
   };

typedef ISRResEval FAR *PISRRESEVAL;



/*
 * ISRResGraph
 */

#undef   INTERFACE
#define  INTERFACE ISRResGraphW

DEFINE_GUID(IID_ISRResGraphW, 0x090CD9AA, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResGraphW, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface)     (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)       (THIS) PURE;
   STDMETHOD_(ULONG,Release)      (THIS) PURE;

   // ISRResGraphW members         
   STDMETHOD (BestPathPhoneme)    (THIS_ DWORD, DWORD *, DWORD, DWORD *) PURE;
   STDMETHOD (BestPathWord)       (THIS_ DWORD, DWORD *, DWORD, DWORD *) PURE;
   STDMETHOD (GetPhonemeNode)     (THIS_ DWORD, PSRRESPHONEMENODE, PWCHAR, 
				   PWCHAR) PURE;
   STDMETHOD (GetWordNode)        (THIS_ DWORD, PSRRESWORDNODE, PSRWORDW, DWORD, 
				   DWORD *) PURE;
   STDMETHOD (PathScorePhoneme)   (THIS_ DWORD *, DWORD, LONG *) PURE;
   STDMETHOD (PathScoreWord)      (THIS_ DWORD *, DWORD, LONG *) PURE;
   };

typedef ISRResGraphW FAR *PISRRESGRAPHW;


#undef   INTERFACE
#define  INTERFACE ISRResGraphA

DEFINE_GUID(IID_ISRResGraphA, 0x05EB6C68L, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResGraphA, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface)     (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)       (THIS) PURE;
   STDMETHOD_(ULONG,Release)      (THIS) PURE;

   // ISRResGraphA members         
   STDMETHOD (BestPathPhoneme)    (THIS_ DWORD, DWORD *, DWORD, DWORD *) PURE;
   STDMETHOD (BestPathWord)       (THIS_ DWORD, DWORD *, DWORD, DWORD *) PURE;
   STDMETHOD (GetPhonemeNode)     (THIS_ DWORD, PSRRESPHONEMENODE, PWCHAR, 
				   PCHAR) PURE;
   STDMETHOD (GetWordNode)        (THIS_ DWORD, PSRRESWORDNODE, PSRWORDA, DWORD, 
				   DWORD *) PURE;
   STDMETHOD (PathScorePhoneme)   (THIS_ DWORD *, DWORD, LONG *) PURE;
   STDMETHOD (PathScoreWord)      (THIS_ DWORD *, DWORD, LONG *) PURE;
   };

typedef ISRResGraphA FAR *PISRRESGRAPHA;


#ifdef _S_UNICODE
 #define ISRResGraph             ISRResGraphW
 #define IID_ISRResGraph         IID_ISRResGraphW
 #define PISRRESGRAPH            PISRRESGRAPHW

#else
 #define ISRResGraph             ISRResGraphA
 #define IID_ISRResGraph         IID_ISRResGraphA
 #define PISRRESGRAPH            PISRRESGRAPHA

#endif   // _S_UNICODE



// ISRResMemory
// This does not need an ANSI/UNICODE interface because no characters are passed
#undef   INTERFACE
#define  INTERFACE   ISRResMemory

DEFINE_GUID(IID_ISRResMemory, 0x090CD9AB, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResMemory, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRResMemory members
   STDMETHOD (Free)           (THIS_ DWORD) PURE;
   STDMETHOD (Get)            (THIS_ DWORD *, DWORD *) PURE;
   STDMETHOD (LockGet)        (THIS_ BOOL *) PURE;
   STDMETHOD (LockSet)        (THIS_ BOOL) PURE;
   };

typedef ISRResMemory FAR *PISRRESMEMORY;



// ISRResModifyGUI
// This does not need an ANSI/UNICODE interface because no characters are passed
#undef   INTERFACE
#define  INTERFACE   ISRResModifyGUI

DEFINE_GUID(IID_ISRResModifyGUI, 0x090CD9AC, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResModifyGUI, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface)    (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)      (THIS) PURE;
   STDMETHOD_(ULONG,Release)     (THIS) PURE;

   // ISRResModifyGUI members
   STDMETHOD (Hide)              (THIS) PURE;
   STDMETHOD (Move)              (THIS_ RECT *) PURE;
   STDMETHOD (Show)              (THIS_ HWND) PURE;
   };

typedef ISRResModifyGUI FAR *PISRRESMODIFYGUI;



/*
 * ISRResSpeakerW
 */

#undef   INTERFACE
#define  INTERFACE   ISRResSpeakerW

DEFINE_GUID(IID_ISRResSpeakerW, 0x090CD9AD, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResSpeakerW, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface)    (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)      (THIS) PURE;
   STDMETHOD_(ULONG,Release)     (THIS) PURE;

   // ISRResSpeakerW members
   STDMETHOD (Correction)        (THIS_ PCWSTR, WORD) PURE;
   STDMETHOD (Validate)          (THIS_ WORD) PURE;
   STDMETHOD (Identify)          (THIS_ DWORD, PWSTR, DWORD, DWORD *, 
				  LONG *) PURE;
   STDMETHOD (IdentifyForFree)   (THIS_ BOOL *) PURE;
   };

typedef ISRResSpeakerW FAR *PISRRESSPEAKERW;


#undef   INTERFACE
#define  INTERFACE   ISRResSpeakerA

DEFINE_GUID(IID_ISRResSpeakerA, 0x05EB6C69L, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRResSpeakerA, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface)    (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)      (THIS) PURE;
   STDMETHOD_(ULONG,Release)     (THIS) PURE;

   // ISRResSpeakerA members
   STDMETHOD (Correction)        (THIS_ PCSTR, WORD) PURE;
   STDMETHOD (Validate)          (THIS_ WORD) PURE;
   STDMETHOD (Identify)          (THIS_ DWORD, PSTR, DWORD, DWORD *, 
				  LONG *) PURE;
   STDMETHOD (IdentifyForFree)   (THIS_ BOOL *) PURE;
   };

typedef ISRResSpeakerA FAR *PISRRESSPEAKERA;


#ifdef _S_UNICODE
 #define ISRResSpeaker           ISRResSpeakerW
 #define IID_ISRResSpeaker       IID_ISRResSpeakerW
 #define PISRRESSPEAKER          PISRRESSPEAKERW

#else
 #define ISRResSpeaker           ISRResSpeakerA
 #define IID_ISRResSpeaker       IID_ISRResSpeakerA
 #define PISRRESSPEAKER          PISRRESSPEAKERA

#endif   // _S_UNICODE



/*
 * ISRSpeaker
 */

#undef   INTERFACE
#define  INTERFACE   ISRSpeakerW

DEFINE_GUID(IID_ISRSpeakerW, 0x090CD9AE, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRSpeakerW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRSpeakerW members
   STDMETHOD (Delete)         (THIS_ PCWSTR) PURE;
   STDMETHOD (Enum)           (THIS_ PWSTR *, DWORD *) PURE;
   STDMETHOD (Merge)          (THIS_ PCWSTR, PVOID, DWORD) PURE;
   STDMETHOD (New)            (THIS_ PCWSTR) PURE;
   STDMETHOD (Query)          (THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD (Read)           (THIS_ PCWSTR, PVOID *, DWORD *) PURE;
   STDMETHOD (Revert)         (THIS_ PCWSTR) PURE;
   STDMETHOD (Select)         (THIS_ PCWSTR, BOOL) PURE;
   STDMETHOD (Write)          (THIS_ PCWSTR, PVOID, DWORD) PURE;
   };

typedef ISRSpeakerW FAR *PISRSPEAKERW;


#undef   INTERFACE
#define  INTERFACE   ISRSpeakerA

DEFINE_GUID(IID_ISRSpeakerA, 0x090CD9AF, 0xDA1A, 0x11CD, 0xB3, 0xCA, 0x0, 0xAA, 0x0, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ISRSpeakerA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ISRSpeakerA members
   STDMETHOD (Delete)         (THIS_ PCSTR) PURE;
   STDMETHOD (Enum)           (THIS_ PSTR *, DWORD *) PURE;
   STDMETHOD (Merge)          (THIS_ PCSTR, PVOID, DWORD) PURE;
   STDMETHOD (New)            (THIS_ PCSTR) PURE;
   STDMETHOD (Query)          (THIS_ PSTR, DWORD, DWORD *) PURE;
   STDMETHOD (Read)           (THIS_ PCSTR, PVOID *, DWORD *) PURE;
   STDMETHOD (Revert)         (THIS_ PCSTR) PURE;
   STDMETHOD (Select)         (THIS_ PCSTR, BOOL) PURE;
   STDMETHOD (Write)          (THIS_ PCSTR, PVOID, DWORD) PURE;
   };

typedef ISRSpeakerA FAR *PISRSPEAKERA;


#ifdef _S_UNICODE
 #define ISRSpeaker              ISRSpeakerW
 #define IID_ISRSpeaker          IID_ISRSpeakerW
 #define PISRSPEAKER             PISRSPEAKERW

#else
 #define ISRSpeaker              ISRSpeakerA
 #define IID_ISRSpeaker          IID_ISRSpeakerA
 #define PISRSPEAKER             PISRSPEAKERA

#endif   // _S_UNICODE



/************************************************************************
Low-Level text-to-speech API
*/


/************************************************************************
defines */

#define  TTSI_NAMELEN                   SVFN_LEN
#define  TTSI_STYLELEN                  SVFN_LEN

#define  GENDER_NEUTRAL                 (0)
#define  GENDER_FEMALE                  (1)
#define  GENDER_MALE                    (2)

#define  TTSFEATURE_ANYWORD             SETBIT(0)
#define  TTSFEATURE_VOLUME              SETBIT(1)
#define  TTSFEATURE_SPEED               SETBIT(2)
#define  TTSFEATURE_PITCH               SETBIT(3)
#define  TTSFEATURE_TAGGED              SETBIT(4)
#define  TTSFEATURE_IPAUNICODE          SETBIT(5)
#define  TTSFEATURE_VISUAL              SETBIT(6)
#define  TTSFEATURE_WORDPOSITION        SETBIT(7)
#define  TTSFEATURE_PCOPTIMIZED         SETBIT(8)
#define  TTSFEATURE_PHONEOPTIMIZED      SETBIT(9)

#define  TTSI_ILEXPRONOUNCE             SETBIT(0)
#define  TTSI_ITTSATTRIBUTES            SETBIT(1)
#define  TTSI_ITTSCENTRAL               SETBIT(2)
#define  TTSI_ITTSDIALOGS               SETBIT(3)

#define  TTSDATAFLAG_TAGGED             SETBIT(0)

#define   TTSBNS_ABORTED                   SETBIT(0)

// ITTSNotifySink
#define   TTSNSAC_REALTIME               0
#define   TTSNSAC_PITCH                  1
#define   TTSNSAC_SPEED                  2
#define   TTSNSAC_VOLUME                 3


#define   TTSNSHINT_QUESTION             SETBIT(0)
#define   TTSNSHINT_STATEMENT            SETBIT(1)
#define   TTSNSHINT_COMMAND              SETBIT(2)
#define   TTSNSHINT_EXCLAMATION          SETBIT(3)
#define   TTSNSHINT_EMPHASIS             SETBIT(4)


// Ages
#define  TTSAGE_BABY                   1
#define  TTSAGE_TODDLER                3
#define  TTSAGE_CHILD                  6
#define  TTSAGE_ADOLESCENT             14
#define  TTSAGE_ADULT                  30
#define  TTSAGE_ELDERLY                70

// Attribute minimums and maximums
#define  TTSATTR_MINPITCH              0
#define  TTSATTR_MAXPITCH              0xffff
#define  TTSATTR_MINREALTIME           0
#define  TTSATTR_MAXREALTIME           0xffffffff
#define  TTSATTR_MINSPEED              0
#define  TTSATTR_MAXSPEED              0xffffffff
#define  TTSATTR_MINVOLUME             0
#define  TTSATTR_MAXVOLUME             0xffffffff


/************************************************************************
typedefs */

typedef struct {
   BYTE     bMouthHeigght;
   BYTE     bMouthWidth;
   BYTE     bMouthUpturn;
   BYTE     bJawOpen;
   BYTE     bTeethUpperVisible;
   BYTE     bTeethLowerVisible;
   BYTE     bTonguePosn;
   BYTE     bLipTension;
   } TTSMOUTH, *PTTSMOUTH;



typedef struct {
   GUID       gEngineID;
   WCHAR      szMfgName[TTSI_NAMELEN];
   WCHAR      szProductName[TTSI_NAMELEN];
   GUID       gModeID;
   WCHAR      szModeName[TTSI_NAMELEN];
   LANGUAGEW  language;
   WCHAR      szSpeaker[TTSI_NAMELEN];
   WCHAR      szStyle[TTSI_STYLELEN];
   WORD       wGender;
   WORD       wAge;
   DWORD      dwFeatures;
   DWORD      dwInterfaces;
   DWORD      dwEngineFeatures;
   } TTSMODEINFOW, *PTTSMODEINFOW;

typedef struct {
   GUID       gEngineID;
   CHAR       szMfgName[TTSI_NAMELEN];
   CHAR       szProductName[TTSI_NAMELEN];
   GUID       gModeID;
   CHAR       szModeName[TTSI_NAMELEN];
   LANGUAGEA  language;
   CHAR       szSpeaker[TTSI_NAMELEN];
   CHAR       szStyle[TTSI_STYLELEN];
   WORD       wGender;
   WORD       wAge;
   DWORD      dwFeatures;
   DWORD      dwInterfaces;
   DWORD      dwEngineFeatures;
   } TTSMODEINFOA, *PTTSMODEINFOA;

#ifdef _S_UNICODE
 #define TTSMODEINFO         TTSMODEINFOW
 #define PTTSMODEINFO        PTTSMODEINFOW

#else
 #define TTSMODEINFO         TTSMODEINFOA
 #define PTTSMODEINFO        PTTSMODEINFOA

#endif   // _S_UNICODE



typedef struct {
   DWORD      dwEngineID;
   DWORD      dwMfgName;
   DWORD      dwProductName;
   DWORD      dwModeID;
   DWORD      dwModeName;
   DWORD      dwLanguage;
   DWORD      dwDialect;
   DWORD      dwSpeaker;
   DWORD      dwStyle;
   DWORD      dwGender;
   DWORD      dwAge;
   DWORD      dwFeatures;
   DWORD      dwInterfaces;
   DWORD      dwEngineFeatures;
   } TTSMODEINFORANK, * PTTSMODEINFORANK;

/************************************************************************
Class IDs */
// {D67C0280-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(CLSID_TTSEnumerator, 
0xd67c0280, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

/************************************************************************
interfaces */

// ITTSAttributes

#undef   INTERFACE
#define  INTERFACE   ITTSAttributesW

DEFINE_GUID(IID_ITTSAttributesW, 0x1287A280L, 0x4A47, 0x101B, 0x93, 0x1A, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSAttributesW, IUnknown) {

// IUnknown members

   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

// ITTSAttributes members

   STDMETHOD (PitchGet)       (THIS_ WORD *) PURE;
   STDMETHOD (PitchSet)       (THIS_ WORD) PURE;  
   STDMETHOD (RealTimeGet)    (THIS_ DWORD *) PURE;
   STDMETHOD (RealTimeSet)    (THIS_ DWORD) PURE;  
   STDMETHOD (SpeedGet)       (THIS_ DWORD *) PURE;
   STDMETHOD (SpeedSet)       (THIS_ DWORD) PURE;  
   STDMETHOD (VolumeGet)      (THIS_ DWORD *) PURE;
   STDMETHOD (VolumeSet)      (THIS_ DWORD) PURE;  
   };

typedef ITTSAttributesW FAR * PITTSATTRIBUTESW;


#undef   INTERFACE
#define  INTERFACE   ITTSAttributesA

DEFINE_GUID(IID_ITTSAttributesA,
0x0FD6E2A1L, 0xE77D, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSAttributesA, IUnknown) {

// IUnknown members

   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

// ITTSAttributes members

   STDMETHOD (PitchGet)       (THIS_ WORD *) PURE;
   STDMETHOD (PitchSet)       (THIS_ WORD) PURE;  
   STDMETHOD (RealTimeGet)    (THIS_ DWORD *) PURE;
   STDMETHOD (RealTimeSet)    (THIS_ DWORD) PURE;  
   STDMETHOD (SpeedGet)       (THIS_ DWORD *) PURE;
   STDMETHOD (SpeedSet)       (THIS_ DWORD) PURE;  
   STDMETHOD (VolumeGet)      (THIS_ DWORD *) PURE;
   STDMETHOD (VolumeSet)      (THIS_ DWORD) PURE;  
   };

typedef ITTSAttributesA FAR * PITTSATTRIBUTESA;


#ifdef _S_UNICODE
 #define ITTSAttributes          ITTSAttributesW
 #define IID_ITTSAttributes      IID_ITTSAttributesW
 #define PITTSATTRIBUTES         PITTSATTRIBUTESW

#else
 #define ITTSAttributes          ITTSAttributesA
 #define IID_ITTSAttributes      IID_ITTSAttributesA
 #define PITTSATTRIBUTES         PITTSATTRIBUTESA

#endif   // _S_UNICODE



// ITTSBufNotifySink

#undef   INTERFACE
#define  INTERFACE   ITTSBufNotifySink

// {E4963D40-C743-11cd-80E5-00AA003E4B50}
DEFINE_GUID(IID_ITTSBufNotifySink, 
0xe4963d40, 0xc743, 0x11cd, 0x80, 0xe5, 0x0, 0xaa, 0x0, 0x3e, 0x4b, 0x50);

DECLARE_INTERFACE_ (ITTSBufNotifySink, IUnknown) {

// IUnknown members

   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

// ITTSBufNotifySink members

   STDMETHOD (TextDataDone)   (THIS_ QWORD, DWORD) PURE;
   STDMETHOD (TextDataStarted)(THIS_ QWORD) PURE;
   STDMETHOD (BookMark)       (THIS_ QWORD, DWORD) PURE;  
   STDMETHOD (WordPosition)   (THIS_ QWORD, DWORD) PURE;
   };

typedef ITTSBufNotifySink FAR * PITTSBUFNOTIFYSINK;

// In case anyone uses the W or A interface
#define ITTSBufNotifySinkW          ITTSBufNotifySink
#define IID_ITTSBufNotifySinkW      IID_ITTSBufNotifySink
#define PITTSBUFNOTIFYSINKW         PITTSBUFNOTIFYSINK
#define ITTSBufNotifySinkA          ITTSBufNotifySink
#define IID_ITTSBufNotifySinkA      IID_ITTSBufNotifySink
#define PITTSBUFNOTIFYSINKA         PITTSBUFNOTIFYSINK



/*
 * ITTSCentral
 */

#undef   INTERFACE
#define  INTERFACE   ITTSCentralW

DEFINE_GUID(IID_ITTSCentralW, 0x28016060L, 0x4A47, 0x101B, 0x93, 0x1A, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSCentralW, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ITTSCentralW members
   STDMETHOD (Inject)         (THIS_ PCWSTR) PURE;
   STDMETHOD (ModeGet)        (THIS_ PTTSMODEINFOW) PURE;
   STDMETHOD (Phoneme)        (THIS_ VOICECHARSET, DWORD, SDATA, PSDATA) PURE;
   STDMETHOD (PosnGet)        (THIS_ PQWORD) PURE;
   STDMETHOD (TextData)       (THIS_ VOICECHARSET, DWORD, SDATA, PVOID, IID) PURE;
   STDMETHOD (ToFileTime)     (THIS_ PQWORD, FILETIME *) PURE;
   STDMETHOD (AudioPause)     (THIS) PURE;
   STDMETHOD (AudioResume)    (THIS) PURE;
   STDMETHOD (AudioReset)     (THIS) PURE;
   STDMETHOD (Register)       (THIS_ PVOID, IID, DWORD*) PURE;
   STDMETHOD (UnRegister)     (THIS_ DWORD) PURE;
   };

typedef ITTSCentralW FAR * PITTSCENTRALW;


#undef   INTERFACE
#define  INTERFACE   ITTSCentralA

DEFINE_GUID(IID_ITTSCentralA, 0x05EB6C6AL, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSCentralA, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ITTSCentralA members
   STDMETHOD (Inject)         (THIS_ PCSTR) PURE;
   STDMETHOD (ModeGet)        (THIS_ PTTSMODEINFOA) PURE;
   STDMETHOD (Phoneme)        (THIS_ VOICECHARSET, DWORD, SDATA, PSDATA) PURE;
   STDMETHOD (PosnGet)        (THIS_ PQWORD) PURE;
   STDMETHOD (TextData)       (THIS_ VOICECHARSET, DWORD, SDATA, PVOID, IID) PURE;
   STDMETHOD (ToFileTime)     (THIS_ PQWORD, FILETIME *) PURE;
   STDMETHOD (AudioPause)     (THIS) PURE;
   STDMETHOD (AudioResume)    (THIS) PURE;
   STDMETHOD (AudioReset)     (THIS) PURE;
   STDMETHOD (Register)       (THIS_ PVOID, IID, DWORD*) PURE;
   STDMETHOD (UnRegister)     (THIS_ DWORD) PURE;
   };

typedef ITTSCentralA FAR * PITTSCENTRALA;


#ifdef _S_UNICODE
 #define ITTSCentral             ITTSCentralW
 #define IID_ITTSCentral         IID_ITTSCentralW
 #define PITTSCENTRAL            PITTSCENTRALW

#else
 #define ITTSCentral             ITTSCentralA
 #define IID_ITTSCentral         IID_ITTSCentralA
 #define PITTSCENTRAL            PITTSCENTRALA

#endif   // _S_UNICODE



/*
 * ITTSDialogsW
 */

#undef   INTERFACE
#define  INTERFACE   ITTSDialogsW

DEFINE_GUID(IID_ITTSDialogsW, 0x47F59D00L, 0x4A47, 0x101B, 0x93, 0x1A, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSDialogsW, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ITTSDialogsW members
   STDMETHOD (AboutDlg)       (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (LexiconDlg)     (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (GeneralDlg)     (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (TranslateDlg)   (THIS_ HWND, PCWSTR) PURE;
   };

typedef ITTSDialogsW FAR * PITTSDIALOGSW;


#undef   INTERFACE
#define  INTERFACE   ITTSDialogsA

DEFINE_GUID(IID_ITTSDialogsA, 0x05EB6C6BL, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSDialogsA, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ITTSDialogsA members
   STDMETHOD (AboutDlg)       (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (LexiconDlg)     (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (GeneralDlg)     (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (TranslateDlg)   (THIS_ HWND, PCSTR) PURE;
   };

typedef ITTSDialogsA FAR * PITTSDIALOGSA;


#ifdef _S_UNICODE
 #define ITTSDialogs          ITTSDialogsW
 #define IID_ITTSDialogs      IID_ITTSDialogsW
 #define PITTSDIALOGS         PITTSDIALOGSW

#else
 #define ITTSDialogs          ITTSDialogsA
 #define IID_ITTSDialogs      IID_ITTSDialogsA
 #define PITTSDIALOGS         PITTSDIALOGSA

#endif



/*
 * ITTSEnum
 */

#undef   INTERFACE
#define  INTERFACE   ITTSEnumW

DEFINE_GUID(IID_ITTSEnumW, 0x6B837B20L, 0x4A47, 0x101B, 0x93, 0x1A, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSEnumW, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ITTSEnumW members
   STDMETHOD (Next)           (THIS_ ULONG, PTTSMODEINFOW, ULONG *) PURE;
   STDMETHOD (Skip)           (THIS_ ULONG) PURE;
   STDMETHOD (Reset)          (THIS) PURE;
   STDMETHOD (Clone)          (THIS_ ITTSEnumW * FAR *) PURE;
   STDMETHOD (Select)         (THIS_ GUID, PITTSCENTRALW *, LPUNKNOWN) PURE;
   };

typedef ITTSEnumW FAR * PITTSENUMW;


#undef   INTERFACE
#define  INTERFACE   ITTSEnumA

DEFINE_GUID(IID_ITTSEnumA, 0x05EB6C6DL, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSEnumA, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ITTSEnumA members
   STDMETHOD (Next)           (THIS_ ULONG, PTTSMODEINFOA, ULONG *) PURE;
   STDMETHOD (Skip)           (THIS_ ULONG) PURE;
   STDMETHOD (Reset)          (THIS) PURE;
   STDMETHOD (Clone)          (THIS_ ITTSEnumA * FAR *) PURE;
   STDMETHOD (Select)         (THIS_ GUID, PITTSCENTRALA *, LPUNKNOWN) PURE;
   };

typedef ITTSEnumA FAR * PITTSENUMA;


#ifdef _S_UNICODE
 #define ITTSEnum             ITTSEnumW
 #define IID_ITTSEnum         IID_ITTSEnumW
 #define PITTSENUM            PITTSENUMW

#else
 #define ITTSEnum             ITTSEnumA
 #define IID_ITTSEnum         IID_ITTSEnumA
 #define PITTSENUM            PITTSENUMA

#endif



/*
 * ITTSFind
 */

#undef   INTERFACE
#define  INTERFACE   ITTSFindW

DEFINE_GUID(IID_ITTSFindW, 0x7AA42960L, 0x4A47, 0x101B, 0x93, 0x1A, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSFindW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ITTSFindW members
   STDMETHOD (Find)           (THIS_ PTTSMODEINFOW, PTTSMODEINFORANK, PTTSMODEINFOW) PURE;
   STDMETHOD (Select)         (THIS_ GUID, PITTSCENTRALW *, LPUNKNOWN) PURE;
   };

typedef ITTSFindW FAR * PITTSFINDW;


#undef   INTERFACE
#define  INTERFACE   ITTSFindA

DEFINE_GUID(IID_ITTSFindA, 0x05EB6C6EL, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSFindA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ITTSFindA members
   STDMETHOD (Find)           (THIS_ PTTSMODEINFOA, PTTSMODEINFORANK, PTTSMODEINFOA) PURE;
   STDMETHOD (Select)         (THIS_ GUID, PITTSCENTRALA *, LPUNKNOWN) PURE;
   };

typedef ITTSFindA FAR * PITTSFINDA;


#ifdef _S_UNICODE
 #define ITTSFind             ITTSFindW
 #define IID_ITTSFind         IID_ITTSFindW
 #define PITTSFIND            PITTSFINDW

#else
 #define ITTSFind             ITTSFindA
 #define IID_ITTSFind         IID_ITTSFindA
 #define PITTSFIND            PITTSFINDA

#endif



/*
 * ITTSNotifySink
 */

#undef   INTERFACE
#define  INTERFACE   ITTSNotifySinkW

DEFINE_GUID(IID_ITTSNotifySinkW, 0xC0FA8F40L, 0x4A46, 0x101B, 0x93, 0x1A, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSNotifySinkW, IUnknown) {

// IUnknown members

   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

// ITTSNotifySinkW members

   STDMETHOD (AttribChanged)  (THIS_ DWORD) PURE;
   STDMETHOD (AudioStart)     (THIS_ QWORD) PURE;
   STDMETHOD (AudioStop)      (THIS_ QWORD) PURE;
   STDMETHOD (Visual)         (THIS_ QWORD, WCHAR, WCHAR, DWORD, PTTSMOUTH) PURE;
   };

typedef ITTSNotifySinkW FAR * PITTSNOTIFYSINKW;


#undef   INTERFACE
#define  INTERFACE   ITTSNotifySinkA

DEFINE_GUID(IID_ITTSNotifySinkA, 0x05EB6C6FL, 0xDBAB, 0x11CD, 0xB3, 0xCA, 0x00, 0xAA, 0x00, 0x47, 0xBA, 0x4F);

DECLARE_INTERFACE_ (ITTSNotifySinkA, IUnknown) {

   // IUnknown members
   STDMETHOD (QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // ITTSNotifySinkA members
   STDMETHOD (AttribChanged)  (THIS_ DWORD) PURE;
   STDMETHOD (AudioStart)     (THIS_ QWORD) PURE;
   STDMETHOD (AudioStop)      (THIS_ QWORD) PURE;
   STDMETHOD (Visual)         (THIS_ QWORD, CHAR, CHAR, DWORD, PTTSMOUTH) PURE;
   };

typedef ITTSNotifySinkA FAR * PITTSNOTIFYSINKA;


#ifdef _S_UNICODE
 #define ITTSNotifySink       ITTSNotifySinkW
 #define IID_ITTSNotifySink   IID_ITTSNotifySinkW
 #define PITTSNOTIFYSINK      PITTSNOTIFYSINKW

#else
 #define ITTSNotifySink       ITTSNotifySinkA
 #define IID_ITTSNotifySink   IID_ITTSNotifySinkA
 #define PITTSNOTIFYSINK      PITTSNOTIFYSINKA

#endif



/************************************************************************
High-Level command and control speech recognition API
*/

/************************************************************************
defines */


// VCMDNAME member lengths
#define VCMD_APPLEN             ((DWORD)32)
#define VCMD_STATELEN           VCMD_APPLEN
#define VCMD_MICLEN             VCMD_APPLEN
#define VCMD_SPEAKERLEN         VCMD_APPLEN

// dwFlags parameter of IVoiceCmd::MenuCreate
#define  VCMDMC_CREATE_TEMP     0x00000001
#define  VCMDMC_CREATE_NEW      0x00000002
#define  VCMDMC_CREATE_ALWAYS   0x00000004
#define  VCMDMC_OPEN_ALWAYS     0x00000008
#define  VCMDMC_OPEN_EXISTING   0x00000010

// dwFlags parameter of IVoiceCmd::Register
#define  VCMDRF_NOMESSAGES      0
#define  VCMDRF_ALLBUTVUMETER   0x00000001
#define  VCMDRF_VUMETER         0x00000002
#define  VCMDRF_ALLMESSAGES     (VCMDRF_ALLBUTVUMETER | VCMDRF_VUMETER)

// dwFlags parameter of IVoiceCmd::MenuEnum
#define  VCMDEF_DATABASE        0x00000000
#define  VCMDEF_ACTIVE          0x00000001
#define  VCMDEF_SELECTED        0x00000002
#define  VCMDEF_PERMANENT       0x00000004
#define  VCMDEF_TEMPORARY       0x00000008

// dwFlags parameter of IVCmdMenu::Activate
#define  VWGFLAG_ASLEEP         0x00000001

// wPriority parameter of IVCmdMenu::Activate
#define  VCMDACT_NORMAL         (0x8000)
#define  VCMDACT_LOW            (0x4000)
#define  VCMDACT_HIGH           (0xC000)

// dwFlags of the VCMDCOMMAND structure
#define  VCMDCMD_VERIFY         0x00000001
#define  VCMDCMD_DISABLED_TEMP  0x00000002
#define  VCMDCMD_DISABLED_PERM  0x00000004

// parameter to any function that processes individual commands
#define  VCMD_BY_POSITION       0x00000001
#define  VCMD_BY_IDENTIFIER     0x00000002


// values for dwAttributes field of IVCmdNotifySink::AttribChanged
#define  IVCNSAC_AUTOGAINENABLE 0x00000001
#define  IVCNSAC_ENABLED        0x00000002
#define  IVCNSAC_AWAKE          0x00000004
#define  IVCNSAC_DEVICE         0x00000008
#define  IVCNSAC_MICROPHONE     0x00000010
#define  IVCNSAC_SPEAKER        0x00000020
#define  IVCNSAC_SRMODE         0x00000040
#define  IVCNSAC_THRESHOLD      0x00000080
#define  IVCNSAC_ORIGINAPP      0x00010000

// values for dwAttributes field of IVTxtNotifySink::AttribChanged
#define  IVTNSAC_DEVICE         0x00000001
#define  IVTNSAC_ENABLED        0x00000002
#define  IVTNSAC_SPEED          0x00000004
#define  IVTNSAC_VOLUME         0x00000008
#define  IVTNSAC_TTSMODE        0x00000010


// values used by IVXxxAttributes::SetMode to set the global speech
// recognition mode
#define  VSRMODE_DISABLED       0x00000001
#define  VSRMODE_OFF            0x00000002
#define  VSRMODE_CMDPAUSED      0x00000004
#define  VSRMODE_CMDNOTPAUSED   0x00000008
#define  VSRMODE_CMDONLY        0x00000010
#define  VSRMODE_DCTONLY        0x00000020
#define  VSRMODE_CMDANDDCT      0x00000040


/************************************************************************
typedefs */

// voice command structure - passed to command menu functions (IVCmdMenu)
typedef struct {
    DWORD   dwSize;         // size of struct including amount of abAction
    DWORD   dwFlags;
    DWORD   dwID;           // Command ID
    DWORD   dwCommand;      // DWORD aligned offset of command string
    DWORD   dwDescription;  // DWORD aligned offset of description string
    DWORD   dwCategory;     // DWORD aligned offset of category string
    DWORD   dwCommandText;  // DWORD aligned offset of command text string
    DWORD   dwAction;       // DWORD aligned offset of action data
    DWORD   dwActionSize;   // size of the action data (could be string or binary)
    BYTE    abData[1];      // command, description, category, and action data
			    // (action data is NOT interpreted by voice command)
} VCMDCOMMAND, * PVCMDCOMMAND;



// site information structure - possible parameter to IVoiceCmd::Register
typedef struct {
    DWORD   dwAutoGainEnable;
    DWORD   dwAwakeState;
    DWORD   dwThreshold;
    DWORD   dwDevice;
    DWORD   dwEnable;
    WCHAR   szMicrophone[VCMD_MICLEN];
    WCHAR   szSpeaker[VCMD_SPEAKERLEN];
    GUID    gModeID;
} VCSITEINFOW, *PVCSITEINFOW;

typedef struct {
    DWORD   dwAutoGainEnable;
    DWORD   dwAwakeState;
    DWORD   dwThreshold;
    DWORD   dwDevice;
    DWORD   dwEnable;
    CHAR    szMicrophone[VCMD_MICLEN];
    CHAR    szSpeaker[VCMD_SPEAKERLEN];
    GUID    gModeID;
} VCSITEINFOA, *PVCSITEINFOA;



// menu name structure
typedef struct {
    WCHAR   szApplication[VCMD_APPLEN]; // unique application name
    WCHAR   szState[VCMD_STATELEN];     // unique application state
} VCMDNAMEW, *PVCMDNAMEW;

typedef struct {
    CHAR    szApplication[VCMD_APPLEN]; // unique application name
    CHAR    szState[VCMD_STATELEN];     // unique application state
} VCMDNAMEA, *PVCMDNAMEA;



#ifdef  _S_UNICODE
 #define VCSITEINFO  VCSITEINFOW
 #define PVCSITEINFO PVCSITEINFOW
 #define VCMDNAME    VCMDNAMEW
 #define PVCMDNAME   PVCMDNAMEW
#else
 #define VCSITEINFO  VCSITEINFOA
 #define PVCSITEINFO PVCSITEINFOA
 #define VCMDNAME    VCMDNAMEA
 #define PVCMDNAME   PVCMDNAMEA
#endif  // _S_UNICODE

/************************************************************************
interfaces */

/*
 *  IVCmdNotifySink
 */
#undef   INTERFACE
#define  INTERFACE   IVCmdNotifySinkW

DEFINE_GUID(IID_IVCmdNotifySinkW, 0xCCFD7A60L, 0x604D, 0x101B, 0x99, 0x26, 0x00, 0xAA, 0x00, 0x3C, 0xFC, 0x2C);

DECLARE_INTERFACE_ (IVCmdNotifySinkW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVCmdNotifySink members

   STDMETHOD (CommandRecognize) (THIS_ DWORD, PVCMDNAMEW, DWORD, DWORD, PVOID, 
				 DWORD, PWSTR, PWSTR) PURE;
   STDMETHOD (CommandOther)     (THIS_ PVCMDNAMEW, PWSTR) PURE;
   STDMETHOD (CommandStart)     (THIS) PURE;
   STDMETHOD (MenuActivate)     (THIS_ PVCMDNAMEW, BOOL) PURE;
   STDMETHOD (UtteranceBegin)   (THIS) PURE;
   STDMETHOD (UtteranceEnd)     (THIS) PURE;
   STDMETHOD (VUMeter)          (THIS_ WORD) PURE;
   STDMETHOD (AttribChanged)    (THIS_ DWORD) PURE;
   STDMETHOD (Interference)     (THIS_ DWORD) PURE;
};

typedef IVCmdNotifySinkW FAR * PIVCMDNOTIFYSINKW;


#undef   INTERFACE
#define  INTERFACE   IVCmdNotifySinkA

// {80B25CC0-5540-11b9-C000-5611722E1D15}
DEFINE_GUID(IID_IVCmdNotifySinkA, 0x80b25cc0, 0x5540, 0x11b9, 0xc0, 0x0, 0x56, 0x11, 0x72, 0x2e, 0x1d, 0x15);

DECLARE_INTERFACE_ (IVCmdNotifySinkA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVCmdNotifySinkA members

   STDMETHOD (CommandRecognize) (THIS_ DWORD, PVCMDNAMEA, DWORD, DWORD, PVOID, 
				 DWORD, PSTR, PSTR) PURE;
   STDMETHOD (CommandOther)     (THIS_ PVCMDNAMEA, PSTR) PURE;
   STDMETHOD (CommandStart)     (THIS) PURE;
   STDMETHOD (MenuActivate)     (THIS_ PVCMDNAMEA, BOOL) PURE;
   STDMETHOD (UtteranceBegin)   (THIS) PURE;
   STDMETHOD (UtteranceEnd)     (THIS) PURE;
   STDMETHOD (VUMeter)          (THIS_ WORD) PURE;
   STDMETHOD (AttribChanged)    (THIS_ DWORD) PURE;
   STDMETHOD (Interference)     (THIS_ DWORD) PURE;
};

typedef IVCmdNotifySinkA FAR * PIVCMDNOTIFYSINKA;


#ifdef _S_UNICODE
 #define IVCmdNotifySink        IVCmdNotifySinkW
 #define IID_IVCmdNotifySink    IID_IVCmdNotifySinkW
 #define PIVCMDNOTIFYSINK       PIVCMDNOTIFYSINKW

#else
 #define IVCmdNotifySink        IVCmdNotifySinkA
 #define IID_IVCmdNotifySink    IID_IVCmdNotifySinkA
 #define PIVCMDNOTIFYSINK       PIVCMDNOTIFYSINKA

#endif // _S_UNICODE


/*
 *  IVCmdNotifySinkEx
 */
#undef   INTERFACE
#define  INTERFACE   IVCmdNotifySinkExW

// {2F440FB4-CE01-11cf-B234-00AA00A215ED}
DEFINE_GUID(IID_IVCmdNotifySinkExW, 
0x2f440fb4, 0xce01, 0x11cf, 0xb2, 0x34, 0x0, 0xaa, 0x0, 0xa2, 0x15, 0xed);

DECLARE_INTERFACE_ (IVCmdNotifySinkExW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVCmdNotifySinkExW members

   STDMETHOD (CommandRecognizeEx)
				(THIS_ DWORD, PVCMDNAMEW, DWORD, DWORD, PVOID, 
				 DWORD, PWSTR, PWSTR, LPUNKNOWN) PURE;
   STDMETHOD (CommandOther)     (THIS_ PVCMDNAMEW, PWSTR) PURE;
   STDMETHOD (CommandStart)     (THIS) PURE;
   STDMETHOD (MenuActivate)     (THIS_ PVCMDNAMEW, BOOL) PURE;
   STDMETHOD (UtteranceBegin)   (THIS) PURE;
   STDMETHOD (UtteranceEnd)     (THIS) PURE;
   STDMETHOD (VUMeter)          (THIS_ WORD) PURE;
   STDMETHOD (AttribChanged)    (THIS_ DWORD) PURE;
   STDMETHOD (Interference)     (THIS_ DWORD) PURE;
};

typedef IVCmdNotifySinkExW FAR * PIVCMDNOTIFYSINKEXW;


#undef   INTERFACE
#define  INTERFACE   IVCmdNotifySinkExA

// {2F440FB8-CE01-11cf-B234-00AA00A215ED}
DEFINE_GUID(IID_IVCmdNotifySinkExA, 
0x2f440fb8, 0xce01, 0x11cf, 0xb2, 0x34, 0x0, 0xaa, 0x0, 0xa2, 0x15, 0xed);

DECLARE_INTERFACE_ (IVCmdNotifySinkExA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVCmdNotifySinkExA members

   STDMETHOD (CommandRecognizeEx)
				(THIS_ DWORD, PVCMDNAMEA, DWORD, DWORD, PVOID, 
				 DWORD, PSTR, PSTR, LPUNKNOWN) PURE;
   STDMETHOD (CommandOther)     (THIS_ PVCMDNAMEA, PSTR) PURE;
   STDMETHOD (CommandStart)     (THIS) PURE;
   STDMETHOD (MenuActivate)     (THIS_ PVCMDNAMEA, BOOL) PURE;
   STDMETHOD (UtteranceBegin)   (THIS) PURE;
   STDMETHOD (UtteranceEnd)     (THIS) PURE;
   STDMETHOD (VUMeter)          (THIS_ WORD) PURE;
   STDMETHOD (AttribChanged)    (THIS_ DWORD) PURE;
   STDMETHOD (Interference)     (THIS_ DWORD) PURE;
};

typedef IVCmdNotifySinkExA FAR * PIVCMDNOTIFYSINKEXA;


#ifdef _S_UNICODE
 #define IVCmdNotifySinkEx        IVCmdNotifySinkExW
 #define IID_IVCmdNotifySinkEx    IID_IVCmdNotifySinkExW
 #define PIVCMDNOTIFYSINKEX       PIVCMDNOTIFYSINKEXW

#else
 #define IVCmdNotifySinkEx        IVCmdNotifySinkExA
 #define IID_IVCmdNotifySinkEx    IID_IVCmdNotifySinkExA
 #define PIVCMDNOTIFYSINKEX       PIVCMDNOTIFYSINKEXA

#endif // _S_UNICODE


/*
 *  IVCmdEnum
 */
#undef   INTERFACE
#define  INTERFACE   IVCmdEnumW

DEFINE_GUID(IID_IVCmdEnumW, 0xD3CC0820L, 0x604D, 0x101B, 0x99, 0x26, 0x00, 0xAA, 0x00, 0x3C, 0xFC, 0x2C);

DECLARE_INTERFACE_ (IVCmdEnumW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVCmdEnum members
   STDMETHOD (Next)           (THIS_ ULONG, PVCMDNAMEW, ULONG *) PURE;
   STDMETHOD (Skip)           (THIS_ ULONG) PURE;
   STDMETHOD (Reset)          (THIS) PURE;
   STDMETHOD (Clone)          (THIS_ IVCmdEnumW * FAR *) PURE;
};
typedef IVCmdEnumW FAR * PIVCMDENUMW;


#undef   INTERFACE
#define  INTERFACE   IVCmdEnumA

// {E86F9540-DCA2-11CD-A166-00AA004CD65C}
DEFINE_GUID(IID_IVCmdEnumA, 
0xE86F9540, 0xDCA2, 0x11CD, 0xA1, 0x66, 0x0, 0xAA, 0x0, 0x4C, 0xD6, 0x5C);

DECLARE_INTERFACE_ (IVCmdEnumA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVCmdEnum members
   STDMETHOD (Next)           (THIS_ ULONG, PVCMDNAMEA, ULONG *) PURE;
   STDMETHOD (Skip)           (THIS_ ULONG) PURE;
   STDMETHOD (Reset)          (THIS) PURE;
   STDMETHOD (Clone)          (THIS_ IVCmdEnumA * FAR *) PURE;
};
typedef IVCmdEnumA FAR * PIVCMDENUMA;


#ifdef _S_UNICODE
 #define IVCmdEnum              IVCmdEnumW
 #define IID_IVCmdEnum          IID_IVCmdEnumW
 #define PIVCMDENUM             PIVCMDENUMW

#else
 #define IVCmdEnum              IVCmdEnumA
 #define IID_IVCmdEnum          IID_IVCmdEnumA
 #define PIVCMDENUM             PIVCMDENUMA

#endif // _S_UNICODE


 
 
/*
 *  IEnumSRShare
 */
#undef   INTERFACE
#define  INTERFACE   IEnumSRShareW

// {E97F05C0-81B3-11ce-B763-00AA004CD65C}
DEFINE_GUID(IID_IEnumSRShareW,
0xe97f05c0, 0x81b3, 0x11ce, 0xb7, 0x63, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);

DECLARE_INTERFACE_ (IEnumSRShareW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IEnumSRShare members
   STDMETHOD (Next)           (THIS_ ULONG, PSRSHAREW, ULONG *) PURE;
   STDMETHOD (Skip)           (THIS_ ULONG) PURE;
   STDMETHOD (Reset)          (THIS) PURE;
   STDMETHOD (Clone)          (THIS_ IEnumSRShareW * FAR *) PURE;
   STDMETHOD (New)            (THIS_ DWORD, GUID, PISRCENTRALW *, QWORD *) PURE;
   STDMETHOD (Share)          (THIS_ QWORD, PISRCENTRALW *) PURE;
   STDMETHOD (Detach)         (THIS_ QWORD) PURE;
};
typedef IEnumSRShareW FAR * PIENUMSRSHAREW;


#undef   INTERFACE
#define  INTERFACE   IEnumSRShareA

// {E97F05C1-81B3-11ce-B763-00AA004CD65C}
DEFINE_GUID(IID_IEnumSRShareA,
0xe97f05c1, 0x81b3, 0x11ce, 0xb7, 0x63, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);

DECLARE_INTERFACE_ (IEnumSRShareA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IEnumSRShare members
   STDMETHOD (Next)           (THIS_ ULONG, PSRSHAREA, ULONG *) PURE;
   STDMETHOD (Skip)           (THIS_ ULONG) PURE;
   STDMETHOD (Reset)          (THIS) PURE;
   STDMETHOD (Clone)          (THIS_ IEnumSRShareA * FAR *) PURE;
   STDMETHOD (New)            (THIS_ DWORD, GUID, PISRCENTRALA *, QWORD *) PURE;
   STDMETHOD (Share)          (THIS_ QWORD, PISRCENTRALA *) PURE;
   STDMETHOD (Detach)         (THIS_ QWORD) PURE;
};
typedef IEnumSRShareA FAR * PIENUMSRSHAREA;


#ifdef _S_UNICODE
 #define IEnumSRShare              IEnumSRShareW
 #define IID_IEnumSRShare          IID_IEnumSRShareW
 #define PIENUMSRSHARE             PIENUMSRSHAREW

#else
 #define IEnumSRShare              IEnumSRShareA
 #define IID_IEnumSRShare          IID_IEnumSRShareA
 #define PIENUMSRSHARE             PIENUMSRSHAREA

#endif // _S_UNICODE


 
 
/*
 *  IVCmdMenu
 */
#undef   INTERFACE
#define  INTERFACE   IVCmdMenuW

DEFINE_GUID(IID_IVCmdMenuW, 0xDAC54F60L, 0x604D, 0x101B, 0x99, 0x26, 0x00, 0xAA, 0x00, 0x3C, 0xFC, 0x2C);

DECLARE_INTERFACE_ (IVCmdMenuW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVCmdMenu members
   STDMETHOD (Activate)       (THIS_ HWND, DWORD) PURE;
   STDMETHOD (Deactivate)     (THIS) PURE;
   STDMETHOD (TrainMenuDlg)   (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (Num)            (THIS_ DWORD *) PURE;
   STDMETHOD (Get)            (THIS_ DWORD, DWORD, DWORD, PSDATA, DWORD *) PURE;
   STDMETHOD (Set)            (THIS_ DWORD, DWORD, DWORD, SDATA) PURE;
   STDMETHOD (Add)            (THIS_ DWORD, SDATA, DWORD *) PURE;
   STDMETHOD (Remove)         (THIS_ DWORD, DWORD, DWORD) PURE;
   STDMETHOD (ListGet)        (THIS_ PCWSTR, PSDATA, DWORD *) PURE;
   STDMETHOD (ListSet)        (THIS_ PCWSTR, DWORD, SDATA) PURE;
   STDMETHOD (EnableItem)     (THIS_ DWORD, DWORD, DWORD) PURE;
   STDMETHOD (SetItem)        (THIS_ DWORD, DWORD, DWORD) PURE;
};

typedef IVCmdMenuW FAR * PIVCMDMENUW;


#undef   INTERFACE
#define  INTERFACE   IVCmdMenuA

// {746141E0-5543-11b9-C000-5611722E1D15}
DEFINE_GUID(IID_IVCmdMenuA, 0x746141e0, 0x5543, 0x11b9, 0xc0, 0x0, 0x56, 0x11, 0x72, 0x2e, 0x1d, 0x15);

DECLARE_INTERFACE_ (IVCmdMenuA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVCmdMenu members
   STDMETHOD (Activate)       (THIS_ HWND, DWORD) PURE;
   STDMETHOD (Deactivate)     (THIS) PURE;
   STDMETHOD (TrainMenuDlg)   (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (Num)            (THIS_ DWORD *) PURE;
   STDMETHOD (Get)            (THIS_ DWORD, DWORD, DWORD, PSDATA, DWORD *) PURE;
   STDMETHOD (Set)            (THIS_ DWORD, DWORD, DWORD, SDATA) PURE;
   STDMETHOD (Add)            (THIS_ DWORD, SDATA, DWORD *) PURE;
   STDMETHOD (Remove)         (THIS_ DWORD, DWORD, DWORD) PURE;
   STDMETHOD (ListGet)        (THIS_ PCSTR, PSDATA, DWORD *) PURE;
   STDMETHOD (ListSet)        (THIS_ PCSTR, DWORD, SDATA) PURE;
   STDMETHOD (EnableItem)     (THIS_ DWORD, DWORD, DWORD) PURE;
   STDMETHOD (SetItem)        (THIS_ DWORD, DWORD, DWORD) PURE;
};

typedef IVCmdMenuA FAR * PIVCMDMENUA;


#ifdef _S_UNICODE
 #define IVCmdMenu      IVCmdMenuW
 #define IID_IVCmdMenu  IID_IVCmdMenuW
 #define PIVCMDMENU     PIVCMDMENUW

#else
 #define IVCmdMenu      IVCmdMenuA
 #define IID_IVCmdMenu  IID_IVCmdMenuA
 #define PIVCMDMENU     PIVCMDMENUA

#endif // _S_UNICODE



/*
 *  IVoiceCmd
 */
#undef   INTERFACE
#define  INTERFACE   IVoiceCmdW

DEFINE_GUID(IID_IVoiceCmdW, 0xE0DCC220L, 0x604D, 0x101B, 0x99, 0x26, 0x00, 0xAA, 0x00, 0x3C, 0xFC, 0x2C);

DECLARE_INTERFACE_ (IVoiceCmdW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVoiceCmd members
   STDMETHOD (Register)       (THIS_ PCWSTR, LPUNKNOWN, GUID, DWORD,
				     PVCSITEINFOW) PURE;
   STDMETHOD (MenuEnum)       (THIS_ DWORD, PCWSTR, PCWSTR, PIVCMDENUMW *) PURE;
   STDMETHOD (MenuCreate)     (THIS_ PVCMDNAMEW, PLANGUAGEW, DWORD,
				     PIVCMDMENUW *) PURE;
   STDMETHOD (MenuDelete)     (THIS_ PVCMDNAMEW) PURE;
   STDMETHOD (CmdMimic)       (THIS_ PVCMDNAMEW, PCWSTR) PURE;
};

typedef IVoiceCmdW FAR * PIVOICECMDW;


#undef   INTERFACE
#define  INTERFACE   IVoiceCmdA

// {C63A2B30-5543-11b9-C000-5611722E1D15}
DEFINE_GUID(IID_IVoiceCmdA, 0xc63a2b30, 0x5543, 0x11b9, 0xc0, 0x0, 0x56, 0x11, 0x72, 0x2e, 0x1d, 0x15);

DECLARE_INTERFACE_ (IVoiceCmdA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVoiceCmd members
   STDMETHOD (Register)       (THIS_ PCSTR, LPUNKNOWN, GUID, DWORD,
				     PVCSITEINFOA) PURE;
   STDMETHOD (MenuEnum)       (THIS_ DWORD, PCSTR, PCSTR, PIVCMDENUMA *) PURE;
   STDMETHOD (MenuCreate)     (THIS_ PVCMDNAMEA, PLANGUAGEA, DWORD,
				     PIVCMDMENUA *) PURE;
   STDMETHOD (MenuDelete)     (THIS_ PVCMDNAMEA) PURE;
   STDMETHOD (CmdMimic)       (THIS_ PVCMDNAMEA, PCSTR) PURE;
};

typedef IVoiceCmdA FAR * PIVOICECMDA;


#ifdef _S_UNICODE
 #define IVoiceCmd      IVoiceCmdW
 #define IID_IVoiceCmd  IID_IVoiceCmdW
 #define PIVOICECMD     PIVOICECMDW

#else
 #define IVoiceCmd      IVoiceCmdA
 #define IID_IVoiceCmd  IID_IVoiceCmdA
 #define PIVOICECMD     PIVOICECMDA

#endif //_S_UNICODE


/*
 *  IVCmdAttributes
 */
#undef   INTERFACE
#define  INTERFACE   IVCmdAttributesW

DEFINE_GUID(IID_IVCmdAttributesW, 0xE5F24680L, 0x6053, 0x101B, 0x99, 0x26, 0x00, 0xAA, 0x00, 0x3C, 0xFC, 0x2C);

DECLARE_INTERFACE_ (IVCmdAttributesW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVCmdAttributes members
   STDMETHOD (AutoGainEnableGet) (THIS_ DWORD *) PURE;
   STDMETHOD (AutoGainEnableSet) (THIS_ DWORD) PURE;
   STDMETHOD (AwakeStateGet)     (THIS_ DWORD *) PURE;
   STDMETHOD (AwakeStateSet)     (THIS_ DWORD) PURE;
   STDMETHOD (ThresholdGet)      (THIS_ DWORD *) PURE;
   STDMETHOD (ThresholdSet)      (THIS_ DWORD) PURE;
   STDMETHOD (DeviceGet)         (THIS_ DWORD *) PURE;
   STDMETHOD (DeviceSet)         (THIS_ DWORD) PURE;
   STDMETHOD (EnabledGet)        (THIS_ DWORD *) PURE;
   STDMETHOD (EnabledSet)        (THIS_ DWORD) PURE;
   STDMETHOD (MicrophoneGet)     (THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD (MicrophoneSet)     (THIS_ PCWSTR) PURE;
   STDMETHOD (SpeakerGet)        (THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD (SpeakerSet)        (THIS_ PCWSTR) PURE;
   STDMETHOD (SRModeGet)         (THIS_ GUID *) PURE;
   STDMETHOD (SRModeSet)         (THIS_ GUID) PURE;
};

typedef IVCmdAttributesW FAR * PIVCMDATTRIBUTESW;


#undef   INTERFACE
#define  INTERFACE   IVCmdAttributesA

// {FFF5DF80-5544-11b9-C000-5611722E1D15}
DEFINE_GUID(IID_IVCmdAttributesA, 0xfff5df80, 0x5544, 0x11b9, 0xc0, 0x0, 0x56, 0x11, 0x72, 0x2e, 0x1d, 0x15);

DECLARE_INTERFACE_ (IVCmdAttributesA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVCmdAttributes members
   STDMETHOD (AutoGainEnableGet) (THIS_ DWORD *) PURE;
   STDMETHOD (AutoGainEnableSet) (THIS_ DWORD) PURE;
   STDMETHOD (AwakeStateGet)     (THIS_ DWORD *) PURE;
   STDMETHOD (AwakeStateSet)     (THIS_ DWORD) PURE;
   STDMETHOD (ThresholdGet)      (THIS_ DWORD *) PURE;
   STDMETHOD (ThresholdSet)      (THIS_ DWORD) PURE;
   STDMETHOD (DeviceGet)         (THIS_ DWORD *) PURE;
   STDMETHOD (DeviceSet)         (THIS_ DWORD) PURE;
   STDMETHOD (EnabledGet)        (THIS_ DWORD *) PURE;
   STDMETHOD (EnabledSet)        (THIS_ DWORD) PURE;
   STDMETHOD (MicrophoneGet)     (THIS_ PSTR, DWORD, DWORD *) PURE;
   STDMETHOD (MicrophoneSet)     (THIS_ PCSTR) PURE;
   STDMETHOD (SpeakerGet)        (THIS_ PSTR, DWORD, DWORD *) PURE;
   STDMETHOD (SpeakerSet)        (THIS_ PCSTR) PURE;
   STDMETHOD (SRModeGet)         (THIS_ GUID *) PURE;
   STDMETHOD (SRModeSet)         (THIS_ GUID) PURE;
};

typedef IVCmdAttributesA FAR * PIVCMDATTRIBUTESA;


#ifdef _S_UNICODE
 #define IVCmdAttributes        IVCmdAttributesW
 #define IID_IVCmdAttributes    IID_IVCmdAttributesW
 #define PIVCMDATTRIBUTES       PIVCMDATTRIBUTESW

#else
 #define IVCmdAttributes        IVCmdAttributesA
 #define IID_IVCmdAttributes    IID_IVCmdAttributesA
 #define PIVCMDATTRIBUTES       PIVCMDATTRIBUTESA

#endif // _S_UNICODE



/*
 *  IVCmdDialog
 */
#undef   INTERFACE
#define  INTERFACE   IVCmdDialogsW

DEFINE_GUID(IID_IVCmdDialogsW, 0xEE39B8A0L, 0x6053, 0x101B, 0x99, 0x26, 0x00, 0xAA, 0x00, 0x3C, 0xFC, 0x2C);

DECLARE_INTERFACE_ (IVCmdDialogsW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)    (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)     (THIS) PURE;
   STDMETHOD_(ULONG,Release)    (THIS) PURE;

   // IVCmdDialogs members
   STDMETHOD (AboutDlg)         (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (GeneralDlg)       (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (LexiconDlg)       (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (TrainGeneralDlg)  (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (TrainMicDlg)      (THIS_ HWND, PCWSTR) PURE;
};

typedef IVCmdDialogsW FAR * PIVCMDDIALOGSW;


#undef   INTERFACE
#define  INTERFACE   IVCmdDialogsA

// {AA8FE260-5545-11b9-C000-5611722E1D15}
DEFINE_GUID(IID_IVCmdDialogsA, 0xaa8fe260, 0x5545, 0x11b9, 0xc0, 0x0, 0x56, 0x11, 0x72, 0x2e, 0x1d, 0x15);

DECLARE_INTERFACE_ (IVCmdDialogsA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)    (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)     (THIS) PURE;
   STDMETHOD_(ULONG,Release)    (THIS) PURE;

   // IVCmdDialogs members
   STDMETHOD (AboutDlg)         (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (GeneralDlg)       (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (LexiconDlg)       (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (TrainGeneralDlg)  (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (TrainMicDlg)      (THIS_ HWND, PCSTR) PURE;
};

typedef IVCmdDialogsA FAR * PIVCMDDIALOGSA;


#ifdef _S_UNICODE
 #define IVCmdDialogs       IVCmdDialogsW
 #define IID_IVCmdDialogs   IID_IVCmdDialogsW
 #define PIVCMDDIALOGS      PIVCMDDIALOGSW

#else
 #define IVCmdDialogs       IVCmdDialogsA
 #define IID_IVCmdDialogs   IID_IVCmdDialogsA
 #define PIVCMDDIALOGS      PIVCMDDIALOGSA

#endif // _S_UNICODE



/************************************************************************
class guids */

// DEFINE_GUID(CLSID_VCmd, 0x93898800L, 0x604D, 0x101B, 0x99, 0x26, 0x00, 0xAA, 0x00, 0x3C, 0xFC, 0x2C);
// {6D40D820-0BA7-11ce-A166-00AA004CD65C}
DEFINE_GUID(CLSID_VCmd, 
0x6d40d820, 0xba7, 0x11ce, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);
// {89F70C30-8636-11ce-B763-00AA004CD65C}
DEFINE_GUID(CLSID_SRShare, 
0x89f70c30, 0x8636, 0x11ce, 0xb7, 0x63, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);



/************************************************************************
High-Level dictation speech recognition API
*/

/************************************************************************
defines */
#define     VDCT_TOPICNAMELEN       32

// bit flags for the dwReason field of IVDctNotifySink::TextChanged
#define     VDCT_TEXTADDED          0x00000001
#define     VDCT_TEXTREMOVED        0x00000002
#define     VDCT_TEXTREPLACED       0x00000004

// bit flags for the dwReason field of IVDctText::TextRemove/TextSet
#define     VDCT_TEXTCLEAN          0x00010000
#define     VDCT_TEXTKEEPRESULTS    0x00020000

// bit flags for dwFlags of IVDctGUI::FlagsSet
#define     VDCTGUIF_VISIBLE        0x00000001
#define     VDCTGUIF_DONTMOVE       0x00000002

/************************************************************************
typedefs */

// site information structure - used for IVoiceDictation::SiteInfoGet/Set
typedef struct {
    DWORD   dwAutoGainEnable;
    DWORD   dwAwakeState;
    DWORD   dwThreshold;
    DWORD   dwDevice;
    DWORD   dwEnable;
    WCHAR   szMicrophone[VCMD_MICLEN];
    WCHAR   szSpeaker[VCMD_SPEAKERLEN];
    GUID    gModeID;
} VDSITEINFOW, *PVDSITEINFOW;

typedef struct {
    DWORD   dwAutoGainEnable;
    DWORD   dwAwakeState;
    DWORD   dwThreshold;
    DWORD   dwDevice;
    DWORD   dwEnable;
    CHAR    szMicrophone[VCMD_MICLEN];
    CHAR    szSpeaker[VCMD_SPEAKERLEN];
    GUID    gModeID;
} VDSITEINFOA, *PVDSITEINFOA;


// topic structure used by the IVoiceDictation object
typedef struct {
    WCHAR       szTopic[VDCT_TOPICNAMELEN];
    LANGUAGEW   language;
} VDCTTOPICW, *PVDCTTOPICW;

typedef struct {
    CHAR        szTopic[VDCT_TOPICNAMELEN];
    LANGUAGEA   language;
} VDCTTOPICA, *PVDCTTOPICA;


#ifdef  _S_UNICODE
 #define VDSITEINFO  VDSITEINFOW
 #define PVDSITEINFO PVDSITEINFOW
 #define VDCTTOPIC   VDCTTOPICW
 #define PVDCTTOPIC  PVDCTTOPICW
#else
 #define VDSITEINFO  VDSITEINFOA
 #define PVDSITEINFO PVDSITEINFOA
 #define VDCTTOPIC   VDCTTOPICA
 #define PVDCTTOPIC  PVDCTTOPICA
#endif  // _S_UNICODE


// memory maintenance structure used by MemoryGet/Set in IVDctAttributes
typedef struct {
    DWORD   dwMaxRAM;
    DWORD   dwMaxTime;
    DWORD   dwMaxWords;
    BOOL    fKeepAudio;
    BOOL    fKeepCorrection;
    BOOL    fKeepEval;
} VDCTMEMORY, *PVDCTMEMORY;


// bookmark definition
typedef struct {
    DWORD   dwID;
    DWORD   dwStartChar;
    DWORD   dwNumChars;
} VDCTBOOKMARK, *PVDCTBOOKMARK;



/************************************************************************
interfaces */

/*
 *  IVDctNotifySink
 */
#undef   INTERFACE
#define  INTERFACE   IVDctNotifySinkW

// {5FEB8800-67D5-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(IID_IVDctNotifySinkW,
0x5feb8800, 0x67d5, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);

DECLARE_INTERFACE_ (IVDctNotifySinkW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVDctNotifySink members
   STDMETHOD (CommandBuiltIn)       (THIS_ PWSTR) PURE;
   STDMETHOD (CommandOther)         (THIS_ PWSTR) PURE;
   STDMETHOD (CommandRecognize)     (THIS_ DWORD, DWORD, DWORD, PVOID, PWSTR) PURE;
   STDMETHOD (TextSelChanged)       (THIS) PURE;
   STDMETHOD (TextChanged)          (THIS_ DWORD) PURE;
   STDMETHOD (TextBookmarkChanged)  (THIS_ DWORD) PURE;
   STDMETHOD (PhraseStart)          (THIS) PURE;
   STDMETHOD (PhraseFinish)         (THIS_ DWORD, PSRPHRASEW) PURE;
   STDMETHOD (PhraseHypothesis)     (THIS_ DWORD, PSRPHRASEW) PURE;
   STDMETHOD (UtteranceBegin)       (THIS) PURE;
   STDMETHOD (UtteranceEnd)         (THIS) PURE;
   STDMETHOD (VUMeter)              (THIS_ WORD) PURE;
   STDMETHOD (AttribChanged)        (THIS_ DWORD) PURE;
   STDMETHOD (Interference)         (THIS_ DWORD) PURE;
   STDMETHOD (Training)             (THIS_ DWORD) PURE;
   STDMETHOD (Dictating)            (THIS_ PCWSTR, BOOL) PURE;
};

typedef IVDctNotifySinkW FAR * PIVDCTNOTIFYSINKW;


#undef   INTERFACE
#define  INTERFACE   IVDctNotifySinkA

// {88AD7DC0-67D5-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(IID_IVDctNotifySinkA,
0x88ad7dc0, 0x67d5, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);

DECLARE_INTERFACE_ (IVDctNotifySinkA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVDctNotifySinkA members
   STDMETHOD (CommandBuiltIn)       (THIS_ PSTR) PURE;
   STDMETHOD (CommandOther)         (THIS_ PSTR) PURE;
   STDMETHOD (CommandRecognize)     (THIS_ DWORD, DWORD, DWORD, PVOID, PSTR) PURE;
   STDMETHOD (TextSelChanged)       (THIS) PURE;
   STDMETHOD (TextChanged)          (THIS_ DWORD) PURE;
   STDMETHOD (TextBookmarkChanged)  (THIS_ DWORD) PURE;
   STDMETHOD (PhraseStart)          (THIS) PURE;
   STDMETHOD (PhraseFinish)         (THIS_ DWORD, PSRPHRASEA) PURE;
   STDMETHOD (PhraseHypothesis)     (THIS_ DWORD, PSRPHRASEA) PURE;
   STDMETHOD (UtteranceBegin)       (THIS) PURE;
   STDMETHOD (UtteranceEnd)         (THIS) PURE;
   STDMETHOD (VUMeter)              (THIS_ WORD) PURE;
   STDMETHOD (AttribChanged)        (THIS_ DWORD) PURE;
   STDMETHOD (Interference)         (THIS_ DWORD) PURE;
   STDMETHOD (Training)             (THIS_ DWORD) PURE;
   STDMETHOD (Dictating)            (THIS_ PCSTR, BOOL) PURE;
};

typedef IVDctNotifySinkA FAR * PIVDCTNOTIFYSINKA;


#ifdef _S_UNICODE
 #define IVDctNotifySink        IVDctNotifySinkW
 #define IID_IVDctNotifySink    IID_IVDctNotifySinkW
 #define PIVDCTNOTIFYSINK       PIVDCTNOTIFYSINKW

#else
 #define IVDctNotifySink        IVDctNotifySinkA
 #define IID_IVDctNotifySink    IID_IVDctNotifySinkA
 #define PIVDCTNOTIFYSINK       PIVDCTNOTIFYSINKA

#endif // _S_UNICODE



 
/*
 *  IVoiceDictation
 */
#undef   INTERFACE
#define  INTERFACE   IVoiceDictationW

// {88AD7DC3-67D5-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(IID_IVoiceDictationW,
0x88ad7dc3, 0x67d5, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);

DECLARE_INTERFACE_ (IVoiceDictationW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVoiceDictation members
   STDMETHOD (Register)         (THIS_ PCWSTR, PCWSTR, LPSTORAGE, PCWSTR,
				 PIVDCTNOTIFYSINK, GUID, DWORD) PURE;
   STDMETHOD (SiteInfoGet)      (THIS_ PCWSTR, PVDSITEINFOW) PURE;
   STDMETHOD (SiteInfoSet)      (THIS_ PCWSTR, PVDSITEINFOW) PURE;
   STDMETHOD (SessionSerialize) (THIS_ LPSTORAGE) PURE;
   STDMETHOD (TopicEnum)        (THIS_ PVDCTTOPICW *, DWORD *) PURE;
   STDMETHOD (TopicAdd)         (THIS_ PCWSTR, LANGUAGEW *, PCWSTR *, PCWSTR *,
				 PCWSTR *, PCWSTR *) PURE;
   STDMETHOD (TopicRemove)      (THIS_ PCWSTR) PURE;
   STDMETHOD (TopicSerialize)   (THIS_ LPSTORAGE) PURE;
   STDMETHOD (TopicDeserialize) (THIS_ LPSTORAGE) PURE;
   STDMETHOD (Activate)         (THIS_ HWND) PURE;
   STDMETHOD (Deactivate)       (THIS) PURE;
   STDMETHOD (TopicAddGrammar)  (THIS_ PCWSTR, SDATA) PURE;
};

typedef IVoiceDictationW FAR * PIVOICEDICTATIONW;


#undef   INTERFACE
#define  INTERFACE   IVoiceDictationA

// {88AD7DC4-67D5-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(IID_IVoiceDictationA,
0x88ad7dc4, 0x67d5, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);

DECLARE_INTERFACE_ (IVoiceDictationA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVoiceDictation members
   STDMETHOD (Register)         (THIS_ PCSTR, PCSTR, LPSTORAGE, PCSTR,
				 PIVDCTNOTIFYSINK, GUID, DWORD) PURE;
   STDMETHOD (SiteInfoGet)      (THIS_ PCSTR, PVDSITEINFOA) PURE;
   STDMETHOD (SiteInfoSet)      (THIS_ PCSTR, PVDSITEINFOA) PURE;
   STDMETHOD (SessionSerialize) (THIS_ LPSTORAGE) PURE;
   STDMETHOD (TopicEnum)        (THIS_ PVDCTTOPICA *, DWORD *) PURE;
   STDMETHOD (TopicAdd)         (THIS_ PCSTR, LANGUAGEA *, PCSTR *, PCSTR *,
				 PCSTR *, PCSTR *) PURE;
   STDMETHOD (TopicRemove)      (THIS_ PCSTR) PURE;
   STDMETHOD (TopicSerialize)   (THIS_ LPSTORAGE) PURE;
   STDMETHOD (TopicDeserialize) (THIS_ LPSTORAGE) PURE;
   STDMETHOD (Activate)         (THIS_ HWND) PURE;
   STDMETHOD (Deactivate)       (THIS) PURE;
   STDMETHOD (TopicAddGrammar)  (THIS_ PCSTR, SDATA) PURE;
};

typedef IVoiceDictationA FAR * PIVOICEDICTATIONA;


#ifdef _S_UNICODE
 #define IVoiceDictation     IVoiceDictationW
 #define IID_IVoiceDictation IID_IVoiceDictationW
 #define PIVOICEDICTATION    PIVOICEDICTATIONW

#else
 #define IVoiceDictation     IVoiceDictationA
 #define IID_IVoiceDictation IID_IVoiceDictationA
 #define PIVOICEDICTATION    PIVOICEDICTATIONA

#endif //_S_UNICODE



/*
 *  IVDctText
 */
#undef   INTERFACE
#define  INTERFACE   IVDctTextW

// {6D62B3A0-6893-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(IID_IVDctTextW,
0x6d62b3a0, 0x6893, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);

DECLARE_INTERFACE_ (IVDctTextW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVDctText members
   STDMETHOD (Lock)             (THIS) PURE;
   STDMETHOD (UnLock)           (THIS) PURE;
   STDMETHOD (TextGet)          (THIS_ DWORD, DWORD, PSDATA) PURE;
   STDMETHOD (TextSet)          (THIS_ DWORD, DWORD, PCWSTR, DWORD) PURE;
   STDMETHOD (TextMove)         (THIS_ DWORD, DWORD, DWORD, DWORD) PURE;
   STDMETHOD (TextRemove)       (THIS_ DWORD, DWORD, DWORD) PURE;
   STDMETHOD (TextSelSet)       (THIS_ DWORD, DWORD) PURE;
   STDMETHOD (TextSelGet)       (THIS_ DWORD *, DWORD *) PURE;
   STDMETHOD (TextLengthGet)    (THIS_ DWORD *) PURE;
   STDMETHOD (GetChanges)       (THIS_ DWORD *, DWORD *, DWORD *, DWORD *) PURE;
   STDMETHOD (BookmarkAdd)      (THIS_ PVDCTBOOKMARK) PURE;
   STDMETHOD (BookmarkRemove)   (THIS_ DWORD) PURE;
   STDMETHOD (BookmarkMove)     (THIS_ DWORD, DWORD, DWORD) PURE;
   STDMETHOD (BookmarkQuery)    (THIS_ DWORD, PVDCTBOOKMARK) PURE;
   STDMETHOD (BookmarkEnum)     (THIS_ DWORD, DWORD, PVDCTBOOKMARK *,
				       DWORD *) PURE;
   STDMETHOD (Hint)             (THIS_ PCWSTR) PURE;
   STDMETHOD (Words)            (THIS_ PCWSTR) PURE;
   STDMETHOD (ResultsGet)       (THIS_ DWORD, DWORD, DWORD *, DWORD *,
				       LPUNKNOWN *) PURE;
};
typedef IVDctTextW FAR * PIVDCTTEXTW;


#undef   INTERFACE
#define  INTERFACE   IVDctTextA

// {6D62B3A1-6893-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(IID_IVDctTextA,
0x6d62b3a1, 0x6893, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);

DECLARE_INTERFACE_ (IVDctTextA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVDctText members
   STDMETHOD (Lock)             (THIS) PURE;
   STDMETHOD (UnLock)           (THIS) PURE;
   STDMETHOD (TextGet)          (THIS_ DWORD, DWORD, PSDATA) PURE;
   STDMETHOD (TextSet)          (THIS_ DWORD, DWORD, PCSTR, DWORD) PURE;
   STDMETHOD (TextMove)         (THIS_ DWORD, DWORD, DWORD, DWORD) PURE;
   STDMETHOD (TextRemove)       (THIS_ DWORD, DWORD, DWORD) PURE;
   STDMETHOD (TextSelSet)       (THIS_ DWORD, DWORD) PURE;
   STDMETHOD (TextSelGet)       (THIS_ DWORD *, DWORD *) PURE;
   STDMETHOD (TextLengthGet)    (THIS_ DWORD *) PURE;
   STDMETHOD (GetChanges)       (THIS_ DWORD *, DWORD *, DWORD *, DWORD *) PURE;
   STDMETHOD (BookmarkAdd)      (THIS_ PVDCTBOOKMARK) PURE;
   STDMETHOD (BookmarkRemove)   (THIS_ DWORD) PURE;
   STDMETHOD (BookmarkMove)     (THIS_ DWORD, DWORD, DWORD) PURE;
   STDMETHOD (BookmarkQuery)    (THIS_ DWORD, PVDCTBOOKMARK) PURE;
   STDMETHOD (BookmarkEnum)     (THIS_ DWORD, DWORD, PVDCTBOOKMARK *,
				       DWORD *) PURE;
   STDMETHOD (Hint)             (THIS_ PCSTR) PURE;
   STDMETHOD (Words)            (THIS_ PCSTR) PURE;
   STDMETHOD (ResultsGet)       (THIS_ DWORD, DWORD, DWORD *, DWORD *,
				       LPUNKNOWN *) PURE;
};
typedef IVDctTextA FAR * PIVDCTTEXTA;


#ifdef _S_UNICODE
 #define IVDctText      IVDctTextW
 #define IID_IVDctText  IID_IVDctTextW
 #define PIVDCTTEXT     PIVDCTTEXTW

#else
 #define IVDctText      IVDctTextA
 #define IID_IVDctText  IID_IVDctTextA
 #define PIVDCTTEXT     PIVDCTTEXTA

#endif //_S_UNICODE



/*
 *  IVDctAttributes
 */
#undef   INTERFACE
#define  INTERFACE   IVDctAttributesW

// {88AD7DC5-67D5-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(IID_IVDctAttributesW,
0x88ad7dc5, 0x67d5, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);

DECLARE_INTERFACE_ (IVDctAttributesW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVDctAttributes members
   STDMETHOD    (AutoGainEnableGet)  (THIS_ DWORD *) PURE;
   STDMETHOD    (AutoGainEnableSet)  (THIS_ DWORD) PURE;
   STDMETHOD    (AwakeStateGet)      (THIS_ DWORD *) PURE;
   STDMETHOD    (AwakeStateSet)      (THIS_ DWORD) PURE;
   STDMETHOD    (ThresholdGet)       (THIS_ DWORD *) PURE;
   STDMETHOD    (ThresholdSet)       (THIS_ DWORD) PURE;
   STDMETHOD    (EchoGet)            (THIS_ BOOL *) PURE;
   STDMETHOD    (EchoSet)            (THIS_ BOOL) PURE;
   STDMETHOD    (EnergyFloorGet)     (THIS_ WORD *) PURE;
   STDMETHOD    (EnergyFloorSet)     (THIS_ WORD) PURE;
   STDMETHOD    (RealTimeGet)        (THIS_ DWORD *) PURE;
   STDMETHOD    (RealTimeSet)        (THIS_ DWORD) PURE;
   STDMETHOD    (TimeOutGet)         (THIS_ DWORD *, DWORD *) PURE;
   STDMETHOD    (TimeOutSet)         (THIS_ DWORD, DWORD) PURE;
   STDMETHOD    (EnabledGet)         (THIS_ DWORD *) PURE;
   STDMETHOD    (EnabledSet)         (THIS_ DWORD) PURE;
   STDMETHOD    (BuiltInFeaturesGet) (THIS_ DWORD *) PURE;
   STDMETHOD    (BuiltInFeaturesSet) (THIS_ DWORD) PURE;
   STDMETHOD    (MemoryGet)          (THIS_ VDCTMEMORY *) PURE;
   STDMETHOD    (MemorySet)          (THIS_ VDCTMEMORY *) PURE;
   STDMETHOD    (DictatingNowGet)    (THIS_ DWORD *) PURE;
   STDMETHOD    (DictatingNowSet)    (THIS_ DWORD) PURE;
   STDMETHOD    (IsAnyoneDictating)  (THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD    (MicrophoneGet)      (THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD    (MicrophoneSet)      (THIS_ PCWSTR) PURE;
   STDMETHOD    (SpeakerGet)         (THIS_ PWSTR, DWORD, DWORD *) PURE;
   STDMETHOD    (SpeakerSet)         (THIS_ PCWSTR) PURE;
};

typedef IVDctAttributesW FAR * PIVDCTATTRIBUTESW;


#undef   INTERFACE
#define  INTERFACE   IVDctAttributesA

// {88AD7DC6-67D5-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(IID_IVDctAttributesA,
0x88ad7dc6, 0x67d5, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);

DECLARE_INTERFACE_ (IVDctAttributesA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVDctAttributes members
   STDMETHOD    (AutoGainEnableGet)  (THIS_ DWORD *) PURE;
   STDMETHOD    (AutoGainEnableSet)  (THIS_ DWORD) PURE;
   STDMETHOD    (AwakeStateGet)      (THIS_ DWORD *) PURE;
   STDMETHOD    (AwakeStateSet)      (THIS_ DWORD) PURE;
   STDMETHOD    (ThresholdGet)       (THIS_ DWORD *) PURE;
   STDMETHOD    (ThresholdSet)       (THIS_ DWORD) PURE;
   STDMETHOD    (EchoGet)            (THIS_ BOOL *) PURE;
   STDMETHOD    (EchoSet)            (THIS_ BOOL) PURE;
   STDMETHOD    (EnergyFloorGet)     (THIS_ WORD *) PURE;
   STDMETHOD    (EnergyFloorSet)     (THIS_ WORD) PURE;
   STDMETHOD    (RealTimeGet)        (THIS_ DWORD *) PURE;
   STDMETHOD    (RealTimeSet)        (THIS_ DWORD) PURE;
   STDMETHOD    (TimeOutGet)         (THIS_ DWORD *, DWORD *) PURE;
   STDMETHOD    (TimeOutSet)         (THIS_ DWORD, DWORD) PURE;
   STDMETHOD    (EnabledGet)         (THIS_ DWORD *) PURE;
   STDMETHOD    (EnabledSet)         (THIS_ DWORD) PURE;
   STDMETHOD    (BuiltInFeaturesGet) (THIS_ DWORD *) PURE;
   STDMETHOD    (BuiltInFeaturesSet) (THIS_ DWORD) PURE;
   STDMETHOD    (MemoryGet)          (THIS_ VDCTMEMORY *) PURE;
   STDMETHOD    (MemorySet)          (THIS_ VDCTMEMORY *) PURE;
   STDMETHOD    (DictatingNowGet)    (THIS_ DWORD *) PURE;
   STDMETHOD    (DictatingNowSet)    (THIS_ DWORD) PURE;
   STDMETHOD    (IsAnyoneDictating)  (THIS_ PSTR, DWORD, DWORD *) PURE;
   STDMETHOD    (MicrophoneGet)      (THIS_ PSTR, DWORD, DWORD *) PURE;
   STDMETHOD    (MicrophoneSet)      (THIS_ PCSTR) PURE;
   STDMETHOD    (SpeakerGet)         (THIS_ PSTR, DWORD, DWORD *) PURE;
   STDMETHOD    (SpeakerSet)         (THIS_ PCSTR) PURE;
};

typedef IVDctAttributesA FAR * PIVDCTATTRIBUTESA;


#ifdef _S_UNICODE
 #define IVDctAttributes        IVDctAttributesW
 #define IID_IVDctAttributes    IID_IVDctAttributesW
 #define PIVDCTATTRIBUTES       PIVDCTATTRIBUTESW

#else
 #define IVDctAttributes        IVDctAttributesA
 #define IID_IVDctAttributes    IID_IVDctAttributesA
 #define PIVDCTATTRIBUTES       PIVDCTATTRIBUTESA

#endif // _S_UNICODE



/*
 *  IVDctCommands
 */
#undef   INTERFACE
#define  INTERFACE   IVDctCommandsW

// {A02C2CA0-AE50-11cf-833A-00AA00A21A29}
DEFINE_GUID(IID_IVDctCommandsW,
0xA02C2CA0, 0xAE50, 0x11cf, 0x83, 0x3A, 0x00, 0xAA, 0x00, 0xA2, 0x1A, 0x29);

DECLARE_INTERFACE_ (IVDctCommandsW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVDctCommands members
   STDMETHOD    (Add)      (THIS_ BOOL, DWORD, SDATA, DWORD *) PURE;
   STDMETHOD    (Remove)   (THIS_ BOOL, DWORD, DWORD, DWORD) PURE;
   STDMETHOD    (Get)      (THIS_ BOOL, DWORD, DWORD, DWORD, SDATA*, DWORD *) PURE;
   STDMETHOD    (Set)      (THIS_ BOOL, DWORD, DWORD, DWORD, SDATA) PURE;
   STDMETHOD    (EnableItem) (THIS_ BOOL, DWORD, DWORD, DWORD) PURE;
   STDMETHOD    (Num)      (THIS_ BOOL, DWORD *) PURE;
};

typedef IVDctCommandsW FAR * PIVDCTCOMMANDSW;


#undef   INTERFACE
#define  INTERFACE   IVDctCommandsA

// {A02C2CA1-AE50-11cf-833A-00AA00A21A29}
DEFINE_GUID(IID_IVDctCommandsA,
0xA02C2CA1, 0xAE50, 0x11cf, 0x83, 0x3A, 0x00, 0xAA, 0x00, 0xA2, 0x1A, 0x29);

DECLARE_INTERFACE_ (IVDctCommandsA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVDctCommands members
   STDMETHOD    (Add)      (THIS_ BOOL, DWORD, SDATA, DWORD *) PURE;
   STDMETHOD    (Remove)   (THIS_ BOOL, DWORD, DWORD, DWORD) PURE;
   STDMETHOD    (Get)      (THIS_ BOOL, DWORD, DWORD, DWORD, SDATA*, DWORD *) PURE;
   STDMETHOD    (Set)      (THIS_ BOOL, DWORD, DWORD, DWORD, SDATA) PURE;
   STDMETHOD    (EnableItem) (THIS_ BOOL, DWORD, DWORD, DWORD) PURE;
   STDMETHOD    (Num)      (THIS_ BOOL, DWORD *) PURE;
};

typedef IVDctCommandsA FAR * PIVDCTCOMMANDSA;


#ifdef _S_UNICODE
 #define IVDctCommands        IVDctCommandsW
 #define IID_IVDctCommands    IID_IVDctCommandsW
 #define PIVDCTCOMMANDS       PIVDCTCOMMANDSW

#else
 #define IVDctCommands        IVDctCommandsA
 #define IID_IVDctCommands    IID_IVDctCommandsA
 #define PIVDCTCOMMANDS       PIVDCTCOMMANDSA

#endif // _S_UNICODE



/*
 *  IVDctGlossary
 */
#undef   INTERFACE
#define  INTERFACE   IVDctGlossaryW

// {A02C2CA2-AE50-11cf-833A-00AA00A21A29}
DEFINE_GUID(IID_IVDctGlossaryW,
0xA02C2CA2, 0xAE50, 0x11cf, 0x83, 0x3A, 0x00, 0xAA, 0x00, 0xA2, 0x1A, 0x29);

DECLARE_INTERFACE_ (IVDctGlossaryW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVDctGlossary members
   STDMETHOD    (Add)      (THIS_ BOOL, DWORD, SDATA, DWORD *) PURE;
   STDMETHOD    (Remove)   (THIS_ BOOL, DWORD, DWORD, DWORD) PURE;
   STDMETHOD    (Get)      (THIS_ BOOL, DWORD, DWORD, DWORD, SDATA*, DWORD *) PURE;
   STDMETHOD    (Set)      (THIS_ BOOL, DWORD, DWORD, DWORD, SDATA) PURE;
   STDMETHOD    (EnableItem) (THIS_ BOOL, DWORD, DWORD, DWORD) PURE;
   STDMETHOD    (Num)      (THIS_ BOOL, DWORD *) PURE;
};

typedef IVDctGlossaryW FAR * PIVDCTGLOSSARYW;


#undef   INTERFACE
#define  INTERFACE   IVDctGlossaryA

// {A02C2CA3-AE50-11cf-833A-00AA00A21A29}
DEFINE_GUID(IID_IVDctGlossaryA,
0xA02C2CA3, 0xAE50, 0x11cf, 0x83, 0x3A, 0x00, 0xAA, 0x00, 0xA2, 0x1A, 0x29);

DECLARE_INTERFACE_ (IVDctGlossaryA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVDctGlossary members
   STDMETHOD    (Add)      (THIS_ BOOL, DWORD, SDATA, DWORD *) PURE;
   STDMETHOD    (Remove)   (THIS_ BOOL, DWORD, DWORD, DWORD) PURE;
   STDMETHOD    (Get)      (THIS_ BOOL, DWORD, DWORD, DWORD, SDATA*, DWORD *) PURE;
   STDMETHOD    (Set)      (THIS_ BOOL, DWORD, DWORD, DWORD, SDATA) PURE;
   STDMETHOD    (EnableItem) (THIS_ BOOL, DWORD, DWORD, DWORD) PURE;
   STDMETHOD    (Num)      (THIS_ BOOL, DWORD *) PURE;
};

typedef IVDctGlossaryA FAR * PIVDCTGLOSSARYA;


#ifdef _S_UNICODE
 #define IVDctGlossary        IVDctGlossaryW
 #define IID_IVDctGlossary    IID_IVDctGlossaryW
 #define PIVDCTGLOSSARY       PIVDCTGLOSSARYW

#else
 #define IVDctGlossary        IVDctGlossaryA
 #define IID_IVDctGlossary    IID_IVDctGlossaryA
 #define PIVDCTGLOSSARY       PIVDCTGLOSSARYA

#endif // _S_UNICODE




/*
 *  IVDctDialog
 */
#undef   INTERFACE
#define  INTERFACE   IVDctDialogsW

// {88AD7DC7-67D5-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(IID_IVDctDialogsW,
0x88ad7dc7, 0x67d5, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);

DECLARE_INTERFACE_ (IVDctDialogsW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)    (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)     (THIS) PURE;
   STDMETHOD_(ULONG,Release)    (THIS) PURE;

   // IVDctDialogs members
   STDMETHOD (AboutDlg)         (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (GeneralDlg)       (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (LexiconDlg)       (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (TrainGeneralDlg)  (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (TrainMicDlg)      (THIS_ HWND, PCWSTR) PURE;
};

typedef IVDctDialogsW FAR * PIVDCTDIALOGSW;


#undef   INTERFACE
#define  INTERFACE   IVDctDialogsA

// {88AD7DC8-67D5-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(IID_IVDctDialogsA,
0x88ad7dc8, 0x67d5, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);

DECLARE_INTERFACE_ (IVDctDialogsA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)    (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)     (THIS) PURE;
   STDMETHOD_(ULONG,Release)    (THIS) PURE;

   // IVDctDialogs members
   STDMETHOD (AboutDlg)         (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (GeneralDlg)       (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (LexiconDlg)       (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (TrainGeneralDlg)  (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (TrainMicDlg)      (THIS_ HWND, PCSTR) PURE;
};

typedef IVDctDialogsA FAR * PIVDCTDIALOGSA;


#ifdef _S_UNICODE
 #define IVDctDialogs       IVDctDialogsW
 #define IID_IVDctDialogs   IID_IVDctDialogsW
 #define PIVDCTDIALOGS      PIVDCTDIALOGSW

#else
 #define IVDctDialogs       IVDctDialogsA
 #define IID_IVDctDialogs   IID_IVDctDialogsA
 #define PIVDCTDIALOGS      PIVDCTDIALOGSA

#endif // _S_UNICODE


#undef   INTERFACE
#define  INTERFACE   IVDctGUI

// {8953F1A0-7E80-11cf-8D15-00A0C9034A7E}
DEFINE_GUID(IID_IVDctGUI,
0x8953f1a0, 0x7e80, 0x11cf, 0x8d, 0x15, 0x0, 0xa0, 0xc9, 0x3, 0x4a, 0x7e);

DECLARE_INTERFACE_ (IVDctGUI, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)    (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)     (THIS) PURE;
   STDMETHOD_(ULONG,Release)    (THIS) PURE;

   // IVDctDialogs members
   STDMETHOD (SetSelRect)       (THIS_ RECT *) PURE;
   STDMETHOD (FlagsSet)         (THIS_ DWORD) PURE;
   STDMETHOD (FlagsGet)         (THIS_ DWORD *) PURE;
};

typedef IVDctGUI FAR * PIVDCTGUI;



/************************************************************************
class guids */

// {25522CA0-67CE-11cf-9B8B-08005AFC3A41}
DEFINE_GUID(CLSID_VDct, 
0x25522ca0, 0x67ce, 0x11cf, 0x9b, 0x8b, 0x8, 0x0, 0x5a, 0xfc, 0x3a, 0x41);



/************************************************************************
High-Level text-to-speech API
*/


/************************************************************************
defines */

#define  ONE                    (1)

// dwFlags parameter of IVoiceText::Register
#define  VTXTF_ALLMESSAGES      (ONE<<0)

/*
 *   dwFlags parameter of IVoiceText::Speak
 */

// type of speech
#define  VTXTST_STATEMENT       0x00000001
#define  VTXTST_QUESTION        0x00000002
#define  VTXTST_COMMAND         0x00000004
#define  VTXTST_WARNING         0x00000008
#define  VTXTST_READING         0x00000010
#define  VTXTST_NUMBERS         0x00000020
#define  VTXTST_SPREADSHEET     0x00000040

// priorities
#define  VTXTSP_VERYHIGH        0x00000080
#define  VTXTSP_HIGH            0x00000100
#define  VTXTSP_NORMAL          0x00000200

/************************************************************************
typedefs */

// possible parameter to IVoiceText::Register
typedef struct {
    DWORD   dwDevice;
    DWORD   dwEnable;
    DWORD   dwSpeed;
    GUID    gModeID;
} VTSITEINFO, *PVTSITEINFO;


/************************************************************************
interfaces */

/*
 *  IVCmdNotifySink
 */
#undef   INTERFACE
#define  INTERFACE   IVTxtNotifySinkW

// {FD3A2430-E090-11cd-A166-00AA004CD65C}
DEFINE_GUID(IID_IVTxtNotifySinkW, 0xfd3a2430, 0xe090, 0x11cd, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);

DECLARE_INTERFACE_ (IVTxtNotifySinkW, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVTxtNotifySinkW members
   STDMETHOD (AttribChanged)    (THIS_ DWORD) PURE;
   STDMETHOD (Visual)           (THIS_ WCHAR, WCHAR, DWORD, PTTSMOUTH) PURE;
   STDMETHOD (Speak)            (THIS_ PWSTR, PWSTR, DWORD) PURE;
   STDMETHOD (SpeakingStarted)  (THIS) PURE;
   STDMETHOD (SpeakingDone)     (THIS) PURE;
};

typedef IVTxtNotifySinkW FAR * PIVTXTNOTIFYSINKW;


#undef   INTERFACE
#define  INTERFACE   IVTxtNotifySinkA

// {D2C840E0-E092-11cd-A166-00AA004CD65C}
DEFINE_GUID(IID_IVTxtNotifySinkA, 0xd2c840e0, 0xe092, 0x11cd, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);

DECLARE_INTERFACE_ (IVTxtNotifySinkA, IUnknown) {

   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVTxtNotifySinkA members
   STDMETHOD (AttribChanged)    (THIS_ DWORD) PURE;
   STDMETHOD (Visual)           (THIS_ WCHAR, CHAR, DWORD, PTTSMOUTH) PURE;
   STDMETHOD (Speak)            (THIS_ PSTR, PSTR, DWORD) PURE;
   STDMETHOD (SpeakingStarted)  (THIS) PURE;
   STDMETHOD (SpeakingDone)     (THIS) PURE;
};

typedef IVTxtNotifySinkA FAR * PIVTXTNOTIFYSINKA;


#ifdef _S_UNICODE
 #define IVTxtNotifySink        IVTxtNotifySinkW
 #define IID_IVTxtNotifySink    IID_IVTxtNotifySinkW
 #define PIVTXTNOTIFYSINK       PIVTXTNOTIFYSINKW

#else
 #define IVTxtNotifySink        IVTxtNotifySinkA
 #define IID_IVTxtNotifySink    IID_IVTxtNotifySinkA
 #define PIVTXTNOTIFYSINK       PIVTXTNOTIFYSINKA

#endif // _S_UNICODE



/*
 *  IVoiceText
 */
#undef   INTERFACE
#define  INTERFACE   IVoiceTextW

// {C4FE8740-E093-11cd-A166-00AA004CD65C}
DEFINE_GUID(IID_IVoiceTextW, 0xc4fe8740, 0xe093, 0x11cd, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);

DECLARE_INTERFACE_ (IVoiceTextW, IUnknown) {
    // IUnknown members
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IVoiceText members

    STDMETHOD (Register)         (THIS_ PCWSTR, PCWSTR, 
					PIVTXTNOTIFYSINK, GUID,
					DWORD, PVTSITEINFO) PURE;
    STDMETHOD (Speak)            (THIS_ PCWSTR, DWORD, PCWSTR) PURE;
    STDMETHOD (StopSpeaking)     (THIS) PURE;
    STDMETHOD (AudioFastForward) (THIS) PURE;
    STDMETHOD (AudioPause)       (THIS) PURE;
    STDMETHOD (AudioResume)      (THIS) PURE;
    STDMETHOD (AudioRewind)      (THIS) PURE;
};

typedef IVoiceTextW FAR * PIVOICETEXTW;


#undef   INTERFACE
#define  INTERFACE   IVoiceTextA

// {E1B7A180-E093-11cd-A166-00AA004CD65C}
DEFINE_GUID(IID_IVoiceTextA, 0xe1b7a180, 0xe093, 0x11cd, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);

DECLARE_INTERFACE_ (IVoiceTextA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVoiceText members

    STDMETHOD (Register)         (THIS_ PCSTR, PCSTR, 
					PIVTXTNOTIFYSINK, GUID,
					DWORD, PVTSITEINFO) PURE;
    STDMETHOD (Speak)            (THIS_ PCSTR, DWORD, PCSTR) PURE;
    STDMETHOD (StopSpeaking)     (THIS) PURE;
    STDMETHOD (AudioFastForward) (THIS) PURE;
    STDMETHOD (AudioPause)       (THIS) PURE;
    STDMETHOD (AudioResume)      (THIS) PURE;
    STDMETHOD (AudioRewind)      (THIS) PURE;
};

typedef IVoiceTextA FAR * PIVOICETEXTA;


#ifdef _S_UNICODE
 #define IVoiceText      IVoiceTextW
 #define IID_IVoiceText  IID_IVoiceTextW
 #define PIVOICETEXT     PIVOICETEXTW

#else
 #define IVoiceText      IVoiceTextA
 #define IID_IVoiceText  IID_IVoiceTextA
 #define PIVOICETEXT     PIVOICETEXTA

#endif //_S_UNICODE



/*
 *  IVTxtAttributes
 */
#undef   INTERFACE
#define  INTERFACE   IVTxtAttributesW

// {6A8D6140-E095-11cd-A166-00AA004CD65C}
DEFINE_GUID(IID_IVTxtAttributesW, 0x6a8d6140, 0xe095, 0x11cd, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);

DECLARE_INTERFACE_ (IVTxtAttributesW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVTxtAttributes members
   STDMETHOD (DeviceGet)         (THIS_ DWORD *) PURE;
   STDMETHOD (DeviceSet)         (THIS_ DWORD) PURE;
   STDMETHOD (EnabledGet)        (THIS_ DWORD *) PURE;
   STDMETHOD (EnabledSet)        (THIS_ DWORD) PURE;
   STDMETHOD (IsSpeaking)        (THIS_ BOOL *) PURE;
   STDMETHOD (SpeedGet)          (THIS_ DWORD *) PURE;
   STDMETHOD (SpeedSet)          (THIS_ DWORD) PURE;
   STDMETHOD (TTSModeGet)        (THIS_ GUID *) PURE;
   STDMETHOD (TTSModeSet)        (THIS_ GUID) PURE;
};

typedef IVTxtAttributesW FAR * PIVTXTATTRIBUTESW;


#undef   INTERFACE
#define  INTERFACE   IVTxtAttributesA

// {8BE9CC30-E095-11cd-A166-00AA004CD65C}
DEFINE_GUID(IID_IVTxtAttributesA, 0x8be9cc30, 0xe095, 0x11cd, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);

DECLARE_INTERFACE_ (IVTxtAttributesA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVTxtAttributes members
   STDMETHOD (DeviceGet)         (THIS_ DWORD *) PURE;
   STDMETHOD (DeviceSet)         (THIS_ DWORD) PURE;
   STDMETHOD (EnabledGet)        (THIS_ DWORD *) PURE;
   STDMETHOD (EnabledSet)        (THIS_ DWORD) PURE;
   STDMETHOD (IsSpeaking)        (THIS_ BOOL *) PURE;
   STDMETHOD (SpeedGet)          (THIS_ DWORD *) PURE;
   STDMETHOD (SpeedSet)          (THIS_ DWORD) PURE;
   STDMETHOD (TTSModeGet)        (THIS_ GUID *) PURE;
   STDMETHOD (TTSModeSet)        (THIS_ GUID) PURE;
};

typedef IVTxtAttributesA FAR * PIVTXTATTRIBUTESA;


#ifdef _S_UNICODE
 #define IVTxtAttributes        IVTxtAttributesW
 #define IID_IVTxtAttributes    IID_IVTxtAttributesW
 #define PIVTXTATTRIBUTES       PIVTXTATTRIBUTESW

#else
 #define IVTxtAttributes        IVTxtAttributesA
 #define IID_IVTxtAttributes    IID_IVTxtAttributesA
 #define PIVTXTATTRIBUTES       PIVTXTATTRIBUTESA

#endif // _S_UNICODE



/*
 *  IVTxtDialog
 */
#undef   INTERFACE
#define  INTERFACE   IVTxtDialogsW

// {D6469210-E095-11cd-A166-00AA004CD65C}
DEFINE_GUID(IID_IVTxtDialogsW, 0xd6469210, 0xe095, 0x11cd, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);

DECLARE_INTERFACE_ (IVTxtDialogsW, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVTxtDialogs members

   STDMETHOD (AboutDlg)       (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (LexiconDlg)     (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (GeneralDlg)     (THIS_ HWND, PCWSTR) PURE;
   STDMETHOD (TranslateDlg)   (THIS_ HWND, PCWSTR) PURE;
};

typedef IVTxtDialogsW FAR * PIVTXTDIALOGSW;


#undef   INTERFACE
#define  INTERFACE   IVTxtDialogsA

// {E8F6FA20-E095-11cd-A166-00AA004CD65C}
DEFINE_GUID(IID_IVTxtDialogsA, 0xe8f6fa20, 0xe095, 0x11cd, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);

DECLARE_INTERFACE_ (IVTxtDialogsA, IUnknown) {
   // IUnknown members
   STDMETHOD(QueryInterface)  (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
   STDMETHOD_(ULONG,AddRef)   (THIS) PURE;
   STDMETHOD_(ULONG,Release)  (THIS) PURE;

   // IVTxtDialogs members
   STDMETHOD (AboutDlg)       (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (LexiconDlg)     (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (GeneralDlg)     (THIS_ HWND, PCSTR) PURE;
   STDMETHOD (TranslateDlg)   (THIS_ HWND, PCSTR) PURE;
};

typedef IVTxtDialogsA FAR * PIVTXTDIALOGSA;


#ifdef _S_UNICODE
 #define IVTxtDialogs       IVTxtDialogsW
 #define IID_IVTxtDialogs   IID_IVTxtDialogsW
 #define PIVTXTDIALOGS      PIVTXTDIALOGSW

#else
 #define IVTxtDialogs       IVTxtDialogsA
 #define IID_IVTxtDialogs   IID_IVTxtDialogsA
 #define PIVTXTDIALOGS      PIVTXTDIALOGSA

#endif // _S_UNICODE



/************************************************************************
class guids */

// {080EB9D0-E096-11cd-A166-00AA004CD65C}
// DEFINE_GUID(CLSID_VTxt, 0x80eb9d0, 0xe096, 0x11cd, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);
// {F1DC95A0-0BA7-11ce-A166-00AA004CD65C}
DEFINE_GUID(CLSID_VTxt, 
0xf1dc95a0, 0xba7, 0x11ce, 0xa1, 0x66, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0x5c);



#endif    // _SPEECH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\narrator\narrhook\getprop.h ===
//getprop.h
DWORD GetObjectName(LPOBJINFO poiObj, LPSTR lpszBuf, int cchBuf);
DWORD GetObjectDescription(LPOBJINFO poiObj, LPSTR lpszBuf, int cchBuf);
DWORD GetObjectValue(LPOBJINFO poiObj, LPSTR lpszBuf, int cchBuf);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\narrator\narrhook\helpthd.h ===
/*************************************************************************

  Include file for helpthd.cpp

  defines STACAKBLE_EVENT_INFO structure and GINFO (Global Info) structure

*************************************************************************/
typedef struct STACKABLE_EVENT_INFO *PSTACKABLE_EVENT_INFO;

typedef struct STACKABLE_EVENT_INFO {

	enum Action {NewEvent, EndHelper};
	Action       m_Action;

	DWORD        event;
	HWND         hwndMsg;
	LONG         idObject;
	LONG         idChild;
	DWORD        idThread;
	DWORD        dwmsEventTime;

} STACKABLE_EVENT_INFO;


typedef struct GINFO {
    CRITICAL_SECTION HelperCritSect;
    HANDLE           hHelperEvent;
    HANDLE           hHelperThread;
    CList            EventInfoList;
} GINFO;


//
// Function Prototypes
//
void InitHelperThread();
void UnInitHelperThread();

void AddEventInfoToStack(DWORD event, HWND hwndMsg, LONG idObject, LONG idChild, DWORD idThread, DWORD dwmsEventTime);
BOOL RemoveInfoFromStack(STACKABLE_EVENT_INFO *pEventInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\narrator\narrhook\keys.h ===
// Keys.H

//
// Functions exported from narrhook.dll
//
__declspec(dllexport) BOOL InitKeys(HWND hwnd);
__declspec(dllexport) BOOL UninitKeys(void);
__declspec(dllexport) BOOL InitMSAA(void);
__declspec(dllexport) BOOL UnInitMSAA(void);
__declspec(dllexport) void BackToApplication(void);
__declspec(dllexport) void GetCurrentText(LPTSTR psz, int cch);
__declspec(dllexport) BOOL GetTrackSecondary();
__declspec(dllexport) BOOL GetTrackCaret();
__declspec(dllexport) BOOL GetTrackInputFocus();
__declspec(dllexport) int GetEchoChars();
__declspec(dllexport) BOOL GetAnnounceWindow();
__declspec(dllexport) BOOL GetAnnounceMenu();
__declspec(dllexport) BOOL GetAnnouncePopup();
__declspec(dllexport) BOOL GetAnnounceToolTips();
__declspec(dllexport) BOOL GetReviewStyle();
__declspec(dllexport) int GetReviewLevel();
__declspec(dllexport) void SetCurrentText(LPCTSTR);
__declspec(dllexport) void SetTrackSecondary(BOOL);
__declspec(dllexport) void SetTrackCaret(BOOL);
__declspec(dllexport) void SetTrackInputFocus(BOOL);
__declspec(dllexport) void SetEchoChars(int);
__declspec(dllexport) void SetAnnounceWindow(BOOL);
__declspec(dllexport) void SetAnnounceMenu(BOOL);
__declspec(dllexport) void SetAnnouncePopup(BOOL);
__declspec(dllexport) void SetAnnounceToolTips(BOOL);
__declspec(dllexport) void SetReviewStyle(BOOL);
__declspec(dllexport) void SetReviewLevel(int);

// this is in other.cpp it is used to avoid pulling in C runtime
__declspec(dllexport) LPTSTR lstrcatn(LPTSTR pDest, LPTSTR pSrc, int maxDest);

//
// typedefs 
//
typedef void (*FPACTION)(int nOption);

typedef struct tagHOTK
{
    WPARAM  keyVal;    // Key value, like F1
	int status;
    FPACTION lFunction; // address of function to get info
    int nOption;     // Extra data to send to function
} HOTK;


//
// defines
//
#define TIMER_ID 1001

#define MSR_CTRL  1
#define MSR_SHIFT 2
#define MSR_ALT   4

#define MSR_KEYUP		1
#define MSR_KEYDOWN		2
#define MSR_KEYLEFT		3
#define MSR_KEYRIGHT	4

//
// Function Prototypes
//
void ProcessWinEvent(DWORD event, HWND hwndMsg, LONG idObject, 
                     LONG idChild, DWORD idThread, DWORD dwmsEventTime);

// Macros and function prototypes for debugging
#include "..\..\inc\w95trace.h"

extern DWORD g_tidMain;	// ROBSI: 10-10-99 (defined in keys.cpp)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\narrator\narrhook\list.cpp ===
#include <windows.h>

#include "list.h"

//----------------------------------------------------------------------------
// 
// Description:
//   this implements a simple C++ list class routine that will let us build
//   up a list of an arbitrary long number of items.  An item can be any 
//   simple type or structure.  
//
//----------------------------------------------------------------------------

CList::CList()
{
    m_pListHead=m_pListCurr=m_pListTail=NULL;
}

CList::~CList()
{
    RemoveAll();
}

//----------------------------------------------------------------------------
// 
// Description:
//   Add an item to the list.  The length of the item is assumed correct
//   for the passed in item.  Items are added to the end of the list.
//
// Arguments:
//   pData  - pointer to the data to add
//   nBytes - the number of bytes of pData
// 
// Returns: TRUE if the data is succesfully added, otherwise FALSE.
//           a-anilk; Just donot absolutely Duplicate Entries
//   
//----------------------------------------------------------------------------
BOOL
CList::Add(PVOID pData, UINT nBytes)
{
    PLIST tmp;

    if ((nBytes == 0) || (pData == NULL))
        return FALSE;

    tmp=new LIST;

    if (NULL == tmp)
        return FALSE;

    tmp->pData=new BYTE[nBytes];

    if (NULL == tmp->pData)
    {
        delete tmp;
        return FALSE;
    }

	// Donot add duplicate entries that come one after another...
	if ( m_pListHead != NULL )
	{
		if (! memcmp(m_pListHead->pData, pData, nBytes ) )
		{
			delete [] tmp->pData;	// raid 113787
			delete tmp;
			return FALSE;
		}
	}

    CopyMemory(tmp->pData,pData,nBytes);

    tmp->nBytes=nBytes;
    tmp->next=NULL;
    tmp->prev=m_pListTail;

    if (IsEmpty())
    {
        m_pListHead=tmp;
    }
    else
    {
        if (m_pListTail != NULL)
            m_pListTail->next=tmp;
    }

    m_pListTail=tmp;

    return TRUE;
}


//----------------------------------------------------------------------------
// 
// Description:
//   Remove all the items from the list.
//
//----------------------------------------------------------------------------
void
CList::RemoveAll()
{
    while(!IsEmpty())
        RemoveHead(NULL);
}


//----------------------------------------------------------------------------
//
// Description:
//   Remove just the item at the head of the list.  If the passed in buffer
//   is not NULL, it will overwrite the buffer with the contents of the data.
//   This code assumes the passed in pData buffer is large enough for the
//   stored data item.  If the passed in pData is NULL, then the head item
//   is simply discarded.
//
// Arguments:
//   pData - a buffer to overwrite with the head item. Can be NULL.
//  
//----------------------------------------------------------------------------
void
CList::RemoveHead(PVOID pData)
{
    PLIST tmp;

    if (!IsEmpty())
    {
        // make sure m_pListCurr is always NULL or someplace valid

        if (m_pListCurr == m_pListHead)
            m_pListCurr=m_pListHead->next;

        tmp=m_pListHead;
        m_pListHead=m_pListHead->next;

        if (tmp->pData != NULL)
        {
            if (pData != NULL)
                CopyMemory(pData,tmp->pData,tmp->nBytes);

            delete[] (tmp->pData);
        }

        delete tmp;

        if (!IsEmpty())
            m_pListHead->prev=NULL;
        else
            m_pListTail=NULL;
    }
}


//----------------------------------------------------------------------------
//
// Description:
//    RemoveHead(NULL, NULL)  <=>   RemoveHead(NULL)
//
//    RemoveHead(pData,NULL)  <=>   RemoveHead(pData)
//
//    RemoveHead(NULL,&nBytes) - sets nBytes to the size of the data in the 
//                               head of the list, nothing is removed
//
//    RemoveHead(pData,&nBytes)- copies the data in the head of the list into
//                               pData up to the min of the size of data in the
//                               head of the list or nBytes. The head of the
//                               list is removed. 
//
//----------------------------------------------------------------------------
void
CList::RemoveHead(PVOID pData, PUINT pnBytes)
{
    PLIST tmp;
    UINT  nBytes;

    if (pnBytes == NULL)
    {
        RemoveHead(pData);
        return;
    }

    if (pData == NULL)
    {
        // they just want the size, so return it.

        if (IsEmpty())
            *pnBytes=0;
        else
            *pnBytes=m_pListHead->nBytes;

        return;
    }

    if (IsEmpty())
    {
        *pnBytes=0;
        return;
    }

    // make sure m_pListCurr is always NULL or someplace valid

    if (m_pListCurr == m_pListHead)
        m_pListCurr=m_pListHead->next;

    tmp=m_pListHead;
    m_pListHead=m_pListHead->next;

    //
    // only copy the min size of the two
    //
        
    nBytes=min((*pnBytes),tmp->nBytes);

    if (tmp->pData != NULL)
    {
        CopyMemory(pData,tmp->pData,nBytes);

        *pnBytes=nBytes;

        delete[] (tmp->pData);
    }
    else
        *pnBytes=0;

    delete tmp;

    if (!IsEmpty())
        m_pListHead->prev=NULL;
    else
        m_pListTail=NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\narrator\narrhook\list.h ===
//
// an aribrary list of sized items
//

typedef struct LIST *PLIST;

typedef struct LIST {
    PVOID pData;
    UINT  nBytes;
    PLIST next;
    PLIST prev;
} LIST;

class CList {
    private:
        PLIST m_pListHead;
        PLIST m_pListCurr;
        PLIST m_pListTail;
    public:
        CList();
        ~CList();
        BOOL   IsEmpty() { return (NULL == m_pListHead); }
        void   RemoveAll();
        void   RemoveHead(PVOID pData);
        void   RemoveHead(PVOID pData, PUINT pnBytes);
        BOOL   Add(PVOID pData, UINT nBytes);
        PVOID  PeekHead() { return (IsEmpty() ? NULL : m_pListHead->pData); }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\narrator\narrhook\helpthd.cpp ===
// Copyright (C) 1997-1999 by Microsoft Corporation.  All rights reserved.
// 
// ----------------------------------------------------------------------
// Additions/ Bug fixes 1999 Anil Kumar
// 
// InitMSAA calls InitHelperThread, which creates (duh) a helper thread. 
// In a past version, the WinEventProc would process the WinEvents by 
// calling AccessibleObjectFromEvent on some events, then calling 
// AddEventInfoToStack for all events.
// Problem is that the objects obtained in the main thread cannot be 
// used in the helper thread. So now the helper thread will get it's 
// own IAccessibleObjects when it processes the events, and all 
// IAccessible objects will be created, used, and released by the 
// helper thread.
//

#define STRICT
#include <windows.h>
#include <windowsx.h>
#include <oleacc.h>
#include <objbase.h>

#include "keys.h"       // for ProcessWinEvent
#include "list.h"       // include list.h before helpthd.h, GINFO needs CList
#include "HelpThd.h"

//
// global variables
//
GINFO	gInfo;

//
// Local function prototypes
//
BOOL  OnHelperThreadEvent (void);
DWORD MsgWaitForSingleObject(HANDLE hEvent, DWORD dwTimeout);


/*************************************************************************
    Function:   
    Purpose:    
    Inputs:     
    Returns: 
    History:    
*************************************************************************/
DWORD WINAPI HelperThreadProc(LPVOID lpParameter)
{
HRESULT	hr;
DWORD	dwWakeup;

	// start COM on this thread
    // SteveDon: CoInitializeEx is supported on both Win95 and WinNT, according to 
    // the SDK docs. Exported from ole32.dll, and defined in objbase.h. 
    // The thing is, for it to be defined, _WIN32_WINNT must be #defined and
    // greater than 0x0400. But since CoInitialize(NULL) is equivalent to
    // CoInitializeEx (NULL,COINIT_APARTMENTTHREADED), we'll just do the 
    // former so it works for sure on both 95 and NT
    //
	hr = CoInitialize (NULL);
	if (FAILED (hr))
	{
		DBPRINTF (TEXT("CoInitialize on helper thread returned 0x%lX\r\n"),hr);
		return (hr);
	}

	// GetGUIThreadInfo (called from acc_getState) will fail if both threads 
	// are not on the same desktop.
	SetThreadDesktop(GetThreadDesktop( g_tidMain )); // ROBSI: 10-10-99

    MSG msg;
	while (TRUE)
    {
        DWORD dwObj = WAIT_FAILED;

        dwObj = MsgWaitForMultipleObjects(1, &gInfo.hHelperEvent, FALSE, INFINITE, QS_ALLINPUT );

        // Proccess the WinEvent
		if ( dwObj == WAIT_OBJECT_0 )
		{
			// OnHelperThreadEvent will return FALSE when it gets
			// the EndHelper event, which means we can terminate 
			// the helper thread.
			if (!OnHelperThreadEvent())
			{
			    DBPRINTF( TEXT("Terminating HelperThreadProc") );
            	CoUninitialize();
            	return 0;
			}
	    }				

		// procces messages that are sent to us.  The only message we expect is
		// WM_TIMER message
		while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

    } 

    return 0;
}


/*************************************************************************
    Function:   
    Purpose:    
    Inputs:     
    Returns: 
    History:    
*************************************************************************/
BOOL OnHelperThreadEvent (void)
{
    Sleep(100); // was this added by Paul? Not sure why it is here...

	STACKABLE_EVENT_INFO sei;
	while(RemoveInfoFromStack(&sei))
	{
		switch(sei.m_Action)
		{
			case STACKABLE_EVENT_INFO::EndHelper:
				return (FALSE);

            case STACKABLE_EVENT_INFO::NewEvent:
				__try
				{
					ProcessWinEvent(sei.event, sei.hwndMsg, sei.idObject, 
                                    sei.idChild, sei.idThread, sei.dwmsEventTime);
				}
				__except(EXCEPTION_EXECUTE_HANDLER)
				{
					DBPRINTF(TEXT("ProcessWinEvent Exception event=0x%x, hwndMsg=0x%x, idObject=0x%x, idChild=0x%x, idThread=0x%x, dwmsEventTime=0x%x\r\n"),
					          sei.event, sei.hwndMsg, sei.idObject, sei.idChild, sei.idThread, sei.dwmsEventTime);
				}

				break;
			default:
				break;
		} // end switch sei.m_Action
	} // end while RemoveInfoFromStack
	return (TRUE);
} // end OnHelperThreadEvent

/*************************************************************************
    Function:   
    Purpose:    
    Inputs:     
    Returns: 
    History:    
*************************************************************************/
void AddEventInfoToStack(DWORD event,HWND hwndMsg, LONG idObject, LONG idChild, 
                         DWORD idThread, DWORD dwmsEventTime)
{
	STACKABLE_EVENT_INFO  sei;

	sei.m_Action = STACKABLE_EVENT_INFO::NewEvent;

	sei.event = event;
	sei.hwndMsg = hwndMsg;
	sei.idObject = idObject;
	sei.idChild = idChild;
	sei.idThread = idThread;
	sei.dwmsEventTime = dwmsEventTime;

	EnterCriticalSection(&gInfo.HelperCritSect);

    gInfo.EventInfoList.Add(&sei,sizeof(sei));

	LeaveCriticalSection(&gInfo.HelperCritSect);

	SetEvent(gInfo.hHelperEvent);
}


/*************************************************************************
    Function:   
    Purpose:    
    Inputs:     
    Returns: 
    History:    
*************************************************************************/
BOOL RemoveInfoFromStack(STACKABLE_EVENT_INFO *pEventInfo)
{
	BOOL bReturn = TRUE;

	EnterCriticalSection(&gInfo.HelperCritSect);

    bReturn = !(gInfo.EventInfoList.IsEmpty());

    if (bReturn)
        gInfo.EventInfoList.RemoveHead(pEventInfo);

	LeaveCriticalSection(&gInfo.HelperCritSect);

	return bReturn;

}

/*************************************************************************
    Function:   
    Purpose:    
    Inputs:     
    Returns: 
    History:    
*************************************************************************/
void InitHelperThread()
{
	DWORD dwThreadId;

	g_tidMain = GetCurrentThreadId();	// ROBSI: 10-10-99

	InitializeCriticalSection(&gInfo.HelperCritSect);
	gInfo.hHelperEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	gInfo.hHelperThread = CreateThread(NULL, 0, HelperThreadProc, NULL, 0, 
								 	   &dwThreadId);
}

/*************************************************************************
    Function:   
    Purpose:    
    Inputs:     
    Returns: 
    History:    
*************************************************************************/
void UnInitHelperThread()
{
	STACKABLE_EVENT_INFO  sei;
    
	EnterCriticalSection(&gInfo.HelperCritSect);

	// Force only one event in the queue
    gInfo.EventInfoList.RemoveAll();

	sei.m_Action = STACKABLE_EVENT_INFO::EndHelper;

    gInfo.EventInfoList.Add(&sei,sizeof(sei));

	LeaveCriticalSection(&gInfo.HelperCritSect);

	SetEvent(gInfo.hHelperEvent);

	// Wait for the thread to die
    // note the last sei will be freed by deconstructor

	// Donot wait for eternity here!! Do not care really during Exit!!
	WaitForSingleObject(gInfo.hHelperThread, 3000);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accessib\narrator\narrhook\keys.cpp ===
/*************************************************************************
	Project:    Narrator
    Module:     keys.cpp

    Author:     Paul Blenkhorn
    Date:       April 1997
    
    Notes:      Credit to be given to MSAA team - bits of code have been 
				lifted from:
					Babble, Inspect, and Snapshot.

    Copyright (C) 1997-1998 by Microsoft Corporation.  All rights reserved.
    See bottom of file for disclaimer
    
    History: Add features, Bug fixes : 1999 Anil Kumar
*************************************************************************/
#define STRICT
#include <windows.h>
#include <windowsx.h>
#include <ole2.h>
#include <ole2ver.h>
#include <commctrl.h>
#include "commdlg.h"
#include <string.h>
#include <initguid.h>
#include <oleacc.h>
#include <TCHAR.H>
#include "..\Narrator\Narrator.h"
#include "keys.h"
#include "w95trace.c"
#include "getprop.h"
#include "..\Narrator\resource.h"
#include "resource.h"

#include "list.h"       // include list.h before helpthd.h, GINFO needs CList
#include "HelpThd.h"
#include <stdio.h>
#include "mappedfile.cpp"

template<class _Ty> class CAutoArray 
{
public:
	explicit CAutoArray(_Ty *_P = 0) : _Ptr(_P) {}
	~CAutoArray()
	{
	    if ( _Ptr )
    	    delete [] _Ptr; 
	}
	_Ty *Get() 
	{
	    return _Ptr; 
	}
private:
	_Ty *_Ptr;
};

#define ARRAYSIZE(x)   (sizeof(x) / sizeof(*x))

// ROBSI: 99-10-09
#define MAX_NAME 4196 // 4K (beyond Max of MSAA)
#define MAX_VALUE 512

// When building with VC5, we need winable.h since the active
// accessibility structures are not in VC5's winuser.h.  winable.h can
// be found in the active accessibility SDK
#ifdef VC5_BUILD___NOT_NT_BUILD_ENVIRONMENT
#include <winable.h>
#endif

#define STATE_MASK (STATE_SYSTEM_CHECKED | STATE_SYSTEM_MIXED | STATE_SYSTEM_READONLY | STATE_SYSTEM_BUSY | STATE_SYSTEM_MARQUEED | STATE_SYSTEM_ANIMATED | STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_UNAVAILABLE)

	  
// Local functions
void Home(int x);
void MoveToEnd(int x);
void SpeakKeyboard(int nOption);
void SpeakWindow(int nOption);
void SpeakRepeat(int nOption);
void SpeakItem(int nOption);
void SpeakMainItems(int nOption);
void SpeakMute(int nOption);
void GetObjectProperty(IAccessible*, long, int, LPTSTR, UINT);
void AddAccessibleObjects(IAccessible*, const VARIANT &);
BOOL AddItem(IAccessible*, const VARIANT &);
void SpeakObjectInfo(LPOBJINFO poiObj, BOOL SpeakExtra);
BOOL Object_Normalize( IAccessible *    pAcc,
                       VARIANT *        pvarChild,
                       IAccessible **   ppAccOut,
                       VARIANT *        pvarChildOut);
_inline void InitChildSelf(VARIANT *pvar)
{
    pvar->vt = VT_I4;
    pvar->lVal = CHILDID_SELF;
}

// MSAA event handlers
BOOL OnFocusChangedEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild, 
                         DWORD dwmsTimeStamp);
BOOL OnValueChangedEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild, 
                         DWORD dwmsTimeStamp);
BOOL OnSelectChangedEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild, 
                          DWORD dwmsTimeStamp);
BOOL OnLocationChangedEvent(DWORD event, HWND hwnd, LONG idObject, 
                            LONG idChild, DWORD dwmsTimeStamp);
BOOL OnStateChangedEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild, 
                         DWORD dwmsTimeStamp);
BOOL OnObjectShowEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild, 
                         DWORD dwmsTimeStamp);

// More local routines
LRESULT CALLBACK KeyboardProc(int code, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK MouseProc(int code, WPARAM wParam, LPARAM lParam);
BOOL IsFocussedItem( HWND hWnd, IAccessible * pAcc, VARIANT varChild );
void FilterGUID(TCHAR* szSpeak); 

// Hot keys
HOTK rgHotKeys[] =
{   //Key       SHIFT					Function            Parameter
    { VK_F12,     MSR_CTRL | MSR_SHIFT,	SpeakKeyboard,          0},  
    { VK_SPACE, MSR_CTRL | MSR_SHIFT,   SpeakWindow,            1},  
    { VK_RETURN,MSR_CTRL | MSR_SHIFT,	SpeakMainItems,         0},  
    { VK_INSERT,MSR_CTRL | MSR_SHIFT,   SpeakItem,              0}, 
    { VK_HOME,	MSR_ALT,				Home,					0},  
    { VK_END,	MSR_ALT,				MoveToEnd,				0},  
};

// a-anilk: this is better than defining as a constant - you don't have to worry
// about making the table and the count match up.
#define CKEYS_HOT (sizeof(rgHotKeys)/sizeof(HOTK))


#define MSR_DONOWT   0
#define MSR_DOCHAR   1
#define MSR_DOWORD	 2
#define MSR_DOLINE	 3
#define MSR_DOLINED  4
#define MSR_DOCHARR  5
#define MSR_DOWORDR  6


#define MSR_DOOBJECT 4
#define MSR_DOWINDOW 5
#define MAX_TEXT_ROLE 128

HHOOK           g_hhookKey = 0;
HHOOK           g_hhookMouse = 0;
HWINEVENTHOOK   g_hEventHook = 0;

POINT   g_ptMoveCursor = {0,0};
UINT_PTR g_uTimer = 0;

// Global Variables stored in memory mapped file

struct GLOBALDATA
{
	int nAutoRead; // Did we get to ReadWindow through focus change or CTRL_ALT_SPACE flag
	int nSpeakWindowSoon; // Flag to indicate the we have a new window ... speak it when sensible

	int nLeftHandSide; // Store left hand side of HTML window we want to read
	BOOL fDoingPassword;
	int nMsrDoNext; // keyboard flag set when curor keys are used ... let us know what to read when caret has moved

	HWND    hwndMSR;

	// Global variables to control events and speech
	BOOL    fInternetExplorer;
	BOOL    fHTML_Help;
	UINT    uMSG_MSR_Cursor;
	POINT   ptCurrentMouse;
	BOOL    fMouseUp;			// flag for mouse up/down
	HWND    hwndHelp;
	BOOL    fJustHadSpace;
	BOOL    fJustHadShiftKeys;
	BOOL	fListFocus;		// To avoid double speaking of list items...
	BOOL	fStartPressed;
	TCHAR   pszTextLocal[2000]; // PB: 22 Nov 1998.  Make it work!!! Make this Global and Shared!

    // Global data that used to be exported from the DLL
    TCHAR szCurrentText[MAX_TEXT];
    int fTrackSecondary;
    int fTrackCaret;
    int fTrackInputFocus;
    int nEchoChars;
    int fAnnounceWindow;
    int fAnnounceMenu;
    int fAnnouncePopup;
    int fAnnounceToolTips;
    int fReviewStyle;
    int nReviewLevel;
};

// pointer to shared global data
GLOBALDATA *g_pGlobalData = 0;
      
// pointer to mem mapped file handle
CMemMappedFile *g_CMappedFile = 0;                       

// the number of times to try to create mem mapped file must be < 10          
const int c_cMappedFileTries = 3;

// name of memory mapped file
TCHAR g_szMappedFileName[] = TEXT("NarratorShared0");

// mutex to access mem mapped file and wait time
TCHAR g_szMutexNarrator[] = TEXT("NarratorMutex0");
const int c_nMutexWait = 5000;

void InitGlobalData()
{
    CScopeMutex csMutex;
    if (csMutex.Create(g_szMutexNarrator, c_nMutexWait) && g_pGlobalData)
    {
        DBPRINTF(TEXT("InitGlobalData\r\n"));
		g_pGlobalData->nMsrDoNext = MSR_DONOWT; // keyboard flag set when curor keys are used
		g_pGlobalData->ptCurrentMouse.x = -1;
		g_pGlobalData->ptCurrentMouse.y = -1;
		g_pGlobalData->fMouseUp = TRUE;		// flag for mouse up/down
        g_pGlobalData->fTrackSecondary = TRUE;
        g_pGlobalData->fTrackCaret = TRUE;
        g_pGlobalData->fTrackInputFocus = FALSE;
        g_pGlobalData->nEchoChars = MSR_ECHOALNUM | MSR_ECHOSPACE | MSR_ECHODELETE | MSR_ECHOMODIFIERS | MSR_ECHOENTER | MSR_ECHOBACK | MSR_ECHOTAB;
        g_pGlobalData->fAnnounceWindow = TRUE;
        g_pGlobalData->fAnnounceMenu = TRUE;
        g_pGlobalData->fAnnouncePopup = TRUE;
        g_pGlobalData->fAnnounceToolTips = FALSE; // this ain't working properly - taken out!
        g_pGlobalData->fReviewStyle = TRUE;
        g_pGlobalData->nReviewLevel = 0;
	}
}

BOOL CreateMappedFile()
{
    g_CMappedFile = new CMemMappedFile;
    if (g_CMappedFile)
    {
        // Append a number thus avoiding restart timing issue 
        // on desktop switches but only try 3 times

        // ISSUE (micw 08/22/00) 
        // - this code has potential problem of ending up with two or more mapped
        // files open.  A mapped file for narrator and one for each hook.  Hooks will
        // cause the DLL to get loaded for that process.  If narrator has NarratorShared1
        // opened and the hook loads this DLL then the hooked process will have
        // NarratorShared0 open.  Could use narrator's hwnd as the thing to append to the
        // file and mutex name.  This code could find the narrator hwnd and use that to
        // open.  Letting this go for now since the above hasn't been observed in testing.

        int iPos1 = lstrlen(g_szMappedFileName) - 1;
        int iPos2 = lstrlen(g_szMutexNarrator) - 1;
        for (int i=0;i<c_cMappedFileTries;i++)
        {
            if (TRUE == g_CMappedFile->Open(g_szMappedFileName, sizeof(GLOBALDATA)))
            {
                CScopeMutex csMutex;
                if (csMutex.Create(g_szMutexNarrator, c_nMutexWait))
                {
                    g_CMappedFile->AccessMem((void **)&g_pGlobalData);
                    if (g_CMappedFile->FirstOpen())
                        InitGlobalData();
                    DBPRINTF(TEXT("CreateMappedFile:  Succeeded %d try!\r\n"), i);
                    return TRUE;
                }
                g_CMappedFile->Close();
                break;  // fail if get to here
            }
            Sleep(500);
            g_szMappedFileName[iPos1] = '1'+i;
            g_szMutexNarrator[iPos2] = '1'+i;
        }
    }
    DBPRINTF(TEXT("CreateMappedFile:  Unable to create the mapped file!\r\n"));
    return FALSE;
}
void CloseMappedFile()
{
    if (g_CMappedFile)
    {
        g_CMappedFile->Close();
        delete g_CMappedFile;
        g_CMappedFile = 0;
    }
}

//
// Accessor functions for what used to be exported, shared, variables
//

#define SIMPLE_FUNC_IMPL(type, prefix, name, error) \
type Get ## name() \
{ \
    CScopeMutex csMutex; \
    if (csMutex.Create(g_szMutexNarrator, c_nMutexWait)) \
    { \
        return g_pGlobalData->prefix ## name; \
    } else \
    { \
        return error; \
    } \
} \
void Set ## name(type value) \
{ \
    CScopeMutex csMutex; \
    if (csMutex.Create(g_szMutexNarrator, c_nMutexWait)) \
    { \
        g_pGlobalData->prefix ## name = value; \
    } \
}

SIMPLE_FUNC_IMPL(BOOL, f, TrackSecondary,   FALSE)
SIMPLE_FUNC_IMPL(BOOL, f, TrackCaret,       FALSE)
SIMPLE_FUNC_IMPL(BOOL, f, TrackInputFocus,  FALSE)
SIMPLE_FUNC_IMPL(int,  n, EchoChars,        0)
SIMPLE_FUNC_IMPL(BOOL, f, AnnounceWindow,   FALSE)
SIMPLE_FUNC_IMPL(BOOL, f, AnnounceMenu,     FALSE)
SIMPLE_FUNC_IMPL(BOOL, f, AnnouncePopup,    FALSE)
SIMPLE_FUNC_IMPL(BOOL, f, AnnounceToolTips, FALSE)
SIMPLE_FUNC_IMPL(BOOL, f, ReviewStyle,      FALSE)
SIMPLE_FUNC_IMPL(int,  n, ReviewLevel,      0)

void GetCurrentText(LPTSTR psz, int cch)
{
    CScopeMutex csMutex;
    if (csMutex.Create(g_szMutexNarrator, c_nMutexWait))
    {
        lstrcpyn(psz, g_pGlobalData->szCurrentText, cch);
        psz[cch-1] = TEXT('\0');
    }
}
void SetCurrentText(LPCTSTR psz)
{
    CScopeMutex csMutex;
    if (csMutex.Create(g_szMutexNarrator, c_nMutexWait))
    {
        lstrcpyn(g_pGlobalData->szCurrentText, psz, MAX_TEXT);
        g_pGlobalData->szCurrentText[MAX_TEXT-1] = TEXT('\0');
    }
}

HINSTANCE g_Hinst = NULL;
DWORD	  g_tidMain=0;	// ROBSI: 10-10-99

// These are class names, This could change from one OS to another and in 
// different OS releases.I have grouped them here : Anil.
// These names may have to changed for Win9x and other releases
#define CLASS_WINSWITCH		TEXT("#32771")  // This is WinSwitch class. Disguises itself :-)AK
#define CLASS_HTMLHELP_IE	TEXT("HTML_Internet Explorer")
#define CLASS_IE_FRAME		TEXT("IEFrame")
#define CLASS_IE_MAINWND	TEXT("Internet Explorer_Server")
#define CLASS_LISTVIEW		TEXT("SysListView32")
#define CLASS_HTMLHELP		TEXT("HH Parent")
#define CLASS_TOOLBAR		TEXT("ToolbarWindow32")
#define CLASS_MS_WINNOTE	TEXT("MS_WINNOTE")
#define CLASS_HH_POPUP  	TEXT("hh_popup")


BOOL IsTridentWindow( LPCTSTR szClass )
{
    return lstrcmpi(szClass, CLASS_HTMLHELP_IE) == 0
        || lstrcmpi(szClass, CLASS_IE_FRAME) == 0
        || lstrcmpi(szClass, CLASS_IE_MAINWND) == 0
        || lstrcmpi(szClass, TEXT("PCHShell Window")) == 0 // Help & Support
        || lstrcmpi(szClass, TEXT("Internet Explorer_TridentDlgFrame")) == 0; // Trident popup windows
}


// Check if the pAcc, varChild refer to a balloon tip. If so, it places the corresponding
// IAccessible and childID in the out ppAcc/pvarChild params.
// The in pAcc/varChild params are always consumed, so should not be freed by caller.
BOOL CheckIsBalloonTipElseRelease( IAccessible * pAcc, VARIANT varChild, IAccessible ** ppAcc, VARIANT * pvarChild )
{
    VARIANT varRole;

    HRESULT hr = pAcc->get_accRole( varChild, &varRole );
    if ( hr == S_OK && varRole.vt == VT_I4 && 
       ( varRole.lVal == ROLE_SYSTEM_TOOLTIP || varRole.lVal == ROLE_SYSTEM_HELPBALLOON ) )
    {
        // Got it...
        *ppAcc = pAcc;
        pvarChild->vt = VT_I4;
        pvarChild->lVal = CHILDID_SELF;
        return TRUE;
    }

    pAcc->Release();
    return FALSE;
}

IAccessible * GetFocusedIAccessibile( HWND hwndFocus, VARIANT * varChild )
{

	IAccessible	*pIAcc = NULL;
	HRESULT hr = AccessibleObjectFromWindow(hwndFocus, OBJID_CLIENT, 
											IID_IAccessible, (void**)&pIAcc);
	InitChildSelf(varChild);
	
	if (S_OK == hr)
	{
        while ( pIAcc )
        {
    		HRESULT hr = pIAcc->get_accFocus(varChild);
    		switch ( varChild->vt )
    		{
        		case VT_I4:
        		    return pIAcc;
           		    break;

           		case VT_DISPATCH:
           		{
                    IAccessible * pAccTemp = NULL;

                    hr = varChild->pdispVal->QueryInterface( IID_IAccessible, (void**) &pAccTemp );
                    VariantClear( varChild );
                    pIAcc->Release();
                    if ( hr != S_OK )
                    {
                        pIAcc = NULL;
                        break;
                    }
                    pIAcc = pAccTemp;

                    break;
           		}
           		
                default:
                    pIAcc->Release();
                    pIAcc = NULL;
                    break;

    		}
        }
	}

    return NULL;
}

/*************************************************************************
    Function:   SpeakString
    Purpose:    Send speak string message back to original application
    Inputs:     TCHAR *str
    Returns:    void
    History:

    Uses sendmessage to avoid other messages firing and overwriting this one.

*************************************************************************/
void SpeakString(TCHAR * str)
{
    DBPRINTF(TEXT("SpeakString '%s'\r\n"), str);
    lstrcpyn(g_pGlobalData->szCurrentText,str,MAX_TEXT);
    g_pGlobalData->szCurrentText[MAX_TEXT-1] = TEXT('\0');
	SendMessage(g_pGlobalData->hwndMSR, WM_MSRSPEAK, 0, 0);
}

/*************************************************************************
    Function:   SpeakStr
    Purpose:    Send speak string message back to original application
    Inputs:     TCHAR *str
    Returns:    void
    History:
    
    This one uses Postmessage to make focus change work for ALT-TAB???????

*************************************************************************/
void SpeakStr(TCHAR * str)
{
    lstrcpyn(g_pGlobalData->szCurrentText,str,MAX_TEXT);
    g_pGlobalData->szCurrentText[MAX_TEXT-1] = TEXT('\0');
	PostMessage(g_pGlobalData->hwndMSR, WM_MSRSPEAK, 0, 0);
}


/*************************************************************************
    Function:   SpeakStringAll
    Purpose:    Speak the string, but put out a space first to make sure the
                string is fresh - i.e. stop duplicate string pruning from 
                occuring
    Inputs:     TCHAR *str
    Returns:    void
    History:
*************************************************************************/
void SpeakStringAll(TCHAR * str)
{
    SpeakString(TEXT(" ")); // stop speech filter losing duplicates
    SpeakString(str);
}

/*************************************************************************
    Function:   SpeakStringId
    Purpose:    Speak a string loaded as a resource ID
    Inputs:     UINT id
    Returns:    void
    History:
*************************************************************************/
void SpeakStringId(UINT id)
{
	if (LoadString(g_Hinst, id, g_pGlobalData->szCurrentText, 256) == 0)
	{
		DBPRINTF (TEXT("LoadString failed on hinst %lX id %u\r\n"),g_Hinst,id);
		SpeakString(TEXT("TEXT NOT FOUND!"));
	}
	else 
    {
		SendMessage(g_pGlobalData->hwndMSR, WM_MSRSPEAK, 0, 0);
		SpeakString(TEXT(" ")); // stop speech filter losing duplicates
	}
}


/*************************************************************************
    Function:   SetSecondary
    Purpose:    Set secondary focus position & posibly move mouse pointer
    Inputs:     Position: x & y
				Whether to move cursor: MoveCursor
    Returns:    void
    History:
*************************************************************************/
void SetSecondary(long x, long y, int MoveCursor)
{
	g_pGlobalData->ptCurrentMouse.x = x;
	g_pGlobalData->ptCurrentMouse.y = y;
	if (MoveCursor)
	{
		// Check if co-ordinates are valid, At many places causes 
		// the cursor to vanish...
		if ( x > 0 && y > 0 )
			SetCursorPos(x,y);
	}

	// Tell everyone where the cursor is.
	// g_pGlobalData->uMSG_MSR_Cursor set using RegisterWindowMessage below in InitMSAA
	SendMessage(HWND_BROADCAST,g_pGlobalData->uMSG_MSR_Cursor,x,y);
}

/*************************************************************************
    Function:   TrackCursor
    Purpose:   This is a callback in responce to a SetTimer it calls SetSecondary 
              then kills the timer and resets the global timer flag.
    Returns:    void
    History:
*************************************************************************/
VOID CALLBACK TrackCursor(HWND hwnd,         // handle to window
                             UINT uMsg,         // WM_TIMER message
                             UINT_PTR idEvent,  // timer identifier
                             DWORD dwTime )      // current system time
{
    
    KillTimer( NULL, g_uTimer );
    g_uTimer = 0;
    SetSecondary(g_ptMoveCursor.x, g_ptMoveCursor.y, TRUE);
	
	return;
}

VOID GetStateString(LONG lState,        
                      LONG lStateMask,    
                      LPTSTR szState, 
                      UINT cchState )      
{
        int     iStateBit;
        DWORD   lStateBits;
        LPTSTR  lpszT;
        UINT    cchT;
        bool fFirstTime = true;
        cchState -= 1; // leave room for the null
        if ( !szState )
            return;

        *szState = TEXT('\0');

        for ( iStateBit = 0, lStateBits = 1; iStateBit < 32; iStateBit++, (lStateBits <<= 1) )
        {
            if ( !fFirstTime && cchState > 2)
            {
                *szState++ = TEXT(',');
                *szState++ = TEXT(' ');
                cchState -= 2;
            }
            *szState = TEXT('\0');  // make sure we are always null terminated
            if (lState & lStateBits & lStateMask)
            {
                cchT = GetStateText(lStateBits, szState, cchState);
                szState += cchT;
                cchState -= cchT;
                fFirstTime = false;
            }
        }
}

/*************************************************************************
    Function:   BackToApplication
    Purpose:    Set the focus back to the application that we came from with F12
    Inputs:     void
    Returns:    void
    History:
*************************************************************************/
void BackToApplication(void)
{
	CScopeMutex csMutex;
	if (csMutex.Create(g_szMutexNarrator, c_nMutexWait))
	    SetForegroundWindow(g_pGlobalData->hwndHelp);
}


/*************************************************************************
    Function:   InitKeys
    Purpose:    Set up processing for global hot keys
    Inputs:     HWND hwnd
    Returns:    BOOL - TRUE if successful
    History:
*************************************************************************/
BOOL InitKeys(HWND hwnd)
{
    HMODULE hModSelf;

	CScopeMutex csMutex;
	if (!csMutex.Create(g_szMutexNarrator, c_nMutexWait))
		return FALSE;

    // If someone else has a hook installed, fail.
    if (g_pGlobalData->hwndMSR)
        return FALSE;

    // Save off the hwnd to send messages to
    g_pGlobalData->hwndMSR = hwnd;
    DBPRINTF(TEXT("InitKeys:  hwndMSR = 0x%x hwnd = 0x%x\r\n"), g_pGlobalData->hwndMSR, hwnd);
    // Get the module handle for this DLL
    hModSelf = GetModuleHandle(TEXT("NarrHook.dll"));

    if(!hModSelf)
        return FALSE;
    
    // Set up the global keyboard hook
    g_hhookKey = SetWindowsHookEx(WH_KEYBOARD, // What kind of hook
                                KeyboardProc,// Proc to send to
                                hModSelf,    // Our Module
                                0);          // For all threads

    // and set up the global mouse hook
    g_hhookMouse = SetWindowsHookEx(WH_MOUSE,  // What kind of hook
                                  MouseProc, // Proc to send to
                                  hModSelf,  // Our Module
                                  0);        // For all threads

    // Return TRUE|FALSE based on result
    return g_hhookKey != NULL && g_hhookMouse != NULL;
}


/*************************************************************************
    Function:   UninitKeys
    Purpose:    Deinstall the hooks
    Inputs:     void
    Returns:    BOOL - TRUE if successful
    History:
*************************************************************************/
BOOL UninitKeys(void)
{
	CScopeMutex csMutex;
	if (!csMutex.Create(g_szMutexNarrator, c_nMutexWait))
		return FALSE;

    // Reset
    DBPRINTF(TEXT("UninitKeys setting hwndMSR NULL\r\n"));
    g_pGlobalData->hwndMSR = NULL;

    // Unhook keyboard if that was hooked
    if (g_hhookKey)
    {
        UnhookWindowsHookEx(g_hhookKey);
        g_hhookKey = NULL;
    }

    // Unhook mouse if that was hooked
    if (g_hhookMouse) 
    {
		UnhookWindowsHookEx(g_hhookMouse);
		g_hhookMouse = NULL;
    }

    return TRUE;
}


/*************************************************************************
    Function:   KeyboardProc
    Purpose:    Gets called for keys hit
    Inputs:     void
    Returns:    BOOL - TRUE if successful
    History:
*************************************************************************/
LRESULT CALLBACK KeyboardProc(int code,	        // hook code
                              WPARAM wParam,    // virtual-key code
                              LPARAM lParam)    // keystroke-message information
{
    int		state = 0;
    int		ihotk;

	g_pGlobalData->fDoingPassword = FALSE;

    if (code == HC_ACTION)
    {
        // If this is a key up, bail out now.
        if (!(lParam & 0x80000000))
        {
            g_pGlobalData->fMouseUp = TRUE;
            g_pGlobalData->nSpeakWindowSoon = FALSE;
            g_pGlobalData->fJustHadSpace = FALSE;
            if (lParam & 0x20000000) 
            { // get ALT state
                state = MSR_ALT;
                SpeakMute(0);
            }
            
            if (GetKeyState(VK_SHIFT) < 0)
                state |= MSR_SHIFT;
            
            if (GetKeyState(VK_CONTROL) < 0)
                state |= MSR_CTRL;
            
            for (ihotk = 0; ihotk < CKEYS_HOT; ihotk++)
            {
                if ((rgHotKeys[ihotk].keyVal == wParam) && 
                    (state == rgHotKeys[ihotk].status))
                {
                    // Call the function
                    SpeakMute(0);
                    (*rgHotKeys[ihotk].lFunction)(rgHotKeys[ihotk].nOption);
                    return(1);
                }
            }


// ROBSI: 10-11-99 -- Work Item: Should be able to use the code in OnFocusChangedEvent
//								 that sets the fDoingPassword flag, but that means 
//								 changing the handling of StateChangeEvents to prevent
//								 calling OnFocusChangedEvent. For now, we'll just use
//								 call GetGUIThreadInfo to determine the focused window
//								 and then rely on OLEACC to tell us if it is a PWD field.
			// ROBSI <begin>
			HWND			hwndFocus = NULL;
			GUITHREADINFO	gui;

			// Use the foreground thread.  If nobody is the foreground, nobody has
			// the focus either.
			gui.cbSize = sizeof(GUITHREADINFO);
			if ( GetGUIThreadInfo(0, &gui) )
			{
				hwndFocus = gui.hwndFocus;
			}

			if (hwndFocus != NULL) 
			{
				// Use OLEACC to detect password fields. It turns out to be more 
				// reliable than SendMessage(GetFocus(), EM_GETPASSWORDCHAR, 0, 0L).
        		VARIANT varChild;
				IAccessible *pIAcc = GetFocusedIAccessibile( hwndFocus, &varChild );
				if ( pIAcc )
				{
					// Test the password bit...
					VARIANT varState;
					VariantInit(&varState); 

					HRESULT hr = pIAcc->get_accState(varChild, &varState);

					if ((S_OK == hr) && (varState.vt == VT_I4) && (varState.lVal & STATE_SYSTEM_PROTECTED))
					{
						g_pGlobalData->fDoingPassword = TRUE;
					}
					
    				pIAcc->Release();
				}

				// ROBSI: OLEACC does not always properly detect password fields.
				// Therefore, we use Win32 as a backup.
				if (!g_pGlobalData->fDoingPassword)
				{
					TCHAR   szClassName[256];

					// Verify this control is an Edit or RichEdit control to avoid 
					// sending EM_ messages to random controls.
					// POTENTIAL BUG? If login dialog changes to another class, we'll break.
					if ( RealGetWindowClass( hwndFocus, szClassName, ARRAYSIZE(szClassName)) )
					{
						if ((0 == lstrcmp(szClassName, TEXT("Edit")))		||
							(0 == lstrcmp(szClassName, TEXT("RICHEDIT")))	||
							(0 == lstrcmp(szClassName, TEXT("RichEdit20A")))	||
							(0 == lstrcmp(szClassName, TEXT("RichEdit20W"))) 
						   )
						{
							g_pGlobalData->fDoingPassword = (SendMessage(hwndFocus, EM_GETPASSWORDCHAR, 0, 0L) != NULL);
						}
					}
				}

			}
			
			// ROBSI <end>

			if (g_pGlobalData->fDoingPassword)
			{
				// ROBSI: 10-11-99
				// Go ahead and speak keys that are not printable but will
				// help the user understand what state they are in.
				switch (wParam)
				{
					case VK_CAPITAL:
						if (g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS)
						{
							SpeakMute(0);
							if ( GetKeyState(VK_CAPITAL) & 0x0F )
								SpeakStringId(IDS_CAPS_ON);
							else
								SpeakStringId(IDS_CAPS_OFF);
						}
						break;

					case VK_NUMLOCK:
						if (g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS)
						{
							SpeakMute(0);
							if ( GetKeyState(VK_NUMLOCK) & 0x0F )
								SpeakStringId(IDS_NUM_ON);
							else
								SpeakStringId(IDS_NUM_OFF);
						}
						break;

					case VK_DELETE:
						if (g_pGlobalData->nEchoChars & MSR_ECHODELETE)
						{
							SpeakMute(0);
							SpeakStringId(IDS_DELETE);
						}
						break;

					case VK_INSERT:
						if (g_pGlobalData->nEchoChars & MSR_ECHODELETE)
						{
							SpeakMute(0);
							SpeakStringId(IDS_INSERT);
						}
						break;

					case VK_BACK:
						if (g_pGlobalData->nEchoChars & MSR_ECHOBACK)
						{
							SpeakMute(0);
							SpeakStringId(IDS_BACKSPACE);
						}
						break;

					case VK_TAB:
						SpeakMute(0);

						if (g_pGlobalData->nEchoChars & MSR_ECHOTAB)
							SpeakStringId(IDS_TAB);
						break;

					case VK_CONTROL:
						SpeakMute(0); // always mute when control held down!

						if ((g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS) && !(g_pGlobalData->fJustHadShiftKeys & MSR_CTRL))
						{
							SpeakStringId(IDS_CONTROL);
							// ROBSI: Commenting out to avoid modifying Global State
							// g_pGlobalData->fJustHadShiftKeys |= MSR_CTRL;  
						}
						break;

					default:
						SpeakMute(0);
						SpeakStringId(IDS_PASS);
						break;
				}

			    return (CallNextHookEx(g_hhookKey, code, wParam, lParam));
			}


            TCHAR buff[20];
            BYTE KeyState[256];
            UINT ScanCode;
            GetKeyboardState(KeyState);
            
            if ((g_pGlobalData->nEchoChars & MSR_ECHOALNUM) && 
                (ScanCode = MapVirtualKeyEx((UINT)wParam, 2,GetKeyboardLayout(0)))) 
            {
#ifdef UNICODE
                ToUnicode((UINT)wParam,ScanCode,KeyState, buff,10,0);
#else
                ToAscii((UINT)wParam,ScanCode,KeyState,(unsigned short *)buff,0);
#endif
                
                // Use 'GetStringTypeEx()' instead of _istprint()
                buff[1] = 0;
                WORD wCharType;
                WORD fPrintable = C1_UPPER|C1_LOWER|C1_DIGIT|C1_SPACE|C1_PUNCT|C1_BLANK|C1_XDIGIT|C1_ALPHA;
                
                GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, buff, 1, &wCharType);
                if (wCharType & fPrintable)
				{
					SpeakMute(0);
					SpeakStringAll(buff);
				}
            }

			// All new: Add speech for all keys...AK
            switch (wParam) {
            case VK_SPACE:
                g_pGlobalData->fJustHadSpace = TRUE;
                if (g_pGlobalData->nEchoChars & MSR_ECHOSPACE)
				{
					SpeakMute(0);
					SpeakStringId(IDS_SPACE);
				}
                break;

			case VK_LWIN:
			case VK_RWIN:
                if (g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS)
				{
					SpeakMute(0);
					g_pGlobalData->fStartPressed = TRUE;
                    SpeakStringId(IDS_WINKEY);
				}
				break;

			case VK_CAPITAL:
                if (g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS)
				{
					SpeakMute(0);
					if ( GetKeyState(VK_CAPITAL) & 0x0F )
						SpeakStringId(IDS_CAPS_ON);
					else
						SpeakStringId(IDS_CAPS_OFF);
				}
				break;

			case VK_SNAPSHOT:
                if (g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS)
				{
					SpeakMute(0);
					SpeakStringId(IDS_PRINT);
				}
				break;

			case VK_ESCAPE:
                if (g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS)
				{
					SpeakMute(0);
					SpeakStringId(IDS_ESC);
				}
				break;

			case VK_NUMLOCK:
                if (g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS)
				{
					SpeakMute(0);
					if ( GetKeyState(VK_NUMLOCK) & 0x0F )
						SpeakStringId(IDS_NUM_ON);
					else
						SpeakStringId(IDS_NUM_OFF);
				}
				break;

            case VK_DELETE:
                if (g_pGlobalData->nEchoChars & MSR_ECHODELETE)
				{
					SpeakMute(0);
                    SpeakStringId(IDS_DELETE);
				}
                break;

			case VK_INSERT:
                if (g_pGlobalData->nEchoChars & MSR_ECHODELETE)
				{
					SpeakMute(0);
                    SpeakStringId(IDS_INSERT);
				}
				break;

			case VK_HOME:
                if (g_pGlobalData->nEchoChars & MSR_ECHODELETE)
				{
					SpeakMute(0);
                    SpeakStringId(IDS_HOME);
				}
				break;

			case VK_END:
                if (g_pGlobalData->nEchoChars & MSR_ECHODELETE)
				{
					SpeakMute(0);
                    SpeakStringId(IDS_END);
				}
				break;

			case VK_PRIOR:
                if (g_pGlobalData->nEchoChars & MSR_ECHODELETE)
				{
					SpeakMute(0);
                    SpeakStringId(IDS_PAGEUP);
				}
				break;

			case VK_NEXT:
                if (g_pGlobalData->nEchoChars & MSR_ECHODELETE)
				{
					SpeakMute(0);
                    SpeakStringId(IDS_PAGEDOWN);
				}
				break;

            case VK_BACK:
                if (g_pGlobalData->nEchoChars & MSR_ECHOBACK)
				{
					SpeakMute(0);
                    SpeakStringId(IDS_BACKSPACE);
				}
                break;

            case VK_TAB:
                SpeakMute(0);

                if (g_pGlobalData->nEchoChars & MSR_ECHOTAB)
                    SpeakStringId(IDS_TAB);
                break;

            case VK_CONTROL:
                SpeakMute(0); // always mute when control held down!

                if ((g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS) && !(g_pGlobalData->fJustHadShiftKeys & MSR_CTRL))
                {
                    SpeakStringId(IDS_CONTROL);
                    g_pGlobalData->fJustHadShiftKeys |= MSR_CTRL;
                }
                break;

            case VK_MENU:
                if ((g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS) && !(g_pGlobalData->fJustHadShiftKeys & MSR_ALT))
				{
					SpeakMute(0);
                    SpeakStringId(IDS_ALT);
				}
                break;

            case VK_SHIFT:
                if ((g_pGlobalData->nEchoChars & MSR_ECHOMODIFIERS) && !(g_pGlobalData->fJustHadShiftKeys & MSR_SHIFT))
				{
					SpeakMute(0);
	                SpeakStringId(IDS_SHIFT);
                    g_pGlobalData->fJustHadShiftKeys |= MSR_SHIFT;
				}
                break;

            case VK_RETURN:
                if (g_pGlobalData->nEchoChars & MSR_ECHOENTER)
				{
					SpeakMute(0);
                    SpeakStringId(IDS_RETURN);
				}
                break;
            }
            
            // set flags for moving around edit controls
            g_pGlobalData->nMsrDoNext = MSR_DONOWT; 

			if (state == MSR_CTRL && (wParam == VK_LEFT || wParam == VK_RIGHT))
			{
				SpeakMute(0);
				g_pGlobalData->nMsrDoNext = MSR_DOWORD;
			}
			else if ((state & MSR_CTRL) && (state & MSR_SHIFT) && (wParam == VK_LEFT))
				g_pGlobalData->nMsrDoNext = MSR_DOWORD;
			else if ((state & MSR_CTRL) && (state & MSR_SHIFT) && (wParam == VK_RIGHT))
				g_pGlobalData->nMsrDoNext = MSR_DOWORDR;
			else if ((state & MSR_SHIFT) && (wParam == VK_LEFT)) 
				g_pGlobalData->nMsrDoNext = MSR_DOCHAR;
			else if ((state & MSR_SHIFT) && (wParam == VK_RIGHT)) 
				g_pGlobalData->nMsrDoNext = MSR_DOCHARR;
			else if ((state & MSR_CTRL) && (wParam == VK_UP || wParam == VK_DOWN))
				g_pGlobalData->nMsrDoNext = MSR_DOLINE;
			else if ((state & MSR_SHIFT) && (wParam == VK_UP))
				g_pGlobalData->nMsrDoNext = MSR_DOLINE;
			else if ((state & MSR_SHIFT) && (wParam == VK_DOWN))
				g_pGlobalData->nMsrDoNext = MSR_DOLINED;
			else if (state == 0) 
			{ // i.e. no shift keys
				switch (wParam) 
				{
					case VK_LEFT: 
					case VK_RIGHT:
						g_pGlobalData->nMsrDoNext = MSR_DOCHAR;
						SpeakMute(0);
						break;
            
					case VK_DOWN: 
					case VK_UP:
						g_pGlobalData->nMsrDoNext = MSR_DOLINE;
						SpeakMute(0);
						break;

					case VK_F3:
						if (GetForegroundWindow() == g_pGlobalData->hwndMSR) 
						{
							PostMessage(g_pGlobalData->hwndMSR, WM_MSRCONFIGURE, 0, 0);
							return(1);
						}
						break;
            
					case VK_F9:
						if (GetForegroundWindow() == g_pGlobalData->hwndMSR) 
						{
							PostMessage(g_pGlobalData->hwndMSR, WM_MSRQUIT, 0, 0);
							return(1);
						}
						 break;
				} // end switch wParam (keycode)
			} // end if no shift keys pressed
        } // end if key down
    } // end if code == HC_ACTION
    g_pGlobalData->fJustHadShiftKeys = state;

    return (CallNextHookEx(g_hhookKey, code, wParam, lParam));
}

/*************************************************************************
    Function:   MouseProc
    Purpose:    Gets called for mouse eventshit
    Inputs:     void
    Returns:    BOOL - TRUE if successful
    History:
*************************************************************************/
LRESULT CALLBACK MouseProc(int code,	        // hook code
                              WPARAM wParam,    // virtual-key code
                              LPARAM lParam)    // keystroke-message information
{
	CScopeMutex csMutex;
	if (!csMutex.Create(g_szMutexNarrator, c_nMutexWait))
		return 1;   // TODO not sure what to do here; MSDN is unclear about retval

    LRESULT retVal = CallNextHookEx(g_hhookMouse, code, wParam, lParam);

    if (code == HC_ACTION)
    {
		switch (wParam) 
        { // want to know if mouse is down
		    case WM_NCLBUTTONDOWN: 
            case WM_LBUTTONDOWN:
    		case WM_NCRBUTTONDOWN: 
            case WM_RBUTTONDOWN:
                // to keep sighted people happy when using mouse shut up 
                // the speech on mouse down
                // SpeakMute(0); 
                // Chnage to PostMessage works for now: a-anilk
                PostMessage(g_pGlobalData->hwndMSR, WM_MUTE, 0, 0);
                // If it is then don't move mouse pointer when focus set!
			    g_pGlobalData->fMouseUp = FALSE;
			    break;

		    case WM_NCLBUTTONUP: 
            case WM_LBUTTONUP:
            case WM_NCRBUTTONUP:
            case WM_RBUTTONUP:
//			    g_pGlobalData->fMouseUp = TRUE; Don't clear flag here - wait until key pressed before enabling auto mouse movemens again
			    break;
		}
    }

    return(retVal);
}


// --------------------------------------------------------------------------
//
//  Entry point:  DllMain()
//
// Some stuff only needs to be done the first time the DLL is loaded, and the
// last time it is unloaded, which is to set up the values for things in the 
// shared data segment, including SharedMemory support.
//
// InterlockedIncrement() and Decrement() return 1 if the result is 
// positive, 0 if  zero, and -1 if negative.  Therefore, the only
// way to use them practically is to start with a counter at -1.  
// Then incrementing from -1 to 0, the first time, will give you
// a unique value of 0.  And decrementing the last time from 0 to -1
// will give you a unique value of -1.
//
// --------------------------------------------------------------------------
BOOL WINAPI DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID pvReserved)
{
    switch (dwReason) 
	{
		case DLL_PROCESS_ATTACH:
        g_Hinst = hinst;
        // Create the memory mapped file for shared global data
        CreateMappedFile();
		break;

		case DLL_PROCESS_DETACH:
        // Close the memory mapped file for shared global data
        CloseMappedFile();
        break;
    }

    return(TRUE);
}

/*************************************************************************
    Function:   WinEventProc
    Purpose:    Callback function handles events
    Inputs:     HWINEVENTHOOK hEvent - Handle of the instance of the event proc
                DWORD event - Event type constant
                HWND hwndMsg - HWND of window generating event
                LONG idObject - ID of object generating event
                LONG idChild - ID of child generating event (0 if object)
                DWORD idThread - ID of thread generating event
                DWORD dwmsEventTime - Timestamp of event
    Returns: 
    History:    
*************************************************************************/
void CALLBACK WinEventProc(HWINEVENTHOOK hEvent, DWORD event, HWND hwndMsg, 
                           LONG idObject, LONG idChild, DWORD idThread, 
                           DWORD dwmsEventTime)
{
    // NOTE: If any more events are handled by ProcessWinEvent, they must be 
    // added to this switch statement.
	// no longer will we get an IAccessible here - the helper thread will
	// get the info from the Stack and get and use the IAccessible there.

    switch (event)
    {
		case EVENT_OBJECT_STATECHANGE:
		case EVENT_OBJECT_VALUECHANGE:
		case EVENT_OBJECT_SELECTION:
		case EVENT_OBJECT_FOCUS:
		case EVENT_OBJECT_LOCATIONCHANGE:
		case EVENT_SYSTEM_MENUSTART:
		case EVENT_SYSTEM_MENUEND:
		case EVENT_SYSTEM_MENUPOPUPSTART:
		case EVENT_SYSTEM_MENUPOPUPEND:
		case EVENT_SYSTEM_SWITCHSTART:
		case EVENT_SYSTEM_FOREGROUND:
		case EVENT_OBJECT_SHOW:
			AddEventInfoToStack(event, hwndMsg, idObject, idChild, 
								idThread, dwmsEventTime);
			break;
    } // end switch (event)
}


/*************************************************************************
    Function:   
    Purpose:    
    Inputs:     
    Returns: 
    History:    
*************************************************************************/
void ProcessWinEvent(DWORD event, HWND hwndMsg, LONG idObject, LONG 
                     idChild, DWORD idThread,DWORD dwmsEventTime)
{
	TCHAR   szName[256];

	// What type of event is coming through?
	// bring secondary focus here: Get from Object inspector
	// bring mouse pointer here if flag set.
	
	if (g_pGlobalData->nReviewLevel != 2)
	{
		switch (event)
		{
			case EVENT_SYSTEM_SWITCHSTART:
				SpeakMute(0);
				SpeakString(TEXT("ALT TAB"));
				break;

			case EVENT_SYSTEM_MENUSTART:
			    break;

		    case EVENT_SYSTEM_MENUEND:
			    SpeakMute(0);
			    if (g_pGlobalData->fAnnounceMenu)
				    SpeakStringId(IDS_MENUEND);
			    break;
		    
		    case EVENT_SYSTEM_MENUPOPUPSTART:
			    if (g_pGlobalData->fAnnouncePopup)
				{
					SpeakMute(0);
				    SpeakStringId(IDS_POPUP);
				}
			    break;
			    
		    case EVENT_SYSTEM_MENUPOPUPEND:
			    SpeakMute(0);
			    if (g_pGlobalData->fAnnouncePopup)
				    SpeakStringId(IDS_POPUPEND);
			    break;
			    
		    case EVENT_OBJECT_STATECHANGE : 
                DBPRINTF(TEXT("EVENT_OBJECT_STATECHANGE\r\n"));
				// want to catch state changes on spacebar pressed
				switch (g_pGlobalData->fJustHadSpace) 
				{ 
					case 0 : // get out - only do this code if space just been pressed
						break;
					case 1 : 
					case 2 : // ignore the first and second time round!
						g_pGlobalData->fJustHadSpace++;
						break;
					case 3 : // second time around speak the item
						OnFocusChangedEvent(event, hwndMsg, idObject, idChild, dwmsEventTime);
						g_pGlobalData->fJustHadSpace = 0;
						break;
				}
				OnStateChangedEvent(event, hwndMsg, idObject, idChild, dwmsEventTime);
			    break;
			    
			case EVENT_OBJECT_VALUECHANGE : 
				 OnValueChangedEvent(event, hwndMsg, idObject, idChild, dwmsEventTime);
				break;
				    
			case EVENT_OBJECT_SELECTION : 
				if (GetParent(hwndMsg) == g_pGlobalData->hwndMSR) 
				{
					// don't do this for our own or list box throws a wobbler!
					break; 
				}
				
				// this comes in for list items a second time after the focus 
				// changes BUT that gets filtered by the double speak check.
				// What this catches is list item changes when cursor down in 
				// combo boxes!
				// Make it just works for them.
				
				OnSelectChangedEvent(event, hwndMsg, idObject, idChild, dwmsEventTime);
				break;
				
			case EVENT_OBJECT_FOCUS:
                DBPRINTF(TEXT("EVENT_OBJECT_FOCUS\r\n"));
				OnFocusChangedEvent(event, hwndMsg, idObject, idChild, dwmsEventTime);
				break;
				
			case EVENT_SYSTEM_FOREGROUND: // Window comes to front - speak its name!
				SpeakMute(0);
				SpeakStringId(IDS_FOREGROUND);

                TCHAR szClassName[100];
                // if the class name is CLASS_MS_WINNOTE or CLASS_HH_POPUP it's context senceitive help 
                // and the text will be read in OnFocusChangeEvent by SpeakObjectInfo.  So we don't need to
                // read the same text here and in SpeakWindow
            	GetClassName( hwndMsg, szClassName, ARRAYSIZE(szClassName) ); 
                if ( (lstrcmpi(szClassName, CLASS_MS_WINNOTE ) == 0) || (lstrcmpi(szClassName, CLASS_HH_POPUP ) == 0) )
                    break;

				GetWindowText(hwndMsg, szName, sizeof(szName)/sizeof(TCHAR));	// raid #113789
				SpeakString(szName);
				
				if (g_pGlobalData->fAnnounceWindow) 
				{
					g_pGlobalData->nSpeakWindowSoon = TRUE; // read window when next focus set
				}
				
				break;
				
			case EVENT_OBJECT_LOCATIONCHANGE:
				// Only the caret
				if (idObject != OBJID_CARET)
					return;

				OnLocationChangedEvent(event, hwndMsg, idObject, idChild, dwmsEventTime);
                break;

            case EVENT_OBJECT_SHOW:
                OnObjectShowEvent(event, hwndMsg, idObject, idChild, dwmsEventTime);
                break;

		} // end switch (event)
	} // end if review level != 2
	return;
}


/*************************************************************************
    Function:   OnValueChangedEvent
    Purpose:    Receives value events
    Inputs:     DWORD event        - What event are we processing
                HWND  hwnd         - HWND of window generating event
                LONG  idObject     - ID of object generating event
                LONG  idChild      - ID of child generating event (0 if object)
                DWORD idThread     - ID of thread generating event
                DWORD dwmsEventTime - Timestamp of event
    Returns:    BOOL - TRUE if succeeded
*************************************************************************/
BOOL OnValueChangedEvent(DWORD event, HWND hwnd,  LONG idObject, LONG idChild, 
                         DWORD dwmsTimeStamp)
{
    HRESULT         hr;
    OBJINFO         objCurrent;
	VARIANT         varRole;
    IAccessible*    pIAcc;
    VARIANT         varChild;
	TCHAR szName[200];

    hr = AccessibleObjectFromEvent (hwnd, idObject, idChild, &pIAcc, &varChild);
    if (SUCCEEDED(hr))
    {
        objCurrent.hwnd = hwnd;
        objCurrent.plObj = (long*)pIAcc;
	    objCurrent.varChild = varChild;
	    
	    VariantInit(&varRole);

	    hr = pIAcc->get_accRole(varChild, &varRole);

		if( FAILED(hr) || 
		   varRole.lVal != ROLE_SYSTEM_SPINBUTTON &&  g_pGlobalData->nMsrDoNext == MSR_DONOWT)
		{
			pIAcc->Release();
			return(FALSE);
		}

		g_pGlobalData->nMsrDoNext = MSR_DONOWT; // PB 22 Nov 1998 stop this firing more than once (probably)

		if (varRole.vt == VT_I4 && (
			(varRole.lVal == ROLE_SYSTEM_TEXT && g_pGlobalData->nMsrDoNext != MSR_DOLINE) ||
			 varRole.lVal == ROLE_SYSTEM_PUSHBUTTON || 
			 varRole.lVal == ROLE_SYSTEM_SCROLLBAR))
		{
			DBPRINTF (TEXT("Don't Speak <%s>\r\n"), szName);
			// don't speak 'cos it's an edit box (or others) changing value!
		}
		else if (!g_pGlobalData->fInternetExplorer) // don't do this for IE .. it speaks edit box too much.
		{
			DBPRINTF (TEXT("Now Speak!\r\n"));
			SpeakMute(0);
			SpeakObjectInfo(&objCurrent, FALSE);
		}
		else
			DBPRINTF (TEXT("Do nowt!\r\n"));

        pIAcc->Release();
    }

    return(TRUE);
}


/*************************************************************************
    Function:   OnSelectChangedEvent
    Purpose:    Receives selection change events - not from MSR though
    Inputs:     DWORD event    - What event are we processing
                HWND hwnd      - HWND of window generating event
                LONG idObject  - 